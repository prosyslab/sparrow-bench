/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 60 "./include/infiniband/verbs.h"
struct __anonstruct_global_25 {
   uint64_t subnet_prefix ;
   uint64_t interface_id ;
};
#line 60 "./include/infiniband/verbs.h"
union ibv_gid {
   uint8_t raw[16] ;
   struct __anonstruct_global_25 global ;
};
#line 167
enum ibv_mtu {
    IBV_MTU_256 = 1,
    IBV_MTU_512 = 2,
    IBV_MTU_1024 = 3,
    IBV_MTU_2048 = 4,
    IBV_MTU_4096 = 5
} ;
#line 349 "./include/infiniband/verbs.h"
struct ibv_global_route {
   union ibv_gid dgid ;
   uint32_t flow_label ;
   uint8_t sgid_index ;
   uint8_t hop_limit ;
   uint8_t traffic_class ;
};
#line 414 "./include/infiniband/verbs.h"
struct ibv_ah_attr {
   struct ibv_global_route grh ;
   uint16_t dlid ;
   uint8_t sl ;
   uint8_t src_path_bits ;
   uint8_t static_rate ;
   uint8_t is_global ;
   uint8_t port_num ;
};
#line 447 "./include/infiniband/verbs.h"
struct ibv_qp_cap {
   uint32_t max_send_wr ;
   uint32_t max_recv_wr ;
   uint32_t max_send_sge ;
   uint32_t max_recv_sge ;
   uint32_t max_inline_data ;
};
#line 489
enum ibv_qp_state {
    IBV_QPS_RESET = 0,
    IBV_QPS_INIT = 1,
    IBV_QPS_RTR = 2,
    IBV_QPS_RTS = 3,
    IBV_QPS_SQD = 4,
    IBV_QPS_SQE = 5,
    IBV_QPS_ERR = 6
} ;
#line 499
enum ibv_mig_state {
    IBV_MIG_MIGRATED = 0,
    IBV_MIG_REARM = 1,
    IBV_MIG_ARMED = 2
} ;
#line 505 "./include/infiniband/verbs.h"
struct ibv_qp_attr {
   enum ibv_qp_state qp_state ;
   enum ibv_qp_state cur_qp_state ;
   enum ibv_mtu path_mtu ;
   enum ibv_mig_state path_mig_state ;
   uint32_t qkey ;
   uint32_t rq_psn ;
   uint32_t sq_psn ;
   uint32_t dest_qp_num ;
   int qp_access_flags ;
   struct ibv_qp_cap cap ;
   struct ibv_ah_attr ah_attr ;
   struct ibv_ah_attr alt_ah_attr ;
   uint16_t pkey_index ;
   uint16_t alt_pkey_index ;
   uint8_t en_sqd_async_notify ;
   uint8_t sq_draining ;
   uint8_t max_rd_atomic ;
   uint8_t max_dest_rd_atomic ;
   uint8_t min_rnr_timer ;
   uint8_t port_num ;
   uint8_t timeout ;
   uint8_t retry_cnt ;
   uint8_t rnr_retry ;
   uint8_t alt_port_num ;
   uint8_t alt_timeout ;
};
#line 39 "./include/infiniband/sa.h"
struct ibv_sa_path_rec {
   union ibv_gid dgid ;
   union ibv_gid sgid ;
   uint16_t dlid ;
   uint16_t slid ;
   int raw_traffic ;
   uint32_t flow_label ;
   uint8_t hop_limit ;
   uint8_t traffic_class ;
   int reversible ;
   uint8_t numb_path ;
   uint16_t pkey ;
   uint8_t sl ;
   uint8_t mtu_selector ;
   uint8_t mtu ;
   uint8_t rate_selector ;
   uint8_t rate ;
   uint8_t packet_life_time_selector ;
   uint8_t packet_life_time ;
   uint8_t preference ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 418 "./include/infiniband/kern-abi.h"
struct ibv_kern_global_route {
   __u8 dgid[16] ;
   __u32 flow_label ;
   __u8 sgid_index ;
   __u8 hop_limit ;
   __u8 traffic_class ;
   __u8 reserved ;
};
#line 427 "./include/infiniband/kern-abi.h"
struct ibv_kern_ah_attr {
   struct ibv_kern_global_route grh ;
   __u16 dlid ;
   __u8 sl ;
   __u8 src_path_bits ;
   __u8 static_rate ;
   __u8 is_global ;
   __u8 port_num ;
   __u8 reserved ;
};
#line 438 "./include/infiniband/kern-abi.h"
struct ibv_kern_qp_attr {
   __u32 qp_attr_mask ;
   __u32 qp_state ;
   __u32 cur_qp_state ;
   __u32 path_mtu ;
   __u32 path_mig_state ;
   __u32 qkey ;
   __u32 rq_psn ;
   __u32 sq_psn ;
   __u32 dest_qp_num ;
   __u32 qp_access_flags ;
   struct ibv_kern_ah_attr ah_attr ;
   struct ibv_kern_ah_attr alt_ah_attr ;
   __u32 max_send_wr ;
   __u32 max_recv_wr ;
   __u32 max_send_sge ;
   __u32 max_recv_sge ;
   __u32 max_inline_data ;
   __u16 pkey_index ;
   __u16 alt_pkey_index ;
   __u8 en_sqd_async_notify ;
   __u8 sq_draining ;
   __u8 max_rd_atomic ;
   __u8 max_dest_rd_atomic ;
   __u8 min_rnr_timer ;
   __u8 port_num ;
   __u8 timeout ;
   __u8 retry_cnt ;
   __u8 rnr_retry ;
   __u8 alt_port_num ;
   __u8 alt_timeout ;
   __u8 reserved[5] ;
};
#line 43 "./include/infiniband/sa-kern-abi.h"
struct ibv_kern_path_rec {
   __u8 dgid[16] ;
   __u8 sgid[16] ;
   __u16 dlid ;
   __u16 slid ;
   __u32 raw_traffic ;
   __u32 flow_label ;
   __u32 reversible ;
   __u32 mtu ;
   __u16 pkey ;
   __u8 hop_limit ;
   __u8 traffic_class ;
   __u8 numb_path ;
   __u8 sl ;
   __u8 mtu_selector ;
   __u8 rate_selector ;
   __u8 rate ;
   __u8 packet_life_time_selector ;
   __u8 packet_life_time ;
   __u8 preference ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 122 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_9 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_9 pthread_mutex_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_10 {
   char __size[4] ;
   int __align ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_10 pthread_mutexattr_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __anonstruct___data_12 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_11 {
   struct __anonstruct___data_12 __data ;
   char __size[48] ;
   long long __align ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_11 pthread_cond_t;
#line 155 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_condattr_t_13 {
   char __size[4] ;
   int __align ;
};
#line 155 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_condattr_t_13 pthread_condattr_t;
#line 84 "./include/infiniband/verbs.h"
enum ibv_node_type {
    IBV_NODE_UNKNOWN = -1,
    IBV_NODE_CA = 1,
    IBV_NODE_SWITCH = 2,
    IBV_NODE_ROUTER = 3,
    IBV_NODE_RNIC = 4
} ;
#line 92
enum ibv_transport_type {
    IBV_TRANSPORT_UNKNOWN = -1,
    IBV_TRANSPORT_IB = 0,
    IBV_TRANSPORT_IWARP = 1
} ;
#line 118
enum ibv_atomic_cap {
    IBV_ATOMIC_NONE = 0,
    IBV_ATOMIC_HCA = 1,
    IBV_ATOMIC_GLOB = 2
} ;
#line 124 "./include/infiniband/verbs.h"
struct ibv_device_attr {
   char fw_ver[64] ;
   uint64_t node_guid ;
   uint64_t sys_image_guid ;
   uint64_t max_mr_size ;
   uint64_t page_size_cap ;
   uint32_t vendor_id ;
   uint32_t vendor_part_id ;
   uint32_t hw_ver ;
   int max_qp ;
   int max_qp_wr ;
   int device_cap_flags ;
   int max_sge ;
   int max_sge_rd ;
   int max_cq ;
   int max_cqe ;
   int max_mr ;
   int max_pd ;
   int max_qp_rd_atom ;
   int max_ee_rd_atom ;
   int max_res_rd_atom ;
   int max_qp_init_rd_atom ;
   int max_ee_init_rd_atom ;
   enum ibv_atomic_cap atomic_cap ;
   int max_ee ;
   int max_rdd ;
   int max_mw ;
   int max_raw_ipv6_qp ;
   int max_raw_ethy_qp ;
   int max_mcast_grp ;
   int max_mcast_qp_attach ;
   int max_total_mcast_qp_attach ;
   int max_ah ;
   int max_fmr ;
   int max_map_per_fmr ;
   int max_srq ;
   int max_srq_wr ;
   int max_srq_sge ;
   uint16_t max_pkeys ;
   uint8_t local_ca_ack_delay ;
   uint8_t phys_port_cnt ;
};
#line 175
enum ibv_port_state {
    IBV_PORT_NOP = 0,
    IBV_PORT_DOWN = 1,
    IBV_PORT_INIT = 2,
    IBV_PORT_ARMED = 3,
    IBV_PORT_ACTIVE = 4,
    IBV_PORT_ACTIVE_DEFER = 5
} ;
#line 190 "./include/infiniband/verbs.h"
struct ibv_port_attr {
   enum ibv_port_state state ;
   enum ibv_mtu max_mtu ;
   enum ibv_mtu active_mtu ;
   int gid_tbl_len ;
   uint32_t port_cap_flags ;
   uint32_t max_msg_sz ;
   uint32_t bad_pkey_cntr ;
   uint32_t qkey_viol_cntr ;
   uint16_t pkey_tbl_len ;
   uint16_t lid ;
   uint16_t sm_lid ;
   uint8_t lmc ;
   uint8_t max_vl_num ;
   uint8_t sm_sl ;
   uint8_t subnet_timeout ;
   uint8_t init_type_reply ;
   uint8_t active_width ;
   uint8_t active_speed ;
   uint8_t phys_state ;
   uint8_t link_layer ;
   uint8_t reserved ;
};
#line 214
enum ibv_event_type {
    IBV_EVENT_CQ_ERR = 0,
    IBV_EVENT_QP_FATAL = 1,
    IBV_EVENT_QP_REQ_ERR = 2,
    IBV_EVENT_QP_ACCESS_ERR = 3,
    IBV_EVENT_COMM_EST = 4,
    IBV_EVENT_SQ_DRAINED = 5,
    IBV_EVENT_PATH_MIG = 6,
    IBV_EVENT_PATH_MIG_ERR = 7,
    IBV_EVENT_DEVICE_FATAL = 8,
    IBV_EVENT_PORT_ACTIVE = 9,
    IBV_EVENT_PORT_ERR = 10,
    IBV_EVENT_LID_CHANGE = 11,
    IBV_EVENT_PKEY_CHANGE = 12,
    IBV_EVENT_SM_CHANGE = 13,
    IBV_EVENT_SRQ_ERR = 14,
    IBV_EVENT_SRQ_LIMIT_REACHED = 15,
    IBV_EVENT_QP_LAST_WQE_REACHED = 16,
    IBV_EVENT_CLIENT_REREGISTER = 17,
    IBV_EVENT_GID_CHANGE = 18
} ;
#line 236
struct ibv_cq;
#line 236
struct ibv_qp;
#line 236
struct ibv_srq;
#line 236 "./include/infiniband/verbs.h"
union __anonunion_element_53 {
   struct ibv_cq *cq ;
   struct ibv_qp *qp ;
   struct ibv_srq *srq ;
   int port_num ;
};
#line 236 "./include/infiniband/verbs.h"
struct ibv_async_event {
   union __anonunion_element_53 element ;
   enum ibv_event_type event_type ;
};
#line 246
enum ibv_wc_status {
    IBV_WC_SUCCESS = 0,
    IBV_WC_LOC_LEN_ERR = 1,
    IBV_WC_LOC_QP_OP_ERR = 2,
    IBV_WC_LOC_EEC_OP_ERR = 3,
    IBV_WC_LOC_PROT_ERR = 4,
    IBV_WC_WR_FLUSH_ERR = 5,
    IBV_WC_MW_BIND_ERR = 6,
    IBV_WC_BAD_RESP_ERR = 7,
    IBV_WC_LOC_ACCESS_ERR = 8,
    IBV_WC_REM_INV_REQ_ERR = 9,
    IBV_WC_REM_ACCESS_ERR = 10,
    IBV_WC_REM_OP_ERR = 11,
    IBV_WC_RETRY_EXC_ERR = 12,
    IBV_WC_RNR_RETRY_EXC_ERR = 13,
    IBV_WC_LOC_RDD_VIOL_ERR = 14,
    IBV_WC_REM_INV_RD_REQ_ERR = 15,
    IBV_WC_REM_ABORT_ERR = 16,
    IBV_WC_INV_EECN_ERR = 17,
    IBV_WC_INV_EEC_STATE_ERR = 18,
    IBV_WC_FATAL_ERR = 19,
    IBV_WC_RESP_TIMEOUT_ERR = 20,
    IBV_WC_GENERAL_ERR = 21
} ;
#line 272
enum ibv_wc_opcode {
    IBV_WC_SEND = 0,
    IBV_WC_RDMA_WRITE = 1,
    IBV_WC_RDMA_READ = 2,
    IBV_WC_COMP_SWAP = 3,
    IBV_WC_FETCH_ADD = 4,
    IBV_WC_BIND_MW = 5,
    IBV_WC_RECV = 128,
    IBV_WC_RECV_RDMA_WITH_IMM = 129
} ;
#line 292 "./include/infiniband/verbs.h"
struct ibv_wc {
   uint64_t wr_id ;
   enum ibv_wc_status status ;
   enum ibv_wc_opcode opcode ;
   uint32_t vendor_err ;
   uint32_t byte_len ;
   uint32_t imm_data ;
   uint32_t qp_num ;
   uint32_t src_qp ;
   int wc_flags ;
   uint16_t pkey_index ;
   uint16_t slid ;
   uint8_t sl ;
   uint8_t dlid_path_bits ;
};
#line 316
struct ibv_context;
#line 316 "./include/infiniband/verbs.h"
struct ibv_pd {
   struct ibv_context *context ;
   uint32_t handle ;
};
#line 328 "./include/infiniband/verbs.h"
struct ibv_mr {
   struct ibv_context *context ;
   struct ibv_pd *pd ;
   void *addr ;
   size_t length ;
   uint32_t handle ;
   uint32_t lkey ;
   uint32_t rkey ;
};
#line 338
enum ibv_mw_type {
    IBV_MW_TYPE_1 = 1,
    IBV_MW_TYPE_2 = 2
} ;
#line 343 "./include/infiniband/verbs.h"
struct ibv_mw {
   struct ibv_context *context ;
   struct ibv_pd *pd ;
   uint32_t rkey ;
};
#line 357 "./include/infiniband/verbs.h"
struct ibv_grh {
   uint32_t version_tclass_flow ;
   uint16_t paylen ;
   uint8_t next_hdr ;
   uint8_t hop_limit ;
   union ibv_gid sgid ;
   union ibv_gid dgid ;
};
#line 366
enum ibv_rate {
    IBV_RATE_MAX = 0,
    IBV_RATE_2_5_GBPS = 2,
    IBV_RATE_5_GBPS = 5,
    IBV_RATE_10_GBPS = 3,
    IBV_RATE_20_GBPS = 6,
    IBV_RATE_30_GBPS = 4,
    IBV_RATE_40_GBPS = 7,
    IBV_RATE_60_GBPS = 8,
    IBV_RATE_80_GBPS = 9,
    IBV_RATE_120_GBPS = 10,
    IBV_RATE_14_GBPS = 11,
    IBV_RATE_56_GBPS = 12,
    IBV_RATE_112_GBPS = 13,
    IBV_RATE_168_GBPS = 14,
    IBV_RATE_25_GBPS = 15,
    IBV_RATE_100_GBPS = 16,
    IBV_RATE_200_GBPS = 17,
    IBV_RATE_300_GBPS = 18
} ;
#line 429 "./include/infiniband/verbs.h"
struct ibv_srq_attr {
   uint32_t max_wr ;
   uint32_t max_sge ;
   uint32_t srq_limit ;
};
#line 435 "./include/infiniband/verbs.h"
struct ibv_srq_init_attr {
   void *srq_context ;
   struct ibv_srq_attr attr ;
};
#line 440
enum ibv_qp_type {
    IBV_QPT_RC = 2,
    IBV_QPT_UC = 3,
    IBV_QPT_UD = 4,
    IBV_QPT_RAW_PACKET = 8
} ;
#line 455 "./include/infiniband/verbs.h"
struct ibv_qp_init_attr {
   void *qp_context ;
   struct ibv_cq *send_cq ;
   struct ibv_cq *recv_cq ;
   struct ibv_srq *srq ;
   struct ibv_qp_cap cap ;
   enum ibv_qp_type qp_type ;
   int sq_sig_all ;
};
#line 533
enum ibv_wr_opcode {
    IBV_WR_RDMA_WRITE = 0,
    IBV_WR_RDMA_WRITE_WITH_IMM = 1,
    IBV_WR_SEND = 2,
    IBV_WR_SEND_WITH_IMM = 3,
    IBV_WR_RDMA_READ = 4,
    IBV_WR_ATOMIC_CMP_AND_SWP = 5,
    IBV_WR_ATOMIC_FETCH_AND_ADD = 6
} ;
#line 551 "./include/infiniband/verbs.h"
struct ibv_sge {
   uint64_t addr ;
   uint32_t length ;
   uint32_t lkey ;
};
#line 557 "./include/infiniband/verbs.h"
struct __anonstruct_rdma_55 {
   uint64_t remote_addr ;
   uint32_t rkey ;
};
#line 557 "./include/infiniband/verbs.h"
struct __anonstruct_atomic_56 {
   uint64_t remote_addr ;
   uint64_t compare_add ;
   uint64_t swap ;
   uint32_t rkey ;
};
#line 557
struct ibv_ah;
#line 557 "./include/infiniband/verbs.h"
struct __anonstruct_ud_57 {
   struct ibv_ah *ah ;
   uint32_t remote_qpn ;
   uint32_t remote_qkey ;
};
#line 557 "./include/infiniband/verbs.h"
union __anonunion_wr_54 {
   struct __anonstruct_rdma_55 rdma ;
   struct __anonstruct_atomic_56 atomic ;
   struct __anonstruct_ud_57 ud ;
};
#line 557 "./include/infiniband/verbs.h"
struct ibv_send_wr {
   uint64_t wr_id ;
   struct ibv_send_wr *next ;
   struct ibv_sge *sg_list ;
   int num_sge ;
   enum ibv_wr_opcode opcode ;
   int send_flags ;
   uint32_t imm_data ;
   union __anonunion_wr_54 wr ;
};
#line 584 "./include/infiniband/verbs.h"
struct ibv_recv_wr {
   uint64_t wr_id ;
   struct ibv_recv_wr *next ;
   struct ibv_sge *sg_list ;
   int num_sge ;
};
#line 591 "./include/infiniband/verbs.h"
struct ibv_mw_bind {
   uint64_t wr_id ;
   struct ibv_mr *mr ;
   void *addr ;
   size_t length ;
   int send_flags ;
   int mw_access_flags ;
};
#line 600 "./include/infiniband/verbs.h"
struct ibv_srq {
   struct ibv_context *context ;
   void *srq_context ;
   struct ibv_pd *pd ;
   uint32_t handle ;
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   uint32_t events_completed ;
};
#line 611 "./include/infiniband/verbs.h"
struct ibv_qp {
   struct ibv_context *context ;
   void *qp_context ;
   struct ibv_pd *pd ;
   struct ibv_cq *send_cq ;
   struct ibv_cq *recv_cq ;
   struct ibv_srq *srq ;
   uint32_t handle ;
   uint32_t qp_num ;
   enum ibv_qp_state state ;
   enum ibv_qp_type qp_type ;
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   uint32_t events_completed ;
};
#line 628 "./include/infiniband/verbs.h"
struct ibv_comp_channel {
   struct ibv_context *context ;
   int fd ;
   int refcnt ;
};
#line 634 "./include/infiniband/verbs.h"
struct ibv_cq {
   struct ibv_context *context ;
   struct ibv_comp_channel *channel ;
   void *cq_context ;
   uint32_t handle ;
   int cqe ;
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   uint32_t comp_events_completed ;
   uint32_t async_events_completed ;
};
#line 647 "./include/infiniband/verbs.h"
struct ibv_ah {
   struct ibv_context *context ;
   struct ibv_pd *pd ;
   uint32_t handle ;
};
#line 750
struct ibv_device;
#line 753 "./include/infiniband/verbs.h"
struct ibv_device_ops {
   struct ibv_context *(*alloc_context)(struct ibv_device *device , int cmd_fd ) ;
   void (*free_context)(struct ibv_context *context ) ;
};
#line 763 "./include/infiniband/verbs.h"
struct ibv_device {
   struct ibv_device_ops ops ;
   enum ibv_node_type node_type ;
   enum ibv_transport_type transport_type ;
   char name[64] ;
   char dev_name[64] ;
   char dev_path[256] ;
   char ibdev_path[256] ;
};
#line 788 "./include/infiniband/verbs.h"
struct ibv_context_ops {
   int (*query_device)(struct ibv_context *context , struct ibv_device_attr *device_attr ) ;
   int (*query_port)(struct ibv_context *context , uint8_t port_num , struct ibv_port_attr *port_attr ) ;
   struct ibv_pd *(*alloc_pd)(struct ibv_context *context ) ;
   int (*dealloc_pd)(struct ibv_pd *pd ) ;
   struct ibv_mr *(*reg_mr)(struct ibv_pd *pd , void *addr , size_t length , int access ) ;
   struct ibv_mr *(*rereg_mr)(struct ibv_mr *mr , int flags , struct ibv_pd *pd ,
                              void *addr , size_t length , int access ) ;
   int (*dereg_mr)(struct ibv_mr *mr ) ;
   struct ibv_mw *(*alloc_mw)(struct ibv_pd *pd , enum ibv_mw_type type ) ;
   int (*bind_mw)(struct ibv_qp *qp , struct ibv_mw *mw , struct ibv_mw_bind *mw_bind ) ;
   int (*dealloc_mw)(struct ibv_mw *mw ) ;
   struct ibv_cq *(*create_cq)(struct ibv_context *context , int cqe , struct ibv_comp_channel *channel ,
                               int comp_vector ) ;
   int (*poll_cq)(struct ibv_cq *cq , int num_entries , struct ibv_wc *wc ) ;
   int (*req_notify_cq)(struct ibv_cq *cq , int solicited_only ) ;
   void (*cq_event)(struct ibv_cq *cq ) ;
   int (*resize_cq)(struct ibv_cq *cq , int cqe ) ;
   int (*destroy_cq)(struct ibv_cq *cq ) ;
   struct ibv_srq *(*create_srq)(struct ibv_pd *pd , struct ibv_srq_init_attr *srq_init_attr ) ;
   int (*modify_srq)(struct ibv_srq *srq , struct ibv_srq_attr *srq_attr , int srq_attr_mask ) ;
   int (*query_srq)(struct ibv_srq *srq , struct ibv_srq_attr *srq_attr ) ;
   int (*destroy_srq)(struct ibv_srq *srq ) ;
   int (*post_srq_recv)(struct ibv_srq *srq , struct ibv_recv_wr *recv_wr , struct ibv_recv_wr **bad_recv_wr ) ;
   struct ibv_qp *(*create_qp)(struct ibv_pd *pd , struct ibv_qp_init_attr *attr ) ;
   int (*query_qp)(struct ibv_qp *qp , struct ibv_qp_attr *attr , int attr_mask ,
                   struct ibv_qp_init_attr *init_attr ) ;
   int (*modify_qp)(struct ibv_qp *qp , struct ibv_qp_attr *attr , int attr_mask ) ;
   int (*destroy_qp)(struct ibv_qp *qp ) ;
   int (*post_send)(struct ibv_qp *qp , struct ibv_send_wr *wr , struct ibv_send_wr **bad_wr ) ;
   int (*post_recv)(struct ibv_qp *qp , struct ibv_recv_wr *wr , struct ibv_recv_wr **bad_wr ) ;
   struct ibv_ah *(*create_ah)(struct ibv_pd *pd , struct ibv_ah_attr *attr ) ;
   int (*destroy_ah)(struct ibv_ah *ah ) ;
   int (*attach_mcast)(struct ibv_qp *qp , union ibv_gid  const  *gid , uint16_t lid ) ;
   int (*detach_mcast)(struct ibv_qp *qp , union ibv_gid  const  *gid , uint16_t lid ) ;
   void (*async_event)(struct ibv_async_event *event ) ;
};
#line 846 "./include/infiniband/verbs.h"
struct ibv_context {
   struct ibv_device *device ;
   struct ibv_context_ops ops ;
   int cmd_fd ;
   int async_fd ;
   int num_comp_vectors ;
   pthread_mutex_t mutex ;
   void *abi_compat ;
};
#line 30 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 151 "./include/infiniband/kern-abi.h"
struct ibv_comp_event {
   __u64 cq_handle ;
};
#line 318 "./include/infiniband/kern-abi.h"
struct ibv_create_comp_channel {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u64 response ;
};
#line 325 "./include/infiniband/kern-abi.h"
struct ibv_create_comp_channel_resp {
   __u32 fd ;
};
#line 75 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/ibverbs.h"
struct ibv_abi_compat_v2 {
   struct ibv_comp_channel channel ;
   pthread_mutex_t in_use ;
};
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 657 "./include/infiniband/verbs.h"
enum ibv_flow_attr_type {
    IBV_FLOW_ATTR_NORMAL = 0,
    IBV_FLOW_ATTR_ALL_DEFAULT = 1,
    IBV_FLOW_ATTR_MC_DEFAULT = 2
} ;
#line 730 "./include/infiniband/verbs.h"
struct ibv_flow_attr {
   uint32_t comp_mask ;
   enum ibv_flow_attr_type type ;
   uint16_t size ;
   uint16_t priority ;
   uint8_t num_of_specs ;
   uint8_t port ;
   uint32_t flags ;
};
#line 744 "./include/infiniband/verbs.h"
struct ibv_flow {
   uint32_t comp_mask ;
   struct ibv_context *context ;
   uint32_t handle ;
};
#line 777 "./include/infiniband/verbs.h"
struct verbs_device {
   struct ibv_device device ;
   size_t sz ;
   size_t size_of_context ;
   int (*init_context)(struct verbs_device *device , struct ibv_context *ctx , int cmd_fd ) ;
   void (*uninit_context)(struct verbs_device *device , struct ibv_context *ctx ) ;
};
#line 862 "./include/infiniband/verbs.h"
struct verbs_context {
   int (*drv_ibv_destroy_flow)(struct ibv_flow *flow ) ;
   int (*lib_ibv_destroy_flow)(struct ibv_flow *flow ) ;
   struct ibv_flow *(*drv_ibv_create_flow)(struct ibv_qp *qp , struct ibv_flow_attr *flow_attr ) ;
   struct ibv_flow *(*lib_ibv_create_flow)(struct ibv_qp *qp , struct ibv_flow_attr *flow_attr ) ;
   uint64_t has_comp_mask ;
   size_t sz ;
   struct ibv_context context ;
};
#line 145 "./include/infiniband/kern-abi.h"
struct ibv_kern_async_event {
   __u64 element ;
   __u32 event_type ;
   __u32 reserved ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 260 "/usr/include/unistd.h"
typedef __pid_t pid_t;
#line 62 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
enum __anonenum_color_68 {
    IBV_RED = 0,
    IBV_BLACK = 1
} ;
#line 62 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
struct ibv_mem_node {
   enum __anonenum_color_68 color ;
   struct ibv_mem_node *parent ;
   struct ibv_mem_node *left ;
   struct ibv_mem_node *right ;
   uintptr_t start ;
   uintptr_t end ;
   int refcnt ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 59 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/rc_pingpong.c"
struct pingpong_context {
   struct ibv_context *context ;
   struct ibv_comp_channel *channel ;
   struct ibv_pd *pd ;
   struct ibv_mr *mr ;
   struct ibv_cq *cq ;
   struct ibv_qp *qp ;
   void *buf ;
   int size ;
   int rx_depth ;
   int pending ;
   struct ibv_port_attr portinfo ;
};
#line 73 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/rc_pingpong.c"
struct pingpong_dest {
   int lid ;
   int qpn ;
   int psn ;
   union ibv_gid gid ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 80 "/usr/include/glob.h"
struct stat;
#line 82
struct dirent;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 38 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef enum __rlimit_resource __rlimit_resource_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 55 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
struct ibv_sysfs_dev {
   char sysfs_name[64] ;
   char ibdev_name[64] ;
   char sysfs_path[256] ;
   char ibdev_path[256] ;
   struct ibv_sysfs_dev *next ;
   int abi_ver ;
   int have_driver ;
};
#line 65 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
struct ibv_driver_name {
   char *name ;
   struct ibv_driver_name *next ;
};
#line 70 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
struct ibv_driver {
   char const   *name ;
   struct ibv_device *(*init_func)(char const   *uverbs_sys_path , int abi_version ) ;
   struct verbs_device *(*verbs_init_func)(char const   *uverbs_sys_path , int abi_version ) ;
   struct ibv_driver *next ;
};
#line 670 "./include/infiniband/verbs.h"
enum ibv_flow_spec_type {
    IBV_FLOW_SPEC_ETH = 32,
    IBV_FLOW_SPEC_IPV4 = 48,
    IBV_FLOW_SPEC_TCP = 64,
    IBV_FLOW_SPEC_UDP = 65
} ;
#line 677 "./include/infiniband/verbs.h"
struct ibv_flow_eth_filter {
   uint8_t dst_mac[6] ;
   uint8_t src_mac[6] ;
   uint16_t ether_type ;
   uint16_t vlan_tag ;
};
#line 687 "./include/infiniband/verbs.h"
struct ibv_flow_spec_eth {
   enum ibv_flow_spec_type type ;
   uint16_t size ;
   struct ibv_flow_eth_filter val ;
   struct ibv_flow_eth_filter mask ;
};
#line 694 "./include/infiniband/verbs.h"
struct ibv_flow_ipv4_filter {
   uint32_t src_ip ;
   uint32_t dst_ip ;
};
#line 699 "./include/infiniband/verbs.h"
struct ibv_flow_spec_ipv4 {
   enum ibv_flow_spec_type type ;
   uint16_t size ;
   struct ibv_flow_ipv4_filter val ;
   struct ibv_flow_ipv4_filter mask ;
};
#line 706 "./include/infiniband/verbs.h"
struct ibv_flow_tcp_udp_filter {
   uint16_t dst_port ;
   uint16_t src_port ;
};
#line 711 "./include/infiniband/verbs.h"
struct ibv_flow_spec_tcp_udp {
   enum ibv_flow_spec_type type ;
   uint16_t size ;
   struct ibv_flow_tcp_udp_filter val ;
   struct ibv_flow_tcp_udp_filter mask ;
};
#line 718 "./include/infiniband/verbs.h"
struct __anonstruct_hdr_50 {
   enum ibv_flow_spec_type type ;
   uint16_t size ;
};
#line 718 "./include/infiniband/verbs.h"
union __anonunion____missing_field_name_49 {
   struct __anonstruct_hdr_50 hdr ;
   struct ibv_flow_spec_eth eth ;
   struct ibv_flow_spec_ipv4 ipv4 ;
   struct ibv_flow_spec_tcp_udp tcp_udp ;
};
#line 718 "./include/infiniband/verbs.h"
struct ibv_flow_spec {
   union __anonunion____missing_field_name_49 __annonCompField1 ;
};
#line 25 "/usr/include/asm-generic/int-ll64.h"
typedef int __s32;
#line 129 "./include/infiniband/kern-abi.h"
struct __anonstruct____missing_field_name_56 {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
};
#line 129 "./include/infiniband/kern-abi.h"
struct __anonstruct____missing_field_name_57 {
   __u64 response ;
};
#line 129 "./include/infiniband/kern-abi.h"
struct __anonstruct____missing_field_name_58 {
   __u16 provider_in_words ;
   __u16 provider_out_words ;
   __u32 reserved ;
};
#line 129 "./include/infiniband/kern-abi.h"
struct ex_hdr {
   struct __anonstruct____missing_field_name_56 __annonCompField2 ;
   struct __anonstruct____missing_field_name_57 __annonCompField3 ;
   struct __anonstruct____missing_field_name_58 __annonCompField4 ;
};
#line 174 "./include/infiniband/kern-abi.h"
struct ibv_get_context {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u64 response ;
   __u64 driver_data[0] ;
};
#line 182 "./include/infiniband/kern-abi.h"
struct ibv_get_context_resp {
   __u32 async_fd ;
   __u32 num_comp_vectors ;
};
#line 187 "./include/infiniband/kern-abi.h"
struct ibv_query_device {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u64 response ;
   __u64 driver_data[0] ;
};
#line 195 "./include/infiniband/kern-abi.h"
struct ibv_query_device_resp {
   __u64 fw_ver ;
   __u64 node_guid ;
   __u64 sys_image_guid ;
   __u64 max_mr_size ;
   __u64 page_size_cap ;
   __u32 vendor_id ;
   __u32 vendor_part_id ;
   __u32 hw_ver ;
   __u32 max_qp ;
   __u32 max_qp_wr ;
   __u32 device_cap_flags ;
   __u32 max_sge ;
   __u32 max_sge_rd ;
   __u32 max_cq ;
   __u32 max_cqe ;
   __u32 max_mr ;
   __u32 max_pd ;
   __u32 max_qp_rd_atom ;
   __u32 max_ee_rd_atom ;
   __u32 max_res_rd_atom ;
   __u32 max_qp_init_rd_atom ;
   __u32 max_ee_init_rd_atom ;
   __u32 atomic_cap ;
   __u32 max_ee ;
   __u32 max_rdd ;
   __u32 max_mw ;
   __u32 max_raw_ipv6_qp ;
   __u32 max_raw_ethy_qp ;
   __u32 max_mcast_grp ;
   __u32 max_mcast_qp_attach ;
   __u32 max_total_mcast_qp_attach ;
   __u32 max_ah ;
   __u32 max_fmr ;
   __u32 max_map_per_fmr ;
   __u32 max_srq ;
   __u32 max_srq_wr ;
   __u32 max_srq_sge ;
   __u16 max_pkeys ;
   __u8 local_ca_ack_delay ;
   __u8 phys_port_cnt ;
   __u8 reserved[4] ;
};
#line 239 "./include/infiniband/kern-abi.h"
struct ibv_query_port {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u64 response ;
   __u8 port_num ;
   __u8 reserved[7] ;
   __u64 driver_data[0] ;
};
#line 249 "./include/infiniband/kern-abi.h"
struct ibv_query_port_resp {
   __u32 port_cap_flags ;
   __u32 max_msg_sz ;
   __u32 bad_pkey_cntr ;
   __u32 qkey_viol_cntr ;
   __u32 gid_tbl_len ;
   __u16 pkey_tbl_len ;
   __u16 lid ;
   __u16 sm_lid ;
   __u8 state ;
   __u8 max_mtu ;
   __u8 active_mtu ;
   __u8 lmc ;
   __u8 max_vl_num ;
   __u8 sm_sl ;
   __u8 subnet_timeout ;
   __u8 init_type_reply ;
   __u8 active_width ;
   __u8 active_speed ;
   __u8 phys_state ;
   __u8 link_layer ;
   __u8 reserved[2] ;
};
#line 273 "./include/infiniband/kern-abi.h"
struct ibv_alloc_pd {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u64 response ;
   __u64 driver_data[0] ;
};
#line 281 "./include/infiniband/kern-abi.h"
struct ibv_alloc_pd_resp {
   __u32 pd_handle ;
};
#line 285 "./include/infiniband/kern-abi.h"
struct ibv_dealloc_pd {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u32 pd_handle ;
};
#line 292 "./include/infiniband/kern-abi.h"
struct ibv_reg_mr {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u64 response ;
   __u64 start ;
   __u64 length ;
   __u64 hca_va ;
   __u32 pd_handle ;
   __u32 access_flags ;
   __u64 driver_data[0] ;
};
#line 305 "./include/infiniband/kern-abi.h"
struct ibv_reg_mr_resp {
   __u32 mr_handle ;
   __u32 lkey ;
   __u32 rkey ;
};
#line 311 "./include/infiniband/kern-abi.h"
struct ibv_dereg_mr {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u32 mr_handle ;
};
#line 329 "./include/infiniband/kern-abi.h"
struct ibv_create_cq {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u64 response ;
   __u64 user_handle ;
   __u32 cqe ;
   __u32 comp_vector ;
   __s32 comp_channel ;
   __u32 reserved ;
   __u64 driver_data[0] ;
};
#line 342 "./include/infiniband/kern-abi.h"
struct ibv_create_cq_resp {
   __u32 cq_handle ;
   __u32 cqe ;
};
#line 347 "./include/infiniband/kern-abi.h"
struct ibv_kern_wc {
   __u64 wr_id ;
   __u32 status ;
   __u32 opcode ;
   __u32 vendor_err ;
   __u32 byte_len ;
   __u32 imm_data ;
   __u32 qp_num ;
   __u32 src_qp ;
   __u32 wc_flags ;
   __u16 pkey_index ;
   __u16 slid ;
   __u8 sl ;
   __u8 dlid_path_bits ;
   __u8 port_num ;
   __u8 reserved ;
};
#line 365 "./include/infiniband/kern-abi.h"
struct ibv_poll_cq {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u64 response ;
   __u32 cq_handle ;
   __u32 ne ;
};
#line 374 "./include/infiniband/kern-abi.h"
struct ibv_poll_cq_resp {
   __u32 count ;
   __u32 reserved ;
   struct ibv_kern_wc wc[0] ;
};
#line 380 "./include/infiniband/kern-abi.h"
struct ibv_req_notify_cq {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u32 cq_handle ;
   __u32 solicited ;
};
#line 388 "./include/infiniband/kern-abi.h"
struct ibv_resize_cq {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u64 response ;
   __u32 cq_handle ;
   __u32 cqe ;
   __u64 driver_data[0] ;
};
#line 398 "./include/infiniband/kern-abi.h"
struct ibv_resize_cq_resp {
   __u32 cqe ;
   __u32 reserved ;
   __u64 driver_data[0] ;
};
#line 404 "./include/infiniband/kern-abi.h"
struct ibv_destroy_cq {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u64 response ;
   __u32 cq_handle ;
   __u32 reserved ;
};
#line 413 "./include/infiniband/kern-abi.h"
struct ibv_destroy_cq_resp {
   __u32 comp_events_reported ;
   __u32 async_events_reported ;
};
#line 476 "./include/infiniband/kern-abi.h"
struct ibv_create_qp {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u64 response ;
   __u64 user_handle ;
   __u32 pd_handle ;
   __u32 send_cq_handle ;
   __u32 recv_cq_handle ;
   __u32 srq_handle ;
   __u32 max_send_wr ;
   __u32 max_recv_wr ;
   __u32 max_send_sge ;
   __u32 max_recv_sge ;
   __u32 max_inline_data ;
   __u8 sq_sig_all ;
   __u8 qp_type ;
   __u8 is_srq ;
   __u8 reserved ;
   __u64 driver_data[0] ;
};
#line 498 "./include/infiniband/kern-abi.h"
struct ibv_create_qp_resp {
   __u32 qp_handle ;
   __u32 qpn ;
   __u32 max_send_wr ;
   __u32 max_recv_wr ;
   __u32 max_send_sge ;
   __u32 max_recv_sge ;
   __u32 max_inline_data ;
   __u32 reserved ;
};
#line 509 "./include/infiniband/kern-abi.h"
struct ibv_qp_dest {
   __u8 dgid[16] ;
   __u32 flow_label ;
   __u16 dlid ;
   __u16 reserved ;
   __u8 sgid_index ;
   __u8 hop_limit ;
   __u8 traffic_class ;
   __u8 sl ;
   __u8 src_path_bits ;
   __u8 static_rate ;
   __u8 is_global ;
   __u8 port_num ;
};
#line 524 "./include/infiniband/kern-abi.h"
struct ibv_query_qp {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u64 response ;
   __u32 qp_handle ;
   __u32 attr_mask ;
   __u64 driver_data[0] ;
};
#line 534 "./include/infiniband/kern-abi.h"
struct ibv_query_qp_resp {
   struct ibv_qp_dest dest ;
   struct ibv_qp_dest alt_dest ;
   __u32 max_send_wr ;
   __u32 max_recv_wr ;
   __u32 max_send_sge ;
   __u32 max_recv_sge ;
   __u32 max_inline_data ;
   __u32 qkey ;
   __u32 rq_psn ;
   __u32 sq_psn ;
   __u32 dest_qp_num ;
   __u32 qp_access_flags ;
   __u16 pkey_index ;
   __u16 alt_pkey_index ;
   __u8 qp_state ;
   __u8 cur_qp_state ;
   __u8 path_mtu ;
   __u8 path_mig_state ;
   __u8 sq_draining ;
   __u8 max_rd_atomic ;
   __u8 max_dest_rd_atomic ;
   __u8 min_rnr_timer ;
   __u8 port_num ;
   __u8 timeout ;
   __u8 retry_cnt ;
   __u8 rnr_retry ;
   __u8 alt_port_num ;
   __u8 alt_timeout ;
   __u8 sq_sig_all ;
   __u8 reserved[5] ;
   __u64 driver_data[0] ;
};
#line 568 "./include/infiniband/kern-abi.h"
struct ibv_modify_qp {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   struct ibv_qp_dest dest ;
   struct ibv_qp_dest alt_dest ;
   __u32 qp_handle ;
   __u32 attr_mask ;
   __u32 qkey ;
   __u32 rq_psn ;
   __u32 sq_psn ;
   __u32 dest_qp_num ;
   __u32 qp_access_flags ;
   __u16 pkey_index ;
   __u16 alt_pkey_index ;
   __u8 qp_state ;
   __u8 cur_qp_state ;
   __u8 path_mtu ;
   __u8 path_mig_state ;
   __u8 en_sqd_async_notify ;
   __u8 max_rd_atomic ;
   __u8 max_dest_rd_atomic ;
   __u8 min_rnr_timer ;
   __u8 port_num ;
   __u8 timeout ;
   __u8 retry_cnt ;
   __u8 rnr_retry ;
   __u8 alt_port_num ;
   __u8 alt_timeout ;
   __u8 reserved[2] ;
   __u64 driver_data[0] ;
};
#line 601 "./include/infiniband/kern-abi.h"
struct ibv_destroy_qp {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u64 response ;
   __u32 qp_handle ;
   __u32 reserved ;
};
#line 610 "./include/infiniband/kern-abi.h"
struct ibv_destroy_qp_resp {
   __u32 events_reported ;
};
#line 614 "./include/infiniband/kern-abi.h"
struct __anonstruct_rdma_60 {
   __u64 remote_addr ;
   __u32 rkey ;
   __u32 reserved ;
};
#line 614 "./include/infiniband/kern-abi.h"
struct __anonstruct_atomic_61 {
   __u64 remote_addr ;
   __u64 compare_add ;
   __u64 swap ;
   __u32 rkey ;
   __u32 reserved ;
};
#line 614 "./include/infiniband/kern-abi.h"
struct __anonstruct_ud_62 {
   __u32 ah ;
   __u32 remote_qpn ;
   __u32 remote_qkey ;
   __u32 reserved ;
};
#line 614 "./include/infiniband/kern-abi.h"
union __anonunion_wr_59 {
   struct __anonstruct_rdma_60 rdma ;
   struct __anonstruct_atomic_61 atomic ;
   struct __anonstruct_ud_62 ud ;
};
#line 614 "./include/infiniband/kern-abi.h"
struct ibv_kern_send_wr {
   __u64 wr_id ;
   __u32 num_sge ;
   __u32 opcode ;
   __u32 send_flags ;
   __u32 imm_data ;
   union __anonunion_wr_59 wr ;
};
#line 642 "./include/infiniband/kern-abi.h"
struct ibv_kern_eth_filter {
   __u8 dst_mac[6] ;
   __u8 src_mac[6] ;
   __u16 ether_type ;
   __u16 vlan_tag ;
};
#line 649 "./include/infiniband/kern-abi.h"
struct ibv_kern_spec_eth {
   __u32 type ;
   __u16 size ;
   __u16 reserved ;
   struct ibv_kern_eth_filter val ;
   struct ibv_kern_eth_filter mask ;
};
#line 657 "./include/infiniband/kern-abi.h"
struct ibv_kern_ipv4_filter {
   __u32 src_ip ;
   __u32 dst_ip ;
};
#line 662 "./include/infiniband/kern-abi.h"
struct ibv_kern_spec_ipv4 {
   __u32 type ;
   __u16 size ;
   __u16 reserved ;
   struct ibv_kern_ipv4_filter val ;
   struct ibv_kern_ipv4_filter mask ;
};
#line 670 "./include/infiniband/kern-abi.h"
struct ibv_kern_tcp_udp_filter {
   __u16 dst_port ;
   __u16 src_port ;
};
#line 675 "./include/infiniband/kern-abi.h"
struct ibv_kern_spec_tcp_udp {
   __u32 type ;
   __u16 size ;
   __u16 reserved ;
   struct ibv_kern_tcp_udp_filter val ;
   struct ibv_kern_tcp_udp_filter mask ;
};
#line 684 "./include/infiniband/kern-abi.h"
struct __anonstruct_hdr_64 {
   __u32 type ;
   __u16 size ;
   __u16 reserved ;
};
#line 684 "./include/infiniband/kern-abi.h"
union __anonunion____missing_field_name_63 {
   struct __anonstruct_hdr_64 hdr ;
   struct ibv_kern_spec_eth eth ;
   struct ibv_kern_spec_ipv4 ipv4 ;
   struct ibv_kern_spec_tcp_udp tcp_udp ;
};
#line 684 "./include/infiniband/kern-abi.h"
struct ibv_kern_spec {
   union __anonunion____missing_field_name_63 __annonCompField5 ;
};
#line 698 "./include/infiniband/kern-abi.h"
struct ibv_kern_flow_attr {
   __u32 type ;
   __u16 size ;
   __u16 priority ;
   __u8 num_of_specs ;
   __u8 reserved[2] ;
   __u8 port ;
   __u32 flags ;
};
#line 712 "./include/infiniband/kern-abi.h"
struct ibv_post_send {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u64 response ;
   __u32 qp_handle ;
   __u32 wr_count ;
   __u32 sge_count ;
   __u32 wqe_size ;
   struct ibv_kern_send_wr send_wr[0] ;
};
#line 724 "./include/infiniband/kern-abi.h"
struct ibv_post_send_resp {
   __u32 bad_wr ;
};
#line 728 "./include/infiniband/kern-abi.h"
struct ibv_kern_recv_wr {
   __u64 wr_id ;
   __u32 num_sge ;
   __u32 reserved ;
};
#line 734 "./include/infiniband/kern-abi.h"
struct ibv_post_recv {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u64 response ;
   __u32 qp_handle ;
   __u32 wr_count ;
   __u32 sge_count ;
   __u32 wqe_size ;
   struct ibv_kern_recv_wr recv_wr[0] ;
};
#line 746 "./include/infiniband/kern-abi.h"
struct ibv_post_recv_resp {
   __u32 bad_wr ;
};
#line 750 "./include/infiniband/kern-abi.h"
struct ibv_post_srq_recv {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u64 response ;
   __u32 srq_handle ;
   __u32 wr_count ;
   __u32 sge_count ;
   __u32 wqe_size ;
   struct ibv_kern_recv_wr recv_wr[0] ;
};
#line 762 "./include/infiniband/kern-abi.h"
struct ibv_post_srq_recv_resp {
   __u32 bad_wr ;
};
#line 766 "./include/infiniband/kern-abi.h"
struct ibv_create_ah {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u64 response ;
   __u64 user_handle ;
   __u32 pd_handle ;
   __u32 reserved ;
   struct ibv_kern_ah_attr attr ;
};
#line 777 "./include/infiniband/kern-abi.h"
struct ibv_create_ah_resp {
   __u32 handle ;
};
#line 781 "./include/infiniband/kern-abi.h"
struct ibv_destroy_ah {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u32 ah_handle ;
};
#line 788 "./include/infiniband/kern-abi.h"
struct ibv_attach_mcast {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u8 gid[16] ;
   __u32 qp_handle ;
   __u16 mlid ;
   __u16 reserved ;
   __u64 driver_data[0] ;
};
#line 799 "./include/infiniband/kern-abi.h"
struct ibv_create_flow {
   struct ex_hdr hdr ;
   __u32 comp_mask ;
   __u32 qp_handle ;
   struct ibv_kern_flow_attr flow_attr ;
};
#line 806 "./include/infiniband/kern-abi.h"
struct ibv_create_flow_resp {
   __u32 comp_mask ;
   __u32 flow_handle ;
};
#line 811 "./include/infiniband/kern-abi.h"
struct ibv_destroy_flow {
   struct ex_hdr hdr ;
   __u32 comp_mask ;
   __u32 flow_handle ;
};
#line 817 "./include/infiniband/kern-abi.h"
struct ibv_detach_mcast {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u8 gid[16] ;
   __u32 qp_handle ;
   __u16 mlid ;
   __u16 reserved ;
   __u64 driver_data[0] ;
};
#line 828 "./include/infiniband/kern-abi.h"
struct ibv_create_srq {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u64 response ;
   __u64 user_handle ;
   __u32 pd_handle ;
   __u32 max_wr ;
   __u32 max_sge ;
   __u32 srq_limit ;
   __u64 driver_data[0] ;
};
#line 841 "./include/infiniband/kern-abi.h"
struct ibv_create_srq_resp {
   __u32 srq_handle ;
   __u32 max_wr ;
   __u32 max_sge ;
   __u32 reserved ;
};
#line 848 "./include/infiniband/kern-abi.h"
struct ibv_modify_srq {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u32 srq_handle ;
   __u32 attr_mask ;
   __u32 max_wr ;
   __u32 srq_limit ;
   __u64 driver_data[0] ;
};
#line 859 "./include/infiniband/kern-abi.h"
struct ibv_query_srq {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u64 response ;
   __u32 srq_handle ;
   __u32 reserved ;
   __u64 driver_data[0] ;
};
#line 869 "./include/infiniband/kern-abi.h"
struct ibv_query_srq_resp {
   __u32 max_wr ;
   __u32 max_sge ;
   __u32 srq_limit ;
   __u32 reserved ;
};
#line 876 "./include/infiniband/kern-abi.h"
struct ibv_destroy_srq {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u64 response ;
   __u32 srq_handle ;
   __u32 reserved ;
};
#line 885 "./include/infiniband/kern-abi.h"
struct ibv_destroy_srq_resp {
   __u32 events_reported ;
};
#line 943 "./include/infiniband/kern-abi.h"
struct ibv_modify_srq_v3 {
   __u32 command ;
   __u16 in_words ;
   __u16 out_words ;
   __u32 srq_handle ;
   __u32 attr_mask ;
   __u32 max_wr ;
   __u32 max_sge ;
   __u32 srq_limit ;
   __u32 reserved ;
   __u64 driver_data[0] ;
};
#line 956 "./include/infiniband/kern-abi.h"
struct ibv_create_qp_resp_v3 {
   __u32 qp_handle ;
   __u32 qpn ;
};
#line 961 "./include/infiniband/kern-abi.h"
struct ibv_create_qp_resp_v4 {
   __u32 qp_handle ;
   __u32 qpn ;
   __u32 max_send_wr ;
   __u32 max_recv_wr ;
   __u32 max_send_sge ;
   __u32 max_recv_sge ;
   __u32 max_inline_data ;
};
#line 971 "./include/infiniband/kern-abi.h"
struct ibv_create_srq_resp_v5 {
   __u32 srq_handle ;
};
#line 45 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct ibv_context_1_0;
#line 45 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct ibv_pd_1_0 {
   struct ibv_context_1_0 *context ;
   uint32_t handle ;
   struct ibv_pd *real_pd ;
};
#line 52 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct ibv_mr_1_0 {
   struct ibv_context_1_0 *context ;
   struct ibv_pd_1_0 *pd ;
   uint32_t handle ;
   uint32_t lkey ;
   uint32_t rkey ;
   struct ibv_mr *real_mr ;
};
#line 62 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct ibv_srq_1_0 {
   struct ibv_context_1_0 *context ;
   void *srq_context ;
   struct ibv_pd_1_0 *pd ;
   uint32_t handle ;
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   uint32_t events_completed ;
   struct ibv_srq *real_srq ;
};
#line 75
struct ibv_cq_1_0;
#line 75 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct ibv_qp_init_attr_1_0 {
   void *qp_context ;
   struct ibv_cq_1_0 *send_cq ;
   struct ibv_cq_1_0 *recv_cq ;
   struct ibv_srq_1_0 *srq ;
   struct ibv_qp_cap cap ;
   enum ibv_qp_type qp_type ;
   int sq_sig_all ;
};
#line 85 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct __anonstruct_rdma_62 {
   uint64_t remote_addr ;
   uint32_t rkey ;
};
#line 85 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct __anonstruct_atomic_63 {
   uint64_t remote_addr ;
   uint64_t compare_add ;
   uint64_t swap ;
   uint32_t rkey ;
};
#line 85
struct ibv_ah_1_0;
#line 85 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct __anonstruct_ud_64 {
   struct ibv_ah_1_0 *ah ;
   uint32_t remote_qpn ;
   uint32_t remote_qkey ;
};
#line 85 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
union __anonunion_wr_61 {
   struct __anonstruct_rdma_62 rdma ;
   struct __anonstruct_atomic_63 atomic ;
   struct __anonstruct_ud_64 ud ;
};
#line 85 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct ibv_send_wr_1_0 {
   struct ibv_send_wr_1_0 *next ;
   uint64_t wr_id ;
   struct ibv_sge *sg_list ;
   int num_sge ;
   enum ibv_wr_opcode opcode ;
   int send_flags ;
   uint32_t imm_data ;
   union __anonunion_wr_61 wr ;
};
#line 112 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct ibv_recv_wr_1_0 {
   struct ibv_recv_wr_1_0 *next ;
   uint64_t wr_id ;
   struct ibv_sge *sg_list ;
   int num_sge ;
};
#line 119 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct ibv_qp_1_0 {
   struct ibv_context_1_0 *context ;
   void *qp_context ;
   struct ibv_pd_1_0 *pd ;
   struct ibv_cq_1_0 *send_cq ;
   struct ibv_cq_1_0 *recv_cq ;
   struct ibv_srq_1_0 *srq ;
   uint32_t handle ;
   uint32_t qp_num ;
   enum ibv_qp_state state ;
   enum ibv_qp_type qp_type ;
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   uint32_t events_completed ;
   struct ibv_qp *real_qp ;
};
#line 138 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct ibv_cq_1_0 {
   struct ibv_context_1_0 *context ;
   void *cq_context ;
   uint32_t handle ;
   int cqe ;
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   uint32_t comp_events_completed ;
   uint32_t async_events_completed ;
   struct ibv_cq *real_cq ;
};
#line 152 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct ibv_ah_1_0 {
   struct ibv_context_1_0 *context ;
   struct ibv_pd_1_0 *pd ;
   uint32_t handle ;
   struct ibv_ah *real_ah ;
};
#line 160 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct ibv_device_1_0 {
   void *obsolete_sysfs_dev ;
   void *obsolete_sysfs_ibdev ;
   struct ibv_device *real_device ;
   struct ibv_device_ops ops ;
};
#line 167 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct ibv_context_ops_1_0 {
   int (*query_device)(struct ibv_context *context , struct ibv_device_attr *device_attr ) ;
   int (*query_port)(struct ibv_context *context , uint8_t port_num , struct ibv_port_attr *port_attr ) ;
   struct ibv_pd *(*alloc_pd)(struct ibv_context *context ) ;
   int (*dealloc_pd)(struct ibv_pd *pd ) ;
   struct ibv_mr *(*reg_mr)(struct ibv_pd *pd , void *addr , size_t length , int access ) ;
   int (*dereg_mr)(struct ibv_mr *mr ) ;
   struct ibv_cq *(*create_cq)(struct ibv_context *context , int cqe , struct ibv_comp_channel *channel ,
                               int comp_vector ) ;
   int (*poll_cq)(struct ibv_cq_1_0 *cq , int num_entries , struct ibv_wc *wc ) ;
   int (*req_notify_cq)(struct ibv_cq_1_0 *cq , int solicited_only ) ;
   void (*cq_event)(struct ibv_cq *cq ) ;
   int (*resize_cq)(struct ibv_cq *cq , int cqe ) ;
   int (*destroy_cq)(struct ibv_cq *cq ) ;
   struct ibv_srq *(*create_srq)(struct ibv_pd *pd , struct ibv_srq_init_attr *srq_init_attr ) ;
   int (*modify_srq)(struct ibv_srq *srq , struct ibv_srq_attr *srq_attr , int srq_attr_mask ) ;
   int (*query_srq)(struct ibv_srq *srq , struct ibv_srq_attr *srq_attr ) ;
   int (*destroy_srq)(struct ibv_srq *srq ) ;
   int (*post_srq_recv)(struct ibv_srq_1_0 *srq , struct ibv_recv_wr_1_0 *recv_wr ,
                        struct ibv_recv_wr_1_0 **bad_recv_wr ) ;
   struct ibv_qp *(*create_qp)(struct ibv_pd *pd , struct ibv_qp_init_attr *attr ) ;
   int (*query_qp)(struct ibv_qp *qp , struct ibv_qp_attr *attr , int attr_mask ,
                   struct ibv_qp_init_attr *init_attr ) ;
   int (*modify_qp)(struct ibv_qp *qp , struct ibv_qp_attr *attr , int attr_mask ) ;
   int (*destroy_qp)(struct ibv_qp *qp ) ;
   int (*post_send)(struct ibv_qp_1_0 *qp , struct ibv_send_wr_1_0 *wr , struct ibv_send_wr_1_0 **bad_wr ) ;
   int (*post_recv)(struct ibv_qp_1_0 *qp , struct ibv_recv_wr_1_0 *wr , struct ibv_recv_wr_1_0 **bad_wr ) ;
   struct ibv_ah *(*create_ah)(struct ibv_pd *pd , struct ibv_ah_attr *attr ) ;
   int (*destroy_ah)(struct ibv_ah *ah ) ;
   int (*attach_mcast)(struct ibv_qp *qp , union ibv_gid *gid , uint16_t lid ) ;
   int (*detach_mcast)(struct ibv_qp *qp , union ibv_gid *gid , uint16_t lid ) ;
};
#line 219 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct ibv_context_1_0 {
   struct ibv_device_1_0 *device ;
   struct ibv_context_ops_1_0 ops ;
   int cmd_fd ;
   int async_fd ;
   int num_comp_vectors ;
   struct ibv_context *real_context ;
};
#line 61 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/srq_pingpong.c"
struct pingpong_context___0 {
   struct ibv_context *context ;
   struct ibv_comp_channel *channel ;
   struct ibv_pd *pd ;
   struct ibv_mr *mr ;
   struct ibv_cq *cq ;
   struct ibv_srq *srq ;
   struct ibv_qp *qp[256] ;
   void *buf ;
   int size ;
   int num_qp ;
   int rx_depth ;
   int pending[256] ;
   struct ibv_port_attr portinfo ;
};
#line 59 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/ud_pingpong.c"
struct pingpong_context___1 {
   struct ibv_context *context ;
   struct ibv_comp_channel *channel ;
   struct ibv_pd *pd ;
   struct ibv_mr *mr ;
   struct ibv_cq *cq ;
   struct ibv_qp *qp ;
   struct ibv_ah *ah ;
   void *buf ;
   int size ;
   int rx_depth ;
   int pending ;
   struct ibv_port_attr portinfo ;
};
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 51 "./include/infiniband/marshall.h"
void ibv_copy_qp_attr_from_kern(struct ibv_qp_attr *dst , struct ibv_kern_qp_attr *src ) ;
#line 54
void ibv_copy_ah_attr_from_kern(struct ibv_ah_attr *dst , struct ibv_kern_ah_attr *src ) ;
#line 57
void ibv_copy_path_rec_from_kern(struct ibv_sa_path_rec *dst , struct ibv_kern_path_rec *src ) ;
#line 60
void ibv_copy_path_rec_to_kern(struct ibv_kern_path_rec *dst , struct ibv_sa_path_rec *src ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/marshall.c"
void ibv_copy_ah_attr_from_kern(struct ibv_ah_attr *dst , struct ibv_kern_ah_attr *src ) 
{ 


  {
  {
#line 44
  memcpy((void */* __restrict  */)(dst->grh.dgid.raw), (void const   */* __restrict  */)(src->grh.dgid),
         sizeof(dst->grh.dgid));
#line 45
  dst->grh.flow_label = src->grh.flow_label;
#line 46
  dst->grh.sgid_index = src->grh.sgid_index;
#line 47
  dst->grh.hop_limit = src->grh.hop_limit;
#line 48
  dst->grh.traffic_class = src->grh.traffic_class;
#line 50
  dst->dlid = src->dlid;
#line 51
  dst->sl = src->sl;
#line 52
  dst->src_path_bits = src->src_path_bits;
#line 53
  dst->static_rate = src->static_rate;
#line 54
  dst->is_global = src->is_global;
#line 55
  dst->port_num = src->port_num;
  }
#line 56
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/marshall.c"
void ibv_copy_qp_attr_from_kern(struct ibv_qp_attr *dst , struct ibv_kern_qp_attr *src ) 
{ 


  {
  {
#line 61
  dst->cur_qp_state = (enum ibv_qp_state )src->cur_qp_state;
#line 62
  dst->path_mtu = (enum ibv_mtu )src->path_mtu;
#line 63
  dst->path_mig_state = (enum ibv_mig_state )src->path_mig_state;
#line 64
  dst->qkey = src->qkey;
#line 65
  dst->rq_psn = src->rq_psn;
#line 66
  dst->sq_psn = src->sq_psn;
#line 67
  dst->dest_qp_num = src->dest_qp_num;
#line 68
  dst->qp_access_flags = (int )src->qp_access_flags;
#line 70
  dst->cap.max_send_wr = src->max_send_wr;
#line 71
  dst->cap.max_recv_wr = src->max_recv_wr;
#line 72
  dst->cap.max_send_sge = src->max_send_sge;
#line 73
  dst->cap.max_recv_sge = src->max_recv_sge;
#line 74
  dst->cap.max_inline_data = src->max_inline_data;
#line 76
  ibv_copy_ah_attr_from_kern(& dst->ah_attr, & src->ah_attr);
#line 77
  ibv_copy_ah_attr_from_kern(& dst->alt_ah_attr, & src->alt_ah_attr);
#line 79
  dst->pkey_index = src->pkey_index;
#line 80
  dst->alt_pkey_index = src->alt_pkey_index;
#line 81
  dst->en_sqd_async_notify = src->en_sqd_async_notify;
#line 82
  dst->sq_draining = src->sq_draining;
#line 83
  dst->max_rd_atomic = src->max_rd_atomic;
#line 84
  dst->max_dest_rd_atomic = src->max_dest_rd_atomic;
#line 85
  dst->min_rnr_timer = src->min_rnr_timer;
#line 86
  dst->port_num = src->port_num;
#line 87
  dst->timeout = src->timeout;
#line 88
  dst->retry_cnt = src->retry_cnt;
#line 89
  dst->rnr_retry = src->rnr_retry;
#line 90
  dst->alt_port_num = src->alt_port_num;
#line 91
  dst->alt_timeout = src->alt_timeout;
  }
#line 92
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/marshall.c"
void ibv_copy_path_rec_from_kern(struct ibv_sa_path_rec *dst , struct ibv_kern_path_rec *src ) 
{ 


  {
  {
#line 97
  memcpy((void */* __restrict  */)(dst->dgid.raw), (void const   */* __restrict  */)(src->dgid),
         sizeof(dst->dgid));
#line 98
  memcpy((void */* __restrict  */)(dst->sgid.raw), (void const   */* __restrict  */)(src->sgid),
         sizeof(dst->sgid));
#line 100
  dst->dlid = src->dlid;
#line 101
  dst->slid = src->slid;
#line 102
  dst->raw_traffic = (int )src->raw_traffic;
#line 103
  dst->flow_label = src->flow_label;
#line 104
  dst->hop_limit = src->hop_limit;
#line 105
  dst->traffic_class = src->traffic_class;
#line 106
  dst->reversible = (int )src->reversible;
#line 107
  dst->numb_path = src->numb_path;
#line 108
  dst->pkey = src->pkey;
#line 109
  dst->sl = src->sl;
#line 110
  dst->mtu_selector = src->mtu_selector;
#line 111
  dst->mtu = (uint8_t )src->mtu;
#line 112
  dst->rate_selector = src->rate_selector;
#line 113
  dst->rate = src->rate;
#line 114
  dst->packet_life_time = src->packet_life_time;
#line 115
  dst->preference = src->preference;
#line 116
  dst->packet_life_time_selector = src->packet_life_time_selector;
  }
#line 117
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/marshall.c"
void ibv_copy_path_rec_to_kern(struct ibv_kern_path_rec *dst , struct ibv_sa_path_rec *src ) 
{ 


  {
  {
#line 122
  memcpy((void */* __restrict  */)(dst->dgid), (void const   */* __restrict  */)(src->dgid.raw),
         sizeof(src->dgid));
#line 123
  memcpy((void */* __restrict  */)(dst->sgid), (void const   */* __restrict  */)(src->sgid.raw),
         sizeof(src->sgid));
#line 125
  dst->dlid = src->dlid;
#line 126
  dst->slid = src->slid;
#line 127
  dst->raw_traffic = (__u32 )src->raw_traffic;
#line 128
  dst->flow_label = src->flow_label;
#line 129
  dst->hop_limit = src->hop_limit;
#line 130
  dst->traffic_class = src->traffic_class;
#line 131
  dst->reversible = (__u32 )src->reversible;
#line 132
  dst->numb_path = src->numb_path;
#line 133
  dst->pkey = src->pkey;
#line 134
  dst->sl = src->sl;
#line 135
  dst->mtu_selector = src->mtu_selector;
#line 136
  dst->mtu = (__u32 )src->mtu;
#line 137
  dst->rate_selector = src->rate_selector;
#line 138
  dst->rate = src->rate;
#line 139
  dst->packet_life_time = src->packet_life_time;
#line 140
  dst->preference = src->preference;
#line 141
  dst->packet_life_time_selector = src->packet_life_time_selector;
  }
#line 142
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 760 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 769
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_trylock)(pthread_mutex_t *__mutex ) ;
#line 773
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 784
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 979
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                                        pthread_condattr_t const   * __restrict  __cond_attr ) ;
#line 988
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
#line 393 "./include/infiniband/verbs.h"
int ibv_rate_to_mult(enum ibv_rate rate )  __attribute__((__const__)) ;
#line 399
enum ibv_rate mult_to_ibv_rate(int mult )  __attribute__((__const__)) ;
#line 406
int ibv_rate_to_mbps(enum ibv_rate rate )  __attribute__((__const__)) ;
#line 412
enum ibv_rate mbps_to_ibv_rate(int mbps )  __attribute__((__const__)) ;
#line 991
extern int ibv_query_gid(struct ibv_context *context , uint8_t port_num , int index ,
                         union ibv_gid *gid ) ;
#line 1044
struct ibv_comp_channel *ibv_create_comp_channel(struct ibv_context *context ) ;
#line 1049
int ibv_destroy_comp_channel(struct ibv_comp_channel *channel ) ;
#line 1253
extern struct ibv_ah *ibv_create_ah(struct ibv_pd *pd , struct ibv_ah_attr *attr ) ;
#line 1266
int ibv_init_ah_from_wc(struct ibv_context *context , uint8_t port_num , struct ibv_wc *wc ,
                        struct ibv_grh *grh , struct ibv_ah_attr *ah_attr ) ;
#line 1282
struct ibv_ah *ibv_create_ah_from_wc(struct ibv_pd *pd , struct ibv_wc *wc , struct ibv_grh *grh ,
                                     uint8_t port_num ) ;
#line 142 "./include/infiniband/driver.h"
int ibv_dontfork_range(void *base , size_t size ) ;
#line 143
int ibv_dofork_range(void *base , size_t size ) ;
#line 150
int ibv_read_sysfs_file(char const   *dir , char const   *file , char *buf , size_t size ) ;
#line 80 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/ibverbs.h"
int __attribute__((__visibility__("hidden")))  abi_ver ;
#line 47 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
int ibv_rate_to_mult(enum ibv_rate rate )  __attribute__((__const__)) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
int ibv_rate_to_mult(enum ibv_rate rate ) 
{ 


  {
  {
#line 50
  if ((unsigned int )rate == 2U) {
#line 50
    goto case_2;
  }
#line 51
  if ((unsigned int )rate == 5U) {
#line 51
    goto case_5;
  }
#line 52
  if ((unsigned int )rate == 3U) {
#line 52
    goto case_3;
  }
#line 53
  if ((unsigned int )rate == 6U) {
#line 53
    goto case_6;
  }
#line 54
  if ((unsigned int )rate == 4U) {
#line 54
    goto case_4;
  }
#line 55
  if ((unsigned int )rate == 7U) {
#line 55
    goto case_7;
  }
#line 56
  if ((unsigned int )rate == 8U) {
#line 56
    goto case_8;
  }
#line 57
  if ((unsigned int )rate == 9U) {
#line 57
    goto case_9;
  }
#line 58
  if ((unsigned int )rate == 10U) {
#line 58
    goto case_10;
  }
#line 59
  goto switch_default;
  case_2: /* CIL Label */ 
#line 50
  return (1);
  case_5: /* CIL Label */ 
#line 51
  return (2);
  case_3: /* CIL Label */ 
#line 52
  return (4);
  case_6: /* CIL Label */ 
#line 53
  return (8);
  case_4: /* CIL Label */ 
#line 54
  return (12);
  case_7: /* CIL Label */ 
#line 55
  return (16);
  case_8: /* CIL Label */ 
#line 56
  return (24);
  case_9: /* CIL Label */ 
#line 57
  return (32);
  case_10: /* CIL Label */ 
#line 58
  return (48);
  switch_default: /* CIL Label */ 
#line 59
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 63
enum ibv_rate mult_to_ibv_rate(int mult )  __attribute__((__const__)) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
enum ibv_rate mult_to_ibv_rate(int mult ) 
{ 


  {
  {
#line 66
  if (mult == 1) {
#line 66
    goto case_1;
  }
#line 67
  if (mult == 2) {
#line 67
    goto case_2;
  }
#line 68
  if (mult == 4) {
#line 68
    goto case_4;
  }
#line 69
  if (mult == 8) {
#line 69
    goto case_8;
  }
#line 70
  if (mult == 12) {
#line 70
    goto case_12;
  }
#line 71
  if (mult == 16) {
#line 71
    goto case_16;
  }
#line 72
  if (mult == 24) {
#line 72
    goto case_24;
  }
#line 73
  if (mult == 32) {
#line 73
    goto case_32;
  }
#line 74
  if (mult == 48) {
#line 74
    goto case_48;
  }
#line 75
  goto switch_default;
  case_1: /* CIL Label */ 
#line 66
  return ((enum ibv_rate )2);
  case_2: /* CIL Label */ 
#line 67
  return ((enum ibv_rate )5);
  case_4: /* CIL Label */ 
#line 68
  return ((enum ibv_rate )3);
  case_8: /* CIL Label */ 
#line 69
  return ((enum ibv_rate )6);
  case_12: /* CIL Label */ 
#line 70
  return ((enum ibv_rate )4);
  case_16: /* CIL Label */ 
#line 71
  return ((enum ibv_rate )7);
  case_24: /* CIL Label */ 
#line 72
  return ((enum ibv_rate )8);
  case_32: /* CIL Label */ 
#line 73
  return ((enum ibv_rate )9);
  case_48: /* CIL Label */ 
#line 74
  return ((enum ibv_rate )10);
  switch_default: /* CIL Label */ 
#line 75
  return ((enum ibv_rate )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 79
int ibv_rate_to_mbps(enum ibv_rate rate )  __attribute__((__const__)) ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
int ibv_rate_to_mbps(enum ibv_rate rate ) 
{ 


  {
  {
#line 82
  if ((unsigned int )rate == 2U) {
#line 82
    goto case_2;
  }
#line 83
  if ((unsigned int )rate == 5U) {
#line 83
    goto case_5;
  }
#line 84
  if ((unsigned int )rate == 3U) {
#line 84
    goto case_3;
  }
#line 85
  if ((unsigned int )rate == 6U) {
#line 85
    goto case_6;
  }
#line 86
  if ((unsigned int )rate == 4U) {
#line 86
    goto case_4;
  }
#line 87
  if ((unsigned int )rate == 7U) {
#line 87
    goto case_7;
  }
#line 88
  if ((unsigned int )rate == 8U) {
#line 88
    goto case_8;
  }
#line 89
  if ((unsigned int )rate == 9U) {
#line 89
    goto case_9;
  }
#line 90
  if ((unsigned int )rate == 10U) {
#line 90
    goto case_10;
  }
#line 91
  if ((unsigned int )rate == 11U) {
#line 91
    goto case_11;
  }
#line 92
  if ((unsigned int )rate == 12U) {
#line 92
    goto case_12;
  }
#line 93
  if ((unsigned int )rate == 13U) {
#line 93
    goto case_13;
  }
#line 94
  if ((unsigned int )rate == 14U) {
#line 94
    goto case_14;
  }
#line 95
  if ((unsigned int )rate == 15U) {
#line 95
    goto case_15;
  }
#line 96
  if ((unsigned int )rate == 16U) {
#line 96
    goto case_16;
  }
#line 97
  if ((unsigned int )rate == 17U) {
#line 97
    goto case_17;
  }
#line 98
  if ((unsigned int )rate == 18U) {
#line 98
    goto case_18;
  }
#line 99
  goto switch_default;
  case_2: /* CIL Label */ 
#line 82
  return (2500);
  case_5: /* CIL Label */ 
#line 83
  return (5000);
  case_3: /* CIL Label */ 
#line 84
  return (10000);
  case_6: /* CIL Label */ 
#line 85
  return (20000);
  case_4: /* CIL Label */ 
#line 86
  return (30000);
  case_7: /* CIL Label */ 
#line 87
  return (40000);
  case_8: /* CIL Label */ 
#line 88
  return (60000);
  case_9: /* CIL Label */ 
#line 89
  return (80000);
  case_10: /* CIL Label */ 
#line 90
  return (120000);
  case_11: /* CIL Label */ 
#line 91
  return (14062);
  case_12: /* CIL Label */ 
#line 92
  return (56250);
  case_13: /* CIL Label */ 
#line 93
  return (112500);
  case_14: /* CIL Label */ 
#line 94
  return (168750);
  case_15: /* CIL Label */ 
#line 95
  return (25781);
  case_16: /* CIL Label */ 
#line 96
  return (103125);
  case_17: /* CIL Label */ 
#line 97
  return (206250);
  case_18: /* CIL Label */ 
#line 98
  return (309375);
  switch_default: /* CIL Label */ 
#line 99
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 103
enum ibv_rate mbps_to_ibv_rate(int mbps )  __attribute__((__const__)) ;
#line 103 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
enum ibv_rate mbps_to_ibv_rate(int mbps ) 
{ 


  {
  {
#line 106
  if (mbps == 2500) {
#line 106
    goto case_2500;
  }
#line 107
  if (mbps == 5000) {
#line 107
    goto case_5000;
  }
#line 108
  if (mbps == 10000) {
#line 108
    goto case_10000;
  }
#line 109
  if (mbps == 20000) {
#line 109
    goto case_20000;
  }
#line 110
  if (mbps == 30000) {
#line 110
    goto case_30000;
  }
#line 111
  if (mbps == 40000) {
#line 111
    goto case_40000;
  }
#line 112
  if (mbps == 60000) {
#line 112
    goto case_60000;
  }
#line 113
  if (mbps == 80000) {
#line 113
    goto case_80000;
  }
#line 114
  if (mbps == 120000) {
#line 114
    goto case_120000;
  }
#line 115
  if (mbps == 14062) {
#line 115
    goto case_14062;
  }
#line 116
  if (mbps == 56250) {
#line 116
    goto case_56250;
  }
#line 117
  if (mbps == 112500) {
#line 117
    goto case_112500;
  }
#line 118
  if (mbps == 168750) {
#line 118
    goto case_168750;
  }
#line 119
  if (mbps == 25781) {
#line 119
    goto case_25781;
  }
#line 120
  if (mbps == 103125) {
#line 120
    goto case_103125;
  }
#line 121
  if (mbps == 206250) {
#line 121
    goto case_206250;
  }
#line 122
  if (mbps == 309375) {
#line 122
    goto case_309375;
  }
#line 123
  goto switch_default;
  case_2500: /* CIL Label */ 
#line 106
  return ((enum ibv_rate )2);
  case_5000: /* CIL Label */ 
#line 107
  return ((enum ibv_rate )5);
  case_10000: /* CIL Label */ 
#line 108
  return ((enum ibv_rate )3);
  case_20000: /* CIL Label */ 
#line 109
  return ((enum ibv_rate )6);
  case_30000: /* CIL Label */ 
#line 110
  return ((enum ibv_rate )4);
  case_40000: /* CIL Label */ 
#line 111
  return ((enum ibv_rate )7);
  case_60000: /* CIL Label */ 
#line 112
  return ((enum ibv_rate )8);
  case_80000: /* CIL Label */ 
#line 113
  return ((enum ibv_rate )9);
  case_120000: /* CIL Label */ 
#line 114
  return ((enum ibv_rate )10);
  case_14062: /* CIL Label */ 
#line 115
  return ((enum ibv_rate )11);
  case_56250: /* CIL Label */ 
#line 116
  return ((enum ibv_rate )12);
  case_112500: /* CIL Label */ 
#line 117
  return ((enum ibv_rate )13);
  case_168750: /* CIL Label */ 
#line 118
  return ((enum ibv_rate )14);
  case_25781: /* CIL Label */ 
#line 119
  return ((enum ibv_rate )15);
  case_103125: /* CIL Label */ 
#line 120
  return ((enum ibv_rate )16);
  case_206250: /* CIL Label */ 
#line 121
  return ((enum ibv_rate )17);
  case_309375: /* CIL Label */ 
#line 122
  return ((enum ibv_rate )18);
  switch_default: /* CIL Label */ 
#line 123
  return ((enum ibv_rate )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
int __ibv_query_device(struct ibv_context *context , struct ibv_device_attr *device_attr ) 
{ 
  int tmp ;

  {
  {
#line 130
  tmp = (*(context->ops.query_device))(context, device_attr);
  }
#line 130
  return (tmp);
}
}
#line 132
__asm__(".symver __ibv_query_device,ibv_query_device@@IBVERBS_1.1");
#line 134 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
int __ibv_query_port(struct ibv_context *context , uint8_t port_num , struct ibv_port_attr *port_attr ) 
{ 
  int tmp ;

  {
  {
#line 137
  tmp = (*(context->ops.query_port))(context, port_num, port_attr);
  }
#line 137
  return (tmp);
}
}
#line 139
__asm__(".symver __ibv_query_port,ibv_query_port@@IBVERBS_1.1");
#line 141 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
int __ibv_query_gid(struct ibv_context *context , uint8_t port_num , int index___0 ,
                    union ibv_gid *gid ) 
{ 
  char name[24] ;
  char attr[41] ;
  uint16_t val ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 149
  snprintf((char */* __restrict  */)(name), sizeof(name), (char const   */* __restrict  */)"ports/%d/gids/%d",
           (int )port_num, index___0);
#line 151
  tmp = ibv_read_sysfs_file((char const   *)((context->device)->ibdev_path), (char const   *)(name),
                            attr, sizeof(attr));
  }
#line 151
  if (tmp < 0) {
#line 153
    return (-1);
  }
#line 155
  i = 0;
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! (i < 8)) {
#line 155
      goto while_break;
    }
    {
#line 156
    tmp___0 = sscanf((char const   */* __restrict  */)(attr + i * 5), (char const   */* __restrict  */)"%hx",
                     & val);
    }
#line 156
    if (tmp___0 != 1) {
#line 157
      return (-1);
    }
#line 158
    gid->raw[i * 2] = (uint8_t )((int )val >> 8);
#line 159
    gid->raw[i * 2 + 1] = (uint8_t )((int )val & 255);
#line 155
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  return (0);
}
}
#line 164
__asm__(".symver __ibv_query_gid,ibv_query_gid@@IBVERBS_1.1");
#line 166 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
int __ibv_query_pkey(struct ibv_context *context , uint8_t port_num , int index___0 ,
                     uint16_t *pkey ) 
{ 
  char name[24] ;
  char attr[8] ;
  uint16_t val ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 173
  snprintf((char */* __restrict  */)(name), sizeof(name), (char const   */* __restrict  */)"ports/%d/pkeys/%d",
           (int )port_num, index___0);
#line 175
  tmp = ibv_read_sysfs_file((char const   *)((context->device)->ibdev_path), (char const   *)(name),
                            attr, sizeof(attr));
  }
#line 175
  if (tmp < 0) {
#line 177
    return (-1);
  }
  {
#line 179
  tmp___0 = sscanf((char const   */* __restrict  */)(attr), (char const   */* __restrict  */)"%hx",
                   & val);
  }
#line 179
  if (tmp___0 != 1) {
#line 180
    return (-1);
  }
  {
#line 182
  *pkey = htons(val);
  }
#line 183
  return (0);
}
}
#line 185
__asm__(".symver __ibv_query_pkey,ibv_query_pkey@@IBVERBS_1.1");
#line 187 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
struct ibv_pd *__ibv_alloc_pd(struct ibv_context *context ) 
{ 
  struct ibv_pd *pd ;

  {
  {
#line 191
  pd = (*(context->ops.alloc_pd))(context);
  }
#line 192
  if (pd) {
#line 193
    pd->context = context;
  }
#line 195
  return (pd);
}
}
#line 197
__asm__(".symver __ibv_alloc_pd,ibv_alloc_pd@@IBVERBS_1.1");
#line 199 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
int __ibv_dealloc_pd(struct ibv_pd *pd ) 
{ 
  int tmp ;

  {
  {
#line 201
  tmp = (*((pd->context)->ops.dealloc_pd))(pd);
  }
#line 201
  return (tmp);
}
}
#line 203
__asm__(".symver __ibv_dealloc_pd,ibv_dealloc_pd@@IBVERBS_1.1");
#line 205 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
struct ibv_mr *__ibv_reg_mr(struct ibv_pd *pd , void *addr , size_t length , int access___0 ) 
{ 
  struct ibv_mr *mr ;
  int tmp ;

  {
  {
#line 210
  tmp = ibv_dontfork_range(addr, length);
  }
#line 210
  if (tmp) {
#line 211
    return ((struct ibv_mr *)((void *)0));
  }
  {
#line 213
  mr = (*((pd->context)->ops.reg_mr))(pd, addr, length, access___0);
  }
#line 214
  if (mr) {
#line 215
    mr->context = pd->context;
#line 216
    mr->pd = pd;
#line 217
    mr->addr = addr;
#line 218
    mr->length = length;
  } else {
    {
#line 220
    ibv_dofork_range(addr, length);
    }
  }
#line 222
  return (mr);
}
}
#line 224
__asm__(".symver __ibv_reg_mr,ibv_reg_mr@@IBVERBS_1.1");
#line 226 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
int __ibv_dereg_mr(struct ibv_mr *mr ) 
{ 
  int ret ;
  void *addr ;
  size_t length ;

  {
  {
#line 229
  addr = mr->addr;
#line 230
  length = mr->length;
#line 232
  ret = (*((mr->context)->ops.dereg_mr))(mr);
  }
#line 233
  if (! ret) {
    {
#line 234
    ibv_dofork_range(addr, length);
    }
  }
#line 236
  return (ret);
}
}
#line 238
__asm__(".symver __ibv_dereg_mr,ibv_dereg_mr@@IBVERBS_1.1");
#line 243 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int warned  ;
#line 240 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static struct ibv_comp_channel *ibv_create_comp_channel_v2(struct ibv_context *context ) 
{ 
  struct ibv_abi_compat_v2 *t ;
  int tmp ;

  {
  {
#line 242
  t = (struct ibv_abi_compat_v2 *)context->abi_compat;
#line 245
  tmp = pthread_mutex_trylock(& t->in_use);
  }
#line 245
  if (! tmp) {
#line 246
    return (& t->channel);
  }
#line 248
  if (! warned) {
    {
#line 249
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: kernel\'s ABI version %d limits capacity.\n    Only one completion channel can be created per context.\n",
            abi_ver);
#line 252
    warned ++;
    }
  }
#line 255
  return ((struct ibv_comp_channel *)((void *)0));
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
struct ibv_comp_channel *ibv_create_comp_channel(struct ibv_context *context ) 
{ 
  struct ibv_comp_channel *channel ;
  struct ibv_create_comp_channel cmd ;
  struct ibv_create_comp_channel_resp resp ;
  struct ibv_comp_channel *tmp ;
  void *tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 264
  if (abi_ver <= (int __attribute__((__visibility__("hidden")))  )2) {
    {
#line 265
    tmp = ibv_create_comp_channel_v2(context);
    }
#line 265
    return (tmp);
  }
  {
#line 267
  tmp___0 = malloc(sizeof(*channel));
#line 267
  channel = (struct ibv_comp_channel *)tmp___0;
  }
#line 268
  if (! channel) {
#line 269
    return ((struct ibv_comp_channel *)((void *)0));
  }
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 271
      cmd.command = (__u32 )17;
    } else {
#line 271
      cmd.command = (__u32 )-1;
    }
#line 271
    cmd.in_words = (__u16 )(sizeof(cmd) / 4UL);
#line 271
    cmd.out_words = (__u16 )(sizeof(resp) / 4UL);
#line 271
    cmd.response = (__u64 )((uintptr_t )(& resp));
#line 271
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 272
  tmp___1 = write(context->cmd_fd, (void const   *)(& cmd), sizeof(cmd));
  }
#line 272
  if ((unsigned long )tmp___1 != sizeof(cmd)) {
    {
#line 273
    free((void *)channel);
    }
#line 274
    return ((struct ibv_comp_channel *)((void *)0));
  }
#line 279
  channel->context = context;
#line 280
  channel->fd = (int )resp.fd;
#line 281
  channel->refcnt = 0;
#line 283
  return (channel);
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int ibv_destroy_comp_channel_v2(struct ibv_comp_channel *channel ) 
{ 
  struct ibv_abi_compat_v2 *t ;

  {
  {
#line 288
  t = (struct ibv_abi_compat_v2 *)channel;
#line 289
  pthread_mutex_unlock(& t->in_use);
  }
#line 290
  return (0);
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
int ibv_destroy_comp_channel(struct ibv_comp_channel *channel ) 
{ 
  struct ibv_context *context ;
  int ret ;

  {
  {
#line 298
  context = channel->context;
#line 299
  pthread_mutex_lock(& context->mutex);
  }
#line 301
  if (channel->refcnt) {
#line 302
    ret = 16;
#line 303
    goto out;
  }
#line 306
  if (abi_ver <= (int __attribute__((__visibility__("hidden")))  )2) {
    {
#line 307
    ret = ibv_destroy_comp_channel_v2(channel);
    }
#line 308
    goto out;
  }
  {
#line 311
  close(channel->fd);
#line 312
  free((void *)channel);
#line 313
  ret = 0;
  }
  out: 
  {
#line 316
  pthread_mutex_unlock(& context->mutex);
  }
#line 318
  return (ret);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
struct ibv_cq *__ibv_create_cq(struct ibv_context *context , int cqe , void *cq_context ,
                               struct ibv_comp_channel *channel , int comp_vector ) 
{ 
  struct ibv_cq *cq ;

  {
  {
#line 326
  pthread_mutex_lock(& context->mutex);
#line 328
  cq = (*(context->ops.create_cq))(context, cqe, channel, comp_vector);
  }
#line 330
  if (cq) {
#line 331
    cq->context = context;
#line 332
    cq->channel = channel;
#line 333
    if (channel) {
#line 334
      (channel->refcnt) ++;
    }
    {
#line 335
    cq->cq_context = cq_context;
#line 336
    cq->comp_events_completed = (uint32_t )0;
#line 337
    cq->async_events_completed = (uint32_t )0;
#line 338
    pthread_mutex_init(& cq->mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 339
    pthread_cond_init((pthread_cond_t */* __restrict  */)(& cq->cond), (pthread_condattr_t const   */* __restrict  */)((void *)0));
    }
  }
  {
#line 342
  pthread_mutex_unlock(& context->mutex);
  }
#line 344
  return (cq);
}
}
#line 346
__asm__(".symver __ibv_create_cq,ibv_create_cq@@IBVERBS_1.1");
#line 348 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
int __ibv_resize_cq(struct ibv_cq *cq , int cqe ) 
{ 
  int tmp ;

  {
#line 350
  if (! (cq->context)->ops.resize_cq) {
#line 351
    return (38);
  }
  {
#line 353
  tmp = (*((cq->context)->ops.resize_cq))(cq, cqe);
  }
#line 353
  return (tmp);
}
}
#line 355
__asm__(".symver __ibv_resize_cq,ibv_resize_cq@@IBVERBS_1.1");
#line 357 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
int __ibv_destroy_cq(struct ibv_cq *cq ) 
{ 
  struct ibv_comp_channel *channel ;
  int ret ;

  {
#line 359
  channel = cq->channel;
#line 362
  if (channel) {
    {
#line 363
    pthread_mutex_lock(& (channel->context)->mutex);
    }
  }
  {
#line 365
  ret = (*((cq->context)->ops.destroy_cq))(cq);
  }
#line 367
  if (channel) {
#line 368
    if (! ret) {
#line 369
      (channel->refcnt) --;
    }
    {
#line 370
    pthread_mutex_unlock(& (channel->context)->mutex);
    }
  }
#line 373
  return (ret);
}
}
#line 375
__asm__(".symver __ibv_destroy_cq,ibv_destroy_cq@@IBVERBS_1.1");
#line 377 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
int __ibv_get_cq_event(struct ibv_comp_channel *channel , struct ibv_cq **cq , void **cq_context ) 
{ 
  struct ibv_comp_event ev ;
  ssize_t tmp ;

  {
  {
#line 382
  tmp = read(channel->fd, (void *)(& ev), sizeof(ev));
  }
#line 382
  if ((unsigned long )tmp != sizeof(ev)) {
#line 383
    return (-1);
  }
#line 385
  *cq = (struct ibv_cq *)((uintptr_t )ev.cq_handle);
#line 386
  *cq_context = (*cq)->cq_context;
#line 388
  if (((*cq)->context)->ops.cq_event) {
    {
#line 389
    (*(((*cq)->context)->ops.cq_event))(*cq);
    }
  }
#line 391
  return (0);
}
}
#line 393
__asm__(".symver __ibv_get_cq_event,ibv_get_cq_event@@IBVERBS_1.1");
#line 395 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
void __ibv_ack_cq_events(struct ibv_cq *cq , unsigned int nevents ) 
{ 


  {
  {
#line 397
  pthread_mutex_lock(& cq->mutex);
#line 398
  cq->comp_events_completed += nevents;
#line 399
  pthread_cond_signal(& cq->cond);
#line 400
  pthread_mutex_unlock(& cq->mutex);
  }
#line 401
  return;
}
}
#line 402
__asm__(".symver __ibv_ack_cq_events,ibv_ack_cq_events@@IBVERBS_1.1");
#line 404 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
struct ibv_srq *__ibv_create_srq(struct ibv_pd *pd , struct ibv_srq_init_attr *srq_init_attr ) 
{ 
  struct ibv_srq *srq ;

  {
#line 409
  if (! (pd->context)->ops.create_srq) {
#line 410
    return ((struct ibv_srq *)((void *)0));
  }
  {
#line 412
  srq = (*((pd->context)->ops.create_srq))(pd, srq_init_attr);
  }
#line 413
  if (srq) {
    {
#line 414
    srq->context = pd->context;
#line 415
    srq->srq_context = srq_init_attr->srq_context;
#line 416
    srq->pd = pd;
#line 417
    srq->events_completed = (uint32_t )0;
#line 418
    pthread_mutex_init(& srq->mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 419
    pthread_cond_init((pthread_cond_t */* __restrict  */)(& srq->cond), (pthread_condattr_t const   */* __restrict  */)((void *)0));
    }
  }
#line 422
  return (srq);
}
}
#line 424
__asm__(".symver __ibv_create_srq,ibv_create_srq@@IBVERBS_1.1");
#line 426 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
int __ibv_modify_srq(struct ibv_srq *srq , struct ibv_srq_attr *srq_attr , int srq_attr_mask ) 
{ 
  int tmp ;

  {
  {
#line 430
  tmp = (*((srq->context)->ops.modify_srq))(srq, srq_attr, srq_attr_mask);
  }
#line 430
  return (tmp);
}
}
#line 432
__asm__(".symver __ibv_modify_srq,ibv_modify_srq@@IBVERBS_1.1");
#line 434 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
int __ibv_query_srq(struct ibv_srq *srq , struct ibv_srq_attr *srq_attr ) 
{ 
  int tmp ;

  {
  {
#line 436
  tmp = (*((srq->context)->ops.query_srq))(srq, srq_attr);
  }
#line 436
  return (tmp);
}
}
#line 438
__asm__(".symver __ibv_query_srq,ibv_query_srq@@IBVERBS_1.1");
#line 440 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
int __ibv_destroy_srq(struct ibv_srq *srq ) 
{ 
  int tmp ;

  {
  {
#line 442
  tmp = (*((srq->context)->ops.destroy_srq))(srq);
  }
#line 442
  return (tmp);
}
}
#line 444
__asm__(".symver __ibv_destroy_srq,ibv_destroy_srq@@IBVERBS_1.1");
#line 446 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
struct ibv_qp *__ibv_create_qp(struct ibv_pd *pd , struct ibv_qp_init_attr *qp_init_attr ) 
{ 
  struct ibv_qp *qp ;
  struct ibv_qp *tmp ;

  {
  {
#line 449
  tmp = (*((pd->context)->ops.create_qp))(pd, qp_init_attr);
#line 449
  qp = tmp;
  }
#line 451
  if (qp) {
    {
#line 452
    qp->context = pd->context;
#line 453
    qp->qp_context = qp_init_attr->qp_context;
#line 454
    qp->pd = pd;
#line 455
    qp->send_cq = qp_init_attr->send_cq;
#line 456
    qp->recv_cq = qp_init_attr->recv_cq;
#line 457
    qp->srq = qp_init_attr->srq;
#line 458
    qp->qp_type = qp_init_attr->qp_type;
#line 459
    qp->state = (enum ibv_qp_state )0;
#line 460
    qp->events_completed = (uint32_t )0;
#line 461
    pthread_mutex_init(& qp->mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 462
    pthread_cond_init((pthread_cond_t */* __restrict  */)(& qp->cond), (pthread_condattr_t const   */* __restrict  */)((void *)0));
    }
  }
#line 465
  return (qp);
}
}
#line 467
__asm__(".symver __ibv_create_qp,ibv_create_qp@@IBVERBS_1.1");
#line 469 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
int __ibv_query_qp(struct ibv_qp *qp , struct ibv_qp_attr *attr , int attr_mask ,
                   struct ibv_qp_init_attr *init_attr ) 
{ 
  int ret ;

  {
  {
#line 475
  ret = (*((qp->context)->ops.query_qp))(qp, attr, attr_mask, init_attr);
  }
#line 476
  if (ret) {
#line 477
    return (ret);
  }
#line 479
  if (attr_mask & 1) {
#line 480
    qp->state = attr->qp_state;
  }
#line 482
  return (0);
}
}
#line 484
__asm__(".symver __ibv_query_qp,ibv_query_qp@@IBVERBS_1.1");
#line 486 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
int __ibv_modify_qp(struct ibv_qp *qp , struct ibv_qp_attr *attr , int attr_mask ) 
{ 
  int ret ;

  {
  {
#line 491
  ret = (*((qp->context)->ops.modify_qp))(qp, attr, attr_mask);
  }
#line 492
  if (ret) {
#line 493
    return (ret);
  }
#line 495
  if (attr_mask & 1) {
#line 496
    qp->state = attr->qp_state;
  }
#line 498
  return (0);
}
}
#line 500
__asm__(".symver __ibv_modify_qp,ibv_modify_qp@@IBVERBS_1.1");
#line 502 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
int __ibv_destroy_qp(struct ibv_qp *qp ) 
{ 
  int tmp ;

  {
  {
#line 504
  tmp = (*((qp->context)->ops.destroy_qp))(qp);
  }
#line 504
  return (tmp);
}
}
#line 506
__asm__(".symver __ibv_destroy_qp,ibv_destroy_qp@@IBVERBS_1.1");
#line 508 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
struct ibv_ah *__ibv_create_ah(struct ibv_pd *pd , struct ibv_ah_attr *attr ) 
{ 
  struct ibv_ah *ah ;
  struct ibv_ah *tmp ;

  {
  {
#line 510
  tmp = (*((pd->context)->ops.create_ah))(pd, attr);
#line 510
  ah = tmp;
  }
#line 512
  if (ah) {
#line 513
    ah->context = pd->context;
#line 514
    ah->pd = pd;
  }
#line 517
  return (ah);
}
}
#line 519
__asm__(".symver __ibv_create_ah,ibv_create_ah@@IBVERBS_1.1");
#line 521 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int ibv_find_gid_index(struct ibv_context *context , uint8_t port_num , union ibv_gid *gid ) 
{ 
  union ibv_gid sgid ;
  int i ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 525
  i = 0;
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 528
    tmp = i;
#line 528
    i ++;
#line 528
    ret = ibv_query_gid(context, port_num, tmp, & sgid);
    }
#line 527
    if (! ret) {
      {
#line 527
      tmp___0 = memcmp((void const   *)(& sgid), (void const   *)gid, sizeof(*gid));
      }
#line 527
      if (! tmp___0) {
#line 527
        goto while_break;
      }
    } else {
#line 527
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 531
  if (ret) {
#line 531
    tmp___1 = ret;
  } else {
#line 531
    tmp___1 = i - 1;
  }
#line 531
  return (tmp___1);
}
}
#line 534 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
int ibv_init_ah_from_wc(struct ibv_context *context , uint8_t port_num , struct ibv_wc *wc ,
                        struct ibv_grh *grh , struct ibv_ah_attr *ah_attr ) 
{ 
  uint32_t flow_class ;
  int ret ;

  {
  {
#line 541
  memset((void *)ah_attr, 0, sizeof(*ah_attr));
#line 542
  ah_attr->dlid = wc->slid;
#line 543
  ah_attr->sl = wc->sl;
#line 544
  ah_attr->src_path_bits = wc->dlid_path_bits;
#line 545
  ah_attr->port_num = port_num;
  }
#line 547
  if (wc->wc_flags & 1) {
    {
#line 548
    ah_attr->is_global = (uint8_t )1;
#line 549
    ah_attr->grh.dgid = grh->sgid;
#line 551
    ret = ibv_find_gid_index(context, port_num, & grh->dgid);
    }
#line 552
    if (ret < 0) {
#line 553
      return (ret);
    }
    {
#line 555
    ah_attr->grh.sgid_index = (uint8_t )ret;
#line 556
    flow_class = ntohl(grh->version_tclass_flow);
#line 557
    ah_attr->grh.flow_label = flow_class & 1048575U;
#line 558
    ah_attr->grh.hop_limit = grh->hop_limit;
#line 559
    ah_attr->grh.traffic_class = (uint8_t )((flow_class >> 20) & 255U);
    }
  }
#line 561
  return (0);
}
}
#line 564 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
struct ibv_ah *ibv_create_ah_from_wc(struct ibv_pd *pd , struct ibv_wc *wc , struct ibv_grh *grh ,
                                     uint8_t port_num ) 
{ 
  struct ibv_ah_attr ah_attr ;
  int ret ;
  struct ibv_ah *tmp ;

  {
  {
#line 570
  ret = ibv_init_ah_from_wc(pd->context, port_num, wc, grh, & ah_attr);
  }
#line 571
  if (ret) {
#line 572
    return ((struct ibv_ah *)((void *)0));
  }
  {
#line 574
  tmp = ibv_create_ah(pd, & ah_attr);
  }
#line 574
  return (tmp);
}
}
#line 577 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
int __ibv_destroy_ah(struct ibv_ah *ah ) 
{ 
  int tmp ;

  {
  {
#line 579
  tmp = (*((ah->context)->ops.destroy_ah))(ah);
  }
#line 579
  return (tmp);
}
}
#line 581
__asm__(".symver __ibv_destroy_ah,ibv_destroy_ah@@IBVERBS_1.1");
#line 583 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
int __ibv_attach_mcast(struct ibv_qp *qp , union ibv_gid  const  *gid , uint16_t lid ) 
{ 
  int tmp ;

  {
  {
#line 585
  tmp = (*((qp->context)->ops.attach_mcast))(qp, gid, lid);
  }
#line 585
  return (tmp);
}
}
#line 587
__asm__(".symver __ibv_attach_mcast,ibv_attach_mcast@@IBVERBS_1.1");
#line 589 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
int __ibv_detach_mcast(struct ibv_qp *qp , union ibv_gid  const  *gid , uint16_t lid ) 
{ 
  int tmp ;

  {
  {
#line 591
  tmp = (*((qp->context)->ops.detach_mcast))(qp, gid, lid);
  }
#line 591
  return (tmp);
}
}
#line 593
__asm__(".symver __ibv_detach_mcast,ibv_detach_mcast@@IBVERBS_1.1");
#line 971 "./include/infiniband/verbs.h"
extern int ibv_query_port(struct ibv_context *context , uint8_t port_num , struct ibv_port_attr *port_attr ) ;
#line 974 "./include/infiniband/verbs.h"
__inline static int ___ibv_query_port(struct ibv_context *context , uint8_t port_num ,
                                      struct ibv_port_attr *port_attr ) 
{ 
  int tmp ;

  {
  {
#line 979
  port_attr->link_layer = (uint8_t )0;
#line 980
  port_attr->reserved = (uint8_t )0;
#line 982
  tmp = ibv_query_port(context, port_num, port_attr);
  }
#line 982
  return (tmp);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/pingpong.h"
enum ibv_mtu pp_mtu_to_enum(int mtu ) ;
#line 39
uint16_t pp_get_local_lid(struct ibv_context *context , int port ) ;
#line 40
int pp_get_port_info(struct ibv_context *context , int port , struct ibv_port_attr *attr ) ;
#line 42
void wire_gid_to_gid(char const   *wgid , union ibv_gid *gid ) ;
#line 43
void gid_to_wire_gid(union ibv_gid  const  *gid , char *wgid ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/pingpong.c"
enum ibv_mtu pp_mtu_to_enum(int mtu ) 
{ 


  {
  {
#line 42
  if (mtu == 256) {
#line 42
    goto case_256;
  }
#line 43
  if (mtu == 512) {
#line 43
    goto case_512;
  }
#line 44
  if (mtu == 1024) {
#line 44
    goto case_1024;
  }
#line 45
  if (mtu == 2048) {
#line 45
    goto case_2048;
  }
#line 46
  if (mtu == 4096) {
#line 46
    goto case_4096;
  }
#line 47
  goto switch_default;
  case_256: /* CIL Label */ 
#line 42
  return ((enum ibv_mtu )1);
  case_512: /* CIL Label */ 
#line 43
  return ((enum ibv_mtu )2);
  case_1024: /* CIL Label */ 
#line 44
  return ((enum ibv_mtu )3);
  case_2048: /* CIL Label */ 
#line 45
  return ((enum ibv_mtu )4);
  case_4096: /* CIL Label */ 
#line 46
  return ((enum ibv_mtu )5);
  switch_default: /* CIL Label */ 
#line 47
  return ((enum ibv_mtu )-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/pingpong.c"
uint16_t pp_get_local_lid(struct ibv_context *context , int port ) 
{ 
  struct ibv_port_attr attr ;
  int tmp ;

  {
  {
#line 55
  tmp = ___ibv_query_port(context, (uint8_t )port, & attr);
  }
#line 55
  if (tmp) {
#line 56
    return ((uint16_t )0);
  }
#line 58
  return (attr.lid);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/pingpong.c"
int pp_get_port_info(struct ibv_context *context , int port , struct ibv_port_attr *attr ) 
{ 
  int tmp ;

  {
  {
#line 64
  tmp = ___ibv_query_port(context, (uint8_t )port, attr);
  }
#line 64
  return (tmp);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/pingpong.c"
void wire_gid_to_gid(char const   *wgid , union ibv_gid *gid ) 
{ 
  char tmp[9] ;
  uint32_t v32 ;
  int i ;

  {
#line 73
  tmp[8] = (char)0;
#line 73
  i = 0;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! (i < 4)) {
#line 73
      goto while_break;
    }
    {
#line 74
    memcpy((void */* __restrict  */)(tmp), (void const   */* __restrict  */)(wgid + i * 8),
           (size_t )8);
#line 75
    sscanf((char const   */* __restrict  */)(tmp), (char const   */* __restrict  */)"%x",
           & v32);
#line 76
    *((uint32_t *)(& gid->raw[i * 4])) = ntohl(v32);
#line 73
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/pingpong.c"
void gid_to_wire_gid(union ibv_gid  const  *gid , char *wgid ) 
{ 
  int i ;
  uint32_t tmp ;

  {
#line 84
  i = 0;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i < 4)) {
#line 84
      goto while_break;
    }
    {
#line 85
    tmp = htonl(*((uint32_t *)(gid->raw + i * 4)));
#line 85
    sprintf((char */* __restrict  */)(wgid + i * 8), (char const   */* __restrict  */)"%08x",
            tmp);
#line 84
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  return;
}
}
/* compiler builtin: 
   long __builtin_bswap64(long  ) ;  */
#line 405 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 108 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 
  long tmp ;

  {
  {
#line 111
  tmp = __builtin_bswap64((long )__bsx);
  }
#line 111
  return ((__uint64_t )tmp);
}
}
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 41 "./include/infiniband/arch.h"
__inline static uint64_t htonll(uint64_t x ) 
{ 
  __uint64_t tmp ;

  {
  {
#line 41
  tmp = __bswap_64(x);
  }
#line 41
  return (tmp);
}
}
#line 505 "/usr/include/pthread.h"
extern int ( __attribute__((__nonnull__(1,2))) pthread_once)(pthread_once_t *__once_control ,
                                                             void (*__init_routine)(void) ) ;
#line 82 "./include/infiniband/verbs.h"
static void *__VERBS_ABI_IS_EXTENDED  =    (void *)((uint8_t *)((void *)0) - 1);
#line 877 "./include/infiniband/verbs.h"
__inline static struct verbs_context *verbs_get_ctx(struct ibv_context *ctx ) 
{ 
  struct verbs_context *tmp ;

  {
#line 879
  if ((unsigned long )ctx->abi_compat != (unsigned long )__VERBS_ABI_IS_EXTENDED) {
#line 879
    tmp = (struct verbs_context *)((void *)0);
  } else {
#line 879
    tmp = (struct verbs_context *)((uint8_t *)ctx - (unsigned long )(& ((struct verbs_context *)0)->context));
  }
#line 879
  return (tmp);
}
}
#line 893 "./include/infiniband/verbs.h"
__inline static struct verbs_device *verbs_get_device(struct ibv_device  const  *dev ) 
{ 
  struct verbs_device *tmp ;

  {
#line 896
  if (dev->ops.alloc_context) {
#line 896
    tmp = (struct verbs_device *)((void *)0);
  } else {
#line 896
    tmp = (struct verbs_device *)((uint8_t *)dev - (unsigned long )(& ((struct verbs_device *)0)->device));
  }
#line 896
  return (tmp);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/ibverbs.h"
int __attribute__((__visibility__("hidden")))  ibverbs_init(struct ibv_device ***list ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static pthread_once_t device_list_once  =    0;
#line 53 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static int num_devices  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static struct ibv_device **device_list  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static void count_devices(void) 
{ 
  int __attribute__((__visibility__("hidden")))  tmp ;

  {
  {
#line 58
  tmp = ibverbs_init(& device_list);
#line 58
  num_devices = (int )tmp;
  }
#line 59
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
struct ibv_device **__ibv_get_device_list(int *num ) 
{ 
  struct ibv_device **l ;
  int i ;
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;

  {
#line 66
  if (num) {
#line 67
    *num = 0;
  }
  {
#line 69
  pthread_once(& device_list_once, & count_devices);
  }
#line 71
  if (num_devices < 0) {
    {
#line 72
    tmp = __errno_location();
#line 72
    *tmp = - num_devices;
    }
#line 73
    return ((struct ibv_device **)((void *)0));
  }
  {
#line 76
  tmp___0 = calloc((size_t )(num_devices + 1), sizeof(struct ibv_device *));
#line 76
  l = (struct ibv_device **)tmp___0;
  }
#line 77
  if (! l) {
    {
#line 78
    tmp___1 = __errno_location();
#line 78
    *tmp___1 = 12;
    }
#line 79
    return ((struct ibv_device **)((void *)0));
  }
#line 82
  i = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i < num_devices)) {
#line 82
      goto while_break;
    }
#line 83
    *(l + i) = *(device_list + i);
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  if (num) {
#line 85
    *num = num_devices;
  }
#line 87
  return (l);
}
}
#line 89
__asm__(".symver __ibv_get_device_list,ibv_get_device_list@@IBVERBS_1.1");
#line 91 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
void __ibv_free_device_list(struct ibv_device **list ) 
{ 


  {
  {
#line 93
  free((void *)list);
  }
#line 94
  return;
}
}
#line 95
__asm__(".symver __ibv_free_device_list,ibv_free_device_list@@IBVERBS_1.1");
#line 97 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
char const   *__ibv_get_device_name(struct ibv_device *device ) 
{ 


  {
#line 99
  return ((char const   *)(device->name));
}
}
#line 101
__asm__(".symver __ibv_get_device_name,ibv_get_device_name@@IBVERBS_1.1");
#line 103 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
uint64_t __ibv_get_device_guid(struct ibv_device *device ) 
{ 
  char attr[24] ;
  uint64_t guid ;
  uint16_t parts[4] ;
  int i ;
  int tmp ;
  int tmp___0 ;
  uint64_t tmp___1 ;

  {
  {
#line 106
  guid = (uint64_t )0;
#line 110
  tmp = ibv_read_sysfs_file((char const   *)(device->ibdev_path), "node_guid", attr,
                            sizeof(attr));
  }
#line 110
  if (tmp < 0) {
#line 112
    return ((uint64_t )0);
  }
  {
#line 114
  tmp___0 = sscanf((char const   */* __restrict  */)(attr), (char const   */* __restrict  */)"%hx:%hx:%hx:%hx",
                   parts, parts + 1, parts + 2, parts + 3);
  }
#line 114
  if (tmp___0 != 4) {
#line 116
    return ((uint64_t )0);
  }
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! (i < 4)) {
#line 118
      goto while_break;
    }
#line 119
    guid = (guid << 16) | (unsigned long )parts[i];
#line 118
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 121
  tmp___1 = htonll(guid);
  }
#line 121
  return (tmp___1);
}
}
#line 123
__asm__(".symver __ibv_get_device_guid,ibv_get_device_guid@@IBVERBS_1.1");
#line 125 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
struct ibv_context *__ibv_open_device(struct ibv_device *device ) 
{ 
  struct verbs_device *verbs_device ;
  struct verbs_device *tmp ;
  char *devpath ;
  int cmd_fd ;
  int ret ;
  struct ibv_context *context ;
  struct verbs_context *context_ex ;
  int tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 127
  tmp = verbs_get_device((struct ibv_device  const  *)device);
#line 127
  verbs_device = tmp;
#line 133
  tmp___0 = asprintf((char **/* __restrict  */)(& devpath), (char const   */* __restrict  */)"/dev/infiniband/%s",
                     device->dev_name);
  }
#line 133
  if (tmp___0 < 0) {
#line 134
    return ((struct ibv_context *)((void *)0));
  }
  {
#line 140
  cmd_fd = open((char const   *)devpath, 524290);
#line 141
  free((void *)devpath);
  }
#line 143
  if (cmd_fd < 0) {
#line 144
    return ((struct ibv_context *)((void *)0));
  }
#line 146
  if (! verbs_device) {
    {
#line 147
    context = (*(device->ops.alloc_context))(device, cmd_fd);
    }
#line 148
    if (! context) {
#line 149
      goto err;
    }
  } else {
    {
#line 152
    tmp___1 = calloc((size_t )1, sizeof(*context_ex) + verbs_device->size_of_context);
#line 152
    context_ex = (struct verbs_context *)tmp___1;
    }
#line 154
    if (! context_ex) {
      {
#line 155
      tmp___2 = __errno_location();
#line 155
      *tmp___2 = 12;
      }
#line 156
      goto err;
    }
    {
#line 159
    context_ex->context.abi_compat = __VERBS_ABI_IS_EXTENDED;
#line 160
    context_ex->sz = sizeof(*context_ex);
#line 162
    context = & context_ex->context;
#line 163
    ret = (*(verbs_device->init_context))(verbs_device, context, cmd_fd);
    }
#line 164
    if (ret) {
#line 165
      goto verbs_err;
    }
#line 172
    context_ex->lib_ibv_create_flow = context_ex->drv_ibv_create_flow;
#line 174
    context_ex->lib_ibv_destroy_flow = context_ex->drv_ibv_destroy_flow;
  }
  {
#line 178
  context->device = device;
#line 179
  context->cmd_fd = cmd_fd;
#line 180
  pthread_mutex_init(& context->mutex, (pthread_mutexattr_t const   *)((void *)0));
  }
#line 182
  return (context);
  verbs_err: 
  {
#line 185
  free((void *)context_ex);
  }
  err: 
  {
#line 187
  close(cmd_fd);
  }
#line 188
  return ((struct ibv_context *)((void *)0));
}
}
#line 190
__asm__(".symver __ibv_open_device,ibv_open_device@@IBVERBS_1.1");
#line 192 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
int __ibv_close_device(struct ibv_context *context ) 
{ 
  int async_fd ;
  int cmd_fd ;
  int cq_fd ;
  struct verbs_context *context_ex ;
  struct verbs_device *verbs_device ;
  struct verbs_device *tmp ;

  {
  {
#line 194
  async_fd = context->async_fd;
#line 195
  cmd_fd = context->cmd_fd;
#line 196
  cq_fd = -1;
#line 199
  context_ex = verbs_get_ctx(context);
  }
#line 200
  if (context_ex) {
    {
#line 201
    tmp = verbs_get_device((struct ibv_device  const  *)context->device);
#line 201
    verbs_device = tmp;
#line 202
    (*(verbs_device->uninit_context))(verbs_device, context);
#line 203
    free((void *)context_ex);
    }
  } else {
    {
#line 205
    (*((context->device)->ops.free_context))(context);
    }
  }
  {
#line 208
  close(async_fd);
#line 209
  close(cmd_fd);
  }
#line 210
  if (abi_ver <= (int __attribute__((__visibility__("hidden")))  )2) {
    {
#line 211
    close(cq_fd);
    }
  }
#line 213
  return (0);
}
}
#line 215
__asm__(".symver __ibv_close_device,ibv_close_device@@IBVERBS_1.1");
#line 217 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
int __ibv_get_async_event(struct ibv_context *context , struct ibv_async_event *event ) 
{ 
  struct ibv_kern_async_event ev ;
  ssize_t tmp ;

  {
  {
#line 222
  tmp = read(context->async_fd, (void *)(& ev), sizeof(ev));
  }
#line 222
  if ((unsigned long )tmp != sizeof(ev)) {
#line 223
    return (-1);
  }
#line 225
  event->event_type = (enum ibv_event_type )ev.event_type;
  {
#line 228
  if ((unsigned int )event->event_type == 0U) {
#line 228
    goto case_0;
  }
#line 239
  if ((unsigned int )event->event_type == 16U) {
#line 239
    goto case_16;
  }
#line 239
  if ((unsigned int )event->event_type == 7U) {
#line 239
    goto case_16;
  }
#line 239
  if ((unsigned int )event->event_type == 6U) {
#line 239
    goto case_16;
  }
#line 239
  if ((unsigned int )event->event_type == 5U) {
#line 239
    goto case_16;
  }
#line 239
  if ((unsigned int )event->event_type == 4U) {
#line 239
    goto case_16;
  }
#line 239
  if ((unsigned int )event->event_type == 3U) {
#line 239
    goto case_16;
  }
#line 239
  if ((unsigned int )event->event_type == 2U) {
#line 239
    goto case_16;
  }
#line 239
  if ((unsigned int )event->event_type == 1U) {
#line 239
    goto case_16;
  }
#line 244
  if ((unsigned int )event->event_type == 15U) {
#line 244
    goto case_15;
  }
#line 244
  if ((unsigned int )event->event_type == 14U) {
#line 244
    goto case_15;
  }
#line 248
  goto switch_default;
  case_0: /* CIL Label */ 
#line 229
  event->element.cq = (struct ibv_cq *)((void *)((uintptr_t )ev.element));
#line 230
  goto switch_break;
  case_16: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 240
  event->element.qp = (struct ibv_qp *)((void *)((uintptr_t )ev.element));
#line 241
  goto switch_break;
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
#line 245
  event->element.srq = (struct ibv_srq *)((void *)((uintptr_t )ev.element));
#line 246
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 249
  event->element.port_num = (int )ev.element;
#line 250
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 253
  if (context->ops.async_event) {
    {
#line 254
    (*(context->ops.async_event))(event);
    }
  }
#line 256
  return (0);
}
}
#line 258
__asm__(".symver __ibv_get_async_event,ibv_get_async_event@@IBVERBS_1.1");
#line 260 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
void __ibv_ack_async_event(struct ibv_async_event *event ) 
{ 
  struct ibv_cq *cq ;
  struct ibv_qp *qp ;
  struct ibv_srq *srq ;

  {
  {
#line 263
  if ((unsigned int )event->event_type == 0U) {
#line 263
    goto case_0;
  }
#line 282
  if ((unsigned int )event->event_type == 16U) {
#line 282
    goto case_16;
  }
#line 282
  if ((unsigned int )event->event_type == 7U) {
#line 282
    goto case_16;
  }
#line 282
  if ((unsigned int )event->event_type == 6U) {
#line 282
    goto case_16;
  }
#line 282
  if ((unsigned int )event->event_type == 5U) {
#line 282
    goto case_16;
  }
#line 282
  if ((unsigned int )event->event_type == 4U) {
#line 282
    goto case_16;
  }
#line 282
  if ((unsigned int )event->event_type == 3U) {
#line 282
    goto case_16;
  }
#line 282
  if ((unsigned int )event->event_type == 2U) {
#line 282
    goto case_16;
  }
#line 282
  if ((unsigned int )event->event_type == 1U) {
#line 282
    goto case_16;
  }
#line 295
  if ((unsigned int )event->event_type == 15U) {
#line 295
    goto case_15;
  }
#line 295
  if ((unsigned int )event->event_type == 14U) {
#line 295
    goto case_15;
  }
#line 307
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 265
  cq = event->element.cq;
#line 267
  pthread_mutex_lock(& cq->mutex);
#line 268
  (cq->async_events_completed) ++;
#line 269
  pthread_cond_signal(& cq->cond);
#line 270
  pthread_mutex_unlock(& cq->mutex);
  }
#line 272
  return;
  case_16: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 284
  qp = event->element.qp;
#line 286
  pthread_mutex_lock(& qp->mutex);
#line 287
  (qp->events_completed) ++;
#line 288
  pthread_cond_signal(& qp->cond);
#line 289
  pthread_mutex_unlock(& qp->mutex);
  }
#line 291
  return;
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  {
#line 297
  srq = event->element.srq;
#line 299
  pthread_mutex_lock(& srq->mutex);
#line 300
  (srq->events_completed) ++;
#line 301
  pthread_cond_signal(& srq->cond);
#line 302
  pthread_mutex_unlock(& srq->mutex);
  }
#line 304
  return;
  switch_default: /* CIL Label */ 
#line 308
  return;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 311
__asm__(".symver __ibv_ack_async_event,ibv_ack_async_event@@IBVERBS_1.1");
#line 94 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) madvise)(void *__addr ,
                                                                              size_t __len ,
                                                                              int __advice ) ;
#line 619 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 503 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) posix_memalign)(void **__memptr ,
                                                                                                     size_t __alignment ,
                                                                                                     size_t __size ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 1317 "./include/infiniband/verbs.h"
int ibv_fork_init(void) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *mm_root  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static pthread_mutex_t mm_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 75 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int page_size  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int huge_page_enabled  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int too_late  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static unsigned long smaps_page_size(FILE *file ) 
{ 
  int n ;
  unsigned long size ;
  char buf[1024] ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 82
  size = (unsigned long )page_size;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 85
    tmp___0 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)file);
    }
#line 85
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 85
      goto while_break;
    }
    {
#line 86
    tmp = strstr((char const   *)(buf), "KernelPageSize:");
    }
#line 86
    if (! tmp) {
#line 87
      goto while_continue;
    }
    {
#line 89
    n = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*s %lu",
               & size);
    }
#line 90
    if (n < 1) {
#line 91
      goto while_continue;
    }
#line 94
    size *= 1024UL;
#line 96
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return (size);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static unsigned long get_page_size(void *base ) 
{ 
  unsigned long ret ;
  pid_t pid ;
  FILE *file ;
  char buf[1024] ;
  int n ;
  uintptr_t range_start ;
  uintptr_t range_end ;
  char *tmp ;

  {
  {
#line 104
  ret = (unsigned long )page_size;
#line 109
  pid = getpid();
#line 110
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"/proc/%d/smaps",
           pid);
#line 112
  file = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"re");
  }
#line 113
  if (! file) {
#line 114
    goto out;
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 116
    tmp = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)file);
    }
#line 116
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 116
      goto while_break;
    }
    {
#line 120
    n = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%lx-%lx",
               & range_start, & range_end);
    }
#line 122
    if (n < 2) {
#line 123
      goto while_continue;
    }
#line 125
    if ((uintptr_t )base >= range_start) {
#line 125
      if ((uintptr_t )base < range_end) {
        {
#line 126
        ret = smaps_page_size(file);
        }
#line 127
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  fclose(file);
  }
  out: 
#line 134
  return (ret);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
int ibv_fork_init(void) 
{ 
  void *tmp ;
  void *tmp_aligned ;
  int ret ;
  unsigned long size ;
  long tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;

  {
#line 143
  if (mm_root) {
#line 144
    return (0);
  }
#line 146
  if (too_late) {
#line 147
    return (22);
  }
  {
#line 149
  tmp___0 = sysconf(30);
#line 149
  page_size = (int )tmp___0;
  }
#line 150
  if (page_size < 0) {
    {
#line 151
    tmp___1 = __errno_location();
    }
#line 151
    return (*tmp___1);
  }
  {
#line 153
  tmp___2 = posix_memalign(& tmp, (size_t )page_size, (size_t )page_size);
  }
#line 153
  if (tmp___2) {
#line 154
    return (12);
  }
  {
#line 156
  tmp___3 = getenv("RDMAV_HUGEPAGES_SAFE");
  }
#line 156
  if (tmp___3) {
#line 157
    huge_page_enabled = 1;
  } else {
#line 159
    huge_page_enabled = 0;
  }
#line 161
  if (huge_page_enabled) {
    {
#line 162
    size = get_page_size(tmp);
#line 163
    tmp_aligned = (void *)((uintptr_t )tmp & ~ (size - 1UL));
    }
  } else {
#line 165
    size = (unsigned long )page_size;
#line 166
    tmp_aligned = tmp;
  }
  {
#line 169
  tmp___4 = madvise(tmp_aligned, size, 10);
  }
#line 169
  if (tmp___4) {
#line 169
    tmp___6 = 1;
  } else {
    {
#line 169
    tmp___5 = madvise(tmp_aligned, size, 11);
    }
#line 169
    if (tmp___5) {
#line 169
      tmp___6 = 1;
    } else {
#line 169
      tmp___6 = 0;
    }
  }
  {
#line 169
  ret = tmp___6;
#line 172
  free(tmp);
  }
#line 174
  if (ret) {
#line 175
    return (38);
  }
  {
#line 177
  tmp___7 = malloc(sizeof(*mm_root));
#line 177
  mm_root = (struct ibv_mem_node *)tmp___7;
  }
#line 178
  if (! mm_root) {
#line 179
    return (12);
  }
#line 181
  mm_root->parent = (struct ibv_mem_node *)((void *)0);
#line 182
  mm_root->left = (struct ibv_mem_node *)((void *)0);
#line 183
  mm_root->right = (struct ibv_mem_node *)((void *)0);
#line 184
  mm_root->color = (enum __anonenum_color_68 )1;
#line 185
  mm_root->start = (uintptr_t )0;
#line 186
  mm_root->end = 0xffffffffffffffffUL;
#line 187
  mm_root->refcnt = 0;
#line 189
  return (0);
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_prev(struct ibv_mem_node *node ) 
{ 


  {
#line 194
  if (node->left) {
#line 195
    node = node->left;
    {
#line 196
    while (1) {
      while_continue: /* CIL Label */ ;
#line 196
      if (! node->right) {
#line 196
        goto while_break;
      }
#line 197
      node = node->right;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 199
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 199
      if (node->parent) {
#line 199
        if (! ((unsigned long )node == (unsigned long )(node->parent)->left)) {
#line 199
          goto while_break___0;
        }
      } else {
#line 199
        goto while_break___0;
      }
#line 200
      node = node->parent;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 202
    node = node->parent;
  }
#line 205
  return (node);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_next(struct ibv_mem_node *node ) 
{ 


  {
#line 210
  if (node->right) {
#line 211
    node = node->right;
    {
#line 212
    while (1) {
      while_continue: /* CIL Label */ ;
#line 212
      if (! node->left) {
#line 212
        goto while_break;
      }
#line 213
      node = node->left;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 215
      if (node->parent) {
#line 215
        if (! ((unsigned long )node == (unsigned long )(node->parent)->right)) {
#line 215
          goto while_break___0;
        }
      } else {
#line 215
        goto while_break___0;
      }
#line 216
      node = node->parent;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 218
    node = node->parent;
  }
#line 221
  return (node);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_rotate_right(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 228
  tmp = node->left;
#line 230
  node->left = tmp->right;
#line 231
  if (node->left) {
#line 232
    (node->left)->parent = node;
  }
#line 234
  if (node->parent) {
#line 235
    if ((unsigned long )(node->parent)->right == (unsigned long )node) {
#line 236
      (node->parent)->right = tmp;
    } else {
#line 238
      (node->parent)->left = tmp;
    }
  } else {
#line 240
    mm_root = tmp;
  }
#line 242
  tmp->parent = node->parent;
#line 244
  tmp->right = node;
#line 245
  node->parent = tmp;
#line 246
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_rotate_left(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 252
  tmp = node->right;
#line 254
  node->right = tmp->left;
#line 255
  if (node->right) {
#line 256
    (node->right)->parent = node;
  }
#line 258
  if (node->parent) {
#line 259
    if ((unsigned long )(node->parent)->right == (unsigned long )node) {
#line 260
      (node->parent)->right = tmp;
    } else {
#line 262
      (node->parent)->left = tmp;
    }
  } else {
#line 264
    mm_root = tmp;
  }
#line 266
  tmp->parent = node->parent;
#line 268
  tmp->left = node;
#line 269
  node->parent = tmp;
#line 270
  return;
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_add_rebalance(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *parent ;
  struct ibv_mem_node *gp ;
  struct ibv_mem_node *uncle ;

  {
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (node->parent) {
#line 304
      if (! ((unsigned int )(node->parent)->color == 0U)) {
#line 304
        goto while_break;
      }
    } else {
#line 304
      goto while_break;
    }
#line 305
    parent = node->parent;
#line 306
    gp = (node->parent)->parent;
#line 308
    if ((unsigned long )parent == (unsigned long )gp->left) {
#line 309
      uncle = gp->right;
#line 311
      if (uncle) {
#line 311
        if ((unsigned int )uncle->color == 0U) {
#line 312
          parent->color = (enum __anonenum_color_68 )1;
#line 313
          uncle->color = (enum __anonenum_color_68 )1;
#line 314
          gp->color = (enum __anonenum_color_68 )0;
#line 316
          node = gp;
        } else {
#line 311
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 318
        if ((unsigned long )node == (unsigned long )parent->right) {
          {
#line 319
          __mm_rotate_left(parent);
#line 320
          node = parent;
#line 321
          parent = node->parent;
          }
        }
        {
#line 324
        parent->color = (enum __anonenum_color_68 )1;
#line 325
        gp->color = (enum __anonenum_color_68 )0;
#line 327
        __mm_rotate_right(gp);
        }
      }
    } else {
#line 330
      uncle = gp->left;
#line 332
      if (uncle) {
#line 332
        if ((unsigned int )uncle->color == 0U) {
#line 333
          parent->color = (enum __anonenum_color_68 )1;
#line 334
          uncle->color = (enum __anonenum_color_68 )1;
#line 335
          gp->color = (enum __anonenum_color_68 )0;
#line 337
          node = gp;
        } else {
#line 332
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 339
        if ((unsigned long )node == (unsigned long )parent->left) {
          {
#line 340
          __mm_rotate_right(parent);
#line 341
          node = parent;
#line 342
          parent = node->parent;
          }
        }
        {
#line 345
        parent->color = (enum __anonenum_color_68 )1;
#line 346
        gp->color = (enum __anonenum_color_68 )0;
#line 348
        __mm_rotate_left(gp);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  mm_root->color = (enum __anonenum_color_68 )1;
#line 354
  return;
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_add(struct ibv_mem_node *new ) 
{ 
  struct ibv_mem_node *node ;
  struct ibv_mem_node *parent ;

  {
#line 358
  parent = (struct ibv_mem_node *)((void *)0);
#line 360
  node = mm_root;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! node) {
#line 361
      goto while_break;
    }
#line 362
    parent = node;
#line 363
    if (node->start < new->start) {
#line 364
      node = node->right;
    } else {
#line 366
      node = node->left;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  if (parent->start < new->start) {
#line 370
    parent->right = new;
  } else {
#line 372
    parent->left = new;
  }
  {
#line 374
  new->parent = parent;
#line 375
  new->left = (struct ibv_mem_node *)((void *)0);
#line 376
  new->right = (struct ibv_mem_node *)((void *)0);
#line 378
  new->color = (enum __anonenum_color_68 )0;
#line 379
  __mm_add_rebalance(new);
  }
#line 380
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_remove(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *child ;
  struct ibv_mem_node *parent ;
  struct ibv_mem_node *sib ;
  struct ibv_mem_node *tmp ;
  int nodecol ;

  {
#line 387
  if (node->left) {
#line 387
    if (node->right) {
#line 388
      tmp = node->left;
      {
#line 389
      while (1) {
        while_continue: /* CIL Label */ ;
#line 389
        if (! tmp->right) {
#line 389
          goto while_break;
        }
#line 390
        tmp = tmp->right;
      }
      while_break: /* CIL Label */ ;
      }
#line 392
      nodecol = (int )tmp->color;
#line 393
      child = tmp->left;
#line 394
      tmp->color = node->color;
#line 396
      if ((unsigned long )tmp->parent != (unsigned long )node) {
#line 397
        parent = tmp->parent;
#line 398
        parent->right = tmp->left;
#line 399
        if (tmp->left) {
#line 400
          (tmp->left)->parent = parent;
        }
#line 402
        tmp->left = node->left;
#line 403
        (node->left)->parent = tmp;
      } else {
#line 405
        parent = tmp;
      }
#line 407
      tmp->right = node->right;
#line 408
      (node->right)->parent = tmp;
#line 410
      tmp->parent = node->parent;
#line 411
      if (node->parent) {
#line 412
        if ((unsigned long )(node->parent)->left == (unsigned long )node) {
#line 413
          (node->parent)->left = tmp;
        } else {
#line 415
          (node->parent)->right = tmp;
        }
      } else {
#line 417
        mm_root = tmp;
      }
    } else {
#line 387
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 419
    nodecol = (int )node->color;
#line 421
    if (node->left) {
#line 421
      child = node->left;
    } else {
#line 421
      child = node->right;
    }
#line 422
    parent = node->parent;
#line 424
    if (child) {
#line 425
      child->parent = parent;
    }
#line 426
    if (parent) {
#line 427
      if ((unsigned long )parent->left == (unsigned long )node) {
#line 428
        parent->left = child;
      } else {
#line 430
        parent->right = child;
      }
    } else {
#line 432
      mm_root = child;
    }
  }
  {
#line 435
  free((void *)node);
  }
#line 437
  if (nodecol == 0) {
#line 438
    return;
  }
  {
#line 440
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 440
    if (! child) {
#line 440
      goto _L___6;
    } else
#line 440
    if ((unsigned int )child->color == 1U) {
      _L___6: /* CIL Label */ 
#line 440
      if (! ((unsigned long )child != (unsigned long )mm_root)) {
#line 440
        goto while_break___0;
      }
    } else {
#line 440
      goto while_break___0;
    }
#line 441
    if ((unsigned long )parent->left == (unsigned long )child) {
#line 442
      sib = parent->right;
#line 444
      if ((unsigned int )sib->color == 0U) {
        {
#line 445
        parent->color = (enum __anonenum_color_68 )0;
#line 446
        sib->color = (enum __anonenum_color_68 )1;
#line 447
        __mm_rotate_left(parent);
#line 448
        sib = parent->right;
        }
      }
#line 451
      if (! sib->left) {
#line 451
        goto _L___2;
      } else
#line 451
      if ((unsigned int )(sib->left)->color == 1U) {
        _L___2: /* CIL Label */ 
#line 451
        if (! sib->right) {
#line 453
          sib->color = (enum __anonenum_color_68 )0;
#line 454
          child = parent;
#line 455
          parent = child->parent;
        } else
#line 451
        if ((unsigned int )(sib->right)->color == 1U) {
#line 453
          sib->color = (enum __anonenum_color_68 )0;
#line 454
          child = parent;
#line 455
          parent = child->parent;
        } else {
#line 451
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 457
        if (! sib->right) {
#line 457
          goto _L___0;
        } else
#line 457
        if ((unsigned int )(sib->right)->color == 1U) {
          _L___0: /* CIL Label */ 
#line 458
          if (sib->left) {
#line 459
            (sib->left)->color = (enum __anonenum_color_68 )1;
          }
          {
#line 460
          sib->color = (enum __anonenum_color_68 )0;
#line 461
          __mm_rotate_right(sib);
#line 462
          sib = parent->right;
          }
        }
#line 465
        sib->color = parent->color;
#line 466
        parent->color = (enum __anonenum_color_68 )1;
#line 467
        if (sib->right) {
#line 468
          (sib->right)->color = (enum __anonenum_color_68 )1;
        }
        {
#line 469
        __mm_rotate_left(parent);
#line 470
        child = mm_root;
        }
#line 471
        goto while_break___0;
      }
    } else {
#line 474
      sib = parent->left;
#line 476
      if ((unsigned int )sib->color == 0U) {
        {
#line 477
        parent->color = (enum __anonenum_color_68 )0;
#line 478
        sib->color = (enum __anonenum_color_68 )1;
#line 479
        __mm_rotate_right(parent);
#line 480
        sib = parent->left;
        }
      }
#line 483
      if (! sib->left) {
#line 483
        goto _L___5;
      } else
#line 483
      if ((unsigned int )(sib->left)->color == 1U) {
        _L___5: /* CIL Label */ 
#line 483
        if (! sib->right) {
#line 485
          sib->color = (enum __anonenum_color_68 )0;
#line 486
          child = parent;
#line 487
          parent = child->parent;
        } else
#line 483
        if ((unsigned int )(sib->right)->color == 1U) {
#line 485
          sib->color = (enum __anonenum_color_68 )0;
#line 486
          child = parent;
#line 487
          parent = child->parent;
        } else {
#line 483
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
#line 489
        if (! sib->left) {
#line 489
          goto _L___3;
        } else
#line 489
        if ((unsigned int )(sib->left)->color == 1U) {
          _L___3: /* CIL Label */ 
#line 490
          if (sib->right) {
#line 491
            (sib->right)->color = (enum __anonenum_color_68 )1;
          }
          {
#line 492
          sib->color = (enum __anonenum_color_68 )0;
#line 493
          __mm_rotate_left(sib);
#line 494
          sib = parent->left;
          }
        }
#line 497
        sib->color = parent->color;
#line 498
        parent->color = (enum __anonenum_color_68 )1;
#line 499
        if (sib->left) {
#line 500
          (sib->left)->color = (enum __anonenum_color_68 )1;
        }
        {
#line 501
        __mm_rotate_right(parent);
#line 502
        child = mm_root;
        }
#line 503
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 508
  if (child) {
#line 509
    child->color = (enum __anonenum_color_68 )1;
  }
#line 510
  return;
}
}
#line 512 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_find_start(uintptr_t start , uintptr_t end ) 
{ 
  struct ibv_mem_node *node ;

  {
#line 514
  node = mm_root;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! node) {
#line 516
      goto while_break;
    }
#line 517
    if (node->start <= start) {
#line 517
      if (node->end >= start) {
#line 518
        goto while_break;
      }
    }
#line 520
    if (node->start < start) {
#line 521
      node = node->right;
    } else {
#line 523
      node = node->left;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 526
  return (node);
}
}
#line 529 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *merge_ranges(struct ibv_mem_node *node , struct ibv_mem_node *prev ) 
{ 


  {
  {
#line 532
  prev->end = node->end;
#line 533
  prev->refcnt = node->refcnt;
#line 534
  __mm_remove(node);
  }
#line 536
  return (prev);
}
}
#line 539 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *split_range(struct ibv_mem_node *node , uintptr_t cut_line ) 
{ 
  struct ibv_mem_node *new_node ;
  void *tmp ;

  {
  {
#line 542
  new_node = (struct ibv_mem_node *)((void *)0);
#line 544
  tmp = malloc(sizeof(*new_node));
#line 544
  new_node = (struct ibv_mem_node *)tmp;
  }
#line 545
  if (! new_node) {
#line 546
    return ((struct ibv_mem_node *)((void *)0));
  }
  {
#line 547
  new_node->start = cut_line;
#line 548
  new_node->end = node->end;
#line 549
  new_node->refcnt = node->refcnt;
#line 550
  node->end = cut_line - 1UL;
#line 551
  __mm_add(new_node);
  }
#line 553
  return (new_node);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *get_start_node(uintptr_t start , uintptr_t end , int inc ) 
{ 
  struct ibv_mem_node *node ;
  struct ibv_mem_node *tmp ;

  {
  {
#line 559
  tmp = (struct ibv_mem_node *)((void *)0);
#line 561
  node = __mm_find_start(start, end);
  }
#line 562
  if (node->start < start) {
    {
#line 563
    node = split_range(node, start);
    }
  } else {
    {
#line 565
    tmp = __mm_prev(node);
    }
#line 566
    if (tmp) {
#line 566
      if (tmp->refcnt == node->refcnt + inc) {
        {
#line 567
        node = merge_ranges(node, tmp);
        }
      }
    }
  }
#line 569
  return (node);
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *undo_node(struct ibv_mem_node *node , uintptr_t start ,
                                      int inc ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 579
  tmp = (struct ibv_mem_node *)((void *)0);
#line 585
  if (start > node->start) {
    {
#line 586
    tmp = split_range(node, start);
    }
#line 587
    if (tmp) {
#line 588
      node->refcnt += inc;
#line 589
      node = tmp;
    } else {
#line 591
      return ((struct ibv_mem_node *)((void *)0));
    }
  }
  {
#line 594
  tmp = __mm_prev(node);
  }
#line 595
  if (tmp) {
#line 595
    if (tmp->refcnt == node->refcnt) {
      {
#line 596
      node = merge_ranges(node, tmp);
      }
    }
  }
  {
#line 598
  tmp = __mm_next(node);
  }
#line 599
  if (tmp) {
#line 599
    if (tmp->refcnt == node->refcnt) {
      {
#line 600
      node = merge_ranges(tmp, node);
      }
    }
  }
#line 602
  return (node);
}
}
#line 605 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int ibv_madvise_range(void *base , size_t size , int advice ) 
{ 
  uintptr_t start ;
  uintptr_t end ;
  struct ibv_mem_node *node ;
  struct ibv_mem_node *tmp ;
  int inc ;
  int rolling_back ;
  int ret ;
  unsigned long range_page_size ;
  struct ibv_mem_node *tmp___0 ;

  {
#line 610
  rolling_back = 0;
#line 611
  ret = 0;
#line 614
  if (! size) {
#line 615
    return (0);
  }
#line 617
  if (huge_page_enabled) {
    {
#line 618
    range_page_size = get_page_size(base);
    }
  } else {
#line 620
    range_page_size = (unsigned long )page_size;
  }
  {
#line 622
  start = (uintptr_t )base & ~ (range_page_size - 1UL);
#line 623
  end = ((uintptr_t )(((base + size) + range_page_size) - 1) & ~ (range_page_size - 1UL)) - 1UL;
#line 626
  pthread_mutex_lock(& mm_mutex);
  }
  again: 
#line 628
  if (advice == 10) {
#line 628
    inc = 1;
  } else {
#line 628
    inc = -1;
  }
  {
#line 630
  node = get_start_node(start, end, inc);
  }
#line 631
  if (! node) {
#line 632
    ret = -1;
#line 633
    goto out;
  }
  {
#line 636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 636
    if (node) {
#line 636
      if (! (node->start <= end)) {
#line 636
        goto while_break;
      }
    } else {
#line 636
      goto while_break;
    }
#line 637
    if (node->end > end) {
      {
#line 638
      tmp___0 = split_range(node, end + 1UL);
      }
#line 638
      if (! tmp___0) {
#line 639
        ret = -1;
#line 640
        goto out;
      }
    }
#line 644
    if (inc == -1) {
#line 644
      if (node->refcnt == 1) {
#line 644
        goto _L;
      } else {
#line 644
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 644
    if (inc == 1) {
#line 644
      if (node->refcnt == 0) {
        _L: /* CIL Label */ 
#line 657
        if (start > node->start) {
          {
#line 658
          ret = madvise((void *)start, (node->end - start) + 1UL, advice);
          }
        } else {
          {
#line 661
          ret = madvise((void *)node->start, (node->end - node->start) + 1UL, advice);
          }
        }
#line 664
        if (ret) {
          {
#line 665
          node = undo_node(node, start, inc);
          }
#line 667
          if (rolling_back) {
#line 668
            goto out;
          } else
#line 667
          if (! node) {
#line 668
            goto out;
          }
#line 671
          rolling_back = 1;
#line 672
          if (advice == 10) {
#line 672
            advice = 11;
          } else {
#line 672
            advice = 10;
          }
          {
#line 674
          tmp = __mm_prev(node);
          }
#line 675
          if (! tmp) {
#line 676
            goto out;
          } else
#line 675
          if (start > tmp->end) {
#line 676
            goto out;
          }
#line 677
          end = tmp->end;
#line 678
          goto again;
        }
      }
    }
    {
#line 682
    node->refcnt += inc;
#line 683
    node = __mm_next(node);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if (node) {
    {
#line 687
    tmp = __mm_prev(node);
    }
#line 688
    if (tmp) {
#line 688
      if (node->refcnt == tmp->refcnt) {
        {
#line 689
        node = merge_ranges(node, tmp);
        }
      }
    }
  }
  out: 
#line 693
  if (rolling_back) {
#line 694
    ret = -1;
  }
  {
#line 696
  pthread_mutex_unlock(& mm_mutex);
  }
#line 698
  return (ret);
}
}
#line 701 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
int ibv_dontfork_range(void *base , size_t size ) 
{ 
  int tmp ;

  {
#line 703
  if (mm_root) {
    {
#line 704
    tmp = ibv_madvise_range(base, size, 10);
    }
#line 704
    return (tmp);
  } else {
#line 706
    too_late = 1;
#line 707
    return (0);
  }
}
}
#line 711 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
int ibv_dofork_range(void *base , size_t size ) 
{ 
  int tmp ;

  {
#line 713
  if (mm_root) {
    {
#line 714
    tmp = ibv_madvise_range(base, size, 11);
    }
#line 714
    return (tmp);
  } else {
#line 716
    too_late = 1;
#line 717
    return (0);
  }
}
}
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 184 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strndup)(char const   *__string ,
                                                                                                size_t __n )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 148 "./include/infiniband/driver.h"
char const   *ibv_get_sysfs_path(void) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/sysfs.c"
static char *sysfs_path  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/sysfs.c"
char const   *ibv_get_sysfs_path(void) 
{ 
  char *env ;
  __uid_t tmp ;
  __uid_t tmp___0 ;
  int len ;
  size_t tmp___1 ;

  {
#line 51
  env = (char *)((void *)0);
#line 53
  if (sysfs_path) {
#line 54
    return ((char const   *)sysfs_path);
  }
  {
#line 60
  tmp = getuid();
#line 60
  tmp___0 = geteuid();
  }
#line 60
  if (tmp == tmp___0) {
    {
#line 61
    env = getenv("SYSFS_PATH");
    }
  }
#line 63
  if (env) {
    {
#line 66
    sysfs_path = strndup((char const   *)env, (size_t )256);
#line 67
    tmp___1 = strlen((char const   *)sysfs_path);
#line 67
    len = (int )tmp___1;
    }
    {
#line 68
    while (1) {
      while_continue: /* CIL Label */ ;
#line 68
      if (len > 0) {
#line 68
        if (! ((int )*(sysfs_path + (len - 1)) == 47)) {
#line 68
          goto while_break;
        }
      } else {
#line 68
        goto while_break;
      }
#line 69
      len --;
#line 70
      *(sysfs_path + len) = (char )'\000';
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 73
    sysfs_path = (char *)"/sys";
  }
#line 75
  return ((char const   *)sysfs_path);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/sysfs.c"
int ibv_read_sysfs_file(char const   *dir , char const   *file , char *buf , size_t size ) 
{ 
  char *path ;
  int fd ;
  int len ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 85
  tmp = asprintf((char **/* __restrict  */)(& path), (char const   */* __restrict  */)"%s/%s",
                 dir, file);
  }
#line 85
  if (tmp < 0) {
#line 86
    return (-1);
  }
  {
#line 88
  fd = open((char const   *)path, 524288);
  }
#line 89
  if (fd < 0) {
    {
#line 90
    free((void *)path);
    }
#line 91
    return (-1);
  }
  {
#line 94
  tmp___0 = read(fd, (void *)buf, size);
#line 94
  len = (int )tmp___0;
#line 96
  close(fd);
#line 97
  free((void *)path);
  }
#line 99
  if (len > 0) {
#line 99
    if ((int )*(buf + (len - 1)) == 10) {
#line 100
      len --;
#line 100
      *(buf + len) = (char )'\000';
    }
  }
#line 102
  return (len);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 393
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) lrand48)(void) ;
#line 403
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand48)(long __seedval ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 59 "/usr/include/malloc.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) memalign)(size_t __alignment ,
                                                                                 size_t __size )  __attribute__((__malloc__)) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 64 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 270 "./include/infiniband/verbs.h"
char const   *ibv_wc_status_str(enum ibv_wc_status status ) ;
#line 908
extern struct ibv_device **ibv_get_device_list(int *num_devices ) ;
#line 918
extern void ibv_free_device_list(struct ibv_device **list ) ;
#line 923
extern char const   *ibv_get_device_name(struct ibv_device *device ) ;
#line 933
extern struct ibv_context *ibv_open_device(struct ibv_device *device ) ;
#line 938
extern int ibv_close_device(struct ibv_context *context ) ;
#line 1003
extern struct ibv_pd *ibv_alloc_pd(struct ibv_context *context ) ;
#line 1008
extern int ibv_dealloc_pd(struct ibv_pd *pd ) ;
#line 1013
extern struct ibv_mr *ibv_reg_mr(struct ibv_pd *pd , void *addr , size_t length ,
                                 int access ) ;
#line 1019
extern int ibv_dereg_mr(struct ibv_mr *mr ) ;
#line 1061
extern struct ibv_cq *ibv_create_cq(struct ibv_context *context , int cqe , void *cq_context ,
                                    struct ibv_comp_channel *channel , int comp_vector ) ;
#line 1078
extern int ibv_destroy_cq(struct ibv_cq *cq ) ;
#line 1089
extern int ibv_get_cq_event(struct ibv_comp_channel *channel , struct ibv_cq **cq ,
                            void **cq_context ) ;
#line 1105
extern void ibv_ack_cq_events(struct ibv_cq *cq , unsigned int nevents ) ;
#line 1120 "./include/infiniband/verbs.h"
__inline static int ibv_poll_cq(struct ibv_cq *cq , int num_entries , struct ibv_wc *wc ) 
{ 
  int tmp ;

  {
  {
#line 1122
  tmp = (*((cq->context)->ops.poll_cq))(cq, num_entries, wc);
  }
#line 1122
  return (tmp);
}
}
#line 1134 "./include/infiniband/verbs.h"
__inline static int ibv_req_notify_cq(struct ibv_cq *cq , int solicited_only ) 
{ 
  int tmp ;

  {
  {
#line 1136
  tmp = (*((cq->context)->ops.req_notify_cq))(cq, solicited_only);
  }
#line 1136
  return (tmp);
}
}
#line 1200
extern struct ibv_qp *ibv_create_qp(struct ibv_pd *pd , struct ibv_qp_init_attr *qp_init_attr ) ;
#line 1206
extern int ibv_modify_qp(struct ibv_qp *qp , struct ibv_qp_attr *attr , int attr_mask ) ;
#line 1227
extern int ibv_destroy_qp(struct ibv_qp *qp ) ;
#line 1235 "./include/infiniband/verbs.h"
__inline static int ibv_post_send(struct ibv_qp *qp , struct ibv_send_wr *wr , struct ibv_send_wr **bad_wr ) 
{ 
  int tmp ;

  {
  {
#line 1238
  tmp = (*((qp->context)->ops.post_send))(qp, wr, bad_wr);
  }
#line 1238
  return (tmp);
}
}
#line 1244 "./include/infiniband/verbs.h"
__inline static int ibv_post_recv(struct ibv_qp *qp , struct ibv_recv_wr *wr , struct ibv_recv_wr **bad_wr ) 
{ 
  int tmp ;

  {
  {
#line 1247
  tmp = (*((qp->context)->ops.post_recv))(qp, wr, bad_wr);
  }
#line 1247
  return (tmp);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/rc_pingpong.c"
static int page_size___0  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/rc_pingpong.c"
static int pp_connect_ctx(struct pingpong_context *ctx , int port , int my_psn , enum ibv_mtu mtu ,
                          int sl , struct pingpong_dest *dest , int sgid_idx ) 
{ 
  struct ibv_qp_attr attr ;
  int tmp ;
  int tmp___0 ;

  {
#line 84
  attr.qp_state = (enum ibv_qp_state )2;
#line 84
  attr.cur_qp_state = 0U;
#line 84
  attr.path_mtu = mtu;
#line 84
  attr.path_mig_state = 0U;
#line 84
  attr.qkey = 0U;
#line 84
  attr.rq_psn = (uint32_t )dest->psn;
#line 84
  attr.sq_psn = 0U;
#line 84
  attr.dest_qp_num = (uint32_t )dest->qpn;
#line 84
  attr.qp_access_flags = 0;
#line 84
  attr.cap.max_send_wr = 0U;
#line 84
  attr.cap.max_recv_wr = 0U;
#line 84
  attr.cap.max_send_sge = 0U;
#line 84
  attr.cap.max_recv_sge = 0U;
#line 84
  attr.cap.max_inline_data = 0U;
#line 84
  attr.ah_attr.grh.dgid.raw[0] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[1] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[2] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[3] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[4] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[5] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[6] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[7] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[8] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[9] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[10] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[11] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[12] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[13] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[14] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[15] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.flow_label = 0U;
#line 84
  attr.ah_attr.grh.sgid_index = (unsigned char)0;
#line 84
  attr.ah_attr.grh.hop_limit = (unsigned char)0;
#line 84
  attr.ah_attr.grh.traffic_class = (unsigned char)0;
#line 84
  attr.ah_attr.dlid = (uint16_t )dest->lid;
#line 84
  attr.ah_attr.sl = (uint8_t )sl;
#line 84
  attr.ah_attr.src_path_bits = (uint8_t )0;
#line 84
  attr.ah_attr.static_rate = (unsigned char)0;
#line 84
  attr.ah_attr.is_global = (uint8_t )0;
#line 84
  attr.ah_attr.port_num = (uint8_t )port;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[0] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[1] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[2] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[3] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[4] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[5] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[6] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[7] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[8] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[9] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[10] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[11] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[12] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[13] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[14] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[15] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.flow_label = 0U;
#line 84
  attr.alt_ah_attr.grh.sgid_index = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.hop_limit = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.traffic_class = (unsigned char)0;
#line 84
  attr.alt_ah_attr.dlid = (unsigned short)0;
#line 84
  attr.alt_ah_attr.sl = (unsigned char)0;
#line 84
  attr.alt_ah_attr.src_path_bits = (unsigned char)0;
#line 84
  attr.alt_ah_attr.static_rate = (unsigned char)0;
#line 84
  attr.alt_ah_attr.is_global = (unsigned char)0;
#line 84
  attr.alt_ah_attr.port_num = (unsigned char)0;
#line 84
  attr.pkey_index = (unsigned short)0;
#line 84
  attr.alt_pkey_index = (unsigned short)0;
#line 84
  attr.en_sqd_async_notify = (unsigned char)0;
#line 84
  attr.sq_draining = (unsigned char)0;
#line 84
  attr.max_rd_atomic = (unsigned char)0;
#line 84
  attr.max_dest_rd_atomic = (uint8_t )1;
#line 84
  attr.min_rnr_timer = (uint8_t )12;
#line 84
  attr.port_num = (unsigned char)0;
#line 84
  attr.timeout = (unsigned char)0;
#line 84
  attr.retry_cnt = (unsigned char)0;
#line 84
  attr.rnr_retry = (unsigned char)0;
#line 84
  attr.alt_port_num = (unsigned char)0;
#line 84
  attr.alt_timeout = (unsigned char)0;
#line 100
  if (dest->gid.global.interface_id) {
#line 101
    attr.ah_attr.is_global = (uint8_t )1;
#line 102
    attr.ah_attr.grh.hop_limit = (uint8_t )1;
#line 103
    attr.ah_attr.grh.dgid = dest->gid;
#line 104
    attr.ah_attr.grh.sgid_index = (uint8_t )sgid_idx;
  }
  {
#line 106
  tmp = ibv_modify_qp(ctx->qp, & attr, 1216897);
  }
#line 106
  if (tmp) {
    {
#line 114
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to modify QP to RTR\n");
    }
#line 115
    return (1);
  }
  {
#line 118
  attr.qp_state = (enum ibv_qp_state )3;
#line 119
  attr.timeout = (uint8_t )14;
#line 120
  attr.retry_cnt = (uint8_t )7;
#line 121
  attr.rnr_retry = (uint8_t )7;
#line 122
  attr.sq_psn = (uint32_t )my_psn;
#line 123
  attr.max_rd_atomic = (uint8_t )1;
#line 124
  tmp___0 = ibv_modify_qp(ctx->qp, & attr, 77313);
  }
#line 124
  if (tmp___0) {
    {
#line 131
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to modify QP to RTS\n");
    }
#line 132
    return (1);
  }
#line 135
  return (0);
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/rc_pingpong.c"
static struct pingpong_dest *pp_client_exch_dest(char const   *servername , int port ,
                                                 struct pingpong_dest  const  *my_dest ) 
{ 
  struct addrinfo *res ;
  struct addrinfo *t ;
  struct addrinfo hints ;
  char *service ;
  char msg[sizeof("0000:000000:000000:00000000000000000000000000000000")] ;
  int n ;
  int sockfd ;
  struct pingpong_dest *rem_dest ;
  char gid[33] ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  ssize_t tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 142
  hints.ai_flags = 0;
#line 142
  hints.ai_family = 0;
#line 142
  hints.ai_socktype = 1;
#line 142
  hints.ai_protocol = 0;
#line 142
  hints.ai_addrlen = 0U;
#line 142
  hints.ai_addr = (struct sockaddr *)0;
#line 142
  hints.ai_canonname = (char *)0;
#line 142
  hints.ai_next = (struct addrinfo *)0;
#line 149
  sockfd = -1;
#line 150
  rem_dest = (struct pingpong_dest *)((void *)0);
#line 153
  tmp = asprintf((char **/* __restrict  */)(& service), (char const   */* __restrict  */)"%d",
                 port);
  }
#line 153
  if (tmp < 0) {
#line 154
    return ((struct pingpong_dest *)((void *)0));
  }
  {
#line 156
  n = getaddrinfo((char const   */* __restrict  */)servername, (char const   */* __restrict  */)service,
                  (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 158
  if (n < 0) {
    {
#line 159
    tmp___0 = gai_strerror(n);
#line 159
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s for %s:%d\n",
            tmp___0, servername, port);
#line 160
    free((void *)service);
    }
#line 161
    return ((struct pingpong_dest *)((void *)0));
  }
#line 164
  t = res;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! t) {
#line 164
      goto while_break;
    }
    {
#line 165
    sockfd = socket(t->ai_family, t->ai_socktype, t->ai_protocol);
    }
#line 166
    if (sockfd >= 0) {
      {
#line 167
      tmp___1 = connect(sockfd, (struct sockaddr  const  */* __restrict  */)t->ai_addr,
                        t->ai_addrlen);
      }
#line 167
      if (! tmp___1) {
#line 168
        goto while_break;
      }
      {
#line 169
      close(sockfd);
#line 170
      sockfd = -1;
      }
    }
#line 164
    t = t->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 174
  freeaddrinfo(res);
#line 175
  free((void *)service);
  }
#line 177
  if (sockfd < 0) {
    {
#line 178
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t connect to %s:%d\n",
            servername, port);
    }
#line 179
    return ((struct pingpong_dest *)((void *)0));
  }
  {
#line 182
  gid_to_wire_gid(& my_dest->gid, gid);
#line 183
  sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"%04x:%06x:%06x:%s",
          my_dest->lid, my_dest->qpn, my_dest->psn, gid);
#line 185
  tmp___2 = write(sockfd, (void const   *)(msg), sizeof(msg));
  }
#line 185
  if ((unsigned long )tmp___2 != sizeof(msg)) {
    {
#line 186
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t send local address\n");
    }
#line 187
    goto out;
  }
  {
#line 190
  tmp___3 = read(sockfd, (void *)(msg), sizeof(msg));
  }
#line 190
  if ((unsigned long )tmp___3 != sizeof(msg)) {
    {
#line 191
    perror("client read");
#line 192
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t read remote address\n");
    }
#line 193
    goto out;
  }
  {
#line 196
  write(sockfd, (void const   *)"done", sizeof("done"));
#line 198
  tmp___4 = malloc(sizeof(*rem_dest));
#line 198
  rem_dest = (struct pingpong_dest *)tmp___4;
  }
#line 199
  if (! rem_dest) {
#line 200
    goto out;
  }
  {
#line 202
  sscanf((char const   */* __restrict  */)(msg), (char const   */* __restrict  */)"%x:%x:%x:%s",
         & rem_dest->lid, & rem_dest->qpn, & rem_dest->psn, gid);
#line 204
  wire_gid_to_gid((char const   *)(gid), & rem_dest->gid);
  }
  out: 
  {
#line 207
  close(sockfd);
  }
#line 208
  return (rem_dest);
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/rc_pingpong.c"
static struct pingpong_dest *pp_server_exch_dest(struct pingpong_context *ctx , int ib_port ,
                                                 enum ibv_mtu mtu , int port , int sl ,
                                                 struct pingpong_dest  const  *my_dest ,
                                                 int sgid_idx ) 
{ 
  struct addrinfo *res ;
  struct addrinfo *t ;
  struct addrinfo hints ;
  char *service ;
  char msg[sizeof("0000:000000:000000:00000000000000000000000000000000")] ;
  int n ;
  int sockfd ;
  int connfd ;
  struct pingpong_dest *rem_dest ;
  char gid[33] ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;

  {
  {
#line 218
  hints.ai_flags = 1;
#line 218
  hints.ai_family = 0;
#line 218
  hints.ai_socktype = 1;
#line 218
  hints.ai_protocol = 0;
#line 218
  hints.ai_addrlen = 0U;
#line 218
  hints.ai_addr = (struct sockaddr *)0;
#line 218
  hints.ai_canonname = (char *)0;
#line 218
  hints.ai_next = (struct addrinfo *)0;
#line 226
  sockfd = -1;
#line 227
  rem_dest = (struct pingpong_dest *)((void *)0);
#line 230
  tmp = asprintf((char **/* __restrict  */)(& service), (char const   */* __restrict  */)"%d",
                 port);
  }
#line 230
  if (tmp < 0) {
#line 231
    return ((struct pingpong_dest *)((void *)0));
  }
  {
#line 233
  n = getaddrinfo((char const   */* __restrict  */)((void *)0), (char const   */* __restrict  */)service,
                  (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 235
  if (n < 0) {
    {
#line 236
    tmp___0 = gai_strerror(n);
#line 236
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s for port %d\n",
            tmp___0, port);
#line 237
    free((void *)service);
    }
#line 238
    return ((struct pingpong_dest *)((void *)0));
  }
#line 241
  t = res;
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! t) {
#line 241
      goto while_break;
    }
    {
#line 242
    sockfd = socket(t->ai_family, t->ai_socktype, t->ai_protocol);
    }
#line 243
    if (sockfd >= 0) {
      {
#line 244
      n = 1;
#line 246
      setsockopt(sockfd, 1, 2, (void const   *)(& n), (socklen_t )sizeof(n));
#line 248
      tmp___1 = bind(sockfd, (struct sockaddr  const  */* __restrict  */)t->ai_addr,
                     t->ai_addrlen);
      }
#line 248
      if (! tmp___1) {
#line 249
        goto while_break;
      }
      {
#line 250
      close(sockfd);
#line 251
      sockfd = -1;
      }
    }
#line 241
    t = t->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 255
  freeaddrinfo(res);
#line 256
  free((void *)service);
  }
#line 258
  if (sockfd < 0) {
    {
#line 259
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t listen to port %d\n",
            port);
    }
#line 260
    return ((struct pingpong_dest *)((void *)0));
  }
  {
#line 263
  listen(sockfd, 1);
#line 264
  connfd = accept(sockfd, (struct sockaddr */* __restrict  */)((void *)0), (socklen_t */* __restrict  */)0);
#line 265
  close(sockfd);
  }
#line 266
  if (connfd < 0) {
    {
#line 267
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"accept() failed\n");
    }
#line 268
    return ((struct pingpong_dest *)((void *)0));
  }
  {
#line 271
  tmp___2 = read(connfd, (void *)(msg), sizeof(msg));
#line 271
  n = (int )tmp___2;
  }
#line 272
  if ((unsigned long )n != sizeof(msg)) {
    {
#line 273
    perror("server read");
#line 274
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d/%d: Couldn\'t read remote address\n",
            n, (int )sizeof(msg));
    }
#line 275
    goto out;
  }
  {
#line 278
  tmp___3 = malloc(sizeof(*rem_dest));
#line 278
  rem_dest = (struct pingpong_dest *)tmp___3;
  }
#line 279
  if (! rem_dest) {
#line 280
    goto out;
  }
  {
#line 282
  sscanf((char const   */* __restrict  */)(msg), (char const   */* __restrict  */)"%x:%x:%x:%s",
         & rem_dest->lid, & rem_dest->qpn, & rem_dest->psn, gid);
#line 284
  wire_gid_to_gid((char const   *)(gid), & rem_dest->gid);
#line 286
  tmp___4 = pp_connect_ctx(ctx, ib_port, (int )my_dest->psn, mtu, sl, rem_dest, sgid_idx);
  }
#line 286
  if (tmp___4) {
    {
#line 288
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t connect to remote QP\n");
#line 289
    free((void *)rem_dest);
#line 290
    rem_dest = (struct pingpong_dest *)((void *)0);
    }
#line 291
    goto out;
  }
  {
#line 295
  gid_to_wire_gid(& my_dest->gid, gid);
#line 296
  sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"%04x:%06x:%06x:%s",
          my_dest->lid, my_dest->qpn, my_dest->psn, gid);
#line 298
  tmp___5 = write(connfd, (void const   *)(msg), sizeof(msg));
  }
#line 298
  if ((unsigned long )tmp___5 != sizeof(msg)) {
    {
#line 299
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t send local address\n");
#line 300
    free((void *)rem_dest);
#line 301
    rem_dest = (struct pingpong_dest *)((void *)0);
    }
#line 302
    goto out;
  }
  {
#line 305
  read(connfd, (void *)(msg), sizeof(msg));
  }
  out: 
  {
#line 308
  close(connfd);
  }
#line 309
  return (rem_dest);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/rc_pingpong.c"
static struct pingpong_context *pp_init_ctx(struct ibv_device *ib_dev , int size ,
                                            int rx_depth , int port , int use_event ) 
{ 
  struct pingpong_context *ctx ;
  void *tmp ;
  char const   *tmp___0 ;
  struct ibv_qp_init_attr attr ;
  struct ibv_qp_attr attr___0 ;
  int tmp___1 ;

  {
  {
#line 318
  tmp = calloc((size_t )1, sizeof(*ctx));
#line 318
  ctx = (struct pingpong_context *)tmp;
  }
#line 319
  if (! ctx) {
#line 320
    return ((struct pingpong_context *)((void *)0));
  }
  {
#line 322
  ctx->size = size;
#line 323
  ctx->rx_depth = rx_depth;
#line 325
  ctx->buf = memalign((size_t )page_size___0, (size_t )size);
  }
#line 326
  if (! ctx->buf) {
    {
#line 327
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t allocate work buf.\n");
    }
#line 328
    goto clean_ctx;
  }
  {
#line 332
  memset(ctx->buf, 123, (size_t )size);
#line 334
  ctx->context = ibv_open_device(ib_dev);
  }
#line 335
  if (! ctx->context) {
    {
#line 336
    tmp___0 = ibv_get_device_name(ib_dev);
#line 336
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t get context for %s\n",
            tmp___0);
    }
#line 338
    goto clean_buffer;
  }
#line 341
  if (use_event) {
    {
#line 342
    ctx->channel = ibv_create_comp_channel(ctx->context);
    }
#line 343
    if (! ctx->channel) {
      {
#line 344
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t create completion channel\n");
      }
#line 345
      goto clean_device;
    }
  } else {
#line 348
    ctx->channel = (struct ibv_comp_channel *)((void *)0);
  }
  {
#line 350
  ctx->pd = ibv_alloc_pd(ctx->context);
  }
#line 351
  if (! ctx->pd) {
    {
#line 352
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t allocate PD\n");
    }
#line 353
    goto clean_comp_channel;
  }
  {
#line 356
  ctx->mr = ibv_reg_mr(ctx->pd, ctx->buf, (size_t )size, 1);
  }
#line 357
  if (! ctx->mr) {
    {
#line 358
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t register MR\n");
    }
#line 359
    goto clean_pd;
  }
  {
#line 362
  ctx->cq = ibv_create_cq(ctx->context, rx_depth + 1, (void *)0, ctx->channel, 0);
  }
#line 364
  if (! ctx->cq) {
    {
#line 365
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t create CQ\n");
    }
#line 366
    goto clean_mr;
  }
  {
#line 370
  attr.qp_context = (void *)0;
#line 370
  attr.send_cq = ctx->cq;
#line 370
  attr.recv_cq = ctx->cq;
#line 370
  attr.srq = (struct ibv_srq *)0;
#line 370
  attr.cap.max_send_wr = (uint32_t )1;
#line 370
  attr.cap.max_recv_wr = (uint32_t )rx_depth;
#line 370
  attr.cap.max_send_sge = (uint32_t )1;
#line 370
  attr.cap.max_recv_sge = (uint32_t )1;
#line 370
  attr.cap.max_inline_data = 0U;
#line 370
  attr.qp_type = (enum ibv_qp_type )2;
#line 370
  attr.sq_sig_all = 0;
#line 382
  ctx->qp = ibv_create_qp(ctx->pd, & attr);
  }
#line 383
  if (! ctx->qp) {
    {
#line 384
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t create QP\n");
    }
#line 385
    goto clean_cq;
  }
  {
#line 390
  attr___0.qp_state = (enum ibv_qp_state )1;
#line 390
  attr___0.cur_qp_state = 0U;
#line 390
  attr___0.path_mtu = 0U;
#line 390
  attr___0.path_mig_state = 0U;
#line 390
  attr___0.qkey = 0U;
#line 390
  attr___0.rq_psn = 0U;
#line 390
  attr___0.sq_psn = 0U;
#line 390
  attr___0.dest_qp_num = 0U;
#line 390
  attr___0.qp_access_flags = 0;
#line 390
  attr___0.cap.max_send_wr = 0U;
#line 390
  attr___0.cap.max_recv_wr = 0U;
#line 390
  attr___0.cap.max_send_sge = 0U;
#line 390
  attr___0.cap.max_recv_sge = 0U;
#line 390
  attr___0.cap.max_inline_data = 0U;
#line 390
  attr___0.ah_attr.grh.dgid.raw[0] = (unsigned char)0;
#line 390
  attr___0.ah_attr.grh.dgid.raw[1] = (unsigned char)0;
#line 390
  attr___0.ah_attr.grh.dgid.raw[2] = (unsigned char)0;
#line 390
  attr___0.ah_attr.grh.dgid.raw[3] = (unsigned char)0;
#line 390
  attr___0.ah_attr.grh.dgid.raw[4] = (unsigned char)0;
#line 390
  attr___0.ah_attr.grh.dgid.raw[5] = (unsigned char)0;
#line 390
  attr___0.ah_attr.grh.dgid.raw[6] = (unsigned char)0;
#line 390
  attr___0.ah_attr.grh.dgid.raw[7] = (unsigned char)0;
#line 390
  attr___0.ah_attr.grh.dgid.raw[8] = (unsigned char)0;
#line 390
  attr___0.ah_attr.grh.dgid.raw[9] = (unsigned char)0;
#line 390
  attr___0.ah_attr.grh.dgid.raw[10] = (unsigned char)0;
#line 390
  attr___0.ah_attr.grh.dgid.raw[11] = (unsigned char)0;
#line 390
  attr___0.ah_attr.grh.dgid.raw[12] = (unsigned char)0;
#line 390
  attr___0.ah_attr.grh.dgid.raw[13] = (unsigned char)0;
#line 390
  attr___0.ah_attr.grh.dgid.raw[14] = (unsigned char)0;
#line 390
  attr___0.ah_attr.grh.dgid.raw[15] = (unsigned char)0;
#line 390
  attr___0.ah_attr.grh.flow_label = 0U;
#line 390
  attr___0.ah_attr.grh.sgid_index = (unsigned char)0;
#line 390
  attr___0.ah_attr.grh.hop_limit = (unsigned char)0;
#line 390
  attr___0.ah_attr.grh.traffic_class = (unsigned char)0;
#line 390
  attr___0.ah_attr.dlid = (unsigned short)0;
#line 390
  attr___0.ah_attr.sl = (unsigned char)0;
#line 390
  attr___0.ah_attr.src_path_bits = (unsigned char)0;
#line 390
  attr___0.ah_attr.static_rate = (unsigned char)0;
#line 390
  attr___0.ah_attr.is_global = (unsigned char)0;
#line 390
  attr___0.ah_attr.port_num = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.grh.dgid.raw[0] = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.grh.dgid.raw[1] = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.grh.dgid.raw[2] = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.grh.dgid.raw[3] = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.grh.dgid.raw[4] = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.grh.dgid.raw[5] = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.grh.dgid.raw[6] = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.grh.dgid.raw[7] = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.grh.dgid.raw[8] = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.grh.dgid.raw[9] = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.grh.dgid.raw[10] = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.grh.dgid.raw[11] = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.grh.dgid.raw[12] = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.grh.dgid.raw[13] = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.grh.dgid.raw[14] = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.grh.dgid.raw[15] = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.grh.flow_label = 0U;
#line 390
  attr___0.alt_ah_attr.grh.sgid_index = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.grh.hop_limit = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.grh.traffic_class = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.dlid = (unsigned short)0;
#line 390
  attr___0.alt_ah_attr.sl = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.src_path_bits = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.static_rate = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.is_global = (unsigned char)0;
#line 390
  attr___0.alt_ah_attr.port_num = (unsigned char)0;
#line 390
  attr___0.pkey_index = (uint16_t )0;
#line 390
  attr___0.alt_pkey_index = (unsigned short)0;
#line 390
  attr___0.en_sqd_async_notify = (unsigned char)0;
#line 390
  attr___0.sq_draining = (unsigned char)0;
#line 390
  attr___0.max_rd_atomic = (unsigned char)0;
#line 390
  attr___0.max_dest_rd_atomic = (unsigned char)0;
#line 390
  attr___0.min_rnr_timer = (unsigned char)0;
#line 390
  attr___0.port_num = (uint8_t )port;
#line 390
  attr___0.timeout = (unsigned char)0;
#line 390
  attr___0.retry_cnt = (unsigned char)0;
#line 390
  attr___0.rnr_retry = (unsigned char)0;
#line 390
  attr___0.alt_port_num = (unsigned char)0;
#line 390
  attr___0.alt_timeout = (unsigned char)0;
#line 397
  tmp___1 = ibv_modify_qp(ctx->qp, & attr___0, 57);
  }
#line 397
  if (tmp___1) {
    {
#line 402
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to modify QP to INIT\n");
    }
#line 403
    goto clean_qp;
  }
#line 407
  return (ctx);
  clean_qp: 
  {
#line 410
  ibv_destroy_qp(ctx->qp);
  }
  clean_cq: 
  {
#line 413
  ibv_destroy_cq(ctx->cq);
  }
  clean_mr: 
  {
#line 416
  ibv_dereg_mr(ctx->mr);
  }
  clean_pd: 
  {
#line 419
  ibv_dealloc_pd(ctx->pd);
  }
  clean_comp_channel: 
#line 422
  if (ctx->channel) {
    {
#line 423
    ibv_destroy_comp_channel(ctx->channel);
    }
  }
  clean_device: 
  {
#line 426
  ibv_close_device(ctx->context);
  }
  clean_buffer: 
  {
#line 429
  free(ctx->buf);
  }
  clean_ctx: 
  {
#line 432
  free((void *)ctx);
  }
#line 434
  return ((struct pingpong_context *)((void *)0));
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/rc_pingpong.c"
int pp_close_ctx(struct pingpong_context *ctx ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 439
  tmp = ibv_destroy_qp(ctx->qp);
  }
#line 439
  if (tmp) {
    {
#line 440
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t destroy QP\n");
    }
#line 441
    return (1);
  }
  {
#line 444
  tmp___0 = ibv_destroy_cq(ctx->cq);
  }
#line 444
  if (tmp___0) {
    {
#line 445
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t destroy CQ\n");
    }
#line 446
    return (1);
  }
  {
#line 449
  tmp___1 = ibv_dereg_mr(ctx->mr);
  }
#line 449
  if (tmp___1) {
    {
#line 450
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t deregister MR\n");
    }
#line 451
    return (1);
  }
  {
#line 454
  tmp___2 = ibv_dealloc_pd(ctx->pd);
  }
#line 454
  if (tmp___2) {
    {
#line 455
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t deallocate PD\n");
    }
#line 456
    return (1);
  }
#line 459
  if (ctx->channel) {
    {
#line 460
    tmp___3 = ibv_destroy_comp_channel(ctx->channel);
    }
#line 460
    if (tmp___3) {
      {
#line 461
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t destroy completion channel\n");
      }
#line 462
      return (1);
    }
  }
  {
#line 466
  tmp___4 = ibv_close_device(ctx->context);
  }
#line 466
  if (tmp___4) {
    {
#line 467
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t release context\n");
    }
#line 468
    return (1);
  }
  {
#line 471
  free(ctx->buf);
#line 472
  free((void *)ctx);
  }
#line 474
  return (0);
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/rc_pingpong.c"
static int pp_post_recv(struct pingpong_context *ctx , int n ) 
{ 
  struct ibv_sge list ;
  struct ibv_recv_wr wr ;
  struct ibv_recv_wr *bad_wr ;
  int i ;
  int tmp ;

  {
#line 479
  list.addr = (uintptr_t )ctx->buf;
#line 479
  list.length = (uint32_t )ctx->size;
#line 479
  list.lkey = (ctx->mr)->lkey;
#line 484
  wr.wr_id = (uint64_t )1;
#line 484
  wr.next = (struct ibv_recv_wr *)0;
#line 484
  wr.sg_list = & list;
#line 484
  wr.num_sge = 1;
#line 492
  i = 0;
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 492
    if (! (i < n)) {
#line 492
      goto while_break;
    }
    {
#line 493
    tmp = ibv_post_recv(ctx->qp, & wr, & bad_wr);
    }
#line 493
    if (tmp) {
#line 494
      goto while_break;
    }
#line 492
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 496
  return (i);
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/rc_pingpong.c"
static int pp_post_send(struct pingpong_context *ctx ) 
{ 
  struct ibv_sge list ;
  struct ibv_send_wr wr ;
  struct ibv_send_wr *bad_wr ;
  int tmp ;

  {
  {
#line 501
  list.addr = (uintptr_t )ctx->buf;
#line 501
  list.length = (uint32_t )ctx->size;
#line 501
  list.lkey = (ctx->mr)->lkey;
#line 506
  wr.wr_id = (uint64_t )2;
#line 506
  wr.next = (struct ibv_send_wr *)0;
#line 506
  wr.sg_list = & list;
#line 506
  wr.num_sge = 1;
#line 506
  wr.opcode = (enum ibv_wr_opcode )2;
#line 506
  wr.send_flags = 2;
#line 506
  wr.imm_data = 0U;
#line 506
  wr.wr.atomic.remote_addr = 0UL;
#line 506
  wr.wr.atomic.compare_add = 0UL;
#line 506
  wr.wr.atomic.swap = 0UL;
#line 506
  wr.wr.atomic.rkey = 0U;
#line 515
  tmp = ibv_post_send(ctx->qp, & wr, & bad_wr);
  }
#line 515
  return (tmp);
}
}
#line 518 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/rc_pingpong.c"
static void usage(char const   *argv0 ) 
{ 


  {
  {
#line 520
  printf((char const   */* __restrict  */)"Usage:\n");
#line 521
  printf((char const   */* __restrict  */)"  %s            start a server and wait for connection\n",
         argv0);
#line 522
  printf((char const   */* __restrict  */)"  %s <host>     connect to server at <host>\n",
         argv0);
#line 523
  printf((char const   */* __restrict  */)"\n");
#line 524
  printf((char const   */* __restrict  */)"Options:\n");
#line 525
  printf((char const   */* __restrict  */)"  -p, --port=<port>      listen on/connect to port <port> (default 18515)\n");
#line 526
  printf((char const   */* __restrict  */)"  -d, --ib-dev=<dev>     use IB device <dev> (default first device found)\n");
#line 527
  printf((char const   */* __restrict  */)"  -i, --ib-port=<port>   use port <port> of IB device (default 1)\n");
#line 528
  printf((char const   */* __restrict  */)"  -s, --size=<size>      size of message to exchange (default 4096)\n");
#line 529
  printf((char const   */* __restrict  */)"  -m, --mtu=<size>       path MTU (default 1024)\n");
#line 530
  printf((char const   */* __restrict  */)"  -r, --rx-depth=<dep>   number of receives to post at a time (default 500)\n");
#line 531
  printf((char const   */* __restrict  */)"  -n, --iters=<iters>    number of exchanges (default 1000)\n");
#line 532
  printf((char const   */* __restrict  */)"  -l, --sl=<sl>          service level value\n");
#line 533
  printf((char const   */* __restrict  */)"  -e, --events           sleep on CQ events (default poll)\n");
#line 534
  printf((char const   */* __restrict  */)"  -g, --gid-idx=<gid index> local port gid index\n");
  }
#line 535
  return;
}
}
#line 566
int main(int argc , char **argv ) ;
#line 566 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/rc_pingpong.c"
static struct option long_options[11]  = 
#line 566
  {      {"port", 1, (int *)0, 'p'}, 
        {"ib-dev", 1, (int *)0, 'd'}, 
        {"ib-port", 1, (int *)0, 'i'}, 
        {"size", 1, (int *)0, 's'}, 
        {"mtu", 1, (int *)0, 'm'}, 
        {"rx-depth", 1, (int *)0, 'r'}, 
        {"iters", 1, (int *)0, 'n'}, 
        {"sl", 1, (int *)0, 'l'}, 
        {"events", 0, (int *)0, 'e'}, 
        {"gid-idx", 1, (int *)0, 'g'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 537 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/rc_pingpong.c"
int main(int argc , char **argv ) 
{ 
  struct ibv_device **dev_list ;
  struct ibv_device *ib_dev ;
  struct pingpong_context *ctx ;
  struct pingpong_dest my_dest ;
  struct pingpong_dest *rem_dest ;
  struct timeval start ;
  struct timeval end ;
  char *ib_devname ;
  char *servername ;
  int port ;
  int ib_port ;
  int size ;
  enum ibv_mtu mtu ;
  int rx_depth ;
  int iters ;
  int use_event ;
  int routs ;
  int rcnt ;
  int scnt ;
  int num_cq_events ;
  int sl ;
  int gidx ;
  char gid[33] ;
  __pid_t tmp ;
  time_t tmp___0 ;
  int c ;
  long tmp___1 ;
  char const   *__old ;
  size_t __len ;
  size_t tmp___2 ;
  char *__new ;
  void *tmp___3 ;
  void *tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  char const   *__old___0 ;
  size_t __len___0 ;
  size_t tmp___12 ;
  char *__new___0 ;
  void *tmp___13 ;
  void *tmp___14 ;
  long tmp___15 ;
  int i ;
  char const   *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  long tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  struct ibv_cq *ev_cq ;
  void *ev_ctx ;
  int tmp___25 ;
  int tmp___26 ;
  struct ibv_wc wc[2] ;
  int ne ;
  int i___0 ;
  char const   *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  float usec ;
  long long bytes ;
  int tmp___31 ;

  {
  {
#line 545
  ib_devname = (char *)((void *)0);
#line 546
  servername = (char *)((void *)0);
#line 547
  port = 18515;
#line 548
  ib_port = 1;
#line 549
  size = 4096;
#line 550
  mtu = (enum ibv_mtu )3;
#line 551
  rx_depth = 500;
#line 552
  iters = 1000;
#line 553
  use_event = 0;
#line 556
  num_cq_events = 0;
#line 557
  sl = 0;
#line 558
  gidx = -1;
#line 561
  tmp = getpid();
#line 561
  tmp___0 = time((time_t *)((void *)0));
#line 561
  srand48((time_t )tmp * tmp___0);
  }
  {
#line 563
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 580
    c = getopt_long(argc, (char * const  *)argv, "p:d:i:s:m:r:n:l:eg:", (struct option  const  *)(long_options),
                    (int *)((void *)0));
    }
#line 582
    if (c == -1) {
#line 583
      goto while_break;
    }
    {
#line 586
    if (c == 112) {
#line 586
      goto case_112;
    }
#line 594
    if (c == 100) {
#line 594
      goto case_100;
    }
#line 598
    if (c == 105) {
#line 598
      goto case_105;
    }
#line 606
    if (c == 115) {
#line 606
      goto case_115;
    }
#line 610
    if (c == 109) {
#line 610
      goto case_109;
    }
#line 618
    if (c == 114) {
#line 618
      goto case_114;
    }
#line 622
    if (c == 110) {
#line 622
      goto case_110;
    }
#line 626
    if (c == 108) {
#line 626
      goto case_108;
    }
#line 630
    if (c == 101) {
#line 630
      goto case_101;
    }
#line 634
    if (c == 103) {
#line 634
      goto case_103;
    }
#line 638
    goto switch_default;
    case_112: /* CIL Label */ 
    {
#line 587
    tmp___1 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                     0);
#line 587
    port = (int )tmp___1;
    }
#line 588
    if (port < 0) {
      {
#line 589
      usage((char const   *)*(argv + 0));
      }
#line 590
      return (1);
    } else
#line 588
    if (port > 65535) {
      {
#line 589
      usage((char const   *)*(argv + 0));
      }
#line 590
      return (1);
    }
#line 592
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 595
    __old = (char const   *)optarg;
#line 595
    tmp___2 = strlen(__old);
#line 595
    __len = tmp___2 + 1UL;
#line 595
    tmp___3 = __builtin_alloca(__len);
#line 595
    __new = (char *)tmp___3;
#line 595
    tmp___4 = memcpy((void */* __restrict  */)__new, (void const   */* __restrict  */)__old,
                     __len);
#line 595
    ib_devname = (char *)tmp___4;
    }
#line 596
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 599
    tmp___5 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                     0);
#line 599
    ib_port = (int )tmp___5;
    }
#line 600
    if (ib_port < 0) {
      {
#line 601
      usage((char const   *)*(argv + 0));
      }
#line 602
      return (1);
    }
#line 604
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 607
    tmp___6 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                     0);
#line 607
    size = (int )tmp___6;
    }
#line 608
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 611
    tmp___7 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                     0);
#line 611
    mtu = pp_mtu_to_enum((int )tmp___7);
    }
#line 612
    if ((unsigned int )mtu < 0U) {
      {
#line 613
      usage((char const   *)*(argv + 0));
      }
#line 614
      return (1);
    }
#line 616
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 619
    tmp___8 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                     0);
#line 619
    rx_depth = (int )tmp___8;
    }
#line 620
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 623
    tmp___9 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                     0);
#line 623
    iters = (int )tmp___9;
    }
#line 624
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 627
    tmp___10 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                      0);
#line 627
    sl = (int )tmp___10;
    }
#line 628
    goto switch_break;
    case_101: /* CIL Label */ 
#line 631
    use_event ++;
#line 632
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 635
    tmp___11 = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                      0);
#line 635
    gidx = (int )tmp___11;
    }
#line 636
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 639
    usage((char const   *)*(argv + 0));
    }
#line 640
    return (1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 644
  if (optind == argc - 1) {
    {
#line 645
    __old___0 = (char const   *)*(argv + optind);
#line 645
    tmp___12 = strlen(__old___0);
#line 645
    __len___0 = tmp___12 + 1UL;
#line 645
    tmp___13 = __builtin_alloca(__len___0);
#line 645
    __new___0 = (char *)tmp___13;
#line 645
    tmp___14 = memcpy((void */* __restrict  */)__new___0, (void const   */* __restrict  */)__old___0,
                      __len___0);
#line 645
    servername = (char *)tmp___14;
    }
  } else
#line 646
  if (optind < argc) {
    {
#line 647
    usage((char const   *)*(argv + 0));
    }
#line 648
    return (1);
  }
  {
#line 651
  tmp___15 = sysconf(30);
#line 651
  page_size___0 = (int )tmp___15;
#line 653
  dev_list = ibv_get_device_list((int *)((void *)0));
  }
#line 654
  if (! dev_list) {
    {
#line 655
    perror("Failed to get IB devices list");
    }
#line 656
    return (1);
  }
#line 659
  if (! ib_devname) {
#line 660
    ib_dev = *dev_list;
#line 661
    if (! ib_dev) {
      {
#line 662
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No IB devices found\n");
      }
#line 663
      return (1);
    }
  } else {
#line 667
    i = 0;
    {
#line 667
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 667
      if (! *(dev_list + i)) {
#line 667
        goto while_break___0;
      }
      {
#line 668
      tmp___16 = ibv_get_device_name(*(dev_list + i));
#line 668
      tmp___17 = strcmp(tmp___16, (char const   *)ib_devname);
      }
#line 668
      if (! tmp___17) {
#line 669
        goto while_break___0;
      }
#line 667
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 670
    ib_dev = *(dev_list + i);
#line 671
    if (! ib_dev) {
      {
#line 672
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"IB device %s not found\n",
              ib_devname);
      }
#line 673
      return (1);
    }
  }
  {
#line 677
  ctx = pp_init_ctx(ib_dev, size, rx_depth, ib_port, use_event);
  }
#line 678
  if (! ctx) {
#line 679
    return (1);
  }
  {
#line 681
  routs = pp_post_recv(ctx, ctx->rx_depth);
  }
#line 682
  if (routs < ctx->rx_depth) {
    {
#line 683
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t post receive (%d)\n",
            routs);
    }
#line 684
    return (1);
  }
#line 687
  if (use_event) {
    {
#line 688
    tmp___18 = ibv_req_notify_cq(ctx->cq, 0);
    }
#line 688
    if (tmp___18) {
      {
#line 689
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t request CQ notification\n");
      }
#line 690
      return (1);
    }
  }
  {
#line 694
  tmp___19 = pp_get_port_info(ctx->context, ib_port, & ctx->portinfo);
  }
#line 694
  if (tmp___19) {
    {
#line 695
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t get port info\n");
    }
#line 696
    return (1);
  }
#line 699
  my_dest.lid = (int )ctx->portinfo.lid;
#line 700
  if ((int )ctx->portinfo.link_layer != 2) {
#line 700
    if (! my_dest.lid) {
      {
#line 702
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t get local LID\n");
      }
#line 703
      return (1);
    }
  }
#line 706
  if (gidx >= 0) {
    {
#line 707
    tmp___20 = ibv_query_gid(ctx->context, (uint8_t )ib_port, gidx, & my_dest.gid);
    }
#line 707
    if (tmp___20) {
      {
#line 708
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t read sgid of index %d\n",
              gidx);
      }
#line 709
      return (1);
    }
  } else {
    {
#line 712
    memset((void *)(& my_dest.gid), 0, sizeof(my_dest.gid));
    }
  }
  {
#line 714
  my_dest.qpn = (int )(ctx->qp)->qp_num;
#line 715
  tmp___21 = lrand48();
#line 715
  my_dest.psn = (int )(tmp___21 & 16777215L);
#line 716
  inet_ntop(10, (void const   */* __restrict  */)(& my_dest.gid), (char */* __restrict  */)(gid),
            (socklen_t )sizeof(gid));
#line 717
  printf((char const   */* __restrict  */)"  local address:  LID 0x%04x, QPN 0x%06x, PSN 0x%06x, GID %s\n",
         my_dest.lid, my_dest.qpn, my_dest.psn, gid);
  }
#line 721
  if (servername) {
    {
#line 722
    rem_dest = pp_client_exch_dest((char const   *)servername, port, (struct pingpong_dest  const  *)(& my_dest));
    }
  } else {
    {
#line 724
    rem_dest = pp_server_exch_dest(ctx, ib_port, mtu, port, sl, (struct pingpong_dest  const  *)(& my_dest),
                                   gidx);
    }
  }
#line 727
  if (! rem_dest) {
#line 728
    return (1);
  }
  {
#line 730
  inet_ntop(10, (void const   */* __restrict  */)(& rem_dest->gid), (char */* __restrict  */)(gid),
            (socklen_t )sizeof(gid));
#line 731
  printf((char const   */* __restrict  */)"  remote address: LID 0x%04x, QPN 0x%06x, PSN 0x%06x, GID %s\n",
         rem_dest->lid, rem_dest->qpn, rem_dest->psn, gid);
  }
#line 734
  if (servername) {
    {
#line 735
    tmp___22 = pp_connect_ctx(ctx, ib_port, my_dest.psn, mtu, sl, rem_dest, gidx);
    }
#line 735
    if (tmp___22) {
#line 737
      return (1);
    }
  }
#line 739
  ctx->pending = 1;
#line 741
  if (servername) {
    {
#line 742
    tmp___23 = pp_post_send(ctx);
    }
#line 742
    if (tmp___23) {
      {
#line 743
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t post send\n");
      }
#line 744
      return (1);
    }
#line 746
    ctx->pending |= 2;
  }
  {
#line 749
  tmp___24 = gettimeofday((struct timeval */* __restrict  */)(& start), (__timezone_ptr_t )((void *)0));
  }
#line 749
  if (tmp___24) {
    {
#line 750
    perror("gettimeofday");
    }
#line 751
    return (1);
  }
#line 754
  scnt = 0;
#line 754
  rcnt = scnt;
  {
#line 755
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 755
    if (! (rcnt < iters)) {
#line 755
      if (! (scnt < iters)) {
#line 755
        goto while_break___1;
      }
    }
#line 756
    if (use_event) {
      {
#line 760
      tmp___25 = ibv_get_cq_event(ctx->channel, & ev_cq, & ev_ctx);
      }
#line 760
      if (tmp___25) {
        {
#line 761
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to get cq_event\n");
        }
#line 762
        return (1);
      }
#line 765
      num_cq_events ++;
#line 767
      if ((unsigned long )ev_cq != (unsigned long )ctx->cq) {
        {
#line 768
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CQ event for unknown CQ %p\n",
                ev_cq);
        }
#line 769
        return (1);
      }
      {
#line 772
      tmp___26 = ibv_req_notify_cq(ctx->cq, 0);
      }
#line 772
      if (tmp___26) {
        {
#line 773
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t request CQ notification\n");
        }
#line 774
        return (1);
      }
    }
    {
#line 782
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 783
      ne = ibv_poll_cq(ctx->cq, 2, wc);
      }
#line 784
      if (ne < 0) {
        {
#line 785
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"poll CQ failed %d\n",
                ne);
        }
#line 786
        return (1);
      }
#line 782
      if (! use_event) {
#line 782
        if (! (ne < 1)) {
#line 782
          goto while_break___2;
        }
      } else {
#line 782
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 791
    i___0 = 0;
    {
#line 791
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 791
      if (! (i___0 < ne)) {
#line 791
        goto while_break___3;
      }
#line 792
      if ((unsigned int )wc[i___0].status != 0U) {
        {
#line 793
        tmp___27 = ibv_wc_status_str(wc[i___0].status);
#line 793
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed status %s (%d) for wr_id %d\n",
                tmp___27, (unsigned int )wc[i___0].status, (int )wc[i___0].wr_id);
        }
#line 796
        return (1);
      }
      {
#line 800
      if ((int )wc[i___0].wr_id == 2) {
#line 800
        goto case_2;
      }
#line 804
      if ((int )wc[i___0].wr_id == 1) {
#line 804
        goto case_1;
      }
#line 818
      goto switch_default___0;
      case_2: /* CIL Label */ 
#line 801
      scnt ++;
#line 802
      goto switch_break___0;
      case_1: /* CIL Label */ 
#line 805
      routs --;
#line 805
      if (routs <= 1) {
        {
#line 806
        tmp___28 = pp_post_recv(ctx, ctx->rx_depth - routs);
#line 806
        routs += tmp___28;
        }
#line 807
        if (routs < ctx->rx_depth) {
          {
#line 808
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t post receive (%d)\n",
                  routs);
          }
#line 811
          return (1);
        }
      }
#line 815
      rcnt ++;
#line 816
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 819
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Completion for unknown wr_id %d\n",
              (int )wc[i___0].wr_id);
      }
#line 821
      return (1);
      switch_break___0: /* CIL Label */ ;
      }
#line 824
      ctx->pending &= ~ ((int )wc[i___0].wr_id);
#line 825
      if (scnt < iters) {
#line 825
        if (! ctx->pending) {
          {
#line 826
          tmp___29 = pp_post_send(ctx);
          }
#line 826
          if (tmp___29) {
            {
#line 827
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t post send\n");
            }
#line 828
            return (1);
          }
#line 830
          ctx->pending = 3;
        }
      }
#line 791
      i___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 837
  tmp___30 = gettimeofday((struct timeval */* __restrict  */)(& end), (__timezone_ptr_t )((void *)0));
  }
#line 837
  if (tmp___30) {
    {
#line 838
    perror("gettimeofday");
    }
#line 839
    return (1);
  }
  {
#line 843
  usec = (float )((end.tv_sec - start.tv_sec) * 1000000L + (end.tv_usec - start.tv_usec));
#line 845
  bytes = ((long long )size * (long long )iters) * 2LL;
#line 847
  printf((char const   */* __restrict  */)"%lld bytes in %.2f seconds = %.2f Mbit/sec\n",
         bytes, (double )usec / 1000000., ((double )bytes * 8.) / (double )usec);
#line 849
  printf((char const   */* __restrict  */)"%d iters in %.2f seconds = %.2f usec/iter\n",
         iters, (double )usec / 1000000., (double )(usec / (float )iters));
#line 853
  ibv_ack_cq_events(ctx->cq, (unsigned int )num_cq_events);
#line 855
  tmp___31 = pp_close_ctx(ctx);
  }
#line 855
  if (tmp___31) {
#line 856
    return (1);
  }
  {
#line 858
  ibv_free_device_list(dev_list);
#line 859
  free((void *)rem_dest);
  }
#line 861
  return (0);
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 557
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strsep)(char ** __restrict  __stringp ,
                                                                                                 char const   * __restrict  __delim ) ;
#line 678 "/usr/include/stdio.h"
extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                         FILE * __restrict  __stream ) ;
#line 56 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *dlopen(char const   *__file , int __mode ) ;
#line 60
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) dlclose)(void *__handle ) ;
#line 82
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dlerror)(void) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit *__rlimits ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 61 "./include/infiniband/driver.h"
void ibv_register_driver(char const   *name , struct ibv_device *(*init_func)(char const   *uverbs_sys_path ,
                                                                              int abi_version ) ) ;
#line 62
void verbs_register_driver(char const   *name , struct verbs_device *(*init_func)(char const   *uverbs_sys_path ,
                                                                                  int abi_version ) ) ;
#line 80 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/ibverbs.h"
int __attribute__((__visibility__("hidden")))  abi_ver  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_sysfs_dev *sysfs_dev_list  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver_name *driver_name_list  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver *head_driver  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver *tail_driver  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static int find_sysfs_devs(void) 
{ 
  char class_path[256] ;
  DIR *class_dir ;
  struct dirent *dent ;
  struct ibv_sysfs_dev *sysfs_dev ;
  char value[8] ;
  int ret ;
  char const   *tmp ;
  struct stat buf ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;

  {
  {
#line 86
  sysfs_dev = (struct ibv_sysfs_dev *)((void *)0);
#line 88
  ret = 0;
#line 90
  tmp = ibv_get_sysfs_path();
#line 90
  snprintf((char */* __restrict  */)(class_path), sizeof(class_path), (char const   */* __restrict  */)"%s/class/infiniband_verbs",
           tmp);
#line 93
  class_dir = opendir((char const   *)(class_path));
  }
#line 94
  if (! class_dir) {
#line 95
    return (38);
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    dent = readdir(class_dir);
    }
#line 97
    if (! dent) {
#line 97
      goto while_break;
    }
#line 100
    if ((int )dent->d_name[0] == 46) {
#line 101
      goto while_continue;
    }
#line 103
    if (! sysfs_dev) {
      {
#line 104
      tmp___0 = malloc(sizeof(*sysfs_dev));
#line 104
      sysfs_dev = (struct ibv_sysfs_dev *)tmp___0;
      }
    }
#line 105
    if (! sysfs_dev) {
#line 106
      ret = 12;
#line 107
      goto out;
    }
    {
#line 110
    snprintf((char */* __restrict  */)(sysfs_dev->sysfs_path), sizeof(sysfs_dev->sysfs_path),
             (char const   */* __restrict  */)"%s/%s", class_path, dent->d_name);
#line 113
    tmp___1 = stat((char const   */* __restrict  */)(sysfs_dev->sysfs_path), (struct stat */* __restrict  */)(& buf));
    }
#line 113
    if (tmp___1) {
      {
#line 114
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t stat \'%s\'.\n",
              sysfs_dev->sysfs_path);
      }
#line 116
      goto while_continue;
    }
#line 119
    if (! ((buf.st_mode & 61440U) == 16384U)) {
#line 120
      goto while_continue;
    }
    {
#line 122
    snprintf((char */* __restrict  */)(sysfs_dev->sysfs_name), sizeof(sysfs_dev->sysfs_name),
             (char const   */* __restrict  */)"%s", dent->d_name);
#line 125
    tmp___2 = ibv_read_sysfs_file((char const   *)(sysfs_dev->sysfs_path), "ibdev",
                                  sysfs_dev->ibdev_name, sizeof(sysfs_dev->ibdev_name));
    }
#line 125
    if (tmp___2 < 0) {
      {
#line 128
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: no ibdev class attr for \'%s\'.\n",
              dent->d_name);
      }
#line 130
      goto while_continue;
    }
    {
#line 133
    tmp___3 = ibv_get_sysfs_path();
#line 133
    snprintf((char */* __restrict  */)(sysfs_dev->ibdev_path), sizeof(sysfs_dev->ibdev_path),
             (char const   */* __restrict  */)"%s/class/infiniband/%s", tmp___3, sysfs_dev->ibdev_name);
#line 137
    sysfs_dev->next = sysfs_dev_list;
#line 138
    sysfs_dev->have_driver = 0;
#line 139
    tmp___5 = ibv_read_sysfs_file((char const   *)(sysfs_dev->sysfs_path), "abi_version",
                                  value, sizeof(value));
    }
#line 139
    if (tmp___5 > 0) {
      {
#line 141
      tmp___4 = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                       10);
#line 141
      sysfs_dev->abi_ver = (int )tmp___4;
      }
    } else {
#line 143
      sysfs_dev->abi_ver = 0;
    }
#line 145
    sysfs_dev_list = sysfs_dev;
#line 146
    sysfs_dev = (struct ibv_sysfs_dev *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
  out: 
#line 150
  if (sysfs_dev) {
    {
#line 151
    free((void *)sysfs_dev);
    }
  }
  {
#line 153
  closedir(class_dir);
  }
#line 154
  return (ret);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void register_driver(char const   *name , struct ibv_device *(*init_func)(char const   *uverbs_sys_path ,
                                                                                 int abi_version ) ,
                            struct verbs_device *(*verbs_init_func)(char const   *uverbs_sys_path ,
                                                                    int abi_version ) ) 
{ 
  struct ibv_driver *driver ;
  void *tmp ;

  {
  {
#line 162
  tmp = malloc(sizeof(*driver));
#line 162
  driver = (struct ibv_driver *)tmp;
  }
#line 163
  if (! driver) {
    {
#line 164
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver for %s\n",
            name);
    }
#line 165
    return;
  }
#line 168
  driver->name = name;
#line 169
  driver->init_func = init_func;
#line 170
  driver->verbs_init_func = verbs_init_func;
#line 171
  driver->next = (struct ibv_driver *)((void *)0);
#line 173
  if (tail_driver) {
#line 174
    tail_driver->next = driver;
  } else {
#line 176
    head_driver = driver;
  }
#line 177
  tail_driver = driver;
#line 178
  return;
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
void ibv_register_driver(char const   *name , struct ibv_device *(*init_func)(char const   *uverbs_sys_path ,
                                                                              int abi_version ) ) 
{ 


  {
  {
#line 182
  register_driver(name, init_func, (struct verbs_device *(*)(char const   *uverbs_sys_path ,
                                                             int abi_version ))((void *)0));
  }
#line 183
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
void verbs_register_driver(char const   *name , struct verbs_device *(*init_func)(char const   *uverbs_sys_path ,
                                                                                  int abi_version ) ) 
{ 


  {
  {
#line 190
  register_driver(name, (struct ibv_device *(*)(char const   *uverbs_sys_path , int abi_version ))((void *)0),
                  init_func);
  }
#line 191
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void load_driver(char const   *name ) 
{ 
  char *so_name ;
  void *dlhandle ;
  char const   *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 201
  if ((int const   )*(name + 0) == 47) {
#line 201
    tmp = "%s-rdmav2.so";
  } else {
#line 201
    tmp = "lib%s-rdmav2.so";
  }
  {
#line 201
  tmp___0 = asprintf((char **/* __restrict  */)(& so_name), (char const   */* __restrict  */)tmp,
                     name);
  }
#line 201
  if (tmp___0 < 0) {
    {
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t load driver \'%s\'.\n",
            name);
    }
#line 208
    return;
  }
  {
#line 211
  dlhandle = dlopen((char const   *)so_name, 2);
  }
#line 212
  if (! dlhandle) {
    {
#line 213
    tmp___1 = dlerror();
#line 213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t load driver \'%s\': %s\n",
            name, tmp___1);
    }
#line 215
    goto out;
  }
  out: 
  {
#line 219
  free((void *)so_name);
  }
#line 220
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void load_drivers(void) 
{ 
  struct ibv_driver_name *name ;
  struct ibv_driver_name *next_name ;
  char const   *env ;
  char *list ;
  char *env_name ;
  char const   *__old ;
  size_t __len ;
  size_t tmp ;
  char *__new ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *__old___0 ;
  size_t __len___0 ;
  size_t tmp___2 ;
  char *__new___0 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;

  {
  {
#line 232
  tmp___7 = getuid();
#line 232
  tmp___8 = geteuid();
  }
#line 232
  if (tmp___7 == tmp___8) {
    {
#line 233
    tmp___6 = getenv("RDMAV_DRIVERS");
#line 233
    env = (char const   *)tmp___6;
    }
#line 233
    if (env) {
      {
#line 234
      __old = env;
#line 234
      tmp = strlen(__old);
#line 234
      __len = tmp + 1UL;
#line 234
      tmp___0 = __builtin_alloca(__len);
#line 234
      __new = (char *)tmp___0;
#line 234
      tmp___1 = memcpy((void */* __restrict  */)__new, (void const   */* __restrict  */)__old,
                       __len);
#line 234
      list = (char *)tmp___1;
      }
      {
#line 235
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 235
        env_name = strsep((char **/* __restrict  */)(& list), (char const   */* __restrict  */)":;");
        }
#line 235
        if (! env_name) {
#line 235
          goto while_break;
        }
        {
#line 236
        load_driver((char const   *)env_name);
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 237
      tmp___5 = getenv("IBV_DRIVERS");
#line 237
      env = (char const   *)tmp___5;
      }
#line 237
      if (env) {
        {
#line 238
        __old___0 = env;
#line 238
        tmp___2 = strlen(__old___0);
#line 238
        __len___0 = tmp___2 + 1UL;
#line 238
        tmp___3 = __builtin_alloca(__len___0);
#line 238
        __new___0 = (char *)tmp___3;
#line 238
        tmp___4 = memcpy((void */* __restrict  */)__new___0, (void const   */* __restrict  */)__old___0,
                         __len___0);
#line 238
        list = (char *)tmp___4;
        }
        {
#line 239
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 239
          env_name = strsep((char **/* __restrict  */)(& list), (char const   */* __restrict  */)":;");
          }
#line 239
          if (! env_name) {
#line 239
            goto while_break___0;
          }
          {
#line 240
          load_driver((char const   *)env_name);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 244
  name = driver_name_list;
#line 244
  if (name) {
#line 244
    next_name = name->next;
  } else {
#line 244
    next_name = (struct ibv_driver_name *)((void *)0);
  }
  {
#line 244
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 244
    if (! name) {
#line 244
      goto while_break___1;
    }
    {
#line 247
    load_driver((char const   *)name->name);
#line 248
    free((void *)name->name);
#line 249
    free((void *)name);
#line 244
    name = next_name;
    }
#line 244
    if (name) {
#line 244
      next_name = name->next;
    } else {
#line 244
      next_name = (struct ibv_driver_name *)((void *)0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 251
  return;
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void read_config_file(char const   *path ) 
{ 
  FILE *conf ;
  char *line ;
  char *config ;
  char *field ;
  size_t buflen ;
  ssize_t len ;
  size_t tmp ;
  struct ibv_driver_name *driver_name ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 256
  line = (char *)((void *)0);
#line 259
  buflen = (size_t )0;
#line 262
  conf = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"re");
  }
#line 263
  if (! conf) {
    {
#line 264
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t read config file %s.\n",
            path);
    }
#line 266
    return;
  }
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 269
    len = getline((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& buflen),
                  (FILE */* __restrict  */)conf);
    }
#line 269
    if (! (len != -1L)) {
#line 269
      goto while_break;
    }
    {
#line 270
    tmp = strspn((char const   *)line, "\t ");
#line 270
    config = line + tmp;
    }
#line 271
    if ((int )*(config + 0) == 10) {
#line 272
      goto while_continue;
    } else
#line 271
    if ((int )*(config + 0) == 35) {
#line 272
      goto while_continue;
    }
    {
#line 274
    field = strsep((char **/* __restrict  */)(& config), (char const   */* __restrict  */)"\n\t ");
#line 276
    tmp___2 = strcmp((char const   *)field, "driver");
    }
#line 276
    if (tmp___2 == 0) {
#line 276
      if ((unsigned long )config != (unsigned long )((void *)0)) {
        {
#line 279
        tmp___0 = strspn((char const   *)config, "\t ");
#line 279
        config += tmp___0;
#line 280
        field = strsep((char **/* __restrict  */)(& config), (char const   */* __restrict  */)"\n\t ");
#line 282
        tmp___1 = malloc(sizeof(*driver_name));
#line 282
        driver_name = (struct ibv_driver_name *)tmp___1;
        }
#line 283
        if (! driver_name) {
          {
#line 284
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver name \'%s\'.\n",
                  field);
          }
#line 286
          goto while_continue;
        }
        {
#line 289
        driver_name->name = strdup((char const   *)field);
        }
#line 290
        if (! driver_name->name) {
          {
#line 291
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver name \'%s\'.\n",
                  field);
#line 293
          free((void *)driver_name);
          }
#line 294
          goto while_continue;
        }
#line 297
        driver_name->next = driver_name_list;
#line 298
        driver_name_list = driver_name;
      } else {
        {
#line 300
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: ignoring bad config directive \'%s\' in file \'%s\'.\n",
                field, path);
        }
      }
    } else {
      {
#line 300
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: ignoring bad config directive \'%s\' in file \'%s\'.\n",
              field, path);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  if (line) {
    {
#line 305
    free((void *)line);
    }
  }
  {
#line 306
  fclose(conf);
  }
#line 307
  return;
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void read_config(void) 
{ 
  DIR *conf_dir ;
  struct dirent *dent ;
  char *path ;
  struct stat buf ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 315
  conf_dir = opendir("/usr/local/etc/libibverbs.d");
  }
#line 316
  if (! conf_dir) {
    {
#line 317
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t open config directory \'%s\'.\n",
            "/usr/local/etc/libibverbs.d");
    }
#line 319
    return;
  }
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 322
    dent = readdir(conf_dir);
    }
#line 322
    if (! dent) {
#line 322
      goto while_break;
    }
    {
#line 325
    tmp = asprintf((char **/* __restrict  */)(& path), (char const   */* __restrict  */)"%s/%s",
                   "/usr/local/etc/libibverbs.d", dent->d_name);
    }
#line 325
    if (tmp < 0) {
      {
#line 326
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t read config file %s/%s.\n",
              "/usr/local/etc/libibverbs.d", dent->d_name);
      }
#line 328
      goto out;
    }
    {
#line 331
    tmp___0 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& buf));
    }
#line 331
    if (tmp___0) {
      {
#line 332
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t stat config file \'%s\'.\n",
              path);
      }
#line 334
      goto next;
    }
#line 337
    if (! ((buf.st_mode & 61440U) == 32768U)) {
#line 338
      goto next;
    }
    {
#line 340
    read_config_file((char const   *)path);
    }
    next: 
    {
#line 342
    free((void *)path);
    }
  }
  while_break: /* CIL Label */ ;
  }
  out: 
  {
#line 346
  closedir(conf_dir);
  }
#line 347
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_device *try_driver(struct ibv_driver *driver , struct ibv_sysfs_dev *sysfs_dev ) 
{ 
  struct verbs_device *vdev ;
  struct ibv_device *dev ;
  char value[8] ;
  long tmp ;
  int tmp___0 ;

  {
#line 356
  if (driver->init_func) {
    {
#line 357
    dev = (*(driver->init_func))((char const   *)(sysfs_dev->sysfs_path), sysfs_dev->abi_ver);
    }
#line 358
    if (! dev) {
#line 359
      return ((struct ibv_device *)((void *)0));
    }
  } else {
    {
#line 361
    vdev = (*(driver->verbs_init_func))((char const   *)(sysfs_dev->sysfs_path), sysfs_dev->abi_ver);
    }
#line 362
    if (! vdev) {
#line 363
      return ((struct ibv_device *)((void *)0));
    }
#line 365
    dev = & vdev->device;
#line 366
    dev->ops.alloc_context = (struct ibv_context *(*)(struct ibv_device *device ,
                                                      int cmd_fd ))((void *)0);
#line 367
    dev->ops.free_context = (void (*)(struct ibv_context *context ))((void *)0);
  }
  {
#line 370
  tmp___0 = ibv_read_sysfs_file((char const   *)(sysfs_dev->ibdev_path), "node_type",
                                value, sizeof(value));
  }
#line 370
  if (tmp___0 < 0) {
    {
#line 371
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: no node_type attr under %s.\n",
            sysfs_dev->ibdev_path);
#line 373
    dev->node_type = (enum ibv_node_type )-1;
    }
  } else {
    {
#line 375
    tmp = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                 10);
#line 375
    dev->node_type = (enum ibv_node_type )tmp;
    }
#line 376
    if ((int )dev->node_type < 1) {
#line 377
      dev->node_type = (enum ibv_node_type )-1;
    } else
#line 376
    if ((int )dev->node_type > 4) {
#line 377
      dev->node_type = (enum ibv_node_type )-1;
    }
  }
  {
#line 383
  if ((int )dev->node_type == 3) {
#line 383
    goto case_3;
  }
#line 383
  if ((int )dev->node_type == 2) {
#line 383
    goto case_3;
  }
#line 383
  if ((int )dev->node_type == 1) {
#line 383
    goto case_3;
  }
#line 386
  if ((int )dev->node_type == 4) {
#line 386
    goto case_4;
  }
#line 389
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 384
  dev->transport_type = (enum ibv_transport_type )0;
#line 385
  goto switch_break;
  case_4: /* CIL Label */ 
#line 387
  dev->transport_type = (enum ibv_transport_type )1;
#line 388
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 390
  dev->transport_type = (enum ibv_transport_type )-1;
#line 391
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 394
  strcpy((char */* __restrict  */)(dev->dev_name), (char const   */* __restrict  */)(sysfs_dev->sysfs_name));
#line 395
  strcpy((char */* __restrict  */)(dev->dev_path), (char const   */* __restrict  */)(sysfs_dev->sysfs_path));
#line 396
  strcpy((char */* __restrict  */)(dev->name), (char const   */* __restrict  */)(sysfs_dev->ibdev_name));
#line 397
  strcpy((char */* __restrict  */)(dev->ibdev_path), (char const   */* __restrict  */)(sysfs_dev->ibdev_path));
  }
#line 399
  return (dev);
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_device *try_drivers(struct ibv_sysfs_dev *sysfs_dev ) 
{ 
  struct ibv_driver *driver ;
  struct ibv_device *dev ;

  {
#line 407
  driver = head_driver;
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 407
    if (! driver) {
#line 407
      goto while_break;
    }
    {
#line 408
    dev = try_driver(driver, sysfs_dev);
    }
#line 409
    if (dev) {
#line 410
      return (dev);
    }
#line 407
    driver = driver->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 413
  return ((struct ibv_device *)((void *)0));
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static int check_abi_version(char const   *path ) 
{ 
  char value[8] ;
  int tmp ;
  long tmp___0 ;

  {
  {
#line 420
  tmp = ibv_read_sysfs_file(path, "class/infiniband_verbs/abi_version", value, sizeof(value));
  }
#line 420
  if (tmp < 0) {
#line 422
    return (38);
  }
  {
#line 425
  tmp___0 = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                   10);
#line 425
  abi_ver = (int __attribute__((__visibility__("hidden")))  )tmp___0;
  }
#line 427
  if (abi_ver < (int __attribute__((__visibility__("hidden")))  )3) {
    {
#line 429
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Fatal: kernel ABI version %d doesn\'t match library version %d.\n",
            abi_ver, 6);
    }
#line 432
    return (38);
  } else
#line 427
  if (abi_ver > (int __attribute__((__visibility__("hidden")))  )6) {
    {
#line 429
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Fatal: kernel ABI version %d doesn\'t match library version %d.\n",
            abi_ver, 6);
    }
#line 432
    return (38);
  }
#line 435
  return (0);
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void check_memlock_limit(void) 
{ 
  struct rlimit rlim ;
  __uid_t tmp ;
  int tmp___0 ;

  {
  {
#line 442
  tmp = geteuid();
  }
#line 442
  if (! tmp) {
#line 443
    return;
  }
  {
#line 445
  tmp___0 = getrlimit((__rlimit_resource_t )8, & rlim);
  }
#line 445
  if (tmp___0) {
    {
#line 446
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: getrlimit(RLIMIT_MEMLOCK) failed.");
    }
#line 447
    return;
  }
#line 450
  if (rlim.rlim_cur <= 32768UL) {
    {
#line 451
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: RLIMIT_MEMLOCK is %lu bytes.\n    This will severely limit memory registrations.\n",
            rlim.rlim_cur);
    }
  }
#line 454
  return;
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void add_device(struct ibv_device *dev , struct ibv_device ***dev_list , int *num_devices___7 ,
                       int *list_size ) 
{ 
  struct ibv_device **new_list ;
  void *tmp ;
  int tmp___0 ;

  {
#line 463
  if (*list_size <= *num_devices___7) {
#line 464
    if (*list_size) {
#line 464
      *list_size *= 2;
    } else {
#line 464
      *list_size = 1;
    }
    {
#line 465
    tmp = realloc((void *)*dev_list, (unsigned long )*list_size * sizeof(struct ibv_device *));
#line 465
    new_list = (struct ibv_device **)tmp;
    }
#line 466
    if (! new_list) {
#line 467
      return;
    }
#line 468
    *dev_list = new_list;
  }
#line 471
  tmp___0 = *num_devices___7;
#line 471
  (*num_devices___7) ++;
#line 471
  *(*dev_list + tmp___0) = dev;
#line 472
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
int __attribute__((__visibility__("hidden")))  ibverbs_init(struct ibv_device ***list ) 
{ 
  char const   *sysfs_path___7 ;
  struct ibv_sysfs_dev *sysfs_dev ;
  struct ibv_sysfs_dev *next_dev ;
  struct ibv_device *device ;
  int num_devices___7 ;
  int list_size ;
  int statically_linked ;
  int no_driver ;
  int ret ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *hand ;
  void *tmp___2 ;

  {
  {
#line 479
  num_devices___7 = 0;
#line 480
  list_size = 0;
#line 481
  statically_linked = 0;
#line 482
  no_driver = 0;
#line 485
  *list = (struct ibv_device **)((void *)0);
#line 487
  tmp___0 = getenv("RDMAV_FORK_SAFE");
  }
#line 487
  if (tmp___0) {
#line 487
    goto _L;
  } else {
    {
#line 487
    tmp___1 = getenv("IBV_FORK_SAFE");
    }
#line 487
    if (tmp___1) {
      _L: /* CIL Label */ 
      {
#line 488
      tmp = ibv_fork_init();
      }
#line 488
      if (tmp) {
        {
#line 489
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: fork()-safety requested but init failed\n");
        }
      }
    }
  }
  {
#line 492
  sysfs_path___7 = ibv_get_sysfs_path();
  }
#line 493
  if (! sysfs_path___7) {
#line 494
    return ((int __attribute__((__visibility__("hidden")))  )-38);
  }
  {
#line 496
  ret = check_abi_version(sysfs_path___7);
  }
#line 497
  if (ret) {
#line 498
    return ((int __attribute__((__visibility__("hidden")))  )(- ret));
  }
  {
#line 500
  check_memlock_limit();
#line 502
  read_config();
#line 504
  ret = find_sysfs_devs();
  }
#line 505
  if (ret) {
#line 506
    return ((int __attribute__((__visibility__("hidden")))  )(- ret));
  }
#line 508
  sysfs_dev = sysfs_dev_list;
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 508
    if (! sysfs_dev) {
#line 508
      goto while_break;
    }
    {
#line 509
    device = try_drivers(sysfs_dev);
    }
#line 510
    if (device) {
      {
#line 511
      add_device(device, list, & num_devices___7, & list_size);
#line 512
      sysfs_dev->have_driver = 1;
      }
    } else {
#line 514
      no_driver = 1;
    }
#line 508
    sysfs_dev = sysfs_dev->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 517
  if (! no_driver) {
#line 518
    goto out;
  }
  {
#line 530
  tmp___2 = dlopen((char const   *)((void *)0), 2);
#line 530
  hand = tmp___2;
  }
#line 531
  if (! hand) {
    {
#line 532
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: dlopen(NULL) failed, assuming static linking.\n");
#line 534
    statically_linked = 1;
    }
#line 535
    goto out;
  }
  {
#line 537
  dlclose(hand);
#line 540
  load_drivers();
#line 542
  sysfs_dev = sysfs_dev_list;
  }
  {
#line 542
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 542
    if (! sysfs_dev) {
#line 542
      goto while_break___0;
    }
#line 543
    if (sysfs_dev->have_driver) {
#line 544
      goto __Cont;
    }
    {
#line 546
    device = try_drivers(sysfs_dev);
    }
#line 547
    if (device) {
      {
#line 548
      add_device(device, list, & num_devices___7, & list_size);
#line 549
      sysfs_dev->have_driver = 1;
      }
    }
    __Cont: /* CIL Label */ 
#line 542
    sysfs_dev = sysfs_dev->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  out: 
#line 554
  sysfs_dev = sysfs_dev_list;
#line 554
  if (sysfs_dev) {
#line 554
    next_dev = sysfs_dev->next;
  } else {
#line 554
    next_dev = (struct ibv_sysfs_dev *)((void *)0);
  }
  {
#line 554
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 554
    if (! sysfs_dev) {
#line 554
      goto while_break___1;
    }
#line 558
    if (! sysfs_dev->have_driver) {
      {
#line 559
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: no userspace device-specific driver found for %s\n",
              sysfs_dev->sysfs_path);
      }
#line 561
      if (statically_linked) {
        {
#line 562
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tWhen linking libibverbs statically, driver must be statically linked too.\n");
        }
      }
    }
    {
#line 565
    free((void *)sysfs_dev);
#line 554
    sysfs_dev = next_dev;
    }
#line 554
    if (sysfs_dev) {
#line 554
      next_dev = sysfs_dev->next;
    } else {
#line 554
      next_dev = (struct ibv_sysfs_dev *)((void *)0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 568
  return ((int __attribute__((__visibility__("hidden")))  )num_devices___7);
}
}
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 1000 "/usr/include/pthread.h"
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
#line 63 "./include/infiniband/driver.h"
int ibv_cmd_get_context(struct ibv_context *context , struct ibv_get_context *cmd ,
                        size_t cmd_size , struct ibv_get_context_resp *resp , size_t resp_size ) ;
#line 66
int ibv_cmd_query_device(struct ibv_context *context , struct ibv_device_attr *device_attr ,
                         uint64_t *raw_fw_ver , struct ibv_query_device *cmd , size_t cmd_size ) ;
#line 70
int ibv_cmd_query_port(struct ibv_context *context , uint8_t port_num , struct ibv_port_attr *port_attr ,
                       struct ibv_query_port *cmd , size_t cmd_size ) ;
#line 77
int ibv_cmd_alloc_pd(struct ibv_context *context , struct ibv_pd *pd , struct ibv_alloc_pd *cmd ,
                     size_t cmd_size , struct ibv_alloc_pd_resp *resp , size_t resp_size ) ;
#line 80
int ibv_cmd_dealloc_pd(struct ibv_pd *pd ) ;
#line 82
int ibv_cmd_reg_mr(struct ibv_pd *pd , void *addr , size_t length , uint64_t hca_va ,
                   int access___0 , struct ibv_mr *mr , struct ibv_reg_mr *cmd , size_t cmd_size ,
                   struct ibv_reg_mr_resp *resp , size_t resp_size ) ;
#line 87
int ibv_cmd_dereg_mr(struct ibv_mr *mr ) ;
#line 88
int ibv_cmd_create_cq(struct ibv_context *context , int cqe , struct ibv_comp_channel *channel ,
                      int comp_vector , struct ibv_cq *cq , struct ibv_create_cq *cmd ,
                      size_t cmd_size , struct ibv_create_cq_resp *resp , size_t resp_size ) ;
#line 93
int ibv_cmd_poll_cq(struct ibv_cq *ibcq , int ne , struct ibv_wc *wc ) ;
#line 94
int ibv_cmd_req_notify_cq(struct ibv_cq *ibcq , int solicited_only ) ;
#line 96
int ibv_cmd_resize_cq(struct ibv_cq *cq , int cqe , struct ibv_resize_cq *cmd , size_t cmd_size ,
                      struct ibv_resize_cq_resp *resp , size_t resp_size ) ;
#line 99
int ibv_cmd_destroy_cq(struct ibv_cq *cq ) ;
#line 101
int ibv_cmd_create_srq(struct ibv_pd *pd , struct ibv_srq *srq , struct ibv_srq_init_attr *attr ,
                       struct ibv_create_srq *cmd , size_t cmd_size , struct ibv_create_srq_resp *resp ,
                       size_t resp_size ) ;
#line 105
int ibv_cmd_modify_srq(struct ibv_srq *srq , struct ibv_srq_attr *srq_attr , int srq_attr_mask ,
                       struct ibv_modify_srq *cmd , size_t cmd_size ) ;
#line 109
int ibv_cmd_query_srq(struct ibv_srq *srq , struct ibv_srq_attr *srq_attr , struct ibv_query_srq *cmd ,
                      size_t cmd_size ) ;
#line 112
int ibv_cmd_destroy_srq(struct ibv_srq *srq ) ;
#line 114
int ibv_cmd_create_qp(struct ibv_pd *pd , struct ibv_qp *qp , struct ibv_qp_init_attr *attr ,
                      struct ibv_create_qp *cmd , size_t cmd_size , struct ibv_create_qp_resp *resp ,
                      size_t resp_size ) ;
#line 118
int ibv_cmd_query_qp(struct ibv_qp *qp , struct ibv_qp_attr *attr , int attr_mask ,
                     struct ibv_qp_init_attr *init_attr , struct ibv_query_qp *cmd ,
                     size_t cmd_size ) ;
#line 122
int ibv_cmd_modify_qp(struct ibv_qp *qp , struct ibv_qp_attr *attr , int attr_mask ,
                      struct ibv_modify_qp *cmd , size_t cmd_size ) ;
#line 125
int ibv_cmd_destroy_qp(struct ibv_qp *qp ) ;
#line 126
int ibv_cmd_post_send(struct ibv_qp *ibqp , struct ibv_send_wr *wr , struct ibv_send_wr **bad_wr ) ;
#line 128
int ibv_cmd_post_recv(struct ibv_qp *ibqp , struct ibv_recv_wr *wr , struct ibv_recv_wr **bad_wr ) ;
#line 130
int ibv_cmd_post_srq_recv(struct ibv_srq *srq , struct ibv_recv_wr *wr , struct ibv_recv_wr **bad_wr ) ;
#line 132
int ibv_cmd_create_ah(struct ibv_pd *pd , struct ibv_ah *ah , struct ibv_ah_attr *attr ) ;
#line 134
int ibv_cmd_destroy_ah(struct ibv_ah *ah ) ;
#line 135
int ibv_cmd_attach_mcast(struct ibv_qp *qp , union ibv_gid  const  *gid , uint16_t lid ) ;
#line 136
int ibv_cmd_detach_mcast(struct ibv_qp *qp , union ibv_gid  const  *gid , uint16_t lid ) ;
#line 138
struct ibv_flow *ibv_cmd_create_flow(struct ibv_qp *qp , struct ibv_flow_attr *flow_attr ) ;
#line 140
int ibv_cmd_destroy_flow(struct ibv_flow *flow_id ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_get_context(struct ibv_context *context , struct ibv_get_context *cmd ,
                        size_t cmd_size , struct ibv_get_context_resp *resp , size_t resp_size ) 
{ 
  int *tmp ;
  ssize_t tmp___0 ;

  {
#line 53
  if (abi_ver < (int __attribute__((__visibility__("hidden")))  )3) {
#line 54
    return (38);
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 56
      cmd->command = (__u32 )0;
    } else {
#line 56
      cmd->command = (__u32 )1;
    }
#line 56
    cmd->in_words = (__u16 )(cmd_size / 4UL);
#line 56
    cmd->out_words = (__u16 )(resp_size / 4UL);
#line 56
    cmd->response = (__u64 )((uintptr_t )resp);
#line 56
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 58
  tmp___0 = write(context->cmd_fd, (void const   *)cmd, cmd_size);
  }
#line 58
  if ((size_t )tmp___0 != cmd_size) {
    {
#line 59
    tmp = __errno_location();
    }
#line 59
    return (*tmp);
  }
#line 63
  context->async_fd = (int )resp->async_fd;
#line 64
  context->num_comp_vectors = (int )resp->num_comp_vectors;
#line 66
  return (0);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_query_device(struct ibv_context *context , struct ibv_device_attr *device_attr ,
                         uint64_t *raw_fw_ver , struct ibv_query_device *cmd , size_t cmd_size ) 
{ 
  struct ibv_query_device_resp resp ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 76
      cmd->command = (__u32 )1;
    } else {
#line 76
      cmd->command = (__u32 )2;
    }
#line 76
    cmd->in_words = (__u16 )(cmd_size / 4UL);
#line 76
    cmd->out_words = (__u16 )(sizeof(resp) / 4UL);
#line 76
    cmd->response = (__u64 )((uintptr_t )(& resp));
#line 76
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 78
  tmp___0 = write(context->cmd_fd, (void const   *)cmd, cmd_size);
  }
#line 78
  if ((size_t )tmp___0 != cmd_size) {
    {
#line 79
    tmp = __errno_location();
    }
#line 79
    return (*tmp);
  }
  {
#line 83
  memset((void *)(device_attr->fw_ver), 0, sizeof(device_attr->fw_ver));
#line 84
  *raw_fw_ver = (uint64_t )resp.fw_ver;
#line 85
  device_attr->node_guid = (uint64_t )resp.node_guid;
#line 86
  device_attr->sys_image_guid = (uint64_t )resp.sys_image_guid;
#line 87
  device_attr->max_mr_size = (uint64_t )resp.max_mr_size;
#line 88
  device_attr->page_size_cap = (uint64_t )resp.page_size_cap;
#line 89
  device_attr->vendor_id = resp.vendor_id;
#line 90
  device_attr->vendor_part_id = resp.vendor_part_id;
#line 91
  device_attr->hw_ver = resp.hw_ver;
#line 92
  device_attr->max_qp = (int )resp.max_qp;
#line 93
  device_attr->max_qp_wr = (int )resp.max_qp_wr;
#line 94
  device_attr->device_cap_flags = (int )resp.device_cap_flags;
#line 95
  device_attr->max_sge = (int )resp.max_sge;
#line 96
  device_attr->max_sge_rd = (int )resp.max_sge_rd;
#line 97
  device_attr->max_cq = (int )resp.max_cq;
#line 98
  device_attr->max_cqe = (int )resp.max_cqe;
#line 99
  device_attr->max_mr = (int )resp.max_mr;
#line 100
  device_attr->max_pd = (int )resp.max_pd;
#line 101
  device_attr->max_qp_rd_atom = (int )resp.max_qp_rd_atom;
#line 102
  device_attr->max_ee_rd_atom = (int )resp.max_ee_rd_atom;
#line 103
  device_attr->max_res_rd_atom = (int )resp.max_res_rd_atom;
#line 104
  device_attr->max_qp_init_rd_atom = (int )resp.max_qp_init_rd_atom;
#line 105
  device_attr->max_ee_init_rd_atom = (int )resp.max_ee_init_rd_atom;
#line 106
  device_attr->atomic_cap = (enum ibv_atomic_cap )resp.atomic_cap;
#line 107
  device_attr->max_ee = (int )resp.max_ee;
#line 108
  device_attr->max_rdd = (int )resp.max_rdd;
#line 109
  device_attr->max_mw = (int )resp.max_mw;
#line 110
  device_attr->max_raw_ipv6_qp = (int )resp.max_raw_ipv6_qp;
#line 111
  device_attr->max_raw_ethy_qp = (int )resp.max_raw_ethy_qp;
#line 112
  device_attr->max_mcast_grp = (int )resp.max_mcast_grp;
#line 113
  device_attr->max_mcast_qp_attach = (int )resp.max_mcast_qp_attach;
#line 114
  device_attr->max_total_mcast_qp_attach = (int )resp.max_total_mcast_qp_attach;
#line 115
  device_attr->max_ah = (int )resp.max_ah;
#line 116
  device_attr->max_fmr = (int )resp.max_fmr;
#line 117
  device_attr->max_map_per_fmr = (int )resp.max_map_per_fmr;
#line 118
  device_attr->max_srq = (int )resp.max_srq;
#line 119
  device_attr->max_srq_wr = (int )resp.max_srq_wr;
#line 120
  device_attr->max_srq_sge = (int )resp.max_srq_sge;
#line 121
  device_attr->max_pkeys = resp.max_pkeys;
#line 122
  device_attr->local_ca_ack_delay = resp.local_ca_ack_delay;
#line 123
  device_attr->phys_port_cnt = resp.phys_port_cnt;
  }
#line 125
  return (0);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_query_port(struct ibv_context *context , uint8_t port_num , struct ibv_port_attr *port_attr ,
                       struct ibv_query_port *cmd , size_t cmd_size ) 
{ 
  struct ibv_query_port_resp resp ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 134
      cmd->command = (__u32 )2;
    } else {
#line 134
      cmd->command = (__u32 )3;
    }
#line 134
    cmd->in_words = (__u16 )(cmd_size / 4UL);
#line 134
    cmd->out_words = (__u16 )(sizeof(resp) / 4UL);
#line 134
    cmd->response = (__u64 )((uintptr_t )(& resp));
#line 134
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 135
  cmd->port_num = port_num;
#line 136
  memset((void *)(cmd->reserved), 0, sizeof(cmd->reserved));
#line 138
  tmp___0 = write(context->cmd_fd, (void const   *)cmd, cmd_size);
  }
#line 138
  if ((size_t )tmp___0 != cmd_size) {
    {
#line 139
    tmp = __errno_location();
    }
#line 139
    return (*tmp);
  }
#line 143
  port_attr->state = (enum ibv_port_state )resp.state;
#line 144
  port_attr->max_mtu = (enum ibv_mtu )resp.max_mtu;
#line 145
  port_attr->active_mtu = (enum ibv_mtu )resp.active_mtu;
#line 146
  port_attr->gid_tbl_len = (int )resp.gid_tbl_len;
#line 147
  port_attr->port_cap_flags = resp.port_cap_flags;
#line 148
  port_attr->max_msg_sz = resp.max_msg_sz;
#line 149
  port_attr->bad_pkey_cntr = resp.bad_pkey_cntr;
#line 150
  port_attr->qkey_viol_cntr = resp.qkey_viol_cntr;
#line 151
  port_attr->pkey_tbl_len = resp.pkey_tbl_len;
#line 152
  port_attr->lid = resp.lid;
#line 153
  port_attr->sm_lid = resp.sm_lid;
#line 154
  port_attr->lmc = resp.lmc;
#line 155
  port_attr->max_vl_num = resp.max_vl_num;
#line 156
  port_attr->sm_sl = resp.sm_sl;
#line 157
  port_attr->subnet_timeout = resp.subnet_timeout;
#line 158
  port_attr->init_type_reply = resp.init_type_reply;
#line 159
  port_attr->active_width = resp.active_width;
#line 160
  port_attr->active_speed = resp.active_speed;
#line 161
  port_attr->phys_state = resp.phys_state;
#line 162
  port_attr->link_layer = resp.link_layer;
#line 164
  return (0);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_alloc_pd(struct ibv_context *context , struct ibv_pd *pd , struct ibv_alloc_pd *cmd ,
                     size_t cmd_size , struct ibv_alloc_pd_resp *resp , size_t resp_size ) 
{ 
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 171
      cmd->command = (__u32 )3;
    } else {
#line 171
      cmd->command = (__u32 )6;
    }
#line 171
    cmd->in_words = (__u16 )(cmd_size / 4UL);
#line 171
    cmd->out_words = (__u16 )(resp_size / 4UL);
#line 171
    cmd->response = (__u64 )((uintptr_t )resp);
#line 171
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 173
  tmp___0 = write(context->cmd_fd, (void const   *)cmd, cmd_size);
  }
#line 173
  if ((size_t )tmp___0 != cmd_size) {
    {
#line 174
    tmp = __errno_location();
    }
#line 174
    return (*tmp);
  }
#line 178
  pd->handle = resp->pd_handle;
#line 179
  pd->context = context;
#line 181
  return (0);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_dealloc_pd(struct ibv_pd *pd ) 
{ 
  struct ibv_dealloc_pd cmd ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 188
      cmd.command = (__u32 )4;
    } else {
#line 188
      cmd.command = (__u32 )7;
    }
#line 188
    cmd.in_words = (__u16 )(sizeof(cmd) / 4UL);
#line 188
    cmd.out_words = (__u16 )0;
#line 188
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 189
  cmd.pd_handle = pd->handle;
#line 191
  tmp___0 = write((pd->context)->cmd_fd, (void const   *)(& cmd), sizeof(cmd));
  }
#line 191
  if ((unsigned long )tmp___0 != sizeof(cmd)) {
    {
#line 192
    tmp = __errno_location();
    }
#line 192
    return (*tmp);
  }
#line 194
  return (0);
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_reg_mr(struct ibv_pd *pd , void *addr , size_t length , uint64_t hca_va ,
                   int access___0 , struct ibv_mr *mr , struct ibv_reg_mr *cmd , size_t cmd_size ,
                   struct ibv_reg_mr_resp *resp , size_t resp_size ) 
{ 
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 204
      cmd->command = (__u32 )9;
    } else {
#line 204
      cmd->command = (__u32 )12;
    }
#line 204
    cmd->in_words = (__u16 )(cmd_size / 4UL);
#line 204
    cmd->out_words = (__u16 )(resp_size / 4UL);
#line 204
    cmd->response = (__u64 )((uintptr_t )resp);
#line 204
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 206
  cmd->start = (__u64 )((uintptr_t )addr);
#line 207
  cmd->length = (__u64 )length;
#line 208
  cmd->hca_va = (__u64 )hca_va;
#line 209
  cmd->pd_handle = pd->handle;
#line 210
  cmd->access_flags = (__u32 )access___0;
#line 212
  tmp___0 = write((pd->context)->cmd_fd, (void const   *)cmd, cmd_size);
  }
#line 212
  if ((size_t )tmp___0 != cmd_size) {
    {
#line 213
    tmp = __errno_location();
    }
#line 213
    return (*tmp);
  }
#line 217
  mr->handle = resp->mr_handle;
#line 218
  mr->lkey = resp->lkey;
#line 219
  mr->rkey = resp->rkey;
#line 220
  mr->context = pd->context;
#line 222
  return (0);
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_dereg_mr(struct ibv_mr *mr ) 
{ 
  struct ibv_dereg_mr cmd ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 229
      cmd.command = (__u32 )13;
    } else {
#line 229
      cmd.command = (__u32 )16;
    }
#line 229
    cmd.in_words = (__u16 )(sizeof(cmd) / 4UL);
#line 229
    cmd.out_words = (__u16 )0;
#line 229
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 230
  cmd.mr_handle = mr->handle;
#line 232
  tmp___0 = write((mr->context)->cmd_fd, (void const   *)(& cmd), sizeof(cmd));
  }
#line 232
  if ((unsigned long )tmp___0 != sizeof(cmd)) {
    {
#line 233
    tmp = __errno_location();
    }
#line 233
    return (*tmp);
  }
#line 235
  return (0);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_create_cq(struct ibv_context *context , int cqe , struct ibv_comp_channel *channel ,
                      int comp_vector , struct ibv_cq *cq , struct ibv_create_cq *cmd ,
                      size_t cmd_size , struct ibv_create_cq_resp *resp , size_t resp_size ) 
{ 
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 244
      cmd->command = (__u32 )18;
    } else {
#line 244
      cmd->command = (__u32 )20;
    }
#line 244
    cmd->in_words = (__u16 )(cmd_size / 4UL);
#line 244
    cmd->out_words = (__u16 )(resp_size / 4UL);
#line 244
    cmd->response = (__u64 )((uintptr_t )resp);
#line 244
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  cmd->user_handle = (__u64 )((uintptr_t )cq);
#line 246
  cmd->cqe = (__u32 )cqe;
#line 247
  cmd->comp_vector = (__u32 )comp_vector;
#line 248
  if (channel) {
#line 248
    cmd->comp_channel = channel->fd;
  } else {
#line 248
    cmd->comp_channel = -1;
  }
  {
#line 249
  cmd->reserved = (__u32 )0;
#line 251
  tmp___0 = write(context->cmd_fd, (void const   *)cmd, cmd_size);
  }
#line 251
  if ((size_t )tmp___0 != cmd_size) {
    {
#line 252
    tmp = __errno_location();
    }
#line 252
    return (*tmp);
  }
#line 256
  cq->handle = resp->cq_handle;
#line 257
  cq->cqe = (int )resp->cqe;
#line 258
  cq->context = context;
#line 260
  return (0);
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_poll_cq(struct ibv_cq *ibcq , int ne , struct ibv_wc *wc ) 
{ 
  struct ibv_poll_cq cmd ;
  struct ibv_poll_cq_resp *resp ;
  int i ;
  int rsize ;
  int ret ;
  void *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 271
  rsize = (int )(sizeof(*resp) + (unsigned long )ne * sizeof(struct ibv_kern_wc ));
#line 272
  tmp = malloc((size_t )rsize);
#line 272
  resp = (struct ibv_poll_cq_resp *)tmp;
  }
#line 273
  if (! resp) {
#line 274
    return (-1);
  }
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 276
      cmd.command = (__u32 )21;
    } else {
#line 276
      cmd.command = (__u32 )23;
    }
#line 276
    cmd.in_words = (__u16 )(sizeof(cmd) / 4UL);
#line 276
    cmd.out_words = (__u16 )(rsize / 4);
#line 276
    cmd.response = (__u64 )((uintptr_t )resp);
#line 276
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 277
  cmd.cq_handle = ibcq->handle;
#line 278
  cmd.ne = (__u32 )ne;
#line 280
  tmp___0 = write((ibcq->context)->cmd_fd, (void const   *)(& cmd), sizeof(cmd));
  }
#line 280
  if ((unsigned long )tmp___0 != sizeof(cmd)) {
#line 281
    ret = -1;
#line 282
    goto out;
  }
#line 287
  i = 0;
  {
#line 287
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 287
    if (! ((__u32 )i < resp->count)) {
#line 287
      goto while_break___0;
    }
#line 288
    (wc + i)->wr_id = (uint64_t )resp->wc[i].wr_id;
#line 289
    (wc + i)->status = (enum ibv_wc_status )resp->wc[i].status;
#line 290
    (wc + i)->opcode = (enum ibv_wc_opcode )resp->wc[i].opcode;
#line 291
    (wc + i)->vendor_err = resp->wc[i].vendor_err;
#line 292
    (wc + i)->byte_len = resp->wc[i].byte_len;
#line 293
    (wc + i)->imm_data = resp->wc[i].imm_data;
#line 294
    (wc + i)->qp_num = resp->wc[i].qp_num;
#line 295
    (wc + i)->src_qp = resp->wc[i].src_qp;
#line 296
    (wc + i)->wc_flags = (int )resp->wc[i].wc_flags;
#line 297
    (wc + i)->pkey_index = resp->wc[i].pkey_index;
#line 298
    (wc + i)->slid = resp->wc[i].slid;
#line 299
    (wc + i)->sl = resp->wc[i].sl;
#line 300
    (wc + i)->dlid_path_bits = resp->wc[i].dlid_path_bits;
#line 287
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 303
  ret = (int )resp->count;
  out: 
  {
#line 306
  free((void *)resp);
  }
#line 307
  return (ret);
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_req_notify_cq(struct ibv_cq *ibcq , int solicited_only ) 
{ 
  struct ibv_req_notify_cq cmd ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 314
      cmd.command = (__u32 )23;
    } else {
#line 314
      cmd.command = (__u32 )25;
    }
#line 314
    cmd.in_words = (__u16 )(sizeof(cmd) / 4UL);
#line 314
    cmd.out_words = (__u16 )0;
#line 314
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 315
  cmd.cq_handle = ibcq->handle;
#line 316
  cmd.solicited = (__u32 )(! (! solicited_only));
#line 318
  tmp___0 = write((ibcq->context)->cmd_fd, (void const   *)(& cmd), sizeof(cmd));
  }
#line 318
  if ((unsigned long )tmp___0 != sizeof(cmd)) {
    {
#line 319
    tmp = __errno_location();
    }
#line 319
    return (*tmp);
  }
#line 321
  return (0);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_resize_cq(struct ibv_cq *cq , int cqe , struct ibv_resize_cq *cmd , size_t cmd_size ,
                      struct ibv_resize_cq_resp *resp , size_t resp_size ) 
{ 
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 328
      cmd->command = (__u32 )19;
    } else {
#line 328
      cmd->command = (__u32 )21;
    }
#line 328
    cmd->in_words = (__u16 )(cmd_size / 4UL);
#line 328
    cmd->out_words = (__u16 )(resp_size / 4UL);
#line 328
    cmd->response = (__u64 )((uintptr_t )resp);
#line 328
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 329
  cmd->cq_handle = cq->handle;
#line 330
  cmd->cqe = (__u32 )cqe;
#line 332
  tmp___0 = write((cq->context)->cmd_fd, (void const   *)cmd, cmd_size);
  }
#line 332
  if ((size_t )tmp___0 != cmd_size) {
    {
#line 333
    tmp = __errno_location();
    }
#line 333
    return (*tmp);
  }
#line 337
  cq->cqe = (int )resp->cqe;
#line 339
  return (0);
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_destroy_cq(struct ibv_cq *cq ) 
{ 
  struct ibv_destroy_cq cmd ;
  struct ibv_destroy_cq_resp resp ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 347
      cmd.command = (__u32 )20;
    } else {
#line 347
      cmd.command = (__u32 )22;
    }
#line 347
    cmd.in_words = (__u16 )(sizeof(cmd) / 4UL);
#line 347
    cmd.out_words = (__u16 )(sizeof(resp) / 4UL);
#line 347
    cmd.response = (__u64 )((uintptr_t )(& resp));
#line 347
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 348
  cmd.cq_handle = cq->handle;
#line 349
  cmd.reserved = (__u32 )0;
#line 351
  tmp___0 = write((cq->context)->cmd_fd, (void const   *)(& cmd), sizeof(cmd));
  }
#line 351
  if ((unsigned long )tmp___0 != sizeof(cmd)) {
    {
#line 352
    tmp = __errno_location();
    }
#line 352
    return (*tmp);
  }
  {
#line 356
  pthread_mutex_lock(& cq->mutex);
  }
  {
#line 357
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 357
    if (! (cq->comp_events_completed != resp.comp_events_reported)) {
#line 357
      if (! (cq->async_events_completed != resp.async_events_reported)) {
#line 357
        goto while_break___0;
      }
    }
    {
#line 359
    pthread_cond_wait((pthread_cond_t */* __restrict  */)(& cq->cond), (pthread_mutex_t */* __restrict  */)(& cq->mutex));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 360
  pthread_mutex_unlock(& cq->mutex);
  }
#line 362
  return (0);
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_create_srq(struct ibv_pd *pd , struct ibv_srq *srq , struct ibv_srq_init_attr *attr ,
                       struct ibv_create_srq *cmd , size_t cmd_size , struct ibv_create_srq_resp *resp ,
                       size_t resp_size ) 
{ 
  int *tmp ;
  ssize_t tmp___0 ;
  struct ibv_create_srq_resp_v5 *resp_v5 ;

  {
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 370
      cmd->command = (__u32 )32;
    } else {
#line 370
      cmd->command = (__u32 )34;
    }
#line 370
    cmd->in_words = (__u16 )(cmd_size / 4UL);
#line 370
    cmd->out_words = (__u16 )(resp_size / 4UL);
#line 370
    cmd->response = (__u64 )((uintptr_t )resp);
#line 370
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 371
  cmd->user_handle = (__u64 )((uintptr_t )srq);
#line 372
  cmd->pd_handle = pd->handle;
#line 373
  cmd->max_wr = attr->attr.max_wr;
#line 374
  cmd->max_sge = attr->attr.max_sge;
#line 375
  cmd->srq_limit = attr->attr.srq_limit;
#line 377
  tmp___0 = write((pd->context)->cmd_fd, (void const   *)cmd, cmd_size);
  }
#line 377
  if ((size_t )tmp___0 != cmd_size) {
    {
#line 378
    tmp = __errno_location();
    }
#line 378
    return (*tmp);
  }
#line 382
  srq->handle = resp->srq_handle;
#line 383
  srq->context = pd->context;
#line 385
  if (abi_ver > (int __attribute__((__visibility__("hidden")))  )5) {
#line 386
    attr->attr.max_wr = resp->max_wr;
#line 387
    attr->attr.max_sge = resp->max_sge;
  } else {
    {
#line 389
    resp_v5 = (struct ibv_create_srq_resp_v5 *)resp;
#line 392
    memmove((void *)resp + sizeof(*resp), (void const   *)((void *)resp_v5 + sizeof(*resp_v5)),
            resp_size - sizeof(*resp));
    }
  }
#line 397
  return (0);
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
static int ibv_cmd_modify_srq_v3(struct ibv_srq *srq , struct ibv_srq_attr *srq_attr ,
                                 int srq_attr_mask , struct ibv_modify_srq *new_cmd ,
                                 size_t new_cmd_size ) 
{ 
  struct ibv_modify_srq_v3 *cmd ;
  size_t cmd_size ;
  void *tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 409
  cmd_size = (sizeof(*cmd) + new_cmd_size) - sizeof(*new_cmd);
#line 410
  tmp = __builtin_alloca(cmd_size);
#line 410
  cmd = (struct ibv_modify_srq_v3 *)tmp;
#line 411
  memcpy((void */* __restrict  */)(cmd->driver_data), (void const   */* __restrict  */)(new_cmd->driver_data),
         new_cmd_size - sizeof(*new_cmd));
  }
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 413
      cmd->command = (__u32 )33;
    } else {
#line 413
      cmd->command = (__u32 )35;
    }
#line 413
    cmd->in_words = (__u16 )(cmd_size / 4UL);
#line 413
    cmd->out_words = (__u16 )0;
#line 413
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 415
  cmd->srq_handle = srq->handle;
#line 416
  cmd->attr_mask = (__u32 )srq_attr_mask;
#line 417
  cmd->max_wr = srq_attr->max_wr;
#line 418
  cmd->srq_limit = srq_attr->srq_limit;
#line 419
  cmd->max_sge = (__u32 )0;
#line 420
  cmd->reserved = (__u32 )0;
#line 422
  tmp___1 = write((srq->context)->cmd_fd, (void const   *)cmd, cmd_size);
  }
#line 422
  if ((size_t )tmp___1 != cmd_size) {
    {
#line 423
    tmp___0 = __errno_location();
    }
#line 423
    return (*tmp___0);
  }
#line 425
  return (0);
}
}
#line 428 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_modify_srq(struct ibv_srq *srq , struct ibv_srq_attr *srq_attr , int srq_attr_mask ,
                       struct ibv_modify_srq *cmd , size_t cmd_size ) 
{ 
  int tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 433
  if (abi_ver == (int __attribute__((__visibility__("hidden")))  )3) {
    {
#line 434
    tmp = ibv_cmd_modify_srq_v3(srq, srq_attr, srq_attr_mask, cmd, cmd_size);
    }
#line 434
    return (tmp);
  }
  {
#line 437
  while (1) {
    while_continue: /* CIL Label */ ;
#line 437
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 437
      cmd->command = (__u32 )33;
    } else {
#line 437
      cmd->command = (__u32 )35;
    }
#line 437
    cmd->in_words = (__u16 )(cmd_size / 4UL);
#line 437
    cmd->out_words = (__u16 )0;
#line 437
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 439
  cmd->srq_handle = srq->handle;
#line 440
  cmd->attr_mask = (__u32 )srq_attr_mask;
#line 441
  cmd->max_wr = srq_attr->max_wr;
#line 442
  cmd->srq_limit = srq_attr->srq_limit;
#line 444
  tmp___1 = write((srq->context)->cmd_fd, (void const   *)cmd, cmd_size);
  }
#line 444
  if ((size_t )tmp___1 != cmd_size) {
    {
#line 445
    tmp___0 = __errno_location();
    }
#line 445
    return (*tmp___0);
  }
#line 447
  return (0);
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_query_srq(struct ibv_srq *srq , struct ibv_srq_attr *srq_attr , struct ibv_query_srq *cmd ,
                      size_t cmd_size ) 
{ 
  struct ibv_query_srq_resp resp ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 455
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 455
      cmd->command = (__u32 )34;
    } else {
#line 455
      cmd->command = (__u32 )36;
    }
#line 455
    cmd->in_words = (__u16 )(cmd_size / 4UL);
#line 455
    cmd->out_words = (__u16 )(sizeof(resp) / 4UL);
#line 455
    cmd->response = (__u64 )((uintptr_t )(& resp));
#line 455
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 456
  cmd->srq_handle = srq->handle;
#line 457
  cmd->reserved = (__u32 )0;
#line 459
  tmp___0 = write((srq->context)->cmd_fd, (void const   *)cmd, cmd_size);
  }
#line 459
  if ((size_t )tmp___0 != cmd_size) {
    {
#line 460
    tmp = __errno_location();
    }
#line 460
    return (*tmp);
  }
#line 464
  srq_attr->max_wr = resp.max_wr;
#line 465
  srq_attr->max_sge = resp.max_sge;
#line 466
  srq_attr->srq_limit = resp.srq_limit;
#line 468
  return (0);
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_destroy_srq(struct ibv_srq *srq ) 
{ 
  struct ibv_destroy_srq cmd ;
  struct ibv_destroy_srq_resp resp ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 476
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 476
      cmd.command = (__u32 )35;
    } else {
#line 476
      cmd.command = (__u32 )37;
    }
#line 476
    cmd.in_words = (__u16 )(sizeof(cmd) / 4UL);
#line 476
    cmd.out_words = (__u16 )(sizeof(resp) / 4UL);
#line 476
    cmd.response = (__u64 )((uintptr_t )(& resp));
#line 476
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 477
  cmd.srq_handle = srq->handle;
#line 478
  cmd.reserved = (__u32 )0;
#line 480
  tmp___0 = write((srq->context)->cmd_fd, (void const   *)(& cmd), sizeof(cmd));
  }
#line 480
  if ((unsigned long )tmp___0 != sizeof(cmd)) {
    {
#line 481
    tmp = __errno_location();
    }
#line 481
    return (*tmp);
  }
  {
#line 485
  pthread_mutex_lock(& srq->mutex);
  }
  {
#line 486
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 486
    if (! (srq->events_completed != resp.events_reported)) {
#line 486
      goto while_break___0;
    }
    {
#line 487
    pthread_cond_wait((pthread_cond_t */* __restrict  */)(& srq->cond), (pthread_mutex_t */* __restrict  */)(& srq->mutex));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 488
  pthread_mutex_unlock(& srq->mutex);
  }
#line 490
  return (0);
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_create_qp(struct ibv_pd *pd , struct ibv_qp *qp , struct ibv_qp_init_attr *attr ,
                      struct ibv_create_qp *cmd , size_t cmd_size , struct ibv_create_qp_resp *resp ,
                      size_t resp_size ) 
{ 
  int *tmp ;
  ssize_t tmp___0 ;
  struct ibv_create_qp_resp_v4 *resp_v4 ;
  struct ibv_create_qp_resp_v3 *resp_v3 ;

  {
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;
#line 498
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 498
      cmd->command = (__u32 )24;
    } else {
#line 498
      cmd->command = (__u32 )26;
    }
#line 498
    cmd->in_words = (__u16 )(cmd_size / 4UL);
#line 498
    cmd->out_words = (__u16 )(resp_size / 4UL);
#line 498
    cmd->response = (__u64 )((uintptr_t )resp);
#line 498
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 500
  cmd->user_handle = (__u64 )((uintptr_t )qp);
#line 501
  cmd->pd_handle = pd->handle;
#line 502
  cmd->send_cq_handle = (attr->send_cq)->handle;
#line 503
  cmd->recv_cq_handle = (attr->recv_cq)->handle;
#line 504
  if (attr->srq) {
#line 504
    cmd->srq_handle = (attr->srq)->handle;
  } else {
#line 504
    cmd->srq_handle = (__u32 )0;
  }
  {
#line 505
  cmd->max_send_wr = attr->cap.max_send_wr;
#line 506
  cmd->max_recv_wr = attr->cap.max_recv_wr;
#line 507
  cmd->max_send_sge = attr->cap.max_send_sge;
#line 508
  cmd->max_recv_sge = attr->cap.max_recv_sge;
#line 509
  cmd->max_inline_data = attr->cap.max_inline_data;
#line 510
  cmd->sq_sig_all = (__u8 )attr->sq_sig_all;
#line 511
  cmd->qp_type = (__u8 )attr->qp_type;
#line 512
  cmd->is_srq = (__u8 )(! (! attr->srq));
#line 513
  cmd->reserved = (__u8 )0;
#line 515
  tmp___0 = write((pd->context)->cmd_fd, (void const   *)cmd, cmd_size);
  }
#line 515
  if ((size_t )tmp___0 != cmd_size) {
    {
#line 516
    tmp = __errno_location();
    }
#line 516
    return (*tmp);
  }
#line 520
  qp->handle = resp->qp_handle;
#line 521
  qp->qp_num = resp->qpn;
#line 522
  qp->context = pd->context;
#line 524
  if (abi_ver > (int __attribute__((__visibility__("hidden")))  )3) {
#line 525
    attr->cap.max_recv_sge = resp->max_recv_sge;
#line 526
    attr->cap.max_send_sge = resp->max_send_sge;
#line 527
    attr->cap.max_recv_wr = resp->max_recv_wr;
#line 528
    attr->cap.max_send_wr = resp->max_send_wr;
#line 529
    attr->cap.max_inline_data = resp->max_inline_data;
  }
#line 532
  if (abi_ver == (int __attribute__((__visibility__("hidden")))  )4) {
    {
#line 533
    resp_v4 = (struct ibv_create_qp_resp_v4 *)resp;
#line 536
    memmove((void *)resp + sizeof(*resp), (void const   *)((void *)resp_v4 + sizeof(*resp_v4)),
            resp_size - sizeof(*resp));
    }
  } else
#line 539
  if (abi_ver <= (int __attribute__((__visibility__("hidden")))  )3) {
    {
#line 540
    resp_v3 = (struct ibv_create_qp_resp_v3 *)resp;
#line 543
    memmove((void *)resp + sizeof(*resp), (void const   *)((void *)resp_v3 + sizeof(*resp_v3)),
            resp_size - sizeof(*resp));
    }
  }
#line 548
  return (0);
}
}
#line 551 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_query_qp(struct ibv_qp *qp , struct ibv_qp_attr *attr , int attr_mask ,
                     struct ibv_qp_init_attr *init_attr , struct ibv_query_qp *cmd ,
                     size_t cmd_size ) 
{ 
  struct ibv_query_qp_resp resp ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 558
  while (1) {
    while_continue: /* CIL Label */ ;
#line 558
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 558
      cmd->command = (__u32 )25;
    } else {
#line 558
      cmd->command = (__u32 )27;
    }
#line 558
    cmd->in_words = (__u16 )(cmd_size / 4UL);
#line 558
    cmd->out_words = (__u16 )(sizeof(resp) / 4UL);
#line 558
    cmd->response = (__u64 )((uintptr_t )(& resp));
#line 558
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 559
  cmd->qp_handle = qp->handle;
#line 560
  cmd->attr_mask = (__u32 )attr_mask;
#line 562
  tmp___0 = write((qp->context)->cmd_fd, (void const   *)cmd, cmd_size);
  }
#line 562
  if ((size_t )tmp___0 != cmd_size) {
    {
#line 563
    tmp = __errno_location();
    }
#line 563
    return (*tmp);
  }
  {
#line 567
  attr->qkey = resp.qkey;
#line 568
  attr->rq_psn = resp.rq_psn;
#line 569
  attr->sq_psn = resp.sq_psn;
#line 570
  attr->dest_qp_num = resp.dest_qp_num;
#line 571
  attr->qp_access_flags = (int )resp.qp_access_flags;
#line 572
  attr->pkey_index = resp.pkey_index;
#line 573
  attr->alt_pkey_index = resp.alt_pkey_index;
#line 574
  attr->qp_state = (enum ibv_qp_state )resp.qp_state;
#line 575
  attr->cur_qp_state = (enum ibv_qp_state )resp.cur_qp_state;
#line 576
  attr->path_mtu = (enum ibv_mtu )resp.path_mtu;
#line 577
  attr->path_mig_state = (enum ibv_mig_state )resp.path_mig_state;
#line 578
  attr->sq_draining = resp.sq_draining;
#line 579
  attr->max_rd_atomic = resp.max_rd_atomic;
#line 580
  attr->max_dest_rd_atomic = resp.max_dest_rd_atomic;
#line 581
  attr->min_rnr_timer = resp.min_rnr_timer;
#line 582
  attr->port_num = resp.port_num;
#line 583
  attr->timeout = resp.timeout;
#line 584
  attr->retry_cnt = resp.retry_cnt;
#line 585
  attr->rnr_retry = resp.rnr_retry;
#line 586
  attr->alt_port_num = resp.alt_port_num;
#line 587
  attr->alt_timeout = resp.alt_timeout;
#line 588
  attr->cap.max_send_wr = resp.max_send_wr;
#line 589
  attr->cap.max_recv_wr = resp.max_recv_wr;
#line 590
  attr->cap.max_send_sge = resp.max_send_sge;
#line 591
  attr->cap.max_recv_sge = resp.max_recv_sge;
#line 592
  attr->cap.max_inline_data = resp.max_inline_data;
#line 594
  memcpy((void */* __restrict  */)(attr->ah_attr.grh.dgid.raw), (void const   */* __restrict  */)(resp.dest.dgid),
         (size_t )16);
#line 595
  attr->ah_attr.grh.flow_label = resp.dest.flow_label;
#line 596
  attr->ah_attr.dlid = resp.dest.dlid;
#line 597
  attr->ah_attr.grh.sgid_index = resp.dest.sgid_index;
#line 598
  attr->ah_attr.grh.hop_limit = resp.dest.hop_limit;
#line 599
  attr->ah_attr.grh.traffic_class = resp.dest.traffic_class;
#line 600
  attr->ah_attr.sl = resp.dest.sl;
#line 601
  attr->ah_attr.src_path_bits = resp.dest.src_path_bits;
#line 602
  attr->ah_attr.static_rate = resp.dest.static_rate;
#line 603
  attr->ah_attr.is_global = resp.dest.is_global;
#line 604
  attr->ah_attr.port_num = resp.dest.port_num;
#line 606
  memcpy((void */* __restrict  */)(attr->alt_ah_attr.grh.dgid.raw), (void const   */* __restrict  */)(resp.alt_dest.dgid),
         (size_t )16);
#line 607
  attr->alt_ah_attr.grh.flow_label = resp.alt_dest.flow_label;
#line 608
  attr->alt_ah_attr.dlid = resp.alt_dest.dlid;
#line 609
  attr->alt_ah_attr.grh.sgid_index = resp.alt_dest.sgid_index;
#line 610
  attr->alt_ah_attr.grh.hop_limit = resp.alt_dest.hop_limit;
#line 611
  attr->alt_ah_attr.grh.traffic_class = resp.alt_dest.traffic_class;
#line 612
  attr->alt_ah_attr.sl = resp.alt_dest.sl;
#line 613
  attr->alt_ah_attr.src_path_bits = resp.alt_dest.src_path_bits;
#line 614
  attr->alt_ah_attr.static_rate = resp.alt_dest.static_rate;
#line 615
  attr->alt_ah_attr.is_global = resp.alt_dest.is_global;
#line 616
  attr->alt_ah_attr.port_num = resp.alt_dest.port_num;
#line 618
  init_attr->qp_context = qp->qp_context;
#line 619
  init_attr->send_cq = qp->send_cq;
#line 620
  init_attr->recv_cq = qp->recv_cq;
#line 621
  init_attr->srq = qp->srq;
#line 622
  init_attr->qp_type = qp->qp_type;
#line 623
  init_attr->cap.max_send_wr = resp.max_send_wr;
#line 624
  init_attr->cap.max_recv_wr = resp.max_recv_wr;
#line 625
  init_attr->cap.max_send_sge = resp.max_send_sge;
#line 626
  init_attr->cap.max_recv_sge = resp.max_recv_sge;
#line 627
  init_attr->cap.max_inline_data = resp.max_inline_data;
#line 628
  init_attr->sq_sig_all = (int )resp.sq_sig_all;
  }
#line 630
  return (0);
}
}
#line 633 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_modify_qp(struct ibv_qp *qp , struct ibv_qp_attr *attr , int attr_mask ,
                      struct ibv_modify_qp *cmd , size_t cmd_size ) 
{ 
  __u8 tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 637
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 637
      cmd->command = (__u32 )26;
    } else {
#line 637
      cmd->command = (__u32 )28;
    }
#line 637
    cmd->in_words = (__u16 )(cmd_size / 4UL);
#line 637
    cmd->out_words = (__u16 )0;
#line 637
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 639
  cmd->qp_handle = qp->handle;
#line 640
  cmd->attr_mask = (__u32 )attr_mask;
#line 641
  cmd->qkey = attr->qkey;
#line 642
  cmd->rq_psn = attr->rq_psn;
#line 643
  cmd->sq_psn = attr->sq_psn;
#line 644
  cmd->dest_qp_num = attr->dest_qp_num;
#line 645
  cmd->qp_access_flags = (__u32 )attr->qp_access_flags;
#line 646
  cmd->pkey_index = attr->pkey_index;
#line 647
  cmd->alt_pkey_index = attr->alt_pkey_index;
#line 648
  cmd->qp_state = (__u8 )attr->qp_state;
#line 649
  cmd->cur_qp_state = (__u8 )attr->cur_qp_state;
#line 650
  cmd->path_mtu = (__u8 )attr->path_mtu;
#line 651
  cmd->path_mig_state = (__u8 )attr->path_mig_state;
#line 652
  cmd->en_sqd_async_notify = attr->en_sqd_async_notify;
#line 653
  cmd->max_rd_atomic = attr->max_rd_atomic;
#line 654
  cmd->max_dest_rd_atomic = attr->max_dest_rd_atomic;
#line 655
  cmd->min_rnr_timer = attr->min_rnr_timer;
#line 656
  cmd->port_num = attr->port_num;
#line 657
  cmd->timeout = attr->timeout;
#line 658
  cmd->retry_cnt = attr->retry_cnt;
#line 659
  cmd->rnr_retry = attr->rnr_retry;
#line 660
  cmd->alt_port_num = attr->alt_port_num;
#line 661
  cmd->alt_timeout = attr->alt_timeout;
#line 663
  memcpy((void */* __restrict  */)(cmd->dest.dgid), (void const   */* __restrict  */)(attr->ah_attr.grh.dgid.raw),
         (size_t )16);
#line 664
  cmd->dest.flow_label = attr->ah_attr.grh.flow_label;
#line 665
  cmd->dest.dlid = attr->ah_attr.dlid;
#line 666
  cmd->dest.reserved = (__u16 )0;
#line 667
  cmd->dest.sgid_index = attr->ah_attr.grh.sgid_index;
#line 668
  cmd->dest.hop_limit = attr->ah_attr.grh.hop_limit;
#line 669
  cmd->dest.traffic_class = attr->ah_attr.grh.traffic_class;
#line 670
  cmd->dest.sl = attr->ah_attr.sl;
#line 671
  cmd->dest.src_path_bits = attr->ah_attr.src_path_bits;
#line 672
  cmd->dest.static_rate = attr->ah_attr.static_rate;
#line 673
  cmd->dest.is_global = attr->ah_attr.is_global;
#line 674
  cmd->dest.port_num = attr->ah_attr.port_num;
#line 676
  memcpy((void */* __restrict  */)(cmd->alt_dest.dgid), (void const   */* __restrict  */)(attr->alt_ah_attr.grh.dgid.raw),
         (size_t )16);
#line 677
  cmd->alt_dest.flow_label = attr->alt_ah_attr.grh.flow_label;
#line 678
  cmd->alt_dest.dlid = attr->alt_ah_attr.dlid;
#line 679
  cmd->alt_dest.reserved = (__u16 )0;
#line 680
  cmd->alt_dest.sgid_index = attr->alt_ah_attr.grh.sgid_index;
#line 681
  cmd->alt_dest.hop_limit = attr->alt_ah_attr.grh.hop_limit;
#line 682
  cmd->alt_dest.traffic_class = attr->alt_ah_attr.grh.traffic_class;
#line 683
  cmd->alt_dest.sl = attr->alt_ah_attr.sl;
#line 684
  cmd->alt_dest.src_path_bits = attr->alt_ah_attr.src_path_bits;
#line 685
  cmd->alt_dest.static_rate = attr->alt_ah_attr.static_rate;
#line 686
  cmd->alt_dest.is_global = attr->alt_ah_attr.is_global;
#line 687
  cmd->alt_dest.port_num = attr->alt_ah_attr.port_num;
#line 689
  tmp = (__u8 )0;
#line 689
  cmd->reserved[1] = tmp;
#line 689
  cmd->reserved[0] = tmp;
#line 691
  tmp___1 = write((qp->context)->cmd_fd, (void const   *)cmd, cmd_size);
  }
#line 691
  if ((size_t )tmp___1 != cmd_size) {
    {
#line 692
    tmp___0 = __errno_location();
    }
#line 692
    return (*tmp___0);
  }
#line 694
  return (0);
}
}
#line 697 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_post_send(struct ibv_qp *ibqp , struct ibv_send_wr *wr , struct ibv_send_wr **bad_wr ) 
{ 
  struct ibv_post_send *cmd ;
  struct ibv_post_send_resp resp ;
  struct ibv_send_wr *i ;
  struct ibv_kern_send_wr *n ;
  struct ibv_kern_send_wr *tmp ;
  struct ibv_sge *s ;
  unsigned int wr_count ;
  unsigned int sge_count ;
  int cmd_size ;
  int ret ;
  void *tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 705
  wr_count = 0U;
#line 706
  sge_count = 0U;
#line 708
  ret = 0;
#line 710
  i = wr;
  {
#line 710
  while (1) {
    while_continue: /* CIL Label */ ;
#line 710
    if (! i) {
#line 710
      goto while_break;
    }
#line 711
    wr_count ++;
#line 712
    sge_count += (unsigned int )i->num_sge;
#line 710
    i = i->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 715
  cmd_size = (int )((sizeof(*cmd) + (unsigned long )wr_count * sizeof(*n)) + (unsigned long )sge_count * sizeof(*s));
#line 716
  tmp___0 = __builtin_alloca((unsigned long )cmd_size);
#line 716
  cmd = (struct ibv_post_send *)tmp___0;
  }
  {
#line 718
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 718
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 718
      cmd->command = (__u32 )28;
    } else {
#line 718
      cmd->command = (__u32 )30;
    }
#line 718
    cmd->in_words = (__u16 )(cmd_size / 4);
#line 718
    cmd->out_words = (__u16 )(sizeof(resp) / 4UL);
#line 718
    cmd->response = (__u64 )((uintptr_t )(& resp));
#line 718
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 719
  cmd->qp_handle = ibqp->handle;
#line 720
  cmd->wr_count = wr_count;
#line 721
  cmd->sge_count = sge_count;
#line 722
  cmd->wqe_size = (__u32 )sizeof(*n);
#line 724
  n = (struct ibv_kern_send_wr *)((void *)cmd + sizeof(*cmd));
#line 725
  s = (struct ibv_sge *)(n + wr_count);
#line 727
  tmp = n;
#line 728
  i = wr;
  {
#line 728
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 728
    if (! i) {
#line 728
      goto while_break___1;
    }
#line 729
    tmp->wr_id = (__u64 )i->wr_id;
#line 730
    tmp->num_sge = (__u32 )i->num_sge;
#line 731
    tmp->opcode = (__u32 )i->opcode;
#line 732
    tmp->send_flags = (__u32 )i->send_flags;
#line 733
    tmp->imm_data = i->imm_data;
#line 734
    if ((unsigned int )ibqp->qp_type == 4U) {
#line 735
      tmp->wr.ud.ah = (i->wr.ud.ah)->handle;
#line 736
      tmp->wr.ud.remote_qpn = i->wr.ud.remote_qpn;
#line 737
      tmp->wr.ud.remote_qkey = i->wr.ud.remote_qkey;
    } else {
      {
#line 742
      if ((unsigned int )i->opcode == 4U) {
#line 742
        goto case_4;
      }
#line 742
      if ((unsigned int )i->opcode == 1U) {
#line 742
        goto case_4;
      }
#line 742
      if ((unsigned int )i->opcode == 0U) {
#line 742
        goto case_4;
      }
#line 748
      if ((unsigned int )i->opcode == 6U) {
#line 748
        goto case_6;
      }
#line 748
      if ((unsigned int )i->opcode == 5U) {
#line 748
        goto case_6;
      }
#line 756
      goto switch_default;
      case_4: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 743
      tmp->wr.rdma.remote_addr = (__u64 )i->wr.rdma.remote_addr;
#line 745
      tmp->wr.rdma.rkey = i->wr.rdma.rkey;
#line 746
      goto switch_break;
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
#line 749
      tmp->wr.atomic.remote_addr = (__u64 )i->wr.atomic.remote_addr;
#line 751
      tmp->wr.atomic.compare_add = (__u64 )i->wr.atomic.compare_add;
#line 753
      tmp->wr.atomic.swap = (__u64 )i->wr.atomic.swap;
#line 754
      tmp->wr.atomic.rkey = i->wr.atomic.rkey;
#line 755
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 757
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 761
    if (tmp->num_sge) {
      {
#line 762
      memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)i->sg_list,
             (unsigned long )tmp->num_sge * sizeof(*s));
#line 763
      s += tmp->num_sge;
      }
    }
#line 766
    tmp ++;
#line 728
    i = i->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 769
  resp.bad_wr = (__u32 )0;
#line 770
  tmp___2 = write((ibqp->context)->cmd_fd, (void const   *)cmd, (size_t )cmd_size);
  }
#line 770
  if (tmp___2 != (ssize_t )cmd_size) {
    {
#line 771
    tmp___1 = __errno_location();
#line 771
    ret = *tmp___1;
    }
  }
#line 775
  wr_count = resp.bad_wr;
#line 776
  if (wr_count) {
#line 777
    i = wr;
    {
#line 778
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 778
      wr_count --;
#line 778
      if (! wr_count) {
#line 778
        goto while_break___2;
      }
#line 779
      i = i->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 780
    *bad_wr = i;
  } else
#line 781
  if (ret) {
#line 782
    *bad_wr = wr;
  }
#line 784
  return (ret);
}
}
#line 787 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_post_recv(struct ibv_qp *ibqp , struct ibv_recv_wr *wr , struct ibv_recv_wr **bad_wr ) 
{ 
  struct ibv_post_recv *cmd ;
  struct ibv_post_recv_resp resp ;
  struct ibv_recv_wr *i ;
  struct ibv_kern_recv_wr *n ;
  struct ibv_kern_recv_wr *tmp ;
  struct ibv_sge *s ;
  unsigned int wr_count ;
  unsigned int sge_count ;
  int cmd_size ;
  int ret ;
  void *tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 795
  wr_count = 0U;
#line 796
  sge_count = 0U;
#line 798
  ret = 0;
#line 800
  i = wr;
  {
#line 800
  while (1) {
    while_continue: /* CIL Label */ ;
#line 800
    if (! i) {
#line 800
      goto while_break;
    }
#line 801
    wr_count ++;
#line 802
    sge_count += (unsigned int )i->num_sge;
#line 800
    i = i->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 805
  cmd_size = (int )((sizeof(*cmd) + (unsigned long )wr_count * sizeof(*n)) + (unsigned long )sge_count * sizeof(*s));
#line 806
  tmp___0 = __builtin_alloca((unsigned long )cmd_size);
#line 806
  cmd = (struct ibv_post_recv *)tmp___0;
  }
  {
#line 808
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 808
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 808
      cmd->command = (__u32 )29;
    } else {
#line 808
      cmd->command = (__u32 )31;
    }
#line 808
    cmd->in_words = (__u16 )(cmd_size / 4);
#line 808
    cmd->out_words = (__u16 )(sizeof(resp) / 4UL);
#line 808
    cmd->response = (__u64 )((uintptr_t )(& resp));
#line 808
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 809
  cmd->qp_handle = ibqp->handle;
#line 810
  cmd->wr_count = wr_count;
#line 811
  cmd->sge_count = sge_count;
#line 812
  cmd->wqe_size = (__u32 )sizeof(*n);
#line 814
  n = (struct ibv_kern_recv_wr *)((void *)cmd + sizeof(*cmd));
#line 815
  s = (struct ibv_sge *)(n + wr_count);
#line 817
  tmp = n;
#line 818
  i = wr;
  {
#line 818
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 818
    if (! i) {
#line 818
      goto while_break___1;
    }
#line 819
    tmp->wr_id = (__u64 )i->wr_id;
#line 820
    tmp->num_sge = (__u32 )i->num_sge;
#line 822
    if (tmp->num_sge) {
      {
#line 823
      memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)i->sg_list,
             (unsigned long )tmp->num_sge * sizeof(*s));
#line 824
      s += tmp->num_sge;
      }
    }
#line 827
    tmp ++;
#line 818
    i = i->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 830
  resp.bad_wr = (__u32 )0;
#line 831
  tmp___2 = write((ibqp->context)->cmd_fd, (void const   *)cmd, (size_t )cmd_size);
  }
#line 831
  if (tmp___2 != (ssize_t )cmd_size) {
    {
#line 832
    tmp___1 = __errno_location();
#line 832
    ret = *tmp___1;
    }
  }
#line 836
  wr_count = resp.bad_wr;
#line 837
  if (wr_count) {
#line 838
    i = wr;
    {
#line 839
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 839
      wr_count --;
#line 839
      if (! wr_count) {
#line 839
        goto while_break___2;
      }
#line 840
      i = i->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 841
    *bad_wr = i;
  } else
#line 842
  if (ret) {
#line 843
    *bad_wr = wr;
  }
#line 845
  return (ret);
}
}
#line 848 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_post_srq_recv(struct ibv_srq *srq , struct ibv_recv_wr *wr , struct ibv_recv_wr **bad_wr ) 
{ 
  struct ibv_post_srq_recv *cmd ;
  struct ibv_post_srq_recv_resp resp ;
  struct ibv_recv_wr *i ;
  struct ibv_kern_recv_wr *n ;
  struct ibv_kern_recv_wr *tmp ;
  struct ibv_sge *s ;
  unsigned int wr_count ;
  unsigned int sge_count ;
  int cmd_size ;
  int ret ;
  void *tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 856
  wr_count = 0U;
#line 857
  sge_count = 0U;
#line 859
  ret = 0;
#line 861
  i = wr;
  {
#line 861
  while (1) {
    while_continue: /* CIL Label */ ;
#line 861
    if (! i) {
#line 861
      goto while_break;
    }
#line 862
    wr_count ++;
#line 863
    sge_count += (unsigned int )i->num_sge;
#line 861
    i = i->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 866
  cmd_size = (int )((sizeof(*cmd) + (unsigned long )wr_count * sizeof(*n)) + (unsigned long )sge_count * sizeof(*s));
#line 867
  tmp___0 = __builtin_alloca((unsigned long )cmd_size);
#line 867
  cmd = (struct ibv_post_srq_recv *)tmp___0;
  }
  {
#line 869
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 869
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 869
      cmd->command = (__u32 )36;
    } else {
#line 869
      cmd->command = (__u32 )38;
    }
#line 869
    cmd->in_words = (__u16 )(cmd_size / 4);
#line 869
    cmd->out_words = (__u16 )(sizeof(resp) / 4UL);
#line 869
    cmd->response = (__u64 )((uintptr_t )(& resp));
#line 869
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 870
  cmd->srq_handle = srq->handle;
#line 871
  cmd->wr_count = wr_count;
#line 872
  cmd->sge_count = sge_count;
#line 873
  cmd->wqe_size = (__u32 )sizeof(*n);
#line 875
  n = (struct ibv_kern_recv_wr *)((void *)cmd + sizeof(*cmd));
#line 876
  s = (struct ibv_sge *)(n + wr_count);
#line 878
  tmp = n;
#line 879
  i = wr;
  {
#line 879
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 879
    if (! i) {
#line 879
      goto while_break___1;
    }
#line 880
    tmp->wr_id = (__u64 )i->wr_id;
#line 881
    tmp->num_sge = (__u32 )i->num_sge;
#line 883
    if (tmp->num_sge) {
      {
#line 884
      memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)i->sg_list,
             (unsigned long )tmp->num_sge * sizeof(*s));
#line 885
      s += tmp->num_sge;
      }
    }
#line 888
    tmp ++;
#line 879
    i = i->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 891
  resp.bad_wr = (__u32 )0;
#line 892
  tmp___2 = write((srq->context)->cmd_fd, (void const   *)cmd, (size_t )cmd_size);
  }
#line 892
  if (tmp___2 != (ssize_t )cmd_size) {
    {
#line 893
    tmp___1 = __errno_location();
#line 893
    ret = *tmp___1;
    }
  }
#line 897
  wr_count = resp.bad_wr;
#line 898
  if (wr_count) {
#line 899
    i = wr;
    {
#line 900
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 900
      wr_count --;
#line 900
      if (! wr_count) {
#line 900
        goto while_break___2;
      }
#line 901
      i = i->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 902
    *bad_wr = i;
  } else
#line 903
  if (ret) {
#line 904
    *bad_wr = wr;
  }
#line 906
  return (ret);
}
}
#line 909 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_create_ah(struct ibv_pd *pd , struct ibv_ah *ah , struct ibv_ah_attr *attr ) 
{ 
  struct ibv_create_ah cmd ;
  struct ibv_create_ah_resp resp ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 915
  while (1) {
    while_continue: /* CIL Label */ ;
#line 915
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 915
      cmd.command = (__u32 )5;
    } else {
#line 915
      cmd.command = (__u32 )8;
    }
#line 915
    cmd.in_words = (__u16 )(sizeof(cmd) / 4UL);
#line 915
    cmd.out_words = (__u16 )(sizeof(resp) / 4UL);
#line 915
    cmd.response = (__u64 )((uintptr_t )(& resp));
#line 915
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 916
  cmd.user_handle = (__u64 )((uintptr_t )ah);
#line 917
  cmd.pd_handle = pd->handle;
#line 918
  cmd.attr.dlid = attr->dlid;
#line 919
  cmd.attr.sl = attr->sl;
#line 920
  cmd.attr.src_path_bits = attr->src_path_bits;
#line 921
  cmd.attr.static_rate = attr->static_rate;
#line 922
  cmd.attr.is_global = attr->is_global;
#line 923
  cmd.attr.port_num = attr->port_num;
#line 924
  cmd.attr.grh.flow_label = attr->grh.flow_label;
#line 925
  cmd.attr.grh.sgid_index = attr->grh.sgid_index;
#line 926
  cmd.attr.grh.hop_limit = attr->grh.hop_limit;
#line 927
  cmd.attr.grh.traffic_class = attr->grh.traffic_class;
#line 928
  memcpy((void */* __restrict  */)(cmd.attr.grh.dgid), (void const   */* __restrict  */)(attr->grh.dgid.raw),
         (size_t )16);
#line 930
  tmp___0 = write((pd->context)->cmd_fd, (void const   *)(& cmd), sizeof(cmd));
  }
#line 930
  if ((unsigned long )tmp___0 != sizeof(cmd)) {
    {
#line 931
    tmp = __errno_location();
    }
#line 931
    return (*tmp);
  }
#line 935
  ah->handle = resp.handle;
#line 936
  ah->context = pd->context;
#line 938
  return (0);
}
}
#line 941 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_destroy_ah(struct ibv_ah *ah ) 
{ 
  struct ibv_destroy_ah cmd ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 945
  while (1) {
    while_continue: /* CIL Label */ ;
#line 945
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 945
      cmd.command = (__u32 )8;
    } else {
#line 945
      cmd.command = (__u32 )11;
    }
#line 945
    cmd.in_words = (__u16 )(sizeof(cmd) / 4UL);
#line 945
    cmd.out_words = (__u16 )0;
#line 945
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 946
  cmd.ah_handle = ah->handle;
#line 948
  tmp___0 = write((ah->context)->cmd_fd, (void const   *)(& cmd), sizeof(cmd));
  }
#line 948
  if ((unsigned long )tmp___0 != sizeof(cmd)) {
    {
#line 949
    tmp = __errno_location();
    }
#line 949
    return (*tmp);
  }
#line 951
  return (0);
}
}
#line 954 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_destroy_qp(struct ibv_qp *qp ) 
{ 
  struct ibv_destroy_qp cmd ;
  struct ibv_destroy_qp_resp resp ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 959
  while (1) {
    while_continue: /* CIL Label */ ;
#line 959
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 959
      cmd.command = (__u32 )27;
    } else {
#line 959
      cmd.command = (__u32 )29;
    }
#line 959
    cmd.in_words = (__u16 )(sizeof(cmd) / 4UL);
#line 959
    cmd.out_words = (__u16 )(sizeof(resp) / 4UL);
#line 959
    cmd.response = (__u64 )((uintptr_t )(& resp));
#line 959
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 960
  cmd.qp_handle = qp->handle;
#line 961
  cmd.reserved = (__u32 )0;
#line 963
  tmp___0 = write((qp->context)->cmd_fd, (void const   *)(& cmd), sizeof(cmd));
  }
#line 963
  if ((unsigned long )tmp___0 != sizeof(cmd)) {
    {
#line 964
    tmp = __errno_location();
    }
#line 964
    return (*tmp);
  }
  {
#line 968
  pthread_mutex_lock(& qp->mutex);
  }
  {
#line 969
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 969
    if (! (qp->events_completed != resp.events_reported)) {
#line 969
      goto while_break___0;
    }
    {
#line 970
    pthread_cond_wait((pthread_cond_t */* __restrict  */)(& qp->cond), (pthread_mutex_t */* __restrict  */)(& qp->mutex));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 971
  pthread_mutex_unlock(& qp->mutex);
  }
#line 973
  return (0);
}
}
#line 976 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_attach_mcast(struct ibv_qp *qp , union ibv_gid  const  *gid , uint16_t lid ) 
{ 
  struct ibv_attach_mcast cmd ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 980
  while (1) {
    while_continue: /* CIL Label */ ;
#line 980
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 980
      cmd.command = (__u32 )30;
    } else {
#line 980
      cmd.command = (__u32 )32;
    }
#line 980
    cmd.in_words = (__u16 )(sizeof(cmd) / 4UL);
#line 980
    cmd.out_words = (__u16 )0;
#line 980
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 981
  memcpy((void */* __restrict  */)(cmd.gid), (void const   */* __restrict  */)(gid->raw),
         sizeof(cmd.gid));
#line 982
  cmd.qp_handle = qp->handle;
#line 983
  cmd.mlid = lid;
#line 984
  cmd.reserved = (__u16 )0;
#line 986
  tmp___0 = write((qp->context)->cmd_fd, (void const   *)(& cmd), sizeof(cmd));
  }
#line 986
  if ((unsigned long )tmp___0 != sizeof(cmd)) {
    {
#line 987
    tmp = __errno_location();
    }
#line 987
    return (*tmp);
  }
#line 989
  return (0);
}
}
#line 992 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_detach_mcast(struct ibv_qp *qp , union ibv_gid  const  *gid , uint16_t lid ) 
{ 
  struct ibv_detach_mcast cmd ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 996
  while (1) {
    while_continue: /* CIL Label */ ;
#line 996
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 996
      cmd.command = (__u32 )31;
    } else {
#line 996
      cmd.command = (__u32 )33;
    }
#line 996
    cmd.in_words = (__u16 )(sizeof(cmd) / 4UL);
#line 996
    cmd.out_words = (__u16 )0;
#line 996
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 997
  memcpy((void */* __restrict  */)(cmd.gid), (void const   */* __restrict  */)(gid->raw),
         sizeof(cmd.gid));
#line 998
  cmd.qp_handle = qp->handle;
#line 999
  cmd.mlid = lid;
#line 1000
  cmd.reserved = (__u16 )0;
#line 1002
  tmp___0 = write((qp->context)->cmd_fd, (void const   *)(& cmd), sizeof(cmd));
  }
#line 1002
  if ((unsigned long )tmp___0 != sizeof(cmd)) {
    {
#line 1003
    tmp = __errno_location();
    }
#line 1003
    return (*tmp);
  }
#line 1005
  return (0);
}
}
#line 1008 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
static int ib_spec_to_kern_spec(struct ibv_flow_spec *ib_spec , struct ibv_kern_spec *kern_spec ) 
{ 


  {
#line 1011
  kern_spec->__annonCompField5.hdr.type = (__u32 )ib_spec->__annonCompField1.hdr.type;
  {
#line 1014
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 32U) {
#line 1014
    goto case_32;
  }
#line 1021
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 48U) {
#line 1021
    goto case_48;
  }
#line 1029
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 65U) {
#line 1029
    goto case_65;
  }
#line 1029
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 64U) {
#line 1029
    goto case_65;
  }
#line 1036
  goto switch_default;
  case_32: /* CIL Label */ 
  {
#line 1015
  kern_spec->__annonCompField5.eth.size = (__u16 )sizeof(struct ibv_kern_spec_eth );
#line 1016
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.eth.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.eth.val),
         sizeof(struct ibv_flow_eth_filter ));
#line 1018
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.eth.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.eth.mask),
         sizeof(struct ibv_flow_eth_filter ));
  }
#line 1020
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 1022
  kern_spec->__annonCompField5.ipv4.size = (__u16 )sizeof(struct ibv_kern_spec_ipv4 );
#line 1023
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.ipv4.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.ipv4.val),
         sizeof(struct ibv_flow_ipv4_filter ));
#line 1025
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.ipv4.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.ipv4.mask),
         sizeof(struct ibv_flow_ipv4_filter ));
  }
#line 1027
  goto switch_break;
  case_65: /* CIL Label */ 
  case_64: /* CIL Label */ 
  {
#line 1030
  kern_spec->__annonCompField5.tcp_udp.size = (__u16 )sizeof(struct ibv_kern_spec_tcp_udp );
#line 1031
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.tcp_udp.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.tcp_udp.val),
         sizeof(struct ibv_flow_ipv4_filter ));
#line 1033
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.tcp_udp.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.tcp_udp.mask),
         sizeof(struct ibv_flow_tcp_udp_filter ));
  }
#line 1035
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1037
  return (-22);
  switch_break: /* CIL Label */ ;
  }
#line 1039
  return (0);
}
}
#line 1042 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
struct ibv_flow *ibv_cmd_create_flow(struct ibv_qp *qp , struct ibv_flow_attr *flow_attr ) 
{ 
  struct ibv_create_flow *cmd ;
  struct ibv_create_flow_resp resp ;
  struct ibv_flow *flow_id ;
  size_t cmd_size ;
  size_t written_size ;
  int i ;
  int err ;
  void *kern_spec ;
  void *ib_spec ;
  void *tmp ;
  void *tmp___0 ;
  size_t c_size ;
  ssize_t tmp___1 ;

  {
  {
#line 1054
  cmd_size = sizeof(*cmd) + (unsigned long )flow_attr->num_of_specs * sizeof(struct ibv_kern_spec );
#line 1056
  tmp = __builtin_alloca(cmd_size);
#line 1056
  cmd = (struct ibv_create_flow *)tmp;
#line 1057
  tmp___0 = malloc(sizeof(*flow_id));
#line 1057
  flow_id = (struct ibv_flow *)tmp___0;
  }
#line 1058
  if (! flow_id) {
#line 1059
    return ((struct ibv_flow *)((void *)0));
  }
  {
#line 1060
  memset((void *)cmd, 0, cmd_size);
#line 1062
  cmd->qp_handle = qp->handle;
#line 1064
  cmd->flow_attr.type = (__u32 )flow_attr->type;
#line 1065
  cmd->flow_attr.priority = flow_attr->priority;
#line 1066
  cmd->flow_attr.num_of_specs = flow_attr->num_of_specs;
#line 1067
  cmd->flow_attr.port = flow_attr->port;
#line 1068
  cmd->flow_attr.flags = flow_attr->flags;
#line 1070
  kern_spec = (void *)(cmd + 1);
#line 1071
  ib_spec = (void *)(flow_attr + 1);
#line 1072
  i = 0;
  }
  {
#line 1072
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1072
    if (! (i < (int )flow_attr->num_of_specs)) {
#line 1072
      goto while_break;
    }
    {
#line 1073
    err = ib_spec_to_kern_spec((struct ibv_flow_spec *)ib_spec, (struct ibv_kern_spec *)kern_spec);
    }
#line 1074
    if (err) {
#line 1075
      goto err;
    }
#line 1076
    cmd->flow_attr.size = (__u16 )((int )cmd->flow_attr.size + (int )((struct ibv_kern_spec *)kern_spec)->__annonCompField5.hdr.size);
#line 1078
    kern_spec += (int )((struct ibv_kern_spec *)kern_spec)->__annonCompField5.hdr.size;
#line 1079
    ib_spec += (int )((struct ibv_flow_spec *)ib_spec)->__annonCompField1.hdr.size;
#line 1072
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1082
  written_size = sizeof(*cmd) + (unsigned long )cmd->flow_attr.size;
  {
#line 1083
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1083
    c_size = written_size - sizeof(struct ex_hdr );
#line 1083
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 1083
      cmd->hdr.__annonCompField2.command = 2147483698U;
    } else {
#line 1083
      cmd->hdr.__annonCompField2.command = (__u32 )-1;
    }
#line 1083
    cmd->hdr.__annonCompField2.in_words = (__u16 )(c_size / 8UL);
#line 1083
    cmd->hdr.__annonCompField2.out_words = (__u16 )(sizeof(resp) / 8UL);
#line 1083
    cmd->hdr.__annonCompField4.provider_in_words = (__u16 )((written_size - written_size) / 8UL);
#line 1083
    cmd->hdr.__annonCompField4.provider_out_words = (__u16 )((sizeof(resp) - sizeof(resp)) / 8UL);
#line 1083
    cmd->hdr.__annonCompField3.response = (__u64 )((uintptr_t )(& resp));
#line 1083
    cmd->hdr.__annonCompField4.reserved = (__u32 )0;
#line 1083
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1085
  tmp___1 = write((qp->context)->cmd_fd, (void const   *)cmd, written_size);
  }
#line 1085
  if ((size_t )tmp___1 != written_size) {
#line 1086
    goto err;
  }
#line 1090
  flow_id->context = qp->context;
#line 1091
  flow_id->handle = resp.flow_handle;
#line 1092
  return (flow_id);
  err: 
  {
#line 1094
  free((void *)flow_id);
  }
#line 1095
  return ((struct ibv_flow *)((void *)0));
}
}
#line 1098 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
int ibv_cmd_destroy_flow(struct ibv_flow *flow_id ) 
{ 
  struct ibv_destroy_flow cmd ;
  int ret ;
  size_t c_size ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 1101
  ret = 0;
#line 1103
  memset((void *)(& cmd), 0, sizeof(cmd));
  }
  {
#line 1104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1104
    c_size = sizeof(cmd) - sizeof(struct ex_hdr );
#line 1104
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 1104
      cmd.hdr.__annonCompField2.command = 2147483699U;
    } else {
#line 1104
      cmd.hdr.__annonCompField2.command = (__u32 )-1;
    }
#line 1104
    cmd.hdr.__annonCompField2.in_words = (__u16 )(c_size / 8UL);
#line 1104
    cmd.hdr.__annonCompField2.out_words = (__u16 )0;
#line 1104
    cmd.hdr.__annonCompField4.provider_in_words = (__u16 )((sizeof(cmd) - sizeof(cmd)) / 8UL);
#line 1104
    cmd.hdr.__annonCompField4.provider_out_words = (__u16 )0;
#line 1104
    cmd.hdr.__annonCompField3.response = (__u64 )((uintptr_t )((void *)0));
#line 1104
    cmd.hdr.__annonCompField4.reserved = (__u32 )0;
#line 1104
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1105
  cmd.flow_handle = flow_id->handle;
#line 1107
  tmp___0 = write((flow_id->context)->cmd_fd, (void const   *)(& cmd), sizeof(cmd));
  }
#line 1107
  if ((unsigned long )tmp___0 != sizeof(cmd)) {
    {
#line 1108
    tmp = __errno_location();
#line 1108
    ret = *tmp;
    }
  }
  {
#line 1109
  free((void *)flow_id);
  }
#line 1110
  return (ret);
}
}
#line 1322 "./include/infiniband/verbs.h"
char const   *ibv_node_type_str(enum ibv_node_type node_type ) ;
#line 1327
char const   *ibv_port_state_str(enum ibv_port_state port_state ) ;
#line 1332
char const   *ibv_event_type_str(enum ibv_event_type event ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  node_type_str[5]  = {      (char const   */* const  */)0,      (char const   */* const  */)"InfiniBand channel adapter",      (char const   */* const  */)"InfiniBand switch",      (char const   */* const  */)"InfiniBand router", 
        (char const   */* const  */)"iWARP NIC"};
#line 35 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
char const   *ibv_node_type_str(enum ibv_node_type node_type ) 
{ 


  {
#line 44
  if ((int )node_type < 1) {
#line 45
    return ("unknown");
  } else
#line 44
  if ((int )node_type > 4) {
#line 45
    return ("unknown");
  }
#line 47
  return ((char const   *)node_type_str[node_type]);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  port_state_str[6]  = {      (char const   */* const  */)"no state change (NOP)",      (char const   */* const  */)"down",      (char const   */* const  */)"init",      (char const   */* const  */)"armed", 
        (char const   */* const  */)"active",      (char const   */* const  */)"active defer"};
#line 50 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
char const   *ibv_port_state_str(enum ibv_port_state port_state ) 
{ 


  {
#line 61
  if ((unsigned int )port_state < 0U) {
#line 62
    return ("unknown");
  } else
#line 61
  if ((unsigned int )port_state > 5U) {
#line 62
    return ("unknown");
  }
#line 64
  return ((char const   *)port_state_str[port_state]);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  event_type_str[19]  = 
#line 69
  {      (char const   */* const  */)"CQ error",      (char const   */* const  */)"local work queue catastrophic error",      (char const   */* const  */)"invalid request local work queue error",      (char const   */* const  */)"local access violation work queue error", 
        (char const   */* const  */)"communication established",      (char const   */* const  */)"send queue drained",      (char const   */* const  */)"path migrated",      (char const   */* const  */)"path migration request error", 
        (char const   */* const  */)"local catastrophic error",      (char const   */* const  */)"port active",      (char const   */* const  */)"port error",      (char const   */* const  */)"LID change", 
        (char const   */* const  */)"P_Key change",      (char const   */* const  */)"SM change",      (char const   */* const  */)"SRQ catastrophic error",      (char const   */* const  */)"SRQ limit reached", 
        (char const   */* const  */)"last WQE reached",      (char const   */* const  */)"client reregistration",      (char const   */* const  */)"GID table change"};
#line 67 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
char const   *ibv_event_type_str(enum ibv_event_type event ) 
{ 


  {
#line 91
  if ((unsigned int )event < 0U) {
#line 92
    return ("unknown");
  } else
#line 91
  if ((unsigned int )event > 18U) {
#line 92
    return ("unknown");
  }
#line 94
  return ((char const   *)event_type_str[event]);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  wc_status_str[22]  = 
#line 99
  {      (char const   */* const  */)"success",      (char const   */* const  */)"local length error",      (char const   */* const  */)"local QP operation error",      (char const   */* const  */)"local EE context operation error", 
        (char const   */* const  */)"local protection error",      (char const   */* const  */)"Work Request Flushed Error",      (char const   */* const  */)"memory management operation error",      (char const   */* const  */)"bad response error", 
        (char const   */* const  */)"local access error",      (char const   */* const  */)"remote invalid request error",      (char const   */* const  */)"remote access error",      (char const   */* const  */)"remote operation error", 
        (char const   */* const  */)"transport retry counter exceeded",      (char const   */* const  */)"RNR retry counter exceeded",      (char const   */* const  */)"local RDD violation error",      (char const   */* const  */)"remote invalid RD request", 
        (char const   */* const  */)"aborted error",      (char const   */* const  */)"invalid EE context number",      (char const   */* const  */)"invalid EE context state",      (char const   */* const  */)"fatal error", 
        (char const   */* const  */)"response timeout error",      (char const   */* const  */)"general error"};
#line 97 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
char const   *ibv_wc_status_str(enum ibv_wc_status status ) 
{ 


  {
#line 124
  if ((unsigned int )status < 0U) {
#line 125
    return ("unknown");
  } else
#line 124
  if ((unsigned int )status > 21U) {
#line 125
    return ("unknown");
  }
#line 127
  return ((char const   *)wc_status_str[status]);
}
}
#line 928 "./include/infiniband/verbs.h"
extern uint64_t ibv_get_device_guid(struct ibv_device *device ) ;
#line 947
extern int ibv_get_async_event(struct ibv_context *context , struct ibv_async_event *event ) ;
#line 960
extern void ibv_ack_async_event(struct ibv_async_event *event ) ;
#line 965
extern int ibv_query_device(struct ibv_context *context , struct ibv_device_attr *device_attr ) ;
#line 997
extern int ibv_query_pkey(struct ibv_context *context , uint8_t port_num , int index ,
                          uint16_t *pkey ) ;
#line 1073
extern int ibv_resize_cq(struct ibv_cq *cq , int cqe ) ;
#line 1150
extern struct ibv_srq *ibv_create_srq(struct ibv_pd *pd , struct ibv_srq_init_attr *srq_init_attr ) ;
#line 1165
extern int ibv_modify_srq(struct ibv_srq *srq , struct ibv_srq_attr *srq_attr , int srq_attr_mask ) ;
#line 1175
extern int ibv_query_srq(struct ibv_srq *srq , struct ibv_srq_attr *srq_attr ) ;
#line 1181
extern int ibv_destroy_srq(struct ibv_srq *srq ) ;
#line 1220
extern int ibv_query_qp(struct ibv_qp *qp , struct ibv_qp_attr *attr , int attr_mask ,
                        struct ibv_qp_init_attr *init_attr ) ;
#line 1288
extern int ibv_destroy_ah(struct ibv_ah *ah ) ;
#line 1301
extern int ibv_attach_mcast(struct ibv_qp *qp , union ibv_gid  const  *gid , uint16_t lid ) ;
#line 1309
extern int ibv_detach_mcast(struct ibv_qp *qp , union ibv_gid  const  *gid , uint16_t lid ) ;
#line 229 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct ibv_device_1_0 **__ibv_get_device_list_1_0(int *num ) 
{ 
  struct ibv_device **real_list ;
  struct ibv_device_1_0 **l ;
  int i ;
  int n ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 235
  real_list = ibv_get_device_list(& n);
  }
#line 236
  if (! real_list) {
#line 237
    return ((struct ibv_device_1_0 **)((void *)0));
  }
  {
#line 239
  tmp = calloc((size_t )(n + 2), sizeof(struct ibv_device_1_0 *));
#line 239
  l = (struct ibv_device_1_0 **)tmp;
  }
#line 240
  if (! l) {
#line 241
    goto free_device_list;
  }
#line 243
  *(l + 0) = (struct ibv_device_1_0 *)((void *)real_list);
#line 245
  i = 0;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! (i < n)) {
#line 245
      goto while_break;
    }
    {
#line 246
    tmp___0 = calloc((size_t )1, sizeof(struct ibv_device_1_0 ));
#line 246
    *(l + (i + 1)) = (struct ibv_device_1_0 *)tmp___0;
    }
#line 247
    if (! *(l + (i + 1))) {
#line 248
      goto fail;
    }
#line 249
    (*(l + (i + 1)))->real_device = *(real_list + i);
#line 245
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  if (num) {
#line 253
    *num = n;
  }
#line 255
  return (l + 1);
  fail: 
#line 258
  i = 1;
  {
#line 258
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 258
    if (! (i <= n)) {
#line 258
      goto while_break___0;
    }
#line 259
    if (*(l + i)) {
      {
#line 260
      free((void *)*(l + i));
      }
    }
#line 258
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 261
  free((void *)l);
  }
  free_device_list: 
  {
#line 264
  ibv_free_device_list(real_list);
  }
#line 265
  return ((struct ibv_device_1_0 **)((void *)0));
}
}
#line 267
__asm__(".symver __ibv_get_device_list_1_0,ibv_get_device_list@IBVERBS_1.0");
#line 269 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
void __ibv_free_device_list_1_0(struct ibv_device_1_0 **list ) 
{ 
  struct ibv_device_1_0 **l ;

  {
#line 271
  l = list;
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    if (! *l) {
#line 273
      goto while_break;
    }
    {
#line 274
    free((void *)*l);
#line 275
    l ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 278
  ibv_free_device_list((struct ibv_device **)((void *)*(list + -1)));
#line 279
  free((void *)(list - 1));
  }
#line 280
  return;
}
}
#line 281
__asm__(".symver __ibv_free_device_list_1_0,ibv_free_device_list@IBVERBS_1.0");
#line 283 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
char const   *__ibv_get_device_name_1_0(struct ibv_device_1_0 *device ) 
{ 
  char const   *tmp ;

  {
  {
#line 285
  tmp = ibv_get_device_name(device->real_device);
  }
#line 285
  return (tmp);
}
}
#line 287
__asm__(".symver __ibv_get_device_name_1_0,ibv_get_device_name@IBVERBS_1.0");
#line 289 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
uint64_t __ibv_get_device_guid_1_0(struct ibv_device_1_0 *device ) 
{ 
  uint64_t tmp ;

  {
  {
#line 291
  tmp = ibv_get_device_guid(device->real_device);
  }
#line 291
  return (tmp);
}
}
#line 293
__asm__(".symver __ibv_get_device_guid_1_0,ibv_get_device_guid@IBVERBS_1.0");
#line 295 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int poll_cq_wrapper_1_0(struct ibv_cq_1_0 *cq , int num_entries , struct ibv_wc *wc ) 
{ 
  int tmp ;

  {
  {
#line 298
  tmp = (*(((cq->context)->real_context)->ops.poll_cq))(cq->real_cq, num_entries,
                                                        wc);
  }
#line 298
  return (tmp);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int req_notify_cq_wrapper_1_0(struct ibv_cq_1_0 *cq , int sol_only ) 
{ 
  int tmp ;

  {
  {
#line 303
  tmp = (*(((cq->context)->real_context)->ops.req_notify_cq))(cq->real_cq, sol_only);
  }
#line 303
  return (tmp);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_srq_recv_wrapper_1_0(struct ibv_srq_1_0 *srq , struct ibv_recv_wr_1_0 *wr ,
                                     struct ibv_recv_wr_1_0 **bad_wr ) 
{ 
  struct ibv_recv_wr_1_0 *w ;
  struct ibv_recv_wr *real_wr ;
  struct ibv_recv_wr *head_wr ;
  struct ibv_recv_wr *tail_wr ;
  struct ibv_recv_wr *real_bad_wr ;
  int ret ;
  void *tmp ;

  {
#line 310
  head_wr = (struct ibv_recv_wr *)((void *)0);
#line 310
  tail_wr = (struct ibv_recv_wr *)((void *)0);
#line 313
  w = wr;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! w) {
#line 313
      goto while_break;
    }
    {
#line 314
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 314
    real_wr = (struct ibv_recv_wr *)tmp;
#line 315
    real_wr->wr_id = w->wr_id;
#line 316
    real_wr->sg_list = w->sg_list;
#line 317
    real_wr->num_sge = w->num_sge;
#line 318
    real_wr->next = (struct ibv_recv_wr *)((void *)0);
    }
#line 319
    if (tail_wr) {
#line 320
      tail_wr->next = real_wr;
    } else {
#line 322
      head_wr = real_wr;
    }
#line 324
    tail_wr = real_wr;
#line 313
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 327
  ret = (*(((srq->context)->real_context)->ops.post_srq_recv))(srq->real_srq, head_wr,
                                                               & real_bad_wr);
  }
#line 330
  if (ret) {
#line 331
    real_wr = head_wr;
#line 331
    w = wr;
    {
#line 331
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 331
      if (! real_wr) {
#line 331
        goto while_break___0;
      }
#line 334
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 335
        *bad_wr = w;
#line 336
        goto while_break___0;
      }
#line 331
      real_wr = real_wr->next;
#line 331
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 340
  return (ret);
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_send_wrapper_1_0(struct ibv_qp_1_0 *qp , struct ibv_send_wr_1_0 *wr ,
                                 struct ibv_send_wr_1_0 **bad_wr ) 
{ 
  struct ibv_send_wr_1_0 *w ;
  struct ibv_send_wr *real_wr ;
  struct ibv_send_wr *head_wr ;
  struct ibv_send_wr *tail_wr ;
  struct ibv_send_wr *real_bad_wr ;
  int is_ud ;
  int ret ;
  void *tmp ;

  {
#line 347
  head_wr = (struct ibv_send_wr *)((void *)0);
#line 347
  tail_wr = (struct ibv_send_wr *)((void *)0);
#line 348
  is_ud = (unsigned int )qp->qp_type == 4U;
#line 351
  w = wr;
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! w) {
#line 351
      goto while_break;
    }
    {
#line 352
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 352
    real_wr = (struct ibv_send_wr *)tmp;
#line 353
    real_wr->wr_id = w->wr_id;
#line 354
    real_wr->next = (struct ibv_send_wr *)((void *)0);
    }
#line 363
    if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->sg_list)) {
      {
#line 364
      memcpy((void */* __restrict  */)(& real_wr->sg_list), (void const   */* __restrict  */)(& w->sg_list),
             sizeof(*real_wr) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list));
      }
    } else
#line 366
    if ((unsigned long )(& ((struct ibv_send_wr *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list) == (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->sg_list)) {
#line 366
      if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->wr) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->wr)) {
        {
#line 371
        memcpy((void */* __restrict  */)(& real_wr->sg_list), (void const   */* __restrict  */)(& w->sg_list),
               ((unsigned long )(& ((struct ibv_send_wr *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list)) + sizeof(real_wr->imm_data));
#line 375
        memcpy((void */* __restrict  */)(& real_wr->wr), (void const   */* __restrict  */)(& w->wr),
               sizeof(real_wr->wr));
        }
      } else {
#line 366
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 377
      real_wr->sg_list = w->sg_list;
#line 378
      real_wr->num_sge = w->num_sge;
#line 379
      real_wr->opcode = w->opcode;
#line 380
      real_wr->send_flags = w->send_flags;
#line 381
      real_wr->imm_data = w->imm_data;
#line 382
      if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->wr) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->wr)) {
        {
#line 383
        memcpy((void */* __restrict  */)(& real_wr->wr), (void const   */* __restrict  */)(& w->wr),
               sizeof(real_wr->wr));
        }
      } else {
#line 386
        real_wr->wr.atomic.remote_addr = w->wr.atomic.remote_addr;
#line 388
        real_wr->wr.atomic.compare_add = w->wr.atomic.compare_add;
#line 390
        real_wr->wr.atomic.swap = w->wr.atomic.swap;
#line 392
        real_wr->wr.atomic.rkey = w->wr.atomic.rkey;
      }
    }
#line 397
    if (is_ud) {
#line 398
      real_wr->wr.ud.ah = (w->wr.ud.ah)->real_ah;
    }
#line 400
    if (tail_wr) {
#line 401
      tail_wr->next = real_wr;
    } else {
#line 403
      head_wr = real_wr;
    }
#line 405
    tail_wr = real_wr;
#line 351
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 408
  ret = (*(((qp->context)->real_context)->ops.post_send))(qp->real_qp, head_wr, & real_bad_wr);
  }
#line 411
  if (ret) {
#line 412
    real_wr = head_wr;
#line 412
    w = wr;
    {
#line 412
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 412
      if (! real_wr) {
#line 412
        goto while_break___0;
      }
#line 415
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 416
        *bad_wr = w;
#line 417
        goto while_break___0;
      }
#line 412
      real_wr = real_wr->next;
#line 412
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 421
  return (ret);
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_recv_wrapper_1_0(struct ibv_qp_1_0 *qp , struct ibv_recv_wr_1_0 *wr ,
                                 struct ibv_recv_wr_1_0 **bad_wr ) 
{ 
  struct ibv_recv_wr_1_0 *w ;
  struct ibv_recv_wr *real_wr ;
  struct ibv_recv_wr *head_wr ;
  struct ibv_recv_wr *tail_wr ;
  struct ibv_recv_wr *real_bad_wr ;
  int ret ;
  void *tmp ;

  {
#line 428
  head_wr = (struct ibv_recv_wr *)((void *)0);
#line 428
  tail_wr = (struct ibv_recv_wr *)((void *)0);
#line 431
  w = wr;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! w) {
#line 431
      goto while_break;
    }
    {
#line 432
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 432
    real_wr = (struct ibv_recv_wr *)tmp;
#line 433
    real_wr->wr_id = w->wr_id;
#line 434
    real_wr->sg_list = w->sg_list;
#line 435
    real_wr->num_sge = w->num_sge;
#line 436
    real_wr->next = (struct ibv_recv_wr *)((void *)0);
    }
#line 437
    if (tail_wr) {
#line 438
      tail_wr->next = real_wr;
    } else {
#line 440
      head_wr = real_wr;
    }
#line 442
    tail_wr = real_wr;
#line 431
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 445
  ret = (*(((qp->context)->real_context)->ops.post_recv))(qp->real_qp, head_wr, & real_bad_wr);
  }
#line 448
  if (ret) {
#line 449
    real_wr = head_wr;
#line 449
    w = wr;
    {
#line 449
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 449
      if (! real_wr) {
#line 449
        goto while_break___0;
      }
#line 452
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 453
        *bad_wr = w;
#line 454
        goto while_break___0;
      }
#line 449
      real_wr = real_wr->next;
#line 449
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 458
  return (ret);
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct ibv_context_1_0 *__ibv_open_device_1_0(struct ibv_device_1_0 *device ) 
{ 
  struct ibv_context *real_ctx ;
  struct ibv_context_1_0 *ctx ;
  void *tmp ;

  {
  {
#line 466
  tmp = malloc(sizeof(*ctx));
#line 466
  ctx = (struct ibv_context_1_0 *)tmp;
  }
#line 467
  if (! ctx) {
#line 468
    return ((struct ibv_context_1_0 *)((void *)0));
  }
  {
#line 470
  real_ctx = ibv_open_device(device->real_device);
  }
#line 471
  if (! real_ctx) {
    {
#line 472
    free((void *)ctx);
    }
#line 473
    return ((struct ibv_context_1_0 *)((void *)0));
  }
#line 476
  ctx->device = device;
#line 477
  ctx->real_context = real_ctx;
#line 479
  ctx->ops.poll_cq = & poll_cq_wrapper_1_0;
#line 480
  ctx->ops.req_notify_cq = & req_notify_cq_wrapper_1_0;
#line 481
  ctx->ops.post_send = & post_send_wrapper_1_0;
#line 482
  ctx->ops.post_recv = & post_recv_wrapper_1_0;
#line 483
  ctx->ops.post_srq_recv = & post_srq_recv_wrapper_1_0;
#line 485
  return (ctx);
}
}
#line 487
__asm__(".symver __ibv_open_device_1_0,ibv_open_device@IBVERBS_1.0");
#line 489 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
int __ibv_close_device_1_0(struct ibv_context_1_0 *context ) 
{ 
  int ret ;

  {
  {
#line 493
  ret = ibv_close_device(context->real_context);
  }
#line 494
  if (ret) {
#line 495
    return (ret);
  }
  {
#line 497
  free((void *)context);
  }
#line 498
  return (0);
}
}
#line 500
__asm__(".symver __ibv_close_device_1_0,ibv_close_device@IBVERBS_1.0");
#line 502 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
int __ibv_get_async_event_1_0(struct ibv_context_1_0 *context , struct ibv_async_event *event ) 
{ 
  int ret ;

  {
  {
#line 507
  ret = ibv_get_async_event(context->real_context, event);
  }
#line 508
  if (ret) {
#line 509
    return (ret);
  }
  {
#line 512
  if ((unsigned int )event->event_type == 0U) {
#line 512
    goto case_0;
  }
#line 523
  if ((unsigned int )event->event_type == 16U) {
#line 523
    goto case_16;
  }
#line 523
  if ((unsigned int )event->event_type == 7U) {
#line 523
    goto case_16;
  }
#line 523
  if ((unsigned int )event->event_type == 6U) {
#line 523
    goto case_16;
  }
#line 523
  if ((unsigned int )event->event_type == 5U) {
#line 523
    goto case_16;
  }
#line 523
  if ((unsigned int )event->event_type == 4U) {
#line 523
    goto case_16;
  }
#line 523
  if ((unsigned int )event->event_type == 3U) {
#line 523
    goto case_16;
  }
#line 523
  if ((unsigned int )event->event_type == 2U) {
#line 523
    goto case_16;
  }
#line 523
  if ((unsigned int )event->event_type == 1U) {
#line 523
    goto case_16;
  }
#line 528
  if ((unsigned int )event->event_type == 15U) {
#line 528
    goto case_15;
  }
#line 528
  if ((unsigned int )event->event_type == 14U) {
#line 528
    goto case_15;
  }
#line 532
  goto switch_default;
  case_0: /* CIL Label */ 
#line 513
  event->element.cq = (struct ibv_cq *)(event->element.cq)->cq_context;
#line 514
  goto switch_break;
  case_16: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 524
  event->element.qp = (struct ibv_qp *)(event->element.qp)->qp_context;
#line 525
  goto switch_break;
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
#line 529
  event->element.srq = (struct ibv_srq *)(event->element.srq)->srq_context;
#line 530
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 533
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 536
  return (ret);
}
}
#line 538
__asm__(".symver __ibv_get_async_event_1_0,ibv_get_async_event@IBVERBS_1.0");
#line 540 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
void __ibv_ack_async_event_1_0(struct ibv_async_event *event ) 
{ 
  struct ibv_async_event real_event ;

  {
#line 542
  real_event = *event;
  {
#line 545
  if ((unsigned int )event->event_type == 0U) {
#line 545
    goto case_0;
  }
#line 557
  if ((unsigned int )event->event_type == 16U) {
#line 557
    goto case_16;
  }
#line 557
  if ((unsigned int )event->event_type == 7U) {
#line 557
    goto case_16;
  }
#line 557
  if ((unsigned int )event->event_type == 6U) {
#line 557
    goto case_16;
  }
#line 557
  if ((unsigned int )event->event_type == 5U) {
#line 557
    goto case_16;
  }
#line 557
  if ((unsigned int )event->event_type == 4U) {
#line 557
    goto case_16;
  }
#line 557
  if ((unsigned int )event->event_type == 3U) {
#line 557
    goto case_16;
  }
#line 557
  if ((unsigned int )event->event_type == 2U) {
#line 557
    goto case_16;
  }
#line 557
  if ((unsigned int )event->event_type == 1U) {
#line 557
    goto case_16;
  }
#line 563
  if ((unsigned int )event->event_type == 15U) {
#line 563
    goto case_15;
  }
#line 563
  if ((unsigned int )event->event_type == 14U) {
#line 563
    goto case_15;
  }
#line 568
  goto switch_default;
  case_0: /* CIL Label */ 
#line 546
  real_event.element.cq = ((struct ibv_cq_1_0 *)event->element.cq)->real_cq;
#line 548
  goto switch_break;
  case_16: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 558
  real_event.element.qp = ((struct ibv_qp_1_0 *)event->element.qp)->real_qp;
#line 560
  goto switch_break;
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
#line 564
  real_event.element.srq = ((struct ibv_srq_1_0 *)event->element.srq)->real_srq;
#line 566
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 569
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 572
  ibv_ack_async_event(& real_event);
  }
#line 573
  return;
}
}
#line 574
__asm__(".symver __ibv_ack_async_event_1_0,ibv_ack_async_event@IBVERBS_1.0");
#line 576 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
int __ibv_query_device_1_0(struct ibv_context_1_0 *context , struct ibv_device_attr *device_attr ) 
{ 
  int tmp ;

  {
  {
#line 579
  tmp = ibv_query_device(context->real_context, device_attr);
  }
#line 579
  return (tmp);
}
}
#line 581
__asm__(".symver __ibv_query_device_1_0,ibv_query_device@IBVERBS_1.0");
#line 583 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
int __ibv_query_port_1_0(struct ibv_context_1_0 *context , uint8_t port_num , struct ibv_port_attr *port_attr ) 
{ 
  int tmp ;

  {
  {
#line 586
  tmp = ___ibv_query_port(context->real_context, port_num, port_attr);
  }
#line 586
  return (tmp);
}
}
#line 588
__asm__(".symver __ibv_query_port_1_0,ibv_query_port@IBVERBS_1.0");
#line 590 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
int __ibv_query_gid_1_0(struct ibv_context_1_0 *context , uint8_t port_num , int index___0 ,
                        union ibv_gid *gid ) 
{ 
  int tmp ;

  {
  {
#line 593
  tmp = ibv_query_gid(context->real_context, port_num, index___0, gid);
  }
#line 593
  return (tmp);
}
}
#line 595
__asm__(".symver __ibv_query_gid_1_0,ibv_query_gid@IBVERBS_1.0");
#line 597 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
int __ibv_query_pkey_1_0(struct ibv_context_1_0 *context , uint8_t port_num , int index___0 ,
                         uint16_t *pkey ) 
{ 
  int tmp ;

  {
  {
#line 600
  tmp = ibv_query_pkey(context->real_context, port_num, index___0, pkey);
  }
#line 600
  return (tmp);
}
}
#line 602
__asm__(".symver __ibv_query_pkey_1_0,ibv_query_pkey@IBVERBS_1.0");
#line 604 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct ibv_pd_1_0 *__ibv_alloc_pd_1_0(struct ibv_context_1_0 *context ) 
{ 
  struct ibv_pd *real_pd ;
  struct ibv_pd_1_0 *pd ;
  void *tmp ;

  {
  {
#line 609
  tmp = malloc(sizeof(*pd));
#line 609
  pd = (struct ibv_pd_1_0 *)tmp;
  }
#line 610
  if (! pd) {
#line 611
    return ((struct ibv_pd_1_0 *)((void *)0));
  }
  {
#line 613
  real_pd = ibv_alloc_pd(context->real_context);
  }
#line 614
  if (! real_pd) {
    {
#line 615
    free((void *)pd);
    }
#line 616
    return ((struct ibv_pd_1_0 *)((void *)0));
  }
#line 619
  pd->context = context;
#line 620
  pd->real_pd = real_pd;
#line 622
  return (pd);
}
}
#line 624
__asm__(".symver __ibv_alloc_pd_1_0,ibv_alloc_pd@IBVERBS_1.0");
#line 626 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
int __ibv_dealloc_pd_1_0(struct ibv_pd_1_0 *pd ) 
{ 
  int ret ;

  {
  {
#line 630
  ret = ibv_dealloc_pd(pd->real_pd);
  }
#line 631
  if (ret) {
#line 632
    return (ret);
  }
  {
#line 634
  free((void *)pd);
  }
#line 635
  return (0);
}
}
#line 637
__asm__(".symver __ibv_dealloc_pd_1_0,ibv_dealloc_pd@IBVERBS_1.0");
#line 639 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct ibv_mr_1_0 *__ibv_reg_mr_1_0(struct ibv_pd_1_0 *pd , void *addr , size_t length ,
                                    int access___0 ) 
{ 
  struct ibv_mr *real_mr ;
  struct ibv_mr_1_0 *mr ;
  void *tmp ;

  {
  {
#line 645
  tmp = malloc(sizeof(*mr));
#line 645
  mr = (struct ibv_mr_1_0 *)tmp;
  }
#line 646
  if (! mr) {
#line 647
    return ((struct ibv_mr_1_0 *)((void *)0));
  }
  {
#line 649
  real_mr = ibv_reg_mr(pd->real_pd, addr, length, access___0);
  }
#line 650
  if (! real_mr) {
    {
#line 651
    free((void *)mr);
    }
#line 652
    return ((struct ibv_mr_1_0 *)((void *)0));
  }
#line 655
  mr->context = pd->context;
#line 656
  mr->pd = pd;
#line 657
  mr->lkey = real_mr->lkey;
#line 658
  mr->rkey = real_mr->rkey;
#line 659
  mr->real_mr = real_mr;
#line 661
  return (mr);
}
}
#line 663
__asm__(".symver __ibv_reg_mr_1_0,ibv_reg_mr@IBVERBS_1.0");
#line 665 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
int __ibv_dereg_mr_1_0(struct ibv_mr_1_0 *mr ) 
{ 
  int ret ;

  {
  {
#line 669
  ret = ibv_dereg_mr(mr->real_mr);
  }
#line 670
  if (ret) {
#line 671
    return (ret);
  }
  {
#line 673
  free((void *)mr);
  }
#line 674
  return (0);
}
}
#line 676
__asm__(".symver __ibv_dereg_mr_1_0,ibv_dereg_mr@IBVERBS_1.0");
#line 678 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct ibv_cq_1_0 *__ibv_create_cq_1_0(struct ibv_context_1_0 *context , int cqe ,
                                       void *cq_context , struct ibv_comp_channel *channel ,
                                       int comp_vector ) 
{ 
  struct ibv_cq *real_cq ;
  struct ibv_cq_1_0 *cq ;
  void *tmp ;

  {
  {
#line 686
  tmp = malloc(sizeof(*cq));
#line 686
  cq = (struct ibv_cq_1_0 *)tmp;
  }
#line 687
  if (! cq) {
#line 688
    return ((struct ibv_cq_1_0 *)((void *)0));
  }
  {
#line 690
  real_cq = ibv_create_cq(context->real_context, cqe, cq_context, channel, comp_vector);
  }
#line 692
  if (! real_cq) {
    {
#line 693
    free((void *)cq);
    }
#line 694
    return ((struct ibv_cq_1_0 *)((void *)0));
  }
#line 697
  cq->context = context;
#line 698
  cq->cq_context = cq_context;
#line 699
  cq->cqe = cqe;
#line 700
  cq->real_cq = real_cq;
#line 702
  real_cq->cq_context = (void *)cq;
#line 704
  return (cq);
}
}
#line 706
__asm__(".symver __ibv_create_cq_1_0,ibv_create_cq@IBVERBS_1.0");
#line 708 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
int __ibv_resize_cq_1_0(struct ibv_cq_1_0 *cq , int cqe ) 
{ 
  int tmp ;

  {
  {
#line 710
  tmp = ibv_resize_cq(cq->real_cq, cqe);
  }
#line 710
  return (tmp);
}
}
#line 712
__asm__(".symver __ibv_resize_cq_1_0,ibv_resize_cq@IBVERBS_1.0");
#line 714 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
int __ibv_destroy_cq_1_0(struct ibv_cq_1_0 *cq ) 
{ 
  int ret ;

  {
  {
#line 718
  ret = ibv_destroy_cq(cq->real_cq);
  }
#line 719
  if (ret) {
#line 720
    return (ret);
  }
  {
#line 722
  free((void *)cq);
  }
#line 723
  return (0);
}
}
#line 725
__asm__(".symver __ibv_destroy_cq_1_0,ibv_destroy_cq@IBVERBS_1.0");
#line 727 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
int __ibv_get_cq_event_1_0(struct ibv_comp_channel *channel , struct ibv_cq_1_0 **cq ,
                           void **cq_context ) 
{ 
  struct ibv_cq *real_cq ;
  void *cq_ptr ;
  int ret ;

  {
  {
#line 734
  ret = ibv_get_cq_event(channel, & real_cq, & cq_ptr);
  }
#line 735
  if (ret) {
#line 736
    return (ret);
  }
#line 738
  *cq = (struct ibv_cq_1_0 *)cq_ptr;
#line 739
  *cq_context = (*cq)->cq_context;
#line 741
  return (0);
}
}
#line 743
__asm__(".symver __ibv_get_cq_event_1_0,ibv_get_cq_event@IBVERBS_1.0");
#line 745 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
void __ibv_ack_cq_events_1_0(struct ibv_cq_1_0 *cq , unsigned int nevents ) 
{ 


  {
  {
#line 747
  ibv_ack_cq_events(cq->real_cq, nevents);
  }
#line 748
  return;
}
}
#line 749
__asm__(".symver __ibv_ack_cq_events_1_0,ibv_ack_cq_events@IBVERBS_1.0");
#line 751 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct ibv_srq_1_0 *__ibv_create_srq_1_0(struct ibv_pd_1_0 *pd , struct ibv_srq_init_attr *srq_init_attr ) 
{ 
  struct ibv_srq *real_srq ;
  struct ibv_srq_1_0 *srq ;
  void *tmp ;

  {
  {
#line 757
  tmp = malloc(sizeof(*srq));
#line 757
  srq = (struct ibv_srq_1_0 *)tmp;
  }
#line 758
  if (! srq) {
#line 759
    return ((struct ibv_srq_1_0 *)((void *)0));
  }
  {
#line 761
  real_srq = ibv_create_srq(pd->real_pd, srq_init_attr);
  }
#line 762
  if (! real_srq) {
    {
#line 763
    free((void *)srq);
    }
#line 764
    return ((struct ibv_srq_1_0 *)((void *)0));
  }
#line 767
  srq->context = pd->context;
#line 768
  srq->srq_context = srq_init_attr->srq_context;
#line 769
  srq->pd = pd;
#line 770
  srq->real_srq = real_srq;
#line 772
  real_srq->srq_context = (void *)srq;
#line 774
  return (srq);
}
}
#line 776
__asm__(".symver __ibv_create_srq_1_0,ibv_create_srq@IBVERBS_1.0");
#line 778 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
int __ibv_modify_srq_1_0(struct ibv_srq_1_0 *srq , struct ibv_srq_attr *srq_attr ,
                         int srq_attr_mask ) 
{ 
  int tmp ;

  {
  {
#line 782
  tmp = ibv_modify_srq(srq->real_srq, srq_attr, srq_attr_mask);
  }
#line 782
  return (tmp);
}
}
#line 784
__asm__(".symver __ibv_modify_srq_1_0,ibv_modify_srq@IBVERBS_1.0");
#line 786 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
int __ibv_query_srq_1_0(struct ibv_srq_1_0 *srq , struct ibv_srq_attr *srq_attr ) 
{ 
  int tmp ;

  {
  {
#line 788
  tmp = ibv_query_srq(srq->real_srq, srq_attr);
  }
#line 788
  return (tmp);
}
}
#line 790
__asm__(".symver __ibv_query_srq_1_0,ibv_query_srq@IBVERBS_1.0");
#line 792 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
int __ibv_destroy_srq_1_0(struct ibv_srq_1_0 *srq ) 
{ 
  int ret ;

  {
  {
#line 796
  ret = ibv_destroy_srq(srq->real_srq);
  }
#line 797
  if (ret) {
#line 798
    return (ret);
  }
  {
#line 800
  free((void *)srq);
  }
#line 801
  return (0);
}
}
#line 803
__asm__(".symver __ibv_destroy_srq_1_0,ibv_destroy_srq@IBVERBS_1.0");
#line 805 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct ibv_qp_1_0 *__ibv_create_qp_1_0(struct ibv_pd_1_0 *pd , struct ibv_qp_init_attr_1_0 *qp_init_attr ) 
{ 
  struct ibv_qp *real_qp ;
  struct ibv_qp_1_0 *qp ;
  struct ibv_qp_init_attr real_init_attr ;
  void *tmp ;

  {
  {
#line 812
  tmp = malloc(sizeof(*qp));
#line 812
  qp = (struct ibv_qp_1_0 *)tmp;
  }
#line 813
  if (! qp) {
#line 814
    return ((struct ibv_qp_1_0 *)((void *)0));
  }
#line 816
  real_init_attr.qp_context = qp_init_attr->qp_context;
#line 817
  real_init_attr.send_cq = (qp_init_attr->send_cq)->real_cq;
#line 818
  real_init_attr.recv_cq = (qp_init_attr->recv_cq)->real_cq;
#line 819
  if (qp_init_attr->srq) {
#line 819
    real_init_attr.srq = (qp_init_attr->srq)->real_srq;
  } else {
#line 819
    real_init_attr.srq = (struct ibv_srq *)((void *)0);
  }
  {
#line 821
  real_init_attr.cap = qp_init_attr->cap;
#line 822
  real_init_attr.qp_type = qp_init_attr->qp_type;
#line 823
  real_init_attr.sq_sig_all = qp_init_attr->sq_sig_all;
#line 825
  real_qp = ibv_create_qp(pd->real_pd, & real_init_attr);
  }
#line 826
  if (! real_qp) {
    {
#line 827
    free((void *)qp);
    }
#line 828
    return ((struct ibv_qp_1_0 *)((void *)0));
  }
#line 831
  qp->context = pd->context;
#line 832
  qp->qp_context = qp_init_attr->qp_context;
#line 833
  qp->pd = pd;
#line 834
  qp->send_cq = qp_init_attr->send_cq;
#line 835
  qp->recv_cq = qp_init_attr->recv_cq;
#line 836
  qp->srq = qp_init_attr->srq;
#line 837
  qp->qp_type = qp_init_attr->qp_type;
#line 838
  qp->qp_num = real_qp->qp_num;
#line 839
  qp->real_qp = real_qp;
#line 841
  qp_init_attr->cap = real_init_attr.cap;
#line 843
  real_qp->qp_context = (void *)qp;
#line 845
  return (qp);
}
}
#line 847
__asm__(".symver __ibv_create_qp_1_0,ibv_create_qp@IBVERBS_1.0");
#line 849 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
int __ibv_query_qp_1_0(struct ibv_qp_1_0 *qp , struct ibv_qp_attr *attr , int attr_mask ,
                       struct ibv_qp_init_attr_1_0 *init_attr ) 
{ 
  struct ibv_qp_init_attr real_init_attr ;
  int ret ;

  {
  {
#line 856
  ret = ibv_query_qp(qp->real_qp, attr, attr_mask, & real_init_attr);
  }
#line 857
  if (ret) {
#line 858
    return (ret);
  }
#line 860
  init_attr->qp_context = qp->qp_context;
#line 861
  init_attr->send_cq = (struct ibv_cq_1_0 *)(real_init_attr.send_cq)->cq_context;
#line 862
  init_attr->recv_cq = (struct ibv_cq_1_0 *)(real_init_attr.recv_cq)->cq_context;
#line 863
  init_attr->srq = (struct ibv_srq_1_0 *)(real_init_attr.srq)->srq_context;
#line 864
  init_attr->qp_type = real_init_attr.qp_type;
#line 865
  init_attr->cap = real_init_attr.cap;
#line 866
  init_attr->sq_sig_all = real_init_attr.sq_sig_all;
#line 868
  return (0);
}
}
#line 870
__asm__(".symver __ibv_query_qp_1_0,ibv_query_qp@IBVERBS_1.0");
#line 872 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
int __ibv_modify_qp_1_0(struct ibv_qp_1_0 *qp , struct ibv_qp_attr *attr , int attr_mask ) 
{ 
  int tmp ;

  {
  {
#line 875
  tmp = ibv_modify_qp(qp->real_qp, attr, attr_mask);
  }
#line 875
  return (tmp);
}
}
#line 877
__asm__(".symver __ibv_modify_qp_1_0,ibv_modify_qp@IBVERBS_1.0");
#line 879 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
int __ibv_destroy_qp_1_0(struct ibv_qp_1_0 *qp ) 
{ 
  int ret ;

  {
  {
#line 883
  ret = ibv_destroy_qp(qp->real_qp);
  }
#line 884
  if (ret) {
#line 885
    return (ret);
  }
  {
#line 887
  free((void *)qp);
  }
#line 888
  return (0);
}
}
#line 890
__asm__(".symver __ibv_destroy_qp_1_0,ibv_destroy_qp@IBVERBS_1.0");
#line 892 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
struct ibv_ah_1_0 *__ibv_create_ah_1_0(struct ibv_pd_1_0 *pd , struct ibv_ah_attr *attr ) 
{ 
  struct ibv_ah *real_ah ;
  struct ibv_ah_1_0 *ah ;
  void *tmp ;

  {
  {
#line 898
  tmp = malloc(sizeof(*ah));
#line 898
  ah = (struct ibv_ah_1_0 *)tmp;
  }
#line 899
  if (! ah) {
#line 900
    return ((struct ibv_ah_1_0 *)((void *)0));
  }
  {
#line 902
  real_ah = ibv_create_ah(pd->real_pd, attr);
  }
#line 903
  if (! real_ah) {
    {
#line 904
    free((void *)ah);
    }
#line 905
    return ((struct ibv_ah_1_0 *)((void *)0));
  }
#line 908
  ah->context = pd->context;
#line 909
  ah->pd = pd;
#line 910
  ah->real_ah = real_ah;
#line 912
  return (ah);
}
}
#line 914
__asm__(".symver __ibv_create_ah_1_0,ibv_create_ah@IBVERBS_1.0");
#line 916 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
int __ibv_destroy_ah_1_0(struct ibv_ah_1_0 *ah ) 
{ 
  int ret ;

  {
  {
#line 920
  ret = ibv_destroy_ah(ah->real_ah);
  }
#line 921
  if (ret) {
#line 922
    return (ret);
  }
  {
#line 924
  free((void *)ah);
  }
#line 925
  return (0);
}
}
#line 927
__asm__(".symver __ibv_destroy_ah_1_0,ibv_destroy_ah@IBVERBS_1.0");
#line 929 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
int __ibv_attach_mcast_1_0(struct ibv_qp_1_0 *qp , union ibv_gid *gid , uint16_t lid ) 
{ 
  int tmp ;

  {
  {
#line 931
  tmp = ibv_attach_mcast(qp->real_qp, (union ibv_gid  const  *)gid, lid);
  }
#line 931
  return (tmp);
}
}
#line 933
__asm__(".symver __ibv_attach_mcast_1_0,ibv_attach_mcast@IBVERBS_1.0");
#line 935 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
int __ibv_detach_mcast_1_0(struct ibv_qp_1_0 *qp , union ibv_gid *gid , uint16_t lid ) 
{ 
  int tmp ;

  {
  {
#line 937
  tmp = ibv_detach_mcast(qp->real_qp, (union ibv_gid  const  *)gid, lid);
  }
#line 937
  return (tmp);
}
}
#line 939
__asm__(".symver __ibv_detach_mcast_1_0,ibv_detach_mcast@IBVERBS_1.0");
#line 57 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/uc_pingpong.c"
static int page_size___1  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/uc_pingpong.c"
static int pp_connect_ctx___0(struct pingpong_context *ctx , int port , int my_psn ,
                              enum ibv_mtu mtu , int sl , struct pingpong_dest *dest ,
                              int sgid_idx ) 
{ 
  struct ibv_qp_attr attr ;
  int tmp ;
  int tmp___0 ;

  {
#line 84
  attr.qp_state = (enum ibv_qp_state )2;
#line 84
  attr.cur_qp_state = 0U;
#line 84
  attr.path_mtu = mtu;
#line 84
  attr.path_mig_state = 0U;
#line 84
  attr.qkey = 0U;
#line 84
  attr.rq_psn = (uint32_t )dest->psn;
#line 84
  attr.sq_psn = 0U;
#line 84
  attr.dest_qp_num = (uint32_t )dest->qpn;
#line 84
  attr.qp_access_flags = 0;
#line 84
  attr.cap.max_send_wr = 0U;
#line 84
  attr.cap.max_recv_wr = 0U;
#line 84
  attr.cap.max_send_sge = 0U;
#line 84
  attr.cap.max_recv_sge = 0U;
#line 84
  attr.cap.max_inline_data = 0U;
#line 84
  attr.ah_attr.grh.dgid.raw[0] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[1] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[2] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[3] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[4] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[5] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[6] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[7] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[8] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[9] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[10] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[11] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[12] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[13] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[14] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.dgid.raw[15] = (unsigned char)0;
#line 84
  attr.ah_attr.grh.flow_label = 0U;
#line 84
  attr.ah_attr.grh.sgid_index = (unsigned char)0;
#line 84
  attr.ah_attr.grh.hop_limit = (unsigned char)0;
#line 84
  attr.ah_attr.grh.traffic_class = (unsigned char)0;
#line 84
  attr.ah_attr.dlid = (uint16_t )dest->lid;
#line 84
  attr.ah_attr.sl = (uint8_t )sl;
#line 84
  attr.ah_attr.src_path_bits = (uint8_t )0;
#line 84
  attr.ah_attr.static_rate = (unsigned char)0;
#line 84
  attr.ah_attr.is_global = (uint8_t )0;
#line 84
  attr.ah_attr.port_num = (uint8_t )port;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[0] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[1] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[2] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[3] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[4] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[5] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[6] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[7] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[8] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[9] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[10] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[11] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[12] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[13] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[14] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.dgid.raw[15] = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.flow_label = 0U;
#line 84
  attr.alt_ah_attr.grh.sgid_index = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.hop_limit = (unsigned char)0;
#line 84
  attr.alt_ah_attr.grh.traffic_class = (unsigned char)0;
#line 84
  attr.alt_ah_attr.dlid = (unsigned short)0;
#line 84
  attr.alt_ah_attr.sl = (unsigned char)0;
#line 84
  attr.alt_ah_attr.src_path_bits = (unsigned char)0;
#line 84
  attr.alt_ah_attr.static_rate = (unsigned char)0;
#line 84
  attr.alt_ah_attr.is_global = (unsigned char)0;
#line 84
  attr.alt_ah_attr.port_num = (unsigned char)0;
#line 84
  attr.pkey_index = (unsigned short)0;
#line 84
  attr.alt_pkey_index = (unsigned short)0;
#line 84
  attr.en_sqd_async_notify = (unsigned char)0;
#line 84
  attr.sq_draining = (unsigned char)0;
#line 84
  attr.max_rd_atomic = (unsigned char)0;
#line 84
  attr.max_dest_rd_atomic = (unsigned char)0;
#line 84
  attr.min_rnr_timer = (unsigned char)0;
#line 84
  attr.port_num = (unsigned char)0;
#line 84
  attr.timeout = (unsigned char)0;
#line 84
  attr.retry_cnt = (unsigned char)0;
#line 84
  attr.rnr_retry = (unsigned char)0;
#line 84
  attr.alt_port_num = (unsigned char)0;
#line 84
  attr.alt_timeout = (unsigned char)0;
#line 98
  if (dest->gid.global.interface_id) {
#line 99
    attr.ah_attr.is_global = (uint8_t )1;
#line 100
    attr.ah_attr.grh.hop_limit = (uint8_t )1;
#line 101
    attr.ah_attr.grh.dgid = dest->gid;
#line 102
    attr.ah_attr.grh.sgid_index = (uint8_t )sgid_idx;
  }
  {
#line 104
  tmp = ibv_modify_qp(ctx->qp, & attr, 1053057);
  }
#line 104
  if (tmp) {
    {
#line 110
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to modify QP to RTR\n");
    }
#line 111
    return (1);
  }
  {
#line 114
  attr.qp_state = (enum ibv_qp_state )3;
#line 115
  attr.sq_psn = (uint32_t )my_psn;
#line 116
  tmp___0 = ibv_modify_qp(ctx->qp, & attr, 65537);
  }
#line 116
  if (tmp___0) {
    {
#line 119
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to modify QP to RTS\n");
    }
#line 120
    return (1);
  }
#line 123
  return (0);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/uc_pingpong.c"
static struct pingpong_dest *pp_client_exch_dest___0(char const   *servername , int port ,
                                                     struct pingpong_dest  const  *my_dest ) 
{ 
  struct addrinfo *res ;
  struct addrinfo *t ;
  struct addrinfo hints ;
  char *service ;
  char msg[sizeof("0000:000000:000000:00000000000000000000000000000000")] ;
  int n ;
  int sockfd ;
  struct pingpong_dest *rem_dest ;
  char gid[33] ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  ssize_t tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 130
  hints.ai_flags = 0;
#line 130
  hints.ai_family = 0;
#line 130
  hints.ai_socktype = 1;
#line 130
  hints.ai_protocol = 0;
#line 130
  hints.ai_addrlen = 0U;
#line 130
  hints.ai_addr = (struct sockaddr *)0;
#line 130
  hints.ai_canonname = (char *)0;
#line 130
  hints.ai_next = (struct addrinfo *)0;
#line 137
  sockfd = -1;
#line 138
  rem_dest = (struct pingpong_dest *)((void *)0);
#line 141
  tmp = asprintf((char **/* __restrict  */)(& service), (char const   */* __restrict  */)"%d",
                 port);
  }
#line 141
  if (tmp < 0) {
#line 142
    return ((struct pingpong_dest *)((void *)0));
  }
  {
#line 144
  n = getaddrinfo((char const   */* __restrict  */)servername, (char const   */* __restrict  */)service,
                  (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 146
  if (n < 0) {
    {
#line 147
    tmp___0 = gai_strerror(n);
#line 147
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s for %s:%d\n",
            tmp___0, servername, port);
#line 148
    free((void *)service);
    }
#line 149
    return ((struct pingpong_dest *)((void *)0));
  }
#line 152
  t = res;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! t) {
#line 152
      goto while_break;
    }
    {
#line 153
    sockfd = socket(t->ai_family, t->ai_socktype, t->ai_protocol);
    }
#line 154
    if (sockfd >= 0) {
      {
#line 155
      tmp___1 = connect(sockfd, (struct sockaddr  const  */* __restrict  */)t->ai_addr,
                        t->ai_addrlen);
      }
#line 155
      if (! tmp___1) {
#line 156
        goto while_break;
      }
      {
#line 157
      close(sockfd);
#line 158
      sockfd = -1;
      }
    }
#line 152
    t = t->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 162
  freeaddrinfo(res);
#line 163
  free((void *)service);
  }
#line 165
  if (sockfd < 0) {
    {
#line 166
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t connect to %s:%d\n",
            servername, port);
    }
#line 167
    return ((struct pingpong_dest *)((void *)0));
  }
  {
#line 170
  gid_to_wire_gid(& my_dest->gid, gid);
#line 171
  sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"%04x:%06x:%06x:%s",
          my_dest->lid, my_dest->qpn, my_dest->psn, gid);
#line 173
  tmp___2 = write(sockfd, (void const   *)(msg), sizeof(msg));
  }
#line 173
  if ((unsigned long )tmp___2 != sizeof(msg)) {
    {
#line 174
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t send local address\n");
    }
#line 175
    goto out;
  }
  {
#line 178
  tmp___3 = read(sockfd, (void *)(msg), sizeof(msg));
  }
#line 178
  if ((unsigned long )tmp___3 != sizeof(msg)) {
    {
#line 179
    perror("client read");
#line 180
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t read remote address\n");
    }
#line 181
    goto out;
  }
  {
#line 184
  write(sockfd, (void const   *)"done", sizeof("done"));
#line 186
  tmp___4 = malloc(sizeof(*rem_dest));
#line 186
  rem_dest = (struct pingpong_dest *)tmp___4;
  }
#line 187
  if (! rem_dest) {
#line 188
    goto out;
  }
  {
#line 190
  sscanf((char const   */* __restrict  */)(msg), (char const   */* __restrict  */)"%x:%x:%x:%s",
         & rem_dest->lid, & rem_dest->qpn, & rem_dest->psn, gid);
#line 192
  wire_gid_to_gid((char const   *)(gid), & rem_dest->gid);
  }
  out: 
  {
#line 195
  close(sockfd);
  }
#line 196
  return (rem_dest);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/uc_pingpong.c"
static struct pingpong_dest *pp_server_exch_dest___0(struct pingpong_context *ctx ,
                                                     int ib_port , enum ibv_mtu mtu ,
                                                     int port , int sl , struct pingpong_dest  const  *my_dest ,
                                                     int sgid_idx ) 
{ 
  struct addrinfo *res ;
  struct addrinfo *t ;
  struct addrinfo hints ;
  char *service ;
  char msg[sizeof("0000:000000:000000:00000000000000000000000000000000")] ;
  int n ;
  int sockfd ;
  int connfd ;
  struct pingpong_dest *rem_dest ;
  char gid[33] ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;

  {
  {
#line 206
  hints.ai_flags = 1;
#line 206
  hints.ai_family = 0;
#line 206
  hints.ai_socktype = 1;
#line 206
  hints.ai_protocol = 0;
#line 206
  hints.ai_addrlen = 0U;
#line 206
  hints.ai_addr = (struct sockaddr *)0;
#line 206
  hints.ai_canonname = (char *)0;
#line 206
  hints.ai_next = (struct addrinfo *)0;
#line 214
  sockfd = -1;
#line 215
  rem_dest = (struct pingpong_dest *)((void *)0);
#line 218
  tmp = asprintf((char **/* __restrict  */)(& service), (char const   */* __restrict  */)"%d",
                 port);
  }
#line 218
  if (tmp < 0) {
#line 219
    return ((struct pingpong_dest *)((void *)0));
  }
  {
#line 221
  n = getaddrinfo((char const   */* __restrict  */)((void *)0), (char const   */* __restrict  */)service,
                  (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 223
  if (n < 0) {
    {
#line 224
    tmp___0 = gai_strerror(n);
#line 224
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s for port %d\n",
            tmp___0, port);
#line 225
    free((void *)service);
    }
#line 226
    return ((struct pingpong_dest *)((void *)0));
  }
#line 229
  t = res;
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (! t) {
#line 229
      goto while_break;
    }
    {
#line 230
    sockfd = socket(t->ai_family, t->ai_socktype, t->ai_protocol);
    }
#line 231
    if (sockfd >= 0) {
      {
#line 232
      n = 1;
#line 234
      setsockopt(sockfd, 1, 2, (void const   *)(& n), (socklen_t )sizeof(n));
#line 236
      tmp___1 = bind(sockfd, (struct sockaddr  const  */* __restrict  */)t->ai_addr,
                     t->ai_addrlen);
      }
#line 236
      if (! tmp___1) {
#line 237
        goto while_break;
      }
      {
#line 238
      close(sockfd);
#line 239
      sockfd = -1;
      }
    }
#line 229
    t = t->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 243
  freeaddrinfo(res);
#line 244
  free((void *)service);
  }
#line 246
  if (sockfd < 0) {
    {
#line 247
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t listen to port %d\n",
            port);
    }
#line 248
    return ((struct pingpong_dest *)((void *)0));
  }
  {
#line 251
  listen(sockfd, 1);
#line 252
  connfd = accept(sockfd, (struct sockaddr */* __restrict  */)((void *)0), (socklen_t */* __restrict  */)0);
#line 253
  close(sockfd);
  }
#line 254
  if (connfd < 0) {
    {
#line 255
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"accept() failed\n");
    }
#line 256
    return ((struct pingpong_dest *)((void *)0));
  }
  {
#line 259
  tmp___2 = read(connfd, (void *)(msg), sizeof(msg));
#line 259
  n = (int )tmp___2;
  }
#line 260
  if ((unsigned long )n != sizeof(msg)) {
    {
#line 261
    perror("server read");
#line 262
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d/%d: Couldn\'t read remote address\n",
            n, (int )sizeof(msg));
    }
#line 263
    goto out;
  }
  {
#line 266
  tmp___3 = malloc(sizeof(*rem_dest));
#line 266
  rem_dest = (struct pingpong_dest *)tmp___3;
  }
#line 267
  if (! rem_dest) {
#line 268
    goto out;
  }
  {
#line 270
  sscanf((char const   */* __restrict  */)(msg), (char const   */* __restrict  */)"%x:%x:%x:%s",
         & rem_dest->lid, & rem_dest->qpn, & rem_dest->psn, gid);
#line 272
  wire_gid_to_gid((char const   *)(gid), & rem_dest->gid);
#line 274
  tmp___4 = pp_connect_ctx___0(ctx, ib_port, (int )my_dest->psn, mtu, sl, rem_dest,
                               sgid_idx);
  }
#line 274
  if (tmp___4) {
    {
#line 276
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t connect to remote QP\n");
#line 277
    free((void *)rem_dest);
#line 278
    rem_dest = (struct pingpong_dest *)((void *)0);
    }
#line 279
    goto out;
  }
  {
#line 283
  gid_to_wire_gid(& my_dest->gid, gid);
#line 284
  sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"%04x:%06x:%06x:%s",
          my_dest->lid, my_dest->qpn, my_dest->psn, gid);
#line 286
  tmp___5 = write(connfd, (void const   *)(msg), sizeof(msg));
  }
#line 286
  if ((unsigned long )tmp___5 != sizeof(msg)) {
    {
#line 287
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t send local address\n");
#line 288
    free((void *)rem_dest);
#line 289
    rem_dest = (struct pingpong_dest *)((void *)0);
    }
#line 290
    goto out;
  }
  {
#line 293
  read(connfd, (void *)(msg), sizeof(msg));
  }
  out: 
  {
#line 296
  close(connfd);
  }
#line 297
  return (rem_dest);
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/uc_pingpong.c"
static struct pingpong_context *pp_init_ctx___0(struct ibv_device *ib_dev , int size ,
                                                int rx_depth , int port , int use_event ) 
{ 
  struct pingpong_context *ctx ;
  void *tmp ;
  char const   *tmp___0 ;
  struct ibv_qp_init_attr attr ;
  struct ibv_qp_attr attr___0 ;
  int tmp___1 ;

  {
  {
#line 306
  tmp = calloc((size_t )1, sizeof(*ctx));
#line 306
  ctx = (struct pingpong_context *)tmp;
  }
#line 307
  if (! ctx) {
#line 308
    return ((struct pingpong_context *)((void *)0));
  }
  {
#line 310
  ctx->size = size;
#line 311
  ctx->rx_depth = rx_depth;
#line 313
  ctx->buf = memalign((size_t )page_size___1, (size_t )size);
  }
#line 314
  if (! ctx->buf) {
    {
#line 315
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t allocate work buf.\n");
    }
#line 316
    goto clean_ctx;
  }
  {
#line 320
  memset(ctx->buf, 123, (size_t )size);
#line 322
  ctx->context = ibv_open_device(ib_dev);
  }
#line 323
  if (! ctx->context) {
    {
#line 324
    tmp___0 = ibv_get_device_name(ib_dev);
#line 324
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t get context for %s\n",
            tmp___0);
    }
#line 326
    goto clean_buffer;
  }
#line 329
  if (use_event) {
    {
#line 330
    ctx->channel = ibv_create_comp_channel(ctx->context);
    }
#line 331
    if (! ctx->channel) {
      {
#line 332
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t create completion channel\n");
      }
#line 333
      goto clean_device;
    }
  } else {
#line 336
    ctx->channel = (struct ibv_comp_channel *)((void *)0);
  }
  {
#line 338
  ctx->pd = ibv_alloc_pd(ctx->context);
  }
#line 339
  if (! ctx->pd) {
    {
#line 340
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t allocate PD\n");
    }
#line 341
    goto clean_comp_channel;
  }
  {
#line 344
  ctx->mr = ibv_reg_mr(ctx->pd, ctx->buf, (size_t )size, 1);
  }
#line 345
  if (! ctx->mr) {
    {
#line 346
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t register MR\n");
    }
#line 347
    goto clean_pd;
  }
  {
#line 350
  ctx->cq = ibv_create_cq(ctx->context, rx_depth + 1, (void *)0, ctx->channel, 0);
  }
#line 352
  if (! ctx->cq) {
    {
#line 353
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t create CQ\n");
    }
#line 354
    goto clean_mr;
  }
  {
#line 358
  attr.qp_context = (void *)0;
#line 358
  attr.send_cq = ctx->cq;
#line 358
  attr.recv_cq = ctx->cq;
#line 358
  attr.srq = (struct ibv_srq *)0;
#line 358
  attr.cap.max_send_wr = (uint32_t )1;
#line 358
  attr.cap.max_recv_wr = (uint32_t )rx_depth;
#line 358
  attr.cap.max_send_sge = (uint32_t )1;
#line 358
  attr.cap.max_recv_sge = (uint32_t )1;
#line 358
  attr.cap.max_inline_data = 0U;
#line 358
  attr.qp_type = (enum ibv_qp_type )3;
#line 358
  attr.sq_sig_all = 0;
#line 370
  ctx->qp = ibv_create_qp(ctx->pd, & attr);
  }
#line 371
  if (! ctx->qp) {
    {
#line 372
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t create QP\n");
    }
#line 373
    goto clean_cq;
  }
  {
#line 378
  attr___0.qp_state = (enum ibv_qp_state )1;
#line 378
  attr___0.cur_qp_state = 0U;
#line 378
  attr___0.path_mtu = 0U;
#line 378
  attr___0.path_mig_state = 0U;
#line 378
  attr___0.qkey = 0U;
#line 378
  attr___0.rq_psn = 0U;
#line 378
  attr___0.sq_psn = 0U;
#line 378
  attr___0.dest_qp_num = 0U;
#line 378
  attr___0.qp_access_flags = 0;
#line 378
  attr___0.cap.max_send_wr = 0U;
#line 378
  attr___0.cap.max_recv_wr = 0U;
#line 378
  attr___0.cap.max_send_sge = 0U;
#line 378
  attr___0.cap.max_recv_sge = 0U;
#line 378
  attr___0.cap.max_inline_data = 0U;
#line 378
  attr___0.ah_attr.grh.dgid.raw[0] = (unsigned char)0;
#line 378
  attr___0.ah_attr.grh.dgid.raw[1] = (unsigned char)0;
#line 378
  attr___0.ah_attr.grh.dgid.raw[2] = (unsigned char)0;
#line 378
  attr___0.ah_attr.grh.dgid.raw[3] = (unsigned char)0;
#line 378
  attr___0.ah_attr.grh.dgid.raw[4] = (unsigned char)0;
#line 378
  attr___0.ah_attr.grh.dgid.raw[5] = (unsigned char)0;
#line 378
  attr___0.ah_attr.grh.dgid.raw[6] = (unsigned char)0;
#line 378
  attr___0.ah_attr.grh.dgid.raw[7] = (unsigned char)0;
#line 378
  attr___0.ah_attr.grh.dgid.raw[8] = (unsigned char)0;
#line 378
  attr___0.ah_attr.grh.dgid.raw[9] = (unsigned char)0;
#line 378
  attr___0.ah_attr.grh.dgid.raw[10] = (unsigned char)0;
#line 378
  attr___0.ah_attr.grh.dgid.raw[11] = (unsigned char)0;
#line 378
  attr___0.ah_attr.grh.dgid.raw[12] = (unsigned char)0;
#line 378
  attr___0.ah_attr.grh.dgid.raw[13] = (unsigned char)0;
#line 378
  attr___0.ah_attr.grh.dgid.raw[14] = (unsigned char)0;
#line 378
  attr___0.ah_attr.grh.dgid.raw[15] = (unsigned char)0;
#line 378
  attr___0.ah_attr.grh.flow_label = 0U;
#line 378
  attr___0.ah_attr.grh.sgid_index = (unsigned char)0;
#line 378
  attr___0.ah_attr.grh.hop_limit = (unsigned char)0;
#line 378
  attr___0.ah_attr.grh.traffic_class = (unsigned char)0;
#line 378
  attr___0.ah_attr.dlid = (unsigned short)0;
#line 378
  attr___0.ah_attr.sl = (unsigned char)0;
#line 378
  attr___0.ah_attr.src_path_bits = (unsigned char)0;
#line 378
  attr___0.ah_attr.static_rate = (unsigned char)0;
#line 378
  attr___0.ah_attr.is_global = (unsigned char)0;
#line 378
  attr___0.ah_attr.port_num = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.grh.dgid.raw[0] = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.grh.dgid.raw[1] = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.grh.dgid.raw[2] = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.grh.dgid.raw[3] = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.grh.dgid.raw[4] = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.grh.dgid.raw[5] = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.grh.dgid.raw[6] = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.grh.dgid.raw[7] = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.grh.dgid.raw[8] = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.grh.dgid.raw[9] = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.grh.dgid.raw[10] = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.grh.dgid.raw[11] = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.grh.dgid.raw[12] = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.grh.dgid.raw[13] = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.grh.dgid.raw[14] = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.grh.dgid.raw[15] = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.grh.flow_label = 0U;
#line 378
  attr___0.alt_ah_attr.grh.sgid_index = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.grh.hop_limit = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.grh.traffic_class = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.dlid = (unsigned short)0;
#line 378
  attr___0.alt_ah_attr.sl = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.src_path_bits = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.static_rate = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.is_global = (unsigned char)0;
#line 378
  attr___0.alt_ah_attr.port_num = (unsigned char)0;
#line 378
  attr___0.pkey_index = (uint16_t )0;
#line 378
  attr___0.alt_pkey_index = (unsigned short)0;
#line 378
  attr___0.en_sqd_async_notify = (unsigned char)0;
#line 378
  attr___0.sq_draining = (unsigned char)0;
#line 378
  attr___0.max_rd_atomic = (unsigned char)0;
#line 378
  attr___0.max_dest_rd_atomic = (unsigned char)0;
#line 378
  attr___0.min_rnr_timer = (unsigned char)0;
#line 378
  attr___0.port_num = (uint8_t )port;
#line 378
  attr___0.timeout = (unsigned char)0;
#line 378
  attr___0.retry_cnt = (unsigned char)0;
#line 378
  attr___0.rnr_retry = (unsigned char)0;
#line 378
  attr___0.alt_port_num = (unsigned char)0;
#line 378
  attr___0.alt_timeout = (unsigned char)0;
#line 385
  tmp___1 = ibv_modify_qp(ctx->qp, & attr___0, 57);
  }
#line 385
  if (tmp___1) {
    {
#line 390
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to modify QP to INIT\n");
    }
#line 391
    goto clean_qp;
  }
#line 395
  return (ctx);
  clean_qp: 
  {
#line 398
  ibv_destroy_qp(ctx->qp);
  }
  clean_cq: 
  {
#line 401
  ibv_destroy_cq(ctx->cq);
  }
  clean_mr: 
  {
#line 404
  ibv_dereg_mr(ctx->mr);
  }
  clean_pd: 
  {
#line 407
  ibv_dealloc_pd(ctx->pd);
  }
  clean_comp_channel: 
#line 410
  if (ctx->channel) {
    {
#line 411
    ibv_destroy_comp_channel(ctx->channel);
    }
  }
  clean_device: 
  {
#line 414
  ibv_close_device(ctx->context);
  }
  clean_buffer: 
  {
#line 417
  free(ctx->buf);
  }
  clean_ctx: 
  {
#line 420
  free((void *)ctx);
  }
#line 422
  return ((struct pingpong_context *)((void *)0));
}
}
#line 465 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/uc_pingpong.c"
static int pp_post_recv___0(struct pingpong_context *ctx , int n ) 
{ 
  struct ibv_sge list ;
  struct ibv_recv_wr wr ;
  struct ibv_recv_wr *bad_wr ;
  int i ;
  int tmp ;

  {
#line 467
  list.addr = (uintptr_t )ctx->buf;
#line 467
  list.length = (uint32_t )ctx->size;
#line 467
  list.lkey = (ctx->mr)->lkey;
#line 472
  wr.wr_id = (uint64_t )1;
#line 472
  wr.next = (struct ibv_recv_wr *)0;
#line 472
  wr.sg_list = & list;
#line 472
  wr.num_sge = 1;
#line 480
  i = 0;
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    if (! (i < n)) {
#line 480
      goto while_break;
    }
    {
#line 481
    tmp = ibv_post_recv(ctx->qp, & wr, & bad_wr);
    }
#line 481
    if (tmp) {
#line 482
      goto while_break;
    }
#line 480
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 484
  return (i);
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/uc_pingpong.c"
static int pp_post_send___0(struct pingpong_context *ctx ) 
{ 
  struct ibv_sge list ;
  struct ibv_send_wr wr ;
  struct ibv_send_wr *bad_wr ;
  int tmp ;

  {
  {
#line 489
  list.addr = (uintptr_t )ctx->buf;
#line 489
  list.length = (uint32_t )ctx->size;
#line 489
  list.lkey = (ctx->mr)->lkey;
#line 494
  wr.wr_id = (uint64_t )2;
#line 494
  wr.next = (struct ibv_send_wr *)0;
#line 494
  wr.sg_list = & list;
#line 494
  wr.num_sge = 1;
#line 494
  wr.opcode = (enum ibv_wr_opcode )2;
#line 494
  wr.send_flags = 2;
#line 494
  wr.imm_data = 0U;
#line 494
  wr.wr.atomic.remote_addr = 0UL;
#line 494
  wr.wr.atomic.compare_add = 0UL;
#line 494
  wr.wr.atomic.swap = 0UL;
#line 494
  wr.wr.atomic.rkey = 0U;
#line 503
  tmp = ibv_post_send(ctx->qp, & wr, & bad_wr);
  }
#line 503
  return (tmp);
}
}
#line 506 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/uc_pingpong.c"
static void usage___0(char const   *argv0 ) 
{ 


  {
  {
#line 508
  printf((char const   */* __restrict  */)"Usage:\n");
#line 509
  printf((char const   */* __restrict  */)"  %s            start a server and wait for connection\n",
         argv0);
#line 510
  printf((char const   */* __restrict  */)"  %s <host>     connect to server at <host>\n",
         argv0);
#line 511
  printf((char const   */* __restrict  */)"\n");
#line 512
  printf((char const   */* __restrict  */)"Options:\n");
#line 513
  printf((char const   */* __restrict  */)"  -p, --port=<port>      listen on/connect to port <port> (default 18515)\n");
#line 514
  printf((char const   */* __restrict  */)"  -d, --ib-dev=<dev>     use IB device <dev> (default first device found)\n");
#line 515
  printf((char const   */* __restrict  */)"  -i, --ib-port=<port>   use port <port> of IB device (default 1)\n");
#line 516
  printf((char const   */* __restrict  */)"  -s, --size=<size>      size of message to exchange (default 4096)\n");
#line 517
  printf((char const   */* __restrict  */)"  -m, --mtu=<size>       path MTU (default 1024)\n");
#line 518
  printf((char const   */* __restrict  */)"  -r, --rx-depth=<dep>   number of receives to post at a time (default 500)\n");
#line 519
  printf((char const   */* __restrict  */)"  -n, --iters=<iters>    number of exchanges (default 1000)\n");
#line 520
  printf((char const   */* __restrict  */)"  -l, --sl=<sl>          service level value\n");
#line 521
  printf((char const   */* __restrict  */)"  -e, --events           sleep on CQ events (default poll)\n");
#line 522
  printf((char const   */* __restrict  */)"  -g, --gid-idx=<gid index> local port gid index\n");
  }
#line 523
  return;
}
}
#line 554 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/uc_pingpong.c"
static struct option long_options___0[11]  = 
#line 554
  {      {"port", 1, (int *)0, 'p'}, 
        {"ib-dev", 1, (int *)0, 'd'}, 
        {"ib-port", 1, (int *)0, 'i'}, 
        {"size", 1, (int *)0, 's'}, 
        {"mtu", 1, (int *)0, 'm'}, 
        {"rx-depth", 1, (int *)0, 'r'}, 
        {"iters", 1, (int *)0, 'n'}, 
        {"sl", 1, (int *)0, 'l'}, 
        {"events", 0, (int *)0, 'e'}, 
        {"gid-idx", 1, (int *)0, 'g'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 132 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
__asm__(".symver __ibv_query_device,ibv_query_device@@IBVERBS_1.1");
#line 139
__asm__(".symver __ibv_query_port,ibv_query_port@@IBVERBS_1.1");
#line 164
__asm__(".symver __ibv_query_gid,ibv_query_gid@@IBVERBS_1.1");
#line 185
__asm__(".symver __ibv_query_pkey,ibv_query_pkey@@IBVERBS_1.1");
#line 197
__asm__(".symver __ibv_alloc_pd,ibv_alloc_pd@@IBVERBS_1.1");
#line 203
__asm__(".symver __ibv_dealloc_pd,ibv_dealloc_pd@@IBVERBS_1.1");
#line 224
__asm__(".symver __ibv_reg_mr,ibv_reg_mr@@IBVERBS_1.1");
#line 238
__asm__(".symver __ibv_dereg_mr,ibv_dereg_mr@@IBVERBS_1.1");
#line 243 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int warned___0  ;
#line 240 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static struct ibv_comp_channel *ibv_create_comp_channel_v2___0(struct ibv_context *context ) 
{ 
  struct ibv_abi_compat_v2 *t ;
  int tmp ;

  {
  {
#line 242
  t = (struct ibv_abi_compat_v2 *)context->abi_compat;
#line 245
  tmp = pthread_mutex_trylock(& t->in_use);
  }
#line 245
  if (! tmp) {
#line 246
    return (& t->channel);
  }
#line 248
  if (! warned___0) {
    {
#line 249
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: kernel\'s ABI version %d limits capacity.\n    Only one completion channel can be created per context.\n",
            abi_ver);
#line 252
    warned___0 ++;
    }
  }
#line 255
  return ((struct ibv_comp_channel *)((void *)0));
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int ibv_destroy_comp_channel_v2___0(struct ibv_comp_channel *channel ) 
{ 
  struct ibv_abi_compat_v2 *t ;

  {
  {
#line 288
  t = (struct ibv_abi_compat_v2 *)channel;
#line 289
  pthread_mutex_unlock(& t->in_use);
  }
#line 290
  return (0);
}
}
#line 346
__asm__(".symver __ibv_create_cq,ibv_create_cq@@IBVERBS_1.1");
#line 355
__asm__(".symver __ibv_resize_cq,ibv_resize_cq@@IBVERBS_1.1");
#line 375
__asm__(".symver __ibv_destroy_cq,ibv_destroy_cq@@IBVERBS_1.1");
#line 393
__asm__(".symver __ibv_get_cq_event,ibv_get_cq_event@@IBVERBS_1.1");
#line 402
__asm__(".symver __ibv_ack_cq_events,ibv_ack_cq_events@@IBVERBS_1.1");
#line 424
__asm__(".symver __ibv_create_srq,ibv_create_srq@@IBVERBS_1.1");
#line 432
__asm__(".symver __ibv_modify_srq,ibv_modify_srq@@IBVERBS_1.1");
#line 438
__asm__(".symver __ibv_query_srq,ibv_query_srq@@IBVERBS_1.1");
#line 444
__asm__(".symver __ibv_destroy_srq,ibv_destroy_srq@@IBVERBS_1.1");
#line 467
__asm__(".symver __ibv_create_qp,ibv_create_qp@@IBVERBS_1.1");
#line 484
__asm__(".symver __ibv_query_qp,ibv_query_qp@@IBVERBS_1.1");
#line 500
__asm__(".symver __ibv_modify_qp,ibv_modify_qp@@IBVERBS_1.1");
#line 506
__asm__(".symver __ibv_destroy_qp,ibv_destroy_qp@@IBVERBS_1.1");
#line 519
__asm__(".symver __ibv_create_ah,ibv_create_ah@@IBVERBS_1.1");
#line 521 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int ibv_find_gid_index___0(struct ibv_context *context , uint8_t port_num ,
                                  union ibv_gid *gid ) 
{ 
  union ibv_gid sgid ;
  int i ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 525
  i = 0;
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 528
    tmp = i;
#line 528
    i ++;
#line 528
    ret = ibv_query_gid(context, port_num, tmp, & sgid);
    }
#line 527
    if (! ret) {
      {
#line 527
      tmp___0 = memcmp((void const   *)(& sgid), (void const   *)gid, sizeof(*gid));
      }
#line 527
      if (! tmp___0) {
#line 527
        goto while_break;
      }
    } else {
#line 527
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 531
  if (ret) {
#line 531
    tmp___1 = ret;
  } else {
#line 531
    tmp___1 = i - 1;
  }
#line 531
  return (tmp___1);
}
}
#line 581
__asm__(".symver __ibv_destroy_ah,ibv_destroy_ah@@IBVERBS_1.1");
#line 587
__asm__(".symver __ibv_attach_mcast,ibv_attach_mcast@@IBVERBS_1.1");
#line 593
__asm__(".symver __ibv_detach_mcast,ibv_detach_mcast@@IBVERBS_1.1");
#line 82 "./include/infiniband/verbs.h"
static void *__VERBS_ABI_IS_EXTENDED___0  =    (void *)((uint8_t *)((void *)0) - 1);
#line 877 "./include/infiniband/verbs.h"
__inline static struct verbs_context *verbs_get_ctx___0(struct ibv_context *ctx ) 
{ 
  struct verbs_context *tmp ;

  {
#line 879
  if ((unsigned long )ctx->abi_compat != (unsigned long )__VERBS_ABI_IS_EXTENDED___0) {
#line 879
    tmp = (struct verbs_context *)((void *)0);
  } else {
#line 879
    tmp = (struct verbs_context *)((uint8_t *)ctx - (unsigned long )(& ((struct verbs_context *)0)->context));
  }
#line 879
  return (tmp);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static pthread_once_t device_list_once___0  =    0;
#line 53 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static int num_devices___0  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static struct ibv_device **device_list___0  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static void count_devices___0(void) 
{ 
  int __attribute__((__visibility__("hidden")))  tmp ;

  {
  {
#line 58
  tmp = ibverbs_init(& device_list___0);
#line 58
  num_devices___0 = (int )tmp;
  }
#line 59
  return;
}
}
#line 89
__asm__(".symver __ibv_get_device_list,ibv_get_device_list@@IBVERBS_1.1");
#line 95
__asm__(".symver __ibv_free_device_list,ibv_free_device_list@@IBVERBS_1.1");
#line 101
__asm__(".symver __ibv_get_device_name,ibv_get_device_name@@IBVERBS_1.1");
#line 123
__asm__(".symver __ibv_get_device_guid,ibv_get_device_guid@@IBVERBS_1.1");
#line 190
__asm__(".symver __ibv_open_device,ibv_open_device@@IBVERBS_1.1");
#line 215
__asm__(".symver __ibv_close_device,ibv_close_device@@IBVERBS_1.1");
#line 258
__asm__(".symver __ibv_get_async_event,ibv_get_async_event@@IBVERBS_1.1");
#line 311
__asm__(".symver __ibv_ack_async_event,ibv_ack_async_event@@IBVERBS_1.1");
#line 73 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *mm_root___0  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static pthread_mutex_t mm_mutex___0  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 75 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int page_size___2  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int huge_page_enabled___0  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int too_late___0  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static unsigned long smaps_page_size___0(FILE *file ) 
{ 
  int n ;
  unsigned long size ;
  char buf[1024] ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 82
  size = (unsigned long )page_size___2;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 85
    tmp___0 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)file);
    }
#line 85
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 85
      goto while_break;
    }
    {
#line 86
    tmp = strstr((char const   *)(buf), "KernelPageSize:");
    }
#line 86
    if (! tmp) {
#line 87
      goto while_continue;
    }
    {
#line 89
    n = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*s %lu",
               & size);
    }
#line 90
    if (n < 1) {
#line 91
      goto while_continue;
    }
#line 94
    size *= 1024UL;
#line 96
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return (size);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static unsigned long get_page_size___0(void *base ) 
{ 
  unsigned long ret ;
  pid_t pid ;
  FILE *file ;
  char buf[1024] ;
  int n ;
  uintptr_t range_start ;
  uintptr_t range_end ;
  char *tmp ;

  {
  {
#line 104
  ret = (unsigned long )page_size___2;
#line 109
  pid = getpid();
#line 110
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"/proc/%d/smaps",
           pid);
#line 112
  file = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"re");
  }
#line 113
  if (! file) {
#line 114
    goto out;
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 116
    tmp = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)file);
    }
#line 116
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 116
      goto while_break;
    }
    {
#line 120
    n = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%lx-%lx",
               & range_start, & range_end);
    }
#line 122
    if (n < 2) {
#line 123
      goto while_continue;
    }
#line 125
    if ((uintptr_t )base >= range_start) {
#line 125
      if ((uintptr_t )base < range_end) {
        {
#line 126
        ret = smaps_page_size___0(file);
        }
#line 127
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  fclose(file);
  }
  out: 
#line 134
  return (ret);
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_prev___0(struct ibv_mem_node *node ) 
{ 


  {
#line 194
  if (node->left) {
#line 195
    node = node->left;
    {
#line 196
    while (1) {
      while_continue: /* CIL Label */ ;
#line 196
      if (! node->right) {
#line 196
        goto while_break;
      }
#line 197
      node = node->right;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 199
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 199
      if (node->parent) {
#line 199
        if (! ((unsigned long )node == (unsigned long )(node->parent)->left)) {
#line 199
          goto while_break___0;
        }
      } else {
#line 199
        goto while_break___0;
      }
#line 200
      node = node->parent;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 202
    node = node->parent;
  }
#line 205
  return (node);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_next___0(struct ibv_mem_node *node ) 
{ 


  {
#line 210
  if (node->right) {
#line 211
    node = node->right;
    {
#line 212
    while (1) {
      while_continue: /* CIL Label */ ;
#line 212
      if (! node->left) {
#line 212
        goto while_break;
      }
#line 213
      node = node->left;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 215
      if (node->parent) {
#line 215
        if (! ((unsigned long )node == (unsigned long )(node->parent)->right)) {
#line 215
          goto while_break___0;
        }
      } else {
#line 215
        goto while_break___0;
      }
#line 216
      node = node->parent;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 218
    node = node->parent;
  }
#line 221
  return (node);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_rotate_right___0(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 228
  tmp = node->left;
#line 230
  node->left = tmp->right;
#line 231
  if (node->left) {
#line 232
    (node->left)->parent = node;
  }
#line 234
  if (node->parent) {
#line 235
    if ((unsigned long )(node->parent)->right == (unsigned long )node) {
#line 236
      (node->parent)->right = tmp;
    } else {
#line 238
      (node->parent)->left = tmp;
    }
  } else {
#line 240
    mm_root___0 = tmp;
  }
#line 242
  tmp->parent = node->parent;
#line 244
  tmp->right = node;
#line 245
  node->parent = tmp;
#line 246
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_rotate_left___0(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 252
  tmp = node->right;
#line 254
  node->right = tmp->left;
#line 255
  if (node->right) {
#line 256
    (node->right)->parent = node;
  }
#line 258
  if (node->parent) {
#line 259
    if ((unsigned long )(node->parent)->right == (unsigned long )node) {
#line 260
      (node->parent)->right = tmp;
    } else {
#line 262
      (node->parent)->left = tmp;
    }
  } else {
#line 264
    mm_root___0 = tmp;
  }
#line 266
  tmp->parent = node->parent;
#line 268
  tmp->left = node;
#line 269
  node->parent = tmp;
#line 270
  return;
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_add_rebalance___0(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *parent ;
  struct ibv_mem_node *gp ;
  struct ibv_mem_node *uncle ;

  {
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (node->parent) {
#line 304
      if (! ((unsigned int )(node->parent)->color == 0U)) {
#line 304
        goto while_break;
      }
    } else {
#line 304
      goto while_break;
    }
#line 305
    parent = node->parent;
#line 306
    gp = (node->parent)->parent;
#line 308
    if ((unsigned long )parent == (unsigned long )gp->left) {
#line 309
      uncle = gp->right;
#line 311
      if (uncle) {
#line 311
        if ((unsigned int )uncle->color == 0U) {
#line 312
          parent->color = (enum __anonenum_color_68 )1;
#line 313
          uncle->color = (enum __anonenum_color_68 )1;
#line 314
          gp->color = (enum __anonenum_color_68 )0;
#line 316
          node = gp;
        } else {
#line 311
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 318
        if ((unsigned long )node == (unsigned long )parent->right) {
          {
#line 319
          __mm_rotate_left___0(parent);
#line 320
          node = parent;
#line 321
          parent = node->parent;
          }
        }
        {
#line 324
        parent->color = (enum __anonenum_color_68 )1;
#line 325
        gp->color = (enum __anonenum_color_68 )0;
#line 327
        __mm_rotate_right___0(gp);
        }
      }
    } else {
#line 330
      uncle = gp->left;
#line 332
      if (uncle) {
#line 332
        if ((unsigned int )uncle->color == 0U) {
#line 333
          parent->color = (enum __anonenum_color_68 )1;
#line 334
          uncle->color = (enum __anonenum_color_68 )1;
#line 335
          gp->color = (enum __anonenum_color_68 )0;
#line 337
          node = gp;
        } else {
#line 332
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 339
        if ((unsigned long )node == (unsigned long )parent->left) {
          {
#line 340
          __mm_rotate_right___0(parent);
#line 341
          node = parent;
#line 342
          parent = node->parent;
          }
        }
        {
#line 345
        parent->color = (enum __anonenum_color_68 )1;
#line 346
        gp->color = (enum __anonenum_color_68 )0;
#line 348
        __mm_rotate_left___0(gp);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  mm_root___0->color = (enum __anonenum_color_68 )1;
#line 354
  return;
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_add___0(struct ibv_mem_node *new ) 
{ 
  struct ibv_mem_node *node ;
  struct ibv_mem_node *parent ;

  {
#line 358
  parent = (struct ibv_mem_node *)((void *)0);
#line 360
  node = mm_root___0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! node) {
#line 361
      goto while_break;
    }
#line 362
    parent = node;
#line 363
    if (node->start < new->start) {
#line 364
      node = node->right;
    } else {
#line 366
      node = node->left;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  if (parent->start < new->start) {
#line 370
    parent->right = new;
  } else {
#line 372
    parent->left = new;
  }
  {
#line 374
  new->parent = parent;
#line 375
  new->left = (struct ibv_mem_node *)((void *)0);
#line 376
  new->right = (struct ibv_mem_node *)((void *)0);
#line 378
  new->color = (enum __anonenum_color_68 )0;
#line 379
  __mm_add_rebalance___0(new);
  }
#line 380
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_remove___0(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *child ;
  struct ibv_mem_node *parent ;
  struct ibv_mem_node *sib ;
  struct ibv_mem_node *tmp ;
  int nodecol ;

  {
#line 387
  if (node->left) {
#line 387
    if (node->right) {
#line 388
      tmp = node->left;
      {
#line 389
      while (1) {
        while_continue: /* CIL Label */ ;
#line 389
        if (! tmp->right) {
#line 389
          goto while_break;
        }
#line 390
        tmp = tmp->right;
      }
      while_break: /* CIL Label */ ;
      }
#line 392
      nodecol = (int )tmp->color;
#line 393
      child = tmp->left;
#line 394
      tmp->color = node->color;
#line 396
      if ((unsigned long )tmp->parent != (unsigned long )node) {
#line 397
        parent = tmp->parent;
#line 398
        parent->right = tmp->left;
#line 399
        if (tmp->left) {
#line 400
          (tmp->left)->parent = parent;
        }
#line 402
        tmp->left = node->left;
#line 403
        (node->left)->parent = tmp;
      } else {
#line 405
        parent = tmp;
      }
#line 407
      tmp->right = node->right;
#line 408
      (node->right)->parent = tmp;
#line 410
      tmp->parent = node->parent;
#line 411
      if (node->parent) {
#line 412
        if ((unsigned long )(node->parent)->left == (unsigned long )node) {
#line 413
          (node->parent)->left = tmp;
        } else {
#line 415
          (node->parent)->right = tmp;
        }
      } else {
#line 417
        mm_root___0 = tmp;
      }
    } else {
#line 387
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 419
    nodecol = (int )node->color;
#line 421
    if (node->left) {
#line 421
      child = node->left;
    } else {
#line 421
      child = node->right;
    }
#line 422
    parent = node->parent;
#line 424
    if (child) {
#line 425
      child->parent = parent;
    }
#line 426
    if (parent) {
#line 427
      if ((unsigned long )parent->left == (unsigned long )node) {
#line 428
        parent->left = child;
      } else {
#line 430
        parent->right = child;
      }
    } else {
#line 432
      mm_root___0 = child;
    }
  }
  {
#line 435
  free((void *)node);
  }
#line 437
  if (nodecol == 0) {
#line 438
    return;
  }
  {
#line 440
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 440
    if (! child) {
#line 440
      goto _L___6;
    } else
#line 440
    if ((unsigned int )child->color == 1U) {
      _L___6: /* CIL Label */ 
#line 440
      if (! ((unsigned long )child != (unsigned long )mm_root___0)) {
#line 440
        goto while_break___0;
      }
    } else {
#line 440
      goto while_break___0;
    }
#line 441
    if ((unsigned long )parent->left == (unsigned long )child) {
#line 442
      sib = parent->right;
#line 444
      if ((unsigned int )sib->color == 0U) {
        {
#line 445
        parent->color = (enum __anonenum_color_68 )0;
#line 446
        sib->color = (enum __anonenum_color_68 )1;
#line 447
        __mm_rotate_left___0(parent);
#line 448
        sib = parent->right;
        }
      }
#line 451
      if (! sib->left) {
#line 451
        goto _L___2;
      } else
#line 451
      if ((unsigned int )(sib->left)->color == 1U) {
        _L___2: /* CIL Label */ 
#line 451
        if (! sib->right) {
#line 453
          sib->color = (enum __anonenum_color_68 )0;
#line 454
          child = parent;
#line 455
          parent = child->parent;
        } else
#line 451
        if ((unsigned int )(sib->right)->color == 1U) {
#line 453
          sib->color = (enum __anonenum_color_68 )0;
#line 454
          child = parent;
#line 455
          parent = child->parent;
        } else {
#line 451
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 457
        if (! sib->right) {
#line 457
          goto _L___0;
        } else
#line 457
        if ((unsigned int )(sib->right)->color == 1U) {
          _L___0: /* CIL Label */ 
#line 458
          if (sib->left) {
#line 459
            (sib->left)->color = (enum __anonenum_color_68 )1;
          }
          {
#line 460
          sib->color = (enum __anonenum_color_68 )0;
#line 461
          __mm_rotate_right___0(sib);
#line 462
          sib = parent->right;
          }
        }
#line 465
        sib->color = parent->color;
#line 466
        parent->color = (enum __anonenum_color_68 )1;
#line 467
        if (sib->right) {
#line 468
          (sib->right)->color = (enum __anonenum_color_68 )1;
        }
        {
#line 469
        __mm_rotate_left___0(parent);
#line 470
        child = mm_root___0;
        }
#line 471
        goto while_break___0;
      }
    } else {
#line 474
      sib = parent->left;
#line 476
      if ((unsigned int )sib->color == 0U) {
        {
#line 477
        parent->color = (enum __anonenum_color_68 )0;
#line 478
        sib->color = (enum __anonenum_color_68 )1;
#line 479
        __mm_rotate_right___0(parent);
#line 480
        sib = parent->left;
        }
      }
#line 483
      if (! sib->left) {
#line 483
        goto _L___5;
      } else
#line 483
      if ((unsigned int )(sib->left)->color == 1U) {
        _L___5: /* CIL Label */ 
#line 483
        if (! sib->right) {
#line 485
          sib->color = (enum __anonenum_color_68 )0;
#line 486
          child = parent;
#line 487
          parent = child->parent;
        } else
#line 483
        if ((unsigned int )(sib->right)->color == 1U) {
#line 485
          sib->color = (enum __anonenum_color_68 )0;
#line 486
          child = parent;
#line 487
          parent = child->parent;
        } else {
#line 483
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
#line 489
        if (! sib->left) {
#line 489
          goto _L___3;
        } else
#line 489
        if ((unsigned int )(sib->left)->color == 1U) {
          _L___3: /* CIL Label */ 
#line 490
          if (sib->right) {
#line 491
            (sib->right)->color = (enum __anonenum_color_68 )1;
          }
          {
#line 492
          sib->color = (enum __anonenum_color_68 )0;
#line 493
          __mm_rotate_left___0(sib);
#line 494
          sib = parent->left;
          }
        }
#line 497
        sib->color = parent->color;
#line 498
        parent->color = (enum __anonenum_color_68 )1;
#line 499
        if (sib->left) {
#line 500
          (sib->left)->color = (enum __anonenum_color_68 )1;
        }
        {
#line 501
        __mm_rotate_right___0(parent);
#line 502
        child = mm_root___0;
        }
#line 503
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 508
  if (child) {
#line 509
    child->color = (enum __anonenum_color_68 )1;
  }
#line 510
  return;
}
}
#line 512 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_find_start___0(uintptr_t start , uintptr_t end ) 
{ 
  struct ibv_mem_node *node ;

  {
#line 514
  node = mm_root___0;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! node) {
#line 516
      goto while_break;
    }
#line 517
    if (node->start <= start) {
#line 517
      if (node->end >= start) {
#line 518
        goto while_break;
      }
    }
#line 520
    if (node->start < start) {
#line 521
      node = node->right;
    } else {
#line 523
      node = node->left;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 526
  return (node);
}
}
#line 529 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *merge_ranges___0(struct ibv_mem_node *node , struct ibv_mem_node *prev ) 
{ 


  {
  {
#line 532
  prev->end = node->end;
#line 533
  prev->refcnt = node->refcnt;
#line 534
  __mm_remove___0(node);
  }
#line 536
  return (prev);
}
}
#line 539 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *split_range___0(struct ibv_mem_node *node , uintptr_t cut_line ) 
{ 
  struct ibv_mem_node *new_node ;
  void *tmp ;

  {
  {
#line 542
  new_node = (struct ibv_mem_node *)((void *)0);
#line 544
  tmp = malloc(sizeof(*new_node));
#line 544
  new_node = (struct ibv_mem_node *)tmp;
  }
#line 545
  if (! new_node) {
#line 546
    return ((struct ibv_mem_node *)((void *)0));
  }
  {
#line 547
  new_node->start = cut_line;
#line 548
  new_node->end = node->end;
#line 549
  new_node->refcnt = node->refcnt;
#line 550
  node->end = cut_line - 1UL;
#line 551
  __mm_add___0(new_node);
  }
#line 553
  return (new_node);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *get_start_node___0(uintptr_t start , uintptr_t end , int inc ) 
{ 
  struct ibv_mem_node *node ;
  struct ibv_mem_node *tmp ;

  {
  {
#line 559
  tmp = (struct ibv_mem_node *)((void *)0);
#line 561
  node = __mm_find_start___0(start, end);
  }
#line 562
  if (node->start < start) {
    {
#line 563
    node = split_range___0(node, start);
    }
  } else {
    {
#line 565
    tmp = __mm_prev___0(node);
    }
#line 566
    if (tmp) {
#line 566
      if (tmp->refcnt == node->refcnt + inc) {
        {
#line 567
        node = merge_ranges___0(node, tmp);
        }
      }
    }
  }
#line 569
  return (node);
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *undo_node___0(struct ibv_mem_node *node , uintptr_t start ,
                                          int inc ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 579
  tmp = (struct ibv_mem_node *)((void *)0);
#line 585
  if (start > node->start) {
    {
#line 586
    tmp = split_range___0(node, start);
    }
#line 587
    if (tmp) {
#line 588
      node->refcnt += inc;
#line 589
      node = tmp;
    } else {
#line 591
      return ((struct ibv_mem_node *)((void *)0));
    }
  }
  {
#line 594
  tmp = __mm_prev___0(node);
  }
#line 595
  if (tmp) {
#line 595
    if (tmp->refcnt == node->refcnt) {
      {
#line 596
      node = merge_ranges___0(node, tmp);
      }
    }
  }
  {
#line 598
  tmp = __mm_next___0(node);
  }
#line 599
  if (tmp) {
#line 599
    if (tmp->refcnt == node->refcnt) {
      {
#line 600
      node = merge_ranges___0(tmp, node);
      }
    }
  }
#line 602
  return (node);
}
}
#line 605 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int ibv_madvise_range___0(void *base , size_t size , int advice ) 
{ 
  uintptr_t start ;
  uintptr_t end ;
  struct ibv_mem_node *node ;
  struct ibv_mem_node *tmp ;
  int inc ;
  int rolling_back ;
  int ret ;
  unsigned long range_page_size ;
  struct ibv_mem_node *tmp___0 ;

  {
#line 610
  rolling_back = 0;
#line 611
  ret = 0;
#line 614
  if (! size) {
#line 615
    return (0);
  }
#line 617
  if (huge_page_enabled___0) {
    {
#line 618
    range_page_size = get_page_size___0(base);
    }
  } else {
#line 620
    range_page_size = (unsigned long )page_size___2;
  }
  {
#line 622
  start = (uintptr_t )base & ~ (range_page_size - 1UL);
#line 623
  end = ((uintptr_t )(((base + size) + range_page_size) - 1) & ~ (range_page_size - 1UL)) - 1UL;
#line 626
  pthread_mutex_lock(& mm_mutex___0);
  }
  again: 
#line 628
  if (advice == 10) {
#line 628
    inc = 1;
  } else {
#line 628
    inc = -1;
  }
  {
#line 630
  node = get_start_node___0(start, end, inc);
  }
#line 631
  if (! node) {
#line 632
    ret = -1;
#line 633
    goto out;
  }
  {
#line 636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 636
    if (node) {
#line 636
      if (! (node->start <= end)) {
#line 636
        goto while_break;
      }
    } else {
#line 636
      goto while_break;
    }
#line 637
    if (node->end > end) {
      {
#line 638
      tmp___0 = split_range___0(node, end + 1UL);
      }
#line 638
      if (! tmp___0) {
#line 639
        ret = -1;
#line 640
        goto out;
      }
    }
#line 644
    if (inc == -1) {
#line 644
      if (node->refcnt == 1) {
#line 644
        goto _L;
      } else {
#line 644
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 644
    if (inc == 1) {
#line 644
      if (node->refcnt == 0) {
        _L: /* CIL Label */ 
#line 657
        if (start > node->start) {
          {
#line 658
          ret = madvise((void *)start, (node->end - start) + 1UL, advice);
          }
        } else {
          {
#line 661
          ret = madvise((void *)node->start, (node->end - node->start) + 1UL, advice);
          }
        }
#line 664
        if (ret) {
          {
#line 665
          node = undo_node___0(node, start, inc);
          }
#line 667
          if (rolling_back) {
#line 668
            goto out;
          } else
#line 667
          if (! node) {
#line 668
            goto out;
          }
#line 671
          rolling_back = 1;
#line 672
          if (advice == 10) {
#line 672
            advice = 11;
          } else {
#line 672
            advice = 10;
          }
          {
#line 674
          tmp = __mm_prev___0(node);
          }
#line 675
          if (! tmp) {
#line 676
            goto out;
          } else
#line 675
          if (start > tmp->end) {
#line 676
            goto out;
          }
#line 677
          end = tmp->end;
#line 678
          goto again;
        }
      }
    }
    {
#line 682
    node->refcnt += inc;
#line 683
    node = __mm_next___0(node);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if (node) {
    {
#line 687
    tmp = __mm_prev___0(node);
    }
#line 688
    if (tmp) {
#line 688
      if (node->refcnt == tmp->refcnt) {
        {
#line 689
        node = merge_ranges___0(node, tmp);
        }
      }
    }
  }
  out: 
#line 693
  if (rolling_back) {
#line 694
    ret = -1;
  }
  {
#line 696
  pthread_mutex_unlock(& mm_mutex___0);
  }
#line 698
  return (ret);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/sysfs.c"
static char *sysfs_path___0  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_sysfs_dev *sysfs_dev_list___0  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver_name *driver_name_list___0  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver *head_driver___0  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver *tail_driver___0  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static int find_sysfs_devs___0(void) 
{ 
  char class_path[256] ;
  DIR *class_dir ;
  struct dirent *dent ;
  struct ibv_sysfs_dev *sysfs_dev ;
  char value[8] ;
  int ret ;
  char const   *tmp ;
  struct stat buf ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;

  {
  {
#line 86
  sysfs_dev = (struct ibv_sysfs_dev *)((void *)0);
#line 88
  ret = 0;
#line 90
  tmp = ibv_get_sysfs_path();
#line 90
  snprintf((char */* __restrict  */)(class_path), sizeof(class_path), (char const   */* __restrict  */)"%s/class/infiniband_verbs",
           tmp);
#line 93
  class_dir = opendir((char const   *)(class_path));
  }
#line 94
  if (! class_dir) {
#line 95
    return (38);
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    dent = readdir(class_dir);
    }
#line 97
    if (! dent) {
#line 97
      goto while_break;
    }
#line 100
    if ((int )dent->d_name[0] == 46) {
#line 101
      goto while_continue;
    }
#line 103
    if (! sysfs_dev) {
      {
#line 104
      tmp___0 = malloc(sizeof(*sysfs_dev));
#line 104
      sysfs_dev = (struct ibv_sysfs_dev *)tmp___0;
      }
    }
#line 105
    if (! sysfs_dev) {
#line 106
      ret = 12;
#line 107
      goto out;
    }
    {
#line 110
    snprintf((char */* __restrict  */)(sysfs_dev->sysfs_path), sizeof(sysfs_dev->sysfs_path),
             (char const   */* __restrict  */)"%s/%s", class_path, dent->d_name);
#line 113
    tmp___1 = stat((char const   */* __restrict  */)(sysfs_dev->sysfs_path), (struct stat */* __restrict  */)(& buf));
    }
#line 113
    if (tmp___1) {
      {
#line 114
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t stat \'%s\'.\n",
              sysfs_dev->sysfs_path);
      }
#line 116
      goto while_continue;
    }
#line 119
    if (! ((buf.st_mode & 61440U) == 16384U)) {
#line 120
      goto while_continue;
    }
    {
#line 122
    snprintf((char */* __restrict  */)(sysfs_dev->sysfs_name), sizeof(sysfs_dev->sysfs_name),
             (char const   */* __restrict  */)"%s", dent->d_name);
#line 125
    tmp___2 = ibv_read_sysfs_file((char const   *)(sysfs_dev->sysfs_path), "ibdev",
                                  sysfs_dev->ibdev_name, sizeof(sysfs_dev->ibdev_name));
    }
#line 125
    if (tmp___2 < 0) {
      {
#line 128
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: no ibdev class attr for \'%s\'.\n",
              dent->d_name);
      }
#line 130
      goto while_continue;
    }
    {
#line 133
    tmp___3 = ibv_get_sysfs_path();
#line 133
    snprintf((char */* __restrict  */)(sysfs_dev->ibdev_path), sizeof(sysfs_dev->ibdev_path),
             (char const   */* __restrict  */)"%s/class/infiniband/%s", tmp___3, sysfs_dev->ibdev_name);
#line 137
    sysfs_dev->next = sysfs_dev_list___0;
#line 138
    sysfs_dev->have_driver = 0;
#line 139
    tmp___5 = ibv_read_sysfs_file((char const   *)(sysfs_dev->sysfs_path), "abi_version",
                                  value, sizeof(value));
    }
#line 139
    if (tmp___5 > 0) {
      {
#line 141
      tmp___4 = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                       10);
#line 141
      sysfs_dev->abi_ver = (int )tmp___4;
      }
    } else {
#line 143
      sysfs_dev->abi_ver = 0;
    }
#line 145
    sysfs_dev_list___0 = sysfs_dev;
#line 146
    sysfs_dev = (struct ibv_sysfs_dev *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
  out: 
#line 150
  if (sysfs_dev) {
    {
#line 151
    free((void *)sysfs_dev);
    }
  }
  {
#line 153
  closedir(class_dir);
  }
#line 154
  return (ret);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void register_driver___0(char const   *name , struct ibv_device *(*init_func)(char const   *uverbs_sys_path ,
                                                                                     int abi_version ) ,
                                struct verbs_device *(*verbs_init_func)(char const   *uverbs_sys_path ,
                                                                        int abi_version ) ) 
{ 
  struct ibv_driver *driver ;
  void *tmp ;

  {
  {
#line 162
  tmp = malloc(sizeof(*driver));
#line 162
  driver = (struct ibv_driver *)tmp;
  }
#line 163
  if (! driver) {
    {
#line 164
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver for %s\n",
            name);
    }
#line 165
    return;
  }
#line 168
  driver->name = name;
#line 169
  driver->init_func = init_func;
#line 170
  driver->verbs_init_func = verbs_init_func;
#line 171
  driver->next = (struct ibv_driver *)((void *)0);
#line 173
  if (tail_driver___0) {
#line 174
    tail_driver___0->next = driver;
  } else {
#line 176
    head_driver___0 = driver;
  }
#line 177
  tail_driver___0 = driver;
#line 178
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void load_driver___0(char const   *name ) 
{ 
  char *so_name ;
  void *dlhandle ;
  char const   *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 201
  if ((int const   )*(name + 0) == 47) {
#line 201
    tmp = "%s-rdmav2.so";
  } else {
#line 201
    tmp = "lib%s-rdmav2.so";
  }
  {
#line 201
  tmp___0 = asprintf((char **/* __restrict  */)(& so_name), (char const   */* __restrict  */)tmp,
                     name);
  }
#line 201
  if (tmp___0 < 0) {
    {
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t load driver \'%s\'.\n",
            name);
    }
#line 208
    return;
  }
  {
#line 211
  dlhandle = dlopen((char const   *)so_name, 2);
  }
#line 212
  if (! dlhandle) {
    {
#line 213
    tmp___1 = dlerror();
#line 213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t load driver \'%s\': %s\n",
            name, tmp___1);
    }
#line 215
    goto out;
  }
  out: 
  {
#line 219
  free((void *)so_name);
  }
#line 220
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void load_drivers___0(void) 
{ 
  struct ibv_driver_name *name ;
  struct ibv_driver_name *next_name ;
  char const   *env ;
  char *list ;
  char *env_name ;
  char const   *__old ;
  size_t __len ;
  size_t tmp ;
  char *__new ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *__old___0 ;
  size_t __len___0 ;
  size_t tmp___2 ;
  char *__new___0 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;

  {
  {
#line 232
  tmp___7 = getuid();
#line 232
  tmp___8 = geteuid();
  }
#line 232
  if (tmp___7 == tmp___8) {
    {
#line 233
    tmp___6 = getenv("RDMAV_DRIVERS");
#line 233
    env = (char const   *)tmp___6;
    }
#line 233
    if (env) {
      {
#line 234
      __old = env;
#line 234
      tmp = strlen(__old);
#line 234
      __len = tmp + 1UL;
#line 234
      tmp___0 = __builtin_alloca(__len);
#line 234
      __new = (char *)tmp___0;
#line 234
      tmp___1 = memcpy((void */* __restrict  */)__new, (void const   */* __restrict  */)__old,
                       __len);
#line 234
      list = (char *)tmp___1;
      }
      {
#line 235
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 235
        env_name = strsep((char **/* __restrict  */)(& list), (char const   */* __restrict  */)":;");
        }
#line 235
        if (! env_name) {
#line 235
          goto while_break;
        }
        {
#line 236
        load_driver___0((char const   *)env_name);
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 237
      tmp___5 = getenv("IBV_DRIVERS");
#line 237
      env = (char const   *)tmp___5;
      }
#line 237
      if (env) {
        {
#line 238
        __old___0 = env;
#line 238
        tmp___2 = strlen(__old___0);
#line 238
        __len___0 = tmp___2 + 1UL;
#line 238
        tmp___3 = __builtin_alloca(__len___0);
#line 238
        __new___0 = (char *)tmp___3;
#line 238
        tmp___4 = memcpy((void */* __restrict  */)__new___0, (void const   */* __restrict  */)__old___0,
                         __len___0);
#line 238
        list = (char *)tmp___4;
        }
        {
#line 239
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 239
          env_name = strsep((char **/* __restrict  */)(& list), (char const   */* __restrict  */)":;");
          }
#line 239
          if (! env_name) {
#line 239
            goto while_break___0;
          }
          {
#line 240
          load_driver___0((char const   *)env_name);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 244
  name = driver_name_list___0;
#line 244
  if (name) {
#line 244
    next_name = name->next;
  } else {
#line 244
    next_name = (struct ibv_driver_name *)((void *)0);
  }
  {
#line 244
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 244
    if (! name) {
#line 244
      goto while_break___1;
    }
    {
#line 247
    load_driver___0((char const   *)name->name);
#line 248
    free((void *)name->name);
#line 249
    free((void *)name);
#line 244
    name = next_name;
    }
#line 244
    if (name) {
#line 244
      next_name = name->next;
    } else {
#line 244
      next_name = (struct ibv_driver_name *)((void *)0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 251
  return;
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void read_config_file___0(char const   *path ) 
{ 
  FILE *conf ;
  char *line ;
  char *config ;
  char *field ;
  size_t buflen ;
  ssize_t len ;
  size_t tmp ;
  struct ibv_driver_name *driver_name ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 256
  line = (char *)((void *)0);
#line 259
  buflen = (size_t )0;
#line 262
  conf = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"re");
  }
#line 263
  if (! conf) {
    {
#line 264
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t read config file %s.\n",
            path);
    }
#line 266
    return;
  }
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 269
    len = getline((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& buflen),
                  (FILE */* __restrict  */)conf);
    }
#line 269
    if (! (len != -1L)) {
#line 269
      goto while_break;
    }
    {
#line 270
    tmp = strspn((char const   *)line, "\t ");
#line 270
    config = line + tmp;
    }
#line 271
    if ((int )*(config + 0) == 10) {
#line 272
      goto while_continue;
    } else
#line 271
    if ((int )*(config + 0) == 35) {
#line 272
      goto while_continue;
    }
    {
#line 274
    field = strsep((char **/* __restrict  */)(& config), (char const   */* __restrict  */)"\n\t ");
#line 276
    tmp___2 = strcmp((char const   *)field, "driver");
    }
#line 276
    if (tmp___2 == 0) {
#line 276
      if ((unsigned long )config != (unsigned long )((void *)0)) {
        {
#line 279
        tmp___0 = strspn((char const   *)config, "\t ");
#line 279
        config += tmp___0;
#line 280
        field = strsep((char **/* __restrict  */)(& config), (char const   */* __restrict  */)"\n\t ");
#line 282
        tmp___1 = malloc(sizeof(*driver_name));
#line 282
        driver_name = (struct ibv_driver_name *)tmp___1;
        }
#line 283
        if (! driver_name) {
          {
#line 284
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver name \'%s\'.\n",
                  field);
          }
#line 286
          goto while_continue;
        }
        {
#line 289
        driver_name->name = strdup((char const   *)field);
        }
#line 290
        if (! driver_name->name) {
          {
#line 291
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver name \'%s\'.\n",
                  field);
#line 293
          free((void *)driver_name);
          }
#line 294
          goto while_continue;
        }
#line 297
        driver_name->next = driver_name_list___0;
#line 298
        driver_name_list___0 = driver_name;
      } else {
        {
#line 300
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: ignoring bad config directive \'%s\' in file \'%s\'.\n",
                field, path);
        }
      }
    } else {
      {
#line 300
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: ignoring bad config directive \'%s\' in file \'%s\'.\n",
              field, path);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  if (line) {
    {
#line 305
    free((void *)line);
    }
  }
  {
#line 306
  fclose(conf);
  }
#line 307
  return;
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void read_config___0(void) 
{ 
  DIR *conf_dir ;
  struct dirent *dent ;
  char *path ;
  struct stat buf ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 315
  conf_dir = opendir("/usr/local/etc/libibverbs.d");
  }
#line 316
  if (! conf_dir) {
    {
#line 317
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t open config directory \'%s\'.\n",
            "/usr/local/etc/libibverbs.d");
    }
#line 319
    return;
  }
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 322
    dent = readdir(conf_dir);
    }
#line 322
    if (! dent) {
#line 322
      goto while_break;
    }
    {
#line 325
    tmp = asprintf((char **/* __restrict  */)(& path), (char const   */* __restrict  */)"%s/%s",
                   "/usr/local/etc/libibverbs.d", dent->d_name);
    }
#line 325
    if (tmp < 0) {
      {
#line 326
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t read config file %s/%s.\n",
              "/usr/local/etc/libibverbs.d", dent->d_name);
      }
#line 328
      goto out;
    }
    {
#line 331
    tmp___0 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& buf));
    }
#line 331
    if (tmp___0) {
      {
#line 332
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t stat config file \'%s\'.\n",
              path);
      }
#line 334
      goto next;
    }
#line 337
    if (! ((buf.st_mode & 61440U) == 32768U)) {
#line 338
      goto next;
    }
    {
#line 340
    read_config_file___0((char const   *)path);
    }
    next: 
    {
#line 342
    free((void *)path);
    }
  }
  while_break: /* CIL Label */ ;
  }
  out: 
  {
#line 346
  closedir(conf_dir);
  }
#line 347
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_device *try_driver___0(struct ibv_driver *driver , struct ibv_sysfs_dev *sysfs_dev ) 
{ 
  struct verbs_device *vdev ;
  struct ibv_device *dev ;
  char value[8] ;
  long tmp ;
  int tmp___0 ;

  {
#line 356
  if (driver->init_func) {
    {
#line 357
    dev = (*(driver->init_func))((char const   *)(sysfs_dev->sysfs_path), sysfs_dev->abi_ver);
    }
#line 358
    if (! dev) {
#line 359
      return ((struct ibv_device *)((void *)0));
    }
  } else {
    {
#line 361
    vdev = (*(driver->verbs_init_func))((char const   *)(sysfs_dev->sysfs_path), sysfs_dev->abi_ver);
    }
#line 362
    if (! vdev) {
#line 363
      return ((struct ibv_device *)((void *)0));
    }
#line 365
    dev = & vdev->device;
#line 366
    dev->ops.alloc_context = (struct ibv_context *(*)(struct ibv_device *device ,
                                                      int cmd_fd ))((void *)0);
#line 367
    dev->ops.free_context = (void (*)(struct ibv_context *context ))((void *)0);
  }
  {
#line 370
  tmp___0 = ibv_read_sysfs_file((char const   *)(sysfs_dev->ibdev_path), "node_type",
                                value, sizeof(value));
  }
#line 370
  if (tmp___0 < 0) {
    {
#line 371
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: no node_type attr under %s.\n",
            sysfs_dev->ibdev_path);
#line 373
    dev->node_type = (enum ibv_node_type )-1;
    }
  } else {
    {
#line 375
    tmp = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                 10);
#line 375
    dev->node_type = (enum ibv_node_type )tmp;
    }
#line 376
    if ((int )dev->node_type < 1) {
#line 377
      dev->node_type = (enum ibv_node_type )-1;
    } else
#line 376
    if ((int )dev->node_type > 4) {
#line 377
      dev->node_type = (enum ibv_node_type )-1;
    }
  }
  {
#line 383
  if ((int )dev->node_type == 3) {
#line 383
    goto case_3;
  }
#line 383
  if ((int )dev->node_type == 2) {
#line 383
    goto case_3;
  }
#line 383
  if ((int )dev->node_type == 1) {
#line 383
    goto case_3;
  }
#line 386
  if ((int )dev->node_type == 4) {
#line 386
    goto case_4;
  }
#line 389
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 384
  dev->transport_type = (enum ibv_transport_type )0;
#line 385
  goto switch_break;
  case_4: /* CIL Label */ 
#line 387
  dev->transport_type = (enum ibv_transport_type )1;
#line 388
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 390
  dev->transport_type = (enum ibv_transport_type )-1;
#line 391
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 394
  strcpy((char */* __restrict  */)(dev->dev_name), (char const   */* __restrict  */)(sysfs_dev->sysfs_name));
#line 395
  strcpy((char */* __restrict  */)(dev->dev_path), (char const   */* __restrict  */)(sysfs_dev->sysfs_path));
#line 396
  strcpy((char */* __restrict  */)(dev->name), (char const   */* __restrict  */)(sysfs_dev->ibdev_name));
#line 397
  strcpy((char */* __restrict  */)(dev->ibdev_path), (char const   */* __restrict  */)(sysfs_dev->ibdev_path));
  }
#line 399
  return (dev);
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_device *try_drivers___0(struct ibv_sysfs_dev *sysfs_dev ) 
{ 
  struct ibv_driver *driver ;
  struct ibv_device *dev ;

  {
#line 407
  driver = head_driver___0;
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 407
    if (! driver) {
#line 407
      goto while_break;
    }
    {
#line 408
    dev = try_driver___0(driver, sysfs_dev);
    }
#line 409
    if (dev) {
#line 410
      return (dev);
    }
#line 407
    driver = driver->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 413
  return ((struct ibv_device *)((void *)0));
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static int check_abi_version___0(char const   *path ) 
{ 
  char value[8] ;
  int tmp ;
  long tmp___0 ;

  {
  {
#line 420
  tmp = ibv_read_sysfs_file(path, "class/infiniband_verbs/abi_version", value, sizeof(value));
  }
#line 420
  if (tmp < 0) {
#line 422
    return (38);
  }
  {
#line 425
  tmp___0 = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                   10);
#line 425
  abi_ver = (int __attribute__((__visibility__("hidden")))  )tmp___0;
  }
#line 427
  if (abi_ver < (int __attribute__((__visibility__("hidden")))  )3) {
    {
#line 429
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Fatal: kernel ABI version %d doesn\'t match library version %d.\n",
            abi_ver, 6);
    }
#line 432
    return (38);
  } else
#line 427
  if (abi_ver > (int __attribute__((__visibility__("hidden")))  )6) {
    {
#line 429
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Fatal: kernel ABI version %d doesn\'t match library version %d.\n",
            abi_ver, 6);
    }
#line 432
    return (38);
  }
#line 435
  return (0);
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void check_memlock_limit___0(void) 
{ 
  struct rlimit rlim ;
  __uid_t tmp ;
  int tmp___0 ;

  {
  {
#line 442
  tmp = geteuid();
  }
#line 442
  if (! tmp) {
#line 443
    return;
  }
  {
#line 445
  tmp___0 = getrlimit((__rlimit_resource_t )8, & rlim);
  }
#line 445
  if (tmp___0) {
    {
#line 446
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: getrlimit(RLIMIT_MEMLOCK) failed.");
    }
#line 447
    return;
  }
#line 450
  if (rlim.rlim_cur <= 32768UL) {
    {
#line 451
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: RLIMIT_MEMLOCK is %lu bytes.\n    This will severely limit memory registrations.\n",
            rlim.rlim_cur);
    }
  }
#line 454
  return;
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void add_device___0(struct ibv_device *dev , struct ibv_device ***dev_list ,
                           int *num_devices___7 , int *list_size ) 
{ 
  struct ibv_device **new_list ;
  void *tmp ;
  int tmp___0 ;

  {
#line 463
  if (*list_size <= *num_devices___7) {
#line 464
    if (*list_size) {
#line 464
      *list_size *= 2;
    } else {
#line 464
      *list_size = 1;
    }
    {
#line 465
    tmp = realloc((void *)*dev_list, (unsigned long )*list_size * sizeof(struct ibv_device *));
#line 465
    new_list = (struct ibv_device **)tmp;
    }
#line 466
    if (! new_list) {
#line 467
      return;
    }
#line 468
    *dev_list = new_list;
  }
#line 471
  tmp___0 = *num_devices___7;
#line 471
  (*num_devices___7) ++;
#line 471
  *(*dev_list + tmp___0) = dev;
#line 472
  return;
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
static int ibv_cmd_modify_srq_v3___0(struct ibv_srq *srq , struct ibv_srq_attr *srq_attr ,
                                     int srq_attr_mask , struct ibv_modify_srq *new_cmd ,
                                     size_t new_cmd_size ) 
{ 
  struct ibv_modify_srq_v3 *cmd ;
  size_t cmd_size ;
  void *tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 409
  cmd_size = (sizeof(*cmd) + new_cmd_size) - sizeof(*new_cmd);
#line 410
  tmp = __builtin_alloca(cmd_size);
#line 410
  cmd = (struct ibv_modify_srq_v3 *)tmp;
#line 411
  memcpy((void */* __restrict  */)(cmd->driver_data), (void const   */* __restrict  */)(new_cmd->driver_data),
         new_cmd_size - sizeof(*new_cmd));
  }
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 413
      cmd->command = (__u32 )33;
    } else {
#line 413
      cmd->command = (__u32 )35;
    }
#line 413
    cmd->in_words = (__u16 )(cmd_size / 4UL);
#line 413
    cmd->out_words = (__u16 )0;
#line 413
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 415
  cmd->srq_handle = srq->handle;
#line 416
  cmd->attr_mask = (__u32 )srq_attr_mask;
#line 417
  cmd->max_wr = srq_attr->max_wr;
#line 418
  cmd->srq_limit = srq_attr->srq_limit;
#line 419
  cmd->max_sge = (__u32 )0;
#line 420
  cmd->reserved = (__u32 )0;
#line 422
  tmp___1 = write((srq->context)->cmd_fd, (void const   *)cmd, cmd_size);
  }
#line 422
  if ((size_t )tmp___1 != cmd_size) {
    {
#line 423
    tmp___0 = __errno_location();
    }
#line 423
    return (*tmp___0);
  }
#line 425
  return (0);
}
}
#line 1008 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
static int ib_spec_to_kern_spec___0(struct ibv_flow_spec *ib_spec , struct ibv_kern_spec *kern_spec ) 
{ 


  {
#line 1011
  kern_spec->__annonCompField5.hdr.type = (__u32 )ib_spec->__annonCompField1.hdr.type;
  {
#line 1014
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 32U) {
#line 1014
    goto case_32;
  }
#line 1021
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 48U) {
#line 1021
    goto case_48;
  }
#line 1029
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 65U) {
#line 1029
    goto case_65;
  }
#line 1029
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 64U) {
#line 1029
    goto case_65;
  }
#line 1036
  goto switch_default;
  case_32: /* CIL Label */ 
  {
#line 1015
  kern_spec->__annonCompField5.eth.size = (__u16 )sizeof(struct ibv_kern_spec_eth );
#line 1016
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.eth.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.eth.val),
         sizeof(struct ibv_flow_eth_filter ));
#line 1018
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.eth.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.eth.mask),
         sizeof(struct ibv_flow_eth_filter ));
  }
#line 1020
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 1022
  kern_spec->__annonCompField5.ipv4.size = (__u16 )sizeof(struct ibv_kern_spec_ipv4 );
#line 1023
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.ipv4.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.ipv4.val),
         sizeof(struct ibv_flow_ipv4_filter ));
#line 1025
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.ipv4.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.ipv4.mask),
         sizeof(struct ibv_flow_ipv4_filter ));
  }
#line 1027
  goto switch_break;
  case_65: /* CIL Label */ 
  case_64: /* CIL Label */ 
  {
#line 1030
  kern_spec->__annonCompField5.tcp_udp.size = (__u16 )sizeof(struct ibv_kern_spec_tcp_udp );
#line 1031
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.tcp_udp.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.tcp_udp.val),
         sizeof(struct ibv_flow_ipv4_filter ));
#line 1033
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.tcp_udp.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.tcp_udp.mask),
         sizeof(struct ibv_flow_tcp_udp_filter ));
  }
#line 1035
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1037
  return (-22);
  switch_break: /* CIL Label */ ;
  }
#line 1039
  return (0);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  node_type_str___0[5]  = {      (char const   */* const  */)0,      (char const   */* const  */)"InfiniBand channel adapter",      (char const   */* const  */)"InfiniBand switch",      (char const   */* const  */)"InfiniBand router", 
        (char const   */* const  */)"iWARP NIC"};
#line 52 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  port_state_str___0[6]  = {      (char const   */* const  */)"no state change (NOP)",      (char const   */* const  */)"down",      (char const   */* const  */)"init",      (char const   */* const  */)"armed", 
        (char const   */* const  */)"active",      (char const   */* const  */)"active defer"};
#line 69 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  event_type_str___0[19]  = 
#line 69
  {      (char const   */* const  */)"CQ error",      (char const   */* const  */)"local work queue catastrophic error",      (char const   */* const  */)"invalid request local work queue error",      (char const   */* const  */)"local access violation work queue error", 
        (char const   */* const  */)"communication established",      (char const   */* const  */)"send queue drained",      (char const   */* const  */)"path migrated",      (char const   */* const  */)"path migration request error", 
        (char const   */* const  */)"local catastrophic error",      (char const   */* const  */)"port active",      (char const   */* const  */)"port error",      (char const   */* const  */)"LID change", 
        (char const   */* const  */)"P_Key change",      (char const   */* const  */)"SM change",      (char const   */* const  */)"SRQ catastrophic error",      (char const   */* const  */)"SRQ limit reached", 
        (char const   */* const  */)"last WQE reached",      (char const   */* const  */)"client reregistration",      (char const   */* const  */)"GID table change"};
#line 99 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  wc_status_str___0[22]  = 
#line 99
  {      (char const   */* const  */)"success",      (char const   */* const  */)"local length error",      (char const   */* const  */)"local QP operation error",      (char const   */* const  */)"local EE context operation error", 
        (char const   */* const  */)"local protection error",      (char const   */* const  */)"Work Request Flushed Error",      (char const   */* const  */)"memory management operation error",      (char const   */* const  */)"bad response error", 
        (char const   */* const  */)"local access error",      (char const   */* const  */)"remote invalid request error",      (char const   */* const  */)"remote access error",      (char const   */* const  */)"remote operation error", 
        (char const   */* const  */)"transport retry counter exceeded",      (char const   */* const  */)"RNR retry counter exceeded",      (char const   */* const  */)"local RDD violation error",      (char const   */* const  */)"remote invalid RD request", 
        (char const   */* const  */)"aborted error",      (char const   */* const  */)"invalid EE context number",      (char const   */* const  */)"invalid EE context state",      (char const   */* const  */)"fatal error", 
        (char const   */* const  */)"response timeout error",      (char const   */* const  */)"general error"};
#line 267 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
__asm__(".symver __ibv_get_device_list_1_0,ibv_get_device_list@IBVERBS_1.0");
#line 281
__asm__(".symver __ibv_free_device_list_1_0,ibv_free_device_list@IBVERBS_1.0");
#line 287
__asm__(".symver __ibv_get_device_name_1_0,ibv_get_device_name@IBVERBS_1.0");
#line 293
__asm__(".symver __ibv_get_device_guid_1_0,ibv_get_device_guid@IBVERBS_1.0");
#line 295 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int poll_cq_wrapper_1_0___0(struct ibv_cq_1_0 *cq , int num_entries , struct ibv_wc *wc ) 
{ 
  int tmp ;

  {
  {
#line 298
  tmp = (*(((cq->context)->real_context)->ops.poll_cq))(cq->real_cq, num_entries,
                                                        wc);
  }
#line 298
  return (tmp);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int req_notify_cq_wrapper_1_0___0(struct ibv_cq_1_0 *cq , int sol_only ) 
{ 
  int tmp ;

  {
  {
#line 303
  tmp = (*(((cq->context)->real_context)->ops.req_notify_cq))(cq->real_cq, sol_only);
  }
#line 303
  return (tmp);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_srq_recv_wrapper_1_0___0(struct ibv_srq_1_0 *srq , struct ibv_recv_wr_1_0 *wr ,
                                         struct ibv_recv_wr_1_0 **bad_wr ) 
{ 
  struct ibv_recv_wr_1_0 *w ;
  struct ibv_recv_wr *real_wr ;
  struct ibv_recv_wr *head_wr ;
  struct ibv_recv_wr *tail_wr ;
  struct ibv_recv_wr *real_bad_wr ;
  int ret ;
  void *tmp ;

  {
#line 310
  head_wr = (struct ibv_recv_wr *)((void *)0);
#line 310
  tail_wr = (struct ibv_recv_wr *)((void *)0);
#line 313
  w = wr;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! w) {
#line 313
      goto while_break;
    }
    {
#line 314
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 314
    real_wr = (struct ibv_recv_wr *)tmp;
#line 315
    real_wr->wr_id = w->wr_id;
#line 316
    real_wr->sg_list = w->sg_list;
#line 317
    real_wr->num_sge = w->num_sge;
#line 318
    real_wr->next = (struct ibv_recv_wr *)((void *)0);
    }
#line 319
    if (tail_wr) {
#line 320
      tail_wr->next = real_wr;
    } else {
#line 322
      head_wr = real_wr;
    }
#line 324
    tail_wr = real_wr;
#line 313
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 327
  ret = (*(((srq->context)->real_context)->ops.post_srq_recv))(srq->real_srq, head_wr,
                                                               & real_bad_wr);
  }
#line 330
  if (ret) {
#line 331
    real_wr = head_wr;
#line 331
    w = wr;
    {
#line 331
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 331
      if (! real_wr) {
#line 331
        goto while_break___0;
      }
#line 334
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 335
        *bad_wr = w;
#line 336
        goto while_break___0;
      }
#line 331
      real_wr = real_wr->next;
#line 331
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 340
  return (ret);
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_send_wrapper_1_0___0(struct ibv_qp_1_0 *qp , struct ibv_send_wr_1_0 *wr ,
                                     struct ibv_send_wr_1_0 **bad_wr ) 
{ 
  struct ibv_send_wr_1_0 *w ;
  struct ibv_send_wr *real_wr ;
  struct ibv_send_wr *head_wr ;
  struct ibv_send_wr *tail_wr ;
  struct ibv_send_wr *real_bad_wr ;
  int is_ud ;
  int ret ;
  void *tmp ;

  {
#line 347
  head_wr = (struct ibv_send_wr *)((void *)0);
#line 347
  tail_wr = (struct ibv_send_wr *)((void *)0);
#line 348
  is_ud = (unsigned int )qp->qp_type == 4U;
#line 351
  w = wr;
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! w) {
#line 351
      goto while_break;
    }
    {
#line 352
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 352
    real_wr = (struct ibv_send_wr *)tmp;
#line 353
    real_wr->wr_id = w->wr_id;
#line 354
    real_wr->next = (struct ibv_send_wr *)((void *)0);
    }
#line 363
    if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->sg_list)) {
      {
#line 364
      memcpy((void */* __restrict  */)(& real_wr->sg_list), (void const   */* __restrict  */)(& w->sg_list),
             sizeof(*real_wr) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list));
      }
    } else
#line 366
    if ((unsigned long )(& ((struct ibv_send_wr *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list) == (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->sg_list)) {
#line 366
      if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->wr) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->wr)) {
        {
#line 371
        memcpy((void */* __restrict  */)(& real_wr->sg_list), (void const   */* __restrict  */)(& w->sg_list),
               ((unsigned long )(& ((struct ibv_send_wr *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list)) + sizeof(real_wr->imm_data));
#line 375
        memcpy((void */* __restrict  */)(& real_wr->wr), (void const   */* __restrict  */)(& w->wr),
               sizeof(real_wr->wr));
        }
      } else {
#line 366
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 377
      real_wr->sg_list = w->sg_list;
#line 378
      real_wr->num_sge = w->num_sge;
#line 379
      real_wr->opcode = w->opcode;
#line 380
      real_wr->send_flags = w->send_flags;
#line 381
      real_wr->imm_data = w->imm_data;
#line 382
      if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->wr) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->wr)) {
        {
#line 383
        memcpy((void */* __restrict  */)(& real_wr->wr), (void const   */* __restrict  */)(& w->wr),
               sizeof(real_wr->wr));
        }
      } else {
#line 386
        real_wr->wr.atomic.remote_addr = w->wr.atomic.remote_addr;
#line 388
        real_wr->wr.atomic.compare_add = w->wr.atomic.compare_add;
#line 390
        real_wr->wr.atomic.swap = w->wr.atomic.swap;
#line 392
        real_wr->wr.atomic.rkey = w->wr.atomic.rkey;
      }
    }
#line 397
    if (is_ud) {
#line 398
      real_wr->wr.ud.ah = (w->wr.ud.ah)->real_ah;
    }
#line 400
    if (tail_wr) {
#line 401
      tail_wr->next = real_wr;
    } else {
#line 403
      head_wr = real_wr;
    }
#line 405
    tail_wr = real_wr;
#line 351
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 408
  ret = (*(((qp->context)->real_context)->ops.post_send))(qp->real_qp, head_wr, & real_bad_wr);
  }
#line 411
  if (ret) {
#line 412
    real_wr = head_wr;
#line 412
    w = wr;
    {
#line 412
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 412
      if (! real_wr) {
#line 412
        goto while_break___0;
      }
#line 415
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 416
        *bad_wr = w;
#line 417
        goto while_break___0;
      }
#line 412
      real_wr = real_wr->next;
#line 412
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 421
  return (ret);
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_recv_wrapper_1_0___0(struct ibv_qp_1_0 *qp , struct ibv_recv_wr_1_0 *wr ,
                                     struct ibv_recv_wr_1_0 **bad_wr ) 
{ 
  struct ibv_recv_wr_1_0 *w ;
  struct ibv_recv_wr *real_wr ;
  struct ibv_recv_wr *head_wr ;
  struct ibv_recv_wr *tail_wr ;
  struct ibv_recv_wr *real_bad_wr ;
  int ret ;
  void *tmp ;

  {
#line 428
  head_wr = (struct ibv_recv_wr *)((void *)0);
#line 428
  tail_wr = (struct ibv_recv_wr *)((void *)0);
#line 431
  w = wr;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! w) {
#line 431
      goto while_break;
    }
    {
#line 432
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 432
    real_wr = (struct ibv_recv_wr *)tmp;
#line 433
    real_wr->wr_id = w->wr_id;
#line 434
    real_wr->sg_list = w->sg_list;
#line 435
    real_wr->num_sge = w->num_sge;
#line 436
    real_wr->next = (struct ibv_recv_wr *)((void *)0);
    }
#line 437
    if (tail_wr) {
#line 438
      tail_wr->next = real_wr;
    } else {
#line 440
      head_wr = real_wr;
    }
#line 442
    tail_wr = real_wr;
#line 431
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 445
  ret = (*(((qp->context)->real_context)->ops.post_recv))(qp->real_qp, head_wr, & real_bad_wr);
  }
#line 448
  if (ret) {
#line 449
    real_wr = head_wr;
#line 449
    w = wr;
    {
#line 449
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 449
      if (! real_wr) {
#line 449
        goto while_break___0;
      }
#line 452
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 453
        *bad_wr = w;
#line 454
        goto while_break___0;
      }
#line 449
      real_wr = real_wr->next;
#line 449
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 458
  return (ret);
}
}
#line 487
__asm__(".symver __ibv_open_device_1_0,ibv_open_device@IBVERBS_1.0");
#line 500
__asm__(".symver __ibv_close_device_1_0,ibv_close_device@IBVERBS_1.0");
#line 538
__asm__(".symver __ibv_get_async_event_1_0,ibv_get_async_event@IBVERBS_1.0");
#line 574
__asm__(".symver __ibv_ack_async_event_1_0,ibv_ack_async_event@IBVERBS_1.0");
#line 581
__asm__(".symver __ibv_query_device_1_0,ibv_query_device@IBVERBS_1.0");
#line 588
__asm__(".symver __ibv_query_port_1_0,ibv_query_port@IBVERBS_1.0");
#line 595
__asm__(".symver __ibv_query_gid_1_0,ibv_query_gid@IBVERBS_1.0");
#line 602
__asm__(".symver __ibv_query_pkey_1_0,ibv_query_pkey@IBVERBS_1.0");
#line 624
__asm__(".symver __ibv_alloc_pd_1_0,ibv_alloc_pd@IBVERBS_1.0");
#line 637
__asm__(".symver __ibv_dealloc_pd_1_0,ibv_dealloc_pd@IBVERBS_1.0");
#line 663
__asm__(".symver __ibv_reg_mr_1_0,ibv_reg_mr@IBVERBS_1.0");
#line 676
__asm__(".symver __ibv_dereg_mr_1_0,ibv_dereg_mr@IBVERBS_1.0");
#line 706
__asm__(".symver __ibv_create_cq_1_0,ibv_create_cq@IBVERBS_1.0");
#line 712
__asm__(".symver __ibv_resize_cq_1_0,ibv_resize_cq@IBVERBS_1.0");
#line 725
__asm__(".symver __ibv_destroy_cq_1_0,ibv_destroy_cq@IBVERBS_1.0");
#line 743
__asm__(".symver __ibv_get_cq_event_1_0,ibv_get_cq_event@IBVERBS_1.0");
#line 749
__asm__(".symver __ibv_ack_cq_events_1_0,ibv_ack_cq_events@IBVERBS_1.0");
#line 776
__asm__(".symver __ibv_create_srq_1_0,ibv_create_srq@IBVERBS_1.0");
#line 784
__asm__(".symver __ibv_modify_srq_1_0,ibv_modify_srq@IBVERBS_1.0");
#line 790
__asm__(".symver __ibv_query_srq_1_0,ibv_query_srq@IBVERBS_1.0");
#line 803
__asm__(".symver __ibv_destroy_srq_1_0,ibv_destroy_srq@IBVERBS_1.0");
#line 847
__asm__(".symver __ibv_create_qp_1_0,ibv_create_qp@IBVERBS_1.0");
#line 870
__asm__(".symver __ibv_query_qp_1_0,ibv_query_qp@IBVERBS_1.0");
#line 877
__asm__(".symver __ibv_modify_qp_1_0,ibv_modify_qp@IBVERBS_1.0");
#line 890
__asm__(".symver __ibv_destroy_qp_1_0,ibv_destroy_qp@IBVERBS_1.0");
#line 914
__asm__(".symver __ibv_create_ah_1_0,ibv_create_ah@IBVERBS_1.0");
#line 927
__asm__(".symver __ibv_destroy_ah_1_0,ibv_destroy_ah@IBVERBS_1.0");
#line 933
__asm__(".symver __ibv_attach_mcast_1_0,ibv_attach_mcast@IBVERBS_1.0");
#line 939
__asm__(".symver __ibv_detach_mcast_1_0,ibv_detach_mcast@IBVERBS_1.0");
#line 47 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/sysfs.c"
static char *sysfs_path___1  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/devinfo.c"
static int verbose  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/devinfo.c"
static int null_gid(union ibv_gid *gid ) 
{ 


  {
#line 55
  return (! ((((((((int )gid->raw[8] | (int )gid->raw[9]) | (int )gid->raw[10]) | (int )gid->raw[11]) | (int )gid->raw[12]) | (int )gid->raw[13]) | (int )gid->raw[14]) | (int )gid->raw[15]));
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/devinfo.c"
static char const   *guid_str(uint64_t node_guid , char *str ) 
{ 


  {
  {
#line 61
  node_guid = htonll(node_guid);
#line 62
  sprintf((char */* __restrict  */)str, (char const   */* __restrict  */)"%04x:%04x:%04x:%04x",
          (unsigned int )(node_guid >> 48) & 65535U, (unsigned int )(node_guid >> 32) & 65535U,
          (unsigned int )(node_guid >> 16) & 65535U, (unsigned int )node_guid & 65535U);
  }
#line 67
  return ((char const   *)str);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/devinfo.c"
static char const   *transport_str(enum ibv_transport_type transport ) 
{ 


  {
  {
#line 73
  if ((int )transport == 0) {
#line 73
    goto case_0;
  }
#line 74
  if ((int )transport == 1) {
#line 74
    goto case_1;
  }
#line 75
  goto switch_default;
  case_0: /* CIL Label */ 
#line 73
  return ("InfiniBand");
  case_1: /* CIL Label */ 
#line 74
  return ("iWARP");
  switch_default: /* CIL Label */ 
#line 75
  return ("invalid transport");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/devinfo.c"
static char const   *port_state_str___1(enum ibv_port_state pstate ) 
{ 


  {
  {
#line 82
  if ((unsigned int )pstate == 1U) {
#line 82
    goto case_1;
  }
#line 83
  if ((unsigned int )pstate == 2U) {
#line 83
    goto case_2;
  }
#line 84
  if ((unsigned int )pstate == 3U) {
#line 84
    goto case_3;
  }
#line 85
  if ((unsigned int )pstate == 4U) {
#line 85
    goto case_4;
  }
#line 86
  goto switch_default;
  case_1: /* CIL Label */ 
#line 82
  return ("PORT_DOWN");
  case_2: /* CIL Label */ 
#line 83
  return ("PORT_INIT");
  case_3: /* CIL Label */ 
#line 84
  return ("PORT_ARMED");
  case_4: /* CIL Label */ 
#line 85
  return ("PORT_ACTIVE");
  switch_default: /* CIL Label */ 
#line 86
  return ("invalid state");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/devinfo.c"
static char const   *port_phy_state_str(uint8_t phys_state ) 
{ 


  {
  {
#line 93
  if ((int )phys_state == 1) {
#line 93
    goto case_1;
  }
#line 94
  if ((int )phys_state == 2) {
#line 94
    goto case_2;
  }
#line 95
  if ((int )phys_state == 3) {
#line 95
    goto case_3;
  }
#line 96
  if ((int )phys_state == 4) {
#line 96
    goto case_4;
  }
#line 97
  if ((int )phys_state == 5) {
#line 97
    goto case_5;
  }
#line 98
  if ((int )phys_state == 6) {
#line 98
    goto case_6;
  }
#line 99
  if ((int )phys_state == 7) {
#line 99
    goto case_7;
  }
#line 100
  goto switch_default;
  case_1: /* CIL Label */ 
#line 93
  return ("SLEEP");
  case_2: /* CIL Label */ 
#line 94
  return ("POLLING");
  case_3: /* CIL Label */ 
#line 95
  return ("DISABLED");
  case_4: /* CIL Label */ 
#line 96
  return ("PORT_CONFIGURATION TRAINNING");
  case_5: /* CIL Label */ 
#line 97
  return ("LINK_UP");
  case_6: /* CIL Label */ 
#line 98
  return ("LINK_ERROR_RECOVERY");
  case_7: /* CIL Label */ 
#line 99
  return ("PHY TEST");
  switch_default: /* CIL Label */ 
#line 100
  return ("invalid physical state");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/devinfo.c"
static char const   *atomic_cap_str(enum ibv_atomic_cap atom_cap ) 
{ 


  {
  {
#line 107
  if ((unsigned int )atom_cap == 0U) {
#line 107
    goto case_0;
  }
#line 108
  if ((unsigned int )atom_cap == 1U) {
#line 108
    goto case_1;
  }
#line 109
  if ((unsigned int )atom_cap == 2U) {
#line 109
    goto case_2;
  }
#line 110
  goto switch_default;
  case_0: /* CIL Label */ 
#line 107
  return ("ATOMIC_NONE");
  case_1: /* CIL Label */ 
#line 108
  return ("ATOMIC_HCA");
  case_2: /* CIL Label */ 
#line 109
  return ("ATOMIC_GLOB");
  switch_default: /* CIL Label */ 
#line 110
  return ("invalid atomic capability");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/devinfo.c"
static char const   *mtu_str(enum ibv_mtu max_mtu ) 
{ 


  {
  {
#line 117
  if ((unsigned int )max_mtu == 1U) {
#line 117
    goto case_1;
  }
#line 118
  if ((unsigned int )max_mtu == 2U) {
#line 118
    goto case_2;
  }
#line 119
  if ((unsigned int )max_mtu == 3U) {
#line 119
    goto case_3;
  }
#line 120
  if ((unsigned int )max_mtu == 4U) {
#line 120
    goto case_4;
  }
#line 121
  if ((unsigned int )max_mtu == 5U) {
#line 121
    goto case_5;
  }
#line 122
  goto switch_default;
  case_1: /* CIL Label */ 
#line 117
  return ("256");
  case_2: /* CIL Label */ 
#line 118
  return ("512");
  case_3: /* CIL Label */ 
#line 119
  return ("1024");
  case_4: /* CIL Label */ 
#line 120
  return ("2048");
  case_5: /* CIL Label */ 
#line 121
  return ("4096");
  switch_default: /* CIL Label */ 
#line 122
  return ("invalid MTU");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/devinfo.c"
static char const   *width_str(uint8_t width ) 
{ 


  {
  {
#line 129
  if ((int )width == 1) {
#line 129
    goto case_1;
  }
#line 130
  if ((int )width == 2) {
#line 130
    goto case_2;
  }
#line 131
  if ((int )width == 4) {
#line 131
    goto case_4;
  }
#line 132
  if ((int )width == 8) {
#line 132
    goto case_8;
  }
#line 133
  goto switch_default;
  case_1: /* CIL Label */ 
#line 129
  return ("1");
  case_2: /* CIL Label */ 
#line 130
  return ("4");
  case_4: /* CIL Label */ 
#line 131
  return ("8");
  case_8: /* CIL Label */ 
#line 132
  return ("12");
  switch_default: /* CIL Label */ 
#line 133
  return ("invalid width");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/devinfo.c"
static char const   *speed_str(uint8_t speed ) 
{ 


  {
  {
#line 140
  if ((int )speed == 1) {
#line 140
    goto case_1;
  }
#line 141
  if ((int )speed == 2) {
#line 141
    goto case_2;
  }
#line 144
  if ((int )speed == 8) {
#line 144
    goto case_8;
  }
#line 144
  if ((int )speed == 4) {
#line 144
    goto case_8;
  }
#line 146
  if ((int )speed == 16) {
#line 146
    goto case_16;
  }
#line 147
  if ((int )speed == 32) {
#line 147
    goto case_32;
  }
#line 148
  goto switch_default;
  case_1: /* CIL Label */ 
#line 140
  return ("2.5 Gbps");
  case_2: /* CIL Label */ 
#line 141
  return ("5.0 Gbps");
  case_8: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 144
  return ("10.0 Gbps");
  case_16: /* CIL Label */ 
#line 146
  return ("14.0 Gbps");
  case_32: /* CIL Label */ 
#line 147
  return ("25.0 Gbps");
  switch_default: /* CIL Label */ 
#line 148
  return ("invalid speed");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/devinfo.c"
static char const   *vl_str(uint8_t vl_num ) 
{ 


  {
  {
#line 155
  if ((int )vl_num == 1) {
#line 155
    goto case_1;
  }
#line 156
  if ((int )vl_num == 2) {
#line 156
    goto case_2;
  }
#line 157
  if ((int )vl_num == 3) {
#line 157
    goto case_3;
  }
#line 158
  if ((int )vl_num == 4) {
#line 158
    goto case_4;
  }
#line 159
  if ((int )vl_num == 5) {
#line 159
    goto case_5;
  }
#line 160
  goto switch_default;
  case_1: /* CIL Label */ 
#line 155
  return ("1");
  case_2: /* CIL Label */ 
#line 156
  return ("2");
  case_3: /* CIL Label */ 
#line 157
  return ("4");
  case_4: /* CIL Label */ 
#line 158
  return ("8");
  case_5: /* CIL Label */ 
#line 159
  return ("15");
  switch_default: /* CIL Label */ 
#line 160
  return ("invalid value");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/devinfo.c"
static int print_all_port_gids(struct ibv_context *ctx , uint8_t port_num , int tbl_len ) 
{ 
  union ibv_gid gid ;
  int rc ;
  int i ;
  int tmp ;

  {
#line 167
  rc = 0;
#line 170
  i = 0;
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! (i < tbl_len)) {
#line 170
      goto while_break;
    }
    {
#line 171
    rc = ibv_query_gid(ctx, port_num, i, & gid);
    }
#line 172
    if (rc) {
      {
#line 173
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to query gid to port %d, index %d\n",
              (int )port_num, i);
      }
#line 175
      return (rc);
    }
    {
#line 177
    tmp = null_gid(& gid);
    }
#line 177
    if (! tmp) {
      {
#line 178
      printf((char const   */* __restrict  */)"\t\t\tGID[%3d]:\t\t%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x\n",
             i, (int )gid.raw[0], (int )gid.raw[1], (int )gid.raw[2], (int )gid.raw[3],
             (int )gid.raw[4], (int )gid.raw[5], (int )gid.raw[6], (int )gid.raw[7],
             (int )gid.raw[8], (int )gid.raw[9], (int )gid.raw[10], (int )gid.raw[11],
             (int )gid.raw[12], (int )gid.raw[13], (int )gid.raw[14], (int )gid.raw[15]);
      }
    }
#line 170
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  return (rc);
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/devinfo.c"
static char const   *link_layer_str(uint8_t link_layer ) 
{ 


  {
  {
#line 196
  if ((int )link_layer == 1) {
#line 196
    goto case_1;
  }
#line 196
  if ((int )link_layer == 0) {
#line 196
    goto case_1;
  }
#line 198
  if ((int )link_layer == 2) {
#line 198
    goto case_2;
  }
#line 200
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 197
  return ("InfiniBand");
  case_2: /* CIL Label */ 
#line 199
  return ("Ethernet");
  switch_default: /* CIL Label */ 
#line 201
  return ("Unknown");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/devinfo.c"
static int print_hca_cap(struct ibv_device *ib_dev , uint8_t ib_port ) 
{ 
  struct ibv_context *ctx ;
  struct ibv_device_attr device_attr ;
  struct ibv_port_attr port_attr ;
  int rc ;
  uint8_t port ;
  char buf[256] ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  {
#line 210
  rc = 0;
#line 214
  ctx = ibv_open_device(ib_dev);
  }
#line 215
  if (! ctx) {
    {
#line 216
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to open device\n");
#line 217
    rc = 1;
    }
#line 218
    goto cleanup;
  }
  {
#line 220
  tmp = ibv_query_device(ctx, & device_attr);
  }
#line 220
  if (tmp) {
    {
#line 221
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to query device props\n");
#line 222
    rc = 2;
    }
#line 223
    goto cleanup;
  }
#line 225
  if (ib_port) {
#line 225
    if ((int )ib_port > (int )device_attr.phys_port_cnt) {
      {
#line 226
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid port requested for device\n");
#line 228
      rc = 4;
      }
#line 229
      goto cleanup;
    }
  }
  {
#line 232
  tmp___0 = ibv_get_device_name(ib_dev);
#line 232
  printf((char const   */* __restrict  */)"hca_id:\t%s\n", tmp___0);
#line 233
  tmp___1 = transport_str(ib_dev->transport_type);
#line 233
  printf((char const   */* __restrict  */)"\ttransport:\t\t\t%s (%d)\n", tmp___1,
         (int )ib_dev->transport_type);
#line 235
  tmp___2 = strlen((char const   *)(device_attr.fw_ver));
  }
#line 235
  if (tmp___2) {
    {
#line 236
    printf((char const   */* __restrict  */)"\tfw_ver:\t\t\t\t%s\n", device_attr.fw_ver);
    }
  }
  {
#line 237
  tmp___3 = guid_str(device_attr.node_guid, buf);
#line 237
  printf((char const   */* __restrict  */)"\tnode_guid:\t\t\t%s\n", tmp___3);
#line 238
  tmp___4 = guid_str(device_attr.sys_image_guid, buf);
#line 238
  printf((char const   */* __restrict  */)"\tsys_image_guid:\t\t\t%s\n", tmp___4);
#line 239
  printf((char const   */* __restrict  */)"\tvendor_id:\t\t\t0x%04x\n", device_attr.vendor_id);
#line 240
  printf((char const   */* __restrict  */)"\tvendor_part_id:\t\t\t%d\n", device_attr.vendor_part_id);
#line 241
  printf((char const   */* __restrict  */)"\thw_ver:\t\t\t\t0x%X\n", device_attr.hw_ver);
#line 243
  tmp___5 = ibv_read_sysfs_file((char const   *)(ib_dev->ibdev_path), "board_id",
                                buf, sizeof(buf));
  }
#line 243
  if (tmp___5 > 0) {
    {
#line 244
    printf((char const   */* __restrict  */)"\tboard_id:\t\t\t%s\n", buf);
    }
  }
  {
#line 246
  printf((char const   */* __restrict  */)"\tphys_port_cnt:\t\t\t%d\n", (int )device_attr.phys_port_cnt);
  }
#line 248
  if (verbose) {
    {
#line 249
    printf((char const   */* __restrict  */)"\tmax_mr_size:\t\t\t0x%llx\n", (unsigned long long )device_attr.max_mr_size);
#line 251
    printf((char const   */* __restrict  */)"\tpage_size_cap:\t\t\t0x%llx\n", (unsigned long long )device_attr.page_size_cap);
#line 253
    printf((char const   */* __restrict  */)"\tmax_qp:\t\t\t\t%d\n", device_attr.max_qp);
#line 254
    printf((char const   */* __restrict  */)"\tmax_qp_wr:\t\t\t%d\n", device_attr.max_qp_wr);
#line 255
    printf((char const   */* __restrict  */)"\tdevice_cap_flags:\t\t0x%08x\n", device_attr.device_cap_flags);
#line 256
    printf((char const   */* __restrict  */)"\tmax_sge:\t\t\t%d\n", device_attr.max_sge);
#line 257
    printf((char const   */* __restrict  */)"\tmax_sge_rd:\t\t\t%d\n", device_attr.max_sge_rd);
#line 258
    printf((char const   */* __restrict  */)"\tmax_cq:\t\t\t\t%d\n", device_attr.max_cq);
#line 259
    printf((char const   */* __restrict  */)"\tmax_cqe:\t\t\t%d\n", device_attr.max_cqe);
#line 260
    printf((char const   */* __restrict  */)"\tmax_mr:\t\t\t\t%d\n", device_attr.max_mr);
#line 261
    printf((char const   */* __restrict  */)"\tmax_pd:\t\t\t\t%d\n", device_attr.max_pd);
#line 262
    printf((char const   */* __restrict  */)"\tmax_qp_rd_atom:\t\t\t%d\n", device_attr.max_qp_rd_atom);
#line 263
    printf((char const   */* __restrict  */)"\tmax_ee_rd_atom:\t\t\t%d\n", device_attr.max_ee_rd_atom);
#line 264
    printf((char const   */* __restrict  */)"\tmax_res_rd_atom:\t\t%d\n", device_attr.max_res_rd_atom);
#line 265
    printf((char const   */* __restrict  */)"\tmax_qp_init_rd_atom:\t\t%d\n", device_attr.max_qp_init_rd_atom);
#line 266
    printf((char const   */* __restrict  */)"\tmax_ee_init_rd_atom:\t\t%d\n", device_attr.max_ee_init_rd_atom);
#line 267
    tmp___6 = atomic_cap_str(device_attr.atomic_cap);
#line 267
    printf((char const   */* __restrict  */)"\tatomic_cap:\t\t\t%s (%d)\n", tmp___6,
           (unsigned int )device_attr.atomic_cap);
#line 269
    printf((char const   */* __restrict  */)"\tmax_ee:\t\t\t\t%d\n", device_attr.max_ee);
#line 270
    printf((char const   */* __restrict  */)"\tmax_rdd:\t\t\t%d\n", device_attr.max_rdd);
#line 271
    printf((char const   */* __restrict  */)"\tmax_mw:\t\t\t\t%d\n", device_attr.max_mw);
#line 272
    printf((char const   */* __restrict  */)"\tmax_raw_ipv6_qp:\t\t%d\n", device_attr.max_raw_ipv6_qp);
#line 273
    printf((char const   */* __restrict  */)"\tmax_raw_ethy_qp:\t\t%d\n", device_attr.max_raw_ethy_qp);
#line 274
    printf((char const   */* __restrict  */)"\tmax_mcast_grp:\t\t\t%d\n", device_attr.max_mcast_grp);
#line 275
    printf((char const   */* __restrict  */)"\tmax_mcast_qp_attach:\t\t%d\n", device_attr.max_mcast_qp_attach);
#line 276
    printf((char const   */* __restrict  */)"\tmax_total_mcast_qp_attach:\t%d\n",
           device_attr.max_total_mcast_qp_attach);
#line 278
    printf((char const   */* __restrict  */)"\tmax_ah:\t\t\t\t%d\n", device_attr.max_ah);
#line 279
    printf((char const   */* __restrict  */)"\tmax_fmr:\t\t\t%d\n", device_attr.max_fmr);
    }
#line 280
    if (device_attr.max_fmr) {
      {
#line 281
      printf((char const   */* __restrict  */)"\tmax_map_per_fmr:\t\t%d\n", device_attr.max_map_per_fmr);
      }
    }
    {
#line 282
    printf((char const   */* __restrict  */)"\tmax_srq:\t\t\t%d\n", device_attr.max_srq);
    }
#line 283
    if (device_attr.max_srq) {
      {
#line 284
      printf((char const   */* __restrict  */)"\tmax_srq_wr:\t\t\t%d\n", device_attr.max_srq_wr);
#line 285
      printf((char const   */* __restrict  */)"\tmax_srq_sge:\t\t\t%d\n", device_attr.max_srq_sge);
      }
    }
    {
#line 287
    printf((char const   */* __restrict  */)"\tmax_pkeys:\t\t\t%d\n", (int )device_attr.max_pkeys);
#line 288
    printf((char const   */* __restrict  */)"\tlocal_ca_ack_delay:\t\t%d\n", (int )device_attr.local_ca_ack_delay);
    }
  }
#line 291
  port = (uint8_t )1;
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    if (! ((int )port <= (int )device_attr.phys_port_cnt)) {
#line 291
      goto while_break;
    }
#line 293
    if (ib_port) {
#line 293
      if ((int )port != (int )ib_port) {
#line 294
        goto __Cont;
      }
    }
    {
#line 296
    rc = ___ibv_query_port(ctx, port, & port_attr);
    }
#line 297
    if (rc) {
      {
#line 298
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to query port %u props\n",
              (int )port);
      }
#line 299
      goto cleanup;
    }
    {
#line 301
    printf((char const   */* __restrict  */)"\t\tport:\t%d\n", (int )port);
#line 302
    tmp___7 = port_state_str___1(port_attr.state);
#line 302
    printf((char const   */* __restrict  */)"\t\t\tstate:\t\t\t%s (%d)\n", tmp___7,
           (unsigned int )port_attr.state);
#line 304
    tmp___8 = mtu_str(port_attr.max_mtu);
#line 304
    printf((char const   */* __restrict  */)"\t\t\tmax_mtu:\t\t%s (%d)\n", tmp___8,
           (unsigned int )port_attr.max_mtu);
#line 306
    tmp___9 = mtu_str(port_attr.active_mtu);
#line 306
    printf((char const   */* __restrict  */)"\t\t\tactive_mtu:\t\t%s (%d)\n", tmp___9,
           (unsigned int )port_attr.active_mtu);
#line 308
    printf((char const   */* __restrict  */)"\t\t\tsm_lid:\t\t\t%d\n", (int )port_attr.sm_lid);
#line 309
    printf((char const   */* __restrict  */)"\t\t\tport_lid:\t\t%d\n", (int )port_attr.lid);
#line 310
    printf((char const   */* __restrict  */)"\t\t\tport_lmc:\t\t0x%02x\n", (int )port_attr.lmc);
#line 311
    tmp___10 = link_layer_str(port_attr.link_layer);
#line 311
    printf((char const   */* __restrict  */)"\t\t\tlink_layer:\t\t%s\n", tmp___10);
    }
#line 314
    if (verbose) {
      {
#line 315
      printf((char const   */* __restrict  */)"\t\t\tmax_msg_sz:\t\t0x%x\n", port_attr.max_msg_sz);
#line 316
      printf((char const   */* __restrict  */)"\t\t\tport_cap_flags:\t\t0x%08x\n",
             port_attr.port_cap_flags);
#line 317
      tmp___11 = vl_str(port_attr.max_vl_num);
#line 317
      printf((char const   */* __restrict  */)"\t\t\tmax_vl_num:\t\t%s (%d)\n", tmp___11,
             (int )port_attr.max_vl_num);
#line 319
      printf((char const   */* __restrict  */)"\t\t\tbad_pkey_cntr:\t\t0x%x\n", port_attr.bad_pkey_cntr);
#line 320
      printf((char const   */* __restrict  */)"\t\t\tqkey_viol_cntr:\t\t0x%x\n", port_attr.qkey_viol_cntr);
#line 321
      printf((char const   */* __restrict  */)"\t\t\tsm_sl:\t\t\t%d\n", (int )port_attr.sm_sl);
#line 322
      printf((char const   */* __restrict  */)"\t\t\tpkey_tbl_len:\t\t%d\n", (int )port_attr.pkey_tbl_len);
#line 323
      printf((char const   */* __restrict  */)"\t\t\tgid_tbl_len:\t\t%d\n", port_attr.gid_tbl_len);
#line 324
      printf((char const   */* __restrict  */)"\t\t\tsubnet_timeout:\t\t%d\n", (int )port_attr.subnet_timeout);
#line 325
      printf((char const   */* __restrict  */)"\t\t\tinit_type_reply:\t%d\n", (int )port_attr.init_type_reply);
#line 326
      tmp___12 = width_str(port_attr.active_width);
#line 326
      printf((char const   */* __restrict  */)"\t\t\tactive_width:\t\t%sX (%d)\n",
             tmp___12, (int )port_attr.active_width);
#line 328
      tmp___13 = speed_str(port_attr.active_speed);
#line 328
      printf((char const   */* __restrict  */)"\t\t\tactive_speed:\t\t%s (%d)\n",
             tmp___13, (int )port_attr.active_speed);
      }
#line 330
      if ((int )ib_dev->transport_type == 0) {
        {
#line 331
        tmp___14 = port_phy_state_str(port_attr.phys_state);
#line 331
        printf((char const   */* __restrict  */)"\t\t\tphys_state:\t\t%s (%d)\n",
               tmp___14, (int )port_attr.phys_state);
        }
      }
      {
#line 334
      tmp___15 = print_all_port_gids(ctx, port, port_attr.gid_tbl_len);
      }
#line 334
      if (tmp___15) {
#line 335
        goto cleanup;
      }
    }
    {
#line 337
    printf((char const   */* __restrict  */)"\n");
    }
    __Cont: /* CIL Label */ 
#line 291
    port = (uint8_t )((int )port + 1);
  }
  while_break: /* CIL Label */ ;
  }
  cleanup: 
#line 340
  if (ctx) {
    {
#line 341
    tmp___16 = ibv_close_device(ctx);
    }
#line 341
    if (tmp___16) {
      {
#line 342
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to close device");
#line 343
      rc = 3;
      }
    }
  }
#line 345
  return (rc);
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/devinfo.c"
static void usage___1(char const   *argv0 ) 
{ 


  {
  {
#line 350
  printf((char const   */* __restrict  */)"Usage: %s             print the ca attributes\n",
         argv0);
#line 351
  printf((char const   */* __restrict  */)"\n");
#line 352
  printf((char const   */* __restrict  */)"Options:\n");
#line 353
  printf((char const   */* __restrict  */)"  -d, --ib-dev=<dev>     use IB device <dev> (default first device found)\n");
#line 354
  printf((char const   */* __restrict  */)"  -i, --ib-port=<port>   use port <port> of IB device (default all ports)\n");
#line 355
  printf((char const   */* __restrict  */)"  -l, --list             print only the IB devices names\n");
#line 356
  printf((char const   */* __restrict  */)"  -v, --verbose          print all the attributes of the IB device(s)\n");
  }
#line 357
  return;
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/devinfo.c"
static struct option long_options___1[5]  = {      {"ib-dev", 1, (int *)0, 'd'}, 
        {"ib-port", 1, (int *)0, 'i'}, 
        {"list", 0, (int *)0, 'l'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 37 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  node_type_str___1[5]  = {      (char const   */* const  */)0,      (char const   */* const  */)"InfiniBand channel adapter",      (char const   */* const  */)"InfiniBand switch",      (char const   */* const  */)"InfiniBand router", 
        (char const   */* const  */)"iWARP NIC"};
#line 52 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  port_state_str___2[6]  = {      (char const   */* const  */)"no state change (NOP)",      (char const   */* const  */)"down",      (char const   */* const  */)"init",      (char const   */* const  */)"armed", 
        (char const   */* const  */)"active",      (char const   */* const  */)"active defer"};
#line 69 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  event_type_str___1[19]  = 
#line 69
  {      (char const   */* const  */)"CQ error",      (char const   */* const  */)"local work queue catastrophic error",      (char const   */* const  */)"invalid request local work queue error",      (char const   */* const  */)"local access violation work queue error", 
        (char const   */* const  */)"communication established",      (char const   */* const  */)"send queue drained",      (char const   */* const  */)"path migrated",      (char const   */* const  */)"path migration request error", 
        (char const   */* const  */)"local catastrophic error",      (char const   */* const  */)"port active",      (char const   */* const  */)"port error",      (char const   */* const  */)"LID change", 
        (char const   */* const  */)"P_Key change",      (char const   */* const  */)"SM change",      (char const   */* const  */)"SRQ catastrophic error",      (char const   */* const  */)"SRQ limit reached", 
        (char const   */* const  */)"last WQE reached",      (char const   */* const  */)"client reregistration",      (char const   */* const  */)"GID table change"};
#line 99 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  wc_status_str___1[22]  = 
#line 99
  {      (char const   */* const  */)"success",      (char const   */* const  */)"local length error",      (char const   */* const  */)"local QP operation error",      (char const   */* const  */)"local EE context operation error", 
        (char const   */* const  */)"local protection error",      (char const   */* const  */)"Work Request Flushed Error",      (char const   */* const  */)"memory management operation error",      (char const   */* const  */)"bad response error", 
        (char const   */* const  */)"local access error",      (char const   */* const  */)"remote invalid request error",      (char const   */* const  */)"remote access error",      (char const   */* const  */)"remote operation error", 
        (char const   */* const  */)"transport retry counter exceeded",      (char const   */* const  */)"RNR retry counter exceeded",      (char const   */* const  */)"local RDD violation error",      (char const   */* const  */)"remote invalid RD request", 
        (char const   */* const  */)"aborted error",      (char const   */* const  */)"invalid EE context number",      (char const   */* const  */)"invalid EE context state",      (char const   */* const  */)"fatal error", 
        (char const   */* const  */)"response timeout error",      (char const   */* const  */)"general error"};
#line 132 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
__asm__(".symver __ibv_query_device,ibv_query_device@@IBVERBS_1.1");
#line 139
__asm__(".symver __ibv_query_port,ibv_query_port@@IBVERBS_1.1");
#line 164
__asm__(".symver __ibv_query_gid,ibv_query_gid@@IBVERBS_1.1");
#line 185
__asm__(".symver __ibv_query_pkey,ibv_query_pkey@@IBVERBS_1.1");
#line 197
__asm__(".symver __ibv_alloc_pd,ibv_alloc_pd@@IBVERBS_1.1");
#line 203
__asm__(".symver __ibv_dealloc_pd,ibv_dealloc_pd@@IBVERBS_1.1");
#line 224
__asm__(".symver __ibv_reg_mr,ibv_reg_mr@@IBVERBS_1.1");
#line 238
__asm__(".symver __ibv_dereg_mr,ibv_dereg_mr@@IBVERBS_1.1");
#line 243 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int warned___1  ;
#line 240 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static struct ibv_comp_channel *ibv_create_comp_channel_v2___1(struct ibv_context *context ) 
{ 
  struct ibv_abi_compat_v2 *t ;
  int tmp ;

  {
  {
#line 242
  t = (struct ibv_abi_compat_v2 *)context->abi_compat;
#line 245
  tmp = pthread_mutex_trylock(& t->in_use);
  }
#line 245
  if (! tmp) {
#line 246
    return (& t->channel);
  }
#line 248
  if (! warned___1) {
    {
#line 249
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: kernel\'s ABI version %d limits capacity.\n    Only one completion channel can be created per context.\n",
            abi_ver);
#line 252
    warned___1 ++;
    }
  }
#line 255
  return ((struct ibv_comp_channel *)((void *)0));
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int ibv_destroy_comp_channel_v2___1(struct ibv_comp_channel *channel ) 
{ 
  struct ibv_abi_compat_v2 *t ;

  {
  {
#line 288
  t = (struct ibv_abi_compat_v2 *)channel;
#line 289
  pthread_mutex_unlock(& t->in_use);
  }
#line 290
  return (0);
}
}
#line 346
__asm__(".symver __ibv_create_cq,ibv_create_cq@@IBVERBS_1.1");
#line 355
__asm__(".symver __ibv_resize_cq,ibv_resize_cq@@IBVERBS_1.1");
#line 375
__asm__(".symver __ibv_destroy_cq,ibv_destroy_cq@@IBVERBS_1.1");
#line 393
__asm__(".symver __ibv_get_cq_event,ibv_get_cq_event@@IBVERBS_1.1");
#line 402
__asm__(".symver __ibv_ack_cq_events,ibv_ack_cq_events@@IBVERBS_1.1");
#line 424
__asm__(".symver __ibv_create_srq,ibv_create_srq@@IBVERBS_1.1");
#line 432
__asm__(".symver __ibv_modify_srq,ibv_modify_srq@@IBVERBS_1.1");
#line 438
__asm__(".symver __ibv_query_srq,ibv_query_srq@@IBVERBS_1.1");
#line 444
__asm__(".symver __ibv_destroy_srq,ibv_destroy_srq@@IBVERBS_1.1");
#line 467
__asm__(".symver __ibv_create_qp,ibv_create_qp@@IBVERBS_1.1");
#line 484
__asm__(".symver __ibv_query_qp,ibv_query_qp@@IBVERBS_1.1");
#line 500
__asm__(".symver __ibv_modify_qp,ibv_modify_qp@@IBVERBS_1.1");
#line 506
__asm__(".symver __ibv_destroy_qp,ibv_destroy_qp@@IBVERBS_1.1");
#line 519
__asm__(".symver __ibv_create_ah,ibv_create_ah@@IBVERBS_1.1");
#line 521 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int ibv_find_gid_index___1(struct ibv_context *context , uint8_t port_num ,
                                  union ibv_gid *gid ) 
{ 
  union ibv_gid sgid ;
  int i ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 525
  i = 0;
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 528
    tmp = i;
#line 528
    i ++;
#line 528
    ret = ibv_query_gid(context, port_num, tmp, & sgid);
    }
#line 527
    if (! ret) {
      {
#line 527
      tmp___0 = memcmp((void const   *)(& sgid), (void const   *)gid, sizeof(*gid));
      }
#line 527
      if (! tmp___0) {
#line 527
        goto while_break;
      }
    } else {
#line 527
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 531
  if (ret) {
#line 531
    tmp___1 = ret;
  } else {
#line 531
    tmp___1 = i - 1;
  }
#line 531
  return (tmp___1);
}
}
#line 581
__asm__(".symver __ibv_destroy_ah,ibv_destroy_ah@@IBVERBS_1.1");
#line 587
__asm__(".symver __ibv_attach_mcast,ibv_attach_mcast@@IBVERBS_1.1");
#line 593
__asm__(".symver __ibv_detach_mcast,ibv_detach_mcast@@IBVERBS_1.1");
#line 77 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_sysfs_dev *sysfs_dev_list___1  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver_name *driver_name_list___1  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver *head_driver___1  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver *tail_driver___1  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static int find_sysfs_devs___1(void) 
{ 
  char class_path[256] ;
  DIR *class_dir ;
  struct dirent *dent ;
  struct ibv_sysfs_dev *sysfs_dev ;
  char value[8] ;
  int ret ;
  char const   *tmp ;
  struct stat buf ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;

  {
  {
#line 86
  sysfs_dev = (struct ibv_sysfs_dev *)((void *)0);
#line 88
  ret = 0;
#line 90
  tmp = ibv_get_sysfs_path();
#line 90
  snprintf((char */* __restrict  */)(class_path), sizeof(class_path), (char const   */* __restrict  */)"%s/class/infiniband_verbs",
           tmp);
#line 93
  class_dir = opendir((char const   *)(class_path));
  }
#line 94
  if (! class_dir) {
#line 95
    return (38);
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    dent = readdir(class_dir);
    }
#line 97
    if (! dent) {
#line 97
      goto while_break;
    }
#line 100
    if ((int )dent->d_name[0] == 46) {
#line 101
      goto while_continue;
    }
#line 103
    if (! sysfs_dev) {
      {
#line 104
      tmp___0 = malloc(sizeof(*sysfs_dev));
#line 104
      sysfs_dev = (struct ibv_sysfs_dev *)tmp___0;
      }
    }
#line 105
    if (! sysfs_dev) {
#line 106
      ret = 12;
#line 107
      goto out;
    }
    {
#line 110
    snprintf((char */* __restrict  */)(sysfs_dev->sysfs_path), sizeof(sysfs_dev->sysfs_path),
             (char const   */* __restrict  */)"%s/%s", class_path, dent->d_name);
#line 113
    tmp___1 = stat((char const   */* __restrict  */)(sysfs_dev->sysfs_path), (struct stat */* __restrict  */)(& buf));
    }
#line 113
    if (tmp___1) {
      {
#line 114
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t stat \'%s\'.\n",
              sysfs_dev->sysfs_path);
      }
#line 116
      goto while_continue;
    }
#line 119
    if (! ((buf.st_mode & 61440U) == 16384U)) {
#line 120
      goto while_continue;
    }
    {
#line 122
    snprintf((char */* __restrict  */)(sysfs_dev->sysfs_name), sizeof(sysfs_dev->sysfs_name),
             (char const   */* __restrict  */)"%s", dent->d_name);
#line 125
    tmp___2 = ibv_read_sysfs_file((char const   *)(sysfs_dev->sysfs_path), "ibdev",
                                  sysfs_dev->ibdev_name, sizeof(sysfs_dev->ibdev_name));
    }
#line 125
    if (tmp___2 < 0) {
      {
#line 128
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: no ibdev class attr for \'%s\'.\n",
              dent->d_name);
      }
#line 130
      goto while_continue;
    }
    {
#line 133
    tmp___3 = ibv_get_sysfs_path();
#line 133
    snprintf((char */* __restrict  */)(sysfs_dev->ibdev_path), sizeof(sysfs_dev->ibdev_path),
             (char const   */* __restrict  */)"%s/class/infiniband/%s", tmp___3, sysfs_dev->ibdev_name);
#line 137
    sysfs_dev->next = sysfs_dev_list___1;
#line 138
    sysfs_dev->have_driver = 0;
#line 139
    tmp___5 = ibv_read_sysfs_file((char const   *)(sysfs_dev->sysfs_path), "abi_version",
                                  value, sizeof(value));
    }
#line 139
    if (tmp___5 > 0) {
      {
#line 141
      tmp___4 = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                       10);
#line 141
      sysfs_dev->abi_ver = (int )tmp___4;
      }
    } else {
#line 143
      sysfs_dev->abi_ver = 0;
    }
#line 145
    sysfs_dev_list___1 = sysfs_dev;
#line 146
    sysfs_dev = (struct ibv_sysfs_dev *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
  out: 
#line 150
  if (sysfs_dev) {
    {
#line 151
    free((void *)sysfs_dev);
    }
  }
  {
#line 153
  closedir(class_dir);
  }
#line 154
  return (ret);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void register_driver___1(char const   *name , struct ibv_device *(*init_func)(char const   *uverbs_sys_path ,
                                                                                     int abi_version ) ,
                                struct verbs_device *(*verbs_init_func)(char const   *uverbs_sys_path ,
                                                                        int abi_version ) ) 
{ 
  struct ibv_driver *driver ;
  void *tmp ;

  {
  {
#line 162
  tmp = malloc(sizeof(*driver));
#line 162
  driver = (struct ibv_driver *)tmp;
  }
#line 163
  if (! driver) {
    {
#line 164
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver for %s\n",
            name);
    }
#line 165
    return;
  }
#line 168
  driver->name = name;
#line 169
  driver->init_func = init_func;
#line 170
  driver->verbs_init_func = verbs_init_func;
#line 171
  driver->next = (struct ibv_driver *)((void *)0);
#line 173
  if (tail_driver___1) {
#line 174
    tail_driver___1->next = driver;
  } else {
#line 176
    head_driver___1 = driver;
  }
#line 177
  tail_driver___1 = driver;
#line 178
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void load_driver___1(char const   *name ) 
{ 
  char *so_name ;
  void *dlhandle ;
  char const   *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 201
  if ((int const   )*(name + 0) == 47) {
#line 201
    tmp = "%s-rdmav2.so";
  } else {
#line 201
    tmp = "lib%s-rdmav2.so";
  }
  {
#line 201
  tmp___0 = asprintf((char **/* __restrict  */)(& so_name), (char const   */* __restrict  */)tmp,
                     name);
  }
#line 201
  if (tmp___0 < 0) {
    {
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t load driver \'%s\'.\n",
            name);
    }
#line 208
    return;
  }
  {
#line 211
  dlhandle = dlopen((char const   *)so_name, 2);
  }
#line 212
  if (! dlhandle) {
    {
#line 213
    tmp___1 = dlerror();
#line 213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t load driver \'%s\': %s\n",
            name, tmp___1);
    }
#line 215
    goto out;
  }
  out: 
  {
#line 219
  free((void *)so_name);
  }
#line 220
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void load_drivers___1(void) 
{ 
  struct ibv_driver_name *name ;
  struct ibv_driver_name *next_name ;
  char const   *env ;
  char *list ;
  char *env_name ;
  char const   *__old ;
  size_t __len ;
  size_t tmp ;
  char *__new ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *__old___0 ;
  size_t __len___0 ;
  size_t tmp___2 ;
  char *__new___0 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;

  {
  {
#line 232
  tmp___7 = getuid();
#line 232
  tmp___8 = geteuid();
  }
#line 232
  if (tmp___7 == tmp___8) {
    {
#line 233
    tmp___6 = getenv("RDMAV_DRIVERS");
#line 233
    env = (char const   *)tmp___6;
    }
#line 233
    if (env) {
      {
#line 234
      __old = env;
#line 234
      tmp = strlen(__old);
#line 234
      __len = tmp + 1UL;
#line 234
      tmp___0 = __builtin_alloca(__len);
#line 234
      __new = (char *)tmp___0;
#line 234
      tmp___1 = memcpy((void */* __restrict  */)__new, (void const   */* __restrict  */)__old,
                       __len);
#line 234
      list = (char *)tmp___1;
      }
      {
#line 235
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 235
        env_name = strsep((char **/* __restrict  */)(& list), (char const   */* __restrict  */)":;");
        }
#line 235
        if (! env_name) {
#line 235
          goto while_break;
        }
        {
#line 236
        load_driver___1((char const   *)env_name);
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 237
      tmp___5 = getenv("IBV_DRIVERS");
#line 237
      env = (char const   *)tmp___5;
      }
#line 237
      if (env) {
        {
#line 238
        __old___0 = env;
#line 238
        tmp___2 = strlen(__old___0);
#line 238
        __len___0 = tmp___2 + 1UL;
#line 238
        tmp___3 = __builtin_alloca(__len___0);
#line 238
        __new___0 = (char *)tmp___3;
#line 238
        tmp___4 = memcpy((void */* __restrict  */)__new___0, (void const   */* __restrict  */)__old___0,
                         __len___0);
#line 238
        list = (char *)tmp___4;
        }
        {
#line 239
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 239
          env_name = strsep((char **/* __restrict  */)(& list), (char const   */* __restrict  */)":;");
          }
#line 239
          if (! env_name) {
#line 239
            goto while_break___0;
          }
          {
#line 240
          load_driver___1((char const   *)env_name);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 244
  name = driver_name_list___1;
#line 244
  if (name) {
#line 244
    next_name = name->next;
  } else {
#line 244
    next_name = (struct ibv_driver_name *)((void *)0);
  }
  {
#line 244
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 244
    if (! name) {
#line 244
      goto while_break___1;
    }
    {
#line 247
    load_driver___1((char const   *)name->name);
#line 248
    free((void *)name->name);
#line 249
    free((void *)name);
#line 244
    name = next_name;
    }
#line 244
    if (name) {
#line 244
      next_name = name->next;
    } else {
#line 244
      next_name = (struct ibv_driver_name *)((void *)0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 251
  return;
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void read_config_file___1(char const   *path ) 
{ 
  FILE *conf ;
  char *line ;
  char *config ;
  char *field ;
  size_t buflen ;
  ssize_t len ;
  size_t tmp ;
  struct ibv_driver_name *driver_name ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 256
  line = (char *)((void *)0);
#line 259
  buflen = (size_t )0;
#line 262
  conf = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"re");
  }
#line 263
  if (! conf) {
    {
#line 264
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t read config file %s.\n",
            path);
    }
#line 266
    return;
  }
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 269
    len = getline((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& buflen),
                  (FILE */* __restrict  */)conf);
    }
#line 269
    if (! (len != -1L)) {
#line 269
      goto while_break;
    }
    {
#line 270
    tmp = strspn((char const   *)line, "\t ");
#line 270
    config = line + tmp;
    }
#line 271
    if ((int )*(config + 0) == 10) {
#line 272
      goto while_continue;
    } else
#line 271
    if ((int )*(config + 0) == 35) {
#line 272
      goto while_continue;
    }
    {
#line 274
    field = strsep((char **/* __restrict  */)(& config), (char const   */* __restrict  */)"\n\t ");
#line 276
    tmp___2 = strcmp((char const   *)field, "driver");
    }
#line 276
    if (tmp___2 == 0) {
#line 276
      if ((unsigned long )config != (unsigned long )((void *)0)) {
        {
#line 279
        tmp___0 = strspn((char const   *)config, "\t ");
#line 279
        config += tmp___0;
#line 280
        field = strsep((char **/* __restrict  */)(& config), (char const   */* __restrict  */)"\n\t ");
#line 282
        tmp___1 = malloc(sizeof(*driver_name));
#line 282
        driver_name = (struct ibv_driver_name *)tmp___1;
        }
#line 283
        if (! driver_name) {
          {
#line 284
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver name \'%s\'.\n",
                  field);
          }
#line 286
          goto while_continue;
        }
        {
#line 289
        driver_name->name = strdup((char const   *)field);
        }
#line 290
        if (! driver_name->name) {
          {
#line 291
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver name \'%s\'.\n",
                  field);
#line 293
          free((void *)driver_name);
          }
#line 294
          goto while_continue;
        }
#line 297
        driver_name->next = driver_name_list___1;
#line 298
        driver_name_list___1 = driver_name;
      } else {
        {
#line 300
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: ignoring bad config directive \'%s\' in file \'%s\'.\n",
                field, path);
        }
      }
    } else {
      {
#line 300
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: ignoring bad config directive \'%s\' in file \'%s\'.\n",
              field, path);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  if (line) {
    {
#line 305
    free((void *)line);
    }
  }
  {
#line 306
  fclose(conf);
  }
#line 307
  return;
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void read_config___1(void) 
{ 
  DIR *conf_dir ;
  struct dirent *dent ;
  char *path ;
  struct stat buf ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 315
  conf_dir = opendir("/usr/local/etc/libibverbs.d");
  }
#line 316
  if (! conf_dir) {
    {
#line 317
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t open config directory \'%s\'.\n",
            "/usr/local/etc/libibverbs.d");
    }
#line 319
    return;
  }
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 322
    dent = readdir(conf_dir);
    }
#line 322
    if (! dent) {
#line 322
      goto while_break;
    }
    {
#line 325
    tmp = asprintf((char **/* __restrict  */)(& path), (char const   */* __restrict  */)"%s/%s",
                   "/usr/local/etc/libibverbs.d", dent->d_name);
    }
#line 325
    if (tmp < 0) {
      {
#line 326
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t read config file %s/%s.\n",
              "/usr/local/etc/libibverbs.d", dent->d_name);
      }
#line 328
      goto out;
    }
    {
#line 331
    tmp___0 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& buf));
    }
#line 331
    if (tmp___0) {
      {
#line 332
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t stat config file \'%s\'.\n",
              path);
      }
#line 334
      goto next;
    }
#line 337
    if (! ((buf.st_mode & 61440U) == 32768U)) {
#line 338
      goto next;
    }
    {
#line 340
    read_config_file___1((char const   *)path);
    }
    next: 
    {
#line 342
    free((void *)path);
    }
  }
  while_break: /* CIL Label */ ;
  }
  out: 
  {
#line 346
  closedir(conf_dir);
  }
#line 347
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_device *try_driver___1(struct ibv_driver *driver , struct ibv_sysfs_dev *sysfs_dev ) 
{ 
  struct verbs_device *vdev ;
  struct ibv_device *dev ;
  char value[8] ;
  long tmp ;
  int tmp___0 ;

  {
#line 356
  if (driver->init_func) {
    {
#line 357
    dev = (*(driver->init_func))((char const   *)(sysfs_dev->sysfs_path), sysfs_dev->abi_ver);
    }
#line 358
    if (! dev) {
#line 359
      return ((struct ibv_device *)((void *)0));
    }
  } else {
    {
#line 361
    vdev = (*(driver->verbs_init_func))((char const   *)(sysfs_dev->sysfs_path), sysfs_dev->abi_ver);
    }
#line 362
    if (! vdev) {
#line 363
      return ((struct ibv_device *)((void *)0));
    }
#line 365
    dev = & vdev->device;
#line 366
    dev->ops.alloc_context = (struct ibv_context *(*)(struct ibv_device *device ,
                                                      int cmd_fd ))((void *)0);
#line 367
    dev->ops.free_context = (void (*)(struct ibv_context *context ))((void *)0);
  }
  {
#line 370
  tmp___0 = ibv_read_sysfs_file((char const   *)(sysfs_dev->ibdev_path), "node_type",
                                value, sizeof(value));
  }
#line 370
  if (tmp___0 < 0) {
    {
#line 371
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: no node_type attr under %s.\n",
            sysfs_dev->ibdev_path);
#line 373
    dev->node_type = (enum ibv_node_type )-1;
    }
  } else {
    {
#line 375
    tmp = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                 10);
#line 375
    dev->node_type = (enum ibv_node_type )tmp;
    }
#line 376
    if ((int )dev->node_type < 1) {
#line 377
      dev->node_type = (enum ibv_node_type )-1;
    } else
#line 376
    if ((int )dev->node_type > 4) {
#line 377
      dev->node_type = (enum ibv_node_type )-1;
    }
  }
  {
#line 383
  if ((int )dev->node_type == 3) {
#line 383
    goto case_3;
  }
#line 383
  if ((int )dev->node_type == 2) {
#line 383
    goto case_3;
  }
#line 383
  if ((int )dev->node_type == 1) {
#line 383
    goto case_3;
  }
#line 386
  if ((int )dev->node_type == 4) {
#line 386
    goto case_4;
  }
#line 389
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 384
  dev->transport_type = (enum ibv_transport_type )0;
#line 385
  goto switch_break;
  case_4: /* CIL Label */ 
#line 387
  dev->transport_type = (enum ibv_transport_type )1;
#line 388
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 390
  dev->transport_type = (enum ibv_transport_type )-1;
#line 391
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 394
  strcpy((char */* __restrict  */)(dev->dev_name), (char const   */* __restrict  */)(sysfs_dev->sysfs_name));
#line 395
  strcpy((char */* __restrict  */)(dev->dev_path), (char const   */* __restrict  */)(sysfs_dev->sysfs_path));
#line 396
  strcpy((char */* __restrict  */)(dev->name), (char const   */* __restrict  */)(sysfs_dev->ibdev_name));
#line 397
  strcpy((char */* __restrict  */)(dev->ibdev_path), (char const   */* __restrict  */)(sysfs_dev->ibdev_path));
  }
#line 399
  return (dev);
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_device *try_drivers___1(struct ibv_sysfs_dev *sysfs_dev ) 
{ 
  struct ibv_driver *driver ;
  struct ibv_device *dev ;

  {
#line 407
  driver = head_driver___1;
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 407
    if (! driver) {
#line 407
      goto while_break;
    }
    {
#line 408
    dev = try_driver___1(driver, sysfs_dev);
    }
#line 409
    if (dev) {
#line 410
      return (dev);
    }
#line 407
    driver = driver->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 413
  return ((struct ibv_device *)((void *)0));
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static int check_abi_version___1(char const   *path ) 
{ 
  char value[8] ;
  int tmp ;
  long tmp___0 ;

  {
  {
#line 420
  tmp = ibv_read_sysfs_file(path, "class/infiniband_verbs/abi_version", value, sizeof(value));
  }
#line 420
  if (tmp < 0) {
#line 422
    return (38);
  }
  {
#line 425
  tmp___0 = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                   10);
#line 425
  abi_ver = (int __attribute__((__visibility__("hidden")))  )tmp___0;
  }
#line 427
  if (abi_ver < (int __attribute__((__visibility__("hidden")))  )3) {
    {
#line 429
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Fatal: kernel ABI version %d doesn\'t match library version %d.\n",
            abi_ver, 6);
    }
#line 432
    return (38);
  } else
#line 427
  if (abi_ver > (int __attribute__((__visibility__("hidden")))  )6) {
    {
#line 429
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Fatal: kernel ABI version %d doesn\'t match library version %d.\n",
            abi_ver, 6);
    }
#line 432
    return (38);
  }
#line 435
  return (0);
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void check_memlock_limit___1(void) 
{ 
  struct rlimit rlim ;
  __uid_t tmp ;
  int tmp___0 ;

  {
  {
#line 442
  tmp = geteuid();
  }
#line 442
  if (! tmp) {
#line 443
    return;
  }
  {
#line 445
  tmp___0 = getrlimit((__rlimit_resource_t )8, & rlim);
  }
#line 445
  if (tmp___0) {
    {
#line 446
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: getrlimit(RLIMIT_MEMLOCK) failed.");
    }
#line 447
    return;
  }
#line 450
  if (rlim.rlim_cur <= 32768UL) {
    {
#line 451
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: RLIMIT_MEMLOCK is %lu bytes.\n    This will severely limit memory registrations.\n",
            rlim.rlim_cur);
    }
  }
#line 454
  return;
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void add_device___1(struct ibv_device *dev , struct ibv_device ***dev_list ,
                           int *num_devices___7 , int *list_size ) 
{ 
  struct ibv_device **new_list ;
  void *tmp ;
  int tmp___0 ;

  {
#line 463
  if (*list_size <= *num_devices___7) {
#line 464
    if (*list_size) {
#line 464
      *list_size *= 2;
    } else {
#line 464
      *list_size = 1;
    }
    {
#line 465
    tmp = realloc((void *)*dev_list, (unsigned long )*list_size * sizeof(struct ibv_device *));
#line 465
    new_list = (struct ibv_device **)tmp;
    }
#line 466
    if (! new_list) {
#line 467
      return;
    }
#line 468
    *dev_list = new_list;
  }
#line 471
  tmp___0 = *num_devices___7;
#line 471
  (*num_devices___7) ++;
#line 471
  *(*dev_list + tmp___0) = dev;
#line 472
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *mm_root___1  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static pthread_mutex_t mm_mutex___1  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 75 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int page_size___3  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int huge_page_enabled___1  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int too_late___1  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static unsigned long smaps_page_size___1(FILE *file ) 
{ 
  int n ;
  unsigned long size ;
  char buf[1024] ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 82
  size = (unsigned long )page_size___3;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 85
    tmp___0 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)file);
    }
#line 85
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 85
      goto while_break;
    }
    {
#line 86
    tmp = strstr((char const   *)(buf), "KernelPageSize:");
    }
#line 86
    if (! tmp) {
#line 87
      goto while_continue;
    }
    {
#line 89
    n = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*s %lu",
               & size);
    }
#line 90
    if (n < 1) {
#line 91
      goto while_continue;
    }
#line 94
    size *= 1024UL;
#line 96
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return (size);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static unsigned long get_page_size___1(void *base ) 
{ 
  unsigned long ret ;
  pid_t pid ;
  FILE *file ;
  char buf[1024] ;
  int n ;
  uintptr_t range_start ;
  uintptr_t range_end ;
  char *tmp ;

  {
  {
#line 104
  ret = (unsigned long )page_size___3;
#line 109
  pid = getpid();
#line 110
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"/proc/%d/smaps",
           pid);
#line 112
  file = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"re");
  }
#line 113
  if (! file) {
#line 114
    goto out;
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 116
    tmp = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)file);
    }
#line 116
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 116
      goto while_break;
    }
    {
#line 120
    n = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%lx-%lx",
               & range_start, & range_end);
    }
#line 122
    if (n < 2) {
#line 123
      goto while_continue;
    }
#line 125
    if ((uintptr_t )base >= range_start) {
#line 125
      if ((uintptr_t )base < range_end) {
        {
#line 126
        ret = smaps_page_size___1(file);
        }
#line 127
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  fclose(file);
  }
  out: 
#line 134
  return (ret);
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_prev___1(struct ibv_mem_node *node ) 
{ 


  {
#line 194
  if (node->left) {
#line 195
    node = node->left;
    {
#line 196
    while (1) {
      while_continue: /* CIL Label */ ;
#line 196
      if (! node->right) {
#line 196
        goto while_break;
      }
#line 197
      node = node->right;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 199
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 199
      if (node->parent) {
#line 199
        if (! ((unsigned long )node == (unsigned long )(node->parent)->left)) {
#line 199
          goto while_break___0;
        }
      } else {
#line 199
        goto while_break___0;
      }
#line 200
      node = node->parent;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 202
    node = node->parent;
  }
#line 205
  return (node);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_next___1(struct ibv_mem_node *node ) 
{ 


  {
#line 210
  if (node->right) {
#line 211
    node = node->right;
    {
#line 212
    while (1) {
      while_continue: /* CIL Label */ ;
#line 212
      if (! node->left) {
#line 212
        goto while_break;
      }
#line 213
      node = node->left;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 215
      if (node->parent) {
#line 215
        if (! ((unsigned long )node == (unsigned long )(node->parent)->right)) {
#line 215
          goto while_break___0;
        }
      } else {
#line 215
        goto while_break___0;
      }
#line 216
      node = node->parent;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 218
    node = node->parent;
  }
#line 221
  return (node);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_rotate_right___1(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 228
  tmp = node->left;
#line 230
  node->left = tmp->right;
#line 231
  if (node->left) {
#line 232
    (node->left)->parent = node;
  }
#line 234
  if (node->parent) {
#line 235
    if ((unsigned long )(node->parent)->right == (unsigned long )node) {
#line 236
      (node->parent)->right = tmp;
    } else {
#line 238
      (node->parent)->left = tmp;
    }
  } else {
#line 240
    mm_root___1 = tmp;
  }
#line 242
  tmp->parent = node->parent;
#line 244
  tmp->right = node;
#line 245
  node->parent = tmp;
#line 246
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_rotate_left___1(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 252
  tmp = node->right;
#line 254
  node->right = tmp->left;
#line 255
  if (node->right) {
#line 256
    (node->right)->parent = node;
  }
#line 258
  if (node->parent) {
#line 259
    if ((unsigned long )(node->parent)->right == (unsigned long )node) {
#line 260
      (node->parent)->right = tmp;
    } else {
#line 262
      (node->parent)->left = tmp;
    }
  } else {
#line 264
    mm_root___1 = tmp;
  }
#line 266
  tmp->parent = node->parent;
#line 268
  tmp->left = node;
#line 269
  node->parent = tmp;
#line 270
  return;
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_add_rebalance___1(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *parent ;
  struct ibv_mem_node *gp ;
  struct ibv_mem_node *uncle ;

  {
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (node->parent) {
#line 304
      if (! ((unsigned int )(node->parent)->color == 0U)) {
#line 304
        goto while_break;
      }
    } else {
#line 304
      goto while_break;
    }
#line 305
    parent = node->parent;
#line 306
    gp = (node->parent)->parent;
#line 308
    if ((unsigned long )parent == (unsigned long )gp->left) {
#line 309
      uncle = gp->right;
#line 311
      if (uncle) {
#line 311
        if ((unsigned int )uncle->color == 0U) {
#line 312
          parent->color = (enum __anonenum_color_68 )1;
#line 313
          uncle->color = (enum __anonenum_color_68 )1;
#line 314
          gp->color = (enum __anonenum_color_68 )0;
#line 316
          node = gp;
        } else {
#line 311
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 318
        if ((unsigned long )node == (unsigned long )parent->right) {
          {
#line 319
          __mm_rotate_left___1(parent);
#line 320
          node = parent;
#line 321
          parent = node->parent;
          }
        }
        {
#line 324
        parent->color = (enum __anonenum_color_68 )1;
#line 325
        gp->color = (enum __anonenum_color_68 )0;
#line 327
        __mm_rotate_right___1(gp);
        }
      }
    } else {
#line 330
      uncle = gp->left;
#line 332
      if (uncle) {
#line 332
        if ((unsigned int )uncle->color == 0U) {
#line 333
          parent->color = (enum __anonenum_color_68 )1;
#line 334
          uncle->color = (enum __anonenum_color_68 )1;
#line 335
          gp->color = (enum __anonenum_color_68 )0;
#line 337
          node = gp;
        } else {
#line 332
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 339
        if ((unsigned long )node == (unsigned long )parent->left) {
          {
#line 340
          __mm_rotate_right___1(parent);
#line 341
          node = parent;
#line 342
          parent = node->parent;
          }
        }
        {
#line 345
        parent->color = (enum __anonenum_color_68 )1;
#line 346
        gp->color = (enum __anonenum_color_68 )0;
#line 348
        __mm_rotate_left___1(gp);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  mm_root___1->color = (enum __anonenum_color_68 )1;
#line 354
  return;
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_add___1(struct ibv_mem_node *new ) 
{ 
  struct ibv_mem_node *node ;
  struct ibv_mem_node *parent ;

  {
#line 358
  parent = (struct ibv_mem_node *)((void *)0);
#line 360
  node = mm_root___1;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! node) {
#line 361
      goto while_break;
    }
#line 362
    parent = node;
#line 363
    if (node->start < new->start) {
#line 364
      node = node->right;
    } else {
#line 366
      node = node->left;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  if (parent->start < new->start) {
#line 370
    parent->right = new;
  } else {
#line 372
    parent->left = new;
  }
  {
#line 374
  new->parent = parent;
#line 375
  new->left = (struct ibv_mem_node *)((void *)0);
#line 376
  new->right = (struct ibv_mem_node *)((void *)0);
#line 378
  new->color = (enum __anonenum_color_68 )0;
#line 379
  __mm_add_rebalance___1(new);
  }
#line 380
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_remove___1(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *child ;
  struct ibv_mem_node *parent ;
  struct ibv_mem_node *sib ;
  struct ibv_mem_node *tmp ;
  int nodecol ;

  {
#line 387
  if (node->left) {
#line 387
    if (node->right) {
#line 388
      tmp = node->left;
      {
#line 389
      while (1) {
        while_continue: /* CIL Label */ ;
#line 389
        if (! tmp->right) {
#line 389
          goto while_break;
        }
#line 390
        tmp = tmp->right;
      }
      while_break: /* CIL Label */ ;
      }
#line 392
      nodecol = (int )tmp->color;
#line 393
      child = tmp->left;
#line 394
      tmp->color = node->color;
#line 396
      if ((unsigned long )tmp->parent != (unsigned long )node) {
#line 397
        parent = tmp->parent;
#line 398
        parent->right = tmp->left;
#line 399
        if (tmp->left) {
#line 400
          (tmp->left)->parent = parent;
        }
#line 402
        tmp->left = node->left;
#line 403
        (node->left)->parent = tmp;
      } else {
#line 405
        parent = tmp;
      }
#line 407
      tmp->right = node->right;
#line 408
      (node->right)->parent = tmp;
#line 410
      tmp->parent = node->parent;
#line 411
      if (node->parent) {
#line 412
        if ((unsigned long )(node->parent)->left == (unsigned long )node) {
#line 413
          (node->parent)->left = tmp;
        } else {
#line 415
          (node->parent)->right = tmp;
        }
      } else {
#line 417
        mm_root___1 = tmp;
      }
    } else {
#line 387
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 419
    nodecol = (int )node->color;
#line 421
    if (node->left) {
#line 421
      child = node->left;
    } else {
#line 421
      child = node->right;
    }
#line 422
    parent = node->parent;
#line 424
    if (child) {
#line 425
      child->parent = parent;
    }
#line 426
    if (parent) {
#line 427
      if ((unsigned long )parent->left == (unsigned long )node) {
#line 428
        parent->left = child;
      } else {
#line 430
        parent->right = child;
      }
    } else {
#line 432
      mm_root___1 = child;
    }
  }
  {
#line 435
  free((void *)node);
  }
#line 437
  if (nodecol == 0) {
#line 438
    return;
  }
  {
#line 440
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 440
    if (! child) {
#line 440
      goto _L___6;
    } else
#line 440
    if ((unsigned int )child->color == 1U) {
      _L___6: /* CIL Label */ 
#line 440
      if (! ((unsigned long )child != (unsigned long )mm_root___1)) {
#line 440
        goto while_break___0;
      }
    } else {
#line 440
      goto while_break___0;
    }
#line 441
    if ((unsigned long )parent->left == (unsigned long )child) {
#line 442
      sib = parent->right;
#line 444
      if ((unsigned int )sib->color == 0U) {
        {
#line 445
        parent->color = (enum __anonenum_color_68 )0;
#line 446
        sib->color = (enum __anonenum_color_68 )1;
#line 447
        __mm_rotate_left___1(parent);
#line 448
        sib = parent->right;
        }
      }
#line 451
      if (! sib->left) {
#line 451
        goto _L___2;
      } else
#line 451
      if ((unsigned int )(sib->left)->color == 1U) {
        _L___2: /* CIL Label */ 
#line 451
        if (! sib->right) {
#line 453
          sib->color = (enum __anonenum_color_68 )0;
#line 454
          child = parent;
#line 455
          parent = child->parent;
        } else
#line 451
        if ((unsigned int )(sib->right)->color == 1U) {
#line 453
          sib->color = (enum __anonenum_color_68 )0;
#line 454
          child = parent;
#line 455
          parent = child->parent;
        } else {
#line 451
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 457
        if (! sib->right) {
#line 457
          goto _L___0;
        } else
#line 457
        if ((unsigned int )(sib->right)->color == 1U) {
          _L___0: /* CIL Label */ 
#line 458
          if (sib->left) {
#line 459
            (sib->left)->color = (enum __anonenum_color_68 )1;
          }
          {
#line 460
          sib->color = (enum __anonenum_color_68 )0;
#line 461
          __mm_rotate_right___1(sib);
#line 462
          sib = parent->right;
          }
        }
#line 465
        sib->color = parent->color;
#line 466
        parent->color = (enum __anonenum_color_68 )1;
#line 467
        if (sib->right) {
#line 468
          (sib->right)->color = (enum __anonenum_color_68 )1;
        }
        {
#line 469
        __mm_rotate_left___1(parent);
#line 470
        child = mm_root___1;
        }
#line 471
        goto while_break___0;
      }
    } else {
#line 474
      sib = parent->left;
#line 476
      if ((unsigned int )sib->color == 0U) {
        {
#line 477
        parent->color = (enum __anonenum_color_68 )0;
#line 478
        sib->color = (enum __anonenum_color_68 )1;
#line 479
        __mm_rotate_right___1(parent);
#line 480
        sib = parent->left;
        }
      }
#line 483
      if (! sib->left) {
#line 483
        goto _L___5;
      } else
#line 483
      if ((unsigned int )(sib->left)->color == 1U) {
        _L___5: /* CIL Label */ 
#line 483
        if (! sib->right) {
#line 485
          sib->color = (enum __anonenum_color_68 )0;
#line 486
          child = parent;
#line 487
          parent = child->parent;
        } else
#line 483
        if ((unsigned int )(sib->right)->color == 1U) {
#line 485
          sib->color = (enum __anonenum_color_68 )0;
#line 486
          child = parent;
#line 487
          parent = child->parent;
        } else {
#line 483
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
#line 489
        if (! sib->left) {
#line 489
          goto _L___3;
        } else
#line 489
        if ((unsigned int )(sib->left)->color == 1U) {
          _L___3: /* CIL Label */ 
#line 490
          if (sib->right) {
#line 491
            (sib->right)->color = (enum __anonenum_color_68 )1;
          }
          {
#line 492
          sib->color = (enum __anonenum_color_68 )0;
#line 493
          __mm_rotate_left___1(sib);
#line 494
          sib = parent->left;
          }
        }
#line 497
        sib->color = parent->color;
#line 498
        parent->color = (enum __anonenum_color_68 )1;
#line 499
        if (sib->left) {
#line 500
          (sib->left)->color = (enum __anonenum_color_68 )1;
        }
        {
#line 501
        __mm_rotate_right___1(parent);
#line 502
        child = mm_root___1;
        }
#line 503
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 508
  if (child) {
#line 509
    child->color = (enum __anonenum_color_68 )1;
  }
#line 510
  return;
}
}
#line 512 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_find_start___1(uintptr_t start , uintptr_t end ) 
{ 
  struct ibv_mem_node *node ;

  {
#line 514
  node = mm_root___1;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! node) {
#line 516
      goto while_break;
    }
#line 517
    if (node->start <= start) {
#line 517
      if (node->end >= start) {
#line 518
        goto while_break;
      }
    }
#line 520
    if (node->start < start) {
#line 521
      node = node->right;
    } else {
#line 523
      node = node->left;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 526
  return (node);
}
}
#line 529 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *merge_ranges___1(struct ibv_mem_node *node , struct ibv_mem_node *prev ) 
{ 


  {
  {
#line 532
  prev->end = node->end;
#line 533
  prev->refcnt = node->refcnt;
#line 534
  __mm_remove___1(node);
  }
#line 536
  return (prev);
}
}
#line 539 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *split_range___1(struct ibv_mem_node *node , uintptr_t cut_line ) 
{ 
  struct ibv_mem_node *new_node ;
  void *tmp ;

  {
  {
#line 542
  new_node = (struct ibv_mem_node *)((void *)0);
#line 544
  tmp = malloc(sizeof(*new_node));
#line 544
  new_node = (struct ibv_mem_node *)tmp;
  }
#line 545
  if (! new_node) {
#line 546
    return ((struct ibv_mem_node *)((void *)0));
  }
  {
#line 547
  new_node->start = cut_line;
#line 548
  new_node->end = node->end;
#line 549
  new_node->refcnt = node->refcnt;
#line 550
  node->end = cut_line - 1UL;
#line 551
  __mm_add___1(new_node);
  }
#line 553
  return (new_node);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *get_start_node___1(uintptr_t start , uintptr_t end , int inc ) 
{ 
  struct ibv_mem_node *node ;
  struct ibv_mem_node *tmp ;

  {
  {
#line 559
  tmp = (struct ibv_mem_node *)((void *)0);
#line 561
  node = __mm_find_start___1(start, end);
  }
#line 562
  if (node->start < start) {
    {
#line 563
    node = split_range___1(node, start);
    }
  } else {
    {
#line 565
    tmp = __mm_prev___1(node);
    }
#line 566
    if (tmp) {
#line 566
      if (tmp->refcnt == node->refcnt + inc) {
        {
#line 567
        node = merge_ranges___1(node, tmp);
        }
      }
    }
  }
#line 569
  return (node);
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *undo_node___1(struct ibv_mem_node *node , uintptr_t start ,
                                          int inc ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 579
  tmp = (struct ibv_mem_node *)((void *)0);
#line 585
  if (start > node->start) {
    {
#line 586
    tmp = split_range___1(node, start);
    }
#line 587
    if (tmp) {
#line 588
      node->refcnt += inc;
#line 589
      node = tmp;
    } else {
#line 591
      return ((struct ibv_mem_node *)((void *)0));
    }
  }
  {
#line 594
  tmp = __mm_prev___1(node);
  }
#line 595
  if (tmp) {
#line 595
    if (tmp->refcnt == node->refcnt) {
      {
#line 596
      node = merge_ranges___1(node, tmp);
      }
    }
  }
  {
#line 598
  tmp = __mm_next___1(node);
  }
#line 599
  if (tmp) {
#line 599
    if (tmp->refcnt == node->refcnt) {
      {
#line 600
      node = merge_ranges___1(tmp, node);
      }
    }
  }
#line 602
  return (node);
}
}
#line 605 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int ibv_madvise_range___1(void *base , size_t size , int advice ) 
{ 
  uintptr_t start ;
  uintptr_t end ;
  struct ibv_mem_node *node ;
  struct ibv_mem_node *tmp ;
  int inc ;
  int rolling_back ;
  int ret ;
  unsigned long range_page_size ;
  struct ibv_mem_node *tmp___0 ;

  {
#line 610
  rolling_back = 0;
#line 611
  ret = 0;
#line 614
  if (! size) {
#line 615
    return (0);
  }
#line 617
  if (huge_page_enabled___1) {
    {
#line 618
    range_page_size = get_page_size___1(base);
    }
  } else {
#line 620
    range_page_size = (unsigned long )page_size___3;
  }
  {
#line 622
  start = (uintptr_t )base & ~ (range_page_size - 1UL);
#line 623
  end = ((uintptr_t )(((base + size) + range_page_size) - 1) & ~ (range_page_size - 1UL)) - 1UL;
#line 626
  pthread_mutex_lock(& mm_mutex___1);
  }
  again: 
#line 628
  if (advice == 10) {
#line 628
    inc = 1;
  } else {
#line 628
    inc = -1;
  }
  {
#line 630
  node = get_start_node___1(start, end, inc);
  }
#line 631
  if (! node) {
#line 632
    ret = -1;
#line 633
    goto out;
  }
  {
#line 636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 636
    if (node) {
#line 636
      if (! (node->start <= end)) {
#line 636
        goto while_break;
      }
    } else {
#line 636
      goto while_break;
    }
#line 637
    if (node->end > end) {
      {
#line 638
      tmp___0 = split_range___1(node, end + 1UL);
      }
#line 638
      if (! tmp___0) {
#line 639
        ret = -1;
#line 640
        goto out;
      }
    }
#line 644
    if (inc == -1) {
#line 644
      if (node->refcnt == 1) {
#line 644
        goto _L;
      } else {
#line 644
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 644
    if (inc == 1) {
#line 644
      if (node->refcnt == 0) {
        _L: /* CIL Label */ 
#line 657
        if (start > node->start) {
          {
#line 658
          ret = madvise((void *)start, (node->end - start) + 1UL, advice);
          }
        } else {
          {
#line 661
          ret = madvise((void *)node->start, (node->end - node->start) + 1UL, advice);
          }
        }
#line 664
        if (ret) {
          {
#line 665
          node = undo_node___1(node, start, inc);
          }
#line 667
          if (rolling_back) {
#line 668
            goto out;
          } else
#line 667
          if (! node) {
#line 668
            goto out;
          }
#line 671
          rolling_back = 1;
#line 672
          if (advice == 10) {
#line 672
            advice = 11;
          } else {
#line 672
            advice = 10;
          }
          {
#line 674
          tmp = __mm_prev___1(node);
          }
#line 675
          if (! tmp) {
#line 676
            goto out;
          } else
#line 675
          if (start > tmp->end) {
#line 676
            goto out;
          }
#line 677
          end = tmp->end;
#line 678
          goto again;
        }
      }
    }
    {
#line 682
    node->refcnt += inc;
#line 683
    node = __mm_next___1(node);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if (node) {
    {
#line 687
    tmp = __mm_prev___1(node);
    }
#line 688
    if (tmp) {
#line 688
      if (node->refcnt == tmp->refcnt) {
        {
#line 689
        node = merge_ranges___1(node, tmp);
        }
      }
    }
  }
  out: 
#line 693
  if (rolling_back) {
#line 694
    ret = -1;
  }
  {
#line 696
  pthread_mutex_unlock(& mm_mutex___1);
  }
#line 698
  return (ret);
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
__asm__(".symver __ibv_get_device_list_1_0,ibv_get_device_list@IBVERBS_1.0");
#line 281
__asm__(".symver __ibv_free_device_list_1_0,ibv_free_device_list@IBVERBS_1.0");
#line 287
__asm__(".symver __ibv_get_device_name_1_0,ibv_get_device_name@IBVERBS_1.0");
#line 293
__asm__(".symver __ibv_get_device_guid_1_0,ibv_get_device_guid@IBVERBS_1.0");
#line 295 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int poll_cq_wrapper_1_0___1(struct ibv_cq_1_0 *cq , int num_entries , struct ibv_wc *wc ) 
{ 
  int tmp ;

  {
  {
#line 298
  tmp = (*(((cq->context)->real_context)->ops.poll_cq))(cq->real_cq, num_entries,
                                                        wc);
  }
#line 298
  return (tmp);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int req_notify_cq_wrapper_1_0___1(struct ibv_cq_1_0 *cq , int sol_only ) 
{ 
  int tmp ;

  {
  {
#line 303
  tmp = (*(((cq->context)->real_context)->ops.req_notify_cq))(cq->real_cq, sol_only);
  }
#line 303
  return (tmp);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_srq_recv_wrapper_1_0___1(struct ibv_srq_1_0 *srq , struct ibv_recv_wr_1_0 *wr ,
                                         struct ibv_recv_wr_1_0 **bad_wr ) 
{ 
  struct ibv_recv_wr_1_0 *w ;
  struct ibv_recv_wr *real_wr ;
  struct ibv_recv_wr *head_wr ;
  struct ibv_recv_wr *tail_wr ;
  struct ibv_recv_wr *real_bad_wr ;
  int ret ;
  void *tmp ;

  {
#line 310
  head_wr = (struct ibv_recv_wr *)((void *)0);
#line 310
  tail_wr = (struct ibv_recv_wr *)((void *)0);
#line 313
  w = wr;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! w) {
#line 313
      goto while_break;
    }
    {
#line 314
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 314
    real_wr = (struct ibv_recv_wr *)tmp;
#line 315
    real_wr->wr_id = w->wr_id;
#line 316
    real_wr->sg_list = w->sg_list;
#line 317
    real_wr->num_sge = w->num_sge;
#line 318
    real_wr->next = (struct ibv_recv_wr *)((void *)0);
    }
#line 319
    if (tail_wr) {
#line 320
      tail_wr->next = real_wr;
    } else {
#line 322
      head_wr = real_wr;
    }
#line 324
    tail_wr = real_wr;
#line 313
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 327
  ret = (*(((srq->context)->real_context)->ops.post_srq_recv))(srq->real_srq, head_wr,
                                                               & real_bad_wr);
  }
#line 330
  if (ret) {
#line 331
    real_wr = head_wr;
#line 331
    w = wr;
    {
#line 331
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 331
      if (! real_wr) {
#line 331
        goto while_break___0;
      }
#line 334
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 335
        *bad_wr = w;
#line 336
        goto while_break___0;
      }
#line 331
      real_wr = real_wr->next;
#line 331
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 340
  return (ret);
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_send_wrapper_1_0___1(struct ibv_qp_1_0 *qp , struct ibv_send_wr_1_0 *wr ,
                                     struct ibv_send_wr_1_0 **bad_wr ) 
{ 
  struct ibv_send_wr_1_0 *w ;
  struct ibv_send_wr *real_wr ;
  struct ibv_send_wr *head_wr ;
  struct ibv_send_wr *tail_wr ;
  struct ibv_send_wr *real_bad_wr ;
  int is_ud ;
  int ret ;
  void *tmp ;

  {
#line 347
  head_wr = (struct ibv_send_wr *)((void *)0);
#line 347
  tail_wr = (struct ibv_send_wr *)((void *)0);
#line 348
  is_ud = (unsigned int )qp->qp_type == 4U;
#line 351
  w = wr;
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! w) {
#line 351
      goto while_break;
    }
    {
#line 352
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 352
    real_wr = (struct ibv_send_wr *)tmp;
#line 353
    real_wr->wr_id = w->wr_id;
#line 354
    real_wr->next = (struct ibv_send_wr *)((void *)0);
    }
#line 363
    if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->sg_list)) {
      {
#line 364
      memcpy((void */* __restrict  */)(& real_wr->sg_list), (void const   */* __restrict  */)(& w->sg_list),
             sizeof(*real_wr) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list));
      }
    } else
#line 366
    if ((unsigned long )(& ((struct ibv_send_wr *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list) == (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->sg_list)) {
#line 366
      if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->wr) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->wr)) {
        {
#line 371
        memcpy((void */* __restrict  */)(& real_wr->sg_list), (void const   */* __restrict  */)(& w->sg_list),
               ((unsigned long )(& ((struct ibv_send_wr *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list)) + sizeof(real_wr->imm_data));
#line 375
        memcpy((void */* __restrict  */)(& real_wr->wr), (void const   */* __restrict  */)(& w->wr),
               sizeof(real_wr->wr));
        }
      } else {
#line 366
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 377
      real_wr->sg_list = w->sg_list;
#line 378
      real_wr->num_sge = w->num_sge;
#line 379
      real_wr->opcode = w->opcode;
#line 380
      real_wr->send_flags = w->send_flags;
#line 381
      real_wr->imm_data = w->imm_data;
#line 382
      if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->wr) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->wr)) {
        {
#line 383
        memcpy((void */* __restrict  */)(& real_wr->wr), (void const   */* __restrict  */)(& w->wr),
               sizeof(real_wr->wr));
        }
      } else {
#line 386
        real_wr->wr.atomic.remote_addr = w->wr.atomic.remote_addr;
#line 388
        real_wr->wr.atomic.compare_add = w->wr.atomic.compare_add;
#line 390
        real_wr->wr.atomic.swap = w->wr.atomic.swap;
#line 392
        real_wr->wr.atomic.rkey = w->wr.atomic.rkey;
      }
    }
#line 397
    if (is_ud) {
#line 398
      real_wr->wr.ud.ah = (w->wr.ud.ah)->real_ah;
    }
#line 400
    if (tail_wr) {
#line 401
      tail_wr->next = real_wr;
    } else {
#line 403
      head_wr = real_wr;
    }
#line 405
    tail_wr = real_wr;
#line 351
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 408
  ret = (*(((qp->context)->real_context)->ops.post_send))(qp->real_qp, head_wr, & real_bad_wr);
  }
#line 411
  if (ret) {
#line 412
    real_wr = head_wr;
#line 412
    w = wr;
    {
#line 412
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 412
      if (! real_wr) {
#line 412
        goto while_break___0;
      }
#line 415
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 416
        *bad_wr = w;
#line 417
        goto while_break___0;
      }
#line 412
      real_wr = real_wr->next;
#line 412
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 421
  return (ret);
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_recv_wrapper_1_0___1(struct ibv_qp_1_0 *qp , struct ibv_recv_wr_1_0 *wr ,
                                     struct ibv_recv_wr_1_0 **bad_wr ) 
{ 
  struct ibv_recv_wr_1_0 *w ;
  struct ibv_recv_wr *real_wr ;
  struct ibv_recv_wr *head_wr ;
  struct ibv_recv_wr *tail_wr ;
  struct ibv_recv_wr *real_bad_wr ;
  int ret ;
  void *tmp ;

  {
#line 428
  head_wr = (struct ibv_recv_wr *)((void *)0);
#line 428
  tail_wr = (struct ibv_recv_wr *)((void *)0);
#line 431
  w = wr;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! w) {
#line 431
      goto while_break;
    }
    {
#line 432
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 432
    real_wr = (struct ibv_recv_wr *)tmp;
#line 433
    real_wr->wr_id = w->wr_id;
#line 434
    real_wr->sg_list = w->sg_list;
#line 435
    real_wr->num_sge = w->num_sge;
#line 436
    real_wr->next = (struct ibv_recv_wr *)((void *)0);
    }
#line 437
    if (tail_wr) {
#line 438
      tail_wr->next = real_wr;
    } else {
#line 440
      head_wr = real_wr;
    }
#line 442
    tail_wr = real_wr;
#line 431
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 445
  ret = (*(((qp->context)->real_context)->ops.post_recv))(qp->real_qp, head_wr, & real_bad_wr);
  }
#line 448
  if (ret) {
#line 449
    real_wr = head_wr;
#line 449
    w = wr;
    {
#line 449
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 449
      if (! real_wr) {
#line 449
        goto while_break___0;
      }
#line 452
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 453
        *bad_wr = w;
#line 454
        goto while_break___0;
      }
#line 449
      real_wr = real_wr->next;
#line 449
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 458
  return (ret);
}
}
#line 487
__asm__(".symver __ibv_open_device_1_0,ibv_open_device@IBVERBS_1.0");
#line 500
__asm__(".symver __ibv_close_device_1_0,ibv_close_device@IBVERBS_1.0");
#line 538
__asm__(".symver __ibv_get_async_event_1_0,ibv_get_async_event@IBVERBS_1.0");
#line 574
__asm__(".symver __ibv_ack_async_event_1_0,ibv_ack_async_event@IBVERBS_1.0");
#line 581
__asm__(".symver __ibv_query_device_1_0,ibv_query_device@IBVERBS_1.0");
#line 588
__asm__(".symver __ibv_query_port_1_0,ibv_query_port@IBVERBS_1.0");
#line 595
__asm__(".symver __ibv_query_gid_1_0,ibv_query_gid@IBVERBS_1.0");
#line 602
__asm__(".symver __ibv_query_pkey_1_0,ibv_query_pkey@IBVERBS_1.0");
#line 624
__asm__(".symver __ibv_alloc_pd_1_0,ibv_alloc_pd@IBVERBS_1.0");
#line 637
__asm__(".symver __ibv_dealloc_pd_1_0,ibv_dealloc_pd@IBVERBS_1.0");
#line 663
__asm__(".symver __ibv_reg_mr_1_0,ibv_reg_mr@IBVERBS_1.0");
#line 676
__asm__(".symver __ibv_dereg_mr_1_0,ibv_dereg_mr@IBVERBS_1.0");
#line 706
__asm__(".symver __ibv_create_cq_1_0,ibv_create_cq@IBVERBS_1.0");
#line 712
__asm__(".symver __ibv_resize_cq_1_0,ibv_resize_cq@IBVERBS_1.0");
#line 725
__asm__(".symver __ibv_destroy_cq_1_0,ibv_destroy_cq@IBVERBS_1.0");
#line 743
__asm__(".symver __ibv_get_cq_event_1_0,ibv_get_cq_event@IBVERBS_1.0");
#line 749
__asm__(".symver __ibv_ack_cq_events_1_0,ibv_ack_cq_events@IBVERBS_1.0");
#line 776
__asm__(".symver __ibv_create_srq_1_0,ibv_create_srq@IBVERBS_1.0");
#line 784
__asm__(".symver __ibv_modify_srq_1_0,ibv_modify_srq@IBVERBS_1.0");
#line 790
__asm__(".symver __ibv_query_srq_1_0,ibv_query_srq@IBVERBS_1.0");
#line 803
__asm__(".symver __ibv_destroy_srq_1_0,ibv_destroy_srq@IBVERBS_1.0");
#line 847
__asm__(".symver __ibv_create_qp_1_0,ibv_create_qp@IBVERBS_1.0");
#line 870
__asm__(".symver __ibv_query_qp_1_0,ibv_query_qp@IBVERBS_1.0");
#line 877
__asm__(".symver __ibv_modify_qp_1_0,ibv_modify_qp@IBVERBS_1.0");
#line 890
__asm__(".symver __ibv_destroy_qp_1_0,ibv_destroy_qp@IBVERBS_1.0");
#line 914
__asm__(".symver __ibv_create_ah_1_0,ibv_create_ah@IBVERBS_1.0");
#line 927
__asm__(".symver __ibv_destroy_ah_1_0,ibv_destroy_ah@IBVERBS_1.0");
#line 933
__asm__(".symver __ibv_attach_mcast_1_0,ibv_attach_mcast@IBVERBS_1.0");
#line 939
__asm__(".symver __ibv_detach_mcast_1_0,ibv_detach_mcast@IBVERBS_1.0");
#line 400 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
static int ibv_cmd_modify_srq_v3___1(struct ibv_srq *srq , struct ibv_srq_attr *srq_attr ,
                                     int srq_attr_mask , struct ibv_modify_srq *new_cmd ,
                                     size_t new_cmd_size ) 
{ 
  struct ibv_modify_srq_v3 *cmd ;
  size_t cmd_size ;
  void *tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 409
  cmd_size = (sizeof(*cmd) + new_cmd_size) - sizeof(*new_cmd);
#line 410
  tmp = __builtin_alloca(cmd_size);
#line 410
  cmd = (struct ibv_modify_srq_v3 *)tmp;
#line 411
  memcpy((void */* __restrict  */)(cmd->driver_data), (void const   */* __restrict  */)(new_cmd->driver_data),
         new_cmd_size - sizeof(*new_cmd));
  }
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 413
      cmd->command = (__u32 )33;
    } else {
#line 413
      cmd->command = (__u32 )35;
    }
#line 413
    cmd->in_words = (__u16 )(cmd_size / 4UL);
#line 413
    cmd->out_words = (__u16 )0;
#line 413
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 415
  cmd->srq_handle = srq->handle;
#line 416
  cmd->attr_mask = (__u32 )srq_attr_mask;
#line 417
  cmd->max_wr = srq_attr->max_wr;
#line 418
  cmd->srq_limit = srq_attr->srq_limit;
#line 419
  cmd->max_sge = (__u32 )0;
#line 420
  cmd->reserved = (__u32 )0;
#line 422
  tmp___1 = write((srq->context)->cmd_fd, (void const   *)cmd, cmd_size);
  }
#line 422
  if ((size_t )tmp___1 != cmd_size) {
    {
#line 423
    tmp___0 = __errno_location();
    }
#line 423
    return (*tmp___0);
  }
#line 425
  return (0);
}
}
#line 1008 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
static int ib_spec_to_kern_spec___1(struct ibv_flow_spec *ib_spec , struct ibv_kern_spec *kern_spec ) 
{ 


  {
#line 1011
  kern_spec->__annonCompField5.hdr.type = (__u32 )ib_spec->__annonCompField1.hdr.type;
  {
#line 1014
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 32U) {
#line 1014
    goto case_32;
  }
#line 1021
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 48U) {
#line 1021
    goto case_48;
  }
#line 1029
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 65U) {
#line 1029
    goto case_65;
  }
#line 1029
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 64U) {
#line 1029
    goto case_65;
  }
#line 1036
  goto switch_default;
  case_32: /* CIL Label */ 
  {
#line 1015
  kern_spec->__annonCompField5.eth.size = (__u16 )sizeof(struct ibv_kern_spec_eth );
#line 1016
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.eth.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.eth.val),
         sizeof(struct ibv_flow_eth_filter ));
#line 1018
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.eth.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.eth.mask),
         sizeof(struct ibv_flow_eth_filter ));
  }
#line 1020
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 1022
  kern_spec->__annonCompField5.ipv4.size = (__u16 )sizeof(struct ibv_kern_spec_ipv4 );
#line 1023
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.ipv4.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.ipv4.val),
         sizeof(struct ibv_flow_ipv4_filter ));
#line 1025
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.ipv4.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.ipv4.mask),
         sizeof(struct ibv_flow_ipv4_filter ));
  }
#line 1027
  goto switch_break;
  case_65: /* CIL Label */ 
  case_64: /* CIL Label */ 
  {
#line 1030
  kern_spec->__annonCompField5.tcp_udp.size = (__u16 )sizeof(struct ibv_kern_spec_tcp_udp );
#line 1031
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.tcp_udp.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.tcp_udp.val),
         sizeof(struct ibv_flow_ipv4_filter ));
#line 1033
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.tcp_udp.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.tcp_udp.mask),
         sizeof(struct ibv_flow_tcp_udp_filter ));
  }
#line 1035
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1037
  return (-22);
  switch_break: /* CIL Label */ ;
  }
#line 1039
  return (0);
}
}
#line 82 "./include/infiniband/verbs.h"
static void *__VERBS_ABI_IS_EXTENDED___1  =    (void *)((uint8_t *)((void *)0) - 1);
#line 877 "./include/infiniband/verbs.h"
__inline static struct verbs_context *verbs_get_ctx___1(struct ibv_context *ctx ) 
{ 
  struct verbs_context *tmp ;

  {
#line 879
  if ((unsigned long )ctx->abi_compat != (unsigned long )__VERBS_ABI_IS_EXTENDED___1) {
#line 879
    tmp = (struct verbs_context *)((void *)0);
  } else {
#line 879
    tmp = (struct verbs_context *)((uint8_t *)ctx - (unsigned long )(& ((struct verbs_context *)0)->context));
  }
#line 879
  return (tmp);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static pthread_once_t device_list_once___1  =    0;
#line 53 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static int num_devices___1  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static struct ibv_device **device_list___1  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static void count_devices___1(void) 
{ 
  int __attribute__((__visibility__("hidden")))  tmp ;

  {
  {
#line 58
  tmp = ibverbs_init(& device_list___1);
#line 58
  num_devices___1 = (int )tmp;
  }
#line 59
  return;
}
}
#line 89
__asm__(".symver __ibv_get_device_list,ibv_get_device_list@@IBVERBS_1.1");
#line 95
__asm__(".symver __ibv_free_device_list,ibv_free_device_list@@IBVERBS_1.1");
#line 101
__asm__(".symver __ibv_get_device_name,ibv_get_device_name@@IBVERBS_1.1");
#line 123
__asm__(".symver __ibv_get_device_guid,ibv_get_device_guid@@IBVERBS_1.1");
#line 190
__asm__(".symver __ibv_open_device,ibv_open_device@@IBVERBS_1.1");
#line 215
__asm__(".symver __ibv_close_device,ibv_close_device@@IBVERBS_1.1");
#line 258
__asm__(".symver __ibv_get_async_event,ibv_get_async_event@@IBVERBS_1.1");
#line 311
__asm__(".symver __ibv_ack_async_event,ibv_ack_async_event@@IBVERBS_1.1");
#line 47 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/sysfs.c"
static char *sysfs_path___2  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  node_type_str___2[5]  = {      (char const   */* const  */)0,      (char const   */* const  */)"InfiniBand channel adapter",      (char const   */* const  */)"InfiniBand switch",      (char const   */* const  */)"InfiniBand router", 
        (char const   */* const  */)"iWARP NIC"};
#line 52 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  port_state_str___3[6]  = {      (char const   */* const  */)"no state change (NOP)",      (char const   */* const  */)"down",      (char const   */* const  */)"init",      (char const   */* const  */)"armed", 
        (char const   */* const  */)"active",      (char const   */* const  */)"active defer"};
#line 69 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  event_type_str___2[19]  = 
#line 69
  {      (char const   */* const  */)"CQ error",      (char const   */* const  */)"local work queue catastrophic error",      (char const   */* const  */)"invalid request local work queue error",      (char const   */* const  */)"local access violation work queue error", 
        (char const   */* const  */)"communication established",      (char const   */* const  */)"send queue drained",      (char const   */* const  */)"path migrated",      (char const   */* const  */)"path migration request error", 
        (char const   */* const  */)"local catastrophic error",      (char const   */* const  */)"port active",      (char const   */* const  */)"port error",      (char const   */* const  */)"LID change", 
        (char const   */* const  */)"P_Key change",      (char const   */* const  */)"SM change",      (char const   */* const  */)"SRQ catastrophic error",      (char const   */* const  */)"SRQ limit reached", 
        (char const   */* const  */)"last WQE reached",      (char const   */* const  */)"client reregistration",      (char const   */* const  */)"GID table change"};
#line 99 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  wc_status_str___2[22]  = 
#line 99
  {      (char const   */* const  */)"success",      (char const   */* const  */)"local length error",      (char const   */* const  */)"local QP operation error",      (char const   */* const  */)"local EE context operation error", 
        (char const   */* const  */)"local protection error",      (char const   */* const  */)"Work Request Flushed Error",      (char const   */* const  */)"memory management operation error",      (char const   */* const  */)"bad response error", 
        (char const   */* const  */)"local access error",      (char const   */* const  */)"remote invalid request error",      (char const   */* const  */)"remote access error",      (char const   */* const  */)"remote operation error", 
        (char const   */* const  */)"transport retry counter exceeded",      (char const   */* const  */)"RNR retry counter exceeded",      (char const   */* const  */)"local RDD violation error",      (char const   */* const  */)"remote invalid RD request", 
        (char const   */* const  */)"aborted error",      (char const   */* const  */)"invalid EE context number",      (char const   */* const  */)"invalid EE context state",      (char const   */* const  */)"fatal error", 
        (char const   */* const  */)"response timeout error",      (char const   */* const  */)"general error"};
#line 132 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
__asm__(".symver __ibv_query_device,ibv_query_device@@IBVERBS_1.1");
#line 139
__asm__(".symver __ibv_query_port,ibv_query_port@@IBVERBS_1.1");
#line 164
__asm__(".symver __ibv_query_gid,ibv_query_gid@@IBVERBS_1.1");
#line 185
__asm__(".symver __ibv_query_pkey,ibv_query_pkey@@IBVERBS_1.1");
#line 197
__asm__(".symver __ibv_alloc_pd,ibv_alloc_pd@@IBVERBS_1.1");
#line 203
__asm__(".symver __ibv_dealloc_pd,ibv_dealloc_pd@@IBVERBS_1.1");
#line 224
__asm__(".symver __ibv_reg_mr,ibv_reg_mr@@IBVERBS_1.1");
#line 238
__asm__(".symver __ibv_dereg_mr,ibv_dereg_mr@@IBVERBS_1.1");
#line 243 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int warned___2  ;
#line 240 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static struct ibv_comp_channel *ibv_create_comp_channel_v2___2(struct ibv_context *context ) 
{ 
  struct ibv_abi_compat_v2 *t ;
  int tmp ;

  {
  {
#line 242
  t = (struct ibv_abi_compat_v2 *)context->abi_compat;
#line 245
  tmp = pthread_mutex_trylock(& t->in_use);
  }
#line 245
  if (! tmp) {
#line 246
    return (& t->channel);
  }
#line 248
  if (! warned___2) {
    {
#line 249
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: kernel\'s ABI version %d limits capacity.\n    Only one completion channel can be created per context.\n",
            abi_ver);
#line 252
    warned___2 ++;
    }
  }
#line 255
  return ((struct ibv_comp_channel *)((void *)0));
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int ibv_destroy_comp_channel_v2___2(struct ibv_comp_channel *channel ) 
{ 
  struct ibv_abi_compat_v2 *t ;

  {
  {
#line 288
  t = (struct ibv_abi_compat_v2 *)channel;
#line 289
  pthread_mutex_unlock(& t->in_use);
  }
#line 290
  return (0);
}
}
#line 346
__asm__(".symver __ibv_create_cq,ibv_create_cq@@IBVERBS_1.1");
#line 355
__asm__(".symver __ibv_resize_cq,ibv_resize_cq@@IBVERBS_1.1");
#line 375
__asm__(".symver __ibv_destroy_cq,ibv_destroy_cq@@IBVERBS_1.1");
#line 393
__asm__(".symver __ibv_get_cq_event,ibv_get_cq_event@@IBVERBS_1.1");
#line 402
__asm__(".symver __ibv_ack_cq_events,ibv_ack_cq_events@@IBVERBS_1.1");
#line 424
__asm__(".symver __ibv_create_srq,ibv_create_srq@@IBVERBS_1.1");
#line 432
__asm__(".symver __ibv_modify_srq,ibv_modify_srq@@IBVERBS_1.1");
#line 438
__asm__(".symver __ibv_query_srq,ibv_query_srq@@IBVERBS_1.1");
#line 444
__asm__(".symver __ibv_destroy_srq,ibv_destroy_srq@@IBVERBS_1.1");
#line 467
__asm__(".symver __ibv_create_qp,ibv_create_qp@@IBVERBS_1.1");
#line 484
__asm__(".symver __ibv_query_qp,ibv_query_qp@@IBVERBS_1.1");
#line 500
__asm__(".symver __ibv_modify_qp,ibv_modify_qp@@IBVERBS_1.1");
#line 506
__asm__(".symver __ibv_destroy_qp,ibv_destroy_qp@@IBVERBS_1.1");
#line 519
__asm__(".symver __ibv_create_ah,ibv_create_ah@@IBVERBS_1.1");
#line 521 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int ibv_find_gid_index___2(struct ibv_context *context , uint8_t port_num ,
                                  union ibv_gid *gid ) 
{ 
  union ibv_gid sgid ;
  int i ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 525
  i = 0;
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 528
    tmp = i;
#line 528
    i ++;
#line 528
    ret = ibv_query_gid(context, port_num, tmp, & sgid);
    }
#line 527
    if (! ret) {
      {
#line 527
      tmp___0 = memcmp((void const   *)(& sgid), (void const   *)gid, sizeof(*gid));
      }
#line 527
      if (! tmp___0) {
#line 527
        goto while_break;
      }
    } else {
#line 527
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 531
  if (ret) {
#line 531
    tmp___1 = ret;
  } else {
#line 531
    tmp___1 = i - 1;
  }
#line 531
  return (tmp___1);
}
}
#line 581
__asm__(".symver __ibv_destroy_ah,ibv_destroy_ah@@IBVERBS_1.1");
#line 587
__asm__(".symver __ibv_attach_mcast,ibv_attach_mcast@@IBVERBS_1.1");
#line 593
__asm__(".symver __ibv_detach_mcast,ibv_detach_mcast@@IBVERBS_1.1");
#line 77 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_sysfs_dev *sysfs_dev_list___2  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver_name *driver_name_list___2  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver *head_driver___2  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver *tail_driver___2  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static int find_sysfs_devs___2(void) 
{ 
  char class_path[256] ;
  DIR *class_dir ;
  struct dirent *dent ;
  struct ibv_sysfs_dev *sysfs_dev ;
  char value[8] ;
  int ret ;
  char const   *tmp ;
  struct stat buf ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;

  {
  {
#line 86
  sysfs_dev = (struct ibv_sysfs_dev *)((void *)0);
#line 88
  ret = 0;
#line 90
  tmp = ibv_get_sysfs_path();
#line 90
  snprintf((char */* __restrict  */)(class_path), sizeof(class_path), (char const   */* __restrict  */)"%s/class/infiniband_verbs",
           tmp);
#line 93
  class_dir = opendir((char const   *)(class_path));
  }
#line 94
  if (! class_dir) {
#line 95
    return (38);
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    dent = readdir(class_dir);
    }
#line 97
    if (! dent) {
#line 97
      goto while_break;
    }
#line 100
    if ((int )dent->d_name[0] == 46) {
#line 101
      goto while_continue;
    }
#line 103
    if (! sysfs_dev) {
      {
#line 104
      tmp___0 = malloc(sizeof(*sysfs_dev));
#line 104
      sysfs_dev = (struct ibv_sysfs_dev *)tmp___0;
      }
    }
#line 105
    if (! sysfs_dev) {
#line 106
      ret = 12;
#line 107
      goto out;
    }
    {
#line 110
    snprintf((char */* __restrict  */)(sysfs_dev->sysfs_path), sizeof(sysfs_dev->sysfs_path),
             (char const   */* __restrict  */)"%s/%s", class_path, dent->d_name);
#line 113
    tmp___1 = stat((char const   */* __restrict  */)(sysfs_dev->sysfs_path), (struct stat */* __restrict  */)(& buf));
    }
#line 113
    if (tmp___1) {
      {
#line 114
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t stat \'%s\'.\n",
              sysfs_dev->sysfs_path);
      }
#line 116
      goto while_continue;
    }
#line 119
    if (! ((buf.st_mode & 61440U) == 16384U)) {
#line 120
      goto while_continue;
    }
    {
#line 122
    snprintf((char */* __restrict  */)(sysfs_dev->sysfs_name), sizeof(sysfs_dev->sysfs_name),
             (char const   */* __restrict  */)"%s", dent->d_name);
#line 125
    tmp___2 = ibv_read_sysfs_file((char const   *)(sysfs_dev->sysfs_path), "ibdev",
                                  sysfs_dev->ibdev_name, sizeof(sysfs_dev->ibdev_name));
    }
#line 125
    if (tmp___2 < 0) {
      {
#line 128
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: no ibdev class attr for \'%s\'.\n",
              dent->d_name);
      }
#line 130
      goto while_continue;
    }
    {
#line 133
    tmp___3 = ibv_get_sysfs_path();
#line 133
    snprintf((char */* __restrict  */)(sysfs_dev->ibdev_path), sizeof(sysfs_dev->ibdev_path),
             (char const   */* __restrict  */)"%s/class/infiniband/%s", tmp___3, sysfs_dev->ibdev_name);
#line 137
    sysfs_dev->next = sysfs_dev_list___2;
#line 138
    sysfs_dev->have_driver = 0;
#line 139
    tmp___5 = ibv_read_sysfs_file((char const   *)(sysfs_dev->sysfs_path), "abi_version",
                                  value, sizeof(value));
    }
#line 139
    if (tmp___5 > 0) {
      {
#line 141
      tmp___4 = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                       10);
#line 141
      sysfs_dev->abi_ver = (int )tmp___4;
      }
    } else {
#line 143
      sysfs_dev->abi_ver = 0;
    }
#line 145
    sysfs_dev_list___2 = sysfs_dev;
#line 146
    sysfs_dev = (struct ibv_sysfs_dev *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
  out: 
#line 150
  if (sysfs_dev) {
    {
#line 151
    free((void *)sysfs_dev);
    }
  }
  {
#line 153
  closedir(class_dir);
  }
#line 154
  return (ret);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void register_driver___2(char const   *name , struct ibv_device *(*init_func)(char const   *uverbs_sys_path ,
                                                                                     int abi_version ) ,
                                struct verbs_device *(*verbs_init_func)(char const   *uverbs_sys_path ,
                                                                        int abi_version ) ) 
{ 
  struct ibv_driver *driver ;
  void *tmp ;

  {
  {
#line 162
  tmp = malloc(sizeof(*driver));
#line 162
  driver = (struct ibv_driver *)tmp;
  }
#line 163
  if (! driver) {
    {
#line 164
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver for %s\n",
            name);
    }
#line 165
    return;
  }
#line 168
  driver->name = name;
#line 169
  driver->init_func = init_func;
#line 170
  driver->verbs_init_func = verbs_init_func;
#line 171
  driver->next = (struct ibv_driver *)((void *)0);
#line 173
  if (tail_driver___2) {
#line 174
    tail_driver___2->next = driver;
  } else {
#line 176
    head_driver___2 = driver;
  }
#line 177
  tail_driver___2 = driver;
#line 178
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void load_driver___2(char const   *name ) 
{ 
  char *so_name ;
  void *dlhandle ;
  char const   *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 201
  if ((int const   )*(name + 0) == 47) {
#line 201
    tmp = "%s-rdmav2.so";
  } else {
#line 201
    tmp = "lib%s-rdmav2.so";
  }
  {
#line 201
  tmp___0 = asprintf((char **/* __restrict  */)(& so_name), (char const   */* __restrict  */)tmp,
                     name);
  }
#line 201
  if (tmp___0 < 0) {
    {
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t load driver \'%s\'.\n",
            name);
    }
#line 208
    return;
  }
  {
#line 211
  dlhandle = dlopen((char const   *)so_name, 2);
  }
#line 212
  if (! dlhandle) {
    {
#line 213
    tmp___1 = dlerror();
#line 213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t load driver \'%s\': %s\n",
            name, tmp___1);
    }
#line 215
    goto out;
  }
  out: 
  {
#line 219
  free((void *)so_name);
  }
#line 220
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void load_drivers___2(void) 
{ 
  struct ibv_driver_name *name ;
  struct ibv_driver_name *next_name ;
  char const   *env ;
  char *list ;
  char *env_name ;
  char const   *__old ;
  size_t __len ;
  size_t tmp ;
  char *__new ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *__old___0 ;
  size_t __len___0 ;
  size_t tmp___2 ;
  char *__new___0 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;

  {
  {
#line 232
  tmp___7 = getuid();
#line 232
  tmp___8 = geteuid();
  }
#line 232
  if (tmp___7 == tmp___8) {
    {
#line 233
    tmp___6 = getenv("RDMAV_DRIVERS");
#line 233
    env = (char const   *)tmp___6;
    }
#line 233
    if (env) {
      {
#line 234
      __old = env;
#line 234
      tmp = strlen(__old);
#line 234
      __len = tmp + 1UL;
#line 234
      tmp___0 = __builtin_alloca(__len);
#line 234
      __new = (char *)tmp___0;
#line 234
      tmp___1 = memcpy((void */* __restrict  */)__new, (void const   */* __restrict  */)__old,
                       __len);
#line 234
      list = (char *)tmp___1;
      }
      {
#line 235
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 235
        env_name = strsep((char **/* __restrict  */)(& list), (char const   */* __restrict  */)":;");
        }
#line 235
        if (! env_name) {
#line 235
          goto while_break;
        }
        {
#line 236
        load_driver___2((char const   *)env_name);
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 237
      tmp___5 = getenv("IBV_DRIVERS");
#line 237
      env = (char const   *)tmp___5;
      }
#line 237
      if (env) {
        {
#line 238
        __old___0 = env;
#line 238
        tmp___2 = strlen(__old___0);
#line 238
        __len___0 = tmp___2 + 1UL;
#line 238
        tmp___3 = __builtin_alloca(__len___0);
#line 238
        __new___0 = (char *)tmp___3;
#line 238
        tmp___4 = memcpy((void */* __restrict  */)__new___0, (void const   */* __restrict  */)__old___0,
                         __len___0);
#line 238
        list = (char *)tmp___4;
        }
        {
#line 239
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 239
          env_name = strsep((char **/* __restrict  */)(& list), (char const   */* __restrict  */)":;");
          }
#line 239
          if (! env_name) {
#line 239
            goto while_break___0;
          }
          {
#line 240
          load_driver___2((char const   *)env_name);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 244
  name = driver_name_list___2;
#line 244
  if (name) {
#line 244
    next_name = name->next;
  } else {
#line 244
    next_name = (struct ibv_driver_name *)((void *)0);
  }
  {
#line 244
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 244
    if (! name) {
#line 244
      goto while_break___1;
    }
    {
#line 247
    load_driver___2((char const   *)name->name);
#line 248
    free((void *)name->name);
#line 249
    free((void *)name);
#line 244
    name = next_name;
    }
#line 244
    if (name) {
#line 244
      next_name = name->next;
    } else {
#line 244
      next_name = (struct ibv_driver_name *)((void *)0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 251
  return;
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void read_config_file___2(char const   *path ) 
{ 
  FILE *conf ;
  char *line ;
  char *config ;
  char *field ;
  size_t buflen ;
  ssize_t len ;
  size_t tmp ;
  struct ibv_driver_name *driver_name ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 256
  line = (char *)((void *)0);
#line 259
  buflen = (size_t )0;
#line 262
  conf = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"re");
  }
#line 263
  if (! conf) {
    {
#line 264
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t read config file %s.\n",
            path);
    }
#line 266
    return;
  }
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 269
    len = getline((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& buflen),
                  (FILE */* __restrict  */)conf);
    }
#line 269
    if (! (len != -1L)) {
#line 269
      goto while_break;
    }
    {
#line 270
    tmp = strspn((char const   *)line, "\t ");
#line 270
    config = line + tmp;
    }
#line 271
    if ((int )*(config + 0) == 10) {
#line 272
      goto while_continue;
    } else
#line 271
    if ((int )*(config + 0) == 35) {
#line 272
      goto while_continue;
    }
    {
#line 274
    field = strsep((char **/* __restrict  */)(& config), (char const   */* __restrict  */)"\n\t ");
#line 276
    tmp___2 = strcmp((char const   *)field, "driver");
    }
#line 276
    if (tmp___2 == 0) {
#line 276
      if ((unsigned long )config != (unsigned long )((void *)0)) {
        {
#line 279
        tmp___0 = strspn((char const   *)config, "\t ");
#line 279
        config += tmp___0;
#line 280
        field = strsep((char **/* __restrict  */)(& config), (char const   */* __restrict  */)"\n\t ");
#line 282
        tmp___1 = malloc(sizeof(*driver_name));
#line 282
        driver_name = (struct ibv_driver_name *)tmp___1;
        }
#line 283
        if (! driver_name) {
          {
#line 284
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver name \'%s\'.\n",
                  field);
          }
#line 286
          goto while_continue;
        }
        {
#line 289
        driver_name->name = strdup((char const   *)field);
        }
#line 290
        if (! driver_name->name) {
          {
#line 291
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver name \'%s\'.\n",
                  field);
#line 293
          free((void *)driver_name);
          }
#line 294
          goto while_continue;
        }
#line 297
        driver_name->next = driver_name_list___2;
#line 298
        driver_name_list___2 = driver_name;
      } else {
        {
#line 300
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: ignoring bad config directive \'%s\' in file \'%s\'.\n",
                field, path);
        }
      }
    } else {
      {
#line 300
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: ignoring bad config directive \'%s\' in file \'%s\'.\n",
              field, path);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  if (line) {
    {
#line 305
    free((void *)line);
    }
  }
  {
#line 306
  fclose(conf);
  }
#line 307
  return;
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void read_config___2(void) 
{ 
  DIR *conf_dir ;
  struct dirent *dent ;
  char *path ;
  struct stat buf ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 315
  conf_dir = opendir("/usr/local/etc/libibverbs.d");
  }
#line 316
  if (! conf_dir) {
    {
#line 317
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t open config directory \'%s\'.\n",
            "/usr/local/etc/libibverbs.d");
    }
#line 319
    return;
  }
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 322
    dent = readdir(conf_dir);
    }
#line 322
    if (! dent) {
#line 322
      goto while_break;
    }
    {
#line 325
    tmp = asprintf((char **/* __restrict  */)(& path), (char const   */* __restrict  */)"%s/%s",
                   "/usr/local/etc/libibverbs.d", dent->d_name);
    }
#line 325
    if (tmp < 0) {
      {
#line 326
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t read config file %s/%s.\n",
              "/usr/local/etc/libibverbs.d", dent->d_name);
      }
#line 328
      goto out;
    }
    {
#line 331
    tmp___0 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& buf));
    }
#line 331
    if (tmp___0) {
      {
#line 332
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t stat config file \'%s\'.\n",
              path);
      }
#line 334
      goto next;
    }
#line 337
    if (! ((buf.st_mode & 61440U) == 32768U)) {
#line 338
      goto next;
    }
    {
#line 340
    read_config_file___2((char const   *)path);
    }
    next: 
    {
#line 342
    free((void *)path);
    }
  }
  while_break: /* CIL Label */ ;
  }
  out: 
  {
#line 346
  closedir(conf_dir);
  }
#line 347
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_device *try_driver___2(struct ibv_driver *driver , struct ibv_sysfs_dev *sysfs_dev ) 
{ 
  struct verbs_device *vdev ;
  struct ibv_device *dev ;
  char value[8] ;
  long tmp ;
  int tmp___0 ;

  {
#line 356
  if (driver->init_func) {
    {
#line 357
    dev = (*(driver->init_func))((char const   *)(sysfs_dev->sysfs_path), sysfs_dev->abi_ver);
    }
#line 358
    if (! dev) {
#line 359
      return ((struct ibv_device *)((void *)0));
    }
  } else {
    {
#line 361
    vdev = (*(driver->verbs_init_func))((char const   *)(sysfs_dev->sysfs_path), sysfs_dev->abi_ver);
    }
#line 362
    if (! vdev) {
#line 363
      return ((struct ibv_device *)((void *)0));
    }
#line 365
    dev = & vdev->device;
#line 366
    dev->ops.alloc_context = (struct ibv_context *(*)(struct ibv_device *device ,
                                                      int cmd_fd ))((void *)0);
#line 367
    dev->ops.free_context = (void (*)(struct ibv_context *context ))((void *)0);
  }
  {
#line 370
  tmp___0 = ibv_read_sysfs_file((char const   *)(sysfs_dev->ibdev_path), "node_type",
                                value, sizeof(value));
  }
#line 370
  if (tmp___0 < 0) {
    {
#line 371
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: no node_type attr under %s.\n",
            sysfs_dev->ibdev_path);
#line 373
    dev->node_type = (enum ibv_node_type )-1;
    }
  } else {
    {
#line 375
    tmp = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                 10);
#line 375
    dev->node_type = (enum ibv_node_type )tmp;
    }
#line 376
    if ((int )dev->node_type < 1) {
#line 377
      dev->node_type = (enum ibv_node_type )-1;
    } else
#line 376
    if ((int )dev->node_type > 4) {
#line 377
      dev->node_type = (enum ibv_node_type )-1;
    }
  }
  {
#line 383
  if ((int )dev->node_type == 3) {
#line 383
    goto case_3;
  }
#line 383
  if ((int )dev->node_type == 2) {
#line 383
    goto case_3;
  }
#line 383
  if ((int )dev->node_type == 1) {
#line 383
    goto case_3;
  }
#line 386
  if ((int )dev->node_type == 4) {
#line 386
    goto case_4;
  }
#line 389
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 384
  dev->transport_type = (enum ibv_transport_type )0;
#line 385
  goto switch_break;
  case_4: /* CIL Label */ 
#line 387
  dev->transport_type = (enum ibv_transport_type )1;
#line 388
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 390
  dev->transport_type = (enum ibv_transport_type )-1;
#line 391
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 394
  strcpy((char */* __restrict  */)(dev->dev_name), (char const   */* __restrict  */)(sysfs_dev->sysfs_name));
#line 395
  strcpy((char */* __restrict  */)(dev->dev_path), (char const   */* __restrict  */)(sysfs_dev->sysfs_path));
#line 396
  strcpy((char */* __restrict  */)(dev->name), (char const   */* __restrict  */)(sysfs_dev->ibdev_name));
#line 397
  strcpy((char */* __restrict  */)(dev->ibdev_path), (char const   */* __restrict  */)(sysfs_dev->ibdev_path));
  }
#line 399
  return (dev);
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_device *try_drivers___2(struct ibv_sysfs_dev *sysfs_dev ) 
{ 
  struct ibv_driver *driver ;
  struct ibv_device *dev ;

  {
#line 407
  driver = head_driver___2;
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 407
    if (! driver) {
#line 407
      goto while_break;
    }
    {
#line 408
    dev = try_driver___2(driver, sysfs_dev);
    }
#line 409
    if (dev) {
#line 410
      return (dev);
    }
#line 407
    driver = driver->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 413
  return ((struct ibv_device *)((void *)0));
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static int check_abi_version___2(char const   *path ) 
{ 
  char value[8] ;
  int tmp ;
  long tmp___0 ;

  {
  {
#line 420
  tmp = ibv_read_sysfs_file(path, "class/infiniband_verbs/abi_version", value, sizeof(value));
  }
#line 420
  if (tmp < 0) {
#line 422
    return (38);
  }
  {
#line 425
  tmp___0 = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                   10);
#line 425
  abi_ver = (int __attribute__((__visibility__("hidden")))  )tmp___0;
  }
#line 427
  if (abi_ver < (int __attribute__((__visibility__("hidden")))  )3) {
    {
#line 429
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Fatal: kernel ABI version %d doesn\'t match library version %d.\n",
            abi_ver, 6);
    }
#line 432
    return (38);
  } else
#line 427
  if (abi_ver > (int __attribute__((__visibility__("hidden")))  )6) {
    {
#line 429
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Fatal: kernel ABI version %d doesn\'t match library version %d.\n",
            abi_ver, 6);
    }
#line 432
    return (38);
  }
#line 435
  return (0);
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void check_memlock_limit___2(void) 
{ 
  struct rlimit rlim ;
  __uid_t tmp ;
  int tmp___0 ;

  {
  {
#line 442
  tmp = geteuid();
  }
#line 442
  if (! tmp) {
#line 443
    return;
  }
  {
#line 445
  tmp___0 = getrlimit((__rlimit_resource_t )8, & rlim);
  }
#line 445
  if (tmp___0) {
    {
#line 446
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: getrlimit(RLIMIT_MEMLOCK) failed.");
    }
#line 447
    return;
  }
#line 450
  if (rlim.rlim_cur <= 32768UL) {
    {
#line 451
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: RLIMIT_MEMLOCK is %lu bytes.\n    This will severely limit memory registrations.\n",
            rlim.rlim_cur);
    }
  }
#line 454
  return;
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void add_device___2(struct ibv_device *dev , struct ibv_device ***dev_list ,
                           int *num_devices___7 , int *list_size ) 
{ 
  struct ibv_device **new_list ;
  void *tmp ;
  int tmp___0 ;

  {
#line 463
  if (*list_size <= *num_devices___7) {
#line 464
    if (*list_size) {
#line 464
      *list_size *= 2;
    } else {
#line 464
      *list_size = 1;
    }
    {
#line 465
    tmp = realloc((void *)*dev_list, (unsigned long )*list_size * sizeof(struct ibv_device *));
#line 465
    new_list = (struct ibv_device **)tmp;
    }
#line 466
    if (! new_list) {
#line 467
      return;
    }
#line 468
    *dev_list = new_list;
  }
#line 471
  tmp___0 = *num_devices___7;
#line 471
  (*num_devices___7) ++;
#line 471
  *(*dev_list + tmp___0) = dev;
#line 472
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *mm_root___2  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static pthread_mutex_t mm_mutex___2  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 75 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int page_size___4  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int huge_page_enabled___2  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int too_late___2  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static unsigned long smaps_page_size___2(FILE *file ) 
{ 
  int n ;
  unsigned long size ;
  char buf[1024] ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 82
  size = (unsigned long )page_size___4;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 85
    tmp___0 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)file);
    }
#line 85
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 85
      goto while_break;
    }
    {
#line 86
    tmp = strstr((char const   *)(buf), "KernelPageSize:");
    }
#line 86
    if (! tmp) {
#line 87
      goto while_continue;
    }
    {
#line 89
    n = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*s %lu",
               & size);
    }
#line 90
    if (n < 1) {
#line 91
      goto while_continue;
    }
#line 94
    size *= 1024UL;
#line 96
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return (size);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static unsigned long get_page_size___2(void *base ) 
{ 
  unsigned long ret ;
  pid_t pid ;
  FILE *file ;
  char buf[1024] ;
  int n ;
  uintptr_t range_start ;
  uintptr_t range_end ;
  char *tmp ;

  {
  {
#line 104
  ret = (unsigned long )page_size___4;
#line 109
  pid = getpid();
#line 110
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"/proc/%d/smaps",
           pid);
#line 112
  file = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"re");
  }
#line 113
  if (! file) {
#line 114
    goto out;
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 116
    tmp = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)file);
    }
#line 116
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 116
      goto while_break;
    }
    {
#line 120
    n = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%lx-%lx",
               & range_start, & range_end);
    }
#line 122
    if (n < 2) {
#line 123
      goto while_continue;
    }
#line 125
    if ((uintptr_t )base >= range_start) {
#line 125
      if ((uintptr_t )base < range_end) {
        {
#line 126
        ret = smaps_page_size___2(file);
        }
#line 127
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  fclose(file);
  }
  out: 
#line 134
  return (ret);
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_prev___2(struct ibv_mem_node *node ) 
{ 


  {
#line 194
  if (node->left) {
#line 195
    node = node->left;
    {
#line 196
    while (1) {
      while_continue: /* CIL Label */ ;
#line 196
      if (! node->right) {
#line 196
        goto while_break;
      }
#line 197
      node = node->right;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 199
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 199
      if (node->parent) {
#line 199
        if (! ((unsigned long )node == (unsigned long )(node->parent)->left)) {
#line 199
          goto while_break___0;
        }
      } else {
#line 199
        goto while_break___0;
      }
#line 200
      node = node->parent;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 202
    node = node->parent;
  }
#line 205
  return (node);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_next___2(struct ibv_mem_node *node ) 
{ 


  {
#line 210
  if (node->right) {
#line 211
    node = node->right;
    {
#line 212
    while (1) {
      while_continue: /* CIL Label */ ;
#line 212
      if (! node->left) {
#line 212
        goto while_break;
      }
#line 213
      node = node->left;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 215
      if (node->parent) {
#line 215
        if (! ((unsigned long )node == (unsigned long )(node->parent)->right)) {
#line 215
          goto while_break___0;
        }
      } else {
#line 215
        goto while_break___0;
      }
#line 216
      node = node->parent;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 218
    node = node->parent;
  }
#line 221
  return (node);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_rotate_right___2(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 228
  tmp = node->left;
#line 230
  node->left = tmp->right;
#line 231
  if (node->left) {
#line 232
    (node->left)->parent = node;
  }
#line 234
  if (node->parent) {
#line 235
    if ((unsigned long )(node->parent)->right == (unsigned long )node) {
#line 236
      (node->parent)->right = tmp;
    } else {
#line 238
      (node->parent)->left = tmp;
    }
  } else {
#line 240
    mm_root___2 = tmp;
  }
#line 242
  tmp->parent = node->parent;
#line 244
  tmp->right = node;
#line 245
  node->parent = tmp;
#line 246
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_rotate_left___2(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 252
  tmp = node->right;
#line 254
  node->right = tmp->left;
#line 255
  if (node->right) {
#line 256
    (node->right)->parent = node;
  }
#line 258
  if (node->parent) {
#line 259
    if ((unsigned long )(node->parent)->right == (unsigned long )node) {
#line 260
      (node->parent)->right = tmp;
    } else {
#line 262
      (node->parent)->left = tmp;
    }
  } else {
#line 264
    mm_root___2 = tmp;
  }
#line 266
  tmp->parent = node->parent;
#line 268
  tmp->left = node;
#line 269
  node->parent = tmp;
#line 270
  return;
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_add_rebalance___2(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *parent ;
  struct ibv_mem_node *gp ;
  struct ibv_mem_node *uncle ;

  {
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (node->parent) {
#line 304
      if (! ((unsigned int )(node->parent)->color == 0U)) {
#line 304
        goto while_break;
      }
    } else {
#line 304
      goto while_break;
    }
#line 305
    parent = node->parent;
#line 306
    gp = (node->parent)->parent;
#line 308
    if ((unsigned long )parent == (unsigned long )gp->left) {
#line 309
      uncle = gp->right;
#line 311
      if (uncle) {
#line 311
        if ((unsigned int )uncle->color == 0U) {
#line 312
          parent->color = (enum __anonenum_color_68 )1;
#line 313
          uncle->color = (enum __anonenum_color_68 )1;
#line 314
          gp->color = (enum __anonenum_color_68 )0;
#line 316
          node = gp;
        } else {
#line 311
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 318
        if ((unsigned long )node == (unsigned long )parent->right) {
          {
#line 319
          __mm_rotate_left___2(parent);
#line 320
          node = parent;
#line 321
          parent = node->parent;
          }
        }
        {
#line 324
        parent->color = (enum __anonenum_color_68 )1;
#line 325
        gp->color = (enum __anonenum_color_68 )0;
#line 327
        __mm_rotate_right___2(gp);
        }
      }
    } else {
#line 330
      uncle = gp->left;
#line 332
      if (uncle) {
#line 332
        if ((unsigned int )uncle->color == 0U) {
#line 333
          parent->color = (enum __anonenum_color_68 )1;
#line 334
          uncle->color = (enum __anonenum_color_68 )1;
#line 335
          gp->color = (enum __anonenum_color_68 )0;
#line 337
          node = gp;
        } else {
#line 332
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 339
        if ((unsigned long )node == (unsigned long )parent->left) {
          {
#line 340
          __mm_rotate_right___2(parent);
#line 341
          node = parent;
#line 342
          parent = node->parent;
          }
        }
        {
#line 345
        parent->color = (enum __anonenum_color_68 )1;
#line 346
        gp->color = (enum __anonenum_color_68 )0;
#line 348
        __mm_rotate_left___2(gp);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  mm_root___2->color = (enum __anonenum_color_68 )1;
#line 354
  return;
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_add___2(struct ibv_mem_node *new ) 
{ 
  struct ibv_mem_node *node ;
  struct ibv_mem_node *parent ;

  {
#line 358
  parent = (struct ibv_mem_node *)((void *)0);
#line 360
  node = mm_root___2;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! node) {
#line 361
      goto while_break;
    }
#line 362
    parent = node;
#line 363
    if (node->start < new->start) {
#line 364
      node = node->right;
    } else {
#line 366
      node = node->left;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  if (parent->start < new->start) {
#line 370
    parent->right = new;
  } else {
#line 372
    parent->left = new;
  }
  {
#line 374
  new->parent = parent;
#line 375
  new->left = (struct ibv_mem_node *)((void *)0);
#line 376
  new->right = (struct ibv_mem_node *)((void *)0);
#line 378
  new->color = (enum __anonenum_color_68 )0;
#line 379
  __mm_add_rebalance___2(new);
  }
#line 380
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_remove___2(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *child ;
  struct ibv_mem_node *parent ;
  struct ibv_mem_node *sib ;
  struct ibv_mem_node *tmp ;
  int nodecol ;

  {
#line 387
  if (node->left) {
#line 387
    if (node->right) {
#line 388
      tmp = node->left;
      {
#line 389
      while (1) {
        while_continue: /* CIL Label */ ;
#line 389
        if (! tmp->right) {
#line 389
          goto while_break;
        }
#line 390
        tmp = tmp->right;
      }
      while_break: /* CIL Label */ ;
      }
#line 392
      nodecol = (int )tmp->color;
#line 393
      child = tmp->left;
#line 394
      tmp->color = node->color;
#line 396
      if ((unsigned long )tmp->parent != (unsigned long )node) {
#line 397
        parent = tmp->parent;
#line 398
        parent->right = tmp->left;
#line 399
        if (tmp->left) {
#line 400
          (tmp->left)->parent = parent;
        }
#line 402
        tmp->left = node->left;
#line 403
        (node->left)->parent = tmp;
      } else {
#line 405
        parent = tmp;
      }
#line 407
      tmp->right = node->right;
#line 408
      (node->right)->parent = tmp;
#line 410
      tmp->parent = node->parent;
#line 411
      if (node->parent) {
#line 412
        if ((unsigned long )(node->parent)->left == (unsigned long )node) {
#line 413
          (node->parent)->left = tmp;
        } else {
#line 415
          (node->parent)->right = tmp;
        }
      } else {
#line 417
        mm_root___2 = tmp;
      }
    } else {
#line 387
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 419
    nodecol = (int )node->color;
#line 421
    if (node->left) {
#line 421
      child = node->left;
    } else {
#line 421
      child = node->right;
    }
#line 422
    parent = node->parent;
#line 424
    if (child) {
#line 425
      child->parent = parent;
    }
#line 426
    if (parent) {
#line 427
      if ((unsigned long )parent->left == (unsigned long )node) {
#line 428
        parent->left = child;
      } else {
#line 430
        parent->right = child;
      }
    } else {
#line 432
      mm_root___2 = child;
    }
  }
  {
#line 435
  free((void *)node);
  }
#line 437
  if (nodecol == 0) {
#line 438
    return;
  }
  {
#line 440
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 440
    if (! child) {
#line 440
      goto _L___6;
    } else
#line 440
    if ((unsigned int )child->color == 1U) {
      _L___6: /* CIL Label */ 
#line 440
      if (! ((unsigned long )child != (unsigned long )mm_root___2)) {
#line 440
        goto while_break___0;
      }
    } else {
#line 440
      goto while_break___0;
    }
#line 441
    if ((unsigned long )parent->left == (unsigned long )child) {
#line 442
      sib = parent->right;
#line 444
      if ((unsigned int )sib->color == 0U) {
        {
#line 445
        parent->color = (enum __anonenum_color_68 )0;
#line 446
        sib->color = (enum __anonenum_color_68 )1;
#line 447
        __mm_rotate_left___2(parent);
#line 448
        sib = parent->right;
        }
      }
#line 451
      if (! sib->left) {
#line 451
        goto _L___2;
      } else
#line 451
      if ((unsigned int )(sib->left)->color == 1U) {
        _L___2: /* CIL Label */ 
#line 451
        if (! sib->right) {
#line 453
          sib->color = (enum __anonenum_color_68 )0;
#line 454
          child = parent;
#line 455
          parent = child->parent;
        } else
#line 451
        if ((unsigned int )(sib->right)->color == 1U) {
#line 453
          sib->color = (enum __anonenum_color_68 )0;
#line 454
          child = parent;
#line 455
          parent = child->parent;
        } else {
#line 451
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 457
        if (! sib->right) {
#line 457
          goto _L___0;
        } else
#line 457
        if ((unsigned int )(sib->right)->color == 1U) {
          _L___0: /* CIL Label */ 
#line 458
          if (sib->left) {
#line 459
            (sib->left)->color = (enum __anonenum_color_68 )1;
          }
          {
#line 460
          sib->color = (enum __anonenum_color_68 )0;
#line 461
          __mm_rotate_right___2(sib);
#line 462
          sib = parent->right;
          }
        }
#line 465
        sib->color = parent->color;
#line 466
        parent->color = (enum __anonenum_color_68 )1;
#line 467
        if (sib->right) {
#line 468
          (sib->right)->color = (enum __anonenum_color_68 )1;
        }
        {
#line 469
        __mm_rotate_left___2(parent);
#line 470
        child = mm_root___2;
        }
#line 471
        goto while_break___0;
      }
    } else {
#line 474
      sib = parent->left;
#line 476
      if ((unsigned int )sib->color == 0U) {
        {
#line 477
        parent->color = (enum __anonenum_color_68 )0;
#line 478
        sib->color = (enum __anonenum_color_68 )1;
#line 479
        __mm_rotate_right___2(parent);
#line 480
        sib = parent->left;
        }
      }
#line 483
      if (! sib->left) {
#line 483
        goto _L___5;
      } else
#line 483
      if ((unsigned int )(sib->left)->color == 1U) {
        _L___5: /* CIL Label */ 
#line 483
        if (! sib->right) {
#line 485
          sib->color = (enum __anonenum_color_68 )0;
#line 486
          child = parent;
#line 487
          parent = child->parent;
        } else
#line 483
        if ((unsigned int )(sib->right)->color == 1U) {
#line 485
          sib->color = (enum __anonenum_color_68 )0;
#line 486
          child = parent;
#line 487
          parent = child->parent;
        } else {
#line 483
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
#line 489
        if (! sib->left) {
#line 489
          goto _L___3;
        } else
#line 489
        if ((unsigned int )(sib->left)->color == 1U) {
          _L___3: /* CIL Label */ 
#line 490
          if (sib->right) {
#line 491
            (sib->right)->color = (enum __anonenum_color_68 )1;
          }
          {
#line 492
          sib->color = (enum __anonenum_color_68 )0;
#line 493
          __mm_rotate_left___2(sib);
#line 494
          sib = parent->left;
          }
        }
#line 497
        sib->color = parent->color;
#line 498
        parent->color = (enum __anonenum_color_68 )1;
#line 499
        if (sib->left) {
#line 500
          (sib->left)->color = (enum __anonenum_color_68 )1;
        }
        {
#line 501
        __mm_rotate_right___2(parent);
#line 502
        child = mm_root___2;
        }
#line 503
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 508
  if (child) {
#line 509
    child->color = (enum __anonenum_color_68 )1;
  }
#line 510
  return;
}
}
#line 512 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_find_start___2(uintptr_t start , uintptr_t end ) 
{ 
  struct ibv_mem_node *node ;

  {
#line 514
  node = mm_root___2;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! node) {
#line 516
      goto while_break;
    }
#line 517
    if (node->start <= start) {
#line 517
      if (node->end >= start) {
#line 518
        goto while_break;
      }
    }
#line 520
    if (node->start < start) {
#line 521
      node = node->right;
    } else {
#line 523
      node = node->left;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 526
  return (node);
}
}
#line 529 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *merge_ranges___2(struct ibv_mem_node *node , struct ibv_mem_node *prev ) 
{ 


  {
  {
#line 532
  prev->end = node->end;
#line 533
  prev->refcnt = node->refcnt;
#line 534
  __mm_remove___2(node);
  }
#line 536
  return (prev);
}
}
#line 539 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *split_range___2(struct ibv_mem_node *node , uintptr_t cut_line ) 
{ 
  struct ibv_mem_node *new_node ;
  void *tmp ;

  {
  {
#line 542
  new_node = (struct ibv_mem_node *)((void *)0);
#line 544
  tmp = malloc(sizeof(*new_node));
#line 544
  new_node = (struct ibv_mem_node *)tmp;
  }
#line 545
  if (! new_node) {
#line 546
    return ((struct ibv_mem_node *)((void *)0));
  }
  {
#line 547
  new_node->start = cut_line;
#line 548
  new_node->end = node->end;
#line 549
  new_node->refcnt = node->refcnt;
#line 550
  node->end = cut_line - 1UL;
#line 551
  __mm_add___2(new_node);
  }
#line 553
  return (new_node);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *get_start_node___2(uintptr_t start , uintptr_t end , int inc ) 
{ 
  struct ibv_mem_node *node ;
  struct ibv_mem_node *tmp ;

  {
  {
#line 559
  tmp = (struct ibv_mem_node *)((void *)0);
#line 561
  node = __mm_find_start___2(start, end);
  }
#line 562
  if (node->start < start) {
    {
#line 563
    node = split_range___2(node, start);
    }
  } else {
    {
#line 565
    tmp = __mm_prev___2(node);
    }
#line 566
    if (tmp) {
#line 566
      if (tmp->refcnt == node->refcnt + inc) {
        {
#line 567
        node = merge_ranges___2(node, tmp);
        }
      }
    }
  }
#line 569
  return (node);
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *undo_node___2(struct ibv_mem_node *node , uintptr_t start ,
                                          int inc ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 579
  tmp = (struct ibv_mem_node *)((void *)0);
#line 585
  if (start > node->start) {
    {
#line 586
    tmp = split_range___2(node, start);
    }
#line 587
    if (tmp) {
#line 588
      node->refcnt += inc;
#line 589
      node = tmp;
    } else {
#line 591
      return ((struct ibv_mem_node *)((void *)0));
    }
  }
  {
#line 594
  tmp = __mm_prev___2(node);
  }
#line 595
  if (tmp) {
#line 595
    if (tmp->refcnt == node->refcnt) {
      {
#line 596
      node = merge_ranges___2(node, tmp);
      }
    }
  }
  {
#line 598
  tmp = __mm_next___2(node);
  }
#line 599
  if (tmp) {
#line 599
    if (tmp->refcnt == node->refcnt) {
      {
#line 600
      node = merge_ranges___2(tmp, node);
      }
    }
  }
#line 602
  return (node);
}
}
#line 605 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int ibv_madvise_range___2(void *base , size_t size , int advice ) 
{ 
  uintptr_t start ;
  uintptr_t end ;
  struct ibv_mem_node *node ;
  struct ibv_mem_node *tmp ;
  int inc ;
  int rolling_back ;
  int ret ;
  unsigned long range_page_size ;
  struct ibv_mem_node *tmp___0 ;

  {
#line 610
  rolling_back = 0;
#line 611
  ret = 0;
#line 614
  if (! size) {
#line 615
    return (0);
  }
#line 617
  if (huge_page_enabled___2) {
    {
#line 618
    range_page_size = get_page_size___2(base);
    }
  } else {
#line 620
    range_page_size = (unsigned long )page_size___4;
  }
  {
#line 622
  start = (uintptr_t )base & ~ (range_page_size - 1UL);
#line 623
  end = ((uintptr_t )(((base + size) + range_page_size) - 1) & ~ (range_page_size - 1UL)) - 1UL;
#line 626
  pthread_mutex_lock(& mm_mutex___2);
  }
  again: 
#line 628
  if (advice == 10) {
#line 628
    inc = 1;
  } else {
#line 628
    inc = -1;
  }
  {
#line 630
  node = get_start_node___2(start, end, inc);
  }
#line 631
  if (! node) {
#line 632
    ret = -1;
#line 633
    goto out;
  }
  {
#line 636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 636
    if (node) {
#line 636
      if (! (node->start <= end)) {
#line 636
        goto while_break;
      }
    } else {
#line 636
      goto while_break;
    }
#line 637
    if (node->end > end) {
      {
#line 638
      tmp___0 = split_range___2(node, end + 1UL);
      }
#line 638
      if (! tmp___0) {
#line 639
        ret = -1;
#line 640
        goto out;
      }
    }
#line 644
    if (inc == -1) {
#line 644
      if (node->refcnt == 1) {
#line 644
        goto _L;
      } else {
#line 644
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 644
    if (inc == 1) {
#line 644
      if (node->refcnt == 0) {
        _L: /* CIL Label */ 
#line 657
        if (start > node->start) {
          {
#line 658
          ret = madvise((void *)start, (node->end - start) + 1UL, advice);
          }
        } else {
          {
#line 661
          ret = madvise((void *)node->start, (node->end - node->start) + 1UL, advice);
          }
        }
#line 664
        if (ret) {
          {
#line 665
          node = undo_node___2(node, start, inc);
          }
#line 667
          if (rolling_back) {
#line 668
            goto out;
          } else
#line 667
          if (! node) {
#line 668
            goto out;
          }
#line 671
          rolling_back = 1;
#line 672
          if (advice == 10) {
#line 672
            advice = 11;
          } else {
#line 672
            advice = 10;
          }
          {
#line 674
          tmp = __mm_prev___2(node);
          }
#line 675
          if (! tmp) {
#line 676
            goto out;
          } else
#line 675
          if (start > tmp->end) {
#line 676
            goto out;
          }
#line 677
          end = tmp->end;
#line 678
          goto again;
        }
      }
    }
    {
#line 682
    node->refcnt += inc;
#line 683
    node = __mm_next___2(node);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if (node) {
    {
#line 687
    tmp = __mm_prev___2(node);
    }
#line 688
    if (tmp) {
#line 688
      if (node->refcnt == tmp->refcnt) {
        {
#line 689
        node = merge_ranges___2(node, tmp);
        }
      }
    }
  }
  out: 
#line 693
  if (rolling_back) {
#line 694
    ret = -1;
  }
  {
#line 696
  pthread_mutex_unlock(& mm_mutex___2);
  }
#line 698
  return (ret);
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
__asm__(".symver __ibv_get_device_list_1_0,ibv_get_device_list@IBVERBS_1.0");
#line 281
__asm__(".symver __ibv_free_device_list_1_0,ibv_free_device_list@IBVERBS_1.0");
#line 287
__asm__(".symver __ibv_get_device_name_1_0,ibv_get_device_name@IBVERBS_1.0");
#line 293
__asm__(".symver __ibv_get_device_guid_1_0,ibv_get_device_guid@IBVERBS_1.0");
#line 295 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int poll_cq_wrapper_1_0___2(struct ibv_cq_1_0 *cq , int num_entries , struct ibv_wc *wc ) 
{ 
  int tmp ;

  {
  {
#line 298
  tmp = (*(((cq->context)->real_context)->ops.poll_cq))(cq->real_cq, num_entries,
                                                        wc);
  }
#line 298
  return (tmp);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int req_notify_cq_wrapper_1_0___2(struct ibv_cq_1_0 *cq , int sol_only ) 
{ 
  int tmp ;

  {
  {
#line 303
  tmp = (*(((cq->context)->real_context)->ops.req_notify_cq))(cq->real_cq, sol_only);
  }
#line 303
  return (tmp);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_srq_recv_wrapper_1_0___2(struct ibv_srq_1_0 *srq , struct ibv_recv_wr_1_0 *wr ,
                                         struct ibv_recv_wr_1_0 **bad_wr ) 
{ 
  struct ibv_recv_wr_1_0 *w ;
  struct ibv_recv_wr *real_wr ;
  struct ibv_recv_wr *head_wr ;
  struct ibv_recv_wr *tail_wr ;
  struct ibv_recv_wr *real_bad_wr ;
  int ret ;
  void *tmp ;

  {
#line 310
  head_wr = (struct ibv_recv_wr *)((void *)0);
#line 310
  tail_wr = (struct ibv_recv_wr *)((void *)0);
#line 313
  w = wr;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! w) {
#line 313
      goto while_break;
    }
    {
#line 314
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 314
    real_wr = (struct ibv_recv_wr *)tmp;
#line 315
    real_wr->wr_id = w->wr_id;
#line 316
    real_wr->sg_list = w->sg_list;
#line 317
    real_wr->num_sge = w->num_sge;
#line 318
    real_wr->next = (struct ibv_recv_wr *)((void *)0);
    }
#line 319
    if (tail_wr) {
#line 320
      tail_wr->next = real_wr;
    } else {
#line 322
      head_wr = real_wr;
    }
#line 324
    tail_wr = real_wr;
#line 313
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 327
  ret = (*(((srq->context)->real_context)->ops.post_srq_recv))(srq->real_srq, head_wr,
                                                               & real_bad_wr);
  }
#line 330
  if (ret) {
#line 331
    real_wr = head_wr;
#line 331
    w = wr;
    {
#line 331
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 331
      if (! real_wr) {
#line 331
        goto while_break___0;
      }
#line 334
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 335
        *bad_wr = w;
#line 336
        goto while_break___0;
      }
#line 331
      real_wr = real_wr->next;
#line 331
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 340
  return (ret);
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_send_wrapper_1_0___2(struct ibv_qp_1_0 *qp , struct ibv_send_wr_1_0 *wr ,
                                     struct ibv_send_wr_1_0 **bad_wr ) 
{ 
  struct ibv_send_wr_1_0 *w ;
  struct ibv_send_wr *real_wr ;
  struct ibv_send_wr *head_wr ;
  struct ibv_send_wr *tail_wr ;
  struct ibv_send_wr *real_bad_wr ;
  int is_ud ;
  int ret ;
  void *tmp ;

  {
#line 347
  head_wr = (struct ibv_send_wr *)((void *)0);
#line 347
  tail_wr = (struct ibv_send_wr *)((void *)0);
#line 348
  is_ud = (unsigned int )qp->qp_type == 4U;
#line 351
  w = wr;
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! w) {
#line 351
      goto while_break;
    }
    {
#line 352
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 352
    real_wr = (struct ibv_send_wr *)tmp;
#line 353
    real_wr->wr_id = w->wr_id;
#line 354
    real_wr->next = (struct ibv_send_wr *)((void *)0);
    }
#line 363
    if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->sg_list)) {
      {
#line 364
      memcpy((void */* __restrict  */)(& real_wr->sg_list), (void const   */* __restrict  */)(& w->sg_list),
             sizeof(*real_wr) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list));
      }
    } else
#line 366
    if ((unsigned long )(& ((struct ibv_send_wr *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list) == (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->sg_list)) {
#line 366
      if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->wr) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->wr)) {
        {
#line 371
        memcpy((void */* __restrict  */)(& real_wr->sg_list), (void const   */* __restrict  */)(& w->sg_list),
               ((unsigned long )(& ((struct ibv_send_wr *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list)) + sizeof(real_wr->imm_data));
#line 375
        memcpy((void */* __restrict  */)(& real_wr->wr), (void const   */* __restrict  */)(& w->wr),
               sizeof(real_wr->wr));
        }
      } else {
#line 366
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 377
      real_wr->sg_list = w->sg_list;
#line 378
      real_wr->num_sge = w->num_sge;
#line 379
      real_wr->opcode = w->opcode;
#line 380
      real_wr->send_flags = w->send_flags;
#line 381
      real_wr->imm_data = w->imm_data;
#line 382
      if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->wr) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->wr)) {
        {
#line 383
        memcpy((void */* __restrict  */)(& real_wr->wr), (void const   */* __restrict  */)(& w->wr),
               sizeof(real_wr->wr));
        }
      } else {
#line 386
        real_wr->wr.atomic.remote_addr = w->wr.atomic.remote_addr;
#line 388
        real_wr->wr.atomic.compare_add = w->wr.atomic.compare_add;
#line 390
        real_wr->wr.atomic.swap = w->wr.atomic.swap;
#line 392
        real_wr->wr.atomic.rkey = w->wr.atomic.rkey;
      }
    }
#line 397
    if (is_ud) {
#line 398
      real_wr->wr.ud.ah = (w->wr.ud.ah)->real_ah;
    }
#line 400
    if (tail_wr) {
#line 401
      tail_wr->next = real_wr;
    } else {
#line 403
      head_wr = real_wr;
    }
#line 405
    tail_wr = real_wr;
#line 351
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 408
  ret = (*(((qp->context)->real_context)->ops.post_send))(qp->real_qp, head_wr, & real_bad_wr);
  }
#line 411
  if (ret) {
#line 412
    real_wr = head_wr;
#line 412
    w = wr;
    {
#line 412
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 412
      if (! real_wr) {
#line 412
        goto while_break___0;
      }
#line 415
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 416
        *bad_wr = w;
#line 417
        goto while_break___0;
      }
#line 412
      real_wr = real_wr->next;
#line 412
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 421
  return (ret);
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_recv_wrapper_1_0___2(struct ibv_qp_1_0 *qp , struct ibv_recv_wr_1_0 *wr ,
                                     struct ibv_recv_wr_1_0 **bad_wr ) 
{ 
  struct ibv_recv_wr_1_0 *w ;
  struct ibv_recv_wr *real_wr ;
  struct ibv_recv_wr *head_wr ;
  struct ibv_recv_wr *tail_wr ;
  struct ibv_recv_wr *real_bad_wr ;
  int ret ;
  void *tmp ;

  {
#line 428
  head_wr = (struct ibv_recv_wr *)((void *)0);
#line 428
  tail_wr = (struct ibv_recv_wr *)((void *)0);
#line 431
  w = wr;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! w) {
#line 431
      goto while_break;
    }
    {
#line 432
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 432
    real_wr = (struct ibv_recv_wr *)tmp;
#line 433
    real_wr->wr_id = w->wr_id;
#line 434
    real_wr->sg_list = w->sg_list;
#line 435
    real_wr->num_sge = w->num_sge;
#line 436
    real_wr->next = (struct ibv_recv_wr *)((void *)0);
    }
#line 437
    if (tail_wr) {
#line 438
      tail_wr->next = real_wr;
    } else {
#line 440
      head_wr = real_wr;
    }
#line 442
    tail_wr = real_wr;
#line 431
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 445
  ret = (*(((qp->context)->real_context)->ops.post_recv))(qp->real_qp, head_wr, & real_bad_wr);
  }
#line 448
  if (ret) {
#line 449
    real_wr = head_wr;
#line 449
    w = wr;
    {
#line 449
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 449
      if (! real_wr) {
#line 449
        goto while_break___0;
      }
#line 452
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 453
        *bad_wr = w;
#line 454
        goto while_break___0;
      }
#line 449
      real_wr = real_wr->next;
#line 449
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 458
  return (ret);
}
}
#line 487
__asm__(".symver __ibv_open_device_1_0,ibv_open_device@IBVERBS_1.0");
#line 500
__asm__(".symver __ibv_close_device_1_0,ibv_close_device@IBVERBS_1.0");
#line 538
__asm__(".symver __ibv_get_async_event_1_0,ibv_get_async_event@IBVERBS_1.0");
#line 574
__asm__(".symver __ibv_ack_async_event_1_0,ibv_ack_async_event@IBVERBS_1.0");
#line 581
__asm__(".symver __ibv_query_device_1_0,ibv_query_device@IBVERBS_1.0");
#line 588
__asm__(".symver __ibv_query_port_1_0,ibv_query_port@IBVERBS_1.0");
#line 595
__asm__(".symver __ibv_query_gid_1_0,ibv_query_gid@IBVERBS_1.0");
#line 602
__asm__(".symver __ibv_query_pkey_1_0,ibv_query_pkey@IBVERBS_1.0");
#line 624
__asm__(".symver __ibv_alloc_pd_1_0,ibv_alloc_pd@IBVERBS_1.0");
#line 637
__asm__(".symver __ibv_dealloc_pd_1_0,ibv_dealloc_pd@IBVERBS_1.0");
#line 663
__asm__(".symver __ibv_reg_mr_1_0,ibv_reg_mr@IBVERBS_1.0");
#line 676
__asm__(".symver __ibv_dereg_mr_1_0,ibv_dereg_mr@IBVERBS_1.0");
#line 706
__asm__(".symver __ibv_create_cq_1_0,ibv_create_cq@IBVERBS_1.0");
#line 712
__asm__(".symver __ibv_resize_cq_1_0,ibv_resize_cq@IBVERBS_1.0");
#line 725
__asm__(".symver __ibv_destroy_cq_1_0,ibv_destroy_cq@IBVERBS_1.0");
#line 743
__asm__(".symver __ibv_get_cq_event_1_0,ibv_get_cq_event@IBVERBS_1.0");
#line 749
__asm__(".symver __ibv_ack_cq_events_1_0,ibv_ack_cq_events@IBVERBS_1.0");
#line 776
__asm__(".symver __ibv_create_srq_1_0,ibv_create_srq@IBVERBS_1.0");
#line 784
__asm__(".symver __ibv_modify_srq_1_0,ibv_modify_srq@IBVERBS_1.0");
#line 790
__asm__(".symver __ibv_query_srq_1_0,ibv_query_srq@IBVERBS_1.0");
#line 803
__asm__(".symver __ibv_destroy_srq_1_0,ibv_destroy_srq@IBVERBS_1.0");
#line 847
__asm__(".symver __ibv_create_qp_1_0,ibv_create_qp@IBVERBS_1.0");
#line 870
__asm__(".symver __ibv_query_qp_1_0,ibv_query_qp@IBVERBS_1.0");
#line 877
__asm__(".symver __ibv_modify_qp_1_0,ibv_modify_qp@IBVERBS_1.0");
#line 890
__asm__(".symver __ibv_destroy_qp_1_0,ibv_destroy_qp@IBVERBS_1.0");
#line 914
__asm__(".symver __ibv_create_ah_1_0,ibv_create_ah@IBVERBS_1.0");
#line 927
__asm__(".symver __ibv_destroy_ah_1_0,ibv_destroy_ah@IBVERBS_1.0");
#line 933
__asm__(".symver __ibv_attach_mcast_1_0,ibv_attach_mcast@IBVERBS_1.0");
#line 939
__asm__(".symver __ibv_detach_mcast_1_0,ibv_detach_mcast@IBVERBS_1.0");
#line 400 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
static int ibv_cmd_modify_srq_v3___2(struct ibv_srq *srq , struct ibv_srq_attr *srq_attr ,
                                     int srq_attr_mask , struct ibv_modify_srq *new_cmd ,
                                     size_t new_cmd_size ) 
{ 
  struct ibv_modify_srq_v3 *cmd ;
  size_t cmd_size ;
  void *tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 409
  cmd_size = (sizeof(*cmd) + new_cmd_size) - sizeof(*new_cmd);
#line 410
  tmp = __builtin_alloca(cmd_size);
#line 410
  cmd = (struct ibv_modify_srq_v3 *)tmp;
#line 411
  memcpy((void */* __restrict  */)(cmd->driver_data), (void const   */* __restrict  */)(new_cmd->driver_data),
         new_cmd_size - sizeof(*new_cmd));
  }
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 413
      cmd->command = (__u32 )33;
    } else {
#line 413
      cmd->command = (__u32 )35;
    }
#line 413
    cmd->in_words = (__u16 )(cmd_size / 4UL);
#line 413
    cmd->out_words = (__u16 )0;
#line 413
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 415
  cmd->srq_handle = srq->handle;
#line 416
  cmd->attr_mask = (__u32 )srq_attr_mask;
#line 417
  cmd->max_wr = srq_attr->max_wr;
#line 418
  cmd->srq_limit = srq_attr->srq_limit;
#line 419
  cmd->max_sge = (__u32 )0;
#line 420
  cmd->reserved = (__u32 )0;
#line 422
  tmp___1 = write((srq->context)->cmd_fd, (void const   *)cmd, cmd_size);
  }
#line 422
  if ((size_t )tmp___1 != cmd_size) {
    {
#line 423
    tmp___0 = __errno_location();
    }
#line 423
    return (*tmp___0);
  }
#line 425
  return (0);
}
}
#line 1008 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
static int ib_spec_to_kern_spec___2(struct ibv_flow_spec *ib_spec , struct ibv_kern_spec *kern_spec ) 
{ 


  {
#line 1011
  kern_spec->__annonCompField5.hdr.type = (__u32 )ib_spec->__annonCompField1.hdr.type;
  {
#line 1014
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 32U) {
#line 1014
    goto case_32;
  }
#line 1021
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 48U) {
#line 1021
    goto case_48;
  }
#line 1029
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 65U) {
#line 1029
    goto case_65;
  }
#line 1029
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 64U) {
#line 1029
    goto case_65;
  }
#line 1036
  goto switch_default;
  case_32: /* CIL Label */ 
  {
#line 1015
  kern_spec->__annonCompField5.eth.size = (__u16 )sizeof(struct ibv_kern_spec_eth );
#line 1016
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.eth.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.eth.val),
         sizeof(struct ibv_flow_eth_filter ));
#line 1018
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.eth.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.eth.mask),
         sizeof(struct ibv_flow_eth_filter ));
  }
#line 1020
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 1022
  kern_spec->__annonCompField5.ipv4.size = (__u16 )sizeof(struct ibv_kern_spec_ipv4 );
#line 1023
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.ipv4.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.ipv4.val),
         sizeof(struct ibv_flow_ipv4_filter ));
#line 1025
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.ipv4.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.ipv4.mask),
         sizeof(struct ibv_flow_ipv4_filter ));
  }
#line 1027
  goto switch_break;
  case_65: /* CIL Label */ 
  case_64: /* CIL Label */ 
  {
#line 1030
  kern_spec->__annonCompField5.tcp_udp.size = (__u16 )sizeof(struct ibv_kern_spec_tcp_udp );
#line 1031
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.tcp_udp.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.tcp_udp.val),
         sizeof(struct ibv_flow_ipv4_filter ));
#line 1033
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.tcp_udp.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.tcp_udp.mask),
         sizeof(struct ibv_flow_tcp_udp_filter ));
  }
#line 1035
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1037
  return (-22);
  switch_break: /* CIL Label */ ;
  }
#line 1039
  return (0);
}
}
#line 82 "./include/infiniband/verbs.h"
static void *__VERBS_ABI_IS_EXTENDED___2  =    (void *)((uint8_t *)((void *)0) - 1);
#line 877 "./include/infiniband/verbs.h"
__inline static struct verbs_context *verbs_get_ctx___2(struct ibv_context *ctx ) 
{ 
  struct verbs_context *tmp ;

  {
#line 879
  if ((unsigned long )ctx->abi_compat != (unsigned long )__VERBS_ABI_IS_EXTENDED___2) {
#line 879
    tmp = (struct verbs_context *)((void *)0);
  } else {
#line 879
    tmp = (struct verbs_context *)((uint8_t *)ctx - (unsigned long )(& ((struct verbs_context *)0)->context));
  }
#line 879
  return (tmp);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static pthread_once_t device_list_once___2  =    0;
#line 53 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static int num_devices___2  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static struct ibv_device **device_list___2  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static void count_devices___2(void) 
{ 
  int __attribute__((__visibility__("hidden")))  tmp ;

  {
  {
#line 58
  tmp = ibverbs_init(& device_list___2);
#line 58
  num_devices___2 = (int )tmp;
  }
#line 59
  return;
}
}
#line 89
__asm__(".symver __ibv_get_device_list,ibv_get_device_list@@IBVERBS_1.1");
#line 95
__asm__(".symver __ibv_free_device_list,ibv_free_device_list@@IBVERBS_1.1");
#line 101
__asm__(".symver __ibv_get_device_name,ibv_get_device_name@@IBVERBS_1.1");
#line 123
__asm__(".symver __ibv_get_device_guid,ibv_get_device_guid@@IBVERBS_1.1");
#line 190
__asm__(".symver __ibv_open_device,ibv_open_device@@IBVERBS_1.1");
#line 215
__asm__(".symver __ibv_close_device,ibv_close_device@@IBVERBS_1.1");
#line 258
__asm__(".symver __ibv_get_async_event,ibv_get_async_event@@IBVERBS_1.1");
#line 311
__asm__(".symver __ibv_ack_async_event,ibv_ack_async_event@@IBVERBS_1.1");
#line 47 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/sysfs.c"
static char *sysfs_path___3  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  node_type_str___3[5]  = {      (char const   */* const  */)0,      (char const   */* const  */)"InfiniBand channel adapter",      (char const   */* const  */)"InfiniBand switch",      (char const   */* const  */)"InfiniBand router", 
        (char const   */* const  */)"iWARP NIC"};
#line 52 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  port_state_str___4[6]  = {      (char const   */* const  */)"no state change (NOP)",      (char const   */* const  */)"down",      (char const   */* const  */)"init",      (char const   */* const  */)"armed", 
        (char const   */* const  */)"active",      (char const   */* const  */)"active defer"};
#line 69 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  event_type_str___3[19]  = 
#line 69
  {      (char const   */* const  */)"CQ error",      (char const   */* const  */)"local work queue catastrophic error",      (char const   */* const  */)"invalid request local work queue error",      (char const   */* const  */)"local access violation work queue error", 
        (char const   */* const  */)"communication established",      (char const   */* const  */)"send queue drained",      (char const   */* const  */)"path migrated",      (char const   */* const  */)"path migration request error", 
        (char const   */* const  */)"local catastrophic error",      (char const   */* const  */)"port active",      (char const   */* const  */)"port error",      (char const   */* const  */)"LID change", 
        (char const   */* const  */)"P_Key change",      (char const   */* const  */)"SM change",      (char const   */* const  */)"SRQ catastrophic error",      (char const   */* const  */)"SRQ limit reached", 
        (char const   */* const  */)"last WQE reached",      (char const   */* const  */)"client reregistration",      (char const   */* const  */)"GID table change"};
#line 99 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  wc_status_str___3[22]  = 
#line 99
  {      (char const   */* const  */)"success",      (char const   */* const  */)"local length error",      (char const   */* const  */)"local QP operation error",      (char const   */* const  */)"local EE context operation error", 
        (char const   */* const  */)"local protection error",      (char const   */* const  */)"Work Request Flushed Error",      (char const   */* const  */)"memory management operation error",      (char const   */* const  */)"bad response error", 
        (char const   */* const  */)"local access error",      (char const   */* const  */)"remote invalid request error",      (char const   */* const  */)"remote access error",      (char const   */* const  */)"remote operation error", 
        (char const   */* const  */)"transport retry counter exceeded",      (char const   */* const  */)"RNR retry counter exceeded",      (char const   */* const  */)"local RDD violation error",      (char const   */* const  */)"remote invalid RD request", 
        (char const   */* const  */)"aborted error",      (char const   */* const  */)"invalid EE context number",      (char const   */* const  */)"invalid EE context state",      (char const   */* const  */)"fatal error", 
        (char const   */* const  */)"response timeout error",      (char const   */* const  */)"general error"};
#line 132 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
__asm__(".symver __ibv_query_device,ibv_query_device@@IBVERBS_1.1");
#line 139
__asm__(".symver __ibv_query_port,ibv_query_port@@IBVERBS_1.1");
#line 164
__asm__(".symver __ibv_query_gid,ibv_query_gid@@IBVERBS_1.1");
#line 185
__asm__(".symver __ibv_query_pkey,ibv_query_pkey@@IBVERBS_1.1");
#line 197
__asm__(".symver __ibv_alloc_pd,ibv_alloc_pd@@IBVERBS_1.1");
#line 203
__asm__(".symver __ibv_dealloc_pd,ibv_dealloc_pd@@IBVERBS_1.1");
#line 224
__asm__(".symver __ibv_reg_mr,ibv_reg_mr@@IBVERBS_1.1");
#line 238
__asm__(".symver __ibv_dereg_mr,ibv_dereg_mr@@IBVERBS_1.1");
#line 243 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int warned___3  ;
#line 240 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static struct ibv_comp_channel *ibv_create_comp_channel_v2___3(struct ibv_context *context ) 
{ 
  struct ibv_abi_compat_v2 *t ;
  int tmp ;

  {
  {
#line 242
  t = (struct ibv_abi_compat_v2 *)context->abi_compat;
#line 245
  tmp = pthread_mutex_trylock(& t->in_use);
  }
#line 245
  if (! tmp) {
#line 246
    return (& t->channel);
  }
#line 248
  if (! warned___3) {
    {
#line 249
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: kernel\'s ABI version %d limits capacity.\n    Only one completion channel can be created per context.\n",
            abi_ver);
#line 252
    warned___3 ++;
    }
  }
#line 255
  return ((struct ibv_comp_channel *)((void *)0));
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int ibv_destroy_comp_channel_v2___3(struct ibv_comp_channel *channel ) 
{ 
  struct ibv_abi_compat_v2 *t ;

  {
  {
#line 288
  t = (struct ibv_abi_compat_v2 *)channel;
#line 289
  pthread_mutex_unlock(& t->in_use);
  }
#line 290
  return (0);
}
}
#line 346
__asm__(".symver __ibv_create_cq,ibv_create_cq@@IBVERBS_1.1");
#line 355
__asm__(".symver __ibv_resize_cq,ibv_resize_cq@@IBVERBS_1.1");
#line 375
__asm__(".symver __ibv_destroy_cq,ibv_destroy_cq@@IBVERBS_1.1");
#line 393
__asm__(".symver __ibv_get_cq_event,ibv_get_cq_event@@IBVERBS_1.1");
#line 402
__asm__(".symver __ibv_ack_cq_events,ibv_ack_cq_events@@IBVERBS_1.1");
#line 424
__asm__(".symver __ibv_create_srq,ibv_create_srq@@IBVERBS_1.1");
#line 432
__asm__(".symver __ibv_modify_srq,ibv_modify_srq@@IBVERBS_1.1");
#line 438
__asm__(".symver __ibv_query_srq,ibv_query_srq@@IBVERBS_1.1");
#line 444
__asm__(".symver __ibv_destroy_srq,ibv_destroy_srq@@IBVERBS_1.1");
#line 467
__asm__(".symver __ibv_create_qp,ibv_create_qp@@IBVERBS_1.1");
#line 484
__asm__(".symver __ibv_query_qp,ibv_query_qp@@IBVERBS_1.1");
#line 500
__asm__(".symver __ibv_modify_qp,ibv_modify_qp@@IBVERBS_1.1");
#line 506
__asm__(".symver __ibv_destroy_qp,ibv_destroy_qp@@IBVERBS_1.1");
#line 519
__asm__(".symver __ibv_create_ah,ibv_create_ah@@IBVERBS_1.1");
#line 521 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int ibv_find_gid_index___3(struct ibv_context *context , uint8_t port_num ,
                                  union ibv_gid *gid ) 
{ 
  union ibv_gid sgid ;
  int i ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 525
  i = 0;
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 528
    tmp = i;
#line 528
    i ++;
#line 528
    ret = ibv_query_gid(context, port_num, tmp, & sgid);
    }
#line 527
    if (! ret) {
      {
#line 527
      tmp___0 = memcmp((void const   *)(& sgid), (void const   *)gid, sizeof(*gid));
      }
#line 527
      if (! tmp___0) {
#line 527
        goto while_break;
      }
    } else {
#line 527
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 531
  if (ret) {
#line 531
    tmp___1 = ret;
  } else {
#line 531
    tmp___1 = i - 1;
  }
#line 531
  return (tmp___1);
}
}
#line 581
__asm__(".symver __ibv_destroy_ah,ibv_destroy_ah@@IBVERBS_1.1");
#line 587
__asm__(".symver __ibv_attach_mcast,ibv_attach_mcast@@IBVERBS_1.1");
#line 593
__asm__(".symver __ibv_detach_mcast,ibv_detach_mcast@@IBVERBS_1.1");
#line 77 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_sysfs_dev *sysfs_dev_list___3  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver_name *driver_name_list___3  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver *head_driver___3  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver *tail_driver___3  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static int find_sysfs_devs___3(void) 
{ 
  char class_path[256] ;
  DIR *class_dir ;
  struct dirent *dent ;
  struct ibv_sysfs_dev *sysfs_dev ;
  char value[8] ;
  int ret ;
  char const   *tmp ;
  struct stat buf ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;

  {
  {
#line 86
  sysfs_dev = (struct ibv_sysfs_dev *)((void *)0);
#line 88
  ret = 0;
#line 90
  tmp = ibv_get_sysfs_path();
#line 90
  snprintf((char */* __restrict  */)(class_path), sizeof(class_path), (char const   */* __restrict  */)"%s/class/infiniband_verbs",
           tmp);
#line 93
  class_dir = opendir((char const   *)(class_path));
  }
#line 94
  if (! class_dir) {
#line 95
    return (38);
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    dent = readdir(class_dir);
    }
#line 97
    if (! dent) {
#line 97
      goto while_break;
    }
#line 100
    if ((int )dent->d_name[0] == 46) {
#line 101
      goto while_continue;
    }
#line 103
    if (! sysfs_dev) {
      {
#line 104
      tmp___0 = malloc(sizeof(*sysfs_dev));
#line 104
      sysfs_dev = (struct ibv_sysfs_dev *)tmp___0;
      }
    }
#line 105
    if (! sysfs_dev) {
#line 106
      ret = 12;
#line 107
      goto out;
    }
    {
#line 110
    snprintf((char */* __restrict  */)(sysfs_dev->sysfs_path), sizeof(sysfs_dev->sysfs_path),
             (char const   */* __restrict  */)"%s/%s", class_path, dent->d_name);
#line 113
    tmp___1 = stat((char const   */* __restrict  */)(sysfs_dev->sysfs_path), (struct stat */* __restrict  */)(& buf));
    }
#line 113
    if (tmp___1) {
      {
#line 114
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t stat \'%s\'.\n",
              sysfs_dev->sysfs_path);
      }
#line 116
      goto while_continue;
    }
#line 119
    if (! ((buf.st_mode & 61440U) == 16384U)) {
#line 120
      goto while_continue;
    }
    {
#line 122
    snprintf((char */* __restrict  */)(sysfs_dev->sysfs_name), sizeof(sysfs_dev->sysfs_name),
             (char const   */* __restrict  */)"%s", dent->d_name);
#line 125
    tmp___2 = ibv_read_sysfs_file((char const   *)(sysfs_dev->sysfs_path), "ibdev",
                                  sysfs_dev->ibdev_name, sizeof(sysfs_dev->ibdev_name));
    }
#line 125
    if (tmp___2 < 0) {
      {
#line 128
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: no ibdev class attr for \'%s\'.\n",
              dent->d_name);
      }
#line 130
      goto while_continue;
    }
    {
#line 133
    tmp___3 = ibv_get_sysfs_path();
#line 133
    snprintf((char */* __restrict  */)(sysfs_dev->ibdev_path), sizeof(sysfs_dev->ibdev_path),
             (char const   */* __restrict  */)"%s/class/infiniband/%s", tmp___3, sysfs_dev->ibdev_name);
#line 137
    sysfs_dev->next = sysfs_dev_list___3;
#line 138
    sysfs_dev->have_driver = 0;
#line 139
    tmp___5 = ibv_read_sysfs_file((char const   *)(sysfs_dev->sysfs_path), "abi_version",
                                  value, sizeof(value));
    }
#line 139
    if (tmp___5 > 0) {
      {
#line 141
      tmp___4 = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                       10);
#line 141
      sysfs_dev->abi_ver = (int )tmp___4;
      }
    } else {
#line 143
      sysfs_dev->abi_ver = 0;
    }
#line 145
    sysfs_dev_list___3 = sysfs_dev;
#line 146
    sysfs_dev = (struct ibv_sysfs_dev *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
  out: 
#line 150
  if (sysfs_dev) {
    {
#line 151
    free((void *)sysfs_dev);
    }
  }
  {
#line 153
  closedir(class_dir);
  }
#line 154
  return (ret);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void register_driver___3(char const   *name , struct ibv_device *(*init_func)(char const   *uverbs_sys_path ,
                                                                                     int abi_version ) ,
                                struct verbs_device *(*verbs_init_func)(char const   *uverbs_sys_path ,
                                                                        int abi_version ) ) 
{ 
  struct ibv_driver *driver ;
  void *tmp ;

  {
  {
#line 162
  tmp = malloc(sizeof(*driver));
#line 162
  driver = (struct ibv_driver *)tmp;
  }
#line 163
  if (! driver) {
    {
#line 164
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver for %s\n",
            name);
    }
#line 165
    return;
  }
#line 168
  driver->name = name;
#line 169
  driver->init_func = init_func;
#line 170
  driver->verbs_init_func = verbs_init_func;
#line 171
  driver->next = (struct ibv_driver *)((void *)0);
#line 173
  if (tail_driver___3) {
#line 174
    tail_driver___3->next = driver;
  } else {
#line 176
    head_driver___3 = driver;
  }
#line 177
  tail_driver___3 = driver;
#line 178
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void load_driver___3(char const   *name ) 
{ 
  char *so_name ;
  void *dlhandle ;
  char const   *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 201
  if ((int const   )*(name + 0) == 47) {
#line 201
    tmp = "%s-rdmav2.so";
  } else {
#line 201
    tmp = "lib%s-rdmav2.so";
  }
  {
#line 201
  tmp___0 = asprintf((char **/* __restrict  */)(& so_name), (char const   */* __restrict  */)tmp,
                     name);
  }
#line 201
  if (tmp___0 < 0) {
    {
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t load driver \'%s\'.\n",
            name);
    }
#line 208
    return;
  }
  {
#line 211
  dlhandle = dlopen((char const   *)so_name, 2);
  }
#line 212
  if (! dlhandle) {
    {
#line 213
    tmp___1 = dlerror();
#line 213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t load driver \'%s\': %s\n",
            name, tmp___1);
    }
#line 215
    goto out;
  }
  out: 
  {
#line 219
  free((void *)so_name);
  }
#line 220
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void load_drivers___3(void) 
{ 
  struct ibv_driver_name *name ;
  struct ibv_driver_name *next_name ;
  char const   *env ;
  char *list ;
  char *env_name ;
  char const   *__old ;
  size_t __len ;
  size_t tmp ;
  char *__new ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *__old___0 ;
  size_t __len___0 ;
  size_t tmp___2 ;
  char *__new___0 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;

  {
  {
#line 232
  tmp___7 = getuid();
#line 232
  tmp___8 = geteuid();
  }
#line 232
  if (tmp___7 == tmp___8) {
    {
#line 233
    tmp___6 = getenv("RDMAV_DRIVERS");
#line 233
    env = (char const   *)tmp___6;
    }
#line 233
    if (env) {
      {
#line 234
      __old = env;
#line 234
      tmp = strlen(__old);
#line 234
      __len = tmp + 1UL;
#line 234
      tmp___0 = __builtin_alloca(__len);
#line 234
      __new = (char *)tmp___0;
#line 234
      tmp___1 = memcpy((void */* __restrict  */)__new, (void const   */* __restrict  */)__old,
                       __len);
#line 234
      list = (char *)tmp___1;
      }
      {
#line 235
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 235
        env_name = strsep((char **/* __restrict  */)(& list), (char const   */* __restrict  */)":;");
        }
#line 235
        if (! env_name) {
#line 235
          goto while_break;
        }
        {
#line 236
        load_driver___3((char const   *)env_name);
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 237
      tmp___5 = getenv("IBV_DRIVERS");
#line 237
      env = (char const   *)tmp___5;
      }
#line 237
      if (env) {
        {
#line 238
        __old___0 = env;
#line 238
        tmp___2 = strlen(__old___0);
#line 238
        __len___0 = tmp___2 + 1UL;
#line 238
        tmp___3 = __builtin_alloca(__len___0);
#line 238
        __new___0 = (char *)tmp___3;
#line 238
        tmp___4 = memcpy((void */* __restrict  */)__new___0, (void const   */* __restrict  */)__old___0,
                         __len___0);
#line 238
        list = (char *)tmp___4;
        }
        {
#line 239
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 239
          env_name = strsep((char **/* __restrict  */)(& list), (char const   */* __restrict  */)":;");
          }
#line 239
          if (! env_name) {
#line 239
            goto while_break___0;
          }
          {
#line 240
          load_driver___3((char const   *)env_name);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 244
  name = driver_name_list___3;
#line 244
  if (name) {
#line 244
    next_name = name->next;
  } else {
#line 244
    next_name = (struct ibv_driver_name *)((void *)0);
  }
  {
#line 244
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 244
    if (! name) {
#line 244
      goto while_break___1;
    }
    {
#line 247
    load_driver___3((char const   *)name->name);
#line 248
    free((void *)name->name);
#line 249
    free((void *)name);
#line 244
    name = next_name;
    }
#line 244
    if (name) {
#line 244
      next_name = name->next;
    } else {
#line 244
      next_name = (struct ibv_driver_name *)((void *)0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 251
  return;
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void read_config_file___3(char const   *path ) 
{ 
  FILE *conf ;
  char *line ;
  char *config ;
  char *field ;
  size_t buflen ;
  ssize_t len ;
  size_t tmp ;
  struct ibv_driver_name *driver_name ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 256
  line = (char *)((void *)0);
#line 259
  buflen = (size_t )0;
#line 262
  conf = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"re");
  }
#line 263
  if (! conf) {
    {
#line 264
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t read config file %s.\n",
            path);
    }
#line 266
    return;
  }
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 269
    len = getline((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& buflen),
                  (FILE */* __restrict  */)conf);
    }
#line 269
    if (! (len != -1L)) {
#line 269
      goto while_break;
    }
    {
#line 270
    tmp = strspn((char const   *)line, "\t ");
#line 270
    config = line + tmp;
    }
#line 271
    if ((int )*(config + 0) == 10) {
#line 272
      goto while_continue;
    } else
#line 271
    if ((int )*(config + 0) == 35) {
#line 272
      goto while_continue;
    }
    {
#line 274
    field = strsep((char **/* __restrict  */)(& config), (char const   */* __restrict  */)"\n\t ");
#line 276
    tmp___2 = strcmp((char const   *)field, "driver");
    }
#line 276
    if (tmp___2 == 0) {
#line 276
      if ((unsigned long )config != (unsigned long )((void *)0)) {
        {
#line 279
        tmp___0 = strspn((char const   *)config, "\t ");
#line 279
        config += tmp___0;
#line 280
        field = strsep((char **/* __restrict  */)(& config), (char const   */* __restrict  */)"\n\t ");
#line 282
        tmp___1 = malloc(sizeof(*driver_name));
#line 282
        driver_name = (struct ibv_driver_name *)tmp___1;
        }
#line 283
        if (! driver_name) {
          {
#line 284
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver name \'%s\'.\n",
                  field);
          }
#line 286
          goto while_continue;
        }
        {
#line 289
        driver_name->name = strdup((char const   *)field);
        }
#line 290
        if (! driver_name->name) {
          {
#line 291
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver name \'%s\'.\n",
                  field);
#line 293
          free((void *)driver_name);
          }
#line 294
          goto while_continue;
        }
#line 297
        driver_name->next = driver_name_list___3;
#line 298
        driver_name_list___3 = driver_name;
      } else {
        {
#line 300
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: ignoring bad config directive \'%s\' in file \'%s\'.\n",
                field, path);
        }
      }
    } else {
      {
#line 300
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: ignoring bad config directive \'%s\' in file \'%s\'.\n",
              field, path);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  if (line) {
    {
#line 305
    free((void *)line);
    }
  }
  {
#line 306
  fclose(conf);
  }
#line 307
  return;
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void read_config___3(void) 
{ 
  DIR *conf_dir ;
  struct dirent *dent ;
  char *path ;
  struct stat buf ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 315
  conf_dir = opendir("/usr/local/etc/libibverbs.d");
  }
#line 316
  if (! conf_dir) {
    {
#line 317
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t open config directory \'%s\'.\n",
            "/usr/local/etc/libibverbs.d");
    }
#line 319
    return;
  }
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 322
    dent = readdir(conf_dir);
    }
#line 322
    if (! dent) {
#line 322
      goto while_break;
    }
    {
#line 325
    tmp = asprintf((char **/* __restrict  */)(& path), (char const   */* __restrict  */)"%s/%s",
                   "/usr/local/etc/libibverbs.d", dent->d_name);
    }
#line 325
    if (tmp < 0) {
      {
#line 326
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t read config file %s/%s.\n",
              "/usr/local/etc/libibverbs.d", dent->d_name);
      }
#line 328
      goto out;
    }
    {
#line 331
    tmp___0 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& buf));
    }
#line 331
    if (tmp___0) {
      {
#line 332
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t stat config file \'%s\'.\n",
              path);
      }
#line 334
      goto next;
    }
#line 337
    if (! ((buf.st_mode & 61440U) == 32768U)) {
#line 338
      goto next;
    }
    {
#line 340
    read_config_file___3((char const   *)path);
    }
    next: 
    {
#line 342
    free((void *)path);
    }
  }
  while_break: /* CIL Label */ ;
  }
  out: 
  {
#line 346
  closedir(conf_dir);
  }
#line 347
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_device *try_driver___3(struct ibv_driver *driver , struct ibv_sysfs_dev *sysfs_dev ) 
{ 
  struct verbs_device *vdev ;
  struct ibv_device *dev ;
  char value[8] ;
  long tmp ;
  int tmp___0 ;

  {
#line 356
  if (driver->init_func) {
    {
#line 357
    dev = (*(driver->init_func))((char const   *)(sysfs_dev->sysfs_path), sysfs_dev->abi_ver);
    }
#line 358
    if (! dev) {
#line 359
      return ((struct ibv_device *)((void *)0));
    }
  } else {
    {
#line 361
    vdev = (*(driver->verbs_init_func))((char const   *)(sysfs_dev->sysfs_path), sysfs_dev->abi_ver);
    }
#line 362
    if (! vdev) {
#line 363
      return ((struct ibv_device *)((void *)0));
    }
#line 365
    dev = & vdev->device;
#line 366
    dev->ops.alloc_context = (struct ibv_context *(*)(struct ibv_device *device ,
                                                      int cmd_fd ))((void *)0);
#line 367
    dev->ops.free_context = (void (*)(struct ibv_context *context ))((void *)0);
  }
  {
#line 370
  tmp___0 = ibv_read_sysfs_file((char const   *)(sysfs_dev->ibdev_path), "node_type",
                                value, sizeof(value));
  }
#line 370
  if (tmp___0 < 0) {
    {
#line 371
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: no node_type attr under %s.\n",
            sysfs_dev->ibdev_path);
#line 373
    dev->node_type = (enum ibv_node_type )-1;
    }
  } else {
    {
#line 375
    tmp = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                 10);
#line 375
    dev->node_type = (enum ibv_node_type )tmp;
    }
#line 376
    if ((int )dev->node_type < 1) {
#line 377
      dev->node_type = (enum ibv_node_type )-1;
    } else
#line 376
    if ((int )dev->node_type > 4) {
#line 377
      dev->node_type = (enum ibv_node_type )-1;
    }
  }
  {
#line 383
  if ((int )dev->node_type == 3) {
#line 383
    goto case_3;
  }
#line 383
  if ((int )dev->node_type == 2) {
#line 383
    goto case_3;
  }
#line 383
  if ((int )dev->node_type == 1) {
#line 383
    goto case_3;
  }
#line 386
  if ((int )dev->node_type == 4) {
#line 386
    goto case_4;
  }
#line 389
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 384
  dev->transport_type = (enum ibv_transport_type )0;
#line 385
  goto switch_break;
  case_4: /* CIL Label */ 
#line 387
  dev->transport_type = (enum ibv_transport_type )1;
#line 388
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 390
  dev->transport_type = (enum ibv_transport_type )-1;
#line 391
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 394
  strcpy((char */* __restrict  */)(dev->dev_name), (char const   */* __restrict  */)(sysfs_dev->sysfs_name));
#line 395
  strcpy((char */* __restrict  */)(dev->dev_path), (char const   */* __restrict  */)(sysfs_dev->sysfs_path));
#line 396
  strcpy((char */* __restrict  */)(dev->name), (char const   */* __restrict  */)(sysfs_dev->ibdev_name));
#line 397
  strcpy((char */* __restrict  */)(dev->ibdev_path), (char const   */* __restrict  */)(sysfs_dev->ibdev_path));
  }
#line 399
  return (dev);
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_device *try_drivers___3(struct ibv_sysfs_dev *sysfs_dev ) 
{ 
  struct ibv_driver *driver ;
  struct ibv_device *dev ;

  {
#line 407
  driver = head_driver___3;
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 407
    if (! driver) {
#line 407
      goto while_break;
    }
    {
#line 408
    dev = try_driver___3(driver, sysfs_dev);
    }
#line 409
    if (dev) {
#line 410
      return (dev);
    }
#line 407
    driver = driver->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 413
  return ((struct ibv_device *)((void *)0));
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static int check_abi_version___3(char const   *path ) 
{ 
  char value[8] ;
  int tmp ;
  long tmp___0 ;

  {
  {
#line 420
  tmp = ibv_read_sysfs_file(path, "class/infiniband_verbs/abi_version", value, sizeof(value));
  }
#line 420
  if (tmp < 0) {
#line 422
    return (38);
  }
  {
#line 425
  tmp___0 = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                   10);
#line 425
  abi_ver = (int __attribute__((__visibility__("hidden")))  )tmp___0;
  }
#line 427
  if (abi_ver < (int __attribute__((__visibility__("hidden")))  )3) {
    {
#line 429
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Fatal: kernel ABI version %d doesn\'t match library version %d.\n",
            abi_ver, 6);
    }
#line 432
    return (38);
  } else
#line 427
  if (abi_ver > (int __attribute__((__visibility__("hidden")))  )6) {
    {
#line 429
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Fatal: kernel ABI version %d doesn\'t match library version %d.\n",
            abi_ver, 6);
    }
#line 432
    return (38);
  }
#line 435
  return (0);
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void check_memlock_limit___3(void) 
{ 
  struct rlimit rlim ;
  __uid_t tmp ;
  int tmp___0 ;

  {
  {
#line 442
  tmp = geteuid();
  }
#line 442
  if (! tmp) {
#line 443
    return;
  }
  {
#line 445
  tmp___0 = getrlimit((__rlimit_resource_t )8, & rlim);
  }
#line 445
  if (tmp___0) {
    {
#line 446
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: getrlimit(RLIMIT_MEMLOCK) failed.");
    }
#line 447
    return;
  }
#line 450
  if (rlim.rlim_cur <= 32768UL) {
    {
#line 451
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: RLIMIT_MEMLOCK is %lu bytes.\n    This will severely limit memory registrations.\n",
            rlim.rlim_cur);
    }
  }
#line 454
  return;
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void add_device___3(struct ibv_device *dev , struct ibv_device ***dev_list ,
                           int *num_devices___7 , int *list_size ) 
{ 
  struct ibv_device **new_list ;
  void *tmp ;
  int tmp___0 ;

  {
#line 463
  if (*list_size <= *num_devices___7) {
#line 464
    if (*list_size) {
#line 464
      *list_size *= 2;
    } else {
#line 464
      *list_size = 1;
    }
    {
#line 465
    tmp = realloc((void *)*dev_list, (unsigned long )*list_size * sizeof(struct ibv_device *));
#line 465
    new_list = (struct ibv_device **)tmp;
    }
#line 466
    if (! new_list) {
#line 467
      return;
    }
#line 468
    *dev_list = new_list;
  }
#line 471
  tmp___0 = *num_devices___7;
#line 471
  (*num_devices___7) ++;
#line 471
  *(*dev_list + tmp___0) = dev;
#line 472
  return;
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/asyncwatch.c"
static char const   *event_name_str(enum ibv_event_type event_type ) 
{ 


  {
  {
#line 46
  if ((unsigned int )event_type == 8U) {
#line 46
    goto case_8;
  }
#line 48
  if ((unsigned int )event_type == 9U) {
#line 48
    goto case_9;
  }
#line 50
  if ((unsigned int )event_type == 10U) {
#line 50
    goto case_10;
  }
#line 52
  if ((unsigned int )event_type == 11U) {
#line 52
    goto case_11;
  }
#line 54
  if ((unsigned int )event_type == 12U) {
#line 54
    goto case_12;
  }
#line 56
  if ((unsigned int )event_type == 13U) {
#line 56
    goto case_13;
  }
#line 58
  if ((unsigned int )event_type == 17U) {
#line 58
    goto case_17;
  }
#line 60
  if ((unsigned int )event_type == 18U) {
#line 60
    goto case_18;
  }
#line 74
  goto switch_default;
  case_8: /* CIL Label */ 
#line 47
  return ("IBV_EVENT_DEVICE_FATAL");
  case_9: /* CIL Label */ 
#line 49
  return ("IBV_EVENT_PORT_ACTIVE");
  case_10: /* CIL Label */ 
#line 51
  return ("IBV_EVENT_PORT_ERR");
  case_11: /* CIL Label */ 
#line 53
  return ("IBV_EVENT_LID_CHANGE");
  case_12: /* CIL Label */ 
#line 55
  return ("IBV_EVENT_PKEY_CHANGE");
  case_13: /* CIL Label */ 
#line 57
  return ("IBV_EVENT_SM_CHANGE");
  case_17: /* CIL Label */ 
#line 59
  return ("IBV_EVENT_CLIENT_REREGISTER");
  case_18: /* CIL Label */ 
#line 61
  return ("IBV_EVENT_GID_CHANGE");
  switch_default: /* CIL Label */ 
#line 75
  return ("unexpected");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *mm_root___3  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static pthread_mutex_t mm_mutex___3  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 75 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int page_size___5  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int huge_page_enabled___3  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int too_late___3  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static unsigned long smaps_page_size___3(FILE *file ) 
{ 
  int n ;
  unsigned long size ;
  char buf[1024] ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 82
  size = (unsigned long )page_size___5;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 85
    tmp___0 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)file);
    }
#line 85
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 85
      goto while_break;
    }
    {
#line 86
    tmp = strstr((char const   *)(buf), "KernelPageSize:");
    }
#line 86
    if (! tmp) {
#line 87
      goto while_continue;
    }
    {
#line 89
    n = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*s %lu",
               & size);
    }
#line 90
    if (n < 1) {
#line 91
      goto while_continue;
    }
#line 94
    size *= 1024UL;
#line 96
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return (size);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static unsigned long get_page_size___3(void *base ) 
{ 
  unsigned long ret ;
  pid_t pid ;
  FILE *file ;
  char buf[1024] ;
  int n ;
  uintptr_t range_start ;
  uintptr_t range_end ;
  char *tmp ;

  {
  {
#line 104
  ret = (unsigned long )page_size___5;
#line 109
  pid = getpid();
#line 110
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"/proc/%d/smaps",
           pid);
#line 112
  file = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"re");
  }
#line 113
  if (! file) {
#line 114
    goto out;
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 116
    tmp = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)file);
    }
#line 116
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 116
      goto while_break;
    }
    {
#line 120
    n = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%lx-%lx",
               & range_start, & range_end);
    }
#line 122
    if (n < 2) {
#line 123
      goto while_continue;
    }
#line 125
    if ((uintptr_t )base >= range_start) {
#line 125
      if ((uintptr_t )base < range_end) {
        {
#line 126
        ret = smaps_page_size___3(file);
        }
#line 127
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  fclose(file);
  }
  out: 
#line 134
  return (ret);
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_prev___3(struct ibv_mem_node *node ) 
{ 


  {
#line 194
  if (node->left) {
#line 195
    node = node->left;
    {
#line 196
    while (1) {
      while_continue: /* CIL Label */ ;
#line 196
      if (! node->right) {
#line 196
        goto while_break;
      }
#line 197
      node = node->right;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 199
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 199
      if (node->parent) {
#line 199
        if (! ((unsigned long )node == (unsigned long )(node->parent)->left)) {
#line 199
          goto while_break___0;
        }
      } else {
#line 199
        goto while_break___0;
      }
#line 200
      node = node->parent;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 202
    node = node->parent;
  }
#line 205
  return (node);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_next___3(struct ibv_mem_node *node ) 
{ 


  {
#line 210
  if (node->right) {
#line 211
    node = node->right;
    {
#line 212
    while (1) {
      while_continue: /* CIL Label */ ;
#line 212
      if (! node->left) {
#line 212
        goto while_break;
      }
#line 213
      node = node->left;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 215
      if (node->parent) {
#line 215
        if (! ((unsigned long )node == (unsigned long )(node->parent)->right)) {
#line 215
          goto while_break___0;
        }
      } else {
#line 215
        goto while_break___0;
      }
#line 216
      node = node->parent;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 218
    node = node->parent;
  }
#line 221
  return (node);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_rotate_right___3(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 228
  tmp = node->left;
#line 230
  node->left = tmp->right;
#line 231
  if (node->left) {
#line 232
    (node->left)->parent = node;
  }
#line 234
  if (node->parent) {
#line 235
    if ((unsigned long )(node->parent)->right == (unsigned long )node) {
#line 236
      (node->parent)->right = tmp;
    } else {
#line 238
      (node->parent)->left = tmp;
    }
  } else {
#line 240
    mm_root___3 = tmp;
  }
#line 242
  tmp->parent = node->parent;
#line 244
  tmp->right = node;
#line 245
  node->parent = tmp;
#line 246
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_rotate_left___3(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 252
  tmp = node->right;
#line 254
  node->right = tmp->left;
#line 255
  if (node->right) {
#line 256
    (node->right)->parent = node;
  }
#line 258
  if (node->parent) {
#line 259
    if ((unsigned long )(node->parent)->right == (unsigned long )node) {
#line 260
      (node->parent)->right = tmp;
    } else {
#line 262
      (node->parent)->left = tmp;
    }
  } else {
#line 264
    mm_root___3 = tmp;
  }
#line 266
  tmp->parent = node->parent;
#line 268
  tmp->left = node;
#line 269
  node->parent = tmp;
#line 270
  return;
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_add_rebalance___3(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *parent ;
  struct ibv_mem_node *gp ;
  struct ibv_mem_node *uncle ;

  {
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (node->parent) {
#line 304
      if (! ((unsigned int )(node->parent)->color == 0U)) {
#line 304
        goto while_break;
      }
    } else {
#line 304
      goto while_break;
    }
#line 305
    parent = node->parent;
#line 306
    gp = (node->parent)->parent;
#line 308
    if ((unsigned long )parent == (unsigned long )gp->left) {
#line 309
      uncle = gp->right;
#line 311
      if (uncle) {
#line 311
        if ((unsigned int )uncle->color == 0U) {
#line 312
          parent->color = (enum __anonenum_color_68 )1;
#line 313
          uncle->color = (enum __anonenum_color_68 )1;
#line 314
          gp->color = (enum __anonenum_color_68 )0;
#line 316
          node = gp;
        } else {
#line 311
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 318
        if ((unsigned long )node == (unsigned long )parent->right) {
          {
#line 319
          __mm_rotate_left___3(parent);
#line 320
          node = parent;
#line 321
          parent = node->parent;
          }
        }
        {
#line 324
        parent->color = (enum __anonenum_color_68 )1;
#line 325
        gp->color = (enum __anonenum_color_68 )0;
#line 327
        __mm_rotate_right___3(gp);
        }
      }
    } else {
#line 330
      uncle = gp->left;
#line 332
      if (uncle) {
#line 332
        if ((unsigned int )uncle->color == 0U) {
#line 333
          parent->color = (enum __anonenum_color_68 )1;
#line 334
          uncle->color = (enum __anonenum_color_68 )1;
#line 335
          gp->color = (enum __anonenum_color_68 )0;
#line 337
          node = gp;
        } else {
#line 332
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 339
        if ((unsigned long )node == (unsigned long )parent->left) {
          {
#line 340
          __mm_rotate_right___3(parent);
#line 341
          node = parent;
#line 342
          parent = node->parent;
          }
        }
        {
#line 345
        parent->color = (enum __anonenum_color_68 )1;
#line 346
        gp->color = (enum __anonenum_color_68 )0;
#line 348
        __mm_rotate_left___3(gp);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  mm_root___3->color = (enum __anonenum_color_68 )1;
#line 354
  return;
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_add___3(struct ibv_mem_node *new ) 
{ 
  struct ibv_mem_node *node ;
  struct ibv_mem_node *parent ;

  {
#line 358
  parent = (struct ibv_mem_node *)((void *)0);
#line 360
  node = mm_root___3;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! node) {
#line 361
      goto while_break;
    }
#line 362
    parent = node;
#line 363
    if (node->start < new->start) {
#line 364
      node = node->right;
    } else {
#line 366
      node = node->left;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  if (parent->start < new->start) {
#line 370
    parent->right = new;
  } else {
#line 372
    parent->left = new;
  }
  {
#line 374
  new->parent = parent;
#line 375
  new->left = (struct ibv_mem_node *)((void *)0);
#line 376
  new->right = (struct ibv_mem_node *)((void *)0);
#line 378
  new->color = (enum __anonenum_color_68 )0;
#line 379
  __mm_add_rebalance___3(new);
  }
#line 380
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_remove___3(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *child ;
  struct ibv_mem_node *parent ;
  struct ibv_mem_node *sib ;
  struct ibv_mem_node *tmp ;
  int nodecol ;

  {
#line 387
  if (node->left) {
#line 387
    if (node->right) {
#line 388
      tmp = node->left;
      {
#line 389
      while (1) {
        while_continue: /* CIL Label */ ;
#line 389
        if (! tmp->right) {
#line 389
          goto while_break;
        }
#line 390
        tmp = tmp->right;
      }
      while_break: /* CIL Label */ ;
      }
#line 392
      nodecol = (int )tmp->color;
#line 393
      child = tmp->left;
#line 394
      tmp->color = node->color;
#line 396
      if ((unsigned long )tmp->parent != (unsigned long )node) {
#line 397
        parent = tmp->parent;
#line 398
        parent->right = tmp->left;
#line 399
        if (tmp->left) {
#line 400
          (tmp->left)->parent = parent;
        }
#line 402
        tmp->left = node->left;
#line 403
        (node->left)->parent = tmp;
      } else {
#line 405
        parent = tmp;
      }
#line 407
      tmp->right = node->right;
#line 408
      (node->right)->parent = tmp;
#line 410
      tmp->parent = node->parent;
#line 411
      if (node->parent) {
#line 412
        if ((unsigned long )(node->parent)->left == (unsigned long )node) {
#line 413
          (node->parent)->left = tmp;
        } else {
#line 415
          (node->parent)->right = tmp;
        }
      } else {
#line 417
        mm_root___3 = tmp;
      }
    } else {
#line 387
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 419
    nodecol = (int )node->color;
#line 421
    if (node->left) {
#line 421
      child = node->left;
    } else {
#line 421
      child = node->right;
    }
#line 422
    parent = node->parent;
#line 424
    if (child) {
#line 425
      child->parent = parent;
    }
#line 426
    if (parent) {
#line 427
      if ((unsigned long )parent->left == (unsigned long )node) {
#line 428
        parent->left = child;
      } else {
#line 430
        parent->right = child;
      }
    } else {
#line 432
      mm_root___3 = child;
    }
  }
  {
#line 435
  free((void *)node);
  }
#line 437
  if (nodecol == 0) {
#line 438
    return;
  }
  {
#line 440
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 440
    if (! child) {
#line 440
      goto _L___6;
    } else
#line 440
    if ((unsigned int )child->color == 1U) {
      _L___6: /* CIL Label */ 
#line 440
      if (! ((unsigned long )child != (unsigned long )mm_root___3)) {
#line 440
        goto while_break___0;
      }
    } else {
#line 440
      goto while_break___0;
    }
#line 441
    if ((unsigned long )parent->left == (unsigned long )child) {
#line 442
      sib = parent->right;
#line 444
      if ((unsigned int )sib->color == 0U) {
        {
#line 445
        parent->color = (enum __anonenum_color_68 )0;
#line 446
        sib->color = (enum __anonenum_color_68 )1;
#line 447
        __mm_rotate_left___3(parent);
#line 448
        sib = parent->right;
        }
      }
#line 451
      if (! sib->left) {
#line 451
        goto _L___2;
      } else
#line 451
      if ((unsigned int )(sib->left)->color == 1U) {
        _L___2: /* CIL Label */ 
#line 451
        if (! sib->right) {
#line 453
          sib->color = (enum __anonenum_color_68 )0;
#line 454
          child = parent;
#line 455
          parent = child->parent;
        } else
#line 451
        if ((unsigned int )(sib->right)->color == 1U) {
#line 453
          sib->color = (enum __anonenum_color_68 )0;
#line 454
          child = parent;
#line 455
          parent = child->parent;
        } else {
#line 451
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 457
        if (! sib->right) {
#line 457
          goto _L___0;
        } else
#line 457
        if ((unsigned int )(sib->right)->color == 1U) {
          _L___0: /* CIL Label */ 
#line 458
          if (sib->left) {
#line 459
            (sib->left)->color = (enum __anonenum_color_68 )1;
          }
          {
#line 460
          sib->color = (enum __anonenum_color_68 )0;
#line 461
          __mm_rotate_right___3(sib);
#line 462
          sib = parent->right;
          }
        }
#line 465
        sib->color = parent->color;
#line 466
        parent->color = (enum __anonenum_color_68 )1;
#line 467
        if (sib->right) {
#line 468
          (sib->right)->color = (enum __anonenum_color_68 )1;
        }
        {
#line 469
        __mm_rotate_left___3(parent);
#line 470
        child = mm_root___3;
        }
#line 471
        goto while_break___0;
      }
    } else {
#line 474
      sib = parent->left;
#line 476
      if ((unsigned int )sib->color == 0U) {
        {
#line 477
        parent->color = (enum __anonenum_color_68 )0;
#line 478
        sib->color = (enum __anonenum_color_68 )1;
#line 479
        __mm_rotate_right___3(parent);
#line 480
        sib = parent->left;
        }
      }
#line 483
      if (! sib->left) {
#line 483
        goto _L___5;
      } else
#line 483
      if ((unsigned int )(sib->left)->color == 1U) {
        _L___5: /* CIL Label */ 
#line 483
        if (! sib->right) {
#line 485
          sib->color = (enum __anonenum_color_68 )0;
#line 486
          child = parent;
#line 487
          parent = child->parent;
        } else
#line 483
        if ((unsigned int )(sib->right)->color == 1U) {
#line 485
          sib->color = (enum __anonenum_color_68 )0;
#line 486
          child = parent;
#line 487
          parent = child->parent;
        } else {
#line 483
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
#line 489
        if (! sib->left) {
#line 489
          goto _L___3;
        } else
#line 489
        if ((unsigned int )(sib->left)->color == 1U) {
          _L___3: /* CIL Label */ 
#line 490
          if (sib->right) {
#line 491
            (sib->right)->color = (enum __anonenum_color_68 )1;
          }
          {
#line 492
          sib->color = (enum __anonenum_color_68 )0;
#line 493
          __mm_rotate_left___3(sib);
#line 494
          sib = parent->left;
          }
        }
#line 497
        sib->color = parent->color;
#line 498
        parent->color = (enum __anonenum_color_68 )1;
#line 499
        if (sib->left) {
#line 500
          (sib->left)->color = (enum __anonenum_color_68 )1;
        }
        {
#line 501
        __mm_rotate_right___3(parent);
#line 502
        child = mm_root___3;
        }
#line 503
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 508
  if (child) {
#line 509
    child->color = (enum __anonenum_color_68 )1;
  }
#line 510
  return;
}
}
#line 512 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_find_start___3(uintptr_t start , uintptr_t end ) 
{ 
  struct ibv_mem_node *node ;

  {
#line 514
  node = mm_root___3;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! node) {
#line 516
      goto while_break;
    }
#line 517
    if (node->start <= start) {
#line 517
      if (node->end >= start) {
#line 518
        goto while_break;
      }
    }
#line 520
    if (node->start < start) {
#line 521
      node = node->right;
    } else {
#line 523
      node = node->left;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 526
  return (node);
}
}
#line 529 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *merge_ranges___3(struct ibv_mem_node *node , struct ibv_mem_node *prev ) 
{ 


  {
  {
#line 532
  prev->end = node->end;
#line 533
  prev->refcnt = node->refcnt;
#line 534
  __mm_remove___3(node);
  }
#line 536
  return (prev);
}
}
#line 539 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *split_range___3(struct ibv_mem_node *node , uintptr_t cut_line ) 
{ 
  struct ibv_mem_node *new_node ;
  void *tmp ;

  {
  {
#line 542
  new_node = (struct ibv_mem_node *)((void *)0);
#line 544
  tmp = malloc(sizeof(*new_node));
#line 544
  new_node = (struct ibv_mem_node *)tmp;
  }
#line 545
  if (! new_node) {
#line 546
    return ((struct ibv_mem_node *)((void *)0));
  }
  {
#line 547
  new_node->start = cut_line;
#line 548
  new_node->end = node->end;
#line 549
  new_node->refcnt = node->refcnt;
#line 550
  node->end = cut_line - 1UL;
#line 551
  __mm_add___3(new_node);
  }
#line 553
  return (new_node);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *get_start_node___3(uintptr_t start , uintptr_t end , int inc ) 
{ 
  struct ibv_mem_node *node ;
  struct ibv_mem_node *tmp ;

  {
  {
#line 559
  tmp = (struct ibv_mem_node *)((void *)0);
#line 561
  node = __mm_find_start___3(start, end);
  }
#line 562
  if (node->start < start) {
    {
#line 563
    node = split_range___3(node, start);
    }
  } else {
    {
#line 565
    tmp = __mm_prev___3(node);
    }
#line 566
    if (tmp) {
#line 566
      if (tmp->refcnt == node->refcnt + inc) {
        {
#line 567
        node = merge_ranges___3(node, tmp);
        }
      }
    }
  }
#line 569
  return (node);
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *undo_node___3(struct ibv_mem_node *node , uintptr_t start ,
                                          int inc ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 579
  tmp = (struct ibv_mem_node *)((void *)0);
#line 585
  if (start > node->start) {
    {
#line 586
    tmp = split_range___3(node, start);
    }
#line 587
    if (tmp) {
#line 588
      node->refcnt += inc;
#line 589
      node = tmp;
    } else {
#line 591
      return ((struct ibv_mem_node *)((void *)0));
    }
  }
  {
#line 594
  tmp = __mm_prev___3(node);
  }
#line 595
  if (tmp) {
#line 595
    if (tmp->refcnt == node->refcnt) {
      {
#line 596
      node = merge_ranges___3(node, tmp);
      }
    }
  }
  {
#line 598
  tmp = __mm_next___3(node);
  }
#line 599
  if (tmp) {
#line 599
    if (tmp->refcnt == node->refcnt) {
      {
#line 600
      node = merge_ranges___3(tmp, node);
      }
    }
  }
#line 602
  return (node);
}
}
#line 605 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int ibv_madvise_range___3(void *base , size_t size , int advice ) 
{ 
  uintptr_t start ;
  uintptr_t end ;
  struct ibv_mem_node *node ;
  struct ibv_mem_node *tmp ;
  int inc ;
  int rolling_back ;
  int ret ;
  unsigned long range_page_size ;
  struct ibv_mem_node *tmp___0 ;

  {
#line 610
  rolling_back = 0;
#line 611
  ret = 0;
#line 614
  if (! size) {
#line 615
    return (0);
  }
#line 617
  if (huge_page_enabled___3) {
    {
#line 618
    range_page_size = get_page_size___3(base);
    }
  } else {
#line 620
    range_page_size = (unsigned long )page_size___5;
  }
  {
#line 622
  start = (uintptr_t )base & ~ (range_page_size - 1UL);
#line 623
  end = ((uintptr_t )(((base + size) + range_page_size) - 1) & ~ (range_page_size - 1UL)) - 1UL;
#line 626
  pthread_mutex_lock(& mm_mutex___3);
  }
  again: 
#line 628
  if (advice == 10) {
#line 628
    inc = 1;
  } else {
#line 628
    inc = -1;
  }
  {
#line 630
  node = get_start_node___3(start, end, inc);
  }
#line 631
  if (! node) {
#line 632
    ret = -1;
#line 633
    goto out;
  }
  {
#line 636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 636
    if (node) {
#line 636
      if (! (node->start <= end)) {
#line 636
        goto while_break;
      }
    } else {
#line 636
      goto while_break;
    }
#line 637
    if (node->end > end) {
      {
#line 638
      tmp___0 = split_range___3(node, end + 1UL);
      }
#line 638
      if (! tmp___0) {
#line 639
        ret = -1;
#line 640
        goto out;
      }
    }
#line 644
    if (inc == -1) {
#line 644
      if (node->refcnt == 1) {
#line 644
        goto _L;
      } else {
#line 644
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 644
    if (inc == 1) {
#line 644
      if (node->refcnt == 0) {
        _L: /* CIL Label */ 
#line 657
        if (start > node->start) {
          {
#line 658
          ret = madvise((void *)start, (node->end - start) + 1UL, advice);
          }
        } else {
          {
#line 661
          ret = madvise((void *)node->start, (node->end - node->start) + 1UL, advice);
          }
        }
#line 664
        if (ret) {
          {
#line 665
          node = undo_node___3(node, start, inc);
          }
#line 667
          if (rolling_back) {
#line 668
            goto out;
          } else
#line 667
          if (! node) {
#line 668
            goto out;
          }
#line 671
          rolling_back = 1;
#line 672
          if (advice == 10) {
#line 672
            advice = 11;
          } else {
#line 672
            advice = 10;
          }
          {
#line 674
          tmp = __mm_prev___3(node);
          }
#line 675
          if (! tmp) {
#line 676
            goto out;
          } else
#line 675
          if (start > tmp->end) {
#line 676
            goto out;
          }
#line 677
          end = tmp->end;
#line 678
          goto again;
        }
      }
    }
    {
#line 682
    node->refcnt += inc;
#line 683
    node = __mm_next___3(node);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if (node) {
    {
#line 687
    tmp = __mm_prev___3(node);
    }
#line 688
    if (tmp) {
#line 688
      if (node->refcnt == tmp->refcnt) {
        {
#line 689
        node = merge_ranges___3(node, tmp);
        }
      }
    }
  }
  out: 
#line 693
  if (rolling_back) {
#line 694
    ret = -1;
  }
  {
#line 696
  pthread_mutex_unlock(& mm_mutex___3);
  }
#line 698
  return (ret);
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
__asm__(".symver __ibv_get_device_list_1_0,ibv_get_device_list@IBVERBS_1.0");
#line 281
__asm__(".symver __ibv_free_device_list_1_0,ibv_free_device_list@IBVERBS_1.0");
#line 287
__asm__(".symver __ibv_get_device_name_1_0,ibv_get_device_name@IBVERBS_1.0");
#line 293
__asm__(".symver __ibv_get_device_guid_1_0,ibv_get_device_guid@IBVERBS_1.0");
#line 295 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int poll_cq_wrapper_1_0___3(struct ibv_cq_1_0 *cq , int num_entries , struct ibv_wc *wc ) 
{ 
  int tmp ;

  {
  {
#line 298
  tmp = (*(((cq->context)->real_context)->ops.poll_cq))(cq->real_cq, num_entries,
                                                        wc);
  }
#line 298
  return (tmp);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int req_notify_cq_wrapper_1_0___3(struct ibv_cq_1_0 *cq , int sol_only ) 
{ 
  int tmp ;

  {
  {
#line 303
  tmp = (*(((cq->context)->real_context)->ops.req_notify_cq))(cq->real_cq, sol_only);
  }
#line 303
  return (tmp);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_srq_recv_wrapper_1_0___3(struct ibv_srq_1_0 *srq , struct ibv_recv_wr_1_0 *wr ,
                                         struct ibv_recv_wr_1_0 **bad_wr ) 
{ 
  struct ibv_recv_wr_1_0 *w ;
  struct ibv_recv_wr *real_wr ;
  struct ibv_recv_wr *head_wr ;
  struct ibv_recv_wr *tail_wr ;
  struct ibv_recv_wr *real_bad_wr ;
  int ret ;
  void *tmp ;

  {
#line 310
  head_wr = (struct ibv_recv_wr *)((void *)0);
#line 310
  tail_wr = (struct ibv_recv_wr *)((void *)0);
#line 313
  w = wr;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! w) {
#line 313
      goto while_break;
    }
    {
#line 314
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 314
    real_wr = (struct ibv_recv_wr *)tmp;
#line 315
    real_wr->wr_id = w->wr_id;
#line 316
    real_wr->sg_list = w->sg_list;
#line 317
    real_wr->num_sge = w->num_sge;
#line 318
    real_wr->next = (struct ibv_recv_wr *)((void *)0);
    }
#line 319
    if (tail_wr) {
#line 320
      tail_wr->next = real_wr;
    } else {
#line 322
      head_wr = real_wr;
    }
#line 324
    tail_wr = real_wr;
#line 313
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 327
  ret = (*(((srq->context)->real_context)->ops.post_srq_recv))(srq->real_srq, head_wr,
                                                               & real_bad_wr);
  }
#line 330
  if (ret) {
#line 331
    real_wr = head_wr;
#line 331
    w = wr;
    {
#line 331
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 331
      if (! real_wr) {
#line 331
        goto while_break___0;
      }
#line 334
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 335
        *bad_wr = w;
#line 336
        goto while_break___0;
      }
#line 331
      real_wr = real_wr->next;
#line 331
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 340
  return (ret);
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_send_wrapper_1_0___3(struct ibv_qp_1_0 *qp , struct ibv_send_wr_1_0 *wr ,
                                     struct ibv_send_wr_1_0 **bad_wr ) 
{ 
  struct ibv_send_wr_1_0 *w ;
  struct ibv_send_wr *real_wr ;
  struct ibv_send_wr *head_wr ;
  struct ibv_send_wr *tail_wr ;
  struct ibv_send_wr *real_bad_wr ;
  int is_ud ;
  int ret ;
  void *tmp ;

  {
#line 347
  head_wr = (struct ibv_send_wr *)((void *)0);
#line 347
  tail_wr = (struct ibv_send_wr *)((void *)0);
#line 348
  is_ud = (unsigned int )qp->qp_type == 4U;
#line 351
  w = wr;
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! w) {
#line 351
      goto while_break;
    }
    {
#line 352
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 352
    real_wr = (struct ibv_send_wr *)tmp;
#line 353
    real_wr->wr_id = w->wr_id;
#line 354
    real_wr->next = (struct ibv_send_wr *)((void *)0);
    }
#line 363
    if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->sg_list)) {
      {
#line 364
      memcpy((void */* __restrict  */)(& real_wr->sg_list), (void const   */* __restrict  */)(& w->sg_list),
             sizeof(*real_wr) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list));
      }
    } else
#line 366
    if ((unsigned long )(& ((struct ibv_send_wr *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list) == (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->sg_list)) {
#line 366
      if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->wr) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->wr)) {
        {
#line 371
        memcpy((void */* __restrict  */)(& real_wr->sg_list), (void const   */* __restrict  */)(& w->sg_list),
               ((unsigned long )(& ((struct ibv_send_wr *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list)) + sizeof(real_wr->imm_data));
#line 375
        memcpy((void */* __restrict  */)(& real_wr->wr), (void const   */* __restrict  */)(& w->wr),
               sizeof(real_wr->wr));
        }
      } else {
#line 366
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 377
      real_wr->sg_list = w->sg_list;
#line 378
      real_wr->num_sge = w->num_sge;
#line 379
      real_wr->opcode = w->opcode;
#line 380
      real_wr->send_flags = w->send_flags;
#line 381
      real_wr->imm_data = w->imm_data;
#line 382
      if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->wr) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->wr)) {
        {
#line 383
        memcpy((void */* __restrict  */)(& real_wr->wr), (void const   */* __restrict  */)(& w->wr),
               sizeof(real_wr->wr));
        }
      } else {
#line 386
        real_wr->wr.atomic.remote_addr = w->wr.atomic.remote_addr;
#line 388
        real_wr->wr.atomic.compare_add = w->wr.atomic.compare_add;
#line 390
        real_wr->wr.atomic.swap = w->wr.atomic.swap;
#line 392
        real_wr->wr.atomic.rkey = w->wr.atomic.rkey;
      }
    }
#line 397
    if (is_ud) {
#line 398
      real_wr->wr.ud.ah = (w->wr.ud.ah)->real_ah;
    }
#line 400
    if (tail_wr) {
#line 401
      tail_wr->next = real_wr;
    } else {
#line 403
      head_wr = real_wr;
    }
#line 405
    tail_wr = real_wr;
#line 351
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 408
  ret = (*(((qp->context)->real_context)->ops.post_send))(qp->real_qp, head_wr, & real_bad_wr);
  }
#line 411
  if (ret) {
#line 412
    real_wr = head_wr;
#line 412
    w = wr;
    {
#line 412
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 412
      if (! real_wr) {
#line 412
        goto while_break___0;
      }
#line 415
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 416
        *bad_wr = w;
#line 417
        goto while_break___0;
      }
#line 412
      real_wr = real_wr->next;
#line 412
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 421
  return (ret);
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_recv_wrapper_1_0___3(struct ibv_qp_1_0 *qp , struct ibv_recv_wr_1_0 *wr ,
                                     struct ibv_recv_wr_1_0 **bad_wr ) 
{ 
  struct ibv_recv_wr_1_0 *w ;
  struct ibv_recv_wr *real_wr ;
  struct ibv_recv_wr *head_wr ;
  struct ibv_recv_wr *tail_wr ;
  struct ibv_recv_wr *real_bad_wr ;
  int ret ;
  void *tmp ;

  {
#line 428
  head_wr = (struct ibv_recv_wr *)((void *)0);
#line 428
  tail_wr = (struct ibv_recv_wr *)((void *)0);
#line 431
  w = wr;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! w) {
#line 431
      goto while_break;
    }
    {
#line 432
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 432
    real_wr = (struct ibv_recv_wr *)tmp;
#line 433
    real_wr->wr_id = w->wr_id;
#line 434
    real_wr->sg_list = w->sg_list;
#line 435
    real_wr->num_sge = w->num_sge;
#line 436
    real_wr->next = (struct ibv_recv_wr *)((void *)0);
    }
#line 437
    if (tail_wr) {
#line 438
      tail_wr->next = real_wr;
    } else {
#line 440
      head_wr = real_wr;
    }
#line 442
    tail_wr = real_wr;
#line 431
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 445
  ret = (*(((qp->context)->real_context)->ops.post_recv))(qp->real_qp, head_wr, & real_bad_wr);
  }
#line 448
  if (ret) {
#line 449
    real_wr = head_wr;
#line 449
    w = wr;
    {
#line 449
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 449
      if (! real_wr) {
#line 449
        goto while_break___0;
      }
#line 452
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 453
        *bad_wr = w;
#line 454
        goto while_break___0;
      }
#line 449
      real_wr = real_wr->next;
#line 449
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 458
  return (ret);
}
}
#line 487
__asm__(".symver __ibv_open_device_1_0,ibv_open_device@IBVERBS_1.0");
#line 500
__asm__(".symver __ibv_close_device_1_0,ibv_close_device@IBVERBS_1.0");
#line 538
__asm__(".symver __ibv_get_async_event_1_0,ibv_get_async_event@IBVERBS_1.0");
#line 574
__asm__(".symver __ibv_ack_async_event_1_0,ibv_ack_async_event@IBVERBS_1.0");
#line 581
__asm__(".symver __ibv_query_device_1_0,ibv_query_device@IBVERBS_1.0");
#line 588
__asm__(".symver __ibv_query_port_1_0,ibv_query_port@IBVERBS_1.0");
#line 595
__asm__(".symver __ibv_query_gid_1_0,ibv_query_gid@IBVERBS_1.0");
#line 602
__asm__(".symver __ibv_query_pkey_1_0,ibv_query_pkey@IBVERBS_1.0");
#line 624
__asm__(".symver __ibv_alloc_pd_1_0,ibv_alloc_pd@IBVERBS_1.0");
#line 637
__asm__(".symver __ibv_dealloc_pd_1_0,ibv_dealloc_pd@IBVERBS_1.0");
#line 663
__asm__(".symver __ibv_reg_mr_1_0,ibv_reg_mr@IBVERBS_1.0");
#line 676
__asm__(".symver __ibv_dereg_mr_1_0,ibv_dereg_mr@IBVERBS_1.0");
#line 706
__asm__(".symver __ibv_create_cq_1_0,ibv_create_cq@IBVERBS_1.0");
#line 712
__asm__(".symver __ibv_resize_cq_1_0,ibv_resize_cq@IBVERBS_1.0");
#line 725
__asm__(".symver __ibv_destroy_cq_1_0,ibv_destroy_cq@IBVERBS_1.0");
#line 743
__asm__(".symver __ibv_get_cq_event_1_0,ibv_get_cq_event@IBVERBS_1.0");
#line 749
__asm__(".symver __ibv_ack_cq_events_1_0,ibv_ack_cq_events@IBVERBS_1.0");
#line 776
__asm__(".symver __ibv_create_srq_1_0,ibv_create_srq@IBVERBS_1.0");
#line 784
__asm__(".symver __ibv_modify_srq_1_0,ibv_modify_srq@IBVERBS_1.0");
#line 790
__asm__(".symver __ibv_query_srq_1_0,ibv_query_srq@IBVERBS_1.0");
#line 803
__asm__(".symver __ibv_destroy_srq_1_0,ibv_destroy_srq@IBVERBS_1.0");
#line 847
__asm__(".symver __ibv_create_qp_1_0,ibv_create_qp@IBVERBS_1.0");
#line 870
__asm__(".symver __ibv_query_qp_1_0,ibv_query_qp@IBVERBS_1.0");
#line 877
__asm__(".symver __ibv_modify_qp_1_0,ibv_modify_qp@IBVERBS_1.0");
#line 890
__asm__(".symver __ibv_destroy_qp_1_0,ibv_destroy_qp@IBVERBS_1.0");
#line 914
__asm__(".symver __ibv_create_ah_1_0,ibv_create_ah@IBVERBS_1.0");
#line 927
__asm__(".symver __ibv_destroy_ah_1_0,ibv_destroy_ah@IBVERBS_1.0");
#line 933
__asm__(".symver __ibv_attach_mcast_1_0,ibv_attach_mcast@IBVERBS_1.0");
#line 939
__asm__(".symver __ibv_detach_mcast_1_0,ibv_detach_mcast@IBVERBS_1.0");
#line 400 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
static int ibv_cmd_modify_srq_v3___3(struct ibv_srq *srq , struct ibv_srq_attr *srq_attr ,
                                     int srq_attr_mask , struct ibv_modify_srq *new_cmd ,
                                     size_t new_cmd_size ) 
{ 
  struct ibv_modify_srq_v3 *cmd ;
  size_t cmd_size ;
  void *tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 409
  cmd_size = (sizeof(*cmd) + new_cmd_size) - sizeof(*new_cmd);
#line 410
  tmp = __builtin_alloca(cmd_size);
#line 410
  cmd = (struct ibv_modify_srq_v3 *)tmp;
#line 411
  memcpy((void */* __restrict  */)(cmd->driver_data), (void const   */* __restrict  */)(new_cmd->driver_data),
         new_cmd_size - sizeof(*new_cmd));
  }
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 413
      cmd->command = (__u32 )33;
    } else {
#line 413
      cmd->command = (__u32 )35;
    }
#line 413
    cmd->in_words = (__u16 )(cmd_size / 4UL);
#line 413
    cmd->out_words = (__u16 )0;
#line 413
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 415
  cmd->srq_handle = srq->handle;
#line 416
  cmd->attr_mask = (__u32 )srq_attr_mask;
#line 417
  cmd->max_wr = srq_attr->max_wr;
#line 418
  cmd->srq_limit = srq_attr->srq_limit;
#line 419
  cmd->max_sge = (__u32 )0;
#line 420
  cmd->reserved = (__u32 )0;
#line 422
  tmp___1 = write((srq->context)->cmd_fd, (void const   *)cmd, cmd_size);
  }
#line 422
  if ((size_t )tmp___1 != cmd_size) {
    {
#line 423
    tmp___0 = __errno_location();
    }
#line 423
    return (*tmp___0);
  }
#line 425
  return (0);
}
}
#line 1008 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
static int ib_spec_to_kern_spec___3(struct ibv_flow_spec *ib_spec , struct ibv_kern_spec *kern_spec ) 
{ 


  {
#line 1011
  kern_spec->__annonCompField5.hdr.type = (__u32 )ib_spec->__annonCompField1.hdr.type;
  {
#line 1014
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 32U) {
#line 1014
    goto case_32;
  }
#line 1021
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 48U) {
#line 1021
    goto case_48;
  }
#line 1029
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 65U) {
#line 1029
    goto case_65;
  }
#line 1029
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 64U) {
#line 1029
    goto case_65;
  }
#line 1036
  goto switch_default;
  case_32: /* CIL Label */ 
  {
#line 1015
  kern_spec->__annonCompField5.eth.size = (__u16 )sizeof(struct ibv_kern_spec_eth );
#line 1016
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.eth.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.eth.val),
         sizeof(struct ibv_flow_eth_filter ));
#line 1018
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.eth.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.eth.mask),
         sizeof(struct ibv_flow_eth_filter ));
  }
#line 1020
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 1022
  kern_spec->__annonCompField5.ipv4.size = (__u16 )sizeof(struct ibv_kern_spec_ipv4 );
#line 1023
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.ipv4.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.ipv4.val),
         sizeof(struct ibv_flow_ipv4_filter ));
#line 1025
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.ipv4.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.ipv4.mask),
         sizeof(struct ibv_flow_ipv4_filter ));
  }
#line 1027
  goto switch_break;
  case_65: /* CIL Label */ 
  case_64: /* CIL Label */ 
  {
#line 1030
  kern_spec->__annonCompField5.tcp_udp.size = (__u16 )sizeof(struct ibv_kern_spec_tcp_udp );
#line 1031
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.tcp_udp.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.tcp_udp.val),
         sizeof(struct ibv_flow_ipv4_filter ));
#line 1033
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.tcp_udp.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.tcp_udp.mask),
         sizeof(struct ibv_flow_tcp_udp_filter ));
  }
#line 1035
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1037
  return (-22);
  switch_break: /* CIL Label */ ;
  }
#line 1039
  return (0);
}
}
#line 82 "./include/infiniband/verbs.h"
static void *__VERBS_ABI_IS_EXTENDED___3  =    (void *)((uint8_t *)((void *)0) - 1);
#line 877 "./include/infiniband/verbs.h"
__inline static struct verbs_context *verbs_get_ctx___3(struct ibv_context *ctx ) 
{ 
  struct verbs_context *tmp ;

  {
#line 879
  if ((unsigned long )ctx->abi_compat != (unsigned long )__VERBS_ABI_IS_EXTENDED___3) {
#line 879
    tmp = (struct verbs_context *)((void *)0);
  } else {
#line 879
    tmp = (struct verbs_context *)((uint8_t *)ctx - (unsigned long )(& ((struct verbs_context *)0)->context));
  }
#line 879
  return (tmp);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static pthread_once_t device_list_once___3  =    0;
#line 53 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static int num_devices___3  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static struct ibv_device **device_list___3  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static void count_devices___3(void) 
{ 
  int __attribute__((__visibility__("hidden")))  tmp ;

  {
  {
#line 58
  tmp = ibverbs_init(& device_list___3);
#line 58
  num_devices___3 = (int )tmp;
  }
#line 59
  return;
}
}
#line 89
__asm__(".symver __ibv_get_device_list,ibv_get_device_list@@IBVERBS_1.1");
#line 95
__asm__(".symver __ibv_free_device_list,ibv_free_device_list@@IBVERBS_1.1");
#line 101
__asm__(".symver __ibv_get_device_name,ibv_get_device_name@@IBVERBS_1.1");
#line 123
__asm__(".symver __ibv_get_device_guid,ibv_get_device_guid@@IBVERBS_1.1");
#line 190
__asm__(".symver __ibv_open_device,ibv_open_device@@IBVERBS_1.1");
#line 215
__asm__(".symver __ibv_close_device,ibv_close_device@@IBVERBS_1.1");
#line 258
__asm__(".symver __ibv_get_async_event,ibv_get_async_event@@IBVERBS_1.1");
#line 311
__asm__(".symver __ibv_ack_async_event,ibv_ack_async_event@@IBVERBS_1.1");
#line 1190 "./include/infiniband/verbs.h"
__inline static int ibv_post_srq_recv(struct ibv_srq *srq , struct ibv_recv_wr *recv_wr ,
                                      struct ibv_recv_wr **bad_recv_wr ) 
{ 
  int tmp ;

  {
  {
#line 1194
  tmp = (*((srq->context)->ops.post_srq_recv))(srq, recv_wr, bad_recv_wr);
  }
#line 1194
  return (tmp);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/srq_pingpong.c"
static int page_size___6  ;
#line 84 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/srq_pingpong.c"
static int pp_connect_ctx___1(struct pingpong_context___0 *ctx , int port , enum ibv_mtu mtu ,
                              int sl , struct pingpong_dest  const  *my_dest , struct pingpong_dest  const  *dest ,
                              int sgid_idx ) 
{ 
  int i ;
  struct ibv_qp_attr attr ;
  int tmp ;
  int tmp___0 ;

  {
#line 90
  i = 0;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! (i < ctx->num_qp)) {
#line 90
      goto while_break;
    }
#line 91
    attr.qp_state = (enum ibv_qp_state )2;
#line 91
    attr.cur_qp_state = 0U;
#line 91
    attr.path_mtu = mtu;
#line 91
    attr.path_mig_state = 0U;
#line 91
    attr.qkey = 0U;
#line 91
    attr.rq_psn = (uint32_t )(dest + i)->psn;
#line 91
    attr.sq_psn = 0U;
#line 91
    attr.dest_qp_num = (uint32_t )(dest + i)->qpn;
#line 91
    attr.qp_access_flags = 0;
#line 91
    attr.cap.max_send_wr = 0U;
#line 91
    attr.cap.max_recv_wr = 0U;
#line 91
    attr.cap.max_send_sge = 0U;
#line 91
    attr.cap.max_recv_sge = 0U;
#line 91
    attr.cap.max_inline_data = 0U;
#line 91
    attr.ah_attr.grh.dgid.raw[0] = (unsigned char)0;
#line 91
    attr.ah_attr.grh.dgid.raw[1] = (unsigned char)0;
#line 91
    attr.ah_attr.grh.dgid.raw[2] = (unsigned char)0;
#line 91
    attr.ah_attr.grh.dgid.raw[3] = (unsigned char)0;
#line 91
    attr.ah_attr.grh.dgid.raw[4] = (unsigned char)0;
#line 91
    attr.ah_attr.grh.dgid.raw[5] = (unsigned char)0;
#line 91
    attr.ah_attr.grh.dgid.raw[6] = (unsigned char)0;
#line 91
    attr.ah_attr.grh.dgid.raw[7] = (unsigned char)0;
#line 91
    attr.ah_attr.grh.dgid.raw[8] = (unsigned char)0;
#line 91
    attr.ah_attr.grh.dgid.raw[9] = (unsigned char)0;
#line 91
    attr.ah_attr.grh.dgid.raw[10] = (unsigned char)0;
#line 91
    attr.ah_attr.grh.dgid.raw[11] = (unsigned char)0;
#line 91
    attr.ah_attr.grh.dgid.raw[12] = (unsigned char)0;
#line 91
    attr.ah_attr.grh.dgid.raw[13] = (unsigned char)0;
#line 91
    attr.ah_attr.grh.dgid.raw[14] = (unsigned char)0;
#line 91
    attr.ah_attr.grh.dgid.raw[15] = (unsigned char)0;
#line 91
    attr.ah_attr.grh.flow_label = 0U;
#line 91
    attr.ah_attr.grh.sgid_index = (unsigned char)0;
#line 91
    attr.ah_attr.grh.hop_limit = (unsigned char)0;
#line 91
    attr.ah_attr.grh.traffic_class = (unsigned char)0;
#line 91
    attr.ah_attr.dlid = (uint16_t )(dest + i)->lid;
#line 91
    attr.ah_attr.sl = (uint8_t )sl;
#line 91
    attr.ah_attr.src_path_bits = (uint8_t )0;
#line 91
    attr.ah_attr.static_rate = (unsigned char)0;
#line 91
    attr.ah_attr.is_global = (uint8_t )0;
#line 91
    attr.ah_attr.port_num = (uint8_t )port;
#line 91
    attr.alt_ah_attr.grh.dgid.raw[0] = (unsigned char)0;
#line 91
    attr.alt_ah_attr.grh.dgid.raw[1] = (unsigned char)0;
#line 91
    attr.alt_ah_attr.grh.dgid.raw[2] = (unsigned char)0;
#line 91
    attr.alt_ah_attr.grh.dgid.raw[3] = (unsigned char)0;
#line 91
    attr.alt_ah_attr.grh.dgid.raw[4] = (unsigned char)0;
#line 91
    attr.alt_ah_attr.grh.dgid.raw[5] = (unsigned char)0;
#line 91
    attr.alt_ah_attr.grh.dgid.raw[6] = (unsigned char)0;
#line 91
    attr.alt_ah_attr.grh.dgid.raw[7] = (unsigned char)0;
#line 91
    attr.alt_ah_attr.grh.dgid.raw[8] = (unsigned char)0;
#line 91
    attr.alt_ah_attr.grh.dgid.raw[9] = (unsigned char)0;
#line 91
    attr.alt_ah_attr.grh.dgid.raw[10] = (unsigned char)0;
#line 91
    attr.alt_ah_attr.grh.dgid.raw[11] = (unsigned char)0;
#line 91
    attr.alt_ah_attr.grh.dgid.raw[12] = (unsigned char)0;
#line 91
    attr.alt_ah_attr.grh.dgid.raw[13] = (unsigned char)0;
#line 91
    attr.alt_ah_attr.grh.dgid.raw[14] = (unsigned char)0;
#line 91
    attr.alt_ah_attr.grh.dgid.raw[15] = (unsigned char)0;
#line 91
    attr.alt_ah_attr.grh.flow_label = 0U;
#line 91
    attr.alt_ah_attr.grh.sgid_index = (unsigned char)0;
#line 91
    attr.alt_ah_attr.grh.hop_limit = (unsigned char)0;
#line 91
    attr.alt_ah_attr.grh.traffic_class = (unsigned char)0;
#line 91
    attr.alt_ah_attr.dlid = (unsigned short)0;
#line 91
    attr.alt_ah_attr.sl = (unsigned char)0;
#line 91
    attr.alt_ah_attr.src_path_bits = (unsigned char)0;
#line 91
    attr.alt_ah_attr.static_rate = (unsigned char)0;
#line 91
    attr.alt_ah_attr.is_global = (unsigned char)0;
#line 91
    attr.alt_ah_attr.port_num = (unsigned char)0;
#line 91
    attr.pkey_index = (unsigned short)0;
#line 91
    attr.alt_pkey_index = (unsigned short)0;
#line 91
    attr.en_sqd_async_notify = (unsigned char)0;
#line 91
    attr.sq_draining = (unsigned char)0;
#line 91
    attr.max_rd_atomic = (unsigned char)0;
#line 91
    attr.max_dest_rd_atomic = (uint8_t )1;
#line 91
    attr.min_rnr_timer = (uint8_t )12;
#line 91
    attr.port_num = (unsigned char)0;
#line 91
    attr.timeout = (unsigned char)0;
#line 91
    attr.retry_cnt = (unsigned char)0;
#line 91
    attr.rnr_retry = (unsigned char)0;
#line 91
    attr.alt_port_num = (unsigned char)0;
#line 91
    attr.alt_timeout = (unsigned char)0;
#line 107
    if (dest->gid.global.interface_id) {
#line 108
      attr.ah_attr.is_global = (uint8_t )1;
#line 109
      attr.ah_attr.grh.hop_limit = (uint8_t )1;
#line 110
      attr.ah_attr.grh.dgid = (union ibv_gid )dest->gid;
#line 111
      attr.ah_attr.grh.sgid_index = (uint8_t )sgid_idx;
    }
    {
#line 113
    tmp = ibv_modify_qp(ctx->qp[i], & attr, 1216897);
    }
#line 113
    if (tmp) {
      {
#line 121
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to modify QP[%d] to RTR\n",
              i);
      }
#line 122
      return (1);
    }
    {
#line 125
    attr.qp_state = (enum ibv_qp_state )3;
#line 126
    attr.timeout = (uint8_t )14;
#line 127
    attr.retry_cnt = (uint8_t )7;
#line 128
    attr.rnr_retry = (uint8_t )7;
#line 129
    attr.sq_psn = (uint32_t )(my_dest + i)->psn;
#line 130
    attr.max_rd_atomic = (uint8_t )1;
#line 131
    tmp___0 = ibv_modify_qp(ctx->qp[i], & attr, 77313);
    }
#line 131
    if (tmp___0) {
      {
#line 138
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to modify QP[%d] to RTS\n",
              i);
      }
#line 139
      return (1);
    }
#line 90
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return (0);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/srq_pingpong.c"
static struct pingpong_dest *pp_client_exch_dest___1(char const   *servername , int port ,
                                                     struct pingpong_dest  const  *my_dest ) 
{ 
  struct addrinfo *res ;
  struct addrinfo *t ;
  struct addrinfo hints ;
  char *service ;
  char msg[sizeof("0000:000000:000000:00000000000000000000000000000000")] ;
  int n ;
  int r ;
  int i ;
  int sockfd ;
  struct pingpong_dest *rem_dest ;
  char gid[33] ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  void *tmp___3 ;
  ssize_t tmp___4 ;

  {
  {
#line 150
  hints.ai_flags = 0;
#line 150
  hints.ai_family = 0;
#line 150
  hints.ai_socktype = 1;
#line 150
  hints.ai_protocol = 0;
#line 150
  hints.ai_addrlen = 0U;
#line 150
  hints.ai_addr = (struct sockaddr *)0;
#line 150
  hints.ai_canonname = (char *)0;
#line 150
  hints.ai_next = (struct addrinfo *)0;
#line 159
  sockfd = -1;
#line 160
  rem_dest = (struct pingpong_dest *)((void *)0);
#line 163
  tmp = asprintf((char **/* __restrict  */)(& service), (char const   */* __restrict  */)"%d",
                 port);
  }
#line 163
  if (tmp < 0) {
#line 164
    return ((struct pingpong_dest *)((void *)0));
  }
  {
#line 166
  n = getaddrinfo((char const   */* __restrict  */)servername, (char const   */* __restrict  */)service,
                  (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 168
  if (n < 0) {
    {
#line 169
    tmp___0 = gai_strerror(n);
#line 169
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s for %s:%d\n",
            tmp___0, servername, port);
#line 170
    free((void *)service);
    }
#line 171
    return ((struct pingpong_dest *)((void *)0));
  }
#line 174
  t = res;
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! t) {
#line 174
      goto while_break;
    }
    {
#line 175
    sockfd = socket(t->ai_family, t->ai_socktype, t->ai_protocol);
    }
#line 176
    if (sockfd >= 0) {
      {
#line 177
      tmp___1 = connect(sockfd, (struct sockaddr  const  */* __restrict  */)t->ai_addr,
                        t->ai_addrlen);
      }
#line 177
      if (! tmp___1) {
#line 178
        goto while_break;
      }
      {
#line 179
      close(sockfd);
#line 180
      sockfd = -1;
      }
    }
#line 174
    t = t->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 184
  freeaddrinfo(res);
#line 185
  free((void *)service);
  }
#line 187
  if (sockfd < 0) {
    {
#line 188
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t connect to %s:%d\n",
            servername, port);
    }
#line 189
    return ((struct pingpong_dest *)((void *)0));
  }
#line 192
  i = 0;
  {
#line 192
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 192
    if (! (i < 256)) {
#line 192
      goto while_break___0;
    }
    {
#line 193
    gid_to_wire_gid(& (my_dest + i)->gid, gid);
#line 194
    sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"%04x:%06x:%06x:%s",
            (my_dest + i)->lid, (my_dest + i)->qpn, (my_dest + i)->psn, gid);
#line 196
    tmp___2 = write(sockfd, (void const   *)(msg), sizeof(msg));
    }
#line 196
    if ((unsigned long )tmp___2 != sizeof(msg)) {
      {
#line 197
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t send local address\n");
      }
#line 198
      goto out;
    }
#line 192
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 202
  tmp___3 = malloc(256UL * sizeof(*rem_dest));
#line 202
  rem_dest = (struct pingpong_dest *)tmp___3;
  }
#line 203
  if (! rem_dest) {
#line 204
    goto out;
  }
#line 206
  i = 0;
  {
#line 206
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 206
    if (! (i < 256)) {
#line 206
      goto while_break___1;
    }
#line 207
    n = 0;
    {
#line 208
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 208
      if (! ((unsigned long )n < sizeof(msg))) {
#line 208
        goto while_break___2;
      }
      {
#line 209
      tmp___4 = read(sockfd, (void *)(msg + n), sizeof(msg) - (unsigned long )n);
#line 209
      r = (int )tmp___4;
      }
#line 210
      if (r < 0) {
        {
#line 211
        perror("client read");
#line 212
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d/%d: Couldn\'t read remote address [%d]\n",
                n, (int )sizeof(msg), i);
        }
#line 214
        goto out;
      }
#line 216
      n += r;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 219
    sscanf((char const   */* __restrict  */)(msg), (char const   */* __restrict  */)"%x:%x:%x:%s",
           & (rem_dest + i)->lid, & (rem_dest + i)->qpn, & (rem_dest + i)->psn, gid);
#line 221
    wire_gid_to_gid((char const   *)(gid), & (rem_dest + i)->gid);
#line 206
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 224
  write(sockfd, (void const   *)"done", sizeof("done"));
  }
  out: 
  {
#line 227
  close(sockfd);
  }
#line 228
  return (rem_dest);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/srq_pingpong.c"
static struct pingpong_dest *pp_server_exch_dest___1(struct pingpong_context___0 *ctx ,
                                                     int ib_port , enum ibv_mtu mtu ,
                                                     int port , int sl , struct pingpong_dest  const  *my_dest ,
                                                     int sgid_idx ) 
{ 
  struct addrinfo *res ;
  struct addrinfo *t ;
  struct addrinfo hints ;
  char *service ;
  char msg[sizeof("0000:000000:000000:00000000000000000000000000000000")] ;
  int n ;
  int r ;
  int i ;
  int sockfd ;
  int connfd ;
  struct pingpong_dest *rem_dest ;
  char gid[33] ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;

  {
  {
#line 238
  hints.ai_flags = 1;
#line 238
  hints.ai_family = 0;
#line 238
  hints.ai_socktype = 1;
#line 238
  hints.ai_protocol = 0;
#line 238
  hints.ai_addrlen = 0U;
#line 238
  hints.ai_addr = (struct sockaddr *)0;
#line 238
  hints.ai_canonname = (char *)0;
#line 238
  hints.ai_next = (struct addrinfo *)0;
#line 248
  sockfd = -1;
#line 249
  rem_dest = (struct pingpong_dest *)((void *)0);
#line 252
  tmp = asprintf((char **/* __restrict  */)(& service), (char const   */* __restrict  */)"%d",
                 port);
  }
#line 252
  if (tmp < 0) {
#line 253
    return ((struct pingpong_dest *)((void *)0));
  }
  {
#line 255
  n = getaddrinfo((char const   */* __restrict  */)((void *)0), (char const   */* __restrict  */)service,
                  (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 257
  if (n < 0) {
    {
#line 258
    tmp___0 = gai_strerror(n);
#line 258
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s for port %d\n",
            tmp___0, port);
#line 259
    free((void *)service);
    }
#line 260
    return ((struct pingpong_dest *)((void *)0));
  }
#line 263
  t = res;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! t) {
#line 263
      goto while_break;
    }
    {
#line 264
    sockfd = socket(t->ai_family, t->ai_socktype, t->ai_protocol);
    }
#line 265
    if (sockfd >= 0) {
      {
#line 266
      n = 1;
#line 268
      setsockopt(sockfd, 1, 2, (void const   *)(& n), (socklen_t )sizeof(n));
#line 270
      tmp___1 = bind(sockfd, (struct sockaddr  const  */* __restrict  */)t->ai_addr,
                     t->ai_addrlen);
      }
#line 270
      if (! tmp___1) {
#line 271
        goto while_break;
      }
      {
#line 272
      close(sockfd);
#line 273
      sockfd = -1;
      }
    }
#line 263
    t = t->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 277
  freeaddrinfo(res);
#line 278
  free((void *)service);
  }
#line 280
  if (sockfd < 0) {
    {
#line 281
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t listen to port %d\n",
            port);
    }
#line 282
    return ((struct pingpong_dest *)((void *)0));
  }
  {
#line 285
  listen(sockfd, 1);
#line 286
  connfd = accept(sockfd, (struct sockaddr */* __restrict  */)((void *)0), (socklen_t */* __restrict  */)0);
#line 287
  close(sockfd);
  }
#line 288
  if (connfd < 0) {
    {
#line 289
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"accept() failed\n");
    }
#line 290
    return ((struct pingpong_dest *)((void *)0));
  }
  {
#line 293
  tmp___2 = malloc(256UL * sizeof(*rem_dest));
#line 293
  rem_dest = (struct pingpong_dest *)tmp___2;
  }
#line 294
  if (! rem_dest) {
#line 295
    goto out;
  }
#line 297
  i = 0;
  {
#line 297
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 297
    if (! (i < 256)) {
#line 297
      goto while_break___0;
    }
#line 298
    n = 0;
    {
#line 299
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 299
      if (! ((unsigned long )n < sizeof(msg))) {
#line 299
        goto while_break___1;
      }
      {
#line 300
      tmp___3 = read(connfd, (void *)(msg + n), sizeof(msg) - (unsigned long )n);
#line 300
      r = (int )tmp___3;
      }
#line 301
      if (r < 0) {
        {
#line 302
        perror("server read");
#line 303
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d/%d: Couldn\'t read remote address [%d]\n",
                n, (int )sizeof(msg), i);
        }
#line 305
        goto out;
      }
#line 307
      n += r;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 310
    sscanf((char const   */* __restrict  */)(msg), (char const   */* __restrict  */)"%x:%x:%x:%s",
           & (rem_dest + i)->lid, & (rem_dest + i)->qpn, & (rem_dest + i)->psn, gid);
#line 312
    wire_gid_to_gid((char const   *)(gid), & (rem_dest + i)->gid);
#line 297
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 315
  tmp___4 = pp_connect_ctx___1(ctx, ib_port, mtu, sl, my_dest, (struct pingpong_dest  const  *)rem_dest,
                               sgid_idx);
  }
#line 315
  if (tmp___4) {
    {
#line 317
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t connect to remote QP\n");
#line 318
    free((void *)rem_dest);
#line 319
    rem_dest = (struct pingpong_dest *)((void *)0);
    }
#line 320
    goto out;
  }
#line 323
  i = 0;
  {
#line 323
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 323
    if (! (i < 256)) {
#line 323
      goto while_break___2;
    }
    {
#line 324
    gid_to_wire_gid(& (my_dest + i)->gid, gid);
#line 325
    sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"%04x:%06x:%06x:%s",
            (my_dest + i)->lid, (my_dest + i)->qpn, (my_dest + i)->psn, gid);
#line 327
    tmp___5 = write(connfd, (void const   *)(msg), sizeof(msg));
    }
#line 327
    if ((unsigned long )tmp___5 != sizeof(msg)) {
      {
#line 328
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t send local address\n");
#line 329
      free((void *)rem_dest);
#line 330
      rem_dest = (struct pingpong_dest *)((void *)0);
      }
#line 331
      goto out;
    }
#line 323
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 335
  read(connfd, (void *)(msg), sizeof(msg));
  }
  out: 
  {
#line 338
  close(connfd);
  }
#line 339
  return (rem_dest);
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/srq_pingpong.c"
static struct pingpong_context___0 *pp_init_ctx___1(struct ibv_device *ib_dev , int size ,
                                                    int num_qp , int rx_depth , int port ,
                                                    int use_event ) 
{ 
  struct pingpong_context___0 *ctx ;
  int i ;
  void *tmp ;
  char const   *tmp___0 ;
  struct ibv_srq_init_attr attr ;
  struct ibv_qp_init_attr attr___0 ;
  struct ibv_qp_attr attr___1 ;
  int tmp___1 ;

  {
  {
#line 349
  tmp = calloc((size_t )1, sizeof(*ctx));
#line 349
  ctx = (struct pingpong_context___0 *)tmp;
  }
#line 350
  if (! ctx) {
#line 351
    return ((struct pingpong_context___0 *)((void *)0));
  }
  {
#line 353
  ctx->size = size;
#line 354
  ctx->num_qp = num_qp;
#line 355
  ctx->rx_depth = rx_depth;
#line 357
  ctx->buf = memalign((size_t )page_size___6, (size_t )size);
  }
#line 358
  if (! ctx->buf) {
    {
#line 359
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t allocate work buf.\n");
    }
#line 360
    goto clean_ctx;
  }
  {
#line 363
  memset(ctx->buf, 0, (size_t )size);
#line 365
  ctx->context = ibv_open_device(ib_dev);
  }
#line 366
  if (! ctx->context) {
    {
#line 367
    tmp___0 = ibv_get_device_name(ib_dev);
#line 367
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t get context for %s\n",
            tmp___0);
    }
#line 369
    goto clean_buffer;
  }
#line 372
  if (use_event) {
    {
#line 373
    ctx->channel = ibv_create_comp_channel(ctx->context);
    }
#line 374
    if (! ctx->channel) {
      {
#line 375
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t create completion channel\n");
      }
#line 376
      goto clean_device;
    }
  } else {
#line 379
    ctx->channel = (struct ibv_comp_channel *)((void *)0);
  }
  {
#line 381
  ctx->pd = ibv_alloc_pd(ctx->context);
  }
#line 382
  if (! ctx->pd) {
    {
#line 383
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t allocate PD\n");
    }
#line 384
    goto clean_comp_channel;
  }
  {
#line 387
  ctx->mr = ibv_reg_mr(ctx->pd, ctx->buf, (size_t )size, 1);
  }
#line 388
  if (! ctx->mr) {
    {
#line 389
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t register MR\n");
    }
#line 390
    goto clean_pd;
  }
  {
#line 393
  ctx->cq = ibv_create_cq(ctx->context, rx_depth + num_qp, (void *)0, ctx->channel,
                          0);
  }
#line 395
  if (! ctx->cq) {
    {
#line 396
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t create CQ\n");
    }
#line 397
    goto clean_mr;
  }
  {
#line 401
  attr.srq_context = (void *)0;
#line 401
  attr.attr.max_wr = (uint32_t )rx_depth;
#line 401
  attr.attr.max_sge = (uint32_t )1;
#line 401
  attr.attr.srq_limit = 0U;
#line 408
  ctx->srq = ibv_create_srq(ctx->pd, & attr);
  }
#line 409
  if (! ctx->srq) {
    {
#line 410
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t create SRQ\n");
    }
#line 411
    goto clean_cq;
  }
#line 415
  i = 0;
  {
#line 415
  while (1) {
    while_continue: /* CIL Label */ ;
#line 415
    if (! (i < num_qp)) {
#line 415
      goto while_break;
    }
    {
#line 416
    attr___0.qp_context = (void *)0;
#line 416
    attr___0.send_cq = ctx->cq;
#line 416
    attr___0.recv_cq = ctx->cq;
#line 416
    attr___0.srq = ctx->srq;
#line 416
    attr___0.cap.max_send_wr = (uint32_t )1;
#line 416
    attr___0.cap.max_recv_wr = 0U;
#line 416
    attr___0.cap.max_send_sge = (uint32_t )1;
#line 416
    attr___0.cap.max_recv_sge = 0U;
#line 416
    attr___0.cap.max_inline_data = 0U;
#line 416
    attr___0.qp_type = (enum ibv_qp_type )2;
#line 416
    attr___0.sq_sig_all = 0;
#line 427
    ctx->qp[i] = ibv_create_qp(ctx->pd, & attr___0);
    }
#line 428
    if (! ctx->qp[i]) {
      {
#line 429
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t create QP[%d]\n",
              i);
      }
#line 430
      goto clean_qps;
    }
#line 415
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 434
  i = 0;
  {
#line 434
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 434
    if (! (i < num_qp)) {
#line 434
      goto while_break___0;
    }
    {
#line 435
    attr___1.qp_state = (enum ibv_qp_state )1;
#line 435
    attr___1.cur_qp_state = 0U;
#line 435
    attr___1.path_mtu = 0U;
#line 435
    attr___1.path_mig_state = 0U;
#line 435
    attr___1.qkey = 0U;
#line 435
    attr___1.rq_psn = 0U;
#line 435
    attr___1.sq_psn = 0U;
#line 435
    attr___1.dest_qp_num = 0U;
#line 435
    attr___1.qp_access_flags = 0;
#line 435
    attr___1.cap.max_send_wr = 0U;
#line 435
    attr___1.cap.max_recv_wr = 0U;
#line 435
    attr___1.cap.max_send_sge = 0U;
#line 435
    attr___1.cap.max_recv_sge = 0U;
#line 435
    attr___1.cap.max_inline_data = 0U;
#line 435
    attr___1.ah_attr.grh.dgid.raw[0] = (unsigned char)0;
#line 435
    attr___1.ah_attr.grh.dgid.raw[1] = (unsigned char)0;
#line 435
    attr___1.ah_attr.grh.dgid.raw[2] = (unsigned char)0;
#line 435
    attr___1.ah_attr.grh.dgid.raw[3] = (unsigned char)0;
#line 435
    attr___1.ah_attr.grh.dgid.raw[4] = (unsigned char)0;
#line 435
    attr___1.ah_attr.grh.dgid.raw[5] = (unsigned char)0;
#line 435
    attr___1.ah_attr.grh.dgid.raw[6] = (unsigned char)0;
#line 435
    attr___1.ah_attr.grh.dgid.raw[7] = (unsigned char)0;
#line 435
    attr___1.ah_attr.grh.dgid.raw[8] = (unsigned char)0;
#line 435
    attr___1.ah_attr.grh.dgid.raw[9] = (unsigned char)0;
#line 435
    attr___1.ah_attr.grh.dgid.raw[10] = (unsigned char)0;
#line 435
    attr___1.ah_attr.grh.dgid.raw[11] = (unsigned char)0;
#line 435
    attr___1.ah_attr.grh.dgid.raw[12] = (unsigned char)0;
#line 435
    attr___1.ah_attr.grh.dgid.raw[13] = (unsigned char)0;
#line 435
    attr___1.ah_attr.grh.dgid.raw[14] = (unsigned char)0;
#line 435
    attr___1.ah_attr.grh.dgid.raw[15] = (unsigned char)0;
#line 435
    attr___1.ah_attr.grh.flow_label = 0U;
#line 435
    attr___1.ah_attr.grh.sgid_index = (unsigned char)0;
#line 435
    attr___1.ah_attr.grh.hop_limit = (unsigned char)0;
#line 435
    attr___1.ah_attr.grh.traffic_class = (unsigned char)0;
#line 435
    attr___1.ah_attr.dlid = (unsigned short)0;
#line 435
    attr___1.ah_attr.sl = (unsigned char)0;
#line 435
    attr___1.ah_attr.src_path_bits = (unsigned char)0;
#line 435
    attr___1.ah_attr.static_rate = (unsigned char)0;
#line 435
    attr___1.ah_attr.is_global = (unsigned char)0;
#line 435
    attr___1.ah_attr.port_num = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.grh.dgid.raw[0] = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.grh.dgid.raw[1] = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.grh.dgid.raw[2] = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.grh.dgid.raw[3] = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.grh.dgid.raw[4] = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.grh.dgid.raw[5] = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.grh.dgid.raw[6] = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.grh.dgid.raw[7] = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.grh.dgid.raw[8] = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.grh.dgid.raw[9] = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.grh.dgid.raw[10] = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.grh.dgid.raw[11] = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.grh.dgid.raw[12] = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.grh.dgid.raw[13] = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.grh.dgid.raw[14] = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.grh.dgid.raw[15] = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.grh.flow_label = 0U;
#line 435
    attr___1.alt_ah_attr.grh.sgid_index = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.grh.hop_limit = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.grh.traffic_class = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.dlid = (unsigned short)0;
#line 435
    attr___1.alt_ah_attr.sl = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.src_path_bits = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.static_rate = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.is_global = (unsigned char)0;
#line 435
    attr___1.alt_ah_attr.port_num = (unsigned char)0;
#line 435
    attr___1.pkey_index = (uint16_t )0;
#line 435
    attr___1.alt_pkey_index = (unsigned short)0;
#line 435
    attr___1.en_sqd_async_notify = (unsigned char)0;
#line 435
    attr___1.sq_draining = (unsigned char)0;
#line 435
    attr___1.max_rd_atomic = (unsigned char)0;
#line 435
    attr___1.max_dest_rd_atomic = (unsigned char)0;
#line 435
    attr___1.min_rnr_timer = (unsigned char)0;
#line 435
    attr___1.port_num = (uint8_t )port;
#line 435
    attr___1.timeout = (unsigned char)0;
#line 435
    attr___1.retry_cnt = (unsigned char)0;
#line 435
    attr___1.rnr_retry = (unsigned char)0;
#line 435
    attr___1.alt_port_num = (unsigned char)0;
#line 435
    attr___1.alt_timeout = (unsigned char)0;
#line 442
    tmp___1 = ibv_modify_qp(ctx->qp[i], & attr___1, 57);
    }
#line 442
    if (tmp___1) {
      {
#line 447
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to modify QP[%d] to INIT\n",
              i);
      }
#line 448
      goto clean_qps_full;
    }
#line 434
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 452
  return (ctx);
  clean_qps_full: 
#line 455
  i = num_qp;
  clean_qps: 
#line 458
  i --;
  {
#line 458
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 458
    if (! (i >= 0)) {
#line 458
      goto while_break___1;
    }
    {
#line 459
    ibv_destroy_qp(ctx->qp[i]);
#line 458
    i --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 461
  ibv_destroy_srq(ctx->srq);
  }
  clean_cq: 
  {
#line 464
  ibv_destroy_cq(ctx->cq);
  }
  clean_mr: 
  {
#line 467
  ibv_dereg_mr(ctx->mr);
  }
  clean_pd: 
  {
#line 470
  ibv_dealloc_pd(ctx->pd);
  }
  clean_comp_channel: 
#line 473
  if (ctx->channel) {
    {
#line 474
    ibv_destroy_comp_channel(ctx->channel);
    }
  }
  clean_device: 
  {
#line 477
  ibv_close_device(ctx->context);
  }
  clean_buffer: 
  {
#line 480
  free(ctx->buf);
  }
  clean_ctx: 
  {
#line 483
  free((void *)ctx);
  }
#line 485
  return ((struct pingpong_context___0 *)((void *)0));
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/srq_pingpong.c"
static int pp_post_recv___1(struct pingpong_context___0 *ctx , int n ) 
{ 
  struct ibv_sge list ;
  struct ibv_recv_wr wr ;
  struct ibv_recv_wr *bad_wr ;
  int i ;
  int tmp ;

  {
#line 539
  list.addr = (uintptr_t )ctx->buf;
#line 539
  list.length = (uint32_t )ctx->size;
#line 539
  list.lkey = (ctx->mr)->lkey;
#line 544
  wr.wr_id = (uint64_t )1;
#line 544
  wr.next = (struct ibv_recv_wr *)0;
#line 544
  wr.sg_list = & list;
#line 544
  wr.num_sge = 1;
#line 552
  i = 0;
  {
#line 552
  while (1) {
    while_continue: /* CIL Label */ ;
#line 552
    if (! (i < n)) {
#line 552
      goto while_break;
    }
    {
#line 553
    tmp = ibv_post_srq_recv(ctx->srq, & wr, & bad_wr);
    }
#line 553
    if (tmp) {
#line 554
      goto while_break;
    }
#line 552
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  return (i);
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/srq_pingpong.c"
static int pp_post_send___1(struct pingpong_context___0 *ctx , int qp_index ) 
{ 
  struct ibv_sge list ;
  struct ibv_send_wr wr ;
  struct ibv_send_wr *bad_wr ;
  int tmp ;

  {
  {
#line 561
  list.addr = (uintptr_t )ctx->buf;
#line 561
  list.length = (uint32_t )ctx->size;
#line 561
  list.lkey = (ctx->mr)->lkey;
#line 566
  wr.wr_id = (uint64_t )2;
#line 566
  wr.next = (struct ibv_send_wr *)0;
#line 566
  wr.sg_list = & list;
#line 566
  wr.num_sge = 1;
#line 566
  wr.opcode = (enum ibv_wr_opcode )2;
#line 566
  wr.send_flags = 2;
#line 566
  wr.imm_data = 0U;
#line 566
  wr.wr.atomic.remote_addr = 0UL;
#line 566
  wr.wr.atomic.compare_add = 0UL;
#line 566
  wr.wr.atomic.swap = 0UL;
#line 566
  wr.wr.atomic.rkey = 0U;
#line 575
  tmp = ibv_post_send(ctx->qp[qp_index], & wr, & bad_wr);
  }
#line 575
  return (tmp);
}
}
#line 578 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/srq_pingpong.c"
static int find_qp(int qpn , struct pingpong_context___0 *ctx , int num_qp ) 
{ 
  int i ;

  {
#line 582
  i = 0;
  {
#line 582
  while (1) {
    while_continue: /* CIL Label */ ;
#line 582
    if (! (i < num_qp)) {
#line 582
      goto while_break;
    }
#line 583
    if ((ctx->qp[i])->qp_num == (uint32_t )qpn) {
#line 584
      return (i);
    }
#line 582
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 586
  return (-1);
}
}
#line 589 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/srq_pingpong.c"
static void usage___2(char const   *argv0 ) 
{ 


  {
  {
#line 591
  printf((char const   */* __restrict  */)"Usage:\n");
#line 592
  printf((char const   */* __restrict  */)"  %s            start a server and wait for connection\n",
         argv0);
#line 593
  printf((char const   */* __restrict  */)"  %s <host>     connect to server at <host>\n",
         argv0);
#line 594
  printf((char const   */* __restrict  */)"\n");
#line 595
  printf((char const   */* __restrict  */)"Options:\n");
#line 596
  printf((char const   */* __restrict  */)"  -p, --port=<port>      listen on/connect to port <port> (default 18515)\n");
#line 597
  printf((char const   */* __restrict  */)"  -d, --ib-dev=<dev>     use IB device <dev> (default first device found)\n");
#line 598
  printf((char const   */* __restrict  */)"  -i, --ib-port=<port>   use port <port> of IB device (default 1)\n");
#line 599
  printf((char const   */* __restrict  */)"  -s, --size=<size>      size of message to exchange (default 4096)\n");
#line 600
  printf((char const   */* __restrict  */)"  -m, --mtu=<size>       path MTU (default 1024)\n");
#line 601
  printf((char const   */* __restrict  */)"  -q, --num-qp=<num>     number of QPs to use (default 16)\n");
#line 602
  printf((char const   */* __restrict  */)"  -r, --rx-depth=<dep>   number of receives to post at a time (default 500)\n");
#line 603
  printf((char const   */* __restrict  */)"  -n, --iters=<iters>    number of exchanges per QP(default 1000)\n");
#line 604
  printf((char const   */* __restrict  */)"  -l, --sl=<sl>          service level value\n");
#line 605
  printf((char const   */* __restrict  */)"  -e, --events           sleep on CQ events (default poll)\n");
#line 606
  printf((char const   */* __restrict  */)"  -g, --gid-idx=<gid index> local port gid index\n");
  }
#line 607
  return;
}
}
#line 642 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/srq_pingpong.c"
static struct option long_options___2[12]  = 
#line 642
  {      {"port", 1, (int *)0, 'p'}, 
        {"ib-dev", 1, (int *)0, 'd'}, 
        {"ib-port", 1, (int *)0, 'i'}, 
        {"size", 1, (int *)0, 's'}, 
        {"mtu", 1, (int *)0, 'm'}, 
        {"num-qp", 1, (int *)0, 'q'}, 
        {"rx-depth", 1, (int *)0, 'r'}, 
        {"iters", 1, (int *)0, 'n'}, 
        {"sl", 1, (int *)0, 'l'}, 
        {"events", 0, (int *)0, 'e'}, 
        {"gid-idx", 1, (int *)0, 'g'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 132 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
__asm__(".symver __ibv_query_device,ibv_query_device@@IBVERBS_1.1");
#line 139
__asm__(".symver __ibv_query_port,ibv_query_port@@IBVERBS_1.1");
#line 164
__asm__(".symver __ibv_query_gid,ibv_query_gid@@IBVERBS_1.1");
#line 185
__asm__(".symver __ibv_query_pkey,ibv_query_pkey@@IBVERBS_1.1");
#line 197
__asm__(".symver __ibv_alloc_pd,ibv_alloc_pd@@IBVERBS_1.1");
#line 203
__asm__(".symver __ibv_dealloc_pd,ibv_dealloc_pd@@IBVERBS_1.1");
#line 224
__asm__(".symver __ibv_reg_mr,ibv_reg_mr@@IBVERBS_1.1");
#line 238
__asm__(".symver __ibv_dereg_mr,ibv_dereg_mr@@IBVERBS_1.1");
#line 243 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int warned___4  ;
#line 240 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static struct ibv_comp_channel *ibv_create_comp_channel_v2___4(struct ibv_context *context ) 
{ 
  struct ibv_abi_compat_v2 *t ;
  int tmp ;

  {
  {
#line 242
  t = (struct ibv_abi_compat_v2 *)context->abi_compat;
#line 245
  tmp = pthread_mutex_trylock(& t->in_use);
  }
#line 245
  if (! tmp) {
#line 246
    return (& t->channel);
  }
#line 248
  if (! warned___4) {
    {
#line 249
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: kernel\'s ABI version %d limits capacity.\n    Only one completion channel can be created per context.\n",
            abi_ver);
#line 252
    warned___4 ++;
    }
  }
#line 255
  return ((struct ibv_comp_channel *)((void *)0));
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int ibv_destroy_comp_channel_v2___4(struct ibv_comp_channel *channel ) 
{ 
  struct ibv_abi_compat_v2 *t ;

  {
  {
#line 288
  t = (struct ibv_abi_compat_v2 *)channel;
#line 289
  pthread_mutex_unlock(& t->in_use);
  }
#line 290
  return (0);
}
}
#line 346
__asm__(".symver __ibv_create_cq,ibv_create_cq@@IBVERBS_1.1");
#line 355
__asm__(".symver __ibv_resize_cq,ibv_resize_cq@@IBVERBS_1.1");
#line 375
__asm__(".symver __ibv_destroy_cq,ibv_destroy_cq@@IBVERBS_1.1");
#line 393
__asm__(".symver __ibv_get_cq_event,ibv_get_cq_event@@IBVERBS_1.1");
#line 402
__asm__(".symver __ibv_ack_cq_events,ibv_ack_cq_events@@IBVERBS_1.1");
#line 424
__asm__(".symver __ibv_create_srq,ibv_create_srq@@IBVERBS_1.1");
#line 432
__asm__(".symver __ibv_modify_srq,ibv_modify_srq@@IBVERBS_1.1");
#line 438
__asm__(".symver __ibv_query_srq,ibv_query_srq@@IBVERBS_1.1");
#line 444
__asm__(".symver __ibv_destroy_srq,ibv_destroy_srq@@IBVERBS_1.1");
#line 467
__asm__(".symver __ibv_create_qp,ibv_create_qp@@IBVERBS_1.1");
#line 484
__asm__(".symver __ibv_query_qp,ibv_query_qp@@IBVERBS_1.1");
#line 500
__asm__(".symver __ibv_modify_qp,ibv_modify_qp@@IBVERBS_1.1");
#line 506
__asm__(".symver __ibv_destroy_qp,ibv_destroy_qp@@IBVERBS_1.1");
#line 519
__asm__(".symver __ibv_create_ah,ibv_create_ah@@IBVERBS_1.1");
#line 521 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int ibv_find_gid_index___4(struct ibv_context *context , uint8_t port_num ,
                                  union ibv_gid *gid ) 
{ 
  union ibv_gid sgid ;
  int i ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 525
  i = 0;
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 528
    tmp = i;
#line 528
    i ++;
#line 528
    ret = ibv_query_gid(context, port_num, tmp, & sgid);
    }
#line 527
    if (! ret) {
      {
#line 527
      tmp___0 = memcmp((void const   *)(& sgid), (void const   *)gid, sizeof(*gid));
      }
#line 527
      if (! tmp___0) {
#line 527
        goto while_break;
      }
    } else {
#line 527
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 531
  if (ret) {
#line 531
    tmp___1 = ret;
  } else {
#line 531
    tmp___1 = i - 1;
  }
#line 531
  return (tmp___1);
}
}
#line 581
__asm__(".symver __ibv_destroy_ah,ibv_destroy_ah@@IBVERBS_1.1");
#line 587
__asm__(".symver __ibv_attach_mcast,ibv_attach_mcast@@IBVERBS_1.1");
#line 593
__asm__(".symver __ibv_detach_mcast,ibv_detach_mcast@@IBVERBS_1.1");
#line 82 "./include/infiniband/verbs.h"
static void *__VERBS_ABI_IS_EXTENDED___4  =    (void *)((uint8_t *)((void *)0) - 1);
#line 877 "./include/infiniband/verbs.h"
__inline static struct verbs_context *verbs_get_ctx___4(struct ibv_context *ctx ) 
{ 
  struct verbs_context *tmp ;

  {
#line 879
  if ((unsigned long )ctx->abi_compat != (unsigned long )__VERBS_ABI_IS_EXTENDED___4) {
#line 879
    tmp = (struct verbs_context *)((void *)0);
  } else {
#line 879
    tmp = (struct verbs_context *)((uint8_t *)ctx - (unsigned long )(& ((struct verbs_context *)0)->context));
  }
#line 879
  return (tmp);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static pthread_once_t device_list_once___4  =    0;
#line 53 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static int num_devices___4  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static struct ibv_device **device_list___4  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static void count_devices___4(void) 
{ 
  int __attribute__((__visibility__("hidden")))  tmp ;

  {
  {
#line 58
  tmp = ibverbs_init(& device_list___4);
#line 58
  num_devices___4 = (int )tmp;
  }
#line 59
  return;
}
}
#line 89
__asm__(".symver __ibv_get_device_list,ibv_get_device_list@@IBVERBS_1.1");
#line 95
__asm__(".symver __ibv_free_device_list,ibv_free_device_list@@IBVERBS_1.1");
#line 101
__asm__(".symver __ibv_get_device_name,ibv_get_device_name@@IBVERBS_1.1");
#line 123
__asm__(".symver __ibv_get_device_guid,ibv_get_device_guid@@IBVERBS_1.1");
#line 190
__asm__(".symver __ibv_open_device,ibv_open_device@@IBVERBS_1.1");
#line 215
__asm__(".symver __ibv_close_device,ibv_close_device@@IBVERBS_1.1");
#line 258
__asm__(".symver __ibv_get_async_event,ibv_get_async_event@@IBVERBS_1.1");
#line 311
__asm__(".symver __ibv_ack_async_event,ibv_ack_async_event@@IBVERBS_1.1");
#line 73 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *mm_root___4  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static pthread_mutex_t mm_mutex___4  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 75 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int page_size___7  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int huge_page_enabled___4  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int too_late___4  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static unsigned long smaps_page_size___4(FILE *file ) 
{ 
  int n ;
  unsigned long size ;
  char buf[1024] ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 82
  size = (unsigned long )page_size___7;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 85
    tmp___0 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)file);
    }
#line 85
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 85
      goto while_break;
    }
    {
#line 86
    tmp = strstr((char const   *)(buf), "KernelPageSize:");
    }
#line 86
    if (! tmp) {
#line 87
      goto while_continue;
    }
    {
#line 89
    n = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*s %lu",
               & size);
    }
#line 90
    if (n < 1) {
#line 91
      goto while_continue;
    }
#line 94
    size *= 1024UL;
#line 96
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return (size);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static unsigned long get_page_size___4(void *base ) 
{ 
  unsigned long ret ;
  pid_t pid ;
  FILE *file ;
  char buf[1024] ;
  int n ;
  uintptr_t range_start ;
  uintptr_t range_end ;
  char *tmp ;

  {
  {
#line 104
  ret = (unsigned long )page_size___7;
#line 109
  pid = getpid();
#line 110
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"/proc/%d/smaps",
           pid);
#line 112
  file = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"re");
  }
#line 113
  if (! file) {
#line 114
    goto out;
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 116
    tmp = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)file);
    }
#line 116
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 116
      goto while_break;
    }
    {
#line 120
    n = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%lx-%lx",
               & range_start, & range_end);
    }
#line 122
    if (n < 2) {
#line 123
      goto while_continue;
    }
#line 125
    if ((uintptr_t )base >= range_start) {
#line 125
      if ((uintptr_t )base < range_end) {
        {
#line 126
        ret = smaps_page_size___4(file);
        }
#line 127
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  fclose(file);
  }
  out: 
#line 134
  return (ret);
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_prev___4(struct ibv_mem_node *node ) 
{ 


  {
#line 194
  if (node->left) {
#line 195
    node = node->left;
    {
#line 196
    while (1) {
      while_continue: /* CIL Label */ ;
#line 196
      if (! node->right) {
#line 196
        goto while_break;
      }
#line 197
      node = node->right;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 199
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 199
      if (node->parent) {
#line 199
        if (! ((unsigned long )node == (unsigned long )(node->parent)->left)) {
#line 199
          goto while_break___0;
        }
      } else {
#line 199
        goto while_break___0;
      }
#line 200
      node = node->parent;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 202
    node = node->parent;
  }
#line 205
  return (node);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_next___4(struct ibv_mem_node *node ) 
{ 


  {
#line 210
  if (node->right) {
#line 211
    node = node->right;
    {
#line 212
    while (1) {
      while_continue: /* CIL Label */ ;
#line 212
      if (! node->left) {
#line 212
        goto while_break;
      }
#line 213
      node = node->left;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 215
      if (node->parent) {
#line 215
        if (! ((unsigned long )node == (unsigned long )(node->parent)->right)) {
#line 215
          goto while_break___0;
        }
      } else {
#line 215
        goto while_break___0;
      }
#line 216
      node = node->parent;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 218
    node = node->parent;
  }
#line 221
  return (node);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_rotate_right___4(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 228
  tmp = node->left;
#line 230
  node->left = tmp->right;
#line 231
  if (node->left) {
#line 232
    (node->left)->parent = node;
  }
#line 234
  if (node->parent) {
#line 235
    if ((unsigned long )(node->parent)->right == (unsigned long )node) {
#line 236
      (node->parent)->right = tmp;
    } else {
#line 238
      (node->parent)->left = tmp;
    }
  } else {
#line 240
    mm_root___4 = tmp;
  }
#line 242
  tmp->parent = node->parent;
#line 244
  tmp->right = node;
#line 245
  node->parent = tmp;
#line 246
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_rotate_left___4(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 252
  tmp = node->right;
#line 254
  node->right = tmp->left;
#line 255
  if (node->right) {
#line 256
    (node->right)->parent = node;
  }
#line 258
  if (node->parent) {
#line 259
    if ((unsigned long )(node->parent)->right == (unsigned long )node) {
#line 260
      (node->parent)->right = tmp;
    } else {
#line 262
      (node->parent)->left = tmp;
    }
  } else {
#line 264
    mm_root___4 = tmp;
  }
#line 266
  tmp->parent = node->parent;
#line 268
  tmp->left = node;
#line 269
  node->parent = tmp;
#line 270
  return;
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_add_rebalance___4(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *parent ;
  struct ibv_mem_node *gp ;
  struct ibv_mem_node *uncle ;

  {
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (node->parent) {
#line 304
      if (! ((unsigned int )(node->parent)->color == 0U)) {
#line 304
        goto while_break;
      }
    } else {
#line 304
      goto while_break;
    }
#line 305
    parent = node->parent;
#line 306
    gp = (node->parent)->parent;
#line 308
    if ((unsigned long )parent == (unsigned long )gp->left) {
#line 309
      uncle = gp->right;
#line 311
      if (uncle) {
#line 311
        if ((unsigned int )uncle->color == 0U) {
#line 312
          parent->color = (enum __anonenum_color_68 )1;
#line 313
          uncle->color = (enum __anonenum_color_68 )1;
#line 314
          gp->color = (enum __anonenum_color_68 )0;
#line 316
          node = gp;
        } else {
#line 311
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 318
        if ((unsigned long )node == (unsigned long )parent->right) {
          {
#line 319
          __mm_rotate_left___4(parent);
#line 320
          node = parent;
#line 321
          parent = node->parent;
          }
        }
        {
#line 324
        parent->color = (enum __anonenum_color_68 )1;
#line 325
        gp->color = (enum __anonenum_color_68 )0;
#line 327
        __mm_rotate_right___4(gp);
        }
      }
    } else {
#line 330
      uncle = gp->left;
#line 332
      if (uncle) {
#line 332
        if ((unsigned int )uncle->color == 0U) {
#line 333
          parent->color = (enum __anonenum_color_68 )1;
#line 334
          uncle->color = (enum __anonenum_color_68 )1;
#line 335
          gp->color = (enum __anonenum_color_68 )0;
#line 337
          node = gp;
        } else {
#line 332
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 339
        if ((unsigned long )node == (unsigned long )parent->left) {
          {
#line 340
          __mm_rotate_right___4(parent);
#line 341
          node = parent;
#line 342
          parent = node->parent;
          }
        }
        {
#line 345
        parent->color = (enum __anonenum_color_68 )1;
#line 346
        gp->color = (enum __anonenum_color_68 )0;
#line 348
        __mm_rotate_left___4(gp);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  mm_root___4->color = (enum __anonenum_color_68 )1;
#line 354
  return;
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_add___4(struct ibv_mem_node *new ) 
{ 
  struct ibv_mem_node *node ;
  struct ibv_mem_node *parent ;

  {
#line 358
  parent = (struct ibv_mem_node *)((void *)0);
#line 360
  node = mm_root___4;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! node) {
#line 361
      goto while_break;
    }
#line 362
    parent = node;
#line 363
    if (node->start < new->start) {
#line 364
      node = node->right;
    } else {
#line 366
      node = node->left;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  if (parent->start < new->start) {
#line 370
    parent->right = new;
  } else {
#line 372
    parent->left = new;
  }
  {
#line 374
  new->parent = parent;
#line 375
  new->left = (struct ibv_mem_node *)((void *)0);
#line 376
  new->right = (struct ibv_mem_node *)((void *)0);
#line 378
  new->color = (enum __anonenum_color_68 )0;
#line 379
  __mm_add_rebalance___4(new);
  }
#line 380
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_remove___4(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *child ;
  struct ibv_mem_node *parent ;
  struct ibv_mem_node *sib ;
  struct ibv_mem_node *tmp ;
  int nodecol ;

  {
#line 387
  if (node->left) {
#line 387
    if (node->right) {
#line 388
      tmp = node->left;
      {
#line 389
      while (1) {
        while_continue: /* CIL Label */ ;
#line 389
        if (! tmp->right) {
#line 389
          goto while_break;
        }
#line 390
        tmp = tmp->right;
      }
      while_break: /* CIL Label */ ;
      }
#line 392
      nodecol = (int )tmp->color;
#line 393
      child = tmp->left;
#line 394
      tmp->color = node->color;
#line 396
      if ((unsigned long )tmp->parent != (unsigned long )node) {
#line 397
        parent = tmp->parent;
#line 398
        parent->right = tmp->left;
#line 399
        if (tmp->left) {
#line 400
          (tmp->left)->parent = parent;
        }
#line 402
        tmp->left = node->left;
#line 403
        (node->left)->parent = tmp;
      } else {
#line 405
        parent = tmp;
      }
#line 407
      tmp->right = node->right;
#line 408
      (node->right)->parent = tmp;
#line 410
      tmp->parent = node->parent;
#line 411
      if (node->parent) {
#line 412
        if ((unsigned long )(node->parent)->left == (unsigned long )node) {
#line 413
          (node->parent)->left = tmp;
        } else {
#line 415
          (node->parent)->right = tmp;
        }
      } else {
#line 417
        mm_root___4 = tmp;
      }
    } else {
#line 387
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 419
    nodecol = (int )node->color;
#line 421
    if (node->left) {
#line 421
      child = node->left;
    } else {
#line 421
      child = node->right;
    }
#line 422
    parent = node->parent;
#line 424
    if (child) {
#line 425
      child->parent = parent;
    }
#line 426
    if (parent) {
#line 427
      if ((unsigned long )parent->left == (unsigned long )node) {
#line 428
        parent->left = child;
      } else {
#line 430
        parent->right = child;
      }
    } else {
#line 432
      mm_root___4 = child;
    }
  }
  {
#line 435
  free((void *)node);
  }
#line 437
  if (nodecol == 0) {
#line 438
    return;
  }
  {
#line 440
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 440
    if (! child) {
#line 440
      goto _L___6;
    } else
#line 440
    if ((unsigned int )child->color == 1U) {
      _L___6: /* CIL Label */ 
#line 440
      if (! ((unsigned long )child != (unsigned long )mm_root___4)) {
#line 440
        goto while_break___0;
      }
    } else {
#line 440
      goto while_break___0;
    }
#line 441
    if ((unsigned long )parent->left == (unsigned long )child) {
#line 442
      sib = parent->right;
#line 444
      if ((unsigned int )sib->color == 0U) {
        {
#line 445
        parent->color = (enum __anonenum_color_68 )0;
#line 446
        sib->color = (enum __anonenum_color_68 )1;
#line 447
        __mm_rotate_left___4(parent);
#line 448
        sib = parent->right;
        }
      }
#line 451
      if (! sib->left) {
#line 451
        goto _L___2;
      } else
#line 451
      if ((unsigned int )(sib->left)->color == 1U) {
        _L___2: /* CIL Label */ 
#line 451
        if (! sib->right) {
#line 453
          sib->color = (enum __anonenum_color_68 )0;
#line 454
          child = parent;
#line 455
          parent = child->parent;
        } else
#line 451
        if ((unsigned int )(sib->right)->color == 1U) {
#line 453
          sib->color = (enum __anonenum_color_68 )0;
#line 454
          child = parent;
#line 455
          parent = child->parent;
        } else {
#line 451
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 457
        if (! sib->right) {
#line 457
          goto _L___0;
        } else
#line 457
        if ((unsigned int )(sib->right)->color == 1U) {
          _L___0: /* CIL Label */ 
#line 458
          if (sib->left) {
#line 459
            (sib->left)->color = (enum __anonenum_color_68 )1;
          }
          {
#line 460
          sib->color = (enum __anonenum_color_68 )0;
#line 461
          __mm_rotate_right___4(sib);
#line 462
          sib = parent->right;
          }
        }
#line 465
        sib->color = parent->color;
#line 466
        parent->color = (enum __anonenum_color_68 )1;
#line 467
        if (sib->right) {
#line 468
          (sib->right)->color = (enum __anonenum_color_68 )1;
        }
        {
#line 469
        __mm_rotate_left___4(parent);
#line 470
        child = mm_root___4;
        }
#line 471
        goto while_break___0;
      }
    } else {
#line 474
      sib = parent->left;
#line 476
      if ((unsigned int )sib->color == 0U) {
        {
#line 477
        parent->color = (enum __anonenum_color_68 )0;
#line 478
        sib->color = (enum __anonenum_color_68 )1;
#line 479
        __mm_rotate_right___4(parent);
#line 480
        sib = parent->left;
        }
      }
#line 483
      if (! sib->left) {
#line 483
        goto _L___5;
      } else
#line 483
      if ((unsigned int )(sib->left)->color == 1U) {
        _L___5: /* CIL Label */ 
#line 483
        if (! sib->right) {
#line 485
          sib->color = (enum __anonenum_color_68 )0;
#line 486
          child = parent;
#line 487
          parent = child->parent;
        } else
#line 483
        if ((unsigned int )(sib->right)->color == 1U) {
#line 485
          sib->color = (enum __anonenum_color_68 )0;
#line 486
          child = parent;
#line 487
          parent = child->parent;
        } else {
#line 483
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
#line 489
        if (! sib->left) {
#line 489
          goto _L___3;
        } else
#line 489
        if ((unsigned int )(sib->left)->color == 1U) {
          _L___3: /* CIL Label */ 
#line 490
          if (sib->right) {
#line 491
            (sib->right)->color = (enum __anonenum_color_68 )1;
          }
          {
#line 492
          sib->color = (enum __anonenum_color_68 )0;
#line 493
          __mm_rotate_left___4(sib);
#line 494
          sib = parent->left;
          }
        }
#line 497
        sib->color = parent->color;
#line 498
        parent->color = (enum __anonenum_color_68 )1;
#line 499
        if (sib->left) {
#line 500
          (sib->left)->color = (enum __anonenum_color_68 )1;
        }
        {
#line 501
        __mm_rotate_right___4(parent);
#line 502
        child = mm_root___4;
        }
#line 503
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 508
  if (child) {
#line 509
    child->color = (enum __anonenum_color_68 )1;
  }
#line 510
  return;
}
}
#line 512 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_find_start___4(uintptr_t start , uintptr_t end ) 
{ 
  struct ibv_mem_node *node ;

  {
#line 514
  node = mm_root___4;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! node) {
#line 516
      goto while_break;
    }
#line 517
    if (node->start <= start) {
#line 517
      if (node->end >= start) {
#line 518
        goto while_break;
      }
    }
#line 520
    if (node->start < start) {
#line 521
      node = node->right;
    } else {
#line 523
      node = node->left;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 526
  return (node);
}
}
#line 529 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *merge_ranges___4(struct ibv_mem_node *node , struct ibv_mem_node *prev ) 
{ 


  {
  {
#line 532
  prev->end = node->end;
#line 533
  prev->refcnt = node->refcnt;
#line 534
  __mm_remove___4(node);
  }
#line 536
  return (prev);
}
}
#line 539 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *split_range___4(struct ibv_mem_node *node , uintptr_t cut_line ) 
{ 
  struct ibv_mem_node *new_node ;
  void *tmp ;

  {
  {
#line 542
  new_node = (struct ibv_mem_node *)((void *)0);
#line 544
  tmp = malloc(sizeof(*new_node));
#line 544
  new_node = (struct ibv_mem_node *)tmp;
  }
#line 545
  if (! new_node) {
#line 546
    return ((struct ibv_mem_node *)((void *)0));
  }
  {
#line 547
  new_node->start = cut_line;
#line 548
  new_node->end = node->end;
#line 549
  new_node->refcnt = node->refcnt;
#line 550
  node->end = cut_line - 1UL;
#line 551
  __mm_add___4(new_node);
  }
#line 553
  return (new_node);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *get_start_node___4(uintptr_t start , uintptr_t end , int inc ) 
{ 
  struct ibv_mem_node *node ;
  struct ibv_mem_node *tmp ;

  {
  {
#line 559
  tmp = (struct ibv_mem_node *)((void *)0);
#line 561
  node = __mm_find_start___4(start, end);
  }
#line 562
  if (node->start < start) {
    {
#line 563
    node = split_range___4(node, start);
    }
  } else {
    {
#line 565
    tmp = __mm_prev___4(node);
    }
#line 566
    if (tmp) {
#line 566
      if (tmp->refcnt == node->refcnt + inc) {
        {
#line 567
        node = merge_ranges___4(node, tmp);
        }
      }
    }
  }
#line 569
  return (node);
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *undo_node___4(struct ibv_mem_node *node , uintptr_t start ,
                                          int inc ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 579
  tmp = (struct ibv_mem_node *)((void *)0);
#line 585
  if (start > node->start) {
    {
#line 586
    tmp = split_range___4(node, start);
    }
#line 587
    if (tmp) {
#line 588
      node->refcnt += inc;
#line 589
      node = tmp;
    } else {
#line 591
      return ((struct ibv_mem_node *)((void *)0));
    }
  }
  {
#line 594
  tmp = __mm_prev___4(node);
  }
#line 595
  if (tmp) {
#line 595
    if (tmp->refcnt == node->refcnt) {
      {
#line 596
      node = merge_ranges___4(node, tmp);
      }
    }
  }
  {
#line 598
  tmp = __mm_next___4(node);
  }
#line 599
  if (tmp) {
#line 599
    if (tmp->refcnt == node->refcnt) {
      {
#line 600
      node = merge_ranges___4(tmp, node);
      }
    }
  }
#line 602
  return (node);
}
}
#line 605 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int ibv_madvise_range___4(void *base , size_t size , int advice ) 
{ 
  uintptr_t start ;
  uintptr_t end ;
  struct ibv_mem_node *node ;
  struct ibv_mem_node *tmp ;
  int inc ;
  int rolling_back ;
  int ret ;
  unsigned long range_page_size ;
  struct ibv_mem_node *tmp___0 ;

  {
#line 610
  rolling_back = 0;
#line 611
  ret = 0;
#line 614
  if (! size) {
#line 615
    return (0);
  }
#line 617
  if (huge_page_enabled___4) {
    {
#line 618
    range_page_size = get_page_size___4(base);
    }
  } else {
#line 620
    range_page_size = (unsigned long )page_size___7;
  }
  {
#line 622
  start = (uintptr_t )base & ~ (range_page_size - 1UL);
#line 623
  end = ((uintptr_t )(((base + size) + range_page_size) - 1) & ~ (range_page_size - 1UL)) - 1UL;
#line 626
  pthread_mutex_lock(& mm_mutex___4);
  }
  again: 
#line 628
  if (advice == 10) {
#line 628
    inc = 1;
  } else {
#line 628
    inc = -1;
  }
  {
#line 630
  node = get_start_node___4(start, end, inc);
  }
#line 631
  if (! node) {
#line 632
    ret = -1;
#line 633
    goto out;
  }
  {
#line 636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 636
    if (node) {
#line 636
      if (! (node->start <= end)) {
#line 636
        goto while_break;
      }
    } else {
#line 636
      goto while_break;
    }
#line 637
    if (node->end > end) {
      {
#line 638
      tmp___0 = split_range___4(node, end + 1UL);
      }
#line 638
      if (! tmp___0) {
#line 639
        ret = -1;
#line 640
        goto out;
      }
    }
#line 644
    if (inc == -1) {
#line 644
      if (node->refcnt == 1) {
#line 644
        goto _L;
      } else {
#line 644
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 644
    if (inc == 1) {
#line 644
      if (node->refcnt == 0) {
        _L: /* CIL Label */ 
#line 657
        if (start > node->start) {
          {
#line 658
          ret = madvise((void *)start, (node->end - start) + 1UL, advice);
          }
        } else {
          {
#line 661
          ret = madvise((void *)node->start, (node->end - node->start) + 1UL, advice);
          }
        }
#line 664
        if (ret) {
          {
#line 665
          node = undo_node___4(node, start, inc);
          }
#line 667
          if (rolling_back) {
#line 668
            goto out;
          } else
#line 667
          if (! node) {
#line 668
            goto out;
          }
#line 671
          rolling_back = 1;
#line 672
          if (advice == 10) {
#line 672
            advice = 11;
          } else {
#line 672
            advice = 10;
          }
          {
#line 674
          tmp = __mm_prev___4(node);
          }
#line 675
          if (! tmp) {
#line 676
            goto out;
          } else
#line 675
          if (start > tmp->end) {
#line 676
            goto out;
          }
#line 677
          end = tmp->end;
#line 678
          goto again;
        }
      }
    }
    {
#line 682
    node->refcnt += inc;
#line 683
    node = __mm_next___4(node);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if (node) {
    {
#line 687
    tmp = __mm_prev___4(node);
    }
#line 688
    if (tmp) {
#line 688
      if (node->refcnt == tmp->refcnt) {
        {
#line 689
        node = merge_ranges___4(node, tmp);
        }
      }
    }
  }
  out: 
#line 693
  if (rolling_back) {
#line 694
    ret = -1;
  }
  {
#line 696
  pthread_mutex_unlock(& mm_mutex___4);
  }
#line 698
  return (ret);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/sysfs.c"
static char *sysfs_path___4  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_sysfs_dev *sysfs_dev_list___4  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver_name *driver_name_list___4  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver *head_driver___4  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver *tail_driver___4  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static int find_sysfs_devs___4(void) 
{ 
  char class_path[256] ;
  DIR *class_dir ;
  struct dirent *dent ;
  struct ibv_sysfs_dev *sysfs_dev ;
  char value[8] ;
  int ret ;
  char const   *tmp ;
  struct stat buf ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;

  {
  {
#line 86
  sysfs_dev = (struct ibv_sysfs_dev *)((void *)0);
#line 88
  ret = 0;
#line 90
  tmp = ibv_get_sysfs_path();
#line 90
  snprintf((char */* __restrict  */)(class_path), sizeof(class_path), (char const   */* __restrict  */)"%s/class/infiniband_verbs",
           tmp);
#line 93
  class_dir = opendir((char const   *)(class_path));
  }
#line 94
  if (! class_dir) {
#line 95
    return (38);
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    dent = readdir(class_dir);
    }
#line 97
    if (! dent) {
#line 97
      goto while_break;
    }
#line 100
    if ((int )dent->d_name[0] == 46) {
#line 101
      goto while_continue;
    }
#line 103
    if (! sysfs_dev) {
      {
#line 104
      tmp___0 = malloc(sizeof(*sysfs_dev));
#line 104
      sysfs_dev = (struct ibv_sysfs_dev *)tmp___0;
      }
    }
#line 105
    if (! sysfs_dev) {
#line 106
      ret = 12;
#line 107
      goto out;
    }
    {
#line 110
    snprintf((char */* __restrict  */)(sysfs_dev->sysfs_path), sizeof(sysfs_dev->sysfs_path),
             (char const   */* __restrict  */)"%s/%s", class_path, dent->d_name);
#line 113
    tmp___1 = stat((char const   */* __restrict  */)(sysfs_dev->sysfs_path), (struct stat */* __restrict  */)(& buf));
    }
#line 113
    if (tmp___1) {
      {
#line 114
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t stat \'%s\'.\n",
              sysfs_dev->sysfs_path);
      }
#line 116
      goto while_continue;
    }
#line 119
    if (! ((buf.st_mode & 61440U) == 16384U)) {
#line 120
      goto while_continue;
    }
    {
#line 122
    snprintf((char */* __restrict  */)(sysfs_dev->sysfs_name), sizeof(sysfs_dev->sysfs_name),
             (char const   */* __restrict  */)"%s", dent->d_name);
#line 125
    tmp___2 = ibv_read_sysfs_file((char const   *)(sysfs_dev->sysfs_path), "ibdev",
                                  sysfs_dev->ibdev_name, sizeof(sysfs_dev->ibdev_name));
    }
#line 125
    if (tmp___2 < 0) {
      {
#line 128
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: no ibdev class attr for \'%s\'.\n",
              dent->d_name);
      }
#line 130
      goto while_continue;
    }
    {
#line 133
    tmp___3 = ibv_get_sysfs_path();
#line 133
    snprintf((char */* __restrict  */)(sysfs_dev->ibdev_path), sizeof(sysfs_dev->ibdev_path),
             (char const   */* __restrict  */)"%s/class/infiniband/%s", tmp___3, sysfs_dev->ibdev_name);
#line 137
    sysfs_dev->next = sysfs_dev_list___4;
#line 138
    sysfs_dev->have_driver = 0;
#line 139
    tmp___5 = ibv_read_sysfs_file((char const   *)(sysfs_dev->sysfs_path), "abi_version",
                                  value, sizeof(value));
    }
#line 139
    if (tmp___5 > 0) {
      {
#line 141
      tmp___4 = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                       10);
#line 141
      sysfs_dev->abi_ver = (int )tmp___4;
      }
    } else {
#line 143
      sysfs_dev->abi_ver = 0;
    }
#line 145
    sysfs_dev_list___4 = sysfs_dev;
#line 146
    sysfs_dev = (struct ibv_sysfs_dev *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
  out: 
#line 150
  if (sysfs_dev) {
    {
#line 151
    free((void *)sysfs_dev);
    }
  }
  {
#line 153
  closedir(class_dir);
  }
#line 154
  return (ret);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void register_driver___4(char const   *name , struct ibv_device *(*init_func)(char const   *uverbs_sys_path ,
                                                                                     int abi_version ) ,
                                struct verbs_device *(*verbs_init_func)(char const   *uverbs_sys_path ,
                                                                        int abi_version ) ) 
{ 
  struct ibv_driver *driver ;
  void *tmp ;

  {
  {
#line 162
  tmp = malloc(sizeof(*driver));
#line 162
  driver = (struct ibv_driver *)tmp;
  }
#line 163
  if (! driver) {
    {
#line 164
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver for %s\n",
            name);
    }
#line 165
    return;
  }
#line 168
  driver->name = name;
#line 169
  driver->init_func = init_func;
#line 170
  driver->verbs_init_func = verbs_init_func;
#line 171
  driver->next = (struct ibv_driver *)((void *)0);
#line 173
  if (tail_driver___4) {
#line 174
    tail_driver___4->next = driver;
  } else {
#line 176
    head_driver___4 = driver;
  }
#line 177
  tail_driver___4 = driver;
#line 178
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void load_driver___4(char const   *name ) 
{ 
  char *so_name ;
  void *dlhandle ;
  char const   *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 201
  if ((int const   )*(name + 0) == 47) {
#line 201
    tmp = "%s-rdmav2.so";
  } else {
#line 201
    tmp = "lib%s-rdmav2.so";
  }
  {
#line 201
  tmp___0 = asprintf((char **/* __restrict  */)(& so_name), (char const   */* __restrict  */)tmp,
                     name);
  }
#line 201
  if (tmp___0 < 0) {
    {
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t load driver \'%s\'.\n",
            name);
    }
#line 208
    return;
  }
  {
#line 211
  dlhandle = dlopen((char const   *)so_name, 2);
  }
#line 212
  if (! dlhandle) {
    {
#line 213
    tmp___1 = dlerror();
#line 213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t load driver \'%s\': %s\n",
            name, tmp___1);
    }
#line 215
    goto out;
  }
  out: 
  {
#line 219
  free((void *)so_name);
  }
#line 220
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void load_drivers___4(void) 
{ 
  struct ibv_driver_name *name ;
  struct ibv_driver_name *next_name ;
  char const   *env ;
  char *list ;
  char *env_name ;
  char const   *__old ;
  size_t __len ;
  size_t tmp ;
  char *__new ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *__old___0 ;
  size_t __len___0 ;
  size_t tmp___2 ;
  char *__new___0 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;

  {
  {
#line 232
  tmp___7 = getuid();
#line 232
  tmp___8 = geteuid();
  }
#line 232
  if (tmp___7 == tmp___8) {
    {
#line 233
    tmp___6 = getenv("RDMAV_DRIVERS");
#line 233
    env = (char const   *)tmp___6;
    }
#line 233
    if (env) {
      {
#line 234
      __old = env;
#line 234
      tmp = strlen(__old);
#line 234
      __len = tmp + 1UL;
#line 234
      tmp___0 = __builtin_alloca(__len);
#line 234
      __new = (char *)tmp___0;
#line 234
      tmp___1 = memcpy((void */* __restrict  */)__new, (void const   */* __restrict  */)__old,
                       __len);
#line 234
      list = (char *)tmp___1;
      }
      {
#line 235
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 235
        env_name = strsep((char **/* __restrict  */)(& list), (char const   */* __restrict  */)":;");
        }
#line 235
        if (! env_name) {
#line 235
          goto while_break;
        }
        {
#line 236
        load_driver___4((char const   *)env_name);
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 237
      tmp___5 = getenv("IBV_DRIVERS");
#line 237
      env = (char const   *)tmp___5;
      }
#line 237
      if (env) {
        {
#line 238
        __old___0 = env;
#line 238
        tmp___2 = strlen(__old___0);
#line 238
        __len___0 = tmp___2 + 1UL;
#line 238
        tmp___3 = __builtin_alloca(__len___0);
#line 238
        __new___0 = (char *)tmp___3;
#line 238
        tmp___4 = memcpy((void */* __restrict  */)__new___0, (void const   */* __restrict  */)__old___0,
                         __len___0);
#line 238
        list = (char *)tmp___4;
        }
        {
#line 239
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 239
          env_name = strsep((char **/* __restrict  */)(& list), (char const   */* __restrict  */)":;");
          }
#line 239
          if (! env_name) {
#line 239
            goto while_break___0;
          }
          {
#line 240
          load_driver___4((char const   *)env_name);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 244
  name = driver_name_list___4;
#line 244
  if (name) {
#line 244
    next_name = name->next;
  } else {
#line 244
    next_name = (struct ibv_driver_name *)((void *)0);
  }
  {
#line 244
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 244
    if (! name) {
#line 244
      goto while_break___1;
    }
    {
#line 247
    load_driver___4((char const   *)name->name);
#line 248
    free((void *)name->name);
#line 249
    free((void *)name);
#line 244
    name = next_name;
    }
#line 244
    if (name) {
#line 244
      next_name = name->next;
    } else {
#line 244
      next_name = (struct ibv_driver_name *)((void *)0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 251
  return;
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void read_config_file___4(char const   *path ) 
{ 
  FILE *conf ;
  char *line ;
  char *config ;
  char *field ;
  size_t buflen ;
  ssize_t len ;
  size_t tmp ;
  struct ibv_driver_name *driver_name ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 256
  line = (char *)((void *)0);
#line 259
  buflen = (size_t )0;
#line 262
  conf = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"re");
  }
#line 263
  if (! conf) {
    {
#line 264
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t read config file %s.\n",
            path);
    }
#line 266
    return;
  }
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 269
    len = getline((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& buflen),
                  (FILE */* __restrict  */)conf);
    }
#line 269
    if (! (len != -1L)) {
#line 269
      goto while_break;
    }
    {
#line 270
    tmp = strspn((char const   *)line, "\t ");
#line 270
    config = line + tmp;
    }
#line 271
    if ((int )*(config + 0) == 10) {
#line 272
      goto while_continue;
    } else
#line 271
    if ((int )*(config + 0) == 35) {
#line 272
      goto while_continue;
    }
    {
#line 274
    field = strsep((char **/* __restrict  */)(& config), (char const   */* __restrict  */)"\n\t ");
#line 276
    tmp___2 = strcmp((char const   *)field, "driver");
    }
#line 276
    if (tmp___2 == 0) {
#line 276
      if ((unsigned long )config != (unsigned long )((void *)0)) {
        {
#line 279
        tmp___0 = strspn((char const   *)config, "\t ");
#line 279
        config += tmp___0;
#line 280
        field = strsep((char **/* __restrict  */)(& config), (char const   */* __restrict  */)"\n\t ");
#line 282
        tmp___1 = malloc(sizeof(*driver_name));
#line 282
        driver_name = (struct ibv_driver_name *)tmp___1;
        }
#line 283
        if (! driver_name) {
          {
#line 284
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver name \'%s\'.\n",
                  field);
          }
#line 286
          goto while_continue;
        }
        {
#line 289
        driver_name->name = strdup((char const   *)field);
        }
#line 290
        if (! driver_name->name) {
          {
#line 291
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver name \'%s\'.\n",
                  field);
#line 293
          free((void *)driver_name);
          }
#line 294
          goto while_continue;
        }
#line 297
        driver_name->next = driver_name_list___4;
#line 298
        driver_name_list___4 = driver_name;
      } else {
        {
#line 300
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: ignoring bad config directive \'%s\' in file \'%s\'.\n",
                field, path);
        }
      }
    } else {
      {
#line 300
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: ignoring bad config directive \'%s\' in file \'%s\'.\n",
              field, path);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  if (line) {
    {
#line 305
    free((void *)line);
    }
  }
  {
#line 306
  fclose(conf);
  }
#line 307
  return;
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void read_config___4(void) 
{ 
  DIR *conf_dir ;
  struct dirent *dent ;
  char *path ;
  struct stat buf ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 315
  conf_dir = opendir("/usr/local/etc/libibverbs.d");
  }
#line 316
  if (! conf_dir) {
    {
#line 317
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t open config directory \'%s\'.\n",
            "/usr/local/etc/libibverbs.d");
    }
#line 319
    return;
  }
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 322
    dent = readdir(conf_dir);
    }
#line 322
    if (! dent) {
#line 322
      goto while_break;
    }
    {
#line 325
    tmp = asprintf((char **/* __restrict  */)(& path), (char const   */* __restrict  */)"%s/%s",
                   "/usr/local/etc/libibverbs.d", dent->d_name);
    }
#line 325
    if (tmp < 0) {
      {
#line 326
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t read config file %s/%s.\n",
              "/usr/local/etc/libibverbs.d", dent->d_name);
      }
#line 328
      goto out;
    }
    {
#line 331
    tmp___0 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& buf));
    }
#line 331
    if (tmp___0) {
      {
#line 332
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t stat config file \'%s\'.\n",
              path);
      }
#line 334
      goto next;
    }
#line 337
    if (! ((buf.st_mode & 61440U) == 32768U)) {
#line 338
      goto next;
    }
    {
#line 340
    read_config_file___4((char const   *)path);
    }
    next: 
    {
#line 342
    free((void *)path);
    }
  }
  while_break: /* CIL Label */ ;
  }
  out: 
  {
#line 346
  closedir(conf_dir);
  }
#line 347
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_device *try_driver___4(struct ibv_driver *driver , struct ibv_sysfs_dev *sysfs_dev ) 
{ 
  struct verbs_device *vdev ;
  struct ibv_device *dev ;
  char value[8] ;
  long tmp ;
  int tmp___0 ;

  {
#line 356
  if (driver->init_func) {
    {
#line 357
    dev = (*(driver->init_func))((char const   *)(sysfs_dev->sysfs_path), sysfs_dev->abi_ver);
    }
#line 358
    if (! dev) {
#line 359
      return ((struct ibv_device *)((void *)0));
    }
  } else {
    {
#line 361
    vdev = (*(driver->verbs_init_func))((char const   *)(sysfs_dev->sysfs_path), sysfs_dev->abi_ver);
    }
#line 362
    if (! vdev) {
#line 363
      return ((struct ibv_device *)((void *)0));
    }
#line 365
    dev = & vdev->device;
#line 366
    dev->ops.alloc_context = (struct ibv_context *(*)(struct ibv_device *device ,
                                                      int cmd_fd ))((void *)0);
#line 367
    dev->ops.free_context = (void (*)(struct ibv_context *context ))((void *)0);
  }
  {
#line 370
  tmp___0 = ibv_read_sysfs_file((char const   *)(sysfs_dev->ibdev_path), "node_type",
                                value, sizeof(value));
  }
#line 370
  if (tmp___0 < 0) {
    {
#line 371
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: no node_type attr under %s.\n",
            sysfs_dev->ibdev_path);
#line 373
    dev->node_type = (enum ibv_node_type )-1;
    }
  } else {
    {
#line 375
    tmp = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                 10);
#line 375
    dev->node_type = (enum ibv_node_type )tmp;
    }
#line 376
    if ((int )dev->node_type < 1) {
#line 377
      dev->node_type = (enum ibv_node_type )-1;
    } else
#line 376
    if ((int )dev->node_type > 4) {
#line 377
      dev->node_type = (enum ibv_node_type )-1;
    }
  }
  {
#line 383
  if ((int )dev->node_type == 3) {
#line 383
    goto case_3;
  }
#line 383
  if ((int )dev->node_type == 2) {
#line 383
    goto case_3;
  }
#line 383
  if ((int )dev->node_type == 1) {
#line 383
    goto case_3;
  }
#line 386
  if ((int )dev->node_type == 4) {
#line 386
    goto case_4;
  }
#line 389
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 384
  dev->transport_type = (enum ibv_transport_type )0;
#line 385
  goto switch_break;
  case_4: /* CIL Label */ 
#line 387
  dev->transport_type = (enum ibv_transport_type )1;
#line 388
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 390
  dev->transport_type = (enum ibv_transport_type )-1;
#line 391
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 394
  strcpy((char */* __restrict  */)(dev->dev_name), (char const   */* __restrict  */)(sysfs_dev->sysfs_name));
#line 395
  strcpy((char */* __restrict  */)(dev->dev_path), (char const   */* __restrict  */)(sysfs_dev->sysfs_path));
#line 396
  strcpy((char */* __restrict  */)(dev->name), (char const   */* __restrict  */)(sysfs_dev->ibdev_name));
#line 397
  strcpy((char */* __restrict  */)(dev->ibdev_path), (char const   */* __restrict  */)(sysfs_dev->ibdev_path));
  }
#line 399
  return (dev);
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_device *try_drivers___4(struct ibv_sysfs_dev *sysfs_dev ) 
{ 
  struct ibv_driver *driver ;
  struct ibv_device *dev ;

  {
#line 407
  driver = head_driver___4;
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 407
    if (! driver) {
#line 407
      goto while_break;
    }
    {
#line 408
    dev = try_driver___4(driver, sysfs_dev);
    }
#line 409
    if (dev) {
#line 410
      return (dev);
    }
#line 407
    driver = driver->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 413
  return ((struct ibv_device *)((void *)0));
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static int check_abi_version___4(char const   *path ) 
{ 
  char value[8] ;
  int tmp ;
  long tmp___0 ;

  {
  {
#line 420
  tmp = ibv_read_sysfs_file(path, "class/infiniband_verbs/abi_version", value, sizeof(value));
  }
#line 420
  if (tmp < 0) {
#line 422
    return (38);
  }
  {
#line 425
  tmp___0 = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                   10);
#line 425
  abi_ver = (int __attribute__((__visibility__("hidden")))  )tmp___0;
  }
#line 427
  if (abi_ver < (int __attribute__((__visibility__("hidden")))  )3) {
    {
#line 429
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Fatal: kernel ABI version %d doesn\'t match library version %d.\n",
            abi_ver, 6);
    }
#line 432
    return (38);
  } else
#line 427
  if (abi_ver > (int __attribute__((__visibility__("hidden")))  )6) {
    {
#line 429
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Fatal: kernel ABI version %d doesn\'t match library version %d.\n",
            abi_ver, 6);
    }
#line 432
    return (38);
  }
#line 435
  return (0);
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void check_memlock_limit___4(void) 
{ 
  struct rlimit rlim ;
  __uid_t tmp ;
  int tmp___0 ;

  {
  {
#line 442
  tmp = geteuid();
  }
#line 442
  if (! tmp) {
#line 443
    return;
  }
  {
#line 445
  tmp___0 = getrlimit((__rlimit_resource_t )8, & rlim);
  }
#line 445
  if (tmp___0) {
    {
#line 446
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: getrlimit(RLIMIT_MEMLOCK) failed.");
    }
#line 447
    return;
  }
#line 450
  if (rlim.rlim_cur <= 32768UL) {
    {
#line 451
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: RLIMIT_MEMLOCK is %lu bytes.\n    This will severely limit memory registrations.\n",
            rlim.rlim_cur);
    }
  }
#line 454
  return;
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void add_device___4(struct ibv_device *dev , struct ibv_device ***dev_list ,
                           int *num_devices___7 , int *list_size ) 
{ 
  struct ibv_device **new_list ;
  void *tmp ;
  int tmp___0 ;

  {
#line 463
  if (*list_size <= *num_devices___7) {
#line 464
    if (*list_size) {
#line 464
      *list_size *= 2;
    } else {
#line 464
      *list_size = 1;
    }
    {
#line 465
    tmp = realloc((void *)*dev_list, (unsigned long )*list_size * sizeof(struct ibv_device *));
#line 465
    new_list = (struct ibv_device **)tmp;
    }
#line 466
    if (! new_list) {
#line 467
      return;
    }
#line 468
    *dev_list = new_list;
  }
#line 471
  tmp___0 = *num_devices___7;
#line 471
  (*num_devices___7) ++;
#line 471
  *(*dev_list + tmp___0) = dev;
#line 472
  return;
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
static int ibv_cmd_modify_srq_v3___4(struct ibv_srq *srq , struct ibv_srq_attr *srq_attr ,
                                     int srq_attr_mask , struct ibv_modify_srq *new_cmd ,
                                     size_t new_cmd_size ) 
{ 
  struct ibv_modify_srq_v3 *cmd ;
  size_t cmd_size ;
  void *tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 409
  cmd_size = (sizeof(*cmd) + new_cmd_size) - sizeof(*new_cmd);
#line 410
  tmp = __builtin_alloca(cmd_size);
#line 410
  cmd = (struct ibv_modify_srq_v3 *)tmp;
#line 411
  memcpy((void */* __restrict  */)(cmd->driver_data), (void const   */* __restrict  */)(new_cmd->driver_data),
         new_cmd_size - sizeof(*new_cmd));
  }
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 413
      cmd->command = (__u32 )33;
    } else {
#line 413
      cmd->command = (__u32 )35;
    }
#line 413
    cmd->in_words = (__u16 )(cmd_size / 4UL);
#line 413
    cmd->out_words = (__u16 )0;
#line 413
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 415
  cmd->srq_handle = srq->handle;
#line 416
  cmd->attr_mask = (__u32 )srq_attr_mask;
#line 417
  cmd->max_wr = srq_attr->max_wr;
#line 418
  cmd->srq_limit = srq_attr->srq_limit;
#line 419
  cmd->max_sge = (__u32 )0;
#line 420
  cmd->reserved = (__u32 )0;
#line 422
  tmp___1 = write((srq->context)->cmd_fd, (void const   *)cmd, cmd_size);
  }
#line 422
  if ((size_t )tmp___1 != cmd_size) {
    {
#line 423
    tmp___0 = __errno_location();
    }
#line 423
    return (*tmp___0);
  }
#line 425
  return (0);
}
}
#line 1008 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
static int ib_spec_to_kern_spec___4(struct ibv_flow_spec *ib_spec , struct ibv_kern_spec *kern_spec ) 
{ 


  {
#line 1011
  kern_spec->__annonCompField5.hdr.type = (__u32 )ib_spec->__annonCompField1.hdr.type;
  {
#line 1014
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 32U) {
#line 1014
    goto case_32;
  }
#line 1021
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 48U) {
#line 1021
    goto case_48;
  }
#line 1029
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 65U) {
#line 1029
    goto case_65;
  }
#line 1029
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 64U) {
#line 1029
    goto case_65;
  }
#line 1036
  goto switch_default;
  case_32: /* CIL Label */ 
  {
#line 1015
  kern_spec->__annonCompField5.eth.size = (__u16 )sizeof(struct ibv_kern_spec_eth );
#line 1016
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.eth.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.eth.val),
         sizeof(struct ibv_flow_eth_filter ));
#line 1018
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.eth.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.eth.mask),
         sizeof(struct ibv_flow_eth_filter ));
  }
#line 1020
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 1022
  kern_spec->__annonCompField5.ipv4.size = (__u16 )sizeof(struct ibv_kern_spec_ipv4 );
#line 1023
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.ipv4.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.ipv4.val),
         sizeof(struct ibv_flow_ipv4_filter ));
#line 1025
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.ipv4.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.ipv4.mask),
         sizeof(struct ibv_flow_ipv4_filter ));
  }
#line 1027
  goto switch_break;
  case_65: /* CIL Label */ 
  case_64: /* CIL Label */ 
  {
#line 1030
  kern_spec->__annonCompField5.tcp_udp.size = (__u16 )sizeof(struct ibv_kern_spec_tcp_udp );
#line 1031
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.tcp_udp.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.tcp_udp.val),
         sizeof(struct ibv_flow_ipv4_filter ));
#line 1033
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.tcp_udp.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.tcp_udp.mask),
         sizeof(struct ibv_flow_tcp_udp_filter ));
  }
#line 1035
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1037
  return (-22);
  switch_break: /* CIL Label */ ;
  }
#line 1039
  return (0);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  node_type_str___4[5]  = {      (char const   */* const  */)0,      (char const   */* const  */)"InfiniBand channel adapter",      (char const   */* const  */)"InfiniBand switch",      (char const   */* const  */)"InfiniBand router", 
        (char const   */* const  */)"iWARP NIC"};
#line 52 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  port_state_str___5[6]  = {      (char const   */* const  */)"no state change (NOP)",      (char const   */* const  */)"down",      (char const   */* const  */)"init",      (char const   */* const  */)"armed", 
        (char const   */* const  */)"active",      (char const   */* const  */)"active defer"};
#line 69 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  event_type_str___4[19]  = 
#line 69
  {      (char const   */* const  */)"CQ error",      (char const   */* const  */)"local work queue catastrophic error",      (char const   */* const  */)"invalid request local work queue error",      (char const   */* const  */)"local access violation work queue error", 
        (char const   */* const  */)"communication established",      (char const   */* const  */)"send queue drained",      (char const   */* const  */)"path migrated",      (char const   */* const  */)"path migration request error", 
        (char const   */* const  */)"local catastrophic error",      (char const   */* const  */)"port active",      (char const   */* const  */)"port error",      (char const   */* const  */)"LID change", 
        (char const   */* const  */)"P_Key change",      (char const   */* const  */)"SM change",      (char const   */* const  */)"SRQ catastrophic error",      (char const   */* const  */)"SRQ limit reached", 
        (char const   */* const  */)"last WQE reached",      (char const   */* const  */)"client reregistration",      (char const   */* const  */)"GID table change"};
#line 99 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  wc_status_str___4[22]  = 
#line 99
  {      (char const   */* const  */)"success",      (char const   */* const  */)"local length error",      (char const   */* const  */)"local QP operation error",      (char const   */* const  */)"local EE context operation error", 
        (char const   */* const  */)"local protection error",      (char const   */* const  */)"Work Request Flushed Error",      (char const   */* const  */)"memory management operation error",      (char const   */* const  */)"bad response error", 
        (char const   */* const  */)"local access error",      (char const   */* const  */)"remote invalid request error",      (char const   */* const  */)"remote access error",      (char const   */* const  */)"remote operation error", 
        (char const   */* const  */)"transport retry counter exceeded",      (char const   */* const  */)"RNR retry counter exceeded",      (char const   */* const  */)"local RDD violation error",      (char const   */* const  */)"remote invalid RD request", 
        (char const   */* const  */)"aborted error",      (char const   */* const  */)"invalid EE context number",      (char const   */* const  */)"invalid EE context state",      (char const   */* const  */)"fatal error", 
        (char const   */* const  */)"response timeout error",      (char const   */* const  */)"general error"};
#line 267 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
__asm__(".symver __ibv_get_device_list_1_0,ibv_get_device_list@IBVERBS_1.0");
#line 281
__asm__(".symver __ibv_free_device_list_1_0,ibv_free_device_list@IBVERBS_1.0");
#line 287
__asm__(".symver __ibv_get_device_name_1_0,ibv_get_device_name@IBVERBS_1.0");
#line 293
__asm__(".symver __ibv_get_device_guid_1_0,ibv_get_device_guid@IBVERBS_1.0");
#line 295 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int poll_cq_wrapper_1_0___4(struct ibv_cq_1_0 *cq , int num_entries , struct ibv_wc *wc ) 
{ 
  int tmp ;

  {
  {
#line 298
  tmp = (*(((cq->context)->real_context)->ops.poll_cq))(cq->real_cq, num_entries,
                                                        wc);
  }
#line 298
  return (tmp);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int req_notify_cq_wrapper_1_0___4(struct ibv_cq_1_0 *cq , int sol_only ) 
{ 
  int tmp ;

  {
  {
#line 303
  tmp = (*(((cq->context)->real_context)->ops.req_notify_cq))(cq->real_cq, sol_only);
  }
#line 303
  return (tmp);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_srq_recv_wrapper_1_0___4(struct ibv_srq_1_0 *srq , struct ibv_recv_wr_1_0 *wr ,
                                         struct ibv_recv_wr_1_0 **bad_wr ) 
{ 
  struct ibv_recv_wr_1_0 *w ;
  struct ibv_recv_wr *real_wr ;
  struct ibv_recv_wr *head_wr ;
  struct ibv_recv_wr *tail_wr ;
  struct ibv_recv_wr *real_bad_wr ;
  int ret ;
  void *tmp ;

  {
#line 310
  head_wr = (struct ibv_recv_wr *)((void *)0);
#line 310
  tail_wr = (struct ibv_recv_wr *)((void *)0);
#line 313
  w = wr;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! w) {
#line 313
      goto while_break;
    }
    {
#line 314
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 314
    real_wr = (struct ibv_recv_wr *)tmp;
#line 315
    real_wr->wr_id = w->wr_id;
#line 316
    real_wr->sg_list = w->sg_list;
#line 317
    real_wr->num_sge = w->num_sge;
#line 318
    real_wr->next = (struct ibv_recv_wr *)((void *)0);
    }
#line 319
    if (tail_wr) {
#line 320
      tail_wr->next = real_wr;
    } else {
#line 322
      head_wr = real_wr;
    }
#line 324
    tail_wr = real_wr;
#line 313
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 327
  ret = (*(((srq->context)->real_context)->ops.post_srq_recv))(srq->real_srq, head_wr,
                                                               & real_bad_wr);
  }
#line 330
  if (ret) {
#line 331
    real_wr = head_wr;
#line 331
    w = wr;
    {
#line 331
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 331
      if (! real_wr) {
#line 331
        goto while_break___0;
      }
#line 334
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 335
        *bad_wr = w;
#line 336
        goto while_break___0;
      }
#line 331
      real_wr = real_wr->next;
#line 331
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 340
  return (ret);
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_send_wrapper_1_0___4(struct ibv_qp_1_0 *qp , struct ibv_send_wr_1_0 *wr ,
                                     struct ibv_send_wr_1_0 **bad_wr ) 
{ 
  struct ibv_send_wr_1_0 *w ;
  struct ibv_send_wr *real_wr ;
  struct ibv_send_wr *head_wr ;
  struct ibv_send_wr *tail_wr ;
  struct ibv_send_wr *real_bad_wr ;
  int is_ud ;
  int ret ;
  void *tmp ;

  {
#line 347
  head_wr = (struct ibv_send_wr *)((void *)0);
#line 347
  tail_wr = (struct ibv_send_wr *)((void *)0);
#line 348
  is_ud = (unsigned int )qp->qp_type == 4U;
#line 351
  w = wr;
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! w) {
#line 351
      goto while_break;
    }
    {
#line 352
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 352
    real_wr = (struct ibv_send_wr *)tmp;
#line 353
    real_wr->wr_id = w->wr_id;
#line 354
    real_wr->next = (struct ibv_send_wr *)((void *)0);
    }
#line 363
    if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->sg_list)) {
      {
#line 364
      memcpy((void */* __restrict  */)(& real_wr->sg_list), (void const   */* __restrict  */)(& w->sg_list),
             sizeof(*real_wr) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list));
      }
    } else
#line 366
    if ((unsigned long )(& ((struct ibv_send_wr *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list) == (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->sg_list)) {
#line 366
      if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->wr) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->wr)) {
        {
#line 371
        memcpy((void */* __restrict  */)(& real_wr->sg_list), (void const   */* __restrict  */)(& w->sg_list),
               ((unsigned long )(& ((struct ibv_send_wr *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list)) + sizeof(real_wr->imm_data));
#line 375
        memcpy((void */* __restrict  */)(& real_wr->wr), (void const   */* __restrict  */)(& w->wr),
               sizeof(real_wr->wr));
        }
      } else {
#line 366
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 377
      real_wr->sg_list = w->sg_list;
#line 378
      real_wr->num_sge = w->num_sge;
#line 379
      real_wr->opcode = w->opcode;
#line 380
      real_wr->send_flags = w->send_flags;
#line 381
      real_wr->imm_data = w->imm_data;
#line 382
      if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->wr) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->wr)) {
        {
#line 383
        memcpy((void */* __restrict  */)(& real_wr->wr), (void const   */* __restrict  */)(& w->wr),
               sizeof(real_wr->wr));
        }
      } else {
#line 386
        real_wr->wr.atomic.remote_addr = w->wr.atomic.remote_addr;
#line 388
        real_wr->wr.atomic.compare_add = w->wr.atomic.compare_add;
#line 390
        real_wr->wr.atomic.swap = w->wr.atomic.swap;
#line 392
        real_wr->wr.atomic.rkey = w->wr.atomic.rkey;
      }
    }
#line 397
    if (is_ud) {
#line 398
      real_wr->wr.ud.ah = (w->wr.ud.ah)->real_ah;
    }
#line 400
    if (tail_wr) {
#line 401
      tail_wr->next = real_wr;
    } else {
#line 403
      head_wr = real_wr;
    }
#line 405
    tail_wr = real_wr;
#line 351
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 408
  ret = (*(((qp->context)->real_context)->ops.post_send))(qp->real_qp, head_wr, & real_bad_wr);
  }
#line 411
  if (ret) {
#line 412
    real_wr = head_wr;
#line 412
    w = wr;
    {
#line 412
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 412
      if (! real_wr) {
#line 412
        goto while_break___0;
      }
#line 415
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 416
        *bad_wr = w;
#line 417
        goto while_break___0;
      }
#line 412
      real_wr = real_wr->next;
#line 412
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 421
  return (ret);
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_recv_wrapper_1_0___4(struct ibv_qp_1_0 *qp , struct ibv_recv_wr_1_0 *wr ,
                                     struct ibv_recv_wr_1_0 **bad_wr ) 
{ 
  struct ibv_recv_wr_1_0 *w ;
  struct ibv_recv_wr *real_wr ;
  struct ibv_recv_wr *head_wr ;
  struct ibv_recv_wr *tail_wr ;
  struct ibv_recv_wr *real_bad_wr ;
  int ret ;
  void *tmp ;

  {
#line 428
  head_wr = (struct ibv_recv_wr *)((void *)0);
#line 428
  tail_wr = (struct ibv_recv_wr *)((void *)0);
#line 431
  w = wr;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! w) {
#line 431
      goto while_break;
    }
    {
#line 432
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 432
    real_wr = (struct ibv_recv_wr *)tmp;
#line 433
    real_wr->wr_id = w->wr_id;
#line 434
    real_wr->sg_list = w->sg_list;
#line 435
    real_wr->num_sge = w->num_sge;
#line 436
    real_wr->next = (struct ibv_recv_wr *)((void *)0);
    }
#line 437
    if (tail_wr) {
#line 438
      tail_wr->next = real_wr;
    } else {
#line 440
      head_wr = real_wr;
    }
#line 442
    tail_wr = real_wr;
#line 431
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 445
  ret = (*(((qp->context)->real_context)->ops.post_recv))(qp->real_qp, head_wr, & real_bad_wr);
  }
#line 448
  if (ret) {
#line 449
    real_wr = head_wr;
#line 449
    w = wr;
    {
#line 449
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 449
      if (! real_wr) {
#line 449
        goto while_break___0;
      }
#line 452
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 453
        *bad_wr = w;
#line 454
        goto while_break___0;
      }
#line 449
      real_wr = real_wr->next;
#line 449
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 458
  return (ret);
}
}
#line 487
__asm__(".symver __ibv_open_device_1_0,ibv_open_device@IBVERBS_1.0");
#line 500
__asm__(".symver __ibv_close_device_1_0,ibv_close_device@IBVERBS_1.0");
#line 538
__asm__(".symver __ibv_get_async_event_1_0,ibv_get_async_event@IBVERBS_1.0");
#line 574
__asm__(".symver __ibv_ack_async_event_1_0,ibv_ack_async_event@IBVERBS_1.0");
#line 581
__asm__(".symver __ibv_query_device_1_0,ibv_query_device@IBVERBS_1.0");
#line 588
__asm__(".symver __ibv_query_port_1_0,ibv_query_port@IBVERBS_1.0");
#line 595
__asm__(".symver __ibv_query_gid_1_0,ibv_query_gid@IBVERBS_1.0");
#line 602
__asm__(".symver __ibv_query_pkey_1_0,ibv_query_pkey@IBVERBS_1.0");
#line 624
__asm__(".symver __ibv_alloc_pd_1_0,ibv_alloc_pd@IBVERBS_1.0");
#line 637
__asm__(".symver __ibv_dealloc_pd_1_0,ibv_dealloc_pd@IBVERBS_1.0");
#line 663
__asm__(".symver __ibv_reg_mr_1_0,ibv_reg_mr@IBVERBS_1.0");
#line 676
__asm__(".symver __ibv_dereg_mr_1_0,ibv_dereg_mr@IBVERBS_1.0");
#line 706
__asm__(".symver __ibv_create_cq_1_0,ibv_create_cq@IBVERBS_1.0");
#line 712
__asm__(".symver __ibv_resize_cq_1_0,ibv_resize_cq@IBVERBS_1.0");
#line 725
__asm__(".symver __ibv_destroy_cq_1_0,ibv_destroy_cq@IBVERBS_1.0");
#line 743
__asm__(".symver __ibv_get_cq_event_1_0,ibv_get_cq_event@IBVERBS_1.0");
#line 749
__asm__(".symver __ibv_ack_cq_events_1_0,ibv_ack_cq_events@IBVERBS_1.0");
#line 776
__asm__(".symver __ibv_create_srq_1_0,ibv_create_srq@IBVERBS_1.0");
#line 784
__asm__(".symver __ibv_modify_srq_1_0,ibv_modify_srq@IBVERBS_1.0");
#line 790
__asm__(".symver __ibv_query_srq_1_0,ibv_query_srq@IBVERBS_1.0");
#line 803
__asm__(".symver __ibv_destroy_srq_1_0,ibv_destroy_srq@IBVERBS_1.0");
#line 847
__asm__(".symver __ibv_create_qp_1_0,ibv_create_qp@IBVERBS_1.0");
#line 870
__asm__(".symver __ibv_query_qp_1_0,ibv_query_qp@IBVERBS_1.0");
#line 877
__asm__(".symver __ibv_modify_qp_1_0,ibv_modify_qp@IBVERBS_1.0");
#line 890
__asm__(".symver __ibv_destroy_qp_1_0,ibv_destroy_qp@IBVERBS_1.0");
#line 914
__asm__(".symver __ibv_create_ah_1_0,ibv_create_ah@IBVERBS_1.0");
#line 927
__asm__(".symver __ibv_destroy_ah_1_0,ibv_destroy_ah@IBVERBS_1.0");
#line 933
__asm__(".symver __ibv_attach_mcast_1_0,ibv_attach_mcast@IBVERBS_1.0");
#line 939
__asm__(".symver __ibv_detach_mcast_1_0,ibv_detach_mcast@IBVERBS_1.0");
#line 132 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
__asm__(".symver __ibv_query_device,ibv_query_device@@IBVERBS_1.1");
#line 139
__asm__(".symver __ibv_query_port,ibv_query_port@@IBVERBS_1.1");
#line 164
__asm__(".symver __ibv_query_gid,ibv_query_gid@@IBVERBS_1.1");
#line 185
__asm__(".symver __ibv_query_pkey,ibv_query_pkey@@IBVERBS_1.1");
#line 197
__asm__(".symver __ibv_alloc_pd,ibv_alloc_pd@@IBVERBS_1.1");
#line 203
__asm__(".symver __ibv_dealloc_pd,ibv_dealloc_pd@@IBVERBS_1.1");
#line 224
__asm__(".symver __ibv_reg_mr,ibv_reg_mr@@IBVERBS_1.1");
#line 238
__asm__(".symver __ibv_dereg_mr,ibv_dereg_mr@@IBVERBS_1.1");
#line 243 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int warned___5  ;
#line 240 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static struct ibv_comp_channel *ibv_create_comp_channel_v2___5(struct ibv_context *context ) 
{ 
  struct ibv_abi_compat_v2 *t ;
  int tmp ;

  {
  {
#line 242
  t = (struct ibv_abi_compat_v2 *)context->abi_compat;
#line 245
  tmp = pthread_mutex_trylock(& t->in_use);
  }
#line 245
  if (! tmp) {
#line 246
    return (& t->channel);
  }
#line 248
  if (! warned___5) {
    {
#line 249
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: kernel\'s ABI version %d limits capacity.\n    Only one completion channel can be created per context.\n",
            abi_ver);
#line 252
    warned___5 ++;
    }
  }
#line 255
  return ((struct ibv_comp_channel *)((void *)0));
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int ibv_destroy_comp_channel_v2___5(struct ibv_comp_channel *channel ) 
{ 
  struct ibv_abi_compat_v2 *t ;

  {
  {
#line 288
  t = (struct ibv_abi_compat_v2 *)channel;
#line 289
  pthread_mutex_unlock(& t->in_use);
  }
#line 290
  return (0);
}
}
#line 346
__asm__(".symver __ibv_create_cq,ibv_create_cq@@IBVERBS_1.1");
#line 355
__asm__(".symver __ibv_resize_cq,ibv_resize_cq@@IBVERBS_1.1");
#line 375
__asm__(".symver __ibv_destroy_cq,ibv_destroy_cq@@IBVERBS_1.1");
#line 393
__asm__(".symver __ibv_get_cq_event,ibv_get_cq_event@@IBVERBS_1.1");
#line 402
__asm__(".symver __ibv_ack_cq_events,ibv_ack_cq_events@@IBVERBS_1.1");
#line 424
__asm__(".symver __ibv_create_srq,ibv_create_srq@@IBVERBS_1.1");
#line 432
__asm__(".symver __ibv_modify_srq,ibv_modify_srq@@IBVERBS_1.1");
#line 438
__asm__(".symver __ibv_query_srq,ibv_query_srq@@IBVERBS_1.1");
#line 444
__asm__(".symver __ibv_destroy_srq,ibv_destroy_srq@@IBVERBS_1.1");
#line 467
__asm__(".symver __ibv_create_qp,ibv_create_qp@@IBVERBS_1.1");
#line 484
__asm__(".symver __ibv_query_qp,ibv_query_qp@@IBVERBS_1.1");
#line 500
__asm__(".symver __ibv_modify_qp,ibv_modify_qp@@IBVERBS_1.1");
#line 506
__asm__(".symver __ibv_destroy_qp,ibv_destroy_qp@@IBVERBS_1.1");
#line 519
__asm__(".symver __ibv_create_ah,ibv_create_ah@@IBVERBS_1.1");
#line 521 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int ibv_find_gid_index___5(struct ibv_context *context , uint8_t port_num ,
                                  union ibv_gid *gid ) 
{ 
  union ibv_gid sgid ;
  int i ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 525
  i = 0;
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 528
    tmp = i;
#line 528
    i ++;
#line 528
    ret = ibv_query_gid(context, port_num, tmp, & sgid);
    }
#line 527
    if (! ret) {
      {
#line 527
      tmp___0 = memcmp((void const   *)(& sgid), (void const   *)gid, sizeof(*gid));
      }
#line 527
      if (! tmp___0) {
#line 527
        goto while_break;
      }
    } else {
#line 527
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 531
  if (ret) {
#line 531
    tmp___1 = ret;
  } else {
#line 531
    tmp___1 = i - 1;
  }
#line 531
  return (tmp___1);
}
}
#line 581
__asm__(".symver __ibv_destroy_ah,ibv_destroy_ah@@IBVERBS_1.1");
#line 587
__asm__(".symver __ibv_attach_mcast,ibv_attach_mcast@@IBVERBS_1.1");
#line 593
__asm__(".symver __ibv_detach_mcast,ibv_detach_mcast@@IBVERBS_1.1");
#line 82 "./include/infiniband/verbs.h"
static void *__VERBS_ABI_IS_EXTENDED___5  =    (void *)((uint8_t *)((void *)0) - 1);
#line 877 "./include/infiniband/verbs.h"
__inline static struct verbs_context *verbs_get_ctx___5(struct ibv_context *ctx ) 
{ 
  struct verbs_context *tmp ;

  {
#line 879
  if ((unsigned long )ctx->abi_compat != (unsigned long )__VERBS_ABI_IS_EXTENDED___5) {
#line 879
    tmp = (struct verbs_context *)((void *)0);
  } else {
#line 879
    tmp = (struct verbs_context *)((uint8_t *)ctx - (unsigned long )(& ((struct verbs_context *)0)->context));
  }
#line 879
  return (tmp);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static pthread_once_t device_list_once___5  =    0;
#line 53 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static int num_devices___5  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static struct ibv_device **device_list___5  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static void count_devices___5(void) 
{ 
  int __attribute__((__visibility__("hidden")))  tmp ;

  {
  {
#line 58
  tmp = ibverbs_init(& device_list___5);
#line 58
  num_devices___5 = (int )tmp;
  }
#line 59
  return;
}
}
#line 89
__asm__(".symver __ibv_get_device_list,ibv_get_device_list@@IBVERBS_1.1");
#line 95
__asm__(".symver __ibv_free_device_list,ibv_free_device_list@@IBVERBS_1.1");
#line 101
__asm__(".symver __ibv_get_device_name,ibv_get_device_name@@IBVERBS_1.1");
#line 123
__asm__(".symver __ibv_get_device_guid,ibv_get_device_guid@@IBVERBS_1.1");
#line 190
__asm__(".symver __ibv_open_device,ibv_open_device@@IBVERBS_1.1");
#line 215
__asm__(".symver __ibv_close_device,ibv_close_device@@IBVERBS_1.1");
#line 258
__asm__(".symver __ibv_get_async_event,ibv_get_async_event@@IBVERBS_1.1");
#line 311
__asm__(".symver __ibv_ack_async_event,ibv_ack_async_event@@IBVERBS_1.1");
#line 73 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *mm_root___5  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static pthread_mutex_t mm_mutex___5  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 75 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int page_size___8  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int huge_page_enabled___5  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int too_late___5  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static unsigned long smaps_page_size___5(FILE *file ) 
{ 
  int n ;
  unsigned long size ;
  char buf[1024] ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 82
  size = (unsigned long )page_size___8;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 85
    tmp___0 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)file);
    }
#line 85
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 85
      goto while_break;
    }
    {
#line 86
    tmp = strstr((char const   *)(buf), "KernelPageSize:");
    }
#line 86
    if (! tmp) {
#line 87
      goto while_continue;
    }
    {
#line 89
    n = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*s %lu",
               & size);
    }
#line 90
    if (n < 1) {
#line 91
      goto while_continue;
    }
#line 94
    size *= 1024UL;
#line 96
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return (size);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static unsigned long get_page_size___5(void *base ) 
{ 
  unsigned long ret ;
  pid_t pid ;
  FILE *file ;
  char buf[1024] ;
  int n ;
  uintptr_t range_start ;
  uintptr_t range_end ;
  char *tmp ;

  {
  {
#line 104
  ret = (unsigned long )page_size___8;
#line 109
  pid = getpid();
#line 110
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"/proc/%d/smaps",
           pid);
#line 112
  file = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"re");
  }
#line 113
  if (! file) {
#line 114
    goto out;
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 116
    tmp = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)file);
    }
#line 116
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 116
      goto while_break;
    }
    {
#line 120
    n = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%lx-%lx",
               & range_start, & range_end);
    }
#line 122
    if (n < 2) {
#line 123
      goto while_continue;
    }
#line 125
    if ((uintptr_t )base >= range_start) {
#line 125
      if ((uintptr_t )base < range_end) {
        {
#line 126
        ret = smaps_page_size___5(file);
        }
#line 127
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  fclose(file);
  }
  out: 
#line 134
  return (ret);
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_prev___5(struct ibv_mem_node *node ) 
{ 


  {
#line 194
  if (node->left) {
#line 195
    node = node->left;
    {
#line 196
    while (1) {
      while_continue: /* CIL Label */ ;
#line 196
      if (! node->right) {
#line 196
        goto while_break;
      }
#line 197
      node = node->right;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 199
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 199
      if (node->parent) {
#line 199
        if (! ((unsigned long )node == (unsigned long )(node->parent)->left)) {
#line 199
          goto while_break___0;
        }
      } else {
#line 199
        goto while_break___0;
      }
#line 200
      node = node->parent;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 202
    node = node->parent;
  }
#line 205
  return (node);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_next___5(struct ibv_mem_node *node ) 
{ 


  {
#line 210
  if (node->right) {
#line 211
    node = node->right;
    {
#line 212
    while (1) {
      while_continue: /* CIL Label */ ;
#line 212
      if (! node->left) {
#line 212
        goto while_break;
      }
#line 213
      node = node->left;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 215
      if (node->parent) {
#line 215
        if (! ((unsigned long )node == (unsigned long )(node->parent)->right)) {
#line 215
          goto while_break___0;
        }
      } else {
#line 215
        goto while_break___0;
      }
#line 216
      node = node->parent;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 218
    node = node->parent;
  }
#line 221
  return (node);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_rotate_right___5(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 228
  tmp = node->left;
#line 230
  node->left = tmp->right;
#line 231
  if (node->left) {
#line 232
    (node->left)->parent = node;
  }
#line 234
  if (node->parent) {
#line 235
    if ((unsigned long )(node->parent)->right == (unsigned long )node) {
#line 236
      (node->parent)->right = tmp;
    } else {
#line 238
      (node->parent)->left = tmp;
    }
  } else {
#line 240
    mm_root___5 = tmp;
  }
#line 242
  tmp->parent = node->parent;
#line 244
  tmp->right = node;
#line 245
  node->parent = tmp;
#line 246
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_rotate_left___5(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 252
  tmp = node->right;
#line 254
  node->right = tmp->left;
#line 255
  if (node->right) {
#line 256
    (node->right)->parent = node;
  }
#line 258
  if (node->parent) {
#line 259
    if ((unsigned long )(node->parent)->right == (unsigned long )node) {
#line 260
      (node->parent)->right = tmp;
    } else {
#line 262
      (node->parent)->left = tmp;
    }
  } else {
#line 264
    mm_root___5 = tmp;
  }
#line 266
  tmp->parent = node->parent;
#line 268
  tmp->left = node;
#line 269
  node->parent = tmp;
#line 270
  return;
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_add_rebalance___5(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *parent ;
  struct ibv_mem_node *gp ;
  struct ibv_mem_node *uncle ;

  {
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (node->parent) {
#line 304
      if (! ((unsigned int )(node->parent)->color == 0U)) {
#line 304
        goto while_break;
      }
    } else {
#line 304
      goto while_break;
    }
#line 305
    parent = node->parent;
#line 306
    gp = (node->parent)->parent;
#line 308
    if ((unsigned long )parent == (unsigned long )gp->left) {
#line 309
      uncle = gp->right;
#line 311
      if (uncle) {
#line 311
        if ((unsigned int )uncle->color == 0U) {
#line 312
          parent->color = (enum __anonenum_color_68 )1;
#line 313
          uncle->color = (enum __anonenum_color_68 )1;
#line 314
          gp->color = (enum __anonenum_color_68 )0;
#line 316
          node = gp;
        } else {
#line 311
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 318
        if ((unsigned long )node == (unsigned long )parent->right) {
          {
#line 319
          __mm_rotate_left___5(parent);
#line 320
          node = parent;
#line 321
          parent = node->parent;
          }
        }
        {
#line 324
        parent->color = (enum __anonenum_color_68 )1;
#line 325
        gp->color = (enum __anonenum_color_68 )0;
#line 327
        __mm_rotate_right___5(gp);
        }
      }
    } else {
#line 330
      uncle = gp->left;
#line 332
      if (uncle) {
#line 332
        if ((unsigned int )uncle->color == 0U) {
#line 333
          parent->color = (enum __anonenum_color_68 )1;
#line 334
          uncle->color = (enum __anonenum_color_68 )1;
#line 335
          gp->color = (enum __anonenum_color_68 )0;
#line 337
          node = gp;
        } else {
#line 332
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 339
        if ((unsigned long )node == (unsigned long )parent->left) {
          {
#line 340
          __mm_rotate_right___5(parent);
#line 341
          node = parent;
#line 342
          parent = node->parent;
          }
        }
        {
#line 345
        parent->color = (enum __anonenum_color_68 )1;
#line 346
        gp->color = (enum __anonenum_color_68 )0;
#line 348
        __mm_rotate_left___5(gp);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  mm_root___5->color = (enum __anonenum_color_68 )1;
#line 354
  return;
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_add___5(struct ibv_mem_node *new ) 
{ 
  struct ibv_mem_node *node ;
  struct ibv_mem_node *parent ;

  {
#line 358
  parent = (struct ibv_mem_node *)((void *)0);
#line 360
  node = mm_root___5;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! node) {
#line 361
      goto while_break;
    }
#line 362
    parent = node;
#line 363
    if (node->start < new->start) {
#line 364
      node = node->right;
    } else {
#line 366
      node = node->left;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  if (parent->start < new->start) {
#line 370
    parent->right = new;
  } else {
#line 372
    parent->left = new;
  }
  {
#line 374
  new->parent = parent;
#line 375
  new->left = (struct ibv_mem_node *)((void *)0);
#line 376
  new->right = (struct ibv_mem_node *)((void *)0);
#line 378
  new->color = (enum __anonenum_color_68 )0;
#line 379
  __mm_add_rebalance___5(new);
  }
#line 380
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_remove___5(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *child ;
  struct ibv_mem_node *parent ;
  struct ibv_mem_node *sib ;
  struct ibv_mem_node *tmp ;
  int nodecol ;

  {
#line 387
  if (node->left) {
#line 387
    if (node->right) {
#line 388
      tmp = node->left;
      {
#line 389
      while (1) {
        while_continue: /* CIL Label */ ;
#line 389
        if (! tmp->right) {
#line 389
          goto while_break;
        }
#line 390
        tmp = tmp->right;
      }
      while_break: /* CIL Label */ ;
      }
#line 392
      nodecol = (int )tmp->color;
#line 393
      child = tmp->left;
#line 394
      tmp->color = node->color;
#line 396
      if ((unsigned long )tmp->parent != (unsigned long )node) {
#line 397
        parent = tmp->parent;
#line 398
        parent->right = tmp->left;
#line 399
        if (tmp->left) {
#line 400
          (tmp->left)->parent = parent;
        }
#line 402
        tmp->left = node->left;
#line 403
        (node->left)->parent = tmp;
      } else {
#line 405
        parent = tmp;
      }
#line 407
      tmp->right = node->right;
#line 408
      (node->right)->parent = tmp;
#line 410
      tmp->parent = node->parent;
#line 411
      if (node->parent) {
#line 412
        if ((unsigned long )(node->parent)->left == (unsigned long )node) {
#line 413
          (node->parent)->left = tmp;
        } else {
#line 415
          (node->parent)->right = tmp;
        }
      } else {
#line 417
        mm_root___5 = tmp;
      }
    } else {
#line 387
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 419
    nodecol = (int )node->color;
#line 421
    if (node->left) {
#line 421
      child = node->left;
    } else {
#line 421
      child = node->right;
    }
#line 422
    parent = node->parent;
#line 424
    if (child) {
#line 425
      child->parent = parent;
    }
#line 426
    if (parent) {
#line 427
      if ((unsigned long )parent->left == (unsigned long )node) {
#line 428
        parent->left = child;
      } else {
#line 430
        parent->right = child;
      }
    } else {
#line 432
      mm_root___5 = child;
    }
  }
  {
#line 435
  free((void *)node);
  }
#line 437
  if (nodecol == 0) {
#line 438
    return;
  }
  {
#line 440
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 440
    if (! child) {
#line 440
      goto _L___6;
    } else
#line 440
    if ((unsigned int )child->color == 1U) {
      _L___6: /* CIL Label */ 
#line 440
      if (! ((unsigned long )child != (unsigned long )mm_root___5)) {
#line 440
        goto while_break___0;
      }
    } else {
#line 440
      goto while_break___0;
    }
#line 441
    if ((unsigned long )parent->left == (unsigned long )child) {
#line 442
      sib = parent->right;
#line 444
      if ((unsigned int )sib->color == 0U) {
        {
#line 445
        parent->color = (enum __anonenum_color_68 )0;
#line 446
        sib->color = (enum __anonenum_color_68 )1;
#line 447
        __mm_rotate_left___5(parent);
#line 448
        sib = parent->right;
        }
      }
#line 451
      if (! sib->left) {
#line 451
        goto _L___2;
      } else
#line 451
      if ((unsigned int )(sib->left)->color == 1U) {
        _L___2: /* CIL Label */ 
#line 451
        if (! sib->right) {
#line 453
          sib->color = (enum __anonenum_color_68 )0;
#line 454
          child = parent;
#line 455
          parent = child->parent;
        } else
#line 451
        if ((unsigned int )(sib->right)->color == 1U) {
#line 453
          sib->color = (enum __anonenum_color_68 )0;
#line 454
          child = parent;
#line 455
          parent = child->parent;
        } else {
#line 451
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 457
        if (! sib->right) {
#line 457
          goto _L___0;
        } else
#line 457
        if ((unsigned int )(sib->right)->color == 1U) {
          _L___0: /* CIL Label */ 
#line 458
          if (sib->left) {
#line 459
            (sib->left)->color = (enum __anonenum_color_68 )1;
          }
          {
#line 460
          sib->color = (enum __anonenum_color_68 )0;
#line 461
          __mm_rotate_right___5(sib);
#line 462
          sib = parent->right;
          }
        }
#line 465
        sib->color = parent->color;
#line 466
        parent->color = (enum __anonenum_color_68 )1;
#line 467
        if (sib->right) {
#line 468
          (sib->right)->color = (enum __anonenum_color_68 )1;
        }
        {
#line 469
        __mm_rotate_left___5(parent);
#line 470
        child = mm_root___5;
        }
#line 471
        goto while_break___0;
      }
    } else {
#line 474
      sib = parent->left;
#line 476
      if ((unsigned int )sib->color == 0U) {
        {
#line 477
        parent->color = (enum __anonenum_color_68 )0;
#line 478
        sib->color = (enum __anonenum_color_68 )1;
#line 479
        __mm_rotate_right___5(parent);
#line 480
        sib = parent->left;
        }
      }
#line 483
      if (! sib->left) {
#line 483
        goto _L___5;
      } else
#line 483
      if ((unsigned int )(sib->left)->color == 1U) {
        _L___5: /* CIL Label */ 
#line 483
        if (! sib->right) {
#line 485
          sib->color = (enum __anonenum_color_68 )0;
#line 486
          child = parent;
#line 487
          parent = child->parent;
        } else
#line 483
        if ((unsigned int )(sib->right)->color == 1U) {
#line 485
          sib->color = (enum __anonenum_color_68 )0;
#line 486
          child = parent;
#line 487
          parent = child->parent;
        } else {
#line 483
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
#line 489
        if (! sib->left) {
#line 489
          goto _L___3;
        } else
#line 489
        if ((unsigned int )(sib->left)->color == 1U) {
          _L___3: /* CIL Label */ 
#line 490
          if (sib->right) {
#line 491
            (sib->right)->color = (enum __anonenum_color_68 )1;
          }
          {
#line 492
          sib->color = (enum __anonenum_color_68 )0;
#line 493
          __mm_rotate_left___5(sib);
#line 494
          sib = parent->left;
          }
        }
#line 497
        sib->color = parent->color;
#line 498
        parent->color = (enum __anonenum_color_68 )1;
#line 499
        if (sib->left) {
#line 500
          (sib->left)->color = (enum __anonenum_color_68 )1;
        }
        {
#line 501
        __mm_rotate_right___5(parent);
#line 502
        child = mm_root___5;
        }
#line 503
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 508
  if (child) {
#line 509
    child->color = (enum __anonenum_color_68 )1;
  }
#line 510
  return;
}
}
#line 512 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_find_start___5(uintptr_t start , uintptr_t end ) 
{ 
  struct ibv_mem_node *node ;

  {
#line 514
  node = mm_root___5;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! node) {
#line 516
      goto while_break;
    }
#line 517
    if (node->start <= start) {
#line 517
      if (node->end >= start) {
#line 518
        goto while_break;
      }
    }
#line 520
    if (node->start < start) {
#line 521
      node = node->right;
    } else {
#line 523
      node = node->left;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 526
  return (node);
}
}
#line 529 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *merge_ranges___5(struct ibv_mem_node *node , struct ibv_mem_node *prev ) 
{ 


  {
  {
#line 532
  prev->end = node->end;
#line 533
  prev->refcnt = node->refcnt;
#line 534
  __mm_remove___5(node);
  }
#line 536
  return (prev);
}
}
#line 539 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *split_range___5(struct ibv_mem_node *node , uintptr_t cut_line ) 
{ 
  struct ibv_mem_node *new_node ;
  void *tmp ;

  {
  {
#line 542
  new_node = (struct ibv_mem_node *)((void *)0);
#line 544
  tmp = malloc(sizeof(*new_node));
#line 544
  new_node = (struct ibv_mem_node *)tmp;
  }
#line 545
  if (! new_node) {
#line 546
    return ((struct ibv_mem_node *)((void *)0));
  }
  {
#line 547
  new_node->start = cut_line;
#line 548
  new_node->end = node->end;
#line 549
  new_node->refcnt = node->refcnt;
#line 550
  node->end = cut_line - 1UL;
#line 551
  __mm_add___5(new_node);
  }
#line 553
  return (new_node);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *get_start_node___5(uintptr_t start , uintptr_t end , int inc ) 
{ 
  struct ibv_mem_node *node ;
  struct ibv_mem_node *tmp ;

  {
  {
#line 559
  tmp = (struct ibv_mem_node *)((void *)0);
#line 561
  node = __mm_find_start___5(start, end);
  }
#line 562
  if (node->start < start) {
    {
#line 563
    node = split_range___5(node, start);
    }
  } else {
    {
#line 565
    tmp = __mm_prev___5(node);
    }
#line 566
    if (tmp) {
#line 566
      if (tmp->refcnt == node->refcnt + inc) {
        {
#line 567
        node = merge_ranges___5(node, tmp);
        }
      }
    }
  }
#line 569
  return (node);
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *undo_node___5(struct ibv_mem_node *node , uintptr_t start ,
                                          int inc ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 579
  tmp = (struct ibv_mem_node *)((void *)0);
#line 585
  if (start > node->start) {
    {
#line 586
    tmp = split_range___5(node, start);
    }
#line 587
    if (tmp) {
#line 588
      node->refcnt += inc;
#line 589
      node = tmp;
    } else {
#line 591
      return ((struct ibv_mem_node *)((void *)0));
    }
  }
  {
#line 594
  tmp = __mm_prev___5(node);
  }
#line 595
  if (tmp) {
#line 595
    if (tmp->refcnt == node->refcnt) {
      {
#line 596
      node = merge_ranges___5(node, tmp);
      }
    }
  }
  {
#line 598
  tmp = __mm_next___5(node);
  }
#line 599
  if (tmp) {
#line 599
    if (tmp->refcnt == node->refcnt) {
      {
#line 600
      node = merge_ranges___5(tmp, node);
      }
    }
  }
#line 602
  return (node);
}
}
#line 605 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int ibv_madvise_range___5(void *base , size_t size , int advice ) 
{ 
  uintptr_t start ;
  uintptr_t end ;
  struct ibv_mem_node *node ;
  struct ibv_mem_node *tmp ;
  int inc ;
  int rolling_back ;
  int ret ;
  unsigned long range_page_size ;
  struct ibv_mem_node *tmp___0 ;

  {
#line 610
  rolling_back = 0;
#line 611
  ret = 0;
#line 614
  if (! size) {
#line 615
    return (0);
  }
#line 617
  if (huge_page_enabled___5) {
    {
#line 618
    range_page_size = get_page_size___5(base);
    }
  } else {
#line 620
    range_page_size = (unsigned long )page_size___8;
  }
  {
#line 622
  start = (uintptr_t )base & ~ (range_page_size - 1UL);
#line 623
  end = ((uintptr_t )(((base + size) + range_page_size) - 1) & ~ (range_page_size - 1UL)) - 1UL;
#line 626
  pthread_mutex_lock(& mm_mutex___5);
  }
  again: 
#line 628
  if (advice == 10) {
#line 628
    inc = 1;
  } else {
#line 628
    inc = -1;
  }
  {
#line 630
  node = get_start_node___5(start, end, inc);
  }
#line 631
  if (! node) {
#line 632
    ret = -1;
#line 633
    goto out;
  }
  {
#line 636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 636
    if (node) {
#line 636
      if (! (node->start <= end)) {
#line 636
        goto while_break;
      }
    } else {
#line 636
      goto while_break;
    }
#line 637
    if (node->end > end) {
      {
#line 638
      tmp___0 = split_range___5(node, end + 1UL);
      }
#line 638
      if (! tmp___0) {
#line 639
        ret = -1;
#line 640
        goto out;
      }
    }
#line 644
    if (inc == -1) {
#line 644
      if (node->refcnt == 1) {
#line 644
        goto _L;
      } else {
#line 644
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 644
    if (inc == 1) {
#line 644
      if (node->refcnt == 0) {
        _L: /* CIL Label */ 
#line 657
        if (start > node->start) {
          {
#line 658
          ret = madvise((void *)start, (node->end - start) + 1UL, advice);
          }
        } else {
          {
#line 661
          ret = madvise((void *)node->start, (node->end - node->start) + 1UL, advice);
          }
        }
#line 664
        if (ret) {
          {
#line 665
          node = undo_node___5(node, start, inc);
          }
#line 667
          if (rolling_back) {
#line 668
            goto out;
          } else
#line 667
          if (! node) {
#line 668
            goto out;
          }
#line 671
          rolling_back = 1;
#line 672
          if (advice == 10) {
#line 672
            advice = 11;
          } else {
#line 672
            advice = 10;
          }
          {
#line 674
          tmp = __mm_prev___5(node);
          }
#line 675
          if (! tmp) {
#line 676
            goto out;
          } else
#line 675
          if (start > tmp->end) {
#line 676
            goto out;
          }
#line 677
          end = tmp->end;
#line 678
          goto again;
        }
      }
    }
    {
#line 682
    node->refcnt += inc;
#line 683
    node = __mm_next___5(node);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if (node) {
    {
#line 687
    tmp = __mm_prev___5(node);
    }
#line 688
    if (tmp) {
#line 688
      if (node->refcnt == tmp->refcnt) {
        {
#line 689
        node = merge_ranges___5(node, tmp);
        }
      }
    }
  }
  out: 
#line 693
  if (rolling_back) {
#line 694
    ret = -1;
  }
  {
#line 696
  pthread_mutex_unlock(& mm_mutex___5);
  }
#line 698
  return (ret);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/ud_pingpong.c"
static int page_size___9  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/ud_pingpong.c"
static int pp_connect_ctx___2(struct pingpong_context___1 *ctx , int port , int my_psn ,
                              int sl , struct pingpong_dest *dest , int sgid_idx ) 
{ 
  struct ibv_ah_attr ah_attr ;
  struct ibv_qp_attr attr ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 84
  ah_attr.grh.dgid.raw[0] = (unsigned char)0;
#line 84
  ah_attr.grh.dgid.raw[1] = (unsigned char)0;
#line 84
  ah_attr.grh.dgid.raw[2] = (unsigned char)0;
#line 84
  ah_attr.grh.dgid.raw[3] = (unsigned char)0;
#line 84
  ah_attr.grh.dgid.raw[4] = (unsigned char)0;
#line 84
  ah_attr.grh.dgid.raw[5] = (unsigned char)0;
#line 84
  ah_attr.grh.dgid.raw[6] = (unsigned char)0;
#line 84
  ah_attr.grh.dgid.raw[7] = (unsigned char)0;
#line 84
  ah_attr.grh.dgid.raw[8] = (unsigned char)0;
#line 84
  ah_attr.grh.dgid.raw[9] = (unsigned char)0;
#line 84
  ah_attr.grh.dgid.raw[10] = (unsigned char)0;
#line 84
  ah_attr.grh.dgid.raw[11] = (unsigned char)0;
#line 84
  ah_attr.grh.dgid.raw[12] = (unsigned char)0;
#line 84
  ah_attr.grh.dgid.raw[13] = (unsigned char)0;
#line 84
  ah_attr.grh.dgid.raw[14] = (unsigned char)0;
#line 84
  ah_attr.grh.dgid.raw[15] = (unsigned char)0;
#line 84
  ah_attr.grh.flow_label = 0U;
#line 84
  ah_attr.grh.sgid_index = (unsigned char)0;
#line 84
  ah_attr.grh.hop_limit = (unsigned char)0;
#line 84
  ah_attr.grh.traffic_class = (unsigned char)0;
#line 84
  ah_attr.dlid = (uint16_t )dest->lid;
#line 84
  ah_attr.sl = (uint8_t )sl;
#line 84
  ah_attr.src_path_bits = (uint8_t )0;
#line 84
  ah_attr.static_rate = (unsigned char)0;
#line 84
  ah_attr.is_global = (uint8_t )0;
#line 84
  ah_attr.port_num = (uint8_t )port;
#line 91
  attr.qp_state = (enum ibv_qp_state )2;
#line 91
  attr.cur_qp_state = 0U;
#line 91
  attr.path_mtu = 0U;
#line 91
  attr.path_mig_state = 0U;
#line 91
  attr.qkey = 0U;
#line 91
  attr.rq_psn = 0U;
#line 91
  attr.sq_psn = 0U;
#line 91
  attr.dest_qp_num = 0U;
#line 91
  attr.qp_access_flags = 0;
#line 91
  attr.cap.max_send_wr = 0U;
#line 91
  attr.cap.max_recv_wr = 0U;
#line 91
  attr.cap.max_send_sge = 0U;
#line 91
  attr.cap.max_recv_sge = 0U;
#line 91
  attr.cap.max_inline_data = 0U;
#line 91
  attr.ah_attr.grh.dgid.raw[0] = (unsigned char)0;
#line 91
  attr.ah_attr.grh.dgid.raw[1] = (unsigned char)0;
#line 91
  attr.ah_attr.grh.dgid.raw[2] = (unsigned char)0;
#line 91
  attr.ah_attr.grh.dgid.raw[3] = (unsigned char)0;
#line 91
  attr.ah_attr.grh.dgid.raw[4] = (unsigned char)0;
#line 91
  attr.ah_attr.grh.dgid.raw[5] = (unsigned char)0;
#line 91
  attr.ah_attr.grh.dgid.raw[6] = (unsigned char)0;
#line 91
  attr.ah_attr.grh.dgid.raw[7] = (unsigned char)0;
#line 91
  attr.ah_attr.grh.dgid.raw[8] = (unsigned char)0;
#line 91
  attr.ah_attr.grh.dgid.raw[9] = (unsigned char)0;
#line 91
  attr.ah_attr.grh.dgid.raw[10] = (unsigned char)0;
#line 91
  attr.ah_attr.grh.dgid.raw[11] = (unsigned char)0;
#line 91
  attr.ah_attr.grh.dgid.raw[12] = (unsigned char)0;
#line 91
  attr.ah_attr.grh.dgid.raw[13] = (unsigned char)0;
#line 91
  attr.ah_attr.grh.dgid.raw[14] = (unsigned char)0;
#line 91
  attr.ah_attr.grh.dgid.raw[15] = (unsigned char)0;
#line 91
  attr.ah_attr.grh.flow_label = 0U;
#line 91
  attr.ah_attr.grh.sgid_index = (unsigned char)0;
#line 91
  attr.ah_attr.grh.hop_limit = (unsigned char)0;
#line 91
  attr.ah_attr.grh.traffic_class = (unsigned char)0;
#line 91
  attr.ah_attr.dlid = (unsigned short)0;
#line 91
  attr.ah_attr.sl = (unsigned char)0;
#line 91
  attr.ah_attr.src_path_bits = (unsigned char)0;
#line 91
  attr.ah_attr.static_rate = (unsigned char)0;
#line 91
  attr.ah_attr.is_global = (unsigned char)0;
#line 91
  attr.ah_attr.port_num = (unsigned char)0;
#line 91
  attr.alt_ah_attr.grh.dgid.raw[0] = (unsigned char)0;
#line 91
  attr.alt_ah_attr.grh.dgid.raw[1] = (unsigned char)0;
#line 91
  attr.alt_ah_attr.grh.dgid.raw[2] = (unsigned char)0;
#line 91
  attr.alt_ah_attr.grh.dgid.raw[3] = (unsigned char)0;
#line 91
  attr.alt_ah_attr.grh.dgid.raw[4] = (unsigned char)0;
#line 91
  attr.alt_ah_attr.grh.dgid.raw[5] = (unsigned char)0;
#line 91
  attr.alt_ah_attr.grh.dgid.raw[6] = (unsigned char)0;
#line 91
  attr.alt_ah_attr.grh.dgid.raw[7] = (unsigned char)0;
#line 91
  attr.alt_ah_attr.grh.dgid.raw[8] = (unsigned char)0;
#line 91
  attr.alt_ah_attr.grh.dgid.raw[9] = (unsigned char)0;
#line 91
  attr.alt_ah_attr.grh.dgid.raw[10] = (unsigned char)0;
#line 91
  attr.alt_ah_attr.grh.dgid.raw[11] = (unsigned char)0;
#line 91
  attr.alt_ah_attr.grh.dgid.raw[12] = (unsigned char)0;
#line 91
  attr.alt_ah_attr.grh.dgid.raw[13] = (unsigned char)0;
#line 91
  attr.alt_ah_attr.grh.dgid.raw[14] = (unsigned char)0;
#line 91
  attr.alt_ah_attr.grh.dgid.raw[15] = (unsigned char)0;
#line 91
  attr.alt_ah_attr.grh.flow_label = 0U;
#line 91
  attr.alt_ah_attr.grh.sgid_index = (unsigned char)0;
#line 91
  attr.alt_ah_attr.grh.hop_limit = (unsigned char)0;
#line 91
  attr.alt_ah_attr.grh.traffic_class = (unsigned char)0;
#line 91
  attr.alt_ah_attr.dlid = (unsigned short)0;
#line 91
  attr.alt_ah_attr.sl = (unsigned char)0;
#line 91
  attr.alt_ah_attr.src_path_bits = (unsigned char)0;
#line 91
  attr.alt_ah_attr.static_rate = (unsigned char)0;
#line 91
  attr.alt_ah_attr.is_global = (unsigned char)0;
#line 91
  attr.alt_ah_attr.port_num = (unsigned char)0;
#line 91
  attr.pkey_index = (unsigned short)0;
#line 91
  attr.alt_pkey_index = (unsigned short)0;
#line 91
  attr.en_sqd_async_notify = (unsigned char)0;
#line 91
  attr.sq_draining = (unsigned char)0;
#line 91
  attr.max_rd_atomic = (unsigned char)0;
#line 91
  attr.max_dest_rd_atomic = (unsigned char)0;
#line 91
  attr.min_rnr_timer = (unsigned char)0;
#line 91
  attr.port_num = (unsigned char)0;
#line 91
  attr.timeout = (unsigned char)0;
#line 91
  attr.retry_cnt = (unsigned char)0;
#line 91
  attr.rnr_retry = (unsigned char)0;
#line 91
  attr.alt_port_num = (unsigned char)0;
#line 91
  attr.alt_timeout = (unsigned char)0;
#line 95
  tmp = ibv_modify_qp(ctx->qp, & attr, 1);
  }
#line 95
  if (tmp) {
    {
#line 96
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to modify QP to RTR\n");
    }
#line 97
    return (1);
  }
  {
#line 100
  attr.qp_state = (enum ibv_qp_state )3;
#line 101
  attr.sq_psn = (uint32_t )my_psn;
#line 103
  tmp___0 = ibv_modify_qp(ctx->qp, & attr, 65537);
  }
#line 103
  if (tmp___0) {
    {
#line 106
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to modify QP to RTS\n");
    }
#line 107
    return (1);
  }
#line 110
  if (dest->gid.global.interface_id) {
#line 111
    ah_attr.is_global = (uint8_t )1;
#line 112
    ah_attr.grh.hop_limit = (uint8_t )1;
#line 113
    ah_attr.grh.dgid = dest->gid;
#line 114
    ah_attr.grh.sgid_index = (uint8_t )sgid_idx;
  }
  {
#line 117
  ctx->ah = ibv_create_ah(ctx->pd, & ah_attr);
  }
#line 118
  if (! ctx->ah) {
    {
#line 119
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to create AH\n");
    }
#line 120
    return (1);
  }
#line 123
  return (0);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/ud_pingpong.c"
static struct pingpong_dest *pp_client_exch_dest___2(char const   *servername , int port ,
                                                     struct pingpong_dest  const  *my_dest ) 
{ 
  struct addrinfo *res ;
  struct addrinfo *t ;
  struct addrinfo hints ;
  char *service ;
  char msg[sizeof("0000:000000:000000:00000000000000000000000000000000")] ;
  int n ;
  int sockfd ;
  struct pingpong_dest *rem_dest ;
  char gid[33] ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  ssize_t tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 130
  hints.ai_flags = 0;
#line 130
  hints.ai_family = 0;
#line 130
  hints.ai_socktype = 1;
#line 130
  hints.ai_protocol = 0;
#line 130
  hints.ai_addrlen = 0U;
#line 130
  hints.ai_addr = (struct sockaddr *)0;
#line 130
  hints.ai_canonname = (char *)0;
#line 130
  hints.ai_next = (struct addrinfo *)0;
#line 137
  sockfd = -1;
#line 138
  rem_dest = (struct pingpong_dest *)((void *)0);
#line 141
  tmp = asprintf((char **/* __restrict  */)(& service), (char const   */* __restrict  */)"%d",
                 port);
  }
#line 141
  if (tmp < 0) {
#line 142
    return ((struct pingpong_dest *)((void *)0));
  }
  {
#line 144
  n = getaddrinfo((char const   */* __restrict  */)servername, (char const   */* __restrict  */)service,
                  (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 146
  if (n < 0) {
    {
#line 147
    tmp___0 = gai_strerror(n);
#line 147
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s for %s:%d\n",
            tmp___0, servername, port);
#line 148
    free((void *)service);
    }
#line 149
    return ((struct pingpong_dest *)((void *)0));
  }
#line 152
  t = res;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! t) {
#line 152
      goto while_break;
    }
    {
#line 153
    sockfd = socket(t->ai_family, t->ai_socktype, t->ai_protocol);
    }
#line 154
    if (sockfd >= 0) {
      {
#line 155
      tmp___1 = connect(sockfd, (struct sockaddr  const  */* __restrict  */)t->ai_addr,
                        t->ai_addrlen);
      }
#line 155
      if (! tmp___1) {
#line 156
        goto while_break;
      }
      {
#line 157
      close(sockfd);
#line 158
      sockfd = -1;
      }
    }
#line 152
    t = t->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 162
  freeaddrinfo(res);
#line 163
  free((void *)service);
  }
#line 165
  if (sockfd < 0) {
    {
#line 166
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t connect to %s:%d\n",
            servername, port);
    }
#line 167
    return ((struct pingpong_dest *)((void *)0));
  }
  {
#line 170
  gid_to_wire_gid(& my_dest->gid, gid);
#line 171
  sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"%04x:%06x:%06x:%s",
          my_dest->lid, my_dest->qpn, my_dest->psn, gid);
#line 173
  tmp___2 = write(sockfd, (void const   *)(msg), sizeof(msg));
  }
#line 173
  if ((unsigned long )tmp___2 != sizeof(msg)) {
    {
#line 174
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t send local address\n");
    }
#line 175
    goto out;
  }
  {
#line 178
  tmp___3 = read(sockfd, (void *)(msg), sizeof(msg));
  }
#line 178
  if ((unsigned long )tmp___3 != sizeof(msg)) {
    {
#line 179
    perror("client read");
#line 180
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t read remote address\n");
    }
#line 181
    goto out;
  }
  {
#line 184
  write(sockfd, (void const   *)"done", sizeof("done"));
#line 186
  tmp___4 = malloc(sizeof(*rem_dest));
#line 186
  rem_dest = (struct pingpong_dest *)tmp___4;
  }
#line 187
  if (! rem_dest) {
#line 188
    goto out;
  }
  {
#line 190
  sscanf((char const   */* __restrict  */)(msg), (char const   */* __restrict  */)"%x:%x:%x:%s",
         & rem_dest->lid, & rem_dest->qpn, & rem_dest->psn, gid);
#line 192
  wire_gid_to_gid((char const   *)(gid), & rem_dest->gid);
  }
  out: 
  {
#line 195
  close(sockfd);
  }
#line 196
  return (rem_dest);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/ud_pingpong.c"
static struct pingpong_dest *pp_server_exch_dest___2(struct pingpong_context___1 *ctx ,
                                                     int ib_port , int port , int sl ,
                                                     struct pingpong_dest  const  *my_dest ,
                                                     int sgid_idx ) 
{ 
  struct addrinfo *res ;
  struct addrinfo *t ;
  struct addrinfo hints ;
  char *service ;
  char msg[sizeof("0000:000000:000000:00000000000000000000000000000000")] ;
  int n ;
  int sockfd ;
  int connfd ;
  struct pingpong_dest *rem_dest ;
  char gid[33] ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;

  {
  {
#line 205
  hints.ai_flags = 1;
#line 205
  hints.ai_family = 0;
#line 205
  hints.ai_socktype = 1;
#line 205
  hints.ai_protocol = 0;
#line 205
  hints.ai_addrlen = 0U;
#line 205
  hints.ai_addr = (struct sockaddr *)0;
#line 205
  hints.ai_canonname = (char *)0;
#line 205
  hints.ai_next = (struct addrinfo *)0;
#line 213
  sockfd = -1;
#line 214
  rem_dest = (struct pingpong_dest *)((void *)0);
#line 217
  tmp = asprintf((char **/* __restrict  */)(& service), (char const   */* __restrict  */)"%d",
                 port);
  }
#line 217
  if (tmp < 0) {
#line 218
    return ((struct pingpong_dest *)((void *)0));
  }
  {
#line 220
  n = getaddrinfo((char const   */* __restrict  */)((void *)0), (char const   */* __restrict  */)service,
                  (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 222
  if (n < 0) {
    {
#line 223
    tmp___0 = gai_strerror(n);
#line 223
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s for port %d\n",
            tmp___0, port);
#line 224
    free((void *)service);
    }
#line 225
    return ((struct pingpong_dest *)((void *)0));
  }
#line 228
  t = res;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! t) {
#line 228
      goto while_break;
    }
    {
#line 229
    sockfd = socket(t->ai_family, t->ai_socktype, t->ai_protocol);
    }
#line 230
    if (sockfd >= 0) {
      {
#line 231
      n = 1;
#line 233
      setsockopt(sockfd, 1, 2, (void const   *)(& n), (socklen_t )sizeof(n));
#line 235
      tmp___1 = bind(sockfd, (struct sockaddr  const  */* __restrict  */)t->ai_addr,
                     t->ai_addrlen);
      }
#line 235
      if (! tmp___1) {
#line 236
        goto while_break;
      }
      {
#line 237
      close(sockfd);
#line 238
      sockfd = -1;
      }
    }
#line 228
    t = t->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 242
  freeaddrinfo(res);
#line 243
  free((void *)service);
  }
#line 245
  if (sockfd < 0) {
    {
#line 246
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t listen to port %d\n",
            port);
    }
#line 247
    return ((struct pingpong_dest *)((void *)0));
  }
  {
#line 250
  listen(sockfd, 1);
#line 251
  connfd = accept(sockfd, (struct sockaddr */* __restrict  */)((void *)0), (socklen_t */* __restrict  */)0);
#line 252
  close(sockfd);
  }
#line 253
  if (connfd < 0) {
    {
#line 254
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"accept() failed\n");
    }
#line 255
    return ((struct pingpong_dest *)((void *)0));
  }
  {
#line 258
  tmp___2 = read(connfd, (void *)(msg), sizeof(msg));
#line 258
  n = (int )tmp___2;
  }
#line 259
  if ((unsigned long )n != sizeof(msg)) {
    {
#line 260
    perror("server read");
#line 261
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d/%d: Couldn\'t read remote address\n",
            n, (int )sizeof(msg));
    }
#line 262
    goto out;
  }
  {
#line 265
  tmp___3 = malloc(sizeof(*rem_dest));
#line 265
  rem_dest = (struct pingpong_dest *)tmp___3;
  }
#line 266
  if (! rem_dest) {
#line 267
    goto out;
  }
  {
#line 269
  sscanf((char const   */* __restrict  */)(msg), (char const   */* __restrict  */)"%x:%x:%x:%s",
         & rem_dest->lid, & rem_dest->qpn, & rem_dest->psn, gid);
#line 271
  wire_gid_to_gid((char const   *)(gid), & rem_dest->gid);
#line 273
  tmp___4 = pp_connect_ctx___2(ctx, ib_port, (int )my_dest->psn, sl, rem_dest, sgid_idx);
  }
#line 273
  if (tmp___4) {
    {
#line 275
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t connect to remote QP\n");
#line 276
    free((void *)rem_dest);
#line 277
    rem_dest = (struct pingpong_dest *)((void *)0);
    }
#line 278
    goto out;
  }
  {
#line 281
  gid_to_wire_gid(& my_dest->gid, gid);
#line 282
  sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"%04x:%06x:%06x:%s",
          my_dest->lid, my_dest->qpn, my_dest->psn, gid);
#line 284
  tmp___5 = write(connfd, (void const   *)(msg), sizeof(msg));
  }
#line 284
  if ((unsigned long )tmp___5 != sizeof(msg)) {
    {
#line 285
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t send local address\n");
#line 286
    free((void *)rem_dest);
#line 287
    rem_dest = (struct pingpong_dest *)((void *)0);
    }
#line 288
    goto out;
  }
  {
#line 291
  read(connfd, (void *)(msg), sizeof(msg));
  }
  out: 
  {
#line 294
  close(connfd);
  }
#line 295
  return (rem_dest);
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/ud_pingpong.c"
static struct pingpong_context___1 *pp_init_ctx___2(struct ibv_device *ib_dev , int size ,
                                                    int rx_depth , int port , int use_event ) 
{ 
  struct pingpong_context___1 *ctx ;
  void *tmp ;
  char const   *tmp___0 ;
  struct ibv_port_attr port_info ;
  int mtu ;
  int tmp___1 ;
  struct ibv_qp_init_attr attr ;
  struct ibv_qp_attr attr___0 ;
  int tmp___2 ;

  {
  {
#line 304
  tmp = malloc(sizeof(*ctx));
#line 304
  ctx = (struct pingpong_context___1 *)tmp;
  }
#line 305
  if (! ctx) {
#line 306
    return ((struct pingpong_context___1 *)((void *)0));
  }
  {
#line 308
  ctx->size = size;
#line 309
  ctx->rx_depth = rx_depth;
#line 311
  ctx->buf = memalign((size_t )page_size___9, (size_t )(size + 40));
  }
#line 312
  if (! ctx->buf) {
    {
#line 313
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t allocate work buf.\n");
    }
#line 314
    goto clean_ctx;
  }
  {
#line 318
  memset(ctx->buf, 123, (size_t )(size + 40));
#line 320
  ctx->context = ibv_open_device(ib_dev);
  }
#line 321
  if (! ctx->context) {
    {
#line 322
    tmp___0 = ibv_get_device_name(ib_dev);
#line 322
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t get context for %s\n",
            tmp___0);
    }
#line 324
    goto clean_buffer;
  }
  {
#line 328
  port_info.state = (enum ibv_port_state )0;
#line 328
  port_info.max_mtu = 0U;
#line 328
  port_info.active_mtu = 0U;
#line 328
  port_info.gid_tbl_len = 0;
#line 328
  port_info.port_cap_flags = 0U;
#line 328
  port_info.max_msg_sz = 0U;
#line 328
  port_info.bad_pkey_cntr = 0U;
#line 328
  port_info.qkey_viol_cntr = 0U;
#line 328
  port_info.pkey_tbl_len = (unsigned short)0;
#line 328
  port_info.lid = (unsigned short)0;
#line 328
  port_info.sm_lid = (unsigned short)0;
#line 328
  port_info.lmc = (unsigned char)0;
#line 328
  port_info.max_vl_num = (unsigned char)0;
#line 328
  port_info.sm_sl = (unsigned char)0;
#line 328
  port_info.subnet_timeout = (unsigned char)0;
#line 328
  port_info.init_type_reply = (unsigned char)0;
#line 328
  port_info.active_width = (unsigned char)0;
#line 328
  port_info.active_speed = (unsigned char)0;
#line 328
  port_info.phys_state = (unsigned char)0;
#line 328
  port_info.link_layer = (unsigned char)0;
#line 328
  port_info.reserved = (unsigned char)0;
#line 331
  tmp___1 = ___ibv_query_port(ctx->context, (uint8_t )port, & port_info);
  }
#line 331
  if (tmp___1) {
    {
#line 332
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to query port info for port %d\n",
            port);
    }
#line 333
    goto clean_device;
  }
#line 335
  mtu = 1 << ((unsigned int )port_info.active_mtu + 7U);
#line 336
  if (size > mtu) {
    {
#line 337
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Requested size larger than port MTU (%d)\n",
            mtu);
    }
#line 338
    goto clean_device;
  }
#line 342
  if (use_event) {
    {
#line 343
    ctx->channel = ibv_create_comp_channel(ctx->context);
    }
#line 344
    if (! ctx->channel) {
      {
#line 345
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t create completion channel\n");
      }
#line 346
      goto clean_device;
    }
  } else {
#line 349
    ctx->channel = (struct ibv_comp_channel *)((void *)0);
  }
  {
#line 351
  ctx->pd = ibv_alloc_pd(ctx->context);
  }
#line 352
  if (! ctx->pd) {
    {
#line 353
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t allocate PD\n");
    }
#line 354
    goto clean_comp_channel;
  }
  {
#line 357
  ctx->mr = ibv_reg_mr(ctx->pd, ctx->buf, (size_t )(size + 40), 1);
  }
#line 358
  if (! ctx->mr) {
    {
#line 359
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t register MR\n");
    }
#line 360
    goto clean_pd;
  }
  {
#line 363
  ctx->cq = ibv_create_cq(ctx->context, rx_depth + 1, (void *)0, ctx->channel, 0);
  }
#line 365
  if (! ctx->cq) {
    {
#line 366
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t create CQ\n");
    }
#line 367
    goto clean_mr;
  }
  {
#line 371
  attr.qp_context = (void *)0;
#line 371
  attr.send_cq = ctx->cq;
#line 371
  attr.recv_cq = ctx->cq;
#line 371
  attr.srq = (struct ibv_srq *)0;
#line 371
  attr.cap.max_send_wr = (uint32_t )1;
#line 371
  attr.cap.max_recv_wr = (uint32_t )rx_depth;
#line 371
  attr.cap.max_send_sge = (uint32_t )1;
#line 371
  attr.cap.max_recv_sge = (uint32_t )1;
#line 371
  attr.cap.max_inline_data = 0U;
#line 371
  attr.qp_type = (enum ibv_qp_type )4;
#line 371
  attr.sq_sig_all = 0;
#line 383
  ctx->qp = ibv_create_qp(ctx->pd, & attr);
  }
#line 384
  if (! ctx->qp) {
    {
#line 385
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t create QP\n");
    }
#line 386
    goto clean_cq;
  }
  {
#line 391
  attr___0.qp_state = (enum ibv_qp_state )1;
#line 391
  attr___0.cur_qp_state = 0U;
#line 391
  attr___0.path_mtu = 0U;
#line 391
  attr___0.path_mig_state = 0U;
#line 391
  attr___0.qkey = (uint32_t )286331153;
#line 391
  attr___0.rq_psn = 0U;
#line 391
  attr___0.sq_psn = 0U;
#line 391
  attr___0.dest_qp_num = 0U;
#line 391
  attr___0.qp_access_flags = 0;
#line 391
  attr___0.cap.max_send_wr = 0U;
#line 391
  attr___0.cap.max_recv_wr = 0U;
#line 391
  attr___0.cap.max_send_sge = 0U;
#line 391
  attr___0.cap.max_recv_sge = 0U;
#line 391
  attr___0.cap.max_inline_data = 0U;
#line 391
  attr___0.ah_attr.grh.dgid.raw[0] = (unsigned char)0;
#line 391
  attr___0.ah_attr.grh.dgid.raw[1] = (unsigned char)0;
#line 391
  attr___0.ah_attr.grh.dgid.raw[2] = (unsigned char)0;
#line 391
  attr___0.ah_attr.grh.dgid.raw[3] = (unsigned char)0;
#line 391
  attr___0.ah_attr.grh.dgid.raw[4] = (unsigned char)0;
#line 391
  attr___0.ah_attr.grh.dgid.raw[5] = (unsigned char)0;
#line 391
  attr___0.ah_attr.grh.dgid.raw[6] = (unsigned char)0;
#line 391
  attr___0.ah_attr.grh.dgid.raw[7] = (unsigned char)0;
#line 391
  attr___0.ah_attr.grh.dgid.raw[8] = (unsigned char)0;
#line 391
  attr___0.ah_attr.grh.dgid.raw[9] = (unsigned char)0;
#line 391
  attr___0.ah_attr.grh.dgid.raw[10] = (unsigned char)0;
#line 391
  attr___0.ah_attr.grh.dgid.raw[11] = (unsigned char)0;
#line 391
  attr___0.ah_attr.grh.dgid.raw[12] = (unsigned char)0;
#line 391
  attr___0.ah_attr.grh.dgid.raw[13] = (unsigned char)0;
#line 391
  attr___0.ah_attr.grh.dgid.raw[14] = (unsigned char)0;
#line 391
  attr___0.ah_attr.grh.dgid.raw[15] = (unsigned char)0;
#line 391
  attr___0.ah_attr.grh.flow_label = 0U;
#line 391
  attr___0.ah_attr.grh.sgid_index = (unsigned char)0;
#line 391
  attr___0.ah_attr.grh.hop_limit = (unsigned char)0;
#line 391
  attr___0.ah_attr.grh.traffic_class = (unsigned char)0;
#line 391
  attr___0.ah_attr.dlid = (unsigned short)0;
#line 391
  attr___0.ah_attr.sl = (unsigned char)0;
#line 391
  attr___0.ah_attr.src_path_bits = (unsigned char)0;
#line 391
  attr___0.ah_attr.static_rate = (unsigned char)0;
#line 391
  attr___0.ah_attr.is_global = (unsigned char)0;
#line 391
  attr___0.ah_attr.port_num = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.grh.dgid.raw[0] = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.grh.dgid.raw[1] = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.grh.dgid.raw[2] = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.grh.dgid.raw[3] = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.grh.dgid.raw[4] = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.grh.dgid.raw[5] = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.grh.dgid.raw[6] = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.grh.dgid.raw[7] = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.grh.dgid.raw[8] = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.grh.dgid.raw[9] = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.grh.dgid.raw[10] = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.grh.dgid.raw[11] = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.grh.dgid.raw[12] = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.grh.dgid.raw[13] = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.grh.dgid.raw[14] = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.grh.dgid.raw[15] = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.grh.flow_label = 0U;
#line 391
  attr___0.alt_ah_attr.grh.sgid_index = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.grh.hop_limit = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.grh.traffic_class = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.dlid = (unsigned short)0;
#line 391
  attr___0.alt_ah_attr.sl = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.src_path_bits = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.static_rate = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.is_global = (unsigned char)0;
#line 391
  attr___0.alt_ah_attr.port_num = (unsigned char)0;
#line 391
  attr___0.pkey_index = (uint16_t )0;
#line 391
  attr___0.alt_pkey_index = (unsigned short)0;
#line 391
  attr___0.en_sqd_async_notify = (unsigned char)0;
#line 391
  attr___0.sq_draining = (unsigned char)0;
#line 391
  attr___0.max_rd_atomic = (unsigned char)0;
#line 391
  attr___0.max_dest_rd_atomic = (unsigned char)0;
#line 391
  attr___0.min_rnr_timer = (unsigned char)0;
#line 391
  attr___0.port_num = (uint8_t )port;
#line 391
  attr___0.timeout = (unsigned char)0;
#line 391
  attr___0.retry_cnt = (unsigned char)0;
#line 391
  attr___0.rnr_retry = (unsigned char)0;
#line 391
  attr___0.alt_port_num = (unsigned char)0;
#line 391
  attr___0.alt_timeout = (unsigned char)0;
#line 398
  tmp___2 = ibv_modify_qp(ctx->qp, & attr___0, 113);
  }
#line 398
  if (tmp___2) {
    {
#line 403
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to modify QP to INIT\n");
    }
#line 404
    goto clean_qp;
  }
#line 408
  return (ctx);
  clean_qp: 
  {
#line 411
  ibv_destroy_qp(ctx->qp);
  }
  clean_cq: 
  {
#line 414
  ibv_destroy_cq(ctx->cq);
  }
  clean_mr: 
  {
#line 417
  ibv_dereg_mr(ctx->mr);
  }
  clean_pd: 
  {
#line 420
  ibv_dealloc_pd(ctx->pd);
  }
  clean_comp_channel: 
#line 423
  if (ctx->channel) {
    {
#line 424
    ibv_destroy_comp_channel(ctx->channel);
    }
  }
  clean_device: 
  {
#line 427
  ibv_close_device(ctx->context);
  }
  clean_buffer: 
  {
#line 430
  free(ctx->buf);
  }
  clean_ctx: 
  {
#line 433
  free((void *)ctx);
  }
#line 435
  return ((struct pingpong_context___1 *)((void *)0));
}
}
#line 483 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/ud_pingpong.c"
static int pp_post_recv___2(struct pingpong_context___1 *ctx , int n ) 
{ 
  struct ibv_sge list ;
  struct ibv_recv_wr wr ;
  struct ibv_recv_wr *bad_wr ;
  int i ;
  int tmp ;

  {
#line 485
  list.addr = (uintptr_t )ctx->buf;
#line 485
  list.length = (uint32_t )(ctx->size + 40);
#line 485
  list.lkey = (ctx->mr)->lkey;
#line 490
  wr.wr_id = (uint64_t )1;
#line 490
  wr.next = (struct ibv_recv_wr *)0;
#line 490
  wr.sg_list = & list;
#line 490
  wr.num_sge = 1;
#line 498
  i = 0;
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;
#line 498
    if (! (i < n)) {
#line 498
      goto while_break;
    }
    {
#line 499
    tmp = ibv_post_recv(ctx->qp, & wr, & bad_wr);
    }
#line 499
    if (tmp) {
#line 500
      goto while_break;
    }
#line 498
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 502
  return (i);
}
}
#line 505 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/ud_pingpong.c"
static int pp_post_send___2(struct pingpong_context___1 *ctx , uint32_t qpn ) 
{ 
  struct ibv_sge list ;
  struct ibv_send_wr wr ;
  struct ibv_send_wr *bad_wr ;
  int tmp ;

  {
  {
#line 507
  list.addr = (uintptr_t )ctx->buf + 40UL;
#line 507
  list.length = (uint32_t )ctx->size;
#line 507
  list.lkey = (ctx->mr)->lkey;
#line 512
  wr.wr_id = (uint64_t )2;
#line 512
  wr.next = (struct ibv_send_wr *)0;
#line 512
  wr.sg_list = & list;
#line 512
  wr.num_sge = 1;
#line 512
  wr.opcode = (enum ibv_wr_opcode )2;
#line 512
  wr.send_flags = 2;
#line 512
  wr.imm_data = 0U;
#line 512
  wr.wr.ud.ah = ctx->ah;
#line 512
  wr.wr.ud.remote_qpn = qpn;
#line 512
  wr.wr.ud.remote_qkey = (uint32_t )286331153;
#line 528
  tmp = ibv_post_send(ctx->qp, & wr, & bad_wr);
  }
#line 528
  return (tmp);
}
}
#line 531 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/ud_pingpong.c"
static void usage___3(char const   *argv0 ) 
{ 


  {
  {
#line 533
  printf((char const   */* __restrict  */)"Usage:\n");
#line 534
  printf((char const   */* __restrict  */)"  %s            start a server and wait for connection\n",
         argv0);
#line 535
  printf((char const   */* __restrict  */)"  %s <host>     connect to server at <host>\n",
         argv0);
#line 536
  printf((char const   */* __restrict  */)"\n");
#line 537
  printf((char const   */* __restrict  */)"Options:\n");
#line 538
  printf((char const   */* __restrict  */)"  -p, --port=<port>      listen on/connect to port <port> (default 18515)\n");
#line 539
  printf((char const   */* __restrict  */)"  -d, --ib-dev=<dev>     use IB device <dev> (default first device found)\n");
#line 540
  printf((char const   */* __restrict  */)"  -i, --ib-port=<port>   use port <port> of IB device (default 1)\n");
#line 541
  printf((char const   */* __restrict  */)"  -s, --size=<size>      size of message to exchange (default 2048)\n");
#line 542
  printf((char const   */* __restrict  */)"  -r, --rx-depth=<dep>   number of receives to post at a time (default 500)\n");
#line 543
  printf((char const   */* __restrict  */)"  -n, --iters=<iters>    number of exchanges (default 1000)\n");
#line 544
  printf((char const   */* __restrict  */)"  -e, --events           sleep on CQ events (default poll)\n");
#line 545
  printf((char const   */* __restrict  */)"  -g, --gid-idx=<gid index> local port gid index\n");
  }
#line 546
  return;
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/examples/ud_pingpong.c"
static struct option long_options___3[10]  = 
#line 576
  {      {"port", 1, (int *)0, 'p'}, 
        {"ib-dev", 1, (int *)0, 'd'}, 
        {"ib-port", 1, (int *)0, 'i'}, 
        {"size", 1, (int *)0, 's'}, 
        {"rx-depth", 1, (int *)0, 'r'}, 
        {"iters", 1, (int *)0, 'n'}, 
        {"sl", 1, (int *)0, 'l'}, 
        {"events", 0, (int *)0, 'e'}, 
        {"gid-idx", 1, (int *)0, 'g'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 47 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/sysfs.c"
static char *sysfs_path___5  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_sysfs_dev *sysfs_dev_list___5  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver_name *driver_name_list___5  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver *head_driver___5  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver *tail_driver___5  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static int find_sysfs_devs___5(void) 
{ 
  char class_path[256] ;
  DIR *class_dir ;
  struct dirent *dent ;
  struct ibv_sysfs_dev *sysfs_dev ;
  char value[8] ;
  int ret ;
  char const   *tmp ;
  struct stat buf ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;

  {
  {
#line 86
  sysfs_dev = (struct ibv_sysfs_dev *)((void *)0);
#line 88
  ret = 0;
#line 90
  tmp = ibv_get_sysfs_path();
#line 90
  snprintf((char */* __restrict  */)(class_path), sizeof(class_path), (char const   */* __restrict  */)"%s/class/infiniband_verbs",
           tmp);
#line 93
  class_dir = opendir((char const   *)(class_path));
  }
#line 94
  if (! class_dir) {
#line 95
    return (38);
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    dent = readdir(class_dir);
    }
#line 97
    if (! dent) {
#line 97
      goto while_break;
    }
#line 100
    if ((int )dent->d_name[0] == 46) {
#line 101
      goto while_continue;
    }
#line 103
    if (! sysfs_dev) {
      {
#line 104
      tmp___0 = malloc(sizeof(*sysfs_dev));
#line 104
      sysfs_dev = (struct ibv_sysfs_dev *)tmp___0;
      }
    }
#line 105
    if (! sysfs_dev) {
#line 106
      ret = 12;
#line 107
      goto out;
    }
    {
#line 110
    snprintf((char */* __restrict  */)(sysfs_dev->sysfs_path), sizeof(sysfs_dev->sysfs_path),
             (char const   */* __restrict  */)"%s/%s", class_path, dent->d_name);
#line 113
    tmp___1 = stat((char const   */* __restrict  */)(sysfs_dev->sysfs_path), (struct stat */* __restrict  */)(& buf));
    }
#line 113
    if (tmp___1) {
      {
#line 114
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t stat \'%s\'.\n",
              sysfs_dev->sysfs_path);
      }
#line 116
      goto while_continue;
    }
#line 119
    if (! ((buf.st_mode & 61440U) == 16384U)) {
#line 120
      goto while_continue;
    }
    {
#line 122
    snprintf((char */* __restrict  */)(sysfs_dev->sysfs_name), sizeof(sysfs_dev->sysfs_name),
             (char const   */* __restrict  */)"%s", dent->d_name);
#line 125
    tmp___2 = ibv_read_sysfs_file((char const   *)(sysfs_dev->sysfs_path), "ibdev",
                                  sysfs_dev->ibdev_name, sizeof(sysfs_dev->ibdev_name));
    }
#line 125
    if (tmp___2 < 0) {
      {
#line 128
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: no ibdev class attr for \'%s\'.\n",
              dent->d_name);
      }
#line 130
      goto while_continue;
    }
    {
#line 133
    tmp___3 = ibv_get_sysfs_path();
#line 133
    snprintf((char */* __restrict  */)(sysfs_dev->ibdev_path), sizeof(sysfs_dev->ibdev_path),
             (char const   */* __restrict  */)"%s/class/infiniband/%s", tmp___3, sysfs_dev->ibdev_name);
#line 137
    sysfs_dev->next = sysfs_dev_list___5;
#line 138
    sysfs_dev->have_driver = 0;
#line 139
    tmp___5 = ibv_read_sysfs_file((char const   *)(sysfs_dev->sysfs_path), "abi_version",
                                  value, sizeof(value));
    }
#line 139
    if (tmp___5 > 0) {
      {
#line 141
      tmp___4 = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                       10);
#line 141
      sysfs_dev->abi_ver = (int )tmp___4;
      }
    } else {
#line 143
      sysfs_dev->abi_ver = 0;
    }
#line 145
    sysfs_dev_list___5 = sysfs_dev;
#line 146
    sysfs_dev = (struct ibv_sysfs_dev *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
  out: 
#line 150
  if (sysfs_dev) {
    {
#line 151
    free((void *)sysfs_dev);
    }
  }
  {
#line 153
  closedir(class_dir);
  }
#line 154
  return (ret);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void register_driver___5(char const   *name , struct ibv_device *(*init_func)(char const   *uverbs_sys_path ,
                                                                                     int abi_version ) ,
                                struct verbs_device *(*verbs_init_func)(char const   *uverbs_sys_path ,
                                                                        int abi_version ) ) 
{ 
  struct ibv_driver *driver ;
  void *tmp ;

  {
  {
#line 162
  tmp = malloc(sizeof(*driver));
#line 162
  driver = (struct ibv_driver *)tmp;
  }
#line 163
  if (! driver) {
    {
#line 164
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver for %s\n",
            name);
    }
#line 165
    return;
  }
#line 168
  driver->name = name;
#line 169
  driver->init_func = init_func;
#line 170
  driver->verbs_init_func = verbs_init_func;
#line 171
  driver->next = (struct ibv_driver *)((void *)0);
#line 173
  if (tail_driver___5) {
#line 174
    tail_driver___5->next = driver;
  } else {
#line 176
    head_driver___5 = driver;
  }
#line 177
  tail_driver___5 = driver;
#line 178
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void load_driver___5(char const   *name ) 
{ 
  char *so_name ;
  void *dlhandle ;
  char const   *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 201
  if ((int const   )*(name + 0) == 47) {
#line 201
    tmp = "%s-rdmav2.so";
  } else {
#line 201
    tmp = "lib%s-rdmav2.so";
  }
  {
#line 201
  tmp___0 = asprintf((char **/* __restrict  */)(& so_name), (char const   */* __restrict  */)tmp,
                     name);
  }
#line 201
  if (tmp___0 < 0) {
    {
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t load driver \'%s\'.\n",
            name);
    }
#line 208
    return;
  }
  {
#line 211
  dlhandle = dlopen((char const   *)so_name, 2);
  }
#line 212
  if (! dlhandle) {
    {
#line 213
    tmp___1 = dlerror();
#line 213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t load driver \'%s\': %s\n",
            name, tmp___1);
    }
#line 215
    goto out;
  }
  out: 
  {
#line 219
  free((void *)so_name);
  }
#line 220
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void load_drivers___5(void) 
{ 
  struct ibv_driver_name *name ;
  struct ibv_driver_name *next_name ;
  char const   *env ;
  char *list ;
  char *env_name ;
  char const   *__old ;
  size_t __len ;
  size_t tmp ;
  char *__new ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *__old___0 ;
  size_t __len___0 ;
  size_t tmp___2 ;
  char *__new___0 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;

  {
  {
#line 232
  tmp___7 = getuid();
#line 232
  tmp___8 = geteuid();
  }
#line 232
  if (tmp___7 == tmp___8) {
    {
#line 233
    tmp___6 = getenv("RDMAV_DRIVERS");
#line 233
    env = (char const   *)tmp___6;
    }
#line 233
    if (env) {
      {
#line 234
      __old = env;
#line 234
      tmp = strlen(__old);
#line 234
      __len = tmp + 1UL;
#line 234
      tmp___0 = __builtin_alloca(__len);
#line 234
      __new = (char *)tmp___0;
#line 234
      tmp___1 = memcpy((void */* __restrict  */)__new, (void const   */* __restrict  */)__old,
                       __len);
#line 234
      list = (char *)tmp___1;
      }
      {
#line 235
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 235
        env_name = strsep((char **/* __restrict  */)(& list), (char const   */* __restrict  */)":;");
        }
#line 235
        if (! env_name) {
#line 235
          goto while_break;
        }
        {
#line 236
        load_driver___5((char const   *)env_name);
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 237
      tmp___5 = getenv("IBV_DRIVERS");
#line 237
      env = (char const   *)tmp___5;
      }
#line 237
      if (env) {
        {
#line 238
        __old___0 = env;
#line 238
        tmp___2 = strlen(__old___0);
#line 238
        __len___0 = tmp___2 + 1UL;
#line 238
        tmp___3 = __builtin_alloca(__len___0);
#line 238
        __new___0 = (char *)tmp___3;
#line 238
        tmp___4 = memcpy((void */* __restrict  */)__new___0, (void const   */* __restrict  */)__old___0,
                         __len___0);
#line 238
        list = (char *)tmp___4;
        }
        {
#line 239
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 239
          env_name = strsep((char **/* __restrict  */)(& list), (char const   */* __restrict  */)":;");
          }
#line 239
          if (! env_name) {
#line 239
            goto while_break___0;
          }
          {
#line 240
          load_driver___5((char const   *)env_name);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 244
  name = driver_name_list___5;
#line 244
  if (name) {
#line 244
    next_name = name->next;
  } else {
#line 244
    next_name = (struct ibv_driver_name *)((void *)0);
  }
  {
#line 244
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 244
    if (! name) {
#line 244
      goto while_break___1;
    }
    {
#line 247
    load_driver___5((char const   *)name->name);
#line 248
    free((void *)name->name);
#line 249
    free((void *)name);
#line 244
    name = next_name;
    }
#line 244
    if (name) {
#line 244
      next_name = name->next;
    } else {
#line 244
      next_name = (struct ibv_driver_name *)((void *)0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 251
  return;
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void read_config_file___5(char const   *path ) 
{ 
  FILE *conf ;
  char *line ;
  char *config ;
  char *field ;
  size_t buflen ;
  ssize_t len ;
  size_t tmp ;
  struct ibv_driver_name *driver_name ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 256
  line = (char *)((void *)0);
#line 259
  buflen = (size_t )0;
#line 262
  conf = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"re");
  }
#line 263
  if (! conf) {
    {
#line 264
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t read config file %s.\n",
            path);
    }
#line 266
    return;
  }
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 269
    len = getline((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& buflen),
                  (FILE */* __restrict  */)conf);
    }
#line 269
    if (! (len != -1L)) {
#line 269
      goto while_break;
    }
    {
#line 270
    tmp = strspn((char const   *)line, "\t ");
#line 270
    config = line + tmp;
    }
#line 271
    if ((int )*(config + 0) == 10) {
#line 272
      goto while_continue;
    } else
#line 271
    if ((int )*(config + 0) == 35) {
#line 272
      goto while_continue;
    }
    {
#line 274
    field = strsep((char **/* __restrict  */)(& config), (char const   */* __restrict  */)"\n\t ");
#line 276
    tmp___2 = strcmp((char const   *)field, "driver");
    }
#line 276
    if (tmp___2 == 0) {
#line 276
      if ((unsigned long )config != (unsigned long )((void *)0)) {
        {
#line 279
        tmp___0 = strspn((char const   *)config, "\t ");
#line 279
        config += tmp___0;
#line 280
        field = strsep((char **/* __restrict  */)(& config), (char const   */* __restrict  */)"\n\t ");
#line 282
        tmp___1 = malloc(sizeof(*driver_name));
#line 282
        driver_name = (struct ibv_driver_name *)tmp___1;
        }
#line 283
        if (! driver_name) {
          {
#line 284
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver name \'%s\'.\n",
                  field);
          }
#line 286
          goto while_continue;
        }
        {
#line 289
        driver_name->name = strdup((char const   *)field);
        }
#line 290
        if (! driver_name->name) {
          {
#line 291
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver name \'%s\'.\n",
                  field);
#line 293
          free((void *)driver_name);
          }
#line 294
          goto while_continue;
        }
#line 297
        driver_name->next = driver_name_list___5;
#line 298
        driver_name_list___5 = driver_name;
      } else {
        {
#line 300
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: ignoring bad config directive \'%s\' in file \'%s\'.\n",
                field, path);
        }
      }
    } else {
      {
#line 300
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: ignoring bad config directive \'%s\' in file \'%s\'.\n",
              field, path);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  if (line) {
    {
#line 305
    free((void *)line);
    }
  }
  {
#line 306
  fclose(conf);
  }
#line 307
  return;
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void read_config___5(void) 
{ 
  DIR *conf_dir ;
  struct dirent *dent ;
  char *path ;
  struct stat buf ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 315
  conf_dir = opendir("/usr/local/etc/libibverbs.d");
  }
#line 316
  if (! conf_dir) {
    {
#line 317
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t open config directory \'%s\'.\n",
            "/usr/local/etc/libibverbs.d");
    }
#line 319
    return;
  }
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 322
    dent = readdir(conf_dir);
    }
#line 322
    if (! dent) {
#line 322
      goto while_break;
    }
    {
#line 325
    tmp = asprintf((char **/* __restrict  */)(& path), (char const   */* __restrict  */)"%s/%s",
                   "/usr/local/etc/libibverbs.d", dent->d_name);
    }
#line 325
    if (tmp < 0) {
      {
#line 326
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t read config file %s/%s.\n",
              "/usr/local/etc/libibverbs.d", dent->d_name);
      }
#line 328
      goto out;
    }
    {
#line 331
    tmp___0 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& buf));
    }
#line 331
    if (tmp___0) {
      {
#line 332
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t stat config file \'%s\'.\n",
              path);
      }
#line 334
      goto next;
    }
#line 337
    if (! ((buf.st_mode & 61440U) == 32768U)) {
#line 338
      goto next;
    }
    {
#line 340
    read_config_file___5((char const   *)path);
    }
    next: 
    {
#line 342
    free((void *)path);
    }
  }
  while_break: /* CIL Label */ ;
  }
  out: 
  {
#line 346
  closedir(conf_dir);
  }
#line 347
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_device *try_driver___5(struct ibv_driver *driver , struct ibv_sysfs_dev *sysfs_dev ) 
{ 
  struct verbs_device *vdev ;
  struct ibv_device *dev ;
  char value[8] ;
  long tmp ;
  int tmp___0 ;

  {
#line 356
  if (driver->init_func) {
    {
#line 357
    dev = (*(driver->init_func))((char const   *)(sysfs_dev->sysfs_path), sysfs_dev->abi_ver);
    }
#line 358
    if (! dev) {
#line 359
      return ((struct ibv_device *)((void *)0));
    }
  } else {
    {
#line 361
    vdev = (*(driver->verbs_init_func))((char const   *)(sysfs_dev->sysfs_path), sysfs_dev->abi_ver);
    }
#line 362
    if (! vdev) {
#line 363
      return ((struct ibv_device *)((void *)0));
    }
#line 365
    dev = & vdev->device;
#line 366
    dev->ops.alloc_context = (struct ibv_context *(*)(struct ibv_device *device ,
                                                      int cmd_fd ))((void *)0);
#line 367
    dev->ops.free_context = (void (*)(struct ibv_context *context ))((void *)0);
  }
  {
#line 370
  tmp___0 = ibv_read_sysfs_file((char const   *)(sysfs_dev->ibdev_path), "node_type",
                                value, sizeof(value));
  }
#line 370
  if (tmp___0 < 0) {
    {
#line 371
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: no node_type attr under %s.\n",
            sysfs_dev->ibdev_path);
#line 373
    dev->node_type = (enum ibv_node_type )-1;
    }
  } else {
    {
#line 375
    tmp = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                 10);
#line 375
    dev->node_type = (enum ibv_node_type )tmp;
    }
#line 376
    if ((int )dev->node_type < 1) {
#line 377
      dev->node_type = (enum ibv_node_type )-1;
    } else
#line 376
    if ((int )dev->node_type > 4) {
#line 377
      dev->node_type = (enum ibv_node_type )-1;
    }
  }
  {
#line 383
  if ((int )dev->node_type == 3) {
#line 383
    goto case_3;
  }
#line 383
  if ((int )dev->node_type == 2) {
#line 383
    goto case_3;
  }
#line 383
  if ((int )dev->node_type == 1) {
#line 383
    goto case_3;
  }
#line 386
  if ((int )dev->node_type == 4) {
#line 386
    goto case_4;
  }
#line 389
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 384
  dev->transport_type = (enum ibv_transport_type )0;
#line 385
  goto switch_break;
  case_4: /* CIL Label */ 
#line 387
  dev->transport_type = (enum ibv_transport_type )1;
#line 388
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 390
  dev->transport_type = (enum ibv_transport_type )-1;
#line 391
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 394
  strcpy((char */* __restrict  */)(dev->dev_name), (char const   */* __restrict  */)(sysfs_dev->sysfs_name));
#line 395
  strcpy((char */* __restrict  */)(dev->dev_path), (char const   */* __restrict  */)(sysfs_dev->sysfs_path));
#line 396
  strcpy((char */* __restrict  */)(dev->name), (char const   */* __restrict  */)(sysfs_dev->ibdev_name));
#line 397
  strcpy((char */* __restrict  */)(dev->ibdev_path), (char const   */* __restrict  */)(sysfs_dev->ibdev_path));
  }
#line 399
  return (dev);
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_device *try_drivers___5(struct ibv_sysfs_dev *sysfs_dev ) 
{ 
  struct ibv_driver *driver ;
  struct ibv_device *dev ;

  {
#line 407
  driver = head_driver___5;
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 407
    if (! driver) {
#line 407
      goto while_break;
    }
    {
#line 408
    dev = try_driver___5(driver, sysfs_dev);
    }
#line 409
    if (dev) {
#line 410
      return (dev);
    }
#line 407
    driver = driver->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 413
  return ((struct ibv_device *)((void *)0));
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static int check_abi_version___5(char const   *path ) 
{ 
  char value[8] ;
  int tmp ;
  long tmp___0 ;

  {
  {
#line 420
  tmp = ibv_read_sysfs_file(path, "class/infiniband_verbs/abi_version", value, sizeof(value));
  }
#line 420
  if (tmp < 0) {
#line 422
    return (38);
  }
  {
#line 425
  tmp___0 = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                   10);
#line 425
  abi_ver = (int __attribute__((__visibility__("hidden")))  )tmp___0;
  }
#line 427
  if (abi_ver < (int __attribute__((__visibility__("hidden")))  )3) {
    {
#line 429
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Fatal: kernel ABI version %d doesn\'t match library version %d.\n",
            abi_ver, 6);
    }
#line 432
    return (38);
  } else
#line 427
  if (abi_ver > (int __attribute__((__visibility__("hidden")))  )6) {
    {
#line 429
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Fatal: kernel ABI version %d doesn\'t match library version %d.\n",
            abi_ver, 6);
    }
#line 432
    return (38);
  }
#line 435
  return (0);
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void check_memlock_limit___5(void) 
{ 
  struct rlimit rlim ;
  __uid_t tmp ;
  int tmp___0 ;

  {
  {
#line 442
  tmp = geteuid();
  }
#line 442
  if (! tmp) {
#line 443
    return;
  }
  {
#line 445
  tmp___0 = getrlimit((__rlimit_resource_t )8, & rlim);
  }
#line 445
  if (tmp___0) {
    {
#line 446
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: getrlimit(RLIMIT_MEMLOCK) failed.");
    }
#line 447
    return;
  }
#line 450
  if (rlim.rlim_cur <= 32768UL) {
    {
#line 451
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: RLIMIT_MEMLOCK is %lu bytes.\n    This will severely limit memory registrations.\n",
            rlim.rlim_cur);
    }
  }
#line 454
  return;
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void add_device___5(struct ibv_device *dev , struct ibv_device ***dev_list ,
                           int *num_devices___7 , int *list_size ) 
{ 
  struct ibv_device **new_list ;
  void *tmp ;
  int tmp___0 ;

  {
#line 463
  if (*list_size <= *num_devices___7) {
#line 464
    if (*list_size) {
#line 464
      *list_size *= 2;
    } else {
#line 464
      *list_size = 1;
    }
    {
#line 465
    tmp = realloc((void *)*dev_list, (unsigned long )*list_size * sizeof(struct ibv_device *));
#line 465
    new_list = (struct ibv_device **)tmp;
    }
#line 466
    if (! new_list) {
#line 467
      return;
    }
#line 468
    *dev_list = new_list;
  }
#line 471
  tmp___0 = *num_devices___7;
#line 471
  (*num_devices___7) ++;
#line 471
  *(*dev_list + tmp___0) = dev;
#line 472
  return;
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
static int ibv_cmd_modify_srq_v3___5(struct ibv_srq *srq , struct ibv_srq_attr *srq_attr ,
                                     int srq_attr_mask , struct ibv_modify_srq *new_cmd ,
                                     size_t new_cmd_size ) 
{ 
  struct ibv_modify_srq_v3 *cmd ;
  size_t cmd_size ;
  void *tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 409
  cmd_size = (sizeof(*cmd) + new_cmd_size) - sizeof(*new_cmd);
#line 410
  tmp = __builtin_alloca(cmd_size);
#line 410
  cmd = (struct ibv_modify_srq_v3 *)tmp;
#line 411
  memcpy((void */* __restrict  */)(cmd->driver_data), (void const   */* __restrict  */)(new_cmd->driver_data),
         new_cmd_size - sizeof(*new_cmd));
  }
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 413
      cmd->command = (__u32 )33;
    } else {
#line 413
      cmd->command = (__u32 )35;
    }
#line 413
    cmd->in_words = (__u16 )(cmd_size / 4UL);
#line 413
    cmd->out_words = (__u16 )0;
#line 413
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 415
  cmd->srq_handle = srq->handle;
#line 416
  cmd->attr_mask = (__u32 )srq_attr_mask;
#line 417
  cmd->max_wr = srq_attr->max_wr;
#line 418
  cmd->srq_limit = srq_attr->srq_limit;
#line 419
  cmd->max_sge = (__u32 )0;
#line 420
  cmd->reserved = (__u32 )0;
#line 422
  tmp___1 = write((srq->context)->cmd_fd, (void const   *)cmd, cmd_size);
  }
#line 422
  if ((size_t )tmp___1 != cmd_size) {
    {
#line 423
    tmp___0 = __errno_location();
    }
#line 423
    return (*tmp___0);
  }
#line 425
  return (0);
}
}
#line 1008 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
static int ib_spec_to_kern_spec___5(struct ibv_flow_spec *ib_spec , struct ibv_kern_spec *kern_spec ) 
{ 


  {
#line 1011
  kern_spec->__annonCompField5.hdr.type = (__u32 )ib_spec->__annonCompField1.hdr.type;
  {
#line 1014
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 32U) {
#line 1014
    goto case_32;
  }
#line 1021
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 48U) {
#line 1021
    goto case_48;
  }
#line 1029
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 65U) {
#line 1029
    goto case_65;
  }
#line 1029
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 64U) {
#line 1029
    goto case_65;
  }
#line 1036
  goto switch_default;
  case_32: /* CIL Label */ 
  {
#line 1015
  kern_spec->__annonCompField5.eth.size = (__u16 )sizeof(struct ibv_kern_spec_eth );
#line 1016
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.eth.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.eth.val),
         sizeof(struct ibv_flow_eth_filter ));
#line 1018
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.eth.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.eth.mask),
         sizeof(struct ibv_flow_eth_filter ));
  }
#line 1020
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 1022
  kern_spec->__annonCompField5.ipv4.size = (__u16 )sizeof(struct ibv_kern_spec_ipv4 );
#line 1023
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.ipv4.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.ipv4.val),
         sizeof(struct ibv_flow_ipv4_filter ));
#line 1025
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.ipv4.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.ipv4.mask),
         sizeof(struct ibv_flow_ipv4_filter ));
  }
#line 1027
  goto switch_break;
  case_65: /* CIL Label */ 
  case_64: /* CIL Label */ 
  {
#line 1030
  kern_spec->__annonCompField5.tcp_udp.size = (__u16 )sizeof(struct ibv_kern_spec_tcp_udp );
#line 1031
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.tcp_udp.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.tcp_udp.val),
         sizeof(struct ibv_flow_ipv4_filter ));
#line 1033
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.tcp_udp.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.tcp_udp.mask),
         sizeof(struct ibv_flow_tcp_udp_filter ));
  }
#line 1035
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1037
  return (-22);
  switch_break: /* CIL Label */ ;
  }
#line 1039
  return (0);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  node_type_str___5[5]  = {      (char const   */* const  */)0,      (char const   */* const  */)"InfiniBand channel adapter",      (char const   */* const  */)"InfiniBand switch",      (char const   */* const  */)"InfiniBand router", 
        (char const   */* const  */)"iWARP NIC"};
#line 52 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  port_state_str___6[6]  = {      (char const   */* const  */)"no state change (NOP)",      (char const   */* const  */)"down",      (char const   */* const  */)"init",      (char const   */* const  */)"armed", 
        (char const   */* const  */)"active",      (char const   */* const  */)"active defer"};
#line 69 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  event_type_str___5[19]  = 
#line 69
  {      (char const   */* const  */)"CQ error",      (char const   */* const  */)"local work queue catastrophic error",      (char const   */* const  */)"invalid request local work queue error",      (char const   */* const  */)"local access violation work queue error", 
        (char const   */* const  */)"communication established",      (char const   */* const  */)"send queue drained",      (char const   */* const  */)"path migrated",      (char const   */* const  */)"path migration request error", 
        (char const   */* const  */)"local catastrophic error",      (char const   */* const  */)"port active",      (char const   */* const  */)"port error",      (char const   */* const  */)"LID change", 
        (char const   */* const  */)"P_Key change",      (char const   */* const  */)"SM change",      (char const   */* const  */)"SRQ catastrophic error",      (char const   */* const  */)"SRQ limit reached", 
        (char const   */* const  */)"last WQE reached",      (char const   */* const  */)"client reregistration",      (char const   */* const  */)"GID table change"};
#line 99 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  wc_status_str___5[22]  = 
#line 99
  {      (char const   */* const  */)"success",      (char const   */* const  */)"local length error",      (char const   */* const  */)"local QP operation error",      (char const   */* const  */)"local EE context operation error", 
        (char const   */* const  */)"local protection error",      (char const   */* const  */)"Work Request Flushed Error",      (char const   */* const  */)"memory management operation error",      (char const   */* const  */)"bad response error", 
        (char const   */* const  */)"local access error",      (char const   */* const  */)"remote invalid request error",      (char const   */* const  */)"remote access error",      (char const   */* const  */)"remote operation error", 
        (char const   */* const  */)"transport retry counter exceeded",      (char const   */* const  */)"RNR retry counter exceeded",      (char const   */* const  */)"local RDD violation error",      (char const   */* const  */)"remote invalid RD request", 
        (char const   */* const  */)"aborted error",      (char const   */* const  */)"invalid EE context number",      (char const   */* const  */)"invalid EE context state",      (char const   */* const  */)"fatal error", 
        (char const   */* const  */)"response timeout error",      (char const   */* const  */)"general error"};
#line 267 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
__asm__(".symver __ibv_get_device_list_1_0,ibv_get_device_list@IBVERBS_1.0");
#line 281
__asm__(".symver __ibv_free_device_list_1_0,ibv_free_device_list@IBVERBS_1.0");
#line 287
__asm__(".symver __ibv_get_device_name_1_0,ibv_get_device_name@IBVERBS_1.0");
#line 293
__asm__(".symver __ibv_get_device_guid_1_0,ibv_get_device_guid@IBVERBS_1.0");
#line 295 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int poll_cq_wrapper_1_0___5(struct ibv_cq_1_0 *cq , int num_entries , struct ibv_wc *wc ) 
{ 
  int tmp ;

  {
  {
#line 298
  tmp = (*(((cq->context)->real_context)->ops.poll_cq))(cq->real_cq, num_entries,
                                                        wc);
  }
#line 298
  return (tmp);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int req_notify_cq_wrapper_1_0___5(struct ibv_cq_1_0 *cq , int sol_only ) 
{ 
  int tmp ;

  {
  {
#line 303
  tmp = (*(((cq->context)->real_context)->ops.req_notify_cq))(cq->real_cq, sol_only);
  }
#line 303
  return (tmp);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_srq_recv_wrapper_1_0___5(struct ibv_srq_1_0 *srq , struct ibv_recv_wr_1_0 *wr ,
                                         struct ibv_recv_wr_1_0 **bad_wr ) 
{ 
  struct ibv_recv_wr_1_0 *w ;
  struct ibv_recv_wr *real_wr ;
  struct ibv_recv_wr *head_wr ;
  struct ibv_recv_wr *tail_wr ;
  struct ibv_recv_wr *real_bad_wr ;
  int ret ;
  void *tmp ;

  {
#line 310
  head_wr = (struct ibv_recv_wr *)((void *)0);
#line 310
  tail_wr = (struct ibv_recv_wr *)((void *)0);
#line 313
  w = wr;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! w) {
#line 313
      goto while_break;
    }
    {
#line 314
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 314
    real_wr = (struct ibv_recv_wr *)tmp;
#line 315
    real_wr->wr_id = w->wr_id;
#line 316
    real_wr->sg_list = w->sg_list;
#line 317
    real_wr->num_sge = w->num_sge;
#line 318
    real_wr->next = (struct ibv_recv_wr *)((void *)0);
    }
#line 319
    if (tail_wr) {
#line 320
      tail_wr->next = real_wr;
    } else {
#line 322
      head_wr = real_wr;
    }
#line 324
    tail_wr = real_wr;
#line 313
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 327
  ret = (*(((srq->context)->real_context)->ops.post_srq_recv))(srq->real_srq, head_wr,
                                                               & real_bad_wr);
  }
#line 330
  if (ret) {
#line 331
    real_wr = head_wr;
#line 331
    w = wr;
    {
#line 331
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 331
      if (! real_wr) {
#line 331
        goto while_break___0;
      }
#line 334
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 335
        *bad_wr = w;
#line 336
        goto while_break___0;
      }
#line 331
      real_wr = real_wr->next;
#line 331
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 340
  return (ret);
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_send_wrapper_1_0___5(struct ibv_qp_1_0 *qp , struct ibv_send_wr_1_0 *wr ,
                                     struct ibv_send_wr_1_0 **bad_wr ) 
{ 
  struct ibv_send_wr_1_0 *w ;
  struct ibv_send_wr *real_wr ;
  struct ibv_send_wr *head_wr ;
  struct ibv_send_wr *tail_wr ;
  struct ibv_send_wr *real_bad_wr ;
  int is_ud ;
  int ret ;
  void *tmp ;

  {
#line 347
  head_wr = (struct ibv_send_wr *)((void *)0);
#line 347
  tail_wr = (struct ibv_send_wr *)((void *)0);
#line 348
  is_ud = (unsigned int )qp->qp_type == 4U;
#line 351
  w = wr;
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! w) {
#line 351
      goto while_break;
    }
    {
#line 352
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 352
    real_wr = (struct ibv_send_wr *)tmp;
#line 353
    real_wr->wr_id = w->wr_id;
#line 354
    real_wr->next = (struct ibv_send_wr *)((void *)0);
    }
#line 363
    if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->sg_list)) {
      {
#line 364
      memcpy((void */* __restrict  */)(& real_wr->sg_list), (void const   */* __restrict  */)(& w->sg_list),
             sizeof(*real_wr) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list));
      }
    } else
#line 366
    if ((unsigned long )(& ((struct ibv_send_wr *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list) == (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->sg_list)) {
#line 366
      if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->wr) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->wr)) {
        {
#line 371
        memcpy((void */* __restrict  */)(& real_wr->sg_list), (void const   */* __restrict  */)(& w->sg_list),
               ((unsigned long )(& ((struct ibv_send_wr *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list)) + sizeof(real_wr->imm_data));
#line 375
        memcpy((void */* __restrict  */)(& real_wr->wr), (void const   */* __restrict  */)(& w->wr),
               sizeof(real_wr->wr));
        }
      } else {
#line 366
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 377
      real_wr->sg_list = w->sg_list;
#line 378
      real_wr->num_sge = w->num_sge;
#line 379
      real_wr->opcode = w->opcode;
#line 380
      real_wr->send_flags = w->send_flags;
#line 381
      real_wr->imm_data = w->imm_data;
#line 382
      if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->wr) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->wr)) {
        {
#line 383
        memcpy((void */* __restrict  */)(& real_wr->wr), (void const   */* __restrict  */)(& w->wr),
               sizeof(real_wr->wr));
        }
      } else {
#line 386
        real_wr->wr.atomic.remote_addr = w->wr.atomic.remote_addr;
#line 388
        real_wr->wr.atomic.compare_add = w->wr.atomic.compare_add;
#line 390
        real_wr->wr.atomic.swap = w->wr.atomic.swap;
#line 392
        real_wr->wr.atomic.rkey = w->wr.atomic.rkey;
      }
    }
#line 397
    if (is_ud) {
#line 398
      real_wr->wr.ud.ah = (w->wr.ud.ah)->real_ah;
    }
#line 400
    if (tail_wr) {
#line 401
      tail_wr->next = real_wr;
    } else {
#line 403
      head_wr = real_wr;
    }
#line 405
    tail_wr = real_wr;
#line 351
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 408
  ret = (*(((qp->context)->real_context)->ops.post_send))(qp->real_qp, head_wr, & real_bad_wr);
  }
#line 411
  if (ret) {
#line 412
    real_wr = head_wr;
#line 412
    w = wr;
    {
#line 412
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 412
      if (! real_wr) {
#line 412
        goto while_break___0;
      }
#line 415
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 416
        *bad_wr = w;
#line 417
        goto while_break___0;
      }
#line 412
      real_wr = real_wr->next;
#line 412
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 421
  return (ret);
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_recv_wrapper_1_0___5(struct ibv_qp_1_0 *qp , struct ibv_recv_wr_1_0 *wr ,
                                     struct ibv_recv_wr_1_0 **bad_wr ) 
{ 
  struct ibv_recv_wr_1_0 *w ;
  struct ibv_recv_wr *real_wr ;
  struct ibv_recv_wr *head_wr ;
  struct ibv_recv_wr *tail_wr ;
  struct ibv_recv_wr *real_bad_wr ;
  int ret ;
  void *tmp ;

  {
#line 428
  head_wr = (struct ibv_recv_wr *)((void *)0);
#line 428
  tail_wr = (struct ibv_recv_wr *)((void *)0);
#line 431
  w = wr;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! w) {
#line 431
      goto while_break;
    }
    {
#line 432
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 432
    real_wr = (struct ibv_recv_wr *)tmp;
#line 433
    real_wr->wr_id = w->wr_id;
#line 434
    real_wr->sg_list = w->sg_list;
#line 435
    real_wr->num_sge = w->num_sge;
#line 436
    real_wr->next = (struct ibv_recv_wr *)((void *)0);
    }
#line 437
    if (tail_wr) {
#line 438
      tail_wr->next = real_wr;
    } else {
#line 440
      head_wr = real_wr;
    }
#line 442
    tail_wr = real_wr;
#line 431
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 445
  ret = (*(((qp->context)->real_context)->ops.post_recv))(qp->real_qp, head_wr, & real_bad_wr);
  }
#line 448
  if (ret) {
#line 449
    real_wr = head_wr;
#line 449
    w = wr;
    {
#line 449
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 449
      if (! real_wr) {
#line 449
        goto while_break___0;
      }
#line 452
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 453
        *bad_wr = w;
#line 454
        goto while_break___0;
      }
#line 449
      real_wr = real_wr->next;
#line 449
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 458
  return (ret);
}
}
#line 487
__asm__(".symver __ibv_open_device_1_0,ibv_open_device@IBVERBS_1.0");
#line 500
__asm__(".symver __ibv_close_device_1_0,ibv_close_device@IBVERBS_1.0");
#line 538
__asm__(".symver __ibv_get_async_event_1_0,ibv_get_async_event@IBVERBS_1.0");
#line 574
__asm__(".symver __ibv_ack_async_event_1_0,ibv_ack_async_event@IBVERBS_1.0");
#line 581
__asm__(".symver __ibv_query_device_1_0,ibv_query_device@IBVERBS_1.0");
#line 588
__asm__(".symver __ibv_query_port_1_0,ibv_query_port@IBVERBS_1.0");
#line 595
__asm__(".symver __ibv_query_gid_1_0,ibv_query_gid@IBVERBS_1.0");
#line 602
__asm__(".symver __ibv_query_pkey_1_0,ibv_query_pkey@IBVERBS_1.0");
#line 624
__asm__(".symver __ibv_alloc_pd_1_0,ibv_alloc_pd@IBVERBS_1.0");
#line 637
__asm__(".symver __ibv_dealloc_pd_1_0,ibv_dealloc_pd@IBVERBS_1.0");
#line 663
__asm__(".symver __ibv_reg_mr_1_0,ibv_reg_mr@IBVERBS_1.0");
#line 676
__asm__(".symver __ibv_dereg_mr_1_0,ibv_dereg_mr@IBVERBS_1.0");
#line 706
__asm__(".symver __ibv_create_cq_1_0,ibv_create_cq@IBVERBS_1.0");
#line 712
__asm__(".symver __ibv_resize_cq_1_0,ibv_resize_cq@IBVERBS_1.0");
#line 725
__asm__(".symver __ibv_destroy_cq_1_0,ibv_destroy_cq@IBVERBS_1.0");
#line 743
__asm__(".symver __ibv_get_cq_event_1_0,ibv_get_cq_event@IBVERBS_1.0");
#line 749
__asm__(".symver __ibv_ack_cq_events_1_0,ibv_ack_cq_events@IBVERBS_1.0");
#line 776
__asm__(".symver __ibv_create_srq_1_0,ibv_create_srq@IBVERBS_1.0");
#line 784
__asm__(".symver __ibv_modify_srq_1_0,ibv_modify_srq@IBVERBS_1.0");
#line 790
__asm__(".symver __ibv_query_srq_1_0,ibv_query_srq@IBVERBS_1.0");
#line 803
__asm__(".symver __ibv_destroy_srq_1_0,ibv_destroy_srq@IBVERBS_1.0");
#line 847
__asm__(".symver __ibv_create_qp_1_0,ibv_create_qp@IBVERBS_1.0");
#line 870
__asm__(".symver __ibv_query_qp_1_0,ibv_query_qp@IBVERBS_1.0");
#line 877
__asm__(".symver __ibv_modify_qp_1_0,ibv_modify_qp@IBVERBS_1.0");
#line 890
__asm__(".symver __ibv_destroy_qp_1_0,ibv_destroy_qp@IBVERBS_1.0");
#line 914
__asm__(".symver __ibv_create_ah_1_0,ibv_create_ah@IBVERBS_1.0");
#line 927
__asm__(".symver __ibv_destroy_ah_1_0,ibv_destroy_ah@IBVERBS_1.0");
#line 933
__asm__(".symver __ibv_attach_mcast_1_0,ibv_attach_mcast@IBVERBS_1.0");
#line 939
__asm__(".symver __ibv_detach_mcast_1_0,ibv_detach_mcast@IBVERBS_1.0");
#line 267
__asm__(".symver __ibv_get_device_list_1_0,ibv_get_device_list@IBVERBS_1.0");
#line 281
__asm__(".symver __ibv_free_device_list_1_0,ibv_free_device_list@IBVERBS_1.0");
#line 287
__asm__(".symver __ibv_get_device_name_1_0,ibv_get_device_name@IBVERBS_1.0");
#line 293
__asm__(".symver __ibv_get_device_guid_1_0,ibv_get_device_guid@IBVERBS_1.0");
#line 295 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int poll_cq_wrapper_1_0___6(struct ibv_cq_1_0 *cq , int num_entries , struct ibv_wc *wc ) 
{ 
  int tmp ;

  {
  {
#line 298
  tmp = (*(((cq->context)->real_context)->ops.poll_cq))(cq->real_cq, num_entries,
                                                        wc);
  }
#line 298
  return (tmp);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int req_notify_cq_wrapper_1_0___6(struct ibv_cq_1_0 *cq , int sol_only ) 
{ 
  int tmp ;

  {
  {
#line 303
  tmp = (*(((cq->context)->real_context)->ops.req_notify_cq))(cq->real_cq, sol_only);
  }
#line 303
  return (tmp);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_srq_recv_wrapper_1_0___6(struct ibv_srq_1_0 *srq , struct ibv_recv_wr_1_0 *wr ,
                                         struct ibv_recv_wr_1_0 **bad_wr ) 
{ 
  struct ibv_recv_wr_1_0 *w ;
  struct ibv_recv_wr *real_wr ;
  struct ibv_recv_wr *head_wr ;
  struct ibv_recv_wr *tail_wr ;
  struct ibv_recv_wr *real_bad_wr ;
  int ret ;
  void *tmp ;

  {
#line 310
  head_wr = (struct ibv_recv_wr *)((void *)0);
#line 310
  tail_wr = (struct ibv_recv_wr *)((void *)0);
#line 313
  w = wr;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! w) {
#line 313
      goto while_break;
    }
    {
#line 314
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 314
    real_wr = (struct ibv_recv_wr *)tmp;
#line 315
    real_wr->wr_id = w->wr_id;
#line 316
    real_wr->sg_list = w->sg_list;
#line 317
    real_wr->num_sge = w->num_sge;
#line 318
    real_wr->next = (struct ibv_recv_wr *)((void *)0);
    }
#line 319
    if (tail_wr) {
#line 320
      tail_wr->next = real_wr;
    } else {
#line 322
      head_wr = real_wr;
    }
#line 324
    tail_wr = real_wr;
#line 313
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 327
  ret = (*(((srq->context)->real_context)->ops.post_srq_recv))(srq->real_srq, head_wr,
                                                               & real_bad_wr);
  }
#line 330
  if (ret) {
#line 331
    real_wr = head_wr;
#line 331
    w = wr;
    {
#line 331
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 331
      if (! real_wr) {
#line 331
        goto while_break___0;
      }
#line 334
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 335
        *bad_wr = w;
#line 336
        goto while_break___0;
      }
#line 331
      real_wr = real_wr->next;
#line 331
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 340
  return (ret);
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_send_wrapper_1_0___6(struct ibv_qp_1_0 *qp , struct ibv_send_wr_1_0 *wr ,
                                     struct ibv_send_wr_1_0 **bad_wr ) 
{ 
  struct ibv_send_wr_1_0 *w ;
  struct ibv_send_wr *real_wr ;
  struct ibv_send_wr *head_wr ;
  struct ibv_send_wr *tail_wr ;
  struct ibv_send_wr *real_bad_wr ;
  int is_ud ;
  int ret ;
  void *tmp ;

  {
#line 347
  head_wr = (struct ibv_send_wr *)((void *)0);
#line 347
  tail_wr = (struct ibv_send_wr *)((void *)0);
#line 348
  is_ud = (unsigned int )qp->qp_type == 4U;
#line 351
  w = wr;
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! w) {
#line 351
      goto while_break;
    }
    {
#line 352
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 352
    real_wr = (struct ibv_send_wr *)tmp;
#line 353
    real_wr->wr_id = w->wr_id;
#line 354
    real_wr->next = (struct ibv_send_wr *)((void *)0);
    }
#line 363
    if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->sg_list)) {
      {
#line 364
      memcpy((void */* __restrict  */)(& real_wr->sg_list), (void const   */* __restrict  */)(& w->sg_list),
             sizeof(*real_wr) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list));
      }
    } else
#line 366
    if ((unsigned long )(& ((struct ibv_send_wr *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list) == (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->sg_list)) {
#line 366
      if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->wr) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->wr)) {
        {
#line 371
        memcpy((void */* __restrict  */)(& real_wr->sg_list), (void const   */* __restrict  */)(& w->sg_list),
               ((unsigned long )(& ((struct ibv_send_wr *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list)) + sizeof(real_wr->imm_data));
#line 375
        memcpy((void */* __restrict  */)(& real_wr->wr), (void const   */* __restrict  */)(& w->wr),
               sizeof(real_wr->wr));
        }
      } else {
#line 366
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 377
      real_wr->sg_list = w->sg_list;
#line 378
      real_wr->num_sge = w->num_sge;
#line 379
      real_wr->opcode = w->opcode;
#line 380
      real_wr->send_flags = w->send_flags;
#line 381
      real_wr->imm_data = w->imm_data;
#line 382
      if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->wr) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->wr)) {
        {
#line 383
        memcpy((void */* __restrict  */)(& real_wr->wr), (void const   */* __restrict  */)(& w->wr),
               sizeof(real_wr->wr));
        }
      } else {
#line 386
        real_wr->wr.atomic.remote_addr = w->wr.atomic.remote_addr;
#line 388
        real_wr->wr.atomic.compare_add = w->wr.atomic.compare_add;
#line 390
        real_wr->wr.atomic.swap = w->wr.atomic.swap;
#line 392
        real_wr->wr.atomic.rkey = w->wr.atomic.rkey;
      }
    }
#line 397
    if (is_ud) {
#line 398
      real_wr->wr.ud.ah = (w->wr.ud.ah)->real_ah;
    }
#line 400
    if (tail_wr) {
#line 401
      tail_wr->next = real_wr;
    } else {
#line 403
      head_wr = real_wr;
    }
#line 405
    tail_wr = real_wr;
#line 351
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 408
  ret = (*(((qp->context)->real_context)->ops.post_send))(qp->real_qp, head_wr, & real_bad_wr);
  }
#line 411
  if (ret) {
#line 412
    real_wr = head_wr;
#line 412
    w = wr;
    {
#line 412
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 412
      if (! real_wr) {
#line 412
        goto while_break___0;
      }
#line 415
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 416
        *bad_wr = w;
#line 417
        goto while_break___0;
      }
#line 412
      real_wr = real_wr->next;
#line 412
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 421
  return (ret);
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_recv_wrapper_1_0___6(struct ibv_qp_1_0 *qp , struct ibv_recv_wr_1_0 *wr ,
                                     struct ibv_recv_wr_1_0 **bad_wr ) 
{ 
  struct ibv_recv_wr_1_0 *w ;
  struct ibv_recv_wr *real_wr ;
  struct ibv_recv_wr *head_wr ;
  struct ibv_recv_wr *tail_wr ;
  struct ibv_recv_wr *real_bad_wr ;
  int ret ;
  void *tmp ;

  {
#line 428
  head_wr = (struct ibv_recv_wr *)((void *)0);
#line 428
  tail_wr = (struct ibv_recv_wr *)((void *)0);
#line 431
  w = wr;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! w) {
#line 431
      goto while_break;
    }
    {
#line 432
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 432
    real_wr = (struct ibv_recv_wr *)tmp;
#line 433
    real_wr->wr_id = w->wr_id;
#line 434
    real_wr->sg_list = w->sg_list;
#line 435
    real_wr->num_sge = w->num_sge;
#line 436
    real_wr->next = (struct ibv_recv_wr *)((void *)0);
    }
#line 437
    if (tail_wr) {
#line 438
      tail_wr->next = real_wr;
    } else {
#line 440
      head_wr = real_wr;
    }
#line 442
    tail_wr = real_wr;
#line 431
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 445
  ret = (*(((qp->context)->real_context)->ops.post_recv))(qp->real_qp, head_wr, & real_bad_wr);
  }
#line 448
  if (ret) {
#line 449
    real_wr = head_wr;
#line 449
    w = wr;
    {
#line 449
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 449
      if (! real_wr) {
#line 449
        goto while_break___0;
      }
#line 452
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 453
        *bad_wr = w;
#line 454
        goto while_break___0;
      }
#line 449
      real_wr = real_wr->next;
#line 449
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 458
  return (ret);
}
}
#line 487
__asm__(".symver __ibv_open_device_1_0,ibv_open_device@IBVERBS_1.0");
#line 500
__asm__(".symver __ibv_close_device_1_0,ibv_close_device@IBVERBS_1.0");
#line 538
__asm__(".symver __ibv_get_async_event_1_0,ibv_get_async_event@IBVERBS_1.0");
#line 574
__asm__(".symver __ibv_ack_async_event_1_0,ibv_ack_async_event@IBVERBS_1.0");
#line 581
__asm__(".symver __ibv_query_device_1_0,ibv_query_device@IBVERBS_1.0");
#line 588
__asm__(".symver __ibv_query_port_1_0,ibv_query_port@IBVERBS_1.0");
#line 595
__asm__(".symver __ibv_query_gid_1_0,ibv_query_gid@IBVERBS_1.0");
#line 602
__asm__(".symver __ibv_query_pkey_1_0,ibv_query_pkey@IBVERBS_1.0");
#line 624
__asm__(".symver __ibv_alloc_pd_1_0,ibv_alloc_pd@IBVERBS_1.0");
#line 637
__asm__(".symver __ibv_dealloc_pd_1_0,ibv_dealloc_pd@IBVERBS_1.0");
#line 663
__asm__(".symver __ibv_reg_mr_1_0,ibv_reg_mr@IBVERBS_1.0");
#line 676
__asm__(".symver __ibv_dereg_mr_1_0,ibv_dereg_mr@IBVERBS_1.0");
#line 706
__asm__(".symver __ibv_create_cq_1_0,ibv_create_cq@IBVERBS_1.0");
#line 712
__asm__(".symver __ibv_resize_cq_1_0,ibv_resize_cq@IBVERBS_1.0");
#line 725
__asm__(".symver __ibv_destroy_cq_1_0,ibv_destroy_cq@IBVERBS_1.0");
#line 743
__asm__(".symver __ibv_get_cq_event_1_0,ibv_get_cq_event@IBVERBS_1.0");
#line 749
__asm__(".symver __ibv_ack_cq_events_1_0,ibv_ack_cq_events@IBVERBS_1.0");
#line 776
__asm__(".symver __ibv_create_srq_1_0,ibv_create_srq@IBVERBS_1.0");
#line 784
__asm__(".symver __ibv_modify_srq_1_0,ibv_modify_srq@IBVERBS_1.0");
#line 790
__asm__(".symver __ibv_query_srq_1_0,ibv_query_srq@IBVERBS_1.0");
#line 803
__asm__(".symver __ibv_destroy_srq_1_0,ibv_destroy_srq@IBVERBS_1.0");
#line 847
__asm__(".symver __ibv_create_qp_1_0,ibv_create_qp@IBVERBS_1.0");
#line 870
__asm__(".symver __ibv_query_qp_1_0,ibv_query_qp@IBVERBS_1.0");
#line 877
__asm__(".symver __ibv_modify_qp_1_0,ibv_modify_qp@IBVERBS_1.0");
#line 890
__asm__(".symver __ibv_destroy_qp_1_0,ibv_destroy_qp@IBVERBS_1.0");
#line 914
__asm__(".symver __ibv_create_ah_1_0,ibv_create_ah@IBVERBS_1.0");
#line 927
__asm__(".symver __ibv_destroy_ah_1_0,ibv_destroy_ah@IBVERBS_1.0");
#line 933
__asm__(".symver __ibv_attach_mcast_1_0,ibv_attach_mcast@IBVERBS_1.0");
#line 939
__asm__(".symver __ibv_detach_mcast_1_0,ibv_detach_mcast@IBVERBS_1.0");
#line 267
__asm__(".symver __ibv_get_device_list_1_0,ibv_get_device_list@IBVERBS_1.0");
#line 281
__asm__(".symver __ibv_free_device_list_1_0,ibv_free_device_list@IBVERBS_1.0");
#line 287
__asm__(".symver __ibv_get_device_name_1_0,ibv_get_device_name@IBVERBS_1.0");
#line 293
__asm__(".symver __ibv_get_device_guid_1_0,ibv_get_device_guid@IBVERBS_1.0");
#line 295 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int poll_cq_wrapper_1_0___7(struct ibv_cq_1_0 *cq , int num_entries , struct ibv_wc *wc ) 
{ 
  int tmp ;

  {
  {
#line 298
  tmp = (*(((cq->context)->real_context)->ops.poll_cq))(cq->real_cq, num_entries,
                                                        wc);
  }
#line 298
  return (tmp);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int req_notify_cq_wrapper_1_0___7(struct ibv_cq_1_0 *cq , int sol_only ) 
{ 
  int tmp ;

  {
  {
#line 303
  tmp = (*(((cq->context)->real_context)->ops.req_notify_cq))(cq->real_cq, sol_only);
  }
#line 303
  return (tmp);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_srq_recv_wrapper_1_0___7(struct ibv_srq_1_0 *srq , struct ibv_recv_wr_1_0 *wr ,
                                         struct ibv_recv_wr_1_0 **bad_wr ) 
{ 
  struct ibv_recv_wr_1_0 *w ;
  struct ibv_recv_wr *real_wr ;
  struct ibv_recv_wr *head_wr ;
  struct ibv_recv_wr *tail_wr ;
  struct ibv_recv_wr *real_bad_wr ;
  int ret ;
  void *tmp ;

  {
#line 310
  head_wr = (struct ibv_recv_wr *)((void *)0);
#line 310
  tail_wr = (struct ibv_recv_wr *)((void *)0);
#line 313
  w = wr;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! w) {
#line 313
      goto while_break;
    }
    {
#line 314
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 314
    real_wr = (struct ibv_recv_wr *)tmp;
#line 315
    real_wr->wr_id = w->wr_id;
#line 316
    real_wr->sg_list = w->sg_list;
#line 317
    real_wr->num_sge = w->num_sge;
#line 318
    real_wr->next = (struct ibv_recv_wr *)((void *)0);
    }
#line 319
    if (tail_wr) {
#line 320
      tail_wr->next = real_wr;
    } else {
#line 322
      head_wr = real_wr;
    }
#line 324
    tail_wr = real_wr;
#line 313
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 327
  ret = (*(((srq->context)->real_context)->ops.post_srq_recv))(srq->real_srq, head_wr,
                                                               & real_bad_wr);
  }
#line 330
  if (ret) {
#line 331
    real_wr = head_wr;
#line 331
    w = wr;
    {
#line 331
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 331
      if (! real_wr) {
#line 331
        goto while_break___0;
      }
#line 334
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 335
        *bad_wr = w;
#line 336
        goto while_break___0;
      }
#line 331
      real_wr = real_wr->next;
#line 331
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 340
  return (ret);
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_send_wrapper_1_0___7(struct ibv_qp_1_0 *qp , struct ibv_send_wr_1_0 *wr ,
                                     struct ibv_send_wr_1_0 **bad_wr ) 
{ 
  struct ibv_send_wr_1_0 *w ;
  struct ibv_send_wr *real_wr ;
  struct ibv_send_wr *head_wr ;
  struct ibv_send_wr *tail_wr ;
  struct ibv_send_wr *real_bad_wr ;
  int is_ud ;
  int ret ;
  void *tmp ;

  {
#line 347
  head_wr = (struct ibv_send_wr *)((void *)0);
#line 347
  tail_wr = (struct ibv_send_wr *)((void *)0);
#line 348
  is_ud = (unsigned int )qp->qp_type == 4U;
#line 351
  w = wr;
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! w) {
#line 351
      goto while_break;
    }
    {
#line 352
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 352
    real_wr = (struct ibv_send_wr *)tmp;
#line 353
    real_wr->wr_id = w->wr_id;
#line 354
    real_wr->next = (struct ibv_send_wr *)((void *)0);
    }
#line 363
    if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->sg_list)) {
      {
#line 364
      memcpy((void */* __restrict  */)(& real_wr->sg_list), (void const   */* __restrict  */)(& w->sg_list),
             sizeof(*real_wr) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list));
      }
    } else
#line 366
    if ((unsigned long )(& ((struct ibv_send_wr *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list) == (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->sg_list)) {
#line 366
      if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->wr) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->wr)) {
        {
#line 371
        memcpy((void */* __restrict  */)(& real_wr->sg_list), (void const   */* __restrict  */)(& w->sg_list),
               ((unsigned long )(& ((struct ibv_send_wr *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list)) + sizeof(real_wr->imm_data));
#line 375
        memcpy((void */* __restrict  */)(& real_wr->wr), (void const   */* __restrict  */)(& w->wr),
               sizeof(real_wr->wr));
        }
      } else {
#line 366
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 377
      real_wr->sg_list = w->sg_list;
#line 378
      real_wr->num_sge = w->num_sge;
#line 379
      real_wr->opcode = w->opcode;
#line 380
      real_wr->send_flags = w->send_flags;
#line 381
      real_wr->imm_data = w->imm_data;
#line 382
      if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->wr) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->wr)) {
        {
#line 383
        memcpy((void */* __restrict  */)(& real_wr->wr), (void const   */* __restrict  */)(& w->wr),
               sizeof(real_wr->wr));
        }
      } else {
#line 386
        real_wr->wr.atomic.remote_addr = w->wr.atomic.remote_addr;
#line 388
        real_wr->wr.atomic.compare_add = w->wr.atomic.compare_add;
#line 390
        real_wr->wr.atomic.swap = w->wr.atomic.swap;
#line 392
        real_wr->wr.atomic.rkey = w->wr.atomic.rkey;
      }
    }
#line 397
    if (is_ud) {
#line 398
      real_wr->wr.ud.ah = (w->wr.ud.ah)->real_ah;
    }
#line 400
    if (tail_wr) {
#line 401
      tail_wr->next = real_wr;
    } else {
#line 403
      head_wr = real_wr;
    }
#line 405
    tail_wr = real_wr;
#line 351
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 408
  ret = (*(((qp->context)->real_context)->ops.post_send))(qp->real_qp, head_wr, & real_bad_wr);
  }
#line 411
  if (ret) {
#line 412
    real_wr = head_wr;
#line 412
    w = wr;
    {
#line 412
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 412
      if (! real_wr) {
#line 412
        goto while_break___0;
      }
#line 415
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 416
        *bad_wr = w;
#line 417
        goto while_break___0;
      }
#line 412
      real_wr = real_wr->next;
#line 412
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 421
  return (ret);
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_recv_wrapper_1_0___7(struct ibv_qp_1_0 *qp , struct ibv_recv_wr_1_0 *wr ,
                                     struct ibv_recv_wr_1_0 **bad_wr ) 
{ 
  struct ibv_recv_wr_1_0 *w ;
  struct ibv_recv_wr *real_wr ;
  struct ibv_recv_wr *head_wr ;
  struct ibv_recv_wr *tail_wr ;
  struct ibv_recv_wr *real_bad_wr ;
  int ret ;
  void *tmp ;

  {
#line 428
  head_wr = (struct ibv_recv_wr *)((void *)0);
#line 428
  tail_wr = (struct ibv_recv_wr *)((void *)0);
#line 431
  w = wr;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! w) {
#line 431
      goto while_break;
    }
    {
#line 432
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 432
    real_wr = (struct ibv_recv_wr *)tmp;
#line 433
    real_wr->wr_id = w->wr_id;
#line 434
    real_wr->sg_list = w->sg_list;
#line 435
    real_wr->num_sge = w->num_sge;
#line 436
    real_wr->next = (struct ibv_recv_wr *)((void *)0);
    }
#line 437
    if (tail_wr) {
#line 438
      tail_wr->next = real_wr;
    } else {
#line 440
      head_wr = real_wr;
    }
#line 442
    tail_wr = real_wr;
#line 431
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 445
  ret = (*(((qp->context)->real_context)->ops.post_recv))(qp->real_qp, head_wr, & real_bad_wr);
  }
#line 448
  if (ret) {
#line 449
    real_wr = head_wr;
#line 449
    w = wr;
    {
#line 449
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 449
      if (! real_wr) {
#line 449
        goto while_break___0;
      }
#line 452
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 453
        *bad_wr = w;
#line 454
        goto while_break___0;
      }
#line 449
      real_wr = real_wr->next;
#line 449
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 458
  return (ret);
}
}
#line 487
__asm__(".symver __ibv_open_device_1_0,ibv_open_device@IBVERBS_1.0");
#line 500
__asm__(".symver __ibv_close_device_1_0,ibv_close_device@IBVERBS_1.0");
#line 538
__asm__(".symver __ibv_get_async_event_1_0,ibv_get_async_event@IBVERBS_1.0");
#line 574
__asm__(".symver __ibv_ack_async_event_1_0,ibv_ack_async_event@IBVERBS_1.0");
#line 581
__asm__(".symver __ibv_query_device_1_0,ibv_query_device@IBVERBS_1.0");
#line 588
__asm__(".symver __ibv_query_port_1_0,ibv_query_port@IBVERBS_1.0");
#line 595
__asm__(".symver __ibv_query_gid_1_0,ibv_query_gid@IBVERBS_1.0");
#line 602
__asm__(".symver __ibv_query_pkey_1_0,ibv_query_pkey@IBVERBS_1.0");
#line 624
__asm__(".symver __ibv_alloc_pd_1_0,ibv_alloc_pd@IBVERBS_1.0");
#line 637
__asm__(".symver __ibv_dealloc_pd_1_0,ibv_dealloc_pd@IBVERBS_1.0");
#line 663
__asm__(".symver __ibv_reg_mr_1_0,ibv_reg_mr@IBVERBS_1.0");
#line 676
__asm__(".symver __ibv_dereg_mr_1_0,ibv_dereg_mr@IBVERBS_1.0");
#line 706
__asm__(".symver __ibv_create_cq_1_0,ibv_create_cq@IBVERBS_1.0");
#line 712
__asm__(".symver __ibv_resize_cq_1_0,ibv_resize_cq@IBVERBS_1.0");
#line 725
__asm__(".symver __ibv_destroy_cq_1_0,ibv_destroy_cq@IBVERBS_1.0");
#line 743
__asm__(".symver __ibv_get_cq_event_1_0,ibv_get_cq_event@IBVERBS_1.0");
#line 749
__asm__(".symver __ibv_ack_cq_events_1_0,ibv_ack_cq_events@IBVERBS_1.0");
#line 776
__asm__(".symver __ibv_create_srq_1_0,ibv_create_srq@IBVERBS_1.0");
#line 784
__asm__(".symver __ibv_modify_srq_1_0,ibv_modify_srq@IBVERBS_1.0");
#line 790
__asm__(".symver __ibv_query_srq_1_0,ibv_query_srq@IBVERBS_1.0");
#line 803
__asm__(".symver __ibv_destroy_srq_1_0,ibv_destroy_srq@IBVERBS_1.0");
#line 847
__asm__(".symver __ibv_create_qp_1_0,ibv_create_qp@IBVERBS_1.0");
#line 870
__asm__(".symver __ibv_query_qp_1_0,ibv_query_qp@IBVERBS_1.0");
#line 877
__asm__(".symver __ibv_modify_qp_1_0,ibv_modify_qp@IBVERBS_1.0");
#line 890
__asm__(".symver __ibv_destroy_qp_1_0,ibv_destroy_qp@IBVERBS_1.0");
#line 914
__asm__(".symver __ibv_create_ah_1_0,ibv_create_ah@IBVERBS_1.0");
#line 927
__asm__(".symver __ibv_destroy_ah_1_0,ibv_destroy_ah@IBVERBS_1.0");
#line 933
__asm__(".symver __ibv_attach_mcast_1_0,ibv_attach_mcast@IBVERBS_1.0");
#line 939
__asm__(".symver __ibv_detach_mcast_1_0,ibv_detach_mcast@IBVERBS_1.0");
#line 267
__asm__(".symver __ibv_get_device_list_1_0,ibv_get_device_list@IBVERBS_1.0");
#line 281
__asm__(".symver __ibv_free_device_list_1_0,ibv_free_device_list@IBVERBS_1.0");
#line 287
__asm__(".symver __ibv_get_device_name_1_0,ibv_get_device_name@IBVERBS_1.0");
#line 293
__asm__(".symver __ibv_get_device_guid_1_0,ibv_get_device_guid@IBVERBS_1.0");
#line 295 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int poll_cq_wrapper_1_0___8(struct ibv_cq_1_0 *cq , int num_entries , struct ibv_wc *wc ) 
{ 
  int tmp ;

  {
  {
#line 298
  tmp = (*(((cq->context)->real_context)->ops.poll_cq))(cq->real_cq, num_entries,
                                                        wc);
  }
#line 298
  return (tmp);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int req_notify_cq_wrapper_1_0___8(struct ibv_cq_1_0 *cq , int sol_only ) 
{ 
  int tmp ;

  {
  {
#line 303
  tmp = (*(((cq->context)->real_context)->ops.req_notify_cq))(cq->real_cq, sol_only);
  }
#line 303
  return (tmp);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_srq_recv_wrapper_1_0___8(struct ibv_srq_1_0 *srq , struct ibv_recv_wr_1_0 *wr ,
                                         struct ibv_recv_wr_1_0 **bad_wr ) 
{ 
  struct ibv_recv_wr_1_0 *w ;
  struct ibv_recv_wr *real_wr ;
  struct ibv_recv_wr *head_wr ;
  struct ibv_recv_wr *tail_wr ;
  struct ibv_recv_wr *real_bad_wr ;
  int ret ;
  void *tmp ;

  {
#line 310
  head_wr = (struct ibv_recv_wr *)((void *)0);
#line 310
  tail_wr = (struct ibv_recv_wr *)((void *)0);
#line 313
  w = wr;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! w) {
#line 313
      goto while_break;
    }
    {
#line 314
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 314
    real_wr = (struct ibv_recv_wr *)tmp;
#line 315
    real_wr->wr_id = w->wr_id;
#line 316
    real_wr->sg_list = w->sg_list;
#line 317
    real_wr->num_sge = w->num_sge;
#line 318
    real_wr->next = (struct ibv_recv_wr *)((void *)0);
    }
#line 319
    if (tail_wr) {
#line 320
      tail_wr->next = real_wr;
    } else {
#line 322
      head_wr = real_wr;
    }
#line 324
    tail_wr = real_wr;
#line 313
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 327
  ret = (*(((srq->context)->real_context)->ops.post_srq_recv))(srq->real_srq, head_wr,
                                                               & real_bad_wr);
  }
#line 330
  if (ret) {
#line 331
    real_wr = head_wr;
#line 331
    w = wr;
    {
#line 331
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 331
      if (! real_wr) {
#line 331
        goto while_break___0;
      }
#line 334
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 335
        *bad_wr = w;
#line 336
        goto while_break___0;
      }
#line 331
      real_wr = real_wr->next;
#line 331
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 340
  return (ret);
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_send_wrapper_1_0___8(struct ibv_qp_1_0 *qp , struct ibv_send_wr_1_0 *wr ,
                                     struct ibv_send_wr_1_0 **bad_wr ) 
{ 
  struct ibv_send_wr_1_0 *w ;
  struct ibv_send_wr *real_wr ;
  struct ibv_send_wr *head_wr ;
  struct ibv_send_wr *tail_wr ;
  struct ibv_send_wr *real_bad_wr ;
  int is_ud ;
  int ret ;
  void *tmp ;

  {
#line 347
  head_wr = (struct ibv_send_wr *)((void *)0);
#line 347
  tail_wr = (struct ibv_send_wr *)((void *)0);
#line 348
  is_ud = (unsigned int )qp->qp_type == 4U;
#line 351
  w = wr;
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! w) {
#line 351
      goto while_break;
    }
    {
#line 352
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 352
    real_wr = (struct ibv_send_wr *)tmp;
#line 353
    real_wr->wr_id = w->wr_id;
#line 354
    real_wr->next = (struct ibv_send_wr *)((void *)0);
    }
#line 363
    if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->sg_list)) {
      {
#line 364
      memcpy((void */* __restrict  */)(& real_wr->sg_list), (void const   */* __restrict  */)(& w->sg_list),
             sizeof(*real_wr) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list));
      }
    } else
#line 366
    if ((unsigned long )(& ((struct ibv_send_wr *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list) == (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->sg_list)) {
#line 366
      if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->wr) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->wr)) {
        {
#line 371
        memcpy((void */* __restrict  */)(& real_wr->sg_list), (void const   */* __restrict  */)(& w->sg_list),
               ((unsigned long )(& ((struct ibv_send_wr *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list)) + sizeof(real_wr->imm_data));
#line 375
        memcpy((void */* __restrict  */)(& real_wr->wr), (void const   */* __restrict  */)(& w->wr),
               sizeof(real_wr->wr));
        }
      } else {
#line 366
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 377
      real_wr->sg_list = w->sg_list;
#line 378
      real_wr->num_sge = w->num_sge;
#line 379
      real_wr->opcode = w->opcode;
#line 380
      real_wr->send_flags = w->send_flags;
#line 381
      real_wr->imm_data = w->imm_data;
#line 382
      if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->wr) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->wr)) {
        {
#line 383
        memcpy((void */* __restrict  */)(& real_wr->wr), (void const   */* __restrict  */)(& w->wr),
               sizeof(real_wr->wr));
        }
      } else {
#line 386
        real_wr->wr.atomic.remote_addr = w->wr.atomic.remote_addr;
#line 388
        real_wr->wr.atomic.compare_add = w->wr.atomic.compare_add;
#line 390
        real_wr->wr.atomic.swap = w->wr.atomic.swap;
#line 392
        real_wr->wr.atomic.rkey = w->wr.atomic.rkey;
      }
    }
#line 397
    if (is_ud) {
#line 398
      real_wr->wr.ud.ah = (w->wr.ud.ah)->real_ah;
    }
#line 400
    if (tail_wr) {
#line 401
      tail_wr->next = real_wr;
    } else {
#line 403
      head_wr = real_wr;
    }
#line 405
    tail_wr = real_wr;
#line 351
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 408
  ret = (*(((qp->context)->real_context)->ops.post_send))(qp->real_qp, head_wr, & real_bad_wr);
  }
#line 411
  if (ret) {
#line 412
    real_wr = head_wr;
#line 412
    w = wr;
    {
#line 412
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 412
      if (! real_wr) {
#line 412
        goto while_break___0;
      }
#line 415
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 416
        *bad_wr = w;
#line 417
        goto while_break___0;
      }
#line 412
      real_wr = real_wr->next;
#line 412
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 421
  return (ret);
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_recv_wrapper_1_0___8(struct ibv_qp_1_0 *qp , struct ibv_recv_wr_1_0 *wr ,
                                     struct ibv_recv_wr_1_0 **bad_wr ) 
{ 
  struct ibv_recv_wr_1_0 *w ;
  struct ibv_recv_wr *real_wr ;
  struct ibv_recv_wr *head_wr ;
  struct ibv_recv_wr *tail_wr ;
  struct ibv_recv_wr *real_bad_wr ;
  int ret ;
  void *tmp ;

  {
#line 428
  head_wr = (struct ibv_recv_wr *)((void *)0);
#line 428
  tail_wr = (struct ibv_recv_wr *)((void *)0);
#line 431
  w = wr;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! w) {
#line 431
      goto while_break;
    }
    {
#line 432
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 432
    real_wr = (struct ibv_recv_wr *)tmp;
#line 433
    real_wr->wr_id = w->wr_id;
#line 434
    real_wr->sg_list = w->sg_list;
#line 435
    real_wr->num_sge = w->num_sge;
#line 436
    real_wr->next = (struct ibv_recv_wr *)((void *)0);
    }
#line 437
    if (tail_wr) {
#line 438
      tail_wr->next = real_wr;
    } else {
#line 440
      head_wr = real_wr;
    }
#line 442
    tail_wr = real_wr;
#line 431
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 445
  ret = (*(((qp->context)->real_context)->ops.post_recv))(qp->real_qp, head_wr, & real_bad_wr);
  }
#line 448
  if (ret) {
#line 449
    real_wr = head_wr;
#line 449
    w = wr;
    {
#line 449
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 449
      if (! real_wr) {
#line 449
        goto while_break___0;
      }
#line 452
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 453
        *bad_wr = w;
#line 454
        goto while_break___0;
      }
#line 449
      real_wr = real_wr->next;
#line 449
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 458
  return (ret);
}
}
#line 487
__asm__(".symver __ibv_open_device_1_0,ibv_open_device@IBVERBS_1.0");
#line 500
__asm__(".symver __ibv_close_device_1_0,ibv_close_device@IBVERBS_1.0");
#line 538
__asm__(".symver __ibv_get_async_event_1_0,ibv_get_async_event@IBVERBS_1.0");
#line 574
__asm__(".symver __ibv_ack_async_event_1_0,ibv_ack_async_event@IBVERBS_1.0");
#line 581
__asm__(".symver __ibv_query_device_1_0,ibv_query_device@IBVERBS_1.0");
#line 588
__asm__(".symver __ibv_query_port_1_0,ibv_query_port@IBVERBS_1.0");
#line 595
__asm__(".symver __ibv_query_gid_1_0,ibv_query_gid@IBVERBS_1.0");
#line 602
__asm__(".symver __ibv_query_pkey_1_0,ibv_query_pkey@IBVERBS_1.0");
#line 624
__asm__(".symver __ibv_alloc_pd_1_0,ibv_alloc_pd@IBVERBS_1.0");
#line 637
__asm__(".symver __ibv_dealloc_pd_1_0,ibv_dealloc_pd@IBVERBS_1.0");
#line 663
__asm__(".symver __ibv_reg_mr_1_0,ibv_reg_mr@IBVERBS_1.0");
#line 676
__asm__(".symver __ibv_dereg_mr_1_0,ibv_dereg_mr@IBVERBS_1.0");
#line 706
__asm__(".symver __ibv_create_cq_1_0,ibv_create_cq@IBVERBS_1.0");
#line 712
__asm__(".symver __ibv_resize_cq_1_0,ibv_resize_cq@IBVERBS_1.0");
#line 725
__asm__(".symver __ibv_destroy_cq_1_0,ibv_destroy_cq@IBVERBS_1.0");
#line 743
__asm__(".symver __ibv_get_cq_event_1_0,ibv_get_cq_event@IBVERBS_1.0");
#line 749
__asm__(".symver __ibv_ack_cq_events_1_0,ibv_ack_cq_events@IBVERBS_1.0");
#line 776
__asm__(".symver __ibv_create_srq_1_0,ibv_create_srq@IBVERBS_1.0");
#line 784
__asm__(".symver __ibv_modify_srq_1_0,ibv_modify_srq@IBVERBS_1.0");
#line 790
__asm__(".symver __ibv_query_srq_1_0,ibv_query_srq@IBVERBS_1.0");
#line 803
__asm__(".symver __ibv_destroy_srq_1_0,ibv_destroy_srq@IBVERBS_1.0");
#line 847
__asm__(".symver __ibv_create_qp_1_0,ibv_create_qp@IBVERBS_1.0");
#line 870
__asm__(".symver __ibv_query_qp_1_0,ibv_query_qp@IBVERBS_1.0");
#line 877
__asm__(".symver __ibv_modify_qp_1_0,ibv_modify_qp@IBVERBS_1.0");
#line 890
__asm__(".symver __ibv_destroy_qp_1_0,ibv_destroy_qp@IBVERBS_1.0");
#line 914
__asm__(".symver __ibv_create_ah_1_0,ibv_create_ah@IBVERBS_1.0");
#line 927
__asm__(".symver __ibv_destroy_ah_1_0,ibv_destroy_ah@IBVERBS_1.0");
#line 933
__asm__(".symver __ibv_attach_mcast_1_0,ibv_attach_mcast@IBVERBS_1.0");
#line 939
__asm__(".symver __ibv_detach_mcast_1_0,ibv_detach_mcast@IBVERBS_1.0");
#line 77 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_sysfs_dev *sysfs_dev_list___6  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver_name *driver_name_list___6  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver *head_driver___6  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_driver *tail_driver___6  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static int find_sysfs_devs___6(void) 
{ 
  char class_path[256] ;
  DIR *class_dir ;
  struct dirent *dent ;
  struct ibv_sysfs_dev *sysfs_dev ;
  char value[8] ;
  int ret ;
  char const   *tmp ;
  struct stat buf ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;

  {
  {
#line 86
  sysfs_dev = (struct ibv_sysfs_dev *)((void *)0);
#line 88
  ret = 0;
#line 90
  tmp = ibv_get_sysfs_path();
#line 90
  snprintf((char */* __restrict  */)(class_path), sizeof(class_path), (char const   */* __restrict  */)"%s/class/infiniband_verbs",
           tmp);
#line 93
  class_dir = opendir((char const   *)(class_path));
  }
#line 94
  if (! class_dir) {
#line 95
    return (38);
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    dent = readdir(class_dir);
    }
#line 97
    if (! dent) {
#line 97
      goto while_break;
    }
#line 100
    if ((int )dent->d_name[0] == 46) {
#line 101
      goto while_continue;
    }
#line 103
    if (! sysfs_dev) {
      {
#line 104
      tmp___0 = malloc(sizeof(*sysfs_dev));
#line 104
      sysfs_dev = (struct ibv_sysfs_dev *)tmp___0;
      }
    }
#line 105
    if (! sysfs_dev) {
#line 106
      ret = 12;
#line 107
      goto out;
    }
    {
#line 110
    snprintf((char */* __restrict  */)(sysfs_dev->sysfs_path), sizeof(sysfs_dev->sysfs_path),
             (char const   */* __restrict  */)"%s/%s", class_path, dent->d_name);
#line 113
    tmp___1 = stat((char const   */* __restrict  */)(sysfs_dev->sysfs_path), (struct stat */* __restrict  */)(& buf));
    }
#line 113
    if (tmp___1) {
      {
#line 114
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t stat \'%s\'.\n",
              sysfs_dev->sysfs_path);
      }
#line 116
      goto while_continue;
    }
#line 119
    if (! ((buf.st_mode & 61440U) == 16384U)) {
#line 120
      goto while_continue;
    }
    {
#line 122
    snprintf((char */* __restrict  */)(sysfs_dev->sysfs_name), sizeof(sysfs_dev->sysfs_name),
             (char const   */* __restrict  */)"%s", dent->d_name);
#line 125
    tmp___2 = ibv_read_sysfs_file((char const   *)(sysfs_dev->sysfs_path), "ibdev",
                                  sysfs_dev->ibdev_name, sizeof(sysfs_dev->ibdev_name));
    }
#line 125
    if (tmp___2 < 0) {
      {
#line 128
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: no ibdev class attr for \'%s\'.\n",
              dent->d_name);
      }
#line 130
      goto while_continue;
    }
    {
#line 133
    tmp___3 = ibv_get_sysfs_path();
#line 133
    snprintf((char */* __restrict  */)(sysfs_dev->ibdev_path), sizeof(sysfs_dev->ibdev_path),
             (char const   */* __restrict  */)"%s/class/infiniband/%s", tmp___3, sysfs_dev->ibdev_name);
#line 137
    sysfs_dev->next = sysfs_dev_list___6;
#line 138
    sysfs_dev->have_driver = 0;
#line 139
    tmp___5 = ibv_read_sysfs_file((char const   *)(sysfs_dev->sysfs_path), "abi_version",
                                  value, sizeof(value));
    }
#line 139
    if (tmp___5 > 0) {
      {
#line 141
      tmp___4 = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                       10);
#line 141
      sysfs_dev->abi_ver = (int )tmp___4;
      }
    } else {
#line 143
      sysfs_dev->abi_ver = 0;
    }
#line 145
    sysfs_dev_list___6 = sysfs_dev;
#line 146
    sysfs_dev = (struct ibv_sysfs_dev *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
  out: 
#line 150
  if (sysfs_dev) {
    {
#line 151
    free((void *)sysfs_dev);
    }
  }
  {
#line 153
  closedir(class_dir);
  }
#line 154
  return (ret);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void register_driver___6(char const   *name , struct ibv_device *(*init_func)(char const   *uverbs_sys_path ,
                                                                                     int abi_version ) ,
                                struct verbs_device *(*verbs_init_func)(char const   *uverbs_sys_path ,
                                                                        int abi_version ) ) 
{ 
  struct ibv_driver *driver ;
  void *tmp ;

  {
  {
#line 162
  tmp = malloc(sizeof(*driver));
#line 162
  driver = (struct ibv_driver *)tmp;
  }
#line 163
  if (! driver) {
    {
#line 164
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver for %s\n",
            name);
    }
#line 165
    return;
  }
#line 168
  driver->name = name;
#line 169
  driver->init_func = init_func;
#line 170
  driver->verbs_init_func = verbs_init_func;
#line 171
  driver->next = (struct ibv_driver *)((void *)0);
#line 173
  if (tail_driver___6) {
#line 174
    tail_driver___6->next = driver;
  } else {
#line 176
    head_driver___6 = driver;
  }
#line 177
  tail_driver___6 = driver;
#line 178
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void load_driver___6(char const   *name ) 
{ 
  char *so_name ;
  void *dlhandle ;
  char const   *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 201
  if ((int const   )*(name + 0) == 47) {
#line 201
    tmp = "%s-rdmav2.so";
  } else {
#line 201
    tmp = "lib%s-rdmav2.so";
  }
  {
#line 201
  tmp___0 = asprintf((char **/* __restrict  */)(& so_name), (char const   */* __restrict  */)tmp,
                     name);
  }
#line 201
  if (tmp___0 < 0) {
    {
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t load driver \'%s\'.\n",
            name);
    }
#line 208
    return;
  }
  {
#line 211
  dlhandle = dlopen((char const   *)so_name, 2);
  }
#line 212
  if (! dlhandle) {
    {
#line 213
    tmp___1 = dlerror();
#line 213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t load driver \'%s\': %s\n",
            name, tmp___1);
    }
#line 215
    goto out;
  }
  out: 
  {
#line 219
  free((void *)so_name);
  }
#line 220
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void load_drivers___6(void) 
{ 
  struct ibv_driver_name *name ;
  struct ibv_driver_name *next_name ;
  char const   *env ;
  char *list ;
  char *env_name ;
  char const   *__old ;
  size_t __len ;
  size_t tmp ;
  char *__new ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *__old___0 ;
  size_t __len___0 ;
  size_t tmp___2 ;
  char *__new___0 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;

  {
  {
#line 232
  tmp___7 = getuid();
#line 232
  tmp___8 = geteuid();
  }
#line 232
  if (tmp___7 == tmp___8) {
    {
#line 233
    tmp___6 = getenv("RDMAV_DRIVERS");
#line 233
    env = (char const   *)tmp___6;
    }
#line 233
    if (env) {
      {
#line 234
      __old = env;
#line 234
      tmp = strlen(__old);
#line 234
      __len = tmp + 1UL;
#line 234
      tmp___0 = __builtin_alloca(__len);
#line 234
      __new = (char *)tmp___0;
#line 234
      tmp___1 = memcpy((void */* __restrict  */)__new, (void const   */* __restrict  */)__old,
                       __len);
#line 234
      list = (char *)tmp___1;
      }
      {
#line 235
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 235
        env_name = strsep((char **/* __restrict  */)(& list), (char const   */* __restrict  */)":;");
        }
#line 235
        if (! env_name) {
#line 235
          goto while_break;
        }
        {
#line 236
        load_driver___6((char const   *)env_name);
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 237
      tmp___5 = getenv("IBV_DRIVERS");
#line 237
      env = (char const   *)tmp___5;
      }
#line 237
      if (env) {
        {
#line 238
        __old___0 = env;
#line 238
        tmp___2 = strlen(__old___0);
#line 238
        __len___0 = tmp___2 + 1UL;
#line 238
        tmp___3 = __builtin_alloca(__len___0);
#line 238
        __new___0 = (char *)tmp___3;
#line 238
        tmp___4 = memcpy((void */* __restrict  */)__new___0, (void const   */* __restrict  */)__old___0,
                         __len___0);
#line 238
        list = (char *)tmp___4;
        }
        {
#line 239
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 239
          env_name = strsep((char **/* __restrict  */)(& list), (char const   */* __restrict  */)":;");
          }
#line 239
          if (! env_name) {
#line 239
            goto while_break___0;
          }
          {
#line 240
          load_driver___6((char const   *)env_name);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 244
  name = driver_name_list___6;
#line 244
  if (name) {
#line 244
    next_name = name->next;
  } else {
#line 244
    next_name = (struct ibv_driver_name *)((void *)0);
  }
  {
#line 244
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 244
    if (! name) {
#line 244
      goto while_break___1;
    }
    {
#line 247
    load_driver___6((char const   *)name->name);
#line 248
    free((void *)name->name);
#line 249
    free((void *)name);
#line 244
    name = next_name;
    }
#line 244
    if (name) {
#line 244
      next_name = name->next;
    } else {
#line 244
      next_name = (struct ibv_driver_name *)((void *)0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 251
  return;
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void read_config_file___6(char const   *path ) 
{ 
  FILE *conf ;
  char *line ;
  char *config ;
  char *field ;
  size_t buflen ;
  ssize_t len ;
  size_t tmp ;
  struct ibv_driver_name *driver_name ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 256
  line = (char *)((void *)0);
#line 259
  buflen = (size_t )0;
#line 262
  conf = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"re");
  }
#line 263
  if (! conf) {
    {
#line 264
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t read config file %s.\n",
            path);
    }
#line 266
    return;
  }
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 269
    len = getline((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& buflen),
                  (FILE */* __restrict  */)conf);
    }
#line 269
    if (! (len != -1L)) {
#line 269
      goto while_break;
    }
    {
#line 270
    tmp = strspn((char const   *)line, "\t ");
#line 270
    config = line + tmp;
    }
#line 271
    if ((int )*(config + 0) == 10) {
#line 272
      goto while_continue;
    } else
#line 271
    if ((int )*(config + 0) == 35) {
#line 272
      goto while_continue;
    }
    {
#line 274
    field = strsep((char **/* __restrict  */)(& config), (char const   */* __restrict  */)"\n\t ");
#line 276
    tmp___2 = strcmp((char const   *)field, "driver");
    }
#line 276
    if (tmp___2 == 0) {
#line 276
      if ((unsigned long )config != (unsigned long )((void *)0)) {
        {
#line 279
        tmp___0 = strspn((char const   *)config, "\t ");
#line 279
        config += tmp___0;
#line 280
        field = strsep((char **/* __restrict  */)(& config), (char const   */* __restrict  */)"\n\t ");
#line 282
        tmp___1 = malloc(sizeof(*driver_name));
#line 282
        driver_name = (struct ibv_driver_name *)tmp___1;
        }
#line 283
        if (! driver_name) {
          {
#line 284
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver name \'%s\'.\n",
                  field);
          }
#line 286
          goto while_continue;
        }
        {
#line 289
        driver_name->name = strdup((char const   *)field);
        }
#line 290
        if (! driver_name->name) {
          {
#line 291
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t allocate driver name \'%s\'.\n",
                  field);
#line 293
          free((void *)driver_name);
          }
#line 294
          goto while_continue;
        }
#line 297
        driver_name->next = driver_name_list___6;
#line 298
        driver_name_list___6 = driver_name;
      } else {
        {
#line 300
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: ignoring bad config directive \'%s\' in file \'%s\'.\n",
                field, path);
        }
      }
    } else {
      {
#line 300
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: ignoring bad config directive \'%s\' in file \'%s\'.\n",
              field, path);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  if (line) {
    {
#line 305
    free((void *)line);
    }
  }
  {
#line 306
  fclose(conf);
  }
#line 307
  return;
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void read_config___6(void) 
{ 
  DIR *conf_dir ;
  struct dirent *dent ;
  char *path ;
  struct stat buf ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 315
  conf_dir = opendir("/usr/local/etc/libibverbs.d");
  }
#line 316
  if (! conf_dir) {
    {
#line 317
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t open config directory \'%s\'.\n",
            "/usr/local/etc/libibverbs.d");
    }
#line 319
    return;
  }
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 322
    dent = readdir(conf_dir);
    }
#line 322
    if (! dent) {
#line 322
      goto while_break;
    }
    {
#line 325
    tmp = asprintf((char **/* __restrict  */)(& path), (char const   */* __restrict  */)"%s/%s",
                   "/usr/local/etc/libibverbs.d", dent->d_name);
    }
#line 325
    if (tmp < 0) {
      {
#line 326
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t read config file %s/%s.\n",
              "/usr/local/etc/libibverbs.d", dent->d_name);
      }
#line 328
      goto out;
    }
    {
#line 331
    tmp___0 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& buf));
    }
#line 331
    if (tmp___0) {
      {
#line 332
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: couldn\'t stat config file \'%s\'.\n",
              path);
      }
#line 334
      goto next;
    }
#line 337
    if (! ((buf.st_mode & 61440U) == 32768U)) {
#line 338
      goto next;
    }
    {
#line 340
    read_config_file___6((char const   *)path);
    }
    next: 
    {
#line 342
    free((void *)path);
    }
  }
  while_break: /* CIL Label */ ;
  }
  out: 
  {
#line 346
  closedir(conf_dir);
  }
#line 347
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_device *try_driver___6(struct ibv_driver *driver , struct ibv_sysfs_dev *sysfs_dev ) 
{ 
  struct verbs_device *vdev ;
  struct ibv_device *dev ;
  char value[8] ;
  long tmp ;
  int tmp___0 ;

  {
#line 356
  if (driver->init_func) {
    {
#line 357
    dev = (*(driver->init_func))((char const   *)(sysfs_dev->sysfs_path), sysfs_dev->abi_ver);
    }
#line 358
    if (! dev) {
#line 359
      return ((struct ibv_device *)((void *)0));
    }
  } else {
    {
#line 361
    vdev = (*(driver->verbs_init_func))((char const   *)(sysfs_dev->sysfs_path), sysfs_dev->abi_ver);
    }
#line 362
    if (! vdev) {
#line 363
      return ((struct ibv_device *)((void *)0));
    }
#line 365
    dev = & vdev->device;
#line 366
    dev->ops.alloc_context = (struct ibv_context *(*)(struct ibv_device *device ,
                                                      int cmd_fd ))((void *)0);
#line 367
    dev->ops.free_context = (void (*)(struct ibv_context *context ))((void *)0);
  }
  {
#line 370
  tmp___0 = ibv_read_sysfs_file((char const   *)(sysfs_dev->ibdev_path), "node_type",
                                value, sizeof(value));
  }
#line 370
  if (tmp___0 < 0) {
    {
#line 371
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: no node_type attr under %s.\n",
            sysfs_dev->ibdev_path);
#line 373
    dev->node_type = (enum ibv_node_type )-1;
    }
  } else {
    {
#line 375
    tmp = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                 10);
#line 375
    dev->node_type = (enum ibv_node_type )tmp;
    }
#line 376
    if ((int )dev->node_type < 1) {
#line 377
      dev->node_type = (enum ibv_node_type )-1;
    } else
#line 376
    if ((int )dev->node_type > 4) {
#line 377
      dev->node_type = (enum ibv_node_type )-1;
    }
  }
  {
#line 383
  if ((int )dev->node_type == 3) {
#line 383
    goto case_3;
  }
#line 383
  if ((int )dev->node_type == 2) {
#line 383
    goto case_3;
  }
#line 383
  if ((int )dev->node_type == 1) {
#line 383
    goto case_3;
  }
#line 386
  if ((int )dev->node_type == 4) {
#line 386
    goto case_4;
  }
#line 389
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 384
  dev->transport_type = (enum ibv_transport_type )0;
#line 385
  goto switch_break;
  case_4: /* CIL Label */ 
#line 387
  dev->transport_type = (enum ibv_transport_type )1;
#line 388
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 390
  dev->transport_type = (enum ibv_transport_type )-1;
#line 391
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 394
  strcpy((char */* __restrict  */)(dev->dev_name), (char const   */* __restrict  */)(sysfs_dev->sysfs_name));
#line 395
  strcpy((char */* __restrict  */)(dev->dev_path), (char const   */* __restrict  */)(sysfs_dev->sysfs_path));
#line 396
  strcpy((char */* __restrict  */)(dev->name), (char const   */* __restrict  */)(sysfs_dev->ibdev_name));
#line 397
  strcpy((char */* __restrict  */)(dev->ibdev_path), (char const   */* __restrict  */)(sysfs_dev->ibdev_path));
  }
#line 399
  return (dev);
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static struct ibv_device *try_drivers___6(struct ibv_sysfs_dev *sysfs_dev ) 
{ 
  struct ibv_driver *driver ;
  struct ibv_device *dev ;

  {
#line 407
  driver = head_driver___6;
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 407
    if (! driver) {
#line 407
      goto while_break;
    }
    {
#line 408
    dev = try_driver___6(driver, sysfs_dev);
    }
#line 409
    if (dev) {
#line 410
      return (dev);
    }
#line 407
    driver = driver->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 413
  return ((struct ibv_device *)((void *)0));
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static int check_abi_version___6(char const   *path ) 
{ 
  char value[8] ;
  int tmp ;
  long tmp___0 ;

  {
  {
#line 420
  tmp = ibv_read_sysfs_file(path, "class/infiniband_verbs/abi_version", value, sizeof(value));
  }
#line 420
  if (tmp < 0) {
#line 422
    return (38);
  }
  {
#line 425
  tmp___0 = strtol((char const   */* __restrict  */)(value), (char **/* __restrict  */)((void *)0),
                   10);
#line 425
  abi_ver = (int __attribute__((__visibility__("hidden")))  )tmp___0;
  }
#line 427
  if (abi_ver < (int __attribute__((__visibility__("hidden")))  )3) {
    {
#line 429
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Fatal: kernel ABI version %d doesn\'t match library version %d.\n",
            abi_ver, 6);
    }
#line 432
    return (38);
  } else
#line 427
  if (abi_ver > (int __attribute__((__visibility__("hidden")))  )6) {
    {
#line 429
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Fatal: kernel ABI version %d doesn\'t match library version %d.\n",
            abi_ver, 6);
    }
#line 432
    return (38);
  }
#line 435
  return (0);
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void check_memlock_limit___6(void) 
{ 
  struct rlimit rlim ;
  __uid_t tmp ;
  int tmp___0 ;

  {
  {
#line 442
  tmp = geteuid();
  }
#line 442
  if (! tmp) {
#line 443
    return;
  }
  {
#line 445
  tmp___0 = getrlimit((__rlimit_resource_t )8, & rlim);
  }
#line 445
  if (tmp___0) {
    {
#line 446
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: getrlimit(RLIMIT_MEMLOCK) failed.");
    }
#line 447
    return;
  }
#line 450
  if (rlim.rlim_cur <= 32768UL) {
    {
#line 451
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: RLIMIT_MEMLOCK is %lu bytes.\n    This will severely limit memory registrations.\n",
            rlim.rlim_cur);
    }
  }
#line 454
  return;
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/init.c"
static void add_device___6(struct ibv_device *dev , struct ibv_device ***dev_list ,
                           int *num_devices___7 , int *list_size ) 
{ 
  struct ibv_device **new_list ;
  void *tmp ;
  int tmp___0 ;

  {
#line 463
  if (*list_size <= *num_devices___7) {
#line 464
    if (*list_size) {
#line 464
      *list_size *= 2;
    } else {
#line 464
      *list_size = 1;
    }
    {
#line 465
    tmp = realloc((void *)*dev_list, (unsigned long )*list_size * sizeof(struct ibv_device *));
#line 465
    new_list = (struct ibv_device **)tmp;
    }
#line 466
    if (! new_list) {
#line 467
      return;
    }
#line 468
    *dev_list = new_list;
  }
#line 471
  tmp___0 = *num_devices___7;
#line 471
  (*num_devices___7) ++;
#line 471
  *(*dev_list + tmp___0) = dev;
#line 472
  return;
}
}
#line 82 "./include/infiniband/verbs.h"
static void *__VERBS_ABI_IS_EXTENDED___6  =    (void *)((uint8_t *)((void *)0) - 1);
#line 877 "./include/infiniband/verbs.h"
__inline static struct verbs_context *verbs_get_ctx___6(struct ibv_context *ctx ) 
{ 
  struct verbs_context *tmp ;

  {
#line 879
  if ((unsigned long )ctx->abi_compat != (unsigned long )__VERBS_ABI_IS_EXTENDED___6) {
#line 879
    tmp = (struct verbs_context *)((void *)0);
  } else {
#line 879
    tmp = (struct verbs_context *)((uint8_t *)ctx - (unsigned long )(& ((struct verbs_context *)0)->context));
  }
#line 879
  return (tmp);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static pthread_once_t device_list_once___6  =    0;
#line 53 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static int num_devices___6  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static struct ibv_device **device_list___6  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/device.c"
static void count_devices___6(void) 
{ 
  int __attribute__((__visibility__("hidden")))  tmp ;

  {
  {
#line 58
  tmp = ibverbs_init(& device_list___6);
#line 58
  num_devices___6 = (int )tmp;
  }
#line 59
  return;
}
}
#line 89
__asm__(".symver __ibv_get_device_list,ibv_get_device_list@@IBVERBS_1.1");
#line 95
__asm__(".symver __ibv_free_device_list,ibv_free_device_list@@IBVERBS_1.1");
#line 101
__asm__(".symver __ibv_get_device_name,ibv_get_device_name@@IBVERBS_1.1");
#line 123
__asm__(".symver __ibv_get_device_guid,ibv_get_device_guid@@IBVERBS_1.1");
#line 190
__asm__(".symver __ibv_open_device,ibv_open_device@@IBVERBS_1.1");
#line 215
__asm__(".symver __ibv_close_device,ibv_close_device@@IBVERBS_1.1");
#line 258
__asm__(".symver __ibv_get_async_event,ibv_get_async_event@@IBVERBS_1.1");
#line 311
__asm__(".symver __ibv_ack_async_event,ibv_ack_async_event@@IBVERBS_1.1");
#line 37 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  node_type_str___6[5]  = {      (char const   */* const  */)0,      (char const   */* const  */)"InfiniBand channel adapter",      (char const   */* const  */)"InfiniBand switch",      (char const   */* const  */)"InfiniBand router", 
        (char const   */* const  */)"iWARP NIC"};
#line 52 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  port_state_str___7[6]  = {      (char const   */* const  */)"no state change (NOP)",      (char const   */* const  */)"down",      (char const   */* const  */)"init",      (char const   */* const  */)"armed", 
        (char const   */* const  */)"active",      (char const   */* const  */)"active defer"};
#line 69 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  event_type_str___6[19]  = 
#line 69
  {      (char const   */* const  */)"CQ error",      (char const   */* const  */)"local work queue catastrophic error",      (char const   */* const  */)"invalid request local work queue error",      (char const   */* const  */)"local access violation work queue error", 
        (char const   */* const  */)"communication established",      (char const   */* const  */)"send queue drained",      (char const   */* const  */)"path migrated",      (char const   */* const  */)"path migration request error", 
        (char const   */* const  */)"local catastrophic error",      (char const   */* const  */)"port active",      (char const   */* const  */)"port error",      (char const   */* const  */)"LID change", 
        (char const   */* const  */)"P_Key change",      (char const   */* const  */)"SM change",      (char const   */* const  */)"SRQ catastrophic error",      (char const   */* const  */)"SRQ limit reached", 
        (char const   */* const  */)"last WQE reached",      (char const   */* const  */)"client reregistration",      (char const   */* const  */)"GID table change"};
#line 99 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/enum_strs.c"
static char const   * const  wc_status_str___6[22]  = 
#line 99
  {      (char const   */* const  */)"success",      (char const   */* const  */)"local length error",      (char const   */* const  */)"local QP operation error",      (char const   */* const  */)"local EE context operation error", 
        (char const   */* const  */)"local protection error",      (char const   */* const  */)"Work Request Flushed Error",      (char const   */* const  */)"memory management operation error",      (char const   */* const  */)"bad response error", 
        (char const   */* const  */)"local access error",      (char const   */* const  */)"remote invalid request error",      (char const   */* const  */)"remote access error",      (char const   */* const  */)"remote operation error", 
        (char const   */* const  */)"transport retry counter exceeded",      (char const   */* const  */)"RNR retry counter exceeded",      (char const   */* const  */)"local RDD violation error",      (char const   */* const  */)"remote invalid RD request", 
        (char const   */* const  */)"aborted error",      (char const   */* const  */)"invalid EE context number",      (char const   */* const  */)"invalid EE context state",      (char const   */* const  */)"fatal error", 
        (char const   */* const  */)"response timeout error",      (char const   */* const  */)"general error"};
#line 73 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *mm_root___6  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static pthread_mutex_t mm_mutex___6  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 75 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int page_size___10  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int huge_page_enabled___6  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int too_late___6  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static unsigned long smaps_page_size___6(FILE *file ) 
{ 
  int n ;
  unsigned long size ;
  char buf[1024] ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 82
  size = (unsigned long )page_size___10;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 85
    tmp___0 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)file);
    }
#line 85
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 85
      goto while_break;
    }
    {
#line 86
    tmp = strstr((char const   *)(buf), "KernelPageSize:");
    }
#line 86
    if (! tmp) {
#line 87
      goto while_continue;
    }
    {
#line 89
    n = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*s %lu",
               & size);
    }
#line 90
    if (n < 1) {
#line 91
      goto while_continue;
    }
#line 94
    size *= 1024UL;
#line 96
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return (size);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static unsigned long get_page_size___6(void *base ) 
{ 
  unsigned long ret ;
  pid_t pid ;
  FILE *file ;
  char buf[1024] ;
  int n ;
  uintptr_t range_start ;
  uintptr_t range_end ;
  char *tmp ;

  {
  {
#line 104
  ret = (unsigned long )page_size___10;
#line 109
  pid = getpid();
#line 110
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"/proc/%d/smaps",
           pid);
#line 112
  file = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"re");
  }
#line 113
  if (! file) {
#line 114
    goto out;
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 116
    tmp = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)file);
    }
#line 116
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 116
      goto while_break;
    }
    {
#line 120
    n = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%lx-%lx",
               & range_start, & range_end);
    }
#line 122
    if (n < 2) {
#line 123
      goto while_continue;
    }
#line 125
    if ((uintptr_t )base >= range_start) {
#line 125
      if ((uintptr_t )base < range_end) {
        {
#line 126
        ret = smaps_page_size___6(file);
        }
#line 127
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  fclose(file);
  }
  out: 
#line 134
  return (ret);
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_prev___6(struct ibv_mem_node *node ) 
{ 


  {
#line 194
  if (node->left) {
#line 195
    node = node->left;
    {
#line 196
    while (1) {
      while_continue: /* CIL Label */ ;
#line 196
      if (! node->right) {
#line 196
        goto while_break;
      }
#line 197
      node = node->right;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 199
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 199
      if (node->parent) {
#line 199
        if (! ((unsigned long )node == (unsigned long )(node->parent)->left)) {
#line 199
          goto while_break___0;
        }
      } else {
#line 199
        goto while_break___0;
      }
#line 200
      node = node->parent;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 202
    node = node->parent;
  }
#line 205
  return (node);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_next___6(struct ibv_mem_node *node ) 
{ 


  {
#line 210
  if (node->right) {
#line 211
    node = node->right;
    {
#line 212
    while (1) {
      while_continue: /* CIL Label */ ;
#line 212
      if (! node->left) {
#line 212
        goto while_break;
      }
#line 213
      node = node->left;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 215
      if (node->parent) {
#line 215
        if (! ((unsigned long )node == (unsigned long )(node->parent)->right)) {
#line 215
          goto while_break___0;
        }
      } else {
#line 215
        goto while_break___0;
      }
#line 216
      node = node->parent;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 218
    node = node->parent;
  }
#line 221
  return (node);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_rotate_right___6(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 228
  tmp = node->left;
#line 230
  node->left = tmp->right;
#line 231
  if (node->left) {
#line 232
    (node->left)->parent = node;
  }
#line 234
  if (node->parent) {
#line 235
    if ((unsigned long )(node->parent)->right == (unsigned long )node) {
#line 236
      (node->parent)->right = tmp;
    } else {
#line 238
      (node->parent)->left = tmp;
    }
  } else {
#line 240
    mm_root___6 = tmp;
  }
#line 242
  tmp->parent = node->parent;
#line 244
  tmp->right = node;
#line 245
  node->parent = tmp;
#line 246
  return;
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_rotate_left___6(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 252
  tmp = node->right;
#line 254
  node->right = tmp->left;
#line 255
  if (node->right) {
#line 256
    (node->right)->parent = node;
  }
#line 258
  if (node->parent) {
#line 259
    if ((unsigned long )(node->parent)->right == (unsigned long )node) {
#line 260
      (node->parent)->right = tmp;
    } else {
#line 262
      (node->parent)->left = tmp;
    }
  } else {
#line 264
    mm_root___6 = tmp;
  }
#line 266
  tmp->parent = node->parent;
#line 268
  tmp->left = node;
#line 269
  node->parent = tmp;
#line 270
  return;
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_add_rebalance___6(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *parent ;
  struct ibv_mem_node *gp ;
  struct ibv_mem_node *uncle ;

  {
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (node->parent) {
#line 304
      if (! ((unsigned int )(node->parent)->color == 0U)) {
#line 304
        goto while_break;
      }
    } else {
#line 304
      goto while_break;
    }
#line 305
    parent = node->parent;
#line 306
    gp = (node->parent)->parent;
#line 308
    if ((unsigned long )parent == (unsigned long )gp->left) {
#line 309
      uncle = gp->right;
#line 311
      if (uncle) {
#line 311
        if ((unsigned int )uncle->color == 0U) {
#line 312
          parent->color = (enum __anonenum_color_68 )1;
#line 313
          uncle->color = (enum __anonenum_color_68 )1;
#line 314
          gp->color = (enum __anonenum_color_68 )0;
#line 316
          node = gp;
        } else {
#line 311
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 318
        if ((unsigned long )node == (unsigned long )parent->right) {
          {
#line 319
          __mm_rotate_left___6(parent);
#line 320
          node = parent;
#line 321
          parent = node->parent;
          }
        }
        {
#line 324
        parent->color = (enum __anonenum_color_68 )1;
#line 325
        gp->color = (enum __anonenum_color_68 )0;
#line 327
        __mm_rotate_right___6(gp);
        }
      }
    } else {
#line 330
      uncle = gp->left;
#line 332
      if (uncle) {
#line 332
        if ((unsigned int )uncle->color == 0U) {
#line 333
          parent->color = (enum __anonenum_color_68 )1;
#line 334
          uncle->color = (enum __anonenum_color_68 )1;
#line 335
          gp->color = (enum __anonenum_color_68 )0;
#line 337
          node = gp;
        } else {
#line 332
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 339
        if ((unsigned long )node == (unsigned long )parent->left) {
          {
#line 340
          __mm_rotate_right___6(parent);
#line 341
          node = parent;
#line 342
          parent = node->parent;
          }
        }
        {
#line 345
        parent->color = (enum __anonenum_color_68 )1;
#line 346
        gp->color = (enum __anonenum_color_68 )0;
#line 348
        __mm_rotate_left___6(gp);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  mm_root___6->color = (enum __anonenum_color_68 )1;
#line 354
  return;
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_add___6(struct ibv_mem_node *new ) 
{ 
  struct ibv_mem_node *node ;
  struct ibv_mem_node *parent ;

  {
#line 358
  parent = (struct ibv_mem_node *)((void *)0);
#line 360
  node = mm_root___6;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! node) {
#line 361
      goto while_break;
    }
#line 362
    parent = node;
#line 363
    if (node->start < new->start) {
#line 364
      node = node->right;
    } else {
#line 366
      node = node->left;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  if (parent->start < new->start) {
#line 370
    parent->right = new;
  } else {
#line 372
    parent->left = new;
  }
  {
#line 374
  new->parent = parent;
#line 375
  new->left = (struct ibv_mem_node *)((void *)0);
#line 376
  new->right = (struct ibv_mem_node *)((void *)0);
#line 378
  new->color = (enum __anonenum_color_68 )0;
#line 379
  __mm_add_rebalance___6(new);
  }
#line 380
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static void __mm_remove___6(struct ibv_mem_node *node ) 
{ 
  struct ibv_mem_node *child ;
  struct ibv_mem_node *parent ;
  struct ibv_mem_node *sib ;
  struct ibv_mem_node *tmp ;
  int nodecol ;

  {
#line 387
  if (node->left) {
#line 387
    if (node->right) {
#line 388
      tmp = node->left;
      {
#line 389
      while (1) {
        while_continue: /* CIL Label */ ;
#line 389
        if (! tmp->right) {
#line 389
          goto while_break;
        }
#line 390
        tmp = tmp->right;
      }
      while_break: /* CIL Label */ ;
      }
#line 392
      nodecol = (int )tmp->color;
#line 393
      child = tmp->left;
#line 394
      tmp->color = node->color;
#line 396
      if ((unsigned long )tmp->parent != (unsigned long )node) {
#line 397
        parent = tmp->parent;
#line 398
        parent->right = tmp->left;
#line 399
        if (tmp->left) {
#line 400
          (tmp->left)->parent = parent;
        }
#line 402
        tmp->left = node->left;
#line 403
        (node->left)->parent = tmp;
      } else {
#line 405
        parent = tmp;
      }
#line 407
      tmp->right = node->right;
#line 408
      (node->right)->parent = tmp;
#line 410
      tmp->parent = node->parent;
#line 411
      if (node->parent) {
#line 412
        if ((unsigned long )(node->parent)->left == (unsigned long )node) {
#line 413
          (node->parent)->left = tmp;
        } else {
#line 415
          (node->parent)->right = tmp;
        }
      } else {
#line 417
        mm_root___6 = tmp;
      }
    } else {
#line 387
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 419
    nodecol = (int )node->color;
#line 421
    if (node->left) {
#line 421
      child = node->left;
    } else {
#line 421
      child = node->right;
    }
#line 422
    parent = node->parent;
#line 424
    if (child) {
#line 425
      child->parent = parent;
    }
#line 426
    if (parent) {
#line 427
      if ((unsigned long )parent->left == (unsigned long )node) {
#line 428
        parent->left = child;
      } else {
#line 430
        parent->right = child;
      }
    } else {
#line 432
      mm_root___6 = child;
    }
  }
  {
#line 435
  free((void *)node);
  }
#line 437
  if (nodecol == 0) {
#line 438
    return;
  }
  {
#line 440
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 440
    if (! child) {
#line 440
      goto _L___6;
    } else
#line 440
    if ((unsigned int )child->color == 1U) {
      _L___6: /* CIL Label */ 
#line 440
      if (! ((unsigned long )child != (unsigned long )mm_root___6)) {
#line 440
        goto while_break___0;
      }
    } else {
#line 440
      goto while_break___0;
    }
#line 441
    if ((unsigned long )parent->left == (unsigned long )child) {
#line 442
      sib = parent->right;
#line 444
      if ((unsigned int )sib->color == 0U) {
        {
#line 445
        parent->color = (enum __anonenum_color_68 )0;
#line 446
        sib->color = (enum __anonenum_color_68 )1;
#line 447
        __mm_rotate_left___6(parent);
#line 448
        sib = parent->right;
        }
      }
#line 451
      if (! sib->left) {
#line 451
        goto _L___2;
      } else
#line 451
      if ((unsigned int )(sib->left)->color == 1U) {
        _L___2: /* CIL Label */ 
#line 451
        if (! sib->right) {
#line 453
          sib->color = (enum __anonenum_color_68 )0;
#line 454
          child = parent;
#line 455
          parent = child->parent;
        } else
#line 451
        if ((unsigned int )(sib->right)->color == 1U) {
#line 453
          sib->color = (enum __anonenum_color_68 )0;
#line 454
          child = parent;
#line 455
          parent = child->parent;
        } else {
#line 451
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 457
        if (! sib->right) {
#line 457
          goto _L___0;
        } else
#line 457
        if ((unsigned int )(sib->right)->color == 1U) {
          _L___0: /* CIL Label */ 
#line 458
          if (sib->left) {
#line 459
            (sib->left)->color = (enum __anonenum_color_68 )1;
          }
          {
#line 460
          sib->color = (enum __anonenum_color_68 )0;
#line 461
          __mm_rotate_right___6(sib);
#line 462
          sib = parent->right;
          }
        }
#line 465
        sib->color = parent->color;
#line 466
        parent->color = (enum __anonenum_color_68 )1;
#line 467
        if (sib->right) {
#line 468
          (sib->right)->color = (enum __anonenum_color_68 )1;
        }
        {
#line 469
        __mm_rotate_left___6(parent);
#line 470
        child = mm_root___6;
        }
#line 471
        goto while_break___0;
      }
    } else {
#line 474
      sib = parent->left;
#line 476
      if ((unsigned int )sib->color == 0U) {
        {
#line 477
        parent->color = (enum __anonenum_color_68 )0;
#line 478
        sib->color = (enum __anonenum_color_68 )1;
#line 479
        __mm_rotate_right___6(parent);
#line 480
        sib = parent->left;
        }
      }
#line 483
      if (! sib->left) {
#line 483
        goto _L___5;
      } else
#line 483
      if ((unsigned int )(sib->left)->color == 1U) {
        _L___5: /* CIL Label */ 
#line 483
        if (! sib->right) {
#line 485
          sib->color = (enum __anonenum_color_68 )0;
#line 486
          child = parent;
#line 487
          parent = child->parent;
        } else
#line 483
        if ((unsigned int )(sib->right)->color == 1U) {
#line 485
          sib->color = (enum __anonenum_color_68 )0;
#line 486
          child = parent;
#line 487
          parent = child->parent;
        } else {
#line 483
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
#line 489
        if (! sib->left) {
#line 489
          goto _L___3;
        } else
#line 489
        if ((unsigned int )(sib->left)->color == 1U) {
          _L___3: /* CIL Label */ 
#line 490
          if (sib->right) {
#line 491
            (sib->right)->color = (enum __anonenum_color_68 )1;
          }
          {
#line 492
          sib->color = (enum __anonenum_color_68 )0;
#line 493
          __mm_rotate_left___6(sib);
#line 494
          sib = parent->left;
          }
        }
#line 497
        sib->color = parent->color;
#line 498
        parent->color = (enum __anonenum_color_68 )1;
#line 499
        if (sib->left) {
#line 500
          (sib->left)->color = (enum __anonenum_color_68 )1;
        }
        {
#line 501
        __mm_rotate_right___6(parent);
#line 502
        child = mm_root___6;
        }
#line 503
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 508
  if (child) {
#line 509
    child->color = (enum __anonenum_color_68 )1;
  }
#line 510
  return;
}
}
#line 512 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *__mm_find_start___6(uintptr_t start , uintptr_t end ) 
{ 
  struct ibv_mem_node *node ;

  {
#line 514
  node = mm_root___6;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! node) {
#line 516
      goto while_break;
    }
#line 517
    if (node->start <= start) {
#line 517
      if (node->end >= start) {
#line 518
        goto while_break;
      }
    }
#line 520
    if (node->start < start) {
#line 521
      node = node->right;
    } else {
#line 523
      node = node->left;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 526
  return (node);
}
}
#line 529 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *merge_ranges___6(struct ibv_mem_node *node , struct ibv_mem_node *prev ) 
{ 


  {
  {
#line 532
  prev->end = node->end;
#line 533
  prev->refcnt = node->refcnt;
#line 534
  __mm_remove___6(node);
  }
#line 536
  return (prev);
}
}
#line 539 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *split_range___6(struct ibv_mem_node *node , uintptr_t cut_line ) 
{ 
  struct ibv_mem_node *new_node ;
  void *tmp ;

  {
  {
#line 542
  new_node = (struct ibv_mem_node *)((void *)0);
#line 544
  tmp = malloc(sizeof(*new_node));
#line 544
  new_node = (struct ibv_mem_node *)tmp;
  }
#line 545
  if (! new_node) {
#line 546
    return ((struct ibv_mem_node *)((void *)0));
  }
  {
#line 547
  new_node->start = cut_line;
#line 548
  new_node->end = node->end;
#line 549
  new_node->refcnt = node->refcnt;
#line 550
  node->end = cut_line - 1UL;
#line 551
  __mm_add___6(new_node);
  }
#line 553
  return (new_node);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *get_start_node___6(uintptr_t start , uintptr_t end , int inc ) 
{ 
  struct ibv_mem_node *node ;
  struct ibv_mem_node *tmp ;

  {
  {
#line 559
  tmp = (struct ibv_mem_node *)((void *)0);
#line 561
  node = __mm_find_start___6(start, end);
  }
#line 562
  if (node->start < start) {
    {
#line 563
    node = split_range___6(node, start);
    }
  } else {
    {
#line 565
    tmp = __mm_prev___6(node);
    }
#line 566
    if (tmp) {
#line 566
      if (tmp->refcnt == node->refcnt + inc) {
        {
#line 567
        node = merge_ranges___6(node, tmp);
        }
      }
    }
  }
#line 569
  return (node);
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static struct ibv_mem_node *undo_node___6(struct ibv_mem_node *node , uintptr_t start ,
                                          int inc ) 
{ 
  struct ibv_mem_node *tmp ;

  {
#line 579
  tmp = (struct ibv_mem_node *)((void *)0);
#line 585
  if (start > node->start) {
    {
#line 586
    tmp = split_range___6(node, start);
    }
#line 587
    if (tmp) {
#line 588
      node->refcnt += inc;
#line 589
      node = tmp;
    } else {
#line 591
      return ((struct ibv_mem_node *)((void *)0));
    }
  }
  {
#line 594
  tmp = __mm_prev___6(node);
  }
#line 595
  if (tmp) {
#line 595
    if (tmp->refcnt == node->refcnt) {
      {
#line 596
      node = merge_ranges___6(node, tmp);
      }
    }
  }
  {
#line 598
  tmp = __mm_next___6(node);
  }
#line 599
  if (tmp) {
#line 599
    if (tmp->refcnt == node->refcnt) {
      {
#line 600
      node = merge_ranges___6(tmp, node);
      }
    }
  }
#line 602
  return (node);
}
}
#line 605 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/memory.c"
static int ibv_madvise_range___6(void *base , size_t size , int advice ) 
{ 
  uintptr_t start ;
  uintptr_t end ;
  struct ibv_mem_node *node ;
  struct ibv_mem_node *tmp ;
  int inc ;
  int rolling_back ;
  int ret ;
  unsigned long range_page_size ;
  struct ibv_mem_node *tmp___0 ;

  {
#line 610
  rolling_back = 0;
#line 611
  ret = 0;
#line 614
  if (! size) {
#line 615
    return (0);
  }
#line 617
  if (huge_page_enabled___6) {
    {
#line 618
    range_page_size = get_page_size___6(base);
    }
  } else {
#line 620
    range_page_size = (unsigned long )page_size___10;
  }
  {
#line 622
  start = (uintptr_t )base & ~ (range_page_size - 1UL);
#line 623
  end = ((uintptr_t )(((base + size) + range_page_size) - 1) & ~ (range_page_size - 1UL)) - 1UL;
#line 626
  pthread_mutex_lock(& mm_mutex___6);
  }
  again: 
#line 628
  if (advice == 10) {
#line 628
    inc = 1;
  } else {
#line 628
    inc = -1;
  }
  {
#line 630
  node = get_start_node___6(start, end, inc);
  }
#line 631
  if (! node) {
#line 632
    ret = -1;
#line 633
    goto out;
  }
  {
#line 636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 636
    if (node) {
#line 636
      if (! (node->start <= end)) {
#line 636
        goto while_break;
      }
    } else {
#line 636
      goto while_break;
    }
#line 637
    if (node->end > end) {
      {
#line 638
      tmp___0 = split_range___6(node, end + 1UL);
      }
#line 638
      if (! tmp___0) {
#line 639
        ret = -1;
#line 640
        goto out;
      }
    }
#line 644
    if (inc == -1) {
#line 644
      if (node->refcnt == 1) {
#line 644
        goto _L;
      } else {
#line 644
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 644
    if (inc == 1) {
#line 644
      if (node->refcnt == 0) {
        _L: /* CIL Label */ 
#line 657
        if (start > node->start) {
          {
#line 658
          ret = madvise((void *)start, (node->end - start) + 1UL, advice);
          }
        } else {
          {
#line 661
          ret = madvise((void *)node->start, (node->end - node->start) + 1UL, advice);
          }
        }
#line 664
        if (ret) {
          {
#line 665
          node = undo_node___6(node, start, inc);
          }
#line 667
          if (rolling_back) {
#line 668
            goto out;
          } else
#line 667
          if (! node) {
#line 668
            goto out;
          }
#line 671
          rolling_back = 1;
#line 672
          if (advice == 10) {
#line 672
            advice = 11;
          } else {
#line 672
            advice = 10;
          }
          {
#line 674
          tmp = __mm_prev___6(node);
          }
#line 675
          if (! tmp) {
#line 676
            goto out;
          } else
#line 675
          if (start > tmp->end) {
#line 676
            goto out;
          }
#line 677
          end = tmp->end;
#line 678
          goto again;
        }
      }
    }
    {
#line 682
    node->refcnt += inc;
#line 683
    node = __mm_next___6(node);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  if (node) {
    {
#line 687
    tmp = __mm_prev___6(node);
    }
#line 688
    if (tmp) {
#line 688
      if (node->refcnt == tmp->refcnt) {
        {
#line 689
        node = merge_ranges___6(node, tmp);
        }
      }
    }
  }
  out: 
#line 693
  if (rolling_back) {
#line 694
    ret = -1;
  }
  {
#line 696
  pthread_mutex_unlock(& mm_mutex___6);
  }
#line 698
  return (ret);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
__asm__(".symver __ibv_query_device,ibv_query_device@@IBVERBS_1.1");
#line 139
__asm__(".symver __ibv_query_port,ibv_query_port@@IBVERBS_1.1");
#line 164
__asm__(".symver __ibv_query_gid,ibv_query_gid@@IBVERBS_1.1");
#line 185
__asm__(".symver __ibv_query_pkey,ibv_query_pkey@@IBVERBS_1.1");
#line 197
__asm__(".symver __ibv_alloc_pd,ibv_alloc_pd@@IBVERBS_1.1");
#line 203
__asm__(".symver __ibv_dealloc_pd,ibv_dealloc_pd@@IBVERBS_1.1");
#line 224
__asm__(".symver __ibv_reg_mr,ibv_reg_mr@@IBVERBS_1.1");
#line 238
__asm__(".symver __ibv_dereg_mr,ibv_dereg_mr@@IBVERBS_1.1");
#line 243 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int warned___6  ;
#line 240 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static struct ibv_comp_channel *ibv_create_comp_channel_v2___6(struct ibv_context *context ) 
{ 
  struct ibv_abi_compat_v2 *t ;
  int tmp ;

  {
  {
#line 242
  t = (struct ibv_abi_compat_v2 *)context->abi_compat;
#line 245
  tmp = pthread_mutex_trylock(& t->in_use);
  }
#line 245
  if (! tmp) {
#line 246
    return (& t->channel);
  }
#line 248
  if (! warned___6) {
    {
#line 249
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libibverbs: Warning: kernel\'s ABI version %d limits capacity.\n    Only one completion channel can be created per context.\n",
            abi_ver);
#line 252
    warned___6 ++;
    }
  }
#line 255
  return ((struct ibv_comp_channel *)((void *)0));
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int ibv_destroy_comp_channel_v2___6(struct ibv_comp_channel *channel ) 
{ 
  struct ibv_abi_compat_v2 *t ;

  {
  {
#line 288
  t = (struct ibv_abi_compat_v2 *)channel;
#line 289
  pthread_mutex_unlock(& t->in_use);
  }
#line 290
  return (0);
}
}
#line 346
__asm__(".symver __ibv_create_cq,ibv_create_cq@@IBVERBS_1.1");
#line 355
__asm__(".symver __ibv_resize_cq,ibv_resize_cq@@IBVERBS_1.1");
#line 375
__asm__(".symver __ibv_destroy_cq,ibv_destroy_cq@@IBVERBS_1.1");
#line 393
__asm__(".symver __ibv_get_cq_event,ibv_get_cq_event@@IBVERBS_1.1");
#line 402
__asm__(".symver __ibv_ack_cq_events,ibv_ack_cq_events@@IBVERBS_1.1");
#line 424
__asm__(".symver __ibv_create_srq,ibv_create_srq@@IBVERBS_1.1");
#line 432
__asm__(".symver __ibv_modify_srq,ibv_modify_srq@@IBVERBS_1.1");
#line 438
__asm__(".symver __ibv_query_srq,ibv_query_srq@@IBVERBS_1.1");
#line 444
__asm__(".symver __ibv_destroy_srq,ibv_destroy_srq@@IBVERBS_1.1");
#line 467
__asm__(".symver __ibv_create_qp,ibv_create_qp@@IBVERBS_1.1");
#line 484
__asm__(".symver __ibv_query_qp,ibv_query_qp@@IBVERBS_1.1");
#line 500
__asm__(".symver __ibv_modify_qp,ibv_modify_qp@@IBVERBS_1.1");
#line 506
__asm__(".symver __ibv_destroy_qp,ibv_destroy_qp@@IBVERBS_1.1");
#line 519
__asm__(".symver __ibv_create_ah,ibv_create_ah@@IBVERBS_1.1");
#line 521 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/verbs.c"
static int ibv_find_gid_index___6(struct ibv_context *context , uint8_t port_num ,
                                  union ibv_gid *gid ) 
{ 
  union ibv_gid sgid ;
  int i ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 525
  i = 0;
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 528
    tmp = i;
#line 528
    i ++;
#line 528
    ret = ibv_query_gid(context, port_num, tmp, & sgid);
    }
#line 527
    if (! ret) {
      {
#line 527
      tmp___0 = memcmp((void const   *)(& sgid), (void const   *)gid, sizeof(*gid));
      }
#line 527
      if (! tmp___0) {
#line 527
        goto while_break;
      }
    } else {
#line 527
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 531
  if (ret) {
#line 531
    tmp___1 = ret;
  } else {
#line 531
    tmp___1 = i - 1;
  }
#line 531
  return (tmp___1);
}
}
#line 581
__asm__(".symver __ibv_destroy_ah,ibv_destroy_ah@@IBVERBS_1.1");
#line 587
__asm__(".symver __ibv_attach_mcast,ibv_attach_mcast@@IBVERBS_1.1");
#line 593
__asm__(".symver __ibv_detach_mcast,ibv_detach_mcast@@IBVERBS_1.1");
#line 400 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
static int ibv_cmd_modify_srq_v3___6(struct ibv_srq *srq , struct ibv_srq_attr *srq_attr ,
                                     int srq_attr_mask , struct ibv_modify_srq *new_cmd ,
                                     size_t new_cmd_size ) 
{ 
  struct ibv_modify_srq_v3 *cmd ;
  size_t cmd_size ;
  void *tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 409
  cmd_size = (sizeof(*cmd) + new_cmd_size) - sizeof(*new_cmd);
#line 410
  tmp = __builtin_alloca(cmd_size);
#line 410
  cmd = (struct ibv_modify_srq_v3 *)tmp;
#line 411
  memcpy((void */* __restrict  */)(cmd->driver_data), (void const   */* __restrict  */)(new_cmd->driver_data),
         new_cmd_size - sizeof(*new_cmd));
  }
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (abi_ver > (int __attribute__((__visibility__("hidden")))  )2) {
#line 413
      cmd->command = (__u32 )33;
    } else {
#line 413
      cmd->command = (__u32 )35;
    }
#line 413
    cmd->in_words = (__u16 )(cmd_size / 4UL);
#line 413
    cmd->out_words = (__u16 )0;
#line 413
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 415
  cmd->srq_handle = srq->handle;
#line 416
  cmd->attr_mask = (__u32 )srq_attr_mask;
#line 417
  cmd->max_wr = srq_attr->max_wr;
#line 418
  cmd->srq_limit = srq_attr->srq_limit;
#line 419
  cmd->max_sge = (__u32 )0;
#line 420
  cmd->reserved = (__u32 )0;
#line 422
  tmp___1 = write((srq->context)->cmd_fd, (void const   *)cmd, cmd_size);
  }
#line 422
  if ((size_t )tmp___1 != cmd_size) {
    {
#line 423
    tmp___0 = __errno_location();
    }
#line 423
    return (*tmp___0);
  }
#line 425
  return (0);
}
}
#line 1008 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/cmd.c"
static int ib_spec_to_kern_spec___6(struct ibv_flow_spec *ib_spec , struct ibv_kern_spec *kern_spec ) 
{ 


  {
#line 1011
  kern_spec->__annonCompField5.hdr.type = (__u32 )ib_spec->__annonCompField1.hdr.type;
  {
#line 1014
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 32U) {
#line 1014
    goto case_32;
  }
#line 1021
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 48U) {
#line 1021
    goto case_48;
  }
#line 1029
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 65U) {
#line 1029
    goto case_65;
  }
#line 1029
  if ((unsigned int )ib_spec->__annonCompField1.hdr.type == 64U) {
#line 1029
    goto case_65;
  }
#line 1036
  goto switch_default;
  case_32: /* CIL Label */ 
  {
#line 1015
  kern_spec->__annonCompField5.eth.size = (__u16 )sizeof(struct ibv_kern_spec_eth );
#line 1016
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.eth.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.eth.val),
         sizeof(struct ibv_flow_eth_filter ));
#line 1018
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.eth.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.eth.mask),
         sizeof(struct ibv_flow_eth_filter ));
  }
#line 1020
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 1022
  kern_spec->__annonCompField5.ipv4.size = (__u16 )sizeof(struct ibv_kern_spec_ipv4 );
#line 1023
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.ipv4.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.ipv4.val),
         sizeof(struct ibv_flow_ipv4_filter ));
#line 1025
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.ipv4.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.ipv4.mask),
         sizeof(struct ibv_flow_ipv4_filter ));
  }
#line 1027
  goto switch_break;
  case_65: /* CIL Label */ 
  case_64: /* CIL Label */ 
  {
#line 1030
  kern_spec->__annonCompField5.tcp_udp.size = (__u16 )sizeof(struct ibv_kern_spec_tcp_udp );
#line 1031
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.tcp_udp.val), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.tcp_udp.val),
         sizeof(struct ibv_flow_ipv4_filter ));
#line 1033
  memcpy((void */* __restrict  */)(& kern_spec->__annonCompField5.tcp_udp.mask), (void const   */* __restrict  */)(& ib_spec->__annonCompField1.tcp_udp.mask),
         sizeof(struct ibv_flow_tcp_udp_filter ));
  }
#line 1035
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1037
  return (-22);
  switch_break: /* CIL Label */ ;
  }
#line 1039
  return (0);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/sysfs.c"
static char *sysfs_path___6  ;
#line 267 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
__asm__(".symver __ibv_get_device_list_1_0,ibv_get_device_list@IBVERBS_1.0");
#line 281
__asm__(".symver __ibv_free_device_list_1_0,ibv_free_device_list@IBVERBS_1.0");
#line 287
__asm__(".symver __ibv_get_device_name_1_0,ibv_get_device_name@IBVERBS_1.0");
#line 293
__asm__(".symver __ibv_get_device_guid_1_0,ibv_get_device_guid@IBVERBS_1.0");
#line 295 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int poll_cq_wrapper_1_0___9(struct ibv_cq_1_0 *cq , int num_entries , struct ibv_wc *wc ) 
{ 
  int tmp ;

  {
  {
#line 298
  tmp = (*(((cq->context)->real_context)->ops.poll_cq))(cq->real_cq, num_entries,
                                                        wc);
  }
#line 298
  return (tmp);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int req_notify_cq_wrapper_1_0___9(struct ibv_cq_1_0 *cq , int sol_only ) 
{ 
  int tmp ;

  {
  {
#line 303
  tmp = (*(((cq->context)->real_context)->ops.req_notify_cq))(cq->real_cq, sol_only);
  }
#line 303
  return (tmp);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_srq_recv_wrapper_1_0___9(struct ibv_srq_1_0 *srq , struct ibv_recv_wr_1_0 *wr ,
                                         struct ibv_recv_wr_1_0 **bad_wr ) 
{ 
  struct ibv_recv_wr_1_0 *w ;
  struct ibv_recv_wr *real_wr ;
  struct ibv_recv_wr *head_wr ;
  struct ibv_recv_wr *tail_wr ;
  struct ibv_recv_wr *real_bad_wr ;
  int ret ;
  void *tmp ;

  {
#line 310
  head_wr = (struct ibv_recv_wr *)((void *)0);
#line 310
  tail_wr = (struct ibv_recv_wr *)((void *)0);
#line 313
  w = wr;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! w) {
#line 313
      goto while_break;
    }
    {
#line 314
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 314
    real_wr = (struct ibv_recv_wr *)tmp;
#line 315
    real_wr->wr_id = w->wr_id;
#line 316
    real_wr->sg_list = w->sg_list;
#line 317
    real_wr->num_sge = w->num_sge;
#line 318
    real_wr->next = (struct ibv_recv_wr *)((void *)0);
    }
#line 319
    if (tail_wr) {
#line 320
      tail_wr->next = real_wr;
    } else {
#line 322
      head_wr = real_wr;
    }
#line 324
    tail_wr = real_wr;
#line 313
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 327
  ret = (*(((srq->context)->real_context)->ops.post_srq_recv))(srq->real_srq, head_wr,
                                                               & real_bad_wr);
  }
#line 330
  if (ret) {
#line 331
    real_wr = head_wr;
#line 331
    w = wr;
    {
#line 331
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 331
      if (! real_wr) {
#line 331
        goto while_break___0;
      }
#line 334
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 335
        *bad_wr = w;
#line 336
        goto while_break___0;
      }
#line 331
      real_wr = real_wr->next;
#line 331
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 340
  return (ret);
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_send_wrapper_1_0___9(struct ibv_qp_1_0 *qp , struct ibv_send_wr_1_0 *wr ,
                                     struct ibv_send_wr_1_0 **bad_wr ) 
{ 
  struct ibv_send_wr_1_0 *w ;
  struct ibv_send_wr *real_wr ;
  struct ibv_send_wr *head_wr ;
  struct ibv_send_wr *tail_wr ;
  struct ibv_send_wr *real_bad_wr ;
  int is_ud ;
  int ret ;
  void *tmp ;

  {
#line 347
  head_wr = (struct ibv_send_wr *)((void *)0);
#line 347
  tail_wr = (struct ibv_send_wr *)((void *)0);
#line 348
  is_ud = (unsigned int )qp->qp_type == 4U;
#line 351
  w = wr;
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! w) {
#line 351
      goto while_break;
    }
    {
#line 352
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 352
    real_wr = (struct ibv_send_wr *)tmp;
#line 353
    real_wr->wr_id = w->wr_id;
#line 354
    real_wr->next = (struct ibv_send_wr *)((void *)0);
    }
#line 363
    if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->sg_list)) {
      {
#line 364
      memcpy((void */* __restrict  */)(& real_wr->sg_list), (void const   */* __restrict  */)(& w->sg_list),
             sizeof(*real_wr) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list));
      }
    } else
#line 366
    if ((unsigned long )(& ((struct ibv_send_wr *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list) == (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->sg_list)) {
#line 366
      if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->wr) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->wr)) {
        {
#line 371
        memcpy((void */* __restrict  */)(& real_wr->sg_list), (void const   */* __restrict  */)(& w->sg_list),
               ((unsigned long )(& ((struct ibv_send_wr *)0)->imm_data) - (unsigned long )(& ((struct ibv_send_wr *)0)->sg_list)) + sizeof(real_wr->imm_data));
#line 375
        memcpy((void */* __restrict  */)(& real_wr->wr), (void const   */* __restrict  */)(& w->wr),
               sizeof(real_wr->wr));
        }
      } else {
#line 366
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 377
      real_wr->sg_list = w->sg_list;
#line 378
      real_wr->num_sge = w->num_sge;
#line 379
      real_wr->opcode = w->opcode;
#line 380
      real_wr->send_flags = w->send_flags;
#line 381
      real_wr->imm_data = w->imm_data;
#line 382
      if (sizeof(struct ibv_send_wr ) - (unsigned long )(& ((struct ibv_send_wr *)0)->wr) == sizeof(struct ibv_send_wr_1_0 ) - (unsigned long )(& ((struct ibv_send_wr_1_0 *)0)->wr)) {
        {
#line 383
        memcpy((void */* __restrict  */)(& real_wr->wr), (void const   */* __restrict  */)(& w->wr),
               sizeof(real_wr->wr));
        }
      } else {
#line 386
        real_wr->wr.atomic.remote_addr = w->wr.atomic.remote_addr;
#line 388
        real_wr->wr.atomic.compare_add = w->wr.atomic.compare_add;
#line 390
        real_wr->wr.atomic.swap = w->wr.atomic.swap;
#line 392
        real_wr->wr.atomic.rkey = w->wr.atomic.rkey;
      }
    }
#line 397
    if (is_ud) {
#line 398
      real_wr->wr.ud.ah = (w->wr.ud.ah)->real_ah;
    }
#line 400
    if (tail_wr) {
#line 401
      tail_wr->next = real_wr;
    } else {
#line 403
      head_wr = real_wr;
    }
#line 405
    tail_wr = real_wr;
#line 351
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 408
  ret = (*(((qp->context)->real_context)->ops.post_send))(qp->real_qp, head_wr, & real_bad_wr);
  }
#line 411
  if (ret) {
#line 412
    real_wr = head_wr;
#line 412
    w = wr;
    {
#line 412
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 412
      if (! real_wr) {
#line 412
        goto while_break___0;
      }
#line 415
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 416
        *bad_wr = w;
#line 417
        goto while_break___0;
      }
#line 412
      real_wr = real_wr->next;
#line 412
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 421
  return (ret);
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/libibverbs-1.1.7/src/compat-1_0.c"
static int post_recv_wrapper_1_0___9(struct ibv_qp_1_0 *qp , struct ibv_recv_wr_1_0 *wr ,
                                     struct ibv_recv_wr_1_0 **bad_wr ) 
{ 
  struct ibv_recv_wr_1_0 *w ;
  struct ibv_recv_wr *real_wr ;
  struct ibv_recv_wr *head_wr ;
  struct ibv_recv_wr *tail_wr ;
  struct ibv_recv_wr *real_bad_wr ;
  int ret ;
  void *tmp ;

  {
#line 428
  head_wr = (struct ibv_recv_wr *)((void *)0);
#line 428
  tail_wr = (struct ibv_recv_wr *)((void *)0);
#line 431
  w = wr;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! w) {
#line 431
      goto while_break;
    }
    {
#line 432
    tmp = __builtin_alloca(sizeof(*real_wr));
#line 432
    real_wr = (struct ibv_recv_wr *)tmp;
#line 433
    real_wr->wr_id = w->wr_id;
#line 434
    real_wr->sg_list = w->sg_list;
#line 435
    real_wr->num_sge = w->num_sge;
#line 436
    real_wr->next = (struct ibv_recv_wr *)((void *)0);
    }
#line 437
    if (tail_wr) {
#line 438
      tail_wr->next = real_wr;
    } else {
#line 440
      head_wr = real_wr;
    }
#line 442
    tail_wr = real_wr;
#line 431
    w = w->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 445
  ret = (*(((qp->context)->real_context)->ops.post_recv))(qp->real_qp, head_wr, & real_bad_wr);
  }
#line 448
  if (ret) {
#line 449
    real_wr = head_wr;
#line 449
    w = wr;
    {
#line 449
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 449
      if (! real_wr) {
#line 449
        goto while_break___0;
      }
#line 452
      if ((unsigned long )real_wr == (unsigned long )real_bad_wr) {
#line 453
        *bad_wr = w;
#line 454
        goto while_break___0;
      }
#line 449
      real_wr = real_wr->next;
#line 449
      w = w->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 458
  return (ret);
}
}
#line 487
__asm__(".symver __ibv_open_device_1_0,ibv_open_device@IBVERBS_1.0");
#line 500
__asm__(".symver __ibv_close_device_1_0,ibv_close_device@IBVERBS_1.0");
#line 538
__asm__(".symver __ibv_get_async_event_1_0,ibv_get_async_event@IBVERBS_1.0");
#line 574
__asm__(".symver __ibv_ack_async_event_1_0,ibv_ack_async_event@IBVERBS_1.0");
#line 581
__asm__(".symver __ibv_query_device_1_0,ibv_query_device@IBVERBS_1.0");
#line 588
__asm__(".symver __ibv_query_port_1_0,ibv_query_port@IBVERBS_1.0");
#line 595
__asm__(".symver __ibv_query_gid_1_0,ibv_query_gid@IBVERBS_1.0");
#line 602
__asm__(".symver __ibv_query_pkey_1_0,ibv_query_pkey@IBVERBS_1.0");
#line 624
__asm__(".symver __ibv_alloc_pd_1_0,ibv_alloc_pd@IBVERBS_1.0");
#line 637
__asm__(".symver __ibv_dealloc_pd_1_0,ibv_dealloc_pd@IBVERBS_1.0");
#line 663
__asm__(".symver __ibv_reg_mr_1_0,ibv_reg_mr@IBVERBS_1.0");
#line 676
__asm__(".symver __ibv_dereg_mr_1_0,ibv_dereg_mr@IBVERBS_1.0");
#line 706
__asm__(".symver __ibv_create_cq_1_0,ibv_create_cq@IBVERBS_1.0");
#line 712
__asm__(".symver __ibv_resize_cq_1_0,ibv_resize_cq@IBVERBS_1.0");
#line 725
__asm__(".symver __ibv_destroy_cq_1_0,ibv_destroy_cq@IBVERBS_1.0");
#line 743
__asm__(".symver __ibv_get_cq_event_1_0,ibv_get_cq_event@IBVERBS_1.0");
#line 749
__asm__(".symver __ibv_ack_cq_events_1_0,ibv_ack_cq_events@IBVERBS_1.0");
#line 776
__asm__(".symver __ibv_create_srq_1_0,ibv_create_srq@IBVERBS_1.0");
#line 784
__asm__(".symver __ibv_modify_srq_1_0,ibv_modify_srq@IBVERBS_1.0");
#line 790
__asm__(".symver __ibv_query_srq_1_0,ibv_query_srq@IBVERBS_1.0");
#line 803
__asm__(".symver __ibv_destroy_srq_1_0,ibv_destroy_srq@IBVERBS_1.0");
#line 847
__asm__(".symver __ibv_create_qp_1_0,ibv_create_qp@IBVERBS_1.0");
#line 870
__asm__(".symver __ibv_query_qp_1_0,ibv_query_qp@IBVERBS_1.0");
#line 877
__asm__(".symver __ibv_modify_qp_1_0,ibv_modify_qp@IBVERBS_1.0");
#line 890
__asm__(".symver __ibv_destroy_qp_1_0,ibv_destroy_qp@IBVERBS_1.0");
#line 914
__asm__(".symver __ibv_create_ah_1_0,ibv_create_ah@IBVERBS_1.0");
#line 927
__asm__(".symver __ibv_destroy_ah_1_0,ibv_destroy_ah@IBVERBS_1.0");
#line 933
__asm__(".symver __ibv_attach_mcast_1_0,ibv_attach_mcast@IBVERBS_1.0");
#line 939
__asm__(".symver __ibv_detach_mcast_1_0,ibv_detach_mcast@IBVERBS_1.0");
