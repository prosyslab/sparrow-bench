/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef unsigned long size_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 42 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 357 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 423 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 426 "/usr/include/regex.h"
typedef int regoff_t;
#line 452 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_76 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 452 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_76 regmatch_t;
#line 31 "libslack/slack/locker.h"
struct Locker;
#line 31 "libslack/slack/locker.h"
typedef struct Locker Locker;
#line 32 "libslack/slack/locker.h"
typedef int lockerf_t(void *lock );
#line 93 "libslack/slack/locker.h"
struct Locker {
   void *lock ;
   lockerf_t *tryrdlock ;
   lockerf_t *rdlock ;
   lockerf_t *trywrlock ;
   lockerf_t *wrlock ;
   lockerf_t *unlock ;
};
#line 34 "libslack/slack/list.h"
struct List;
#line 34 "libslack/slack/list.h"
typedef struct List List;
#line 35
struct Lister;
#line 35 "libslack/slack/list.h"
typedef struct Lister Lister;
#line 36 "libslack/slack/list.h"
typedef void list_release_t(void *item );
#line 36 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.h"
struct String;
#line 36 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.h"
typedef struct String String;
#line 37
struct StringTR;
#line 37 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.h"
typedef struct StringTR StringTR;
#line 39
enum StringAlignment {
    ALIGN_LEFT = 60,
    ALIGN_RIGHT = 62,
    ALIGN_CENTRE = 124,
    ALIGN_CENTER = 124,
    ALIGN_FULL = 61
} ;
#line 55 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.h"
typedef enum StringAlignment StringAlignment;
#line 336 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
struct String {
   size_t size ;
   size_t length ;
   char *str ;
   Locker *locker ;
};
#line 346 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
struct StringTR {
   int squash ;
   short table[256] ;
   Locker *locker ;
};
#line 4595 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
union __anonunion_soundex_79 {
   char c[4] ;
   int i ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef int __sig_atomic_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_4 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_4 __sigset_t;
#line 40 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 49 "/usr/include/signal.h"
typedef __sigset_t sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_7 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_8 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_9 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_10 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_11 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_12 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_13 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_6 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_7 _kill ;
   struct __anonstruct__timer_8 _timer ;
   struct __anonstruct__rt_9 _rt ;
   struct __anonstruct__sigchld_10 _sigchld ;
   struct __anonstruct__sigfault_11 _sigfault ;
   struct __anonstruct__sigpoll_12 _sigpoll ;
   struct __anonstruct__sigsys_13 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_5 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_6 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_5 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_25 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_25 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 31 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/sig.h"
typedef void signal_handler_t(int signo );
#line 98 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/sig.c"
struct real_signal_handler_t;
#line 98 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/sig.c"
typedef struct real_signal_handler_t real_signal_handler_t;
#line 100 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/sig.c"
struct real_signal_handler_t {
   struct sigaction action[1] ;
   signal_handler_t *handler ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 61 "/usr/include/signal.h"
typedef __pid_t pid_t;
#line 67 "/usr/include/signal.h"
typedef __uid_t uid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 57 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/daemon.h"
typedef void daemon_config_parser_t(void *obj , char const   *path , char *line ,
                                    size_t lineno );
#line 38 "libslack/slack/list.h"
typedef int list_cmp_t(void const   *a , void const   *b );
#line 31 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.h"
struct Map;
#line 31 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.h"
typedef struct Map Map;
#line 34 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.h"
typedef list_release_t map_release_t;
#line 123 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
struct Prop;
#line 123 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
typedef struct Prop Prop;
#line 125 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
struct Prop {
   Map *map ;
   Prop *defaults ;
};
#line 133 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
struct __anonstruct_g_70 {
   int init ;
   Prop *prop ;
   char *home ;
   int dirty ;
   Locker *locker ;
};
#line 38 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.h"
struct Msg;
#line 38 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.h"
typedef struct Msg Msg;
#line 83 "libslack/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 42 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.h"
typedef struct option option;
#line 43
struct Option;
#line 43 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.h"
typedef struct Option Option;
#line 44
struct Options;
#line 44 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.h"
typedef struct Options Options;
#line 46 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.h"
typedef void opt_action_int_t(int arg );
#line 47 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.h"
typedef void opt_action_optional_int_t(int *arg );
#line 48 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.h"
typedef void opt_action_string_t(char const   *arg );
#line 51 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.h"
typedef void func_t(void);
#line 53
enum OptionArgument {
    OPT_NONE = 0,
    OPT_INTEGER = 1,
    OPT_STRING = 2
} ;
#line 60
enum OptionAction {
    OPT_NOTHING = 0,
    OPT_VARIABLE = 1,
    OPT_FUNCTION = 2
} ;
#line 67 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.h"
typedef enum OptionArgument OptionArgument;
#line 68 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.h"
typedef enum OptionAction OptionAction;
#line 70 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.h"
struct Option {
   char const   *name ;
   char short_name ;
   char const   *argname ;
   char const   *desc ;
   int has_arg ;
   OptionArgument arg_type ;
   OptionAction action ;
   void *object ;
   func_t *function ;
};
#line 83 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.h"
struct Options {
   Options *parent ;
   Option *options ;
};
#line 201 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
struct Prog;
#line 201 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
typedef struct Prog Prog;
#line 203 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
struct Prog {
   char const   *name ;
   Options *options ;
   char const   *syntax ;
   char const   *desc ;
   char const   *version ;
   char const   *date ;
   char const   *author ;
   char const   *contact ;
   char const   *vendor ;
   char const   *url ;
   char const   *legal ;
   Msg *out ;
   Msg *err ;
   Msg *dbg ;
   Msg *log ;
   size_t debug_level ;
   size_t verbosity_level ;
   Locker *locker ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 224 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 242 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_74 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_74 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 264 "/usr/include/netinet/in.h"
struct ip_mreq {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_interface ;
};
#line 288 "/usr/include/netinet/in.h"
struct ipv6_mreq {
   struct in6_addr ipv6mr_multiaddr ;
   unsigned int ipv6mr_interface ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_77 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_78 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_77 ifr_ifrn ;
   union __anonunion_ifr_ifru_78 ifr_ifru ;
};
#line 176 "/usr/include/net/if.h"
union __anonunion_ifc_ifcu_79 {
   __caddr_t ifcu_buf ;
   struct ifreq *ifcu_req ;
};
#line 176 "/usr/include/net/if.h"
struct ifconf {
   int ifc_len ;
   union __anonunion_ifc_ifcu_79 ifc_ifcu ;
};
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 37 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.h"
typedef struct sockaddr sockaddr_t;
#line 38 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.h"
typedef unsigned short sockport_t;
#line 39
struct sockopt_t;
#line 39 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.h"
typedef struct sockopt_t sockopt_t;
#line 41
union sockaddr_any_t;
#line 41 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.h"
typedef union sockaddr_any_t sockaddr_any_t;
#line 42 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.h"
typedef struct sockaddr_un sockaddr_un_t;
#line 43 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.h"
typedef struct sockaddr_in sockaddr_in_t;
#line 45 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.h"
typedef struct sockaddr_in6 sockaddr_in6_t;
#line 48
struct net_interface_t;
#line 48 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.h"
typedef struct net_interface_t net_interface_t;
#line 49
struct rudp_t;
#line 49 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.h"
typedef struct rudp_t rudp_t;
#line 51 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.h"
struct sockopt_t {
   int level ;
   int optname ;
   void const   *optval ;
   int optlen ;
};
#line 59 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.h"
union sockaddr_any_t {
   sockaddr_t any ;
   sockaddr_un_t un ;
   sockaddr_in_t in ;
   sockaddr_in6_t in6 ;
};
#line 77 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.h"
struct net_interface_t {
   char name[16] ;
   unsigned int index ;
   short flags ;
   int mtu ;
   sockaddr_any_t *addr ;
   sockaddr_any_t *brdaddr ;
   sockaddr_any_t *dstaddr ;
   sockaddr_any_t *hwaddr ;
};
#line 220 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
struct rudp_t {
   double rtt ;
   double srtt ;
   double rttvar ;
   double rto ;
   int nrexmt ;
   uint32_t base ;
   uint32_t sequence ;
};
#line 2584 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
struct __anonstruct_ohdr_82 {
   uint32_t sequence ;
   uint32_t timestamp ;
};
#line 3893 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
union __anonunion_control_83 {
   struct cmsghdr align ;
   char control[(((sizeof(int ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))] ;
};
#line 3968 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
union __anonunion_control_84 {
   struct cmsghdr align ;
   char control[(((sizeof(int ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 39 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.h"
typedef void msg_out_t(void *data , void const   *mesg , size_t mesglen );
#line 40 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.h"
typedef void msg_release_t(void *data );
#line 116 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
typedef int MsgFDData;
#line 117
struct MsgFileData;
#line 117 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
typedef struct MsgFileData MsgFileData;
#line 118
struct MsgSyslogData;
#line 118 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
typedef struct MsgSyslogData MsgSyslogData;
#line 119
struct MsgPlexData;
#line 119 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
typedef struct MsgPlexData MsgPlexData;
#line 126 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
struct Msg {
   int type ;
   msg_out_t *out ;
   void *data ;
   msg_release_t *destroy ;
   Locker *locker ;
};
#line 135 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
struct MsgFileData {
   int fd ;
};
#line 140 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
struct MsgSyslogData {
   int facility ;
   int priority ;
};
#line 146 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
struct MsgPlexData {
   size_t size ;
   size_t length ;
   Msg **list ;
};
#line 153
struct syslog_map_t;
#line 153 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
typedef struct syslog_map_t syslog_map_t;
#line 155 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
struct syslog_map_t {
   char *name ;
   int val ;
};
#line 40 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.h"
struct Pool;
#line 40 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.h"
typedef struct Pool Pool;
#line 100 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.c"
struct Pool {
   size_t size ;
   size_t used ;
   char *pool ;
   Locker *locker ;
};
#line 37 "libslack/slack/list.h"
typedef void *list_copy_t(void const   *item );
#line 32 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.h"
struct Mapper;
#line 32 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.h"
typedef struct Mapper Mapper;
#line 33
struct Mapping;
#line 33 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.h"
typedef struct Mapping Mapping;
#line 35 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.h"
typedef list_copy_t map_copy_t;
#line 36 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.h"
typedef list_cmp_t map_cmp_t;
#line 37 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.h"
typedef size_t map_hash_t(size_t table_size , void const   *key );
#line 38 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.h"
typedef void map_action_t(void *key , void *item , void *data );
#line 138 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
struct Map {
   size_t size ;
   size_t items ;
   List **chain ;
   map_hash_t *hash ;
   map_copy_t *copy ;
   map_cmp_t *cmp ;
   map_release_t *key_destroy ;
   map_release_t *value_destroy ;
   Mapper *mapper ;
   Locker *locker ;
};
#line 152 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
struct Mapping {
   void *key ;
   void *value ;
   map_release_t *key_destroy ;
   map_release_t *value_destroy ;
};
#line 160 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
struct Mapper {
   Map *map ;
   ssize_t chain_index ;
   ssize_t item_index ;
   ssize_t next_chain_index ;
   ssize_t next_item_index ;
};
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_29 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_29 pthread_mutex_t;
#line 174 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __anonstruct___data_35 {
   int __lock ;
   unsigned int __nr_readers ;
   unsigned int __readers_wakeup ;
   unsigned int __writer_wakeup ;
   unsigned int __nr_readers_queued ;
   unsigned int __nr_writers_queued ;
   int __writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 174 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_rwlock_t_34 {
   struct __anonstruct___data_35 __data ;
   char __size[56] ;
   long __align ;
};
#line 174 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlock_t_34 pthread_rwlock_t;
#line 39 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.h"
typedef void list_action_t(void *item , size_t *index , void *data );
#line 40 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.h"
typedef void *list_map_t(void *item , size_t *index , void *data );
#line 41 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.h"
typedef int list_query_t(void *item , size_t *index , void *data );
#line 31 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/hsort.h"
typedef int hsort_cmp_t(void const   *a , void const   *b );
#line 187 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
struct List {
   size_t size ;
   size_t length ;
   void **list ;
   list_release_t *destroy ;
   Lister *lister ;
   Locker *locker ;
};
#line 197 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
struct Lister {
   List *list ;
   ssize_t index ;
};
#line 29 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.h"
struct slink_t;
#line 29 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.h"
typedef struct slink_t slink_t;
#line 30
struct dlink_t;
#line 30 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.h"
typedef struct dlink_t dlink_t;
#line 32 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.h"
struct slink_t {
   void *next ;
};
#line 37 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.h"
struct dlink_t {
   void *next ;
   void *prev ;
};
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 119 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
struct conf_t;
#line 119 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
typedef struct conf_t conf_t;
#line 121 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
struct conf_t {
   int const   name ;
   long const   value ;
   off_t const   offset ;
};
#line 130 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
struct __anonstruct_g_77 {
   conf_t conf[19] ;
};
#line 32 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/hsort.h"
typedef int hsort_closure_cmp_t(void const   *a , void const   *b , void const   *data );
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_63 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_63 fd_set;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 42 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rlimit_resource_t;
#line 104 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/daemon.c"
struct __anonstruct_g_85 {
   pthread_mutex_t lock ;
   char *pidfile ;
};
#line 30 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.h"
struct Agent;
#line 30 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.h"
typedef struct Agent Agent;
#line 31 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.h"
typedef int agent_action_t(Agent *agent , void *arg );
#line 32 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.h"
typedef int agent_reaction_t(Agent *agent , int fd , int revents , void *arg );
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 143 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
struct timewheel_t;
#line 143 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
typedef struct timewheel_t timewheel_t;
#line 144
struct action_t;
#line 144 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
typedef struct action_t action_t;
#line 145
struct reaction_t;
#line 145 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
typedef struct reaction_t reaction_t;
#line 146
struct activity_t;
#line 146 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
typedef struct activity_t activity_t;
#line 147 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
typedef struct timeval timeval;
#line 154 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
struct __anonstruct_s_78 {
   fd_set *rfds ;
   fd_set *xfds ;
   fd_set *wfds ;
};
#line 154 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
union __anonunion_u_77 {
   struct pollfd *pfds ;
   struct __anonstruct_s_78 s ;
};
#line 154 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
struct Agent {
   int state ;
   ssize_t *ids ;
   size_t ids_size ;
   int method ;
   union __anonunion_u_77 u ;
   reaction_t *reactions ;
   activity_t *tempo ;
   activity_t *activity ;
   size_t size ;
   size_t length ;
   timewheel_t *timewheel ;
   size_t timers ;
   Locker *locker ;
};
#line 184 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
struct action_t {
   action_t *next ;
   action_t *prev ;
   action_t **parent ;
   timeval when ;
   agent_action_t *action ;
   void *arg ;
   size_t day ;
   size_t hour ;
   size_t minute ;
   size_t second ;
   size_t jiffy ;
};
#line 199 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
struct reaction_t {
   int fd ;
   int events ;
   agent_reaction_t *reaction ;
   void *arg ;
};
#line 207 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
struct activity_t {
   timeval since ;
   size_t detail ;
   int dt ;
   int ddt ;
   int dddt ;
};
#line 225 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
struct timewheel_t {
   timeval now[1] ;
   size_t day ;
   size_t hour ;
   size_t minute ;
   size_t second ;
   size_t jiffy ;
   action_t *days[10] ;
   action_t *hours[24] ;
   action_t *minutes[60] ;
   action_t *seconds[60] ;
   action_t *jiffies[100] ;
};
#line 1057 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
struct __anonstruct_buf_80 {
   reaction_t reaction ;
   activity_t activity ;
};
#line 1131 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
struct __anonstruct_buf_81 {
   reaction_t reaction ;
   activity_t activity ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 685 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
struct Config;
#line 685 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
typedef struct Config Config;
#line 687 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
struct Config {
   char *name ;
   List *options ;
};
#line 745 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
struct __anonstruct_g_70___0 {
   int ac ;
   char **av ;
   char **cmd ;
   char *name ;
   char *pidfiles ;
   char *pidfile ;
   char *user ;
   char *group ;
   char userbuf[8192] ;
   char groupbuf[8192] ;
   char *chroot ;
   char *chdir ;
   char *command ;
   mode_t umask ;
   int init_groups ;
   uid_t initial_uid ;
   uid_t uid ;
   gid_t gid ;
   List *env ;
   char **environ ;
   int inherit ;
   int respawn ;
   int acceptable ;
   int attempts ;
   int delay ;
   int limit ;
   int idiot ;
   int attempt ;
   int burst ;
   int foreground ;
   int pty ;
   int noecho ;
   int core ;
   int unsafe ;
   int safe ;
   char *client_out ;
   char *client_err ;
   char *daemon_err ;
   char *daemon_dbg ;
   int client_outlog ;
   int client_errlog ;
   int daemon_errlog ;
   int daemon_dbglog ;
   int client_outfd ;
   int client_errfd ;
   char *config ;
   int noconfig ;
   pid_t pid ;
   int in ;
   int out ;
   int err ;
   int masterfd ;
   char slavename[64] ;
   size_t slavenamesize ;
   int stop ;
   int running ;
   int restart ;
   time_t spawn_time ;
   int done_name ;
   int done_chroot ;
   int done_user ;
   int done_config ;
   struct termios stdin_termios ;
   struct winsize stdin_winsize ;
   int stdin_isatty ;
   int stdin_eof ;
   int terminated ;
};
#line 2239 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
union __anonunion_71 {
   int __in ;
   int __i ;
};
#line 2242 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
union __anonunion_72 {
   int __in ;
   int __i ;
};
#line 2241 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
union __anonunion_73 {
   int __in ;
   int __i ;
};
#line 2247 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
union __anonunion_74 {
   int __in ;
   int __i ;
};
#line 2249 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
union __anonunion_75 {
   int __in ;
   int __i ;
};
#line 2251 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
union __anonunion_76 {
   int __in ;
   int __i ;
};
#line 2255 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
union __anonunion_77 {
   int __in ;
   int __i ;
};
#line 2253 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
union __anonunion_78 {
   int __in ;
   int __i ;
};
#line 2244 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
union __anonunion_79 {
   int __in ;
   int __i ;
};
#line 2237 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
union __anonunion_80 {
   int __in ;
   int __i ;
};
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 912
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) flockfile)(FILE *stream ) ;
#line 919
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) funlockfile)(FILE *stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 235
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 398
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 83 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.h"
int set_errno(int errnum ) ;
#line 84
void *set_errnull(int errnum ) ;
#line 562 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 566
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 574
extern void regfree(regex_t *__preg ) ;
#line 48 "libslack/slack/list.h"
List *list_create_with_locker(Locker *locker , list_release_t *destroy ) ;
#line 52
int list_rdlock(List const   *list ) ;
#line 54
int list_unlock(List const   *list ) ;
#line 55
void list_release(List *list ) ;
#line 61
void *list_item(List const   *list , ssize_t index ) ;
#line 67
ssize_t list_length(List const   *list ) ;
#line 81
List *list_append(List *list , void *item ) ;
#line 139
Lister *lister_create(List *list ) ;
#line 142
Lister *lister_create_unlocked(List const   *list ) ;
#line 143
void lister_release(Lister *lister ) ;
#line 144
void lister_release_unlocked(Lister *lister ) ;
#line 147
int lister_has_next(Lister *lister ) ;
#line 148
void *lister_next(Lister *lister ) ;
#line 151
int list_has_next(List *list ) ;
#line 153
void *list_next(List *list ) ;
#line 59 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.h"
String *str_create(char const   *format  , ...) ;
#line 60
String *str_create_with_locker(Locker *locker , char const   *format  , ...) ;
#line 61
String *str_vcreate(char const   *format , va_list args ) ;
#line 62
String *str_vcreate_with_locker(Locker *locker , char const   *format , va_list args ) ;
#line 63
String *str_create_sized(size_t size , char const   *format  , ...) ;
#line 64
String *str_create_with_locker_sized(Locker *locker , size_t size , char const   *format 
                                     , ...) ;
#line 65
String *str_vcreate_sized(size_t size , char const   *format , va_list args ) ;
#line 66
String *str_vcreate_with_locker_sized(Locker *locker , size_t size , char const   *format ,
                                      va_list args ) ;
#line 67
String *str_copy(String const   *str ) ;
#line 68
String *str_copy_unlocked(String const   *str ) ;
#line 69
String *str_copy_with_locker(Locker *locker , String const   *str ) ;
#line 70
String *str_copy_with_locker_unlocked(Locker *locker , String const   *str ) ;
#line 71
String *str_fgetline(FILE *stream ) ;
#line 72
String *str_fgetline_with_locker(Locker *locker , FILE *stream ) ;
#line 73
void str_release(String *str ) ;
#line 74
void *str_destroy(String **str ) ;
#line 75
int str_rdlock(String const   *str ) ;
#line 76
int str_wrlock(String const   *str ) ;
#line 77
int str_unlock(String const   *str ) ;
#line 78
int str_empty(String const   *str ) ;
#line 79
int str_empty_unlocked(String const   *str ) ;
#line 80
ssize_t str_length(String const   *str ) ;
#line 81
ssize_t str_length_unlocked(String const   *str ) ;
#line 82
char *cstr(String const   *str ) ;
#line 83
ssize_t str_set_length(String *str , size_t length ) ;
#line 84
ssize_t str_set_length_unlocked(String *str , size_t length ) ;
#line 85
ssize_t str_recalc_length(String *str ) ;
#line 86
ssize_t str_recalc_length_unlocked(String *str ) ;
#line 87
String *str_clear(String *str ) ;
#line 88
String *str_clear_unlocked(String *str ) ;
#line 89
String *str_remove(String *str , ssize_t index___0 ) ;
#line 90
String *str_remove_unlocked(String *str , ssize_t index___0 ) ;
#line 91
String *str_remove_range(String *str , ssize_t index___0 , ssize_t range ) ;
#line 92
String *str_remove_range_unlocked(String *str , ssize_t index___0 , ssize_t range ) ;
#line 93
String *str_insert(String *str , ssize_t index___0 , char const   *format  , ...) ;
#line 94
String *str_insert_unlocked(String *str , ssize_t index___0 , char const   *format 
                            , ...) ;
#line 95
String *str_vinsert(String *str , ssize_t index___0 , char const   *format , va_list args ) ;
#line 96
String *str_vinsert_unlocked(String *str , ssize_t index___0 , char const   *format ,
                             va_list args ) ;
#line 97
String *str_insert_str(String *str , ssize_t index___0 , String const   *src ) ;
#line 98
String *str_insert_str_unlocked(String *str , ssize_t index___0 , String const   *src ) ;
#line 99
String *str_append(String *str , char const   *format  , ...) ;
#line 100
String *str_append_unlocked(String *str , char const   *format  , ...) ;
#line 101
String *str_vappend(String *str , char const   *format , va_list args ) ;
#line 102
String *str_vappend_unlocked(String *str , char const   *format , va_list args ) ;
#line 103
String *str_append_str(String *str , String const   *src ) ;
#line 104
String *str_append_str_unlocked(String *str , String const   *src ) ;
#line 105
String *str_prepend(String *str , char const   *format  , ...) ;
#line 106
String *str_prepend_unlocked(String *str , char const   *format  , ...) ;
#line 107
String *str_vprepend(String *str , char const   *format , va_list args ) ;
#line 108
String *str_vprepend_unlocked(String *str , char const   *format , va_list args ) ;
#line 109
String *str_prepend_str(String *str , String const   *src ) ;
#line 110
String *str_prepend_str_unlocked(String *str , String const   *src ) ;
#line 111
String *str_replace(String *str , ssize_t index___0 , ssize_t range , char const   *format 
                    , ...) ;
#line 112
String *str_replace_unlocked(String *str , ssize_t index___0 , ssize_t range , char const   *format 
                             , ...) ;
#line 113
String *str_vreplace(String *str , ssize_t index___0 , ssize_t range , char const   *format ,
                     va_list args ) ;
#line 114
String *str_vreplace_unlocked(String *str , ssize_t index___0 , ssize_t range , char const   *format ,
                              va_list args ) ;
#line 115
String *str_replace_str(String *str , ssize_t index___0 , ssize_t range , String const   *src ) ;
#line 116
String *str_replace_str_unlocked(String *str , ssize_t index___0 , ssize_t range ,
                                 String const   *src ) ;
#line 117
String *str_substr(String const   *str , ssize_t index___0 , ssize_t range ) ;
#line 118
String *str_substr_unlocked(String const   *str , ssize_t index___0 , ssize_t range ) ;
#line 119
String *str_substr_with_locker(Locker *locker , String const   *str , ssize_t index___0 ,
                               ssize_t range ) ;
#line 120
String *str_substr_with_locker_unlocked(Locker *locker , String const   *str , ssize_t index___0 ,
                                        ssize_t range ) ;
#line 121
String *substr(char const   *str , ssize_t index___0 , ssize_t range ) ;
#line 122
String *substr_with_locker(Locker *locker , char const   *str , ssize_t index___0 ,
                           ssize_t range ) ;
#line 123
String *str_splice(String *str , ssize_t index___0 , ssize_t range ) ;
#line 124
String *str_splice_unlocked(String *str , ssize_t index___0 , ssize_t range ) ;
#line 125
String *str_splice_with_locker(Locker *locker , String *str , ssize_t index___0 ,
                               ssize_t range ) ;
#line 126
String *str_splice_with_locker_unlocked(Locker *locker , String *str , ssize_t index___0 ,
                                        ssize_t range ) ;
#line 127
String *str_repeat(size_t count , char const   *format  , ...) ;
#line 128
String *str_repeat_with_locker(Locker *locker , size_t count , char const   *format 
                               , ...) ;
#line 129
String *str_vrepeat(size_t count , char const   *format , va_list args ) ;
#line 130
String *str_vrepeat_with_locker(Locker *locker , size_t count , char const   *format ,
                                va_list args ) ;
#line 131
int str_tr(String *str , char const   *from , char const   *to , int option ) ;
#line 132
int str_tr_unlocked(String *str , char const   *from , char const   *to , int option ) ;
#line 133
int str_tr_str(String *str , String const   *from , String const   *to , int option ) ;
#line 134
int str_tr_str_unlocked(String *str , String const   *from , String const   *to ,
                        int option ) ;
#line 135
int tr(char *str , char const   *from , char const   *to , int option ) ;
#line 136
StringTR *tr_compile(char const   *from , char const   *to , int option ) ;
#line 137
StringTR *tr_compile_with_locker(Locker *locker , char const   *from , char const   *to ,
                                 int option ) ;
#line 138
StringTR *str_tr_compile(String const   *from , String const   *to , int option ) ;
#line 139
StringTR *str_tr_compile_unlocked(String const   *from , String const   *to , int option ) ;
#line 140
StringTR *str_tr_compile_with_locker(Locker *locker , String const   *from , String const   *to ,
                                     int option ) ;
#line 141
StringTR *str_tr_compile_with_locker_unlocked(Locker *locker , String const   *from ,
                                              String const   *to , int option ) ;
#line 142
void tr_release(StringTR *table ) ;
#line 143
void *tr_destroy(StringTR **table ) ;
#line 144
int str_tr_compiled(String *str , StringTR *table ) ;
#line 145
int str_tr_compiled_unlocked(String *str , StringTR *table ) ;
#line 146
int tr_compiled(char *str , StringTR *table ) ;
#line 147
List *str_regexpr(char const   *pattern , String const   *text , int cflags , int eflags ) ;
#line 148
List *str_regexpr_unlocked(char const   *pattern , String const   *text , int cflags ,
                           int eflags ) ;
#line 149
List *str_regexpr_with_locker(Locker *locker , char const   *pattern , String const   *text ,
                              int cflags , int eflags ) ;
#line 150
List *str_regexpr_with_locker_unlocked(Locker *locker , char const   *pattern , String const   *text ,
                                       int cflags , int eflags ) ;
#line 151
List *regexpr(char const   *pattern , char const   *text , int cflags , int eflags ) ;
#line 152
List *regexpr_with_locker(Locker *locker , char const   *pattern , char const   *text ,
                          int cflags , int eflags ) ;
#line 153
int regexpr_compile(regex_t *compiled , char const   *pattern , int cflags ) ;
#line 154
void regexpr_release(regex_t *compiled ) ;
#line 155
List *str_regexpr_compiled(regex_t const   *compiled , String const   *text , int eflags ) ;
#line 156
List *str_regexpr_compiled_unlocked(regex_t const   *compiled , String const   *text ,
                                    int eflags ) ;
#line 157
List *str_regexpr_compiled_with_locker(Locker *locker , regex_t const   *compiled ,
                                       String const   *text , int eflags ) ;
#line 158
List *str_regexpr_compiled_with_locker_unlocked(Locker *locker , regex_t const   *compiled ,
                                                String const   *text , int eflags ) ;
#line 159
List *regexpr_compiled(regex_t const   *compiled , char const   *text , int eflags ) ;
#line 160
List *regexpr_compiled_with_locker(Locker *locker , regex_t const   *compiled , char const   *text ,
                                   int eflags ) ;
#line 161
String *str_regsub(char const   *pattern , char const   *replacement , String *text ,
                   int cflags , int eflags , int all ) ;
#line 162
String *str_regsub_unlocked(char const   *pattern , char const   *replacement , String *text ,
                            int cflags , int eflags , int all ) ;
#line 163
String *str_regsub_compiled(regex_t const   *compiled , char const   *replacement ,
                            String *text , int eflags , int all ) ;
#line 164
String *str_regsub_compiled_unlocked(regex_t const   *compiled , char const   *replacement ,
                                     String *text , int eflags , int all ) ;
#line 165
List *str_fmt(String const   *str , size_t line_width , StringAlignment alignment ) ;
#line 166
List *str_fmt_unlocked(String const   *str , size_t line_width , StringAlignment alignment ) ;
#line 167
List *str_fmt_with_locker(Locker *locker , String const   *str , size_t line_width ,
                          StringAlignment alignment ) ;
#line 168
List *str_fmt_with_locker_unlocked(Locker *locker , String const   *str , size_t line_width ,
                                   StringAlignment alignment ) ;
#line 169
List *fmt(char const   *str , size_t line_width , StringAlignment alignment ) ;
#line 170
List *fmt_with_locker(Locker *locker , char const   *str , size_t line_width , StringAlignment alignment ) ;
#line 171
List *str_split(String const   *str , char const   *delim ) ;
#line 172
List *str_split_unlocked(String const   *str , char const   *delim ) ;
#line 173
List *str_split_with_locker(Locker *locker , String const   *str , char const   *delim ) ;
#line 174
List *str_split_with_locker_unlocked(Locker *locker , String const   *str , char const   *delim ) ;
#line 175
List *split(char const   *str , char const   *delim ) ;
#line 176
List *split_with_locker(Locker *locker , char const   *str , char const   *delim ) ;
#line 177
List *str_regexpr_split(String const   *str , char const   *delim , int cflags , int eflags ) ;
#line 178
List *str_regexpr_split_unlocked(String const   *str , char const   *delim , int cflags ,
                                 int eflags ) ;
#line 179
List *str_regexpr_split_with_locker(Locker *locker , String const   *str , char const   *delim ,
                                    int cflags , int eflags ) ;
#line 180
List *str_regexpr_split_with_locker_unlocked(Locker *locker , String const   *str ,
                                             char const   *delim , int cflags , int eflags ) ;
#line 181
List *regexpr_split(char const   *str , char const   *delim , int cflags , int eflags ) ;
#line 182
List *regexpr_split_with_locker(Locker *locker , char const   *str , char const   *delim ,
                                int cflags , int eflags ) ;
#line 183
String *str_join(List const   *list , char const   *delim ) ;
#line 184
String *str_join_unlocked(List const   *list , char const   *delim ) ;
#line 185
String *str_join_with_locker(Locker *locker , List const   *list , char const   *delim ) ;
#line 186
String *str_join_with_locker_unlocked(Locker *locker , List const   *list , char const   *delim ) ;
#line 187
String *join(List const   *list , char const   *delim ) ;
#line 188
String *join_with_locker(Locker *locker , List const   *list , char const   *delim ) ;
#line 189
int str_soundex(String const   *str ) ;
#line 190
int str_soundex_unlocked(String const   *str ) ;
#line 191
int soundex(char const   *str ) ;
#line 192
String *str_trim(String *str ) ;
#line 193
String *str_trim_unlocked(String *str ) ;
#line 194
char *trim(char *str ) ;
#line 195
String *str_trim_left(String *str ) ;
#line 196
String *str_trim_left_unlocked(String *str ) ;
#line 197
char *trim_left(char *str ) ;
#line 198
String *str_trim_right(String *str ) ;
#line 199
String *str_trim_right_unlocked(String *str ) ;
#line 200
char *trim_right(char *str ) ;
#line 201
String *str_squeeze(String *str ) ;
#line 202
String *str_squeeze_unlocked(String *str ) ;
#line 203
char *squeeze(char *str ) ;
#line 204
String *str_quote(String const   *str , char const   *quotable , char quote_char ) ;
#line 205
String *str_quote_unlocked(String const   *str , char const   *quotable , char quote_char ) ;
#line 206
String *str_quote_with_locker(Locker *locker , String const   *str , char const   *quotable ,
                              char quote_char ) ;
#line 207
String *str_quote_with_locker_unlocked(Locker *locker , String const   *str , char const   *quotable ,
                                       char quote_char ) ;
#line 208
String *quote(char const   *str , char const   *quotable , char quote_char ) ;
#line 209
String *quote_with_locker(Locker *locker , char const   *str , char const   *quotable ,
                          char quote_char ) ;
#line 210
String *str_unquote(String const   *str , char const   *quotable , char quote_char ) ;
#line 211
String *str_unquote_unlocked(String const   *str , char const   *quotable , char quote_char ) ;
#line 212
String *str_unquote_with_locker(Locker *locker , String const   *str , char const   *quotable ,
                                char quote_char ) ;
#line 213
String *str_unquote_with_locker_unlocked(Locker *locker , String const   *str , char const   *quotable ,
                                         char quote_char ) ;
#line 214
String *unquote(char const   *str , char const   *quotable , char quote_char ) ;
#line 215
String *unquote_with_locker(Locker *locker , char const   *str , char const   *quotable ,
                            char quote_char ) ;
#line 216
String *str_encode(String const   *str , char const   *uncoded , char const   *coded ,
                   char quote_char , int printable ) ;
#line 217
String *str_encode_unlocked(String const   *str , char const   *uncoded , char const   *coded ,
                            char quote_char , int printable ) ;
#line 218
String *str_encode_with_locker(Locker *locker , String const   *str , char const   *uncoded ,
                               char const   *coded , char quote_char , int printable ) ;
#line 219
String *str_encode_with_locker_unlocked(Locker *locker , String const   *str , char const   *uncoded ,
                                        char const   *coded , char quote_char , int printable ) ;
#line 220
String *str_decode(String const   *str , char const   *uncoded , char const   *coded ,
                   char quote_char , int printable ) ;
#line 221
String *str_decode_unlocked(String const   *str , char const   *uncoded , char const   *coded ,
                            char quote_char , int printable ) ;
#line 222
String *str_decode_with_locker(Locker *locker , String const   *str , char const   *uncoded ,
                               char const   *coded , char quote_char , int printable ) ;
#line 223
String *str_decode_with_locker_unlocked(Locker *locker , String const   *str , char const   *uncoded ,
                                        char const   *coded , char quote_char , int printable ) ;
#line 224
String *encode(char const   *str , char const   *uncoded , char const   *coded , char quote_char ,
               int printable ) ;
#line 225
String *encode_with_locker(Locker *locker , char const   *str , char const   *uncoded ,
                           char const   *coded , char quote_char , int printable ) ;
#line 226
String *decode(char const   *str , char const   *uncoded , char const   *coded , char quote_char ,
               int printable ) ;
#line 227
String *decode_with_locker(Locker *locker , char const   *str , char const   *uncoded ,
                           char const   *coded , char quote_char , int printable ) ;
#line 228
String *str_lc(String *str ) ;
#line 229
String *str_lc_unlocked(String *str ) ;
#line 230
char *lc(char *str ) ;
#line 231
String *str_lcfirst(String *str ) ;
#line 232
String *str_lcfirst_unlocked(String *str ) ;
#line 233
char *lcfirst(char *str ) ;
#line 234
String *str_uc(String *str ) ;
#line 235
String *str_uc_unlocked(String *str ) ;
#line 236
char *uc(char *str ) ;
#line 237
String *str_ucfirst(String *str ) ;
#line 238
String *str_ucfirst_unlocked(String *str ) ;
#line 239
char *ucfirst(char *str ) ;
#line 240
int str_chop(String *str ) ;
#line 241
int str_chop_unlocked(String *str ) ;
#line 242
int chop(char *str ) ;
#line 243
int str_chomp(String *str ) ;
#line 244
int str_chomp_unlocked(String *str ) ;
#line 245
int chomp(char *str ) ;
#line 246
int str_bin(String const   *str ) ;
#line 247
int str_bin_unlocked(String const   *str ) ;
#line 248
int bin(char const   *str ) ;
#line 249
int str_hex(String const   *str ) ;
#line 250
int str_hex_unlocked(String const   *str ) ;
#line 251
int hex(char const   *str ) ;
#line 252
int str_oct(String const   *str ) ;
#line 253
int str_oct_unlocked(String const   *str ) ;
#line 254
int oct(char const   *str ) ;
#line 257
size_t strlcpy(char *dst , char const   *src , size_t size ) ;
#line 258
size_t strlcat(char *dst , char const   *src , size_t size ) ;
#line 259
char *cstrcpy(char *dst , char const   *src ) ;
#line 260
char *cstrcat(char *dst , char const   *src ) ;
#line 261
char *cstrchr(char const   *str , int c ) ;
#line 262
char *cstrpbrk(char const   *str , char const   *brk___0 ) ;
#line 263
char *cstrrchr(char const   *str , int c ) ;
#line 264
char *cstrstr(char const   *str , char const   *srch ) ;
#line 265
int asprintf(char **str , char const   *format  , ...) ;
#line 266
int vasprintf(char **str , char const   *format , va_list args ) ;
#line 46 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.h"
void *mem_resize_fn(void **mem , size_t size ) ;
#line 34 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/fio.h"
char *fgetline_unlocked(char *line , size_t size , FILE *stream ) ;
#line 373 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
static unsigned long const   MIN_STRING_SIZE  =    (size_t const   )32;
#line 377 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
static unsigned long const   MIN_EMPTY_STRING_SIZE  =    (size_t const   )1024;
#line 397 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
static int grow(String *str , size_t bytes ) 
{ 
  int grown ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 399
  grown = 0;
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 401
    if (! (str->length + bytes > str->size)) {
#line 401
      goto while_break;
    }
#line 403
    if (str->size) {
#line 404
      str->size <<= 1;
    } else {
#line 406
      str->size = (size_t )MIN_STRING_SIZE;
    }
#line 408
    grown = 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 411
  if (grown) {
    {
#line 412
    tmp___1 = mem_resize_fn((void **)(& str->str), str->size * sizeof(*(str->str)));
    }
#line 412
    if (tmp___1) {
#line 412
      tmp___0 = 0;
    } else {
#line 412
      tmp___0 = -1;
    }
#line 412
    return (tmp___0);
  }
#line 414
  return (0);
}
}
#line 426 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
static int shrink(String *str , size_t bytes ) 
{ 
  int shrunk ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 428
  shrunk = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! (str->length - bytes < str->size >> 1)) {
#line 430
      goto while_break;
    }
#line 432
    if (str->size <= (size_t )MIN_EMPTY_STRING_SIZE) {
#line 433
      goto while_break;
    }
#line 435
    str->size >>= 1;
#line 436
    shrunk = 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 439
  if (shrunk) {
    {
#line 440
    tmp___1 = mem_resize_fn((void **)(& str->str), str->size * sizeof(*(str->str)));
    }
#line 440
    if (tmp___1) {
#line 440
      tmp___0 = 0;
    } else {
#line 440
      tmp___0 = -1;
    }
#line 440
    return (tmp___0);
  }
#line 442
  return (0);
}
}
#line 454 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
static int expand(String *str , ssize_t index___0 , size_t range ) 
{ 
  int tmp ;

  {
  {
#line 456
  tmp = grow(str, range);
  }
#line 456
  if (tmp == -1) {
#line 457
    return (-1);
  }
  {
#line 459
  memmove((void *)((str->str + index___0) + range), (void const   *)(str->str + index___0),
          (str->length - (size_t )index___0) * sizeof(*(str->str)));
#line 460
  str->length += range;
  }
#line 462
  return (0);
}
}
#line 475 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
static int contract(String *str , ssize_t index___0 , size_t range ) 
{ 
  int tmp ;

  {
  {
#line 477
  memmove((void *)(str->str + index___0), (void const   *)((str->str + index___0) + range),
          ((str->length - (size_t )index___0) - range) * sizeof(*(str->str)));
#line 479
  tmp = shrink(str, range);
  }
#line 479
  if (tmp == -1) {
#line 480
    return (-1);
  }
#line 482
  str->length -= range;
#line 484
  return (0);
}
}
#line 497 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
static int adjust(String *str , ssize_t index___0 , size_t range , size_t length ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 499
  if (range < length) {
    {
#line 500
    tmp = expand(str, (ssize_t )((size_t )index___0 + range), length - range);
    }
#line 500
    return (tmp);
  }
#line 502
  if (range > length) {
    {
#line 503
    tmp___0 = contract(str, (ssize_t )((size_t )index___0 + length), range - length);
    }
#line 503
    return (tmp___0);
  }
#line 505
  return (0);
}
}
#line 531 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_create(char const   *format  , ...) 
{ 
  String *str ;
  va_list args ;

  {
  {
#line 535
  __builtin_va_start(args, format);
#line 536
  str = str_vcreate_with_locker_sized((Locker *)((void *)0), (size_t )MIN_STRING_SIZE,
                                      format, args);
#line 537
  __builtin_va_end(args);
  }
#line 538
  return (str);
}
}
#line 552 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_create_with_locker(Locker *locker , char const   *format  , ...) 
{ 
  String *str ;
  va_list args ;

  {
  {
#line 556
  __builtin_va_start(args, format);
#line 557
  str = str_vcreate_with_locker_sized(locker, (size_t )MIN_STRING_SIZE, format, args);
#line 558
  __builtin_va_end(args);
  }
#line 559
  return (str);
}
}
#line 573 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_vcreate(char const   *format , va_list args ) 
{ 
  String *tmp ;

  {
  {
#line 575
  tmp = str_vcreate_with_locker_sized((Locker *)((void *)0), (size_t )MIN_STRING_SIZE,
                                      format, args);
  }
#line 575
  return (tmp);
}
}
#line 589 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_vcreate_with_locker(Locker *locker , char const   *format , va_list args ) 
{ 
  String *tmp ;

  {
  {
#line 591
  tmp = str_vcreate_with_locker_sized(locker, (size_t )MIN_STRING_SIZE, format, args);
  }
#line 591
  return (tmp);
}
}
#line 609 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_create_sized(size_t size , char const   *format  , ...) 
{ 
  String *str ;
  va_list args ;

  {
  {
#line 613
  __builtin_va_start(args, format);
#line 614
  str = str_vcreate_with_locker_sized((Locker *)((void *)0), size, format, args);
#line 615
  __builtin_va_end(args);
  }
#line 616
  return (str);
}
}
#line 630 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_create_with_locker_sized(Locker *locker , size_t size , char const   *format 
                                     , ...) 
{ 
  String *str ;
  va_list args ;

  {
  {
#line 634
  __builtin_va_start(args, format);
#line 635
  str = str_vcreate_with_locker_sized(locker, size, format, args);
#line 636
  __builtin_va_end(args);
  }
#line 637
  return (str);
}
}
#line 651 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_vcreate_sized(size_t size , char const   *format , va_list args ) 
{ 
  String *tmp ;

  {
  {
#line 653
  tmp = str_vcreate_with_locker_sized((Locker *)((void *)0), size, format, args);
  }
#line 653
  return (tmp);
}
}
#line 671 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_vcreate_with_locker_sized(Locker *locker , size_t size , char const   *format ,
                                      va_list args ) 
{ 
  String *str ;
  char *buf ;
  ssize_t length ;
  unsigned int bit ;
  va_list args_copy ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp14 ;

  {
#line 674
  buf = (char *)((void *)0);
#line 679
  bit = 1U;
  {
#line 679
  while (1) {
    while_continue: /* CIL Label */ ;
#line 679
    if (! bit) {
#line 679
      goto while_break;
    }
#line 681
    if ((size_t )bit >= size) {
#line 683
      size = (size_t )bit;
#line 684
      goto while_break;
    }
#line 679
    bit <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 688
  if (! bit) {
    {
#line 689
    tmp = set_errnull(22);
    }
#line 689
    return ((String *)tmp);
  }
#line 691
  if (! format) {
#line 692
    format = "";
  }
  {
#line 694
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 696
    tmp___0 = mem_resize_fn((void **)(& buf), size * sizeof(*buf));
    }
#line 696
    if (! tmp___0) {
      {
#line 698
      free((void *)buf);
      }
#line 699
      return ((String *)((void *)0));
    }
    {
#line 703
    __builtin_va_copy(args_copy, args);
#line 704
    tmp___1 = vsnprintf((char */* __restrict  */)buf, size, (char const   */* __restrict  */)format,
                        args_copy);
#line 704
    length = (ssize_t )tmp___1;
#line 705
    __builtin_va_end(args_copy);
    }
#line 709
    if (length != -1L) {
#line 709
      if ((size_t )length < size) {
#line 710
        goto while_break___0;
      }
    }
#line 694
    size <<= 1;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 713
  tmp___2 = malloc(sizeof(String ));
#line 713
  str = (String *)tmp___2;
  }
#line 713
  if (! str) {
    {
#line 715
    free((void *)buf);
    }
#line 716
    return ((String *)((void *)0));
  }
#line 719
  str->size = size;
#line 720
  str->length = (size_t )(length + 1L);
#line 721
  str->str = buf;
#line 722
  str->locker = locker;
#line 724
  return (str);
}
}
#line 740 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_copy(String const   *str ) 
{ 
  String *tmp ;

  {
  {
#line 742
  tmp = str_copy_with_locker((Locker *)((void *)0), str);
  }
#line 742
  return (tmp);
}
}
#line 755 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_copy_unlocked(String const   *str ) 
{ 
  String *tmp ;

  {
  {
#line 757
  tmp = str_copy_with_locker_unlocked((Locker *)((void *)0), str);
  }
#line 757
  return (tmp);
}
}
#line 771 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_copy_with_locker(Locker *locker , String const   *str ) 
{ 
  String *tmp ;

  {
  {
#line 773
  tmp = str_substr_with_locker(locker, str, (ssize_t )0, (ssize_t )-1);
  }
#line 773
  return (tmp);
}
}
#line 787 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_copy_with_locker_unlocked(Locker *locker , String const   *str ) 
{ 
  String *tmp ;

  {
  {
#line 789
  tmp = str_substr_with_locker_unlocked(locker, str, (ssize_t )0, (ssize_t )-1);
  }
#line 789
  return (tmp);
}
}
#line 812 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_fgetline(FILE *stream ) 
{ 
  String *tmp ;

  {
  {
#line 814
  tmp = str_fgetline_with_locker((Locker *)((void *)0), stream);
  }
#line 814
  return (tmp);
}
}
#line 828 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_fgetline_with_locker(Locker *locker , FILE *stream ) 
{ 
  String *ret ;
  char buf[8192] ;
  String *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 830
  ret = (String *)((void *)0);
#line 833
  flockfile(stream);
  }
  {
#line 835
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 835
    tmp___1 = fgetline_unlocked(buf, (size_t )8192, stream);
    }
#line 835
    if (! tmp___1) {
#line 835
      goto while_break;
    }
#line 837
    if (! ret) {
      {
#line 839
      ret = str_create_with_locker(locker, "%s", buf);
      }
#line 839
      if (! ret) {
#line 840
        goto while_break;
      }
    } else {
      {
#line 842
      tmp = str_append(ret, "%s", buf);
      }
#line 842
      if (! tmp) {
        {
#line 844
        str_destroy(& ret);
        }
#line 845
        goto while_break;
      }
    }
    {
#line 848
    tmp___0 = cstr((String const   *)ret);
    }
#line 848
    if ((int )*(tmp___0 + (ret->length - 2UL)) == 10) {
#line 849
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 852
  funlockfile(stream);
  }
#line 853
  return (ret);
}
}
#line 866 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
void str_release(String *str ) 
{ 
  Locker *locker ;
  int tmp ;

  {
#line 870
  if (! str) {
#line 871
    return;
  }
  {
#line 873
  tmp = str_wrlock((String const   *)str);
  }
#line 873
  if (tmp) {
#line 874
    return;
  }
  {
#line 876
  locker = str->locker;
#line 877
  free((void *)str->str);
#line 878
  free((void *)str);
  }
#line 879
  if (locker) {
    {
#line 879
    (*(locker->unlock))(locker->lock);
    }
  }
#line 880
  return;
}
}
#line 894 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
void *str_destroy(String **str ) 
{ 


  {
#line 896
  if (str) {
#line 896
    if (*str) {
      {
#line 898
      str_release(*str);
#line 899
      *str = (String *)((void *)0);
      }
    }
  }
#line 902
  return ((void *)0);
}
}
#line 929 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int str_rdlock(String const   *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 931
  if (str) {
#line 931
    if (str->locker) {
      {
#line 931
      tmp = (*((str->locker)->rdlock))((str->locker)->lock);
#line 931
      tmp___0 = tmp;
      }
    } else {
#line 931
      tmp___0 = 0;
    }
#line 931
    tmp___1 = tmp___0;
  } else {
#line 931
    tmp___1 = 22;
  }
#line 931
  return (tmp___1);
}
}
#line 954 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int str_wrlock(String const   *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 956
  if (str) {
#line 956
    if (str->locker) {
      {
#line 956
      tmp = (*((str->locker)->wrlock))((str->locker)->lock);
#line 956
      tmp___0 = tmp;
      }
    } else {
#line 956
      tmp___0 = 0;
    }
#line 956
    tmp___1 = tmp___0;
  } else {
#line 956
    tmp___1 = 22;
  }
#line 956
  return (tmp___1);
}
}
#line 971 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int str_unlock(String const   *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 973
  if (str) {
#line 973
    if (str->locker) {
      {
#line 973
      tmp = (*((str->locker)->unlock))((str->locker)->lock);
#line 973
      tmp___0 = tmp;
      }
    } else {
#line 973
      tmp___0 = 0;
    }
#line 973
    tmp___1 = tmp___0;
  } else {
#line 973
    tmp___1 = 22;
  }
#line 973
  return (tmp___1);
}
}
#line 987 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int str_empty(String const   *str ) 
{ 
  int empty ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 992
  if (! str) {
    {
#line 993
    tmp = set_errno(22);
    }
#line 993
    return (tmp);
  }
#line 995
  if (str) {
#line 995
    if (str->locker) {
      {
#line 995
      tmp___1 = (*((str->locker)->rdlock))((str->locker)->lock);
#line 995
      tmp___2 = tmp___1;
      }
    } else {
#line 995
      tmp___2 = 0;
    }
#line 995
    err = tmp___2;
  } else {
#line 995
    err = 22;
  }
#line 995
  if (err) {
    {
#line 996
    tmp___0 = set_errno(err);
    }
#line 996
    return (tmp___0);
  }
  {
#line 998
  empty = str_empty_unlocked(str);
  }
#line 1000
  if (str) {
#line 1000
    if (str->locker) {
      {
#line 1000
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 1000
      tmp___5 = tmp___4;
      }
    } else {
#line 1000
      tmp___5 = 0;
    }
#line 1000
    err = tmp___5;
  } else {
#line 1000
    err = 22;
  }
#line 1000
  if (err) {
    {
#line 1001
    tmp___3 = set_errno(err);
    }
#line 1001
    return (tmp___3);
  }
#line 1003
  return (empty);
}
}
#line 1016 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int str_empty_unlocked(String const   *str ) 
{ 
  int tmp ;

  {
#line 1018
  if (! str) {
    {
#line 1019
    tmp = set_errno(22);
    }
#line 1019
    return (tmp);
  }
#line 1021
  return (str->length == 1UL);
}
}
#line 1035 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
ssize_t str_length(String const   *str ) 
{ 
  size_t length ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1040
  if (! str) {
    {
#line 1041
    tmp = set_errno(22);
    }
#line 1041
    return ((ssize_t )tmp);
  }
#line 1043
  if (str) {
#line 1043
    if (str->locker) {
      {
#line 1043
      tmp___1 = (*((str->locker)->rdlock))((str->locker)->lock);
#line 1043
      tmp___2 = tmp___1;
      }
    } else {
#line 1043
      tmp___2 = 0;
    }
#line 1043
    err = tmp___2;
  } else {
#line 1043
    err = 22;
  }
#line 1043
  if (err) {
    {
#line 1044
    tmp___0 = set_errno(err);
    }
#line 1044
    return ((ssize_t )tmp___0);
  }
  {
#line 1046
  tmp___3 = str_length_unlocked(str);
#line 1046
  length = (size_t )tmp___3;
  }
#line 1048
  if (str) {
#line 1048
    if (str->locker) {
      {
#line 1048
      tmp___5 = (*((str->locker)->unlock))((str->locker)->lock);
#line 1048
      tmp___6 = tmp___5;
      }
    } else {
#line 1048
      tmp___6 = 0;
    }
#line 1048
    err = tmp___6;
  } else {
#line 1048
    err = 22;
  }
#line 1048
  if (err) {
    {
#line 1049
    tmp___4 = set_errno(err);
    }
#line 1049
    return ((ssize_t )tmp___4);
  }
#line 1051
  return ((ssize_t )length);
}
}
#line 1063 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
ssize_t str_length_unlocked(String const   *str ) 
{ 
  int tmp ;

  {
#line 1065
  if (! str) {
    {
#line 1066
    tmp = set_errno(22);
    }
#line 1066
    return ((ssize_t )tmp);
  }
#line 1068
  return ((ssize_t )(str->length - 1UL));
}
}
#line 1086 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
char *cstr(String const   *str ) 
{ 
  void *tmp ;

  {
#line 1088
  if (! str) {
    {
#line 1089
    tmp = set_errnull(22);
    }
#line 1089
    return ((char *)tmp);
  }
#line 1091
  return ((char *)str->str);
}
}
#line 1107 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
ssize_t str_set_length(String *str , size_t length ) 
{ 
  ssize_t len ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1112
  if (! str) {
    {
#line 1113
    tmp = set_errno(22);
    }
#line 1113
    return ((ssize_t )tmp);
  }
#line 1115
  if (str) {
#line 1115
    if (str->locker) {
      {
#line 1115
      tmp___1 = (*((str->locker)->wrlock))((str->locker)->lock);
#line 1115
      tmp___2 = tmp___1;
      }
    } else {
#line 1115
      tmp___2 = 0;
    }
#line 1115
    err = tmp___2;
  } else {
#line 1115
    err = 22;
  }
#line 1115
  if (err) {
    {
#line 1116
    tmp___0 = set_errno(err);
    }
#line 1116
    return ((ssize_t )tmp___0);
  }
  {
#line 1118
  len = str_set_length_unlocked(str, length);
  }
#line 1120
  if (str) {
#line 1120
    if (str->locker) {
      {
#line 1120
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 1120
      tmp___5 = tmp___4;
      }
    } else {
#line 1120
      tmp___5 = 0;
    }
#line 1120
    err = tmp___5;
  } else {
#line 1120
    err = 22;
  }
#line 1120
  if (err) {
    {
#line 1121
    tmp___3 = set_errno(err);
    }
#line 1121
    return ((ssize_t )tmp___3);
  }
#line 1123
  return (len);
}
}
#line 1136 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
ssize_t str_set_length_unlocked(String *str , size_t length ) 
{ 
  int tmp ;

  {
#line 1138
  if (! str) {
    {
#line 1139
    tmp = set_errno(22);
    }
#line 1139
    return ((ssize_t )tmp);
  } else
#line 1138
  if (length >= str->length) {
    {
#line 1139
    tmp = set_errno(22);
    }
#line 1139
    return ((ssize_t )tmp);
  }
#line 1141
  str->length = length + 1UL;
#line 1142
  *(str->str + (str->length - 1UL)) = (char )'\000';
#line 1144
  return ((ssize_t )(str->length - 1UL));
}
}
#line 1161 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
ssize_t str_recalc_length(String *str ) 
{ 
  ssize_t len ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1166
  if (! str) {
    {
#line 1167
    tmp = set_errno(22);
    }
#line 1167
    return ((ssize_t )tmp);
  }
#line 1169
  if (str) {
#line 1169
    if (str->locker) {
      {
#line 1169
      tmp___1 = (*((str->locker)->wrlock))((str->locker)->lock);
#line 1169
      tmp___2 = tmp___1;
      }
    } else {
#line 1169
      tmp___2 = 0;
    }
#line 1169
    err = tmp___2;
  } else {
#line 1169
    err = 22;
  }
#line 1169
  if (err) {
    {
#line 1170
    tmp___0 = set_errno(err);
    }
#line 1170
    return ((ssize_t )tmp___0);
  }
  {
#line 1172
  len = str_recalc_length_unlocked(str);
  }
#line 1174
  if (str) {
#line 1174
    if (str->locker) {
      {
#line 1174
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 1174
      tmp___5 = tmp___4;
      }
    } else {
#line 1174
      tmp___5 = 0;
    }
#line 1174
    err = tmp___5;
  } else {
#line 1174
    err = 22;
  }
#line 1174
  if (err) {
    {
#line 1175
    tmp___3 = set_errno(err);
    }
#line 1175
    return ((ssize_t )tmp___3);
  }
#line 1177
  return (len);
}
}
#line 1191 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
ssize_t str_recalc_length_unlocked(String *str ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
#line 1193
  if (! str) {
    {
#line 1194
    tmp = set_errno(22);
    }
#line 1194
    return ((ssize_t )tmp);
  }
  {
#line 1196
  tmp___0 = strlen((char const   *)str->str);
#line 1196
  str->length = tmp___0 + 1UL;
  }
#line 1198
  return ((ssize_t )(str->length - 1UL));
}
}
#line 1212 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_clear(String *str ) 
{ 
  String *tmp ;

  {
  {
#line 1214
  tmp = str_remove_range(str, (ssize_t )0, (ssize_t )-1);
  }
#line 1214
  return (tmp);
}
}
#line 1227 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_clear_unlocked(String *str ) 
{ 
  String *tmp ;

  {
  {
#line 1229
  tmp = str_remove_range_unlocked(str, (ssize_t )0, (ssize_t )-1);
  }
#line 1229
  return (tmp);
}
}
#line 1246 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_remove(String *str , ssize_t index___0 ) 
{ 
  String *tmp ;

  {
  {
#line 1248
  tmp = str_remove_range(str, index___0, (ssize_t )1);
  }
#line 1248
  return (tmp);
}
}
#line 1261 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_remove_unlocked(String *str , ssize_t index___0 ) 
{ 
  String *tmp ;

  {
  {
#line 1263
  tmp = str_remove_range_unlocked(str, index___0, (ssize_t )1);
  }
#line 1263
  return (tmp);
}
}
#line 1280 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_remove_range(String *str , ssize_t index___0 , ssize_t range ) 
{ 
  String *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1285
  if (! str) {
    {
#line 1286
    tmp = set_errnull(22);
    }
#line 1286
    return ((String *)tmp);
  }
#line 1288
  if (str) {
#line 1288
    if (str->locker) {
      {
#line 1288
      tmp___1 = (*((str->locker)->wrlock))((str->locker)->lock);
#line 1288
      tmp___2 = tmp___1;
      }
    } else {
#line 1288
      tmp___2 = 0;
    }
#line 1288
    err = tmp___2;
  } else {
#line 1288
    err = 22;
  }
#line 1288
  if (err) {
    {
#line 1289
    tmp___0 = set_errnull(err);
    }
#line 1289
    return ((String *)tmp___0);
  }
  {
#line 1291
  ret = str_remove_range_unlocked(str, index___0, range);
  }
#line 1293
  if (str) {
#line 1293
    if (str->locker) {
      {
#line 1293
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 1293
      tmp___5 = tmp___4;
      }
    } else {
#line 1293
      tmp___5 = 0;
    }
#line 1293
    err = tmp___5;
  } else {
#line 1293
    err = 22;
  }
#line 1293
  if (err) {
    {
#line 1294
    tmp___3 = set_errnull(err);
    }
#line 1294
    return ((String *)tmp___3);
  }
#line 1296
  return (ret);
}
}
#line 1309 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_remove_range_unlocked(String *str , ssize_t index___0 , ssize_t range ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 1311
  if (! str) {
    {
#line 1312
    tmp = set_errnull(22);
    }
#line 1312
    return ((String *)tmp);
  }
#line 1314
  if (index___0 < 0L) {
#line 1315
    index___0 = (ssize_t )(str->length + (size_t )index___0);
  }
#line 1317
  if (index___0 < 0L) {
    {
#line 1318
    tmp___0 = set_errnull(22);
    }
#line 1318
    return ((String *)tmp___0);
  }
#line 1320
  if (range < 0L) {
#line 1321
    range = (ssize_t )((str->length + (size_t )range) - (size_t )index___0);
  }
#line 1323
  if (range < 0L) {
    {
#line 1324
    tmp___1 = set_errnull(22);
    }
#line 1324
    return ((String *)tmp___1);
  }
#line 1326
  if (str->length - 1UL < (size_t )(index___0 + range)) {
    {
#line 1327
    tmp___2 = set_errnull(22);
    }
#line 1327
    return ((String *)tmp___2);
  }
  {
#line 1329
  contract(str, index___0, (size_t )range);
  }
#line 1331
  return (str);
}
}
#line 1348 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_insert(String *str , ssize_t index___0 , char const   *format  , ...) 
{ 
  String *ret ;
  va_list args ;

  {
  {
#line 1352
  __builtin_va_start(args, format);
#line 1353
  ret = str_vinsert(str, index___0, format, args);
#line 1354
  __builtin_va_end(args);
  }
#line 1355
  return (ret);
}
}
#line 1368 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_insert_unlocked(String *str , ssize_t index___0 , char const   *format 
                            , ...) 
{ 
  String *ret ;
  va_list args ;

  {
  {
#line 1372
  __builtin_va_start(args, format);
#line 1373
  ret = str_vinsert_unlocked(str, index___0, format, args);
#line 1374
  __builtin_va_end(args);
  }
#line 1375
  return (ret);
}
}
#line 1389 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_vinsert(String *str , ssize_t index___0 , char const   *format , va_list args ) 
{ 
  String *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1394
  if (! str) {
    {
#line 1395
    tmp = set_errnull(22);
    }
#line 1395
    return ((String *)tmp);
  }
#line 1397
  if (str) {
#line 1397
    if (str->locker) {
      {
#line 1397
      tmp___1 = (*((str->locker)->wrlock))((str->locker)->lock);
#line 1397
      tmp___2 = tmp___1;
      }
    } else {
#line 1397
      tmp___2 = 0;
    }
#line 1397
    err = tmp___2;
  } else {
#line 1397
    err = 22;
  }
#line 1397
  if (err) {
    {
#line 1398
    tmp___0 = set_errnull(err);
    }
#line 1398
    return ((String *)tmp___0);
  }
  {
#line 1400
  ret = str_vinsert_unlocked(str, index___0, format, args);
  }
#line 1402
  if (str) {
#line 1402
    if (str->locker) {
      {
#line 1402
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 1402
      tmp___5 = tmp___4;
      }
    } else {
#line 1402
      tmp___5 = 0;
    }
#line 1402
    err = tmp___5;
  } else {
#line 1402
    err = 22;
  }
#line 1402
  if (err) {
    {
#line 1403
    tmp___3 = set_errnull(err);
    }
#line 1403
    return ((String *)tmp___3);
  }
#line 1405
  return (ret);
}
}
#line 1418 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_vinsert_unlocked(String *str , ssize_t index___0 , char const   *format ,
                             va_list args ) 
{ 
  String *tmp ;
  String *ret ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 1422
  if (! str) {
    {
#line 1423
    tmp___0 = set_errnull(22);
    }
#line 1423
    return ((String *)tmp___0);
  }
#line 1425
  if (index___0 < 0L) {
#line 1426
    index___0 = (ssize_t )(str->length + (size_t )index___0);
  }
#line 1428
  if (index___0 < 0L) {
    {
#line 1429
    tmp___1 = set_errnull(22);
    }
#line 1429
    return ((String *)tmp___1);
  }
#line 1431
  if (str->length - 1UL < (size_t )index___0) {
    {
#line 1432
    tmp___2 = set_errnull(22);
    }
#line 1432
    return ((String *)tmp___2);
  }
  {
#line 1434
  tmp = str_vcreate(format, args);
  }
#line 1434
  if (! tmp) {
#line 1435
    return ((String *)((void *)0));
  }
  {
#line 1437
  ret = str_insert_str_unlocked(str, index___0, (String const   *)tmp);
#line 1438
  str_release(tmp);
  }
#line 1440
  return (ret);
}
}
#line 1457 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_insert_str(String *str , ssize_t index___0 , String const   *src ) 
{ 
  String *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 1462
  if (! str) {
    {
#line 1463
    tmp = set_errnull(22);
    }
#line 1463
    return ((String *)tmp);
  } else
#line 1462
  if (! src) {
    {
#line 1463
    tmp = set_errnull(22);
    }
#line 1463
    return ((String *)tmp);
  }
#line 1465
  if (src) {
#line 1465
    if (src->locker) {
      {
#line 1465
      tmp___1 = (*((src->locker)->rdlock))((src->locker)->lock);
#line 1465
      tmp___2 = tmp___1;
      }
    } else {
#line 1465
      tmp___2 = 0;
    }
#line 1465
    err = tmp___2;
  } else {
#line 1465
    err = 22;
  }
#line 1465
  if (err) {
    {
#line 1466
    tmp___0 = set_errnull(err);
    }
#line 1466
    return ((String *)tmp___0);
  }
#line 1468
  if (str) {
#line 1468
    if (str->locker) {
      {
#line 1468
      tmp___4 = (*((str->locker)->wrlock))((str->locker)->lock);
#line 1468
      tmp___5 = tmp___4;
      }
    } else {
#line 1468
      tmp___5 = 0;
    }
#line 1468
    err = tmp___5;
  } else {
#line 1468
    err = 22;
  }
#line 1468
  if (err) {
#line 1470
    if (src) {
#line 1470
      if (src->locker) {
        {
#line 1470
        (*((src->locker)->unlock))((src->locker)->lock);
        }
      }
    }
    {
#line 1471
    tmp___3 = set_errnull(err);
    }
#line 1471
    return ((String *)tmp___3);
  }
  {
#line 1474
  ret = str_insert_str_unlocked(str, index___0, src);
  }
#line 1476
  if (str) {
#line 1476
    if (str->locker) {
      {
#line 1476
      tmp___7 = (*((str->locker)->unlock))((str->locker)->lock);
#line 1476
      tmp___8 = tmp___7;
      }
    } else {
#line 1476
      tmp___8 = 0;
    }
#line 1476
    err = tmp___8;
  } else {
#line 1476
    err = 22;
  }
#line 1476
  if (err) {
#line 1478
    if (src) {
#line 1478
      if (src->locker) {
        {
#line 1478
        (*((src->locker)->unlock))((src->locker)->lock);
        }
      }
    }
    {
#line 1479
    tmp___6 = set_errnull(err);
    }
#line 1479
    return ((String *)tmp___6);
  }
#line 1482
  if (src) {
#line 1482
    if (src->locker) {
      {
#line 1482
      tmp___10 = (*((src->locker)->unlock))((src->locker)->lock);
#line 1482
      tmp___11 = tmp___10;
      }
    } else {
#line 1482
      tmp___11 = 0;
    }
#line 1482
    err = tmp___11;
  } else {
#line 1482
    err = 22;
  }
#line 1482
  if (err) {
    {
#line 1483
    tmp___9 = set_errnull(err);
    }
#line 1483
    return ((String *)tmp___9);
  }
#line 1485
  return (ret);
}
}
#line 1501 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_insert_str_unlocked(String *str , ssize_t index___0 , String const   *src ) 
{ 
  size_t length ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1505
  if (! str) {
    {
#line 1506
    tmp = set_errnull(22);
    }
#line 1506
    return ((String *)tmp);
  } else
#line 1505
  if (! src) {
    {
#line 1506
    tmp = set_errnull(22);
    }
#line 1506
    return ((String *)tmp);
  }
#line 1508
  if (index___0 < 0L) {
#line 1509
    index___0 = (ssize_t )(str->length + (size_t )index___0);
  }
#line 1511
  if (index___0 < 0L) {
    {
#line 1512
    tmp___0 = set_errnull(22);
    }
#line 1512
    return ((String *)tmp___0);
  }
#line 1514
  if (str->length - 1UL < (size_t )index___0) {
    {
#line 1515
    tmp___1 = set_errnull(22);
    }
#line 1515
    return ((String *)tmp___1);
  }
  {
#line 1517
  length = (size_t )(src->length - 1UL);
#line 1519
  tmp___2 = expand(str, index___0, length);
  }
#line 1519
  if (tmp___2 == -1) {
#line 1520
    return ((String *)((void *)0));
  }
  {
#line 1522
  memcpy((void */* __restrict  */)(str->str + index___0), (void const   */* __restrict  */)src->str,
         length);
  }
#line 1524
  return (str);
}
}
#line 1538 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_append(String *str , char const   *format  , ...) 
{ 
  String *ret ;
  va_list args ;

  {
  {
#line 1542
  __builtin_va_start(args, format);
#line 1543
  ret = str_vinsert(str, (ssize_t )-1, format, args);
#line 1544
  __builtin_va_end(args);
  }
#line 1545
  return (ret);
}
}
#line 1558 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_append_unlocked(String *str , char const   *format  , ...) 
{ 
  String *ret ;
  va_list args ;

  {
  {
#line 1562
  __builtin_va_start(args, format);
#line 1563
  ret = str_vinsert_unlocked(str, (ssize_t )-1, format, args);
#line 1564
  __builtin_va_end(args);
  }
#line 1565
  return (ret);
}
}
#line 1579 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_vappend(String *str , char const   *format , va_list args ) 
{ 
  String *tmp ;

  {
  {
#line 1581
  tmp = str_vinsert(str, (ssize_t )-1, format, args);
  }
#line 1581
  return (tmp);
}
}
#line 1594 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_vappend_unlocked(String *str , char const   *format , va_list args ) 
{ 
  String *tmp ;

  {
  {
#line 1596
  tmp = str_vinsert_unlocked(str, (ssize_t )-1, format, args);
  }
#line 1596
  return (tmp);
}
}
#line 1610 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_append_str(String *str , String const   *src ) 
{ 
  String *tmp ;

  {
  {
#line 1612
  tmp = str_insert_str(str, (ssize_t )-1, src);
  }
#line 1612
  return (tmp);
}
}
#line 1628 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_append_str_unlocked(String *str , String const   *src ) 
{ 
  String *tmp ;

  {
  {
#line 1630
  tmp = str_insert_str_unlocked(str, (ssize_t )-1, src);
  }
#line 1630
  return (tmp);
}
}
#line 1644 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_prepend(String *str , char const   *format  , ...) 
{ 
  String *ret ;
  va_list args ;

  {
  {
#line 1648
  __builtin_va_start(args, format);
#line 1649
  ret = str_vinsert(str, (ssize_t )0, format, args);
#line 1650
  __builtin_va_end(args);
  }
#line 1651
  return (ret);
}
}
#line 1664 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_prepend_unlocked(String *str , char const   *format  , ...) 
{ 
  String *ret ;
  va_list args ;

  {
  {
#line 1668
  __builtin_va_start(args, format);
#line 1669
  ret = str_vinsert_unlocked(str, (ssize_t )0, format, args);
#line 1670
  __builtin_va_end(args);
  }
#line 1671
  return (ret);
}
}
#line 1685 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_vprepend(String *str , char const   *format , va_list args ) 
{ 
  String *tmp ;

  {
  {
#line 1687
  tmp = str_vinsert(str, (ssize_t )0, format, args);
  }
#line 1687
  return (tmp);
}
}
#line 1700 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_vprepend_unlocked(String *str , char const   *format , va_list args ) 
{ 
  String *tmp ;

  {
  {
#line 1702
  tmp = str_vinsert_unlocked(str, (ssize_t )0, format, args);
  }
#line 1702
  return (tmp);
}
}
#line 1716 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_prepend_str(String *str , String const   *src ) 
{ 
  String *tmp ;

  {
  {
#line 1718
  tmp = str_insert_str(str, (ssize_t )0, src);
  }
#line 1718
  return (tmp);
}
}
#line 1734 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_prepend_str_unlocked(String *str , String const   *src ) 
{ 
  String *tmp ;

  {
  {
#line 1736
  tmp = str_insert_str_unlocked(str, (ssize_t )0, src);
  }
#line 1736
  return (tmp);
}
}
#line 1754 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_replace(String *str , ssize_t index___0 , ssize_t range , char const   *format 
                    , ...) 
{ 
  String *ret ;
  va_list args ;

  {
  {
#line 1758
  __builtin_va_start(args, format);
#line 1759
  ret = str_vreplace(str, index___0, range, format, args);
#line 1760
  __builtin_va_end(args);
  }
#line 1761
  return (ret);
}
}
#line 1774 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_replace_unlocked(String *str , ssize_t index___0 , ssize_t range , char const   *format 
                             , ...) 
{ 
  String *ret ;
  va_list args ;

  {
  {
#line 1778
  __builtin_va_start(args, format);
#line 1779
  ret = str_vreplace_unlocked(str, index___0, range, format, args);
#line 1780
  __builtin_va_end(args);
  }
#line 1781
  return (ret);
}
}
#line 1795 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_vreplace(String *str , ssize_t index___0 , ssize_t range , char const   *format ,
                     va_list args ) 
{ 
  String *tmp ;
  String *ret ;
  void *tmp___0 ;

  {
#line 1799
  if (! str) {
    {
#line 1800
    tmp___0 = set_errnull(22);
    }
#line 1800
    return ((String *)tmp___0);
  }
  {
#line 1802
  tmp = str_vcreate(format, args);
  }
#line 1802
  if (! tmp) {
#line 1803
    return ((String *)((void *)0));
  }
  {
#line 1805
  ret = str_replace_str(str, index___0, range, (String const   *)tmp);
#line 1806
  str_release(tmp);
  }
#line 1808
  return (ret);
}
}
#line 1821 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_vreplace_unlocked(String *str , ssize_t index___0 , ssize_t range , char const   *format ,
                              va_list args ) 
{ 
  String *tmp ;
  String *ret ;
  void *tmp___0 ;

  {
#line 1825
  if (! str) {
    {
#line 1826
    tmp___0 = set_errnull(22);
    }
#line 1826
    return ((String *)tmp___0);
  }
  {
#line 1828
  tmp = str_vcreate(format, args);
  }
#line 1828
  if (! tmp) {
#line 1829
    return ((String *)((void *)0));
  }
  {
#line 1831
  ret = str_replace_str_unlocked(str, index___0, range, (String const   *)tmp);
#line 1832
  str_release(tmp);
  }
#line 1834
  return (ret);
}
}
#line 1852 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_replace_str(String *str , ssize_t index___0 , ssize_t range , String const   *src ) 
{ 
  String *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 1857
  if (! src) {
    {
#line 1858
    tmp = set_errnull(22);
    }
#line 1858
    return ((String *)tmp);
  } else
#line 1857
  if (! str) {
    {
#line 1858
    tmp = set_errnull(22);
    }
#line 1858
    return ((String *)tmp);
  }
#line 1860
  if (src) {
#line 1860
    if (src->locker) {
      {
#line 1860
      tmp___1 = (*((src->locker)->rdlock))((src->locker)->lock);
#line 1860
      tmp___2 = tmp___1;
      }
    } else {
#line 1860
      tmp___2 = 0;
    }
#line 1860
    err = tmp___2;
  } else {
#line 1860
    err = 22;
  }
#line 1860
  if (err) {
    {
#line 1861
    tmp___0 = set_errnull(err);
    }
#line 1861
    return ((String *)tmp___0);
  }
#line 1863
  if (str) {
#line 1863
    if (str->locker) {
      {
#line 1863
      tmp___4 = (*((str->locker)->wrlock))((str->locker)->lock);
#line 1863
      tmp___5 = tmp___4;
      }
    } else {
#line 1863
      tmp___5 = 0;
    }
#line 1863
    err = tmp___5;
  } else {
#line 1863
    err = 22;
  }
#line 1863
  if (err) {
#line 1865
    if (src) {
#line 1865
      if (src->locker) {
        {
#line 1865
        (*((src->locker)->unlock))((src->locker)->lock);
        }
      }
    }
    {
#line 1866
    tmp___3 = set_errnull(err);
    }
#line 1866
    return ((String *)tmp___3);
  }
  {
#line 1869
  ret = str_replace_str_unlocked(str, index___0, range, src);
  }
#line 1871
  if (str) {
#line 1871
    if (str->locker) {
      {
#line 1871
      tmp___7 = (*((str->locker)->unlock))((str->locker)->lock);
#line 1871
      tmp___8 = tmp___7;
      }
    } else {
#line 1871
      tmp___8 = 0;
    }
#line 1871
    err = tmp___8;
  } else {
#line 1871
    err = 22;
  }
#line 1871
  if (err) {
#line 1873
    if (src) {
#line 1873
      if (src->locker) {
        {
#line 1873
        (*((src->locker)->unlock))((src->locker)->lock);
        }
      }
    }
    {
#line 1874
    tmp___6 = set_errnull(err);
    }
#line 1874
    return ((String *)tmp___6);
  }
#line 1877
  if (src) {
#line 1877
    if (src->locker) {
      {
#line 1877
      tmp___10 = (*((src->locker)->unlock))((src->locker)->lock);
#line 1877
      tmp___11 = tmp___10;
      }
    } else {
#line 1877
      tmp___11 = 0;
    }
#line 1877
    err = tmp___11;
  } else {
#line 1877
    err = 22;
  }
#line 1877
  if (err) {
    {
#line 1878
    tmp___9 = set_errnull(err);
    }
#line 1878
    return ((String *)tmp___9);
  }
#line 1880
  return (ret);
}
}
#line 1896 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_replace_str_unlocked(String *str , ssize_t index___0 , ssize_t range ,
                                 String const   *src ) 
{ 
  size_t length ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 1900
  if (! src) {
    {
#line 1901
    tmp = set_errnull(22);
    }
#line 1901
    return ((String *)tmp);
  } else
#line 1900
  if (! str) {
    {
#line 1901
    tmp = set_errnull(22);
    }
#line 1901
    return ((String *)tmp);
  }
#line 1903
  if (index___0 < 0L) {
#line 1904
    index___0 = (ssize_t )(str->length + (size_t )index___0);
  }
#line 1906
  if (index___0 < 0L) {
    {
#line 1907
    tmp___0 = set_errnull(22);
    }
#line 1907
    return ((String *)tmp___0);
  }
#line 1909
  if (range < 0L) {
#line 1910
    range = (ssize_t )((str->length + (size_t )range) - (size_t )index___0);
  }
#line 1912
  if (range < 0L) {
    {
#line 1913
    tmp___1 = set_errnull(22);
    }
#line 1913
    return ((String *)tmp___1);
  }
#line 1915
  if (str->length - 1UL < (size_t )(index___0 + range)) {
    {
#line 1916
    tmp___2 = set_errnull(22);
    }
#line 1916
    return ((String *)tmp___2);
  }
  {
#line 1918
  length = (size_t )(src->length - 1UL);
#line 1920
  tmp___3 = adjust(str, index___0, (size_t )range, length);
  }
#line 1920
  if (tmp___3 == -1) {
#line 1921
    return ((String *)((void *)0));
  }
  {
#line 1923
  memcpy((void */* __restrict  */)(str->str + index___0), (void const   */* __restrict  */)src->str,
         length);
  }
#line 1925
  return (str);
}
}
#line 1945 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_substr(String const   *str , ssize_t index___0 , ssize_t range ) 
{ 
  String *tmp ;

  {
  {
#line 1947
  tmp = str_substr_with_locker((Locker *)((void *)0), str, index___0, range);
  }
#line 1947
  return (tmp);
}
}
#line 1960 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_substr_unlocked(String const   *str , ssize_t index___0 , ssize_t range ) 
{ 
  String *tmp ;

  {
  {
#line 1962
  tmp = str_substr_with_locker_unlocked((Locker *)((void *)0), str, index___0, range);
  }
#line 1962
  return (tmp);
}
}
#line 1976 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_substr_with_locker(Locker *locker , String const   *str , ssize_t index___0 ,
                               ssize_t range ) 
{ 
  String *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1981
  if (! str) {
    {
#line 1982
    tmp = set_errnull(22);
    }
#line 1982
    return ((String *)tmp);
  }
#line 1984
  if (str) {
#line 1984
    if (str->locker) {
      {
#line 1984
      tmp___1 = (*((str->locker)->rdlock))((str->locker)->lock);
#line 1984
      tmp___2 = tmp___1;
      }
    } else {
#line 1984
      tmp___2 = 0;
    }
#line 1984
    err = tmp___2;
  } else {
#line 1984
    err = 22;
  }
#line 1984
  if (err) {
    {
#line 1985
    tmp___0 = set_errnull(err);
    }
#line 1985
    return ((String *)tmp___0);
  }
  {
#line 1987
  ret = str_substr_with_locker_unlocked(locker, str, index___0, range);
  }
#line 1989
  if (str) {
#line 1989
    if (str->locker) {
      {
#line 1989
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 1989
      tmp___5 = tmp___4;
      }
    } else {
#line 1989
      tmp___5 = 0;
    }
#line 1989
    err = tmp___5;
  } else {
#line 1989
    err = 22;
  }
#line 1989
  if (err) {
    {
#line 1990
    tmp___3 = set_errnull(err);
    }
#line 1990
    return ((String *)tmp___3);
  }
#line 1992
  return (ret);
}
}
#line 2006 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_substr_with_locker_unlocked(Locker *locker , String const   *str , ssize_t index___0 ,
                                        ssize_t range ) 
{ 
  String *ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 2010
  if (! str) {
    {
#line 2011
    tmp = set_errnull(22);
    }
#line 2011
    return ((String *)tmp);
  }
#line 2013
  if (index___0 < 0L) {
#line 2014
    index___0 = (ssize_t )(str->length + (size_t const   )index___0);
  }
#line 2016
  if (index___0 < 0L) {
    {
#line 2017
    tmp___0 = set_errnull(22);
    }
#line 2017
    return ((String *)tmp___0);
  }
#line 2019
  if (range < 0L) {
#line 2020
    range = (ssize_t )((str->length + (size_t const   )range) - (size_t const   )index___0);
  }
#line 2022
  if (range < 0L) {
    {
#line 2023
    tmp___1 = set_errnull(22);
    }
#line 2023
    return ((String *)tmp___1);
  }
#line 2025
  if (str->length - 1UL < (size_t const   )(index___0 + range)) {
    {
#line 2026
    tmp___2 = set_errnull(22);
    }
#line 2026
    return ((String *)tmp___2);
  }
  {
#line 2028
  ret = str_create_with_locker_sized(locker, (size_t )(range + 1L), (char const   *)((void *)0));
  }
#line 2028
  if (! ret) {
#line 2029
    return ((String *)((void *)0));
  }
  {
#line 2031
  memcpy((void */* __restrict  */)ret->str, (void const   */* __restrict  */)(str->str + index___0),
         (size_t )range);
#line 2032
  ret->length = (size_t )(range + 1L);
#line 2033
  *(ret->str + (ret->length - 1UL)) = (char )'\000';
  }
#line 2035
  return (ret);
}
}
#line 2048 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *substr(char const   *str , ssize_t index___0 , ssize_t range ) 
{ 
  String *tmp ;

  {
  {
#line 2050
  tmp = substr_with_locker((Locker *)((void *)0), str, index___0, range);
  }
#line 2050
  return (tmp);
}
}
#line 2065 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *substr_with_locker(Locker *locker , char const   *str , ssize_t index___0 ,
                           ssize_t range ) 
{ 
  String *ret ;
  size_t len ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 2068
  len = (size_t )0;
#line 2070
  if (! str) {
    {
#line 2071
    tmp = set_errnull(22);
    }
#line 2071
    return ((String *)tmp);
  }
#line 2073
  if (index___0 < 0L) {
    {
#line 2074
    tmp___0 = strlen(str);
#line 2074
    len = tmp___0 + 1UL;
    }
  } else
#line 2073
  if (range < 0L) {
    {
#line 2074
    tmp___0 = strlen(str);
#line 2074
    len = tmp___0 + 1UL;
    }
  }
#line 2076
  if (index___0 < 0L) {
#line 2077
    index___0 = (ssize_t )(len + (size_t )index___0);
  }
#line 2079
  if (index___0 < 0L) {
    {
#line 2080
    tmp___1 = set_errnull(22);
    }
#line 2080
    return ((String *)tmp___1);
  }
#line 2082
  if (range < 0L) {
#line 2083
    range = (ssize_t )((len + (size_t )range) - (size_t )index___0);
  }
#line 2085
  if (range < 0L) {
    {
#line 2086
    tmp___2 = set_errnull(22);
    }
#line 2086
    return ((String *)tmp___2);
  }
  {
#line 2088
  ret = str_create_with_locker_sized(locker, (size_t )(range + 1L), (char const   *)((void *)0));
  }
#line 2088
  if (! ret) {
#line 2089
    return ((String *)((void *)0));
  }
  {
#line 2091
  memcpy((void */* __restrict  */)ret->str, (void const   */* __restrict  */)(str + index___0),
         (size_t )range);
#line 2092
  ret->length = (size_t )(range + 1L);
#line 2093
  *(ret->str + (ret->length - 1UL)) = (char )'\000';
  }
#line 2095
  return (ret);
}
}
#line 2114 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_splice(String *str , ssize_t index___0 , ssize_t range ) 
{ 
  String *tmp ;

  {
  {
#line 2116
  tmp = str_splice_with_locker((Locker *)((void *)0), str, index___0, range);
  }
#line 2116
  return (tmp);
}
}
#line 2129 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_splice_unlocked(String *str , ssize_t index___0 , ssize_t range ) 
{ 
  String *tmp ;

  {
  {
#line 2131
  tmp = str_splice_with_locker_unlocked((Locker *)((void *)0), str, index___0, range);
  }
#line 2131
  return (tmp);
}
}
#line 2145 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_splice_with_locker(Locker *locker , String *str , ssize_t index___0 ,
                               ssize_t range ) 
{ 
  String *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 2150
  if (! str) {
    {
#line 2151
    tmp = set_errnull(22);
    }
#line 2151
    return ((String *)tmp);
  }
#line 2153
  if (str) {
#line 2153
    if (str->locker) {
      {
#line 2153
      tmp___1 = (*((str->locker)->wrlock))((str->locker)->lock);
#line 2153
      tmp___2 = tmp___1;
      }
    } else {
#line 2153
      tmp___2 = 0;
    }
#line 2153
    err = tmp___2;
  } else {
#line 2153
    err = 22;
  }
#line 2153
  if (err) {
    {
#line 2154
    tmp___0 = set_errnull(err);
    }
#line 2154
    return ((String *)tmp___0);
  }
  {
#line 2156
  ret = str_splice_with_locker_unlocked(locker, str, index___0, range);
  }
#line 2158
  if (str) {
#line 2158
    if (str->locker) {
      {
#line 2158
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 2158
      tmp___5 = tmp___4;
      }
    } else {
#line 2158
      tmp___5 = 0;
    }
#line 2158
    err = tmp___5;
  } else {
#line 2158
    err = 22;
  }
#line 2158
  if (err) {
    {
#line 2160
    str_release(ret);
#line 2161
    tmp___3 = set_errnull(err);
    }
#line 2161
    return ((String *)tmp___3);
  }
#line 2164
  return (ret);
}
}
#line 2178 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_splice_with_locker_unlocked(Locker *locker , String *str , ssize_t index___0 ,
                                        ssize_t range ) 
{ 
  String *ret ;
  void *tmp ;
  String *tmp___0 ;

  {
#line 2182
  if (! str) {
    {
#line 2183
    tmp = set_errnull(22);
    }
#line 2183
    return ((String *)tmp);
  }
  {
#line 2185
  ret = str_substr_with_locker_unlocked(locker, (String const   *)str, index___0,
                                        range);
  }
#line 2185
  if (! ret) {
#line 2186
    return ((String *)((void *)0));
  }
  {
#line 2188
  tmp___0 = str_remove_range_unlocked(str, index___0, range);
  }
#line 2188
  if (! tmp___0) {
    {
#line 2190
    str_release(ret);
    }
#line 2191
    return ((String *)((void *)0));
  }
#line 2194
  return (ret);
}
}
#line 2211 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_repeat(size_t count , char const   *format  , ...) 
{ 
  String *ret ;
  va_list args ;

  {
  {
#line 2215
  __builtin_va_start(args, format);
#line 2216
  ret = str_vrepeat_with_locker((Locker *)((void *)0), count, format, args);
#line 2217
  __builtin_va_end(args);
  }
#line 2218
  return (ret);
}
}
#line 2232 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_repeat_with_locker(Locker *locker , size_t count , char const   *format 
                               , ...) 
{ 
  String *ret ;
  va_list args ;

  {
  {
#line 2236
  __builtin_va_start(args, format);
#line 2237
  ret = str_vrepeat_with_locker(locker, count, format, args);
#line 2238
  __builtin_va_end(args);
  }
#line 2239
  return (ret);
}
}
#line 2253 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_vrepeat(size_t count , char const   *format , va_list args ) 
{ 
  String *tmp ;

  {
  {
#line 2255
  tmp = str_vrepeat_with_locker((Locker *)((void *)0), count, format, args);
  }
#line 2255
  return (tmp);
}
}
#line 2269 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_vrepeat_with_locker(Locker *locker , size_t count , char const   *format ,
                                va_list args ) 
{ 
  String *tmp ;
  String *ret ;
  ssize_t length ;
  size_t i ;
  String *tmp___0 ;

  {
  {
#line 2275
  tmp = str_vcreate(format, args);
  }
#line 2275
  if (! tmp) {
#line 2276
    return ((String *)((void *)0));
  }
  {
#line 2278
  length = str_length((String const   *)tmp);
  }
#line 2278
  if (length == -1L) {
#line 2279
    return ((String *)((void *)0));
  }
  {
#line 2281
  ret = str_create_with_locker_sized(locker, (size_t )length * count + 1UL, (char const   *)((void *)0));
  }
#line 2281
  if (! ret) {
    {
#line 2283
    str_release(tmp);
    }
#line 2284
    return ((String *)((void *)0));
  }
#line 2287
  i = (size_t )0;
  {
#line 2287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2287
    if (! (i < count)) {
#line 2287
      goto while_break;
    }
    {
#line 2289
    tmp___0 = str_append_str(ret, (String const   *)tmp);
    }
#line 2289
    if (! tmp___0) {
      {
#line 2291
      str_release(tmp);
#line 2292
      str_release(ret);
      }
#line 2293
      return ((String *)((void *)0));
    }
#line 2287
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2297
  str_release(tmp);
  }
#line 2299
  return (ret);
}
}
#line 2369
static StringTR *tr_compile_table(StringTR *table , char const   *from , char const   *to ,
                                  int option ) ;
#line 2371 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int str_tr(String *str , char const   *from , char const   *to , int option ) 
{ 
  StringTR table[1] ;
  int tmp ;
  StringTR *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp9 ;

  {
#line 2375
  if (! str) {
    {
#line 2376
    tmp = set_errno(22);
    }
#line 2376
    return (tmp);
  } else
#line 2375
  if (! from) {
    {
#line 2376
    tmp = set_errno(22);
    }
#line 2376
    return (tmp);
  }
  {
#line 2378
  table[0].locker = (Locker *)((void *)0);
#line 2380
  tmp___0 = tr_compile_table(table, from, to, option);
  }
#line 2380
  if (! tmp___0) {
#line 2381
    return (-1);
  }
  {
#line 2383
  tmp___1 = str_tr_compiled(str, table);
  }
#line 2383
  return (tmp___1);
}
}
#line 2396 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int str_tr_unlocked(String *str , char const   *from , char const   *to , int option ) 
{ 
  StringTR table[1] ;
  int tmp ;
  StringTR *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp9 ;

  {
#line 2400
  if (! str) {
    {
#line 2401
    tmp = set_errno(22);
    }
#line 2401
    return (tmp);
  } else
#line 2400
  if (! from) {
    {
#line 2401
    tmp = set_errno(22);
    }
#line 2401
    return (tmp);
  }
  {
#line 2403
  table[0].locker = (Locker *)((void *)0);
#line 2405
  tmp___0 = tr_compile_table(table, from, to, option);
  }
#line 2405
  if (! tmp___0) {
#line 2406
    return (-1);
  }
  {
#line 2408
  tmp___1 = str_tr_compiled_unlocked(str, table);
  }
#line 2408
  return (tmp___1);
}
}
#line 2423
static StringTR *str_tr_compile_table(StringTR *table , String const   *from , String const   *to ,
                                      int option ) ;
#line 2425 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int str_tr_str(String *str , String const   *from , String const   *to , int option ) 
{ 
  StringTR table[1] ;
  int tmp ;
  StringTR *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp9 ;

  {
#line 2429
  if (! str) {
    {
#line 2430
    tmp = set_errno(22);
    }
#line 2430
    return (tmp);
  } else
#line 2429
  if (! from) {
    {
#line 2430
    tmp = set_errno(22);
    }
#line 2430
    return (tmp);
  }
  {
#line 2432
  table[0].locker = (Locker *)((void *)0);
#line 2434
  tmp___0 = str_tr_compile_table(table, from, to, option);
  }
#line 2434
  if (! tmp___0) {
#line 2435
    return (-1);
  }
  {
#line 2437
  tmp___1 = str_tr_compiled(str, table);
  }
#line 2437
  return (tmp___1);
}
}
#line 2453
static StringTR *str_tr_compile_table_unlocked(StringTR *table , String const   *from ,
                                               String const   *to , int option ) ;
#line 2455 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int str_tr_str_unlocked(String *str , String const   *from , String const   *to ,
                        int option ) 
{ 
  StringTR table[1] ;
  int tmp ;
  StringTR *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp9 ;

  {
#line 2459
  if (! str) {
    {
#line 2460
    tmp = set_errno(22);
    }
#line 2460
    return (tmp);
  } else
#line 2459
  if (! from) {
    {
#line 2460
    tmp = set_errno(22);
    }
#line 2460
    return (tmp);
  }
  {
#line 2462
  table[0].locker = (Locker *)((void *)0);
#line 2464
  tmp___0 = str_tr_compile_table_unlocked(table, from, to, option);
  }
#line 2464
  if (! tmp___0) {
#line 2465
    return (-1);
  }
  {
#line 2467
  tmp___1 = str_tr_compiled_unlocked(str, table);
  }
#line 2467
  return (tmp___1);
}
}
#line 2480 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int tr(char *str , char const   *from , char const   *to , int option ) 
{ 
  StringTR table[1] ;
  int tmp ;
  StringTR *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp9 ;

  {
#line 2484
  if (! str) {
    {
#line 2485
    tmp = set_errno(22);
    }
#line 2485
    return (tmp);
  } else
#line 2484
  if (! from) {
    {
#line 2485
    tmp = set_errno(22);
    }
#line 2485
    return (tmp);
  }
  {
#line 2487
  table[0].locker = (Locker *)((void *)0);
#line 2489
  tmp___0 = tr_compile_table(table, from, to, option);
  }
#line 2489
  if (! tmp___0) {
#line 2490
    return (-1);
  }
  {
#line 2492
  tmp___1 = tr_compiled(str, table);
  }
#line 2492
  return (tmp___1);
}
}
#line 2509 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
StringTR *tr_compile(char const   *from , char const   *to , int option ) 
{ 
  StringTR *tmp ;

  {
  {
#line 2511
  tmp = tr_compile_with_locker((Locker *)((void *)0), from, to, option);
  }
#line 2511
  return (tmp);
}
}
#line 2525 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
StringTR *tr_compile_with_locker(Locker *locker , char const   *from , char const   *to ,
                                 int option ) 
{ 
  StringTR *ret ;
  void *tmp ;
  StringTR *tmp___0 ;
  void *__cil_tmp8 ;

  {
  {
#line 2529
  tmp = malloc(sizeof(StringTR ));
#line 2529
  ret = (StringTR *)tmp;
  }
#line 2529
  if (! ret) {
#line 2530
    return ((StringTR *)((void *)0));
  }
  {
#line 2532
  ret->locker = locker;
#line 2534
  tmp___0 = tr_compile_table(ret, from, to, option);
  }
#line 2534
  return (tmp___0);
}
}
#line 2549 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
StringTR *str_tr_compile(String const   *from , String const   *to , int option ) 
{ 
  StringTR *tmp ;

  {
  {
#line 2551
  tmp = str_tr_compile_with_locker((Locker *)((void *)0), from, to, option);
  }
#line 2551
  return (tmp);
}
}
#line 2565 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
StringTR *str_tr_compile_unlocked(String const   *from , String const   *to , int option ) 
{ 
  StringTR *tmp ;

  {
  {
#line 2567
  tmp = str_tr_compile_with_locker_unlocked((Locker *)((void *)0), from, to, option);
  }
#line 2567
  return (tmp);
}
}
#line 2581 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
StringTR *str_tr_compile_with_locker(Locker *locker , String const   *from , String const   *to ,
                                     int option ) 
{ 
  StringTR *ret ;
  void *tmp ;
  StringTR *tmp___0 ;
  void *__cil_tmp8 ;

  {
  {
#line 2585
  tmp = malloc(sizeof(StringTR ));
#line 2585
  ret = (StringTR *)tmp;
  }
#line 2585
  if (! ret) {
#line 2586
    return ((StringTR *)((void *)0));
  }
  {
#line 2588
  ret->locker = locker;
#line 2590
  tmp___0 = str_tr_compile_table(ret, from, to, option);
  }
#line 2590
  return (tmp___0);
}
}
#line 2606 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
StringTR *str_tr_compile_with_locker_unlocked(Locker *locker , String const   *from ,
                                              String const   *to , int option ) 
{ 
  StringTR *ret ;
  void *tmp ;
  StringTR *tmp___0 ;
  void *__cil_tmp8 ;

  {
  {
#line 2610
  tmp = malloc(sizeof(StringTR ));
#line 2610
  ret = (StringTR *)tmp;
  }
#line 2610
  if (! ret) {
#line 2611
    return ((StringTR *)((void *)0));
  }
  {
#line 2613
  ret->locker = locker;
#line 2615
  tmp___0 = str_tr_compile_table_unlocked(ret, from, to, option);
  }
#line 2615
  return (tmp___0);
}
}
#line 2628 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
void tr_release(StringTR *table ) 
{ 
  Locker *locker ;
  int tmp ;
  int tmp___0 ;

  {
#line 2632
  if (! table) {
#line 2633
    return;
  }
#line 2635
  locker = table->locker;
#line 2636
  if (locker) {
    {
#line 2636
    tmp = (*(locker->wrlock))(locker->lock);
#line 2636
    tmp___0 = tmp;
    }
  } else {
#line 2636
    tmp___0 = 0;
  }
#line 2636
  if (tmp___0) {
#line 2637
    return;
  }
  {
#line 2639
  free((void *)table);
  }
#line 2640
  if (locker) {
    {
#line 2640
    (*(locker->unlock))(locker->lock);
    }
  }
#line 2641
  return;
}
}
#line 2655 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
void *tr_destroy(StringTR **table ) 
{ 


  {
#line 2657
  if (table) {
#line 2657
    if (*table) {
      {
#line 2659
      tr_release(*table);
#line 2660
      *table = (StringTR *)((void *)0);
      }
    }
  }
#line 2663
  return ((void *)0);
}
}
#line 2680 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
static StringTR *do_tr_compile_table(StringTR *table , char const   *from , ssize_t fromlen ,
                                     char const   *to , ssize_t tolen , int option ) 
{ 
  char const   *f ;
  char const   *t ;
  char *xf ;
  char *xt ;
  char xfrom[256] ;
  char xto[256] ;
  short tbl[256] ;
  int i ;
  int j ;
  int k ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  short tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  char tmp___5[256] ;
  char *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  size_t flen ;
  size_t tlen ;
  void *tmp___12 ;
  int tmp___13 ;
  unsigned char fc ;
  unsigned char tc ;
  void *tmp___14 ;
  int tmp___15 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
#line 2689
  if (! table) {
    {
#line 2690
    tmp = set_errnull(22);
    }
#line 2690
    return ((StringTR *)tmp);
  } else
#line 2689
  if (! from) {
    {
#line 2690
    tmp = set_errnull(22);
    }
#line 2690
    return ((StringTR *)tmp);
  }
#line 2692
  i = 0;
  {
#line 2692
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2692
    if (! (i < 256)) {
#line 2692
      goto while_break;
    }
#line 2693
    tbl[i] = (short)-1;
#line 2692
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2697
  xf = xfrom;
#line 2697
  f = from;
  {
#line 2697
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2697
    if (fromlen == -1L) {
#line 2697
      tmp___3 = (int const   )*f;
    } else {
#line 2697
      tmp___3 = (int const   )(f - from < fromlen);
    }
#line 2697
    if (tmp___3) {
#line 2697
      if (! (xf - xfrom < 256L)) {
#line 2697
        goto while_break___0;
      }
    } else {
#line 2697
      goto while_break___0;
    }
#line 2699
    j = (int )*f;
#line 2699
    i = j;
#line 2701
    if ((int const   )*(f + 1) == 45) {
#line 2701
      if (*(f + 2)) {
#line 2702
        j = (int )*(f + 2);
#line 2702
        f += 2;
      }
    }
#line 2704
    if ((int )((unsigned char )j) < (int )((unsigned char )i)) {
      {
#line 2705
      tmp___0 = set_errnull(22);
      }
#line 2705
      return ((StringTR *)tmp___0);
    }
#line 2707
    k = (int )((unsigned char )i);
    {
#line 2707
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2707
      if (! (k <= (int )((unsigned char )j))) {
#line 2707
        goto while_break___1;
      }
#line 2708
      tmp___1 = xf;
#line 2708
      xf ++;
#line 2708
      tmp___2 = (short )k;
#line 2708
      tbl[k] = tmp___2;
#line 2708
      *tmp___1 = (char )tmp___2;
#line 2707
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2697
    f ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2711
  if (xf - xfrom == 256L) {
    {
#line 2712
    tmp___4 = set_errnull(22);
    }
#line 2712
    return ((StringTR *)tmp___4);
  }
#line 2714
  if (option & 1) {
#line 2718
    xf = tmp___5;
#line 2718
    k = 0;
    {
#line 2718
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2718
      if (! (k < 256)) {
#line 2718
        goto while_break___2;
      }
#line 2719
      if ((int )tbl[k] == -1) {
#line 2720
        tmp___6 = xf;
#line 2720
        xf ++;
#line 2720
        *tmp___6 = (char )k;
      }
#line 2718
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 2722
    memcpy((void */* __restrict  */)(xfrom), (void const   */* __restrict  */)(tmp___5),
           (size_t )(xf - tmp___5));
#line 2723
    xf = xfrom + (xf - tmp___5);
    }
  }
#line 2728
  if (! to) {
#line 2728
    goto _L;
  } else {
#line 2728
    if (tolen == -1L) {
#line 2728
      tmp___7 = (int const   )*to == 0;
    } else {
#line 2728
      tmp___7 = tolen == 0L;
    }
#line 2728
    if (tmp___7) {
      _L: /* CIL Label */ 
#line 2729
      if (option & 2) {
#line 2729
        to = "";
      } else {
#line 2729
        to = from;
      }
    }
  }
#line 2731
  xt = xto;
#line 2731
  t = to;
  {
#line 2731
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2731
    if (tolen == -1L) {
#line 2731
      tmp___10 = (int const   )*t;
    } else {
#line 2731
      tmp___10 = (int const   )(t - to < tolen);
    }
#line 2731
    if (tmp___10) {
#line 2731
      if (! (xt - xto < 256L)) {
#line 2731
        goto while_break___3;
      }
    } else {
#line 2731
      goto while_break___3;
    }
#line 2733
    j = (int )*t;
#line 2733
    i = j;
#line 2735
    if ((int const   )*(t + 1) == 45) {
#line 2735
      if (*(t + 2)) {
#line 2736
        j = (int )*(t + 2);
#line 2736
        t += 2;
      }
    }
#line 2738
    if ((int )((unsigned char )j) < (int )((unsigned char )i)) {
      {
#line 2739
      tmp___8 = set_errnull(22);
      }
#line 2739
      return ((StringTR *)tmp___8);
    }
#line 2741
    k = (int )((unsigned char )i);
    {
#line 2741
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2741
      if (! (k <= (int )((unsigned char )j))) {
#line 2741
        goto while_break___4;
      }
#line 2742
      tmp___9 = xt;
#line 2742
      xt ++;
#line 2742
      *tmp___9 = (char )k;
#line 2741
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2731
    t ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2745
  if (xt - xto == 256L) {
    {
#line 2746
    tmp___11 = set_errnull(22);
    }
#line 2746
    return ((StringTR *)tmp___11);
  }
#line 2748
  if (! (option & 2)) {
#line 2750
    flen = (size_t )(xf - xfrom);
#line 2751
    tlen = (size_t )(xt - xto);
#line 2753
    if (tlen < flen) {
      {
#line 2755
      memset((void *)xt, (int )*(xt + -1), flen - tlen);
#line 2756
      xt += flen - tlen;
      }
    }
  }
#line 2762
  if (table->locker) {
    {
#line 2762
    tmp___13 = (*((table->locker)->wrlock))((table->locker)->lock);
#line 2762
    err = tmp___13;
    }
  } else {
#line 2762
    err = 0;
  }
#line 2762
  if (err) {
    {
#line 2763
    tmp___12 = set_errnull(err);
    }
#line 2763
    return ((StringTR *)tmp___12);
  }
#line 2765
  table->squash = option & 4;
#line 2766
  i = 0;
  {
#line 2766
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2766
    if (! (i < 256)) {
#line 2766
      goto while_break___5;
    }
#line 2767
    table->table[i] = (short)-1;
#line 2766
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2769
  j = 0;
#line 2769
  i = j;
  {
#line 2769
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 2769
    if (! ((unsigned long )(xfrom + i) < (unsigned long )xf)) {
#line 2769
      goto while_break___6;
    }
#line 2771
    fc = (unsigned char )xfrom[i];
#line 2772
    tc = (unsigned char )xto[j];
#line 2773
    if ((int )table->table[fc] == -1) {
#line 2774
      if ((unsigned long )(xto + j) < (unsigned long )xt) {
#line 2774
        table->table[fc] = (short )tc;
      } else {
#line 2774
        table->table[fc] = (short)-2;
      }
    }
#line 2769
    i ++;
#line 2769
    j ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 2777
  if (table->locker) {
    {
#line 2777
    tmp___15 = (*((table->locker)->unlock))((table->locker)->lock);
#line 2777
    err = tmp___15;
    }
  } else {
#line 2777
    err = 0;
  }
#line 2777
  if (err) {
    {
#line 2778
    tmp___14 = set_errnull(err);
    }
#line 2778
    return ((StringTR *)tmp___14);
  }
#line 2780
  return (table);
}
}
#line 2793 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
static StringTR *tr_compile_table(StringTR *table , char const   *from , char const   *to ,
                                  int option ) 
{ 
  StringTR *tmp ;

  {
  {
#line 2795
  tmp = do_tr_compile_table(table, from, (ssize_t )-1, to, (ssize_t )-1, option);
  }
#line 2795
  return (tmp);
}
}
#line 2808 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
static StringTR *str_tr_compile_table(StringTR *table , String const   *from , String const   *to ,
                                      int option ) 
{ 
  StringTR *ret ;
  int err ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 2813
  if (from) {
#line 2813
    if (from->locker) {
      {
#line 2813
      tmp___0 = (*((from->locker)->rdlock))((from->locker)->lock);
#line 2813
      tmp___1 = tmp___0;
      }
    } else {
#line 2813
      tmp___1 = 0;
    }
#line 2813
    err = tmp___1;
  } else {
#line 2813
    err = 22;
  }
#line 2813
  if (err) {
    {
#line 2814
    tmp = set_errnull(err);
    }
#line 2814
    return ((StringTR *)tmp);
  }
#line 2816
  if (to) {
#line 2816
    if (to->locker) {
      {
#line 2816
      tmp___3 = (*((to->locker)->rdlock))((to->locker)->lock);
#line 2816
      tmp___4 = tmp___3;
      }
    } else {
#line 2816
      tmp___4 = 0;
    }
#line 2816
    err = tmp___4;
  } else {
#line 2816
    err = 22;
  }
#line 2816
  if (err) {
#line 2818
    if (from) {
#line 2818
      if (from->locker) {
        {
#line 2818
        (*((from->locker)->unlock))((from->locker)->lock);
        }
      }
    }
    {
#line 2819
    tmp___2 = set_errnull(err);
    }
#line 2819
    return ((StringTR *)tmp___2);
  }
  {
#line 2822
  ret = str_tr_compile_table_unlocked(table, from, to, option);
  }
#line 2824
  if (from) {
#line 2824
    if (from->locker) {
      {
#line 2824
      tmp___6 = (*((from->locker)->unlock))((from->locker)->lock);
#line 2824
      tmp___7 = tmp___6;
      }
    } else {
#line 2824
      tmp___7 = 0;
    }
#line 2824
    err = tmp___7;
  } else {
#line 2824
    err = 22;
  }
#line 2824
  if (err) {
#line 2826
    if (to) {
#line 2826
      if (to->locker) {
        {
#line 2826
        (*((to->locker)->unlock))((to->locker)->lock);
        }
      }
    }
    {
#line 2827
    tmp___5 = set_errnull(err);
    }
#line 2827
    return ((StringTR *)tmp___5);
  }
#line 2830
  if (to) {
#line 2830
    if (to->locker) {
      {
#line 2830
      tmp___9 = (*((to->locker)->unlock))((to->locker)->lock);
#line 2830
      tmp___10 = tmp___9;
      }
    } else {
#line 2830
      tmp___10 = 0;
    }
#line 2830
    err = tmp___10;
  } else {
#line 2830
    err = 22;
  }
#line 2830
  if (err) {
    {
#line 2831
    tmp___8 = set_errnull(err);
    }
#line 2831
    return ((StringTR *)tmp___8);
  }
#line 2833
  return (ret);
}
}
#line 2845 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
static StringTR *str_tr_compile_table_unlocked(StringTR *table , String const   *from ,
                                               String const   *to , int option ) 
{ 
  ssize_t tmp ;
  ssize_t tmp___0 ;
  StringTR *tmp___1 ;

  {
  {
#line 2847
  tmp = str_length_unlocked(to);
#line 2847
  tmp___0 = str_length_unlocked(from);
#line 2847
  tmp___1 = do_tr_compile_table(table, (char const   *)from->str, tmp___0, (char const   *)to->str,
                                tmp, option);
  }
#line 2847
  return (tmp___1);
}
}
#line 2866 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
static int do_tr_compiled(unsigned char *str , size_t *length , StringTR *table ) 
{ 
  int ret ;
  int deleted ;
  unsigned char *r ;
  unsigned char *s ;
  short t ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 2868
  ret = 0;
#line 2869
  deleted = 0;
#line 2874
  if (! str) {
    {
#line 2875
    tmp = set_errno(22);
    }
#line 2875
    return (tmp);
  } else
#line 2874
  if (! table) {
    {
#line 2875
    tmp = set_errno(22);
    }
#line 2875
    return (tmp);
  }
#line 2877
  if (table->locker) {
    {
#line 2877
    tmp___1 = (*((table->locker)->rdlock))((table->locker)->lock);
#line 2877
    err = tmp___1;
    }
  } else {
#line 2877
    err = 0;
  }
#line 2877
  if (err) {
    {
#line 2878
    tmp___0 = set_errno(err);
    }
#line 2878
    return (tmp___0);
  }
#line 2880
  s = str;
#line 2880
  r = s;
  {
#line 2880
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2880
    if (length) {
#line 2880
      tmp___4 = (size_t )(s - str) < *length - 1UL;
    } else {
#line 2880
      tmp___4 = (int )*s;
    }
#line 2880
    if (! tmp___4) {
#line 2880
      goto while_break;
    }
#line 2882
    t = table->table[(int )*s];
    {
#line 2884
    if ((int )t == -2) {
#line 2884
      goto case_neg_2;
    }
#line 2889
    if ((int )t == -1) {
#line 2889
      goto case_neg_1;
    }
#line 2896
    goto switch_default;
    case_neg_2: /* CIL Label */ 
#line 2885
    deleted ++;
#line 2886
    ret ++;
#line 2887
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 2890
    if (! table->squash) {
#line 2891
      tmp___2 = r;
#line 2891
      r ++;
#line 2891
      *tmp___2 = *s;
    } else
#line 2890
    if ((unsigned long )r == (unsigned long )str) {
#line 2891
      tmp___2 = r;
#line 2891
      r ++;
#line 2891
      *tmp___2 = *s;
    } else
#line 2890
    if ((int )*(r + -1) != (int )*s) {
#line 2891
      tmp___2 = r;
#line 2891
      r ++;
#line 2891
      *tmp___2 = *s;
    } else {
#line 2893
      deleted ++;
    }
#line 2894
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2897
    if (! table->squash) {
#line 2898
      tmp___3 = r;
#line 2898
      r ++;
#line 2898
      *tmp___3 = (unsigned char )t;
    } else
#line 2897
    if ((unsigned long )r == (unsigned long )str) {
#line 2898
      tmp___3 = r;
#line 2898
      r ++;
#line 2898
      *tmp___3 = (unsigned char )t;
    } else
#line 2897
    if ((int )*(r + -1) != (int )t) {
#line 2898
      tmp___3 = r;
#line 2898
      r ++;
#line 2898
      *tmp___3 = (unsigned char )t;
    } else {
#line 2900
      deleted ++;
    }
#line 2901
    ret ++;
#line 2902
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2880
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2906
  if (table->locker) {
    {
#line 2906
    tmp___6 = (*((table->locker)->unlock))((table->locker)->lock);
#line 2906
    err = tmp___6;
    }
  } else {
#line 2906
    err = 0;
  }
#line 2906
  if (err) {
    {
#line 2907
    tmp___5 = set_errno(err);
    }
#line 2907
    return (tmp___5);
  }
#line 2909
  *r = (unsigned char )'\000';
#line 2910
  if (length) {
#line 2910
    if (deleted) {
#line 2911
      *length -= (size_t )deleted;
    }
  }
#line 2913
  return (ret);
}
}
#line 2930 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int str_tr_compiled(String *str , StringTR *table ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 2935
  if (! str) {
    {
#line 2936
    tmp = set_errno(22);
    }
#line 2936
    return (tmp);
  } else
#line 2935
  if (! table) {
    {
#line 2936
    tmp = set_errno(22);
    }
#line 2936
    return (tmp);
  }
#line 2938
  if (table->locker) {
    {
#line 2938
    tmp___1 = (*((table->locker)->rdlock))((table->locker)->lock);
#line 2938
    err = tmp___1;
    }
  } else {
#line 2938
    err = 0;
  }
#line 2938
  if (err) {
    {
#line 2939
    tmp___0 = set_errno(err);
    }
#line 2939
    return (tmp___0);
  }
#line 2941
  if (str) {
#line 2941
    if (str->locker) {
      {
#line 2941
      tmp___3 = (*((str->locker)->wrlock))((str->locker)->lock);
#line 2941
      tmp___4 = tmp___3;
      }
    } else {
#line 2941
      tmp___4 = 0;
    }
#line 2941
    err = tmp___4;
  } else {
#line 2941
    err = 22;
  }
#line 2941
  if (err) {
#line 2943
    if (table->locker) {
      {
#line 2943
      (*((table->locker)->unlock))((table->locker)->lock);
      }
    }
    {
#line 2944
    tmp___2 = set_errno(err);
    }
#line 2944
    return (tmp___2);
  }
  {
#line 2947
  ret = str_tr_compiled_unlocked(str, table);
  }
#line 2949
  if (str) {
#line 2949
    if (str->locker) {
      {
#line 2949
      tmp___6 = (*((str->locker)->unlock))((str->locker)->lock);
#line 2949
      tmp___7 = tmp___6;
      }
    } else {
#line 2949
      tmp___7 = 0;
    }
#line 2949
    err = tmp___7;
  } else {
#line 2949
    err = 22;
  }
#line 2949
  if (err) {
#line 2951
    if (table->locker) {
      {
#line 2951
      (*((table->locker)->unlock))((table->locker)->lock);
      }
    }
    {
#line 2952
    tmp___5 = set_errno(err);
    }
#line 2952
    return (tmp___5);
  }
#line 2955
  if (table->locker) {
    {
#line 2955
    tmp___9 = (*((table->locker)->unlock))((table->locker)->lock);
#line 2955
    err = tmp___9;
    }
  } else {
#line 2955
    err = 0;
  }
#line 2955
  if (err) {
    {
#line 2956
    tmp___8 = set_errno(err);
    }
#line 2956
    return (tmp___8);
  }
#line 2958
  return (ret);
}
}
#line 2971 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int str_tr_compiled_unlocked(String *str , StringTR *table ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2973
  if (! str) {
    {
#line 2974
    tmp = set_errno(22);
    }
#line 2974
    return (tmp);
  } else
#line 2973
  if (! table) {
    {
#line 2974
    tmp = set_errno(22);
    }
#line 2974
    return (tmp);
  }
  {
#line 2976
  tmp___0 = do_tr_compiled((unsigned char *)str->str, & str->length, table);
  }
#line 2976
  return (tmp___0);
}
}
#line 2989 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int tr_compiled(char *str , StringTR *table ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2994
  if (! str) {
    {
#line 2995
    tmp = set_errno(22);
    }
#line 2995
    return (tmp);
  } else
#line 2994
  if (! table) {
    {
#line 2995
    tmp = set_errno(22);
    }
#line 2995
    return (tmp);
  }
#line 2997
  if (table->locker) {
    {
#line 2997
    tmp___1 = (*((table->locker)->rdlock))((table->locker)->lock);
#line 2997
    err = tmp___1;
    }
  } else {
#line 2997
    err = 0;
  }
#line 2997
  if (err) {
    {
#line 2998
    tmp___0 = set_errno(err);
    }
#line 2998
    return (tmp___0);
  }
  {
#line 3000
  ret = do_tr_compiled((unsigned char *)str, (size_t *)((void *)0), table);
  }
#line 3002
  if (table->locker) {
    {
#line 3002
    tmp___3 = (*((table->locker)->unlock))((table->locker)->lock);
#line 3002
    err = tmp___3;
    }
  } else {
#line 3002
    err = 0;
  }
#line 3002
  if (err) {
    {
#line 3003
    tmp___2 = set_errno(err);
    }
#line 3003
    return (tmp___2);
  }
#line 3005
  return (ret);
}
}
#line 3035 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *str_regexpr(char const   *pattern , String const   *text , int cflags , int eflags ) 
{ 
  List *tmp ;

  {
  {
#line 3037
  tmp = str_regexpr_with_locker((Locker *)((void *)0), pattern, text, cflags, eflags);
  }
#line 3037
  return (tmp);
}
}
#line 3050 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *str_regexpr_unlocked(char const   *pattern , String const   *text , int cflags ,
                           int eflags ) 
{ 
  List *tmp ;

  {
  {
#line 3052
  tmp = str_regexpr_with_locker_unlocked((Locker *)((void *)0), pattern, text, cflags,
                                         eflags);
  }
#line 3052
  return (tmp);
}
}
#line 3066 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *str_regexpr_with_locker(Locker *locker , char const   *pattern , String const   *text ,
                              int cflags , int eflags ) 
{ 
  List *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 3071
  if (! pattern) {
    {
#line 3072
    tmp = set_errnull(22);
    }
#line 3072
    return ((List *)tmp);
  } else
#line 3071
  if (! text) {
    {
#line 3072
    tmp = set_errnull(22);
    }
#line 3072
    return ((List *)tmp);
  }
#line 3074
  if (text) {
#line 3074
    if (text->locker) {
      {
#line 3074
      tmp___1 = (*((text->locker)->rdlock))((text->locker)->lock);
#line 3074
      tmp___2 = tmp___1;
      }
    } else {
#line 3074
      tmp___2 = 0;
    }
#line 3074
    err = tmp___2;
  } else {
#line 3074
    err = 22;
  }
#line 3074
  if (err) {
    {
#line 3075
    tmp___0 = set_errnull(err);
    }
#line 3075
    return ((List *)tmp___0);
  }
  {
#line 3077
  ret = str_regexpr_with_locker_unlocked(locker, pattern, text, cflags, eflags);
  }
#line 3079
  if (text) {
#line 3079
    if (text->locker) {
      {
#line 3079
      tmp___4 = (*((text->locker)->unlock))((text->locker)->lock);
#line 3079
      tmp___5 = tmp___4;
      }
    } else {
#line 3079
      tmp___5 = 0;
    }
#line 3079
    err = tmp___5;
  } else {
#line 3079
    err = 22;
  }
#line 3079
  if (err) {
    {
#line 3081
    list_release(ret);
#line 3082
    tmp___3 = set_errnull(err);
    }
#line 3082
    return ((List *)tmp___3);
  }
#line 3085
  return (ret);
}
}
#line 3099 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *str_regexpr_with_locker_unlocked(Locker *locker , char const   *pattern , String const   *text ,
                                       int cflags , int eflags ) 
{ 
  void *tmp ;
  List *tmp___0 ;

  {
#line 3101
  if (! pattern) {
    {
#line 3102
    tmp = set_errnull(22);
    }
#line 3102
    return ((List *)tmp);
  } else
#line 3101
  if (! text) {
    {
#line 3102
    tmp = set_errnull(22);
    }
#line 3102
    return ((List *)tmp);
  }
  {
#line 3104
  tmp___0 = regexpr_with_locker(locker, pattern, (char const   *)text->str, cflags,
                                eflags);
  }
#line 3104
  return (tmp___0);
}
}
#line 3117 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *regexpr(char const   *pattern , char const   *text , int cflags , int eflags ) 
{ 
  List *tmp ;

  {
  {
#line 3119
  tmp = regexpr_with_locker((Locker *)((void *)0), pattern, text, cflags, eflags);
  }
#line 3119
  return (tmp);
}
}
#line 3133 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *regexpr_with_locker(Locker *locker , char const   *pattern , char const   *text ,
                          int cflags , int eflags ) 
{ 
  regex_t compiled[1] ;
  List *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  void *__cil_tmp11 ;

  {
#line 3139
  if (! pattern) {
    {
#line 3140
    tmp = set_errnull(22);
    }
#line 3140
    return ((List *)tmp);
  } else
#line 3139
  if (! text) {
    {
#line 3140
    tmp = set_errnull(22);
    }
#line 3140
    return ((List *)tmp);
  }
  {
#line 3142
  err = regexpr_compile(compiled, pattern, cflags);
  }
#line 3142
  if (err) {
    {
#line 3143
    tmp___0 = set_errnull(err);
    }
#line 3143
    return ((List *)tmp___0);
  }
  {
#line 3145
  ret = regexpr_compiled_with_locker(locker, (regex_t const   *)(compiled), text,
                                     eflags);
#line 3146
  regfree(compiled);
  }
#line 3148
  return (ret);
}
}
#line 3166 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int regexpr_compile(regex_t *compiled , char const   *pattern , int cflags ) 
{ 
  int tmp ;

  {
#line 3168
  if (! compiled) {
#line 3169
    return (2);
  } else
#line 3168
  if (! pattern) {
#line 3169
    return (2);
  }
  {
#line 3171
  tmp = regcomp((regex_t */* __restrict  */)compiled, (char const   */* __restrict  */)pattern,
                cflags | 1);
  }
#line 3171
  return (tmp);
}
}
#line 3184 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
void regexpr_release(regex_t *compiled ) 
{ 


  {
#line 3186
  if (compiled) {
    {
#line 3187
    regfree(compiled);
    }
  }
#line 3188
  return;
}
}
#line 3208 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *str_regexpr_compiled(regex_t const   *compiled , String const   *text , int eflags ) 
{ 
  List *tmp ;

  {
  {
#line 3210
  tmp = str_regexpr_compiled_with_locker((Locker *)((void *)0), compiled, text, eflags);
  }
#line 3210
  return (tmp);
}
}
#line 3224 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *str_regexpr_compiled_unlocked(regex_t const   *compiled , String const   *text ,
                                    int eflags ) 
{ 
  List *tmp ;

  {
  {
#line 3226
  tmp = str_regexpr_compiled_with_locker_unlocked((Locker *)((void *)0), compiled,
                                                  text, eflags);
  }
#line 3226
  return (tmp);
}
}
#line 3240 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *str_regexpr_compiled_with_locker(Locker *locker , regex_t const   *compiled ,
                                       String const   *text , int eflags ) 
{ 
  List *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 3245
  if (! compiled) {
    {
#line 3246
    tmp = set_errnull(22);
    }
#line 3246
    return ((List *)tmp);
  } else
#line 3245
  if (! text) {
    {
#line 3246
    tmp = set_errnull(22);
    }
#line 3246
    return ((List *)tmp);
  }
#line 3248
  if (text) {
#line 3248
    if (text->locker) {
      {
#line 3248
      tmp___1 = (*((text->locker)->rdlock))((text->locker)->lock);
#line 3248
      tmp___2 = tmp___1;
      }
    } else {
#line 3248
      tmp___2 = 0;
    }
#line 3248
    err = tmp___2;
  } else {
#line 3248
    err = 22;
  }
#line 3248
  if (err) {
    {
#line 3249
    tmp___0 = set_errnull(err);
    }
#line 3249
    return ((List *)tmp___0);
  }
  {
#line 3251
  ret = str_regexpr_compiled_with_locker_unlocked(locker, compiled, text, eflags);
  }
#line 3253
  if (text) {
#line 3253
    if (text->locker) {
      {
#line 3253
      tmp___4 = (*((text->locker)->unlock))((text->locker)->lock);
#line 3253
      tmp___5 = tmp___4;
      }
    } else {
#line 3253
      tmp___5 = 0;
    }
#line 3253
    err = tmp___5;
  } else {
#line 3253
    err = 22;
  }
#line 3253
  if (err) {
    {
#line 3255
    list_release(ret);
#line 3256
    tmp___3 = set_errnull(err);
    }
#line 3256
    return ((List *)tmp___3);
  }
#line 3259
  return (ret);
}
}
#line 3273 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *str_regexpr_compiled_with_locker_unlocked(Locker *locker , regex_t const   *compiled ,
                                                String const   *text , int eflags ) 
{ 
  void *tmp ;
  List *tmp___0 ;

  {
#line 3275
  if (! compiled) {
    {
#line 3276
    tmp = set_errnull(22);
    }
#line 3276
    return ((List *)tmp);
  } else
#line 3275
  if (! text) {
    {
#line 3276
    tmp = set_errnull(22);
    }
#line 3276
    return ((List *)tmp);
  }
  {
#line 3278
  tmp___0 = regexpr_compiled_with_locker(locker, compiled, (char const   *)text->str,
                                         eflags);
  }
#line 3278
  return (tmp___0);
}
}
#line 3291 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *regexpr_compiled(regex_t const   *compiled , char const   *text , int eflags ) 
{ 
  List *tmp ;

  {
  {
#line 3293
  tmp = regexpr_compiled_with_locker((Locker *)((void *)0), compiled, text, eflags);
  }
#line 3293
  return (tmp);
}
}
#line 3307 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *regexpr_compiled_with_locker(Locker *locker , regex_t const   *compiled , char const   *text ,
                                   int eflags ) 
{ 
  regmatch_t match[33] ;
  List *ret ;
  int i ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  String *m ;
  String *tmp___1 ;
  List *tmp___2 ;
  void *__cil_tmp14 ;

  {
#line 3314
  if (! compiled) {
    {
#line 3315
    tmp = set_errnull(22);
    }
#line 3315
    return ((List *)tmp);
  } else
#line 3314
  if (! text) {
    {
#line 3315
    tmp = set_errnull(22);
    }
#line 3315
    return ((List *)tmp);
  }
  {
#line 3317
  err = regexec((regex_t const   */* __restrict  */)compiled, (char const   */* __restrict  */)text,
                (size_t )33, (regmatch_t */* __restrict  */)(match), eflags);
  }
#line 3317
  if (err) {
    {
#line 3318
    tmp___0 = set_errnull(err);
    }
#line 3318
    return ((List *)tmp___0);
  }
  {
#line 3320
  ret = list_create_with_locker(locker, (list_release_t *)(& str_release));
  }
#line 3320
  if (! ret) {
#line 3321
    return ((List *)((void *)0));
  }
#line 3323
  i = 0;
  {
#line 3323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3323
    if (i < 33) {
#line 3323
      if (! (match[i].rm_so != -1)) {
#line 3323
        goto while_break;
      }
    } else {
#line 3323
      goto while_break;
    }
    {
#line 3325
    tmp___1 = substr(text, (ssize_t )match[i].rm_so, (ssize_t )(match[i].rm_eo - match[i].rm_so));
#line 3325
    m = tmp___1;
    }
#line 3327
    if (! m) {
      {
#line 3329
      list_release(ret);
      }
#line 3330
      return ((List *)((void *)0));
    }
    {
#line 3333
    tmp___2 = list_append(ret, (void *)m);
    }
#line 3333
    if (! tmp___2) {
      {
#line 3335
      str_release(m);
#line 3336
      list_release(ret);
      }
#line 3337
      return ((List *)((void *)0));
    }
#line 3323
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3341
  return (ret);
}
}
#line 3382 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_regsub(char const   *pattern , char const   *replacement , String *text ,
                   int cflags , int eflags , int all ) 
{ 
  regex_t compiled[1] ;
  String *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  void *__cil_tmp12 ;

  {
#line 3388
  if (! pattern) {
    {
#line 3389
    tmp = set_errnull(22);
    }
#line 3389
    return ((String *)tmp);
  } else
#line 3388
  if (! replacement) {
    {
#line 3389
    tmp = set_errnull(22);
    }
#line 3389
    return ((String *)tmp);
  } else
#line 3388
  if (! text) {
    {
#line 3389
    tmp = set_errnull(22);
    }
#line 3389
    return ((String *)tmp);
  }
  {
#line 3391
  err = regexpr_compile(compiled, pattern, cflags);
  }
#line 3391
  if (err) {
    {
#line 3392
    tmp___0 = set_errnull(err);
    }
#line 3392
    return ((String *)tmp___0);
  }
  {
#line 3394
  ret = str_regsub_compiled((regex_t const   *)(compiled), replacement, text, eflags,
                            all);
#line 3395
  regfree(compiled);
  }
#line 3397
  return (ret);
}
}
#line 3410 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_regsub_unlocked(char const   *pattern , char const   *replacement , String *text ,
                            int cflags , int eflags , int all ) 
{ 
  regex_t compiled[1] ;
  String *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  void *__cil_tmp12 ;

  {
#line 3416
  if (! pattern) {
    {
#line 3417
    tmp = set_errnull(22);
    }
#line 3417
    return ((String *)tmp);
  } else
#line 3416
  if (! replacement) {
    {
#line 3417
    tmp = set_errnull(22);
    }
#line 3417
    return ((String *)tmp);
  } else
#line 3416
  if (! text) {
    {
#line 3417
    tmp = set_errnull(22);
    }
#line 3417
    return ((String *)tmp);
  }
  {
#line 3419
  err = regexpr_compile(compiled, pattern, cflags);
  }
#line 3419
  if (err) {
    {
#line 3420
    tmp___0 = set_errnull(err);
    }
#line 3420
    return ((String *)tmp___0);
  }
  {
#line 3422
  ret = str_regsub_compiled_unlocked((regex_t const   *)(compiled), replacement, text,
                                     eflags, all);
#line 3423
  regfree(compiled);
  }
#line 3425
  return (ret);
}
}
#line 3439 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_regsub_compiled(regex_t const   *compiled , char const   *replacement ,
                            String *text , int eflags , int all ) 
{ 
  String *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 3444
  if (! compiled) {
    {
#line 3445
    tmp = set_errnull(22);
    }
#line 3445
    return ((String *)tmp);
  } else
#line 3444
  if (! replacement) {
    {
#line 3445
    tmp = set_errnull(22);
    }
#line 3445
    return ((String *)tmp);
  } else
#line 3444
  if (! text) {
    {
#line 3445
    tmp = set_errnull(22);
    }
#line 3445
    return ((String *)tmp);
  }
#line 3447
  if (text) {
#line 3447
    if (text->locker) {
      {
#line 3447
      tmp___1 = (*((text->locker)->wrlock))((text->locker)->lock);
#line 3447
      tmp___2 = tmp___1;
      }
    } else {
#line 3447
      tmp___2 = 0;
    }
#line 3447
    err = tmp___2;
  } else {
#line 3447
    err = 22;
  }
#line 3447
  if (err) {
    {
#line 3448
    tmp___0 = set_errnull(err);
    }
#line 3448
    return ((String *)tmp___0);
  }
  {
#line 3450
  ret = str_regsub_compiled_unlocked(compiled, replacement, text, eflags, all);
  }
#line 3452
  if (text) {
#line 3452
    if (text->locker) {
      {
#line 3452
      tmp___4 = (*((text->locker)->unlock))((text->locker)->lock);
#line 3452
      tmp___5 = tmp___4;
      }
    } else {
#line 3452
      tmp___5 = 0;
    }
#line 3452
    err = tmp___5;
  } else {
#line 3452
    err = 22;
  }
#line 3452
  if (err) {
    {
#line 3453
    tmp___3 = set_errnull(err);
    }
#line 3453
    return ((String *)tmp___3);
  }
#line 3455
  return (ret);
}
}
#line 3469 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_regsub_compiled_unlocked(regex_t const   *compiled , char const   *replacement ,
                                     String *text , int eflags , int all ) 
{ 
  regmatch_t match[33] ;
  String *rep ;
  int matches ;
  size_t start ;
  int states[33] ;
  int i ;
  int s ;
  void *tmp ;
  String *tmp___0 ;
  int tmp___1 ;
  String *tmp___2 ;
  int ref ;
  int j ;
  unsigned short const   **tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  unsigned short const   **tmp___6 ;
  void *tmp___7 ;
  String *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  String *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  String *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  String *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  String *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  String *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  String *tmp___26 ;
  void *tmp___27 ;
  String *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  void *tmp___31 ;
  int tmp___32 ;
  String *tmp___33 ;
  unsigned short const   **tmp___34 ;
  void *tmp___35 ;
  String *tmp___36 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;

  {
#line 3490
  if (! compiled) {
    {
#line 3491
    tmp = set_errnull(22);
    }
#line 3491
    return ((String *)tmp);
  } else
#line 3490
  if (! replacement) {
    {
#line 3491
    tmp = set_errnull(22);
    }
#line 3491
    return ((String *)tmp);
  } else
#line 3490
  if (! text) {
    {
#line 3491
    tmp = set_errnull(22);
    }
#line 3491
    return ((String *)tmp);
  }
#line 3493
  start = (size_t )0;
#line 3493
  matches = 0;
  {
#line 3493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3493
    if (! (start <= text->length - 1UL)) {
#line 3493
      goto while_break;
    }
    {
#line 3495
    tmp___1 = regexec((regex_t const   */* __restrict  */)compiled, (char const   */* __restrict  */)(text->str + start),
                      (size_t )33, (regmatch_t */* __restrict  */)(match), eflags);
    }
#line 3495
    if (tmp___1) {
#line 3496
      if (matches) {
#line 3496
        tmp___0 = text;
      } else {
#line 3496
        tmp___0 = (String *)((void *)0);
      }
#line 3496
      return (tmp___0);
    }
    {
#line 3503
    rep = str_create("%s", replacement);
    }
#line 3503
    if (! rep) {
#line 3504
      return ((String *)((void *)0));
    }
#line 3506
    i = 0;
    {
#line 3506
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3506
      if (! ((size_t )i < rep->length - 1UL)) {
#line 3506
        goto while_break___0;
      }
#line 3508
      if ((int )*(rep->str + i) == 36) {
#line 3510
        if ((int )*(rep->str + (i + 1)) == 36) {
          {
#line 3512
          tmp___2 = str_remove(rep, (ssize_t )i);
          }
#line 3512
          if (! tmp___2) {
            {
#line 3514
            str_release(rep);
            }
#line 3515
            return ((String *)((void *)0));
          }
        } else {
#line 3521
          j = i + 1;
#line 3523
          if ((int )*(rep->str + j) == 123) {
#line 3525
            j ++;
#line 3525
            ref = 0;
            {
#line 3525
            while (1) {
              while_continue___1: /* CIL Label */ ;
              {
#line 3525
              tmp___3 = __ctype_b_loc();
              }
#line 3525
              if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*(rep->str + j))) & 2048)) {
#line 3525
                goto while_break___1;
              }
#line 3526
              ref *= 10;
#line 3526
              ref += (int )*(rep->str + j) - 48;
#line 3525
              j ++;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 3528
            if ((int )*(rep->str + j) != 125) {
              {
#line 3530
              str_release(rep);
#line 3531
              tmp___4 = set_errnull(22);
              }
#line 3531
              return ((String *)tmp___4);
            }
          } else {
            {
#line 3534
            tmp___6 = __ctype_b_loc();
            }
#line 3534
            if ((int const   )*(*tmp___6 + (int )((unsigned char )*(rep->str + (i + 1)))) & 2048) {
#line 3536
              ref = (int )*(rep->str + j) - 48;
            } else {
              {
#line 3540
              str_release(rep);
#line 3541
              tmp___5 = set_errnull(22);
              }
#line 3541
              return ((String *)tmp___5);
            }
          }
#line 3544
          if (ref < 0) {
            {
#line 3546
            str_release(rep);
#line 3547
            tmp___7 = set_errnull(22);
            }
#line 3547
            return ((String *)tmp___7);
          } else
#line 3544
          if (ref >= 33) {
            {
#line 3546
            str_release(rep);
#line 3547
            tmp___7 = set_errnull(22);
            }
#line 3547
            return ((String *)tmp___7);
          } else
#line 3544
          if (match[ref].rm_so == -1) {
            {
#line 3546
            str_release(rep);
#line 3547
            tmp___7 = set_errnull(22);
            }
#line 3547
            return ((String *)tmp___7);
          }
          {
#line 3550
          tmp___8 = str_replace(rep, (ssize_t )i, (ssize_t )((j + 1) - i), "%.*s",
                                match[ref].rm_eo - match[ref].rm_so, text->str + match[ref].rm_so);
          }
#line 3550
          if (! tmp___8) {
            {
#line 3552
            str_release(rep);
            }
#line 3553
            return ((String *)((void *)0));
          }
#line 3556
          i += (match[ref].rm_eo - match[ref].rm_so) - 1;
        }
      }
#line 3506
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3569
    s = 0;
#line 3569
    states[s] = 0;
#line 3569
    i = 0;
    {
#line 3569
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3569
      if (! ((size_t )i < rep->length - 1UL)) {
#line 3569
        goto while_break___2;
      }
#line 3571
      if ((int )*(rep->str + i) == 92) {
        {
#line 3575
        if ((int )*(rep->str + (i + 1)) == 108) {
#line 3575
          goto case_108;
        }
#line 3576
        if ((int )*(rep->str + (i + 1)) == 76) {
#line 3576
          goto case_76;
        }
#line 3577
        if ((int )*(rep->str + (i + 1)) == 117) {
#line 3577
          goto case_117;
        }
#line 3578
        if ((int )*(rep->str + (i + 1)) == 85) {
#line 3578
          goto case_85;
        }
#line 3579
        if ((int )*(rep->str + (i + 1)) == 81) {
#line 3579
          goto case_81;
        }
#line 3580
        if ((int )*(rep->str + (i + 1)) == 69) {
#line 3580
          goto case_69;
        }
#line 3581
        if ((int )*(rep->str + (i + 1)) == 92) {
#line 3581
          goto case_92;
        }
#line 3573
        goto switch_break;
        case_108: /* CIL Label */ 
#line 3575
        if (s >= 32) {
          {
#line 3575
          str_release(rep);
#line 3575
          tmp___9 = set_errnull(22);
          }
#line 3575
          return ((String *)tmp___9);
        }
        {
#line 3575
        states[s + 1] = states[s] | 9;
#line 3575
        s ++;
#line 3575
        states[s] &= -3;
#line 3575
        tmp___11 = str_remove_range(rep, (ssize_t )i, (ssize_t )2);
        }
#line 3575
        if (! tmp___11) {
          {
#line 3575
          str_release(rep);
#line 3575
          tmp___10 = set_errnull(22);
          }
#line 3575
          return ((String *)tmp___10);
        }
#line 3575
        i --;
#line 3575
        goto switch_break;
        case_76: /* CIL Label */ 
#line 3576
        if (s >= 32) {
          {
#line 3576
          str_release(rep);
#line 3576
          tmp___12 = set_errnull(22);
          }
#line 3576
          return ((String *)tmp___12);
        }
        {
#line 3576
        states[s + 1] = states[s] | 1;
#line 3576
        s ++;
#line 3576
        states[s] &= -3;
#line 3576
        tmp___14 = str_remove_range(rep, (ssize_t )i, (ssize_t )2);
        }
#line 3576
        if (! tmp___14) {
          {
#line 3576
          str_release(rep);
#line 3576
          tmp___13 = set_errnull(22);
          }
#line 3576
          return ((String *)tmp___13);
        }
#line 3576
        i --;
#line 3576
        goto switch_break;
        case_117: /* CIL Label */ 
#line 3577
        if (s >= 32) {
          {
#line 3577
          str_release(rep);
#line 3577
          tmp___15 = set_errnull(22);
          }
#line 3577
          return ((String *)tmp___15);
        }
        {
#line 3577
        states[s + 1] = states[s] | 10;
#line 3577
        s ++;
#line 3577
        states[s] &= -2;
#line 3577
        tmp___17 = str_remove_range(rep, (ssize_t )i, (ssize_t )2);
        }
#line 3577
        if (! tmp___17) {
          {
#line 3577
          str_release(rep);
#line 3577
          tmp___16 = set_errnull(22);
          }
#line 3577
          return ((String *)tmp___16);
        }
#line 3577
        i --;
#line 3577
        goto switch_break;
        case_85: /* CIL Label */ 
#line 3578
        if (s >= 32) {
          {
#line 3578
          str_release(rep);
#line 3578
          tmp___18 = set_errnull(22);
          }
#line 3578
          return ((String *)tmp___18);
        }
        {
#line 3578
        states[s + 1] = states[s] | 2;
#line 3578
        s ++;
#line 3578
        states[s] &= -2;
#line 3578
        tmp___20 = str_remove_range(rep, (ssize_t )i, (ssize_t )2);
        }
#line 3578
        if (! tmp___20) {
          {
#line 3578
          str_release(rep);
#line 3578
          tmp___19 = set_errnull(22);
          }
#line 3578
          return ((String *)tmp___19);
        }
#line 3578
        i --;
#line 3578
        goto switch_break;
        case_81: /* CIL Label */ 
#line 3579
        if (s >= 32) {
          {
#line 3579
          str_release(rep);
#line 3579
          tmp___21 = set_errnull(22);
          }
#line 3579
          return ((String *)tmp___21);
        }
        {
#line 3579
        states[s + 1] = states[s] | 4;
#line 3579
        s ++;
#line 3579
        tmp___23 = str_remove_range(rep, (ssize_t )i, (ssize_t )2);
        }
#line 3579
        if (! tmp___23) {
          {
#line 3579
          str_release(rep);
#line 3579
          tmp___22 = set_errnull(22);
          }
#line 3579
          return ((String *)tmp___22);
        }
#line 3579
        i --;
#line 3579
        goto switch_break;
        case_69: /* CIL Label */ 
#line 3580
        if (s == 0) {
          {
#line 3580
          str_release(rep);
#line 3580
          tmp___24 = set_errnull(22);
          }
#line 3580
          return ((String *)tmp___24);
        }
        {
#line 3580
        s --;
#line 3580
        tmp___26 = str_remove_range(rep, (ssize_t )i, (ssize_t )2);
        }
#line 3580
        if (! tmp___26) {
          {
#line 3580
          str_release(rep);
#line 3580
          tmp___25 = set_errnull(22);
          }
#line 3580
          return ((String *)tmp___25);
        }
#line 3580
        i --;
#line 3580
        goto switch_break;
        case_92: /* CIL Label */ 
        {
#line 3581
        tmp___28 = str_remove(rep, (ssize_t )i);
        }
#line 3581
        if (! tmp___28) {
          {
#line 3581
          str_release(rep);
#line 3581
          tmp___27 = set_errnull(22);
          }
#line 3581
          return ((String *)tmp___27);
        }
#line 3581
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      } else {
#line 3586
        if (states[s] & 1) {
          {
#line 3587
          tmp___29 = tolower((int )((unsigned char )*(rep->str + i)));
#line 3587
          *(rep->str + i) = (char )tmp___29;
          }
        }
#line 3589
        if (states[s] & 2) {
          {
#line 3590
          tmp___30 = toupper((int )((unsigned char )*(rep->str + i)));
#line 3590
          *(rep->str + i) = (char )tmp___30;
          }
        }
#line 3592
        if (states[s] & 4) {
          {
#line 3592
          tmp___34 = __ctype_b_loc();
          }
#line 3592
          if (! ((int const   )*(*tmp___34 + (int )((unsigned char )*(rep->str + i))) & 8)) {
            {
#line 3593
            tmp___32 = i;
#line 3593
            i ++;
#line 3593
            tmp___33 = str_insert(rep, (ssize_t )tmp___32, "\\");
            }
#line 3593
            if (! tmp___33) {
              {
#line 3594
              str_release(rep);
#line 3594
              tmp___31 = set_errnull(22);
              }
#line 3594
              return ((String *)tmp___31);
            }
          }
        }
#line 3596
        if (states[s] & 8) {
#line 3597
          if (s == 0) {
            {
#line 3597
            str_release(rep);
#line 3597
            tmp___35 = set_errnull(22);
            }
#line 3597
            return ((String *)tmp___35);
          }
#line 3597
          s --;
        }
      }
#line 3569
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 3603
    tmp___36 = str_replace_str_unlocked(text, (ssize_t )(start + (size_t )match[0].rm_so),
                                        (ssize_t )(match[0].rm_eo - match[0].rm_so),
                                        (String const   *)rep);
    }
#line 3603
    if (! tmp___36) {
      {
#line 3605
      str_release(rep);
      }
#line 3606
      return ((String *)((void *)0));
    }
#line 3611
    if (match[0].rm_so == 0) {
#line 3611
      if (match[0].rm_eo == 0) {
#line 3613
        (match[0].rm_so) ++;
#line 3614
        (match[0].rm_eo) ++;
      }
    }
    {
#line 3617
    start += ((size_t )match[0].rm_so + rep->length) - 1UL;
#line 3618
    str_release(rep);
    }
#line 3620
    if (! all) {
#line 3621
      goto while_break;
    }
#line 3493
    matches ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3624
  return (text);
}
}
#line 3675 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *str_fmt(String const   *str , size_t line_width , StringAlignment alignment ) 
{ 
  List *tmp ;

  {
  {
#line 3677
  tmp = str_fmt_with_locker((Locker *)((void *)0), str, line_width, alignment);
  }
#line 3677
  return (tmp);
}
}
#line 3690 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *str_fmt_unlocked(String const   *str , size_t line_width , StringAlignment alignment ) 
{ 
  List *tmp ;

  {
  {
#line 3692
  tmp = str_fmt_with_locker_unlocked((Locker *)((void *)0), str, line_width, alignment);
  }
#line 3692
  return (tmp);
}
}
#line 3706 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *str_fmt_with_locker(Locker *locker , String const   *str , size_t line_width ,
                          StringAlignment alignment ) 
{ 
  List *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 3711
  if (! str) {
    {
#line 3712
    tmp = set_errnull(22);
    }
#line 3712
    return ((List *)tmp);
  }
#line 3714
  if (str) {
#line 3714
    if (str->locker) {
      {
#line 3714
      tmp___1 = (*((str->locker)->rdlock))((str->locker)->lock);
#line 3714
      tmp___2 = tmp___1;
      }
    } else {
#line 3714
      tmp___2 = 0;
    }
#line 3714
    err = tmp___2;
  } else {
#line 3714
    err = 22;
  }
#line 3714
  if (err) {
    {
#line 3715
    tmp___0 = set_errnull(err);
    }
#line 3715
    return ((List *)tmp___0);
  }
  {
#line 3717
  ret = str_fmt_with_locker_unlocked(locker, str, line_width, alignment);
  }
#line 3719
  if (str) {
#line 3719
    if (str->locker) {
      {
#line 3719
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 3719
      tmp___5 = tmp___4;
      }
    } else {
#line 3719
      tmp___5 = 0;
    }
#line 3719
    err = tmp___5;
  } else {
#line 3719
    err = 22;
  }
#line 3719
  if (err) {
    {
#line 3721
    list_release(ret);
#line 3722
    tmp___3 = set_errnull(err);
    }
#line 3722
    return ((List *)tmp___3);
  }
#line 3725
  return (ret);
}
}
#line 3739 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *str_fmt_with_locker_unlocked(Locker *locker , String const   *str , size_t line_width ,
                                   StringAlignment alignment ) 
{ 
  void *tmp ;
  List *tmp___0 ;

  {
#line 3741
  if (! str) {
    {
#line 3742
    tmp = set_errnull(22);
    }
#line 3742
    return ((List *)tmp);
  }
  {
#line 3744
  tmp___0 = fmt_with_locker(locker, (char const   *)str->str, line_width, alignment);
  }
#line 3744
  return (tmp___0);
}
}
#line 3757 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *fmt(char const   *str , size_t line_width , StringAlignment alignment ) 
{ 
  List *tmp ;

  {
  {
#line 3759
  tmp = fmt_with_locker((Locker *)((void *)0), str, line_width, alignment);
  }
#line 3759
  return (tmp);
}
}
#line 3773 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *fmt_with_locker(Locker *locker , char const   *str , size_t line_width , StringAlignment alignment ) 
{ 
  List *para ;
  String *line ;
  char const   *s ;
  char const   *r ;
  ssize_t len ;
  void *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  List *tmp___2 ;
  String *tmp___3 ;
  ssize_t tmp___4 ;
  List *tmp___5 ;
  void *tmp___6 ;
  String *tmp___7 ;
  int tmp___8 ;
  ssize_t lines ;
  int i ;
  size_t extra ;
  size_t gaps ;
  void *tmp___9 ;
  int gap ;
  String *tmp___10 ;
  size_t extra___0 ;
  void *tmp___11 ;
  String *tmp___12 ;
  int tmp___13 ;
  void *tmp___14 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
#line 3776
  line = (String *)((void *)0);
#line 3780
  if (! str) {
    {
#line 3781
    tmp = set_errnull(22);
    }
#line 3781
    return ((List *)tmp);
  }
  {
#line 3787
  if ((unsigned int )alignment == 61U) {
#line 3787
    goto case_61;
  }
#line 3787
  if ((unsigned int )alignment == 62U) {
#line 3787
    goto case_61;
  }
#line 3787
  if ((unsigned int )alignment == 60U) {
#line 3787
    goto case_61;
  }
#line 3915
  if ((unsigned int )alignment == 124U) {
#line 3915
    goto case_124;
  }
#line 3942
  goto switch_default;
  case_61: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_60: /* CIL Label */ 
  {
#line 3789
  para = list_create_with_locker(locker, (list_release_t *)(& str_release));
  }
#line 3789
  if (! para) {
#line 3790
    return ((List *)((void *)0));
  }
#line 3792
  s = str;
  {
#line 3792
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3792
    if (! *s) {
#line 3792
      goto while_break;
    }
    {
#line 3794
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 3794
      tmp___0 = __ctype_b_loc();
      }
#line 3794
      if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*s)) & 8192)) {
#line 3794
        goto while_break___0;
      }
#line 3795
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3797
    r = s;
    {
#line 3797
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3797
      if (*r) {
        {
#line 3797
        tmp___1 = __ctype_b_loc();
        }
#line 3797
        if ((int const   )*(*tmp___1 + (int )((unsigned char )*r)) & 8192) {
#line 3797
          goto while_break___1;
        }
      } else {
#line 3797
        goto while_break___1;
      }
#line 3797
      r ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3800
    if ((unsigned long )r > (unsigned long )s) {
      {
#line 3802
      len = str_length((String const   *)line);
      }
#line 3802
      if (len == -1L) {
#line 3803
        len ++;
      }
#line 3805
      if ((size_t )((len + (ssize_t )(len != 0L)) + (r - s)) > line_width) {
#line 3807
        if (len) {
          {
#line 3807
          tmp___2 = list_append(para, (void *)line);
          }
#line 3807
          if (! tmp___2) {
            {
#line 3809
            str_release(line);
#line 3810
            list_release(para);
            }
#line 3811
            return ((List *)((void *)0));
          }
        }
#line 3814
        line = (String *)((void *)0);
      }
#line 3817
      if (! line) {
        {
#line 3819
        line = str_create_sized(line_width, "%.*s", r - s, s);
        }
#line 3819
        if (! line) {
          {
#line 3821
          list_release(para);
          }
#line 3822
          return ((List *)((void *)0));
        }
      } else {
        {
#line 3825
        tmp___3 = str_append(line, " %.*s", r - s, s);
        }
#line 3825
        if (! tmp___3) {
          {
#line 3827
          str_release(line);
#line 3828
          list_release(para);
          }
#line 3829
          return ((List *)((void *)0));
        }
      }
#line 3832
      s = r;
#line 3834
      if (! *s) {
#line 3835
        s --;
      }
    }
#line 3792
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3839
  tmp___4 = str_length((String const   *)line);
  }
#line 3839
  if (tmp___4 > 0L) {
    {
#line 3839
    tmp___5 = list_append(para, (void *)line);
    }
#line 3839
    if (! tmp___5) {
      {
#line 3841
      str_release(line);
#line 3842
      list_release(para);
      }
#line 3843
      return ((List *)((void *)0));
    }
  }
#line 3846
  if ((unsigned int )alignment == 62U) {
    {
#line 3848
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 3848
      tmp___8 = list_has_next(para);
      }
#line 3848
      if (! (tmp___8 == 1)) {
#line 3848
        goto while_break___2;
      }
      {
#line 3850
      tmp___6 = list_next(para);
#line 3850
      line = (String *)tmp___6;
#line 3851
      len = str_length((String const   *)line);
      }
#line 3853
      if ((size_t )len >= line_width) {
#line 3854
        goto while_continue___2;
      }
      {
#line 3856
      tmp___7 = str_prepend(line, "%*s", line_width - (size_t )len, "");
      }
#line 3856
      if (! tmp___7) {
        {
#line 3858
        list_release(para);
        }
#line 3859
        return ((List *)((void *)0));
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 3863
  if ((unsigned int )alignment == 61U) {
    {
#line 3868
    lines = list_length((List const   *)para);
    }
#line 3868
    if (lines == -1L) {
      {
#line 3870
      list_release(para);
      }
#line 3871
      return ((List *)((void *)0));
    }
#line 3874
    i = 0;
    {
#line 3874
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 3874
      if (! ((ssize_t )i < lines - 1L)) {
#line 3874
        goto while_break___3;
      }
      {
#line 3879
      tmp___9 = list_item((List const   *)para, (ssize_t )i);
#line 3879
      line = (String *)tmp___9;
#line 3880
      len = str_length((String const   *)line);
      }
#line 3882
      if ((size_t )len >= line_width) {
#line 3883
        goto __Cont;
      }
#line 3885
      extra = line_width - (size_t )len;
#line 3886
      gaps = (size_t )0;
#line 3888
      s = (char const   *)line->str;
      {
#line 3888
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 3888
        if (! *s) {
#line 3888
          goto while_break___4;
        }
#line 3889
        if ((int const   )*s == 32) {
#line 3890
          gaps ++;
        }
#line 3888
        s ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 3892
      s = (char const   *)line->str;
      {
#line 3892
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 3892
        if (gaps) {
#line 3892
          if (! *s) {
#line 3892
            goto while_break___5;
          }
        } else {
#line 3892
          goto while_break___5;
        }
#line 3894
        if ((int const   )*s == 32) {
          {
#line 3896
          gap = (int )(extra / gaps);
#line 3898
          tmp___10 = str_insert(line, s - (char const   *)line->str, "%*s", gap, "");
          }
#line 3898
          if (! tmp___10) {
            {
#line 3900
            list_release(para);
            }
#line 3901
            return ((List *)((void *)0));
          }
#line 3904
          extra -= (size_t )gap;
#line 3905
          gaps --;
#line 3906
          s += gap;
        }
#line 3892
        s ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 3874
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 3912
  goto switch_break;
  case_124: /* CIL Label */ 
  {
#line 3917
  para = split_with_locker(locker, str, "\n");
  }
#line 3917
  if (! para) {
#line 3918
    return ((List *)((void *)0));
  }
  {
#line 3920
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 3920
    tmp___13 = list_has_next(para);
    }
#line 3920
    if (! (tmp___13 == 1)) {
#line 3920
      goto while_break___6;
    }
    {
#line 3923
    tmp___11 = list_next(para);
#line 3923
    line = (String *)tmp___11;
#line 3924
    str_squeeze(line);
#line 3925
    len = str_length((String const   *)line);
    }
#line 3927
    if ((size_t )len >= line_width) {
#line 3928
      goto while_continue___6;
    }
#line 3930
    extra___0 = (line_width - (size_t )len) / 2UL;
#line 3932
    if (extra___0) {
      {
#line 3932
      tmp___12 = str_prepend(line, "%*s", extra___0, "");
      }
#line 3932
      if (! tmp___12) {
        {
#line 3934
        list_release(para);
        }
#line 3935
        return ((List *)((void *)0));
      }
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 3939
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 3944
  tmp___14 = set_errnull(22);
  }
#line 3944
  return ((List *)tmp___14);
  switch_break: /* CIL Label */ ;
  }
#line 3948
  return (para);
}
}
#line 3966 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
static List *do_split_with_locker(Locker *locker , char const   *str , ssize_t length ,
                                  char const   *delim ) 
{ 
  List *ret ;
  char const   *s ;
  char const   *r ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  String *token ;
  String *tmp___10 ;
  List *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 3971
  if (! str) {
    {
#line 3972
    tmp = set_errnull(22);
    }
#line 3972
    return ((List *)tmp);
  } else
#line 3971
  if (! delim) {
    {
#line 3972
    tmp = set_errnull(22);
    }
#line 3972
    return ((List *)tmp);
  }
  {
#line 3974
  ret = list_create_with_locker(locker, (list_release_t *)(& str_release));
  }
#line 3974
  if (! ret) {
#line 3975
    return ((List *)((void *)0));
  }
#line 3977
  s = str;
  {
#line 3977
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3977
    if (length == -1L) {
#line 3977
      tmp___13 = (int const   )*s;
    } else {
#line 3977
      tmp___13 = (int const   )(s - str < length);
    }
#line 3977
    if (! tmp___13) {
#line 3977
      goto while_break;
    }
    {
#line 3979
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3979
      if (length == -1L) {
#line 3979
        if (*s) {
          {
#line 3979
          tmp___0 = strchr(delim, (int )*s);
          }
#line 3979
          if (tmp___0) {
#line 3979
            tmp___1 = 1;
          } else {
#line 3979
            tmp___1 = 0;
          }
        } else {
#line 3979
          tmp___1 = 0;
        }
#line 3979
        tmp___4 = tmp___1;
      } else {
#line 3979
        if (s - str < length) {
#line 3979
          if (*s) {
            {
#line 3979
            tmp___2 = strchr(delim, (int )*s);
            }
#line 3979
            if (tmp___2) {
#line 3979
              tmp___3 = 1;
            } else {
#line 3979
              tmp___3 = 0;
            }
          } else {
#line 3979
            tmp___3 = 0;
          }
        } else {
#line 3979
          tmp___3 = 0;
        }
#line 3979
        tmp___4 = tmp___3;
      }
#line 3979
      if (! tmp___4) {
#line 3979
        goto while_break___0;
      }
#line 3980
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3982
    if (! *delim) {
#line 3983
      r = s + 1;
    } else {
#line 3985
      r = s;
      {
#line 3985
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3985
        if (length == -1L) {
#line 3985
          if (*r) {
            {
#line 3985
            tmp___5 = strchr(delim, (int )*r);
            }
#line 3985
            if (tmp___5) {
#line 3985
              tmp___6 = 0;
            } else {
#line 3985
              tmp___6 = 1;
            }
          } else {
#line 3985
            tmp___6 = 0;
          }
#line 3985
          tmp___9 = tmp___6;
        } else {
#line 3985
          if (r - str < length) {
#line 3985
            if (! *r) {
#line 3985
              tmp___8 = 1;
            } else {
              {
#line 3985
              tmp___7 = strchr(delim, (int )*r);
              }
#line 3985
              if (tmp___7) {
#line 3985
                tmp___8 = 0;
              } else {
#line 3985
                tmp___8 = 1;
              }
            }
          } else {
#line 3985
            tmp___8 = 0;
          }
#line 3985
          tmp___9 = tmp___8;
        }
#line 3985
        if (! tmp___9) {
#line 3985
          goto while_break___1;
        }
#line 3985
        r ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 3988
    if ((unsigned long )r > (unsigned long )s) {
      {
#line 3990
      tmp___10 = substr(s, (ssize_t )0, r - s);
#line 3990
      token = tmp___10;
      }
#line 3991
      if (! token) {
        {
#line 3993
        list_release(ret);
        }
#line 3994
        return ((List *)((void *)0));
      }
      {
#line 3997
      tmp___11 = list_append(ret, (void *)token);
      }
#line 3997
      if (! tmp___11) {
        {
#line 3999
        str_release(token);
#line 4000
        list_release(ret);
        }
#line 4001
        return ((List *)((void *)0));
      }
#line 4004
      s = r;
#line 4005
      if (! *delim) {
#line 4006
        s --;
      }
    }
#line 4009
    if (length == -1L) {
#line 4009
      tmp___12 = ! *s;
    } else {
#line 4009
      tmp___12 = s - str == length;
    }
#line 4009
    if (tmp___12) {
#line 4010
      goto while_break;
    }
#line 3977
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4013
  return (ret);
}
}
#line 4030 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *str_split(String const   *str , char const   *delim ) 
{ 
  List *tmp ;

  {
  {
#line 4032
  tmp = str_split_with_locker((Locker *)((void *)0), str, delim);
  }
#line 4032
  return (tmp);
}
}
#line 4045 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *str_split_unlocked(String const   *str , char const   *delim ) 
{ 
  List *tmp ;

  {
  {
#line 4047
  tmp = str_split_with_locker_unlocked((Locker *)((void *)0), str, delim);
  }
#line 4047
  return (tmp);
}
}
#line 4061 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *str_split_with_locker(Locker *locker , String const   *str , char const   *delim ) 
{ 
  List *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 4066
  if (! str) {
    {
#line 4067
    tmp = set_errnull(22);
    }
#line 4067
    return ((List *)tmp);
  } else
#line 4066
  if (! delim) {
    {
#line 4067
    tmp = set_errnull(22);
    }
#line 4067
    return ((List *)tmp);
  }
#line 4069
  if (str) {
#line 4069
    if (str->locker) {
      {
#line 4069
      tmp___1 = (*((str->locker)->rdlock))((str->locker)->lock);
#line 4069
      tmp___2 = tmp___1;
      }
    } else {
#line 4069
      tmp___2 = 0;
    }
#line 4069
    err = tmp___2;
  } else {
#line 4069
    err = 22;
  }
#line 4069
  if (err) {
    {
#line 4070
    tmp___0 = set_errnull(err);
    }
#line 4070
    return ((List *)tmp___0);
  }
  {
#line 4072
  ret = str_split_with_locker_unlocked(locker, str, delim);
  }
#line 4074
  if (str) {
#line 4074
    if (str->locker) {
      {
#line 4074
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 4074
      tmp___5 = tmp___4;
      }
    } else {
#line 4074
      tmp___5 = 0;
    }
#line 4074
    err = tmp___5;
  } else {
#line 4074
    err = 22;
  }
#line 4074
  if (err) {
    {
#line 4076
    list_release(ret);
#line 4077
    tmp___3 = set_errnull(err);
    }
#line 4077
    return ((List *)tmp___3);
  }
#line 4080
  return (ret);
}
}
#line 4094 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *str_split_with_locker_unlocked(Locker *locker , String const   *str , char const   *delim ) 
{ 
  void *tmp ;
  List *tmp___0 ;

  {
#line 4096
  if (! str) {
    {
#line 4097
    tmp = set_errnull(22);
    }
#line 4097
    return ((List *)tmp);
  } else
#line 4096
  if (! delim) {
    {
#line 4097
    tmp = set_errnull(22);
    }
#line 4097
    return ((List *)tmp);
  }
  {
#line 4099
  tmp___0 = do_split_with_locker(locker, (char const   *)str->str, (ssize_t )(str->length - 1UL),
                                 delim);
  }
#line 4099
  return (tmp___0);
}
}
#line 4112 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *split(char const   *str , char const   *delim ) 
{ 
  List *tmp ;

  {
  {
#line 4114
  tmp = split_with_locker((Locker *)((void *)0), str, delim);
  }
#line 4114
  return (tmp);
}
}
#line 4128 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *split_with_locker(Locker *locker , char const   *str , char const   *delim ) 
{ 
  void *tmp ;
  List *tmp___0 ;

  {
#line 4130
  if (! str) {
    {
#line 4131
    tmp = set_errnull(22);
    }
#line 4131
    return ((List *)tmp);
  } else
#line 4130
  if (! delim) {
    {
#line 4131
    tmp = set_errnull(22);
    }
#line 4131
    return ((List *)tmp);
  }
  {
#line 4133
  tmp___0 = do_split_with_locker(locker, str, (ssize_t )-1, delim);
  }
#line 4133
  return (tmp___0);
}
}
#line 4154 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *str_regexpr_split(String const   *str , char const   *delim , int cflags , int eflags ) 
{ 
  List *tmp ;

  {
  {
#line 4156
  tmp = str_regexpr_split_with_locker((Locker *)((void *)0), str, delim, cflags, eflags);
  }
#line 4156
  return (tmp);
}
}
#line 4169 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *str_regexpr_split_unlocked(String const   *str , char const   *delim , int cflags ,
                                 int eflags ) 
{ 
  List *tmp ;

  {
  {
#line 4171
  tmp = str_regexpr_split_with_locker_unlocked((Locker *)((void *)0), str, delim,
                                               cflags, eflags);
  }
#line 4171
  return (tmp);
}
}
#line 4185 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *str_regexpr_split_with_locker(Locker *locker , String const   *str , char const   *delim ,
                                    int cflags , int eflags ) 
{ 
  List *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 4190
  if (! str) {
    {
#line 4191
    tmp = set_errnull(22);
    }
#line 4191
    return ((List *)tmp);
  } else
#line 4190
  if (! delim) {
    {
#line 4191
    tmp = set_errnull(22);
    }
#line 4191
    return ((List *)tmp);
  }
#line 4193
  if (str) {
#line 4193
    if (str->locker) {
      {
#line 4193
      tmp___1 = (*((str->locker)->rdlock))((str->locker)->lock);
#line 4193
      tmp___2 = tmp___1;
      }
    } else {
#line 4193
      tmp___2 = 0;
    }
#line 4193
    err = tmp___2;
  } else {
#line 4193
    err = 22;
  }
#line 4193
  if (err) {
    {
#line 4194
    tmp___0 = set_errnull(err);
    }
#line 4194
    return ((List *)tmp___0);
  }
  {
#line 4196
  ret = str_regexpr_split_with_locker_unlocked(locker, str, delim, cflags, eflags);
  }
#line 4198
  if (str) {
#line 4198
    if (str->locker) {
      {
#line 4198
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 4198
      tmp___5 = tmp___4;
      }
    } else {
#line 4198
      tmp___5 = 0;
    }
#line 4198
    err = tmp___5;
  } else {
#line 4198
    err = 22;
  }
#line 4198
  if (err) {
    {
#line 4200
    list_release(ret);
#line 4201
    tmp___3 = set_errnull(err);
    }
#line 4201
    return ((List *)tmp___3);
  }
#line 4204
  return (ret);
}
}
#line 4218 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *str_regexpr_split_with_locker_unlocked(Locker *locker , String const   *str ,
                                             char const   *delim , int cflags , int eflags ) 
{ 
  void *tmp ;
  List *tmp___0 ;

  {
#line 4220
  if (! str) {
    {
#line 4221
    tmp = set_errnull(22);
    }
#line 4221
    return ((List *)tmp);
  } else
#line 4220
  if (! delim) {
    {
#line 4221
    tmp = set_errnull(22);
    }
#line 4221
    return ((List *)tmp);
  }
  {
#line 4223
  tmp___0 = regexpr_split_with_locker(locker, (char const   *)str->str, delim, cflags,
                                      eflags);
  }
#line 4223
  return (tmp___0);
}
}
#line 4236 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *regexpr_split(char const   *str , char const   *delim , int cflags , int eflags ) 
{ 
  List *tmp ;

  {
  {
#line 4238
  tmp = regexpr_split_with_locker((Locker *)((void *)0), str, delim, cflags, eflags);
  }
#line 4238
  return (tmp);
}
}
#line 4252 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
List *regexpr_split_with_locker(Locker *locker , char const   *str , char const   *delim ,
                                int cflags , int eflags ) 
{ 
  List *ret ;
  String *token ;
  regex_t compiled[1] ;
  regmatch_t match[1] ;
  int start ;
  int matches ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  List *tmp___2 ;
  List *tmp___3 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 4261
  if (! str) {
    {
#line 4262
    tmp = set_errnull(22);
    }
#line 4262
    return ((List *)tmp);
  } else
#line 4261
  if (! delim) {
    {
#line 4262
    tmp = set_errnull(22);
    }
#line 4262
    return ((List *)tmp);
  }
  {
#line 4264
  err = regexpr_compile(compiled, delim, cflags);
  }
#line 4264
  if (err) {
    {
#line 4265
    tmp___0 = set_errnull(err);
    }
#line 4265
    return ((List *)tmp___0);
  }
  {
#line 4267
  ret = list_create_with_locker(locker, (list_release_t *)(& str_release));
  }
#line 4267
  if (! ret) {
#line 4268
    return ((List *)((void *)0));
  }
#line 4270
  start = 0;
#line 4270
  matches = 0;
  {
#line 4270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4270
    if (! *(str + start)) {
#line 4270
      goto while_break;
    }
    {
#line 4272
    tmp___1 = regexec((regex_t const   */* __restrict  */)(compiled), (char const   */* __restrict  */)(str + start),
                      (size_t )1, (regmatch_t */* __restrict  */)(match), eflags);
    }
#line 4272
    if (tmp___1) {
#line 4273
      goto while_break;
    }
#line 4277
    if (match[0].rm_so == 0) {
#line 4277
      if (match[0].rm_eo == 0) {
#line 4279
        (match[0].rm_so) ++;
#line 4280
        (match[0].rm_eo) ++;
      }
    }
#line 4285
    if (match[0].rm_so) {
      {
#line 4287
      token = substr(str, (ssize_t )start, (ssize_t )match[0].rm_so);
      }
#line 4287
      if (! token) {
        {
#line 4289
        list_release(ret);
        }
#line 4290
        return ((List *)((void *)0));
      }
      {
#line 4293
      tmp___2 = list_append(ret, (void *)token);
      }
#line 4293
      if (! tmp___2) {
        {
#line 4295
        str_release(token);
#line 4296
        list_release(ret);
        }
#line 4297
        return ((List *)((void *)0));
      }
    }
#line 4301
    start += match[0].rm_eo;
#line 4270
    matches ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4306
  if (*(str + start)) {
    {
#line 4308
    token = str_create("%s", str + start);
    }
#line 4308
    if (! token) {
      {
#line 4310
      list_release(ret);
      }
#line 4311
      return ((List *)((void *)0));
    }
    {
#line 4314
    tmp___3 = list_append(ret, (void *)token);
    }
#line 4314
    if (! tmp___3) {
      {
#line 4316
      str_release(token);
#line 4317
      list_release(ret);
      }
#line 4318
      return ((List *)((void *)0));
    }
  }
#line 4322
  return (ret);
}
}
#line 4341 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_join(List const   *list , char const   *delim ) 
{ 
  String *tmp ;

  {
  {
#line 4343
  tmp = str_join_with_locker((Locker *)((void *)0), list, delim);
  }
#line 4343
  return (tmp);
}
}
#line 4356 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_join_unlocked(List const   *list , char const   *delim ) 
{ 
  String *tmp ;

  {
  {
#line 4358
  tmp = str_join_with_locker_unlocked((Locker *)((void *)0), list, delim);
  }
#line 4358
  return (tmp);
}
}
#line 4372 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_join_with_locker(Locker *locker , List const   *list , char const   *delim ) 
{ 
  String *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 4377
  if (! list) {
    {
#line 4378
    tmp = set_errnull(22);
    }
#line 4378
    return ((String *)tmp);
  }
  {
#line 4380
  err = list_rdlock(list);
  }
#line 4380
  if (err) {
    {
#line 4381
    tmp___0 = set_errnull(err);
    }
#line 4381
    return ((String *)tmp___0);
  }
  {
#line 4383
  ret = str_join_with_locker_unlocked(locker, list, delim);
#line 4385
  err = list_unlock(list);
  }
#line 4385
  if (err) {
    {
#line 4386
    tmp___1 = set_errnull(err);
    }
#line 4386
    return ((String *)tmp___1);
  }
#line 4388
  return (ret);
}
}
#line 4402 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_join_with_locker_unlocked(Locker *locker , List const   *list , char const   *delim ) 
{ 
  String *ret ;
  String *del ;
  Lister *lister ;
  int i ;
  void *tmp ;
  char const   *tmp___0 ;
  String *s ;
  void *tmp___1 ;
  String *tmp___2 ;
  String *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp15 ;

  {
#line 4409
  if (! list) {
    {
#line 4410
    tmp = set_errnull(22);
    }
#line 4410
    return ((String *)tmp);
  }
  {
#line 4412
  ret = str_create_with_locker(locker, (char const   *)((void *)0));
  }
#line 4412
  if (! ret) {
#line 4413
    return ((String *)((void *)0));
  }
#line 4415
  if (delim) {
#line 4415
    tmp___0 = "%s";
  } else {
#line 4415
    tmp___0 = (char const   *)((void *)0);
  }
  {
#line 4415
  del = str_create(tmp___0, delim);
  }
#line 4415
  if (! del) {
    {
#line 4417
    str_release(ret);
    }
#line 4418
    return ((String *)((void *)0));
  }
  {
#line 4421
  lister = lister_create_unlocked(list);
  }
#line 4421
  if (! lister) {
    {
#line 4423
    str_release(ret);
#line 4424
    str_release(del);
    }
#line 4425
    return ((String *)((void *)0));
  }
#line 4428
  i = 0;
  {
#line 4428
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4428
    tmp___4 = lister_has_next(lister);
    }
#line 4428
    if (! (tmp___4 == 1)) {
#line 4428
      goto while_break;
    }
    {
#line 4430
    tmp___1 = lister_next(lister);
#line 4430
    s = (String *)tmp___1;
    }
#line 4432
    if (i) {
      {
#line 4432
      tmp___2 = str_append_str(ret, (String const   *)del);
      }
#line 4432
      if (! tmp___2) {
        {
#line 4434
        str_release(ret);
#line 4435
        str_release(del);
#line 4436
        lister_release_unlocked(lister);
        }
#line 4437
        return ((String *)((void *)0));
      }
    }
#line 4440
    if (s) {
      {
#line 4440
      tmp___3 = str_append_str(ret, (String const   *)s);
      }
#line 4440
      if (! tmp___3) {
        {
#line 4442
        str_release(ret);
#line 4443
        str_release(del);
#line 4444
        lister_release_unlocked(lister);
        }
#line 4445
        return ((String *)((void *)0));
      }
    }
#line 4428
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4449
  str_release(del);
#line 4450
  lister_release_unlocked(lister);
  }
#line 4452
  return (ret);
}
}
#line 4465 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *join(List const   *list , char const   *delim ) 
{ 
  String *tmp ;

  {
  {
#line 4467
  tmp = join_with_locker((Locker *)((void *)0), list, delim);
  }
#line 4467
  return (tmp);
}
}
#line 4481 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *join_with_locker(Locker *locker , List const   *list , char const   *delim ) 
{ 
  String *ret ;
  String *del ;
  Lister *lister ;
  int i ;
  void *tmp ;
  char const   *tmp___0 ;
  char *s ;
  void *tmp___1 ;
  String *tmp___2 ;
  String *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 4488
  if (! list) {
    {
#line 4489
    tmp = set_errnull(22);
    }
#line 4489
    return ((String *)tmp);
  }
  {
#line 4491
  ret = str_create_with_locker(locker, (char const   *)((void *)0));
  }
#line 4491
  if (! ret) {
#line 4492
    return ((String *)((void *)0));
  }
#line 4494
  if (delim) {
#line 4494
    tmp___0 = "%s";
  } else {
#line 4494
    tmp___0 = (char const   *)((void *)0);
  }
  {
#line 4494
  del = str_create(tmp___0, delim);
  }
#line 4494
  if (! del) {
    {
#line 4496
    str_release(ret);
    }
#line 4497
    return ((String *)((void *)0));
  }
  {
#line 4500
  lister = lister_create((List *)list);
  }
#line 4500
  if (! lister) {
    {
#line 4502
    str_release(ret);
#line 4503
    str_release(del);
    }
#line 4504
    return ((String *)((void *)0));
  }
#line 4507
  i = 0;
  {
#line 4507
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4507
    tmp___4 = lister_has_next(lister);
    }
#line 4507
    if (! (tmp___4 == 1)) {
#line 4507
      goto while_break;
    }
    {
#line 4509
    tmp___1 = lister_next(lister);
#line 4509
    s = (char *)tmp___1;
    }
#line 4511
    if (i) {
      {
#line 4511
      tmp___2 = str_append_str(ret, (String const   *)del);
      }
#line 4511
      if (! tmp___2) {
        {
#line 4513
        str_release(ret);
#line 4514
        str_release(del);
#line 4515
        lister_release(lister);
        }
#line 4516
        return ((String *)((void *)0));
      }
    }
#line 4519
    if (s) {
      {
#line 4519
      tmp___3 = str_append(ret, "%s", s);
      }
#line 4519
      if (! tmp___3) {
        {
#line 4521
        str_release(ret);
#line 4522
        str_release(del);
#line 4523
        lister_release(lister);
        }
#line 4524
        return ((String *)((void *)0));
      }
    }
#line 4507
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4528
  str_release(del);
#line 4529
  lister_release(lister);
  }
#line 4531
  return (ret);
}
}
#line 4545 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int str_soundex(String const   *str ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 4550
  if (! str) {
    {
#line 4551
    tmp = set_errno(22);
    }
#line 4551
    return (tmp);
  }
#line 4553
  if (str) {
#line 4553
    if (str->locker) {
      {
#line 4553
      tmp___1 = (*((str->locker)->rdlock))((str->locker)->lock);
#line 4553
      tmp___2 = tmp___1;
      }
    } else {
#line 4553
      tmp___2 = 0;
    }
#line 4553
    err = tmp___2;
  } else {
#line 4553
    err = 22;
  }
#line 4553
  if (err) {
    {
#line 4554
    tmp___0 = set_errno(err);
    }
#line 4554
    return (tmp___0);
  }
  {
#line 4556
  ret = str_soundex_unlocked(str);
  }
#line 4558
  if (str) {
#line 4558
    if (str->locker) {
      {
#line 4558
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 4558
      tmp___5 = tmp___4;
      }
    } else {
#line 4558
      tmp___5 = 0;
    }
#line 4558
    err = tmp___5;
  } else {
#line 4558
    err = 22;
  }
#line 4558
  if (err) {
    {
#line 4559
    tmp___3 = set_errno(err);
    }
#line 4559
    return (tmp___3);
  }
#line 4561
  return (ret);
}
}
#line 4574 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int str_soundex_unlocked(String const   *str ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 4576
  if (! str) {
    {
#line 4577
    tmp = set_errno(22);
    }
#line 4577
    return (tmp);
  }
  {
#line 4579
  tmp___0 = soundex((char const   *)str->str);
  }
#line 4579
  return (tmp___0);
}
}
#line 4592 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int soundex(char const   *str ) 
{ 
  char const   *soundex_table ;
  union __anonunion_soundex_79 soundex___0 ;
  int last ;
  int small ;
  int tmp ;
  int code ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  uint32_t tmp___5 ;
  char *__cil_tmp14 ;

  {
#line 4594
  soundex_table = "\000123\00012\000\00022455\00012623\0001\0002\0002";
#line 4598
  if (! str) {
    {
#line 4599
    tmp = set_errno(22);
    }
#line 4599
    return (tmp);
  }
#line 4601
  soundex___0.i = 0;
#line 4603
  last = -1;
#line 4603
  small = 0;
  {
#line 4603
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4603
    if (*str) {
#line 4603
      if (! (small < 4)) {
#line 4603
        goto while_break;
      }
    } else {
#line 4603
      goto while_break;
    }
    {
#line 4605
    tmp___3 = __ctype_b_loc();
    }
#line 4605
    if ((int const   )*(*tmp___3 + (int )((unsigned char )*str)) & 1024) {
      {
#line 4607
      tmp___0 = toupper((int )((unsigned char )*str));
#line 4607
      code = tmp___0;
      }
#line 4609
      if (small == 0) {
#line 4611
        tmp___1 = small;
#line 4611
        small ++;
#line 4611
        soundex___0.c[tmp___1] = (char )code;
#line 4612
        last = (int )*(soundex_table + (code - 65));
      } else {
#line 4616
        code = (int )*(soundex_table + (code - 65));
#line 4616
        if (code != last) {
#line 4618
          if (code != 0) {
#line 4619
            tmp___2 = small;
#line 4619
            small ++;
#line 4619
            soundex___0.c[tmp___2] = (char )code;
          }
#line 4621
          last = code;
        }
      }
    }
#line 4603
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4627
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4627
    if (! (small < 4)) {
#line 4627
      goto while_break___0;
    }
#line 4628
    tmp___4 = small;
#line 4628
    small ++;
#line 4628
    soundex___0.c[tmp___4] = (char )'0';
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 4630
  tmp___5 = ntohl((uint32_t )soundex___0.i);
  }
#line 4630
  return ((int )tmp___5);
}
}
#line 4644 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_trim(String *str ) 
{ 
  String *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 4649
  if (! str) {
    {
#line 4650
    tmp = set_errnull(22);
    }
#line 4650
    return ((String *)tmp);
  }
#line 4652
  if (str) {
#line 4652
    if (str->locker) {
      {
#line 4652
      tmp___1 = (*((str->locker)->wrlock))((str->locker)->lock);
#line 4652
      tmp___2 = tmp___1;
      }
    } else {
#line 4652
      tmp___2 = 0;
    }
#line 4652
    err = tmp___2;
  } else {
#line 4652
    err = 22;
  }
#line 4652
  if (err) {
    {
#line 4653
    tmp___0 = set_errnull(err);
    }
#line 4653
    return ((String *)tmp___0);
  }
  {
#line 4655
  ret = str_trim_unlocked(str);
  }
#line 4657
  if (str) {
#line 4657
    if (str->locker) {
      {
#line 4657
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 4657
      tmp___5 = tmp___4;
      }
    } else {
#line 4657
      tmp___5 = 0;
    }
#line 4657
    err = tmp___5;
  } else {
#line 4657
    err = 22;
  }
#line 4657
  if (err) {
    {
#line 4658
    tmp___3 = set_errnull(err);
    }
#line 4658
    return ((String *)tmp___3);
  }
#line 4660
  return (ret);
}
}
#line 4673 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_trim_unlocked(String *str ) 
{ 
  char *s ;
  void *tmp ;
  unsigned short const   **tmp___0 ;
  String *tmp___1 ;
  unsigned short const   **tmp___2 ;
  String *tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
#line 4677
  if (! str) {
    {
#line 4678
    tmp = set_errnull(22);
    }
#line 4678
    return ((String *)tmp);
  }
#line 4680
  s = str->str;
  {
#line 4680
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4680
    tmp___0 = __ctype_b_loc();
    }
#line 4680
    if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*s)) & 8192)) {
#line 4680
      goto while_break;
    }
#line 4680
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4683
  if ((unsigned long )s > (unsigned long )str->str) {
    {
#line 4685
    tmp___1 = str_remove_range_unlocked(str, (ssize_t )0, s - str->str);
    }
#line 4685
    if (! tmp___1) {
#line 4686
      return ((String *)((void *)0));
    }
  }
#line 4689
  s = (str->str + str->length) - 1;
  {
#line 4689
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4689
    if ((unsigned long )s > (unsigned long )str->str) {
      {
#line 4689
      tmp___2 = __ctype_b_loc();
      }
#line 4689
      if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*(s + -1))) & 8192)) {
#line 4689
        goto while_break___0;
      }
    } else {
#line 4689
      goto while_break___0;
    }
#line 4689
    s --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 4692
  tmp___4 = __ctype_b_loc();
  }
#line 4692
  if ((int const   )*(*tmp___4 + (int )((unsigned char )*s)) & 8192) {
    {
#line 4694
    tmp___3 = str_remove_range_unlocked(str, s - str->str, (ssize_t )((str->length - 1UL) - (size_t )(s - str->str)));
    }
#line 4694
    if (! tmp___3) {
#line 4695
      return ((String *)((void *)0));
    }
  }
#line 4698
  return (str);
}
}
#line 4711 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
char *trim(char *str ) 
{ 
  char *s ;
  size_t len ;
  void *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 4716
  if (! str) {
    {
#line 4717
    tmp = set_errnull(22);
    }
#line 4717
    return ((char *)tmp);
  }
#line 4719
  s = str;
  {
#line 4719
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4719
    tmp___0 = __ctype_b_loc();
    }
#line 4719
    if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*s)) & 8192)) {
#line 4719
      goto while_break;
    }
#line 4719
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4722
  len = strlen((char const   *)s);
  }
#line 4724
  if ((unsigned long )s > (unsigned long )str) {
    {
#line 4725
    memmove((void *)str, (void const   *)s, len + 1UL);
    }
  }
#line 4727
  s = str + len;
  {
#line 4727
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4727
    if ((unsigned long )s > (unsigned long )str) {
      {
#line 4727
      tmp___1 = __ctype_b_loc();
#line 4727
      s --;
      }
#line 4727
      if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*s)) & 8192)) {
#line 4727
        goto while_break___0;
      }
    } else {
#line 4727
      goto while_break___0;
    }
#line 4728
    *s = (char )'\000';
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4730
  return (str);
}
}
#line 4744 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_trim_left(String *str ) 
{ 
  String *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 4749
  if (! str) {
    {
#line 4750
    tmp = set_errnull(22);
    }
#line 4750
    return ((String *)tmp);
  }
#line 4752
  if (str) {
#line 4752
    if (str->locker) {
      {
#line 4752
      tmp___1 = (*((str->locker)->wrlock))((str->locker)->lock);
#line 4752
      tmp___2 = tmp___1;
      }
    } else {
#line 4752
      tmp___2 = 0;
    }
#line 4752
    err = tmp___2;
  } else {
#line 4752
    err = 22;
  }
#line 4752
  if (err) {
    {
#line 4753
    tmp___0 = set_errnull(err);
    }
#line 4753
    return ((String *)tmp___0);
  }
  {
#line 4755
  ret = str_trim_left_unlocked(str);
  }
#line 4757
  if (str) {
#line 4757
    if (str->locker) {
      {
#line 4757
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 4757
      tmp___5 = tmp___4;
      }
    } else {
#line 4757
      tmp___5 = 0;
    }
#line 4757
    err = tmp___5;
  } else {
#line 4757
    err = 22;
  }
#line 4757
  if (err) {
    {
#line 4758
    tmp___3 = set_errnull(err);
    }
#line 4758
    return ((String *)tmp___3);
  }
#line 4760
  return (ret);
}
}
#line 4773 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_trim_left_unlocked(String *str ) 
{ 
  char *s ;
  void *tmp ;
  unsigned short const   **tmp___0 ;
  String *tmp___1 ;

  {
#line 4777
  if (! str) {
    {
#line 4778
    tmp = set_errnull(22);
    }
#line 4778
    return ((String *)tmp);
  }
#line 4780
  s = str->str;
  {
#line 4780
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4780
    tmp___0 = __ctype_b_loc();
    }
#line 4780
    if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*s)) & 8192)) {
#line 4780
      goto while_break;
    }
#line 4780
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4783
  if ((unsigned long )s > (unsigned long )str->str) {
    {
#line 4784
    tmp___1 = str_remove_range_unlocked(str, (ssize_t )0, s - str->str);
    }
#line 4784
    if (! tmp___1) {
#line 4785
      return ((String *)((void *)0));
    }
  }
#line 4787
  return (str);
}
}
#line 4800 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
char *trim_left(char *str ) 
{ 
  char *s ;
  size_t len ;
  void *tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 4805
  if (! str) {
    {
#line 4806
    tmp = set_errnull(22);
    }
#line 4806
    return ((char *)tmp);
  }
#line 4808
  s = str;
  {
#line 4808
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4808
    tmp___0 = __ctype_b_loc();
    }
#line 4808
    if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*s)) & 8192)) {
#line 4808
      goto while_break;
    }
#line 4808
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4811
  len = strlen((char const   *)s);
  }
#line 4813
  if ((unsigned long )s > (unsigned long )str) {
    {
#line 4814
    memmove((void *)str, (void const   *)s, len + 1UL);
    }
  }
#line 4816
  return (str);
}
}
#line 4830 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_trim_right(String *str ) 
{ 
  String *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 4835
  if (! str) {
    {
#line 4836
    tmp = set_errnull(22);
    }
#line 4836
    return ((String *)tmp);
  }
#line 4838
  if (str) {
#line 4838
    if (str->locker) {
      {
#line 4838
      tmp___1 = (*((str->locker)->wrlock))((str->locker)->lock);
#line 4838
      tmp___2 = tmp___1;
      }
    } else {
#line 4838
      tmp___2 = 0;
    }
#line 4838
    err = tmp___2;
  } else {
#line 4838
    err = 22;
  }
#line 4838
  if (err) {
    {
#line 4839
    tmp___0 = set_errnull(err);
    }
#line 4839
    return ((String *)tmp___0);
  }
  {
#line 4841
  ret = str_trim_right_unlocked(str);
  }
#line 4843
  if (str) {
#line 4843
    if (str->locker) {
      {
#line 4843
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 4843
      tmp___5 = tmp___4;
      }
    } else {
#line 4843
      tmp___5 = 0;
    }
#line 4843
    err = tmp___5;
  } else {
#line 4843
    err = 22;
  }
#line 4843
  if (err) {
    {
#line 4844
    tmp___3 = set_errnull(err);
    }
#line 4844
    return ((String *)tmp___3);
  }
#line 4846
  return (ret);
}
}
#line 4859 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_trim_right_unlocked(String *str ) 
{ 
  char *s ;
  void *tmp ;
  unsigned short const   **tmp___0 ;
  String *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 4863
  if (! str) {
    {
#line 4864
    tmp = set_errnull(22);
    }
#line 4864
    return ((String *)tmp);
  }
#line 4866
  s = (str->str + str->length) - 1;
  {
#line 4866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4866
    if ((unsigned long )s > (unsigned long )str->str) {
      {
#line 4866
      tmp___0 = __ctype_b_loc();
      }
#line 4866
      if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*(s + -1))) & 8192)) {
#line 4866
        goto while_break;
      }
    } else {
#line 4866
      goto while_break;
    }
#line 4866
    s --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4869
  tmp___2 = __ctype_b_loc();
  }
#line 4869
  if ((int const   )*(*tmp___2 + (int )((unsigned char )*s)) & 8192) {
    {
#line 4870
    tmp___1 = str_remove_range_unlocked(str, s - str->str, (ssize_t )((str->length - 1UL) - (size_t )(s - str->str)));
    }
#line 4870
    if (! tmp___1) {
#line 4871
      return ((String *)((void *)0));
    }
  }
#line 4873
  return (str);
}
}
#line 4886 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
char *trim_right(char *str ) 
{ 
  char *s ;
  size_t len ;
  void *tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 4891
  if (! str) {
    {
#line 4892
    tmp = set_errnull(22);
    }
#line 4892
    return ((char *)tmp);
  }
  {
#line 4894
  len = strlen((char const   *)str);
#line 4896
  s = str + len;
  }
  {
#line 4896
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4896
    if ((unsigned long )s > (unsigned long )str) {
      {
#line 4896
      tmp___0 = __ctype_b_loc();
#line 4896
      s --;
      }
#line 4896
      if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*s)) & 8192)) {
#line 4896
        goto while_break;
      }
    } else {
#line 4896
      goto while_break;
    }
#line 4897
    *s = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
#line 4899
  return (str);
}
}
#line 4914 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_squeeze(String *str ) 
{ 
  String *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 4919
  if (! str) {
    {
#line 4920
    tmp = set_errnull(22);
    }
#line 4920
    return ((String *)tmp);
  }
#line 4922
  if (str) {
#line 4922
    if (str->locker) {
      {
#line 4922
      tmp___1 = (*((str->locker)->wrlock))((str->locker)->lock);
#line 4922
      tmp___2 = tmp___1;
      }
    } else {
#line 4922
      tmp___2 = 0;
    }
#line 4922
    err = tmp___2;
  } else {
#line 4922
    err = 22;
  }
#line 4922
  if (err) {
    {
#line 4923
    tmp___0 = set_errnull(err);
    }
#line 4923
    return ((String *)tmp___0);
  }
  {
#line 4925
  ret = str_squeeze_unlocked(str);
  }
#line 4927
  if (str) {
#line 4927
    if (str->locker) {
      {
#line 4927
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 4927
      tmp___5 = tmp___4;
      }
    } else {
#line 4927
      tmp___5 = 0;
    }
#line 4927
    err = tmp___5;
  } else {
#line 4927
    err = 22;
  }
#line 4927
  if (err) {
    {
#line 4928
    tmp___3 = set_errnull(err);
    }
#line 4928
    return ((String *)tmp___3);
  }
#line 4930
  return (ret);
}
}
#line 4943 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_squeeze_unlocked(String *str ) 
{ 
  char *s ;
  char *r ;
  int started ;
  int was_space ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  String *tmp___4 ;

  {
#line 4946
  started = 0;
#line 4947
  was_space = 0;
#line 4949
  if (! str) {
    {
#line 4950
    tmp = set_errnull(22);
    }
#line 4950
    return ((String *)tmp);
  }
#line 4952
  s = str->str;
#line 4952
  r = s;
  {
#line 4952
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4952
    if (! ((size_t )(s - str->str) < str->length - 1UL)) {
#line 4952
      goto while_break;
    }
    {
#line 4954
    tmp___2 = __ctype_b_loc();
    }
#line 4954
    if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*s)) & 8192)) {
#line 4956
      if (was_space) {
#line 4956
        if (started) {
#line 4957
          tmp___0 = r;
#line 4957
          r ++;
#line 4957
          *tmp___0 = (char )' ';
        }
      }
#line 4958
      tmp___1 = r;
#line 4958
      r ++;
#line 4958
      *tmp___1 = *s;
#line 4959
      started = 1;
    }
    {
#line 4962
    tmp___3 = __ctype_b_loc();
#line 4962
    was_space = (int )((int const   )*(*tmp___3 + (int )((unsigned char )*s)) & 8192);
#line 4952
    s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4965
  if ((size_t )(r - str->str) < str->length) {
    {
#line 4966
    tmp___4 = str_remove_range_unlocked(str, r - str->str, (ssize_t )((str->length - 1UL) - (size_t )(r - str->str)));
    }
#line 4966
    if (! tmp___4) {
#line 4967
      return ((String *)((void *)0));
    }
  }
#line 4969
  return (str);
}
}
#line 4982 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
char *squeeze(char *str ) 
{ 
  char *s ;
  char *r ;
  int started ;
  int was_space ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 4985
  started = 0;
#line 4986
  was_space = 0;
#line 4988
  if (! str) {
    {
#line 4989
    tmp = set_errnull(22);
    }
#line 4989
    return ((char *)tmp);
  }
#line 4991
  s = str;
#line 4991
  r = s;
  {
#line 4991
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4991
    if (! *s) {
#line 4991
      goto while_break;
    }
    {
#line 4993
    tmp___2 = __ctype_b_loc();
    }
#line 4993
    if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*s)) & 8192)) {
#line 4995
      if (was_space) {
#line 4995
        if (started) {
#line 4996
          tmp___0 = r;
#line 4996
          r ++;
#line 4996
          *tmp___0 = (char )' ';
        }
      }
#line 4997
      tmp___1 = r;
#line 4997
      r ++;
#line 4997
      *tmp___1 = *s;
#line 4998
      started = 1;
    }
    {
#line 5001
    tmp___3 = __ctype_b_loc();
#line 5001
    was_space = (int )((int const   )*(*tmp___3 + (int )((unsigned char )*s)) & 8192);
#line 4991
    s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5004
  *r = (char )'\000';
#line 5006
  return (str);
}
}
#line 5023 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_quote(String const   *str , char const   *quotable , char quote_char ) 
{ 
  String *tmp ;

  {
  {
#line 5025
  tmp = str_quote_with_locker((Locker *)((void *)0), str, quotable, quote_char);
  }
#line 5025
  return (tmp);
}
}
#line 5038 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_quote_unlocked(String const   *str , char const   *quotable , char quote_char ) 
{ 
  String *tmp ;

  {
  {
#line 5040
  tmp = str_quote_with_locker_unlocked((Locker *)((void *)0), str, quotable, quote_char);
  }
#line 5040
  return (tmp);
}
}
#line 5054 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_quote_with_locker(Locker *locker , String const   *str , char const   *quotable ,
                              char quote_char ) 
{ 
  String *ret ;
  size_t i ;
  void *tmp ;
  size_t tmp___0 ;
  String *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp11 ;

  {
#line 5059
  if (! str) {
    {
#line 5060
    tmp = set_errnull(22);
    }
#line 5060
    return ((String *)tmp);
  } else
#line 5059
  if (! quotable) {
    {
#line 5060
    tmp = set_errnull(22);
    }
#line 5060
    return ((String *)tmp);
  }
  {
#line 5062
  ret = str_copy_with_locker(locker, str);
  }
#line 5062
  if (! ret) {
#line 5063
    return ((String *)((void *)0));
  }
#line 5065
  i = (size_t )0;
  {
#line 5065
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5065
    if (! (i < ret->length - 1UL)) {
#line 5065
      goto while_break;
    }
#line 5067
    if (*(ret->str + i)) {
      {
#line 5067
      tmp___2 = strchr(quotable, (int )*(ret->str + i));
      }
#line 5067
      if (tmp___2) {
        {
#line 5069
        tmp___0 = i;
#line 5069
        i ++;
#line 5069
        tmp___1 = str_insert(ret, (ssize_t )tmp___0, "%c", (int )quote_char);
        }
#line 5069
        if (! tmp___1) {
          {
#line 5071
          str_release(ret);
          }
#line 5072
          return ((String *)((void *)0));
        }
      }
    }
#line 5065
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5077
  return (ret);
}
}
#line 5090 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_quote_with_locker_unlocked(Locker *locker , String const   *str , char const   *quotable ,
                                       char quote_char ) 
{ 
  String *ret ;
  size_t i ;
  void *tmp ;
  size_t tmp___0 ;
  String *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp11 ;

  {
#line 5095
  if (! str) {
    {
#line 5096
    tmp = set_errnull(22);
    }
#line 5096
    return ((String *)tmp);
  } else
#line 5095
  if (! quotable) {
    {
#line 5096
    tmp = set_errnull(22);
    }
#line 5096
    return ((String *)tmp);
  }
  {
#line 5098
  ret = str_copy_with_locker_unlocked(locker, str);
  }
#line 5098
  if (! ret) {
#line 5099
    return ((String *)((void *)0));
  }
#line 5101
  i = (size_t )0;
  {
#line 5101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5101
    if (! (i < ret->length - 1UL)) {
#line 5101
      goto while_break;
    }
#line 5103
    if (*(ret->str + i)) {
      {
#line 5103
      tmp___2 = strchr(quotable, (int )*(ret->str + i));
      }
#line 5103
      if (tmp___2) {
        {
#line 5105
        tmp___0 = i;
#line 5105
        i ++;
#line 5105
        tmp___1 = str_insert(ret, (ssize_t )tmp___0, "%c", (int )quote_char);
        }
#line 5105
        if (! tmp___1) {
          {
#line 5107
          str_release(ret);
          }
#line 5108
          return ((String *)((void *)0));
        }
      }
    }
#line 5101
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5113
  return (ret);
}
}
#line 5126 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *quote(char const   *str , char const   *quotable , char quote_char ) 
{ 
  String *tmp ;

  {
  {
#line 5128
  tmp = quote_with_locker((Locker *)((void *)0), str, quotable, quote_char);
  }
#line 5128
  return (tmp);
}
}
#line 5142 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *quote_with_locker(Locker *locker , char const   *str , char const   *quotable ,
                          char quote_char ) 
{ 
  String *ret ;
  size_t i ;
  void *tmp ;
  size_t tmp___0 ;
  String *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 5147
  if (! str) {
    {
#line 5148
    tmp = set_errnull(22);
    }
#line 5148
    return ((String *)tmp);
  } else
#line 5147
  if (! quotable) {
    {
#line 5148
    tmp = set_errnull(22);
    }
#line 5148
    return ((String *)tmp);
  }
  {
#line 5150
  ret = str_create_with_locker(locker, "%s", str);
  }
#line 5150
  if (! ret) {
#line 5151
    return ((String *)((void *)0));
  }
#line 5153
  i = (size_t )0;
  {
#line 5153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5153
    if (! (i < ret->length - 1UL)) {
#line 5153
      goto while_break;
    }
    {
#line 5155
    tmp___2 = strchr(quotable, (int )*(ret->str + i));
    }
#line 5155
    if (tmp___2) {
      {
#line 5157
      tmp___0 = i;
#line 5157
      i ++;
#line 5157
      tmp___1 = str_insert(ret, (ssize_t )tmp___0, "%c", (int )quote_char);
      }
#line 5157
      if (! tmp___1) {
        {
#line 5159
        str_release(ret);
        }
#line 5160
        return ((String *)((void *)0));
      }
    }
#line 5153
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5165
  return (ret);
}
}
#line 5182 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_unquote(String const   *str , char const   *quotable , char quote_char ) 
{ 
  String *tmp ;

  {
  {
#line 5184
  tmp = str_unquote_with_locker((Locker *)((void *)0), str, quotable, quote_char);
  }
#line 5184
  return (tmp);
}
}
#line 5197 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_unquote_unlocked(String const   *str , char const   *quotable , char quote_char ) 
{ 
  String *tmp ;

  {
  {
#line 5199
  tmp = str_unquote_with_locker_unlocked((Locker *)((void *)0), str, quotable, quote_char);
  }
#line 5199
  return (tmp);
}
}
#line 5213 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_unquote_with_locker(Locker *locker , String const   *str , char const   *quotable ,
                                char quote_char ) 
{ 
  String *ret ;
  int i ;
  void *tmp ;
  String *tmp___0 ;
  char *tmp___1 ;

  {
#line 5218
  if (! str) {
    {
#line 5219
    tmp = set_errnull(22);
    }
#line 5219
    return ((String *)tmp);
  } else
#line 5218
  if (! quotable) {
    {
#line 5219
    tmp = set_errnull(22);
    }
#line 5219
    return ((String *)tmp);
  }
  {
#line 5221
  ret = str_copy_with_locker(locker, str);
  }
#line 5221
  if (! ret) {
#line 5222
    return ((String *)((void *)0));
  }
#line 5224
  i = 0;
  {
#line 5224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5224
    if (! (i < (int )ret->length - 2)) {
#line 5224
      goto while_break;
    }
#line 5226
    if ((int )*(ret->str + i) == (int )quote_char) {
#line 5226
      if (*(ret->str + (i + 1))) {
        {
#line 5226
        tmp___1 = strchr(quotable, (int )*(ret->str + (i + 1)));
        }
#line 5226
        if (tmp___1) {
          {
#line 5228
          tmp___0 = str_remove(ret, (ssize_t )i);
          }
#line 5228
          if (! tmp___0) {
            {
#line 5230
            str_release(ret);
            }
#line 5231
            return ((String *)((void *)0));
          }
        }
      }
    }
#line 5224
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5236
  return (ret);
}
}
#line 5250 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_unquote_with_locker_unlocked(Locker *locker , String const   *str , char const   *quotable ,
                                         char quote_char ) 
{ 
  String *ret ;
  int i ;
  void *tmp ;
  String *tmp___0 ;
  char *tmp___1 ;

  {
#line 5255
  if (! str) {
    {
#line 5256
    tmp = set_errnull(22);
    }
#line 5256
    return ((String *)tmp);
  } else
#line 5255
  if (! quotable) {
    {
#line 5256
    tmp = set_errnull(22);
    }
#line 5256
    return ((String *)tmp);
  }
  {
#line 5258
  ret = str_copy_with_locker_unlocked(locker, str);
  }
#line 5258
  if (! ret) {
#line 5259
    return ((String *)((void *)0));
  }
#line 5261
  i = 0;
  {
#line 5261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5261
    if (! (i < (int )ret->length - 2)) {
#line 5261
      goto while_break;
    }
#line 5263
    if ((int )*(ret->str + i) == (int )quote_char) {
#line 5263
      if (*(ret->str + (i + 1))) {
        {
#line 5263
        tmp___1 = strchr(quotable, (int )*(ret->str + (i + 1)));
        }
#line 5263
        if (tmp___1) {
          {
#line 5265
          tmp___0 = str_remove(ret, (ssize_t )i);
          }
#line 5265
          if (! tmp___0) {
            {
#line 5267
            str_release(ret);
            }
#line 5268
            return ((String *)((void *)0));
          }
        }
      }
    }
#line 5261
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5273
  return (ret);
}
}
#line 5286 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *unquote(char const   *str , char const   *quotable , char quote_char ) 
{ 
  String *tmp ;

  {
  {
#line 5288
  tmp = unquote_with_locker((Locker *)((void *)0), str, quotable, quote_char);
  }
#line 5288
  return (tmp);
}
}
#line 5302 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *unquote_with_locker(Locker *locker , char const   *str , char const   *quotable ,
                            char quote_char ) 
{ 
  String *ret ;
  int i ;
  void *tmp ;
  String *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp10 ;

  {
#line 5307
  if (! str) {
    {
#line 5308
    tmp = set_errnull(22);
    }
#line 5308
    return ((String *)tmp);
  } else
#line 5307
  if (! quotable) {
    {
#line 5308
    tmp = set_errnull(22);
    }
#line 5308
    return ((String *)tmp);
  }
  {
#line 5310
  ret = str_create_with_locker(locker, "%s", str);
  }
#line 5310
  if (! ret) {
#line 5311
    return ((String *)((void *)0));
  }
#line 5313
  i = 0;
  {
#line 5313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5313
    if (! (i < (int )ret->length - 2)) {
#line 5313
      goto while_break;
    }
#line 5315
    if ((int )*(ret->str + i) == (int )quote_char) {
      {
#line 5315
      tmp___1 = strchr(quotable, (int )*(ret->str + (i + 1)));
      }
#line 5315
      if (tmp___1) {
        {
#line 5317
        tmp___0 = str_remove(ret, (ssize_t )i);
        }
#line 5317
        if (! tmp___0) {
          {
#line 5319
          str_release(ret);
          }
#line 5320
          return ((String *)((void *)0));
        }
      }
    }
#line 5313
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5325
  return (ret);
}
}
#line 5338
static String *do_encode_with_locker(Locker *locker , char const   *str , size_t length ,
                                     char const   *uncoded , char const   *coded ,
                                     char quote_char , int printable ) ;
#line 5338 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
static char const   hex___0[17]  = 
#line 5338
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
#line 5336 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
static String *do_encode_with_locker(Locker *locker , char const   *str , size_t length ,
                                     char const   *uncoded , char const   *coded ,
                                     char quote_char , int printable ) 
{ 
  String *encoded ;
  char const   *target ;
  char const   *s ;
  void *tmp ;
  String *tmp___0 ;
  String *tmp___1 ;
  String *tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 5343
  if (! str) {
    {
#line 5344
    tmp = set_errnull(22);
    }
#line 5344
    return ((String *)tmp);
  } else
#line 5343
  if (! uncoded) {
    {
#line 5344
    tmp = set_errnull(22);
    }
#line 5344
    return ((String *)tmp);
  } else
#line 5343
  if (! coded) {
    {
#line 5344
    tmp = set_errnull(22);
    }
#line 5344
    return ((String *)tmp);
  }
  {
#line 5346
  encoded = str_create_with_locker_sized(locker, length * 4UL + 1UL, "");
  }
#line 5346
  if (! encoded) {
#line 5347
    return ((String *)((void *)0));
  }
#line 5349
  s = str;
  {
#line 5349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5349
    if (! ((size_t )(s - str) < length)) {
#line 5349
      goto while_break;
    }
#line 5351
    if (*s) {
      {
#line 5351
      tmp___4 = strchr(uncoded, (int )((unsigned char )*s));
#line 5351
      target = (char const   *)tmp___4;
      }
#line 5351
      if (target) {
        {
#line 5353
        tmp___0 = str_append(encoded, "%c%c", (int )((unsigned char )quote_char),
                             (int const   )*(coded + (target - uncoded)));
        }
#line 5353
        if (! tmp___0) {
          {
#line 5355
          str_release(encoded);
          }
#line 5356
          return ((String *)((void *)0));
        }
      } else {
#line 5351
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 5359
    if (printable) {
      {
#line 5359
      tmp___3 = __ctype_b_loc();
      }
#line 5359
      if ((int const   )*(*tmp___3 + (int )((unsigned char )*s)) & 16384) {
#line 5359
        goto _L;
      } else {
        {
#line 5361
        tmp___1 = str_append(encoded, "%cx%c%c", (int )((unsigned char )quote_char),
                             (int const   )hex___0[(int )((unsigned char )*s) >> 4],
                             (int const   )hex___0[(int )((unsigned char )*s) & 15]);
        }
#line 5361
        if (! tmp___1) {
          {
#line 5363
          str_release(encoded);
          }
#line 5364
          return ((String *)((void *)0));
        }
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 5369
      tmp___2 = str_append(encoded, "%c", (int )((unsigned char )*s));
      }
#line 5369
      if (! tmp___2) {
        {
#line 5371
        str_release(encoded);
        }
#line 5372
        return ((String *)((void *)0));
      }
    }
#line 5349
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5377
  return (encoded);
}
}
#line 5388 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
static String *do_decode_with_locker(Locker *locker , char const   *str , size_t length ,
                                     char const   *uncoded , char const   *coded ,
                                     char quote_char , int printable ) 
{ 
  String *decoded ;
  char const   *start ;
  char const   *slosh ;
  char *target ;
  void *tmp ;
  int digits ;
  char const   *s ;
  char c ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  String *tmp___4 ;
  String *tmp___5 ;
  String *tmp___6 ;
  String *tmp___7 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 5395
  if (! str) {
    {
#line 5396
    tmp = set_errnull(22);
    }
#line 5396
    return ((String *)tmp);
  } else
#line 5395
  if (! uncoded) {
    {
#line 5396
    tmp = set_errnull(22);
    }
#line 5396
    return ((String *)tmp);
  } else
#line 5395
  if (! coded) {
    {
#line 5396
    tmp = set_errnull(22);
    }
#line 5396
    return ((String *)tmp);
  }
  {
#line 5398
  decoded = str_create_with_locker_sized(locker, length + 1UL, "");
  }
#line 5398
  if (! decoded) {
#line 5399
    return ((String *)((void *)0));
  }
#line 5401
  start = str;
  {
#line 5401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5401
    if (! ((size_t )(start - str) < length)) {
#line 5401
      goto while_break;
    }
#line 5403
    slosh = start;
    {
#line 5403
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5403
      if (! ((size_t )(slosh - str) < length)) {
#line 5403
        goto while_break___0;
      }
#line 5404
      if ((int const   )*slosh == (int const   )quote_char) {
#line 5405
        goto while_break___0;
      }
#line 5403
      slosh ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5407
    if ((size_t )(slosh - str) == length) {
#line 5408
      goto while_break;
    }
#line 5410
    if (printable) {
      {
#line 5412
      digits = 0;
#line 5413
      s = slosh + 1;
#line 5414
      c = (char )'\000';
#line 5416
      tmp___3 = __ctype_b_loc();
      }
#line 5416
      if ((int const   )*(*tmp___3 + (int )((unsigned char )*s)) & 2048) {
#line 5416
        if ((int const   )*s <= 55) {
#line 5418
          s --;
          {
#line 5420
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 5422
            digits ++;
#line 5423
            c = (char )((int )c << 3);
#line 5423
            s ++;
#line 5423
            c = (char )((int )c | (int )((int const   )*s - 48));
#line 5420
            if (digits < 3) {
              {
#line 5420
              tmp___0 = __ctype_b_loc();
              }
#line 5420
              if ((int const   )*(*tmp___0 + (int )((unsigned char )*(s + 1))) & 2048) {
#line 5420
                if (! ((int const   )*(s + 1) <= 55)) {
#line 5420
                  goto while_break___1;
                }
              } else {
#line 5420
                goto while_break___1;
              }
            } else {
#line 5420
              goto while_break___1;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
#line 5416
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 5427
      if ((int const   )*s == 120) {
        {
#line 5427
        tmp___2 = __ctype_b_loc();
        }
#line 5427
        if ((int const   )*(*tmp___2 + (int )((unsigned char )*(s + 1))) & 4096) {
          {
#line 5429
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 5431
            digits ++;
#line 5432
            c = (char )((int )c << 4);
#line 5434
            s ++;
            {
#line 5437
            if ((int const   )*s == 57) {
#line 5437
              goto case_57;
            }
#line 5437
            if ((int const   )*s == 56) {
#line 5437
              goto case_57;
            }
#line 5437
            if ((int const   )*s == 55) {
#line 5437
              goto case_57;
            }
#line 5437
            if ((int const   )*s == 54) {
#line 5437
              goto case_57;
            }
#line 5437
            if ((int const   )*s == 53) {
#line 5437
              goto case_57;
            }
#line 5437
            if ((int const   )*s == 52) {
#line 5437
              goto case_57;
            }
#line 5437
            if ((int const   )*s == 51) {
#line 5437
              goto case_57;
            }
#line 5437
            if ((int const   )*s == 50) {
#line 5437
              goto case_57;
            }
#line 5437
            if ((int const   )*s == 49) {
#line 5437
              goto case_57;
            }
#line 5437
            if ((int const   )*s == 48) {
#line 5437
              goto case_57;
            }
#line 5440
            if ((int const   )*s == 102) {
#line 5440
              goto case_102;
            }
#line 5440
            if ((int const   )*s == 101) {
#line 5440
              goto case_102;
            }
#line 5440
            if ((int const   )*s == 100) {
#line 5440
              goto case_102;
            }
#line 5440
            if ((int const   )*s == 99) {
#line 5440
              goto case_102;
            }
#line 5440
            if ((int const   )*s == 98) {
#line 5440
              goto case_102;
            }
#line 5440
            if ((int const   )*s == 97) {
#line 5440
              goto case_102;
            }
#line 5443
            if ((int const   )*s == 70) {
#line 5443
              goto case_70;
            }
#line 5443
            if ((int const   )*s == 69) {
#line 5443
              goto case_70;
            }
#line 5443
            if ((int const   )*s == 68) {
#line 5443
              goto case_70;
            }
#line 5443
            if ((int const   )*s == 67) {
#line 5443
              goto case_70;
            }
#line 5443
            if ((int const   )*s == 66) {
#line 5443
              goto case_70;
            }
#line 5443
            if ((int const   )*s == 65) {
#line 5443
              goto case_70;
            }
#line 5434
            goto switch_break;
            case_57: /* CIL Label */ 
            case_56: /* CIL Label */ 
            case_55: /* CIL Label */ 
            case_54: /* CIL Label */ 
            case_53: /* CIL Label */ 
            case_52: /* CIL Label */ 
            case_51: /* CIL Label */ 
            case_50: /* CIL Label */ 
            case_49: /* CIL Label */ 
            case_48: /* CIL Label */ 
#line 5438
            c = (char )((int )c | (int )((int const   )*s - 48));
#line 5439
            goto switch_break;
            case_102: /* CIL Label */ 
            case_101: /* CIL Label */ 
            case_100: /* CIL Label */ 
            case_99: /* CIL Label */ 
            case_98: /* CIL Label */ 
            case_97: /* CIL Label */ 
#line 5441
            c = (char )((int )c | (int )(((int const   )*s - 97) + 10));
#line 5442
            goto switch_break;
            case_70: /* CIL Label */ 
            case_69: /* CIL Label */ 
            case_68: /* CIL Label */ 
            case_67: /* CIL Label */ 
            case_66: /* CIL Label */ 
            case_65: /* CIL Label */ 
#line 5444
            c = (char )((int )c | (int )(((int const   )*s - 65) + 10));
#line 5445
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
#line 5429
            if (digits < 2) {
              {
#line 5429
              tmp___1 = __ctype_b_loc();
              }
#line 5429
              if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*(s + 1))) & 4096)) {
#line 5429
                goto while_break___2;
              }
            } else {
#line 5429
              goto while_break___2;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
#line 5451
      if (digits) {
        {
#line 5453
        tmp___4 = str_append(decoded, "%*.*s%c", slosh - start, slosh - start, start,
                             (int )c);
        }
#line 5453
        if (! tmp___4) {
          {
#line 5455
          str_release(decoded);
          }
#line 5456
          return ((String *)((void *)0));
        }
#line 5459
        slosh = s;
#line 5460
        goto __Cont;
      }
    }
#line 5464
    if (! *(slosh + 1)) {
#line 5464
      goto _L___0;
    } else {
      {
#line 5464
      target = strchr(coded, (int )*(slosh + 1));
      }
#line 5464
      if (! target) {
        _L___0: /* CIL Label */ 
        {
#line 5466
        tmp___5 = str_append(decoded, "%*.*s%c", slosh - start, slosh - start, start,
                             (int )quote_char);
        }
#line 5466
        if (! tmp___5) {
          {
#line 5468
          str_release(decoded);
          }
#line 5469
          return ((String *)((void *)0));
        }
#line 5472
        goto __Cont;
      }
    }
    {
#line 5475
    tmp___6 = str_append(decoded, "%*.*s%c", slosh - start, slosh - start, start,
                         (int const   )*(uncoded + (target - (char *)coded)));
    }
#line 5475
    if (! tmp___6) {
      {
#line 5477
      str_release(decoded);
      }
#line 5478
      return ((String *)((void *)0));
    }
#line 5481
    slosh ++;
    __Cont: /* CIL Label */ 
#line 5401
    start = slosh + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5484
  tmp___7 = str_append(decoded, "%s", start);
  }
#line 5484
  if (! tmp___7) {
    {
#line 5486
    str_release(decoded);
    }
#line 5487
    return ((String *)((void *)0));
  }
#line 5490
  return (decoded);
}
}
#line 5517 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_encode(String const   *str , char const   *uncoded , char const   *coded ,
                   char quote_char , int printable ) 
{ 
  String *tmp ;

  {
  {
#line 5519
  tmp = str_encode_with_locker((Locker *)((void *)0), str, uncoded, coded, quote_char,
                               printable);
  }
#line 5519
  return (tmp);
}
}
#line 5532 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_encode_unlocked(String const   *str , char const   *uncoded , char const   *coded ,
                            char quote_char , int printable ) 
{ 
  String *tmp ;

  {
  {
#line 5534
  tmp = str_encode_with_locker_unlocked((Locker *)((void *)0), str, uncoded, coded,
                                        quote_char, printable);
  }
#line 5534
  return (tmp);
}
}
#line 5548 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_encode_with_locker(Locker *locker , String const   *str , char const   *uncoded ,
                               char const   *coded , char quote_char , int printable ) 
{ 
  String *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 5553
  if (! str) {
    {
#line 5554
    tmp = set_errnull(22);
    }
#line 5554
    return ((String *)tmp);
  } else
#line 5553
  if (! uncoded) {
    {
#line 5554
    tmp = set_errnull(22);
    }
#line 5554
    return ((String *)tmp);
  } else
#line 5553
  if (! coded) {
    {
#line 5554
    tmp = set_errnull(22);
    }
#line 5554
    return ((String *)tmp);
  }
#line 5556
  if (str) {
#line 5556
    if (str->locker) {
      {
#line 5556
      tmp___1 = (*((str->locker)->rdlock))((str->locker)->lock);
#line 5556
      tmp___2 = tmp___1;
      }
    } else {
#line 5556
      tmp___2 = 0;
    }
#line 5556
    err = tmp___2;
  } else {
#line 5556
    err = 22;
  }
#line 5556
  if (err) {
    {
#line 5557
    tmp___0 = set_errnull(err);
    }
#line 5557
    return ((String *)tmp___0);
  }
  {
#line 5559
  ret = str_encode_with_locker_unlocked(locker, str, uncoded, coded, quote_char, printable);
  }
#line 5561
  if (str) {
#line 5561
    if (str->locker) {
      {
#line 5561
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 5561
      tmp___5 = tmp___4;
      }
    } else {
#line 5561
      tmp___5 = 0;
    }
#line 5561
    err = tmp___5;
  } else {
#line 5561
    err = 22;
  }
#line 5561
  if (err) {
    {
#line 5563
    str_release(ret);
#line 5564
    tmp___3 = set_errnull(err);
    }
#line 5564
    return ((String *)tmp___3);
  }
#line 5567
  return (ret);
}
}
#line 5581 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_encode_with_locker_unlocked(Locker *locker , String const   *str , char const   *uncoded ,
                                        char const   *coded , char quote_char , int printable ) 
{ 
  void *tmp ;
  String *tmp___0 ;

  {
#line 5583
  if (! str) {
    {
#line 5584
    tmp = set_errnull(22);
    }
#line 5584
    return ((String *)tmp);
  } else
#line 5583
  if (! uncoded) {
    {
#line 5584
    tmp = set_errnull(22);
    }
#line 5584
    return ((String *)tmp);
  } else
#line 5583
  if (! coded) {
    {
#line 5584
    tmp = set_errnull(22);
    }
#line 5584
    return ((String *)tmp);
  }
  {
#line 5586
  tmp___0 = do_encode_with_locker(locker, (char const   *)str->str, (size_t )(str->length - 1UL),
                                  uncoded, coded, quote_char, printable);
  }
#line 5586
  return (tmp___0);
}
}
#line 5606 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_decode(String const   *str , char const   *uncoded , char const   *coded ,
                   char quote_char , int printable ) 
{ 
  String *tmp ;

  {
  {
#line 5608
  tmp = str_decode_with_locker((Locker *)((void *)0), str, uncoded, coded, quote_char,
                               printable);
  }
#line 5608
  return (tmp);
}
}
#line 5621 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_decode_unlocked(String const   *str , char const   *uncoded , char const   *coded ,
                            char quote_char , int printable ) 
{ 
  String *tmp ;

  {
  {
#line 5623
  tmp = str_decode_with_locker_unlocked((Locker *)((void *)0), str, uncoded, coded,
                                        quote_char, printable);
  }
#line 5623
  return (tmp);
}
}
#line 5637 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_decode_with_locker(Locker *locker , String const   *str , char const   *uncoded ,
                               char const   *coded , char quote_char , int printable ) 
{ 
  String *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 5642
  if (! str) {
    {
#line 5643
    tmp = set_errnull(22);
    }
#line 5643
    return ((String *)tmp);
  } else
#line 5642
  if (! uncoded) {
    {
#line 5643
    tmp = set_errnull(22);
    }
#line 5643
    return ((String *)tmp);
  } else
#line 5642
  if (! coded) {
    {
#line 5643
    tmp = set_errnull(22);
    }
#line 5643
    return ((String *)tmp);
  }
#line 5645
  if (str) {
#line 5645
    if (str->locker) {
      {
#line 5645
      tmp___1 = (*((str->locker)->rdlock))((str->locker)->lock);
#line 5645
      tmp___2 = tmp___1;
      }
    } else {
#line 5645
      tmp___2 = 0;
    }
#line 5645
    err = tmp___2;
  } else {
#line 5645
    err = 22;
  }
#line 5645
  if (err) {
    {
#line 5646
    tmp___0 = set_errnull(err);
    }
#line 5646
    return ((String *)tmp___0);
  }
  {
#line 5648
  ret = str_decode_with_locker_unlocked(locker, str, uncoded, coded, quote_char, printable);
  }
#line 5650
  if (str) {
#line 5650
    if (str->locker) {
      {
#line 5650
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 5650
      tmp___5 = tmp___4;
      }
    } else {
#line 5650
      tmp___5 = 0;
    }
#line 5650
    err = tmp___5;
  } else {
#line 5650
    err = 22;
  }
#line 5650
  if (err) {
    {
#line 5652
    str_release(ret);
#line 5653
    tmp___3 = set_errnull(err);
    }
#line 5653
    return ((String *)tmp___3);
  }
#line 5656
  return (ret);
}
}
#line 5670 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_decode_with_locker_unlocked(Locker *locker , String const   *str , char const   *uncoded ,
                                        char const   *coded , char quote_char , int printable ) 
{ 
  void *tmp ;
  String *tmp___0 ;

  {
#line 5672
  if (! str) {
    {
#line 5673
    tmp = set_errnull(22);
    }
#line 5673
    return ((String *)tmp);
  } else
#line 5672
  if (! uncoded) {
    {
#line 5673
    tmp = set_errnull(22);
    }
#line 5673
    return ((String *)tmp);
  } else
#line 5672
  if (! coded) {
    {
#line 5673
    tmp = set_errnull(22);
    }
#line 5673
    return ((String *)tmp);
  }
  {
#line 5675
  tmp___0 = do_decode_with_locker(locker, (char const   *)str->str, (size_t )(str->length - 1UL),
                                  uncoded, coded, quote_char, printable);
  }
#line 5675
  return (tmp___0);
}
}
#line 5688 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *encode(char const   *str , char const   *uncoded , char const   *coded , char quote_char ,
               int printable ) 
{ 
  String *tmp ;

  {
  {
#line 5690
  tmp = encode_with_locker((Locker *)((void *)0), str, uncoded, coded, quote_char,
                           printable);
  }
#line 5690
  return (tmp);
}
}
#line 5704 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *encode_with_locker(Locker *locker , char const   *str , char const   *uncoded ,
                           char const   *coded , char quote_char , int printable ) 
{ 
  void *tmp ;
  size_t tmp___0 ;
  String *tmp___1 ;

  {
#line 5706
  if (! str) {
    {
#line 5707
    tmp = set_errnull(22);
    }
#line 5707
    return ((String *)tmp);
  } else
#line 5706
  if (! uncoded) {
    {
#line 5707
    tmp = set_errnull(22);
    }
#line 5707
    return ((String *)tmp);
  } else
#line 5706
  if (! coded) {
    {
#line 5707
    tmp = set_errnull(22);
    }
#line 5707
    return ((String *)tmp);
  }
  {
#line 5709
  tmp___0 = strlen(str);
#line 5709
  tmp___1 = do_encode_with_locker(locker, str, tmp___0, uncoded, coded, quote_char,
                                  printable);
  }
#line 5709
  return (tmp___1);
}
}
#line 5722 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *decode(char const   *str , char const   *uncoded , char const   *coded , char quote_char ,
               int printable ) 
{ 
  String *tmp ;

  {
  {
#line 5724
  tmp = decode_with_locker((Locker *)((void *)0), str, uncoded, coded, quote_char,
                           printable);
  }
#line 5724
  return (tmp);
}
}
#line 5738 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *decode_with_locker(Locker *locker , char const   *str , char const   *uncoded ,
                           char const   *coded , char quote_char , int printable ) 
{ 
  void *tmp ;
  size_t tmp___0 ;
  String *tmp___1 ;

  {
#line 5740
  if (! str) {
    {
#line 5741
    tmp = set_errnull(22);
    }
#line 5741
    return ((String *)tmp);
  } else
#line 5740
  if (! uncoded) {
    {
#line 5741
    tmp = set_errnull(22);
    }
#line 5741
    return ((String *)tmp);
  } else
#line 5740
  if (! coded) {
    {
#line 5741
    tmp = set_errnull(22);
    }
#line 5741
    return ((String *)tmp);
  }
  {
#line 5743
  tmp___0 = strlen(str);
#line 5743
  tmp___1 = do_decode_with_locker(locker, str, tmp___0, uncoded, coded, quote_char,
                                  printable);
  }
#line 5743
  return (tmp___1);
}
}
#line 5757 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_lc(String *str ) 
{ 
  String *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 5762
  if (! str) {
    {
#line 5763
    tmp = set_errnull(22);
    }
#line 5763
    return ((String *)tmp);
  }
#line 5765
  if (str) {
#line 5765
    if (str->locker) {
      {
#line 5765
      tmp___1 = (*((str->locker)->wrlock))((str->locker)->lock);
#line 5765
      tmp___2 = tmp___1;
      }
    } else {
#line 5765
      tmp___2 = 0;
    }
#line 5765
    err = tmp___2;
  } else {
#line 5765
    err = 22;
  }
#line 5765
  if (err) {
    {
#line 5766
    tmp___0 = set_errnull(err);
    }
#line 5766
    return ((String *)tmp___0);
  }
  {
#line 5768
  ret = str_lc_unlocked(str);
  }
#line 5770
  if (str) {
#line 5770
    if (str->locker) {
      {
#line 5770
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 5770
      tmp___5 = tmp___4;
      }
    } else {
#line 5770
      tmp___5 = 0;
    }
#line 5770
    err = tmp___5;
  } else {
#line 5770
    err = 22;
  }
#line 5770
  if (err) {
    {
#line 5771
    tmp___3 = set_errnull(err);
    }
#line 5771
    return ((String *)tmp___3);
  }
#line 5773
  return (ret);
}
}
#line 5786 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_lc_unlocked(String *str ) 
{ 
  size_t i ;
  void *tmp ;
  int tmp___0 ;

  {
#line 5790
  if (! str) {
    {
#line 5791
    tmp = set_errnull(22);
    }
#line 5791
    return ((String *)tmp);
  }
#line 5793
  i = (size_t )0;
  {
#line 5793
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5793
    if (! (i < str->length - 1UL)) {
#line 5793
      goto while_break;
    }
    {
#line 5794
    tmp___0 = tolower((int )((unsigned char )*(str->str + i)));
#line 5794
    *(str->str + i) = (char )tmp___0;
#line 5793
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5796
  return (str);
}
}
#line 5810 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
char *lc(char *str ) 
{ 
  char *s ;
  void *tmp ;
  int tmp___0 ;

  {
#line 5814
  if (! str) {
    {
#line 5815
    tmp = set_errnull(22);
    }
#line 5815
    return ((char *)tmp);
  }
#line 5817
  s = str;
  {
#line 5817
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5817
    if (! *s) {
#line 5817
      goto while_break;
    }
    {
#line 5818
    tmp___0 = tolower((int )((unsigned char )*s));
#line 5818
    *s = (char )tmp___0;
#line 5817
    s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5820
  return (str);
}
}
#line 5834 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_lcfirst(String *str ) 
{ 
  String *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 5839
  if (! str) {
    {
#line 5840
    tmp = set_errnull(22);
    }
#line 5840
    return ((String *)tmp);
  }
#line 5842
  if (str) {
#line 5842
    if (str->locker) {
      {
#line 5842
      tmp___1 = (*((str->locker)->wrlock))((str->locker)->lock);
#line 5842
      tmp___2 = tmp___1;
      }
    } else {
#line 5842
      tmp___2 = 0;
    }
#line 5842
    err = tmp___2;
  } else {
#line 5842
    err = 22;
  }
#line 5842
  if (err) {
    {
#line 5843
    tmp___0 = set_errnull(err);
    }
#line 5843
    return ((String *)tmp___0);
  }
  {
#line 5845
  ret = str_lcfirst_unlocked(str);
  }
#line 5847
  if (str) {
#line 5847
    if (str->locker) {
      {
#line 5847
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 5847
      tmp___5 = tmp___4;
      }
    } else {
#line 5847
      tmp___5 = 0;
    }
#line 5847
    err = tmp___5;
  } else {
#line 5847
    err = 22;
  }
#line 5847
  if (err) {
    {
#line 5848
    tmp___3 = set_errnull(err);
    }
#line 5848
    return ((String *)tmp___3);
  }
#line 5850
  return (ret);
}
}
#line 5863 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_lcfirst_unlocked(String *str ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
#line 5865
  if (! str) {
    {
#line 5866
    tmp = set_errnull(22);
    }
#line 5866
    return ((String *)tmp);
  }
#line 5868
  if (str->length > 1UL) {
    {
#line 5869
    tmp___0 = tolower((int )((unsigned char )*(str->str)));
#line 5869
    *(str->str) = (char )tmp___0;
    }
  }
#line 5871
  return (str);
}
}
#line 5885 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
char *lcfirst(char *str ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
#line 5887
  if (! str) {
    {
#line 5888
    tmp = set_errnull(22);
    }
#line 5888
    return ((char *)tmp);
  }
  {
#line 5890
  tmp___0 = tolower((int )((unsigned char )*str));
#line 5890
  *str = (char )tmp___0;
  }
#line 5892
  return (str);
}
}
#line 5906 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_uc(String *str ) 
{ 
  String *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 5911
  if (! str) {
    {
#line 5912
    tmp = set_errnull(22);
    }
#line 5912
    return ((String *)tmp);
  }
#line 5914
  if (str) {
#line 5914
    if (str->locker) {
      {
#line 5914
      tmp___1 = (*((str->locker)->wrlock))((str->locker)->lock);
#line 5914
      tmp___2 = tmp___1;
      }
    } else {
#line 5914
      tmp___2 = 0;
    }
#line 5914
    err = tmp___2;
  } else {
#line 5914
    err = 22;
  }
#line 5914
  if (err) {
    {
#line 5915
    tmp___0 = set_errnull(err);
    }
#line 5915
    return ((String *)tmp___0);
  }
  {
#line 5917
  ret = str_uc_unlocked(str);
  }
#line 5919
  if (str) {
#line 5919
    if (str->locker) {
      {
#line 5919
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 5919
      tmp___5 = tmp___4;
      }
    } else {
#line 5919
      tmp___5 = 0;
    }
#line 5919
    err = tmp___5;
  } else {
#line 5919
    err = 22;
  }
#line 5919
  if (err) {
    {
#line 5920
    tmp___3 = set_errnull(err);
    }
#line 5920
    return ((String *)tmp___3);
  }
#line 5922
  return (ret);
}
}
#line 5935 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_uc_unlocked(String *str ) 
{ 
  size_t i ;
  void *tmp ;
  int tmp___0 ;

  {
#line 5939
  if (! str) {
    {
#line 5940
    tmp = set_errnull(22);
    }
#line 5940
    return ((String *)tmp);
  }
#line 5942
  i = (size_t )0;
  {
#line 5942
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5942
    if (! (i < str->length - 1UL)) {
#line 5942
      goto while_break;
    }
    {
#line 5943
    tmp___0 = toupper((int )((unsigned char )*(str->str + i)));
#line 5943
    *(str->str + i) = (char )tmp___0;
#line 5942
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5945
  return (str);
}
}
#line 5959 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
char *uc(char *str ) 
{ 
  char *s ;
  void *tmp ;
  int tmp___0 ;

  {
#line 5963
  if (! str) {
    {
#line 5964
    tmp = set_errnull(22);
    }
#line 5964
    return ((char *)tmp);
  }
#line 5966
  s = str;
  {
#line 5966
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5966
    if (! *s) {
#line 5966
      goto while_break;
    }
    {
#line 5967
    tmp___0 = toupper((int )((unsigned char )*s));
#line 5967
    *s = (char )tmp___0;
#line 5966
    s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5969
  return (str);
}
}
#line 5983 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_ucfirst(String *str ) 
{ 
  String *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 5988
  if (! str) {
    {
#line 5989
    tmp = set_errnull(22);
    }
#line 5989
    return ((String *)tmp);
  }
#line 5991
  if (str) {
#line 5991
    if (str->locker) {
      {
#line 5991
      tmp___1 = (*((str->locker)->wrlock))((str->locker)->lock);
#line 5991
      tmp___2 = tmp___1;
      }
    } else {
#line 5991
      tmp___2 = 0;
    }
#line 5991
    err = tmp___2;
  } else {
#line 5991
    err = 22;
  }
#line 5991
  if (err) {
    {
#line 5992
    tmp___0 = set_errnull(err);
    }
#line 5992
    return ((String *)tmp___0);
  }
  {
#line 5994
  ret = str_ucfirst_unlocked(str);
  }
#line 5996
  if (str) {
#line 5996
    if (str->locker) {
      {
#line 5996
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 5996
      tmp___5 = tmp___4;
      }
    } else {
#line 5996
      tmp___5 = 0;
    }
#line 5996
    err = tmp___5;
  } else {
#line 5996
    err = 22;
  }
#line 5996
  if (err) {
    {
#line 5997
    tmp___3 = set_errnull(err);
    }
#line 5997
    return ((String *)tmp___3);
  }
#line 5999
  return (ret);
}
}
#line 6012 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
String *str_ucfirst_unlocked(String *str ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
#line 6014
  if (! str) {
    {
#line 6015
    tmp = set_errnull(22);
    }
#line 6015
    return ((String *)tmp);
  }
#line 6017
  if (str->length > 1UL) {
    {
#line 6018
    tmp___0 = toupper((int )((unsigned char )*(str->str)));
#line 6018
    *(str->str) = (char )tmp___0;
    }
  }
#line 6020
  return (str);
}
}
#line 6034 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
char *ucfirst(char *str ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
#line 6036
  if (! str) {
    {
#line 6037
    tmp = set_errnull(22);
    }
#line 6037
    return ((char *)tmp);
  }
  {
#line 6039
  tmp___0 = toupper((int )((unsigned char )*str));
#line 6039
  *str = (char )tmp___0;
  }
#line 6041
  return (str);
}
}
#line 6055 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int str_chop(String *str ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 6060
  if (! str) {
    {
#line 6061
    tmp = set_errno(22);
    }
#line 6061
    return (tmp);
  }
#line 6063
  if (str) {
#line 6063
    if (str->locker) {
      {
#line 6063
      tmp___1 = (*((str->locker)->wrlock))((str->locker)->lock);
#line 6063
      tmp___2 = tmp___1;
      }
    } else {
#line 6063
      tmp___2 = 0;
    }
#line 6063
    err = tmp___2;
  } else {
#line 6063
    err = 22;
  }
#line 6063
  if (err) {
    {
#line 6064
    tmp___0 = set_errno(err);
    }
#line 6064
    return (tmp___0);
  }
  {
#line 6066
  ret = str_chop_unlocked(str);
  }
#line 6068
  if (str) {
#line 6068
    if (str->locker) {
      {
#line 6068
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 6068
      tmp___5 = tmp___4;
      }
    } else {
#line 6068
      tmp___5 = 0;
    }
#line 6068
    err = tmp___5;
  } else {
#line 6068
    err = 22;
  }
#line 6068
  if (err) {
    {
#line 6069
    tmp___3 = set_errno(err);
    }
#line 6069
    return (tmp___3);
  }
#line 6071
  return (ret);
}
}
#line 6084 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int str_chop_unlocked(String *str ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 6088
  if (! str) {
    {
#line 6089
    tmp = set_errno(22);
    }
#line 6089
    return (tmp);
  }
#line 6091
  if (str->length == 1UL) {
    {
#line 6092
    tmp___0 = set_errno(22);
    }
#line 6092
    return (tmp___0);
  }
  {
#line 6094
  ret = (int )*(str->str + (str->length - 2UL));
#line 6096
  tmp___1 = contract(str, (ssize_t )(str->length - 2UL), (size_t )1);
  }
#line 6096
  if (tmp___1 == -1) {
#line 6097
    return (-1);
  }
#line 6099
  return (ret);
}
}
#line 6113 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int chop(char *str ) 
{ 
  int ret ;
  int tmp ;

  {
#line 6117
  if (! str) {
    {
#line 6118
    tmp = set_errno(22);
    }
#line 6118
    return (tmp);
  } else
#line 6117
  if (! *str) {
    {
#line 6118
    tmp = set_errno(22);
    }
#line 6118
    return (tmp);
  }
  {
#line 6120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6120
    if (! *(str + 1)) {
#line 6120
      goto while_break;
    }
#line 6121
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6123
  ret = (int )*str;
#line 6124
  *str = (char )'\000';
#line 6126
  return (ret);
}
}
#line 6141 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int str_chomp(String *str ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 6146
  if (! str) {
    {
#line 6147
    tmp = set_errno(22);
    }
#line 6147
    return (tmp);
  }
#line 6149
  if (str) {
#line 6149
    if (str->locker) {
      {
#line 6149
      tmp___1 = (*((str->locker)->wrlock))((str->locker)->lock);
#line 6149
      tmp___2 = tmp___1;
      }
    } else {
#line 6149
      tmp___2 = 0;
    }
#line 6149
    err = tmp___2;
  } else {
#line 6149
    err = 22;
  }
#line 6149
  if (err) {
    {
#line 6150
    tmp___0 = set_errno(err);
    }
#line 6150
    return (tmp___0);
  }
  {
#line 6152
  ret = str_chomp_unlocked(str);
  }
#line 6154
  if (str) {
#line 6154
    if (str->locker) {
      {
#line 6154
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 6154
      tmp___5 = tmp___4;
      }
    } else {
#line 6154
      tmp___5 = 0;
    }
#line 6154
    err = tmp___5;
  } else {
#line 6154
    err = 22;
  }
#line 6154
  if (err) {
    {
#line 6155
    tmp___3 = set_errno(err);
    }
#line 6155
    return (tmp___3);
  }
#line 6157
  return (ret);
}
}
#line 6170 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int str_chomp_unlocked(String *str ) 
{ 
  char *s ;
  size_t length ;
  int tmp ;
  int tmp___0 ;

  {
#line 6175
  if (! str) {
    {
#line 6176
    tmp = set_errno(22);
    }
#line 6176
    return (tmp);
  }
#line 6178
  if (str->length == 1UL) {
#line 6179
    return (0);
  }
#line 6181
  length = str->length;
#line 6183
  s = (str->str + str->length) - 2;
  {
#line 6183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6183
    if (! ((int )*s == 10)) {
#line 6183
      if (! ((int )*s == 13)) {
#line 6183
        goto while_break;
      }
    }
    {
#line 6185
    tmp___0 = contract(str, (ssize_t )(str->length - 2UL), (size_t )1);
    }
#line 6185
    if (tmp___0 == -1) {
#line 6186
      return (-1);
    }
#line 6183
    s --;
  }
  while_break: /* CIL Label */ ;
  }
#line 6189
  return ((int )(length - str->length));
}
}
#line 6204 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int chomp(char *str ) 
{ 
  char *s ;
  int tmp ;

  {
#line 6208
  if (! str) {
    {
#line 6209
    tmp = set_errno(22);
    }
#line 6209
    return (tmp);
  }
#line 6211
  if ((int )*(str + 0) == 0) {
#line 6212
    return (0);
  }
  {
#line 6214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6214
    if (! *(str + 1)) {
#line 6214
      goto while_break;
    }
#line 6215
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6217
  s = str;
  {
#line 6217
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6217
    if (! ((int )*s == 10)) {
#line 6217
      if (! ((int )*s == 13)) {
#line 6217
        goto while_break___0;
      }
    }
#line 6218
    *s = (char )'\000';
#line 6217
    s --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6220
  return ((int )(str - s));
}
}
#line 6235 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int str_bin(String const   *str ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 6240
  if (! str) {
    {
#line 6241
    tmp = set_errno(22);
    }
#line 6241
    return (tmp);
  }
#line 6243
  if (str) {
#line 6243
    if (str->locker) {
      {
#line 6243
      tmp___1 = (*((str->locker)->rdlock))((str->locker)->lock);
#line 6243
      tmp___2 = tmp___1;
      }
    } else {
#line 6243
      tmp___2 = 0;
    }
#line 6243
    err = tmp___2;
  } else {
#line 6243
    err = 22;
  }
#line 6243
  if (err) {
    {
#line 6244
    tmp___0 = set_errno(err);
    }
#line 6244
    return (tmp___0);
  }
  {
#line 6246
  ret = str_bin_unlocked(str);
  }
#line 6248
  if (str) {
#line 6248
    if (str->locker) {
      {
#line 6248
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 6248
      tmp___5 = tmp___4;
      }
    } else {
#line 6248
      tmp___5 = 0;
    }
#line 6248
    err = tmp___5;
  } else {
#line 6248
    err = 22;
  }
#line 6248
  if (err) {
    {
#line 6249
    tmp___3 = set_errno(err);
    }
#line 6249
    return (tmp___3);
  }
#line 6251
  return (ret);
}
}
#line 6264 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int str_bin_unlocked(String const   *str ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 6266
  if (! str) {
    {
#line 6267
    tmp = set_errno(22);
    }
#line 6267
    return (tmp);
  }
  {
#line 6269
  tmp___0 = bin((char const   *)str->str);
  }
#line 6269
  return (tmp___0);
}
}
#line 6284 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int bin(char const   *str ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 6286
  ret = 0;
#line 6288
  if (! str) {
    {
#line 6289
    tmp = set_errno(22);
    }
#line 6289
    return (tmp);
  }
#line 6291
  if ((int const   )*(str + 0) == 48) {
#line 6291
    if ((int const   )*(str + 1) == 98) {
#line 6292
      str += 2;
    }
  }
  {
#line 6294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6294
    if (! *str) {
#line 6294
      goto while_break;
    }
#line 6296
    ret <<= 1;
    {
#line 6300
    if ((int const   )*str == 48) {
#line 6300
      goto case_48;
    }
#line 6301
    if ((int const   )*str == 49) {
#line 6301
      goto case_49;
    }
#line 6302
    goto switch_default;
    case_48: /* CIL Label */ 
#line 6300
    goto switch_break;
    case_49: /* CIL Label */ 
#line 6301
    ret |= 1;
#line 6301
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 6302
    tmp___0 = set_errno(22);
    }
#line 6302
    return (tmp___0);
    switch_break: /* CIL Label */ ;
    }
#line 6294
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6306
  return (ret);
}
}
#line 6321 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int str_hex(String const   *str ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 6326
  if (! str) {
    {
#line 6327
    tmp = set_errno(22);
    }
#line 6327
    return (tmp);
  }
#line 6329
  if (str) {
#line 6329
    if (str->locker) {
      {
#line 6329
      tmp___1 = (*((str->locker)->rdlock))((str->locker)->lock);
#line 6329
      tmp___2 = tmp___1;
      }
    } else {
#line 6329
      tmp___2 = 0;
    }
#line 6329
    err = tmp___2;
  } else {
#line 6329
    err = 22;
  }
#line 6329
  if (err) {
    {
#line 6330
    tmp___0 = set_errno(err);
    }
#line 6330
    return (tmp___0);
  }
  {
#line 6332
  ret = str_hex_unlocked(str);
  }
#line 6334
  if (str) {
#line 6334
    if (str->locker) {
      {
#line 6334
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 6334
      tmp___5 = tmp___4;
      }
    } else {
#line 6334
      tmp___5 = 0;
    }
#line 6334
    err = tmp___5;
  } else {
#line 6334
    err = 22;
  }
#line 6334
  if (err) {
    {
#line 6335
    tmp___3 = set_errno(err);
    }
#line 6335
    return (tmp___3);
  }
#line 6337
  return (ret);
}
}
#line 6350 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int str_hex_unlocked(String const   *str ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 6352
  if (! str) {
    {
#line 6353
    tmp = set_errno(22);
    }
#line 6353
    return (tmp);
  }
  {
#line 6355
  tmp___0 = hex((char const   *)str->str);
  }
#line 6355
  return (tmp___0);
}
}
#line 6370 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int hex(char const   *str ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 6372
  ret = 0;
#line 6374
  if (! str) {
    {
#line 6375
    tmp = set_errno(22);
    }
#line 6375
    return (tmp);
  }
#line 6377
  if ((int const   )*(str + 0) == 48) {
#line 6377
    if ((int const   )*(str + 1) == 120) {
#line 6378
      str += 2;
    }
  }
  {
#line 6380
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6380
    if (! *str) {
#line 6380
      goto while_break;
    }
#line 6382
    ret <<= 4;
    {
#line 6387
    if ((int const   )*str == 57) {
#line 6387
      goto case_57;
    }
#line 6387
    if ((int const   )*str == 56) {
#line 6387
      goto case_57;
    }
#line 6387
    if ((int const   )*str == 55) {
#line 6387
      goto case_57;
    }
#line 6387
    if ((int const   )*str == 54) {
#line 6387
      goto case_57;
    }
#line 6387
    if ((int const   )*str == 53) {
#line 6387
      goto case_57;
    }
#line 6387
    if ((int const   )*str == 52) {
#line 6387
      goto case_57;
    }
#line 6387
    if ((int const   )*str == 51) {
#line 6387
      goto case_57;
    }
#line 6387
    if ((int const   )*str == 50) {
#line 6387
      goto case_57;
    }
#line 6387
    if ((int const   )*str == 49) {
#line 6387
      goto case_57;
    }
#line 6387
    if ((int const   )*str == 48) {
#line 6387
      goto case_57;
    }
#line 6390
    if ((int const   )*str == 102) {
#line 6390
      goto case_102;
    }
#line 6390
    if ((int const   )*str == 101) {
#line 6390
      goto case_102;
    }
#line 6390
    if ((int const   )*str == 100) {
#line 6390
      goto case_102;
    }
#line 6390
    if ((int const   )*str == 99) {
#line 6390
      goto case_102;
    }
#line 6390
    if ((int const   )*str == 98) {
#line 6390
      goto case_102;
    }
#line 6390
    if ((int const   )*str == 97) {
#line 6390
      goto case_102;
    }
#line 6393
    if ((int const   )*str == 70) {
#line 6393
      goto case_70;
    }
#line 6393
    if ((int const   )*str == 69) {
#line 6393
      goto case_70;
    }
#line 6393
    if ((int const   )*str == 68) {
#line 6393
      goto case_70;
    }
#line 6393
    if ((int const   )*str == 67) {
#line 6393
      goto case_70;
    }
#line 6393
    if ((int const   )*str == 66) {
#line 6393
      goto case_70;
    }
#line 6393
    if ((int const   )*str == 65) {
#line 6393
      goto case_70;
    }
#line 6396
    goto switch_default;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 6388
    ret |= (int )((int const   )*str - 48);
#line 6389
    goto switch_break;
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
#line 6391
    ret |= (int )(((int const   )*str - 97) + 10);
#line 6392
    goto switch_break;
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
#line 6394
    ret |= (int )(((int const   )*str - 65) + 10);
#line 6395
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 6397
    tmp___0 = set_errno(22);
    }
#line 6397
    return (tmp___0);
    switch_break: /* CIL Label */ ;
    }
#line 6380
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6401
  return (ret);
}
}
#line 6418 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int str_oct(String const   *str ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 6423
  if (! str) {
    {
#line 6424
    tmp = set_errno(22);
    }
#line 6424
    return (tmp);
  }
#line 6426
  if (str) {
#line 6426
    if (str->locker) {
      {
#line 6426
      tmp___1 = (*((str->locker)->rdlock))((str->locker)->lock);
#line 6426
      tmp___2 = tmp___1;
      }
    } else {
#line 6426
      tmp___2 = 0;
    }
#line 6426
    err = tmp___2;
  } else {
#line 6426
    err = 22;
  }
#line 6426
  if (err) {
    {
#line 6427
    tmp___0 = set_errno(err);
    }
#line 6427
    return (tmp___0);
  }
  {
#line 6429
  ret = str_oct_unlocked(str);
  }
#line 6431
  if (str) {
#line 6431
    if (str->locker) {
      {
#line 6431
      tmp___4 = (*((str->locker)->unlock))((str->locker)->lock);
#line 6431
      tmp___5 = tmp___4;
      }
    } else {
#line 6431
      tmp___5 = 0;
    }
#line 6431
    err = tmp___5;
  } else {
#line 6431
    err = 22;
  }
#line 6431
  if (err) {
    {
#line 6432
    tmp___3 = set_errno(err);
    }
#line 6432
    return (tmp___3);
  }
#line 6434
  return (ret);
}
}
#line 6447 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int str_oct_unlocked(String const   *str ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 6449
  if (! str) {
    {
#line 6450
    tmp = set_errno(22);
    }
#line 6450
    return (tmp);
  }
  {
#line 6452
  tmp___0 = oct((char const   *)str->str);
  }
#line 6452
  return (tmp___0);
}
}
#line 6469 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int oct(char const   *str ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 6471
  ret = 0;
#line 6473
  if (! str) {
    {
#line 6474
    tmp = set_errno(22);
    }
#line 6474
    return (tmp);
  } else
#line 6473
  if ((int const   )*(str + 0) != 48) {
    {
#line 6474
    tmp = set_errno(22);
    }
#line 6474
    return (tmp);
  }
#line 6476
  if ((int const   )*(str + 1) == 98) {
    {
#line 6477
    tmp___0 = bin(str);
    }
#line 6477
    return (tmp___0);
  }
#line 6479
  if ((int const   )*(str + 1) == 120) {
    {
#line 6480
    tmp___1 = hex(str);
    }
#line 6480
    return (tmp___1);
  }
#line 6482
  str ++;
  {
#line 6482
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6482
    if (! *str) {
#line 6482
      goto while_break;
    }
#line 6484
    ret <<= 3;
    {
#line 6489
    if ((int const   )*str == 55) {
#line 6489
      goto case_55;
    }
#line 6489
    if ((int const   )*str == 54) {
#line 6489
      goto case_55;
    }
#line 6489
    if ((int const   )*str == 53) {
#line 6489
      goto case_55;
    }
#line 6489
    if ((int const   )*str == 52) {
#line 6489
      goto case_55;
    }
#line 6489
    if ((int const   )*str == 51) {
#line 6489
      goto case_55;
    }
#line 6489
    if ((int const   )*str == 50) {
#line 6489
      goto case_55;
    }
#line 6489
    if ((int const   )*str == 49) {
#line 6489
      goto case_55;
    }
#line 6489
    if ((int const   )*str == 48) {
#line 6489
      goto case_55;
    }
#line 6492
    goto switch_default;
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 6490
    ret |= (int )((int const   )*str - 48);
#line 6491
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 6493
    tmp___2 = set_errno(22);
    }
#line 6493
    return (tmp___2);
    switch_break: /* CIL Label */ ;
    }
#line 6482
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6497
  return (ret);
}
}
#line 6577 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
size_t strlcpy(char *dst , char const   *src , size_t size ) 
{ 
  char const   *s ;
  char *d ;
  size_t n ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 6579
  s = src;
#line 6580
  d = dst;
#line 6581
  n = size;
#line 6583
  if (n) {
    {
#line 6584
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6584
      n --;
#line 6584
      if (n) {
#line 6584
        tmp = d;
#line 6584
        d ++;
#line 6584
        tmp___1 = s;
#line 6584
        s ++;
#line 6584
        tmp___0 = (char )*tmp___1;
#line 6584
        *tmp = tmp___0;
#line 6584
        if (! tmp___0) {
#line 6584
          goto while_break;
        }
      } else {
#line 6584
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 6587
  if (n == 0UL) {
#line 6589
    if (size) {
#line 6590
      *d = (char )'\000';
    }
    {
#line 6592
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6592
      tmp___2 = s;
#line 6592
      s ++;
#line 6592
      if (! *tmp___2) {
#line 6592
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 6596
  return ((size_t )((s - src) - 1L));
}
}
#line 6619 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
size_t strlcat(char *dst , char const   *src , size_t size ) 
{ 
  char const   *s ;
  char *d ;
  size_t n ;
  size_t dlen ;
  size_t tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;

  {
#line 6621
  s = src;
#line 6622
  d = dst;
#line 6623
  n = size;
#line 6624
  dlen = (size_t )0;
  {
#line 6626
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6626
    tmp = n;
#line 6626
    n --;
#line 6626
    if (tmp) {
#line 6626
      if (! *d) {
#line 6626
        goto while_break;
      }
    } else {
#line 6626
      goto while_break;
    }
#line 6627
    d ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6629
  dlen = (size_t )(d - dst);
#line 6631
  n ++;
#line 6631
  if (n == 0UL) {
    {
#line 6633
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6633
      tmp___0 = s;
#line 6633
      s ++;
#line 6633
      if (! *tmp___0) {
#line 6633
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 6636
    return ((size_t )(((s + dlen) - src) - 1L));
  }
  {
#line 6639
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 6639
    if (! *s) {
#line 6639
      goto while_break___1;
    }
#line 6640
    if (n - 1UL) {
#line 6641
      n --;
#line 6641
      tmp___1 = d;
#line 6641
      d ++;
#line 6641
      *tmp___1 = (char )*s;
    }
#line 6639
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 6643
  *d = (char )'\000';
#line 6645
  return ((size_t )((s + dlen) - src));
}
}
#line 6666 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
char *cstrcpy(char *dst , char const   *src ) 
{ 
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 6668
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6668
    tmp = dst;
#line 6668
    dst ++;
#line 6668
    tmp___1 = src;
#line 6668
    src ++;
#line 6668
    tmp___0 = (char )*tmp___1;
#line 6668
    *tmp = tmp___0;
#line 6668
    if (! tmp___0) {
#line 6668
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6671
  return (dst - 1);
}
}
#line 6689 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
char *cstrcat(char *dst , char const   *src ) 
{ 
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 6691
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6691
    if (! *dst) {
#line 6691
      goto while_break;
    }
#line 6692
    dst ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6694
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6694
    tmp = dst;
#line 6694
    dst ++;
#line 6694
    tmp___1 = src;
#line 6694
    src ++;
#line 6694
    tmp___0 = (char )*tmp___1;
#line 6694
    *tmp = tmp___0;
#line 6694
    if (! tmp___0) {
#line 6694
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6697
  return (dst - 1);
}
}
#line 6714 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
char *cstrchr(char const   *str , int c ) 
{ 


  {
  {
#line 6716
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6716
    if (*str) {
#line 6716
      if (! ((int const   )*str != (int const   )((char )c))) {
#line 6716
        goto while_break;
      }
    } else {
#line 6716
      goto while_break;
    }
#line 6717
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6719
  return ((char *)str);
}
}
#line 6736 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
char *cstrpbrk(char const   *str , char const   *brk___0 ) 
{ 
  char const   *b ;

  {
  {
#line 6740
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6740
    if (! *str) {
#line 6740
      goto while_break;
    }
#line 6741
    b = brk___0;
    {
#line 6741
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6741
      if (! *b) {
#line 6741
        goto while_break___0;
      }
#line 6742
      if ((int const   )*str == (int const   )*b) {
#line 6743
        return ((char *)str);
      }
#line 6741
      b ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 6740
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6745
  return ((char *)str);
}
}
#line 6762 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
char *cstrrchr(char const   *str , int c ) 
{ 
  char *match ;
  char *tmp ;

  {
#line 6764
  match = (char *)((void *)0);
  {
#line 6766
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6766
    if (! *str) {
#line 6766
      goto while_break;
    }
#line 6767
    if ((int const   )*str == (int const   )((char )c)) {
#line 6768
      match = (char *)str;
    }
#line 6766
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6770
  if (match) {
#line 6770
    tmp = match;
  } else {
#line 6770
    tmp = (char *)str;
  }
#line 6770
  return (tmp);
}
}
#line 6787 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
char *cstrstr(char const   *str , char const   *srch ) 
{ 
  char *s ;
  char *r ;
  char *tmp ;

  {
#line 6789
  if ((int const   )*srch == 0) {
#line 6790
    return ((char *)str);
  }
  {
#line 6792
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 6792
    tmp = cstrchr(str, (int )*srch);
#line 6792
    str = (char const   *)tmp;
    }
#line 6792
    if (! *str) {
#line 6792
      goto while_break;
    }
#line 6794
    s = (char *)str;
#line 6795
    r = (char *)srch;
    {
#line 6797
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6799
      r ++;
#line 6799
      if ((int )*r == 0) {
#line 6800
        return ((char *)str);
      }
#line 6801
      s ++;
#line 6801
      if ((int )*s != (int )*r) {
#line 6802
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 6792
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6806
  return ((char *)str);
}
}
#line 6826 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int asprintf(char **str , char const   *format  , ...) 
{ 
  int ret ;
  va_list args ;

  {
  {
#line 6830
  __builtin_va_start(args, format);
#line 6831
  ret = vasprintf(str, format, args);
#line 6832
  __builtin_va_end(args);
  }
#line 6834
  return (ret);
}
}
#line 6852 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/str.c"
int vasprintf(char **str , char const   *format , va_list args ) 
{ 
  String *tmp ;
  int len ;
  ssize_t tmp___0 ;

  {
  {
#line 6857
  tmp = str_vcreate(format, args);
  }
#line 6857
  if (! tmp) {
#line 6859
    *str = (char *)((void *)0);
#line 6860
    return (-1);
  }
#line 6863
  if (str) {
    {
#line 6864
    *str = cstr((String const   *)tmp);
    }
  }
  {
#line 6865
  tmp___0 = str_length((String const   *)tmp);
#line 6865
  len = (int )tmp___0;
#line 6866
  free((void *)tmp);
  }
#line 6868
  return (len);
}
}
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 34 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/sig.h"
int signal_set_handler(int signo , int flags , signal_handler_t *handler ) ;
#line 35
int signal_addset(int signo_handled , int signo_blocked ) ;
#line 36
int signal_received(int signo ) ;
#line 37
int signal_raise(int signo ) ;
#line 38
int signal_handle(int signo ) ;
#line 39
void signal_handle_all(void) ;
#line 108 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/sig.c"
static real_signal_handler_t g_handler[65]  ;
#line 109 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/sig.c"
static sig_atomic_t volatile   g_received[65]  ;
#line 120 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/sig.c"
static void signal_catcher(int signo ) 
{ 


  {
#line 122
  g_received[signo] += (sig_atomic_t volatile   )1;
#line 123
  return;
}
}
#line 149 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/sig.c"
int signal_set_handler(int signo , int flags , signal_handler_t *handler ) 
{ 
  real_signal_handler_t *h ;
  int tmp ;

  {
  {
#line 151
  h = & g_handler[signo];
#line 153
  sigemptyset(& h->action[0].sa_mask);
#line 154
  sigaddset(& h->action[0].sa_mask, signo);
#line 155
  h->action[0].sa_flags = flags;
  }
#line 157
  if ((unsigned long )handler == (unsigned long )((void (*)(int  ))0)) {
#line 158
    h->action[0].__sigaction_handler.sa_handler = handler;
  } else
#line 157
  if ((unsigned long )handler == (unsigned long )((void (*)(int  ))1)) {
#line 158
    h->action[0].__sigaction_handler.sa_handler = handler;
  } else {
    {
#line 171
    if (signo == 31) {
#line 171
      goto case_31;
    }
#line 171
    if (signo == 7) {
#line 171
      goto case_31;
    }
#line 171
    if (signo == 11) {
#line 171
      goto case_31;
    }
#line 171
    if (signo == 8) {
#line 171
      goto case_31;
    }
#line 171
    if (signo == 6) {
#line 171
      goto case_31;
    }
#line 171
    if (signo == 4) {
#line 171
      goto case_31;
    }
#line 175
    goto switch_default;
    case_31: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 173
    h->action[0].__sigaction_handler.sa_handler = handler;
#line 174
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 176
    h->action[0].__sigaction_handler.sa_handler = & signal_catcher;
#line 177
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 181
  h->handler = handler;
#line 182
  g_received[signo] = (sig_atomic_t volatile   )0;
#line 184
  tmp = sigaction(signo, (struct sigaction  const  */* __restrict  */)(h->action),
                  (struct sigaction */* __restrict  */)((void *)0));
  }
#line 184
  return (tmp);
}
}
#line 201 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/sig.c"
int signal_addset(int signo_handled , int signo_blocked ) 
{ 
  real_signal_handler_t *h ;
  int tmp ;

  {
  {
#line 203
  h = & g_handler[signo_handled];
#line 205
  tmp = sigaddset(& h->action[0].sa_mask, signo_blocked);
  }
#line 205
  return (tmp);
}
}
#line 221 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/sig.c"
int signal_received(int signo ) 
{ 
  int tmp ;

  {
#line 223
  if (signo < 0) {
    {
#line 224
    tmp = set_errno(22);
    }
#line 224
    return (tmp);
  } else
#line 223
  if (signo >= 65) {
    {
#line 224
    tmp = set_errno(22);
    }
#line 224
    return (tmp);
  }
#line 226
  return ((int )g_received[signo]);
}
}
#line 242 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/sig.c"
int signal_raise(int signo ) 
{ 
  int tmp ;

  {
#line 244
  if (signo < 0) {
    {
#line 245
    tmp = set_errno(22);
    }
#line 245
    return (tmp);
  } else
#line 244
  if (signo >= 65) {
    {
#line 245
    tmp = set_errno(22);
    }
#line 245
    return (tmp);
  }
#line 247
  g_received[signo] += (sig_atomic_t volatile   )1;
#line 247
  return ((int )g_received[signo]);
}
}
#line 264 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/sig.c"
int signal_handle(int signo ) 
{ 
  real_signal_handler_t *h ;
  sigset_t origmask[1] ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp6 ;

  {
  {
#line 266
  h = & g_handler[signo];
#line 269
  tmp = sigprocmask(0, (sigset_t const   */* __restrict  */)(& h->action[0].sa_mask),
                    (sigset_t */* __restrict  */)(origmask));
  }
#line 269
  if (tmp == -1) {
#line 270
    return (-1);
  }
  {
#line 272
  (*(g_handler[signo].handler))(signo);
#line 273
  g_received[signo] = (sig_atomic_t volatile   )0;
#line 275
  tmp___0 = sigprocmask(2, (sigset_t const   */* __restrict  */)(origmask), (sigset_t */* __restrict  */)((void *)0));
  }
#line 275
  return (tmp___0);
}
}
#line 292 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/sig.c"
void signal_handle_all(void) 
{ 
  int signo ;
  int tmp ;

  {
#line 296
  signo = 0;
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (signo < 65)) {
#line 296
      goto while_break;
    }
    {
#line 297
    tmp = signal_received(signo);
    }
#line 297
    if (tmp) {
      {
#line 298
      signal_handle(signo);
      }
    }
#line 296
    signo ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  return;
}
}
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 473
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *__file ,
                                                                                            __uid_t __owner ,
                                                                                            __gid_t __group ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 774
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) ttyname_r)(int __fd ,
                                                                                                char *__buf ,
                                                                                                size_t __buflen ) ;
#line 906
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) vhangup)(void) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 33 "/usr/include/pty.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) openpty)(int *__amaster ,
                                                                              int *__aslave ,
                                                                              char *__name ,
                                                                              struct termios  const  *__termp ,
                                                                              struct winsize  const  *__winp ) ;
#line 208 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 283
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 49 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/pseudo.h"
int pty_open(int *masterfd , int *slavefd , char *slavename , size_t slavenamesize ,
             struct termios  const  *slave_termios , struct winsize  const  *slave_winsize ) ;
#line 50
int pty_release(char const   *slavename ) ;
#line 51
int pty_set_owner(char const   *slavename , uid_t uid ) ;
#line 52
int pty_make_controlling_tty(int *slavefd , char const   *slavename ) ;
#line 53
int pty_change_window_size(int masterfd , int row , int col , int xpixel , int ypixel ) ;
#line 54
pid_t pty_fork(int *masterfd , char *slavename , size_t slavenamesize , struct termios  const  *slave_termios ,
               struct winsize  const  *slave_winsize ) ;
#line 174 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/pseudo.c"
static int groupname2gid(char const   *groupname ) 
{ 
  FILE *group ;
  FILE *tmp ;
  char line[8192] ;
  char *gid ;
  int ret ;
  int tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 176
  tmp = fopen((char const   */* __restrict  */)"/etc/group", (char const   */* __restrict  */)"r");
#line 176
  group = tmp;
#line 178
  ret = -1;
  }
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 180
    tmp___1 = fgets((char */* __restrict  */)(line), 8192, (FILE */* __restrict  */)group);
    }
#line 180
    if (! tmp___1) {
#line 180
      goto while_break;
    }
    {
#line 182
    tmp___0 = strncmp((char const   *)(line), "tty:", (size_t )4);
    }
#line 182
    if (! tmp___0) {
      {
#line 184
      gid = strchr((char const   *)(line + 4), ':');
      }
#line 184
      if (gid) {
        {
#line 185
        ret = atoi((char const   *)(gid + 1));
        }
      }
#line 187
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  fclose(group);
  }
#line 193
  return (ret);
}
}
#line 196 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/pseudo.c"
static int uid2gid(uid_t uid ) 
{ 
  FILE *passwd ;
  FILE *tmp ;
  char line[8192] ;
  char *ptr ;
  int ret ;
  int tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 198
  tmp = fopen((char const   */* __restrict  */)"/etc/passwd", (char const   */* __restrict  */)"r");
#line 198
  passwd = tmp;
#line 200
  ret = -1;
  }
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 202
    tmp___1 = fgets((char */* __restrict  */)(line), 8192, (FILE */* __restrict  */)passwd);
    }
#line 202
    if (! tmp___1) {
#line 202
      goto while_break;
    }
    {
#line 204
    ptr = strchr((char const   *)(line), ':');
    }
#line 204
    if (ptr) {
      {
#line 204
      ptr = strchr((char const   *)(ptr + 1), ':');
      }
#line 204
      if (ptr) {
        {
#line 204
        tmp___0 = atoi((char const   *)(ptr + 1));
        }
#line 204
        if (tmp___0 == (int )uid) {
          {
#line 204
          ptr = strchr((char const   *)(ptr + 1), ':');
          }
#line 204
          if (ptr) {
            {
#line 207
            ret = atoi((char const   *)(ptr + 1));
            }
#line 208
            goto while_break;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 212
  fclose(passwd);
  }
#line 214
  return (ret);
}
}
#line 217 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/pseudo.c"
int pty_open(int *masterfd , int *slavefd , char *slavename , size_t slavenamesize ,
             struct termios  const  *slave_termios , struct winsize  const  *slave_winsize ) 
{ 
  struct termios master_termios[1] ;
  char buf[64] ;
  char *name ;
  int err ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp20 ;
  int __cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;

  {
#line 226
  name = buf;
#line 232
  if (! masterfd) {
    {
#line 233
    tmp = __errno_location();
#line 233
    *tmp = 22;
    }
#line 233
    return (-1);
  } else
#line 232
  if (! slavefd) {
    {
#line 233
    tmp = __errno_location();
#line 233
    *tmp = 22;
    }
#line 233
    return (-1);
  } else
#line 232
  if (! slavename) {
    {
#line 233
    tmp = __errno_location();
#line 233
    *tmp = 22;
    }
#line 233
    return (-1);
  } else
#line 232
  if (slavenamesize < 64UL) {
    {
#line 233
    tmp = __errno_location();
#line 233
    *tmp = 22;
    }
#line 233
    return (-1);
  }
  {
#line 237
  tmp___0 = openpty(masterfd, slavefd, (char *)((void *)0), (struct termios  const  *)((void *)0),
                    (struct winsize  const  *)((void *)0));
  }
#line 237
  if (tmp___0 == -1) {
#line 238
    return (-1);
  }
  {
#line 243
  err = ttyname_r(*slavefd, buf, (size_t )64);
  }
#line 243
  if (err) {
    {
#line 245
    close(*masterfd);
#line 246
    close(*slavefd);
#line 247
    tmp___1 = __errno_location();
#line 247
    *tmp___1 = err;
    }
#line 247
    return (-1);
  }
  {
#line 260
  tmp___3 = strlcpy(slavename, (char const   *)name, slavenamesize);
  }
#line 260
  if (tmp___3 >= slavenamesize) {
    {
#line 262
    close(*masterfd);
#line 263
    close(*slavefd);
#line 264
    tmp___2 = __errno_location();
#line 264
    *tmp___2 = 28;
    }
#line 264
    return (-1);
  }
  {
#line 512
  tmp___5 = tcgetattr(*masterfd, master_termios);
  }
#line 512
  if (tmp___5 != -1) {
#line 514
    if (master_termios[0].c_lflag & 8U) {
      {
#line 516
      master_termios[0].c_lflag &= 4294967287U;
#line 518
      tmp___4 = tcsetattr(*masterfd, 0, (struct termios  const  *)(master_termios));
      }
#line 518
      if (tmp___4 == -1) {
        {
#line 520
        close(*masterfd);
#line 521
        close(*slavefd);
        }
#line 522
        return (-1);
      }
    }
  }
#line 529
  if (slave_termios) {
    {
#line 529
    tmp___6 = tcsetattr(*slavefd, 0, slave_termios);
    }
#line 529
    if (tmp___6 == -1) {
      {
#line 531
      close(*masterfd);
#line 532
      close(*slavefd);
      }
#line 533
      return (-1);
    }
  }
#line 538
  if (slave_winsize) {
    {
#line 538
    tmp___7 = ioctl(*slavefd, 21524UL, slave_winsize);
    }
#line 538
    if (tmp___7 == -1) {
      {
#line 540
      close(*masterfd);
#line 541
      close(*slavefd);
      }
#line 542
      return (-1);
    }
  }
#line 545
  return (0);
}
}
#line 561 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/pseudo.c"
int pty_release(char const   *slavename ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 563
  if (! slavename) {
    {
#line 564
    tmp = __errno_location();
#line 564
    *tmp = 22;
    }
#line 564
    return (-1);
  }
  {
#line 566
  tmp___0 = chown(slavename, (uid_t )0, (gid_t )0);
  }
#line 566
  if (tmp___0 == -1) {
#line 567
    return (-1);
  }
  {
#line 569
  tmp___1 = chmod(slavename, (__mode_t )((((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3)));
  }
#line 569
  if (tmp___1 == -1) {
#line 570
    return (-1);
  }
#line 572
  return (0);
}
}
#line 595 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/pseudo.c"
int pty_set_owner(char const   *slavename , uid_t uid ) 
{ 
  mode_t mode ;
  struct stat status[1] ;
  int gid ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 597
  mode = (mode_t )(384 | (128 >> 3));
#line 601
  tmp = stat((char const   */* __restrict  */)slavename, (struct stat */* __restrict  */)(status));
  }
#line 601
  if (tmp == -1) {
#line 602
    return (-1);
  }
  {
#line 604
  gid = groupname2gid("tty");
  }
#line 604
  if (gid == -1) {
    {
#line 606
    gid = uid2gid(uid);
#line 607
    mode |= (unsigned int )((128 >> 3) >> 3);
    }
  }
#line 610
  if (status[0].st_uid != uid) {
#line 610
    goto _L;
  } else
#line 610
  if (status[0].st_gid != (__gid_t )gid) {
    _L: /* CIL Label */ 
    {
#line 611
    tmp___1 = chown(slavename, uid, (__gid_t )gid);
    }
#line 611
    if (tmp___1 == -1) {
      {
#line 612
      tmp___0 = __errno_location();
      }
#line 612
      if (*tmp___0 != 30) {
#line 613
        return (-1);
      } else
#line 612
      if (status[0].st_uid != uid) {
#line 613
        return (-1);
      }
    }
  }
#line 615
  if ((status[0].st_mode & (unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3))) != mode) {
    {
#line 616
    tmp___3 = chmod(slavename, mode);
    }
#line 616
    if (tmp___3 == -1) {
      {
#line 617
      tmp___2 = __errno_location();
      }
#line 617
      if (*tmp___2 != 30) {
#line 618
        return (-1);
      } else
#line 617
      if (status[0].st_mode & (unsigned int )((256 >> 3) | ((256 >> 3) >> 3))) {
#line 618
        return (-1);
      }
    }
  }
#line 620
  return (0);
}
}
#line 637 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/pseudo.c"
int pty_make_controlling_tty(int *slavefd , char const   *slavename ) 
{ 
  int fd ;
  void (*old)(int  ) ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 644
  if (! slavefd) {
    {
#line 645
    tmp = __errno_location();
#line 645
    *tmp = 22;
    }
#line 645
    return (-1);
  } else
#line 644
  if (*slavefd < 0) {
    {
#line 645
    tmp = __errno_location();
#line 645
    *tmp = 22;
    }
#line 645
    return (-1);
  } else
#line 644
  if (! slavename) {
    {
#line 645
    tmp = __errno_location();
#line 645
    *tmp = 22;
    }
#line 645
    return (-1);
  }
  {
#line 649
  fd = open("/dev/tty", 258);
  }
#line 649
  if (fd >= 0) {
    {
#line 651
    ioctl(fd, 21538UL, (void *)0);
#line 652
    close(fd);
    }
  }
  {
#line 656
  setsid();
#line 672
  tmp___0 = ioctl(*slavefd, 21518UL, (void *)0);
  }
#line 672
  if (tmp___0 == -1) {
#line 673
    return (-1);
  }
  {
#line 679
  old = signal(1, (void (*)(int  ))1);
#line 680
  vhangup();
#line 681
  signal(1, old);
#line 684
  fd = open(slavename, 2);
  }
#line 684
  if (fd >= 0) {
    {
#line 687
    close(*slavefd);
#line 688
    *slavefd = fd;
    }
  }
  {
#line 695
  fd = open("/dev/tty", 2);
  }
#line 695
  if (fd == -1) {
#line 696
    return (-1);
  }
  {
#line 698
  close(fd);
  }
#line 700
  return (0);
}
}
#line 716 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/pseudo.c"
int pty_change_window_size(int masterfd , int row , int col , int xpixel , int ypixel ) 
{ 
  struct winsize win ;
  int *tmp ;
  int tmp___0 ;

  {
#line 720
  if (masterfd < 0) {
    {
#line 721
    tmp = __errno_location();
#line 721
    *tmp = 22;
    }
#line 721
    return (-1);
  } else
#line 720
  if (row < 0) {
    {
#line 721
    tmp = __errno_location();
#line 721
    *tmp = 22;
    }
#line 721
    return (-1);
  } else
#line 720
  if (col < 0) {
    {
#line 721
    tmp = __errno_location();
#line 721
    *tmp = 22;
    }
#line 721
    return (-1);
  } else
#line 720
  if (xpixel < 0) {
    {
#line 721
    tmp = __errno_location();
#line 721
    *tmp = 22;
    }
#line 721
    return (-1);
  } else
#line 720
  if (ypixel < 0) {
    {
#line 721
    tmp = __errno_location();
#line 721
    *tmp = 22;
    }
#line 721
    return (-1);
  }
  {
#line 723
  win.ws_row = (unsigned short )row;
#line 724
  win.ws_col = (unsigned short )col;
#line 725
  win.ws_xpixel = (unsigned short )xpixel;
#line 726
  win.ws_ypixel = (unsigned short )ypixel;
#line 728
  tmp___0 = ioctl(masterfd, 21524UL, & win);
  }
#line 728
  return (tmp___0);
}
}
#line 757 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/pseudo.c"
pid_t pty_fork(int *masterfd , char *slavename , size_t slavenamesize , struct termios  const  *slave_termios ,
               struct winsize  const  *slave_winsize ) 
{ 
  int slavefd ;
  pid_t pid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 769
  tmp = pty_open(masterfd, & slavefd, slavename, slavenamesize, slave_termios, slave_winsize);
  }
#line 769
  if (tmp == -1) {
#line 770
    return (-1);
  }
  {
#line 772
  pid = fork();
  }
  {
#line 774
  if (pid == -1) {
#line 774
    goto case_neg_1;
  }
#line 780
  if (pid == 0) {
#line 780
    goto case_0;
  }
#line 810
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 775
  pty_release((char const   *)slavename);
#line 776
  close(slavefd);
#line 777
  close(*masterfd);
  }
#line 778
  return (-1);
  case_0: /* CIL Label */ 
  {
#line 784
  tmp___0 = pty_make_controlling_tty(& slavefd, (char const   *)slavename);
  }
#line 784
  if (tmp___0 == -1) {
    {
#line 785
    _exit(1);
    }
  }
#line 789
  if (slavefd != 0) {
    {
#line 789
    tmp___1 = dup2(slavefd, 0);
    }
#line 789
    if (tmp___1 == -1) {
      {
#line 790
      _exit(1);
      }
    }
  }
#line 792
  if (slavefd != 1) {
    {
#line 792
    tmp___2 = dup2(slavefd, 1);
    }
#line 792
    if (tmp___2 == -1) {
      {
#line 793
      _exit(1);
      }
    }
  }
#line 795
  if (slavefd != 2) {
    {
#line 795
    tmp___3 = dup2(slavefd, 2);
    }
#line 795
    if (tmp___3 == -1) {
      {
#line 796
      _exit(1);
      }
    }
  }
#line 800
  if (slavefd != 0) {
#line 800
    if (slavefd != 1) {
#line 800
      if (slavefd != 2) {
        {
#line 801
        close(slavefd);
        }
      }
    }
  }
  {
#line 805
  close(*masterfd);
  }
#line 807
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 814
  close(slavefd);
  }
#line 816
  return (pid);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 356 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 320 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 109 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.h"
char const   *prog_name(void) ;
#line 67 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/daemon.h"
void *daemon_parse_config(char const   *path , void *obj , daemon_config_parser_t *parser ) ;
#line 123 "libslack/slack/list.h"
List *list_sort(List *list , list_cmp_t *cmp ) ;
#line 41 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.h"
Map *map_create(map_release_t *destroy ) ;
#line 56
void map_release(Map *map ) ;
#line 62
int map_add(Map *map , void const   *key , void *value ) ;
#line 64
int map_put(Map *map , void const   *key , void *value ) ;
#line 68
int map_remove(Map *map , void const   *key ) ;
#line 70
void *map_get(Map *map , void const   *key ) ;
#line 91
List *map_keys(Map *map ) ;
#line 65 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.h"
int error(char const   *format  , ...) ;
#line 57 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.h"
long limit_path(void) ;
#line 54 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.h"
char *mem_strdup(char const   *str ) ;
#line 31 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.h"
char const   *prop_get(char const   *name ) ;
#line 32
char const   *prop_get_or(char const   *name , char const   *default_value ) ;
#line 33
char const   *prop_set(char const   *name , char const   *value ) ;
#line 34
int prop_get_int(char const   *name ) ;
#line 35
int prop_get_int_or(char const   *name , int default_value ) ;
#line 36
int prop_set_int(char const   *name , int value ) ;
#line 37
double prop_get_double(char const   *name ) ;
#line 38
double prop_get_double_or(char const   *name , double default_value ) ;
#line 39
double prop_set_double(char const   *name , double value ) ;
#line 40
int prop_get_bool(char const   *name ) ;
#line 41
int prop_get_bool_or(char const   *name , int default_value ) ;
#line 42
int prop_set_bool(char const   *name , int value ) ;
#line 43
int prop_unset(char const   *name ) ;
#line 44
int prop_save(void) ;
#line 45
int prop_clear(void) ;
#line 46
int prop_locker(Locker *locker ) ;
#line 133 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
static struct __anonstruct_g_70 g  =    {0, (Prop *)((void *)0), (char *)((void *)0), 0, (Locker *)((void *)0)};
#line 153 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
static Prop *prop_create(Map *map , Prop *defaults ) 
{ 
  Prop *prop ;
  void *tmp ;

  {
  {
#line 157
  tmp = malloc(sizeof(Prop ));
#line 157
  prop = (Prop *)tmp;
  }
#line 157
  if (! prop) {
#line 158
    return ((Prop *)((void *)0));
  }
#line 160
  prop->map = map;
#line 161
  prop->defaults = defaults;
#line 163
  return (prop);
}
}
#line 174 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
static void prop_release(Prop *prop ) 
{ 


  {
#line 176
  if (! prop) {
#line 177
    return;
  }
  {
#line 179
  map_release(prop->map);
#line 180
  prop_release(prop->defaults);
#line 181
  free((void *)prop);
  }
#line 182
  return;
}
}
#line 192 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
static int key_cmp(char const   **a , char const   **b ) 
{ 
  int tmp ;

  {
  {
#line 194
  tmp = strcmp(*a, *b);
  }
#line 194
  return (tmp);
}
}
#line 197 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
static char const   *special_code  =    "abfnrtv";
#line 198 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
static char const   *special_char  =    "\a\b\f\n\r\t\v";
#line 199 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
static char const   *eq  =    "=";
#line 213 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
static String *quote_special(char const   *src ) 
{ 
  String *tmp ;

  {
  {
#line 215
  tmp = encode(src, special_char, special_code, (char )'\\', 1);
  }
#line 215
  return (tmp);
}
}
#line 230 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
static String *unquote_special(char const   *src ) 
{ 
  String *tmp ;

  {
  {
#line 232
  tmp = decode(src, special_char, special_code, (char )'\\', 1);
  }
#line 232
  return (tmp);
}
}
#line 244 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
static String *quote_equals(char const   *src ) 
{ 
  String *tmp ;

  {
  {
#line 246
  tmp = encode(src, eq, eq, (char )'\\', 0);
  }
#line 246
  return (tmp);
}
}
#line 258 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
static String *unquote_equals(char const   *src ) 
{ 
  String *tmp ;

  {
  {
#line 260
  tmp = decode(src, eq, eq, (char )'\\', 0);
  }
#line 260
  return (tmp);
}
}
#line 272 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
static char *user_home(void) 
{ 
  struct passwd *pwent ;
  char *home ;
  __uid_t tmp ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
#line 275
  home = (char *)((void *)0);
#line 277
  if (g.home) {
#line 278
    return (g.home);
  }
  {
#line 280
  tmp = getuid();
#line 280
  pwent = getpwuid(tmp);
  }
#line 280
  if (pwent) {
#line 281
    home = pwent->pw_dir;
  }
#line 283
  if (home) {
    {
#line 283
    tmp___2 = strlen((char const   *)home);
    }
#line 283
    if (tmp___2) {
      {
#line 283
      tmp___1 = mem_strdup((char const   *)home);
#line 283
      g.home = tmp___1;
      }
    } else {
#line 283
      g.home = (char *)((void *)0);
    }
  } else {
#line 283
    g.home = (char *)((void *)0);
  }
#line 283
  return (g.home);
}
}
#line 299 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
static void prop_parse(Map *map , char const   *path , char *line , size_t lineno ) 
{ 
  String *prop ;
  String *name ;
  char *p ;
  char *eq___0 ;
  char *value ;
  char *val ;
  char *key ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 306
  prop = unquote_special((char const   *)line);
  }
#line 306
  if (! prop) {
    {
#line 308
    error("prop: Out of memory");
    }
#line 309
    return;
  }
  {
#line 314
  p = cstr((String const   *)prop);
#line 314
  eq___0 = strchr((char const   *)p, '=');
  }
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (! eq___0) {
#line 314
      goto while_break;
    }
#line 315
    if ((unsigned long )eq___0 == (unsigned long )p) {
#line 316
      goto while_break;
    } else
#line 315
    if ((int )*(eq___0 + -1) != 92) {
#line 316
      goto while_break;
    }
    {
#line 314
    eq___0 = strchr((char const   *)(eq___0 + 1), '=');
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  if (! eq___0) {
    {
#line 320
    error("prop: %s line %d: Expected \'=\'\n%s", path, lineno, line);
#line 321
    str_release(prop);
#line 322
    set_errno(22);
    }
#line 323
    return;
  }
#line 328
  value = eq___0 + 1;
  {
#line 330
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 330
    tmp = __ctype_b_loc();
    }
#line 330
    if (! ((int const   )*(*tmp + (int )((unsigned char )*(value + 0))) & 8192)) {
#line 330
      goto while_break___0;
    }
#line 331
    value ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 333
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 333
    if ((unsigned long )eq___0 > (unsigned long )p) {
      {
#line 333
      tmp___0 = __ctype_b_loc();
      }
#line 333
      if ((int const   )*(*tmp___0 + (int )((unsigned char )*(eq___0 + -1))) & 8192) {
#line 333
        if (! ((unsigned long )eq___0 == (unsigned long )(p + 1))) {
#line 333
          if (! ((int )*(eq___0 + -2) != 92)) {
#line 333
            goto while_break___1;
          }
        }
      } else {
#line 333
        goto while_break___1;
      }
    } else {
#line 333
      goto while_break___1;
    }
#line 334
    eq___0 --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 336
  *eq___0 = (char )'\000';
#line 340
  if ((unsigned long )eq___0 > (unsigned long )(p + 1)) {
    {
#line 340
    tmp___1 = __ctype_b_loc();
    }
#line 340
    if ((int const   )*(*tmp___1 + (int )((unsigned char )*(eq___0 + -1))) & 8192) {
#line 340
      if ((int )*(eq___0 + -2) == 92) {
#line 342
        *(eq___0 + -2) = *(eq___0 + -1);
#line 343
        *(eq___0 + -1) = (char )'\000';
      }
    }
  }
  {
#line 348
  name = unquote_equals((char const   *)p);
  }
#line 348
  if (! name) {
    {
#line 350
    error("prop: Out of memory");
#line 351
    str_release(prop);
    }
#line 352
    return;
  }
  {
#line 355
  key = cstr((String const   *)name);
  }
#line 359
  if ((int )*value == 92) {
#line 360
    value ++;
  }
  {
#line 364
  val = mem_strdup((char const   *)value);
  }
#line 364
  if (! val) {
    {
#line 366
    error("prop: Out of memory");
#line 367
    str_release(prop);
#line 368
    str_release(name);
    }
#line 369
    return;
  }
  {
#line 372
  tmp___2 = map_add(map, (void const   *)key, (void *)val);
  }
#line 372
  if (tmp___2 == -1) {
    {
#line 374
    error("prop: %s line %d: Property %s already defined\n%s", path, lineno, name,
          line);
#line 375
    free((void *)val);
    }
  }
  {
#line 378
  str_release(prop);
#line 379
  str_release(name);
  }
#line 380
  return;
}
}
#line 392 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
static Prop *prop_load(char const   *path , Prop *defaults ) 
{ 
  Prop *prop ;
  Map *map ;
  void *tmp ;

  {
  {
#line 397
  map = map_create((map_release_t *)(& free));
  }
#line 397
  if (! map) {
#line 398
    return ((Prop *)((void *)0));
  }
  {
#line 400
  tmp = daemon_parse_config(path, (void *)map, (daemon_config_parser_t *)(& prop_parse));
  }
#line 400
  if (! tmp) {
    {
#line 402
    map_release(map);
    }
#line 403
    return ((Prop *)((void *)0));
  }
  {
#line 406
  prop = prop_create(map, defaults);
  }
#line 406
  if (! prop) {
    {
#line 408
    map_release(map);
    }
#line 409
    return ((Prop *)((void *)0));
  }
#line 412
  return (prop);
}
}
#line 434 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
static int prop_init(void) 
{ 
  char *path ;
  Prop *prop ;
  Prop *prop_next ;
  char *home ;
  int writable ;
  size_t path_len ;
  long tmp ;
  void *tmp___0 ;
  char *progname ;
  char *sep ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  Map *map ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 437
  prop = (Prop *)((void *)0);
#line 440
  writable = 0;
#line 443
  tmp = limit_path();
#line 443
  path_len = (size_t )tmp;
#line 445
  tmp___0 = malloc(path_len * sizeof(char ));
#line 445
  path = (char *)tmp___0;
  }
#line 445
  if (! path) {
#line 446
    return (-1);
  }
  {
#line 450
  snprintf((char */* __restrict  */)path, path_len, (char const   */* __restrict  */)"%s%cproperties%capp",
           "/etc", '/', '/');
#line 451
  prop_next = prop_load((char const   *)path, prop);
  }
#line 451
  if (prop_next) {
#line 452
    prop = prop_next;
  }
  {
#line 456
  home = user_home();
  }
#line 456
  if (home) {
    {
#line 458
    snprintf((char */* __restrict  */)path, path_len, (char const   */* __restrict  */)"%s%c.properties%capp",
             home, '/', '/');
#line 459
    prop_next = prop_load((char const   *)path, prop);
    }
#line 459
    if (prop_next) {
#line 460
      prop = prop_next;
    }
  }
  {
#line 463
  tmp___3 = prog_name();
  }
#line 463
  if (tmp___3) {
    {
#line 467
    tmp___1 = prog_name();
#line 467
    progname = mem_strdup(tmp___1);
    }
#line 467
    if (! progname) {
      {
#line 469
      free((void *)path);
#line 470
      prop_release(prop);
      }
#line 471
      return (-1);
    }
    {
#line 474
    sep = strchr((char const   *)progname, '/');
    }
    {
#line 474
    while (1) {
      while_continue: /* CIL Label */ ;
#line 474
      if (! sep) {
#line 474
        goto while_break;
      }
      {
#line 475
      tmp___2 = sep;
#line 475
      sep ++;
#line 475
      *tmp___2 = (char )'-';
#line 474
      sep = strchr((char const   *)sep, '/');
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 479
    snprintf((char */* __restrict  */)path, path_len, (char const   */* __restrict  */)"%s%cproperties%capp.%s",
             "/etc", '/', '/', progname);
#line 480
    prop_next = prop_load((char const   *)path, prop);
    }
#line 480
    if (prop_next) {
#line 481
      prop = prop_next;
    }
#line 485
    if (home) {
      {
#line 487
      snprintf((char */* __restrict  */)path, path_len, (char const   */* __restrict  */)"%s%c.properties%capp.%s",
               home, '/', '/', progname);
#line 488
      prop_next = prop_load((char const   *)path, prop);
      }
#line 488
      if (prop_next) {
#line 490
        prop = prop_next;
#line 491
        writable = 1;
      }
    }
    {
#line 495
    free((void *)progname);
    }
  }
#line 500
  if (! writable) {
    {
#line 504
    map = map_create((map_release_t *)(& free));
    }
#line 504
    if (! map) {
      {
#line 506
      free((void *)path);
#line 507
      prop_release(prop);
      }
#line 508
      return (-1);
    }
    {
#line 511
    prop_next = prop_create(map, prop);
    }
#line 511
    if (! prop_next) {
      {
#line 513
      free((void *)path);
#line 514
      prop_release(prop);
#line 515
      map_release(map);
      }
#line 516
      return (-1);
    }
#line 519
    prop = prop_next;
  }
  {
#line 522
  free((void *)path);
#line 523
  g.prop = prop;
#line 524
  g.init = 1;
  }
#line 526
  return (0);
}
}
#line 540 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
char const   *prop_get(char const   *name ) 
{ 
  Prop *p ;
  char const   *value ;
  int err ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
#line 543
  value = (char const   *)((void *)0);
#line 546
  if (g.locker) {
    {
#line 546
    tmp___0 = (*((g.locker)->wrlock))((g.locker)->lock);
#line 546
    err = tmp___0;
    }
  } else {
#line 546
    err = 0;
  }
#line 546
  if (err) {
    {
#line 547
    tmp = set_errnull(err);
    }
#line 547
    return ((char const   *)tmp);
  }
#line 549
  if (! g.init) {
    {
#line 549
    tmp___1 = prop_init();
    }
#line 549
    if (tmp___1 == -1) {
#line 551
      if (g.locker) {
        {
#line 551
        (*((g.locker)->unlock))((g.locker)->lock);
        }
      }
#line 552
      return ((char const   *)((void *)0));
    }
  }
#line 555
  p = g.prop;
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    if (! p) {
#line 555
      goto while_break;
    }
    {
#line 556
    tmp___2 = map_get(p->map, (void const   *)name);
#line 556
    value = (char const   *)tmp___2;
    }
#line 556
    if (value) {
#line 557
      goto while_break;
    }
#line 555
    p = p->defaults;
  }
  while_break: /* CIL Label */ ;
  }
#line 559
  if (g.locker) {
    {
#line 559
    tmp___4 = (*((g.locker)->unlock))((g.locker)->lock);
#line 559
    err = tmp___4;
    }
  } else {
#line 559
    err = 0;
  }
#line 559
  if (err) {
    {
#line 560
    tmp___3 = set_errnull(err);
    }
#line 560
    return ((char const   *)tmp___3);
  }
#line 562
  return (value);
}
}
#line 576 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
char const   *prop_get_or(char const   *name , char const   *default_value ) 
{ 
  char const   *prop ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 578
  tmp = prop_get(name);
#line 578
  prop = tmp;
  }
#line 580
  if (prop) {
#line 580
    tmp___0 = prop;
  } else {
#line 580
    tmp___0 = default_value;
  }
#line 580
  return (tmp___0);
}
}
#line 597 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
char const   *prop_set(char const   *name , char const   *value ) 
{ 
  char *val ;
  int err ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
#line 602
  if (g.locker) {
    {
#line 602
    tmp___0 = (*((g.locker)->wrlock))((g.locker)->lock);
#line 602
    err = tmp___0;
    }
  } else {
#line 602
    err = 0;
  }
#line 602
  if (err) {
    {
#line 603
    tmp = set_errnull(err);
    }
#line 603
    return ((char const   *)tmp);
  }
#line 605
  if (! g.init) {
    {
#line 605
    tmp___1 = prop_init();
    }
#line 605
    if (tmp___1 == -1) {
#line 607
      if (g.locker) {
        {
#line 607
        (*((g.locker)->unlock))((g.locker)->lock);
        }
      }
#line 608
      return ((char const   *)((void *)0));
    }
  }
  {
#line 611
  val = mem_strdup(value);
  }
#line 611
  if (! val) {
#line 613
    if (g.locker) {
      {
#line 613
      (*((g.locker)->unlock))((g.locker)->lock);
      }
    }
#line 614
    return ((char const   *)((void *)0));
  }
  {
#line 617
  tmp___2 = map_put((g.prop)->map, (void const   *)name, (void *)val);
  }
#line 617
  if (tmp___2 == -1) {
    {
#line 619
    free((void *)val);
    }
#line 620
    if (g.locker) {
      {
#line 620
      (*((g.locker)->unlock))((g.locker)->lock);
      }
    }
#line 621
    return ((char const   *)((void *)0));
  }
#line 624
  g.dirty = 1;
#line 626
  if (g.locker) {
    {
#line 626
    tmp___4 = (*((g.locker)->unlock))((g.locker)->lock);
#line 626
    err = tmp___4;
    }
  } else {
#line 626
    err = 0;
  }
#line 626
  if (err) {
    {
#line 627
    tmp___3 = set_errnull(err);
    }
#line 627
    return ((char const   *)tmp___3);
  }
#line 629
  return ((char const   *)val);
}
}
#line 644 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
int prop_get_int(char const   *name ) 
{ 
  int tmp ;

  {
  {
#line 646
  tmp = prop_get_int_or(name, 0);
  }
#line 646
  return (tmp);
}
}
#line 661 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
int prop_get_int_or(char const   *name , int default_value ) 
{ 
  char const   *prop ;
  char const   *tmp ;
  int val ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp9 ;

  {
  {
#line 663
  tmp = prop_get(name);
#line 663
  prop = tmp;
  }
#line 666
  if (prop) {
    {
#line 666
    tmp___2 = sscanf((char const   */* __restrict  */)prop, (char const   */* __restrict  */)" %d ",
                     & val);
    }
#line 666
    if (tmp___2) {
#line 666
      tmp___1 = val;
    } else {
#line 666
      tmp___1 = default_value;
    }
  } else {
#line 666
    tmp___1 = default_value;
  }
#line 666
  return (tmp___1);
}
}
#line 682 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
int prop_set_int(char const   *name , int value ) 
{ 
  char buf[128] ;
  int tmp___0 ;
  char const   *tmp___1 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 685
  snprintf((char */* __restrict  */)(buf), (size_t )128, (char const   */* __restrict  */)"%d",
           value);
#line 686
  tmp___1 = prop_set(name, (char const   *)(buf));
  }
#line 686
  if (tmp___1) {
#line 686
    tmp___0 = value;
  } else {
#line 686
    tmp___0 = 0;
  }
#line 686
  return (tmp___0);
}
}
#line 701 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
double prop_get_double(char const   *name ) 
{ 
  double tmp ;

  {
  {
#line 703
  tmp = prop_get_double_or(name, 0.0);
  }
#line 703
  return (tmp);
}
}
#line 718 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
double prop_get_double_or(char const   *name , double default_value ) 
{ 
  char const   *prop ;
  char const   *tmp ;
  double val ;
  double tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp9 ;

  {
  {
#line 720
  tmp = prop_get(name);
#line 720
  prop = tmp;
  }
#line 723
  if (prop) {
    {
#line 723
    tmp___2 = sscanf((char const   */* __restrict  */)prop, (char const   */* __restrict  */)"%lg",
                     & val);
    }
#line 723
    if (tmp___2) {
#line 723
      tmp___1 = val;
    } else {
#line 723
      tmp___1 = default_value;
    }
  } else {
#line 723
    tmp___1 = default_value;
  }
#line 723
  return (tmp___1);
}
}
#line 739 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
double prop_set_double(char const   *name , double value ) 
{ 
  char buf[128] ;
  double tmp___0 ;
  char const   *tmp___1 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 742
  snprintf((char */* __restrict  */)(buf), (size_t )128, (char const   */* __restrict  */)"%g",
           value);
#line 743
  tmp___1 = prop_set(name, (char const   *)(buf));
  }
#line 743
  if (tmp___1) {
#line 743
    tmp___0 = value;
  } else {
#line 743
    tmp___0 = (double )-1;
  }
#line 743
  return (tmp___0);
}
}
#line 759 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
int prop_get_bool(char const   *name ) 
{ 
  int tmp ;

  {
  {
#line 761
  tmp = prop_get_bool_or(name, 0);
  }
#line 761
  return (tmp);
}
}
#line 779 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
int prop_get_bool_or(char const   *name , int default_value ) 
{ 
  char const   *prop ;
  char const   *tmp ;
  char buf[128] ;
  int val ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 781
  tmp = prop_get(name);
#line 781
  prop = tmp;
  }
#line 785
  if (! prop) {
#line 786
    return (default_value);
  }
  {
#line 788
  tmp___0 = sscanf((char const   */* __restrict  */)prop, (char const   */* __restrict  */)" %d ",
                   & val);
  }
#line 788
  if (tmp___0) {
#line 789
    return (val);
  }
  {
#line 791
  tmp___1 = sscanf((char const   */* __restrict  */)prop, (char const   */* __restrict  */)" %s ",
                   buf);
  }
#line 791
  if (tmp___1) {
#line 793
    if ((int )buf[0] == 116) {
#line 793
      goto _L___2;
    } else
#line 793
    if ((int )buf[0] == 84) {
      _L___2: /* CIL Label */ 
#line 793
      if ((int )buf[1] == 114) {
#line 793
        goto _L___1;
      } else
#line 793
      if ((int )buf[1] == 82) {
        _L___1: /* CIL Label */ 
#line 793
        if ((int )buf[2] == 117) {
#line 793
          goto _L___0;
        } else
#line 793
        if ((int )buf[2] == 85) {
          _L___0: /* CIL Label */ 
#line 793
          if ((int )buf[3] == 101) {
#line 793
            goto _L;
          } else
#line 793
          if ((int )buf[3] == 69) {
            _L: /* CIL Label */ 
#line 793
            if ((int )buf[4] == 0) {
#line 798
              return (1);
            }
          }
        }
      }
    }
#line 800
    if ((int )buf[0] == 102) {
#line 800
      goto _L___7;
    } else
#line 800
    if ((int )buf[0] == 70) {
      _L___7: /* CIL Label */ 
#line 800
      if ((int )buf[1] == 97) {
#line 800
        goto _L___6;
      } else
#line 800
      if ((int )buf[1] == 65) {
        _L___6: /* CIL Label */ 
#line 800
        if ((int )buf[2] == 108) {
#line 800
          goto _L___5;
        } else
#line 800
        if ((int )buf[2] == 76) {
          _L___5: /* CIL Label */ 
#line 800
          if ((int )buf[3] == 115) {
#line 800
            goto _L___4;
          } else
#line 800
          if ((int )buf[3] == 83) {
            _L___4: /* CIL Label */ 
#line 800
            if ((int )buf[4] == 101) {
#line 800
              goto _L___3;
            } else
#line 800
            if ((int )buf[4] == 69) {
              _L___3: /* CIL Label */ 
#line 800
              if ((int )buf[5] == 0) {
#line 806
                return (0);
              }
            }
          }
        }
      }
    }
#line 808
    if ((int )buf[0] == 121) {
#line 808
      goto _L___10;
    } else
#line 808
    if ((int )buf[0] == 89) {
      _L___10: /* CIL Label */ 
#line 808
      if ((int )buf[1] == 101) {
#line 808
        goto _L___9;
      } else
#line 808
      if ((int )buf[1] == 69) {
        _L___9: /* CIL Label */ 
#line 808
        if ((int )buf[2] == 115) {
#line 808
          goto _L___8;
        } else
#line 808
        if ((int )buf[2] == 83) {
          _L___8: /* CIL Label */ 
#line 808
          if ((int )buf[3] == 0) {
#line 812
            return (1);
          }
        }
      }
    }
#line 814
    if ((int )buf[0] == 110) {
#line 814
      goto _L___12;
    } else
#line 814
    if ((int )buf[0] == 78) {
      _L___12: /* CIL Label */ 
#line 814
      if ((int )buf[1] == 111) {
#line 814
        goto _L___11;
      } else
#line 814
      if ((int )buf[1] == 79) {
        _L___11: /* CIL Label */ 
#line 814
        if ((int )buf[2] == 0) {
#line 817
          return (0);
        }
      }
    }
#line 819
    if ((int )buf[0] == 111) {
#line 819
      goto _L___14;
    } else
#line 819
    if ((int )buf[0] == 79) {
      _L___14: /* CIL Label */ 
#line 819
      if ((int )buf[1] == 110) {
#line 819
        goto _L___13;
      } else
#line 819
      if ((int )buf[1] == 78) {
        _L___13: /* CIL Label */ 
#line 819
        if ((int )buf[2] == 0) {
#line 822
          return (1);
        }
      }
    }
#line 824
    if ((int )buf[0] == 111) {
#line 824
      goto _L___17;
    } else
#line 824
    if ((int )buf[0] == 79) {
      _L___17: /* CIL Label */ 
#line 824
      if ((int )buf[1] == 102) {
#line 824
        goto _L___16;
      } else
#line 824
      if ((int )buf[1] == 70) {
        _L___16: /* CIL Label */ 
#line 824
        if ((int )buf[2] == 102) {
#line 824
          goto _L___15;
        } else
#line 824
        if ((int )buf[2] == 70) {
          _L___15: /* CIL Label */ 
#line 824
          if ((int )buf[3] == 0) {
#line 828
            return (0);
          }
        }
      }
    }
  }
#line 831
  return (default_value);
}
}
#line 847 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
int prop_set_bool(char const   *name , int value ) 
{ 
  int tmp ;

  {
  {
#line 849
  tmp = prop_set_int(name, value);
  }
#line 849
  return (tmp);
}
}
#line 866 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
int prop_unset(char const   *name ) 
{ 
  Prop *p ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 871
  if (g.locker) {
    {
#line 871
    tmp___0 = (*((g.locker)->wrlock))((g.locker)->lock);
#line 871
    err = tmp___0;
    }
  } else {
#line 871
    err = 0;
  }
#line 871
  if (err) {
    {
#line 872
    tmp = set_errno(err);
    }
#line 872
    return (tmp);
  }
#line 874
  if (! g.init) {
    {
#line 874
    tmp___1 = prop_init();
    }
#line 874
    if (tmp___1 == -1) {
#line 876
      if (g.locker) {
        {
#line 876
        (*((g.locker)->unlock))((g.locker)->lock);
        }
      }
#line 877
      return (-1);
    }
  }
#line 880
  p = g.prop;
  {
#line 880
  while (1) {
    while_continue: /* CIL Label */ ;
#line 880
    if (! p) {
#line 880
      goto while_break;
    }
    {
#line 881
    map_remove(p->map, (void const   *)name);
#line 880
    p = p->defaults;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 883
  g.dirty = 1;
#line 885
  if (g.locker) {
    {
#line 885
    tmp___3 = (*((g.locker)->unlock))((g.locker)->lock);
#line 885
    err = tmp___3;
    }
  } else {
#line 885
    err = 0;
  }
#line 885
  if (err) {
    {
#line 886
    tmp___2 = set_errno(err);
    }
#line 886
    return (tmp___2);
  }
#line 888
  return (0);
}
}
#line 914 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
int prop_save(void) 
{ 
  char *path ;
  size_t path_len ;
  size_t len ;
  char *home ;
  char *progname ;
  char *sep ;
  struct stat status[1] ;
  List *keys ;
  Lister *k ;
  FILE *file ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  List *tmp___15 ;
  char const   *key ;
  void *tmp___16 ;
  char const   *value ;
  void *tmp___17 ;
  String *lhs ;
  String *rhs ;
  String *lhs2 ;
  char *tmp___18 ;
  ssize_t tmp___19 ;
  String *tmp___20 ;
  ssize_t tmp___21 ;
  unsigned short const   **tmp___22 ;
  char *tmp___23 ;
  ssize_t tmp___24 ;
  String *tmp___25 ;
  unsigned short const   **tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  void *__cil_tmp51 ;
  int __cil_tmp52 ;
  void *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;

  {
  {
#line 927
  tmp = prop_get_bool_or("save", 1);
  }
#line 927
  if (! tmp) {
#line 928
    return (0);
  }
#line 930
  if (g.locker) {
    {
#line 930
    tmp___1 = (*((g.locker)->wrlock))((g.locker)->lock);
#line 930
    err = tmp___1;
    }
  } else {
#line 930
    err = 0;
  }
#line 930
  if (err) {
    {
#line 931
    tmp___0 = set_errno(err);
    }
#line 931
    return (tmp___0);
  }
#line 933
  if (! g.dirty) {
#line 935
    if (g.locker) {
      {
#line 935
      tmp___3 = (*((g.locker)->unlock))((g.locker)->lock);
#line 935
      err = tmp___3;
      }
    } else {
#line 935
      err = 0;
    }
#line 935
    if (err) {
      {
#line 936
      tmp___2 = set_errno(err);
      }
#line 936
      return (tmp___2);
    }
#line 938
    return (0);
  }
  {
#line 941
  tmp___5 = prog_name();
  }
#line 941
  if (! tmp___5) {
#line 943
    if (g.locker) {
      {
#line 943
      (*((g.locker)->unlock))((g.locker)->lock);
      }
    }
    {
#line 944
    tmp___4 = set_errno(22);
    }
#line 944
    return (tmp___4);
  }
  {
#line 947
  home = user_home();
  }
#line 947
  if (! home) {
#line 949
    if (g.locker) {
      {
#line 949
      (*((g.locker)->unlock))((g.locker)->lock);
      }
    }
    {
#line 950
    tmp___6 = set_errno(22);
    }
#line 950
    return (tmp___6);
  }
  {
#line 953
  tmp___7 = limit_path();
#line 953
  path_len = (size_t )tmp___7;
#line 955
  tmp___8 = malloc(path_len * sizeof(char ));
#line 955
  path = (char *)tmp___8;
  }
#line 955
  if (! path) {
#line 957
    if (g.locker) {
      {
#line 957
      (*((g.locker)->unlock))((g.locker)->lock);
      }
    }
#line 958
    return (-1);
  }
  {
#line 961
  snprintf((char */* __restrict  */)path, path_len, (char const   */* __restrict  */)"%s%c.properties",
           home, '/');
#line 963
  tmp___9 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(status));
  }
#line 963
  if (tmp___9 == -1) {
    {
#line 963
    tmp___10 = mkdir((char const   *)path, (__mode_t )448);
    }
#line 963
    if (tmp___10 == -1) {
      {
#line 965
      free((void *)path);
      }
#line 966
      if (g.locker) {
        {
#line 966
        (*((g.locker)->unlock))((g.locker)->lock);
        }
      }
#line 967
      return (-1);
    }
  }
  {
#line 970
  tmp___12 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(status));
  }
#line 970
  if (tmp___12 == -1) {
#line 970
    goto _L;
  } else
#line 970
  if (((status[0].st_mode & 61440U) == 16384U) == 0) {
    _L: /* CIL Label */ 
    {
#line 972
    free((void *)path);
    }
#line 973
    if (g.locker) {
      {
#line 973
      (*((g.locker)->unlock))((g.locker)->lock);
      }
    }
    {
#line 974
    tmp___11 = set_errno(22);
    }
#line 974
    return (tmp___11);
  }
  {
#line 977
  tmp___13 = prog_name();
#line 977
  progname = mem_strdup(tmp___13);
  }
#line 977
  if (! progname) {
    {
#line 979
    free((void *)path);
    }
#line 980
    if (g.locker) {
      {
#line 980
      (*((g.locker)->unlock))((g.locker)->lock);
      }
    }
#line 981
    return (-1);
  }
  {
#line 984
  sep = strchr((char const   *)progname, '/');
  }
  {
#line 984
  while (1) {
    while_continue: /* CIL Label */ ;
#line 984
    if (! sep) {
#line 984
      goto while_break;
    }
    {
#line 985
    tmp___14 = sep;
#line 985
    sep ++;
#line 985
    *tmp___14 = (char )'-';
#line 984
    sep = strchr((char const   *)sep, '/');
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 987
  len = strlen((char const   *)path);
#line 988
  snprintf((char */* __restrict  */)(path + len), path_len - len, (char const   */* __restrict  */)"%capp.%s",
           '/', progname);
#line 989
  free((void *)progname);
#line 991
  file = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"w");
#line 992
  free((void *)path);
  }
#line 994
  if (! file) {
#line 996
    if (g.locker) {
      {
#line 996
      (*((g.locker)->unlock))((g.locker)->lock);
      }
    }
#line 997
    return (-1);
  }
  {
#line 1000
  keys = map_keys((g.prop)->map);
  }
#line 1000
  if (! keys) {
#line 1002
    if (g.locker) {
      {
#line 1002
      (*((g.locker)->unlock))((g.locker)->lock);
      }
    }
#line 1003
    return (-1);
  }
  {
#line 1006
  tmp___15 = list_sort(keys, (list_cmp_t *)(& key_cmp));
  }
#line 1006
  if (! tmp___15) {
    {
#line 1008
    list_release(keys);
    }
#line 1009
    if (g.locker) {
      {
#line 1009
      (*((g.locker)->unlock))((g.locker)->lock);
      }
    }
#line 1010
    return (-1);
  }
  {
#line 1013
  k = lister_create(keys);
  }
#line 1013
  if (! k) {
    {
#line 1015
    list_release(keys);
    }
#line 1016
    if (g.locker) {
      {
#line 1016
      (*((g.locker)->unlock))((g.locker)->lock);
      }
    }
#line 1017
    return (-1);
  }
  {
#line 1020
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1020
    tmp___30 = lister_has_next(k);
    }
#line 1020
    if (! (tmp___30 == 1)) {
#line 1020
      goto while_break___0;
    }
    {
#line 1022
    tmp___16 = lister_next(k);
#line 1022
    key = (char const   *)tmp___16;
#line 1023
    tmp___17 = map_get((g.prop)->map, (void const   *)key);
#line 1023
    value = (char const   *)tmp___17;
#line 1028
    lhs = quote_equals(key);
    }
#line 1028
    if (! lhs) {
      {
#line 1030
      fclose(file);
#line 1031
      lister_release(k);
#line 1032
      list_release(keys);
      }
#line 1033
      if (g.locker) {
        {
#line 1033
        (*((g.locker)->unlock))((g.locker)->lock);
        }
      }
#line 1034
      return (-1);
    }
    {
#line 1039
    tmp___18 = cstr((String const   *)lhs);
#line 1039
    lhs2 = quote_special((char const   *)tmp___18);
    }
#line 1039
    if (! lhs2) {
      {
#line 1041
      fclose(file);
#line 1042
      lister_release(k);
#line 1043
      list_release(keys);
#line 1044
      str_release(lhs);
      }
#line 1045
      if (g.locker) {
        {
#line 1045
        (*((g.locker)->unlock))((g.locker)->lock);
        }
      }
#line 1046
      return (-1);
    }
    {
#line 1049
    str_release(lhs);
#line 1050
    lhs = lhs2;
#line 1054
    tmp___21 = str_length((String const   *)lhs);
    }
#line 1054
    if (tmp___21) {
      {
#line 1054
      tmp___22 = __ctype_b_loc();
#line 1054
      tmp___23 = cstr((String const   *)lhs);
#line 1054
      tmp___24 = str_length((String const   *)lhs);
      }
#line 1054
      if ((int const   )*(*tmp___22 + (int )((unsigned char )*(tmp___23 + (tmp___24 - 1L)))) & 8192) {
        {
#line 1056
        tmp___19 = str_length((String const   *)lhs);
#line 1056
        tmp___20 = str_insert(lhs, tmp___19 - 1L, "\\");
        }
#line 1056
        if (! tmp___20) {
          {
#line 1058
          fclose(file);
#line 1059
          lister_release(k);
#line 1060
          list_release(keys);
#line 1061
          str_release(lhs);
          }
#line 1062
          if (g.locker) {
            {
#line 1062
            (*((g.locker)->unlock))((g.locker)->lock);
            }
          }
#line 1063
          return (-1);
        }
      }
    }
    {
#line 1069
    rhs = quote_special(value);
    }
#line 1069
    if (! rhs) {
      {
#line 1071
      fclose(file);
#line 1072
      lister_release(k);
#line 1073
      list_release(keys);
#line 1074
      str_release(lhs);
      }
#line 1075
      if (g.locker) {
        {
#line 1075
        (*((g.locker)->unlock))((g.locker)->lock);
        }
      }
#line 1076
      return (-1);
    }
    {
#line 1081
    tmp___26 = __ctype_b_loc();
#line 1081
    tmp___27 = cstr((String const   *)rhs);
    }
#line 1081
    if ((int const   )*(*tmp___26 + (int )((unsigned char )*(tmp___27 + 0))) & 8192) {
      {
#line 1083
      tmp___25 = str_insert(rhs, (ssize_t )0, "\\");
      }
#line 1083
      if (! tmp___25) {
        {
#line 1085
        fclose(file);
#line 1086
        lister_release(k);
#line 1087
        list_release(keys);
#line 1088
        str_release(lhs);
        }
#line 1089
        if (g.locker) {
          {
#line 1089
          (*((g.locker)->unlock))((g.locker)->lock);
          }
        }
#line 1090
        return (-1);
      }
    }
    {
#line 1094
    tmp___28 = cstr((String const   *)rhs);
#line 1094
    tmp___29 = cstr((String const   *)lhs);
#line 1094
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%s=%s\n",
            tmp___29, tmp___28);
#line 1095
    str_release(lhs);
#line 1096
    str_release(rhs);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1099
  fclose(file);
#line 1100
  lister_release(k);
#line 1101
  list_release(keys);
#line 1102
  g.dirty = 0;
  }
#line 1104
  if (g.locker) {
    {
#line 1104
    tmp___32 = (*((g.locker)->unlock))((g.locker)->lock);
#line 1104
    err = tmp___32;
    }
  } else {
#line 1104
    err = 0;
  }
#line 1104
  if (err) {
    {
#line 1105
    tmp___31 = set_errno(err);
    }
#line 1105
    return (tmp___31);
  }
#line 1107
  return (0);
}
}
#line 1121 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
int prop_clear(void) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1125
  if (g.locker) {
    {
#line 1125
    tmp___0 = (*((g.locker)->wrlock))((g.locker)->lock);
#line 1125
    err = tmp___0;
    }
  } else {
#line 1125
    err = 0;
  }
#line 1125
  if (err) {
    {
#line 1126
    tmp = set_errno(err);
    }
#line 1126
    return (tmp);
  }
  {
#line 1128
  prop_release(g.prop);
#line 1129
  g.prop = (Prop *)((void *)0);
#line 1130
  g.init = 0;
#line 1131
  g.dirty = 0;
  }
#line 1133
  if (g.locker) {
    {
#line 1133
    tmp___2 = (*((g.locker)->unlock))((g.locker)->lock);
#line 1133
    err = tmp___2;
    }
  } else {
#line 1133
    err = 0;
  }
#line 1133
  if (err) {
    {
#line 1134
    tmp___1 = set_errno(err);
    }
#line 1134
    return (tmp___1);
  }
#line 1136
  return (0);
}
}
#line 1152 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prop.c"
int prop_locker(Locker *locker ) 
{ 
  int tmp ;

  {
#line 1154
  if (g.locker) {
    {
#line 1155
    tmp = set_errno(22);
    }
#line 1155
    return (tmp);
  }
#line 1157
  g.locker = locker;
#line 1159
  return (0);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 262 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 36 "libslack/getopt.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 48 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.h"
void msg_release(Msg *mesg ) ;
#line 50
void msg_out(Msg *dst , char const   *format  , ...) ;
#line 55
Msg *msg_create_fd_with_locker(Locker *locker , int fd ) ;
#line 61
Msg *msg_create_file_with_locker(Locker *locker , char const   *path ) ;
#line 63
Msg *msg_create_syslog_with_locker(Locker *locker , char const   *ident , int option ,
                                   int facility , int priority ) ;
#line 59 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.h"
void msg(char const   *format  , ...) ;
#line 139 "libslack/getopt.h"
extern int getopt_long(int __argc , char * const  *__argv , char const   *__shortopts ,
                       struct option  const  *__longopts , int *__longind ) ;
#line 90 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.h"
void prog_init(void) ;
#line 91
char const   *prog_set_name(char const   *name ) ;
#line 92
Options *prog_set_options(Options *options___0 ) ;
#line 93
char const   *prog_set_syntax(char const   *syntax ) ;
#line 94
char const   *prog_set_desc(char const   *desc ) ;
#line 95
char const   *prog_set_version(char const   *version ) ;
#line 96
char const   *prog_set_date(char const   *date ) ;
#line 97
char const   *prog_set_author(char const   *author ) ;
#line 98
char const   *prog_set_contact(char const   *contact ) ;
#line 99
char const   *prog_set_vendor(char const   *vendor ) ;
#line 100
char const   *prog_set_url(char const   *url ) ;
#line 101
char const   *prog_set_legal(char const   *legal ) ;
#line 102
Msg *prog_set_out(Msg *out ) ;
#line 103
Msg *prog_set_err(Msg *err ) ;
#line 104
Msg *prog_set_dbg(Msg *dbg ) ;
#line 105
Msg *prog_set_alert(Msg *alert___0 ) ;
#line 106
ssize_t prog_set_debug_level(size_t debug_level ) ;
#line 107
ssize_t prog_set_verbosity_level(size_t verbosity_level ) ;
#line 108
int prog_set_locker(Locker *locker ) ;
#line 110
Options const   *prog_options(void) ;
#line 111
char const   *prog_syntax(void) ;
#line 112
char const   *prog_desc(void) ;
#line 113
char const   *prog_version(void) ;
#line 114
char const   *prog_date(void) ;
#line 115
char const   *prog_author(void) ;
#line 116
char const   *prog_contact(void) ;
#line 117
char const   *prog_vendor(void) ;
#line 118
char const   *prog_url(void) ;
#line 119
char const   *prog_legal(void) ;
#line 120
Msg *prog_out(void) ;
#line 121
Msg *prog_err(void) ;
#line 122
Msg *prog_dbg(void) ;
#line 123
Msg *prog_alert(void) ;
#line 124
size_t prog_debug_level(void) ;
#line 125
size_t prog_verbosity_level(void) ;
#line 126
int prog_out_fd(int fd ) ;
#line 127
int prog_out_stdout(void) ;
#line 128
int prog_out_file(char const   *path ) ;
#line 129
int prog_out_syslog(char const   *ident , int option___0 , int facility , int priority ) ;
#line 130
int prog_out_none(void) ;
#line 131
int prog_err_fd(int fd ) ;
#line 132
int prog_err_stderr(void) ;
#line 133
int prog_err_file(char const   *path ) ;
#line 134
int prog_err_syslog(char const   *ident , int option___0 , int facility , int priority ) ;
#line 135
int prog_err_none(void) ;
#line 136
int prog_dbg_fd(int fd ) ;
#line 137
int prog_dbg_stdout(void) ;
#line 138
int prog_dbg_stderr(void) ;
#line 139
int prog_dbg_file(char const   *path ) ;
#line 140
int prog_dbg_syslog(char const   *id , int option___0 , int facility , int priority ) ;
#line 141
int prog_dbg_none(void) ;
#line 142
int prog_alert_fd(int fd ) ;
#line 143
int prog_alert_stdout(void) ;
#line 144
int prog_alert_stderr(void) ;
#line 145
int prog_alert_file(char const   *path ) ;
#line 146
int prog_alert_syslog(char const   *id , int option___0 , int facility , int priority ) ;
#line 147
int prog_alert_none(void) ;
#line 148
int prog_opt_process(int ac , char **av ) ;
#line 149
void prog_usage_msg(char const   *format  , ...) ;
#line 150
void prog_help_msg(void) ;
#line 151
void prog_version_msg(void) ;
#line 152
char const   *prog_basename(char const   *path ) ;
#line 153
Options prog_options_table[1] ;
#line 154
int opt_process(int argc , char **argv , Options *options___0 , char *msgbuf , size_t bufsize ) ;
#line 155
char *opt_usage(char *buf , size_t size , Options *options___0 ) ;
#line 227 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
static Prog g___0  = 
#line 227 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
     {(char const   *)((void *)0), (Options *)((void *)0), (char const   *)((void *)0),
    (char const   *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0),
    (char const   *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0),
    (char const   *)((void *)0), (char const   *)((void *)0), (Msg *)((void *)0),
    (Msg *)((void *)0), (Msg *)((void *)0), (Msg *)((void *)0), (size_t )0, (size_t )0,
    (Locker *)((void *)0)};
#line 245 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
void prog_init(void) 
{ 


  {
  {
#line 247
  prog_out_stdout();
#line 248
  prog_err_stderr();
#line 249
  prog_dbg_stderr();
#line 250
  prog_alert_stderr();
  }
#line 251
  return;
}
}
#line 305 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
char const   *prog_set_name(char const   *name ) 
{ 
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 307
  if (g___0.locker) {
    {
#line 307
    tmp = (*((g___0.locker)->wrlock))((g___0.locker)->lock);
#line 307
    rc = tmp;
    }
  } else {
#line 307
    rc = 0;
  }
#line 307
  if (rc) {
    {
#line 307
    set_errno(rc);
    }
#line 307
    return ((char const   *)((void *)0));
  }
#line 307
  g___0.name = name;
#line 307
  if (g___0.locker) {
    {
#line 307
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 307
    rc___0 = tmp___0;
    }
  } else {
#line 307
    rc___0 = 0;
  }
#line 307
  if (rc___0) {
    {
#line 307
    set_errno(rc___0);
    }
#line 307
    return ((char const   *)((void *)0));
  }
#line 307
  return (g___0.name);
}
}
#line 322 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
Options *prog_set_options(Options *options___0 ) 
{ 
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 324
  if (g___0.locker) {
    {
#line 324
    tmp = (*((g___0.locker)->wrlock))((g___0.locker)->lock);
#line 324
    rc = tmp;
    }
  } else {
#line 324
    rc = 0;
  }
#line 324
  if (rc) {
    {
#line 324
    set_errno(rc);
    }
#line 324
    return ((Options *)((void *)0));
  }
#line 324
  g___0.options = options___0;
#line 324
  if (g___0.locker) {
    {
#line 324
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 324
    rc___0 = tmp___0;
    }
  } else {
#line 324
    rc___0 = 0;
  }
#line 324
  if (rc___0) {
    {
#line 324
    set_errno(rc___0);
    }
#line 324
    return ((Options *)((void *)0));
  }
#line 324
  return (g___0.options);
}
}
#line 340 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
char const   *prog_set_syntax(char const   *syntax ) 
{ 
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 342
  if (g___0.locker) {
    {
#line 342
    tmp = (*((g___0.locker)->wrlock))((g___0.locker)->lock);
#line 342
    rc = tmp;
    }
  } else {
#line 342
    rc = 0;
  }
#line 342
  if (rc) {
    {
#line 342
    set_errno(rc);
    }
#line 342
    return ((char const   *)((void *)0));
  }
#line 342
  g___0.syntax = syntax;
#line 342
  if (g___0.locker) {
    {
#line 342
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 342
    rc___0 = tmp___0;
    }
  } else {
#line 342
    rc___0 = 0;
  }
#line 342
  if (rc___0) {
    {
#line 342
    set_errno(rc___0);
    }
#line 342
    return ((char const   *)((void *)0));
  }
#line 342
  return (g___0.syntax);
}
}
#line 357 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
char const   *prog_set_desc(char const   *desc ) 
{ 
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 359
  if (g___0.locker) {
    {
#line 359
    tmp = (*((g___0.locker)->wrlock))((g___0.locker)->lock);
#line 359
    rc = tmp;
    }
  } else {
#line 359
    rc = 0;
  }
#line 359
  if (rc) {
    {
#line 359
    set_errno(rc);
    }
#line 359
    return ((char const   *)((void *)0));
  }
#line 359
  g___0.desc = desc;
#line 359
  if (g___0.locker) {
    {
#line 359
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 359
    rc___0 = tmp___0;
    }
  } else {
#line 359
    rc___0 = 0;
  }
#line 359
  if (rc___0) {
    {
#line 359
    set_errno(rc___0);
    }
#line 359
    return ((char const   *)((void *)0));
  }
#line 359
  return (g___0.desc);
}
}
#line 374 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
char const   *prog_set_version(char const   *version ) 
{ 
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 376
  if (g___0.locker) {
    {
#line 376
    tmp = (*((g___0.locker)->wrlock))((g___0.locker)->lock);
#line 376
    rc = tmp;
    }
  } else {
#line 376
    rc = 0;
  }
#line 376
  if (rc) {
    {
#line 376
    set_errno(rc);
    }
#line 376
    return ((char const   *)((void *)0));
  }
#line 376
  g___0.version = version;
#line 376
  if (g___0.locker) {
    {
#line 376
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 376
    rc___0 = tmp___0;
    }
  } else {
#line 376
    rc___0 = 0;
  }
#line 376
  if (rc___0) {
    {
#line 376
    set_errno(rc___0);
    }
#line 376
    return ((char const   *)((void *)0));
  }
#line 376
  return (g___0.version);
}
}
#line 391 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
char const   *prog_set_date(char const   *date ) 
{ 
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 393
  if (g___0.locker) {
    {
#line 393
    tmp = (*((g___0.locker)->wrlock))((g___0.locker)->lock);
#line 393
    rc = tmp;
    }
  } else {
#line 393
    rc = 0;
  }
#line 393
  if (rc) {
    {
#line 393
    set_errno(rc);
    }
#line 393
    return ((char const   *)((void *)0));
  }
#line 393
  g___0.date = date;
#line 393
  if (g___0.locker) {
    {
#line 393
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 393
    rc___0 = tmp___0;
    }
  } else {
#line 393
    rc___0 = 0;
  }
#line 393
  if (rc___0) {
    {
#line 393
    set_errno(rc___0);
    }
#line 393
    return ((char const   *)((void *)0));
  }
#line 393
  return (g___0.date);
}
}
#line 408 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
char const   *prog_set_author(char const   *author ) 
{ 
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 410
  if (g___0.locker) {
    {
#line 410
    tmp = (*((g___0.locker)->wrlock))((g___0.locker)->lock);
#line 410
    rc = tmp;
    }
  } else {
#line 410
    rc = 0;
  }
#line 410
  if (rc) {
    {
#line 410
    set_errno(rc);
    }
#line 410
    return ((char const   *)((void *)0));
  }
#line 410
  g___0.author = author;
#line 410
  if (g___0.locker) {
    {
#line 410
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 410
    rc___0 = tmp___0;
    }
  } else {
#line 410
    rc___0 = 0;
  }
#line 410
  if (rc___0) {
    {
#line 410
    set_errno(rc___0);
    }
#line 410
    return ((char const   *)((void *)0));
  }
#line 410
  return (g___0.author);
}
}
#line 426 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
char const   *prog_set_contact(char const   *contact ) 
{ 
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 428
  if (g___0.locker) {
    {
#line 428
    tmp = (*((g___0.locker)->wrlock))((g___0.locker)->lock);
#line 428
    rc = tmp;
    }
  } else {
#line 428
    rc = 0;
  }
#line 428
  if (rc) {
    {
#line 428
    set_errno(rc);
    }
#line 428
    return ((char const   *)((void *)0));
  }
#line 428
  g___0.contact = contact;
#line 428
  if (g___0.locker) {
    {
#line 428
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 428
    rc___0 = tmp___0;
    }
  } else {
#line 428
    rc___0 = 0;
  }
#line 428
  if (rc___0) {
    {
#line 428
    set_errno(rc___0);
    }
#line 428
    return ((char const   *)((void *)0));
  }
#line 428
  return (g___0.contact);
}
}
#line 443 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
char const   *prog_set_vendor(char const   *vendor ) 
{ 
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 445
  if (g___0.locker) {
    {
#line 445
    tmp = (*((g___0.locker)->wrlock))((g___0.locker)->lock);
#line 445
    rc = tmp;
    }
  } else {
#line 445
    rc = 0;
  }
#line 445
  if (rc) {
    {
#line 445
    set_errno(rc);
    }
#line 445
    return ((char const   *)((void *)0));
  }
#line 445
  g___0.vendor = vendor;
#line 445
  if (g___0.locker) {
    {
#line 445
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 445
    rc___0 = tmp___0;
    }
  } else {
#line 445
    rc___0 = 0;
  }
#line 445
  if (rc___0) {
    {
#line 445
    set_errno(rc___0);
    }
#line 445
    return ((char const   *)((void *)0));
  }
#line 445
  return (g___0.vendor);
}
}
#line 460 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
char const   *prog_set_url(char const   *url ) 
{ 
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 462
  if (g___0.locker) {
    {
#line 462
    tmp = (*((g___0.locker)->wrlock))((g___0.locker)->lock);
#line 462
    rc = tmp;
    }
  } else {
#line 462
    rc = 0;
  }
#line 462
  if (rc) {
    {
#line 462
    set_errno(rc);
    }
#line 462
    return ((char const   *)((void *)0));
  }
#line 462
  g___0.url = url;
#line 462
  if (g___0.locker) {
    {
#line 462
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 462
    rc___0 = tmp___0;
    }
  } else {
#line 462
    rc___0 = 0;
  }
#line 462
  if (rc___0) {
    {
#line 462
    set_errno(rc___0);
    }
#line 462
    return ((char const   *)((void *)0));
  }
#line 462
  return (g___0.url);
}
}
#line 478 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
char const   *prog_set_legal(char const   *legal ) 
{ 
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 480
  if (g___0.locker) {
    {
#line 480
    tmp = (*((g___0.locker)->wrlock))((g___0.locker)->lock);
#line 480
    rc = tmp;
    }
  } else {
#line 480
    rc = 0;
  }
#line 480
  if (rc) {
    {
#line 480
    set_errno(rc);
    }
#line 480
    return ((char const   *)((void *)0));
  }
#line 480
  g___0.legal = legal;
#line 480
  if (g___0.locker) {
    {
#line 480
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 480
    rc___0 = tmp___0;
    }
  } else {
#line 480
    rc___0 = 0;
  }
#line 480
  if (rc___0) {
    {
#line 480
    set_errno(rc___0);
    }
#line 480
    return ((char const   *)((void *)0));
  }
#line 480
  return (g___0.legal);
}
}
#line 499 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
Msg *prog_set_out(Msg *out ) 
{ 
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 501
  if (g___0.locker) {
    {
#line 501
    tmp = (*((g___0.locker)->wrlock))((g___0.locker)->lock);
#line 501
    rc = tmp;
    }
  } else {
#line 501
    rc = 0;
  }
#line 501
  if (rc) {
    {
#line 501
    set_errno(rc);
    }
#line 501
    return ((Msg *)((void *)0));
  }
#line 501
  if (g___0.out) {
#line 501
    if ((unsigned long )g___0.out != (unsigned long )out) {
      {
#line 501
      msg_release(g___0.out);
      }
    }
  }
#line 501
  g___0.out = out;
#line 501
  if (g___0.locker) {
    {
#line 501
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 501
    rc___0 = tmp___0;
    }
  } else {
#line 501
    rc___0 = 0;
  }
#line 501
  if (rc___0) {
    {
#line 501
    set_errno(rc___0);
    }
#line 501
    return ((Msg *)((void *)0));
  }
#line 501
  return (out);
}
}
#line 519 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
Msg *prog_set_err(Msg *err ) 
{ 
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 521
  if (g___0.locker) {
    {
#line 521
    tmp = (*((g___0.locker)->wrlock))((g___0.locker)->lock);
#line 521
    rc = tmp;
    }
  } else {
#line 521
    rc = 0;
  }
#line 521
  if (rc) {
    {
#line 521
    set_errno(rc);
    }
#line 521
    return ((Msg *)((void *)0));
  }
#line 521
  if (g___0.err) {
#line 521
    if ((unsigned long )g___0.err != (unsigned long )err) {
      {
#line 521
      msg_release(g___0.err);
      }
    }
  }
#line 521
  g___0.err = err;
#line 521
  if (g___0.locker) {
    {
#line 521
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 521
    rc___0 = tmp___0;
    }
  } else {
#line 521
    rc___0 = 0;
  }
#line 521
  if (rc___0) {
    {
#line 521
    set_errno(rc___0);
    }
#line 521
    return ((Msg *)((void *)0));
  }
#line 521
  return (err);
}
}
#line 537 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
Msg *prog_set_dbg(Msg *dbg ) 
{ 
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 539
  if (g___0.locker) {
    {
#line 539
    tmp = (*((g___0.locker)->wrlock))((g___0.locker)->lock);
#line 539
    rc = tmp;
    }
  } else {
#line 539
    rc = 0;
  }
#line 539
  if (rc) {
    {
#line 539
    set_errno(rc);
    }
#line 539
    return ((Msg *)((void *)0));
  }
#line 539
  if (g___0.dbg) {
#line 539
    if ((unsigned long )g___0.dbg != (unsigned long )dbg) {
      {
#line 539
      msg_release(g___0.dbg);
      }
    }
  }
#line 539
  g___0.dbg = dbg;
#line 539
  if (g___0.locker) {
    {
#line 539
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 539
    rc___0 = tmp___0;
    }
  } else {
#line 539
    rc___0 = 0;
  }
#line 539
  if (rc___0) {
    {
#line 539
    set_errno(rc___0);
    }
#line 539
    return ((Msg *)((void *)0));
  }
#line 539
  return (dbg);
}
}
#line 555 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
Msg *prog_set_alert(Msg *alert___0 ) 
{ 
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 557
  if (g___0.locker) {
    {
#line 557
    tmp = (*((g___0.locker)->wrlock))((g___0.locker)->lock);
#line 557
    rc = tmp;
    }
  } else {
#line 557
    rc = 0;
  }
#line 557
  if (rc) {
    {
#line 557
    set_errno(rc);
    }
#line 557
    return ((Msg *)((void *)0));
  }
#line 557
  if (g___0.log) {
#line 557
    if ((unsigned long )g___0.log != (unsigned long )alert___0) {
      {
#line 557
      msg_release(g___0.log);
      }
    }
  }
#line 557
  g___0.log = alert___0;
#line 557
  if (g___0.locker) {
    {
#line 557
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 557
    rc___0 = tmp___0;
    }
  } else {
#line 557
    rc___0 = 0;
  }
#line 557
  if (rc___0) {
    {
#line 557
    set_errno(rc___0);
    }
#line 557
    return ((Msg *)((void *)0));
  }
#line 557
  return (alert___0);
}
}
#line 603 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
ssize_t prog_set_debug_level(size_t debug_level ) 
{ 
  size_t prev ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 605
  if (g___0.locker) {
    {
#line 605
    tmp = (*((g___0.locker)->wrlock))((g___0.locker)->lock);
#line 605
    rc = tmp;
    }
  } else {
#line 605
    rc = 0;
  }
#line 605
  if (rc) {
    {
#line 605
    set_errno(rc);
    }
#line 605
    return ((ssize_t )-1);
  }
#line 605
  prev = g___0.debug_level;
#line 605
  g___0.debug_level = debug_level;
#line 605
  if (g___0.locker) {
    {
#line 605
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 605
    rc___0 = tmp___0;
    }
  } else {
#line 605
    rc___0 = 0;
  }
#line 605
  if (rc___0) {
    {
#line 605
    set_errno(rc___0);
    }
#line 605
    return ((ssize_t )-1);
  }
#line 605
  return ((ssize_t )prev);
}
}
#line 622 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
ssize_t prog_set_verbosity_level(size_t verbosity_level ) 
{ 
  size_t prev ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 624
  if (g___0.locker) {
    {
#line 624
    tmp = (*((g___0.locker)->wrlock))((g___0.locker)->lock);
#line 624
    rc = tmp;
    }
  } else {
#line 624
    rc = 0;
  }
#line 624
  if (rc) {
    {
#line 624
    set_errno(rc);
    }
#line 624
    return ((ssize_t )-1);
  }
#line 624
  prev = g___0.verbosity_level;
#line 624
  g___0.verbosity_level = verbosity_level;
#line 624
  if (g___0.locker) {
    {
#line 624
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 624
    rc___0 = tmp___0;
    }
  } else {
#line 624
    rc___0 = 0;
  }
#line 624
  if (rc___0) {
    {
#line 624
    set_errno(rc___0);
    }
#line 624
    return ((ssize_t )-1);
  }
#line 624
  return ((ssize_t )prev);
}
}
#line 640 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_set_locker(Locker *locker ) 
{ 


  {
#line 642
  if (g___0.locker) {
#line 643
    return (-1);
  }
#line 645
  g___0.locker = locker;
#line 647
  return (0);
}
}
#line 661 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
char const   *prog_name(void) 
{ 
  void *value ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 663
  if (g___0.locker) {
    {
#line 663
    tmp = (*((g___0.locker)->rdlock))((g___0.locker)->lock);
#line 663
    rc = tmp;
    }
  } else {
#line 663
    rc = 0;
  }
#line 663
  if (rc) {
    {
#line 663
    set_errno(rc);
    }
#line 663
    return ((char const   *)((void *)0));
  }
#line 663
  value = (void *)g___0.name;
#line 663
  if (g___0.locker) {
    {
#line 663
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 663
    rc___0 = tmp___0;
    }
  } else {
#line 663
    rc___0 = 0;
  }
#line 663
  if (rc___0) {
    {
#line 663
    set_errno(rc___0);
    }
#line 663
    return ((char const   *)((void *)0));
  }
#line 663
  return ((char const   *)value);
}
}
#line 677 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
Options const   *prog_options(void) 
{ 
  void *value ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 679
  if (g___0.locker) {
    {
#line 679
    tmp = (*((g___0.locker)->rdlock))((g___0.locker)->lock);
#line 679
    rc = tmp;
    }
  } else {
#line 679
    rc = 0;
  }
#line 679
  if (rc) {
    {
#line 679
    set_errno(rc);
    }
#line 679
    return ((Options const   *)((void *)0));
  }
#line 679
  value = (void *)g___0.options;
#line 679
  if (g___0.locker) {
    {
#line 679
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 679
    rc___0 = tmp___0;
    }
  } else {
#line 679
    rc___0 = 0;
  }
#line 679
  if (rc___0) {
    {
#line 679
    set_errno(rc___0);
    }
#line 679
    return ((Options const   *)((void *)0));
  }
#line 679
  return ((Options const   *)value);
}
}
#line 693 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
char const   *prog_syntax(void) 
{ 
  void *value ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 695
  if (g___0.locker) {
    {
#line 695
    tmp = (*((g___0.locker)->rdlock))((g___0.locker)->lock);
#line 695
    rc = tmp;
    }
  } else {
#line 695
    rc = 0;
  }
#line 695
  if (rc) {
    {
#line 695
    set_errno(rc);
    }
#line 695
    return ((char const   *)((void *)0));
  }
#line 695
  value = (void *)g___0.syntax;
#line 695
  if (g___0.locker) {
    {
#line 695
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 695
    rc___0 = tmp___0;
    }
  } else {
#line 695
    rc___0 = 0;
  }
#line 695
  if (rc___0) {
    {
#line 695
    set_errno(rc___0);
    }
#line 695
    return ((char const   *)((void *)0));
  }
#line 695
  return ((char const   *)value);
}
}
#line 709 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
char const   *prog_desc(void) 
{ 
  void *value ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 711
  if (g___0.locker) {
    {
#line 711
    tmp = (*((g___0.locker)->rdlock))((g___0.locker)->lock);
#line 711
    rc = tmp;
    }
  } else {
#line 711
    rc = 0;
  }
#line 711
  if (rc) {
    {
#line 711
    set_errno(rc);
    }
#line 711
    return ((char const   *)((void *)0));
  }
#line 711
  value = (void *)g___0.desc;
#line 711
  if (g___0.locker) {
    {
#line 711
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 711
    rc___0 = tmp___0;
    }
  } else {
#line 711
    rc___0 = 0;
  }
#line 711
  if (rc___0) {
    {
#line 711
    set_errno(rc___0);
    }
#line 711
    return ((char const   *)((void *)0));
  }
#line 711
  return ((char const   *)value);
}
}
#line 725 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
char const   *prog_version(void) 
{ 
  void *value ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 727
  if (g___0.locker) {
    {
#line 727
    tmp = (*((g___0.locker)->rdlock))((g___0.locker)->lock);
#line 727
    rc = tmp;
    }
  } else {
#line 727
    rc = 0;
  }
#line 727
  if (rc) {
    {
#line 727
    set_errno(rc);
    }
#line 727
    return ((char const   *)((void *)0));
  }
#line 727
  value = (void *)g___0.version;
#line 727
  if (g___0.locker) {
    {
#line 727
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 727
    rc___0 = tmp___0;
    }
  } else {
#line 727
    rc___0 = 0;
  }
#line 727
  if (rc___0) {
    {
#line 727
    set_errno(rc___0);
    }
#line 727
    return ((char const   *)((void *)0));
  }
#line 727
  return ((char const   *)value);
}
}
#line 741 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
char const   *prog_date(void) 
{ 
  void *value ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 743
  if (g___0.locker) {
    {
#line 743
    tmp = (*((g___0.locker)->rdlock))((g___0.locker)->lock);
#line 743
    rc = tmp;
    }
  } else {
#line 743
    rc = 0;
  }
#line 743
  if (rc) {
    {
#line 743
    set_errno(rc);
    }
#line 743
    return ((char const   *)((void *)0));
  }
#line 743
  value = (void *)g___0.date;
#line 743
  if (g___0.locker) {
    {
#line 743
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 743
    rc___0 = tmp___0;
    }
  } else {
#line 743
    rc___0 = 0;
  }
#line 743
  if (rc___0) {
    {
#line 743
    set_errno(rc___0);
    }
#line 743
    return ((char const   *)((void *)0));
  }
#line 743
  return ((char const   *)value);
}
}
#line 757 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
char const   *prog_author(void) 
{ 
  void *value ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 759
  if (g___0.locker) {
    {
#line 759
    tmp = (*((g___0.locker)->rdlock))((g___0.locker)->lock);
#line 759
    rc = tmp;
    }
  } else {
#line 759
    rc = 0;
  }
#line 759
  if (rc) {
    {
#line 759
    set_errno(rc);
    }
#line 759
    return ((char const   *)((void *)0));
  }
#line 759
  value = (void *)g___0.author;
#line 759
  if (g___0.locker) {
    {
#line 759
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 759
    rc___0 = tmp___0;
    }
  } else {
#line 759
    rc___0 = 0;
  }
#line 759
  if (rc___0) {
    {
#line 759
    set_errno(rc___0);
    }
#line 759
    return ((char const   *)((void *)0));
  }
#line 759
  return ((char const   *)value);
}
}
#line 773 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
char const   *prog_contact(void) 
{ 
  void *value ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 775
  if (g___0.locker) {
    {
#line 775
    tmp = (*((g___0.locker)->rdlock))((g___0.locker)->lock);
#line 775
    rc = tmp;
    }
  } else {
#line 775
    rc = 0;
  }
#line 775
  if (rc) {
    {
#line 775
    set_errno(rc);
    }
#line 775
    return ((char const   *)((void *)0));
  }
#line 775
  value = (void *)g___0.contact;
#line 775
  if (g___0.locker) {
    {
#line 775
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 775
    rc___0 = tmp___0;
    }
  } else {
#line 775
    rc___0 = 0;
  }
#line 775
  if (rc___0) {
    {
#line 775
    set_errno(rc___0);
    }
#line 775
    return ((char const   *)((void *)0));
  }
#line 775
  return ((char const   *)value);
}
}
#line 789 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
char const   *prog_vendor(void) 
{ 
  void *value ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 791
  if (g___0.locker) {
    {
#line 791
    tmp = (*((g___0.locker)->rdlock))((g___0.locker)->lock);
#line 791
    rc = tmp;
    }
  } else {
#line 791
    rc = 0;
  }
#line 791
  if (rc) {
    {
#line 791
    set_errno(rc);
    }
#line 791
    return ((char const   *)((void *)0));
  }
#line 791
  value = (void *)g___0.vendor;
#line 791
  if (g___0.locker) {
    {
#line 791
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 791
    rc___0 = tmp___0;
    }
  } else {
#line 791
    rc___0 = 0;
  }
#line 791
  if (rc___0) {
    {
#line 791
    set_errno(rc___0);
    }
#line 791
    return ((char const   *)((void *)0));
  }
#line 791
  return ((char const   *)value);
}
}
#line 805 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
char const   *prog_url(void) 
{ 
  void *value ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 807
  if (g___0.locker) {
    {
#line 807
    tmp = (*((g___0.locker)->rdlock))((g___0.locker)->lock);
#line 807
    rc = tmp;
    }
  } else {
#line 807
    rc = 0;
  }
#line 807
  if (rc) {
    {
#line 807
    set_errno(rc);
    }
#line 807
    return ((char const   *)((void *)0));
  }
#line 807
  value = (void *)g___0.url;
#line 807
  if (g___0.locker) {
    {
#line 807
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 807
    rc___0 = tmp___0;
    }
  } else {
#line 807
    rc___0 = 0;
  }
#line 807
  if (rc___0) {
    {
#line 807
    set_errno(rc___0);
    }
#line 807
    return ((char const   *)((void *)0));
  }
#line 807
  return ((char const   *)value);
}
}
#line 821 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
char const   *prog_legal(void) 
{ 
  void *value ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 823
  if (g___0.locker) {
    {
#line 823
    tmp = (*((g___0.locker)->rdlock))((g___0.locker)->lock);
#line 823
    rc = tmp;
    }
  } else {
#line 823
    rc = 0;
  }
#line 823
  if (rc) {
    {
#line 823
    set_errno(rc);
    }
#line 823
    return ((char const   *)((void *)0));
  }
#line 823
  value = (void *)g___0.legal;
#line 823
  if (g___0.locker) {
    {
#line 823
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 823
    rc___0 = tmp___0;
    }
  } else {
#line 823
    rc___0 = 0;
  }
#line 823
  if (rc___0) {
    {
#line 823
    set_errno(rc___0);
    }
#line 823
    return ((char const   *)((void *)0));
  }
#line 823
  return ((char const   *)value);
}
}
#line 837 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
Msg *prog_out(void) 
{ 
  void *value ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 839
  if (g___0.locker) {
    {
#line 839
    tmp = (*((g___0.locker)->rdlock))((g___0.locker)->lock);
#line 839
    rc = tmp;
    }
  } else {
#line 839
    rc = 0;
  }
#line 839
  if (rc) {
    {
#line 839
    set_errno(rc);
    }
#line 839
    return ((Msg *)((void *)0));
  }
#line 839
  value = (void *)g___0.out;
#line 839
  if (g___0.locker) {
    {
#line 839
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 839
    rc___0 = tmp___0;
    }
  } else {
#line 839
    rc___0 = 0;
  }
#line 839
  if (rc___0) {
    {
#line 839
    set_errno(rc___0);
    }
#line 839
    return ((Msg *)((void *)0));
  }
#line 839
  return ((Msg *)value);
}
}
#line 853 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
Msg *prog_err(void) 
{ 
  void *value ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 855
  if (g___0.locker) {
    {
#line 855
    tmp = (*((g___0.locker)->rdlock))((g___0.locker)->lock);
#line 855
    rc = tmp;
    }
  } else {
#line 855
    rc = 0;
  }
#line 855
  if (rc) {
    {
#line 855
    set_errno(rc);
    }
#line 855
    return ((Msg *)((void *)0));
  }
#line 855
  value = (void *)g___0.err;
#line 855
  if (g___0.locker) {
    {
#line 855
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 855
    rc___0 = tmp___0;
    }
  } else {
#line 855
    rc___0 = 0;
  }
#line 855
  if (rc___0) {
    {
#line 855
    set_errno(rc___0);
    }
#line 855
    return ((Msg *)((void *)0));
  }
#line 855
  return ((Msg *)value);
}
}
#line 869 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
Msg *prog_dbg(void) 
{ 
  void *value ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 871
  if (g___0.locker) {
    {
#line 871
    tmp = (*((g___0.locker)->rdlock))((g___0.locker)->lock);
#line 871
    rc = tmp;
    }
  } else {
#line 871
    rc = 0;
  }
#line 871
  if (rc) {
    {
#line 871
    set_errno(rc);
    }
#line 871
    return ((Msg *)((void *)0));
  }
#line 871
  value = (void *)g___0.dbg;
#line 871
  if (g___0.locker) {
    {
#line 871
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 871
    rc___0 = tmp___0;
    }
  } else {
#line 871
    rc___0 = 0;
  }
#line 871
  if (rc___0) {
    {
#line 871
    set_errno(rc___0);
    }
#line 871
    return ((Msg *)((void *)0));
  }
#line 871
  return ((Msg *)value);
}
}
#line 885 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
Msg *prog_alert(void) 
{ 
  void *value ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 887
  if (g___0.locker) {
    {
#line 887
    tmp = (*((g___0.locker)->rdlock))((g___0.locker)->lock);
#line 887
    rc = tmp;
    }
  } else {
#line 887
    rc = 0;
  }
#line 887
  if (rc) {
    {
#line 887
    set_errno(rc);
    }
#line 887
    return ((Msg *)((void *)0));
  }
#line 887
  value = (void *)g___0.log;
#line 887
  if (g___0.locker) {
    {
#line 887
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 887
    rc___0 = tmp___0;
    }
  } else {
#line 887
    rc___0 = 0;
  }
#line 887
  if (rc___0) {
    {
#line 887
    set_errno(rc___0);
    }
#line 887
    return ((Msg *)((void *)0));
  }
#line 887
  return ((Msg *)value);
}
}
#line 901 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
size_t prog_debug_level(void) 
{ 
  int value ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 903
  if (g___0.locker) {
    {
#line 903
    tmp = (*((g___0.locker)->rdlock))((g___0.locker)->lock);
#line 903
    rc = tmp;
    }
  } else {
#line 903
    rc = 0;
  }
#line 903
  if (rc) {
    {
#line 903
    set_errno(rc);
    }
#line 903
    return ((size_t )0);
  }
#line 903
  value = (int )g___0.debug_level;
#line 903
  if (g___0.locker) {
    {
#line 903
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 903
    rc___0 = tmp___0;
    }
  } else {
#line 903
    rc___0 = 0;
  }
#line 903
  if (rc___0) {
    {
#line 903
    set_errno(rc___0);
    }
#line 903
    return ((size_t )0);
  }
#line 903
  return ((size_t )value);
}
}
#line 917 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
size_t prog_verbosity_level(void) 
{ 
  int value ;
  int rc ;
  int tmp ;
  int rc___0 ;
  int tmp___0 ;

  {
#line 919
  if (g___0.locker) {
    {
#line 919
    tmp = (*((g___0.locker)->rdlock))((g___0.locker)->lock);
#line 919
    rc = tmp;
    }
  } else {
#line 919
    rc = 0;
  }
#line 919
  if (rc) {
    {
#line 919
    set_errno(rc);
    }
#line 919
    return ((size_t )0);
  }
#line 919
  value = (int )g___0.verbosity_level;
#line 919
  if (g___0.locker) {
    {
#line 919
    tmp___0 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 919
    rc___0 = tmp___0;
    }
  } else {
#line 919
    rc___0 = 0;
  }
#line 919
  if (rc___0) {
    {
#line 919
    set_errno(rc___0);
    }
#line 919
    return ((size_t )0);
  }
#line 919
  return ((size_t )value);
}
}
#line 934 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_out_fd(int fd ) 
{ 
  Msg *mesg ;
  Msg *tmp ;

  {
  {
#line 938
  mesg = msg_create_fd_with_locker(g___0.locker, fd);
  }
#line 938
  if (! mesg) {
#line 939
    return (-1);
  }
  {
#line 941
  tmp = prog_set_out(mesg);
  }
#line 941
  if (! tmp) {
    {
#line 943
    msg_release(mesg);
    }
#line 944
    return (-1);
  }
#line 947
  return (0);
}
}
#line 961 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_out_stdout(void) 
{ 
  int tmp ;

  {
  {
#line 963
  tmp = prog_out_fd(1);
  }
#line 963
  return (tmp);
}
}
#line 978 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_out_file(char const   *path ) 
{ 
  Msg *mesg ;
  Msg *tmp ;

  {
  {
#line 982
  mesg = msg_create_file_with_locker(g___0.locker, path);
  }
#line 982
  if (! mesg) {
#line 983
    return (-1);
  }
  {
#line 985
  tmp = prog_set_out(mesg);
  }
#line 985
  if (! tmp) {
    {
#line 987
    msg_release(mesg);
    }
#line 988
    return (-1);
  }
#line 991
  return (0);
}
}
#line 1006 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_out_syslog(char const   *ident , int option___0 , int facility , int priority ) 
{ 
  Msg *mesg ;
  Msg *tmp ;

  {
  {
#line 1010
  mesg = msg_create_syslog_with_locker(g___0.locker, ident, option___0, facility,
                                       priority);
  }
#line 1010
  if (! mesg) {
#line 1011
    return (-1);
  }
  {
#line 1013
  tmp = prog_set_out(mesg);
  }
#line 1013
  if (! tmp) {
    {
#line 1015
    msg_release(mesg);
    }
#line 1016
    return (-1);
  }
#line 1019
  return (0);
}
}
#line 1033 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_out_none(void) 
{ 


  {
  {
#line 1035
  prog_set_out((Msg *)((void *)0));
  }
#line 1037
  return (0);
}
}
#line 1052 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_err_fd(int fd ) 
{ 
  Msg *mesg ;
  Msg *tmp ;

  {
  {
#line 1056
  mesg = msg_create_fd_with_locker(g___0.locker, fd);
  }
#line 1056
  if (! mesg) {
#line 1057
    return (-1);
  }
  {
#line 1059
  tmp = prog_set_err(mesg);
  }
#line 1059
  if (! tmp) {
    {
#line 1061
    msg_release(mesg);
    }
#line 1062
    return (-1);
  }
#line 1065
  return (0);
}
}
#line 1080 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_err_stderr(void) 
{ 
  int tmp ;

  {
  {
#line 1082
  tmp = prog_err_fd(2);
  }
#line 1082
  return (tmp);
}
}
#line 1097 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_err_file(char const   *path ) 
{ 
  Msg *mesg ;
  Msg *tmp ;

  {
  {
#line 1101
  mesg = msg_create_file_with_locker(g___0.locker, path);
  }
#line 1101
  if (! mesg) {
#line 1102
    return (-1);
  }
  {
#line 1104
  tmp = prog_set_err(mesg);
  }
#line 1104
  if (! tmp) {
    {
#line 1106
    msg_release(mesg);
    }
#line 1107
    return (-1);
  }
#line 1110
  return (0);
}
}
#line 1125 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_err_syslog(char const   *ident , int option___0 , int facility , int priority ) 
{ 
  Msg *mesg ;
  Msg *tmp ;

  {
  {
#line 1129
  mesg = msg_create_syslog_with_locker(g___0.locker, ident, option___0, facility,
                                       priority);
  }
#line 1129
  if (! mesg) {
#line 1130
    return (-1);
  }
  {
#line 1132
  tmp = prog_set_err(mesg);
  }
#line 1132
  if (! tmp) {
    {
#line 1134
    msg_release(mesg);
    }
#line 1135
    return (-1);
  }
#line 1138
  return (0);
}
}
#line 1153 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_err_none(void) 
{ 
  int tmp___0 ;
  Msg *tmp___1 ;

  {
  {
#line 1155
  tmp___1 = prog_set_err((Msg *)((void *)0));
  }
#line 1155
  if (tmp___1) {
#line 1155
    tmp___0 = 0;
  } else {
#line 1155
    tmp___0 = -1;
  }
#line 1155
  return (tmp___0);
}
}
#line 1170 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_dbg_fd(int fd ) 
{ 
  Msg *mesg ;
  Msg *tmp ;

  {
  {
#line 1174
  mesg = msg_create_fd_with_locker(g___0.locker, fd);
  }
#line 1174
  if (! mesg) {
#line 1175
    return (-1);
  }
  {
#line 1177
  tmp = prog_set_dbg(mesg);
  }
#line 1177
  if (! tmp) {
    {
#line 1179
    msg_release(mesg);
    }
#line 1180
    return (-1);
  }
#line 1183
  return (0);
}
}
#line 1198 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_dbg_stdout(void) 
{ 
  int tmp ;

  {
  {
#line 1200
  tmp = prog_dbg_fd(1);
  }
#line 1200
  return (tmp);
}
}
#line 1215 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_dbg_stderr(void) 
{ 
  int tmp ;

  {
  {
#line 1217
  tmp = prog_dbg_fd(2);
  }
#line 1217
  return (tmp);
}
}
#line 1232 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_dbg_file(char const   *path ) 
{ 
  Msg *dbg ;
  Msg *tmp ;

  {
  {
#line 1236
  dbg = msg_create_file_with_locker(g___0.locker, path);
  }
#line 1236
  if (! dbg) {
#line 1237
    return (-1);
  }
  {
#line 1239
  tmp = prog_set_dbg(dbg);
  }
#line 1239
  if (! tmp) {
    {
#line 1241
    msg_release(dbg);
    }
#line 1242
    return (-1);
  }
#line 1245
  return (0);
}
}
#line 1260 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_dbg_syslog(char const   *id , int option___0 , int facility , int priority ) 
{ 
  Msg *dbg ;
  Msg *tmp ;

  {
  {
#line 1264
  dbg = msg_create_syslog_with_locker(g___0.locker, id, option___0, facility, priority);
  }
#line 1264
  if (! dbg) {
#line 1265
    return (-1);
  }
  {
#line 1267
  tmp = prog_set_dbg(dbg);
  }
#line 1267
  if (! tmp) {
    {
#line 1269
    msg_release(dbg);
    }
#line 1270
    return (-1);
  }
#line 1273
  return (0);
}
}
#line 1288 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_dbg_none(void) 
{ 
  int tmp___0 ;
  Msg *tmp___1 ;

  {
  {
#line 1290
  tmp___1 = prog_set_dbg((Msg *)((void *)0));
  }
#line 1290
  if (tmp___1) {
#line 1290
    tmp___0 = 0;
  } else {
#line 1290
    tmp___0 = -1;
  }
#line 1290
  return (tmp___0);
}
}
#line 1305 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_alert_fd(int fd ) 
{ 
  Msg *mesg ;
  Msg *tmp ;

  {
  {
#line 1309
  mesg = msg_create_fd_with_locker(g___0.locker, fd);
  }
#line 1309
  if (! mesg) {
#line 1310
    return (-1);
  }
  {
#line 1312
  tmp = prog_set_alert(mesg);
  }
#line 1312
  if (! tmp) {
    {
#line 1314
    msg_release(mesg);
    }
#line 1315
    return (-1);
  }
#line 1318
  return (0);
}
}
#line 1333 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_alert_stdout(void) 
{ 
  int tmp ;

  {
  {
#line 1335
  tmp = prog_alert_fd(1);
  }
#line 1335
  return (tmp);
}
}
#line 1350 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_alert_stderr(void) 
{ 
  int tmp ;

  {
  {
#line 1352
  tmp = prog_alert_fd(2);
  }
#line 1352
  return (tmp);
}
}
#line 1367 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_alert_file(char const   *path ) 
{ 
  Msg *alert___0 ;
  Msg *tmp ;

  {
  {
#line 1371
  alert___0 = msg_create_file_with_locker(g___0.locker, path);
  }
#line 1371
  if (! alert___0) {
#line 1372
    return (-1);
  }
  {
#line 1374
  tmp = prog_set_alert(alert___0);
  }
#line 1374
  if (! tmp) {
    {
#line 1376
    msg_release(alert___0);
    }
#line 1377
    return (-1);
  }
#line 1380
  return (0);
}
}
#line 1395 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_alert_syslog(char const   *id , int option___0 , int facility , int priority ) 
{ 
  Msg *alert___0 ;
  Msg *tmp ;

  {
  {
#line 1399
  alert___0 = msg_create_syslog_with_locker(g___0.locker, id, option___0, facility,
                                            priority);
  }
#line 1399
  if (! alert___0) {
#line 1400
    return (-1);
  }
  {
#line 1402
  tmp = prog_set_alert(alert___0);
  }
#line 1402
  if (! tmp) {
    {
#line 1404
    msg_release(alert___0);
    }
#line 1405
    return (-1);
  }
#line 1408
  return (0);
}
}
#line 1423 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_alert_none(void) 
{ 
  int tmp___0 ;
  Msg *tmp___1 ;

  {
  {
#line 1425
  tmp___1 = prog_set_alert((Msg *)((void *)0));
  }
#line 1425
  if (tmp___1) {
#line 1425
    tmp___0 = 0;
  } else {
#line 1425
    tmp___0 = -1;
  }
#line 1425
  return (tmp___0);
}
}
#line 1452 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int prog_opt_process(int ac , char **av ) 
{ 
  char msgbuf[256] ;
  unsigned int tmp ;
  int err ;
  int rc ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp11 ;

  {
#line 1454
  msgbuf[0] = (char )'\000';
#line 1454
  tmp = 1U;
  {
#line 1454
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1454
    if (tmp >= 256U) {
#line 1454
      goto while_break;
    }
#line 1454
    msgbuf[tmp] = (char)0;
#line 1454
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1458
  if (g___0.locker) {
    {
#line 1458
    tmp___1 = (*((g___0.locker)->rdlock))((g___0.locker)->lock);
#line 1458
    err = tmp___1;
    }
  } else {
#line 1458
    err = 0;
  }
#line 1458
  if (err) {
    {
#line 1459
    tmp___0 = set_errno(err);
    }
#line 1459
    return (tmp___0);
  }
  {
#line 1461
  rc = opt_process(ac, av, g___0.options, msgbuf, (size_t )256);
  }
#line 1463
  if (g___0.locker) {
    {
#line 1463
    tmp___3 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 1463
    err = tmp___3;
    }
  } else {
#line 1463
    err = 0;
  }
#line 1463
  if (err) {
    {
#line 1464
    tmp___2 = set_errno(err);
    }
#line 1464
    return (tmp___2);
  }
#line 1466
  if (rc == -1) {
    {
#line 1467
    prog_usage_msg((char const   *)(msgbuf));
    }
  }
#line 1469
  return (rc);
}
}
#line 1495 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
void prog_usage_msg(char const   *format  , ...) 
{ 
  char msg_buf[8192] ;
  char opt_buf[8192] ;
  int msg_length ;
  va_list args ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 1501
  __builtin_va_start(args, format);
#line 1502
  vsnprintf((char */* __restrict  */)(msg_buf), (size_t )8192, (char const   */* __restrict  */)format,
            args);
#line 1503
  __builtin_va_end(args);
  }
#line 1505
  if (g___0.locker) {
    {
#line 1505
    tmp = (*((g___0.locker)->rdlock))((g___0.locker)->lock);
#line 1505
    tmp___0 = tmp;
    }
  } else {
#line 1505
    tmp___0 = 0;
  }
#line 1505
  if (tmp___0) {
    {
#line 1506
    exit(1);
    }
  }
  {
#line 1508
  opt_usage(opt_buf, (size_t )8192, g___0.options);
#line 1509
  fflush(stderr);
#line 1511
  tmp___1 = strlen((char const   *)(msg_buf));
#line 1511
  msg_length = (int )tmp___1;
  }
#line 1512
  if (opt_buf[0]) {
#line 1512
    tmp___2 = "options:\n";
  } else {
#line 1512
    tmp___2 = "";
  }
#line 1512
  if (g___0.syntax) {
#line 1512
    tmp___3 = g___0.syntax;
  } else {
#line 1512
    tmp___3 = "";
  }
#line 1512
  if (g___0.name) {
#line 1512
    tmp___4 = " ";
  } else {
#line 1512
    tmp___4 = "";
  }
#line 1512
  if (g___0.name) {
#line 1512
    tmp___5 = g___0.name;
  } else {
#line 1512
    tmp___5 = "";
  }
#line 1512
  if (msg_length) {
#line 1512
    if ((int )msg_buf[msg_length - 1] != 10) {
#line 1512
      tmp___6 = "\n";
    } else {
#line 1512
      tmp___6 = "";
    }
  } else {
#line 1512
    tmp___6 = "";
  }
  {
#line 1512
  msg_out(g___0.err, "%s%susage: %s%s%s\n%s%s", msg_buf, tmp___6, tmp___5, tmp___4,
          tmp___3, tmp___2, opt_buf);
  }
#line 1522
  if (g___0.locker) {
    {
#line 1522
    (*((g___0.locker)->unlock))((g___0.locker)->lock);
    }
  }
  {
#line 1524
  exit(1);
  }
}
}
#line 1540 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
void prog_help_msg(void) 
{ 
  char buf[8192] ;
  size_t length ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 1543
  length = (size_t )0;
#line 1545
  if (g___0.locker) {
    {
#line 1545
    tmp = (*((g___0.locker)->rdlock))((g___0.locker)->lock);
#line 1545
    tmp___0 = tmp;
    }
  } else {
#line 1545
    tmp___0 = 0;
  }
#line 1545
  if (tmp___0) {
    {
#line 1546
    exit(1);
    }
  }
#line 1548
  if (g___0.syntax) {
#line 1548
    tmp___1 = g___0.syntax;
  } else {
#line 1548
    tmp___1 = "";
  }
#line 1548
  if (g___0.name) {
#line 1548
    tmp___2 = g___0.name;
  } else {
#line 1548
    tmp___2 = "";
  }
  {
#line 1548
  snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"usage: %s %s\n",
           tmp___2, tmp___1);
  }
#line 1553
  if (g___0.options) {
    {
#line 1555
    length = strlen((char const   *)(buf));
#line 1556
    snprintf((char */* __restrict  */)(buf + length), 8192UL - length, (char const   */* __restrict  */)"options:\n");
#line 1557
    length = strlen((char const   *)(buf));
#line 1558
    opt_usage(buf + length, 8192UL - length, g___0.options);
    }
  }
#line 1561
  if (g___0.desc) {
    {
#line 1563
    length = strlen((char const   *)(buf));
#line 1564
    snprintf((char */* __restrict  */)(buf + length), 8192UL - length, (char const   */* __restrict  */)"\n%s\n",
             g___0.desc);
    }
  }
#line 1567
  if (g___0.name) {
    {
#line 1569
    length = strlen((char const   *)(buf));
#line 1570
    snprintf((char */* __restrict  */)(buf + length), 8192UL - length, (char const   */* __restrict  */)"Name: %s\n",
             g___0.name);
    }
  }
#line 1573
  if (g___0.version) {
    {
#line 1575
    length = strlen((char const   *)(buf));
#line 1576
    snprintf((char */* __restrict  */)(buf + length), 8192UL - length, (char const   */* __restrict  */)"Version: %s\n",
             g___0.version);
    }
  }
#line 1579
  if (g___0.date) {
    {
#line 1581
    length = strlen((char const   *)(buf));
#line 1582
    snprintf((char */* __restrict  */)(buf + length), 8192UL - length, (char const   */* __restrict  */)"Date: %s\n",
             g___0.date);
    }
  }
#line 1585
  if (g___0.author) {
    {
#line 1587
    length = strlen((char const   *)(buf));
#line 1588
    snprintf((char */* __restrict  */)(buf + length), 8192UL - length, (char const   */* __restrict  */)"Author: %s\n",
             g___0.author);
    }
  }
#line 1591
  if (g___0.vendor) {
    {
#line 1593
    length = strlen((char const   *)(buf));
#line 1594
    snprintf((char */* __restrict  */)(buf + length), 8192UL - length, (char const   */* __restrict  */)"Vendor: %s\n",
             g___0.vendor);
    }
  }
#line 1597
  if (g___0.url) {
    {
#line 1599
    length = strlen((char const   *)(buf));
#line 1600
    snprintf((char */* __restrict  */)(buf + length), 8192UL - length, (char const   */* __restrict  */)"URL: %s\n",
             g___0.url);
    }
  }
#line 1603
  if (g___0.legal) {
    {
#line 1605
    length = strlen((char const   *)(buf));
#line 1606
    snprintf((char */* __restrict  */)(buf + length), 8192UL - length, (char const   */* __restrict  */)"\n%s\n",
             g___0.legal);
    }
  }
#line 1609
  if (g___0.contact) {
    {
#line 1611
    length = strlen((char const   *)(buf));
#line 1612
    snprintf((char */* __restrict  */)(buf + length), 8192UL - length, (char const   */* __restrict  */)"Report bugs to %s\n",
             g___0.contact);
    }
  }
#line 1615
  if (g___0.locker) {
    {
#line 1615
    tmp___3 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 1615
    tmp___4 = tmp___3;
    }
  } else {
#line 1615
    tmp___4 = 0;
  }
#line 1615
  if (tmp___4) {
    {
#line 1616
    exit(1);
    }
  }
  {
#line 1618
  msg("%s", buf);
#line 1619
  exit(0);
  }
}
}
#line 1634 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
void prog_version_msg(void) 
{ 
  char buf[8192] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1638
  if (g___0.locker) {
    {
#line 1638
    tmp = (*((g___0.locker)->rdlock))((g___0.locker)->lock);
#line 1638
    tmp___0 = tmp;
    }
  } else {
#line 1638
    tmp___0 = 0;
  }
#line 1638
  if (tmp___0) {
    {
#line 1639
    exit(1);
    }
  }
#line 1641
  if (g___0.name) {
#line 1641
    if (g___0.version) {
      {
#line 1642
      snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"%s-%s\n",
               g___0.name, g___0.version);
      }
    } else {
#line 1641
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1643
  if (g___0.name) {
    {
#line 1644
    snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"%s\n",
             g___0.name);
    }
  } else
#line 1645
  if (g___0.version) {
    {
#line 1646
    snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"%s\n",
             g___0.version);
    }
  } else {
#line 1648
    buf[0] = (char )'\000';
  }
#line 1650
  if (g___0.locker) {
    {
#line 1650
    tmp___1 = (*((g___0.locker)->unlock))((g___0.locker)->lock);
#line 1650
    tmp___2 = tmp___1;
    }
  } else {
#line 1650
    tmp___2 = 0;
  }
#line 1650
  if (tmp___2) {
    {
#line 1651
    exit(1);
    }
  }
  {
#line 1653
  msg("%s", buf);
#line 1654
  exit(0);
  }
}
}
#line 1668 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
char const   *prog_basename(char const   *path ) 
{ 
  char const   *name ;
  void *tmp ;
  char const   *tmp___1 ;
  char *tmp___2 ;

  {
#line 1672
  if (! path) {
    {
#line 1673
    tmp = set_errnull(22);
    }
#line 1673
    return ((char const   *)tmp);
  }
  {
#line 1675
  tmp___2 = strrchr(path, '/');
#line 1675
  name = (char const   *)tmp___2;
  }
#line 1675
  if (name) {
#line 1675
    tmp___1 = name + 1;
  } else {
#line 1675
    tmp___1 = path;
  }
#line 1675
  return (tmp___1);
}
}
#line 1714 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
static void handle_verbose_option(int *arg ) 
{ 
  int tmp ;

  {
#line 1716
  if (arg) {
#line 1716
    tmp = *arg;
  } else {
#line 1716
    tmp = 1;
  }
  {
#line 1716
  prog_set_verbosity_level((size_t )tmp);
  }
#line 1717
  return;
}
}
#line 1719 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
static void handle_debug_option(int *arg ) 
{ 
  int tmp ;

  {
#line 1721
  if (arg) {
#line 1721
    tmp = *arg;
  } else {
#line 1721
    tmp = 1;
  }
  {
#line 1721
  prog_set_debug_level((size_t )tmp);
  }
#line 1722
  return;
}
}
#line 1724 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
static Option prog_optab[5]  = {      {"help", (char )'h', (char const   *)((void *)0), "Print a help message then exit",
      0, (OptionArgument )0, (OptionAction )2, (void *)0, & prog_help_msg}, 
        {"version", (char )'V', (char const   *)((void *)0), "Print a version message then exit",
      0, (OptionArgument )0, (OptionAction )2, (void *)0, & prog_version_msg}, 
        {"verbose", (char )'v', "level", "Set the verbosity level", 2, (OptionArgument )1,
      (OptionAction )2, (void *)0, (func_t *)(& handle_verbose_option)}, 
        {"debug", (char )'d', "level", "Set the debugging level", 2, (OptionArgument )1,
      (OptionAction )2, (void *)0, (func_t *)(& handle_debug_option)}, 
        {(char const   *)((void *)0), (char )'\000', (char const   *)((void *)0), (char const   *)((void *)0),
      0, (OptionArgument )0, (OptionAction )0, (void *)0, (func_t *)((void *)0)}};
#line 1749 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
Options prog_options_table[1]  = {      {(Options *)((void *)0), prog_optab}};
#line 1762 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
static option *opt_convert(Options *options___0 ) 
{ 
  Options *opts ;
  size_t size ;
  size_t i ;
  option *ret ;
  int index___0 ;
  void *tmp ;
  int i___0 ;
  void *__cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 1765
  size = (size_t )0;
#line 1768
  index___0 = 0;
#line 1770
  opts = options___0;
  {
#line 1770
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1770
    if (! opts) {
#line 1770
      goto while_break;
    }
#line 1771
    i = (size_t )0;
    {
#line 1771
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1771
      if (! (opts->options + i)->name) {
#line 1771
        goto while_break___0;
      }
#line 1772
      size ++;
#line 1771
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1770
    opts = opts->parent;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1774
  tmp = malloc((size + 1UL) * sizeof(option ));
#line 1774
  ret = (option *)tmp;
  }
#line 1774
  if (! ret) {
#line 1775
    return ((option *)((void *)0));
  }
#line 1777
  opts = options___0;
  {
#line 1777
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1777
    if (! opts) {
#line 1777
      goto while_break___1;
    }
#line 1781
    i___0 = 0;
    {
#line 1781
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1781
      if (! (opts->options + i___0)->name) {
#line 1781
        goto while_break___2;
      }
#line 1783
      (ret + index___0)->name = (char const   *)((char *)(opts->options + i___0)->name);
#line 1784
      (ret + index___0)->has_arg = (opts->options + i___0)->has_arg;
#line 1785
      (ret + index___0)->flag = (int *)((void *)0);
#line 1786
      (ret + index___0)->val = 0;
#line 1781
      i___0 ++;
#line 1781
      index___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1777
    opts = opts->parent;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1790
  memset((void *)(ret + index___0), 0, sizeof(option ));
  }
#line 1792
  return (ret);
}
}
#line 1806 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
static char *opt_optstring(Options *options___0 ) 
{ 
  Options *opts ;
  size_t size ;
  size_t i ;
  char *optstring ;
  char *p ;
  void *tmp ;
  int i___0 ;
  char short_name ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 1809
  size = (size_t )0;
#line 1814
  opts = options___0;
  {
#line 1814
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1814
    if (! opts) {
#line 1814
      goto while_break;
    }
#line 1815
    i = (size_t )0;
    {
#line 1815
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1815
      if (! (opts->options + i)->name) {
#line 1815
        goto while_break___0;
      }
#line 1816
      if ((opts->options + i)->short_name) {
#line 1817
        size ++;
      }
#line 1815
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1814
    opts = opts->parent;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1819
  tmp = malloc((size * 3UL + 1UL) * sizeof(char ));
#line 1819
  optstring = (char *)tmp;
#line 1819
  p = optstring;
  }
#line 1819
  if (! p) {
#line 1820
    return ((char *)((void *)0));
  }
#line 1822
  opts = options___0;
  {
#line 1822
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1822
    if (! opts) {
#line 1822
      goto while_break___1;
    }
#line 1826
    i___0 = 0;
    {
#line 1826
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1826
      if (! (opts->options + i___0)->name) {
#line 1826
        goto while_break___2;
      }
#line 1828
      if ((opts->options + i___0)->short_name) {
#line 1830
        short_name = (opts->options + i___0)->short_name;
#line 1832
        if ((int )short_name == 63) {
#line 1833
          short_name = (char )'\001';
        }
#line 1835
        tmp___0 = p;
#line 1835
        p ++;
#line 1835
        *tmp___0 = short_name;
        {
#line 1839
        if ((opts->options + i___0)->has_arg == 2) {
#line 1839
          goto case_2;
        }
#line 1840
        if ((opts->options + i___0)->has_arg == 1) {
#line 1840
          goto case_1;
        }
#line 1837
        goto switch_break;
        case_2: /* CIL Label */ 
#line 1839
        tmp___1 = p;
#line 1839
        p ++;
#line 1839
        *tmp___1 = (char )':';
        case_1: /* CIL Label */ 
#line 1840
        tmp___2 = p;
#line 1840
        p ++;
#line 1840
        *tmp___2 = (char )':';
        switch_break: /* CIL Label */ ;
        }
      }
#line 1826
      i___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1822
    opts = opts->parent;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1846
  *p = (char )'\000';
#line 1848
  return (optstring);
}
}
#line 1862 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
static int int_arg(char const   *argument ) 
{ 
  char *endptr ;
  long val ;
  long tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 1864
  endptr = (char *)((void *)0);
#line 1865
  tmp = strtol((char const   */* __restrict  */)argument, (char **/* __restrict  */)(& endptr),
               0);
#line 1865
  val = tmp;
  }
#line 1867
  if (val > 2147483647L) {
    {
#line 1868
    tmp___0 = __errno_location();
#line 1868
    *tmp___0 = 34;
    }
#line 1868
    return (2147483647);
  }
#line 1870
  if (val < (-0x7FFFFFFF-1)) {
    {
#line 1871
    tmp___1 = __errno_location();
#line 1871
    *tmp___1 = 34;
    }
#line 1871
    return ((-0x7FFFFFFF-1));
  }
#line 1873
  if ((unsigned long )endptr == (unsigned long )argument) {
    {
#line 1874
    tmp___2 = __errno_location();
#line 1874
    *tmp___2 = 33;
    }
#line 1874
    return (0);
  } else
#line 1873
  if ((int )*endptr != 0) {
    {
#line 1874
    tmp___2 = __errno_location();
#line 1874
    *tmp___2 = 33;
    }
#line 1874
    return (0);
  }
#line 1876
  return ((int )val);
}
}
#line 1889 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
static void opt_action(Options *options___0 , int rc , int longindex , char const   *argument ) 
{ 
  Option *option___0 ;
  int i ;
  int arg ;
  int tmp ;

  {
#line 1892
  i = -1;
#line 1894
  if (rc != 0) {
#line 1894
    if (longindex == -1) {
      {
#line 1896
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1896
        if (! options___0) {
#line 1896
          goto while_break;
        }
#line 1898
        i = 0;
        {
#line 1898
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1898
          if (! (options___0->options + i)->name) {
#line 1898
            goto while_break___0;
          }
#line 1899
          if ((int )(options___0->options + i)->short_name == rc) {
#line 1900
            goto while_break___0;
          }
#line 1898
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1902
        if ((int )(options___0->options + i)->short_name == rc) {
#line 1903
          goto while_break;
        }
#line 1896
        options___0 = options___0->parent;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 1894
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1906
  if (rc == 0) {
#line 1906
    if (longindex != -1) {
#line 1908
      i = 0;
      {
#line 1908
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1908
        if (! options___0) {
#line 1908
          goto while_break___1;
        }
#line 1910
        i = 0;
        {
#line 1910
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1910
          if (longindex) {
#line 1910
            if (! (options___0->options + i)->name) {
#line 1910
              goto while_break___2;
            }
          } else {
#line 1910
            goto while_break___2;
          }
#line 1911
          longindex --;
#line 1910
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1913
        if (! (options___0->options + i)->name) {
#line 1914
          goto __Cont;
        }
#line 1916
        if (longindex == 0) {
#line 1917
          goto while_break___1;
        }
        __Cont: /* CIL Label */ 
#line 1908
        options___0 = options___0->parent;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 1921
      return;
    }
  } else {
#line 1921
    return;
  }
#line 1923
  if (! options___0) {
#line 1924
    return;
  } else
#line 1923
  if (i == -1) {
#line 1924
    return;
  }
#line 1926
  option___0 = options___0->options + i;
#line 1928
  if (option___0->has_arg == 1) {
#line 1928
    if (! argument) {
#line 1929
      return;
    }
  }
#line 1931
  if (option___0->has_arg == 0) {
#line 1931
    if (argument) {
#line 1932
      return;
    }
  }
#line 1934
  if (argument) {
    {
#line 1938
    if ((unsigned int )option___0->arg_type == 0U) {
#line 1938
      goto case_0;
    }
#line 1941
    if ((unsigned int )option___0->arg_type == 1U) {
#line 1941
      goto case_1;
    }
#line 1968
    if ((unsigned int )option___0->arg_type == 2U) {
#line 1968
      goto case_2___0;
    }
#line 1936
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1939
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1945
    if ((unsigned int )option___0->action == 0U) {
#line 1945
      goto case_0___0;
    }
#line 1948
    if ((unsigned int )option___0->action == 1U) {
#line 1948
      goto case_1___0;
    }
#line 1952
    if ((unsigned int )option___0->action == 2U) {
#line 1952
      goto case_2;
    }
#line 1943
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 1946
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 1949
    *((int *)option___0->object) = int_arg(argument);
    }
#line 1950
    goto switch_break___0;
    case_2: /* CIL Label */ 
    {
#line 1954
    tmp = int_arg(argument);
#line 1954
    arg = tmp;
    }
#line 1956
    if (option___0->has_arg == 1) {
      {
#line 1957
      (*((opt_action_int_t *)option___0->function))(arg);
      }
    } else {
      {
#line 1959
      (*((opt_action_optional_int_t *)option___0->function))(& arg);
      }
    }
#line 1961
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1965
    goto switch_break;
    case_2___0: /* CIL Label */ 
    {
#line 1972
    if ((unsigned int )option___0->action == 0U) {
#line 1972
      goto case_0___1;
    }
#line 1975
    if ((unsigned int )option___0->action == 1U) {
#line 1975
      goto case_1___1;
    }
#line 1979
    if ((unsigned int )option___0->action == 2U) {
#line 1979
      goto case_2___1;
    }
#line 1970
    goto switch_break___1;
    case_0___1: /* CIL Label */ 
#line 1973
    goto switch_break___1;
    case_1___1: /* CIL Label */ 
#line 1976
    *((char const   **)option___0->object) = argument;
#line 1977
    goto switch_break___1;
    case_2___1: /* CIL Label */ 
    {
#line 1980
    (*((opt_action_string_t *)option___0->function))(argument);
    }
#line 1981
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 1984
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1992
    if ((unsigned int )option___0->action == 0U) {
#line 1992
      goto case_0___2;
    }
#line 1995
    if ((unsigned int )option___0->action == 1U) {
#line 1995
      goto case_1___2;
    }
#line 2000
    if ((unsigned int )option___0->action == 2U) {
#line 2000
      goto case_2___2;
    }
#line 1990
    goto switch_break___2;
    case_0___2: /* CIL Label */ 
#line 1993
    goto switch_break___2;
    case_1___2: /* CIL Label */ 
#line 1996
    if ((unsigned int )option___0->arg_type != 2U) {
#line 1997
      (*((int *)option___0->object)) ++;
    }
#line 1998
    goto switch_break___2;
    case_2___2: /* CIL Label */ 
#line 2001
    if ((unsigned int )option___0->action == 2U) {
      {
#line 2002
      (*((opt_action_optional_int_t *)option___0->function))((int *)((void *)0));
      }
    } else {
      {
#line 2004
      (*(option___0->function))();
      }
    }
#line 2005
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
  }
#line 2008
  return;
}
}
#line 2051 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
int opt_process(int argc , char **argv , Options *options___0 , char *msgbuf , size_t bufsize ) 
{ 
  option *long_options ;
  char *optstring ;
  int longindex ;
  int rc ;
  int tmp ;
  int *tmp___0 ;
  char optname[256] ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 2056
  long_options = opt_convert(options___0);
  }
#line 2056
  if (! long_options) {
#line 2057
    return (optind);
  }
  {
#line 2059
  optstring = opt_optstring(options___0);
  }
#line 2059
  if (! optstring) {
    {
#line 2061
    free((void *)long_options);
    }
#line 2062
    return (optind);
  }
  {
#line 2065
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2067
    longindex = -1;
#line 2070
    rc = getopt_long(argc, (char * const  *)argv, (char const   *)optstring, (struct option  const  *)long_options,
                     & longindex);
    }
#line 2070
    if (rc == -1) {
#line 2071
      goto while_break;
    }
#line 2073
    if (rc == 63) {
      {
#line 2075
      free((void *)long_options);
#line 2076
      free((void *)optstring);
#line 2077
      tmp = set_errno(22);
      }
#line 2077
      return (tmp);
    } else
#line 2073
    if (rc == 58) {
      {
#line 2075
      free((void *)long_options);
#line 2076
      free((void *)optstring);
#line 2077
      tmp = set_errno(22);
      }
#line 2077
      return (tmp);
    }
#line 2080
    if (rc == 1) {
#line 2081
      rc = '?';
    }
    {
#line 2083
    tmp___0 = __errno_location();
#line 2083
    *tmp___0 = 0;
#line 2084
    opt_action(options___0, rc, longindex, (char const   *)optarg);
#line 2085
    tmp___4 = __errno_location();
    }
#line 2085
    if (*tmp___4 == 34) {
#line 2085
      goto _L___0;
    } else {
      {
#line 2085
      tmp___5 = __errno_location();
      }
#line 2085
      if (*tmp___5 == 33) {
        _L___0: /* CIL Label */ 
#line 2087
        if (msgbuf) {
#line 2091
          if (rc != 0) {
#line 2091
            if (longindex == -1) {
              {
#line 2092
              snprintf((char */* __restrict  */)(optname), (size_t )256, (char const   */* __restrict  */)"-%c",
                       rc);
              }
            } else {
#line 2091
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 2093
          if (rc == 0) {
#line 2093
            if (longindex != -1) {
              {
#line 2094
              snprintf((char */* __restrict  */)(optname), (size_t )256, (char const   */* __restrict  */)"--%s",
                       (long_options + longindex)->name);
              }
            }
          }
          {
#line 2096
          tmp___3 = __errno_location();
          }
#line 2096
          if (*tmp___3 == 33) {
#line 2096
            tmp___2 = "not an integer";
          } else {
#line 2096
            tmp___2 = "integer out of range";
          }
          {
#line 2096
          snprintf((char */* __restrict  */)msgbuf, bufsize, (char const   */* __restrict  */)"%s: invalid %s argument: %s",
                   *argv, optname, tmp___2);
          }
        }
        {
#line 2099
        free((void *)long_options);
#line 2100
        free((void *)optstring);
        }
#line 2101
        return (-1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2105
  free((void *)long_options);
#line 2106
  free((void *)optstring);
  }
#line 2107
  return (optind);
}
}
#line 2139 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/prog.c"
char *opt_usage(char *buf , size_t size , Options *options___0 ) 
{ 
  int total_width ;
  char const   *indent ;
  size_t indent_width ;
  size_t tmp ;
  char const   *leader ;
  size_t leader_width ;
  size_t tmp___0 ;
  Options *opts ;
  Options **stack ;
  size_t max_width ;
  size_t depth ;
  size_t length ;
  size_t remainder___0 ;
  int i ;
  Option *opt ;
  size_t width ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  Option *opt___0 ;
  char help[8192] ;
  char const   *desc ;
  char const   *next ;
  size_t desc_length ;
  size_t help_length ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int optional ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  char *tmp___12 ;
  unsigned short const   **tmp___13 ;
  unsigned short const   **tmp___14 ;
  size_t tmp___15 ;
  void *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;

  {
  {
#line 2141
  total_width = 80;
#line 2142
  indent = "      ";
#line 2143
  tmp = strlen(indent);
#line 2143
  indent_width = tmp;
#line 2144
  leader = " - ";
#line 2145
  tmp___0 = strlen(leader);
#line 2145
  leader_width = tmp___0;
#line 2149
  max_width = (size_t )0;
#line 2150
  depth = (size_t )0;
#line 2151
  length = (size_t )0;
#line 2152
  remainder___0 = (size_t )0;
#line 2157
  opts = options___0;
  }
  {
#line 2157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2157
    if (! opts) {
#line 2157
      goto while_break;
    }
#line 2159
    i = 0;
    {
#line 2159
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2159
      if (! (opts->options + i)->name) {
#line 2159
        goto while_break___0;
      }
      {
#line 2161
      opt = opts->options + i;
#line 2162
      tmp___1 = strlen(opt->name);
#line 2162
      width = tmp___1;
      }
#line 2164
      if (opt->argname) {
        {
#line 2166
        tmp___2 = strlen(opt->argname);
#line 2166
        width += 1UL + tmp___2;
        }
#line 2168
        if (opt->has_arg == 2) {
#line 2169
          width += 2UL;
        }
      }
#line 2172
      if (width > max_width) {
#line 2173
        max_width = width;
      }
#line 2159
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2157
    opts = opts->parent;
#line 2157
    depth ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2179
  max_width += 6UL;
#line 2183
  tmp___3 = malloc(depth * sizeof(Options *));
#line 2183
  stack = (Options **)tmp___3;
  }
#line 2183
  if (! stack) {
#line 2184
    return ((char *)((void *)0));
  }
#line 2186
  opts = options___0;
#line 2186
  i = 0;
  {
#line 2186
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2186
    if (! opts) {
#line 2186
      goto while_break___1;
    }
#line 2187
    tmp___4 = i;
#line 2187
    i ++;
#line 2187
    *(stack + tmp___4) = opts;
#line 2186
    opts = opts->parent;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2191
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2191
    tmp___15 = depth;
#line 2191
    depth --;
#line 2191
    if (! tmp___15) {
#line 2191
      goto while_break___2;
    }
    {
#line 2193
    opts = *(stack + depth);
#line 2195
    snprintf((char */* __restrict  */)(buf + length), size - length, (char const   */* __restrict  */)"\n");
#line 2196
    length = strlen((char const   *)buf);
#line 2198
    i = 0;
    }
    {
#line 2198
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2198
      if (! (opts->options + i)->name) {
#line 2198
        goto while_break___3;
      }
#line 2200
      opt___0 = opts->options + i;
#line 2203
      next = (char const   *)((void *)0);
#line 2209
      if (opt___0->short_name) {
#line 2209
        tmp___5 = ',';
      } else {
#line 2209
        tmp___5 = ' ';
      }
#line 2209
      if (opt___0->short_name) {
#line 2209
        tmp___6 = (int )opt___0->short_name;
      } else {
#line 2209
        tmp___6 = ' ';
      }
#line 2209
      if (opt___0->short_name) {
#line 2209
        tmp___7 = '-';
      } else {
#line 2209
        tmp___7 = ' ';
      }
      {
#line 2209
      snprintf((char */* __restrict  */)(help), (size_t )8192, (char const   */* __restrict  */)"%s%c%c%c --%s",
               indent, tmp___7, tmp___6, tmp___5, opt___0->name);
#line 2217
      help_length = strlen((char const   *)(help));
      }
#line 2219
      if (opt___0->argname) {
#line 2221
        optional = opt___0->has_arg == 2;
#line 2223
        if (optional) {
#line 2223
          tmp___8 = "]";
        } else {
#line 2223
          tmp___8 = "";
        }
#line 2223
        if (optional) {
#line 2223
          tmp___9 = "[=";
        } else {
#line 2223
          tmp___9 = "=";
        }
        {
#line 2223
        snprintf((char */* __restrict  */)(help + help_length), 8192UL - help_length,
                 (char const   */* __restrict  */)"%s%s%s", tmp___9, opt___0->argname,
                 tmp___8);
#line 2229
        help_length = strlen((char const   *)(help));
        }
      }
      {
#line 2232
      snprintf((char */* __restrict  */)(help + help_length), 8192UL - help_length,
               (char const   */* __restrict  */)"%*s%s", (int )((max_width - help_length) + indent_width),
               "", leader);
#line 2233
      help_length = strlen((char const   *)(help));
#line 2234
      remainder___0 = (size_t )total_width - help_length;
#line 2238
      desc = opt___0->desc;
      }
      {
#line 2238
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 2238
        desc_length = strlen(desc);
        }
#line 2238
        if (! (desc_length > remainder___0)) {
#line 2238
          goto while_break___4;
        }
#line 2241
        if ((unsigned long )desc != (unsigned long )opt___0->desc) {
          {
#line 2243
          snprintf((char */* __restrict  */)(help + help_length), 8192UL - help_length,
                   (char const   */* __restrict  */)"%*s%*.*s", (int )(indent_width + max_width),
                   "", (int )leader_width, (int )leader_width, "");
#line 2244
          help_length = strlen((char const   *)(help));
          }
        }
#line 2249
        next = desc + remainder___0;
        {
#line 2251
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 2251
          if ((unsigned long )next > (unsigned long )desc) {
            {
#line 2251
            tmp___10 = __ctype_b_loc();
            }
#line 2251
            if ((int const   )*(*tmp___10 + (int )((unsigned int )*next)) & 8192) {
#line 2251
              goto while_break___5;
            }
          } else {
#line 2251
            goto while_break___5;
          }
#line 2251
          next --;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 2256
        if ((unsigned long )next == (unsigned long )desc) {
          {
#line 2258
          while (1) {
            while_continue___6: /* CIL Label */ ;
            {
#line 2258
            tmp___11 = __ctype_b_loc();
            }
#line 2258
            if (! ((int const   )*(*tmp___11 + (int )((unsigned int )*next)) & 8192)) {
#line 2258
              goto while_break___6;
            }
#line 2259
            next ++;
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 2261
          tmp___12 = strchr(desc, ' ');
#line 2261
          next = (char const   *)tmp___12;
          }
#line 2263
          if (! next) {
#line 2264
            next = desc + desc_length;
          }
        }
        {
#line 2269
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 2269
          if ((unsigned long )next != (unsigned long )desc) {
            {
#line 2269
            tmp___13 = __ctype_b_loc();
            }
#line 2269
            if (! ((int const   )*(*tmp___13 + (int )((unsigned int )*(next + -1))) & 8192)) {
#line 2269
              goto while_break___7;
            }
          } else {
#line 2269
            goto while_break___7;
          }
#line 2270
          next --;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 2274
        snprintf((char */* __restrict  */)(help + help_length), 8192UL - help_length,
                 (char const   */* __restrict  */)"%*.*s\n", (int )(next - desc),
                 (int )(next - desc), desc);
#line 2275
        help_length = strlen((char const   *)(help));
        }
        {
#line 2279
        while (1) {
          while_continue___8: /* CIL Label */ ;
          {
#line 2279
          tmp___14 = __ctype_b_loc();
          }
#line 2279
          if (! ((int const   )*(*tmp___14 + (int )((unsigned int )*next)) & 8192)) {
#line 2279
            goto while_break___8;
          }
#line 2280
          next ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 2238
        desc = next;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 2285
      if (desc_length) {
#line 2289
        if ((unsigned long )desc != (unsigned long )opt___0->desc) {
          {
#line 2291
          snprintf((char */* __restrict  */)(help + help_length), 8192UL - help_length,
                   (char const   */* __restrict  */)"%*s%*.*s", (int )(indent_width + max_width),
                   "", (int )leader_width, (int )leader_width, "");
#line 2292
          help_length = strlen((char const   *)(help));
          }
        }
        {
#line 2295
        snprintf((char */* __restrict  */)(help + help_length), 8192UL - help_length,
                 (char const   */* __restrict  */)"%s\n", desc);
        }
      }
      {
#line 2300
      snprintf((char */* __restrict  */)(buf + length), size - length, (char const   */* __restrict  */)"%s",
               help);
#line 2301
      length = strlen((char const   *)buf);
#line 2198
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2305
  free((void *)stack);
  }
#line 2307
  return (buf);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 181 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 483 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__)) vsscanf)(char const   * __restrict  __s ,
                                                                                                     char const   * __restrict  __format ,
                                                                                                     __gnuc_va_list __arg )  __asm__("__isoc99_vsscanf")  ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 341
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 39 "/usr/include/x86_64-linux-gnu/sys/uio.h"
extern ssize_t readv(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 50
extern ssize_t writev(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 149
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 184
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 202
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 219
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void * __restrict  __optval ,
                                                                                 socklen_t * __restrict  __optlen ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 227 "/usr/include/netinet/in.h"
extern struct in6_addr  const  in6addr_any ;
#line 228
extern struct in6_addr  const  in6addr_loopback ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 179 "/usr/include/netdb.h"
extern int gethostbyname_r(char const   * __restrict  __name , struct hostent * __restrict  __result_buf ,
                           char * __restrict  __buf , size_t __buflen , struct hostent ** __restrict  __result ,
                           int * __restrict  __h_errnop ) ;
#line 312
extern int getservbyname_r(char const   * __restrict  __name , char const   * __restrict  __proto ,
                           struct servent * __restrict  __result_buf , char * __restrict  __buf ,
                           size_t __buflen , struct servent ** __restrict  __result ) ;
#line 193 "/usr/include/net/if.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) if_nametoindex)(char const   *__ifname ) ;
#line 194
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) if_indextoname)(unsigned int __ifindex ,
                                                                                       char *__ifname ) ;
#line 152 "libslack/slack/list.h"
void list_break(List *list ) ;
#line 90 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.h"
int net_server(char const   *interface , char const   *service , sockport_t port ,
               int rcvbufsz , int sndbufsz , sockaddr_t *addr , size_t *addrsize ) ;
#line 91
int net_client(char const   *host , char const   *service , sockport_t port , long timeout___0 ,
               int rcvbufsz , int sndbufsz , sockaddr_t *addr , size_t *addrsize ) ;
#line 92
int net_udp_server(char const   *interface , char const   *service , sockport_t port ,
                   int rcvbufsz , int sndbufsz , sockaddr_t *addr , size_t *addrsize ) ;
#line 93
int net_udp_client(char const   *host , char const   *service , sockport_t port ,
                   int rcvbufsz , int sndbufsz , sockaddr_t *addr , size_t *addrsize ) ;
#line 94
int net_create_server(char const   *interface , char const   *service , sockport_t port ,
                      int type , int protocol , sockopt_t *sockopts , sockaddr_t *addr ,
                      size_t *addrsize ) ;
#line 95
int net_create_client(char const   *host , char const   *service , sockport_t port ,
                      sockport_t localport , int type , int protocol , long timeout___0 ,
                      sockopt_t *sockopts , sockaddr_t *addr , size_t *addrsize ) ;
#line 96
int net_multicast_sender(char const   *group , char const   *service , sockport_t port ,
                         sockopt_t *sockopts , sockaddr_t *addr , size_t *addrsize ,
                         char const   *ifname , unsigned int ifindex , int ttl , unsigned int noloopback ) ;
#line 97
int net_multicast_receiver(char const   *group , char const   *service , sockport_t port ,
                           sockopt_t *sockopts , sockaddr_t *addr , size_t *addrsize ,
                           char const   *ifname , unsigned int ifindex ) ;
#line 98
int net_multicast_join(int sockfd , sockaddr_t const   *addr , size_t addrsize , char const   *ifname ,
                       unsigned int ifindex ) ;
#line 99
int net_multicast_leave(int sockfd , sockaddr_t const   *addr , size_t addrsize ,
                        char const   *ifname , unsigned int ifindex ) ;
#line 100
int net_multicast_set_interface(int sockfd , char const   *ifname , unsigned int ifindex ) ;
#line 101
int net_multicast_get_interface(int sockfd ) ;
#line 102
int net_multicast_set_loopback(int sockfd , unsigned int loopback ) ;
#line 103
int net_multicast_get_loopback(int sockfd ) ;
#line 104
int net_multicast_set_ttl(int sockfd , int ttl ) ;
#line 105
int net_multicast_get_ttl(int sockfd ) ;
#line 106
int net_tos_lowdelay(int sockfd ) ;
#line 107
int net_tos_throughput(int sockfd ) ;
#line 108
int net_tos_reliability(int sockfd ) ;
#line 109
int net_tos_lowcost(int sockfd ) ;
#line 110
int net_tos_normal(int sockfd ) ;
#line 111
struct hostent *net_gethostbyname(char const   *name , struct hostent *hostbuf , void **buf ,
                                  size_t *size , int *herrno ) ;
#line 112
struct servent *net_getservbyname(char const   *name , char const   *proto , struct servent *servbuf ,
                                  void **buf , size_t *size ) ;
#line 113
int net_options(int sockfd , sockopt_t *sockopts ) ;
#line 114
List *net_interfaces(void) ;
#line 115
List *net_interfaces_with_locker(Locker *locker ) ;
#line 116
List *net_interfaces_by_family(int family ) ;
#line 117
List *net_interfaces_by_family_with_locker(int family , Locker *locker ) ;
#line 118
rudp_t *rudp_create(void) ;
#line 119
void rudp_release(rudp_t *rudp ) ;
#line 120
void *rudp_destroy(rudp_t **rudp ) ;
#line 121
ssize_t net_rudp_transact(int sockfd , rudp_t *rudp , void const   *obuf , size_t osize ,
                          void *ibuf , size_t isize ) ;
#line 122
ssize_t net_rudp_transactwith(int sockfd , rudp_t *rudp , void const   *obuf , size_t osize ,
                              int oflags , void *ibuf , size_t isize , int iflags ,
                              sockaddr_any_t *addr , size_t addrsize ) ;
#line 123
ssize_t net_pack(int sockfd , long timeout___0 , int flags , char const   *format 
                 , ...) ;
#line 124
ssize_t net_vpack(int sockfd , long timeout___0 , int flags , char const   *format ,
                  va_list args ) ;
#line 125
ssize_t net_packto(int sockfd , long timeout___0 , int flags , sockaddr_t const   *to ,
                   size_t tosize , char const   *format  , ...) ;
#line 126
ssize_t net_vpackto(int sockfd , long timeout___0 , int flags , sockaddr_t const   *to ,
                    size_t tosize , char const   *format , va_list args ) ;
#line 127
ssize_t net_unpack(int sockfd , long timeout___0 , int flags , char const   *format 
                   , ...) ;
#line 128
ssize_t net_vunpack(int sockfd , long timeout___0 , int flags , char const   *format ,
                    va_list args ) ;
#line 129
ssize_t net_unpackfrom(int sockfd , long timeout___0 , int flags , sockaddr_t *from ,
                       size_t *fromsize , char const   *format  , ...) ;
#line 130
ssize_t net_vunpackfrom(int sockfd , long timeout___0 , int flags , sockaddr_t *from ,
                        size_t *fromsize , char const   *format , va_list args ) ;
#line 131
ssize_t pack(void *buf , size_t size , char const   *format  , ...) ;
#line 132
ssize_t vpack(void *buf , size_t size , char const   *format , va_list args ) ;
#line 133
ssize_t unpack(void *buf , size_t size , char const   *format  , ...) ;
#line 134
ssize_t vunpack(void *buf , size_t size , char const   *format , va_list args ) ;
#line 135
ssize_t net_read(int sockfd , long timeout___0 , char *buf , size_t count ) ;
#line 136
ssize_t net_write(int sockfd , long timeout___0 , char const   *buf , size_t count ) ;
#line 137
ssize_t net_expect(int sockfd , long timeout___0 , char const   *format  , ...) ;
#line 138
ssize_t net_vexpect(int sockfd , long timeout___0 , char const   *format , va_list args ) ;
#line 139
ssize_t net_send(int sockfd , long timeout___0 , char const   *format  , ...) ;
#line 140
ssize_t net_vsend(int sockfd , long timeout___0 , char const   *format , va_list args ) ;
#line 141
ssize_t sendfd(int sockfd , void const   *buf , size_t nbytes , int flags , int fd ) ;
#line 142
ssize_t recvfd(int sockfd , void *buf , size_t nbytes , int flags , int *fd ) ;
#line 143
int mail(char const   *server , char const   *sender , char const   *recipients ,
         char const   *subject , char const   *message ) ;
#line 35 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/fio.h"
int read_timeout(int fd , long sec , long usec ) ;
#line 36
int write_timeout(int fd , long sec , long usec ) ;
#line 37
int rw_timeout(int fd , long sec , long usec ) ;
#line 43
int nonblock_on(int fd ) ;
#line 44
int nonblock_off(int fd ) ;
#line 286 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
static sockopt_t *build_sockopts(sockopt_t *sockopts , int *rcvbufsz , int *sndbufsz ) 
{ 
  size_t so ;

  {
#line 288
  so = (size_t )0;
#line 290
  if (*rcvbufsz) {
#line 292
    (sockopts + so)->level = 1;
#line 293
    (sockopts + so)->optname = 8;
#line 294
    (sockopts + so)->optval = (void const   *)rcvbufsz;
#line 295
    (sockopts + so)->optlen = (int )sizeof(int );
#line 296
    so ++;
  }
#line 299
  if (*sndbufsz) {
#line 301
    (sockopts + so)->level = 1;
#line 302
    (sockopts + so)->optname = 7;
#line 303
    (sockopts + so)->optval = (void const   *)sndbufsz;
#line 304
    (sockopts + so)->optlen = (int )sizeof(int );
#line 305
    so ++;
  }
#line 308
  (sockopts + so)->optval = (void const   *)((void *)0);
#line 310
  return (sockopts);
}
}
#line 313 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
int net_server(char const   *interface , char const   *service , sockport_t port ,
               int rcvbufsz , int sndbufsz , sockaddr_t *addr , size_t *addrsize ) 
{ 
  sockopt_t sockopts[3] ;
  int tmp ;
  void *__cil_tmp10 ;

  {
  {
#line 317
  build_sockopts(sockopts, & rcvbufsz, & sndbufsz);
#line 319
  tmp = net_create_server(interface, service, port, 1, 0, sockopts, addr, addrsize);
  }
#line 319
  return (tmp);
}
}
#line 369 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
int net_client(char const   *host , char const   *service , sockport_t port , long timeout___0 ,
               int rcvbufsz , int sndbufsz , sockaddr_t *addr , size_t *addrsize ) 
{ 
  sockopt_t sockopts[3] ;
  int tmp ;
  void *__cil_tmp11 ;

  {
  {
#line 373
  build_sockopts(sockopts, & rcvbufsz, & sndbufsz);
#line 375
  tmp = net_create_client(host, service, port, (sockport_t )0, 1, 0, timeout___0,
                          sockopts, addr, addrsize);
  }
#line 375
  return (tmp);
}
}
#line 392 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
int net_udp_server(char const   *interface , char const   *service , sockport_t port ,
                   int rcvbufsz , int sndbufsz , sockaddr_t *addr , size_t *addrsize ) 
{ 
  sockopt_t sockopts[3] ;
  int tmp ;
  void *__cil_tmp10 ;

  {
  {
#line 396
  build_sockopts(sockopts, & rcvbufsz, & sndbufsz);
#line 398
  tmp = net_create_server(interface, service, port, 2, 0, sockopts, addr, addrsize);
  }
#line 398
  return (tmp);
}
}
#line 415 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
int net_udp_client(char const   *host , char const   *service , sockport_t port ,
                   int rcvbufsz , int sndbufsz , sockaddr_t *addr , size_t *addrsize ) 
{ 
  sockopt_t sockopts[3] ;
  int tmp ;
  void *__cil_tmp10 ;

  {
  {
#line 419
  build_sockopts(sockopts, & rcvbufsz, & sndbufsz);
#line 421
  tmp = net_create_client(host, service, port, (sockport_t )0, 2, 0, 0L, sockopts,
                          addr, addrsize);
  }
#line 421
  return (tmp);
}
}
#line 439 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
static sockaddr_t *net_unaddr(sockaddr_un_t *un , size_t family , char const   *path ) 
{ 


  {
  {
#line 441
  memset((void *)un, 0, sizeof(sockaddr_un_t ));
#line 442
  un->sun_family = (sa_family_t )family;
#line 443
  strlcpy(un->sun_path, path, sizeof(un->sun_path));
  }
#line 444
  return ((sockaddr_t *)un);
}
}
#line 447 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
static sockaddr_t *net_inaddr(sockaddr_in_t *in , size_t family , void const   *addr ,
                              size_t addrsize , sockport_t port ) 
{ 


  {
  {
#line 449
  memset((void *)in, 0, sizeof(sockaddr_in_t ));
#line 450
  in->sin_family = (sa_family_t )family;
#line 451
  memcpy((void */* __restrict  */)(& in->sin_addr), (void const   */* __restrict  */)addr,
         addrsize);
#line 452
  in->sin_port = port;
  }
#line 453
  return ((sockaddr_t *)in);
}
}
#line 457 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
static sockaddr_t *net_in6addr(sockaddr_in6_t *in6 , size_t family , void const   *addr ,
                               size_t addrsize , sockport_t port ) 
{ 


  {
  {
#line 459
  memset((void *)in6, 0, sizeof(sockaddr_in6_t ));
#line 460
  in6->sin6_family = (sa_family_t )family;
#line 461
  memcpy((void */* __restrict  */)(& in6->sin6_addr), (void const   */* __restrict  */)addr,
         addrsize);
#line 462
  in6->sin6_port = port;
  }
#line 463
  return ((sockaddr_t *)in6);
}
}
#line 468 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
static int inet6_required(void) 
{ 
  char *res_options ;
  FILE *resolv_conf ;
  char *tmp ;
  char line[8192] ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 473
  res_options = getenv("RES_OPTIONS");
  }
#line 473
  if (res_options) {
    {
#line 473
    tmp = strstr((char const   *)res_options, "inet6");
    }
#line 473
    if (tmp) {
#line 474
      return (1);
    }
  }
  {
#line 476
  resolv_conf = fopen((char const   */* __restrict  */)"/etc/resolv.conf", (char const   */* __restrict  */)"r");
  }
#line 476
  if (resolv_conf) {
    {
#line 480
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 480
      tmp___2 = fgets((char */* __restrict  */)(line), 8192, (FILE */* __restrict  */)resolv_conf);
      }
#line 480
      if (! tmp___2) {
#line 480
        goto while_break;
      }
      {
#line 482
      tmp___0 = strncmp((char const   *)(line), "options", (size_t )7);
      }
#line 482
      if (! tmp___0) {
        {
#line 482
        tmp___1 = strstr((char const   *)(line + 8), "inet6");
        }
#line 482
        if (tmp___1) {
          {
#line 484
          fclose(resolv_conf);
          }
#line 485
          return (1);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 489
    fclose(resolv_conf);
    }
  }
#line 492
  return (0);
}
}
#line 496 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
static char const   *getprotonamebysocktype(int socktype ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 500
  if (socktype == 1) {
#line 500
    goto case_1;
  }
#line 501
  if (socktype == 2) {
#line 501
    goto case_2;
  }
#line 502
  goto switch_default;
  case_1: /* CIL Label */ 
#line 500
  return ("tcp");
  case_2: /* CIL Label */ 
#line 501
  return ("udp");
  switch_default: /* CIL Label */ 
#line 502
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 506 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
static sockport_t getservportbynameandtype(char const   *name , int type ) 
{ 
  struct servent servbuf[1] ;
  struct servent *serv ;
  void *buf ;
  size_t size ;
  sockport_t port ;
  char const   *proto ;
  void *__cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 510
  buf = (void *)0;
#line 511
  size = (size_t )0;
#line 512
  port = (sockport_t )0;
#line 515
  proto = getprotonamebysocktype(type);
#line 517
  serv = net_getservbyname(name, proto, servbuf, & buf, & size);
  }
#line 517
  if (serv) {
#line 518
    port = (sockport_t )serv->s_port;
  }
  {
#line 520
  free(buf);
  }
#line 522
  return (port);
}
}
#line 525 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
static int service_number(char const   *service ) 
{ 
  char *endptr ;
  unsigned long val ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 527
  endptr = (char *)((void *)0);
#line 528
  tmp = strtoul((char const   */* __restrict  */)service, (char **/* __restrict  */)(& endptr),
                10);
#line 528
  val = tmp;
#line 530
  val = strtoul((char const   */* __restrict  */)service, (char **/* __restrict  */)(& endptr),
                10);
  }
#line 530
  if (val > 65535UL) {
    {
#line 531
    tmp___0 = set_errno(34);
    }
#line 531
    return (tmp___0);
  }
#line 533
  if ((unsigned long )endptr == (unsigned long )service) {
    {
#line 534
    tmp___1 = set_errno(33);
    }
#line 534
    return (tmp___1);
  } else
#line 533
  if ((int )*endptr != 0) {
    {
#line 534
    tmp___1 = set_errno(33);
    }
#line 534
    return (tmp___1);
  }
#line 536
  return ((int )val);
}
}
#line 539 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
static sockport_t service_port(char const   *service , int type , int port ) 
{ 
  int ret ;
  uint16_t tmp ;
  sockport_t tmp___0 ;
  uint16_t tmp___1 ;

  {
#line 541
  if (service) {
    {
#line 545
    ret = service_number(service);
    }
#line 545
    if (ret != -1) {
      {
#line 546
      tmp = htons((sockport_t )ret);
      }
#line 546
      return (tmp);
    }
    {
#line 548
    tmp___0 = getservportbynameandtype(service, type);
#line 548
    ret = (int )tmp___0;
    }
#line 548
    if (ret != 0) {
#line 549
      return ((sockport_t )ret);
    }
  }
  {
#line 552
  tmp___1 = htons((uint16_t )port);
  }
#line 552
  return (tmp___1);
}
}
#line 555 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
static int is_multicast(sockaddr_t *address ) 
{ 
  sockaddr_any_t *addr ;
  long *longptr ;
  uint32_t tmp ;

  {
#line 557
  addr = (sockaddr_any_t *)address;
  {
#line 562
  if ((int )addr->any.sa_family == 2) {
#line 562
    goto case_2;
  }
#line 569
  if ((int )addr->any.sa_family == 10) {
#line 569
    goto case_10;
  }
#line 560
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 565
  longptr = (long *)(& addr->in.sin_addr);
#line 566
  tmp = ntohl((uint32_t )*longptr);
  }
#line 566
  return ((tmp & 4026531840U) == 3758096384U);
  case_10: /* CIL Label */ 
#line 570
  return ((int const   )*((uint8_t const   *)(& addr->in6.sin6_addr) + 0) == 255);
  switch_break: /* CIL Label */ ;
  }
#line 574
  return (0);
}
}
#line 577 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
int net_create_server(char const   *interface , char const   *service , sockport_t port ,
                      int type , int protocol , sockopt_t *sockopts , sockaddr_t *addr ,
                      size_t *addrsize ) 
{ 
  int sockfd ;
  sockaddr_any_t localany ;
  sockaddr_t *localaddr ;
  size_t localsize ;
  struct hostent *hostent ;
  int reuse_addr ;
  int tmp ;
  size_t tmp___0 ;
  struct hostent hostbuf[1] ;
  void *buf ;
  size_t size ;
  int herrno ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned long inaddr_any ;
  uint32_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *__cil_tmp32 ;
  int __cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 584
  reuse_addr = 1;
#line 588
  if (interface) {
    {
#line 588
    tmp___5 = strcmp(interface, "/unix");
    }
#line 588
    if (tmp___5) {
#line 588
      goto _L;
    } else {
#line 590
      if (! service) {
        {
#line 591
        tmp = set_errno(22);
        }
#line 591
        return (tmp);
      } else
#line 590
      if ((int const   )*service != 47) {
        {
#line 591
        tmp = set_errno(22);
        }
#line 591
        return (tmp);
      } else
#line 590
      if (! *(service + 1)) {
        {
#line 591
        tmp = set_errno(22);
        }
#line 591
        return (tmp);
      } else {
        {
#line 590
        tmp___0 = strlen(service);
        }
#line 590
        if (tmp___0 >= sizeof(localany.un.sun_path)) {
          {
#line 591
          tmp = set_errno(22);
          }
#line 591
          return (tmp);
        }
      }
      {
#line 593
      localaddr = net_unaddr(& localany.un, (size_t )1, service);
#line 594
      localsize = sizeof(localany.un);
#line 595
      unlink((char const   *)(localany.un.sun_path));
      }
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 601
    port = service_port(service, type, (int )port);
    }
#line 605
    if (interface) {
      {
#line 608
      buf = (void *)0;
#line 609
      size = (size_t )0;
#line 612
      hostent = net_gethostbyname(interface, hostbuf, & buf, & size, & herrno);
      }
#line 612
      if (! hostent) {
        {
#line 614
        free(buf);
#line 615
        tmp___1 = set_errno(2);
        }
#line 615
        return (tmp___1);
      }
#line 618
      if (hostent->h_addrtype == 2) {
        {
#line 620
        localaddr = net_inaddr(& localany.in, (size_t )hostent->h_addrtype, (void const   *)*(hostent->h_addr_list + 0),
                               (size_t )hostent->h_length, port);
#line 621
        localsize = sizeof(localany.in);
        }
      } else
#line 624
      if (hostent->h_addrtype == 10) {
        {
#line 626
        localaddr = net_in6addr(& localany.in6, (size_t )hostent->h_addrtype, (void const   *)*(hostent->h_addr_list + 0),
                                (size_t )hostent->h_length, port);
#line 627
        localsize = sizeof(localany.in6);
        }
      } else {
        {
#line 632
        free(buf);
#line 633
        tmp___2 = set_errno(38);
        }
#line 633
        return (tmp___2);
      }
      {
#line 636
      free(buf);
      }
    } else {
      {
#line 641
      tmp___4 = inet6_required();
      }
#line 641
      if (tmp___4) {
        {
#line 643
        localaddr = net_in6addr(& localany.in6, (size_t )10, (void const   *)(& in6addr_any),
                                sizeof(in6addr_any), port);
#line 644
        localsize = sizeof(localany.in6);
        }
      } else {
        {
#line 649
        tmp___3 = htonl((in_addr_t )0);
#line 649
        inaddr_any = (unsigned long )tmp___3;
#line 650
        localaddr = net_inaddr(& localany.in, (size_t )2, (void const   *)(& inaddr_any),
                               sizeof(inaddr_any), port);
#line 651
        localsize = sizeof(localany.in);
        }
      }
    }
  }
  {
#line 658
  sockfd = socket((int )localaddr->sa_family, type, protocol);
  }
#line 658
  if (sockfd == -1) {
#line 659
    return (-1);
  }
#line 663
  if (type == 1) {
#line 663
    if ((int )localaddr->sa_family != 1) {
#line 663
      goto _L___0;
    } else {
#line 663
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 663
  if (type == 2) {
    {
#line 663
    tmp___7 = is_multicast(localaddr);
    }
#line 663
    if (tmp___7) {
      _L___0: /* CIL Label */ 
      {
#line 664
      tmp___6 = setsockopt(sockfd, 1, 2, (void const   *)(& reuse_addr), (socklen_t )sizeof(reuse_addr));
      }
#line 664
      if (tmp___6 == -1) {
        {
#line 665
        close(sockfd);
        }
#line 665
        return (-1);
      }
    }
  }
#line 669
  if (sockopts) {
    {
#line 669
    tmp___8 = net_options(sockfd, sockopts);
    }
#line 669
    if (tmp___8 == -1) {
      {
#line 670
      close(sockfd);
      }
#line 670
      return (-1);
    }
  }
  {
#line 674
  tmp___9 = bind(sockfd, (struct sockaddr  const  *)localaddr, (socklen_t )localsize);
  }
#line 674
  if (tmp___9 == -1) {
    {
#line 675
    close(sockfd);
    }
#line 675
    return (-1);
  }
#line 679
  if (type == 1) {
    {
#line 679
    tmp___10 = listen(sockfd, 1024);
    }
#line 679
    if (tmp___10 == -1) {
      {
#line 680
      close(sockfd);
      }
#line 680
      return (-1);
    }
  }
#line 684
  if (addr) {
#line 684
    if (addrsize) {
#line 684
      if (*addrsize >= localsize) {
        {
#line 685
        memcpy((void */* __restrict  */)addr, (void const   */* __restrict  */)localaddr,
               localsize);
        }
      }
    }
  }
#line 687
  if (addrsize) {
#line 688
    *addrsize = localsize;
  }
#line 690
  return (sockfd);
}
}
#line 709 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
static int net_client_connect(sockaddr_t *remoteaddr , size_t remotesize , sockport_t localport ,
                              int type , int protocol , int timeout___0 , sockopt_t *sockopts ) 
{ 
  int sockfd ;
  int rc ;
  int tmp ;
  sockaddr_any_t localany ;
  sockaddr_t *localaddr ;
  size_t localsize ;
  uint16_t tmp___0 ;
  unsigned long inaddr_any ;
  uint32_t tmp___1 ;
  uint16_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int saved_errno ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int access___0 ;
  int err ;
  size_t size ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp31 ;

  {
  {
#line 716
  sockfd = socket((int )remoteaddr->sa_family, type, protocol);
  }
#line 716
  if (sockfd == -1) {
#line 717
    return (-1);
  }
#line 721
  if (sockopts) {
    {
#line 721
    tmp = net_options(sockfd, sockopts);
    }
#line 721
    if (tmp == -1) {
      {
#line 722
      close(sockfd);
      }
#line 722
      return (-1);
    }
  }
#line 726
  if (type == 2) {
#line 726
    if (localport) {
#line 726
      goto _L;
    } else
#line 726
    if ((int )remoteaddr->sa_family == 1) {
      _L: /* CIL Label */ 
#line 732
      if ((int )remoteaddr->sa_family == 1) {
        {
#line 735
        localaddr = net_unaddr(& localany.un, (size_t )1, "");
#line 766
        localsize = sizeof(localany.un);
        }
      } else {
        {
#line 771
        tmp___3 = inet6_required();
        }
#line 771
        if (tmp___3) {
          {
#line 773
          tmp___0 = htons(localport);
#line 773
          localaddr = net_in6addr(& localany.in6, (size_t )10, (void const   *)(& in6addr_any),
                                  sizeof(in6addr_any), tmp___0);
#line 774
          localsize = sizeof(localany.in6);
          }
        } else {
          {
#line 779
          tmp___1 = htonl((in_addr_t )0);
#line 779
          inaddr_any = (unsigned long )tmp___1;
#line 780
          tmp___2 = htons(localport);
#line 780
          localaddr = net_inaddr(& localany.in, (size_t )2, (void const   *)(& inaddr_any),
                                 sizeof(inaddr_any), tmp___2);
#line 781
          localsize = sizeof(localany.in);
          }
        }
      }
      {
#line 785
      tmp___4 = bind(sockfd, (struct sockaddr  const  *)localaddr, (socklen_t )localsize);
      }
#line 785
      if (tmp___4 == -1) {
        {
#line 786
        close(sockfd);
        }
#line 786
        return (-1);
      }
    }
  }
#line 791
  if (timeout___0) {
    {
#line 791
    tmp___5 = nonblock_on(sockfd);
    }
#line 791
    if (tmp___5 == -1) {
      {
#line 792
      close(sockfd);
      }
#line 792
      return (-1);
    }
  }
  {
#line 794
  rc = connect(sockfd, (struct sockaddr  const  *)remoteaddr, (socklen_t )remotesize);
  }
#line 794
  if (rc == -1) {
    {
#line 794
    tmp___8 = __errno_location();
    }
#line 794
    if (*tmp___8 != 115) {
      {
#line 796
      tmp___6 = __errno_location();
#line 796
      saved_errno = *tmp___6;
#line 797
      close(sockfd);
#line 798
      tmp___7 = set_errno(saved_errno);
      }
#line 798
      return (tmp___7);
    }
  }
#line 801
  if (rc == -1) {
    {
#line 803
    err = 0;
#line 804
    size = sizeof(err);
#line 806
    access___0 = rw_timeout(sockfd, (long )timeout___0, 0L);
    }
#line 806
    if (access___0 == -1) {
      {
#line 807
      close(sockfd);
      }
#line 807
      return (-1);
    }
#line 809
    if (! (access___0 & 4)) {
#line 809
      if (! (access___0 & 2)) {
        {
#line 810
        close(sockfd);
        }
#line 810
        return (-1);
      }
    }
    {
#line 812
    tmp___9 = getsockopt(sockfd, 1, 4, (void */* __restrict  */)((void *)(& err)),
                         (socklen_t */* __restrict  */)((void *)(& size)));
    }
#line 812
    if (tmp___9 == -1) {
      {
#line 813
      close(sockfd);
      }
#line 813
      return (-1);
    }
#line 815
    if (err) {
      {
#line 816
      close(sockfd);
#line 816
      tmp___10 = set_errno(err);
      }
#line 816
      return (tmp___10);
    }
  }
#line 819
  if (timeout___0) {
    {
#line 819
    tmp___11 = nonblock_off(sockfd);
    }
#line 819
    if (tmp___11 == -1) {
      {
#line 820
      close(sockfd);
      }
#line 820
      return (-1);
    }
  }
#line 822
  return (sockfd);
}
}
#line 825 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
int net_create_client(char const   *host , char const   *service , sockport_t port ,
                      sockport_t localport , int type , int protocol , long timeout___0 ,
                      sockopt_t *sockopts , sockaddr_t *addr , size_t *addrsize ) 
{ 
  int sockfd ;
  sockaddr_any_t remoteany ;
  sockaddr_t *remoteaddr ;
  size_t remotesize ;
  struct hostent *hostent ;
  struct hostent hostbuf[1] ;
  void *buf ;
  size_t size ;
  int herrno ;
  size_t h ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned long inaddr_loopback ;
  uint32_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp29 ;
  int __cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 831
  hostent = (struct hostent *)((void *)0);
#line 833
  buf = (void *)0;
#line 834
  size = (size_t )0;
#line 836
  h = (size_t )0;
#line 840
  if (host) {
    {
#line 840
    tmp___5 = strcmp(host, "/unix");
    }
#line 840
    if (tmp___5) {
#line 840
      goto _L;
    } else {
#line 842
      if (! service) {
        {
#line 843
        tmp = set_errno(22);
        }
#line 843
        return (tmp);
      } else
#line 842
      if ((int const   )*service != 47) {
        {
#line 843
        tmp = set_errno(22);
        }
#line 843
        return (tmp);
      } else
#line 842
      if (! *(service + 1)) {
        {
#line 843
        tmp = set_errno(22);
        }
#line 843
        return (tmp);
      } else {
        {
#line 842
        tmp___0 = strlen(service);
        }
#line 842
        if (tmp___0 >= sizeof(remoteany.un.sun_path)) {
          {
#line 843
          tmp = set_errno(22);
          }
#line 843
          return (tmp);
        }
      }
      {
#line 845
      remoteaddr = net_unaddr(& remoteany.un, (size_t )1, service);
#line 846
      remotesize = sizeof(remoteany.un);
      }
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 852
    port = service_port(service, type, (int )port);
    }
#line 856
    if (host) {
      {
#line 858
      hostent = net_gethostbyname(host, hostbuf, & buf, & size, & herrno);
      }
#line 858
      if (! hostent) {
        {
#line 860
        free(buf);
#line 861
        tmp___1 = set_errno(2);
        }
#line 861
        return (tmp___1);
      }
#line 864
      if (hostent->h_addrtype == 2) {
        {
#line 866
        remoteaddr = net_inaddr(& remoteany.in, (size_t )hostent->h_addrtype, (void const   *)*(hostent->h_addr_list + 0),
                                (size_t )hostent->h_length, port);
#line 867
        remotesize = sizeof(remoteany.in);
        }
      } else
#line 870
      if (hostent->h_addrtype == 10) {
        {
#line 872
        remoteaddr = net_in6addr(& remoteany.in6, (size_t )hostent->h_addrtype, (void const   *)*(hostent->h_addr_list + 0),
                                 (size_t )hostent->h_length, port);
#line 873
        remotesize = sizeof(remoteany.in6);
        }
      } else {
        {
#line 878
        free(buf);
#line 879
        tmp___2 = set_errno(38);
        }
#line 879
        return (tmp___2);
      }
    } else {
      {
#line 885
      tmp___4 = inet6_required();
      }
#line 885
      if (tmp___4) {
        {
#line 887
        remoteaddr = net_in6addr(& remoteany.in6, (size_t )10, (void const   *)(& in6addr_loopback),
                                 sizeof(in6addr_loopback), port);
#line 888
        remotesize = sizeof(remoteany.in6);
        }
      } else {
        {
#line 893
        tmp___3 = htonl((in_addr_t )2130706433);
#line 893
        inaddr_loopback = (unsigned long )tmp___3;
#line 894
        remoteaddr = net_inaddr(& remoteany.in, (size_t )2, (void const   *)(& inaddr_loopback),
                                sizeof(inaddr_loopback), port);
#line 895
        remotesize = sizeof(remoteany.in);
        }
      }
    }
  }
  {
#line 902
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 904
    sockfd = net_client_connect(remoteaddr, remotesize, localport, type, protocol,
                                (int )timeout___0, sockopts);
    }
#line 904
    if (sockfd != -1) {
#line 905
      goto while_break;
    }
#line 909
    if (! hostent) {
#line 910
      goto while_break;
    } else {
#line 909
      h ++;
#line 909
      if (! *(hostent->h_addr_list + h)) {
#line 910
        goto while_break;
      }
    }
#line 912
    if (hostent->h_addrtype == 2) {
      {
#line 914
      remoteaddr = net_inaddr(& remoteany.in, (size_t )hostent->h_addrtype, (void const   *)*(hostent->h_addr_list + h),
                              (size_t )hostent->h_length, port);
#line 915
      remotesize = sizeof(remoteany.in);
      }
    } else
#line 918
    if (hostent->h_addrtype == 10) {
      {
#line 920
      remoteaddr = net_in6addr(& remoteany.in6, (size_t )hostent->h_addrtype, (void const   *)*(hostent->h_addr_list + h),
                               (size_t )hostent->h_length, port);
#line 921
      remotesize = sizeof(remoteany.in6);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 926
  free(buf);
  }
#line 930
  if (sockfd == -1) {
#line 931
    return (-1);
  }
#line 935
  if (addr) {
#line 935
    if (addrsize) {
#line 935
      if (*addrsize >= remotesize) {
        {
#line 936
        memcpy((void */* __restrict  */)addr, (void const   */* __restrict  */)remoteaddr,
               remotesize);
        }
      }
    }
  }
#line 938
  if (addrsize) {
#line 939
    *addrsize = remotesize;
  }
#line 941
  return (sockfd);
}
}
#line 995 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
int net_multicast_sender(char const   *group , char const   *service , sockport_t port ,
                         sockopt_t *sockopts , sockaddr_t *addr , size_t *addrsize ,
                         char const   *ifname , unsigned int ifindex , int ttl , unsigned int noloopback ) 
{ 
  int sockfd ;
  unsigned int loopback ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 998
  loopback = 0U;
#line 1000
  sockfd = net_create_client(group, service, port, (sockport_t )0, 2, 0, 0L, sockopts,
                             addr, addrsize);
  }
#line 1000
  if (sockfd == -1) {
#line 1001
    return (-1);
  }
#line 1003
  if (ifname) {
#line 1003
    goto _L;
  } else
#line 1003
  if (ifindex) {
    _L: /* CIL Label */ 
    {
#line 1003
    tmp = net_multicast_set_interface(sockfd, ifname, ifindex);
    }
#line 1003
    if (tmp == -1) {
      {
#line 1004
      close(sockfd);
      }
#line 1004
      return (-1);
    }
  }
#line 1006
  if (ttl > 1) {
    {
#line 1006
    tmp___0 = net_multicast_set_ttl(sockfd, ttl);
    }
#line 1006
    if (tmp___0 == -1) {
      {
#line 1007
      close(sockfd);
      }
#line 1007
      return (-1);
    }
  }
#line 1009
  if (noloopback) {
    {
#line 1009
    tmp___1 = net_multicast_set_loopback(sockfd, loopback);
    }
#line 1009
    if (tmp___1 == -1) {
      {
#line 1010
      close(sockfd);
      }
#line 1010
      return (-1);
    }
  }
#line 1012
  return (sockfd);
}
}
#line 1054 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
int net_multicast_receiver(char const   *group , char const   *service , sockport_t port ,
                           sockopt_t *sockopts , sockaddr_t *addr , size_t *addrsize ,
                           char const   *ifname , unsigned int ifindex ) 
{ 
  sockaddr_any_t any[1] ;
  size_t anysize ;
  int sockfd ;
  int tmp ;
  void *__cil_tmp13 ;

  {
#line 1057
  anysize = sizeof(any);
#line 1060
  if (! addr) {
#line 1061
    addr = (sockaddr_t *)(any);
  }
#line 1063
  if (! addrsize) {
#line 1064
    addrsize = & anysize;
  }
  {
#line 1066
  sockfd = net_create_server(group, service, port, 2, 0, sockopts, addr, addrsize);
  }
#line 1066
  if (sockfd == -1) {
#line 1067
    return (-1);
  }
  {
#line 1069
  tmp = net_multicast_join(sockfd, (sockaddr_t const   *)addr, *addrsize, ifname,
                           ifindex);
  }
#line 1069
  if (tmp == -1) {
    {
#line 1070
    close(sockfd);
    }
#line 1070
    return (-1);
  }
#line 1072
  return (sockfd);
}
}
#line 1158 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
int net_multicast_join(int sockfd , sockaddr_t const   *addr , size_t addrsize , char const   *ifname ,
                       unsigned int ifindex ) 
{ 
  sockaddr_any_t *any ;
  struct ip_mreq mreq[1] ;
  struct ifreq ifreq[1] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct ipv6_mreq mreq___0[1] ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp17 ;
  int __cil_tmp18 ;
  void *__cil_tmp19 ;
  int __cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  int __cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;

  {
#line 1160
  any = (sockaddr_any_t *)addr;
  {
#line 1164
  if ((int )any->any.sa_family == 2) {
#line 1164
    goto case_2;
  }
#line 1197
  if ((int )any->any.sa_family == 10) {
#line 1197
    goto case_10;
  }
#line 1217
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 1169
  memcpy((void */* __restrict  */)(& mreq[0].imr_multiaddr), (void const   */* __restrict  */)(& any->in.sin_addr),
         sizeof(mreq[0].imr_multiaddr));
  }
#line 1171
  if (! ifindex) {
#line 1171
    if (! ifname) {
      {
#line 1173
      mreq[0].imr_interface.s_addr = htonl((in_addr_t )0);
      }
    } else {
#line 1171
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1177
    if (ifname) {
      {
#line 1179
      strlcpy(ifreq[0].ifr_ifrn.ifrn_name, ifname, (size_t )16);
      }
    } else
#line 1181
    if (ifindex) {
      {
#line 1183
      tmp___0 = if_indextoname(ifindex, ifreq[0].ifr_ifrn.ifrn_name);
      }
#line 1183
      if (! tmp___0) {
        {
#line 1184
        tmp = set_errno(6);
        }
#line 1184
        return (tmp);
      }
    }
    {
#line 1187
    tmp___1 = ioctl(sockfd, 35093UL, ifreq);
    }
#line 1187
    if (tmp___1 == -1) {
#line 1188
      return (-1);
    }
    {
#line 1190
    memcpy((void */* __restrict  */)(& mreq[0].imr_interface), (void const   */* __restrict  */)(& ((sockaddr_in_t *)(& ifreq[0].ifr_ifru.ifru_addr))->sin_addr),
           sizeof(mreq[0].imr_multiaddr));
    }
  }
  {
#line 1193
  tmp___2 = setsockopt(sockfd, 0, 35, (void const   *)(mreq), (socklen_t )sizeof(mreq));
  }
#line 1193
  return (tmp___2);
  case_10: /* CIL Label */ 
  {
#line 1201
  memcpy((void */* __restrict  */)(& mreq___0[0].ipv6mr_multiaddr), (void const   */* __restrict  */)(& any->in6.sin6_addr),
         sizeof(mreq___0[0].ipv6mr_multiaddr));
  }
#line 1203
  if (ifname) {
    {
#line 1205
    mreq___0[0].ipv6mr_interface = if_nametoindex(ifname);
    }
#line 1205
    if (mreq___0[0].ipv6mr_interface == 0U) {
      {
#line 1206
      tmp___3 = set_errno(6);
      }
#line 1206
      return (tmp___3);
    }
  } else {
#line 1210
    mreq___0[0].ipv6mr_interface = ifindex;
  }
  {
#line 1213
  tmp___4 = setsockopt(sockfd, 41, 20, (void const   *)(mreq___0), (socklen_t )sizeof(mreq___0));
  }
#line 1213
  return (tmp___4);
  switch_default: /* CIL Label */ 
  {
#line 1218
  tmp___5 = set_errno(93);
  }
#line 1218
  return (tmp___5);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1238 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
int net_multicast_leave(int sockfd , sockaddr_t const   *addr , size_t addrsize ,
                        char const   *ifname , unsigned int ifindex ) 
{ 
  sockaddr_any_t *any ;
  struct ip_mreq mreq[1] ;
  struct ifreq ifreq[1] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct ipv6_mreq mreq___0[1] ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp17 ;
  int __cil_tmp18 ;
  void *__cil_tmp19 ;
  int __cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  int __cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;

  {
#line 1240
  any = (sockaddr_any_t *)addr;
  {
#line 1244
  if ((int )any->any.sa_family == 2) {
#line 1244
    goto case_2;
  }
#line 1277
  if ((int )any->any.sa_family == 10) {
#line 1277
    goto case_10;
  }
#line 1297
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 1249
  memcpy((void */* __restrict  */)(& mreq[0].imr_multiaddr), (void const   */* __restrict  */)(& any->in.sin_addr),
         sizeof(mreq[0].imr_multiaddr));
  }
#line 1251
  if (! ifindex) {
#line 1251
    if (! ifname) {
      {
#line 1253
      mreq[0].imr_interface.s_addr = htonl((in_addr_t )0);
      }
    } else {
#line 1251
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1257
    if (ifname) {
      {
#line 1259
      strlcpy(ifreq[0].ifr_ifrn.ifrn_name, ifname, (size_t )16);
      }
    } else
#line 1261
    if (ifindex) {
      {
#line 1263
      tmp___0 = if_indextoname(ifindex, ifreq[0].ifr_ifrn.ifrn_name);
      }
#line 1263
      if (! tmp___0) {
        {
#line 1264
        tmp = set_errno(6);
        }
#line 1264
        return (tmp);
      }
    }
    {
#line 1267
    tmp___1 = ioctl(sockfd, 35093UL, ifreq);
    }
#line 1267
    if (tmp___1 == -1) {
#line 1268
      return (-1);
    }
    {
#line 1270
    memcpy((void */* __restrict  */)(& mreq[0].imr_interface), (void const   */* __restrict  */)(& ((sockaddr_in_t *)(& ifreq[0].ifr_ifru.ifru_addr))->sin_addr),
           sizeof(mreq[0].imr_interface));
    }
  }
  {
#line 1273
  tmp___2 = setsockopt(sockfd, 0, 36, (void const   *)(mreq), (socklen_t )sizeof(mreq));
  }
#line 1273
  return (tmp___2);
  case_10: /* CIL Label */ 
  {
#line 1281
  memcpy((void */* __restrict  */)(& mreq___0[0].ipv6mr_multiaddr), (void const   */* __restrict  */)(& any->in6.sin6_addr),
         sizeof(mreq___0[0].ipv6mr_multiaddr));
  }
#line 1283
  if (ifname) {
    {
#line 1285
    mreq___0[0].ipv6mr_interface = if_nametoindex(ifname);
    }
#line 1285
    if (mreq___0[0].ipv6mr_interface == 0U) {
      {
#line 1286
      tmp___3 = set_errno(6);
      }
#line 1286
      return (tmp___3);
    }
  } else {
#line 1290
    mreq___0[0].ipv6mr_interface = ifindex;
  }
  {
#line 1293
  tmp___4 = setsockopt(sockfd, 41, 21, (void const   *)(mreq___0), (socklen_t )sizeof(mreq___0));
  }
#line 1293
  return (tmp___4);
  switch_default: /* CIL Label */ 
  {
#line 1298
  tmp___5 = set_errno(93);
  }
#line 1298
  return (tmp___5);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1319 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
int net_multicast_set_interface(int sockfd , char const   *ifname , unsigned int ifindex ) 
{ 
  sockaddr_any_t any ;
  size_t size ;
  int tmp ;
  struct ifreq ifreq[1] ;
  struct in_addr inaddr ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int index___0 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp17 ;
  int __cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;

  {
  {
#line 1322
  size = sizeof(any);
#line 1324
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((void *)(& any)),
                    (socklen_t */* __restrict  */)((void *)(& size)));
  }
#line 1324
  if (tmp == -1) {
#line 1325
    return (-1);
  }
  {
#line 1329
  if ((int )any.any.sa_family == 2) {
#line 1329
    goto case_2;
  }
#line 1360
  if ((int )any.any.sa_family == 10) {
#line 1360
    goto case_10;
  }
#line 1373
  goto switch_default;
  case_2: /* CIL Label */ 
#line 1334
  if (! ifindex) {
#line 1334
    if (! ifname) {
      {
#line 1336
      inaddr.s_addr = htonl((in_addr_t )0);
      }
    } else {
#line 1334
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1340
    if (ifname) {
      {
#line 1342
      strlcpy(ifreq[0].ifr_ifrn.ifrn_name, ifname, (size_t )16);
      }
    } else
#line 1344
    if (ifindex) {
      {
#line 1346
      tmp___1 = if_indextoname(ifindex, ifreq[0].ifr_ifrn.ifrn_name);
      }
#line 1346
      if (! tmp___1) {
        {
#line 1347
        tmp___0 = set_errno(6);
        }
#line 1347
        return (tmp___0);
      }
    }
    {
#line 1350
    tmp___2 = ioctl(sockfd, 35093UL, ifreq);
    }
#line 1350
    if (tmp___2 == -1) {
#line 1351
      return (-1);
    }
    {
#line 1353
    memcpy((void */* __restrict  */)(& inaddr), (void const   */* __restrict  */)(& ((sockaddr_in_t *)(& ifreq[0].ifr_ifru.ifru_addr))->sin_addr),
           sizeof(inaddr));
    }
  }
  {
#line 1356
  tmp___3 = setsockopt(sockfd, 0, 32, (void const   *)(& inaddr), (socklen_t )sizeof(inaddr));
  }
#line 1356
  return (tmp___3);
  case_10: /* CIL Label */ 
#line 1364
  if (ifname) {
    {
#line 1364
    index___0 = if_nametoindex(ifname);
    }
#line 1364
    if (index___0 == 0U) {
      {
#line 1365
      tmp___4 = set_errno(6);
      }
#line 1365
      return (tmp___4);
    }
  }
  {
#line 1367
  index___0 = ifindex;
#line 1369
  tmp___5 = setsockopt(sockfd, 41, 17, (void const   *)(& index___0), (socklen_t )sizeof(index___0));
  }
#line 1369
  return (tmp___5);
  switch_default: /* CIL Label */ 
  {
#line 1374
  tmp___6 = set_errno(93);
  }
#line 1374
  return (tmp___6);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1389 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
int net_multicast_get_interface(int sockfd ) 
{ 
  sockaddr_any_t any ;
  size_t size ;
  int tmp ;
  struct in_addr inaddr ;
  size_t size___0 ;
  unsigned int index___0 ;
  List *ifaces ;
  int tmp___0 ;
  net_interface_t *iface ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int index___1 ;
  size_t size___1 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1392
  size = sizeof(any);
#line 1394
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((void *)(& any)),
                    (socklen_t */* __restrict  */)((void *)(& size)));
  }
#line 1394
  if (tmp == -1) {
#line 1395
    return (-1);
  }
  {
#line 1399
  if ((int )any.any.sa_family == 2) {
#line 1399
    goto case_2;
  }
#line 1433
  if ((int )any.any.sa_family == 10) {
#line 1433
    goto case_10;
  }
#line 1445
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 1402
  size___0 = sizeof(inaddr);
#line 1403
  index___0 = 0U;
#line 1406
  tmp___0 = getsockopt(sockfd, 0, 32, (void */* __restrict  */)(& inaddr), (socklen_t */* __restrict  */)((void *)(& size___0)));
  }
#line 1406
  if (tmp___0 == -1) {
#line 1407
    return (-1);
  }
  {
#line 1409
  ifaces = net_interfaces_by_family(2);
  }
#line 1409
  if (! ifaces) {
#line 1410
    return (-1);
  }
  {
#line 1412
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1412
    tmp___3 = list_has_next(ifaces);
    }
#line 1412
    if (! tmp___3) {
#line 1412
      goto while_break;
    }
    {
#line 1414
    tmp___1 = list_next(ifaces);
#line 1414
    iface = (net_interface_t *)tmp___1;
    }
#line 1416
    if ((int )iface->flags & 1) {
#line 1418
      if ((int )(iface->addr)->any.sa_family == 2) {
        {
#line 1418
        tmp___2 = memcmp((void const   *)(& inaddr), (void const   *)(& (iface->addr)->in.sin_addr),
                         sizeof(inaddr));
        }
#line 1418
        if (! tmp___2) {
          {
#line 1420
          index___0 = iface->index;
#line 1421
          list_break(ifaces);
          }
#line 1422
          goto while_break;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1427
  list_release(ifaces);
  }
#line 1429
  return ((int )index___0);
  case_10: /* CIL Label */ 
  {
#line 1436
  size___1 = sizeof(index___1);
#line 1438
  tmp___4 = getsockopt(sockfd, 41, 17, (void */* __restrict  */)(& index___1), (socklen_t */* __restrict  */)((void *)(& size___1)));
  }
#line 1438
  if (tmp___4 == -1) {
#line 1439
    return (-1);
  }
#line 1441
  return ((int )index___1);
  switch_default: /* CIL Label */ 
  {
#line 1446
  tmp___5 = set_errno(93);
  }
#line 1446
  return (tmp___5);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1465 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
int net_multicast_set_loopback(int sockfd , unsigned int loopback ) 
{ 
  sockaddr_any_t any ;
  size_t size ;
  int tmp ;
  unsigned char flag ;
  int tmp___0 ;
  unsigned int flag___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1468
  size = sizeof(any);
#line 1470
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((void *)(& any)),
                    (socklen_t */* __restrict  */)((void *)(& size)));
  }
#line 1470
  if (tmp == -1) {
#line 1471
    return (-1);
  }
  {
#line 1475
  if ((int )any.any.sa_family == 2) {
#line 1475
    goto case_2;
  }
#line 1483
  if ((int )any.any.sa_family == 10) {
#line 1483
    goto case_10;
  }
#line 1491
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 1477
  flag = (unsigned char )loopback;
#line 1479
  tmp___0 = setsockopt(sockfd, 0, 34, (void const   *)(& flag), (socklen_t )sizeof(flag));
  }
#line 1479
  return (tmp___0);
  case_10: /* CIL Label */ 
  {
#line 1485
  flag___0 = loopback;
#line 1487
  tmp___1 = setsockopt(sockfd, 41, 19, (void const   *)(& flag___0), (socklen_t )sizeof(flag___0));
  }
#line 1487
  return (tmp___1);
  switch_default: /* CIL Label */ 
  {
#line 1492
  tmp___2 = set_errno(93);
  }
#line 1492
  return (tmp___2);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1509 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
int net_multicast_get_loopback(int sockfd ) 
{ 
  sockaddr_any_t any ;
  size_t size ;
  int tmp ;
  unsigned char flag ;
  size_t size___0 ;
  int tmp___0 ;
  unsigned int flag___0 ;
  size_t size___1 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1512
  size = sizeof(any);
#line 1514
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((void *)(& any)),
                    (socklen_t */* __restrict  */)((void *)(& size)));
  }
#line 1514
  if (tmp == -1) {
#line 1515
    return (-1);
  }
  {
#line 1519
  if ((int )any.any.sa_family == 2) {
#line 1519
    goto case_2;
  }
#line 1531
  if ((int )any.any.sa_family == 10) {
#line 1531
    goto case_10;
  }
#line 1543
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 1522
  size___0 = sizeof(flag);
#line 1524
  tmp___0 = getsockopt(sockfd, 0, 34, (void */* __restrict  */)(& flag), (socklen_t */* __restrict  */)((void *)(& size___0)));
  }
#line 1524
  if (tmp___0 == -1) {
#line 1525
    return (-1);
  }
#line 1527
  return ((int )flag);
  case_10: /* CIL Label */ 
  {
#line 1534
  size___1 = sizeof(flag___0);
#line 1536
  tmp___1 = getsockopt(sockfd, 41, 19, (void */* __restrict  */)(& flag___0), (socklen_t */* __restrict  */)((void *)(& size___1)));
  }
#line 1536
  if (tmp___1 == -1) {
#line 1537
    return (-1);
  }
#line 1539
  return ((int )flag___0);
  switch_default: /* CIL Label */ 
  {
#line 1544
  tmp___2 = set_errno(93);
  }
#line 1544
  return (tmp___2);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1561 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
int net_multicast_set_ttl(int sockfd , int ttl ) 
{ 
  sockaddr_any_t any ;
  size_t size ;
  int tmp ;
  unsigned char hops ;
  int tmp___0 ;
  int hops___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1564
  size = sizeof(any);
#line 1566
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((void *)(& any)),
                    (socklen_t */* __restrict  */)((void *)(& size)));
  }
#line 1566
  if (tmp == -1) {
#line 1567
    return (-1);
  }
  {
#line 1571
  if ((int )any.any.sa_family == 2) {
#line 1571
    goto case_2;
  }
#line 1579
  if ((int )any.any.sa_family == 10) {
#line 1579
    goto case_10;
  }
#line 1587
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 1573
  hops = (unsigned char )ttl;
#line 1575
  tmp___0 = setsockopt(sockfd, 0, 33, (void const   *)(& hops), (socklen_t )sizeof(hops));
  }
#line 1575
  return (tmp___0);
  case_10: /* CIL Label */ 
  {
#line 1581
  hops___0 = ttl;
#line 1583
  tmp___1 = setsockopt(sockfd, 41, 18, (void const   *)(& hops___0), (socklen_t )sizeof(hops___0));
  }
#line 1583
  return (tmp___1);
  switch_default: /* CIL Label */ 
  {
#line 1588
  tmp___2 = set_errno(93);
  }
#line 1588
  return (tmp___2);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1603 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
int net_multicast_get_ttl(int sockfd ) 
{ 
  sockaddr_any_t any ;
  size_t size ;
  int tmp ;
  unsigned char hops ;
  size_t size___0 ;
  int tmp___0 ;
  int hops___0 ;
  size_t size___1 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1606
  size = sizeof(any);
#line 1608
  tmp = getsockname(sockfd, (struct sockaddr */* __restrict  */)((void *)(& any)),
                    (socklen_t */* __restrict  */)((void *)(& size)));
  }
#line 1608
  if (tmp == -1) {
#line 1609
    return (-1);
  }
  {
#line 1613
  if ((int )any.any.sa_family == 2) {
#line 1613
    goto case_2;
  }
#line 1625
  if ((int )any.any.sa_family == 10) {
#line 1625
    goto case_10;
  }
#line 1637
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 1616
  size___0 = sizeof(hops);
#line 1618
  tmp___0 = getsockopt(sockfd, 0, 33, (void */* __restrict  */)(& hops), (socklen_t */* __restrict  */)((void *)(& size___0)));
  }
#line 1618
  if (tmp___0 == -1) {
#line 1619
    return (-1);
  }
#line 1621
  return ((int )hops);
  case_10: /* CIL Label */ 
  {
#line 1628
  size___1 = sizeof(hops___0);
#line 1630
  tmp___1 = getsockopt(sockfd, 41, 18, (void */* __restrict  */)(& hops___0), (socklen_t */* __restrict  */)((void *)(& size___1)));
  }
#line 1630
  if (tmp___1 == -1) {
#line 1631
    return (-1);
  }
#line 1633
  return (hops___0);
  switch_default: /* CIL Label */ 
  {
#line 1638
  tmp___2 = set_errno(93);
  }
#line 1638
  return (tmp___2);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1655 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
int net_tos_lowdelay(int sockfd ) 
{ 
  int tos ;
  int tmp ;

  {
  {
#line 1657
  tos = 16;
#line 1659
  tmp = setsockopt(sockfd, 0, 1, (void const   *)(& tos), (socklen_t )sizeof(tos));
  }
#line 1659
  return (tmp);
}
}
#line 1675 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
int net_tos_throughput(int sockfd ) 
{ 
  int tos ;
  int tmp ;

  {
  {
#line 1677
  tos = 8;
#line 1679
  tmp = setsockopt(sockfd, 0, 1, (void const   *)(& tos), (socklen_t )sizeof(tos));
  }
#line 1679
  return (tmp);
}
}
#line 1695 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
int net_tos_reliability(int sockfd ) 
{ 
  int tos ;
  int tmp ;

  {
  {
#line 1697
  tos = 4;
#line 1699
  tmp = setsockopt(sockfd, 0, 1, (void const   *)(& tos), (socklen_t )sizeof(tos));
  }
#line 1699
  return (tmp);
}
}
#line 1718 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
int net_tos_lowcost(int sockfd ) 
{ 
  int tos ;
  int tmp ;

  {
  {
#line 1720
  tos = 2;
#line 1722
  tmp = setsockopt(sockfd, 0, 1, (void const   *)(& tos), (socklen_t )sizeof(tos));
  }
#line 1722
  return (tmp);
}
}
#line 1736 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
int net_tos_normal(int sockfd ) 
{ 
  int tos ;
  int tmp ;

  {
  {
#line 1738
  tos = 0;
#line 1740
  tmp = setsockopt(sockfd, 0, 1, (void const   *)(& tos), (socklen_t )sizeof(tos));
  }
#line 1740
  return (tmp);
}
}
#line 1779 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
struct hostent *net_gethostbyname(char const   *name , struct hostent *hostbuf , void **buf ,
                                  size_t *size , int *herrno ) 
{ 
  void *tmp ;
  struct hostent *ret ;
  int err ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  struct hostent *tmp___5 ;

  {
#line 1781
  if (! name) {
    {
#line 1782
    tmp = set_errnull(22);
    }
#line 1782
    return ((struct hostent *)tmp);
  } else
#line 1781
  if (! hostbuf) {
    {
#line 1782
    tmp = set_errnull(22);
    }
#line 1782
    return ((struct hostent *)tmp);
  } else
#line 1781
  if (! buf) {
    {
#line 1782
    tmp = set_errnull(22);
    }
#line 1782
    return ((struct hostent *)tmp);
  } else
#line 1781
  if (! size) {
    {
#line 1782
    tmp = set_errnull(22);
    }
#line 1782
    return ((struct hostent *)tmp);
  } else
#line 1781
  if (! *buf ^ ! *size) {
    {
#line 1782
    tmp = set_errnull(22);
    }
#line 1782
    return ((struct hostent *)tmp);
  } else
#line 1781
  if (! herrno) {
    {
#line 1782
    tmp = set_errnull(22);
    }
#line 1782
    return ((struct hostent *)tmp);
  }
#line 1790
  if (*size == 0UL) {
    {
#line 1790
    tmp___1 = (size_t )1024;
#line 1790
    *size = tmp___1;
#line 1790
    tmp___0 = malloc(tmp___1);
#line 1790
    *buf = tmp___0;
    }
#line 1790
    if (! tmp___0) {
#line 1791
      return ((struct hostent *)((void *)0));
    }
  }
  {
#line 1793
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1793
    err = gethostbyname_r((char const   */* __restrict  */)name, (struct hostent */* __restrict  */)hostbuf,
                          (char */* __restrict  */)*buf, *size, (struct hostent **/* __restrict  */)(& ret),
                          (int */* __restrict  */)herrno);
    }
#line 1793
    if (err) {
      {
#line 1793
      tmp___4 = __errno_location();
      }
#line 1793
      if (! (*tmp___4 == 34)) {
#line 1793
        goto while_break;
      }
    } else {
#line 1793
      goto while_break;
    }
    {
#line 1794
    tmp___2 = *size << 1;
#line 1794
    *size = tmp___2;
#line 1794
    tmp___3 = mem_resize_fn((void **)((char **)buf), tmp___2 * sizeof(*(*((char **)buf))));
    }
#line 1794
    if (! tmp___3) {
#line 1795
      return ((struct hostent *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1797
  if (err) {
#line 1797
    tmp___5 = (struct hostent *)((void *)0);
  } else {
#line 1797
    tmp___5 = ret;
  }
#line 1797
  return (tmp___5);
}
}
#line 1895 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
struct servent *net_getservbyname(char const   *name , char const   *proto , struct servent *servbuf ,
                                  void **buf , size_t *size ) 
{ 
  void *tmp ;
  struct servent *ret ;
  int err ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  struct servent *tmp___5 ;

  {
#line 1897
  if (! name) {
    {
#line 1898
    tmp = set_errnull(22);
    }
#line 1898
    return ((struct servent *)tmp);
  } else
#line 1897
  if (! servbuf) {
    {
#line 1898
    tmp = set_errnull(22);
    }
#line 1898
    return ((struct servent *)tmp);
  } else
#line 1897
  if (! buf) {
    {
#line 1898
    tmp = set_errnull(22);
    }
#line 1898
    return ((struct servent *)tmp);
  } else
#line 1897
  if (! size) {
    {
#line 1898
    tmp = set_errnull(22);
    }
#line 1898
    return ((struct servent *)tmp);
  } else
#line 1897
  if (! *buf ^ ! *size) {
    {
#line 1898
    tmp = set_errnull(22);
    }
#line 1898
    return ((struct servent *)tmp);
  }
#line 1906
  if (*size == 0UL) {
    {
#line 1906
    tmp___1 = (size_t )128;
#line 1906
    *size = tmp___1;
#line 1906
    tmp___0 = malloc(tmp___1);
#line 1906
    *buf = tmp___0;
    }
#line 1906
    if (! tmp___0) {
#line 1907
      return ((struct servent *)((void *)0));
    }
  }
  {
#line 1909
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1909
    err = getservbyname_r((char const   */* __restrict  */)name, (char const   */* __restrict  */)proto,
                          (struct servent */* __restrict  */)servbuf, (char */* __restrict  */)*buf,
                          *size, (struct servent **/* __restrict  */)(& ret));
    }
#line 1909
    if (err) {
      {
#line 1909
      tmp___4 = __errno_location();
      }
#line 1909
      if (! (*tmp___4 == 34)) {
#line 1909
        goto while_break;
      }
    } else {
#line 1909
      goto while_break;
    }
    {
#line 1910
    tmp___2 = *size << 1;
#line 1910
    *size = tmp___2;
#line 1910
    tmp___3 = mem_resize_fn((void **)((char **)buf), tmp___2 * sizeof(*(*((char **)buf))));
    }
#line 1910
    if (! tmp___3) {
#line 1911
      return ((struct servent *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1913
  if (err) {
#line 1913
    tmp___5 = (struct servent *)((void *)0);
  } else {
#line 1913
    tmp___5 = ret;
  }
#line 1913
  return (tmp___5);
}
}
#line 1989 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
int net_options(int sockfd , sockopt_t *sockopts ) 
{ 
  sockopt_t *so ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1992
  err = 0;
#line 1994
  if (sockfd == -1) {
    {
#line 1995
    tmp = set_errno(9);
    }
#line 1995
    return (tmp);
  }
#line 1997
  if (! sockopts) {
    {
#line 1998
    tmp___0 = set_errno(22);
    }
#line 1998
    return (tmp___0);
  }
#line 2000
  so = sockopts;
  {
#line 2000
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2000
    if (! so->optval) {
#line 2000
      goto while_break;
    }
    {
#line 2001
    tmp___1 = setsockopt(sockfd, so->level, so->optname, so->optval, (socklen_t )so->optlen);
    }
#line 2001
    if (tmp___1 == -1) {
#line 2002
      err = -1;
    }
#line 2000
    so ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2004
  return (err);
}
}
#line 2007 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
static void iface_release(net_interface_t *iface ) 
{ 


  {
#line 2009
  if (iface) {
    {
#line 2011
    free((void *)iface->addr);
#line 2012
    free((void *)iface->brdaddr);
#line 2013
    free((void *)iface->dstaddr);
#line 2014
    free((void *)iface->hwaddr);
#line 2015
    free((void *)iface);
    }
  }
#line 2017
  return;
}
}
#line 2039 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
List *net_interfaces(void) 
{ 
  List *tmp ;

  {
  {
#line 2041
  tmp = net_interfaces_with_locker((Locker *)((void *)0));
  }
#line 2041
  return (tmp);
}
}
#line 2055 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
List *net_interfaces_with_locker(Locker *locker ) 
{ 
  int family ;
  int tmp ;
  List *tmp___0 ;

  {
  {
#line 2060
  tmp = inet6_required();
  }
#line 2060
  if (tmp) {
#line 2061
    family = 10;
  } else {
#line 2064
    family = 2;
  }
  {
#line 2066
  tmp___0 = net_interfaces_by_family_with_locker(family, locker);
  }
#line 2066
  return (tmp___0);
}
}
#line 2080 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
List *net_interfaces_by_family(int family ) 
{ 
  List *tmp ;

  {
  {
#line 2082
  tmp = net_interfaces_by_family_with_locker(family, (Locker *)((void *)0));
  }
#line 2082
  return (tmp);
}
}
#line 2096 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
List *net_interfaces_by_family_with_locker(int family , Locker *locker ) 
{ 
  List *ret ;
  int sockfd ;
  size_t size ;
  size_t lastsize ;
  char *buf ;
  char *ptr ;
  struct ifconf ifc[1] ;
  int index___0 ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct ifreq *ifr ;
  struct ifreq ifrcopy[1] ;
  net_interface_t *iface ;
  void *tmp___2 ;
  List *tmp___3 ;
  int tmp___4 ;
  sockaddr_any_t *tmp___5 ;
  void *tmp___6 ;
  sockaddr_any_t *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  sockaddr_any_t *tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  sockaddr_any_t *tmp___14 ;
  void *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  void *__cil_tmp33 ;
  int __cil_tmp34 ;
  void *__cil_tmp35 ;
  int __cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;

  {
  {
#line 2100
  lastsize = (size_t )0;
#line 2101
  buf = (char *)((void *)0);
#line 2103
  index___0 = 0;
#line 2105
  ret = list_create_with_locker(locker, (list_release_t *)(& iface_release));
  }
#line 2105
  if (! ret) {
#line 2106
    return ((List *)((void *)0));
  }
  {
#line 2108
  sockfd = socket(family, 2, 0);
  }
#line 2108
  if (sockfd == -1) {
    {
#line 2110
    list_release(ret);
    }
#line 2111
    return ((List *)((void *)0));
  }
#line 2116
  size = 100UL * sizeof(struct ifreq );
  {
#line 2116
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2118
    tmp = mem_resize_fn((void **)(& buf), size * sizeof(*buf));
    }
#line 2118
    if (! tmp) {
      {
#line 2120
      list_release(ret);
#line 2121
      free((void *)buf);
#line 2122
      close(sockfd);
      }
#line 2123
      return ((List *)((void *)0));
    }
    {
#line 2126
    ifc[0].ifc_len = (int )size;
#line 2127
    ifc[0].ifc_ifcu.ifcu_buf = buf;
#line 2129
    tmp___1 = ioctl(sockfd, 35090UL, ifc);
    }
#line 2129
    if (tmp___1 == -1) {
      {
#line 2131
      tmp___0 = __errno_location();
      }
#line 2131
      if (*tmp___0 != 22) {
        {
#line 2133
        list_release(ret);
#line 2134
        free((void *)buf);
#line 2135
        close(sockfd);
        }
#line 2136
        return ((List *)((void *)0));
      } else
#line 2131
      if (lastsize != 0UL) {
        {
#line 2133
        list_release(ret);
#line 2134
        free((void *)buf);
#line 2135
        close(sockfd);
        }
#line 2136
        return ((List *)((void *)0));
      }
    } else {
#line 2141
      if ((size_t )ifc[0].ifc_len == lastsize) {
#line 2142
        goto while_break;
      }
#line 2144
      lastsize = (size_t )ifc[0].ifc_len;
    }
#line 2116
    size += 10UL * sizeof(struct ifreq );
  }
  while_break: /* CIL Label */ ;
  }
#line 2150
  ptr = buf;
  {
#line 2150
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2150
    if (! ((unsigned long )ptr < (unsigned long )(buf + lastsize))) {
#line 2150
      goto while_break___0;
    }
    {
#line 2152
    ifr = (struct ifreq *)ptr;
#line 2156
    tmp___2 = calloc((size_t )1, sizeof(net_interface_t ));
#line 2156
    iface = (net_interface_t *)tmp___2;
    }
#line 2156
    if (! iface) {
      {
#line 2158
      list_release(ret);
#line 2159
      free((void *)buf);
#line 2160
      close(sockfd);
      }
#line 2161
      return ((List *)((void *)0));
    }
    {
#line 2164
    tmp___3 = list_append(ret, (void *)iface);
    }
#line 2164
    if (! tmp___3) {
      {
#line 2166
      list_release(ret);
#line 2167
      free((void *)buf);
#line 2168
      free((void *)iface);
#line 2169
      close(sockfd);
      }
#line 2170
      return ((List *)((void *)0));
    }
    {
#line 2179
    if ((int )ifr->ifr_ifru.ifru_addr.sa_family == 10) {
#line 2179
      goto case_10;
    }
#line 2184
    goto switch_default;
    case_10: /* CIL Label */ 
#line 2180
    size = sizeof(sockaddr_in6_t );
#line 2181
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2185
    size = sizeof(sockaddr_t );
#line 2186
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 2190
    ptr += sizeof(ifr->ifr_ifrn.ifrn_name) + size;
#line 2191
    ifrcopy[0] = *ifr;
#line 2195
    tmp___4 = ioctl(sockfd, 35091UL, ifrcopy);
    }
#line 2195
    if (tmp___4 == -1) {
      {
#line 2197
      list_release(ret);
#line 2198
      free((void *)buf);
#line 2199
      close(sockfd);
      }
#line 2200
      return ((List *)((void *)0));
    }
    {
#line 2203
    iface->flags = ifrcopy[0].ifr_ifru.ifru_flags;
#line 2204
    strlcpy(iface->name, (char const   *)(ifr->ifr_ifrn.ifrn_name), (size_t )16);
    }
#line 2208
    if ((int )iface->flags & 1) {
      {
#line 2210
      tmp___6 = calloc((size_t )1, size);
#line 2210
      tmp___5 = (sockaddr_any_t *)tmp___6;
#line 2210
      iface->addr = tmp___5;
      }
#line 2210
      if (! tmp___5) {
        {
#line 2212
        list_release(ret);
#line 2213
        free((void *)buf);
#line 2214
        close(sockfd);
        }
#line 2215
        return ((List *)((void *)0));
      }
      {
#line 2218
      memcpy((void */* __restrict  */)iface->addr, (void const   */* __restrict  */)(& ifr->ifr_ifru.ifru_addr),
             size);
#line 2223
      tmp___9 = ioctl(sockfd, 35111UL, ifrcopy);
      }
#line 2223
      if (tmp___9 == 0) {
        {
#line 2225
        tmp___8 = malloc(sizeof(sockaddr_t ));
#line 2225
        tmp___7 = (sockaddr_any_t *)tmp___8;
#line 2225
        iface->hwaddr = tmp___7;
        }
#line 2225
        if (! tmp___7) {
          {
#line 2227
          list_release(ret);
#line 2228
          free((void *)buf);
#line 2229
          close(sockfd);
          }
#line 2230
          return ((List *)((void *)0));
        }
        {
#line 2233
        memcpy((void */* __restrict  */)iface->hwaddr, (void const   */* __restrict  */)(& ifrcopy[0].ifr_ifru.ifru_hwaddr),
               sizeof(sockaddr_t ));
        }
      }
#line 2240
      if ((int )iface->flags & 2) {
        {
#line 2242
        tmp___10 = ioctl(sockfd, 35097UL, ifrcopy);
        }
#line 2242
        if (tmp___10 == -1) {
          {
#line 2244
          list_release(ret);
#line 2245
          free((void *)buf);
#line 2246
          close(sockfd);
          }
#line 2247
          return ((List *)((void *)0));
        }
        {
#line 2250
        tmp___12 = calloc((size_t )1, size);
#line 2250
        tmp___11 = (sockaddr_any_t *)tmp___12;
#line 2250
        iface->brdaddr = tmp___11;
        }
#line 2250
        if (! tmp___11) {
          {
#line 2252
          list_release(ret);
#line 2253
          free((void *)buf);
#line 2254
          close(sockfd);
          }
#line 2255
          return ((List *)((void *)0));
        }
        {
#line 2258
        memcpy((void */* __restrict  */)iface->brdaddr, (void const   */* __restrict  */)(& ifrcopy[0].ifr_ifru.ifru_broadaddr),
               size);
        }
      }
#line 2265
      if ((int )iface->flags & 16) {
        {
#line 2267
        tmp___13 = ioctl(sockfd, 35095UL, ifrcopy);
        }
#line 2267
        if (tmp___13 == -1) {
          {
#line 2269
          list_release(ret);
#line 2270
          free((void *)buf);
#line 2271
          close(sockfd);
          }
#line 2272
          return ((List *)((void *)0));
        }
        {
#line 2275
        tmp___15 = calloc((size_t )1, size);
#line 2275
        tmp___14 = (sockaddr_any_t *)tmp___15;
#line 2275
        iface->dstaddr = tmp___14;
        }
#line 2275
        if (! tmp___14) {
          {
#line 2277
          list_release(ret);
#line 2278
          free((void *)buf);
#line 2279
          close(sockfd);
          }
#line 2280
          return ((List *)((void *)0));
        }
        {
#line 2283
        memcpy((void */* __restrict  */)iface->dstaddr, (void const   */* __restrict  */)(& ifrcopy[0].ifr_ifru.ifru_dstaddr),
               size);
        }
      }
    }
    {
#line 2291
    tmp___16 = ioctl(sockfd, 35105UL, ifrcopy);
    }
#line 2291
    if (tmp___16 != -1) {
#line 2292
      iface->mtu = ifrcopy[0].ifr_ifru.ifru_mtu;
    } else {
#line 2295
      iface->mtu = -1;
    }
    {
#line 2300
    tmp___17 = ioctl(sockfd, 35123UL, ifrcopy);
    }
#line 2300
    if (tmp___17 != -1) {
#line 2301
      iface->index = (unsigned int )ifrcopy[0].ifr_ifru.ifru_ivalue;
    } else {
#line 2304
      index___0 ++;
#line 2304
      iface->index = (unsigned int )index___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2307
  free((void *)buf);
#line 2308
  close(sockfd);
  }
#line 2310
  return (ret);
}
}
#line 2331 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
static double rudp_minmax(double rto ) 
{ 


  {
#line 2333
  if (rto < (double )2) {
#line 2334
    return ((double )2);
  }
#line 2336
  if (rto > (double )60) {
#line 2337
    return ((double )60);
  }
#line 2339
  return (rto);
}
}
#line 2342 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
static int rudp_init(rudp_t *rudp ) 
{ 
  int tmp ;

  {
#line 2351
  if (! rudp) {
    {
#line 2352
    tmp = set_errno(22);
    }
#line 2352
    return (tmp);
  }
  {
#line 2354
  rudp->rtt = 0.0;
#line 2355
  rudp->srtt = 0.0;
#line 2356
  rudp->rttvar = 0.75;
#line 2357
  rudp->rto = rudp_minmax(rudp->srtt + 4.0 * rudp->rttvar);
#line 2358
  rudp->sequence = (uint32_t )0;
  }
#line 2360
  return (0);
}
}
#line 2363 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
rudp_t *rudp_create(void) 
{ 
  rudp_t *rudp ;
  struct timeval now[1] ;
  int tmp ;
  void *tmp___0 ;
  void *__cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 2368
  tmp = gettimeofday((struct timeval */* __restrict  */)(now), (__timezone_ptr_t )((void *)0));
  }
#line 2368
  if (tmp == -1) {
#line 2369
    return ((rudp_t *)((void *)0));
  }
  {
#line 2371
  tmp___0 = malloc(sizeof(rudp_t ));
#line 2371
  rudp = (rudp_t *)tmp___0;
  }
#line 2371
  if (! rudp) {
#line 2372
    return ((rudp_t *)((void *)0));
  }
  {
#line 2374
  rudp->base = (uint32_t )now[0].tv_sec;
#line 2375
  rudp_init(rudp);
  }
#line 2377
  return (rudp);
}
}
#line 2390 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
void rudp_release(rudp_t *rudp ) 
{ 


  {
  {
#line 2392
  free((void *)rudp);
  }
#line 2393
  return;
}
}
#line 2406 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
void *rudp_destroy(rudp_t **rudp ) 
{ 


  {
#line 2408
  if (rudp) {
#line 2408
    if (*rudp) {
      {
#line 2410
      rudp_release(*rudp);
#line 2411
      *rudp = (rudp_t *)((void *)0);
      }
    }
  }
#line 2414
  return ((void *)0);
}
}
#line 2428 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
static uint32_t rudp_timestamp(rudp_t *rudp ) 
{ 
  struct timeval now[1] ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 2432
  if (! rudp) {
    {
#line 2433
    tmp = set_errno(22);
    }
#line 2433
    return ((uint32_t )tmp);
  }
  {
#line 2435
  tmp___0 = gettimeofday((struct timeval */* __restrict  */)(now), (__timezone_ptr_t )((void *)0));
  }
#line 2435
  if (tmp___0 == -1) {
#line 2436
    return ((uint32_t )-1);
  }
#line 2438
  return ((uint32_t )((__suseconds_t )((uint32_t )((now[0].tv_sec - (__time_t )rudp->base) * 1000L)) + now[0].tv_usec / 1000L));
}
}
#line 2453 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
static uint32_t rudp_newpack(rudp_t *rudp ) 
{ 
  int tmp ;

  {
#line 2455
  if (! rudp) {
    {
#line 2456
    tmp = set_errno(22);
    }
#line 2456
    return ((uint32_t )tmp);
  }
#line 2458
  rudp->nrexmt = 0;
#line 2459
  (rudp->sequence) ++;
#line 2461
  return (rudp->sequence);
}
}
#line 2473 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
static double rudp_start(rudp_t *rudp ) 
{ 
  int tmp ;

  {
#line 2475
  if (! rudp) {
    {
#line 2476
    tmp = set_errno(22);
    }
#line 2476
    return ((double )tmp);
  }
#line 2478
  return (rudp->rto);
}
}
#line 2492 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
static int rudp_stop(rudp_t *rudp , uint32_t rtt ) 
{ 
  double delta ;
  int tmp ;
  double tmp___0 ;

  {
#line 2496
  if (! rudp) {
    {
#line 2497
    tmp = set_errno(22);
    }
#line 2497
    return (tmp);
  }
  {
#line 2499
  rudp->rtt = (double )rtt / 1000.0;
#line 2500
  delta = rudp->rtt - rudp->srtt;
#line 2501
  rudp->srtt += delta / (double )8;
#line 2502
  tmp___0 = fabs(delta);
#line 2502
  rudp->rttvar += (tmp___0 - rudp->rttvar) / (double )4;
#line 2503
  rudp->rto = rudp_minmax(rudp->srtt + 4.0 * rudp->rttvar);
  }
#line 2505
  return (0);
}
}
#line 2520 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
static int rudp_timeout(rudp_t *rudp ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2522
  if (! rudp) {
    {
#line 2523
    tmp = set_errno(22);
    }
#line 2523
    return (tmp);
  }
#line 2525
  rudp->rto *= (double )2;
#line 2527
  (rudp->nrexmt) ++;
#line 2527
  if (rudp->nrexmt > 3) {
    {
#line 2528
    tmp___0 = set_errno(110);
    }
#line 2528
    return (tmp___0);
  }
#line 2530
  return (0);
}
}
#line 2557 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
ssize_t net_rudp_transact(int sockfd , rudp_t *rudp , void const   *obuf , size_t osize ,
                          void *ibuf , size_t isize ) 
{ 
  ssize_t tmp ;

  {
  {
#line 2559
  tmp = net_rudp_transactwith(sockfd, rudp, obuf, osize, 0, ibuf, isize, 0, (sockaddr_any_t *)((void *)0),
                              (size_t )0);
  }
#line 2559
  return (tmp);
}
}
#line 2582 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
ssize_t net_rudp_transactwith(int sockfd , rudp_t *rudp , void const   *obuf , size_t osize ,
                              int oflags , void *ibuf , size_t isize , int iflags ,
                              sockaddr_any_t *addr , size_t addrsize ) 
{ 
  struct __anonstruct_ohdr_82 ohdr[1] ;
  struct __anonstruct_ohdr_82 ihdr[1] ;
  struct msghdr omsg[1] ;
  struct msghdr imsg[1] ;
  struct iovec ovec[2] ;
  struct iovec ivec[2] ;
  int sequence ;
  uint32_t timestamp ;
  double timeout___0 ;
  long timeout_sec ;
  long timeout_usec ;
  ssize_t bytes ;
  int tmp ;
  uint32_t tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  uint32_t tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp32 ;
  int __cil_tmp33 ;
  void *__cil_tmp34 ;
  int __cil_tmp35 ;
  void *__cil_tmp36 ;
  int __cil_tmp37 ;
  void *__cil_tmp38 ;
  int __cil_tmp39 ;
  void *__cil_tmp40 ;
  int __cil_tmp41 ;
  void *__cil_tmp42 ;
  int __cil_tmp43 ;

  {
#line 2594
  if (sockfd < 0) {
    {
#line 2595
    tmp = set_errno(22);
    }
#line 2595
    return ((ssize_t )tmp);
  } else
#line 2594
  if (! rudp) {
    {
#line 2595
    tmp = set_errno(22);
    }
#line 2595
    return ((ssize_t )tmp);
  } else
#line 2594
  if (! obuf) {
    {
#line 2595
    tmp = set_errno(22);
    }
#line 2595
    return ((ssize_t )tmp);
  } else
#line 2594
  if (! osize) {
    {
#line 2595
    tmp = set_errno(22);
    }
#line 2595
    return ((ssize_t )tmp);
  } else
#line 2594
  if (! ibuf) {
    {
#line 2595
    tmp = set_errno(22);
    }
#line 2595
    return ((ssize_t )tmp);
  } else
#line 2594
  if (! isize) {
    {
#line 2595
    tmp = set_errno(22);
    }
#line 2595
    return ((ssize_t )tmp);
  }
#line 2597
  if (addr) {
    {
#line 2599
    memset((void *)(omsg), 0, sizeof(omsg));
#line 2600
    omsg[0].msg_name = (void *)addr;
#line 2601
    omsg[0].msg_namelen = (socklen_t )addrsize;
#line 2602
    omsg[0].msg_iov = ovec;
#line 2603
    omsg[0].msg_iovlen = (size_t )2;
#line 2605
    memset((void *)(imsg), 0, sizeof(imsg));
#line 2606
    imsg[0].msg_iov = ivec;
#line 2607
    imsg[0].msg_iovlen = (size_t )2;
    }
  }
  {
#line 2610
  ovec[0].iov_base = (void *)(ohdr);
#line 2611
  ovec[0].iov_len = sizeof(ohdr);
#line 2612
  ovec[1].iov_base = (void *)obuf;
#line 2613
  ovec[1].iov_len = osize;
#line 2615
  ivec[0].iov_base = (void *)(ihdr);
#line 2616
  ivec[0].iov_len = sizeof(ihdr);
#line 2617
  ivec[1].iov_base = ibuf;
#line 2618
  ivec[1].iov_len = isize;
#line 2620
  tmp___0 = rudp_newpack(rudp);
#line 2620
  sequence = (int )tmp___0;
  }
#line 2620
  if (sequence == -1) {
#line 2621
    return ((ssize_t )-1);
  }
#line 2623
  ohdr[0].sequence = (uint32_t )sequence;
  sendagain: 
  {
#line 2627
  timestamp = rudp_timestamp(rudp);
  }
#line 2627
  if (timestamp == 4294967295U) {
#line 2628
    return ((ssize_t )-1);
  }
#line 2630
  ohdr[0].timestamp = timestamp;
#line 2632
  if (addr) {
    {
#line 2634
    tmp___1 = sendmsg(sockfd, (struct msghdr  const  *)(omsg), oflags);
    }
#line 2634
    if (tmp___1 == -1L) {
#line 2635
      return ((ssize_t )-1);
    }
  } else {
    {
#line 2639
    tmp___2 = writev(sockfd, (struct iovec  const  *)(ovec), 2);
    }
#line 2639
    if (tmp___2 == -1L) {
#line 2640
      return ((ssize_t )-1);
    }
  }
  {
#line 2643
  timeout___0 = rudp_start(rudp);
  }
#line 2643
  if (timeout___0 == (double )-1) {
#line 2644
    return ((ssize_t )-1);
  }
#line 2646
  timeout_sec = (long )timeout___0;
#line 2647
  timeout_usec = (long )((timeout___0 - (double )timeout_sec) * (double )1000000);
  recvagain: 
  {
#line 2651
  tmp___5 = read_timeout(sockfd, timeout_sec, timeout_usec);
  }
#line 2651
  if (tmp___5 == -1) {
    {
#line 2653
    tmp___3 = __errno_location();
    }
#line 2653
    if (*tmp___3 == 110) {
      {
#line 2653
      tmp___4 = rudp_timeout(rudp);
      }
#line 2653
      if (tmp___4 != -1) {
#line 2654
        goto sendagain;
      }
    }
    {
#line 2656
    rudp_init(rudp);
    }
#line 2658
    return ((ssize_t )-1);
  }
#line 2661
  if (addr) {
    {
#line 2663
    bytes = recvmsg(sockfd, imsg, iflags);
    }
#line 2663
    if (bytes == -1L) {
#line 2664
      return ((ssize_t )-1);
    }
  } else {
    {
#line 2668
    bytes = readv(sockfd, (struct iovec  const  *)(ivec), 2);
    }
#line 2668
    if (bytes == -1L) {
#line 2669
      return ((ssize_t )-1);
    }
  }
#line 2672
  if ((unsigned long )bytes < sizeof(ihdr)) {
#line 2673
    goto recvagain;
  } else
#line 2672
  if (ihdr[0].sequence != ohdr[0].sequence) {
#line 2673
    goto recvagain;
  }
  {
#line 2675
  tmp___6 = rudp_timestamp(rudp);
#line 2675
  tmp___7 = rudp_stop(rudp, tmp___6 - ihdr[0].timestamp);
  }
#line 2675
  if (tmp___7 == -1) {
#line 2676
    return ((ssize_t )-1);
  }
#line 2678
  return ((ssize_t )((unsigned long )bytes - sizeof(ihdr)));
}
}
#line 2706 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
ssize_t net_pack(int sockfd , long timeout___0 , int flags , char const   *format 
                 , ...) 
{ 
  va_list args ;
  int rc ;
  ssize_t tmp ;

  {
  {
#line 2711
  __builtin_va_start(args, format);
#line 2712
  tmp = net_vpack(sockfd, timeout___0, flags, format, args);
#line 2712
  rc = (int )tmp;
#line 2713
  __builtin_va_end(args);
  }
#line 2715
  return ((ssize_t )rc);
}
}
#line 2729 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
ssize_t net_vpack(int sockfd , long timeout___0 , int flags , char const   *format ,
                  va_list args ) 
{ 
  char buf[8192] ;
  int rc ;
  ssize_t tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  void *__cil_tmp11 ;

  {
  {
#line 2734
  tmp = vpack((void *)(buf), (size_t )8192, format, args);
#line 2734
  rc = (int )tmp;
  }
#line 2734
  if (rc == -1) {
#line 2735
    return ((ssize_t )-1);
  }
#line 2737
  if (timeout___0) {
    {
#line 2737
    tmp___0 = write_timeout(sockfd, timeout___0, 0L);
    }
#line 2737
    if (tmp___0 == -1) {
#line 2738
      return ((ssize_t )-1);
    }
  }
  {
#line 2740
  tmp___1 = send(sockfd, (void const   *)(buf), (size_t )rc, flags);
  }
#line 2740
  return (tmp___1);
}
}
#line 2760 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
ssize_t net_packto(int sockfd , long timeout___0 , int flags , sockaddr_t const   *to ,
                   size_t tosize , char const   *format  , ...) 
{ 
  va_list args ;
  int rc ;
  ssize_t tmp ;

  {
  {
#line 2765
  __builtin_va_start(args, format);
#line 2766
  tmp = net_vpackto(sockfd, timeout___0, flags, to, tosize, format, args);
#line 2766
  rc = (int )tmp;
#line 2767
  __builtin_va_end(args);
  }
#line 2769
  return ((ssize_t )rc);
}
}
#line 2783 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
ssize_t net_vpackto(int sockfd , long timeout___0 , int flags , sockaddr_t const   *to ,
                    size_t tosize , char const   *format , va_list args ) 
{ 
  char buf[8192] ;
  int rc ;
  ssize_t tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  void *__cil_tmp13 ;

  {
  {
#line 2788
  tmp = vpack((void *)(buf), (size_t )8192, format, args);
#line 2788
  rc = (int )tmp;
  }
#line 2788
  if (rc == -1) {
#line 2789
    return ((ssize_t )-1);
  }
#line 2791
  if (timeout___0) {
    {
#line 2791
    tmp___0 = write_timeout(sockfd, timeout___0, 0L);
    }
#line 2791
    if (tmp___0 == -1) {
#line 2792
      return ((ssize_t )-1);
    }
  }
  {
#line 2794
  tmp___1 = sendto(sockfd, (void const   *)(buf), (size_t )rc, flags, to, (socklen_t )tosize);
  }
#line 2794
  return (tmp___1);
}
}
#line 2818 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
ssize_t net_unpack(int sockfd , long timeout___0 , int flags , char const   *format 
                   , ...) 
{ 
  va_list args ;
  int rc ;
  ssize_t tmp ;

  {
  {
#line 2823
  __builtin_va_start(args, format);
#line 2824
  tmp = net_vunpack(sockfd, timeout___0, flags, format, args);
#line 2824
  rc = (int )tmp;
#line 2825
  __builtin_va_end(args);
  }
#line 2827
  return ((ssize_t )rc);
}
}
#line 2841 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
ssize_t net_vunpack(int sockfd , long timeout___0 , int flags , char const   *format ,
                    va_list args ) 
{ 
  char buf[8192] ;
  int rc ;
  int tmp ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;
  void *__cil_tmp11 ;

  {
  {
#line 2846
  tmp = read_timeout(sockfd, timeout___0, 0L);
  }
#line 2846
  if (tmp == -1) {
#line 2847
    return ((ssize_t )-1);
  }
  {
#line 2849
  tmp___0 = recv(sockfd, (void *)(buf), (size_t )8192, flags);
#line 2849
  rc = (int )tmp___0;
  }
#line 2849
  if (rc == -1) {
#line 2850
    return ((ssize_t )-1);
  }
  {
#line 2852
  tmp___1 = vunpack((void *)(buf), (size_t )rc, format, args);
  }
#line 2852
  return (tmp___1);
}
}
#line 2873 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
ssize_t net_unpackfrom(int sockfd , long timeout___0 , int flags , sockaddr_t *from ,
                       size_t *fromsize , char const   *format  , ...) 
{ 
  va_list args ;
  int rc ;
  ssize_t tmp ;

  {
  {
#line 2878
  __builtin_va_start(args, format);
#line 2879
  tmp = net_vunpackfrom(sockfd, timeout___0, flags, from, fromsize, format, args);
#line 2879
  rc = (int )tmp;
#line 2880
  __builtin_va_end(args);
  }
#line 2882
  return ((ssize_t )rc);
}
}
#line 2896 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
ssize_t net_vunpackfrom(int sockfd , long timeout___0 , int flags , sockaddr_t *from ,
                        size_t *fromsize , char const   *format , va_list args ) 
{ 
  char buf[8192] ;
  int rc ;
  int tmp ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;
  void *__cil_tmp13 ;

  {
  {
#line 2901
  tmp = read_timeout(sockfd, timeout___0, 0L);
  }
#line 2901
  if (tmp == -1) {
#line 2902
    return ((ssize_t )-1);
  }
  {
#line 2904
  tmp___0 = recvfrom(sockfd, (void */* __restrict  */)(buf), (size_t )8192, flags,
                     (struct sockaddr */* __restrict  */)from, (socklen_t */* __restrict  */)((void *)fromsize));
#line 2904
  rc = (int )tmp___0;
  }
#line 2904
  if (rc == -1) {
#line 2905
    return ((ssize_t )-1);
  }
  {
#line 2907
  tmp___1 = vunpack((void *)(buf), (size_t )rc, format, args);
  }
#line 2907
  return (tmp___1);
}
}
#line 3000 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
ssize_t pack(void *buf , size_t size , char const   *format  , ...) 
{ 
  va_list args ;
  int rc ;
  ssize_t tmp ;

  {
  {
#line 3005
  __builtin_va_start(args, format);
#line 3006
  tmp = vpack(buf, size, format, args);
#line 3006
  rc = (int )tmp;
#line 3007
  __builtin_va_end(args);
  }
#line 3009
  return ((ssize_t )rc);
}
}
#line 3037 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
ssize_t vpack(void *buf , size_t size , char const   *format , va_list args ) 
{ 
  size_t count ;
  unsigned char *pkt ;
  unsigned char *p ;
  char tmp[128] ;
  int tmp___0 ;
  char f ;
  char const   *tmp___1 ;
  void *data ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  char *data___0 ;
  size_t len ;
  int tmp___11 ;
  unsigned short const   **tmp___12 ;
  unsigned short const   **tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *data___1 ;
  unsigned char byte ;
  int shift ;
  int tmp___19 ;
  unsigned short const   **tmp___20 ;
  unsigned short const   **tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  unsigned char *tmp___28 ;
  size_t tmp___29 ;
  unsigned char *tmp___30 ;
  char *data___2 ;
  unsigned char byte___0 ;
  int shift___0 ;
  int tmp___32 ;
  unsigned short const   **tmp___33 ;
  unsigned short const   **tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  char *tmp___38 ;
  unsigned char nybble ;
  char *tmp___39 ;
  int tmp___40 ;
  unsigned char *tmp___41 ;
  size_t tmp___42 ;
  unsigned char *tmp___43 ;
  int tmp___45 ;
  unsigned short const   **tmp___46 ;
  unsigned short const   **tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  unsigned char *tmp___50 ;
  int tmp___52 ;
  size_t tmp___53 ;
  int tmp___55 ;
  unsigned short const   **tmp___56 ;
  unsigned short const   **tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  unsigned short data___3 ;
  int tmp___61 ;
  unsigned char *tmp___62 ;
  unsigned char *tmp___63 ;
  size_t tmp___64 ;
  int tmp___66 ;
  unsigned short const   **tmp___67 ;
  unsigned short const   **tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  unsigned long data___4 ;
  int tmp___72 ;
  unsigned char *tmp___73 ;
  unsigned char *tmp___74 ;
  unsigned char *tmp___75 ;
  unsigned char *tmp___76 ;
  size_t tmp___77 ;
  int tmp___79 ;
  unsigned short const   **tmp___80 ;
  unsigned short const   **tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  unsigned long long data___5 ;
  long long tmp___85 ;
  unsigned char *tmp___86 ;
  unsigned char *tmp___87 ;
  unsigned char *tmp___88 ;
  unsigned char *tmp___89 ;
  unsigned char *tmp___90 ;
  unsigned char *tmp___91 ;
  unsigned char *tmp___92 ;
  unsigned char *tmp___93 ;
  size_t tmp___94 ;
  int tmp___96 ;
  unsigned short const   **tmp___97 ;
  unsigned short const   **tmp___98 ;
  int tmp___99 ;
  double data___6 ;
  double tmp___101 ;
  int rc ;
  int tmp___102 ;
  size_t len___0 ;
  int tmp___103 ;
  size_t tmp___104 ;
  int tmp___105 ;
  unsigned char *tmp___106 ;
  size_t tmp___107 ;
  int tmp___109 ;
  unsigned short const   **tmp___110 ;
  unsigned short const   **tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  unsigned short data___7 ;
  int tmp___115 ;
  unsigned char *tmp___116 ;
  unsigned char *tmp___117 ;
  size_t tmp___118 ;
  int tmp___120 ;
  unsigned short const   **tmp___121 ;
  unsigned short const   **tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  unsigned int data___8 ;
  int tmp___126 ;
  unsigned char *tmp___127 ;
  unsigned char *tmp___128 ;
  unsigned char *tmp___129 ;
  unsigned char *tmp___130 ;
  size_t tmp___131 ;
  int tmp___133 ;
  unsigned short const   **tmp___134 ;
  unsigned short const   **tmp___135 ;
  int tmp___136 ;
  int tmp___137 ;
  int tmp___139 ;
  unsigned short const   **tmp___140 ;
  unsigned short const   **tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  int tmp___145 ;
  unsigned short const   **tmp___146 ;
  unsigned short const   **tmp___147 ;
  int tmp___148 ;
  int tmp___149 ;
  int tmp___150 ;
  int tmp___151 ;
  void *__cil_tmp180 ;
  char *__cil_tmp181 ;

  {
#line 3040
  pkt = (unsigned char *)buf;
#line 3041
  p = pkt;
#line 3044
  if (! pkt) {
    {
#line 3045
    tmp___0 = set_errno(22);
    }
#line 3045
    return ((ssize_t )tmp___0);
  } else
#line 3044
  if (! format) {
    {
#line 3045
    tmp___0 = set_errno(22);
    }
#line 3045
    return ((ssize_t )tmp___0);
  }
  {
#line 3047
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3047
    if (! *format) {
#line 3047
      goto while_break;
    }
#line 3049
    tmp___1 = format;
#line 3049
    format ++;
#line 3049
    f = (char )*tmp___1;
#line 3050
    if ((int )f == 112) {
#line 3050
      if (sizeof(void *) == 8UL) {
#line 3051
        f = (char )'P';
      }
    }
    {
#line 3055
    if ((int )f == 97) {
#line 3055
      goto case_97;
    }
#line 3067
    if ((int )f == 122) {
#line 3067
      goto case_122;
    }
#line 3087
    if ((int )f == 98) {
#line 3087
      goto case_98;
    }
#line 3122
    if ((int )f == 104) {
#line 3122
      goto case_104;
    }
#line 3163
    if ((int )f == 99) {
#line 3163
      goto case_99___0;
    }
#line 3172
    if ((int )f == 115) {
#line 3172
      goto case_115;
    }
#line 3187
    if ((int )f == 112) {
#line 3187
      goto case_112;
    }
#line 3187
    if ((int )f == 105) {
#line 3187
      goto case_112;
    }
#line 3205
    if ((int )f == 80) {
#line 3205
      goto case_80;
    }
#line 3205
    if ((int )f == 108) {
#line 3205
      goto case_80;
    }
#line 3233
    if ((int )f == 100) {
#line 3233
      goto case_100___0;
    }
#line 3233
    if ((int )f == 102) {
#line 3233
      goto case_100___0;
    }
#line 3253
    if ((int )f == 118) {
#line 3253
      goto case_118;
    }
#line 3267
    if ((int )f == 119) {
#line 3267
      goto case_119;
    }
#line 3283
    if ((int )f == 120) {
#line 3283
      goto case_120;
    }
#line 3292
    if ((int )f == 88) {
#line 3292
      goto case_88;
    }
#line 3301
    if ((int )f == 64) {
#line 3301
      goto case_64;
    }
#line 3313
    goto switch_default___1;
    case_97: /* CIL Label */ 
#line 3058
    count = (size_t )1;
#line 3058
    if ((int const   )*format == 42) {
      {
#line 3058
      format ++;
#line 3058
      tmp___3 = __builtin_va_arg(args, int );
#line 3058
      count = (size_t )tmp___3;
      }
    } else {
      {
#line 3058
      tmp___5 = __ctype_b_loc();
      }
#line 3058
      if ((int const   )*(*tmp___5 + (int )((unsigned int )*format)) & 2048) {
#line 3058
        count = (size_t )0;
        {
#line 3058
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 3058
          tmp___4 = __ctype_b_loc();
          }
#line 3058
          if (! ((int const   )*(*tmp___4 + (int )((unsigned int )*format)) & 2048)) {
#line 3058
            goto while_break___0;
          }
#line 3058
          count *= 10UL;
#line 3058
          count += (size_t )((int const   )*format - 48);
#line 3058
          format ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 3058
    if ((ssize_t )count < 1L) {
      {
#line 3058
      tmp___6 = set_errno(22);
      }
#line 3058
      return ((ssize_t )tmp___6);
    }
#line 3059
    if ((unsigned long )(p + count) > (unsigned long )(pkt + size)) {
      {
#line 3059
      tmp___7 = set_errno(28);
      }
#line 3059
      return ((ssize_t )tmp___7);
    }
    {
#line 3060
    tmp___9 = __builtin_va_arg(args, void *);
#line 3060
    data = tmp___9;
    }
#line 3060
    if (! data) {
      {
#line 3061
      tmp___8 = set_errno(22);
      }
#line 3061
      return ((ssize_t )tmp___8);
    }
    {
#line 3062
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)data, count);
#line 3063
    p += count;
    }
#line 3064
    goto switch_break;
    case_122: /* CIL Label */ 
#line 3071
    count = (size_t )1;
#line 3071
    if ((int const   )*format == 42) {
      {
#line 3071
      format ++;
#line 3071
      tmp___11 = __builtin_va_arg(args, int );
#line 3071
      count = (size_t )tmp___11;
      }
    } else {
      {
#line 3071
      tmp___13 = __ctype_b_loc();
      }
#line 3071
      if ((int const   )*(*tmp___13 + (int )((unsigned int )*format)) & 2048) {
#line 3071
        count = (size_t )0;
        {
#line 3071
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 3071
          tmp___12 = __ctype_b_loc();
          }
#line 3071
          if (! ((int const   )*(*tmp___12 + (int )((unsigned int )*format)) & 2048)) {
#line 3071
            goto while_break___1;
          }
#line 3071
          count *= 10UL;
#line 3071
          count += (size_t )((int const   )*format - 48);
#line 3071
          format ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 3071
    if ((ssize_t )count < 1L) {
      {
#line 3071
      tmp___14 = set_errno(22);
      }
#line 3071
      return ((ssize_t )tmp___14);
    }
#line 3072
    if ((unsigned long )(p + count) > (unsigned long )(pkt + size)) {
      {
#line 3072
      tmp___15 = set_errno(28);
      }
#line 3072
      return ((ssize_t )tmp___15);
    }
    {
#line 3073
    tmp___17 = __builtin_va_arg(args, char *);
#line 3073
    data___0 = tmp___17;
    }
#line 3073
    if (! data___0) {
      {
#line 3074
      tmp___16 = set_errno(22);
      }
#line 3074
      return ((ssize_t )tmp___16);
    }
    {
#line 3075
    len = strlen((char const   *)data___0);
    }
#line 3076
    if (len > count) {
#line 3077
      len = count;
    }
    {
#line 3078
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)data___0,
           len);
#line 3079
    p += len;
#line 3080
    count -= len;
    }
#line 3081
    if (count) {
      {
#line 3082
      memset((void *)p, 0, count);
      }
    }
#line 3083
    p += count;
#line 3084
    goto switch_break;
    case_98: /* CIL Label */ 
#line 3092
    count = (size_t )1;
#line 3092
    if ((int const   )*format == 42) {
      {
#line 3092
      format ++;
#line 3092
      tmp___19 = __builtin_va_arg(args, int );
#line 3092
      count = (size_t )tmp___19;
      }
    } else {
      {
#line 3092
      tmp___21 = __ctype_b_loc();
      }
#line 3092
      if ((int const   )*(*tmp___21 + (int )((unsigned int )*format)) & 2048) {
#line 3092
        count = (size_t )0;
        {
#line 3092
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 3092
          tmp___20 = __ctype_b_loc();
          }
#line 3092
          if (! ((int const   )*(*tmp___20 + (int )((unsigned int )*format)) & 2048)) {
#line 3092
            goto while_break___2;
          }
#line 3092
          count *= 10UL;
#line 3092
          count += (size_t )((int const   )*format - 48);
#line 3092
          format ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
#line 3092
    if ((ssize_t )count < 1L) {
      {
#line 3092
      tmp___22 = set_errno(22);
      }
#line 3092
      return ((ssize_t )tmp___22);
    }
#line 3093
    if ((unsigned long )(p + ((count + 7UL) >> 3)) > (unsigned long )(pkt + size)) {
      {
#line 3093
      tmp___23 = set_errno(28);
      }
#line 3093
      return ((ssize_t )tmp___23);
    }
    {
#line 3094
    tmp___25 = __builtin_va_arg(args, char *);
#line 3094
    data___1 = tmp___25;
    }
#line 3094
    if (! data___1) {
      {
#line 3095
      tmp___24 = set_errno(22);
      }
#line 3095
      return ((ssize_t )tmp___24);
    }
#line 3096
    byte = (unsigned char)0;
#line 3097
    shift = 7;
    {
#line 3098
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 3098
      tmp___29 = count;
#line 3098
      count --;
#line 3098
      if (! tmp___29) {
#line 3098
        goto while_break___3;
      }
#line 3100
      tmp___26 = data___1;
#line 3100
      data___1 ++;
      {
#line 3102
      if ((int )*tmp___26 == 48) {
#line 3102
        goto case_48;
      }
#line 3104
      if ((int )*tmp___26 == 49) {
#line 3104
        goto case_49;
      }
#line 3107
      goto switch_default;
      case_48: /* CIL Label */ 
#line 3103
      goto switch_break___0;
      case_49: /* CIL Label */ 
#line 3105
      byte = (unsigned char )((int )byte | (1 << shift));
#line 3106
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 3108
      tmp___27 = set_errno(22);
      }
#line 3108
      return ((ssize_t )tmp___27);
      switch_break___0: /* CIL Label */ ;
      }
#line 3110
      shift --;
#line 3110
      if (shift == -1) {
#line 3112
        tmp___28 = p;
#line 3112
        p ++;
#line 3112
        *tmp___28 = byte;
#line 3113
        byte = (unsigned char)0;
#line 3114
        shift = 7;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 3117
    if (shift != 7) {
#line 3118
      tmp___30 = p;
#line 3118
      p ++;
#line 3118
      *tmp___30 = byte;
    }
#line 3119
    goto switch_break;
    case_104: /* CIL Label */ 
#line 3127
    count = (size_t )1;
#line 3127
    if ((int const   )*format == 42) {
      {
#line 3127
      format ++;
#line 3127
      tmp___32 = __builtin_va_arg(args, int );
#line 3127
      count = (size_t )tmp___32;
      }
    } else {
      {
#line 3127
      tmp___34 = __ctype_b_loc();
      }
#line 3127
      if ((int const   )*(*tmp___34 + (int )((unsigned int )*format)) & 2048) {
#line 3127
        count = (size_t )0;
        {
#line 3127
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 3127
          tmp___33 = __ctype_b_loc();
          }
#line 3127
          if (! ((int const   )*(*tmp___33 + (int )((unsigned int )*format)) & 2048)) {
#line 3127
            goto while_break___4;
          }
#line 3127
          count *= 10UL;
#line 3127
          count += (size_t )((int const   )*format - 48);
#line 3127
          format ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
#line 3127
    if ((ssize_t )count < 1L) {
      {
#line 3127
      tmp___35 = set_errno(22);
      }
#line 3127
      return ((ssize_t )tmp___35);
    }
#line 3128
    if ((unsigned long )(p + ((count + 1UL) >> 1)) > (unsigned long )(pkt + size)) {
      {
#line 3128
      tmp___36 = set_errno(28);
      }
#line 3128
      return ((ssize_t )tmp___36);
    }
    {
#line 3129
    tmp___38 = __builtin_va_arg(args, char *);
#line 3129
    data___2 = tmp___38;
    }
#line 3129
    if (! data___2) {
      {
#line 3130
      tmp___37 = set_errno(22);
      }
#line 3130
      return ((ssize_t )tmp___37);
    }
#line 3131
    byte___0 = (unsigned char)0;
#line 3132
    shift___0 = 4;
    {
#line 3133
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 3133
      tmp___42 = count;
#line 3133
      count --;
#line 3133
      if (! tmp___42) {
#line 3133
        goto while_break___5;
      }
#line 3135
      tmp___39 = data___2;
#line 3135
      data___2 ++;
#line 3135
      nybble = (unsigned char )*tmp___39;
      {
#line 3139
      if ((int )nybble == 57) {
#line 3139
        goto case_57;
      }
#line 3139
      if ((int )nybble == 56) {
#line 3139
        goto case_57;
      }
#line 3139
      if ((int )nybble == 55) {
#line 3139
        goto case_57;
      }
#line 3139
      if ((int )nybble == 54) {
#line 3139
        goto case_57;
      }
#line 3139
      if ((int )nybble == 53) {
#line 3139
        goto case_57;
      }
#line 3139
      if ((int )nybble == 52) {
#line 3139
        goto case_57;
      }
#line 3139
      if ((int )nybble == 51) {
#line 3139
        goto case_57;
      }
#line 3139
      if ((int )nybble == 50) {
#line 3139
        goto case_57;
      }
#line 3139
      if ((int )nybble == 49) {
#line 3139
        goto case_57;
      }
#line 3139
      if ((int )nybble == 48) {
#line 3139
        goto case_57;
      }
#line 3142
      if ((int )nybble == 102) {
#line 3142
        goto case_102;
      }
#line 3142
      if ((int )nybble == 101) {
#line 3142
        goto case_102;
      }
#line 3142
      if ((int )nybble == 100) {
#line 3142
        goto case_102;
      }
#line 3142
      if ((int )nybble == 99) {
#line 3142
        goto case_102;
      }
#line 3142
      if ((int )nybble == 98) {
#line 3142
        goto case_102;
      }
#line 3142
      if ((int )nybble == 97) {
#line 3142
        goto case_102;
      }
#line 3145
      if ((int )nybble == 70) {
#line 3145
        goto case_70;
      }
#line 3145
      if ((int )nybble == 69) {
#line 3145
        goto case_70;
      }
#line 3145
      if ((int )nybble == 68) {
#line 3145
        goto case_70;
      }
#line 3145
      if ((int )nybble == 67) {
#line 3145
        goto case_70;
      }
#line 3145
      if ((int )nybble == 66) {
#line 3145
        goto case_70;
      }
#line 3145
      if ((int )nybble == 65) {
#line 3145
        goto case_70;
      }
#line 3148
      goto switch_default___0;
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49___0: /* CIL Label */ 
      case_48___0: /* CIL Label */ 
#line 3140
      byte___0 = (unsigned char )((int )byte___0 | (((int )nybble - 48) << shift___0));
#line 3141
      goto switch_break___1;
      case_102: /* CIL Label */ 
      case_101: /* CIL Label */ 
      case_100: /* CIL Label */ 
      case_99: /* CIL Label */ 
      case_98___0: /* CIL Label */ 
      case_97___0: /* CIL Label */ 
#line 3143
      byte___0 = (unsigned char )((int )byte___0 | ((((int )nybble - 97) + 10) << shift___0));
#line 3144
      goto switch_break___1;
      case_70: /* CIL Label */ 
      case_69: /* CIL Label */ 
      case_68: /* CIL Label */ 
      case_67: /* CIL Label */ 
      case_66: /* CIL Label */ 
      case_65: /* CIL Label */ 
#line 3146
      byte___0 = (unsigned char )((int )byte___0 | ((((int )nybble - 65) + 10) << shift___0));
#line 3147
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
      {
#line 3149
      tmp___40 = set_errno(22);
      }
#line 3149
      return ((ssize_t )tmp___40);
      switch_break___1: /* CIL Label */ ;
      }
#line 3151
      shift___0 -= 4;
#line 3151
      if (shift___0 == -4) {
#line 3153
        tmp___41 = p;
#line 3153
        p ++;
#line 3153
        *tmp___41 = byte___0;
#line 3154
        byte___0 = (unsigned char)0;
#line 3155
        shift___0 = 4;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 3158
    if (shift___0 != 4) {
#line 3159
      tmp___43 = p;
#line 3159
      p ++;
#line 3159
      *tmp___43 = byte___0;
    }
#line 3160
    goto switch_break;
    case_99___0: /* CIL Label */ 
#line 3165
    count = (size_t )1;
#line 3165
    if ((int const   )*format == 42) {
      {
#line 3165
      format ++;
#line 3165
      tmp___45 = __builtin_va_arg(args, int );
#line 3165
      count = (size_t )tmp___45;
      }
    } else {
      {
#line 3165
      tmp___47 = __ctype_b_loc();
      }
#line 3165
      if ((int const   )*(*tmp___47 + (int )((unsigned int )*format)) & 2048) {
#line 3165
        count = (size_t )0;
        {
#line 3165
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 3165
          tmp___46 = __ctype_b_loc();
          }
#line 3165
          if (! ((int const   )*(*tmp___46 + (int )((unsigned int )*format)) & 2048)) {
#line 3165
            goto while_break___6;
          }
#line 3165
          count *= 10UL;
#line 3165
          count += (size_t )((int const   )*format - 48);
#line 3165
          format ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
    }
#line 3165
    if ((ssize_t )count < 1L) {
      {
#line 3165
      tmp___48 = set_errno(22);
      }
#line 3165
      return ((ssize_t )tmp___48);
    }
#line 3166
    if ((unsigned long )(p + count) > (unsigned long )(pkt + size)) {
      {
#line 3166
      tmp___49 = set_errno(28);
      }
#line 3166
      return ((ssize_t )tmp___49);
    }
    {
#line 3167
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 3167
      tmp___53 = count;
#line 3167
      count --;
#line 3167
      if (! tmp___53) {
#line 3167
        goto while_break___7;
      }
      {
#line 3168
      tmp___50 = p;
#line 3168
      p ++;
#line 3168
      tmp___52 = __builtin_va_arg(args, int );
#line 3168
      *tmp___50 = (unsigned char )tmp___52;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 3169
    goto switch_break;
    case_115: /* CIL Label */ 
#line 3174
    count = (size_t )1;
#line 3174
    if ((int const   )*format == 42) {
      {
#line 3174
      format ++;
#line 3174
      tmp___55 = __builtin_va_arg(args, int );
#line 3174
      count = (size_t )tmp___55;
      }
    } else {
      {
#line 3174
      tmp___57 = __ctype_b_loc();
      }
#line 3174
      if ((int const   )*(*tmp___57 + (int )((unsigned int )*format)) & 2048) {
#line 3174
        count = (size_t )0;
        {
#line 3174
        while (1) {
          while_continue___8: /* CIL Label */ ;
          {
#line 3174
          tmp___56 = __ctype_b_loc();
          }
#line 3174
          if (! ((int const   )*(*tmp___56 + (int )((unsigned int )*format)) & 2048)) {
#line 3174
            goto while_break___8;
          }
#line 3174
          count *= 10UL;
#line 3174
          count += (size_t )((int const   )*format - 48);
#line 3174
          format ++;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
    }
#line 3174
    if ((ssize_t )count < 1L) {
      {
#line 3174
      tmp___58 = set_errno(22);
      }
#line 3174
      return ((ssize_t )tmp___58);
    }
#line 3175
    if ((unsigned long )(p + (count << 1)) > (unsigned long )(pkt + size)) {
      {
#line 3175
      tmp___59 = set_errno(28);
      }
#line 3175
      return ((ssize_t )tmp___59);
    }
    {
#line 3176
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 3176
      tmp___64 = count;
#line 3176
      count --;
#line 3176
      if (! tmp___64) {
#line 3176
        goto while_break___9;
      }
      {
#line 3178
      tmp___61 = __builtin_va_arg(args, int );
#line 3178
      data___3 = (unsigned short )tmp___61;
#line 3179
      tmp___62 = p;
#line 3179
      p ++;
#line 3179
      *tmp___62 = (unsigned char )(((int )data___3 >> 8) & 255);
#line 3180
      tmp___63 = p;
#line 3180
      p ++;
#line 3180
      *tmp___63 = (unsigned char )((int )data___3 & 255);
      }
    }
    while_break___9: /* CIL Label */ ;
    }
#line 3183
    goto switch_break;
    case_112: /* CIL Label */ 
    case_105: /* CIL Label */ 
#line 3189
    count = (size_t )1;
#line 3189
    if ((int const   )*format == 42) {
      {
#line 3189
      format ++;
#line 3189
      tmp___66 = __builtin_va_arg(args, int );
#line 3189
      count = (size_t )tmp___66;
      }
    } else {
      {
#line 3189
      tmp___68 = __ctype_b_loc();
      }
#line 3189
      if ((int const   )*(*tmp___68 + (int )((unsigned int )*format)) & 2048) {
#line 3189
        count = (size_t )0;
        {
#line 3189
        while (1) {
          while_continue___10: /* CIL Label */ ;
          {
#line 3189
          tmp___67 = __ctype_b_loc();
          }
#line 3189
          if (! ((int const   )*(*tmp___67 + (int )((unsigned int )*format)) & 2048)) {
#line 3189
            goto while_break___10;
          }
#line 3189
          count *= 10UL;
#line 3189
          count += (size_t )((int const   )*format - 48);
#line 3189
          format ++;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
    }
#line 3189
    if ((ssize_t )count < 1L) {
      {
#line 3189
      tmp___69 = set_errno(22);
      }
#line 3189
      return ((ssize_t )tmp___69);
    }
#line 3190
    if ((unsigned long )(p + (count << 2)) > (unsigned long )(pkt + size)) {
      {
#line 3190
      tmp___70 = set_errno(28);
      }
#line 3190
      return ((ssize_t )tmp___70);
    }
    {
#line 3191
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 3191
      tmp___77 = count;
#line 3191
      count --;
#line 3191
      if (! tmp___77) {
#line 3191
        goto while_break___11;
      }
      {
#line 3193
      tmp___72 = __builtin_va_arg(args, int );
#line 3193
      data___4 = (unsigned long )tmp___72;
#line 3194
      tmp___73 = p;
#line 3194
      p ++;
#line 3194
      *tmp___73 = (unsigned char )((data___4 >> 24) & 255UL);
#line 3195
      tmp___74 = p;
#line 3195
      p ++;
#line 3195
      *tmp___74 = (unsigned char )((data___4 >> 16) & 255UL);
#line 3196
      tmp___75 = p;
#line 3196
      p ++;
#line 3196
      *tmp___75 = (unsigned char )((data___4 >> 8) & 255UL);
#line 3197
      tmp___76 = p;
#line 3197
      p ++;
#line 3197
      *tmp___76 = (unsigned char )(data___4 & 255UL);
      }
    }
    while_break___11: /* CIL Label */ ;
    }
#line 3200
    goto switch_break;
    case_80: /* CIL Label */ 
    case_108: /* CIL Label */ 
#line 3207
    count = (size_t )1;
#line 3207
    if ((int const   )*format == 42) {
      {
#line 3207
      format ++;
#line 3207
      tmp___79 = __builtin_va_arg(args, int );
#line 3207
      count = (size_t )tmp___79;
      }
    } else {
      {
#line 3207
      tmp___81 = __ctype_b_loc();
      }
#line 3207
      if ((int const   )*(*tmp___81 + (int )((unsigned int )*format)) & 2048) {
#line 3207
        count = (size_t )0;
        {
#line 3207
        while (1) {
          while_continue___12: /* CIL Label */ ;
          {
#line 3207
          tmp___80 = __ctype_b_loc();
          }
#line 3207
          if (! ((int const   )*(*tmp___80 + (int )((unsigned int )*format)) & 2048)) {
#line 3207
            goto while_break___12;
          }
#line 3207
          count *= 10UL;
#line 3207
          count += (size_t )((int const   )*format - 48);
#line 3207
          format ++;
        }
        while_break___12: /* CIL Label */ ;
        }
      }
    }
#line 3207
    if ((ssize_t )count < 1L) {
      {
#line 3207
      tmp___82 = set_errno(22);
      }
#line 3207
      return ((ssize_t )tmp___82);
    }
#line 3208
    if ((unsigned long )(p + (count << 3)) > (unsigned long )(pkt + size)) {
      {
#line 3208
      tmp___83 = set_errno(28);
      }
#line 3208
      return ((ssize_t )tmp___83);
    }
    {
#line 3209
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 3209
      tmp___94 = count;
#line 3209
      count --;
#line 3209
      if (! tmp___94) {
#line 3209
        goto while_break___13;
      }
      {
#line 3211
      tmp___85 = __builtin_va_arg(args, long long );
#line 3211
      data___5 = (unsigned long long )tmp___85;
#line 3212
      tmp___86 = p;
#line 3212
      p ++;
#line 3212
      *tmp___86 = (unsigned char )((data___5 >> 56) & 255ULL);
#line 3213
      tmp___87 = p;
#line 3213
      p ++;
#line 3213
      *tmp___87 = (unsigned char )((data___5 >> 48) & 255ULL);
#line 3214
      tmp___88 = p;
#line 3214
      p ++;
#line 3214
      *tmp___88 = (unsigned char )((data___5 >> 40) & 255ULL);
#line 3215
      tmp___89 = p;
#line 3215
      p ++;
#line 3215
      *tmp___89 = (unsigned char )((data___5 >> 32) & 255ULL);
#line 3216
      tmp___90 = p;
#line 3216
      p ++;
#line 3216
      *tmp___90 = (unsigned char )((data___5 >> 24) & 255ULL);
#line 3217
      tmp___91 = p;
#line 3217
      p ++;
#line 3217
      *tmp___91 = (unsigned char )((data___5 >> 16) & 255ULL);
#line 3218
      tmp___92 = p;
#line 3218
      p ++;
#line 3218
      *tmp___92 = (unsigned char )((data___5 >> 8) & 255ULL);
#line 3219
      tmp___93 = p;
#line 3219
      p ++;
#line 3219
      *tmp___93 = (unsigned char )(data___5 & 255ULL);
      }
    }
    while_break___13: /* CIL Label */ ;
    }
#line 3222
    goto switch_break;
    case_100___0: /* CIL Label */ 
    case_102___0: /* CIL Label */ 
#line 3235
    count = (size_t )1;
#line 3235
    if ((int const   )*format == 42) {
      {
#line 3235
      format ++;
#line 3235
      tmp___96 = __builtin_va_arg(args, int );
#line 3235
      count = (size_t )tmp___96;
      }
    } else {
      {
#line 3235
      tmp___98 = __ctype_b_loc();
      }
#line 3235
      if ((int const   )*(*tmp___98 + (int )((unsigned int )*format)) & 2048) {
#line 3235
        count = (size_t )0;
        {
#line 3235
        while (1) {
          while_continue___14: /* CIL Label */ ;
          {
#line 3235
          tmp___97 = __ctype_b_loc();
          }
#line 3235
          if (! ((int const   )*(*tmp___97 + (int )((unsigned int )*format)) & 2048)) {
#line 3235
            goto while_break___14;
          }
#line 3235
          count *= 10UL;
#line 3235
          count += (size_t )((int const   )*format - 48);
#line 3235
          format ++;
        }
        while_break___14: /* CIL Label */ ;
        }
      }
    }
#line 3235
    if ((ssize_t )count < 1L) {
      {
#line 3235
      tmp___99 = set_errno(22);
      }
#line 3235
      return ((ssize_t )tmp___99);
    }
    {
#line 3236
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 3236
      tmp___107 = count;
#line 3236
      count --;
#line 3236
      if (! tmp___107) {
#line 3236
        goto while_break___15;
      }
      {
#line 3238
      tmp___101 = __builtin_va_arg(args, double );
#line 3238
      data___6 = tmp___101;
#line 3239
      tmp___102 = snprintf((char */* __restrict  */)(tmp), (size_t )128, (char const   */* __restrict  */)"%g",
                           data___6);
#line 3239
      rc = tmp___102;
      }
#line 3241
      if (rc == -1) {
        {
#line 3242
        tmp___103 = set_errno(28);
        }
#line 3242
        return ((ssize_t )tmp___103);
      } else
#line 3241
      if (rc >= 128) {
        {
#line 3242
        tmp___103 = set_errno(28);
        }
#line 3242
        return ((ssize_t )tmp___103);
      }
      {
#line 3243
      tmp___104 = strlen((char const   *)(tmp));
#line 3243
      len___0 = tmp___104 + 1UL;
      }
#line 3244
      if ((unsigned long )(p + (len___0 + 1UL)) > (unsigned long )(pkt + size)) {
        {
#line 3244
        tmp___105 = set_errno(28);
        }
#line 3244
        return ((ssize_t )tmp___105);
      }
      {
#line 3245
      tmp___106 = p;
#line 3245
      p ++;
#line 3245
      *tmp___106 = (unsigned char )(len___0 & 255UL);
#line 3246
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(tmp), len___0);
#line 3247
      p += len___0;
      }
    }
    while_break___15: /* CIL Label */ ;
    }
#line 3250
    goto switch_break;
    case_118: /* CIL Label */ 
#line 3255
    count = (size_t )1;
#line 3255
    if ((int const   )*format == 42) {
      {
#line 3255
      format ++;
#line 3255
      tmp___109 = __builtin_va_arg(args, int );
#line 3255
      count = (size_t )tmp___109;
      }
    } else {
      {
#line 3255
      tmp___111 = __ctype_b_loc();
      }
#line 3255
      if ((int const   )*(*tmp___111 + (int )((unsigned int )*format)) & 2048) {
#line 3255
        count = (size_t )0;
        {
#line 3255
        while (1) {
          while_continue___16: /* CIL Label */ ;
          {
#line 3255
          tmp___110 = __ctype_b_loc();
          }
#line 3255
          if (! ((int const   )*(*tmp___110 + (int )((unsigned int )*format)) & 2048)) {
#line 3255
            goto while_break___16;
          }
#line 3255
          count *= 10UL;
#line 3255
          count += (size_t )((int const   )*format - 48);
#line 3255
          format ++;
        }
        while_break___16: /* CIL Label */ ;
        }
      }
    }
#line 3255
    if ((ssize_t )count < 1L) {
      {
#line 3255
      tmp___112 = set_errno(22);
      }
#line 3255
      return ((ssize_t )tmp___112);
    }
#line 3256
    if ((unsigned long )(p + (count << 1)) > (unsigned long )(pkt + size)) {
      {
#line 3256
      tmp___113 = set_errno(28);
      }
#line 3256
      return ((ssize_t )tmp___113);
    }
    {
#line 3257
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 3257
      tmp___118 = count;
#line 3257
      count --;
#line 3257
      if (! tmp___118) {
#line 3257
        goto while_break___17;
      }
      {
#line 3259
      tmp___115 = __builtin_va_arg(args, int );
#line 3259
      data___7 = (unsigned short )tmp___115;
#line 3260
      tmp___116 = p;
#line 3260
      p ++;
#line 3260
      *tmp___116 = (unsigned char )((int )data___7 & 255);
#line 3261
      tmp___117 = p;
#line 3261
      p ++;
#line 3261
      *tmp___117 = (unsigned char )(((int )data___7 >> 8) & 255);
      }
    }
    while_break___17: /* CIL Label */ ;
    }
#line 3264
    goto switch_break;
    case_119: /* CIL Label */ 
#line 3269
    count = (size_t )1;
#line 3269
    if ((int const   )*format == 42) {
      {
#line 3269
      format ++;
#line 3269
      tmp___120 = __builtin_va_arg(args, int );
#line 3269
      count = (size_t )tmp___120;
      }
    } else {
      {
#line 3269
      tmp___122 = __ctype_b_loc();
      }
#line 3269
      if ((int const   )*(*tmp___122 + (int )((unsigned int )*format)) & 2048) {
#line 3269
        count = (size_t )0;
        {
#line 3269
        while (1) {
          while_continue___18: /* CIL Label */ ;
          {
#line 3269
          tmp___121 = __ctype_b_loc();
          }
#line 3269
          if (! ((int const   )*(*tmp___121 + (int )((unsigned int )*format)) & 2048)) {
#line 3269
            goto while_break___18;
          }
#line 3269
          count *= 10UL;
#line 3269
          count += (size_t )((int const   )*format - 48);
#line 3269
          format ++;
        }
        while_break___18: /* CIL Label */ ;
        }
      }
    }
#line 3269
    if ((ssize_t )count < 1L) {
      {
#line 3269
      tmp___123 = set_errno(22);
      }
#line 3269
      return ((ssize_t )tmp___123);
    }
#line 3270
    if ((unsigned long )(p + (count << 2)) > (unsigned long )(pkt + size)) {
      {
#line 3270
      tmp___124 = set_errno(28);
      }
#line 3270
      return ((ssize_t )tmp___124);
    }
    {
#line 3271
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 3271
      tmp___131 = count;
#line 3271
      count --;
#line 3271
      if (! tmp___131) {
#line 3271
        goto while_break___19;
      }
      {
#line 3273
      tmp___126 = __builtin_va_arg(args, int );
#line 3273
      data___8 = (unsigned int )tmp___126;
#line 3274
      tmp___127 = p;
#line 3274
      p ++;
#line 3274
      *tmp___127 = (unsigned char )(data___8 & 255U);
#line 3275
      tmp___128 = p;
#line 3275
      p ++;
#line 3275
      *tmp___128 = (unsigned char )((data___8 >> 8) & 255U);
#line 3276
      tmp___129 = p;
#line 3276
      p ++;
#line 3276
      *tmp___129 = (unsigned char )((data___8 >> 16) & 255U);
#line 3277
      tmp___130 = p;
#line 3277
      p ++;
#line 3277
      *tmp___130 = (unsigned char )((data___8 >> 24) & 255U);
      }
    }
    while_break___19: /* CIL Label */ ;
    }
#line 3280
    goto switch_break;
    case_120: /* CIL Label */ 
#line 3285
    count = (size_t )1;
#line 3285
    if ((int const   )*format == 42) {
      {
#line 3285
      format ++;
#line 3285
      tmp___133 = __builtin_va_arg(args, int );
#line 3285
      count = (size_t )tmp___133;
      }
    } else {
      {
#line 3285
      tmp___135 = __ctype_b_loc();
      }
#line 3285
      if ((int const   )*(*tmp___135 + (int )((unsigned int )*format)) & 2048) {
#line 3285
        count = (size_t )0;
        {
#line 3285
        while (1) {
          while_continue___20: /* CIL Label */ ;
          {
#line 3285
          tmp___134 = __ctype_b_loc();
          }
#line 3285
          if (! ((int const   )*(*tmp___134 + (int )((unsigned int )*format)) & 2048)) {
#line 3285
            goto while_break___20;
          }
#line 3285
          count *= 10UL;
#line 3285
          count += (size_t )((int const   )*format - 48);
#line 3285
          format ++;
        }
        while_break___20: /* CIL Label */ ;
        }
      }
    }
#line 3285
    if ((ssize_t )count < 1L) {
      {
#line 3285
      tmp___136 = set_errno(22);
      }
#line 3285
      return ((ssize_t )tmp___136);
    }
#line 3286
    if ((unsigned long )(p + count) > (unsigned long )(pkt + size)) {
      {
#line 3286
      tmp___137 = set_errno(28);
      }
#line 3286
      return ((ssize_t )tmp___137);
    }
    {
#line 3287
    memset((void *)p, 0, count);
#line 3288
    p += count;
    }
#line 3289
    goto switch_break;
    case_88: /* CIL Label */ 
#line 3294
    count = (size_t )1;
#line 3294
    if ((int const   )*format == 42) {
      {
#line 3294
      format ++;
#line 3294
      tmp___139 = __builtin_va_arg(args, int );
#line 3294
      count = (size_t )tmp___139;
      }
    } else {
      {
#line 3294
      tmp___141 = __ctype_b_loc();
      }
#line 3294
      if ((int const   )*(*tmp___141 + (int )((unsigned int )*format)) & 2048) {
#line 3294
        count = (size_t )0;
        {
#line 3294
        while (1) {
          while_continue___21: /* CIL Label */ ;
          {
#line 3294
          tmp___140 = __ctype_b_loc();
          }
#line 3294
          if (! ((int const   )*(*tmp___140 + (int )((unsigned int )*format)) & 2048)) {
#line 3294
            goto while_break___21;
          }
#line 3294
          count *= 10UL;
#line 3294
          count += (size_t )((int const   )*format - 48);
#line 3294
          format ++;
        }
        while_break___21: /* CIL Label */ ;
        }
      }
    }
#line 3294
    if ((ssize_t )count < 1L) {
      {
#line 3294
      tmp___142 = set_errno(22);
      }
#line 3294
      return ((ssize_t )tmp___142);
    }
#line 3295
    if ((unsigned long )(p - count) < (unsigned long )pkt) {
      {
#line 3296
      tmp___143 = set_errno(22);
      }
#line 3296
      return ((ssize_t )tmp___143);
    }
#line 3297
    p -= count;
#line 3298
    goto switch_break;
    case_64: /* CIL Label */ 
#line 3303
    count = (size_t )1;
#line 3303
    if ((int const   )*format == 42) {
      {
#line 3303
      format ++;
#line 3303
      tmp___145 = __builtin_va_arg(args, int );
#line 3303
      count = (size_t )tmp___145;
      }
    } else {
      {
#line 3303
      tmp___147 = __ctype_b_loc();
      }
#line 3303
      if ((int const   )*(*tmp___147 + (int )((unsigned int )*format)) & 2048) {
#line 3303
        count = (size_t )0;
        {
#line 3303
        while (1) {
          while_continue___22: /* CIL Label */ ;
          {
#line 3303
          tmp___146 = __ctype_b_loc();
          }
#line 3303
          if (! ((int const   )*(*tmp___146 + (int )((unsigned int )*format)) & 2048)) {
#line 3303
            goto while_break___22;
          }
#line 3303
          count *= 10UL;
#line 3303
          count += (size_t )((int const   )*format - 48);
#line 3303
          format ++;
        }
        while_break___22: /* CIL Label */ ;
        }
      }
    }
#line 3303
    if ((ssize_t )count < 1L) {
      {
#line 3303
      tmp___148 = set_errno(22);
      }
#line 3303
      return ((ssize_t )tmp___148);
    }
#line 3304
    if (count > size) {
      {
#line 3305
      tmp___149 = set_errno(28);
      }
#line 3305
      return ((ssize_t )tmp___149);
    }
#line 3306
    if ((unsigned long )(pkt + count) < (unsigned long )p) {
      {
#line 3307
      tmp___150 = set_errno(22);
      }
#line 3307
      return ((ssize_t )tmp___150);
    }
    {
#line 3308
    memset((void *)p, 0, count - (size_t )(p - pkt));
#line 3309
    p += count - (size_t )(p - pkt);
    }
#line 3310
    goto switch_break;
    switch_default___1: /* CIL Label */ 
    {
#line 3315
    tmp___151 = set_errno(22);
    }
#line 3315
    return ((ssize_t )tmp___151);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3320
  return (p - pkt);
}
}
#line 3346 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
ssize_t unpack(void *buf , size_t size , char const   *format  , ...) 
{ 
  va_list args ;
  int rc ;
  ssize_t tmp ;

  {
  {
#line 3351
  __builtin_va_start(args, format);
#line 3352
  tmp = vunpack(buf, size, format, args);
#line 3352
  rc = (int )tmp;
#line 3353
  __builtin_va_end(args);
  }
#line 3355
  return ((ssize_t )rc);
}
}
#line 3400 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
ssize_t vunpack(void *buf , size_t size , char const   *format , va_list args ) 
{ 
  unsigned char *pkt ;
  unsigned char *p ;
  size_t count ;
  size_t limit ;
  int tmp ;
  char f ;
  char const   *tmp___0 ;
  void *data ;
  int tmp___2 ;
  size_t *countp ;
  size_t *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  char *data___0 ;
  size_t len ;
  int tmp___14 ;
  size_t *countp___0 ;
  size_t *tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  unsigned short const   **tmp___19 ;
  unsigned short const   **tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  size_t tmp___25 ;
  char bin___0[3] ;
  char *data___1 ;
  int shift ;
  int tmp___27 ;
  size_t *countp___1 ;
  size_t *tmp___29 ;
  int tmp___30 ;
  size_t tmp___31 ;
  unsigned short const   **tmp___32 ;
  unsigned short const   **tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  size_t tmp___39 ;
  char hex___1[17] ;
  char *data___2 ;
  int shift___0 ;
  int tmp___41 ;
  size_t *countp___2 ;
  size_t *tmp___43 ;
  int tmp___44 ;
  size_t tmp___45 ;
  unsigned short const   **tmp___46 ;
  unsigned short const   **tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  size_t tmp___53 ;
  int tmp___55 ;
  unsigned short const   **tmp___56 ;
  unsigned short const   **tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  signed char *data___3 ;
  signed char *tmp___61 ;
  unsigned char *tmp___62 ;
  size_t tmp___63 ;
  int tmp___65 ;
  unsigned short const   **tmp___66 ;
  unsigned short const   **tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  short *data___4 ;
  short *tmp___71 ;
  unsigned char *tmp___72 ;
  unsigned char *tmp___73 ;
  size_t tmp___74 ;
  int tmp___76 ;
  unsigned short const   **tmp___77 ;
  unsigned short const   **tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int *data___5 ;
  int *tmp___82 ;
  unsigned char *tmp___83 ;
  unsigned char *tmp___84 ;
  unsigned char *tmp___85 ;
  unsigned char *tmp___86 ;
  size_t tmp___87 ;
  int tmp___89 ;
  unsigned short const   **tmp___90 ;
  unsigned short const   **tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  short *data___6 ;
  short *tmp___95 ;
  unsigned char *tmp___96 ;
  unsigned char *tmp___97 ;
  size_t tmp___98 ;
  int tmp___100 ;
  unsigned short const   **tmp___101 ;
  unsigned short const   **tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int *data___7 ;
  int *tmp___106 ;
  unsigned char *tmp___107 ;
  unsigned char *tmp___108 ;
  unsigned char *tmp___109 ;
  unsigned char *tmp___110 ;
  size_t tmp___111 ;
  int tmp___113 ;
  unsigned short const   **tmp___114 ;
  unsigned short const   **tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  long long *data___8 ;
  long long *tmp___119 ;
  unsigned char *tmp___120 ;
  unsigned char *tmp___121 ;
  unsigned char *tmp___122 ;
  unsigned char *tmp___123 ;
  unsigned char *tmp___124 ;
  unsigned char *tmp___125 ;
  unsigned char *tmp___126 ;
  unsigned char *tmp___127 ;
  size_t tmp___128 ;
  int tmp___130 ;
  unsigned short const   **tmp___131 ;
  unsigned short const   **tmp___132 ;
  int tmp___133 ;
  float *data___9 ;
  float *tmp___135 ;
  size_t len___0 ;
  int tmp___136 ;
  unsigned char *tmp___137 ;
  int tmp___138 ;
  size_t tmp___139 ;
  int tmp___141 ;
  unsigned short const   **tmp___142 ;
  unsigned short const   **tmp___143 ;
  int tmp___144 ;
  double *data___10 ;
  double *tmp___146 ;
  size_t len___1 ;
  int tmp___147 ;
  unsigned char *tmp___148 ;
  int tmp___149 ;
  size_t tmp___150 ;
  int tmp___152 ;
  unsigned short const   **tmp___153 ;
  unsigned short const   **tmp___154 ;
  int tmp___155 ;
  int tmp___156 ;
  int tmp___158 ;
  unsigned short const   **tmp___159 ;
  unsigned short const   **tmp___160 ;
  int tmp___161 ;
  int tmp___162 ;
  int tmp___164 ;
  unsigned short const   **tmp___165 ;
  unsigned short const   **tmp___166 ;
  int tmp___167 ;
  int tmp___168 ;
  int tmp___169 ;
  int tmp___170 ;
  void *__cil_tmp205 ;
  void *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;

  {
#line 3402
  pkt = (unsigned char *)buf;
#line 3403
  p = pkt;
#line 3406
  if (! pkt) {
    {
#line 3407
    tmp = set_errno(22);
    }
#line 3407
    return ((ssize_t )tmp);
  } else
#line 3406
  if (! format) {
    {
#line 3407
    tmp = set_errno(22);
    }
#line 3407
    return ((ssize_t )tmp);
  }
  {
#line 3409
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3409
    if (! *format) {
#line 3409
      goto while_break;
    }
#line 3411
    tmp___0 = format;
#line 3411
    format ++;
#line 3411
    f = (char )*tmp___0;
#line 3412
    if ((int )f == 112) {
#line 3412
      if (sizeof(void *) == 8UL) {
#line 3413
        f = (char )'P';
      }
    }
    {
#line 3417
    if ((int )f == 97) {
#line 3417
      goto case_97;
    }
#line 3429
    if ((int )f == 122) {
#line 3429
      goto case_122;
    }
#line 3449
    if ((int )f == 98) {
#line 3449
      goto case_98;
    }
#line 3471
    if ((int )f == 104) {
#line 3471
      goto case_104;
    }
#line 3493
    if ((int )f == 99) {
#line 3493
      goto case_99;
    }
#line 3506
    if ((int )f == 115) {
#line 3506
      goto case_115;
    }
#line 3521
    if ((int )f == 112) {
#line 3521
      goto case_112;
    }
#line 3521
    if ((int )f == 105) {
#line 3521
      goto case_112;
    }
#line 3538
    if ((int )f == 118) {
#line 3538
      goto case_118;
    }
#line 3552
    if ((int )f == 119) {
#line 3552
      goto case_119;
    }
#line 3571
    if ((int )f == 80) {
#line 3571
      goto case_80;
    }
#line 3571
    if ((int )f == 108) {
#line 3571
      goto case_80;
    }
#line 3599
    if ((int )f == 102) {
#line 3599
      goto case_102;
    }
#line 3617
    if ((int )f == 100) {
#line 3617
      goto case_100;
    }
#line 3635
    if ((int )f == 120) {
#line 3635
      goto case_120;
    }
#line 3643
    if ((int )f == 88) {
#line 3643
      goto case_88;
    }
#line 3652
    if ((int )f == 64) {
#line 3652
      goto case_64;
    }
#line 3663
    goto switch_default;
    case_97: /* CIL Label */ 
#line 3420
    count = (size_t )1;
#line 3420
    limit = count;
#line 3420
    if ((int const   )*format == 42) {
      {
#line 3420
      format ++;
#line 3420
      tmp___2 = __builtin_va_arg(args, int );
#line 3420
      count = (size_t )tmp___2;
#line 3420
      limit = count;
      }
    } else
#line 3420
    if ((int const   )*format == 63) {
      {
#line 3420
      tmp___4 = __builtin_va_arg(args, size_t *);
#line 3420
      countp = tmp___4;
      }
#line 3420
      if (! countp) {
        {
#line 3420
        tmp___5 = set_errno(22);
        }
#line 3420
        return ((ssize_t )tmp___5);
      }
      {
#line 3420
      count = *countp;
#line 3420
      tmp___6 = __builtin_va_arg(args, size_t );
#line 3420
      limit = tmp___6;
#line 3420
      format ++;
      }
    } else {
      {
#line 3420
      tmp___8 = __ctype_b_loc();
      }
#line 3420
      if ((int const   )*(*tmp___8 + (int )((unsigned int )*format)) & 2048) {
#line 3420
        count = (size_t )0;
        {
#line 3420
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 3420
          tmp___7 = __ctype_b_loc();
          }
#line 3420
          if (! ((int const   )*(*tmp___7 + (int )((unsigned int )*format)) & 2048)) {
#line 3420
            goto while_break___0;
          }
#line 3420
          count *= 10UL;
#line 3420
          count += (size_t )((int const   )*format - 48);
#line 3420
          format ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 3420
        limit = count;
      }
    }
#line 3420
    if ((ssize_t )count < 1L) {
      {
#line 3420
      tmp___9 = set_errno(22);
      }
#line 3420
      return ((ssize_t )tmp___9);
    } else
#line 3420
    if ((ssize_t )limit < 1L) {
      {
#line 3420
      tmp___9 = set_errno(22);
      }
#line 3420
      return ((ssize_t )tmp___9);
    }
#line 3420
    if (count > limit) {
      {
#line 3420
      tmp___10 = set_errno(28);
      }
#line 3420
      return ((ssize_t )tmp___10);
    }
#line 3421
    if ((unsigned long )(p + count) > (unsigned long )(pkt + size)) {
      {
#line 3421
      tmp___11 = set_errno(28);
      }
#line 3421
      return ((ssize_t )tmp___11);
    }
    {
#line 3422
    tmp___12 = __builtin_va_arg(args, void *);
#line 3422
    data = tmp___12;
    }
#line 3423
    if (! data) {
#line 3423
      p += count;
#line 3423
      goto switch_break;
    }
    {
#line 3424
    memcpy((void */* __restrict  */)data, (void const   */* __restrict  */)p, count);
#line 3425
    p += count;
    }
#line 3426
    goto switch_break;
    case_122: /* CIL Label */ 
#line 3433
    count = (size_t )1;
#line 3433
    limit = count;
#line 3433
    if ((int const   )*format == 42) {
      {
#line 3433
      format ++;
#line 3433
      tmp___14 = __builtin_va_arg(args, int );
#line 3433
      count = (size_t )tmp___14;
#line 3433
      limit = count;
      }
    } else
#line 3433
    if ((int const   )*format == 63) {
      {
#line 3433
      tmp___16 = __builtin_va_arg(args, size_t *);
#line 3433
      countp___0 = tmp___16;
      }
#line 3433
      if (! countp___0) {
        {
#line 3433
        tmp___17 = set_errno(22);
        }
#line 3433
        return ((ssize_t )tmp___17);
      }
      {
#line 3433
      count = *countp___0;
#line 3433
      tmp___18 = __builtin_va_arg(args, size_t );
#line 3433
      limit = tmp___18;
#line 3433
      format ++;
      }
    } else {
      {
#line 3433
      tmp___20 = __ctype_b_loc();
      }
#line 3433
      if ((int const   )*(*tmp___20 + (int )((unsigned int )*format)) & 2048) {
#line 3433
        count = (size_t )0;
        {
#line 3433
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 3433
          tmp___19 = __ctype_b_loc();
          }
#line 3433
          if (! ((int const   )*(*tmp___19 + (int )((unsigned int )*format)) & 2048)) {
#line 3433
            goto while_break___1;
          }
#line 3433
          count *= 10UL;
#line 3433
          count += (size_t )((int const   )*format - 48);
#line 3433
          format ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 3433
        limit = count;
      }
    }
#line 3433
    if ((ssize_t )count < 1L) {
      {
#line 3433
      tmp___21 = set_errno(22);
      }
#line 3433
      return ((ssize_t )tmp___21);
    } else
#line 3433
    if ((ssize_t )limit < 1L) {
      {
#line 3433
      tmp___21 = set_errno(22);
      }
#line 3433
      return ((ssize_t )tmp___21);
    }
#line 3433
    if (count > limit) {
      {
#line 3433
      tmp___22 = set_errno(28);
      }
#line 3433
      return ((ssize_t )tmp___22);
    }
#line 3434
    if ((unsigned long )(p + count) > (unsigned long )(pkt + size)) {
      {
#line 3434
      tmp___23 = set_errno(28);
      }
#line 3434
      return ((ssize_t )tmp___23);
    }
    {
#line 3435
    tmp___24 = __builtin_va_arg(args, char *);
#line 3435
    data___0 = tmp___24;
    }
#line 3436
    if (! data___0) {
#line 3436
      p += count;
#line 3436
      goto switch_break;
    }
#line 3437
    len = (size_t )0;
    {
#line 3437
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3437
      if ((unsigned long )(p + len) < (unsigned long )(pkt + size)) {
#line 3437
        if (! *(p + len)) {
#line 3437
          goto while_break___2;
        }
      } else {
#line 3437
        goto while_break___2;
      }
#line 3437
      len ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 3439
    if (len > count) {
#line 3440
      len = count;
    }
    {
#line 3441
    memcpy((void */* __restrict  */)data___0, (void const   */* __restrict  */)p,
           len);
#line 3442
    p += len;
#line 3443
    count -= len;
    }
#line 3444
    if (count) {
#line 3444
      tmp___25 = count;
    } else {
#line 3444
      tmp___25 = (size_t )1;
    }
    {
#line 3444
    memset((void *)(data___0 + len), 0, tmp___25);
#line 3445
    p += count;
    }
#line 3446
    goto switch_break;
    case_98: /* CIL Label */ 
#line 3451
    bin___0[0] = (char )'0';
#line 3451
    bin___0[1] = (char )'1';
#line 3451
    bin___0[2] = (char )'\000';
#line 3454
    count = (size_t )1;
#line 3454
    limit = count;
#line 3454
    if ((int const   )*format == 42) {
      {
#line 3454
      format ++;
#line 3454
      tmp___27 = __builtin_va_arg(args, int );
#line 3454
      count = (size_t )tmp___27;
#line 3454
      limit = count;
      }
    } else
#line 3454
    if ((int const   )*format == 63) {
      {
#line 3454
      tmp___29 = __builtin_va_arg(args, size_t *);
#line 3454
      countp___1 = tmp___29;
      }
#line 3454
      if (! countp___1) {
        {
#line 3454
        tmp___30 = set_errno(22);
        }
#line 3454
        return ((ssize_t )tmp___30);
      }
      {
#line 3454
      count = *countp___1;
#line 3454
      tmp___31 = __builtin_va_arg(args, size_t );
#line 3454
      limit = tmp___31;
#line 3454
      format ++;
      }
    } else {
      {
#line 3454
      tmp___33 = __ctype_b_loc();
      }
#line 3454
      if ((int const   )*(*tmp___33 + (int )((unsigned int )*format)) & 2048) {
#line 3454
        count = (size_t )0;
        {
#line 3454
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 3454
          tmp___32 = __ctype_b_loc();
          }
#line 3454
          if (! ((int const   )*(*tmp___32 + (int )((unsigned int )*format)) & 2048)) {
#line 3454
            goto while_break___3;
          }
#line 3454
          count *= 10UL;
#line 3454
          count += (size_t )((int const   )*format - 48);
#line 3454
          format ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 3454
        limit = count;
      }
    }
#line 3454
    if ((ssize_t )count < 1L) {
      {
#line 3454
      tmp___34 = set_errno(22);
      }
#line 3454
      return ((ssize_t )tmp___34);
    } else
#line 3454
    if ((ssize_t )limit < 1L) {
      {
#line 3454
      tmp___34 = set_errno(22);
      }
#line 3454
      return ((ssize_t )tmp___34);
    }
#line 3454
    if (count > limit) {
      {
#line 3454
      tmp___35 = set_errno(28);
      }
#line 3454
      return ((ssize_t )tmp___35);
    }
#line 3455
    if ((unsigned long )(p + ((count + 7UL) >> 3)) > (unsigned long )(pkt + size)) {
      {
#line 3455
      tmp___36 = set_errno(28);
      }
#line 3455
      return ((ssize_t )tmp___36);
    }
    {
#line 3456
    tmp___37 = __builtin_va_arg(args, char *);
#line 3456
    data___1 = tmp___37;
    }
#line 3457
    if (! data___1) {
#line 3457
      p += (count + 7UL) >> 3;
#line 3457
      goto switch_break;
    }
#line 3458
    shift = 7;
    {
#line 3459
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3459
      tmp___39 = count;
#line 3459
      count --;
#line 3459
      if (! tmp___39) {
#line 3459
        goto while_break___4;
      }
#line 3461
      tmp___38 = data___1;
#line 3461
      data___1 ++;
#line 3461
      *tmp___38 = bin___0[((int )*p & (1 << shift)) >> shift];
#line 3462
      shift --;
#line 3462
      if (shift == -1) {
#line 3463
        p ++;
#line 3463
        shift = 7;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 3465
    if (shift != 7) {
#line 3466
      p ++;
    }
#line 3467
    *data___1 = (char )'\000';
#line 3468
    goto switch_break;
    case_104: /* CIL Label */ 
#line 3473
    hex___1[0] = (char )'0';
#line 3473
    hex___1[1] = (char )'1';
#line 3473
    hex___1[2] = (char )'2';
#line 3473
    hex___1[3] = (char )'3';
#line 3473
    hex___1[4] = (char )'4';
#line 3473
    hex___1[5] = (char )'5';
#line 3473
    hex___1[6] = (char )'6';
#line 3473
    hex___1[7] = (char )'7';
#line 3473
    hex___1[8] = (char )'8';
#line 3473
    hex___1[9] = (char )'9';
#line 3473
    hex___1[10] = (char )'a';
#line 3473
    hex___1[11] = (char )'b';
#line 3473
    hex___1[12] = (char )'c';
#line 3473
    hex___1[13] = (char )'d';
#line 3473
    hex___1[14] = (char )'e';
#line 3473
    hex___1[15] = (char )'f';
#line 3473
    hex___1[16] = (char )'\000';
#line 3476
    count = (size_t )1;
#line 3476
    limit = count;
#line 3476
    if ((int const   )*format == 42) {
      {
#line 3476
      format ++;
#line 3476
      tmp___41 = __builtin_va_arg(args, int );
#line 3476
      count = (size_t )tmp___41;
#line 3476
      limit = count;
      }
    } else
#line 3476
    if ((int const   )*format == 63) {
      {
#line 3476
      tmp___43 = __builtin_va_arg(args, size_t *);
#line 3476
      countp___2 = tmp___43;
      }
#line 3476
      if (! countp___2) {
        {
#line 3476
        tmp___44 = set_errno(22);
        }
#line 3476
        return ((ssize_t )tmp___44);
      }
      {
#line 3476
      count = *countp___2;
#line 3476
      tmp___45 = __builtin_va_arg(args, size_t );
#line 3476
      limit = tmp___45;
#line 3476
      format ++;
      }
    } else {
      {
#line 3476
      tmp___47 = __ctype_b_loc();
      }
#line 3476
      if ((int const   )*(*tmp___47 + (int )((unsigned int )*format)) & 2048) {
#line 3476
        count = (size_t )0;
        {
#line 3476
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 3476
          tmp___46 = __ctype_b_loc();
          }
#line 3476
          if (! ((int const   )*(*tmp___46 + (int )((unsigned int )*format)) & 2048)) {
#line 3476
            goto while_break___5;
          }
#line 3476
          count *= 10UL;
#line 3476
          count += (size_t )((int const   )*format - 48);
#line 3476
          format ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 3476
        limit = count;
      }
    }
#line 3476
    if ((ssize_t )count < 1L) {
      {
#line 3476
      tmp___48 = set_errno(22);
      }
#line 3476
      return ((ssize_t )tmp___48);
    } else
#line 3476
    if ((ssize_t )limit < 1L) {
      {
#line 3476
      tmp___48 = set_errno(22);
      }
#line 3476
      return ((ssize_t )tmp___48);
    }
#line 3476
    if (count > limit) {
      {
#line 3476
      tmp___49 = set_errno(28);
      }
#line 3476
      return ((ssize_t )tmp___49);
    }
#line 3477
    if ((unsigned long )(p + ((count + 1UL) >> 1)) > (unsigned long )(pkt + size)) {
      {
#line 3477
      tmp___50 = set_errno(28);
      }
#line 3477
      return ((ssize_t )tmp___50);
    }
    {
#line 3478
    tmp___51 = __builtin_va_arg(args, char *);
#line 3478
    data___2 = tmp___51;
    }
#line 3479
    if (! data___2) {
#line 3479
      p += (count + 1UL) >> 1;
#line 3479
      goto switch_break;
    }
#line 3480
    shift___0 = 4;
    {
#line 3481
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 3481
      tmp___53 = count;
#line 3481
      count --;
#line 3481
      if (! tmp___53) {
#line 3481
        goto while_break___6;
      }
#line 3483
      tmp___52 = data___2;
#line 3483
      data___2 ++;
#line 3483
      *tmp___52 = hex___1[((int )*p & (15 << shift___0)) >> shift___0];
#line 3484
      shift___0 -= 4;
#line 3484
      if (shift___0 == -4) {
#line 3485
        p ++;
#line 3485
        shift___0 = 4;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 3487
    if (shift___0 != 4) {
#line 3488
      p ++;
    }
#line 3489
    *data___2 = (char )'\000';
#line 3490
    goto switch_break;
    case_99: /* CIL Label */ 
#line 3495
    count = (size_t )1;
#line 3495
    if ((int const   )*format == 42) {
      {
#line 3495
      format ++;
#line 3495
      tmp___55 = __builtin_va_arg(args, int );
#line 3495
      count = (size_t )tmp___55;
      }
    } else {
      {
#line 3495
      tmp___57 = __ctype_b_loc();
      }
#line 3495
      if ((int const   )*(*tmp___57 + (int )((unsigned int )*format)) & 2048) {
#line 3495
        count = (size_t )0;
        {
#line 3495
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 3495
          tmp___56 = __ctype_b_loc();
          }
#line 3495
          if (! ((int const   )*(*tmp___56 + (int )((unsigned int )*format)) & 2048)) {
#line 3495
            goto while_break___7;
          }
#line 3495
          count *= 10UL;
#line 3495
          count += (size_t )((int const   )*format - 48);
#line 3495
          format ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
    }
#line 3495
    if ((ssize_t )count < 1L) {
      {
#line 3495
      tmp___58 = set_errno(22);
      }
#line 3495
      return ((ssize_t )tmp___58);
    }
#line 3496
    if ((unsigned long )(p + count) > (unsigned long )(pkt + size)) {
      {
#line 3496
      tmp___59 = set_errno(28);
      }
#line 3496
      return ((ssize_t )tmp___59);
    }
    {
#line 3497
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 3497
      tmp___63 = count;
#line 3497
      count --;
#line 3497
      if (! tmp___63) {
#line 3497
        goto while_break___8;
      }
      {
#line 3499
      tmp___61 = __builtin_va_arg(args, signed char *);
#line 3499
      data___3 = tmp___61;
      }
#line 3500
      if (! data___3) {
#line 3500
        p ++;
#line 3500
        goto while_continue___8;
      }
#line 3501
      tmp___62 = p;
#line 3501
      p ++;
#line 3501
      *data___3 = (signed char )*tmp___62;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 3503
    goto switch_break;
    case_115: /* CIL Label */ 
#line 3508
    count = (size_t )1;
#line 3508
    if ((int const   )*format == 42) {
      {
#line 3508
      format ++;
#line 3508
      tmp___65 = __builtin_va_arg(args, int );
#line 3508
      count = (size_t )tmp___65;
      }
    } else {
      {
#line 3508
      tmp___67 = __ctype_b_loc();
      }
#line 3508
      if ((int const   )*(*tmp___67 + (int )((unsigned int )*format)) & 2048) {
#line 3508
        count = (size_t )0;
        {
#line 3508
        while (1) {
          while_continue___9: /* CIL Label */ ;
          {
#line 3508
          tmp___66 = __ctype_b_loc();
          }
#line 3508
          if (! ((int const   )*(*tmp___66 + (int )((unsigned int )*format)) & 2048)) {
#line 3508
            goto while_break___9;
          }
#line 3508
          count *= 10UL;
#line 3508
          count += (size_t )((int const   )*format - 48);
#line 3508
          format ++;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
    }
#line 3508
    if ((ssize_t )count < 1L) {
      {
#line 3508
      tmp___68 = set_errno(22);
      }
#line 3508
      return ((ssize_t )tmp___68);
    }
#line 3509
    if ((unsigned long )(p + (count << 1)) > (unsigned long )(pkt + size)) {
      {
#line 3509
      tmp___69 = set_errno(28);
      }
#line 3509
      return ((ssize_t )tmp___69);
    }
    {
#line 3510
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 3510
      tmp___74 = count;
#line 3510
      count --;
#line 3510
      if (! tmp___74) {
#line 3510
        goto while_break___10;
      }
      {
#line 3512
      tmp___71 = __builtin_va_arg(args, short *);
#line 3512
      data___4 = tmp___71;
      }
#line 3513
      if (! data___4) {
#line 3513
        p += 2;
#line 3513
        goto while_continue___10;
      }
#line 3514
      tmp___72 = p;
#line 3514
      p ++;
#line 3514
      *data___4 = (short )((int )((short )*tmp___72) << 8);
#line 3515
      tmp___73 = p;
#line 3515
      p ++;
#line 3515
      *data___4 = (short )((int )*data___4 | (int )*tmp___73);
    }
    while_break___10: /* CIL Label */ ;
    }
#line 3517
    goto switch_break;
    case_112: /* CIL Label */ 
    case_105: /* CIL Label */ 
#line 3523
    count = (size_t )1;
#line 3523
    if ((int const   )*format == 42) {
      {
#line 3523
      format ++;
#line 3523
      tmp___76 = __builtin_va_arg(args, int );
#line 3523
      count = (size_t )tmp___76;
      }
    } else {
      {
#line 3523
      tmp___78 = __ctype_b_loc();
      }
#line 3523
      if ((int const   )*(*tmp___78 + (int )((unsigned int )*format)) & 2048) {
#line 3523
        count = (size_t )0;
        {
#line 3523
        while (1) {
          while_continue___11: /* CIL Label */ ;
          {
#line 3523
          tmp___77 = __ctype_b_loc();
          }
#line 3523
          if (! ((int const   )*(*tmp___77 + (int )((unsigned int )*format)) & 2048)) {
#line 3523
            goto while_break___11;
          }
#line 3523
          count *= 10UL;
#line 3523
          count += (size_t )((int const   )*format - 48);
#line 3523
          format ++;
        }
        while_break___11: /* CIL Label */ ;
        }
      }
    }
#line 3523
    if ((ssize_t )count < 1L) {
      {
#line 3523
      tmp___79 = set_errno(22);
      }
#line 3523
      return ((ssize_t )tmp___79);
    }
#line 3524
    if ((unsigned long )(p + (count << 2)) > (unsigned long )(pkt + size)) {
      {
#line 3524
      tmp___80 = set_errno(28);
      }
#line 3524
      return ((ssize_t )tmp___80);
    }
    {
#line 3525
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 3525
      tmp___87 = count;
#line 3525
      count --;
#line 3525
      if (! tmp___87) {
#line 3525
        goto while_break___12;
      }
      {
#line 3527
      tmp___82 = __builtin_va_arg(args, int *);
#line 3527
      data___5 = tmp___82;
      }
#line 3528
      if (! data___5) {
#line 3528
        p += 4;
#line 3528
        goto while_continue___12;
      }
#line 3529
      tmp___83 = p;
#line 3529
      p ++;
#line 3529
      *data___5 = (int )*tmp___83 << 24;
#line 3530
      tmp___84 = p;
#line 3530
      p ++;
#line 3530
      *data___5 |= (int )*tmp___84 << 16;
#line 3531
      tmp___85 = p;
#line 3531
      p ++;
#line 3531
      *data___5 |= (int )*tmp___85 << 8;
#line 3532
      tmp___86 = p;
#line 3532
      p ++;
#line 3532
      *data___5 |= (int )*tmp___86;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 3535
    goto switch_break;
    case_118: /* CIL Label */ 
#line 3540
    count = (size_t )1;
#line 3540
    if ((int const   )*format == 42) {
      {
#line 3540
      format ++;
#line 3540
      tmp___89 = __builtin_va_arg(args, int );
#line 3540
      count = (size_t )tmp___89;
      }
    } else {
      {
#line 3540
      tmp___91 = __ctype_b_loc();
      }
#line 3540
      if ((int const   )*(*tmp___91 + (int )((unsigned int )*format)) & 2048) {
#line 3540
        count = (size_t )0;
        {
#line 3540
        while (1) {
          while_continue___13: /* CIL Label */ ;
          {
#line 3540
          tmp___90 = __ctype_b_loc();
          }
#line 3540
          if (! ((int const   )*(*tmp___90 + (int )((unsigned int )*format)) & 2048)) {
#line 3540
            goto while_break___13;
          }
#line 3540
          count *= 10UL;
#line 3540
          count += (size_t )((int const   )*format - 48);
#line 3540
          format ++;
        }
        while_break___13: /* CIL Label */ ;
        }
      }
    }
#line 3540
    if ((ssize_t )count < 1L) {
      {
#line 3540
      tmp___92 = set_errno(22);
      }
#line 3540
      return ((ssize_t )tmp___92);
    }
#line 3541
    if ((unsigned long )(p + (count << 1)) > (unsigned long )(pkt + size)) {
      {
#line 3541
      tmp___93 = set_errno(28);
      }
#line 3541
      return ((ssize_t )tmp___93);
    }
    {
#line 3542
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 3542
      tmp___98 = count;
#line 3542
      count --;
#line 3542
      if (! tmp___98) {
#line 3542
        goto while_break___14;
      }
      {
#line 3544
      tmp___95 = __builtin_va_arg(args, short *);
#line 3544
      data___6 = tmp___95;
      }
#line 3545
      if (! data___6) {
#line 3545
        p += 2;
#line 3545
        goto while_continue___14;
      }
#line 3546
      tmp___96 = p;
#line 3546
      p ++;
#line 3546
      *data___6 = (short )*tmp___96;
#line 3547
      tmp___97 = p;
#line 3547
      p ++;
#line 3547
      *data___6 = (short )((int )*data___6 | ((int )((unsigned short )*tmp___97) << 8));
    }
    while_break___14: /* CIL Label */ ;
    }
#line 3549
    goto switch_break;
    case_119: /* CIL Label */ 
#line 3554
    count = (size_t )1;
#line 3554
    if ((int const   )*format == 42) {
      {
#line 3554
      format ++;
#line 3554
      tmp___100 = __builtin_va_arg(args, int );
#line 3554
      count = (size_t )tmp___100;
      }
    } else {
      {
#line 3554
      tmp___102 = __ctype_b_loc();
      }
#line 3554
      if ((int const   )*(*tmp___102 + (int )((unsigned int )*format)) & 2048) {
#line 3554
        count = (size_t )0;
        {
#line 3554
        while (1) {
          while_continue___15: /* CIL Label */ ;
          {
#line 3554
          tmp___101 = __ctype_b_loc();
          }
#line 3554
          if (! ((int const   )*(*tmp___101 + (int )((unsigned int )*format)) & 2048)) {
#line 3554
            goto while_break___15;
          }
#line 3554
          count *= 10UL;
#line 3554
          count += (size_t )((int const   )*format - 48);
#line 3554
          format ++;
        }
        while_break___15: /* CIL Label */ ;
        }
      }
    }
#line 3554
    if ((ssize_t )count < 1L) {
      {
#line 3554
      tmp___103 = set_errno(22);
      }
#line 3554
      return ((ssize_t )tmp___103);
    }
#line 3555
    if ((unsigned long )(p + (count << 2)) > (unsigned long )(pkt + size)) {
      {
#line 3555
      tmp___104 = set_errno(28);
      }
#line 3555
      return ((ssize_t )tmp___104);
    }
    {
#line 3556
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 3556
      tmp___111 = count;
#line 3556
      count --;
#line 3556
      if (! tmp___111) {
#line 3556
        goto while_break___16;
      }
      {
#line 3558
      tmp___106 = __builtin_va_arg(args, int *);
#line 3558
      data___7 = tmp___106;
      }
#line 3559
      if (! data___7) {
#line 3559
        p += 4;
#line 3559
        goto while_continue___16;
      }
#line 3560
      tmp___107 = p;
#line 3560
      p ++;
#line 3560
      *data___7 = (int )((long )*tmp___107);
#line 3561
      tmp___108 = p;
#line 3561
      p ++;
#line 3561
      *data___7 = (int )((long )*data___7 | ((long )*tmp___108 << 8));
#line 3562
      tmp___109 = p;
#line 3562
      p ++;
#line 3562
      *data___7 = (int )((long )*data___7 | ((long )*tmp___109 << 16));
#line 3563
      tmp___110 = p;
#line 3563
      p ++;
#line 3563
      *data___7 = (int )((long )*data___7 | ((long )*tmp___110 << 24));
    }
    while_break___16: /* CIL Label */ ;
    }
#line 3566
    goto switch_break;
    case_80: /* CIL Label */ 
    case_108: /* CIL Label */ 
#line 3573
    count = (size_t )1;
#line 3573
    if ((int const   )*format == 42) {
      {
#line 3573
      format ++;
#line 3573
      tmp___113 = __builtin_va_arg(args, int );
#line 3573
      count = (size_t )tmp___113;
      }
    } else {
      {
#line 3573
      tmp___115 = __ctype_b_loc();
      }
#line 3573
      if ((int const   )*(*tmp___115 + (int )((unsigned int )*format)) & 2048) {
#line 3573
        count = (size_t )0;
        {
#line 3573
        while (1) {
          while_continue___17: /* CIL Label */ ;
          {
#line 3573
          tmp___114 = __ctype_b_loc();
          }
#line 3573
          if (! ((int const   )*(*tmp___114 + (int )((unsigned int )*format)) & 2048)) {
#line 3573
            goto while_break___17;
          }
#line 3573
          count *= 10UL;
#line 3573
          count += (size_t )((int const   )*format - 48);
#line 3573
          format ++;
        }
        while_break___17: /* CIL Label */ ;
        }
      }
    }
#line 3573
    if ((ssize_t )count < 1L) {
      {
#line 3573
      tmp___116 = set_errno(22);
      }
#line 3573
      return ((ssize_t )tmp___116);
    }
#line 3574
    if ((unsigned long )(p + (count << 3)) > (unsigned long )(pkt + size)) {
      {
#line 3574
      tmp___117 = set_errno(28);
      }
#line 3574
      return ((ssize_t )tmp___117);
    }
    {
#line 3575
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 3575
      tmp___128 = count;
#line 3575
      count --;
#line 3575
      if (! tmp___128) {
#line 3575
        goto while_break___18;
      }
      {
#line 3577
      tmp___119 = __builtin_va_arg(args, long long *);
#line 3577
      data___8 = tmp___119;
      }
#line 3578
      if (! data___8) {
#line 3578
        p += 8;
#line 3578
        goto while_continue___18;
      }
#line 3579
      tmp___120 = p;
#line 3579
      p ++;
#line 3579
      *data___8 = (long long )*tmp___120 << 56;
#line 3580
      tmp___121 = p;
#line 3580
      p ++;
#line 3580
      *data___8 |= (long long )*tmp___121 << 48;
#line 3581
      tmp___122 = p;
#line 3581
      p ++;
#line 3581
      *data___8 |= (long long )*tmp___122 << 40;
#line 3582
      tmp___123 = p;
#line 3582
      p ++;
#line 3582
      *data___8 |= (long long )*tmp___123 << 32;
#line 3583
      tmp___124 = p;
#line 3583
      p ++;
#line 3583
      *data___8 |= (long long )*tmp___124 << 24;
#line 3584
      tmp___125 = p;
#line 3584
      p ++;
#line 3584
      *data___8 |= (long long )*tmp___125 << 16;
#line 3585
      tmp___126 = p;
#line 3585
      p ++;
#line 3585
      *data___8 |= (long long )*tmp___126 << 8;
#line 3586
      tmp___127 = p;
#line 3586
      p ++;
#line 3586
      *data___8 |= (long long )*tmp___127;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 3589
    goto switch_break;
    case_102: /* CIL Label */ 
#line 3601
    count = (size_t )1;
#line 3601
    if ((int const   )*format == 42) {
      {
#line 3601
      format ++;
#line 3601
      tmp___130 = __builtin_va_arg(args, int );
#line 3601
      count = (size_t )tmp___130;
      }
    } else {
      {
#line 3601
      tmp___132 = __ctype_b_loc();
      }
#line 3601
      if ((int const   )*(*tmp___132 + (int )((unsigned int )*format)) & 2048) {
#line 3601
        count = (size_t )0;
        {
#line 3601
        while (1) {
          while_continue___19: /* CIL Label */ ;
          {
#line 3601
          tmp___131 = __ctype_b_loc();
          }
#line 3601
          if (! ((int const   )*(*tmp___131 + (int )((unsigned int )*format)) & 2048)) {
#line 3601
            goto while_break___19;
          }
#line 3601
          count *= 10UL;
#line 3601
          count += (size_t )((int const   )*format - 48);
#line 3601
          format ++;
        }
        while_break___19: /* CIL Label */ ;
        }
      }
    }
#line 3601
    if ((ssize_t )count < 1L) {
      {
#line 3601
      tmp___133 = set_errno(22);
      }
#line 3601
      return ((ssize_t )tmp___133);
    }
    {
#line 3602
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 3602
      tmp___139 = count;
#line 3602
      count --;
#line 3602
      if (! tmp___139) {
#line 3602
        goto while_break___20;
      }
      {
#line 3604
      tmp___135 = __builtin_va_arg(args, float *);
#line 3604
      data___9 = tmp___135;
      }
#line 3606
      if ((unsigned long )(p + 1) > (unsigned long )(pkt + size)) {
        {
#line 3606
        tmp___136 = set_errno(28);
        }
#line 3606
        return ((ssize_t )tmp___136);
      }
#line 3607
      tmp___137 = p;
#line 3607
      p ++;
#line 3607
      len___0 = (size_t )*tmp___137;
#line 3608
      if ((unsigned long )(p + len___0) > (unsigned long )(pkt + size)) {
        {
#line 3608
        tmp___138 = set_errno(28);
        }
#line 3608
        return ((ssize_t )tmp___138);
      }
#line 3609
      if (! data___9) {
#line 3609
        p += len___0;
#line 3609
        goto while_continue___20;
      }
      {
#line 3610
      sscanf((char const   */* __restrict  */)((char const   *)p), (char const   */* __restrict  */)"%g",
             data___9);
#line 3611
      p += len___0;
      }
    }
    while_break___20: /* CIL Label */ ;
    }
#line 3614
    goto switch_break;
    case_100: /* CIL Label */ 
#line 3619
    count = (size_t )1;
#line 3619
    if ((int const   )*format == 42) {
      {
#line 3619
      format ++;
#line 3619
      tmp___141 = __builtin_va_arg(args, int );
#line 3619
      count = (size_t )tmp___141;
      }
    } else {
      {
#line 3619
      tmp___143 = __ctype_b_loc();
      }
#line 3619
      if ((int const   )*(*tmp___143 + (int )((unsigned int )*format)) & 2048) {
#line 3619
        count = (size_t )0;
        {
#line 3619
        while (1) {
          while_continue___21: /* CIL Label */ ;
          {
#line 3619
          tmp___142 = __ctype_b_loc();
          }
#line 3619
          if (! ((int const   )*(*tmp___142 + (int )((unsigned int )*format)) & 2048)) {
#line 3619
            goto while_break___21;
          }
#line 3619
          count *= 10UL;
#line 3619
          count += (size_t )((int const   )*format - 48);
#line 3619
          format ++;
        }
        while_break___21: /* CIL Label */ ;
        }
      }
    }
#line 3619
    if ((ssize_t )count < 1L) {
      {
#line 3619
      tmp___144 = set_errno(22);
      }
#line 3619
      return ((ssize_t )tmp___144);
    }
    {
#line 3620
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 3620
      tmp___150 = count;
#line 3620
      count --;
#line 3620
      if (! tmp___150) {
#line 3620
        goto while_break___22;
      }
      {
#line 3622
      tmp___146 = __builtin_va_arg(args, double *);
#line 3622
      data___10 = tmp___146;
      }
#line 3624
      if ((unsigned long )(p + 1) > (unsigned long )(pkt + size)) {
        {
#line 3624
        tmp___147 = set_errno(28);
        }
#line 3624
        return ((ssize_t )tmp___147);
      }
#line 3625
      tmp___148 = p;
#line 3625
      p ++;
#line 3625
      len___1 = (size_t )*tmp___148;
#line 3626
      if ((unsigned long )(p + len___1) > (unsigned long )(pkt + size)) {
        {
#line 3626
        tmp___149 = set_errno(28);
        }
#line 3626
        return ((ssize_t )tmp___149);
      }
#line 3627
      if (! data___10) {
#line 3627
        p += len___1;
#line 3627
        goto while_continue___22;
      }
      {
#line 3628
      sscanf((char const   */* __restrict  */)((char const   *)p), (char const   */* __restrict  */)"%lg",
             data___10);
#line 3629
      p += len___1;
      }
    }
    while_break___22: /* CIL Label */ ;
    }
#line 3632
    goto switch_break;
    case_120: /* CIL Label */ 
#line 3637
    count = (size_t )1;
#line 3637
    if ((int const   )*format == 42) {
      {
#line 3637
      format ++;
#line 3637
      tmp___152 = __builtin_va_arg(args, int );
#line 3637
      count = (size_t )tmp___152;
      }
    } else {
      {
#line 3637
      tmp___154 = __ctype_b_loc();
      }
#line 3637
      if ((int const   )*(*tmp___154 + (int )((unsigned int )*format)) & 2048) {
#line 3637
        count = (size_t )0;
        {
#line 3637
        while (1) {
          while_continue___23: /* CIL Label */ ;
          {
#line 3637
          tmp___153 = __ctype_b_loc();
          }
#line 3637
          if (! ((int const   )*(*tmp___153 + (int )((unsigned int )*format)) & 2048)) {
#line 3637
            goto while_break___23;
          }
#line 3637
          count *= 10UL;
#line 3637
          count += (size_t )((int const   )*format - 48);
#line 3637
          format ++;
        }
        while_break___23: /* CIL Label */ ;
        }
      }
    }
#line 3637
    if ((ssize_t )count < 1L) {
      {
#line 3637
      tmp___155 = set_errno(22);
      }
#line 3637
      return ((ssize_t )tmp___155);
    }
#line 3638
    if ((unsigned long )(p + count) > (unsigned long )(pkt + size)) {
      {
#line 3638
      tmp___156 = set_errno(28);
      }
#line 3638
      return ((ssize_t )tmp___156);
    }
#line 3639
    p += count;
#line 3640
    goto switch_break;
    case_88: /* CIL Label */ 
#line 3645
    count = (size_t )1;
#line 3645
    if ((int const   )*format == 42) {
      {
#line 3645
      format ++;
#line 3645
      tmp___158 = __builtin_va_arg(args, int );
#line 3645
      count = (size_t )tmp___158;
      }
    } else {
      {
#line 3645
      tmp___160 = __ctype_b_loc();
      }
#line 3645
      if ((int const   )*(*tmp___160 + (int )((unsigned int )*format)) & 2048) {
#line 3645
        count = (size_t )0;
        {
#line 3645
        while (1) {
          while_continue___24: /* CIL Label */ ;
          {
#line 3645
          tmp___159 = __ctype_b_loc();
          }
#line 3645
          if (! ((int const   )*(*tmp___159 + (int )((unsigned int )*format)) & 2048)) {
#line 3645
            goto while_break___24;
          }
#line 3645
          count *= 10UL;
#line 3645
          count += (size_t )((int const   )*format - 48);
#line 3645
          format ++;
        }
        while_break___24: /* CIL Label */ ;
        }
      }
    }
#line 3645
    if ((ssize_t )count < 1L) {
      {
#line 3645
      tmp___161 = set_errno(22);
      }
#line 3645
      return ((ssize_t )tmp___161);
    }
#line 3646
    if ((unsigned long )(p - count) < (unsigned long )pkt) {
      {
#line 3647
      tmp___162 = set_errno(22);
      }
#line 3647
      return ((ssize_t )tmp___162);
    }
#line 3648
    p -= count;
#line 3649
    goto switch_break;
    case_64: /* CIL Label */ 
#line 3654
    count = (size_t )1;
#line 3654
    if ((int const   )*format == 42) {
      {
#line 3654
      format ++;
#line 3654
      tmp___164 = __builtin_va_arg(args, int );
#line 3654
      count = (size_t )tmp___164;
      }
    } else {
      {
#line 3654
      tmp___166 = __ctype_b_loc();
      }
#line 3654
      if ((int const   )*(*tmp___166 + (int )((unsigned int )*format)) & 2048) {
#line 3654
        count = (size_t )0;
        {
#line 3654
        while (1) {
          while_continue___25: /* CIL Label */ ;
          {
#line 3654
          tmp___165 = __ctype_b_loc();
          }
#line 3654
          if (! ((int const   )*(*tmp___165 + (int )((unsigned int )*format)) & 2048)) {
#line 3654
            goto while_break___25;
          }
#line 3654
          count *= 10UL;
#line 3654
          count += (size_t )((int const   )*format - 48);
#line 3654
          format ++;
        }
        while_break___25: /* CIL Label */ ;
        }
      }
    }
#line 3654
    if ((ssize_t )count < 1L) {
      {
#line 3654
      tmp___167 = set_errno(22);
      }
#line 3654
      return ((ssize_t )tmp___167);
    }
#line 3655
    if (count > size) {
      {
#line 3656
      tmp___168 = set_errno(28);
      }
#line 3656
      return ((ssize_t )tmp___168);
    }
#line 3657
    if ((unsigned long )(pkt + count) < (unsigned long )p) {
      {
#line 3658
      tmp___169 = set_errno(22);
      }
#line 3658
      return ((ssize_t )tmp___169);
    }
#line 3659
    p += count - (size_t )(p - pkt);
#line 3660
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 3665
    tmp___170 = set_errno(22);
    }
#line 3665
    return ((ssize_t )tmp___170);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3670
  return (p - pkt);
}
}
#line 3687 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
ssize_t net_read(int sockfd , long timeout___0 , char *buf , size_t count ) 
{ 
  char *b ;
  ssize_t bytes ;
  int tmp ;

  {
#line 3692
  b = buf;
  {
#line 3692
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3692
    if (! count) {
#line 3692
      goto while_break;
    }
    {
#line 3694
    tmp = read_timeout(sockfd, timeout___0, 0L);
    }
#line 3694
    if (tmp == -1) {
#line 3695
      return ((ssize_t )-1);
    }
    {
#line 3697
    bytes = read(sockfd, (void *)b, count);
    }
#line 3697
    if (bytes == -1L) {
#line 3698
      return ((ssize_t )-1);
    }
#line 3700
    if (bytes == 0L) {
#line 3701
      goto while_break;
    }
#line 3692
    count -= (size_t )bytes;
#line 3692
    b += bytes;
  }
  while_break: /* CIL Label */ ;
  }
#line 3704
  return (b - buf);
}
}
#line 3720 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
ssize_t net_write(int sockfd , long timeout___0 , char const   *buf , size_t count ) 
{ 
  char const   *b ;
  ssize_t bytes ;
  int tmp ;

  {
#line 3725
  b = buf;
  {
#line 3725
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3725
    if (! count) {
#line 3725
      goto while_break;
    }
    {
#line 3727
    tmp = write_timeout(sockfd, timeout___0, 0L);
    }
#line 3727
    if (tmp == -1) {
#line 3728
      return ((ssize_t )-1);
    }
    {
#line 3730
    bytes = write(sockfd, (void const   *)b, count);
    }
#line 3730
    if (bytes <= 0L) {
#line 3731
      return (bytes);
    }
#line 3725
    count -= (size_t )bytes;
#line 3725
    b += bytes;
  }
  while_break: /* CIL Label */ ;
  }
#line 3734
  return (b - buf);
}
}
#line 3761 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
ssize_t net_expect(int sockfd , long timeout___0 , char const   *format  , ...) 
{ 
  va_list args ;
  ssize_t rc ;

  {
  {
#line 3766
  __builtin_va_start(args, format);
#line 3767
  rc = net_vexpect(sockfd, timeout___0, format, args);
#line 3768
  __builtin_va_end(args);
  }
#line 3770
  return (rc);
}
}
#line 3784 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
ssize_t net_vexpect(int sockfd , long timeout___0 , char const   *format , va_list args ) 
{ 
  char buf[8193] ;
  ssize_t bytes ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp9 ;

  {
  {
#line 3789
  tmp = read_timeout(sockfd, timeout___0, 0L);
  }
#line 3789
  if (tmp == -1) {
#line 3790
    return ((ssize_t )-1);
  }
  {
#line 3792
  bytes = read(sockfd, (void *)(buf), (size_t )8192);
  }
#line 3792
  if (bytes <= 0L) {
#line 3793
    return (bytes);
  }
  {
#line 3795
  buf[bytes] = (char )'\000';
#line 3797
  tmp___0 = vsscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)format,
                    args);
  }
#line 3797
  return ((ssize_t )tmp___0);
}
}
#line 3813 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
ssize_t net_send(int sockfd , long timeout___0 , char const   *format  , ...) 
{ 
  va_list args ;
  ssize_t rc ;

  {
  {
#line 3818
  __builtin_va_start(args, format);
#line 3819
  rc = net_vsend(sockfd, timeout___0, format, args);
#line 3820
  __builtin_va_end(args);
  }
#line 3822
  return (rc);
}
}
#line 3836 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
ssize_t net_vsend(int sockfd , long timeout___0 , char const   *format , va_list args ) 
{ 
  char buf[8193] ;
  ssize_t bytes ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  void *__cil_tmp10 ;

  {
  {
#line 3841
  tmp = vsnprintf((char */* __restrict  */)(buf), (size_t )8193, (char const   */* __restrict  */)format,
                  args);
#line 3841
  bytes = (ssize_t )tmp;
  }
#line 3842
  if (bytes == -1L) {
    {
#line 3843
    tmp___0 = set_errno(28);
    }
#line 3843
    return ((ssize_t )tmp___0);
  } else
#line 3842
  if (bytes > 8192L) {
    {
#line 3843
    tmp___0 = set_errno(28);
    }
#line 3843
    return ((ssize_t )tmp___0);
  }
  {
#line 3845
  tmp___1 = net_write(sockfd, timeout___0, (char const   *)(buf), (size_t )bytes);
  }
#line 3845
  return (tmp___1);
}
}
#line 3872 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
ssize_t sendfd(int sockfd , void const   *buf , size_t nbytes , int flags , int fd ) 
{ 
  struct msghdr mesg[1] ;
  struct iovec iov[1] ;
  union __anonunion_control_83 control ;
  struct cmsghdr *cmsg ;
  int tmp ;
  ssize_t tmp___0 ;
  void *__cil_tmp12 ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 3902
  if (sockfd < 0) {
    {
#line 3903
    tmp = set_errno(22);
    }
#line 3903
    return ((ssize_t )tmp);
  } else
#line 3902
  if (fd < 0) {
    {
#line 3903
    tmp = set_errno(22);
    }
#line 3903
    return ((ssize_t )tmp);
  }
#line 3905
  mesg[0].msg_control = (void *)(control.control);
#line 3906
  mesg[0].msg_controllen = sizeof(control.control);
#line 3908
  if (mesg[0].msg_controllen >= sizeof(struct cmsghdr )) {
#line 3908
    cmsg = (struct cmsghdr *)mesg[0].msg_control;
  } else {
#line 3908
    cmsg = (struct cmsghdr *)0;
  }
  {
#line 3909
  cmsg->cmsg_len = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + sizeof(int );
#line 3910
  cmsg->cmsg_level = 1;
#line 3911
  cmsg->cmsg_type = 1;
#line 3913
  *((int *)((unsigned char *)(cmsg + 1))) = fd;
#line 3922
  mesg[0].msg_name = (void *)0;
#line 3923
  mesg[0].msg_namelen = (socklen_t )0;
#line 3925
  mesg[0].msg_iov = iov;
#line 3926
  mesg[0].msg_iovlen = (size_t )1;
#line 3928
  iov[0].iov_base = (void *)buf;
#line 3929
  iov[0].iov_len = nbytes;
#line 3931
  tmp___0 = sendmsg(sockfd, (struct msghdr  const  *)(mesg), flags);
  }
#line 3931
  return (tmp___0);
}
}
#line 3960 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
ssize_t recvfd(int sockfd , void *buf , size_t nbytes , int flags , int *fd ) 
{ 
  struct msghdr mesg[1] ;
  struct iovec iov[1] ;
  ssize_t rc ;
  union __anonunion_control_84 control ;
  struct cmsghdr *cmsg ;
  int tmp ;
  void *__cil_tmp12 ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 3977
  mesg[0].msg_control = (void *)(control.control);
#line 3978
  mesg[0].msg_controllen = sizeof(control.control);
#line 3989
  if (sockfd < 0) {
    {
#line 3990
    tmp = set_errno(22);
    }
#line 3990
    return ((ssize_t )tmp);
  } else
#line 3989
  if (! fd) {
    {
#line 3990
    tmp = set_errno(22);
    }
#line 3990
    return ((ssize_t )tmp);
  }
  {
#line 3992
  mesg[0].msg_name = (void *)0;
#line 3993
  mesg[0].msg_namelen = (socklen_t )0;
#line 3995
  mesg[0].msg_iov = iov;
#line 3996
  mesg[0].msg_iovlen = (size_t )1;
#line 3998
  iov[0].iov_base = buf;
#line 3999
  iov[0].iov_len = nbytes;
#line 4001
  rc = recvmsg(sockfd, mesg, flags);
  }
#line 4001
  if (rc <= 0L) {
#line 4002
    return ((ssize_t )-1);
  }
#line 4006
  *fd = -1;
#line 4008
  if (mesg[0].msg_controllen >= sizeof(struct cmsghdr )) {
#line 4008
    cmsg = (struct cmsghdr *)mesg[0].msg_control;
  } else {
#line 4008
    cmsg = (struct cmsghdr *)0;
  }
#line 4008
  if (cmsg) {
#line 4008
    if (cmsg->cmsg_len == (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + sizeof(int )) {
#line 4010
      if (cmsg->cmsg_level == 1) {
#line 4010
        if (cmsg->cmsg_type == 1) {
#line 4011
          *fd = *((int *)((unsigned char *)(cmsg + 1)));
        }
      }
    }
  }
#line 4020
  return (rc);
}
}
#line 4112 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
static int rcpt(int smtp , char const   *recipients ) 
{ 
  List *list ;
  List *tmp ;
  ssize_t tmp___0 ;
  char *recipient ;
  void *tmp___1 ;
  char *tmp___2 ;
  int rc ;
  int code ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 4114
  tmp = split(recipients, ", ");
#line 4114
  list = tmp;
  }
#line 4116
  if (! list) {
#line 4117
    return (-1);
  } else {
    {
#line 4116
    tmp___0 = list_length((List const   *)list);
    }
#line 4116
    if (tmp___0 <= 0L) {
#line 4117
      return (-1);
    }
  }
  {
#line 4119
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4119
    tmp___6 = list_has_next(list);
    }
#line 4119
    if (! (tmp___6 == 1)) {
#line 4119
      goto while_break;
    }
    {
#line 4121
    tmp___1 = list_next(list);
#line 4121
    tmp___2 = cstr((String const   *)((String *)tmp___1));
#line 4121
    recipient = tmp___2;
#line 4124
    tmp___3 = net_send(smtp, 10L, "RCPT TO: <%s>\r\n", recipient);
    }
#line 4124
    if (tmp___3 == -1L) {
      {
#line 4127
      list_release(list);
      }
#line 4128
      return (-1);
    } else {
      {
#line 4124
      tmp___4 = net_expect(smtp, 10L, "%d", & code);
#line 4124
      rc = (int )tmp___4;
      }
#line 4124
      if (rc == -1) {
        {
#line 4127
        list_release(list);
        }
#line 4128
        return (-1);
      }
    }
#line 4131
    if (rc != 1) {
      {
#line 4133
      list_release(list);
#line 4134
      tmp___5 = set_errno(71);
      }
#line 4134
      return (tmp___5);
    } else
#line 4131
    if (code != 250) {
      {
#line 4133
      list_release(list);
#line 4134
      tmp___5 = set_errno(71);
      }
#line 4134
      return (tmp___5);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4138
  list_release(list);
  }
#line 4139
  return (0);
}
}
#line 4142 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/net.c"
int mail(char const   *server , char const   *sender , char const   *recipients ,
         char const   *subject , char const   *message ) 
{ 
  int smtp ;
  int code ;
  int rc ;
  char c ;
  int tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;
  ssize_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  ssize_t tmp___11 ;
  ssize_t tmp___12 ;
  int tmp___13 ;
  ssize_t tmp___14 ;
  ssize_t tmp___15 ;
  char const   *tmp___16 ;
  ssize_t tmp___17 ;
  char const   *tmp___18 ;
  ssize_t tmp___19 ;
  ssize_t tmp___20 ;
  int tmp___21 ;
  ssize_t tmp___22 ;
  ssize_t tmp___23 ;
  int tmp___24 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;

  {
#line 4149
  if (! sender) {
    {
#line 4150
    tmp = set_errno(22);
    }
#line 4150
    return (tmp);
  } else
#line 4149
  if (! recipients) {
    {
#line 4150
    tmp = set_errno(22);
    }
#line 4150
    return (tmp);
  }
  {
#line 4152
  smtp = net_client(server, "smtp", (sockport_t )25, 5L, 0, 0, (sockaddr_t *)((void *)0),
                    (size_t *)((void *)0));
  }
#line 4152
  if (smtp == -1) {
#line 4153
    return (-1);
  }
  {
#line 4161
  net_tos_lowdelay(smtp);
#line 4163
  tmp___0 = net_expect(smtp, 10L, "%d%c", & code, & c);
#line 4163
  rc = (int )tmp___0;
  }
#line 4163
  if (rc == -1) {
    {
#line 4163
    close(smtp);
    }
#line 4163
    return (-1);
  }
#line 4163
  if (rc != 2) {
    {
#line 4163
    close(smtp);
#line 4163
    tmp___1 = set_errno(71);
    }
#line 4163
    return (tmp___1);
  } else
#line 4163
  if (code != 220) {
    {
#line 4163
    close(smtp);
#line 4163
    tmp___1 = set_errno(71);
    }
#line 4163
    return (tmp___1);
  }
  {
#line 4165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4165
    if (! ((int )c == 45)) {
#line 4165
      goto while_break;
    }
    {
#line 4166
    tmp___2 = net_expect(smtp, 10L, "%d%c", & code, & c);
#line 4166
    rc = (int )tmp___2;
    }
#line 4166
    if (rc == -1) {
      {
#line 4166
      close(smtp);
      }
#line 4166
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4166
  if (rc != 2) {
    {
#line 4166
    close(smtp);
#line 4166
    tmp___3 = set_errno(71);
    }
#line 4166
    return (tmp___3);
  } else
#line 4166
  if (code != 220) {
    {
#line 4166
    close(smtp);
#line 4166
    tmp___3 = set_errno(71);
    }
#line 4166
    return (tmp___3);
  }
  {
#line 4168
  tmp___4 = net_send(smtp, 10L, "HELO localhost\r\n");
  }
#line 4168
  if (tmp___4 == -1L) {
    {
#line 4168
    close(smtp);
    }
#line 4168
    return (-1);
  }
  {
#line 4169
  tmp___5 = net_expect(smtp, 10L, "%d", & code);
#line 4169
  rc = (int )tmp___5;
  }
#line 4169
  if (rc == -1) {
    {
#line 4169
    close(smtp);
    }
#line 4169
    return (-1);
  }
#line 4169
  if (rc != 1) {
    {
#line 4169
    close(smtp);
#line 4169
    tmp___6 = set_errno(71);
    }
#line 4169
    return (tmp___6);
  } else
#line 4169
  if (code != 250) {
    {
#line 4169
    close(smtp);
#line 4169
    tmp___6 = set_errno(71);
    }
#line 4169
    return (tmp___6);
  }
  {
#line 4170
  tmp___7 = net_send(smtp, 10L, "MAIL FROM: <%s>\r\n", sender);
  }
#line 4170
  if (tmp___7 == -1L) {
    {
#line 4170
    close(smtp);
    }
#line 4170
    return (-1);
  }
  {
#line 4171
  tmp___8 = net_expect(smtp, 10L, "%d", & code);
#line 4171
  rc = (int )tmp___8;
  }
#line 4171
  if (rc == -1) {
    {
#line 4171
    close(smtp);
    }
#line 4171
    return (-1);
  }
#line 4171
  if (rc != 1) {
    {
#line 4171
    close(smtp);
#line 4171
    tmp___9 = set_errno(71);
    }
#line 4171
    return (tmp___9);
  } else
#line 4171
  if (code != 250) {
    {
#line 4171
    close(smtp);
#line 4171
    tmp___9 = set_errno(71);
    }
#line 4171
    return (tmp___9);
  }
  {
#line 4172
  tmp___10 = rcpt(smtp, recipients);
  }
#line 4172
  if (tmp___10 == -1) {
    {
#line 4172
    close(smtp);
    }
#line 4172
    return (-1);
  }
  {
#line 4173
  tmp___11 = net_send(smtp, 10L, "DATA\r\n");
  }
#line 4173
  if (tmp___11 == -1L) {
    {
#line 4173
    close(smtp);
    }
#line 4173
    return (-1);
  }
  {
#line 4174
  tmp___12 = net_expect(smtp, 10L, "%d", & code);
#line 4174
  rc = (int )tmp___12;
  }
#line 4174
  if (rc == -1) {
    {
#line 4174
    close(smtp);
    }
#line 4174
    return (-1);
  }
#line 4174
  if (rc != 1) {
    {
#line 4174
    close(smtp);
#line 4174
    tmp___13 = set_errno(71);
    }
#line 4174
    return (tmp___13);
  } else
#line 4174
  if (code != 354) {
    {
#line 4174
    close(smtp);
#line 4174
    tmp___13 = set_errno(71);
    }
#line 4174
    return (tmp___13);
  }
  {
#line 4176
  net_tos_throughput(smtp);
#line 4178
  tmp___14 = net_send(smtp, 10L, "From: %s\r\n", sender);
  }
#line 4178
  if (tmp___14 == -1L) {
    {
#line 4178
    close(smtp);
    }
#line 4178
    return (-1);
  }
  {
#line 4179
  tmp___15 = net_send(smtp, 10L, "To: %s\r\n", recipients);
  }
#line 4179
  if (tmp___15 == -1L) {
    {
#line 4179
    close(smtp);
    }
#line 4179
    return (-1);
  }
#line 4180
  if (subject) {
#line 4180
    tmp___16 = subject;
  } else {
#line 4180
    tmp___16 = "";
  }
  {
#line 4180
  tmp___17 = net_send(smtp, 10L, "Subject: %s\r\n\r\n", tmp___16);
  }
#line 4180
  if (tmp___17 == -1L) {
    {
#line 4180
    close(smtp);
    }
#line 4180
    return (-1);
  }
#line 4181
  if (message) {
#line 4181
    tmp___18 = message;
  } else {
#line 4181
    tmp___18 = "";
  }
  {
#line 4181
  tmp___19 = net_send(smtp, 10L, "%s\r\n.\r\n", tmp___18);
  }
#line 4181
  if (tmp___19 == -1L) {
    {
#line 4181
    close(smtp);
    }
#line 4181
    return (-1);
  }
  {
#line 4182
  tmp___20 = net_expect(smtp, 10L, "%d", & code);
#line 4182
  rc = (int )tmp___20;
  }
#line 4182
  if (rc == -1) {
    {
#line 4182
    close(smtp);
    }
#line 4182
    return (-1);
  }
#line 4182
  if (rc != 1) {
    {
#line 4182
    close(smtp);
#line 4182
    tmp___21 = set_errno(71);
    }
#line 4182
    return (tmp___21);
  } else
#line 4182
  if (code != 250) {
    {
#line 4182
    close(smtp);
#line 4182
    tmp___21 = set_errno(71);
    }
#line 4182
    return (tmp___21);
  }
  {
#line 4184
  net_tos_lowdelay(smtp);
#line 4186
  tmp___22 = net_send(smtp, 10L, "QUIT\r\n");
  }
#line 4186
  if (tmp___22 == -1L) {
    {
#line 4186
    close(smtp);
    }
#line 4186
    return (-1);
  }
  {
#line 4187
  tmp___23 = net_expect(smtp, 10L, "%d", & code);
#line 4187
  rc = (int )tmp___23;
  }
#line 4187
  if (rc == -1) {
    {
#line 4187
    close(smtp);
    }
#line 4187
    return (-1);
  }
#line 4187
  if (rc != 1) {
    {
#line 4187
    close(smtp);
#line 4187
    tmp___24 = set_errno(71);
    }
#line 4187
    return (tmp___24);
  } else
#line 4187
  if (code != 221) {
    {
#line 4187
    close(smtp);
#line 4187
    tmp___24 = set_errno(71);
    }
#line 4187
    return (tmp___24);
  }
  {
#line 4188
  close(smtp);
  }
#line 4190
  return (0);
}
}
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 43 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.h"
Msg *msg_create(int type , msg_out_t *out , void *data , msg_release_t *destroy ) ;
#line 44
Msg *msg_create_with_locker(Locker *locker , int type , msg_out_t *out , void *data ,
                            msg_release_t *destroy ) ;
#line 45
int msg_rdlock(Msg *mesg ) ;
#line 46
int msg_wrlock(Msg *mesg ) ;
#line 47
int msg_unlock(Msg *mesg ) ;
#line 49
void *msg_destroy(Msg **mesg ) ;
#line 51
void msg_out_unlocked(Msg *dst , char const   *format  , ...) ;
#line 52
void vmsg_out(Msg *dst , char const   *format , va_list args ) ;
#line 53
void vmsg_out_unlocked(Msg *dst , char const   *format , va_list args ) ;
#line 54
Msg *msg_create_fd(int fd ) ;
#line 56
Msg *msg_create_stderr(void) ;
#line 57
Msg *msg_create_stderr_with_locker(Locker *locker ) ;
#line 58
Msg *msg_create_stdout(void) ;
#line 59
Msg *msg_create_stdout_with_locker(Locker *locker ) ;
#line 60
Msg *msg_create_file(char const   *path ) ;
#line 62
Msg *msg_create_syslog(char const   *ident , int option , int facility , int priority ) ;
#line 64
Msg *msg_syslog_set_facility(Msg *mesg , int facility ) ;
#line 65
Msg *msg_syslog_set_facility_unlocked(Msg *mesg , int facility ) ;
#line 66
Msg *msg_syslog_set_priority(Msg *mesg , int priority ) ;
#line 67
Msg *msg_syslog_set_priority_unlocked(Msg *mesg , int priority ) ;
#line 68
Msg *msg_create_plex(Msg *msg1 , Msg *msg2 ) ;
#line 69
Msg *msg_create_plex_with_locker(Locker *locker , Msg *msg1 , Msg *msg2 ) ;
#line 70
int msg_add_plex(Msg *mesg , Msg *item ) ;
#line 71
int msg_add_plex_unlocked(Msg *mesg , Msg *item ) ;
#line 72
char const   *msg_set_timestamp_format(char const   *format ) ;
#line 73
int msg_set_timestamp_format_locker(Locker *locker ) ;
#line 74
int syslog_lookup_facility(char const   *facility ) ;
#line 75
int syslog_lookup_priority(char const   *priority ) ;
#line 76
char const   *syslog_facility_str(int spec ) ;
#line 77
char const   *syslog_priority_str(int spec ) ;
#line 78
int syslog_parse(char const   *spec , int *facility , int *priority ) ;
#line 173 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
static syslog_map_t const   syslog_facility_map[19]  = 
#line 173 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
  {      {(char *)"kern", 0}, 
        {(char *)"user", 1 << 3}, 
        {(char *)"mail", 2 << 3}, 
        {(char *)"daemon", 3 << 3}, 
        {(char *)"auth", 4 << 3}, 
        {(char *)"syslog", 5 << 3}, 
        {(char *)"lpr", 6 << 3}, 
        {(char *)"news", 7 << 3}, 
        {(char *)"uucp", 8 << 3}, 
        {(char *)"cron", 9 << 3}, 
        {(char *)"local0", 16 << 3}, 
        {(char *)"local1", 17 << 3}, 
        {(char *)"local2", 18 << 3}, 
        {(char *)"local3", 19 << 3}, 
        {(char *)"local4", 20 << 3}, 
        {(char *)"local5", 21 << 3}, 
        {(char *)"local6", 22 << 3}, 
        {(char *)"local7", 23 << 3}, 
        {(char *)((void *)0), -1}};
#line 196 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
static syslog_map_t const   syslog_priority_map[9]  = 
#line 196
  {      {(char *)"emerg", 0}, 
        {(char *)"alert", 1}, 
        {(char *)"crit", 2}, 
        {(char *)"err", 3}, 
        {(char *)"warning", 4}, 
        {(char *)"notice", 5}, 
        {(char *)"info", 6}, 
        {(char *)"debug", 7}, 
        {(char *)((void *)0), -1}};
#line 213 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
static char const   *timestamp_format  =    "%Y%m%d %H:%M:%S ";
#line 214 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
static Locker *timestamp_format_locker  =    (Locker *)((void *)0);
#line 230 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
Msg *msg_create(int type , msg_out_t *out , void *data , msg_release_t *destroy ) 
{ 
  Msg *tmp ;

  {
  {
#line 232
  tmp = msg_create_with_locker((Locker *)((void *)0), type, out, data, destroy);
  }
#line 232
  return (tmp);
}
}
#line 246 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
Msg *msg_create_with_locker(Locker *locker , int type , msg_out_t *out , void *data ,
                            msg_release_t *destroy ) 
{ 
  Msg *mesg ;
  void *tmp ;

  {
  {
#line 250
  tmp = malloc(sizeof(Msg ));
#line 250
  mesg = (Msg *)tmp;
  }
#line 250
  if (! mesg) {
#line 251
    return ((Msg *)((void *)0));
  }
#line 253
  mesg->type = type;
#line 254
  mesg->out = out;
#line 255
  mesg->data = data;
#line 256
  mesg->destroy = destroy;
#line 257
  mesg->locker = locker;
#line 259
  return (mesg);
}
}
#line 282 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
int msg_rdlock(Msg *mesg ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 284
  if (mesg) {
#line 284
    if (mesg->locker) {
      {
#line 284
      tmp = (*((mesg->locker)->rdlock))((mesg->locker)->lock);
#line 284
      tmp___0 = tmp;
      }
    } else {
#line 284
      tmp___0 = 0;
    }
#line 284
    tmp___1 = tmp___0;
  } else {
#line 284
    tmp___1 = 22;
  }
#line 284
  return (tmp___1);
}
}
#line 305 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
int msg_wrlock(Msg *mesg ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 307
  if (mesg) {
#line 307
    if (mesg->locker) {
      {
#line 307
      tmp = (*((mesg->locker)->wrlock))((mesg->locker)->lock);
#line 307
      tmp___0 = tmp;
      }
    } else {
#line 307
      tmp___0 = 0;
    }
#line 307
    tmp___1 = tmp___0;
  } else {
#line 307
    tmp___1 = 22;
  }
#line 307
  return (tmp___1);
}
}
#line 322 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
int msg_unlock(Msg *mesg ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 324
  if (mesg) {
#line 324
    if (mesg->locker) {
      {
#line 324
      tmp = (*((mesg->locker)->unlock))((mesg->locker)->lock);
#line 324
      tmp___0 = tmp;
      }
    } else {
#line 324
      tmp___0 = 0;
    }
#line 324
    tmp___1 = tmp___0;
  } else {
#line 324
    tmp___1 = 22;
  }
#line 324
  return (tmp___1);
}
}
#line 337 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
void msg_release(Msg *mesg ) 
{ 


  {
#line 339
  if (! mesg) {
#line 340
    return;
  }
#line 342
  if (mesg->destroy) {
    {
#line 343
    (*(mesg->destroy))(mesg->data);
    }
  }
  {
#line 345
  free((void *)mesg);
  }
#line 346
  return;
}
}
#line 358 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
void *msg_destroy(Msg **mesg ) 
{ 


  {
#line 360
  if (mesg) {
#line 360
    if (*mesg) {
      {
#line 362
      msg_release(*mesg);
#line 363
      *mesg = (Msg *)((void *)0);
      }
    }
  }
#line 366
  return ((void *)0);
}
}
#line 389 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
void msg_out(Msg *dst , char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 392
  __builtin_va_start(args, format);
#line 393
  vmsg_out(dst, format, args);
#line 394
  __builtin_va_end(args);
  }
#line 395
  return;
}
}
#line 407 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
void msg_out_unlocked(Msg *dst , char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 410
  __builtin_va_start(args, format);
#line 411
  vmsg_out_unlocked(dst, format, args);
#line 412
  __builtin_va_end(args);
  }
#line 413
  return;
}
}
#line 426 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
void vmsg_out(Msg *dst , char const   *format , va_list args ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 430
  if (! dst) {
#line 431
    return;
  }
#line 433
  if (dst) {
#line 433
    if (dst->locker) {
      {
#line 433
      tmp = (*((dst->locker)->rdlock))((dst->locker)->lock);
#line 433
      tmp___0 = tmp;
      }
    } else {
#line 433
      tmp___0 = 0;
    }
#line 433
    err = tmp___0;
  } else {
#line 433
    err = 22;
  }
#line 433
  if (err) {
    {
#line 435
    set_errno(err);
    }
#line 436
    return;
  }
  {
#line 439
  vmsg_out_unlocked(dst, format, args);
  }
#line 441
  if (dst) {
#line 441
    if (dst->locker) {
      {
#line 441
      tmp___1 = (*((dst->locker)->unlock))((dst->locker)->lock);
#line 441
      tmp___2 = tmp___1;
      }
    } else {
#line 441
      tmp___2 = 0;
    }
#line 441
    err = tmp___2;
  } else {
#line 441
    err = 22;
  }
#line 441
  if (err) {
    {
#line 442
    set_errno(err);
    }
  }
#line 443
  return;
}
}
#line 455 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
void vmsg_out_unlocked(Msg *dst , char const   *format , va_list args ) 
{ 
  char mesg[8192] ;
  size_t tmp ;
  void *__cil_tmp6 ;

  {
#line 457
  if (! dst) {
#line 458
    return;
  }
#line 460
  if (dst->out) {
    {
#line 463
    vsnprintf((char */* __restrict  */)(mesg), (size_t )8192, (char const   */* __restrict  */)format,
              args);
#line 464
    tmp = strlen((char const   *)(mesg));
#line 464
    (*(dst->out))(dst->data, (void const   *)(mesg), tmp);
    }
  }
#line 466
  return;
}
}
#line 478 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
static MsgFDData *msg_fddata_create(int fd ) 
{ 
  MsgFDData *data ;
  void *tmp ;

  {
  {
#line 482
  tmp = malloc(sizeof(MsgFDData ));
#line 482
  data = (MsgFDData *)tmp;
  }
#line 482
  if (! data) {
#line 483
    return ((MsgFDData *)((void *)0));
  }
#line 485
  *data = fd;
#line 487
  return (data);
}
}
#line 499 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
static void msg_fddata_release(MsgFDData *data ) 
{ 


  {
  {
#line 501
  free((void *)data);
  }
#line 502
  return;
}
}
#line 513 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
static void msg_out_fd(void *data , void const   *mesg , size_t mesglen ) 
{ 
  ssize_t tmp ;

  {
#line 515
  if (data) {
#line 515
    if (mesg) {
      {
#line 516
      tmp = write(*((MsgFDData *)data), mesg, mesglen);
      }
    }
  }
#line 518
  return;
}
}
#line 533 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
Msg *msg_create_fd(int fd ) 
{ 
  Msg *tmp ;

  {
  {
#line 535
  tmp = msg_create_fd_with_locker((Locker *)((void *)0), fd);
  }
#line 535
  return (tmp);
}
}
#line 549 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
Msg *msg_create_fd_with_locker(Locker *locker , int fd ) 
{ 
  MsgFDData *data ;
  Msg *mesg ;

  {
  {
#line 554
  data = msg_fddata_create(fd);
  }
#line 554
  if (! data) {
#line 555
    return ((Msg *)((void *)0));
  }
  {
#line 557
  mesg = msg_create_with_locker(locker, 1, & msg_out_fd, (void *)data, (msg_release_t *)(& msg_fddata_release));
  }
#line 557
  if (! mesg) {
    {
#line 559
    msg_fddata_release(data);
    }
#line 560
    return ((Msg *)((void *)0));
  }
#line 563
  return (mesg);
}
}
#line 579 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
Msg *msg_create_stderr(void) 
{ 
  Msg *tmp ;

  {
  {
#line 581
  tmp = msg_create_fd_with_locker((Locker *)((void *)0), 2);
  }
#line 581
  return (tmp);
}
}
#line 595 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
Msg *msg_create_stderr_with_locker(Locker *locker ) 
{ 
  Msg *tmp ;

  {
  {
#line 597
  tmp = msg_create_fd_with_locker(locker, 2);
  }
#line 597
  return (tmp);
}
}
#line 613 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
Msg *msg_create_stdout(void) 
{ 
  Msg *tmp ;

  {
  {
#line 615
  tmp = msg_create_fd_with_locker((Locker *)((void *)0), 1);
  }
#line 615
  return (tmp);
}
}
#line 629 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
Msg *msg_create_stdout_with_locker(Locker *locker ) 
{ 
  Msg *tmp ;

  {
  {
#line 631
  tmp = msg_create_fd_with_locker(locker, 1);
  }
#line 631
  return (tmp);
}
}
#line 646 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
static int msg_filedata_init(MsgFileData *data , char const   *path ) 
{ 
  mode_t mode ;
  int tmp ;
  int tmp___0 ;

  {
#line 650
  if (! data) {
    {
#line 651
    tmp = set_errno(22);
    }
#line 651
    return (tmp);
  } else
#line 650
  if (! path) {
    {
#line 651
    tmp = set_errno(22);
    }
#line 651
    return (tmp);
  }
  {
#line 653
  mode = (mode_t )((((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3));
#line 655
  tmp___0 = open(path, 1089, mode);
#line 655
  data->fd = tmp___0;
  }
#line 655
  if (tmp___0 == -1) {
#line 656
    return (-1);
  }
#line 658
  return (0);
}
}
#line 671 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
static MsgFileData *msg_filedata_create(char const   *path ) 
{ 
  MsgFileData *data ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 675
  tmp = malloc(sizeof(MsgFileData ));
#line 675
  data = (MsgFileData *)tmp;
  }
#line 675
  if (! data) {
#line 676
    return ((MsgFileData *)((void *)0));
  }
  {
#line 678
  tmp___0 = msg_filedata_init(data, path);
  }
#line 678
  if (tmp___0 == -1) {
    {
#line 680
    free((void *)data);
    }
#line 681
    return ((MsgFileData *)((void *)0));
  }
#line 684
  return (data);
}
}
#line 696 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
static void msg_filedata_release(MsgFileData *data ) 
{ 


  {
#line 698
  if (! data) {
#line 699
    return;
  }
#line 701
  if (data->fd != -1) {
    {
#line 702
    close(data->fd);
    }
  }
  {
#line 704
  free((void *)data);
  }
#line 705
  return;
}
}
#line 717 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
static void msg_out_file(void *data , void const   *mesg , size_t mesglen ) 
{ 
  MsgFileData *dst ;
  char buf[8192] ;
  size_t buflen ;
  int err ;
  time_t t ;
  time_t tmp ;
  int tmp___0 ;
  struct tm *tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  void *__cil_tmp14 ;

  {
  {
#line 719
  dst = (MsgFileData *)data;
#line 724
  tmp = time((time_t *)((void *)0));
#line 724
  t = tmp;
  }
#line 726
  if (timestamp_format_locker) {
    {
#line 726
    tmp___0 = (*(timestamp_format_locker->rdlock))(timestamp_format_locker->lock);
#line 726
    err = tmp___0;
    }
  } else {
#line 726
    err = 0;
  }
#line 726
  if (err) {
    {
#line 728
    set_errno(err);
    }
#line 729
    return;
  }
  {
#line 732
  tmp___1 = localtime((time_t const   *)(& t));
#line 732
  strftime((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)timestamp_format,
           (struct tm  const  */* __restrict  */)tmp___1);
  }
#line 734
  if (timestamp_format_locker) {
    {
#line 734
    tmp___2 = (*(timestamp_format_locker->unlock))(timestamp_format_locker->lock);
#line 734
    err = tmp___2;
    }
  } else {
#line 734
    err = 0;
  }
#line 734
  if (err) {
    {
#line 736
    set_errno(err);
    }
#line 737
    return;
  }
  {
#line 740
  buflen = strlen((char const   *)(buf));
  }
#line 741
  if (buflen + mesglen >= 8192UL) {
#line 742
    mesglen -= 8192UL - buflen;
  }
  {
#line 743
  memmove((void *)(buf + buflen), mesg, mesglen);
  }
#line 745
  if (mesg) {
#line 745
    if (dst) {
#line 745
      if (dst->fd != -1) {
        {
#line 746
        tmp___3 = write(dst->fd, (void const   *)(buf), buflen + mesglen);
        }
      }
    }
  }
#line 748
  return;
}
}
#line 763 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
Msg *msg_create_file(char const   *path ) 
{ 
  Msg *tmp ;

  {
  {
#line 765
  tmp = msg_create_file_with_locker((Locker *)((void *)0), path);
  }
#line 765
  return (tmp);
}
}
#line 779 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
Msg *msg_create_file_with_locker(Locker *locker , char const   *path ) 
{ 
  MsgFileData *data ;
  Msg *mesg ;

  {
  {
#line 784
  data = msg_filedata_create(path);
  }
#line 784
  if (! data) {
#line 785
    return ((Msg *)((void *)0));
  }
  {
#line 787
  mesg = msg_create_with_locker(locker, 2, & msg_out_file, (void *)data, (msg_release_t *)(& msg_filedata_release));
  }
#line 787
  if (! mesg) {
    {
#line 789
    msg_filedata_release(data);
    }
#line 790
    return ((Msg *)((void *)0));
  }
#line 793
  return (mesg);
}
}
#line 808 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
static int msg_sysdata_init(MsgSyslogData *data , char const   *ident , int option ,
                            int facility , int priority ) 
{ 
  int tmp ;

  {
#line 810
  if (! data) {
    {
#line 811
    tmp = set_errno(22);
    }
#line 811
    return (tmp);
  } else
#line 810
  if (facility == -1) {
    {
#line 811
    tmp = set_errno(22);
    }
#line 811
    return (tmp);
  }
  {
#line 813
  data->facility = facility & 1016;
#line 814
  data->priority = priority & 7;
#line 816
  openlog(ident, option, 0);
  }
#line 818
  return (0);
}
}
#line 832 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
static MsgSyslogData *msg_sysdata_create(char const   *ident , int option , int facility ,
                                         int priority ) 
{ 
  MsgSyslogData *data ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 836
  tmp = malloc(sizeof(MsgSyslogData ));
#line 836
  data = (MsgSyslogData *)tmp;
  }
#line 836
  if (! data) {
#line 837
    return ((MsgSyslogData *)((void *)0));
  }
  {
#line 839
  tmp___0 = msg_sysdata_init(data, ident, option, facility, priority);
  }
#line 839
  if (tmp___0 == -1) {
    {
#line 841
    free((void *)data);
    }
#line 842
    return ((MsgSyslogData *)((void *)0));
  }
#line 845
  return (data);
}
}
#line 857 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
static void msg_sysdata_release(MsgSyslogData *data ) 
{ 


  {
#line 859
  if (! data) {
#line 860
    return;
  }
  {
#line 862
  free((void *)data);
#line 863
  closelog();
  }
#line 864
  return;
}
}
#line 875 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
static void msg_out_syslog(void *data , void const   *mesg , size_t mesglen ) 
{ 
  MsgSyslogData *dst ;
  char *__cil_tmp5 ;

  {
#line 877
  dst = (MsgSyslogData *)data;
#line 879
  if (mesg) {
#line 879
    if (dst) {
#line 879
      if (dst->facility != -1) {
        {
#line 880
        syslog(dst->facility | dst->priority, "%*.*s", (int )mesglen, (int )mesglen,
               (char *)mesg);
        }
      }
    }
  }
#line 881
  return;
}
}
#line 897 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
Msg *msg_create_syslog(char const   *ident , int option , int facility , int priority ) 
{ 
  Msg *tmp ;

  {
  {
#line 899
  tmp = msg_create_syslog_with_locker((Locker *)((void *)0), ident, option, facility,
                                      priority);
  }
#line 899
  return (tmp);
}
}
#line 913 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
Msg *msg_create_syslog_with_locker(Locker *locker , char const   *ident , int option ,
                                   int facility , int priority ) 
{ 
  MsgSyslogData *data ;
  Msg *mesg ;

  {
  {
#line 918
  data = msg_sysdata_create(ident, option, facility, priority);
  }
#line 918
  if (! data) {
#line 919
    return ((Msg *)((void *)0));
  }
  {
#line 921
  mesg = msg_create_with_locker(locker, 3, & msg_out_syslog, (void *)data, (msg_release_t *)(& msg_sysdata_release));
  }
#line 921
  if (! mesg) {
    {
#line 923
    msg_sysdata_release(data);
    }
#line 924
    return ((Msg *)((void *)0));
  }
#line 927
  return (mesg);
}
}
#line 941 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
Msg *msg_syslog_set_facility(Msg *mesg , int facility ) 
{ 
  Msg *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 946
  if (! mesg) {
    {
#line 947
    tmp = set_errnull(22);
    }
#line 947
    return ((Msg *)tmp);
  }
#line 949
  if (mesg) {
#line 949
    if (mesg->locker) {
      {
#line 949
      tmp___1 = (*((mesg->locker)->wrlock))((mesg->locker)->lock);
#line 949
      tmp___2 = tmp___1;
      }
    } else {
#line 949
      tmp___2 = 0;
    }
#line 949
    err = tmp___2;
  } else {
#line 949
    err = 22;
  }
#line 949
  if (err) {
    {
#line 950
    tmp___0 = set_errnull(err);
    }
#line 950
    return ((Msg *)tmp___0);
  }
  {
#line 952
  ret = msg_syslog_set_facility_unlocked(mesg, facility);
  }
#line 954
  if (mesg) {
#line 954
    if (mesg->locker) {
      {
#line 954
      tmp___4 = (*((mesg->locker)->unlock))((mesg->locker)->lock);
#line 954
      tmp___5 = tmp___4;
      }
    } else {
#line 954
      tmp___5 = 0;
    }
#line 954
    err = tmp___5;
  } else {
#line 954
    err = 22;
  }
#line 954
  if (err) {
    {
#line 955
    tmp___3 = set_errnull(err);
    }
#line 955
    return ((Msg *)tmp___3);
  }
#line 957
  return (ret);
}
}
#line 971 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
Msg *msg_syslog_set_facility_unlocked(Msg *mesg , int facility ) 
{ 
  MsgSyslogData *data ;
  void *tmp ;

  {
#line 975
  if (! mesg) {
    {
#line 976
    tmp = set_errnull(22);
    }
#line 976
    return ((Msg *)tmp);
  } else
#line 975
  if (mesg->type != 3) {
    {
#line 976
    tmp = set_errnull(22);
    }
#line 976
    return ((Msg *)tmp);
  }
#line 978
  data = (MsgSyslogData *)mesg->data;
#line 979
  data->facility = facility;
#line 981
  return (mesg);
}
}
#line 995 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
Msg *msg_syslog_set_priority(Msg *mesg , int priority ) 
{ 
  Msg *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1000
  if (! mesg) {
    {
#line 1001
    tmp = set_errnull(22);
    }
#line 1001
    return ((Msg *)tmp);
  }
#line 1003
  if (mesg) {
#line 1003
    if (mesg->locker) {
      {
#line 1003
      tmp___1 = (*((mesg->locker)->wrlock))((mesg->locker)->lock);
#line 1003
      tmp___2 = tmp___1;
      }
    } else {
#line 1003
      tmp___2 = 0;
    }
#line 1003
    err = tmp___2;
  } else {
#line 1003
    err = 22;
  }
#line 1003
  if (err) {
    {
#line 1004
    tmp___0 = set_errnull(err);
    }
#line 1004
    return ((Msg *)tmp___0);
  }
  {
#line 1006
  ret = msg_syslog_set_priority_unlocked(mesg, priority);
  }
#line 1008
  if (mesg) {
#line 1008
    if (mesg->locker) {
      {
#line 1008
      tmp___4 = (*((mesg->locker)->unlock))((mesg->locker)->lock);
#line 1008
      tmp___5 = tmp___4;
      }
    } else {
#line 1008
      tmp___5 = 0;
    }
#line 1008
    err = tmp___5;
  } else {
#line 1008
    err = 22;
  }
#line 1008
  if (err) {
    {
#line 1009
    tmp___3 = set_errnull(err);
    }
#line 1009
    return ((Msg *)tmp___3);
  }
#line 1011
  return (ret);
}
}
#line 1025 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
Msg *msg_syslog_set_priority_unlocked(Msg *mesg , int priority ) 
{ 
  MsgSyslogData *data ;
  void *tmp ;

  {
#line 1029
  if (! mesg) {
    {
#line 1030
    tmp = set_errnull(22);
    }
#line 1030
    return ((Msg *)tmp);
  } else
#line 1029
  if (mesg->type != 3) {
    {
#line 1030
    tmp = set_errnull(22);
    }
#line 1030
    return ((Msg *)tmp);
  }
#line 1032
  data = (MsgSyslogData *)mesg->data;
#line 1033
  data->priority = priority;
#line 1035
  return (mesg);
}
}
#line 1048 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
static int msg_plexdata_init(MsgPlexData *data , Msg *msg1 , Msg *msg2 ) 
{ 
  size_t tmp ;
  Msg **tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1050
  tmp = (size_t )2;
#line 1050
  data->size = tmp;
#line 1050
  data->length = tmp;
#line 1052
  tmp___1 = malloc(data->size * sizeof(Msg *));
#line 1052
  tmp___0 = (Msg **)tmp___1;
#line 1052
  data->list = tmp___0;
  }
#line 1052
  if (! tmp___0) {
#line 1053
    return (-1);
  }
#line 1055
  *(data->list + 0) = msg1;
#line 1056
  *(data->list + 1) = msg2;
#line 1058
  return (0);
}
}
#line 1070 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
static int msg_plexdata_add(MsgPlexData *data , Msg *mesg ) 
{ 
  size_t new_size ;
  Msg **new_list ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 1072
  if (data->length == data->size) {
    {
#line 1074
    new_size = data->size << 1;
#line 1075
    tmp = mem_resize_fn((void **)(& data->list), new_size * sizeof(*(data->list)));
#line 1075
    new_list = (Msg **)tmp;
    }
#line 1076
    if (! new_list) {
#line 1077
      return (-1);
    }
#line 1079
    data->size = new_size;
#line 1080
    data->list = new_list;
  }
#line 1083
  tmp___0 = data->length;
#line 1083
  (data->length) ++;
#line 1083
  *(data->list + tmp___0) = mesg;
#line 1085
  return (0);
}
}
#line 1099 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
static MsgPlexData *msg_plexdata_create(Msg *msg1 , Msg *msg2 ) 
{ 
  MsgPlexData *data ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 1103
  tmp = malloc(sizeof(MsgPlexData ));
#line 1103
  data = (MsgPlexData *)tmp;
  }
#line 1103
  if (! data) {
#line 1104
    return ((MsgPlexData *)((void *)0));
  }
  {
#line 1106
  tmp___0 = msg_plexdata_init(data, msg1, msg2);
  }
#line 1106
  if (tmp___0 == -1) {
    {
#line 1108
    free((void *)data);
    }
#line 1109
    return ((MsgPlexData *)((void *)0));
  }
#line 1112
  return (data);
}
}
#line 1124 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
static void msg_plexdata_release(MsgPlexData *data ) 
{ 
  size_t i ;

  {
#line 1128
  if (! data) {
#line 1129
    return;
  }
#line 1131
  i = (size_t )0;
  {
#line 1131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1131
    if (! (i < data->length)) {
#line 1131
      goto while_break;
    }
    {
#line 1132
    msg_destroy(data->list + i);
#line 1131
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1134
  free((void *)data->list);
#line 1135
  free((void *)data);
  }
#line 1136
  return;
}
}
#line 1147 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
static void msg_out_plex(void *data , void const   *mesg , size_t mesglen ) 
{ 
  MsgPlexData *dst ;
  size_t i ;
  Msg *out ;

  {
#line 1149
  dst = (MsgPlexData *)data;
#line 1152
  if (mesg) {
#line 1152
    if (dst) {
#line 1154
      i = (size_t )0;
      {
#line 1154
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1154
        if (! (i < dst->length)) {
#line 1154
          goto while_break;
        }
#line 1156
        out = *(dst->list + i);
#line 1157
        if (out) {
#line 1157
          if (out->out) {
            {
#line 1158
            (*(out->out))(out->data, mesg, mesglen);
            }
          }
        }
#line 1154
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1161
  return;
}
}
#line 1177 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
Msg *msg_create_plex(Msg *msg1 , Msg *msg2 ) 
{ 
  Msg *tmp ;

  {
  {
#line 1179
  tmp = msg_create_plex_with_locker((Locker *)((void *)0), msg1, msg2);
  }
#line 1179
  return (tmp);
}
}
#line 1193 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
Msg *msg_create_plex_with_locker(Locker *locker , Msg *msg1 , Msg *msg2 ) 
{ 
  MsgPlexData *data ;
  Msg *mesg ;

  {
  {
#line 1198
  data = msg_plexdata_create(msg1, msg2);
  }
#line 1198
  if (! data) {
#line 1199
    return ((Msg *)((void *)0));
  }
  {
#line 1201
  mesg = msg_create_with_locker(locker, 4, & msg_out_plex, (void *)data, (msg_release_t *)(& msg_plexdata_release));
  }
#line 1201
  if (! mesg) {
    {
#line 1203
    msg_plexdata_release(data);
    }
#line 1204
    return ((Msg *)((void *)0));
  }
#line 1207
  return (mesg);
}
}
#line 1222 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
int msg_add_plex(Msg *mesg , Msg *item ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1227
  if (! mesg) {
    {
#line 1228
    tmp = set_errno(22);
    }
#line 1228
    return (tmp);
  }
#line 1230
  if (mesg) {
#line 1230
    if (mesg->locker) {
      {
#line 1230
      tmp___1 = (*((mesg->locker)->wrlock))((mesg->locker)->lock);
#line 1230
      tmp___2 = tmp___1;
      }
    } else {
#line 1230
      tmp___2 = 0;
    }
#line 1230
    err = tmp___2;
  } else {
#line 1230
    err = 22;
  }
#line 1230
  if (err) {
    {
#line 1231
    tmp___0 = set_errno(err);
    }
#line 1231
    return (tmp___0);
  }
  {
#line 1233
  ret = msg_add_plex_unlocked(mesg, item);
  }
#line 1235
  if (mesg) {
#line 1235
    if (mesg->locker) {
      {
#line 1235
      tmp___4 = (*((mesg->locker)->unlock))((mesg->locker)->lock);
#line 1235
      tmp___5 = tmp___4;
      }
    } else {
#line 1235
      tmp___5 = 0;
    }
#line 1235
    err = tmp___5;
  } else {
#line 1235
    err = 22;
  }
#line 1235
  if (err) {
    {
#line 1236
    tmp___3 = set_errno(err);
    }
#line 1236
    return (tmp___3);
  }
#line 1238
  return (ret);
}
}
#line 1251 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
int msg_add_plex_unlocked(Msg *mesg , Msg *item ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1253
  if (! mesg) {
    {
#line 1254
    tmp = set_errno(22);
    }
#line 1254
    return (tmp);
  } else
#line 1253
  if (mesg->type != 4) {
    {
#line 1254
    tmp = set_errno(22);
    }
#line 1254
    return (tmp);
  }
  {
#line 1256
  tmp___0 = msg_plexdata_add((MsgPlexData *)mesg->data, item);
  }
#line 1256
  return (tmp___0);
}
}
#line 1271 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
char const   *msg_set_timestamp_format(char const   *format ) 
{ 
  char const   *save ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 1276
  if (! format) {
    {
#line 1277
    tmp = set_errnull(22);
    }
#line 1277
    return ((char const   *)tmp);
  }
#line 1279
  if (timestamp_format_locker) {
    {
#line 1279
    tmp___1 = (*(timestamp_format_locker->wrlock))(timestamp_format_locker->lock);
#line 1279
    err = tmp___1;
    }
  } else {
#line 1279
    err = 0;
  }
#line 1279
  if (err) {
    {
#line 1280
    tmp___0 = set_errnull(err);
    }
#line 1280
    return ((char const   *)tmp___0);
  }
#line 1282
  save = timestamp_format;
#line 1283
  timestamp_format = format;
#line 1285
  if (timestamp_format_locker) {
    {
#line 1285
    tmp___3 = (*(timestamp_format_locker->unlock))(timestamp_format_locker->lock);
#line 1285
    err = tmp___3;
    }
  } else {
#line 1285
    err = 0;
  }
#line 1285
  if (err) {
    {
#line 1286
    tmp___2 = set_errnull(err);
    }
#line 1286
    return ((char const   *)tmp___2);
  }
#line 1288
  return (save);
}
}
#line 1304 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
int msg_set_timestamp_format_locker(Locker *locker ) 
{ 
  int tmp ;

  {
#line 1306
  if (timestamp_format_locker) {
    {
#line 1307
    tmp = set_errno(22);
    }
#line 1307
    return (tmp);
  }
#line 1309
  timestamp_format_locker = locker;
#line 1311
  return (0);
}
}
#line 1323 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
static int syslog_lookup(syslog_map_t const   *map , char const   *name ) 
{ 
  int i ;
  int tmp ;

  {
#line 1327
  i = 0;
  {
#line 1327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1327
    if (! (map + i)->name) {
#line 1327
      goto while_break;
    }
    {
#line 1328
    tmp = strcmp(name, (char const   *)(map + i)->name);
    }
#line 1328
    if (! tmp) {
#line 1329
      goto while_break;
    }
#line 1327
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1331
  return ((int )(map + i)->val);
}
}
#line 1343 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
static char const   *syslog_lookup_str(syslog_map_t const   *map , int spec , int mask ) 
{ 
  int i ;

  {
#line 1347
  i = 0;
  {
#line 1347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1347
    if (! (map + i)->name) {
#line 1347
      goto while_break;
    }
#line 1348
    if ((spec & mask) == (int )(map + i)->val) {
#line 1349
      goto while_break;
    }
#line 1347
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1351
  return ((char const   *)(map + i)->name);
}
}
#line 1364 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
int syslog_lookup_facility(char const   *facility ) 
{ 
  int tmp ;

  {
  {
#line 1366
  tmp = syslog_lookup(syslog_facility_map, facility);
  }
#line 1366
  return (tmp);
}
}
#line 1379 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
int syslog_lookup_priority(char const   *priority ) 
{ 
  int tmp ;

  {
  {
#line 1381
  tmp = syslog_lookup(syslog_priority_map, priority);
  }
#line 1381
  return (tmp);
}
}
#line 1395 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
char const   *syslog_facility_str(int spec ) 
{ 
  char const   *tmp ;

  {
  {
#line 1397
  tmp = syslog_lookup_str(syslog_facility_map, spec, 1016);
  }
#line 1397
  return (tmp);
}
}
#line 1411 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
char const   *syslog_priority_str(int spec ) 
{ 
  char const   *tmp ;

  {
  {
#line 1413
  tmp = syslog_lookup_str(syslog_priority_map, spec, 7);
  }
#line 1413
  return (tmp);
}
}
#line 1451 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/msg.c"
int syslog_parse(char const   *spec , int *facility , int *priority ) 
{ 
  char fac[64] ;
  char *pri ;
  int f ;
  int p ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp13 ;

  {
#line 1456
  if (! spec) {
    {
#line 1457
    tmp = set_errno(22);
    }
#line 1457
    return (tmp);
  }
  {
#line 1459
  strlcpy(fac, spec, (size_t )64);
#line 1461
  pri = strchr((char const   *)(fac), '.');
  }
#line 1461
  if (! pri) {
    {
#line 1462
    tmp___0 = set_errno(22);
    }
#line 1462
    return (tmp___0);
  }
  {
#line 1464
  tmp___1 = pri;
#line 1464
  pri ++;
#line 1464
  *tmp___1 = (char )'\000';
#line 1466
  f = syslog_lookup_facility((char const   *)(fac));
  }
#line 1466
  if (f == -1) {
    {
#line 1467
    tmp___2 = set_errno(22);
    }
#line 1467
    return (tmp___2);
  }
  {
#line 1469
  p = syslog_lookup_priority((char const   *)pri);
  }
#line 1469
  if (p == -1) {
    {
#line 1470
    tmp___3 = set_errno(22);
    }
#line 1470
    return (tmp___3);
  }
#line 1472
  if (facility) {
#line 1473
    *facility = f;
  }
#line 1475
  if (priority) {
#line 1476
    *priority = p;
  }
#line 1478
  return (0);
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 103 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) mlock)(void const   *__addr ,
                                                                            size_t __len ) ;
#line 106
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munlock)(void const   *__addr ,
                                                                              size_t __len ) ;
#line 48 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.h"
void *mem_destroy(void **mem ) ;
#line 50
void *mem_create_secure(size_t size ) ;
#line 51
void mem_release_secure(void *mem ) ;
#line 52
void *mem_destroy_secure(void **mem ) ;
#line 58
void *mem_create_space(size_t size  , ...) ;
#line 59
size_t mem_space_start(size_t size  , ...) ;
#line 68
Pool *pool_create(size_t size ) ;
#line 69
Pool *pool_create_with_locker(Locker *locker , size_t size ) ;
#line 70
void pool_release(Pool *pool ) ;
#line 71
void *pool_destroy(Pool **pool ) ;
#line 72
Pool *pool_create_secure(size_t size ) ;
#line 73
Pool *pool_create_secure_with_locker(Locker *locker , size_t size ) ;
#line 74
void pool_release_secure(Pool *pool ) ;
#line 75
void *pool_destroy_secure(Pool **pool ) ;
#line 76
void pool_clear_secure(Pool *pool ) ;
#line 79
void *pool_alloc(Pool *pool , size_t size ) ;
#line 80
void pool_clear(Pool *pool ) ;
#line 182 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.c"
void *mem_resize_fn(void **mem , size_t size ) 
{ 
  void *ptr ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 186
  if (! mem) {
    {
#line 187
    tmp = set_errnull(22);
    }
#line 187
    return (tmp);
  }
  {
#line 189
  ptr = realloc(*mem, size);
  }
#line 190
  if (size) {
#line 190
    if (! ptr) {
#line 191
      return ((void *)0);
    }
  }
#line 193
  tmp___0 = ptr;
#line 193
  *mem = tmp___0;
#line 193
  return (tmp___0);
}
}
#line 213 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.c"
void *mem_destroy(void **mem ) 
{ 


  {
#line 215
  if (mem) {
#line 215
    if (*mem) {
      {
#line 217
      free(*mem);
#line 218
      *mem = (void *)0;
      }
    }
  }
#line 221
  return ((void *)0);
}
}
#line 270 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.c"
void *mem_create_secure(size_t size ) 
{ 
  char *addr ;
  char *lock ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 284
  size += sizeof(size_t );
#line 285
  tmp = malloc(size);
#line 285
  addr = (char *)tmp;
  }
#line 288
  if (! addr) {
#line 289
    return ((void *)0);
  }
  {
#line 297
  lock = addr;
#line 300
  tmp___0 = mlock((void const   *)lock, size);
  }
#line 300
  if (tmp___0 == -1) {
    {
#line 302
    free((void *)addr);
    }
#line 303
    return ((void *)0);
  }
#line 310
  *((size_t *)lock) = size;
#line 311
  lock += sizeof(size_t );
#line 313
  return ((void *)lock);
}
}
#line 333 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.c"
void mem_release_secure(void *mem ) 
{ 
  char *addr ;
  char *lock ;
  size_t size ;

  {
#line 339
  if (! mem) {
#line 340
    return;
  }
  {
#line 342
  lock = (char *)mem;
#line 343
  lock -= sizeof(size_t );
#line 344
  size = *((size_t *)lock);
#line 349
  addr = lock;
#line 352
  memset((void *)lock, 255, size);
#line 353
  memset((void *)lock, 170, size);
#line 354
  memset((void *)lock, 85, size);
#line 355
  memset((void *)lock, 0, size);
#line 356
  munlock((void const   *)lock, size);
#line 357
  free((void *)addr);
  }
#line 359
  return;
}
}
#line 373 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.c"
void *mem_destroy_secure(void **mem ) 
{ 


  {
#line 375
  if (mem) {
#line 375
    if (*mem) {
      {
#line 377
      mem_release_secure(*mem);
#line 378
      *mem = (void *)0;
      }
    }
  }
#line 381
  return ((void *)0);
}
}
#line 398 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.c"
char *mem_strdup(char const   *str ) 
{ 
  size_t size ;
  char *copy ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 403
  if (! str) {
    {
#line 404
    tmp = set_errnull(22);
    }
#line 404
    return ((char *)tmp);
  }
  {
#line 406
  tmp___0 = strlen(str);
#line 406
  size = tmp___0 + 1UL;
#line 406
  tmp___1 = malloc(size * sizeof(char ));
#line 406
  copy = (char *)tmp___1;
  }
#line 406
  if (! copy) {
#line 407
    return ((char *)((void *)0));
  }
  {
#line 409
  tmp___2 = memcpy((void */* __restrict  */)copy, (void const   */* __restrict  */)str,
                   size);
  }
#line 409
  return ((char *)tmp___2);
}
}
#line 469 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.c"
void *mem_create_space(size_t size  , ...) 
{ 
  size_t dim[32] ;
  size_t d ;
  size_t i ;
  size_t j ;
  size_t lengths[32] ;
  size_t starts[32] ;
  size_t sizes[32] ;
  char *space ;
  size_t arg ;
  size_t length ;
  va_list args ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t num ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;

  {
  {
#line 479
  __builtin_va_start(args, size);
#line 480
  d = (size_t )0;
  }
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    if (d < 32UL) {
      {
#line 480
      tmp = __builtin_va_arg(args, size_t );
#line 480
      arg = tmp;
      }
#line 480
      if (! arg) {
#line 480
        goto while_break;
      }
    } else {
#line 480
      goto while_break;
    }
#line 481
    dim[d] = arg;
#line 480
    d ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 482
  __builtin_va_end(args);
#line 484
  i = (size_t )0;
#line 484
  length = i;
  }
  {
#line 484
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 484
    if (! (i < d)) {
#line 484
      goto while_break___0;
    }
#line 486
    starts[i] = length;
#line 487
    if (i == d - 1UL) {
#line 487
      tmp___0 = size;
    } else {
#line 487
      tmp___0 = sizeof(void *);
    }
#line 487
    sizes[i] = tmp___0;
#line 487
    lengths[i] = tmp___0;
#line 488
    j = (size_t )0;
    {
#line 488
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 488
      if (! (j <= i)) {
#line 488
        goto while_break___1;
      }
#line 489
      lengths[i] *= dim[j];
#line 488
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 490
    length += lengths[i];
#line 484
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 493
  tmp___1 = calloc(length, (size_t )1);
#line 493
  space = (char *)tmp___1;
  }
#line 493
  if (! space) {
#line 494
    return ((void *)0);
  }
#line 496
  i = (size_t )0;
  {
#line 496
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 496
    if (! (i < d - 1UL)) {
#line 496
      goto while_break___2;
    }
#line 498
    num = dim[i];
#line 500
    j = (size_t )0;
    {
#line 500
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 500
      if (! (j < i)) {
#line 500
        goto while_break___3;
      }
#line 501
      num *= dim[j];
#line 500
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 503
    j = (size_t )0;
    {
#line 503
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 503
      if (! (j < num)) {
#line 503
        goto while_break___4;
      }
#line 504
      *((char **)((space + starts[i]) + j * sizes[i])) = (space + starts[i + 1UL]) + (j * dim[i + 1UL]) * sizes[i + 1UL];
#line 503
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 496
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 507
  return ((void *)space);
}
}
#line 526 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.c"
size_t mem_space_start(size_t size  , ...) 
{ 
  size_t dim[32] ;
  size_t d ;
  size_t i ;
  size_t j ;
  size_t lengths[32] ;
  size_t arg ;
  size_t length ;
  va_list args ;
  size_t tmp ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;

  {
  {
#line 533
  __builtin_va_start(args, size);
#line 534
  d = (size_t )0;
  }
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 534
    if (d < 32UL) {
      {
#line 534
      tmp = __builtin_va_arg(args, size_t );
#line 534
      arg = tmp;
      }
#line 534
      if (! arg) {
#line 534
        goto while_break;
      }
    } else {
#line 534
      goto while_break;
    }
#line 535
    dim[d] = arg;
#line 534
    d ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 536
  __builtin_va_end(args);
#line 538
  i = (size_t )0;
#line 538
  length = i;
  }
  {
#line 538
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 538
    if (! (i < d)) {
#line 538
      goto while_break___0;
    }
#line 540
    if (i == d - 1UL) {
#line 540
      lengths[i] = size;
    } else {
#line 540
      lengths[i] = sizeof(void *);
    }
#line 541
    j = (size_t )0;
    {
#line 541
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 541
      if (! (j <= i)) {
#line 541
        goto while_break___1;
      }
#line 542
      lengths[i] *= dim[j];
#line 541
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 543
    length += lengths[i];
#line 538
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 546
  return (length - lengths[d - 1UL]);
}
}
#line 616 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.c"
Pool *pool_create(size_t size ) 
{ 
  Pool *tmp ;

  {
  {
#line 618
  tmp = pool_create_with_locker((Locker *)((void *)0), size);
  }
#line 618
  return (tmp);
}
}
#line 632 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.c"
Pool *pool_create_with_locker(Locker *locker , size_t size ) 
{ 
  Pool *pool ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 634
  tmp = malloc(sizeof(Pool ));
#line 634
  pool = (Pool *)tmp;
  }
#line 636
  if (! pool) {
#line 637
    return ((Pool *)((void *)0));
  }
  {
#line 639
  tmp___1 = malloc(size);
#line 639
  tmp___0 = (char *)tmp___1;
#line 639
  pool->pool = tmp___0;
  }
#line 639
  if (! tmp___0) {
    {
#line 641
    free((void *)pool);
    }
#line 642
    return ((Pool *)((void *)0));
  }
#line 645
  pool->size = size;
#line 646
  pool->used = (size_t )0;
#line 647
  pool->locker = locker;
#line 649
  return (pool);
}
}
#line 680 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.c"
void pool_release(Pool *pool ) 
{ 
  Locker *locker ;
  int err ;
  int tmp ;
  int tmp___0 ;

  {
#line 685
  if (! pool) {
#line 686
    return;
  }
#line 688
  if (pool->locker) {
    {
#line 688
    tmp = (*((pool->locker)->wrlock))((pool->locker)->lock);
#line 688
    err = tmp;
    }
  } else {
#line 688
    err = 0;
  }
#line 688
  if (err) {
    {
#line 690
    set_errno(err);
    }
#line 691
    return;
  }
  {
#line 694
  locker = pool->locker;
#line 695
  free((void *)pool->pool);
#line 696
  free((void *)pool);
  }
#line 698
  if (locker) {
    {
#line 698
    tmp___0 = (*(locker->unlock))(locker->lock);
#line 698
    err = tmp___0;
    }
  } else {
#line 698
    err = 0;
  }
#line 698
  if (err) {
    {
#line 699
    set_errno(err);
    }
  }
#line 700
  return;
}
}
#line 714 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.c"
void *pool_destroy(Pool **pool ) 
{ 


  {
#line 716
  if (pool) {
#line 716
    if (*pool) {
      {
#line 718
      pool_release(*pool);
#line 719
      *pool = (Pool *)((void *)0);
      }
    }
  }
#line 722
  return ((void *)0);
}
}
#line 743 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.c"
Pool *pool_create_secure(size_t size ) 
{ 
  Pool *tmp ;

  {
  {
#line 745
  tmp = pool_create_secure_with_locker((Locker *)((void *)0), size);
  }
#line 745
  return (tmp);
}
}
#line 759 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.c"
Pool *pool_create_secure_with_locker(Locker *locker , size_t size ) 
{ 
  Pool *pool ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 762
  tmp = malloc(sizeof(Pool ));
#line 762
  pool = (Pool *)tmp;
  }
#line 764
  if (! pool) {
#line 765
    return ((Pool *)((void *)0));
  }
  {
#line 767
  tmp___1 = mem_create_secure(size);
#line 767
  tmp___0 = (char *)tmp___1;
#line 767
  pool->pool = tmp___0;
  }
#line 767
  if (! tmp___0) {
    {
#line 769
    free((void *)pool);
    }
#line 770
    return ((Pool *)((void *)0));
  }
#line 773
  pool->size = size;
#line 774
  pool->used = (size_t )0;
#line 775
  pool->locker = locker;
#line 777
  return (pool);
}
}
#line 797 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.c"
void pool_release_secure(Pool *pool ) 
{ 
  Locker *locker ;
  int err ;
  int tmp ;
  int tmp___0 ;

  {
#line 803
  if (! pool) {
#line 804
    return;
  }
#line 806
  if (pool->locker) {
    {
#line 806
    tmp = (*((pool->locker)->wrlock))((pool->locker)->lock);
#line 806
    err = tmp;
    }
  } else {
#line 806
    err = 0;
  }
#line 806
  if (err) {
    {
#line 808
    set_errno(err);
    }
#line 809
    return;
  }
  {
#line 812
  locker = pool->locker;
#line 813
  mem_release_secure((void *)pool->pool);
#line 814
  free((void *)pool);
  }
#line 816
  if (locker) {
    {
#line 816
    tmp___0 = (*(locker->unlock))(locker->lock);
#line 816
    err = tmp___0;
    }
  } else {
#line 816
    err = 0;
  }
#line 816
  if (err) {
    {
#line 817
    set_errno(err);
    }
  }
#line 819
  return;
}
}
#line 834 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.c"
void *pool_destroy_secure(Pool **pool ) 
{ 


  {
#line 836
  if (pool) {
#line 836
    if (*pool) {
      {
#line 838
      pool_release_secure(*pool);
#line 839
      *pool = (Pool *)((void *)0);
      }
    }
  }
#line 842
  return ((void *)0);
}
}
#line 857
static void pool_clear_unlocked(Pool *pool ) ;
#line 859 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.c"
void pool_clear_secure(Pool *pool ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;

  {
#line 863
  if (! pool) {
#line 864
    return;
  }
#line 866
  if (pool->locker) {
    {
#line 866
    tmp = (*((pool->locker)->wrlock))((pool->locker)->lock);
#line 866
    err = tmp;
    }
  } else {
#line 866
    err = 0;
  }
#line 866
  if (err) {
    {
#line 868
    set_errno(err);
    }
#line 869
    return;
  }
  {
#line 872
  pool_clear_unlocked(pool);
#line 873
  memset((void *)pool->pool, 255, pool->size);
#line 874
  memset((void *)pool->pool, 170, pool->size);
#line 875
  memset((void *)pool->pool, 85, pool->size);
#line 876
  memset((void *)pool->pool, 0, pool->size);
  }
#line 878
  if (pool->locker) {
    {
#line 878
    tmp___0 = (*((pool->locker)->unlock))((pool->locker)->lock);
#line 878
    err = tmp___0;
    }
  } else {
#line 878
    err = 0;
  }
#line 878
  if (err) {
    {
#line 879
    set_errno(err);
    }
  }
#line 880
  return;
}
}
#line 919 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.c"
void *pool_alloc(Pool *pool , size_t size ) 
{ 
  void *addr ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
#line 924
  if (! pool) {
    {
#line 925
    tmp = set_errnull(22);
    }
#line 925
    return (tmp);
  }
#line 927
  if (pool->locker) {
    {
#line 927
    tmp___1 = (*((pool->locker)->wrlock))((pool->locker)->lock);
#line 927
    err = tmp___1;
    }
  } else {
#line 927
    err = 0;
  }
#line 927
  if (err) {
    {
#line 928
    tmp___0 = set_errnull(err);
    }
#line 928
    return (tmp___0);
  }
#line 930
  if (pool->used + size > pool->size) {
#line 932
    if (pool->locker) {
      {
#line 932
      (*((pool->locker)->unlock))((pool->locker)->lock);
      }
    }
    {
#line 933
    tmp___2 = set_errnull(28);
    }
#line 933
    return (tmp___2);
  }
#line 936
  addr = (void *)(pool->pool + pool->used);
#line 937
  pool->used += size;
#line 939
  if (pool->locker) {
    {
#line 939
    tmp___4 = (*((pool->locker)->unlock))((pool->locker)->lock);
#line 939
    err = tmp___4;
    }
  } else {
#line 939
    err = 0;
  }
#line 939
  if (err) {
    {
#line 940
    tmp___3 = set_errnull(err);
    }
#line 940
    return (tmp___3);
  }
#line 942
  return (addr);
}
}
#line 956 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.c"
static void pool_clear_with_locker(Pool *pool , int lock_pool ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;

  {
#line 960
  if (! pool) {
#line 961
    return;
  }
#line 963
  if (lock_pool) {
#line 963
    if (pool->locker) {
      {
#line 963
      tmp = (*((pool->locker)->wrlock))((pool->locker)->lock);
#line 963
      err = tmp;
      }
    } else {
#line 963
      err = 0;
    }
#line 963
    if (err) {
      {
#line 965
      set_errno(err);
      }
#line 966
      return;
    }
  }
#line 969
  pool->used = (size_t )0;
#line 971
  if (lock_pool) {
#line 971
    if (pool->locker) {
      {
#line 971
      tmp___0 = (*((pool->locker)->unlock))((pool->locker)->lock);
#line 971
      err = tmp___0;
      }
    } else {
#line 971
      err = 0;
    }
#line 971
    if (err) {
      {
#line 972
      set_errno(err);
      }
    }
  }
#line 973
  return;
}
}
#line 975 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.c"
static void pool_clear_unlocked(Pool *pool ) 
{ 


  {
  {
#line 977
  pool_clear_with_locker(pool, 0);
  }
#line 978
  return;
}
}
#line 980 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/mem.c"
void pool_clear(Pool *pool ) 
{ 


  {
  {
#line 982
  pool_clear_with_locker(pool, 1);
  }
#line 983
  return;
}
}
#line 44 "libslack/slack/list.h"
List *list_create(list_release_t *destroy ) ;
#line 56
void *list_destroy(List **list ) ;
#line 62
void *list_item_unlocked(List const   *list , ssize_t index ) ;
#line 68
ssize_t list_length_unlocked(List const   *list ) ;
#line 72
List *list_remove_unlocked(List *list , ssize_t index ) ;
#line 82
List *list_append_unlocked(List *list , void *item ) ;
#line 42 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.h"
Map *map_create_sized(size_t size , map_release_t *destroy ) ;
#line 43
Map *map_create_with_hash(map_hash_t *hash___0 , map_release_t *destroy ) ;
#line 44
Map *map_create_sized_with_hash(size_t size , map_hash_t *hash___0 , map_release_t *destroy ) ;
#line 45
Map *map_create_with_locker(Locker *locker , map_release_t *destroy ) ;
#line 46
Map *map_create_with_locker_sized(Locker *locker , size_t size , map_release_t *destroy ) ;
#line 47
Map *map_create_with_locker_with_hash(Locker *locker , map_hash_t *hash___0 , map_release_t *destroy ) ;
#line 48
Map *map_create_with_locker_sized_with_hash(Locker *locker , size_t size , map_hash_t *hash___0 ,
                                            map_release_t *destroy ) ;
#line 49
Map *map_create_generic(map_copy_t *copy , map_cmp_t *cmp , map_hash_t *hash___0 ,
                        map_release_t *key_destroy , map_release_t *value_destroy ) ;
#line 50
Map *map_create_generic_sized(size_t size , map_copy_t *copy , map_cmp_t *cmp , map_hash_t *hash___0 ,
                              map_release_t *key_destroy , map_release_t *value_destroy ) ;
#line 51
Map *map_create_generic_with_locker(Locker *locker , map_copy_t *copy , map_cmp_t *cmp ,
                                    map_hash_t *hash___0 , map_release_t *key_destroy ,
                                    map_release_t *value_destroy ) ;
#line 52
Map *map_create_generic_with_locker_sized(Locker *locker , size_t size , map_copy_t *copy ,
                                          map_cmp_t *cmp , map_hash_t *hash___0 ,
                                          map_release_t *key_destroy , map_release_t *value_destroy ) ;
#line 53
int map_rdlock(Map const   *map ) ;
#line 54
int map_wrlock(Map const   *map ) ;
#line 55
int map_unlock(Map const   *map ) ;
#line 57
void *map_destroy(Map **map ) ;
#line 58
int map_own(Map *map , map_release_t *destroy ) ;
#line 59
int map_own_unlocked(Map *map , map_release_t *destroy ) ;
#line 60
map_release_t *map_disown(Map *map ) ;
#line 61
map_release_t *map_disown_unlocked(Map *map ) ;
#line 63
int map_add_unlocked(Map *map , void const   *key , void *value ) ;
#line 65
int map_put_unlocked(Map *map , void const   *key , void *value ) ;
#line 66
int map_insert(Map *map , void const   *key , void *value , int replace ) ;
#line 67
int map_insert_unlocked(Map *map , void const   *key , void *value , int replace ) ;
#line 69
int map_remove_unlocked(Map *map , void const   *key ) ;
#line 71
void *map_get_unlocked(Map const   *map , void const   *key ) ;
#line 72
Mapper *mapper_create(Map *map ) ;
#line 73
Mapper *mapper_create_rdlocked(Map *map ) ;
#line 74
Mapper *mapper_create_wrlocked(Map *map ) ;
#line 75
Mapper *mapper_create_unlocked(Map *map ) ;
#line 76
void mapper_release(Mapper *mapper ) ;
#line 77
void mapper_release_unlocked(Mapper *mapper ) ;
#line 78
void *mapper_destroy(Mapper **mapper ) ;
#line 79
void *mapper_destroy_unlocked(Mapper **mapper ) ;
#line 80
int mapper_has_next(Mapper *mapper ) ;
#line 81
void *mapper_next(Mapper *mapper ) ;
#line 82
Mapping const   *mapper_next_mapping(Mapper *mapper ) ;
#line 83
void mapper_remove(Mapper *mapper ) ;
#line 84
int map_has_next(Map *map ) ;
#line 85
void map_break(Map *map ) ;
#line 86
void *map_next(Map *map ) ;
#line 87
Mapping const   *map_next_mapping(Map *map ) ;
#line 88
void map_remove_current(Map *map ) ;
#line 89
void const   *mapping_key(Mapping const   *mapping ) ;
#line 90
void const   *mapping_value(Mapping const   *mapping ) ;
#line 92
List *map_keys_unlocked(Map *map ) ;
#line 93
List *map_keys_with_locker(Locker *locker , Map *map ) ;
#line 94
List *map_keys_with_locker_unlocked(Locker *locker , Map *map ) ;
#line 95
List *map_values(Map *map ) ;
#line 96
List *map_values_unlocked(Map *map ) ;
#line 97
List *map_values_with_locker(Locker *locker , Map *map ) ;
#line 98
List *map_values_with_locker_unlocked(Locker *locker , Map *map ) ;
#line 99
void map_apply(Map *map , map_action_t *action , void *data ) ;
#line 100
void map_apply_rdlocked(Map *map , map_action_t *action , void *data ) ;
#line 101
void map_apply_wrlocked(Map *map , map_action_t *action , void *data ) ;
#line 102
void map_apply_unlocked(Map *map , map_action_t *action , void *data ) ;
#line 103
ssize_t map_size(Map *map ) ;
#line 104
ssize_t map_size_unlocked(Map const   *map ) ;
#line 85 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.h"
void (*set_errnullf(int errnum ))() ;
#line 173 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
static size_t const   table_sizes[22]  = 
#line 173 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
  {      (size_t const   )11,      (size_t const   )23,      (size_t const   )47,      (size_t const   )101, 
        (size_t const   )199,      (size_t const   )401,      (size_t const   )797,      (size_t const   )1601, 
        (size_t const   )3203,      (size_t const   )6397,      (size_t const   )12799,      (size_t const   )25601, 
        (size_t const   )51199,      (size_t const   )102397,      (size_t const   )204803,      (size_t const   )409597, 
        (size_t const   )819187,      (size_t const   )1638431,      (size_t const   )3276799,      (size_t const   )6553621, 
        (size_t const   )13107197,      (size_t const   )26214401};
#line 180 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
static unsigned long const   num_table_sizes  =    (size_t const   )(sizeof(table_sizes) / sizeof(table_sizes[0]));
#line 184 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
static double const   table_resize_factor  =    (double const   )2.0;
#line 217 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
static size_t hash(size_t size , void const   *key ) 
{ 
  unsigned char const   *k ;
  size_t h ;
  unsigned char const   *tmp ;

  {
#line 219
  k = (unsigned char const   *)key;
#line 220
  h = (size_t )0;
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (! *k) {
#line 222
      goto while_break;
    }
#line 223
    h *= 31UL;
#line 223
    tmp = k;
#line 223
    k ++;
#line 223
    h += (size_t )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  return (h % size);
}
}
#line 238 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
static Mapping *mapping_create(void *key , void *value , map_release_t *key_destroy ,
                               map_release_t *value_destroy ) 
{ 
  Mapping *mapping ;
  void *tmp ;

  {
  {
#line 242
  tmp = malloc(sizeof(Mapping ));
#line 242
  mapping = (Mapping *)tmp;
  }
#line 242
  if (! mapping) {
#line 243
    return ((Mapping *)((void *)0));
  }
#line 245
  mapping->key = key;
#line 246
  mapping->value = value;
#line 247
  mapping->key_destroy = key_destroy;
#line 248
  mapping->value_destroy = value_destroy;
#line 250
  return (mapping);
}
}
#line 261 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
static void mapping_release(Mapping *mapping ) 
{ 


  {
#line 263
  if (! mapping) {
#line 264
    return;
  }
#line 266
  if (mapping->key_destroy) {
    {
#line 267
    (*(mapping->key_destroy))(mapping->key);
    }
  }
#line 269
  if (mapping->value_destroy) {
    {
#line 270
    (*(mapping->value_destroy))(mapping->value);
    }
  }
  {
#line 272
  free((void *)mapping);
  }
#line 273
  return;
}
}
#line 288 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
Map *map_create(map_release_t *destroy ) 
{ 
  Map *tmp ;

  {
  {
#line 290
  tmp = map_create_sized_with_hash((size_t )table_sizes[0], & hash, destroy);
  }
#line 290
  return (tmp);
}
}
#line 306 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
Map *map_create_sized(size_t size , map_release_t *destroy ) 
{ 
  Map *tmp ;

  {
  {
#line 308
  tmp = map_create_sized_with_hash(size, & hash, destroy);
  }
#line 308
  return (tmp);
}
}
#line 324 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
Map *map_create_with_hash(map_hash_t *hash___0 , map_release_t *destroy ) 
{ 
  Map *tmp ;

  {
  {
#line 326
  tmp = map_create_sized_with_hash((size_t )table_sizes[0], hash___0, destroy);
  }
#line 326
  return (tmp);
}
}
#line 342 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
Map *map_create_sized_with_hash(size_t size , map_hash_t *hash___0 , map_release_t *destroy ) 
{ 
  Map *tmp ;

  {
  {
#line 344
  tmp = map_create_generic_sized(size, (map_copy_t *)(& mem_strdup), (map_cmp_t *)(& strcmp),
                                 hash___0, (map_release_t *)(& free), destroy);
  }
#line 344
  return (tmp);
}
}
#line 358 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
Map *map_create_with_locker(Locker *locker , map_release_t *destroy ) 
{ 
  Map *tmp ;

  {
  {
#line 360
  tmp = map_create_with_locker_sized_with_hash(locker, (size_t )table_sizes[0], & hash,
                                               destroy);
  }
#line 360
  return (tmp);
}
}
#line 374 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
Map *map_create_with_locker_sized(Locker *locker , size_t size , map_release_t *destroy ) 
{ 
  Map *tmp ;

  {
  {
#line 376
  tmp = map_create_with_locker_sized_with_hash(locker, size, & hash, destroy);
  }
#line 376
  return (tmp);
}
}
#line 390 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
Map *map_create_with_locker_with_hash(Locker *locker , map_hash_t *hash___0 , map_release_t *destroy ) 
{ 
  Map *tmp ;

  {
  {
#line 392
  tmp = map_create_with_locker_sized_with_hash(locker, (size_t )table_sizes[0], hash___0,
                                               destroy);
  }
#line 392
  return (tmp);
}
}
#line 406 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
Map *map_create_with_locker_sized_with_hash(Locker *locker , size_t size , map_hash_t *hash___0 ,
                                            map_release_t *destroy ) 
{ 
  Map *tmp ;

  {
  {
#line 408
  tmp = map_create_generic_with_locker_sized(locker, size, (map_copy_t *)(& mem_strdup),
                                             (map_cmp_t *)(& strcmp), hash___0, (map_release_t *)(& free),
                                             destroy);
  }
#line 408
  return (tmp);
}
}
#line 432 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
Map *map_create_generic(map_copy_t *copy , map_cmp_t *cmp , map_hash_t *hash___0 ,
                        map_release_t *key_destroy , map_release_t *value_destroy ) 
{ 
  Map *tmp ;

  {
  {
#line 434
  tmp = map_create_generic_with_locker_sized((Locker *)((void *)0), (size_t )table_sizes[0],
                                             copy, cmp, hash___0, key_destroy, value_destroy);
  }
#line 434
  return (tmp);
}
}
#line 450 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
Map *map_create_generic_sized(size_t size , map_copy_t *copy , map_cmp_t *cmp , map_hash_t *hash___0 ,
                              map_release_t *key_destroy , map_release_t *value_destroy ) 
{ 
  Map *tmp ;

  {
  {
#line 452
  tmp = map_create_generic_with_locker_sized((Locker *)((void *)0), size, copy, cmp,
                                             hash___0, key_destroy, value_destroy);
  }
#line 452
  return (tmp);
}
}
#line 466 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
Map *map_create_generic_with_locker(Locker *locker , map_copy_t *copy , map_cmp_t *cmp ,
                                    map_hash_t *hash___0 , map_release_t *key_destroy ,
                                    map_release_t *value_destroy ) 
{ 
  Map *tmp ;

  {
  {
#line 468
  tmp = map_create_generic_with_locker_sized(locker, (size_t )table_sizes[0], copy,
                                             cmp, hash___0, key_destroy, value_destroy);
  }
#line 468
  return (tmp);
}
}
#line 482 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
Map *map_create_generic_with_locker_sized(Locker *locker , size_t size , map_copy_t *copy ,
                                          map_cmp_t *cmp , map_hash_t *hash___0 ,
                                          map_release_t *key_destroy , map_release_t *value_destroy ) 
{ 
  Map *map ;
  size_t i ;
  void *tmp ;
  void *tmp___0 ;
  List **tmp___1 ;
  void *tmp___2 ;

  {
#line 487
  i = (size_t )0;
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 487
    if (! (i < (size_t )num_table_sizes)) {
#line 487
      goto while_break;
    }
#line 489
    if (table_sizes[i] >= (size_t const   )size) {
#line 491
      size = (size_t )table_sizes[i];
#line 492
      goto while_break;
    }
#line 487
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 496
  if (i == (size_t )num_table_sizes) {
    {
#line 497
    tmp = set_errnull(22);
    }
#line 497
    return ((Map *)tmp);
  }
  {
#line 499
  tmp___0 = malloc(sizeof(Map ));
#line 499
  map = (Map *)tmp___0;
  }
#line 499
  if (! map) {
#line 500
    return ((Map *)((void *)0));
  }
  {
#line 502
  tmp___2 = malloc(size * sizeof(List *));
#line 502
  tmp___1 = (List **)tmp___2;
#line 502
  map->chain = tmp___1;
  }
#line 502
  if (! tmp___1) {
    {
#line 504
    free((void *)map);
    }
#line 505
    return ((Map *)((void *)0));
  }
  {
#line 508
  map->size = size;
#line 509
  map->items = (size_t )0;
#line 510
  memset((void *)map->chain, 0, map->size * sizeof(List *));
#line 511
  map->hash = hash___0;
#line 512
  map->copy = copy;
#line 513
  map->cmp = cmp;
#line 514
  map->key_destroy = key_destroy;
#line 515
  map->value_destroy = value_destroy;
#line 516
  map->mapper = (Mapper *)((void *)0);
#line 517
  map->locker = locker;
  }
#line 519
  return (map);
}
}
#line 542 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
int map_rdlock(Map const   *map ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 544
  if (map) {
#line 544
    if (map->locker) {
      {
#line 544
      tmp = (*((map->locker)->rdlock))((map->locker)->lock);
#line 544
      tmp___0 = tmp;
      }
    } else {
#line 544
      tmp___0 = 0;
    }
#line 544
    tmp___1 = tmp___0;
  } else {
#line 544
    tmp___1 = 22;
  }
#line 544
  return (tmp___1);
}
}
#line 563 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
int map_wrlock(Map const   *map ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 565
  if (map) {
#line 565
    if (map->locker) {
      {
#line 565
      tmp = (*((map->locker)->wrlock))((map->locker)->lock);
#line 565
      tmp___0 = tmp;
      }
    } else {
#line 565
      tmp___0 = 0;
    }
#line 565
    tmp___1 = tmp___0;
  } else {
#line 565
    tmp___1 = 22;
  }
#line 565
  return (tmp___1);
}
}
#line 580 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
int map_unlock(Map const   *map ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 582
  if (map) {
#line 582
    if (map->locker) {
      {
#line 582
      tmp = (*((map->locker)->unlock))((map->locker)->lock);
#line 582
      tmp___0 = tmp;
      }
    } else {
#line 582
      tmp___0 = 0;
    }
#line 582
    tmp___1 = tmp___0;
  } else {
#line 582
    tmp___1 = 22;
  }
#line 582
  return (tmp___1);
}
}
#line 596 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
void map_release(Map *map ) 
{ 
  size_t i ;

  {
#line 600
  if (! map) {
#line 601
    return;
  }
#line 603
  i = (size_t )0;
  {
#line 603
  while (1) {
    while_continue: /* CIL Label */ ;
#line 603
    if (! (i < map->size)) {
#line 603
      goto while_break;
    }
    {
#line 604
    list_release(*(map->chain + i));
#line 603
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 606
  free((void *)map->chain);
#line 607
  free((void *)map);
  }
#line 608
  return;
}
}
#line 622 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
void *map_destroy(Map **map ) 
{ 


  {
#line 624
  if (map) {
#line 624
    if (*map) {
      {
#line 626
      map_release(*map);
#line 627
      *map = (Map *)((void *)0);
      }
    }
  }
#line 630
  return ((void *)0);
}
}
#line 646 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
int map_own(Map *map , map_release_t *destroy ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 651
  if (! map) {
    {
#line 652
    tmp = set_errno(22);
    }
#line 652
    return (tmp);
  } else
#line 651
  if (! destroy) {
    {
#line 652
    tmp = set_errno(22);
    }
#line 652
    return (tmp);
  }
#line 654
  if (map) {
#line 654
    if (map->locker) {
      {
#line 654
      tmp___1 = (*((map->locker)->wrlock))((map->locker)->lock);
#line 654
      tmp___2 = tmp___1;
      }
    } else {
#line 654
      tmp___2 = 0;
    }
#line 654
    err = tmp___2;
  } else {
#line 654
    err = 22;
  }
#line 654
  if (err) {
    {
#line 655
    tmp___0 = set_errno(err);
    }
#line 655
    return (tmp___0);
  }
  {
#line 657
  ret = map_own_unlocked(map, destroy);
  }
#line 659
  if (map) {
#line 659
    if (map->locker) {
      {
#line 659
      tmp___4 = (*((map->locker)->unlock))((map->locker)->lock);
#line 659
      tmp___5 = tmp___4;
      }
    } else {
#line 659
      tmp___5 = 0;
    }
#line 659
    err = tmp___5;
  } else {
#line 659
    err = 22;
  }
#line 659
  if (err) {
    {
#line 660
    tmp___3 = set_errno(err);
    }
#line 660
    return (tmp___3);
  }
#line 662
  return (ret);
}
}
#line 675 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
int map_own_unlocked(Map *map , map_release_t *destroy ) 
{ 
  ssize_t length ;
  size_t c ;
  size_t i ;
  int tmp ;
  List *chain ;
  Mapping *mapping ;
  void *tmp___0 ;

  {
#line 680
  if (! map) {
    {
#line 681
    tmp = set_errno(22);
    }
#line 681
    return (tmp);
  } else
#line 680
  if (! destroy) {
    {
#line 681
    tmp = set_errno(22);
    }
#line 681
    return (tmp);
  }
#line 683
  if ((unsigned long )destroy == (unsigned long )map->value_destroy) {
#line 684
    return (0);
  }
#line 686
  map->value_destroy = destroy;
#line 688
  c = (size_t )0;
  {
#line 688
  while (1) {
    while_continue: /* CIL Label */ ;
#line 688
    if (! (c < map->size)) {
#line 688
      goto while_break;
    }
#line 690
    chain = *(map->chain + c);
#line 692
    if (! chain) {
#line 693
      goto __Cont;
    }
    {
#line 695
    length = list_length_unlocked((List const   *)chain);
    }
#line 695
    if (length == -1L) {
#line 696
      return (-1);
    }
#line 698
    i = (size_t )0;
    {
#line 698
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 698
      if (! (i < (size_t )length)) {
#line 698
        goto while_break___0;
      }
      {
#line 700
      tmp___0 = list_item_unlocked((List const   *)chain, (ssize_t )i);
#line 700
      mapping = (Mapping *)tmp___0;
#line 701
      mapping->value_destroy = destroy;
#line 698
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 688
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 705
  return (0);
}
}
#line 721 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
map_release_t *map_disown(Map *map ) 
{ 
  map_release_t *ret ;
  int err ;
  void (*tmp)() ;
  void (*tmp___0)() ;
  int tmp___1 ;
  int tmp___2 ;
  void (*tmp___3)() ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 726
  if (! map) {
    {
#line 727
    tmp = set_errnullf(22);
    }
#line 727
    return ((map_release_t *)tmp);
  }
#line 729
  if (map) {
#line 729
    if (map->locker) {
      {
#line 729
      tmp___1 = (*((map->locker)->wrlock))((map->locker)->lock);
#line 729
      tmp___2 = tmp___1;
      }
    } else {
#line 729
      tmp___2 = 0;
    }
#line 729
    err = tmp___2;
  } else {
#line 729
    err = 22;
  }
#line 729
  if (err) {
    {
#line 730
    tmp___0 = set_errnullf(err);
    }
#line 730
    return ((map_release_t *)tmp___0);
  }
  {
#line 732
  ret = map_disown_unlocked(map);
  }
#line 734
  if (map) {
#line 734
    if (map->locker) {
      {
#line 734
      tmp___4 = (*((map->locker)->unlock))((map->locker)->lock);
#line 734
      tmp___5 = tmp___4;
      }
    } else {
#line 734
      tmp___5 = 0;
    }
#line 734
    err = tmp___5;
  } else {
#line 734
    err = 22;
  }
#line 734
  if (err) {
    {
#line 735
    tmp___3 = set_errnullf(err);
    }
#line 735
    return ((map_release_t *)tmp___3);
  }
#line 737
  return (ret);
}
}
#line 750 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
map_release_t *map_disown_unlocked(Map *map ) 
{ 
  ssize_t length ;
  size_t c ;
  size_t i ;
  map_release_t *destroy ;
  void (*tmp)() ;
  List *chain ;
  Mapping *mapping ;
  void *tmp___0 ;

  {
#line 756
  if (! map) {
    {
#line 757
    tmp = set_errnullf(22);
    }
#line 757
    return ((map_release_t *)tmp);
  }
#line 759
  if (! map->value_destroy) {
#line 760
    return ((map_release_t *)((void *)0));
  }
#line 762
  destroy = map->value_destroy;
#line 763
  map->value_destroy = (map_release_t *)((void *)0);
#line 765
  c = (size_t )0;
  {
#line 765
  while (1) {
    while_continue: /* CIL Label */ ;
#line 765
    if (! (c < map->size)) {
#line 765
      goto while_break;
    }
#line 767
    chain = *(map->chain + c);
#line 769
    if (! chain) {
#line 770
      goto __Cont;
    }
    {
#line 772
    length = list_length_unlocked((List const   *)chain);
    }
#line 772
    if (length == -1L) {
#line 773
      return ((map_release_t *)((void *)0));
    }
#line 775
    i = (size_t )0;
    {
#line 775
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 775
      if (! (i < (size_t )length)) {
#line 775
        goto while_break___0;
      }
      {
#line 777
      tmp___0 = list_item_unlocked((List const   *)chain, (ssize_t )i);
#line 777
      mapping = (Mapping *)tmp___0;
#line 778
      mapping->value_destroy = (map_release_t *)((void *)0);
#line 775
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 765
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 782
  return (destroy);
}
}
#line 795 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
static int map_resize(Map *map ) 
{ 
  size_t size ;
  size_t i ;
  Mapper *mapper ;
  Map *new_map ;
  int tmp ;
  int tmp___0 ;
  Mapping const   *mapping ;
  Mapping const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  map_release_t *tmp___5 ;
  int *tmp___6 ;

  {
#line 797
  size = (size_t )0;
#line 802
  if (! map) {
    {
#line 803
    tmp = set_errno(22);
    }
#line 803
    return (tmp);
  }
#line 805
  i = (size_t )1;
  {
#line 805
  while (1) {
    while_continue: /* CIL Label */ ;
#line 805
    if (! (i < (size_t )num_table_sizes)) {
#line 805
      goto while_break;
    }
#line 807
    if (table_sizes[i] > (size_t const   )map->size) {
#line 809
      size = (size_t )table_sizes[i];
#line 810
      goto while_break;
    }
#line 805
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 814
  if (i == (size_t )num_table_sizes) {
    {
#line 815
    tmp___0 = set_errno(22);
    }
#line 815
    return (tmp___0);
  } else
#line 814
  if (size == 0UL) {
    {
#line 815
    tmp___0 = set_errno(22);
    }
#line 815
    return (tmp___0);
  }
  {
#line 817
  new_map = map_create_generic_sized(size, map->copy, map->cmp, map->hash, map->key_destroy,
                                     map->value_destroy);
  }
#line 817
  if (! new_map) {
#line 818
    return (-1);
  }
  {
#line 820
  mapper = mapper_create_unlocked(map);
  }
#line 820
  if (! mapper) {
    {
#line 822
    map_release(new_map);
    }
#line 823
    return (-1);
  }
  {
#line 826
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 826
    tmp___3 = mapper_has_next(mapper);
    }
#line 826
    if (! (tmp___3 == 1)) {
#line 826
      goto while_break___0;
    }
    {
#line 828
    tmp___1 = mapper_next_mapping(mapper);
#line 828
    mapping = tmp___1;
#line 830
    tmp___2 = map_add_unlocked(new_map, (void const   *)mapping->key, (void *)mapping->value);
    }
#line 830
    if (tmp___2 == -1) {
      {
#line 832
      mapper_release_unlocked(mapper);
#line 833
      map_release(new_map);
      }
#line 834
      return (-1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 838
  mapper_release_unlocked(mapper);
#line 840
  tmp___4 = __errno_location();
#line 840
  *tmp___4 = 0;
#line 841
  tmp___5 = map_disown_unlocked(map);
  }
#line 841
  if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
    {
#line 841
    tmp___6 = __errno_location();
    }
#line 841
    if (*tmp___6) {
      {
#line 843
      map_release(new_map);
      }
#line 844
      return (-1);
    }
  }
#line 847
  i = (size_t )0;
  {
#line 847
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 847
    if (! (i < map->size)) {
#line 847
      goto while_break___1;
    }
    {
#line 848
    list_release(*(map->chain + i));
#line 847
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 849
  free((void *)map->chain);
#line 851
  map->size = new_map->size;
#line 852
  map->items = new_map->items;
#line 853
  map->chain = new_map->chain;
#line 854
  map->value_destroy = new_map->value_destroy;
#line 855
  free((void *)new_map);
  }
#line 857
  return (0);
}
}
#line 872 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
int map_add(Map *map , void const   *key , void *value ) 
{ 
  int tmp ;

  {
  {
#line 874
  tmp = map_insert(map, key, value, 0);
  }
#line 874
  return (tmp);
}
}
#line 887 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
int map_add_unlocked(Map *map , void const   *key , void *value ) 
{ 
  int tmp ;

  {
  {
#line 889
  tmp = map_insert_unlocked(map, key, value, 0);
  }
#line 889
  return (tmp);
}
}
#line 904 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
int map_put(Map *map , void const   *key , void *value ) 
{ 
  int tmp ;

  {
  {
#line 906
  tmp = map_insert(map, key, value, 1);
  }
#line 906
  return (tmp);
}
}
#line 919 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
int map_put_unlocked(Map *map , void const   *key , void *value ) 
{ 
  int tmp ;

  {
  {
#line 921
  tmp = map_insert_unlocked(map, key, value, 1);
  }
#line 921
  return (tmp);
}
}
#line 938 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
int map_insert(Map *map , void const   *key , void *value , int replace ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 943
  if (! map) {
    {
#line 944
    tmp = set_errno(22);
    }
#line 944
    return (tmp);
  } else
#line 943
  if (! key) {
    {
#line 944
    tmp = set_errno(22);
    }
#line 944
    return (tmp);
  }
#line 946
  if (map) {
#line 946
    if (map->locker) {
      {
#line 946
      tmp___1 = (*((map->locker)->wrlock))((map->locker)->lock);
#line 946
      tmp___2 = tmp___1;
      }
    } else {
#line 946
      tmp___2 = 0;
    }
#line 946
    err = tmp___2;
  } else {
#line 946
    err = 22;
  }
#line 946
  if (err) {
    {
#line 947
    tmp___0 = set_errno(err);
    }
#line 947
    return (tmp___0);
  }
  {
#line 949
  ret = map_insert_unlocked(map, key, value, replace);
  }
#line 951
  if (map) {
#line 951
    if (map->locker) {
      {
#line 951
      tmp___4 = (*((map->locker)->unlock))((map->locker)->lock);
#line 951
      tmp___5 = tmp___4;
      }
    } else {
#line 951
      tmp___5 = 0;
    }
#line 951
    err = tmp___5;
  } else {
#line 951
    err = 22;
  }
#line 951
  if (err) {
    {
#line 952
    tmp___3 = set_errno(err);
    }
#line 952
    return (tmp___3);
  }
#line 954
  return (ret);
}
}
#line 967 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
int map_insert_unlocked(Map *map , void const   *key , void *value , int replace ) 
{ 
  Mapping *mapping ;
  List *chain ;
  ssize_t length ;
  size_t h ;
  size_t c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  List *tmp___2 ;
  void *tmp___3 ;
  List *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  List *tmp___7 ;

  {
#line 974
  if (! map) {
    {
#line 975
    tmp = set_errno(22);
    }
#line 975
    return (tmp);
  } else
#line 974
  if (! key) {
    {
#line 975
    tmp = set_errno(22);
    }
#line 975
    return (tmp);
  }
#line 977
  if ((double )map->items / (double )map->size >= (double )table_resize_factor) {
    {
#line 978
    tmp___0 = map_resize(map);
    }
#line 978
    if (tmp___0 == -1) {
#line 979
      return (-1);
    }
  }
  {
#line 981
  h = (*(map->hash))(map->size, key);
  }
#line 981
  if (h >= map->size) {
    {
#line 982
    tmp___1 = set_errno(22);
    }
#line 982
    return (tmp___1);
  }
#line 984
  if (! *(map->chain + h)) {
    {
#line 984
    tmp___2 = list_create((map_release_t *)(& mapping_release));
#line 984
    *(map->chain + h) = tmp___2;
    }
#line 984
    if (! tmp___2) {
#line 985
      return (-1);
    }
  }
  {
#line 987
  chain = *(map->chain + h);
#line 989
  length = list_length_unlocked((List const   *)chain);
  }
#line 989
  if (length == -1L) {
#line 990
    return (-1);
  }
#line 992
  c = (size_t )0;
  {
#line 992
  while (1) {
    while_continue: /* CIL Label */ ;
#line 992
    if (! (c < (size_t )length)) {
#line 992
      goto while_break;
    }
    {
#line 994
    tmp___3 = list_item_unlocked((List const   *)chain, (ssize_t )c);
#line 994
    mapping = (Mapping *)tmp___3;
#line 996
    tmp___5 = (*(map->cmp))((void const   *)mapping->key, key);
    }
#line 996
    if (! tmp___5) {
#line 998
      if (replace) {
        {
#line 998
        tmp___4 = list_remove_unlocked(chain, (ssize_t )c);
        }
#line 998
        if (tmp___4) {
#line 999
          goto while_break;
        }
      }
#line 1001
      return (-1);
    }
#line 992
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1005
  tmp___6 = (*(map->copy))(key);
#line 1005
  mapping = mapping_create(tmp___6, value, map->key_destroy, map->value_destroy);
  }
#line 1005
  if (! mapping) {
#line 1006
    return (-1);
  }
  {
#line 1008
  tmp___7 = list_append_unlocked(chain, (void *)mapping);
  }
#line 1008
  if (! tmp___7) {
    {
#line 1010
    mapping_release(mapping);
    }
#line 1011
    return (-1);
  }
#line 1014
  (map->items) ++;
#line 1016
  return (0);
}
}
#line 1032 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
int map_remove(Map *map , void const   *key ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1037
  if (! map) {
    {
#line 1038
    tmp = set_errno(22);
    }
#line 1038
    return (tmp);
  } else
#line 1037
  if (! key) {
    {
#line 1038
    tmp = set_errno(22);
    }
#line 1038
    return (tmp);
  }
#line 1040
  if (map) {
#line 1040
    if (map->locker) {
      {
#line 1040
      tmp___1 = (*((map->locker)->wrlock))((map->locker)->lock);
#line 1040
      tmp___2 = tmp___1;
      }
    } else {
#line 1040
      tmp___2 = 0;
    }
#line 1040
    err = tmp___2;
  } else {
#line 1040
    err = 22;
  }
#line 1040
  if (err) {
    {
#line 1041
    tmp___0 = set_errno(err);
    }
#line 1041
    return (tmp___0);
  }
  {
#line 1043
  ret = map_remove_unlocked(map, key);
  }
#line 1045
  if (map) {
#line 1045
    if (map->locker) {
      {
#line 1045
      tmp___4 = (*((map->locker)->unlock))((map->locker)->lock);
#line 1045
      tmp___5 = tmp___4;
      }
    } else {
#line 1045
      tmp___5 = 0;
    }
#line 1045
    err = tmp___5;
  } else {
#line 1045
    err = 22;
  }
#line 1045
  if (err) {
    {
#line 1046
    tmp___3 = set_errno(err);
    }
#line 1046
    return (tmp___3);
  }
#line 1048
  return (ret);
}
}
#line 1061 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
int map_remove_unlocked(Map *map , void const   *key ) 
{ 
  List *chain ;
  ssize_t length ;
  size_t h ;
  size_t c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  Mapping *mapping ;
  void *tmp___2 ;
  List *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1067
  if (! map) {
    {
#line 1068
    tmp = set_errno(22);
    }
#line 1068
    return (tmp);
  } else
#line 1067
  if (! key) {
    {
#line 1068
    tmp = set_errno(22);
    }
#line 1068
    return (tmp);
  }
  {
#line 1070
  h = (*(map->hash))(map->size, key);
  }
#line 1070
  if (h >= map->size) {
    {
#line 1071
    tmp___0 = set_errno(22);
    }
#line 1071
    return (tmp___0);
  }
#line 1073
  chain = *(map->chain + h);
#line 1073
  if (! chain) {
    {
#line 1074
    tmp___1 = set_errno(2);
    }
#line 1074
    return (tmp___1);
  }
  {
#line 1076
  length = list_length_unlocked((List const   *)chain);
  }
#line 1076
  if (length == -1L) {
#line 1077
    return (-1);
  }
#line 1079
  c = (size_t )0;
  {
#line 1079
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1079
    if (! (c < (size_t )length)) {
#line 1079
      goto while_break;
    }
    {
#line 1081
    tmp___2 = list_item_unlocked((List const   *)chain, (ssize_t )c);
#line 1081
    mapping = (Mapping *)tmp___2;
#line 1083
    tmp___4 = (*(map->cmp))((void const   *)mapping->key, key);
    }
#line 1083
    if (! tmp___4) {
      {
#line 1085
      tmp___3 = list_remove_unlocked(chain, (ssize_t )c);
      }
#line 1085
      if (! tmp___3) {
#line 1086
        return (-1);
      }
#line 1088
      (map->items) --;
#line 1090
      return (0);
    }
#line 1079
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1094
  tmp___5 = set_errno(2);
  }
#line 1094
  return (tmp___5);
}
}
#line 1108 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
void *map_get(Map *map , void const   *key ) 
{ 
  void *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1113
  if (! map) {
    {
#line 1114
    tmp = set_errnull(22);
    }
#line 1114
    return (tmp);
  } else
#line 1113
  if (! key) {
    {
#line 1114
    tmp = set_errnull(22);
    }
#line 1114
    return (tmp);
  }
#line 1116
  if (map) {
#line 1116
    if (map->locker) {
      {
#line 1116
      tmp___1 = (*((map->locker)->rdlock))((map->locker)->lock);
#line 1116
      tmp___2 = tmp___1;
      }
    } else {
#line 1116
      tmp___2 = 0;
    }
#line 1116
    err = tmp___2;
  } else {
#line 1116
    err = 22;
  }
#line 1116
  if (err) {
    {
#line 1117
    tmp___0 = set_errnull(err);
    }
#line 1117
    return (tmp___0);
  }
  {
#line 1119
  ret = map_get_unlocked((Map const   *)map, key);
  }
#line 1121
  if (map) {
#line 1121
    if (map->locker) {
      {
#line 1121
      tmp___4 = (*((map->locker)->unlock))((map->locker)->lock);
#line 1121
      tmp___5 = tmp___4;
      }
    } else {
#line 1121
      tmp___5 = 0;
    }
#line 1121
    err = tmp___5;
  } else {
#line 1121
    err = 22;
  }
#line 1121
  if (err) {
    {
#line 1122
    tmp___3 = set_errnull(err);
    }
#line 1122
    return (tmp___3);
  }
#line 1124
  return (ret);
}
}
#line 1137 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
void *map_get_unlocked(Map const   *map , void const   *key ) 
{ 
  List *chain ;
  ssize_t length ;
  size_t h ;
  size_t c ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  Mapping *mapping ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;

  {
#line 1143
  if (! map) {
    {
#line 1144
    tmp = set_errnull(22);
    }
#line 1144
    return (tmp);
  } else
#line 1143
  if (! key) {
    {
#line 1144
    tmp = set_errnull(22);
    }
#line 1144
    return (tmp);
  }
  {
#line 1146
  h = (*(map->hash))((size_t )map->size, key);
  }
#line 1146
  if (h >= (size_t )map->size) {
    {
#line 1147
    tmp___0 = set_errnull(22);
    }
#line 1147
    return (tmp___0);
  }
#line 1149
  chain = *(map->chain + h);
#line 1149
  if (! chain) {
    {
#line 1150
    tmp___1 = set_errnull(2);
    }
#line 1150
    return (tmp___1);
  }
  {
#line 1152
  length = list_length_unlocked((List const   *)chain);
  }
#line 1152
  if (length == -1L) {
#line 1153
    return ((void *)0);
  }
#line 1155
  c = (size_t )0;
  {
#line 1155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1155
    if (! (c < (size_t )length)) {
#line 1155
      goto while_break;
    }
    {
#line 1157
    tmp___2 = list_item_unlocked((List const   *)chain, (ssize_t )c);
#line 1157
    mapping = (Mapping *)tmp___2;
#line 1159
    tmp___3 = (*(map->cmp))((void const   *)mapping->key, key);
    }
#line 1159
    if (! tmp___3) {
#line 1160
      return (mapping->value);
    }
#line 1155
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1163
  tmp___4 = set_errnull(2);
  }
#line 1163
  return (tmp___4);
}
}
#line 1180 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
Mapper *mapper_create(Map *map ) 
{ 
  Mapper *tmp ;

  {
  {
#line 1182
  tmp = mapper_create_wrlocked(map);
  }
#line 1182
  return (tmp);
}
}
#line 1197 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
Mapper *mapper_create_rdlocked(Map *map ) 
{ 
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  Mapper *tmp___3 ;

  {
#line 1201
  if (! map) {
    {
#line 1202
    tmp = set_errnull(22);
    }
#line 1202
    return ((Mapper *)tmp);
  }
#line 1204
  if (map) {
#line 1204
    if (map->locker) {
      {
#line 1204
      tmp___1 = (*((map->locker)->rdlock))((map->locker)->lock);
#line 1204
      tmp___2 = tmp___1;
      }
    } else {
#line 1204
      tmp___2 = 0;
    }
#line 1204
    err = tmp___2;
  } else {
#line 1204
    err = 22;
  }
#line 1204
  if (err) {
    {
#line 1205
    tmp___0 = set_errnull(err);
    }
#line 1205
    return ((Mapper *)tmp___0);
  }
  {
#line 1207
  tmp___3 = mapper_create_unlocked(map);
  }
#line 1207
  return (tmp___3);
}
}
#line 1221 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
Mapper *mapper_create_wrlocked(Map *map ) 
{ 
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  Mapper *tmp___3 ;

  {
#line 1225
  if (! map) {
    {
#line 1226
    tmp = set_errnull(22);
    }
#line 1226
    return ((Mapper *)tmp);
  }
#line 1228
  if (map) {
#line 1228
    if (map->locker) {
      {
#line 1228
      tmp___1 = (*((map->locker)->wrlock))((map->locker)->lock);
#line 1228
      tmp___2 = tmp___1;
      }
    } else {
#line 1228
      tmp___2 = 0;
    }
#line 1228
    err = tmp___2;
  } else {
#line 1228
    err = 22;
  }
#line 1228
  if (err) {
    {
#line 1229
    tmp___0 = set_errnull(err);
    }
#line 1229
    return ((Mapper *)tmp___0);
  }
  {
#line 1231
  tmp___3 = mapper_create_unlocked(map);
  }
#line 1231
  return (tmp___3);
}
}
#line 1244 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
Mapper *mapper_create_unlocked(Map *map ) 
{ 
  Mapper *mapper ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1248
  if (! map) {
    {
#line 1249
    tmp = set_errnull(22);
    }
#line 1249
    return ((Mapper *)tmp);
  }
  {
#line 1251
  tmp___0 = malloc(sizeof(Mapper ));
#line 1251
  mapper = (Mapper *)tmp___0;
  }
#line 1251
  if (! mapper) {
#line 1252
    return ((Mapper *)((void *)0));
  }
#line 1254
  mapper->map = map;
#line 1255
  mapper->chain_index = (ssize_t )-1;
#line 1256
  mapper->item_index = (ssize_t )-1;
#line 1257
  mapper->next_chain_index = (ssize_t )-1;
#line 1258
  mapper->next_item_index = (ssize_t )-1;
#line 1260
  return (mapper);
}
}
#line 1273 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
void mapper_release(Mapper *mapper ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;

  {
#line 1277
  if (! mapper) {
#line 1278
    return;
  }
#line 1280
  if (mapper->map) {
#line 1280
    if ((mapper->map)->locker) {
      {
#line 1280
      tmp = (*(((mapper->map)->locker)->unlock))(((mapper->map)->locker)->lock);
#line 1280
      tmp___0 = tmp;
      }
    } else {
#line 1280
      tmp___0 = 0;
    }
#line 1280
    err = tmp___0;
  } else {
#line 1280
    err = 22;
  }
#line 1280
  if (err) {
    {
#line 1282
    set_errno(err);
    }
#line 1283
    return;
  }
  {
#line 1286
  free((void *)mapper);
  }
#line 1287
  return;
}
}
#line 1300 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
void mapper_release_unlocked(Mapper *mapper ) 
{ 


  {
#line 1302
  if (! mapper) {
#line 1303
    return;
  }
  {
#line 1305
  free((void *)mapper);
  }
#line 1306
  return;
}
}
#line 1319 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
void *mapper_destroy(Mapper **mapper ) 
{ 


  {
#line 1321
  if (mapper) {
#line 1321
    if (*mapper) {
      {
#line 1323
      mapper_release(*mapper);
#line 1324
      *mapper = (Mapper *)((void *)0);
      }
    }
  }
#line 1327
  return ((void *)0);
}
}
#line 1341 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
void *mapper_destroy_unlocked(Mapper **mapper ) 
{ 


  {
#line 1343
  if (mapper) {
#line 1343
    if (*mapper) {
      {
#line 1345
      mapper_release_unlocked(*mapper);
#line 1346
      *mapper = (Mapper *)((void *)0);
      }
    }
  }
#line 1349
  return ((void *)0);
}
}
#line 1363 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
int mapper_has_next(Mapper *mapper ) 
{ 
  List *chain ;
  ssize_t length ;
  int tmp ;

  {
#line 1368
  if (! mapper) {
    {
#line 1369
    tmp = set_errno(22);
    }
#line 1369
    return (tmp);
  }
#line 1373
  mapper->next_chain_index = mapper->chain_index;
#line 1374
  mapper->next_item_index = mapper->item_index;
#line 1376
  if (mapper->next_chain_index == -1L) {
#line 1377
    (mapper->next_chain_index) ++;
  }
  {
#line 1379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1379
    if ((size_t )mapper->next_chain_index < (mapper->map)->size) {
#line 1379
      if (! (! *((mapper->map)->chain + mapper->next_chain_index))) {
#line 1379
        goto while_break;
      }
    } else {
#line 1379
      goto while_break;
    }
#line 1380
    (mapper->next_chain_index) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1382
  if ((size_t )mapper->next_chain_index == (mapper->map)->size) {
#line 1383
    return (0);
  }
  {
#line 1385
  chain = *((mapper->map)->chain + mapper->next_chain_index);
#line 1389
  length = list_length_unlocked((List const   *)chain);
  }
#line 1389
  if (length == -1L) {
#line 1390
    return (-1);
  }
#line 1392
  (mapper->next_item_index) ++;
#line 1392
  if (mapper->next_item_index < length) {
#line 1393
    return (1);
  }
  {
#line 1395
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1397
    (mapper->next_chain_index) ++;
    {
#line 1399
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1399
      if ((size_t )mapper->next_chain_index < (mapper->map)->size) {
#line 1399
        if (! (! *((mapper->map)->chain + mapper->next_chain_index))) {
#line 1399
          goto while_break___1;
        }
      } else {
#line 1399
        goto while_break___1;
      }
#line 1400
      (mapper->next_chain_index) ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1402
    if ((size_t )mapper->next_chain_index == (mapper->map)->size) {
#line 1403
      return (0);
    }
    {
#line 1405
    chain = *((mapper->map)->chain + mapper->next_chain_index);
#line 1407
    length = list_length_unlocked((List const   *)chain);
    }
#line 1407
    if (length == -1L) {
#line 1408
      return (-1);
    }
#line 1395
    if (! (length == 0L)) {
#line 1395
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1412
  mapper->next_item_index = (ssize_t )0;
#line 1414
  return (1);
}
}
#line 1428 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
void *mapper_next(Mapper *mapper ) 
{ 
  void *tmp ;
  Mapping const   *tmp___0 ;

  {
#line 1430
  if (! mapper) {
    {
#line 1431
    tmp = set_errnull(22);
    }
#line 1431
    return (tmp);
  }
  {
#line 1433
  tmp___0 = mapper_next_mapping(mapper);
  }
#line 1433
  return ((void *)tmp___0->value);
}
}
#line 1447 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
Mapping const   *mapper_next_mapping(Mapper *mapper ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 1449
  if (! mapper) {
    {
#line 1450
    tmp = set_errnull(22);
    }
#line 1450
    return ((Mapping const   *)tmp);
  }
  {
#line 1452
  mapper->chain_index = mapper->next_chain_index;
#line 1453
  mapper->item_index = mapper->next_item_index;
#line 1455
  tmp___0 = list_item_unlocked((List const   *)*((mapper->map)->chain + mapper->chain_index),
                               mapper->item_index);
  }
#line 1455
  return ((Mapping const   *)((Mapping *)tmp___0));
}
}
#line 1470 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
void mapper_remove(Mapper *mapper ) 
{ 
  ssize_t tmp ;

  {
#line 1472
  if (! mapper) {
    {
#line 1474
    set_errno(22);
    }
#line 1475
    return;
  }
#line 1478
  if (mapper->item_index == -1L) {
    {
#line 1480
    set_errno(22);
    }
#line 1481
    return;
  }
  {
#line 1484
  tmp = mapper->item_index;
#line 1484
  (mapper->item_index) --;
#line 1484
  list_remove_unlocked(*((mapper->map)->chain + mapper->chain_index), (ssize_t )((size_t )tmp));
#line 1485
  ((mapper->map)->items) --;
  }
#line 1486
  return;
}
}
#line 1524 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
int map_has_next(Map *map ) 
{ 
  int has ;
  int tmp ;
  Mapper *tmp___0 ;

  {
#line 1528
  if (! map) {
    {
#line 1529
    tmp = set_errno(22);
    }
#line 1529
    return (tmp);
  }
#line 1531
  if (! map->mapper) {
    {
#line 1531
    tmp___0 = mapper_create_unlocked(map);
#line 1531
    map->mapper = tmp___0;
    }
#line 1531
    if (! tmp___0) {
#line 1532
      return (-1);
    }
  }
  {
#line 1534
  has = mapper_has_next(map->mapper);
  }
#line 1534
  if (has != 1) {
    {
#line 1535
    map_break(map);
    }
  }
#line 1537
  return (has);
}
}
#line 1552 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
void map_break(Map *map ) 
{ 


  {
#line 1554
  if (! map) {
    {
#line 1556
    set_errno(22);
    }
#line 1557
    return;
  }
  {
#line 1560
  mapper_destroy_unlocked(& map->mapper);
  }
#line 1561
  return;
}
}
#line 1574 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
void *map_next(Map *map ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 1576
  if (! map) {
    {
#line 1577
    tmp = set_errnull(22);
    }
#line 1577
    return (tmp);
  } else
#line 1576
  if (! map->mapper) {
    {
#line 1577
    tmp = set_errnull(22);
    }
#line 1577
    return (tmp);
  }
  {
#line 1579
  tmp___0 = mapper_next(map->mapper);
  }
#line 1579
  return (tmp___0);
}
}
#line 1593 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
Mapping const   *map_next_mapping(Map *map ) 
{ 
  void *tmp ;
  Mapping const   *tmp___0 ;

  {
#line 1595
  if (! map) {
    {
#line 1596
    tmp = set_errnull(22);
    }
#line 1596
    return ((Mapping const   *)tmp);
  } else
#line 1595
  if (! map->mapper) {
    {
#line 1596
    tmp = set_errnull(22);
    }
#line 1596
    return ((Mapping const   *)tmp);
  }
  {
#line 1598
  tmp___0 = mapper_next_mapping(map->mapper);
  }
#line 1598
  return (tmp___0);
}
}
#line 1613 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
void map_remove_current(Map *map ) 
{ 


  {
#line 1615
  if (! map) {
    {
#line 1617
    set_errno(22);
    }
#line 1618
    return;
  } else
#line 1615
  if (! map->mapper) {
    {
#line 1617
    set_errno(22);
    }
#line 1618
    return;
  }
  {
#line 1621
  mapper_remove(map->mapper);
  }
#line 1622
  return;
}
}
#line 1635 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
void const   *mapping_key(Mapping const   *mapping ) 
{ 
  void *tmp ;

  {
#line 1637
  if (! mapping) {
    {
#line 1638
    tmp = set_errnull(22);
    }
#line 1638
    return ((void const   *)tmp);
  }
#line 1640
  return ((void const   *)mapping->key);
}
}
#line 1654 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
void const   *mapping_value(Mapping const   *mapping ) 
{ 
  void *tmp ;

  {
#line 1656
  if (! mapping) {
    {
#line 1657
    tmp = set_errnull(22);
    }
#line 1657
    return ((void const   *)tmp);
  }
#line 1659
  return ((void const   *)mapping->value);
}
}
#line 1676 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
List *map_keys(Map *map ) 
{ 
  List *tmp ;

  {
  {
#line 1678
  tmp = map_keys_with_locker((Locker *)((void *)0), map);
  }
#line 1678
  return (tmp);
}
}
#line 1691 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
List *map_keys_unlocked(Map *map ) 
{ 
  List *tmp ;

  {
  {
#line 1693
  tmp = map_keys_with_locker_unlocked((Locker *)((void *)0), map);
  }
#line 1693
  return (tmp);
}
}
#line 1707 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
List *map_keys_with_locker(Locker *locker , Map *map ) 
{ 
  List *keys ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1712
  if (! map) {
    {
#line 1713
    tmp = set_errnull(22);
    }
#line 1713
    return ((List *)tmp);
  }
#line 1715
  if (map) {
#line 1715
    if (map->locker) {
      {
#line 1715
      tmp___1 = (*((map->locker)->rdlock))((map->locker)->lock);
#line 1715
      tmp___2 = tmp___1;
      }
    } else {
#line 1715
      tmp___2 = 0;
    }
#line 1715
    err = tmp___2;
  } else {
#line 1715
    err = 22;
  }
#line 1715
  if (err) {
    {
#line 1716
    tmp___0 = set_errnull(err);
    }
#line 1716
    return ((List *)tmp___0);
  }
  {
#line 1718
  keys = map_keys_with_locker_unlocked(locker, map);
  }
#line 1720
  if (map) {
#line 1720
    if (map->locker) {
      {
#line 1720
      tmp___4 = (*((map->locker)->unlock))((map->locker)->lock);
#line 1720
      tmp___5 = tmp___4;
      }
    } else {
#line 1720
      tmp___5 = 0;
    }
#line 1720
    err = tmp___5;
  } else {
#line 1720
    err = 22;
  }
#line 1720
  if (err) {
    {
#line 1721
    tmp___3 = set_errnull(err);
    }
#line 1721
    return ((List *)tmp___3);
  }
#line 1723
  return (keys);
}
}
#line 1737 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
List *map_keys_with_locker_unlocked(Locker *locker , Map *map ) 
{ 
  Mapper *mapper ;
  List *keys ;
  void *tmp ;
  Mapping const   *mapping ;
  Mapping const   *tmp___0 ;
  List *tmp___1 ;
  int tmp___2 ;

  {
#line 1742
  if (! map) {
    {
#line 1743
    tmp = set_errnull(22);
    }
#line 1743
    return ((List *)tmp);
  }
  {
#line 1745
  keys = list_create_with_locker(locker, (list_release_t *)((void *)0));
  }
#line 1745
  if (! keys) {
#line 1746
    return ((List *)((void *)0));
  }
  {
#line 1748
  mapper = mapper_create_unlocked(map);
  }
#line 1748
  if (! mapper) {
    {
#line 1750
    list_release(keys);
    }
#line 1751
    return ((List *)((void *)0));
  }
  {
#line 1754
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1754
    tmp___2 = mapper_has_next(mapper);
    }
#line 1754
    if (! (tmp___2 == 1)) {
#line 1754
      goto while_break;
    }
    {
#line 1756
    tmp___0 = mapper_next_mapping(mapper);
#line 1756
    mapping = tmp___0;
#line 1758
    tmp___1 = list_append(keys, (void *)mapping->key);
    }
#line 1758
    if (! tmp___1) {
      {
#line 1760
      list_destroy(& keys);
      }
#line 1761
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1765
  mapper_release_unlocked(mapper);
  }
#line 1767
  return (keys);
}
}
#line 1784 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
List *map_values(Map *map ) 
{ 
  List *tmp ;

  {
  {
#line 1786
  tmp = map_values_with_locker((Locker *)((void *)0), map);
  }
#line 1786
  return (tmp);
}
}
#line 1799 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
List *map_values_unlocked(Map *map ) 
{ 
  List *tmp ;

  {
  {
#line 1801
  tmp = map_values_with_locker_unlocked((Locker *)((void *)0), map);
  }
#line 1801
  return (tmp);
}
}
#line 1815 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
List *map_values_with_locker(Locker *locker , Map *map ) 
{ 
  List *values ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1820
  if (! map) {
    {
#line 1821
    tmp = set_errnull(22);
    }
#line 1821
    return ((List *)tmp);
  }
#line 1823
  if (map) {
#line 1823
    if (map->locker) {
      {
#line 1823
      tmp___1 = (*((map->locker)->rdlock))((map->locker)->lock);
#line 1823
      tmp___2 = tmp___1;
      }
    } else {
#line 1823
      tmp___2 = 0;
    }
#line 1823
    err = tmp___2;
  } else {
#line 1823
    err = 22;
  }
#line 1823
  if (err) {
    {
#line 1824
    tmp___0 = set_errnull(err);
    }
#line 1824
    return ((List *)tmp___0);
  }
  {
#line 1826
  values = map_values_with_locker_unlocked(locker, map);
  }
#line 1828
  if (map) {
#line 1828
    if (map->locker) {
      {
#line 1828
      tmp___4 = (*((map->locker)->unlock))((map->locker)->lock);
#line 1828
      tmp___5 = tmp___4;
      }
    } else {
#line 1828
      tmp___5 = 0;
    }
#line 1828
    err = tmp___5;
  } else {
#line 1828
    err = 22;
  }
#line 1828
  if (err) {
    {
#line 1829
    tmp___3 = set_errnull(err);
    }
#line 1829
    return ((List *)tmp___3);
  }
#line 1831
  return (values);
}
}
#line 1845 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
List *map_values_with_locker_unlocked(Locker *locker , Map *map ) 
{ 
  Mapper *mapper ;
  List *values ;
  void *tmp ;
  Mapping const   *mapping ;
  Mapping const   *tmp___0 ;
  List *tmp___1 ;
  int tmp___2 ;

  {
#line 1850
  if (! map) {
    {
#line 1851
    tmp = set_errnull(22);
    }
#line 1851
    return ((List *)tmp);
  }
  {
#line 1853
  values = list_create_with_locker(locker, (list_release_t *)((void *)0));
  }
#line 1853
  if (! values) {
#line 1854
    return ((List *)((void *)0));
  }
  {
#line 1856
  mapper = mapper_create_unlocked(map);
  }
#line 1856
  if (! mapper) {
    {
#line 1858
    list_release(values);
    }
#line 1859
    return ((List *)((void *)0));
  }
  {
#line 1862
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1862
    tmp___2 = mapper_has_next(mapper);
    }
#line 1862
    if (! (tmp___2 == 1)) {
#line 1862
      goto while_break;
    }
    {
#line 1864
    tmp___0 = mapper_next_mapping(mapper);
#line 1864
    mapping = tmp___0;
#line 1866
    tmp___1 = list_append(values, (void *)mapping->value);
    }
#line 1866
    if (! tmp___1) {
      {
#line 1868
      list_destroy(& values);
      }
#line 1869
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1873
  mapper_release_unlocked(mapper);
  }
#line 1875
  return (values);
}
}
#line 1890 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
void map_apply(Map *map , map_action_t *action , void *data ) 
{ 


  {
  {
#line 1892
  map_apply_wrlocked(map, action, data);
  }
#line 1893
  return;
}
}
#line 1907 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
void map_apply_rdlocked(Map *map , map_action_t *action , void *data ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1911
  if (! map) {
    {
#line 1913
    set_errno(22);
    }
#line 1914
    return;
  } else
#line 1911
  if (! action) {
    {
#line 1913
    set_errno(22);
    }
#line 1914
    return;
  }
#line 1917
  if (map) {
#line 1917
    if (map->locker) {
      {
#line 1917
      tmp = (*((map->locker)->rdlock))((map->locker)->lock);
#line 1917
      tmp___0 = tmp;
      }
    } else {
#line 1917
      tmp___0 = 0;
    }
#line 1917
    err = tmp___0;
  } else {
#line 1917
    err = 22;
  }
#line 1917
  if (err) {
    {
#line 1919
    set_errno(err);
    }
#line 1920
    return;
  }
  {
#line 1923
  map_apply_unlocked(map, action, data);
  }
#line 1925
  if (map) {
#line 1925
    if (map->locker) {
      {
#line 1925
      tmp___1 = (*((map->locker)->unlock))((map->locker)->lock);
#line 1925
      tmp___2 = tmp___1;
      }
    } else {
#line 1925
      tmp___2 = 0;
    }
#line 1925
    err = tmp___2;
  } else {
#line 1925
    err = 22;
  }
#line 1925
  if (err) {
    {
#line 1927
    set_errno(err);
    }
#line 1928
    return;
  }
#line 1930
  return;
}
}
#line 1943 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
void map_apply_wrlocked(Map *map , map_action_t *action , void *data ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1947
  if (! map) {
    {
#line 1949
    set_errno(22);
    }
#line 1950
    return;
  } else
#line 1947
  if (! action) {
    {
#line 1949
    set_errno(22);
    }
#line 1950
    return;
  }
#line 1953
  if (map) {
#line 1953
    if (map->locker) {
      {
#line 1953
      tmp = (*((map->locker)->wrlock))((map->locker)->lock);
#line 1953
      tmp___0 = tmp;
      }
    } else {
#line 1953
      tmp___0 = 0;
    }
#line 1953
    err = tmp___0;
  } else {
#line 1953
    err = 22;
  }
#line 1953
  if (err) {
    {
#line 1955
    set_errno(err);
    }
#line 1956
    return;
  }
  {
#line 1959
  map_apply_unlocked(map, action, data);
  }
#line 1961
  if (map) {
#line 1961
    if (map->locker) {
      {
#line 1961
      tmp___1 = (*((map->locker)->unlock))((map->locker)->lock);
#line 1961
      tmp___2 = tmp___1;
      }
    } else {
#line 1961
      tmp___2 = 0;
    }
#line 1961
    err = tmp___2;
  } else {
#line 1961
    err = 22;
  }
#line 1961
  if (err) {
    {
#line 1963
    set_errno(err);
    }
#line 1964
    return;
  }
#line 1966
  return;
}
}
#line 1978 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
void map_apply_unlocked(Map *map , map_action_t *action , void *data ) 
{ 
  Mapper *mapper ;
  Mapping const   *mapping ;
  Mapping const   *tmp ;
  int tmp___0 ;

  {
#line 1982
  if (! map) {
    {
#line 1984
    set_errno(22);
    }
#line 1985
    return;
  } else
#line 1982
  if (! action) {
    {
#line 1984
    set_errno(22);
    }
#line 1985
    return;
  }
  {
#line 1988
  mapper = mapper_create_unlocked(map);
  }
#line 1988
  if (! mapper) {
#line 1989
    return;
  }
  {
#line 1991
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1991
    tmp___0 = mapper_has_next(mapper);
    }
#line 1991
    if (! (tmp___0 == 1)) {
#line 1991
      goto while_break;
    }
    {
#line 1993
    tmp = mapper_next_mapping(mapper);
#line 1993
    mapping = tmp;
#line 1994
    (*action)((void *)mapping->key, (void *)mapping->value, data);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1997
  mapper_release_unlocked(mapper);
  }
#line 1998
  return;
}
}
#line 2011 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
ssize_t map_size(Map *map ) 
{ 
  size_t size ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 2016
  if (! map) {
    {
#line 2017
    tmp = set_errno(22);
    }
#line 2017
    return ((ssize_t )tmp);
  }
#line 2019
  if (map) {
#line 2019
    if (map->locker) {
      {
#line 2019
      tmp___1 = (*((map->locker)->rdlock))((map->locker)->lock);
#line 2019
      tmp___2 = tmp___1;
      }
    } else {
#line 2019
      tmp___2 = 0;
    }
#line 2019
    err = tmp___2;
  } else {
#line 2019
    err = 22;
  }
#line 2019
  if (err) {
    {
#line 2020
    tmp___0 = set_errno(err);
    }
#line 2020
    return ((ssize_t )tmp___0);
  }
#line 2022
  size = map->items;
#line 2024
  if (map) {
#line 2024
    if (map->locker) {
      {
#line 2024
      tmp___4 = (*((map->locker)->unlock))((map->locker)->lock);
#line 2024
      tmp___5 = tmp___4;
      }
    } else {
#line 2024
      tmp___5 = 0;
    }
#line 2024
    err = tmp___5;
  } else {
#line 2024
    err = 22;
  }
#line 2024
  if (err) {
    {
#line 2025
    tmp___3 = set_errno(err);
    }
#line 2025
    return ((ssize_t )tmp___3);
  }
#line 2027
  return ((ssize_t )size);
}
}
#line 2040 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/map.c"
ssize_t map_size_unlocked(Map const   *map ) 
{ 
  int tmp ;

  {
#line 2042
  if (! map) {
    {
#line 2043
    tmp = set_errno(22);
    }
#line 2043
    return ((ssize_t )tmp);
  }
#line 2045
  return ((ssize_t )map->items);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 412 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 277 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) pthread_t ( __attribute__((__leaf__)) pthread_self)(void)  __attribute__((__const__)) ;
#line 760
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_trylock)(pthread_mutex_t *__mutex ) ;
#line 764
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 899
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_rwlock_rdlock)(pthread_rwlock_t *__rwlock ) ;
#line 903
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_rwlock_tryrdlock)(pthread_rwlock_t *__rwlock ) ;
#line 914
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_rwlock_wrlock)(pthread_rwlock_t *__rwlock ) ;
#line 918
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_rwlock_trywrlock)(pthread_rwlock_t *__rwlock ) ;
#line 929
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_rwlock_unlock)(pthread_rwlock_t *__rwlock ) ;
#line 64 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/locker.h"
Locker *locker_create_mutex(pthread_mutex_t *mutex ) ;
#line 65
Locker *locker_create_rwlock(pthread_rwlock_t *rwlock ) ;
#line 66
Locker *locker_create_debug_mutex(pthread_mutex_t *mutex ) ;
#line 67
Locker *locker_create_debug_rwlock(pthread_rwlock_t *rwlock ) ;
#line 68
Locker *locker_create(void *lock , lockerf_t *tryrdlock , lockerf_t *rdlock , lockerf_t *trywrlock ,
                      lockerf_t *wrlock , lockerf_t *unlock ) ;
#line 69
void locker_release(Locker *locker ) ;
#line 70
void *locker_destroy(Locker **locker ) ;
#line 71
int locker_tryrdlock(Locker *locker ) ;
#line 72
int locker_rdlock(Locker *locker ) ;
#line 73
int locker_trywrlock(Locker *locker ) ;
#line 74
int locker_wrlock(Locker *locker ) ;
#line 75
int locker_unlock(Locker *locker ) ;
#line 179 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/locker.c"
Locker *locker_create_mutex(pthread_mutex_t *mutex ) 
{ 
  Locker *tmp ;

  {
  {
#line 181
  tmp = locker_create((void *)mutex, (lockerf_t *)(& pthread_mutex_trylock), (lockerf_t *)(& pthread_mutex_lock),
                      (lockerf_t *)(& pthread_mutex_trylock), (lockerf_t *)(& pthread_mutex_lock),
                      (lockerf_t *)(& pthread_mutex_unlock));
  }
#line 181
  return (tmp);
}
}
#line 210 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/locker.c"
Locker *locker_create_rwlock(pthread_rwlock_t *rwlock ) 
{ 
  Locker *tmp ;

  {
  {
#line 212
  tmp = locker_create((void *)rwlock, (lockerf_t *)(& pthread_rwlock_tryrdlock), (lockerf_t *)(& pthread_rwlock_rdlock),
                      (lockerf_t *)(& pthread_rwlock_trywrlock), (lockerf_t *)(& pthread_rwlock_wrlock),
                      (lockerf_t *)(& pthread_rwlock_unlock));
  }
#line 212
  return (tmp);
}
}
#line 243 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/locker.c"
static int debug_invoke(char const   *name , lockerf_t *action , void *lock ) 
{ 
  int err ;
  pthread_t tmp ;
  char *tmp___0 ;
  pthread_t tmp___1 ;
  pthread_t tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 247
  tmp = pthread_self();
#line 247
  printf((char const   */* __restrict  */)"[%lu] %s(%p) ...\n", tmp, name, lock);
#line 248
  err = (*action)(lock);
  }
#line 249
  if (err) {
    {
#line 250
    tmp___0 = strerror(err);
#line 250
    tmp___1 = pthread_self();
#line 250
    printf((char const   */* __restrict  */)"[%lu] %s(%p) done (%s)\n", tmp___1, name,
           lock, tmp___0);
    }
  } else {
    {
#line 252
    tmp___2 = pthread_self();
#line 252
    printf((char const   */* __restrict  */)"[%lu] %s(%p) done\n", tmp___2, name,
           lock);
    }
  }
#line 253
  return (err);
}
}
#line 256 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/locker.c"
static int debug_pthread_mutex_trylock(pthread_mutex_t *mutex ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 258
  tmp = debug_invoke("pthread_mutex_trylock", (lockerf_t *)(& pthread_mutex_trylock),
                     (void *)mutex);
  }
#line 258
  return (tmp);
}
}
#line 261 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/locker.c"
static int debug_pthread_mutex_lock(pthread_mutex_t *mutex ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 263
  tmp = debug_invoke("pthread_mutex_lock", (lockerf_t *)(& pthread_mutex_lock), (void *)mutex);
  }
#line 263
  return (tmp);
}
}
#line 266 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/locker.c"
static int debug_pthread_mutex_unlock(pthread_mutex_t *mutex ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 268
  tmp = debug_invoke("pthread_mutex_unlock", (lockerf_t *)(& pthread_mutex_unlock),
                     (void *)mutex);
  }
#line 268
  return (tmp);
}
}
#line 271 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/locker.c"
Locker *locker_create_debug_mutex(pthread_mutex_t *mutex ) 
{ 
  Locker *tmp ;

  {
  {
#line 273
  tmp = locker_create((void *)mutex, (lockerf_t *)(& debug_pthread_mutex_trylock),
                      (lockerf_t *)(& debug_pthread_mutex_lock), (lockerf_t *)(& debug_pthread_mutex_trylock),
                      (lockerf_t *)(& debug_pthread_mutex_lock), (lockerf_t *)(& debug_pthread_mutex_unlock));
  }
#line 273
  return (tmp);
}
}
#line 302 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/locker.c"
static int debug_pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 304
  tmp = debug_invoke("pthread_rwlock_tryrdlock", (lockerf_t *)(& pthread_rwlock_tryrdlock),
                     (void *)rwlock);
  }
#line 304
  return (tmp);
}
}
#line 307 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/locker.c"
static int debug_pthread_rwlock_rdlock(pthread_rwlock_t *rwlock ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 309
  tmp = debug_invoke("pthread_rwlock_rdlock", (lockerf_t *)(& pthread_rwlock_rdlock),
                     (void *)rwlock);
  }
#line 309
  return (tmp);
}
}
#line 312 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/locker.c"
static int debug_pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 314
  tmp = debug_invoke("pthread_rwlock_trywrlock", (lockerf_t *)(& pthread_rwlock_trywrlock),
                     (void *)rwlock);
  }
#line 314
  return (tmp);
}
}
#line 317 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/locker.c"
static int debug_pthread_rwlock_wrlock(pthread_rwlock_t *rwlock ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 319
  tmp = debug_invoke("pthread_rwlock_wrlock", (lockerf_t *)(& pthread_rwlock_wrlock),
                     (void *)rwlock);
  }
#line 319
  return (tmp);
}
}
#line 322 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/locker.c"
static int debug_pthread_rwlock_unlock(pthread_rwlock_t *rwlock ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 324
  tmp = debug_invoke("pthread_rwlock_unlock", (lockerf_t *)(& pthread_rwlock_unlock),
                     (void *)rwlock);
  }
#line 324
  return (tmp);
}
}
#line 327 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/locker.c"
Locker *locker_create_debug_rwlock(pthread_rwlock_t *rwlock ) 
{ 
  Locker *tmp ;

  {
  {
#line 329
  tmp = locker_create((void *)rwlock, (lockerf_t *)(& debug_pthread_rwlock_tryrdlock),
                      (lockerf_t *)(& debug_pthread_rwlock_rdlock), (lockerf_t *)(& debug_pthread_rwlock_trywrlock),
                      (lockerf_t *)(& debug_pthread_rwlock_wrlock), (lockerf_t *)(& debug_pthread_rwlock_unlock));
  }
#line 329
  return (tmp);
}
}
#line 359 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/locker.c"
Locker *locker_create(void *lock , lockerf_t *tryrdlock , lockerf_t *rdlock , lockerf_t *trywrlock ,
                      lockerf_t *wrlock , lockerf_t *unlock ) 
{ 
  Locker *locker ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 363
  if (! lock) {
    {
#line 364
    tmp = set_errnull(22);
    }
#line 364
    return ((Locker *)tmp);
  } else
#line 363
  if (! tryrdlock) {
    {
#line 364
    tmp = set_errnull(22);
    }
#line 364
    return ((Locker *)tmp);
  } else
#line 363
  if (! rdlock) {
    {
#line 364
    tmp = set_errnull(22);
    }
#line 364
    return ((Locker *)tmp);
  } else
#line 363
  if (! trywrlock) {
    {
#line 364
    tmp = set_errnull(22);
    }
#line 364
    return ((Locker *)tmp);
  } else
#line 363
  if (! wrlock) {
    {
#line 364
    tmp = set_errnull(22);
    }
#line 364
    return ((Locker *)tmp);
  } else
#line 363
  if (! unlock) {
    {
#line 364
    tmp = set_errnull(22);
    }
#line 364
    return ((Locker *)tmp);
  }
  {
#line 366
  tmp___0 = malloc(sizeof(Locker ));
#line 366
  locker = (Locker *)tmp___0;
  }
#line 366
  if (! locker) {
#line 367
    return ((Locker *)((void *)0));
  }
#line 369
  locker->lock = lock;
#line 370
  locker->tryrdlock = tryrdlock;
#line 371
  locker->rdlock = rdlock;
#line 372
  locker->trywrlock = trywrlock;
#line 373
  locker->wrlock = wrlock;
#line 374
  locker->unlock = unlock;
#line 376
  return (locker);
}
}
#line 390 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/locker.c"
void locker_release(Locker *locker ) 
{ 


  {
#line 392
  if (! locker) {
#line 393
    return;
  }
  {
#line 395
  free((void *)locker);
  }
#line 396
  return;
}
}
#line 410 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/locker.c"
void *locker_destroy(Locker **locker ) 
{ 


  {
#line 412
  if (locker) {
#line 412
    if (*locker) {
      {
#line 414
      locker_release(*locker);
#line 415
      *locker = (Locker *)((void *)0);
      }
    }
  }
#line 418
  return ((void *)0);
}
}
#line 435 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/locker.c"
int locker_tryrdlock(Locker *locker ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 437
  if (locker) {
    {
#line 437
    tmp = (*(locker->tryrdlock))(locker->lock);
#line 437
    tmp___0 = tmp;
    }
  } else {
#line 437
    tmp___0 = 0;
  }
#line 437
  return (tmp___0);
}
}
#line 453 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/locker.c"
int locker_rdlock(Locker *locker ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 455
  if (locker) {
    {
#line 455
    tmp = (*(locker->rdlock))(locker->lock);
#line 455
    tmp___0 = tmp;
    }
  } else {
#line 455
    tmp___0 = 0;
  }
#line 455
  return (tmp___0);
}
}
#line 472 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/locker.c"
int locker_trywrlock(Locker *locker ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 474
  if (locker) {
    {
#line 474
    tmp = (*(locker->trywrlock))(locker->lock);
#line 474
    tmp___0 = tmp;
    }
  } else {
#line 474
    tmp___0 = 0;
  }
#line 474
  return (tmp___0);
}
}
#line 490 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/locker.c"
int locker_wrlock(Locker *locker ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 492
  if (locker) {
    {
#line 492
    tmp = (*(locker->wrlock))(locker->lock);
#line 492
    tmp___0 = tmp;
    }
  } else {
#line 492
    tmp___0 = 0;
  }
#line 492
  return (tmp___0);
}
}
#line 508 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/locker.c"
int locker_unlock(Locker *locker ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 510
  if (locker) {
    {
#line 510
    tmp = (*(locker->unlock))(locker->lock);
#line 510
    tmp___0 = tmp;
    }
  } else {
#line 510
    tmp___0 = 0;
  }
#line 510
  return (tmp___0);
}
}
#line 764 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 45 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.h"
List *list_make(list_release_t *destroy  , ...) ;
#line 46
List *list_vmake(list_release_t *destroy , va_list args ) ;
#line 47
List *list_copy(List const   *src , list_copy_t *copy ) ;
#line 49
List *list_make_with_locker(Locker *locker , list_release_t *destroy  , ...) ;
#line 50
List *list_vmake_with_locker(Locker *locker , list_release_t *destroy , va_list args ) ;
#line 51
List *list_copy_with_locker(Locker *locker , List const   *src , list_copy_t *copy ) ;
#line 53
int list_wrlock(List const   *list ) ;
#line 57
int list_own(List *list , list_release_t *destroy ) ;
#line 58
int list_own_unlocked(List *list , list_release_t *destroy ) ;
#line 59
list_release_t *list_disown(List *list ) ;
#line 60
list_release_t *list_disown_unlocked(List *list ) ;
#line 63
int list_item_int(List const   *list , ssize_t index ) ;
#line 64
int list_item_int_unlocked(List const   *list , ssize_t index ) ;
#line 65
int list_empty(List const   *list ) ;
#line 66
int list_empty_unlocked(List const   *list ) ;
#line 69
ssize_t list_last(List const   *list ) ;
#line 70
ssize_t list_last_unlocked(List const   *list ) ;
#line 71
List *list_remove(List *list , ssize_t index ) ;
#line 73
List *list_remove_range(List *list , ssize_t index , ssize_t range ) ;
#line 74
List *list_remove_range_unlocked(List *list , ssize_t index , ssize_t range ) ;
#line 75
List *list_insert(List *list , ssize_t index , void *item ) ;
#line 76
List *list_insert_unlocked(List *list , ssize_t index , void *item ) ;
#line 77
List *list_insert_int(List *list , ssize_t index , int item ) ;
#line 78
List *list_insert_int_unlocked(List *list , ssize_t index , int item ) ;
#line 79
List *list_insert_list(List *list , ssize_t index , List const   *src , list_copy_t *copy ) ;
#line 80
List *list_insert_list_unlocked(List *list , ssize_t index , List const   *src , list_copy_t *copy ) ;
#line 83
List *list_append_int(List *list , int item ) ;
#line 84
List *list_append_int_unlocked(List *list , int item ) ;
#line 85
List *list_append_list(List *list , List const   *src , list_copy_t *copy ) ;
#line 86
List *list_append_list_unlocked(List *list , List const   *src , list_copy_t *copy ) ;
#line 87
List *list_prepend(List *list , void *item ) ;
#line 88
List *list_prepend_unlocked(List *list , void *item ) ;
#line 89
List *list_prepend_int(List *list , int item ) ;
#line 90
List *list_prepend_int_unlocked(List *list , int item ) ;
#line 91
List *list_prepend_list(List *list , List const   *src , list_copy_t *copy ) ;
#line 92
List *list_prepend_list_unlocked(List *list , List const   *src , list_copy_t *copy ) ;
#line 93
List *list_replace(List *list , ssize_t index , ssize_t range , void *item ) ;
#line 94
List *list_replace_unlocked(List *list , ssize_t index , ssize_t range , void *item ) ;
#line 95
List *list_replace_int(List *list , ssize_t index , ssize_t range , int item ) ;
#line 96
List *list_replace_int_unlocked(List *list , ssize_t index , ssize_t range , int item ) ;
#line 97
List *list_replace_list(List *list , ssize_t index , ssize_t range , List const   *src ,
                        list_copy_t *copy ) ;
#line 98
List *list_replace_list_unlocked(List *list , ssize_t index , ssize_t range , List const   *src ,
                                 list_copy_t *copy ) ;
#line 99
List *list_extract(List const   *list , ssize_t index , ssize_t range , list_copy_t *copy ) ;
#line 100
List *list_extract_unlocked(List const   *list , ssize_t index , ssize_t range , list_copy_t *copy ) ;
#line 101
List *list_extract_with_locker(Locker *locker , List const   *list , ssize_t index ,
                               ssize_t range , list_copy_t *copy ) ;
#line 102
List *list_extract_with_locker_unlocked(Locker *locker , List const   *list , ssize_t index ,
                                        ssize_t range , list_copy_t *copy ) ;
#line 103
List *list_push(List *list , void *item ) ;
#line 104
List *list_push_unlocked(List *list , void *item ) ;
#line 105
List *list_push_int(List *list , int item ) ;
#line 106
List *list_push_int_unlocked(List *list , int item ) ;
#line 107
void *list_pop(List *list ) ;
#line 108
void *list_pop_unlocked(List *list ) ;
#line 109
int list_pop_int(List *list ) ;
#line 110
int list_pop_int_unlocked(List *list ) ;
#line 111
void *list_shift(List *list ) ;
#line 112
void *list_shift_unlocked(List *list ) ;
#line 113
int list_shift_int(List *list ) ;
#line 114
int list_shift_int_unlocked(List *list ) ;
#line 115
List *list_unshift(List *list , void *item ) ;
#line 116
List *list_unshift_unlocked(List *list , void *item ) ;
#line 117
List *list_unshift_int(List *list , int item ) ;
#line 118
List *list_unshift_int_unlocked(List *list , int item ) ;
#line 119
List *list_splice(List *list , ssize_t index , ssize_t range , list_copy_t *copy ) ;
#line 120
List *list_splice_unlocked(List *list , ssize_t index , ssize_t range , list_copy_t *copy ) ;
#line 121
List *list_splice_with_locker(Locker *locker , List *list , ssize_t index , ssize_t range ,
                              list_copy_t *copy ) ;
#line 122
List *list_splice_with_locker_unlocked(Locker *locker , List *list , ssize_t index ,
                                       ssize_t range , list_copy_t *copy ) ;
#line 124
List *list_sort_unlocked(List *list , list_cmp_t *cmp ) ;
#line 125
void list_apply(List *list , list_action_t *action , void *data ) ;
#line 126
void list_apply_rdlocked(List *list , list_action_t *action , void *data ) ;
#line 127
void list_apply_wrlocked(List *list , list_action_t *action , void *data ) ;
#line 128
void list_apply_unlocked(List *list , list_action_t *action , void *data ) ;
#line 129
List *list_map(List *list , list_release_t *destroy , list_map_t *map , void *data ) ;
#line 130
List *list_map_unlocked(List *list , list_release_t *destroy , list_map_t *map , void *data ) ;
#line 131
List *list_map_with_locker(Locker *locker , List *list , list_release_t *destroy ,
                           list_map_t *map , void *data ) ;
#line 132
List *list_map_with_locker_unlocked(Locker *locker , List *list , list_release_t *destroy ,
                                    list_map_t *map , void *data ) ;
#line 133
List *list_grep(List *list , list_query_t *grep , void *data ) ;
#line 134
List *list_grep_unlocked(List *list , list_query_t *grep , void *data ) ;
#line 135
List *list_grep_with_locker(Locker *locker , List *list , list_query_t *grep , void *data ) ;
#line 136
List *list_grep_with_locker_unlocked(Locker *locker , List *list , list_query_t *grep ,
                                     void *data ) ;
#line 137
ssize_t list_query(List *list , ssize_t *index , list_query_t *query , void *data ) ;
#line 138
ssize_t list_query_unlocked(List *list , ssize_t *index , list_query_t *query , void *data ) ;
#line 140
Lister *lister_create_rdlocked(List *list ) ;
#line 141
Lister *lister_create_wrlocked(List *list ) ;
#line 145
void *lister_destroy(Lister **lister ) ;
#line 146
void *lister_destroy_unlocked(Lister **lister ) ;
#line 149
int lister_next_int(Lister *lister ) ;
#line 150
void lister_remove(Lister *lister ) ;
#line 154
int list_next_int(List *list ) ;
#line 155
void list_remove_current(List *list ) ;
#line 35 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/hsort.h"
void hsort(void *base , size_t n , size_t size , hsort_cmp_t *cmp ) ;
#line 207 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
static unsigned long const   MIN_LIST_SIZE  =    (size_t const   )4;
#line 218 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
static int grow___0(List *list , size_t items ) 
{ 
  int grown ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 220
  grown = 0;
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (! (list->length + items > list->size)) {
#line 222
      goto while_break;
    }
#line 224
    if (list->size) {
#line 225
      list->size <<= 1;
    } else {
#line 227
      list->size = (size_t )MIN_LIST_SIZE;
    }
#line 229
    grown = 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 232
  if (grown) {
    {
#line 233
    tmp___1 = mem_resize_fn((void **)(& list->list), list->size * sizeof(*(list->list)));
    }
#line 233
    if (tmp___1) {
#line 233
      tmp___0 = 0;
    } else {
#line 233
      tmp___0 = -1;
    }
#line 233
    return (tmp___0);
  }
#line 235
  return (0);
}
}
#line 247 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
static int shrink___0(List *list , size_t items ) 
{ 
  int shrunk ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 249
  shrunk = 0;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! (list->length - items < list->size >> 1)) {
#line 251
      goto while_break;
    }
#line 253
    if (list->size == (size_t )MIN_LIST_SIZE) {
#line 254
      goto while_break;
    }
#line 256
    list->size >>= 1;
#line 257
    shrunk = 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 260
  if (shrunk) {
    {
#line 261
    tmp___1 = mem_resize_fn((void **)(& list->list), list->size * sizeof(*(list->list)));
    }
#line 261
    if (tmp___1) {
#line 261
      tmp___0 = 0;
    } else {
#line 261
      tmp___0 = -1;
    }
#line 261
    return (tmp___0);
  }
#line 263
  return (0);
}
}
#line 275 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
static int expand___0(List *list , ssize_t index , size_t range ) 
{ 
  int tmp ;

  {
  {
#line 277
  tmp = grow___0(list, range);
  }
#line 277
  if (tmp == -1) {
#line 278
    return (-1);
  }
  {
#line 280
  memmove((void *)((list->list + index) + range), (void const   *)(list->list + index),
          (list->length - (size_t )index) * sizeof(*(list->list)));
#line 281
  list->length += range;
  }
#line 283
  return (0);
}
}
#line 296 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
static int contract___0(List *list , ssize_t index , size_t range ) 
{ 
  int tmp ;

  {
  {
#line 298
  memmove((void *)(list->list + index), (void const   *)((list->list + index) + range),
          ((list->length - (size_t )index) - range) * sizeof(*(list->list)));
#line 300
  tmp = shrink___0(list, range);
  }
#line 300
  if (tmp == -1) {
#line 301
    return (-1);
  }
#line 303
  list->length -= range;
#line 305
  return (0);
}
}
#line 318 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
static int adjust___0(List *list , ssize_t index , size_t range , size_t length ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 320
  if (range < length) {
    {
#line 321
    tmp = expand___0(list, (ssize_t )((size_t )index + range), length - range);
    }
#line 321
    return (tmp);
  }
#line 323
  if (range > length) {
    {
#line 324
    tmp___0 = contract___0(list, (ssize_t )((size_t )index + length), range - length);
    }
#line 324
    return (tmp___0);
  }
#line 326
  return (0);
}
}
#line 337 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
static void killitems(List *list , size_t index , size_t range ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 339
    tmp___0 = range;
#line 339
    range --;
#line 339
    if (! tmp___0) {
#line 339
      goto while_break;
    }
#line 341
    if (list->destroy) {
      {
#line 342
      (*(list->destroy))(*(list->list + index));
      }
    }
#line 343
    tmp = index;
#line 343
    index ++;
#line 343
    *(list->list + tmp) = (void *)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 345
  return;
}
}
#line 360 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_create(list_release_t *destroy ) 
{ 
  List *tmp ;

  {
  {
#line 362
  tmp = list_create_with_locker((Locker *)((void *)0), destroy);
  }
#line 362
  return (tmp);
}
}
#line 379 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_make(list_release_t *destroy  , ...) 
{ 
  List *list ;
  va_list args ;

  {
  {
#line 383
  __builtin_va_start(args, destroy);
#line 384
  list = list_vmake_with_locker((Locker *)((void *)0), destroy, args);
#line 385
  __builtin_va_end(args);
  }
#line 386
  return (list);
}
}
#line 400 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_vmake(list_release_t *destroy , va_list args ) 
{ 
  List *tmp ;

  {
  {
#line 402
  tmp = list_vmake_with_locker((Locker *)((void *)0), destroy, args);
  }
#line 402
  return (tmp);
}
}
#line 418 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_copy(List const   *src , list_copy_t *copy ) 
{ 
  List *tmp ;

  {
  {
#line 420
  tmp = list_copy_with_locker((Locker *)((void *)0), src, copy);
  }
#line 420
  return (tmp);
}
}
#line 434 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_create_with_locker(Locker *locker , list_release_t *destroy ) 
{ 
  List *list ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 438
  tmp = malloc(sizeof(List ));
#line 438
  list = (List *)tmp;
  }
#line 438
  if (! list) {
#line 439
    return ((List *)((void *)0));
  }
#line 441
  tmp___0 = (size_t )0;
#line 441
  list->length = tmp___0;
#line 441
  list->size = tmp___0;
#line 442
  list->list = (void **)((void *)0);
#line 443
  list->destroy = destroy;
#line 444
  list->lister = (Lister *)((void *)0);
#line 445
  list->locker = locker;
#line 447
  return (list);
}
}
#line 461 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_make_with_locker(Locker *locker , list_release_t *destroy  , ...) 
{ 
  List *list ;
  va_list args ;

  {
  {
#line 465
  __builtin_va_start(args, destroy);
#line 466
  list = list_vmake_with_locker(locker, destroy, args);
#line 467
  __builtin_va_end(args);
  }
#line 468
  return (list);
}
}
#line 482 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_vmake_with_locker(Locker *locker , list_release_t *destroy , va_list args ) 
{ 
  List *list ;
  void *item ;
  List *tmp ;
  void *tmp___0 ;

  {
  {
#line 487
  list = list_create_with_locker(locker, destroy);
  }
#line 487
  if (! list) {
#line 488
    return ((List *)((void *)0));
  }
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 490
    tmp___0 = __builtin_va_arg(args, void *);
#line 490
    item = tmp___0;
    }
#line 490
    if (! ((unsigned long )item != (unsigned long )((void *)0))) {
#line 490
      goto while_break;
    }
    {
#line 492
    tmp = list_append(list, item);
    }
#line 492
    if (! tmp) {
      {
#line 494
      list_release(list);
      }
#line 495
      return ((List *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 499
  return (list);
}
}
#line 513 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_copy_with_locker(Locker *locker , List const   *src , list_copy_t *copy ) 
{ 
  List *list ;
  void *tmp ;

  {
#line 517
  if (! src) {
    {
#line 518
    tmp = set_errnull(22);
    }
#line 518
    return ((List *)tmp);
  }
  {
#line 520
  list = list_extract(src, (ssize_t )0, (ssize_t )src->length, copy);
  }
#line 520
  if (! list) {
#line 521
    return ((List *)((void *)0));
  }
#line 523
  list->locker = locker;
#line 525
  return (list);
}
}
#line 548 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
int list_rdlock(List const   *list ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 550
  if (list) {
#line 550
    if (list->locker) {
      {
#line 550
      tmp = (*((list->locker)->rdlock))((list->locker)->lock);
#line 550
      tmp___0 = tmp;
      }
    } else {
#line 550
      tmp___0 = 0;
    }
#line 550
    tmp___1 = tmp___0;
  } else {
#line 550
    tmp___1 = 22;
  }
#line 550
  return (tmp___1);
}
}
#line 569 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
int list_wrlock(List const   *list ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 571
  if (list) {
#line 571
    if (list->locker) {
      {
#line 571
      tmp = (*((list->locker)->wrlock))((list->locker)->lock);
#line 571
      tmp___0 = tmp;
      }
    } else {
#line 571
      tmp___0 = 0;
    }
#line 571
    tmp___1 = tmp___0;
  } else {
#line 571
    tmp___1 = 22;
  }
#line 571
  return (tmp___1);
}
}
#line 586 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
int list_unlock(List const   *list ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 588
  if (list) {
#line 588
    if (list->locker) {
      {
#line 588
      tmp = (*((list->locker)->unlock))((list->locker)->lock);
#line 588
      tmp___0 = tmp;
      }
    } else {
#line 588
      tmp___0 = 0;
    }
#line 588
    tmp___1 = tmp___0;
  } else {
#line 588
    tmp___1 = 22;
  }
#line 588
  return (tmp___1);
}
}
#line 602 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
void list_release(List *list ) 
{ 


  {
#line 604
  if (! list) {
#line 605
    return;
  }
#line 607
  if (list->list) {
    {
#line 609
    killitems(list, (size_t )0, list->length);
#line 610
    free((void *)list->list);
    }
  }
  {
#line 613
  free((void *)list);
  }
#line 614
  return;
}
}
#line 628 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
void *list_destroy(List **list ) 
{ 


  {
#line 630
  if (list) {
#line 630
    if (*list) {
      {
#line 632
      list_release(*list);
#line 633
      *list = (List *)((void *)0);
      }
    }
  }
#line 636
  return ((void *)0);
}
}
#line 652 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
int list_own(List *list , list_release_t *destroy ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 656
  if (! list) {
    {
#line 657
    tmp = set_errno(22);
    }
#line 657
    return (tmp);
  } else
#line 656
  if (! destroy) {
    {
#line 657
    tmp = set_errno(22);
    }
#line 657
    return (tmp);
  }
#line 659
  if (list) {
#line 659
    if (list->locker) {
      {
#line 659
      tmp___1 = (*((list->locker)->wrlock))((list->locker)->lock);
#line 659
      tmp___2 = tmp___1;
      }
    } else {
#line 659
      tmp___2 = 0;
    }
#line 659
    err = tmp___2;
  } else {
#line 659
    err = 22;
  }
#line 659
  if (err) {
    {
#line 660
    tmp___0 = set_errno(err);
    }
#line 660
    return (tmp___0);
  }
#line 662
  list->destroy = destroy;
#line 664
  if (list) {
#line 664
    if (list->locker) {
      {
#line 664
      tmp___4 = (*((list->locker)->unlock))((list->locker)->lock);
#line 664
      tmp___5 = tmp___4;
      }
    } else {
#line 664
      tmp___5 = 0;
    }
#line 664
    err = tmp___5;
  } else {
#line 664
    err = 22;
  }
#line 664
  if (err) {
    {
#line 665
    tmp___3 = set_errno(err);
    }
#line 665
    return (tmp___3);
  }
#line 667
  return (0);
}
}
#line 680 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
int list_own_unlocked(List *list , list_release_t *destroy ) 
{ 
  int tmp ;

  {
#line 682
  if (! list) {
    {
#line 683
    tmp = set_errno(22);
    }
#line 683
    return (tmp);
  } else
#line 682
  if (! destroy) {
    {
#line 683
    tmp = set_errno(22);
    }
#line 683
    return (tmp);
  }
#line 685
  list->destroy = destroy;
#line 687
  return (0);
}
}
#line 703 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
list_release_t *list_disown(List *list ) 
{ 
  list_release_t *destroy ;
  int err ;
  void (*tmp)() ;
  void (*tmp___0)() ;
  int tmp___1 ;
  int tmp___2 ;
  void (*tmp___3)() ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 708
  if (! list) {
    {
#line 709
    tmp = set_errnullf(22);
    }
#line 709
    return ((list_release_t *)tmp);
  }
#line 711
  if (list) {
#line 711
    if (list->locker) {
      {
#line 711
      tmp___1 = (*((list->locker)->wrlock))((list->locker)->lock);
#line 711
      tmp___2 = tmp___1;
      }
    } else {
#line 711
      tmp___2 = 0;
    }
#line 711
    err = tmp___2;
  } else {
#line 711
    err = 22;
  }
#line 711
  if (err) {
    {
#line 712
    tmp___0 = set_errnullf(err);
    }
#line 712
    return ((list_release_t *)tmp___0);
  }
  {
#line 714
  destroy = list_disown_unlocked(list);
  }
#line 716
  if (list) {
#line 716
    if (list->locker) {
      {
#line 716
      tmp___4 = (*((list->locker)->unlock))((list->locker)->lock);
#line 716
      tmp___5 = tmp___4;
      }
    } else {
#line 716
      tmp___5 = 0;
    }
#line 716
    err = tmp___5;
  } else {
#line 716
    err = 22;
  }
#line 716
  if (err) {
    {
#line 717
    tmp___3 = set_errnullf(err);
    }
#line 717
    return ((list_release_t *)tmp___3);
  }
#line 719
  return (destroy);
}
}
#line 732 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
list_release_t *list_disown_unlocked(List *list ) 
{ 
  list_release_t *destroy ;
  void (*tmp)() ;

  {
#line 736
  if (! list) {
    {
#line 737
    tmp = set_errnullf(22);
    }
#line 737
    return ((list_release_t *)tmp);
  }
#line 739
  destroy = list->destroy;
#line 740
  list->destroy = (list_release_t *)((void *)0);
#line 742
  return (destroy);
}
}
#line 758 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
void *list_item(List const   *list , ssize_t index ) 
{ 
  void *item ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 763
  if (! list) {
    {
#line 764
    tmp = set_errnull(22);
    }
#line 764
    return (tmp);
  }
#line 766
  if (list) {
#line 766
    if (list->locker) {
      {
#line 766
      tmp___1 = (*((list->locker)->rdlock))((list->locker)->lock);
#line 766
      tmp___2 = tmp___1;
      }
    } else {
#line 766
      tmp___2 = 0;
    }
#line 766
    err = tmp___2;
  } else {
#line 766
    err = 22;
  }
#line 766
  if (err) {
    {
#line 767
    tmp___0 = set_errnull(err);
    }
#line 767
    return (tmp___0);
  }
  {
#line 769
  item = list_item_unlocked(list, index);
  }
#line 771
  if (list) {
#line 771
    if (list->locker) {
      {
#line 771
      tmp___4 = (*((list->locker)->unlock))((list->locker)->lock);
#line 771
      tmp___5 = tmp___4;
      }
    } else {
#line 771
      tmp___5 = 0;
    }
#line 771
    err = tmp___5;
  } else {
#line 771
    err = 22;
  }
#line 771
  if (err) {
    {
#line 772
    tmp___3 = set_errnull(err);
    }
#line 772
    return (tmp___3);
  }
#line 774
  return (item);
}
}
#line 787 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
void *list_item_unlocked(List const   *list , ssize_t index ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 789
  if (! list) {
    {
#line 790
    tmp = set_errnull(22);
    }
#line 790
    return (tmp);
  }
#line 792
  if (index < 0L) {
#line 793
    index = (ssize_t )((list->length + 1UL) + (size_t const   )index);
  }
#line 795
  if (index < 0L) {
    {
#line 796
    tmp___0 = set_errnull(22);
    }
#line 796
    return (tmp___0);
  }
#line 798
  if ((size_t const   )index >= list->length) {
    {
#line 799
    tmp___1 = set_errnull(22);
    }
#line 799
    return (tmp___1);
  }
#line 801
  return (*(list->list + index));
}
}
#line 815 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
int list_item_int(List const   *list , ssize_t index ) 
{ 
  void *tmp ;

  {
  {
#line 817
  tmp = list_item(list, index);
  }
#line 817
  return ((int )((long )tmp));
}
}
#line 830 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
int list_item_int_unlocked(List const   *list , ssize_t index ) 
{ 
  void *tmp ;

  {
  {
#line 832
  tmp = list_item_unlocked(list, index);
  }
#line 832
  return ((int )((long )tmp));
}
}
#line 846 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
int list_empty(List const   *list ) 
{ 
  int empty ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 851
  if (! list) {
    {
#line 852
    tmp = set_errno(22);
    }
#line 852
    return (tmp);
  }
#line 854
  if (list) {
#line 854
    if (list->locker) {
      {
#line 854
      tmp___1 = (*((list->locker)->rdlock))((list->locker)->lock);
#line 854
      tmp___2 = tmp___1;
      }
    } else {
#line 854
      tmp___2 = 0;
    }
#line 854
    err = tmp___2;
  } else {
#line 854
    err = 22;
  }
#line 854
  if (err) {
    {
#line 855
    tmp___0 = set_errno(err);
    }
#line 855
    return (tmp___0);
  }
#line 857
  empty = list->length == 0UL;
#line 859
  if (list) {
#line 859
    if (list->locker) {
      {
#line 859
      tmp___4 = (*((list->locker)->unlock))((list->locker)->lock);
#line 859
      tmp___5 = tmp___4;
      }
    } else {
#line 859
      tmp___5 = 0;
    }
#line 859
    err = tmp___5;
  } else {
#line 859
    err = 22;
  }
#line 859
  if (err) {
    {
#line 860
    tmp___3 = set_errno(err);
    }
#line 860
    return (tmp___3);
  }
#line 862
  return (empty);
}
}
#line 875 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
int list_empty_unlocked(List const   *list ) 
{ 
  int tmp ;

  {
#line 877
  if (! list) {
    {
#line 878
    tmp = set_errno(22);
    }
#line 878
    return (tmp);
  }
#line 880
  return (list->length == 0UL);
}
}
#line 894 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
ssize_t list_length(List const   *list ) 
{ 
  size_t length ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 899
  if (! list) {
    {
#line 900
    tmp = set_errno(22);
    }
#line 900
    return ((ssize_t )tmp);
  }
#line 902
  if (list) {
#line 902
    if (list->locker) {
      {
#line 902
      tmp___1 = (*((list->locker)->rdlock))((list->locker)->lock);
#line 902
      tmp___2 = tmp___1;
      }
    } else {
#line 902
      tmp___2 = 0;
    }
#line 902
    err = tmp___2;
  } else {
#line 902
    err = 22;
  }
#line 902
  if (err) {
    {
#line 903
    tmp___0 = set_errno(err);
    }
#line 903
    return ((ssize_t )tmp___0);
  }
#line 905
  length = (size_t )list->length;
#line 907
  if (list) {
#line 907
    if (list->locker) {
      {
#line 907
      tmp___4 = (*((list->locker)->unlock))((list->locker)->lock);
#line 907
      tmp___5 = tmp___4;
      }
    } else {
#line 907
      tmp___5 = 0;
    }
#line 907
    err = tmp___5;
  } else {
#line 907
    err = 22;
  }
#line 907
  if (err) {
    {
#line 908
    tmp___3 = set_errno(err);
    }
#line 908
    return ((ssize_t )tmp___3);
  }
#line 910
  return ((ssize_t )length);
}
}
#line 923 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
ssize_t list_length_unlocked(List const   *list ) 
{ 
  int tmp ;

  {
#line 925
  if (! list) {
    {
#line 926
    tmp = set_errno(22);
    }
#line 926
    return ((ssize_t )tmp);
  }
#line 928
  return ((ssize_t )list->length);
}
}
#line 942 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
ssize_t list_last(List const   *list ) 
{ 
  ssize_t last ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 947
  if (! list) {
    {
#line 948
    tmp = set_errno(22);
    }
#line 948
    return ((ssize_t )tmp);
  }
#line 950
  if (list) {
#line 950
    if (list->locker) {
      {
#line 950
      tmp___1 = (*((list->locker)->rdlock))((list->locker)->lock);
#line 950
      tmp___2 = tmp___1;
      }
    } else {
#line 950
      tmp___2 = 0;
    }
#line 950
    err = tmp___2;
  } else {
#line 950
    err = 22;
  }
#line 950
  if (err) {
    {
#line 951
    tmp___0 = set_errno(err);
    }
#line 951
    return ((ssize_t )tmp___0);
  }
#line 953
  last = (ssize_t )(list->length - 1UL);
#line 955
  if (list) {
#line 955
    if (list->locker) {
      {
#line 955
      tmp___4 = (*((list->locker)->unlock))((list->locker)->lock);
#line 955
      tmp___5 = tmp___4;
      }
    } else {
#line 955
      tmp___5 = 0;
    }
#line 955
    err = tmp___5;
  } else {
#line 955
    err = 22;
  }
#line 955
  if (err) {
    {
#line 956
    tmp___3 = set_errno(err);
    }
#line 956
    return ((ssize_t )tmp___3);
  }
#line 958
  return (last);
}
}
#line 971 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
ssize_t list_last_unlocked(List const   *list ) 
{ 
  int tmp ;

  {
#line 973
  if (! list) {
    {
#line 974
    tmp = set_errno(22);
    }
#line 974
    return ((ssize_t )tmp);
  }
#line 976
  return ((ssize_t )(list->length - 1UL));
}
}
#line 993 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_remove(List *list , ssize_t index ) 
{ 
  List *tmp ;

  {
  {
#line 995
  tmp = list_remove_range(list, index, (ssize_t )1);
  }
#line 995
  return (tmp);
}
}
#line 1008 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_remove_unlocked(List *list , ssize_t index ) 
{ 
  List *tmp ;

  {
  {
#line 1010
  tmp = list_remove_range_unlocked(list, index, (ssize_t )1);
  }
#line 1010
  return (tmp);
}
}
#line 1027 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_remove_range(List *list , ssize_t index , ssize_t range ) 
{ 
  List *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1032
  if (! list) {
    {
#line 1033
    tmp = set_errnull(22);
    }
#line 1033
    return ((List *)tmp);
  }
#line 1035
  if (list) {
#line 1035
    if (list->locker) {
      {
#line 1035
      tmp___1 = (*((list->locker)->wrlock))((list->locker)->lock);
#line 1035
      tmp___2 = tmp___1;
      }
    } else {
#line 1035
      tmp___2 = 0;
    }
#line 1035
    err = tmp___2;
  } else {
#line 1035
    err = 22;
  }
#line 1035
  if (err) {
    {
#line 1036
    tmp___0 = set_errnull(err);
    }
#line 1036
    return ((List *)tmp___0);
  }
  {
#line 1038
  ret = list_remove_range_unlocked(list, index, range);
  }
#line 1040
  if (list) {
#line 1040
    if (list->locker) {
      {
#line 1040
      tmp___4 = (*((list->locker)->unlock))((list->locker)->lock);
#line 1040
      tmp___5 = tmp___4;
      }
    } else {
#line 1040
      tmp___5 = 0;
    }
#line 1040
    err = tmp___5;
  } else {
#line 1040
    err = 22;
  }
#line 1040
  if (err) {
    {
#line 1041
    tmp___3 = set_errnull(err);
    }
#line 1041
    return ((List *)tmp___3);
  }
#line 1043
  return (ret);
}
}
#line 1057 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_remove_range_unlocked(List *list , ssize_t index , ssize_t range ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 1059
  if (! list) {
    {
#line 1060
    tmp = set_errnull(22);
    }
#line 1060
    return ((List *)tmp);
  }
#line 1062
  if (index < 0L) {
#line 1063
    index = (ssize_t )((list->length + 1UL) + (size_t )index);
  }
#line 1065
  if (index < 0L) {
    {
#line 1066
    tmp___0 = set_errnull(22);
    }
#line 1066
    return ((List *)tmp___0);
  }
#line 1068
  if (range < 0L) {
#line 1069
    range = (ssize_t )(((list->length + 1UL) + (size_t )range) - (size_t )index);
  }
#line 1071
  if (range < 0L) {
    {
#line 1072
    tmp___1 = set_errnull(22);
    }
#line 1072
    return ((List *)tmp___1);
  }
#line 1074
  if (list->length < (size_t )(index + range)) {
    {
#line 1075
    tmp___2 = set_errnull(22);
    }
#line 1075
    return ((List *)tmp___2);
  }
  {
#line 1077
  killitems(list, (size_t )index, (size_t )range);
#line 1079
  tmp___3 = contract___0(list, index, (size_t )range);
  }
#line 1079
  if (tmp___3 == -1) {
#line 1080
    return ((List *)((void *)0));
  }
#line 1082
  return (list);
}
}
#line 1099 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_insert(List *list , ssize_t index , void *item ) 
{ 
  List *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1104
  if (! list) {
    {
#line 1105
    tmp = set_errnull(22);
    }
#line 1105
    return ((List *)tmp);
  }
#line 1107
  if (list) {
#line 1107
    if (list->locker) {
      {
#line 1107
      tmp___1 = (*((list->locker)->wrlock))((list->locker)->lock);
#line 1107
      tmp___2 = tmp___1;
      }
    } else {
#line 1107
      tmp___2 = 0;
    }
#line 1107
    err = tmp___2;
  } else {
#line 1107
    err = 22;
  }
#line 1107
  if (err) {
    {
#line 1108
    tmp___0 = set_errnull(err);
    }
#line 1108
    return ((List *)tmp___0);
  }
  {
#line 1110
  ret = list_insert_unlocked(list, index, item);
  }
#line 1112
  if (list) {
#line 1112
    if (list->locker) {
      {
#line 1112
      tmp___4 = (*((list->locker)->unlock))((list->locker)->lock);
#line 1112
      tmp___5 = tmp___4;
      }
    } else {
#line 1112
      tmp___5 = 0;
    }
#line 1112
    err = tmp___5;
  } else {
#line 1112
    err = 22;
  }
#line 1112
  if (err) {
    {
#line 1113
    tmp___3 = set_errnull(err);
    }
#line 1113
    return ((List *)tmp___3);
  }
#line 1115
  return (ret);
}
}
#line 1128 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_insert_unlocked(List *list , ssize_t index , void *item ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 1130
  if (! list) {
    {
#line 1131
    tmp = set_errnull(22);
    }
#line 1131
    return ((List *)tmp);
  }
#line 1133
  if (index < 0L) {
#line 1134
    index = (ssize_t )((list->length + 1UL) + (size_t )index);
  }
#line 1136
  if (index < 0L) {
    {
#line 1137
    tmp___0 = set_errnull(22);
    }
#line 1137
    return ((List *)tmp___0);
  }
#line 1139
  if (list->length < (size_t )index) {
    {
#line 1140
    tmp___1 = set_errnull(22);
    }
#line 1140
    return ((List *)tmp___1);
  }
  {
#line 1142
  tmp___2 = expand___0(list, index, (size_t )1);
  }
#line 1142
  if (tmp___2 == -1) {
#line 1143
    return ((List *)((void *)0));
  }
#line 1145
  *(list->list + index) = item;
#line 1147
  return (list);
}
}
#line 1160 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_insert_int(List *list , ssize_t index , int item ) 
{ 
  List *tmp ;

  {
  {
#line 1162
  tmp = list_insert(list, index, (void *)((long )item));
  }
#line 1162
  return (tmp);
}
}
#line 1175 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_insert_int_unlocked(List *list , ssize_t index , int item ) 
{ 
  List *tmp ;

  {
  {
#line 1177
  tmp = list_insert_unlocked(list, index, (void *)((long )item));
  }
#line 1177
  return (tmp);
}
}
#line 1195 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_insert_list(List *list , ssize_t index , List const   *src , list_copy_t *copy ) 
{ 
  List *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 1200
  if (! src) {
    {
#line 1201
    tmp = set_errnull(22);
    }
#line 1201
    return ((List *)tmp);
  } else
#line 1200
  if (! list) {
    {
#line 1201
    tmp = set_errnull(22);
    }
#line 1201
    return ((List *)tmp);
  }
#line 1203
  if (list) {
#line 1203
    if (list->locker) {
      {
#line 1203
      tmp___1 = (*((list->locker)->wrlock))((list->locker)->lock);
#line 1203
      tmp___2 = tmp___1;
      }
    } else {
#line 1203
      tmp___2 = 0;
    }
#line 1203
    err = tmp___2;
  } else {
#line 1203
    err = 22;
  }
#line 1203
  if (err) {
    {
#line 1204
    tmp___0 = set_errnull(err);
    }
#line 1204
    return ((List *)tmp___0);
  }
#line 1206
  if (src) {
#line 1206
    if (src->locker) {
      {
#line 1206
      tmp___4 = (*((src->locker)->rdlock))((src->locker)->lock);
#line 1206
      tmp___5 = tmp___4;
      }
    } else {
#line 1206
      tmp___5 = 0;
    }
#line 1206
    err = tmp___5;
  } else {
#line 1206
    err = 22;
  }
#line 1206
  if (err) {
#line 1208
    if (list) {
#line 1208
      if (list->locker) {
        {
#line 1208
        (*((list->locker)->unlock))((list->locker)->lock);
        }
      }
    }
    {
#line 1209
    tmp___3 = set_errnull(err);
    }
#line 1209
    return ((List *)tmp___3);
  }
  {
#line 1212
  ret = list_insert_list_unlocked(list, index, src, copy);
  }
#line 1214
  if (src) {
#line 1214
    if (src->locker) {
      {
#line 1214
      tmp___7 = (*((src->locker)->unlock))((src->locker)->lock);
#line 1214
      tmp___8 = tmp___7;
      }
    } else {
#line 1214
      tmp___8 = 0;
    }
#line 1214
    err = tmp___8;
  } else {
#line 1214
    err = 22;
  }
#line 1214
  if (err) {
#line 1216
    if (list) {
#line 1216
      if (list->locker) {
        {
#line 1216
        (*((list->locker)->unlock))((list->locker)->lock);
        }
      }
    }
    {
#line 1217
    tmp___6 = set_errnull(err);
    }
#line 1217
    return ((List *)tmp___6);
  }
#line 1220
  if (list) {
#line 1220
    if (list->locker) {
      {
#line 1220
      tmp___10 = (*((list->locker)->unlock))((list->locker)->lock);
#line 1220
      tmp___11 = tmp___10;
      }
    } else {
#line 1220
      tmp___11 = 0;
    }
#line 1220
    err = tmp___11;
  } else {
#line 1220
    err = 22;
  }
#line 1220
  if (err) {
    {
#line 1221
    tmp___9 = set_errnull(err);
    }
#line 1221
    return ((List *)tmp___9);
  }
#line 1223
  return (ret);
}
}
#line 1241 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_insert_list_unlocked(List *list , ssize_t index , List const   *src , list_copy_t *copy ) 
{ 
  size_t i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 1245
  if (! src) {
    {
#line 1246
    tmp = set_errnull(22);
    }
#line 1246
    return ((List *)tmp);
  } else
#line 1245
  if (! list) {
    {
#line 1246
    tmp = set_errnull(22);
    }
#line 1246
    return ((List *)tmp);
  }
#line 1248
  if (index < 0L) {
#line 1249
    index = (ssize_t )((list->length + 1UL) + (size_t )index);
  }
#line 1251
  if (index < 0L) {
    {
#line 1252
    tmp___0 = set_errnull(22);
    }
#line 1252
    return ((List *)tmp___0);
  }
#line 1254
  if (list->length < (size_t )index) {
    {
#line 1255
    tmp___1 = set_errnull(22);
    }
#line 1255
    return ((List *)tmp___1);
  } else
#line 1254
  if (! list->destroy ^ ! copy) {
    {
#line 1255
    tmp___1 = set_errnull(22);
    }
#line 1255
    return ((List *)tmp___1);
  }
  {
#line 1257
  tmp___2 = expand___0(list, index, (size_t )src->length);
  }
#line 1257
  if (tmp___2 == -1) {
#line 1258
    return ((List *)((void *)0));
  }
#line 1260
  i = (size_t )0;
  {
#line 1260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1260
    if (! (i < (size_t )src->length)) {
#line 1260
      goto while_break;
    }
#line 1261
    if (copy) {
      {
#line 1261
      tmp___3 = (*copy)((void const   *)*(src->list + i));
#line 1261
      *(list->list + ((size_t )index + i)) = tmp___3;
      }
    } else {
#line 1261
      *(list->list + ((size_t )index + i)) = *(src->list + i);
    }
#line 1260
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1263
  return (list);
}
}
#line 1277 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_append(List *list , void *item ) 
{ 
  List *tmp ;

  {
  {
#line 1279
  tmp = list_insert(list, (ssize_t )-1, item);
  }
#line 1279
  return (tmp);
}
}
#line 1292 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_append_unlocked(List *list , void *item ) 
{ 
  List *tmp ;

  {
  {
#line 1294
  tmp = list_insert_unlocked(list, (ssize_t )-1, item);
  }
#line 1294
  return (tmp);
}
}
#line 1307 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_append_int(List *list , int item ) 
{ 
  List *tmp ;

  {
  {
#line 1309
  tmp = list_insert_int(list, (ssize_t )-1, item);
  }
#line 1309
  return (tmp);
}
}
#line 1322 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_append_int_unlocked(List *list , int item ) 
{ 
  List *tmp ;

  {
  {
#line 1324
  tmp = list_insert_int_unlocked(list, (ssize_t )-1, item);
  }
#line 1324
  return (tmp);
}
}
#line 1339 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_append_list(List *list , List const   *src , list_copy_t *copy ) 
{ 
  List *tmp ;

  {
  {
#line 1341
  tmp = list_insert_list(list, (ssize_t )-1, src, copy);
  }
#line 1341
  return (tmp);
}
}
#line 1355 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_append_list_unlocked(List *list , List const   *src , list_copy_t *copy ) 
{ 
  List *tmp ;

  {
  {
#line 1357
  tmp = list_insert_list_unlocked(list, (ssize_t )-1, src, copy);
  }
#line 1357
  return (tmp);
}
}
#line 1371 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_prepend(List *list , void *item ) 
{ 
  List *tmp ;

  {
  {
#line 1373
  tmp = list_insert(list, (ssize_t )0, item);
  }
#line 1373
  return (tmp);
}
}
#line 1386 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_prepend_unlocked(List *list , void *item ) 
{ 
  List *tmp ;

  {
  {
#line 1388
  tmp = list_insert_unlocked(list, (ssize_t )0, item);
  }
#line 1388
  return (tmp);
}
}
#line 1401 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_prepend_int(List *list , int item ) 
{ 
  List *tmp ;

  {
  {
#line 1403
  tmp = list_insert_int(list, (ssize_t )0, item);
  }
#line 1403
  return (tmp);
}
}
#line 1417 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_prepend_int_unlocked(List *list , int item ) 
{ 
  List *tmp ;

  {
  {
#line 1419
  tmp = list_insert_int_unlocked(list, (ssize_t )0, item);
  }
#line 1419
  return (tmp);
}
}
#line 1434 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_prepend_list(List *list , List const   *src , list_copy_t *copy ) 
{ 
  List *tmp ;

  {
  {
#line 1436
  tmp = list_insert_list(list, (ssize_t )0, src, copy);
  }
#line 1436
  return (tmp);
}
}
#line 1450 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_prepend_list_unlocked(List *list , List const   *src , list_copy_t *copy ) 
{ 
  List *tmp ;

  {
  {
#line 1452
  tmp = list_insert_list_unlocked(list, (ssize_t )0, src, copy);
  }
#line 1452
  return (tmp);
}
}
#line 1469 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_replace(List *list , ssize_t index , ssize_t range , void *item ) 
{ 
  List *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1474
  if (! list) {
    {
#line 1475
    tmp = set_errnull(22);
    }
#line 1475
    return ((List *)tmp);
  }
#line 1477
  if (list) {
#line 1477
    if (list->locker) {
      {
#line 1477
      tmp___1 = (*((list->locker)->wrlock))((list->locker)->lock);
#line 1477
      tmp___2 = tmp___1;
      }
    } else {
#line 1477
      tmp___2 = 0;
    }
#line 1477
    err = tmp___2;
  } else {
#line 1477
    err = 22;
  }
#line 1477
  if (err) {
    {
#line 1478
    tmp___0 = set_errnull(err);
    }
#line 1478
    return ((List *)tmp___0);
  }
  {
#line 1480
  ret = list_replace_unlocked(list, index, range, item);
  }
#line 1482
  if (list) {
#line 1482
    if (list->locker) {
      {
#line 1482
      tmp___4 = (*((list->locker)->unlock))((list->locker)->lock);
#line 1482
      tmp___5 = tmp___4;
      }
    } else {
#line 1482
      tmp___5 = 0;
    }
#line 1482
    err = tmp___5;
  } else {
#line 1482
    err = 22;
  }
#line 1482
  if (err) {
    {
#line 1483
    tmp___3 = set_errnull(err);
    }
#line 1483
    return ((List *)tmp___3);
  }
#line 1485
  return (ret);
}
}
#line 1498 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_replace_unlocked(List *list , ssize_t index , ssize_t range , void *item ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 1500
  if (! list) {
    {
#line 1501
    tmp = set_errnull(22);
    }
#line 1501
    return ((List *)tmp);
  }
#line 1503
  if (index < 0L) {
#line 1504
    index = (ssize_t )((list->length + 1UL) + (size_t )index);
  }
#line 1506
  if (index < 0L) {
    {
#line 1507
    tmp___0 = set_errnull(22);
    }
#line 1507
    return ((List *)tmp___0);
  }
#line 1509
  if (range < 0L) {
#line 1510
    range = (ssize_t )(((list->length + 1UL) + (size_t )range) - (size_t )index);
  }
#line 1512
  if (range < 0L) {
    {
#line 1513
    tmp___1 = set_errnull(22);
    }
#line 1513
    return ((List *)tmp___1);
  }
#line 1515
  if (list->length < (size_t )(index + range)) {
    {
#line 1516
    tmp___2 = set_errnull(22);
    }
#line 1516
    return ((List *)tmp___2);
  }
  {
#line 1518
  killitems(list, (size_t )index, (size_t )range);
#line 1520
  tmp___3 = adjust___0(list, index, (size_t )range, (size_t )1);
  }
#line 1520
  if (tmp___3 == -1) {
#line 1521
    return ((List *)((void *)0));
  }
#line 1523
  *(list->list + index) = item;
#line 1525
  return (list);
}
}
#line 1538 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_replace_int(List *list , ssize_t index , ssize_t range , int item ) 
{ 
  List *tmp ;

  {
  {
#line 1540
  tmp = list_replace(list, index, range, (void *)((long )item));
  }
#line 1540
  return (tmp);
}
}
#line 1553 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_replace_int_unlocked(List *list , ssize_t index , ssize_t range , int item ) 
{ 
  List *tmp ;

  {
  {
#line 1555
  tmp = list_replace_unlocked(list, index, range, (void *)((long )item));
  }
#line 1555
  return (tmp);
}
}
#line 1573 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_replace_list(List *list , ssize_t index , ssize_t range , List const   *src ,
                        list_copy_t *copy ) 
{ 
  List *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 1578
  if (! src) {
    {
#line 1579
    tmp = set_errnull(22);
    }
#line 1579
    return ((List *)tmp);
  } else
#line 1578
  if (! list) {
    {
#line 1579
    tmp = set_errnull(22);
    }
#line 1579
    return ((List *)tmp);
  }
#line 1581
  if (list) {
#line 1581
    if (list->locker) {
      {
#line 1581
      tmp___1 = (*((list->locker)->wrlock))((list->locker)->lock);
#line 1581
      tmp___2 = tmp___1;
      }
    } else {
#line 1581
      tmp___2 = 0;
    }
#line 1581
    err = tmp___2;
  } else {
#line 1581
    err = 22;
  }
#line 1581
  if (err) {
    {
#line 1582
    tmp___0 = set_errnull(err);
    }
#line 1582
    return ((List *)tmp___0);
  }
#line 1584
  if (src) {
#line 1584
    if (src->locker) {
      {
#line 1584
      tmp___4 = (*((src->locker)->rdlock))((src->locker)->lock);
#line 1584
      tmp___5 = tmp___4;
      }
    } else {
#line 1584
      tmp___5 = 0;
    }
#line 1584
    err = tmp___5;
  } else {
#line 1584
    err = 22;
  }
#line 1584
  if (err) {
#line 1586
    if (list) {
#line 1586
      if (list->locker) {
        {
#line 1586
        (*((list->locker)->unlock))((list->locker)->lock);
        }
      }
    }
    {
#line 1587
    tmp___3 = set_errnull(err);
    }
#line 1587
    return ((List *)tmp___3);
  }
  {
#line 1590
  ret = list_replace_list_unlocked(list, index, range, src, copy);
  }
#line 1592
  if (src) {
#line 1592
    if (src->locker) {
      {
#line 1592
      tmp___7 = (*((src->locker)->unlock))((src->locker)->lock);
#line 1592
      tmp___8 = tmp___7;
      }
    } else {
#line 1592
      tmp___8 = 0;
    }
#line 1592
    err = tmp___8;
  } else {
#line 1592
    err = 22;
  }
#line 1592
  if (err) {
#line 1594
    if (list) {
#line 1594
      if (list->locker) {
        {
#line 1594
        (*((list->locker)->unlock))((list->locker)->lock);
        }
      }
    }
    {
#line 1595
    tmp___6 = set_errnull(err);
    }
#line 1595
    return ((List *)tmp___6);
  }
#line 1598
  if (list) {
#line 1598
    if (list->locker) {
      {
#line 1598
      tmp___10 = (*((list->locker)->unlock))((list->locker)->lock);
#line 1598
      tmp___11 = tmp___10;
      }
    } else {
#line 1598
      tmp___11 = 0;
    }
#line 1598
    err = tmp___11;
  } else {
#line 1598
    err = 22;
  }
#line 1598
  if (err) {
    {
#line 1599
    tmp___9 = set_errnull(err);
    }
#line 1599
    return ((List *)tmp___9);
  }
#line 1601
  return (ret);
}
}
#line 1617 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_replace_list_unlocked(List *list , ssize_t index , ssize_t range , List const   *src ,
                                 list_copy_t *copy ) 
{ 
  ssize_t length ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 1621
  if (! src) {
    {
#line 1622
    tmp = set_errnull(22);
    }
#line 1622
    return ((List *)tmp);
  } else
#line 1621
  if (! list) {
    {
#line 1622
    tmp = set_errnull(22);
    }
#line 1622
    return ((List *)tmp);
  }
#line 1624
  if (index < 0L) {
#line 1625
    index = (ssize_t )((list->length + 1UL) + (size_t )index);
  }
#line 1627
  if (index < 0L) {
    {
#line 1628
    tmp___0 = set_errnull(22);
    }
#line 1628
    return ((List *)tmp___0);
  }
#line 1630
  if (range < 0L) {
#line 1631
    range = (ssize_t )(((list->length + 1UL) + (size_t )range) - (size_t )index);
  }
#line 1633
  if (range < 0L) {
    {
#line 1634
    tmp___1 = set_errnull(22);
    }
#line 1634
    return ((List *)tmp___1);
  }
#line 1636
  if (list->length < (size_t )(index + range)) {
    {
#line 1637
    tmp___2 = set_errnull(22);
    }
#line 1637
    return ((List *)tmp___2);
  } else
#line 1636
  if (! list->destroy ^ ! copy) {
    {
#line 1637
    tmp___2 = set_errnull(22);
    }
#line 1637
    return ((List *)tmp___2);
  }
  {
#line 1639
  killitems(list, (size_t )index, (size_t )range);
#line 1641
  length = (ssize_t )src->length;
#line 1643
  tmp___3 = adjust___0(list, index, (size_t )range, (size_t )length);
  }
#line 1643
  if (tmp___3 == -1) {
#line 1644
    return ((List *)((void *)0));
  }
  {
#line 1646
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1646
    tmp___5 = length;
#line 1646
    length --;
#line 1646
    if (! tmp___5) {
#line 1646
      goto while_break;
    }
#line 1647
    if (copy) {
      {
#line 1647
      tmp___4 = (*copy)((void const   *)*(src->list + length));
#line 1647
      *(list->list + (index + length)) = tmp___4;
      }
    } else {
#line 1647
      *(list->list + (index + length)) = *(src->list + length);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1649
  return (list);
}
}
#line 1669 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_extract(List const   *list , ssize_t index , ssize_t range , list_copy_t *copy ) 
{ 
  List *tmp ;

  {
  {
#line 1671
  tmp = list_extract_with_locker((Locker *)((void *)0), list, index, range, copy);
  }
#line 1671
  return (tmp);
}
}
#line 1684 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_extract_unlocked(List const   *list , ssize_t index , ssize_t range , list_copy_t *copy ) 
{ 
  List *tmp ;

  {
  {
#line 1686
  tmp = list_extract_with_locker_unlocked((Locker *)((void *)0), list, index, range,
                                          copy);
  }
#line 1686
  return (tmp);
}
}
#line 1700 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_extract_with_locker(Locker *locker , List const   *list , ssize_t index ,
                               ssize_t range , list_copy_t *copy ) 
{ 
  List *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1705
  if (! list) {
    {
#line 1706
    tmp = set_errnull(22);
    }
#line 1706
    return ((List *)tmp);
  }
#line 1708
  if (list) {
#line 1708
    if (list->locker) {
      {
#line 1708
      tmp___1 = (*((list->locker)->rdlock))((list->locker)->lock);
#line 1708
      tmp___2 = tmp___1;
      }
    } else {
#line 1708
      tmp___2 = 0;
    }
#line 1708
    err = tmp___2;
  } else {
#line 1708
    err = 22;
  }
#line 1708
  if (err) {
    {
#line 1709
    tmp___0 = set_errnull(err);
    }
#line 1709
    return ((List *)tmp___0);
  }
  {
#line 1711
  ret = list_extract_with_locker_unlocked(locker, list, index, range, copy);
  }
#line 1713
  if (list) {
#line 1713
    if (list->locker) {
      {
#line 1713
      tmp___4 = (*((list->locker)->unlock))((list->locker)->lock);
#line 1713
      tmp___5 = tmp___4;
      }
    } else {
#line 1713
      tmp___5 = 0;
    }
#line 1713
    err = tmp___5;
  } else {
#line 1713
    err = 22;
  }
#line 1713
  if (err) {
    {
#line 1714
    tmp___3 = set_errnull(err);
    }
#line 1714
    return ((List *)tmp___3);
  }
#line 1716
  return (ret);
}
}
#line 1730 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_extract_with_locker_unlocked(Locker *locker , List const   *list , ssize_t index ,
                                        ssize_t range , list_copy_t *copy ) 
{ 
  List *ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  list_release_t *tmp___3 ;
  ssize_t tmp___4 ;
  void *tmp___5 ;
  ssize_t tmp___6 ;
  void *tmp___7 ;
  List *tmp___8 ;
  ssize_t tmp___9 ;

  {
#line 1734
  if (! list) {
    {
#line 1735
    tmp = set_errnull(22);
    }
#line 1735
    return ((List *)tmp);
  }
#line 1737
  if (index < 0L) {
#line 1738
    index = (ssize_t )((list->length + 1UL) + (size_t const   )index);
  }
#line 1740
  if (index < 0L) {
    {
#line 1741
    tmp___0 = set_errnull(22);
    }
#line 1741
    return ((List *)tmp___0);
  }
#line 1743
  if (range < 0L) {
#line 1744
    range = (ssize_t )(((list->length + 1UL) + (size_t const   )range) - (size_t const   )index);
  }
#line 1746
  if (range < 0L) {
    {
#line 1747
    tmp___1 = set_errnull(22);
    }
#line 1747
    return ((List *)tmp___1);
  }
#line 1749
  if (list->length < (size_t const   )(index + range)) {
    {
#line 1750
    tmp___2 = set_errnull(22);
    }
#line 1750
    return ((List *)tmp___2);
  } else
#line 1749
  if (! list->destroy ^ ! copy) {
    {
#line 1750
    tmp___2 = set_errnull(22);
    }
#line 1750
    return ((List *)tmp___2);
  }
#line 1752
  if (copy) {
#line 1752
    tmp___3 = list->destroy;
  } else {
#line 1752
    tmp___3 = (list_release_t */* const  */)((void *)0);
  }
  {
#line 1752
  ret = list_create_with_locker(locker, (list_release_t *)tmp___3);
  }
#line 1752
  if (! ret) {
#line 1753
    return ((List *)((void *)0));
  }
  {
#line 1755
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1755
    tmp___9 = range;
#line 1755
    range --;
#line 1755
    if (! tmp___9) {
#line 1755
      goto while_break;
    }
#line 1757
    if (copy) {
      {
#line 1757
      tmp___4 = index;
#line 1757
      index ++;
#line 1757
      tmp___5 = (*copy)((void const   *)*(list->list + tmp___4));
#line 1757
      tmp___7 = tmp___5;
      }
    } else {
#line 1757
      tmp___6 = index;
#line 1757
      index ++;
#line 1757
      tmp___7 = *(list->list + tmp___6);
    }
    {
#line 1757
    tmp___8 = list_append(ret, tmp___7);
    }
#line 1757
    if (! tmp___8) {
      {
#line 1759
      list_release(ret);
      }
#line 1760
      return ((List *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1764
  return (ret);
}
}
#line 1780 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_push(List *list , void *item ) 
{ 
  List *tmp ;

  {
  {
#line 1782
  tmp = list_append(list, item);
  }
#line 1782
  return (tmp);
}
}
#line 1795 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_push_unlocked(List *list , void *item ) 
{ 
  List *tmp ;

  {
  {
#line 1797
  tmp = list_append_unlocked(list, item);
  }
#line 1797
  return (tmp);
}
}
#line 1810 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_push_int(List *list , int item ) 
{ 
  List *tmp ;

  {
  {
#line 1812
  tmp = list_append_int(list, item);
  }
#line 1812
  return (tmp);
}
}
#line 1825 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_push_int_unlocked(List *list , int item ) 
{ 
  List *tmp ;

  {
  {
#line 1827
  tmp = list_append_int_unlocked(list, item);
  }
#line 1827
  return (tmp);
}
}
#line 1841 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
void *list_pop(List *list ) 
{ 
  void *item ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1846
  if (! list) {
    {
#line 1847
    tmp = set_errnull(22);
    }
#line 1847
    return (tmp);
  }
#line 1849
  if (list) {
#line 1849
    if (list->locker) {
      {
#line 1849
      tmp___1 = (*((list->locker)->wrlock))((list->locker)->lock);
#line 1849
      tmp___2 = tmp___1;
      }
    } else {
#line 1849
      tmp___2 = 0;
    }
#line 1849
    err = tmp___2;
  } else {
#line 1849
    err = 22;
  }
#line 1849
  if (err) {
    {
#line 1850
    tmp___0 = set_errnull(err);
    }
#line 1850
    return (tmp___0);
  }
  {
#line 1852
  item = list_pop_unlocked(list);
  }
#line 1854
  if (list) {
#line 1854
    if (list->locker) {
      {
#line 1854
      tmp___4 = (*((list->locker)->unlock))((list->locker)->lock);
#line 1854
      tmp___5 = tmp___4;
      }
    } else {
#line 1854
      tmp___5 = 0;
    }
#line 1854
    err = tmp___5;
  } else {
#line 1854
    err = 22;
  }
#line 1854
  if (err) {
    {
#line 1855
    tmp___3 = set_errnull(err);
    }
#line 1855
    return (tmp___3);
  }
#line 1857
  return (item);
}
}
#line 1870 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
void *list_pop_unlocked(List *list ) 
{ 
  void *item ;
  void *tmp ;
  void *tmp___0 ;
  List *tmp___1 ;

  {
#line 1874
  if (! list) {
    {
#line 1875
    tmp = set_errnull(22);
    }
#line 1875
    return (tmp);
  }
#line 1877
  if (! list->length) {
    {
#line 1878
    tmp___0 = set_errnull(22);
    }
#line 1878
    return (tmp___0);
  }
  {
#line 1880
  item = *(list->list + (list->length - 1UL));
#line 1881
  *(list->list + (list->length - 1UL)) = (void *)0;
#line 1883
  tmp___1 = list_remove_unlocked(list, (ssize_t )(list->length - 1UL));
  }
#line 1883
  if (! tmp___1) {
#line 1885
    *(list->list + (list->length - 1UL)) = item;
#line 1886
    return ((void *)0);
  }
#line 1889
  return (item);
}
}
#line 1903 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
int list_pop_int(List *list ) 
{ 
  void *tmp ;

  {
  {
#line 1905
  tmp = list_pop(list);
  }
#line 1905
  return ((int )((long )tmp));
}
}
#line 1918 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
int list_pop_int_unlocked(List *list ) 
{ 
  void *tmp ;

  {
  {
#line 1920
  tmp = list_pop_unlocked(list);
  }
#line 1920
  return ((int )((long )tmp));
}
}
#line 1934 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
void *list_shift(List *list ) 
{ 
  void *item ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1939
  if (! list) {
    {
#line 1940
    tmp = set_errnull(22);
    }
#line 1940
    return (tmp);
  }
#line 1942
  if (list) {
#line 1942
    if (list->locker) {
      {
#line 1942
      tmp___1 = (*((list->locker)->wrlock))((list->locker)->lock);
#line 1942
      tmp___2 = tmp___1;
      }
    } else {
#line 1942
      tmp___2 = 0;
    }
#line 1942
    err = tmp___2;
  } else {
#line 1942
    err = 22;
  }
#line 1942
  if (err) {
    {
#line 1943
    tmp___0 = set_errnull(err);
    }
#line 1943
    return (tmp___0);
  }
  {
#line 1945
  item = list_shift_unlocked(list);
  }
#line 1947
  if (list) {
#line 1947
    if (list->locker) {
      {
#line 1947
      tmp___4 = (*((list->locker)->unlock))((list->locker)->lock);
#line 1947
      tmp___5 = tmp___4;
      }
    } else {
#line 1947
      tmp___5 = 0;
    }
#line 1947
    err = tmp___5;
  } else {
#line 1947
    err = 22;
  }
#line 1947
  if (err) {
    {
#line 1948
    tmp___3 = set_errnull(err);
    }
#line 1948
    return (tmp___3);
  }
#line 1950
  return (item);
}
}
#line 1963 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
void *list_shift_unlocked(List *list ) 
{ 
  void *item ;
  void *tmp ;
  void *tmp___0 ;
  List *tmp___1 ;

  {
#line 1967
  if (! list) {
    {
#line 1968
    tmp = set_errnull(22);
    }
#line 1968
    return (tmp);
  }
#line 1970
  if (! list->length) {
    {
#line 1971
    tmp___0 = set_errnull(22);
    }
#line 1971
    return (tmp___0);
  }
  {
#line 1973
  item = *(list->list + 0);
#line 1974
  *(list->list + 0) = (void *)0;
#line 1976
  tmp___1 = list_remove_unlocked(list, (ssize_t )0);
  }
#line 1976
  if (! tmp___1) {
#line 1978
    *(list->list + 0) = item;
#line 1979
    return ((void *)0);
  }
#line 1982
  return (item);
}
}
#line 1996 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
int list_shift_int(List *list ) 
{ 
  void *tmp ;

  {
  {
#line 1998
  tmp = list_shift(list);
  }
#line 1998
  return ((int )((long )tmp));
}
}
#line 2011 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
int list_shift_int_unlocked(List *list ) 
{ 
  void *tmp ;

  {
  {
#line 2013
  tmp = list_shift_unlocked(list);
  }
#line 2013
  return ((int )((long )tmp));
}
}
#line 2027 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_unshift(List *list , void *item ) 
{ 
  List *tmp ;

  {
  {
#line 2029
  tmp = list_prepend(list, item);
  }
#line 2029
  return (tmp);
}
}
#line 2042 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_unshift_unlocked(List *list , void *item ) 
{ 
  List *tmp ;

  {
  {
#line 2044
  tmp = list_prepend_unlocked(list, item);
  }
#line 2044
  return (tmp);
}
}
#line 2057 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_unshift_int(List *list , int item ) 
{ 
  List *tmp ;

  {
  {
#line 2059
  tmp = list_prepend_int(list, item);
  }
#line 2059
  return (tmp);
}
}
#line 2073 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_unshift_int_unlocked(List *list , int item ) 
{ 
  List *tmp ;

  {
  {
#line 2075
  tmp = list_prepend_int_unlocked(list, item);
  }
#line 2075
  return (tmp);
}
}
#line 2095 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_splice(List *list , ssize_t index , ssize_t range , list_copy_t *copy ) 
{ 
  List *tmp ;

  {
  {
#line 2097
  tmp = list_splice_with_locker((Locker *)((void *)0), list, index, range, copy);
  }
#line 2097
  return (tmp);
}
}
#line 2110 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_splice_unlocked(List *list , ssize_t index , ssize_t range , list_copy_t *copy ) 
{ 
  List *tmp ;

  {
  {
#line 2112
  tmp = list_splice_with_locker_unlocked((Locker *)((void *)0), list, index, range,
                                         copy);
  }
#line 2112
  return (tmp);
}
}
#line 2126 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_splice_with_locker(Locker *locker , List *list , ssize_t index , ssize_t range ,
                              list_copy_t *copy ) 
{ 
  List *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 2131
  if (! list) {
    {
#line 2132
    tmp = set_errnull(22);
    }
#line 2132
    return ((List *)tmp);
  }
#line 2134
  if (list) {
#line 2134
    if (list->locker) {
      {
#line 2134
      tmp___1 = (*((list->locker)->wrlock))((list->locker)->lock);
#line 2134
      tmp___2 = tmp___1;
      }
    } else {
#line 2134
      tmp___2 = 0;
    }
#line 2134
    err = tmp___2;
  } else {
#line 2134
    err = 22;
  }
#line 2134
  if (err) {
    {
#line 2135
    tmp___0 = set_errnull(err);
    }
#line 2135
    return ((List *)tmp___0);
  }
  {
#line 2137
  ret = list_splice_with_locker_unlocked(locker, list, index, range, copy);
  }
#line 2139
  if (list) {
#line 2139
    if (list->locker) {
      {
#line 2139
      tmp___4 = (*((list->locker)->unlock))((list->locker)->lock);
#line 2139
      tmp___5 = tmp___4;
      }
    } else {
#line 2139
      tmp___5 = 0;
    }
#line 2139
    err = tmp___5;
  } else {
#line 2139
    err = 22;
  }
#line 2139
  if (err) {
    {
#line 2141
    list_release(ret);
#line 2142
    tmp___3 = set_errnull(err);
    }
#line 2142
    return ((List *)tmp___3);
  }
#line 2145
  return (ret);
}
}
#line 2159 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_splice_with_locker_unlocked(Locker *locker , List *list , ssize_t index ,
                                       ssize_t range , list_copy_t *copy ) 
{ 
  List *ret ;
  void *tmp ;
  List *tmp___0 ;

  {
#line 2163
  if (! list) {
    {
#line 2164
    tmp = set_errnull(22);
    }
#line 2164
    return ((List *)tmp);
  }
  {
#line 2166
  ret = list_extract_with_locker_unlocked(locker, (List const   *)list, index, range,
                                          copy);
  }
#line 2166
  if (! ret) {
#line 2167
    return ((List *)((void *)0));
  }
  {
#line 2169
  tmp___0 = list_remove_range_unlocked(list, index, range);
  }
#line 2169
  if (! tmp___0) {
    {
#line 2171
    list_release(ret);
    }
#line 2172
    return ((List *)((void *)0));
  }
#line 2175
  return (ret);
}
}
#line 2191 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_sort(List *list , list_cmp_t *cmp ) 
{ 
  List *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 2196
  if (! list) {
    {
#line 2197
    tmp = set_errnull(22);
    }
#line 2197
    return ((List *)tmp);
  }
#line 2199
  if (list) {
#line 2199
    if (list->locker) {
      {
#line 2199
      tmp___1 = (*((list->locker)->wrlock))((list->locker)->lock);
#line 2199
      tmp___2 = tmp___1;
      }
    } else {
#line 2199
      tmp___2 = 0;
    }
#line 2199
    err = tmp___2;
  } else {
#line 2199
    err = 22;
  }
#line 2199
  if (err) {
    {
#line 2200
    tmp___0 = set_errnull(err);
    }
#line 2200
    return ((List *)tmp___0);
  }
  {
#line 2202
  ret = list_sort_unlocked(list, cmp);
  }
#line 2204
  if (list) {
#line 2204
    if (list->locker) {
      {
#line 2204
      tmp___4 = (*((list->locker)->unlock))((list->locker)->lock);
#line 2204
      tmp___5 = tmp___4;
      }
    } else {
#line 2204
      tmp___5 = 0;
    }
#line 2204
    err = tmp___5;
  } else {
#line 2204
    err = 22;
  }
#line 2204
  if (err) {
    {
#line 2205
    tmp___3 = set_errnull(err);
    }
#line 2205
    return ((List *)tmp___3);
  }
#line 2207
  return (ret);
}
}
#line 2220 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_sort_unlocked(List *list , list_cmp_t *cmp ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void ( __attribute__((__nonnull__(1,4))) (*tmp___1))(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   *a ,
                                                                                       void const   *b ) ) ;

  {
#line 2222
  if (! list) {
    {
#line 2223
    tmp = set_errnull(22);
    }
#line 2223
    return ((List *)tmp);
  }
#line 2225
  if (! list->list) {
    {
#line 2226
    tmp___0 = set_errnull(22);
    }
#line 2226
    return ((List *)tmp___0);
  } else
#line 2225
  if (! list->length) {
    {
#line 2226
    tmp___0 = set_errnull(22);
    }
#line 2226
    return ((List *)tmp___0);
  }
#line 2228
  if (list->length >= 10000UL) {
#line 2228
    tmp___1 = (void ( __attribute__((__nonnull__(1,4))) (*))(void *__base , size_t __nmemb ,
                                                             size_t __size , int (*__compar)(void const   *a ,
                                                                                             void const   *b ) ))(& hsort);
  } else {
#line 2228
    tmp___1 = & qsort;
  }
  {
#line 2228
  (*tmp___1)((void *)list->list, list->length, sizeof(*(list->list + 0)), cmp);
  }
#line 2230
  return (list);
}
}
#line 2245 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
void list_apply(List *list , list_action_t *action , void *data ) 
{ 


  {
  {
#line 2247
  list_apply_wrlocked(list, action, data);
  }
#line 2248
  return;
}
}
#line 2262 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
void list_apply_rdlocked(List *list , list_action_t *action , void *data ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2266
  if (! list) {
    {
#line 2268
    set_errno(22);
    }
#line 2269
    return;
  } else
#line 2266
  if (! action) {
    {
#line 2268
    set_errno(22);
    }
#line 2269
    return;
  }
#line 2272
  if (list) {
#line 2272
    if (list->locker) {
      {
#line 2272
      tmp = (*((list->locker)->rdlock))((list->locker)->lock);
#line 2272
      tmp___0 = tmp;
      }
    } else {
#line 2272
      tmp___0 = 0;
    }
#line 2272
    err = tmp___0;
  } else {
#line 2272
    err = 22;
  }
#line 2272
  if (err) {
    {
#line 2274
    set_errno(err);
    }
#line 2275
    return;
  }
  {
#line 2278
  list_apply_unlocked(list, action, data);
  }
#line 2280
  if (list) {
#line 2280
    if (list->locker) {
      {
#line 2280
      tmp___1 = (*((list->locker)->unlock))((list->locker)->lock);
#line 2280
      tmp___2 = tmp___1;
      }
    } else {
#line 2280
      tmp___2 = 0;
    }
#line 2280
    err = tmp___2;
  } else {
#line 2280
    err = 22;
  }
#line 2280
  if (err) {
    {
#line 2281
    set_errno(err);
    }
  }
#line 2282
  return;
}
}
#line 2295 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
void list_apply_wrlocked(List *list , list_action_t *action , void *data ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2299
  if (! list) {
    {
#line 2301
    set_errno(22);
    }
#line 2302
    return;
  } else
#line 2299
  if (! action) {
    {
#line 2301
    set_errno(22);
    }
#line 2302
    return;
  }
#line 2305
  if (list) {
#line 2305
    if (list->locker) {
      {
#line 2305
      tmp = (*((list->locker)->wrlock))((list->locker)->lock);
#line 2305
      tmp___0 = tmp;
      }
    } else {
#line 2305
      tmp___0 = 0;
    }
#line 2305
    err = tmp___0;
  } else {
#line 2305
    err = 22;
  }
#line 2305
  if (err) {
    {
#line 2307
    set_errno(err);
    }
#line 2308
    return;
  }
  {
#line 2311
  list_apply_unlocked(list, action, data);
  }
#line 2313
  if (list) {
#line 2313
    if (list->locker) {
      {
#line 2313
      tmp___1 = (*((list->locker)->unlock))((list->locker)->lock);
#line 2313
      tmp___2 = tmp___1;
      }
    } else {
#line 2313
      tmp___2 = 0;
    }
#line 2313
    err = tmp___2;
  } else {
#line 2313
    err = 22;
  }
#line 2313
  if (err) {
    {
#line 2314
    set_errno(err);
    }
  }
#line 2315
  return;
}
}
#line 2327 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
void list_apply_unlocked(List *list , list_action_t *action , void *data ) 
{ 
  size_t i ;

  {
#line 2331
  if (! list) {
    {
#line 2333
    set_errno(22);
    }
#line 2334
    return;
  } else
#line 2331
  if (! action) {
    {
#line 2333
    set_errno(22);
    }
#line 2334
    return;
  }
#line 2337
  i = (size_t )0;
  {
#line 2337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2337
    if (! (i < list->length)) {
#line 2337
      goto while_break;
    }
    {
#line 2338
    (*action)(*(list->list + i), & i, data);
#line 2337
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2339
  return;
}
}
#line 2357 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_map(List *list , list_release_t *destroy , list_map_t *map , void *data ) 
{ 
  List *tmp ;

  {
  {
#line 2359
  tmp = list_map_with_locker((Locker *)((void *)0), list, destroy, map, data);
  }
#line 2359
  return (tmp);
}
}
#line 2372 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_map_unlocked(List *list , list_release_t *destroy , list_map_t *map , void *data ) 
{ 
  List *tmp ;

  {
  {
#line 2374
  tmp = list_map_with_locker_unlocked((Locker *)((void *)0), list, destroy, map, data);
  }
#line 2374
  return (tmp);
}
}
#line 2388 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_map_with_locker(Locker *locker , List *list , list_release_t *destroy ,
                           list_map_t *map , void *data ) 
{ 
  List *mapping ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 2393
  if (! list) {
    {
#line 2394
    tmp = set_errnull(22);
    }
#line 2394
    return ((List *)tmp);
  } else
#line 2393
  if (! map) {
    {
#line 2394
    tmp = set_errnull(22);
    }
#line 2394
    return ((List *)tmp);
  }
#line 2396
  if (list) {
#line 2396
    if (list->locker) {
      {
#line 2396
      tmp___1 = (*((list->locker)->rdlock))((list->locker)->lock);
#line 2396
      tmp___2 = tmp___1;
      }
    } else {
#line 2396
      tmp___2 = 0;
    }
#line 2396
    err = tmp___2;
  } else {
#line 2396
    err = 22;
  }
#line 2396
  if (err) {
    {
#line 2397
    tmp___0 = set_errnull(err);
    }
#line 2397
    return ((List *)tmp___0);
  }
  {
#line 2399
  mapping = list_map_with_locker_unlocked(locker, list, destroy, map, data);
  }
#line 2401
  if (list) {
#line 2401
    if (list->locker) {
      {
#line 2401
      tmp___4 = (*((list->locker)->unlock))((list->locker)->lock);
#line 2401
      tmp___5 = tmp___4;
      }
    } else {
#line 2401
      tmp___5 = 0;
    }
#line 2401
    err = tmp___5;
  } else {
#line 2401
    err = 22;
  }
#line 2401
  if (err) {
    {
#line 2403
    list_release(mapping);
#line 2404
    tmp___3 = set_errnull(err);
    }
#line 2404
    return ((List *)tmp___3);
  }
#line 2407
  return (mapping);
}
}
#line 2421 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_map_with_locker_unlocked(Locker *locker , List *list , list_release_t *destroy ,
                                    list_map_t *map , void *data ) 
{ 
  List *mapping ;
  size_t i ;
  void *tmp ;
  void *tmp___0 ;
  List *tmp___1 ;

  {
#line 2426
  if (! list) {
    {
#line 2427
    tmp = set_errnull(22);
    }
#line 2427
    return ((List *)tmp);
  } else
#line 2426
  if (! map) {
    {
#line 2427
    tmp = set_errnull(22);
    }
#line 2427
    return ((List *)tmp);
  }
  {
#line 2429
  mapping = list_create_with_locker(locker, destroy);
  }
#line 2429
  if (! mapping) {
#line 2430
    return ((List *)((void *)0));
  }
#line 2432
  i = (size_t )0;
  {
#line 2432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2432
    if (! (i < list->length)) {
#line 2432
      goto while_break;
    }
    {
#line 2434
    tmp___0 = (*map)(*(list->list + i), & i, data);
#line 2434
    tmp___1 = list_append(mapping, tmp___0);
    }
#line 2434
    if (! tmp___1) {
      {
#line 2436
      list_release(mapping);
      }
#line 2437
      return ((List *)((void *)0));
    }
#line 2432
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2441
  return (mapping);
}
}
#line 2461 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_grep(List *list , list_query_t *grep , void *data ) 
{ 
  List *tmp ;

  {
  {
#line 2463
  tmp = list_grep_with_locker((Locker *)((void *)0), list, grep, data);
  }
#line 2463
  return (tmp);
}
}
#line 2476 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_grep_unlocked(List *list , list_query_t *grep , void *data ) 
{ 
  List *tmp ;

  {
  {
#line 2478
  tmp = list_grep_with_locker_unlocked((Locker *)((void *)0), list, grep, data);
  }
#line 2478
  return (tmp);
}
}
#line 2492 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_grep_with_locker(Locker *locker , List *list , list_query_t *grep , void *data ) 
{ 
  List *grepping ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 2497
  if (! list) {
    {
#line 2498
    tmp = set_errnull(22);
    }
#line 2498
    return ((List *)tmp);
  } else
#line 2497
  if (! list) {
    {
#line 2498
    tmp = set_errnull(22);
    }
#line 2498
    return ((List *)tmp);
  }
#line 2500
  if (list) {
#line 2500
    if (list->locker) {
      {
#line 2500
      tmp___1 = (*((list->locker)->rdlock))((list->locker)->lock);
#line 2500
      tmp___2 = tmp___1;
      }
    } else {
#line 2500
      tmp___2 = 0;
    }
#line 2500
    err = tmp___2;
  } else {
#line 2500
    err = 22;
  }
#line 2500
  if (err) {
    {
#line 2501
    tmp___0 = set_errnull(err);
    }
#line 2501
    return ((List *)tmp___0);
  }
  {
#line 2503
  grepping = list_grep_with_locker_unlocked(locker, list, grep, data);
  }
#line 2505
  if (list) {
#line 2505
    if (list->locker) {
      {
#line 2505
      tmp___4 = (*((list->locker)->unlock))((list->locker)->lock);
#line 2505
      tmp___5 = tmp___4;
      }
    } else {
#line 2505
      tmp___5 = 0;
    }
#line 2505
    err = tmp___5;
  } else {
#line 2505
    err = 22;
  }
#line 2505
  if (err) {
    {
#line 2507
    list_release(grepping);
#line 2508
    tmp___3 = set_errnull(err);
    }
#line 2508
    return ((List *)tmp___3);
  }
#line 2511
  return (grepping);
}
}
#line 2525 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
List *list_grep_with_locker_unlocked(Locker *locker , List *list , list_query_t *grep ,
                                     void *data ) 
{ 
  List *grepping ;
  size_t i ;
  void *tmp ;
  List *tmp___0 ;
  int tmp___1 ;

  {
#line 2530
  if (! list) {
    {
#line 2531
    tmp = set_errnull(22);
    }
#line 2531
    return ((List *)tmp);
  } else
#line 2530
  if (! list) {
    {
#line 2531
    tmp = set_errnull(22);
    }
#line 2531
    return ((List *)tmp);
  }
  {
#line 2533
  grepping = list_create((list_release_t *)((void *)0));
  }
#line 2533
  if (! grepping) {
#line 2534
    return ((List *)((void *)0));
  }
#line 2536
  i = (size_t )0;
  {
#line 2536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2536
    if (! (i < list->length)) {
#line 2536
      goto while_break;
    }
    {
#line 2538
    tmp___1 = (*grep)(*(list->list + i), & i, data);
    }
#line 2538
    if (tmp___1) {
      {
#line 2540
      tmp___0 = list_append(grepping, *(list->list + i));
      }
#line 2540
      if (! tmp___0) {
        {
#line 2542
        list_release(grepping);
        }
#line 2543
        return ((List *)((void *)0));
      }
    }
#line 2536
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2548
  return (grepping);
}
}
#line 2566 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
ssize_t list_query(List *list , ssize_t *index , list_query_t *query , void *data ) 
{ 
  ssize_t ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 2571
  if (! list) {
    {
#line 2572
    tmp = set_errno(22);
    }
#line 2572
    return ((ssize_t )tmp);
  } else
#line 2571
  if (! index) {
    {
#line 2572
    tmp = set_errno(22);
    }
#line 2572
    return ((ssize_t )tmp);
  } else
#line 2571
  if (! query) {
    {
#line 2572
    tmp = set_errno(22);
    }
#line 2572
    return ((ssize_t )tmp);
  }
#line 2574
  if (list) {
#line 2574
    if (list->locker) {
      {
#line 2574
      tmp___1 = (*((list->locker)->rdlock))((list->locker)->lock);
#line 2574
      tmp___2 = tmp___1;
      }
    } else {
#line 2574
      tmp___2 = 0;
    }
#line 2574
    err = tmp___2;
  } else {
#line 2574
    err = 22;
  }
#line 2574
  if (err) {
    {
#line 2575
    tmp___0 = set_errno(err);
    }
#line 2575
    return ((ssize_t )tmp___0);
  }
  {
#line 2577
  ret = list_query_unlocked(list, index, query, data);
  }
#line 2579
  if (list) {
#line 2579
    if (list->locker) {
      {
#line 2579
      tmp___4 = (*((list->locker)->unlock))((list->locker)->lock);
#line 2579
      tmp___5 = tmp___4;
      }
    } else {
#line 2579
      tmp___5 = 0;
    }
#line 2579
    err = tmp___5;
  } else {
#line 2579
    err = 22;
  }
#line 2579
  if (err) {
    {
#line 2580
    tmp___3 = set_errno(err);
    }
#line 2580
    return ((ssize_t )tmp___3);
  }
#line 2582
  return (ret);
}
}
#line 2595 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
ssize_t list_query_unlocked(List *list , ssize_t *index , list_query_t *query , void *data ) 
{ 
  size_t i ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 2599
  if (! list) {
    {
#line 2600
    tmp = set_errno(22);
    }
#line 2600
    return ((ssize_t )tmp);
  } else
#line 2599
  if (! index) {
    {
#line 2600
    tmp = set_errno(22);
    }
#line 2600
    return ((ssize_t )tmp);
  } else
#line 2599
  if (! query) {
    {
#line 2600
    tmp = set_errno(22);
    }
#line 2600
    return ((ssize_t )tmp);
  }
#line 2602
  if ((size_t )*index >= list->length) {
    {
#line 2603
    tmp___0 = set_errno(22);
    }
#line 2603
    return ((ssize_t )tmp___0);
  }
#line 2605
  i = (size_t )*index;
  {
#line 2605
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2605
    if (! (i < list->length)) {
#line 2605
      goto while_break;
    }
    {
#line 2607
    tmp___2 = (*query)(*(list->list + i), (size_t *)index, data);
    }
#line 2607
    if (tmp___2) {
#line 2608
      tmp___1 = (ssize_t )i;
#line 2608
      *index = tmp___1;
#line 2608
      return (tmp___1);
    }
#line 2605
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2611
  tmp___3 = (ssize_t )-1;
#line 2611
  *index = tmp___3;
#line 2611
  return (tmp___3);
}
}
#line 2629 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
Lister *lister_create(List *list ) 
{ 
  Lister *tmp ;

  {
  {
#line 2631
  tmp = lister_create_wrlocked(list);
  }
#line 2631
  return (tmp);
}
}
#line 2646 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
Lister *lister_create_rdlocked(List *list ) 
{ 
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  Lister *tmp___3 ;

  {
#line 2650
  if (! list) {
    {
#line 2651
    tmp = set_errnull(22);
    }
#line 2651
    return ((Lister *)tmp);
  }
#line 2653
  if (list) {
#line 2653
    if (list->locker) {
      {
#line 2653
      tmp___1 = (*((list->locker)->rdlock))((list->locker)->lock);
#line 2653
      tmp___2 = tmp___1;
      }
    } else {
#line 2653
      tmp___2 = 0;
    }
#line 2653
    err = tmp___2;
  } else {
#line 2653
    err = 22;
  }
#line 2653
  if (err) {
    {
#line 2654
    tmp___0 = set_errnull(err);
    }
#line 2654
    return ((Lister *)tmp___0);
  }
  {
#line 2656
  tmp___3 = lister_create_unlocked((List const   *)list);
  }
#line 2656
  return (tmp___3);
}
}
#line 2670 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
Lister *lister_create_wrlocked(List *list ) 
{ 
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  Lister *tmp___3 ;

  {
#line 2674
  if (! list) {
    {
#line 2675
    tmp = set_errnull(22);
    }
#line 2675
    return ((Lister *)tmp);
  }
#line 2677
  if (list) {
#line 2677
    if (list->locker) {
      {
#line 2677
      tmp___1 = (*((list->locker)->wrlock))((list->locker)->lock);
#line 2677
      tmp___2 = tmp___1;
      }
    } else {
#line 2677
      tmp___2 = 0;
    }
#line 2677
    err = tmp___2;
  } else {
#line 2677
    err = 22;
  }
#line 2677
  if (err) {
    {
#line 2678
    tmp___0 = set_errnull(err);
    }
#line 2678
    return ((Lister *)tmp___0);
  }
  {
#line 2680
  tmp___3 = lister_create_unlocked((List const   *)list);
  }
#line 2680
  return (tmp___3);
}
}
#line 2693 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
Lister *lister_create_unlocked(List const   *list ) 
{ 
  Lister *lister ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 2697
  if (! list) {
    {
#line 2698
    tmp = set_errnull(22);
    }
#line 2698
    return ((Lister *)tmp);
  }
  {
#line 2700
  tmp___0 = malloc(sizeof(Lister ));
#line 2700
  lister = (Lister *)tmp___0;
  }
#line 2700
  if (! lister) {
#line 2701
    return ((Lister *)((void *)0));
  }
#line 2703
  lister->list = (List *)list;
#line 2704
  lister->index = (ssize_t )-1;
#line 2706
  return (lister);
}
}
#line 2719 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
void lister_release(Lister *lister ) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;

  {
#line 2723
  if (! lister) {
#line 2724
    return;
  }
#line 2726
  if (lister->list) {
#line 2726
    if ((lister->list)->locker) {
      {
#line 2726
      tmp = (*(((lister->list)->locker)->unlock))(((lister->list)->locker)->lock);
#line 2726
      tmp___0 = tmp;
      }
    } else {
#line 2726
      tmp___0 = 0;
    }
#line 2726
    err = tmp___0;
  } else {
#line 2726
    err = 22;
  }
#line 2726
  if (err) {
    {
#line 2728
    set_errno(err);
    }
#line 2729
    return;
  }
  {
#line 2732
  free((void *)lister);
  }
#line 2733
  return;
}
}
#line 2746 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
void lister_release_unlocked(Lister *lister ) 
{ 


  {
#line 2748
  if (! lister) {
#line 2749
    return;
  }
  {
#line 2751
  free((void *)lister);
  }
#line 2752
  return;
}
}
#line 2765 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
void *lister_destroy(Lister **lister ) 
{ 


  {
#line 2767
  if (lister) {
#line 2767
    if (*lister) {
      {
#line 2769
      lister_release(*lister);
#line 2770
      *lister = (Lister *)((void *)0);
      }
    }
  }
#line 2773
  return ((void *)0);
}
}
#line 2787 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
void *lister_destroy_unlocked(Lister **lister ) 
{ 


  {
#line 2789
  if (lister) {
#line 2789
    if (*lister) {
      {
#line 2791
      lister_release_unlocked(*lister);
#line 2792
      *lister = (Lister *)((void *)0);
      }
    }
  }
#line 2795
  return ((void *)0);
}
}
#line 2810 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
int lister_has_next(Lister *lister ) 
{ 
  int tmp ;

  {
#line 2812
  if (! lister) {
    {
#line 2813
    tmp = set_errno(22);
    }
#line 2813
    return (tmp);
  }
#line 2815
  return ((size_t )(lister->index + 1L) < (lister->list)->length);
}
}
#line 2829 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
void *lister_next(Lister *lister ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 2831
  if (! lister) {
    {
#line 2832
    tmp = set_errnull(22);
    }
#line 2832
    return (tmp);
  }
  {
#line 2834
  (lister->index) ++;
#line 2834
  tmp___0 = list_item_unlocked((List const   *)lister->list, (ssize_t )((size_t )lister->index));
  }
#line 2834
  return (tmp___0);
}
}
#line 2847 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
int lister_next_int(Lister *lister ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2849
  if (! lister) {
    {
#line 2850
    tmp = set_errno(22);
    }
#line 2850
    return (tmp);
  }
  {
#line 2852
  (lister->index) ++;
#line 2852
  tmp___0 = list_item_int_unlocked((List const   *)lister->list, (ssize_t )((size_t )lister->index));
  }
#line 2852
  return (tmp___0);
}
}
#line 2868 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
void lister_remove(Lister *lister ) 
{ 
  ssize_t tmp ;

  {
#line 2871
  if (! lister) {
    {
#line 2873
    set_errno(22);
    }
#line 2874
    return;
  }
#line 2877
  if (lister->index == -1L) {
    {
#line 2879
    set_errno(22);
    }
#line 2880
    return;
  }
  {
#line 2883
  tmp = lister->index;
#line 2883
  (lister->index) --;
#line 2883
  list_remove_unlocked(lister->list, (ssize_t )((size_t )tmp));
  }
#line 2884
  return;
}
}
#line 2922 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
int list_has_next(List *list ) 
{ 
  int has ;
  int tmp ;
  Lister *tmp___0 ;

  {
#line 2926
  if (! list) {
    {
#line 2927
    tmp = set_errno(22);
    }
#line 2927
    return (tmp);
  }
#line 2929
  if (! list->lister) {
    {
#line 2929
    tmp___0 = lister_create_unlocked((List const   *)list);
#line 2929
    list->lister = tmp___0;
    }
#line 2929
    if (! tmp___0) {
#line 2930
      return (-1);
    }
  }
  {
#line 2932
  has = lister_has_next(list->lister);
  }
#line 2932
  if (has != 1) {
    {
#line 2933
    list_break(list);
    }
  }
#line 2935
  return (has);
}
}
#line 2950 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
void list_break(List *list ) 
{ 


  {
#line 2952
  if (! list) {
    {
#line 2954
    set_errno(22);
    }
#line 2955
    return;
  }
  {
#line 2958
  lister_destroy_unlocked(& list->lister);
  }
#line 2959
  return;
}
}
#line 2972 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
void *list_next(List *list ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 2974
  if (! list) {
    {
#line 2975
    tmp = set_errnull(22);
    }
#line 2975
    return (tmp);
  } else
#line 2974
  if (! list->lister) {
    {
#line 2975
    tmp = set_errnull(22);
    }
#line 2975
    return (tmp);
  }
  {
#line 2977
  tmp___0 = lister_next(list->lister);
  }
#line 2977
  return (tmp___0);
}
}
#line 2990 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
int list_next_int(List *list ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2992
  if (! list) {
    {
#line 2993
    tmp = set_errno(22);
    }
#line 2993
    return (tmp);
  } else
#line 2992
  if (! list->lister) {
    {
#line 2993
    tmp = set_errno(22);
    }
#line 2993
    return (tmp);
  }
  {
#line 2995
  tmp___0 = lister_next_int(list->lister);
  }
#line 2995
  return (tmp___0);
}
}
#line 3010 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/list.c"
void list_remove_current(List *list ) 
{ 


  {
#line 3012
  if (! list) {
    {
#line 3014
    set_errno(22);
    }
#line 3015
    return;
  } else
#line 3012
  if (! list->lister) {
    {
#line 3014
    set_errno(22);
    }
#line 3015
    return;
  }
  {
#line 3018
  lister_remove(list->lister);
  }
#line 3019
  return;
}
}
#line 44 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.h"
int slink_has_next(void *link___0 ) ;
#line 45
void *slink_next(void *link___0 ) ;
#line 46
int dlink_has_next(void *link___0 ) ;
#line 47
void *dlink_next(void *link___0 ) ;
#line 48
int dlink_has_prev(void *link___0 ) ;
#line 49
void *dlink_prev(void *link___0 ) ;
#line 50
void *slink_insert(void *link___0 , void *item ) ;
#line 51
void *dlink_insert(void *link___0 , void *item ) ;
#line 52
void *slink_remove(void *link___0 ) ;
#line 53
void *dlink_remove(void *link___0 ) ;
#line 54
void *slink_freelist_init(void *freelist , size_t nelem , size_t size ) ;
#line 55
void *dlink_freelist_init(void *freelist , size_t nelem , size_t size ) ;
#line 56
void *slink_freelist_attach(void *freelist1 , void *freelist2 ) ;
#line 57
void *dlink_freelist_attach(void *freelist1 , void *freelist2 ) ;
#line 58
void *slink_alloc(void **freelist ) ;
#line 59
void *dlink_alloc(void **freelist ) ;
#line 60
void *slink_free(void **freelist , void *item ) ;
#line 61
void *dlink_free(void **freelist , void *item ) ;
#line 105 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.c"
int slink_has_next(void *link___0 ) 
{ 
  int tmp ;

  {
#line 107
  if (! link___0) {
    {
#line 108
    tmp = set_errno(22);
    }
#line 108
    return (tmp);
  }
#line 110
  return ((unsigned long )((slink_t *)link___0)->next != (unsigned long )((void *)0));
}
}
#line 124 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.c"
void *slink_next(void *link___0 ) 
{ 
  void *tmp ;

  {
#line 126
  if (! link___0) {
    {
#line 127
    tmp = set_errnull(22);
    }
#line 127
    return (tmp);
  }
#line 129
  return (((slink_t *)link___0)->next);
}
}
#line 143 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.c"
int dlink_has_next(void *link___0 ) 
{ 
  int tmp ;

  {
#line 145
  if (! link___0) {
    {
#line 146
    tmp = set_errno(22);
    }
#line 146
    return (tmp);
  }
#line 148
  return ((unsigned long )((dlink_t *)link___0)->next != (unsigned long )((void *)0));
}
}
#line 162 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.c"
void *dlink_next(void *link___0 ) 
{ 
  void *tmp ;

  {
#line 164
  if (! link___0) {
    {
#line 165
    tmp = set_errnull(22);
    }
#line 165
    return (tmp);
  }
#line 167
  return (((dlink_t *)link___0)->next);
}
}
#line 181 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.c"
int dlink_has_prev(void *link___0 ) 
{ 
  int tmp ;

  {
#line 183
  if (! link___0) {
    {
#line 184
    tmp = set_errno(22);
    }
#line 184
    return (tmp);
  }
#line 186
  return ((unsigned long )((dlink_t *)link___0)->prev != (unsigned long )((void *)0));
}
}
#line 200 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.c"
void *dlink_prev(void *link___0 ) 
{ 
  void *tmp ;

  {
#line 202
  if (! link___0) {
    {
#line 203
    tmp = set_errnull(22);
    }
#line 203
    return (tmp);
  }
#line 205
  return (((dlink_t *)link___0)->prev);
}
}
#line 220 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.c"
void *slink_insert(void *link___0 , void *item ) 
{ 
  slink_t *insert ;
  void *tmp ;

  {
#line 224
  if (! item) {
    {
#line 225
    tmp = set_errnull(22);
    }
#line 225
    return (tmp);
  }
#line 227
  insert = (slink_t *)item;
#line 228
  insert->next = link___0;
#line 230
  return ((void *)insert);
}
}
#line 245 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.c"
void *dlink_insert(void *link___0 , void *item ) 
{ 
  dlink_t *insert ;
  dlink_t *next ;
  dlink_t *prev ;
  void *tmp ;

  {
#line 249
  if (! item) {
    {
#line 250
    tmp = set_errnull(22);
    }
#line 250
    return (tmp);
  }
#line 252
  insert = (dlink_t *)item;
#line 253
  next = (dlink_t *)link___0;
#line 254
  if (next) {
#line 254
    prev = (dlink_t *)next->prev;
  } else {
#line 254
    prev = (dlink_t *)((void *)0);
  }
#line 256
  insert->next = (void *)next;
#line 257
  insert->prev = (void *)prev;
#line 259
  if (next) {
#line 260
    next->prev = (void *)insert;
  }
#line 262
  if (prev) {
#line 263
    prev->next = (void *)insert;
  }
#line 265
  return ((void *)insert);
}
}
#line 280 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.c"
void *slink_remove(void *link___0 ) 
{ 
  slink_t *remove___0 ;
  void *tmp ;

  {
#line 284
  if (! link___0) {
    {
#line 285
    tmp = set_errnull(22);
    }
#line 285
    return (tmp);
  }
#line 287
  remove___0 = (slink_t *)link___0;
#line 289
  return (remove___0->next);
}
}
#line 304 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.c"
void *dlink_remove(void *link___0 ) 
{ 
  dlink_t *remove___0 ;
  void *tmp ;

  {
#line 308
  if (! link___0) {
    {
#line 309
    tmp = set_errnull(22);
    }
#line 309
    return (tmp);
  }
#line 311
  remove___0 = (dlink_t *)link___0;
#line 313
  if (remove___0->next) {
#line 314
    ((dlink_t *)remove___0->next)->prev = remove___0->prev;
  }
#line 316
  if (remove___0->prev) {
#line 317
    ((dlink_t *)remove___0->prev)->next = remove___0->next;
  }
#line 319
  return (remove___0->next);
}
}
#line 334 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.c"
void *slink_freelist_init(void *freelist , size_t nelem , size_t size ) 
{ 
  char *link___0 ;
  void *tmp ;

  {
#line 338
  if (! freelist) {
    {
#line 339
    tmp = set_errnull(22);
    }
#line 339
    return (tmp);
  } else
#line 338
  if (! nelem) {
    {
#line 339
    tmp = set_errnull(22);
    }
#line 339
    return (tmp);
  } else
#line 338
  if (! size) {
    {
#line 339
    tmp = set_errnull(22);
    }
#line 339
    return (tmp);
  }
#line 341
  link___0 = (char *)freelist;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    nelem --;
#line 341
    if (! nelem) {
#line 341
      goto while_break;
    }
#line 343
    ((slink_t *)link___0)->next = (void *)(link___0 + size);
#line 341
    link___0 += size;
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  ((slink_t *)link___0)->next = (void *)0;
#line 348
  return (freelist);
}
}
#line 363 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.c"
void *dlink_freelist_init(void *freelist , size_t nelem , size_t size ) 
{ 
  char *link___0 ;
  char *prev ;
  void *tmp ;

  {
#line 367
  if (! freelist) {
    {
#line 368
    tmp = set_errnull(22);
    }
#line 368
    return (tmp);
  } else
#line 367
  if (! nelem) {
    {
#line 368
    tmp = set_errnull(22);
    }
#line 368
    return (tmp);
  } else
#line 367
  if (! size) {
    {
#line 368
    tmp = set_errnull(22);
    }
#line 368
    return (tmp);
  }
#line 370
  prev = (char *)((void *)0);
#line 370
  link___0 = (char *)freelist;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    nelem --;
#line 370
    if (! nelem) {
#line 370
      goto while_break;
    }
#line 372
    ((dlink_t *)link___0)->next = (void *)(link___0 + size);
#line 373
    ((dlink_t *)link___0)->prev = (void *)prev;
#line 370
    prev = link___0;
#line 370
    link___0 += size;
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  ((dlink_t *)link___0)->next = (void *)0;
#line 377
  ((dlink_t *)link___0)->prev = (void *)prev;
#line 379
  return (freelist);
}
}
#line 396 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.c"
void *slink_freelist_attach(void *freelist1 , void *freelist2 ) 
{ 
  char *freelist ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 400
  if (! freelist2) {
    {
#line 401
    tmp = set_errnull(22);
    }
#line 401
    return (tmp);
  }
#line 403
  freelist = (char *)freelist1;
#line 403
  if (! freelist) {
#line 404
    return (freelist2);
  }
  {
#line 406
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 406
    tmp___1 = slink_has_next((void *)freelist);
    }
#line 406
    if (! (tmp___1 == 1)) {
#line 406
      goto while_break;
    }
    {
#line 407
    tmp___0 = slink_next((void *)freelist);
#line 407
    freelist = (char *)tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 409
  ((slink_t *)freelist)->next = freelist2;
#line 411
  return (freelist1);
}
}
#line 428 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.c"
void *dlink_freelist_attach(void *freelist1 , void *freelist2 ) 
{ 
  char *freelist ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 432
  if (! freelist2) {
    {
#line 433
    tmp = set_errnull(22);
    }
#line 433
    return (tmp);
  }
#line 435
  freelist = (char *)freelist1;
#line 435
  if (! freelist) {
#line 436
    return (freelist2);
  }
  {
#line 438
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 438
    tmp___1 = dlink_has_next((void *)freelist);
    }
#line 438
    if (! tmp___1) {
#line 438
      goto while_break;
    }
    {
#line 439
    tmp___0 = dlink_next((void *)freelist);
#line 439
    freelist = (char *)tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  ((dlink_t *)freelist)->next = freelist2;
#line 442
  ((dlink_t *)freelist2)->prev = (void *)freelist;
#line 444
  return (freelist1);
}
}
#line 460 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.c"
void *slink_alloc(void **freelist ) 
{ 
  void *alloc ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 464
  if (! freelist) {
    {
#line 465
    tmp = set_errnull(22);
    }
#line 465
    return (tmp);
  }
#line 467
  if (! *freelist) {
    {
#line 468
    tmp___0 = set_errnull(28);
    }
#line 468
    return (tmp___0);
  }
  {
#line 470
  alloc = *freelist;
#line 471
  *freelist = slink_remove(*freelist);
  }
#line 473
  return (alloc);
}
}
#line 489 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.c"
void *dlink_alloc(void **freelist ) 
{ 
  void *alloc ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 493
  if (! freelist) {
    {
#line 494
    tmp = set_errnull(22);
    }
#line 494
    return (tmp);
  }
#line 496
  if (! *freelist) {
    {
#line 497
    tmp___0 = set_errnull(28);
    }
#line 497
    return (tmp___0);
  }
  {
#line 499
  alloc = *freelist;
#line 500
  *freelist = dlink_remove(*freelist);
  }
#line 502
  return (alloc);
}
}
#line 518 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.c"
void *slink_free(void **freelist , void *item ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 520
  if (! freelist) {
    {
#line 521
    tmp = set_errnull(22);
    }
#line 521
    return (tmp);
  } else
#line 520
  if (! item) {
    {
#line 521
    tmp = set_errnull(22);
    }
#line 521
    return (tmp);
  }
  {
#line 523
  tmp___0 = slink_insert(*freelist, item);
#line 523
  *freelist = tmp___0;
  }
#line 523
  return (tmp___0);
}
}
#line 539 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/link.c"
void *dlink_free(void **freelist , void *item ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 541
  if (! freelist) {
    {
#line 542
    tmp = set_errnull(22);
    }
#line 542
    return (tmp);
  } else
#line 541
  if (! item) {
    {
#line 542
    tmp = set_errnull(22);
    }
#line 542
    return (tmp);
  }
  {
#line 544
  tmp___0 = dlink_insert(*freelist, item);
#line 544
  *freelist = tmp___0;
  }
#line 544
  return (tmp___0);
}
}
#line 612 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) pathconf)(char const   *__path ,
                                                                                                int __name ) ;
#line 616
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) fpathconf)(int __fd ,
                                                                                 int __name ) ;
#line 619
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 30 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.h"
long limit_arg(void) ;
#line 31
long limit_child(void) ;
#line 32
long limit_tick(void) ;
#line 33
long limit_group(void) ;
#line 34
long limit_open(void) ;
#line 35
long limit_stream(void) ;
#line 36
long limit_tzname(void) ;
#line 37
long limit_job(void) ;
#line 38
long limit_save_ids(void) ;
#line 39
long limit_version(void) ;
#line 40
long limit_pcanon(char const   *path ) ;
#line 41
long limit_fcanon(int fd ) ;
#line 42
long limit_canon(void) ;
#line 43
long limit_pinput(char const   *path ) ;
#line 44
long limit_finput(int fd ) ;
#line 45
long limit_input(void) ;
#line 46
long limit_pvdisable(char const   *path ) ;
#line 47
long limit_fvdisable(int fd ) ;
#line 48
long limit_vdisable(void) ;
#line 49
long limit_plink(char const   *path ) ;
#line 50
long limit_flink(int fd ) ;
#line 51
long limit_link(void) ;
#line 52
long limit_pname(char const   *path ) ;
#line 53
long limit_fname(int fd ) ;
#line 54
long limit_name(void) ;
#line 55
long limit_ppath(char const   *path ) ;
#line 56
long limit_fpath(int fd ) ;
#line 58
long limit_ppipe(char const   *path ) ;
#line 59
long limit_fpipe(int fd ) ;
#line 60
long limit_pnotrunc(char const   *path ) ;
#line 61
long limit_fnotrunc(int fd ) ;
#line 62
long limit_notrunc(void) ;
#line 63
long limit_pchown(char const   *path ) ;
#line 64
long limit_fchown(int fd ) ;
#line 65
long limit_chown(void) ;
#line 130 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
static struct __anonstruct_g_77  const  g___1  =    {{{(int const   )0, (long const   )131072, (off_t const   )0}, {(int const   )1,
                                                                   (long const   )1024,
                                                                   (off_t const   )0},
     {(int const   )2, (long const   )-1, (off_t const   )0}, {(int const   )3, (long const   )32,
                                                               (off_t const   )0},
     {(int const   )4, (long const   )1024, (off_t const   )0}, {(int const   )5,
                                                                 (long const   )1024,
                                                                 (off_t const   )0},
     {(int const   )6, (long const   )3, (off_t const   )0}, {(int const   )7, (long const   )0,
                                                              (off_t const   )0},
     {(int const   )8, (long const   )0, (off_t const   )0}, {(int const   )29, (long const   )0,
                                                              (off_t const   )0},
     {(int const   )1, (long const   )255, (off_t const   )0}, {(int const   )2, (long const   )255,
                                                                (off_t const   )0},
     {(int const   )8, (long const   )0, (off_t const   )0}, {(int const   )0, (long const   )32768,
                                                              (off_t const   )0},
     {(int const   )3, (long const   )1024, (off_t const   )0}, {(int const   )4,
                                                                 (long const   )4096,
                                                                 (off_t const   )2},
     {(int const   )5, (long const   )4096, (off_t const   )0}, {(int const   )7,
                                                                 (long const   )0,
                                                                 (off_t const   )0},
     {(int const   )6, (long const   )0, (off_t const   )0}}};
#line 169 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
static long limit_sysconf(int limit ) 
{ 
  long value ;

  {
  {
#line 173
  value = sysconf((int )g___1.conf[limit].name);
  }
#line 173
  if (value == -1L) {
#line 174
    return ((long )g___1.conf[limit].value);
  }
#line 176
  return (value);
}
}
#line 193 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
static long limit_pathconf(int limit , char const   *path ) 
{ 
  long value ;

  {
  {
#line 197
  value = pathconf(path, (int )g___1.conf[limit].name);
  }
#line 197
  if (value == -1L) {
#line 198
    return ((long )g___1.conf[limit].value);
  }
#line 200
  return (value + (long )g___1.conf[limit].offset);
}
}
#line 217 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
static long limit_fpathconf(int limit , int fd ) 
{ 
  long value ;

  {
  {
#line 221
  value = fpathconf(fd, (int )g___1.conf[limit].name);
  }
#line 221
  if (value == -1L) {
#line 222
    return ((long )g___1.conf[limit].value);
  }
#line 224
  return (value + (long )g___1.conf[limit].offset);
}
}
#line 238 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_arg(void) 
{ 
  long tmp ;

  {
  {
#line 240
  tmp = limit_sysconf(0);
  }
#line 240
  return (tmp);
}
}
#line 254 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_child(void) 
{ 
  long tmp ;

  {
  {
#line 256
  tmp = limit_sysconf(1);
  }
#line 256
  return (tmp);
}
}
#line 270 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_tick(void) 
{ 
  long tmp ;

  {
  {
#line 272
  tmp = limit_sysconf(2);
  }
#line 272
  return (tmp);
}
}
#line 286 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_group(void) 
{ 
  long tmp ;

  {
  {
#line 288
  tmp = limit_sysconf(3);
  }
#line 288
  return (tmp);
}
}
#line 302 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_open(void) 
{ 
  long tmp ;

  {
  {
#line 304
  tmp = limit_sysconf(4);
  }
#line 304
  return (tmp);
}
}
#line 318 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_stream(void) 
{ 
  long tmp ;

  {
  {
#line 320
  tmp = limit_sysconf(5);
  }
#line 320
  return (tmp);
}
}
#line 334 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_tzname(void) 
{ 
  long tmp ;

  {
  {
#line 336
  tmp = limit_sysconf(6);
  }
#line 336
  return (tmp);
}
}
#line 349 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_job(void) 
{ 
  long tmp ;

  {
  {
#line 351
  tmp = limit_sysconf(7);
  }
#line 351
  return (tmp);
}
}
#line 365 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_save_ids(void) 
{ 
  long tmp ;

  {
  {
#line 367
  tmp = limit_sysconf(8);
  }
#line 367
  return (tmp);
}
}
#line 381 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_version(void) 
{ 
  long tmp ;

  {
  {
#line 383
  tmp = limit_sysconf(9);
  }
#line 383
  return (tmp);
}
}
#line 397 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_pcanon(char const   *path ) 
{ 
  long tmp ;

  {
  {
#line 399
  tmp = limit_pathconf(10, path);
  }
#line 399
  return (tmp);
}
}
#line 413 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_fcanon(int fd ) 
{ 
  long tmp ;

  {
  {
#line 415
  tmp = limit_fpathconf(10, fd);
  }
#line 415
  return (tmp);
}
}
#line 429 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_canon(void) 
{ 
  long tmp ;
  char *__cil_tmp2 ;

  {
  {
#line 431
  tmp = limit_pcanon("/dev/tty");
  }
#line 431
  return (tmp);
}
}
#line 445 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_pinput(char const   *path ) 
{ 
  long tmp ;

  {
  {
#line 447
  tmp = limit_pathconf(11, path);
  }
#line 447
  return (tmp);
}
}
#line 461 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_finput(int fd ) 
{ 
  long tmp ;

  {
  {
#line 463
  tmp = limit_fpathconf(11, fd);
  }
#line 463
  return (tmp);
}
}
#line 477 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_input(void) 
{ 
  long tmp ;
  char *__cil_tmp2 ;

  {
  {
#line 479
  tmp = limit_pinput("/dev/tty");
  }
#line 479
  return (tmp);
}
}
#line 493 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_pvdisable(char const   *path ) 
{ 
  long tmp ;

  {
  {
#line 495
  tmp = limit_pathconf(12, path);
  }
#line 495
  return (tmp);
}
}
#line 509 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_fvdisable(int fd ) 
{ 
  long tmp ;

  {
  {
#line 511
  tmp = limit_fpathconf(12, fd);
  }
#line 511
  return (tmp);
}
}
#line 525 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_vdisable(void) 
{ 
  long tmp ;
  char *__cil_tmp2 ;

  {
  {
#line 527
  tmp = limit_pvdisable("/dev/tty");
  }
#line 527
  return (tmp);
}
}
#line 541 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_plink(char const   *path ) 
{ 
  long tmp ;

  {
  {
#line 543
  tmp = limit_pathconf(13, path);
  }
#line 543
  return (tmp);
}
}
#line 557 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_flink(int fd ) 
{ 
  long tmp ;

  {
  {
#line 559
  tmp = limit_fpathconf(13, fd);
  }
#line 559
  return (tmp);
}
}
#line 573 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_link(void) 
{ 
  long tmp ;
  char *__cil_tmp2 ;

  {
  {
#line 575
  tmp = limit_plink("/");
  }
#line 575
  return (tmp);
}
}
#line 590 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_pname(char const   *path ) 
{ 
  long tmp ;

  {
  {
#line 592
  tmp = limit_pathconf(14, path);
  }
#line 592
  return (tmp);
}
}
#line 607 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_fname(int fd ) 
{ 
  long tmp ;

  {
  {
#line 609
  tmp = limit_fpathconf(14, fd);
  }
#line 609
  return (tmp);
}
}
#line 623 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_name(void) 
{ 
  long tmp ;
  char *__cil_tmp2 ;

  {
  {
#line 625
  tmp = limit_pname("/");
  }
#line 625
  return (tmp);
}
}
#line 640 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_ppath(char const   *path ) 
{ 
  long tmp ;

  {
  {
#line 642
  tmp = limit_pathconf(15, path);
  }
#line 642
  return (tmp);
}
}
#line 657 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_fpath(int fd ) 
{ 
  long tmp ;

  {
  {
#line 659
  tmp = limit_fpathconf(15, fd);
  }
#line 659
  return (tmp);
}
}
#line 673 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_path(void) 
{ 
  long tmp ;
  char *__cil_tmp2 ;

  {
  {
#line 675
  tmp = limit_ppath("/");
  }
#line 675
  return (tmp);
}
}
#line 689 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_ppipe(char const   *path ) 
{ 
  long tmp ;

  {
  {
#line 691
  tmp = limit_pathconf(16, path);
  }
#line 691
  return (tmp);
}
}
#line 705 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_fpipe(int fd ) 
{ 
  long tmp ;

  {
  {
#line 707
  tmp = limit_fpathconf(16, fd);
  }
#line 707
  return (tmp);
}
}
#line 721 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_pnotrunc(char const   *path ) 
{ 
  long tmp ;

  {
  {
#line 723
  tmp = limit_pathconf(17, path);
  }
#line 723
  return (tmp);
}
}
#line 737 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_fnotrunc(int fd ) 
{ 
  long tmp ;

  {
  {
#line 739
  tmp = limit_fpathconf(17, fd);
  }
#line 739
  return (tmp);
}
}
#line 753 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_notrunc(void) 
{ 
  long tmp ;
  char *__cil_tmp2 ;

  {
  {
#line 755
  tmp = limit_pnotrunc("/");
  }
#line 755
  return (tmp);
}
}
#line 769 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_pchown(char const   *path ) 
{ 
  long tmp ;

  {
  {
#line 771
  tmp = limit_pathconf(18, path);
  }
#line 771
  return (tmp);
}
}
#line 785 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_fchown(int fd ) 
{ 
  long tmp ;

  {
  {
#line 787
  tmp = limit_fpathconf(18, fd);
  }
#line 787
  return (tmp);
}
}
#line 801 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/lim.c"
long limit_chown(void) 
{ 
  long tmp ;
  char *__cil_tmp2 ;

  {
  {
#line 803
  tmp = limit_pchown("/");
  }
#line 803
  return (tmp);
}
}
#line 36 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/hsort.h"
void hsort_closure(void *base , size_t n , size_t size , hsort_closure_cmp_t *cmp ,
                   void const   *data ) ;
#line 156 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/hsort.c"
static void swap(char *p1 , char *p2 , size_t n ) 
{ 
  register char ctmp ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    tmp___1 = n;
#line 183
    n --;
#line 183
    if (! (tmp___1 != 0UL)) {
#line 183
      goto while_break;
    }
#line 185
    ctmp = *p1;
#line 185
    tmp = p1;
#line 185
    p1 ++;
#line 185
    *tmp = *p2;
#line 185
    tmp___0 = p2;
#line 185
    p2 ++;
#line 185
    *tmp___0 = ctmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return;
}
}
#line 201 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/hsort.c"
void hsort(void *base , size_t n , size_t size , hsort_cmp_t *cmp ) 
{ 
  register char *p ;
  register char *q ;
  register char *base0 ;
  register char *hi ;
  register unsigned int gap ;
  register unsigned int g___4 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 206
  if (n < 2UL) {
#line 207
    return;
  }
#line 209
  base0 = (char *)base - size;
#line 220
  gap = (unsigned int )((n >> 1) * size);
#line 221
  hi = (base0 + gap) + gap;
#line 222
  if (n & 1UL) {
#line 223
    hi += size;
  }
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! ((size_t )gap != size)) {
#line 234
      goto while_break;
    }
#line 238
    g___4 = gap;
#line 238
    p = base0 + g___4;
    {
#line 238
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 238
      q = p + g___4;
#line 238
      if (! ((unsigned long )q <= (unsigned long )hi)) {
#line 238
        goto while_break___0;
      }
#line 240
      g___4 += g___4;
#line 246
      if ((unsigned long )q != (unsigned long )hi) {
        {
#line 246
        tmp = (*cmp)((void const   *)(q + size), (void const   *)q);
        }
#line 246
        if (tmp > 0) {
#line 248
          q += size;
#line 249
          g___4 = (unsigned int )((size_t )g___4 + size);
        }
      }
      {
#line 256
      tmp___0 = (*cmp)((void const   *)p, (void const   *)q);
      }
#line 256
      if (tmp___0 >= 0) {
#line 257
        goto while_break___0;
      }
      {
#line 259
      swap(p, q, size);
#line 238
      p = q;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 234
    gap = (unsigned int )((size_t )gap - size);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 271
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 271
    if (! ((unsigned long )hi != (unsigned long )base)) {
#line 271
      goto while_break___1;
    }
#line 275
    p = (char *)base;
#line 276
    g___4 = (unsigned int )size;
    {
#line 276
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 276
      q = p + g___4;
#line 276
      if (! ((unsigned long )q <= (unsigned long )hi)) {
#line 276
        goto while_break___2;
      }
#line 278
      g___4 += g___4;
#line 279
      if ((unsigned long )q != (unsigned long )hi) {
        {
#line 279
        tmp___1 = (*cmp)((void const   *)(q + size), (void const   *)q);
        }
#line 279
        if (tmp___1 > 0) {
#line 281
          q += size;
#line 282
          g___4 = (unsigned int )((size_t )g___4 + size);
        }
      }
      {
#line 285
      tmp___2 = (*cmp)((void const   *)p, (void const   *)q);
      }
#line 285
      if (tmp___2 >= 0) {
#line 286
        goto while_break___2;
      }
      {
#line 288
      swap(p, q, size);
#line 276
      p = q;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 291
    swap((char *)base, hi, size);
#line 271
    hi -= size;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 293
  return;
}
}
#line 295 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/hsort.c"
void hsort_closure(void *base , size_t n , size_t size , hsort_closure_cmp_t *cmp ,
                   void const   *data ) 
{ 
  register char *p ;
  register char *q ;
  register char *base0 ;
  register char *hi ;
  register unsigned int gap ;
  register unsigned int g___4 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 300
  if (n < 2UL) {
#line 301
    return;
  }
#line 303
  base0 = (char *)base - size;
#line 314
  gap = (unsigned int )((n >> 1) * size);
#line 315
  hi = (base0 + gap) + gap;
#line 316
  if (n & 1UL) {
#line 317
    hi += size;
  }
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    if (! ((size_t )gap != size)) {
#line 328
      goto while_break;
    }
#line 332
    g___4 = gap;
#line 332
    p = base0 + g___4;
    {
#line 332
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 332
      q = p + g___4;
#line 332
      if (! ((unsigned long )q <= (unsigned long )hi)) {
#line 332
        goto while_break___0;
      }
#line 334
      g___4 += g___4;
#line 340
      if ((unsigned long )q != (unsigned long )hi) {
        {
#line 340
        tmp = (*cmp)((void const   *)(q + size), (void const   *)q, data);
        }
#line 340
        if (tmp > 0) {
#line 342
          q += size;
#line 343
          g___4 = (unsigned int )((size_t )g___4 + size);
        }
      }
      {
#line 350
      tmp___0 = (*cmp)((void const   *)p, (void const   *)q, data);
      }
#line 350
      if (tmp___0 >= 0) {
#line 351
        goto while_break___0;
      }
      {
#line 353
      swap(p, q, size);
#line 332
      p = q;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 328
    gap = (unsigned int )((size_t )gap - size);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 365
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 365
    if (! ((unsigned long )hi != (unsigned long )base)) {
#line 365
      goto while_break___1;
    }
#line 369
    p = (char *)base;
#line 370
    g___4 = (unsigned int )size;
    {
#line 370
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 370
      q = p + g___4;
#line 370
      if (! ((unsigned long )q <= (unsigned long )hi)) {
#line 370
        goto while_break___2;
      }
#line 372
      g___4 += g___4;
#line 373
      if ((unsigned long )q != (unsigned long )hi) {
        {
#line 373
        tmp___1 = (*cmp)((void const   *)(q + size), (void const   *)q, data);
        }
#line 373
        if (tmp___1 > 0) {
#line 375
          q += size;
#line 376
          g___4 = (unsigned int )((size_t )g___4 + size);
        }
      }
      {
#line 379
      tmp___2 = (*cmp)((void const   *)p, (void const   *)q, data);
      }
#line 379
      if (tmp___2 >= 0) {
#line 380
        goto while_break___2;
      }
      {
#line 382
      swap(p, q, size);
#line 370
      p = q;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 385
    swap((char *)base, hi, size);
#line 365
    hi -= size;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 387
  return;
}
}
#line 550 "/usr/include/stdio.h"
extern int getc_unlocked(FILE *__stream ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 213 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 349
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkfifo)(char const   *__path ,
                                                                                             __mode_t __mode ) ;
#line 33 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/fio.h"
char *fgetline(char *line , size_t size , FILE *stream ) ;
#line 38
int nap(long sec , long usec ) ;
#line 39
int fcntl_set_flag(int fd , int flag ) ;
#line 40
int fcntl_clear_flag(int fd , int flag ) ;
#line 41
int fcntl_lock(int fd , int cmd , int type , int whence , int start , int len ) ;
#line 42
int nonblock_set(int fd , int arg ) ;
#line 45
int fifo_exists(char const   *path , int prepare ) ;
#line 46
int fifo_has_reader(char const   *path , int prepare ) ;
#line 47
int fifo_open(char const   *path , mode_t mode , int lock , int *writefd ) ;
#line 122 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/fio.c"
char *fgetline(char *line , size_t size , FILE *stream ) 
{ 
  char *ret ;

  {
  {
#line 126
  flockfile(stream);
#line 127
  ret = fgetline_unlocked(line, size, stream);
#line 128
  funlockfile(stream);
  }
#line 130
  return (ret);
}
}
#line 143 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/fio.c"
char *fgetline_unlocked(char *line , size_t size , FILE *stream ) 
{ 
  char *s ;
  char *end ;
  int c ;
  int c2 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 145
  s = line;
#line 146
  end = (line + size) - 1;
#line 147
  c = '\000';
#line 149
  if (! s) {
#line 150
    return ((char *)((void *)0));
  }
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if ((unsigned long )s < (unsigned long )end) {
      {
#line 152
      c = getc_unlocked(stream);
      }
#line 152
      if (! (c != -1)) {
#line 152
        goto while_break;
      }
    } else {
#line 152
      goto while_break;
    }
#line 154
    if (c == 10) {
#line 156
      tmp = s;
#line 156
      s ++;
#line 156
      *tmp = (char )c;
#line 157
      goto while_break;
    } else
#line 159
    if (c == 13) {
      {
#line 161
      tmp___0 = s;
#line 161
      s ++;
#line 161
      *tmp___0 = (char )'\n';
#line 163
      c2 = getc_unlocked(stream);
      }
#line 163
      if (c2 == 10) {
#line 164
        goto while_break;
      }
      {
#line 166
      ungetc(c2, stream);
      }
#line 167
      goto while_break;
    } else {
#line 170
      tmp___1 = s;
#line 170
      s ++;
#line 170
      *tmp___1 = (char )c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  *s = (char )'\000';
#line 175
  if (c == -1) {
#line 175
    if ((unsigned long )s == (unsigned long )line) {
#line 176
      return ((char *)((void *)0));
    } else {
      {
#line 175
      tmp___2 = ferror(stream);
      }
#line 175
      if (tmp___2) {
#line 176
        return ((char *)((void *)0));
      }
    }
  }
#line 178
  return (line);
}
}
#line 201 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/fio.c"
int read_timeout(int fd , long sec , long usec ) 
{ 
  fd_set readfds[1] ;
  fd_set exceptfds[1] ;
  struct timeval timeout___0[1] ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;

  {
#line 207
  if (fd < 0) {
    {
#line 208
    tmp = set_errno(22);
    }
#line 208
    return (tmp);
  } else
#line 207
  if (sec < 0L) {
    {
#line 208
    tmp = set_errno(22);
    }
#line 208
    return (tmp);
  } else
#line 207
  if (usec < 0L) {
    {
#line 208
    tmp = set_errno(22);
    }
#line 208
    return (tmp);
  }
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readfds[0].fds_bits[0]): "memory");
#line 210
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 211
  readfds[0].fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << fd % (8 * (int )sizeof(__fd_mask )));
#line 212
  exceptfds[0] = readfds[0];
#line 213
  timeout___0[0].tv_sec = sec;
#line 214
  timeout___0[0].tv_usec = usec;
#line 216
  tmp___0 = select(fd + 1, (fd_set */* __restrict  */)(readfds), (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)(exceptfds), (struct timeval */* __restrict  */)(timeout___0));
  }
  {
#line 218
  if (tmp___0 == -1) {
#line 218
    goto case_neg_1;
  }
#line 220
  if (tmp___0 == 0) {
#line 220
    goto case_0;
  }
#line 216
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 219
  return (-1);
  case_0: /* CIL Label */ 
  {
#line 221
  tmp___1 = set_errno(110);
  }
#line 221
  return (tmp___1);
  switch_break: /* CIL Label */ ;
  }
#line 224
  return (0);
}
}
#line 246 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/fio.c"
int write_timeout(int fd , long sec , long usec ) 
{ 
  fd_set writefds[1] ;
  struct timeval timeout___0[1] ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 251
  if (fd < 0) {
    {
#line 252
    tmp = set_errno(22);
    }
#line 252
    return (tmp);
  } else
#line 251
  if (sec < 0L) {
    {
#line 252
    tmp = set_errno(22);
    }
#line 252
    return (tmp);
  } else
#line 251
  if (usec < 0L) {
    {
#line 252
    tmp = set_errno(22);
    }
#line 252
    return (tmp);
  }
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& writefds[0].fds_bits[0]): "memory");
#line 254
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 255
  writefds[0].fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << fd % (8 * (int )sizeof(__fd_mask )));
#line 256
  timeout___0[0].tv_sec = sec;
#line 257
  timeout___0[0].tv_usec = usec;
#line 259
  tmp___0 = select(fd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(writefds),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(timeout___0));
  }
  {
#line 261
  if (tmp___0 == -1) {
#line 261
    goto case_neg_1;
  }
#line 263
  if (tmp___0 == 0) {
#line 263
    goto case_0;
  }
#line 259
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 262
  return (-1);
  case_0: /* CIL Label */ 
  {
#line 264
  tmp___1 = set_errno(110);
  }
#line 264
  return (tmp___1);
  switch_break: /* CIL Label */ ;
  }
#line 267
  return (0);
}
}
#line 297 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/fio.c"
int rw_timeout(int fd , long sec , long usec ) 
{ 
  fd_set readfds[1] ;
  fd_set writefds[1] ;
  fd_set exceptfds[1] ;
  struct timeval timeout___0[1] ;
  int rc ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 303
  rc = 0;
#line 305
  if (fd < 0) {
    {
#line 306
    tmp = set_errno(22);
    }
#line 306
    return (tmp);
  } else
#line 305
  if (sec < 0L) {
    {
#line 306
    tmp = set_errno(22);
    }
#line 306
    return (tmp);
  } else
#line 305
  if (usec < 0L) {
    {
#line 306
    tmp = set_errno(22);
    }
#line 306
    return (tmp);
  }
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readfds[0].fds_bits[0]): "memory");
#line 308
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 309
  readfds[0].fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << fd % (8 * (int )sizeof(__fd_mask )));
#line 310
  writefds[0] = readfds[0];
#line 311
  exceptfds[0] = readfds[0];
#line 312
  timeout___0[0].tv_sec = sec;
#line 313
  timeout___0[0].tv_usec = usec;
#line 315
  tmp___0 = select(fd + 1, (fd_set */* __restrict  */)(readfds), (fd_set */* __restrict  */)(writefds),
                   (fd_set */* __restrict  */)(exceptfds), (struct timeval */* __restrict  */)(timeout___0));
  }
  {
#line 317
  if (tmp___0 == -1) {
#line 317
    goto case_neg_1;
  }
#line 319
  if (tmp___0 == 0) {
#line 319
    goto case_0;
  }
#line 315
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 318
  return (-1);
  case_0: /* CIL Label */ 
  {
#line 320
  tmp___1 = set_errno(110);
  }
#line 320
  return (tmp___1);
  switch_break: /* CIL Label */ ;
  }
#line 323
  if ((readfds[0].fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 324
    rc |= 4;
  }
#line 326
  if ((writefds[0].fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 327
    rc |= 2;
  }
#line 329
  if ((exceptfds[0].fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 330
    rc |= 1;
  }
#line 332
  return (rc);
}
}
#line 350 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/fio.c"
int nap(long sec , long usec ) 
{ 
  struct timeval tv[1] ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 354
  if (sec < 0L) {
    {
#line 355
    tmp = set_errno(22);
    }
#line 355
    return (tmp);
  } else
#line 354
  if (usec < 0L) {
    {
#line 355
    tmp = set_errno(22);
    }
#line 355
    return (tmp);
  }
  {
#line 357
  tv[0].tv_sec = sec;
#line 358
  tv[0].tv_usec = usec;
#line 360
  tmp___0 = select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(tv));
  }
#line 360
  return (tmp___0);
}
}
#line 376 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/fio.c"
int fcntl_set_flag(int fd , int flag ) 
{ 
  int flags ;
  int tmp ;

  {
  {
#line 380
  flags = fcntl(fd, 3, 0);
  }
#line 380
  if (flags == -1) {
#line 381
    return (-1);
  }
  {
#line 383
  tmp = fcntl(fd, 4, flags | flag);
  }
#line 383
  return (tmp);
}
}
#line 399 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/fio.c"
int fcntl_clear_flag(int fd , int flag ) 
{ 
  int flags ;
  int tmp ;

  {
  {
#line 403
  flags = fcntl(fd, 3, 0);
  }
#line 403
  if (flags == -1) {
#line 404
    return (-1);
  }
  {
#line 406
  tmp = fcntl(fd, 4, flags & ~ flag);
  }
#line 406
  return (tmp);
}
}
#line 426 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/fio.c"
int fcntl_lock(int fd , int cmd , int type , int whence , int start , int len ) 
{ 
  struct flock lock[1] ;
  int tmp ;
  void *__cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 430
  lock[0].l_type = (short )type;
#line 431
  lock[0].l_whence = (short )whence;
#line 432
  lock[0].l_start = (__off_t )start;
#line 433
  lock[0].l_len = (__off_t )len;
#line 435
  tmp = fcntl(fd, cmd, lock);
  }
#line 435
  return (tmp);
}
}
#line 451 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/fio.c"
int nonblock_set(int fd , int arg ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 453
  if (arg) {
    {
#line 453
    tmp = nonblock_on(fd);
#line 453
    tmp___1 = tmp;
    }
  } else {
    {
#line 453
    tmp___0 = nonblock_off(fd);
#line 453
    tmp___1 = tmp___0;
    }
  }
#line 453
  return (tmp___1);
}
}
#line 468 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/fio.c"
int nonblock_on(int fd ) 
{ 
  int tmp ;

  {
  {
#line 470
  tmp = fcntl_set_flag(fd, 2048);
  }
#line 470
  return (tmp);
}
}
#line 485 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/fio.c"
int nonblock_off(int fd ) 
{ 
  int tmp ;

  {
  {
#line 487
  tmp = fcntl_clear_flag(fd, 2048);
  }
#line 487
  return (tmp);
}
}
#line 503 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/fio.c"
int fifo_exists(char const   *path , int prepare ) 
{ 
  struct stat status[1] ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp8 ;
  int __cil_tmp9 ;
  void *__cil_tmp10 ;

  {
  {
#line 507
  tmp___2 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(status));
  }
#line 507
  if (tmp___2 == -1) {
    {
#line 508
    tmp___1 = __errno_location();
    }
#line 508
    if (*tmp___1 == 2) {
#line 508
      tmp___0 = 0;
    } else {
#line 508
      tmp___0 = -1;
    }
#line 508
    return (tmp___0);
  }
#line 510
  if (((status[0].st_mode & 61440U) == 4096U) == 0) {
#line 512
    if (prepare) {
      {
#line 513
      unlink(path);
      }
    }
#line 515
    return (0);
  }
#line 518
  return (1);
}
}
#line 535 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/fio.c"
int fifo_has_reader(char const   *path , int prepare ) 
{ 
  int fd ;
  int tmp ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 544
  tmp = fifo_exists(path, prepare);
  }
  {
#line 546
  if (tmp == 0) {
#line 546
    goto case_0;
  }
#line 547
  if (tmp == -1) {
#line 547
    goto case_neg_1;
  }
#line 544
  goto switch_break;
  case_0: /* CIL Label */ 
#line 546
  return (0);
  case_neg_1: /* CIL Label */ 
#line 547
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 556
  fd = open(path, 2049);
  }
#line 556
  if (fd == -1) {
    {
#line 557
    tmp___2 = __errno_location();
    }
#line 557
    if (*tmp___2 == 6) {
#line 557
      tmp___1 = 0;
    } else {
#line 557
      tmp___1 = -1;
    }
#line 557
    return (tmp___1);
  }
  {
#line 559
  tmp___3 = close(fd);
  }
#line 559
  if (tmp___3 == -1) {
#line 560
    return (-1);
  }
#line 562
  return (1);
}
}
#line 598 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/fio.c"
int fifo_open(char const   *path , mode_t mode , int lock , int *writefd ) 
{ 
  struct stat status[1] ;
  int rfd ;
  int wfd ;
  int mine ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  void *__cil_tmp24 ;
  int __cil_tmp25 ;
  void *__cil_tmp26 ;

  {
  {
#line 601
  mine = 0;
#line 605
  tmp = fifo_has_reader(path, 1);
  }
  {
#line 607
  if (tmp == 1) {
#line 607
    goto case_1;
  }
#line 608
  if (tmp == -1) {
#line 608
    goto case_neg_1;
  }
#line 605
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 607
  tmp___0 = set_errno(98);
  }
#line 607
  return (tmp___0);
  case_neg_1: /* CIL Label */ 
#line 608
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 613
  tmp___2 = mkfifo(path, mode);
  }
#line 613
  if (tmp___2 != -1) {
#line 614
    mine = 1;
  } else {
    {
#line 615
    tmp___1 = __errno_location();
    }
#line 615
    if (*tmp___1 != 17) {
#line 616
      return (-1);
    }
  }
  {
#line 625
  rfd = open(path, 2048);
  }
#line 625
  if (rfd == -1) {
#line 627
    if (mine) {
      {
#line 628
      unlink(path);
      }
    }
#line 629
    return (-1);
  }
  {
#line 638
  tmp___3 = fstat(rfd, status);
  }
#line 638
  if (tmp___3 == -1) {
#line 638
    goto _L;
  } else
#line 638
  if (((status[0].st_mode & 61440U) == 4096U) == 0) {
    _L: /* CIL Label */ 
#line 640
    if (mine) {
      {
#line 641
      unlink(path);
      }
    }
    {
#line 642
    close(rfd);
    }
#line 643
    return (-1);
  }
  {
#line 657
  wfd = open(path, 1);
  }
#line 657
  if (wfd == -1) {
#line 659
    if (mine) {
      {
#line 660
      unlink(path);
      }
    }
    {
#line 661
    close(rfd);
    }
#line 662
    return (-1);
  }
#line 677
  if (lock) {
    {
#line 677
    tmp___8 = fcntl_lock(wfd, 6, 1, 0, 0, 0);
    }
#line 677
    if (tmp___8 == -1) {
      {
#line 677
      tmp___9 = __errno_location();
      }
#line 677
      if (*tmp___9 != 95) {
        {
#line 677
        tmp___10 = __errno_location();
        }
#line 677
        if (*tmp___10 != 95) {
          {
#line 677
          tmp___11 = __errno_location();
          }
#line 677
          if (*tmp___11 != 9) {
#line 679
            if (mine) {
              {
#line 680
              unlink(path);
              }
            }
            {
#line 681
            close(rfd);
#line 682
            close(wfd);
#line 683
            tmp___7 = __errno_location();
            }
#line 683
            if (*tmp___7 == 13) {
              {
#line 683
              tmp___5 = set_errno(98);
#line 683
              tmp___6 = tmp___5;
              }
            } else {
#line 683
              tmp___6 = -1;
            }
#line 683
            return (tmp___6);
          }
        }
      }
    }
  }
  {
#line 688
  tmp___12 = fstat(wfd, status);
  }
#line 688
  if (tmp___12 == -1) {
#line 688
    goto _L___0;
  } else
#line 688
  if (((status[0].st_mode & 61440U) == 4096U) == 0) {
    _L___0: /* CIL Label */ 
#line 690
    if (mine) {
      {
#line 691
      unlink(path);
      }
    }
    {
#line 692
    close(rfd);
#line 693
    close(wfd);
    }
#line 694
    return (-1);
  }
  {
#line 699
  tmp___13 = nonblock_off(rfd);
  }
#line 699
  if (tmp___13 == -1) {
#line 701
    if (mine) {
      {
#line 702
      unlink(path);
      }
    }
    {
#line 703
    close(rfd);
#line 704
    close(wfd);
    }
#line 705
    return (-1);
  }
#line 714
  if (writefd) {
#line 715
    *writefd = wfd;
  }
#line 717
  return (rfd);
}
}
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 60 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.h"
void vmsg(char const   *format , va_list args ) ;
#line 61
void verbose(size_t level , char const   *format  , ...) ;
#line 62
void vverbose(size_t level , char const   *format , va_list args ) ;
#line 63
void debugf(size_t level , char const   *format  , ...) ;
#line 64
void vdebugf(size_t level , char const   *format , va_list args ) ;
#line 66
int verror(char const   *format , va_list args ) ;
#line 67
void fatal(char const   *format  , ...) ;
#line 68
void vfatal(char const   *format , va_list args ) ;
#line 69
void dump(char const   *format  , ...) ;
#line 70
void vdump(char const   *format , va_list args ) ;
#line 71
void alert(int priority , char const   *format  , ...) ;
#line 72
void valert(int priority , char const   *format , va_list args ) ;
#line 73
void debugsysf(size_t level , char const   *format  , ...) ;
#line 74
void vdebugsysf(size_t level , char const   *format , va_list args ) ;
#line 75
int errorsys(char const   *format  , ...) ;
#line 76
int verrorsys(char const   *format , va_list args ) ;
#line 77
void fatalsys(char const   *format  , ...) ;
#line 78
void vfatalsys(char const   *format , va_list args ) ;
#line 79
void dumpsys(char const   *format  , ...) ;
#line 80
void vdumpsys(char const   *format , va_list args ) ;
#line 81
void alertsys(int priority , char const   *format  , ...) ;
#line 82
void valertsys(int priority , char const   *format , va_list args ) ;
#line 149 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
void msg(char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 152
  __builtin_va_start(args, format);
#line 153
  vmsg(format, args);
#line 154
  __builtin_va_end(args);
  }
#line 155
  return;
}
}
#line 168 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
void vmsg(char const   *format , va_list args ) 
{ 
  Msg *tmp ;

  {
  {
#line 170
  tmp = prog_out();
#line 170
  vmsg_out(tmp, format, args);
  }
#line 171
  return;
}
}
#line 190 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
void verbose(size_t level , char const   *format  , ...) 
{ 
  va_list args ;
  size_t tmp ;

  {
  {
#line 192
  tmp = prog_verbosity_level();
  }
#line 192
  if (tmp >= level) {
    {
#line 195
    __builtin_va_start(args, format);
#line 196
    vverbose(level, format, args);
#line 197
    __builtin_va_end(args);
    }
  }
#line 199
  return;
}
}
#line 212 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
void vverbose(size_t level , char const   *format , va_list args ) 
{ 
  char mesg[8192] ;
  char const   *tmp ;
  Msg *tmp___0 ;
  Msg *tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 214
  tmp___3 = prog_verbosity_level();
  }
#line 214
  if (tmp___3 >= level) {
    {
#line 217
    vsnprintf((char */* __restrict  */)(mesg), (size_t )8192, (char const   */* __restrict  */)format,
              args);
#line 219
    tmp___2 = prog_name();
    }
#line 219
    if (tmp___2) {
      {
#line 220
      tmp = prog_name();
#line 220
      tmp___0 = prog_out();
#line 220
      msg_out(tmp___0, "%s: %*s%s\n", tmp, level, "", mesg);
      }
    } else {
      {
#line 222
      tmp___1 = prog_out();
#line 222
      msg_out(tmp___1, "%*s%s\n", level, "", mesg);
      }
    }
  }
#line 224
  return;
}
}
#line 250 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
static int debug_level_match(size_t level ) 
{ 
  size_t debug_level ;
  size_t debug_section ;
  size_t section ;
  int tmp ;

  {
  {
#line 254
  debug_level = prog_debug_level();
#line 255
  debug_section = debug_level & 4294967040UL;
#line 256
  debug_level &= 255UL;
#line 257
  section = level & 4294967040UL;
#line 258
  level &= 255UL;
  }
#line 260
  if (! debug_section) {
#line 260
    goto _L;
  } else
#line 260
  if (debug_section & section) {
    _L: /* CIL Label */ 
#line 260
    if (debug_level >= level) {
#line 260
      tmp = 1;
    } else {
#line 260
      tmp = 0;
    }
  } else {
#line 260
    tmp = 0;
  }
#line 260
  return (tmp);
}
}
#line 263 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
void debugf(size_t level , char const   *format  , ...) 
{ 
  va_list args ;
  int tmp ;

  {
  {
#line 265
  tmp = debug_level_match(level);
  }
#line 265
  if (tmp) {
    {
#line 268
    __builtin_va_start(args, format);
#line 269
    vdebugf(level, format, args);
#line 270
    __builtin_va_end(args);
    }
  }
#line 272
  return;
}
}
#line 285 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
void vdebugf(size_t level , char const   *format , va_list args ) 
{ 
  char mesg[8192] ;
  char prefix[32] ;
  unsigned int tmp ;
  char const   *tmp___0 ;
  Msg *tmp___1 ;
  Msg *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 287
  tmp___4 = debug_level_match(level);
  }
#line 287
  if (tmp___4) {
#line 289
    prefix[0] = (char )'\000';
#line 289
    tmp = 1U;
    {
#line 289
    while (1) {
      while_continue: /* CIL Label */ ;
#line 289
      if (tmp >= 32U) {
#line 289
        goto while_break;
      }
#line 289
      prefix[tmp] = (char)0;
#line 289
      tmp ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 290
    vsnprintf((char */* __restrict  */)(mesg), (size_t )8192, (char const   */* __restrict  */)format,
              args);
    }
#line 292
    if (level & 4294967040UL) {
      {
#line 293
      snprintf((char */* __restrict  */)(prefix), (size_t )32, (char const   */* __restrict  */)" [%d]",
               (int )((level & 4294967040UL) >> 8));
      }
    }
    {
#line 295
    tmp___3 = prog_name();
    }
#line 295
    if (tmp___3) {
      {
#line 296
      tmp___0 = prog_name();
#line 296
      tmp___1 = prog_dbg();
#line 296
      msg_out(tmp___1, "%s: debug:%s%*s%s\n", tmp___0, prefix, level & 255UL, "",
              mesg);
      }
    } else {
      {
#line 298
      tmp___2 = prog_dbg();
#line 298
      msg_out(tmp___2, "debug:%s%*s%s\n", prefix, level & 255UL, "", mesg);
      }
    }
  }
#line 300
  return;
}
}
#line 316 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
int error(char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 319
  __builtin_va_start(args, format);
#line 320
  verror(format, args);
#line 321
  __builtin_va_end(args);
  }
#line 323
  return (-1);
}
}
#line 337 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
int verror(char const   *format , va_list args ) 
{ 
  char mesg[8192] ;
  char const   *tmp ;
  Msg *tmp___0 ;
  Msg *tmp___1 ;
  char const   *tmp___2 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 340
  vsnprintf((char */* __restrict  */)(mesg), (size_t )8192, (char const   */* __restrict  */)format,
            args);
#line 342
  tmp___2 = prog_name();
  }
#line 342
  if (tmp___2) {
    {
#line 343
    tmp = prog_name();
#line 343
    tmp___0 = prog_err();
#line 343
    msg_out(tmp___0, "%s: %s\n", tmp, mesg);
    }
  } else {
    {
#line 345
    tmp___1 = prog_err();
#line 345
    msg_out(tmp___1, "%s\n", mesg);
    }
  }
#line 347
  return (-1);
}
}
#line 367 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
void fatal(char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 370
  __builtin_va_start(args, format);
#line 371
  vfatal(format, args);
#line 372
  __builtin_va_end(args);
  }
#line 373
  return;
}
}
#line 386 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
void vfatal(char const   *format , va_list args ) 
{ 
  char mesg[8192] ;
  void *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 389
  vsnprintf((char */* __restrict  */)(mesg), (size_t )8192, (char const   */* __restrict  */)format,
            args);
#line 390
  error("fatal: %s", mesg);
#line 391
  exit(1);
  }
}
}
#line 411 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
void dump(char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 414
  __builtin_va_start(args, format);
#line 415
  vdump(format, args);
#line 416
  __builtin_va_end(args);
  }
#line 417
  return;
}
}
#line 430 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
void vdump(char const   *format , va_list args ) 
{ 
  char mesg[8192] ;
  void *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 433
  vsnprintf((char */* __restrict  */)(mesg), (size_t )8192, (char const   */* __restrict  */)format,
            args);
#line 434
  error("dump: %s", mesg);
#line 435
  abort();
  }
}
}
#line 456 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
void alert(int priority , char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 459
  __builtin_va_start(args, format);
#line 460
  valert(priority, format, args);
#line 461
  __builtin_va_end(args);
  }
#line 462
  return;
}
}
#line 475 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
void valert(int priority , char const   *format , va_list args ) 
{ 
  Msg *alert___0 ;
  char mesg[8192] ;
  int err ;
  char const   *tmp ;
  char const   *tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 481
  vsnprintf((char */* __restrict  */)(mesg), (size_t )8192, (char const   */* __restrict  */)format,
            args);
#line 483
  alert___0 = prog_alert();
#line 485
  err = msg_wrlock(alert___0);
  }
#line 485
  if (err) {
    {
#line 487
    set_errno(err);
    }
#line 488
    return;
  }
  {
#line 491
  msg_syslog_set_priority_unlocked(alert___0, priority);
#line 493
  tmp___0 = prog_name();
  }
#line 493
  if (tmp___0) {
    {
#line 494
    tmp = prog_name();
#line 494
    msg_out_unlocked(alert___0, "%s: %s\n", tmp, mesg);
    }
  } else {
    {
#line 496
    msg_out_unlocked(alert___0, "%s\n", mesg);
    }
  }
  {
#line 498
  err = msg_unlock(alert___0);
  }
#line 498
  if (err) {
    {
#line 499
    set_errno(err);
    }
  }
#line 500
  return;
}
}
#line 514 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
void debugsysf(size_t level , char const   *format  , ...) 
{ 
  va_list args ;
  int tmp ;

  {
  {
#line 516
  tmp = debug_level_match(level);
  }
#line 516
  if (tmp) {
    {
#line 519
    __builtin_va_start(args, format);
#line 520
    vdebugsysf(level, format, args);
#line 521
    __builtin_va_end(args);
    }
  }
#line 523
  return;
}
}
#line 536 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
void vdebugsysf(size_t level , char const   *format , va_list args ) 
{ 
  char mesg[8192] ;
  int errno_saved ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 538
  tmp___1 = debug_level_match(level);
  }
#line 538
  if (tmp___1) {
    {
#line 541
    tmp = __errno_location();
#line 541
    errno_saved = *tmp;
#line 542
    vsnprintf((char */* __restrict  */)(mesg), (size_t )8192, (char const   */* __restrict  */)format,
              args);
#line 543
    tmp___0 = strerror(errno_saved);
#line 543
    debugf(level, "%s: %s", mesg, tmp___0);
    }
  }
#line 545
  return;
}
}
#line 559 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
int errorsys(char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 562
  __builtin_va_start(args, format);
#line 563
  verrorsys(format, args);
#line 564
  __builtin_va_end(args);
  }
#line 565
  return (-1);
}
}
#line 579 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
int verrorsys(char const   *format , va_list args ) 
{ 
  char mesg[8192] ;
  int errno_saved ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 582
  tmp = __errno_location();
#line 582
  errno_saved = *tmp;
#line 583
  vsnprintf((char */* __restrict  */)(mesg), (size_t )8192, (char const   */* __restrict  */)format,
            args);
#line 584
  tmp___0 = strerror(errno_saved);
#line 584
  tmp___1 = error("%s: %s", mesg, tmp___0);
  }
#line 584
  return (tmp___1);
}
}
#line 599 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
void fatalsys(char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 602
  __builtin_va_start(args, format);
#line 603
  vfatalsys(format, args);
#line 604
  __builtin_va_end(args);
  }
#line 605
  return;
}
}
#line 618 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
void vfatalsys(char const   *format , va_list args ) 
{ 
  char mesg[8192] ;
  int errno_saved ;
  int *tmp ;
  char *tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 621
  tmp = __errno_location();
#line 621
  errno_saved = *tmp;
#line 622
  vsnprintf((char */* __restrict  */)(mesg), (size_t )8192, (char const   */* __restrict  */)format,
            args);
#line 623
  tmp___0 = strerror(errno_saved);
#line 623
  fatal("%s: %s", mesg, tmp___0);
  }
#line 624
  return;
}
}
#line 638 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
void dumpsys(char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 641
  __builtin_va_start(args, format);
#line 642
  vdumpsys(format, args);
#line 643
  __builtin_va_end(args);
  }
#line 644
  return;
}
}
#line 657 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
void vdumpsys(char const   *format , va_list args ) 
{ 
  char mesg[8192] ;
  int errno_saved ;
  int *tmp ;
  char *tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 660
  tmp = __errno_location();
#line 660
  errno_saved = *tmp;
#line 661
  vsnprintf((char */* __restrict  */)(mesg), (size_t )8192, (char const   */* __restrict  */)format,
            args);
#line 662
  tmp___0 = strerror(errno_saved);
#line 662
  dump("%s: %s", mesg, tmp___0);
  }
#line 663
  return;
}
}
#line 677 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
void alertsys(int priority , char const   *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 680
  __builtin_va_start(args, format);
#line 681
  valertsys(priority, format, args);
#line 682
  __builtin_va_end(args);
  }
#line 683
  return;
}
}
#line 696 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
void valertsys(int priority , char const   *format , va_list args ) 
{ 
  char mesg[8192] ;
  int errno_saved ;
  int *tmp ;
  char *tmp___0 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 699
  tmp = __errno_location();
#line 699
  errno_saved = *tmp;
#line 700
  vsnprintf((char */* __restrict  */)(mesg), (size_t )8192, (char const   */* __restrict  */)format,
            args);
#line 701
  tmp___0 = strerror(errno_saved);
#line 701
  alert(priority, "%s: %s", mesg, tmp___0);
  }
#line 702
  return;
}
}
#line 714 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
int set_errno(int errnum ) 
{ 
  int *tmp ;

  {
  {
#line 716
  tmp = __errno_location();
#line 716
  *tmp = errnum;
  }
#line 717
  return (-1);
}
}
#line 730 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
void *set_errnull(int errnum ) 
{ 
  int *tmp ;

  {
  {
#line 732
  tmp = __errno_location();
#line 732
  *tmp = errnum;
  }
#line 733
  return ((void *)0);
}
}
#line 748 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/err.c"
void (*set_errnullf(int errnum ))() 
{ 
  int *tmp ;

  {
  {
#line 750
  tmp = __errno_location();
#line 750
  *tmp = errnum;
  }
#line 751
  return ((void (*)())((void *)0));
}
}
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getppid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 689
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getgroups)(int __size ,
                                                                                __gid_t *__list ) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 809
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 78 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 70 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 179
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgroups)(size_t __n ,
                                                                                __gid_t const   *__groups ) ;
#line 200
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 262 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 311
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit *__rlimits ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit  const  *__rlimits ) ;
#line 60 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/daemon.h"
int daemon_started_by_init(void) ;
#line 61
int daemon_started_by_inetd(void) ;
#line 62
int daemon_prevent_core(void) ;
#line 63
int daemon_revoke_privileges(void) ;
#line 64
int daemon_become_user(uid_t uid , gid_t gid , char *user ) ;
#line 65
char *daemon_absolute_path(char const   *path ) ;
#line 66
int daemon_path_is_safe(char const   *path , char *explanation , size_t explanation_size ) ;
#line 68
int daemon_pidfile(char const   *name ) ;
#line 69
int daemon_init(char const   *name ) ;
#line 70
int daemon_close(void) ;
#line 71
pid_t daemon_getpid(char const   *name ) ;
#line 72
int daemon_is_running(char const   *name ) ;
#line 73
int daemon_stop(char const   *name ) ;
#line 104 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/daemon.c"
static struct __anonstruct_g_85 g___2  =    {{{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}},
    (char *)((void *)0)};
#line 130 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/daemon.c"
int daemon_started_by_init(void) 
{ 
  __pid_t tmp ;

  {
  {
#line 132
  tmp = getppid();
  }
#line 132
  return (tmp == 1);
}
}
#line 149 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/daemon.c"
int daemon_started_by_inetd(void) 
{ 
  size_t optlen ;
  int optval ;
  int tmp ;

  {
  {
#line 151
  optlen = sizeof(int );
#line 154
  tmp = getsockopt(0, 1, 3, (void */* __restrict  */)(& optval), (socklen_t */* __restrict  */)((void *)(& optlen)));
  }
#line 154
  return (tmp == 0);
}
}
#line 169 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/daemon.c"
int daemon_prevent_core(void) 
{ 
  struct rlimit limit[1] ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 171
  limit[0].rlim_cur = (rlim_t )0;
#line 171
  limit[0].rlim_max = (rlim_t )0;
#line 173
  tmp = getrlimit(4, limit);
  }
#line 173
  if (tmp == -1) {
#line 174
    return (-1);
  }
  {
#line 176
  limit[0].rlim_cur = (rlim_t )0;
#line 178
  tmp___0 = setrlimit(4, (struct rlimit  const  *)(limit));
  }
#line 178
  return (tmp___0);
}
}
#line 200 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/daemon.c"
int daemon_revoke_privileges(void) 
{ 
  uid_t uid ;
  __uid_t tmp ;
  gid_t gid ;
  __gid_t tmp___0 ;
  uid_t euid ;
  __uid_t tmp___1 ;
  gid_t egid ;
  __gid_t tmp___2 ;
  int tmp___3 ;
  __gid_t tmp___4 ;
  __gid_t tmp___5 ;
  int tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;

  {
  {
#line 202
  tmp = getuid();
#line 202
  uid = tmp;
#line 203
  tmp___0 = getgid();
#line 203
  gid = tmp___0;
#line 204
  tmp___1 = geteuid();
#line 204
  euid = tmp___1;
#line 205
  tmp___2 = getegid();
#line 205
  egid = tmp___2;
  }
#line 207
  if (egid != gid) {
    {
#line 207
    tmp___3 = setgid(gid);
    }
#line 207
    if (tmp___3 == -1) {
#line 208
      return (-1);
    } else {
      {
#line 207
      tmp___4 = getegid();
#line 207
      tmp___5 = getgid();
      }
#line 207
      if (tmp___4 != tmp___5) {
#line 208
        return (-1);
      }
    }
  }
#line 210
  if (euid != uid) {
    {
#line 210
    tmp___6 = setuid(uid);
    }
#line 210
    if (tmp___6 == -1) {
#line 211
      return (-1);
    } else {
      {
#line 210
      tmp___7 = geteuid();
#line 210
      tmp___8 = getuid();
      }
#line 210
      if (tmp___7 != tmp___8) {
#line 211
        return (-1);
      }
    }
  }
  {
#line 213
  endpwent();
#line 214
  endgrent();
  }
#line 216
  return (0);
}
}
#line 233 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/daemon.c"
int daemon_become_user(uid_t uid , gid_t gid , char *user ) 
{ 
  gid_t gids[10] ;
  int g___4 ;
  int tmp ;
  __gid_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  __gid_t tmp___3 ;
  __gid_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  __uid_t tmp___7 ;
  __uid_t tmp___8 ;
  void *__cil_tmp16 ;

  {
  {
#line 236
  g___4 = 0;
#line 238
  tmp___1 = setgroups((size_t )0, (__gid_t const   *)((void *)0));
  }
#line 238
  if (tmp___1 == -1) {
#line 238
    goto _L;
  } else {
    {
#line 238
    g___4 = getgroups(0, (__gid_t *)((void *)0));
    }
#line 238
    if (g___4 != 0) {
      _L: /* CIL Label */ 
#line 242
      if (g___4 != 1) {
#line 243
        return (-1);
      } else {
        {
#line 242
        tmp = getgroups(10, gids);
        }
#line 242
        if (tmp != 1) {
#line 243
          return (-1);
        } else {
          {
#line 242
          tmp___0 = getgid();
          }
#line 242
          if (gids[0] != tmp___0) {
#line 243
            return (-1);
          }
        }
      }
    }
  }
  {
#line 246
  tmp___2 = setgid(gid);
  }
#line 246
  if (tmp___2 == -1) {
#line 247
    return (-1);
  } else {
    {
#line 246
    tmp___3 = getgid();
    }
#line 246
    if (tmp___3 != gid) {
#line 247
      return (-1);
    } else {
      {
#line 246
      tmp___4 = getegid();
      }
#line 246
      if (tmp___4 != gid) {
#line 247
        return (-1);
      }
    }
  }
#line 249
  if (user) {
    {
#line 249
    tmp___5 = initgroups((char const   *)user, gid);
    }
#line 249
    if (tmp___5 == -1) {
#line 250
      return (-1);
    }
  }
  {
#line 252
  tmp___6 = setuid(uid);
  }
#line 252
  if (tmp___6 == -1) {
#line 253
    return (-1);
  } else {
    {
#line 252
    tmp___7 = getuid();
    }
#line 252
    if (tmp___7 != uid) {
#line 253
      return (-1);
    } else {
      {
#line 252
      tmp___8 = geteuid();
      }
#line 252
      if (tmp___8 != uid) {
#line 253
        return (-1);
      }
    }
  }
#line 255
  return (0);
}
}
#line 273 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/daemon.c"
char *daemon_absolute_path(char const   *path ) 
{ 
  size_t path_len ;
  char *abs_path ;
  char *p ;
  void *tmp ;
  long lim ;
  long tmp___0 ;
  char *cwd ;
  void *tmp___1 ;
  size_t cwd_len ;
  int rc ;
  char *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  int keep_sep ;
  int tmp___6 ;
  char *scan ;
  char *parent ;
  int keep_sep___0 ;
  int tmp___7 ;
  char *__cil_tmp22 ;

  {
#line 279
  if (! path) {
    {
#line 280
    tmp = set_errnull(22);
    }
#line 280
    return ((char *)tmp);
  }
#line 284
  if ((int const   )*path != 47) {
    {
#line 286
    tmp___0 = limit_path();
#line 286
    lim = tmp___0;
#line 287
    tmp___1 = malloc((unsigned long )lim * sizeof(char ));
#line 287
    cwd = (char *)tmp___1;
    }
#line 291
    if (! cwd) {
#line 292
      return ((char *)((void *)0));
    }
    {
#line 294
    tmp___2 = getcwd(cwd, (size_t )lim);
    }
#line 294
    if (! tmp___2) {
      {
#line 296
      free((void *)cwd);
      }
#line 297
      return ((char *)((void *)0));
    }
    {
#line 300
    cwd_len = strlen((char const   *)cwd);
#line 301
    tmp___4 = strlen(path);
    }
#line 301
    if ((cwd_len + 1UL) + tmp___4 >= (size_t )lim) {
      {
#line 303
      free((void *)cwd);
#line 304
      tmp___3 = set_errnull(36);
      }
#line 304
      return ((char *)tmp___3);
    }
    {
#line 307
    rc = snprintf((char */* __restrict  */)(cwd + cwd_len), (size_t )lim - cwd_len,
                  (char const   */* __restrict  */)"%c%s", '/', path);
    }
#line 308
    if (rc == -1) {
      {
#line 310
      free((void *)cwd);
#line 311
      tmp___5 = set_errnull(36);
      }
#line 311
      return ((char *)tmp___5);
    } else
#line 308
    if ((size_t )rc >= (size_t )lim - cwd_len) {
      {
#line 310
      free((void *)cwd);
#line 311
      tmp___5 = set_errnull(36);
      }
#line 311
      return ((char *)tmp___5);
    }
#line 314
    abs_path = cwd;
  } else {
    {
#line 318
    abs_path = mem_strdup(path);
    }
#line 318
    if (! abs_path) {
#line 319
      return ((char *)((void *)0));
    }
  }
  {
#line 324
  path_len = strlen((char const   *)abs_path);
#line 326
  p = abs_path;
  }
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 326
    if (! *p) {
#line 326
      goto while_break;
    }
#line 328
    if ((int )*(p + 0) == 47) {
#line 330
      if ((int )*(p + 1) == 47) {
        {
#line 332
        memmove((void *)p, (void const   *)(p + 1), (path_len + 1UL) - (size_t )((p + 1) - abs_path));
#line 333
        path_len --;
#line 334
        p --;
        }
      } else
#line 336
      if ((int )*(p + 1) == 46) {
#line 338
        if ((int )*(p + 2) == 47) {
#line 338
          goto _L___0;
        } else
#line 338
        if ((int )*(p + 2) == 0) {
          _L___0: /* CIL Label */ 
#line 340
          if ((unsigned long )p == (unsigned long )abs_path) {
#line 340
            if ((int )*(p + 2) == 0) {
#line 340
              tmp___6 = 1;
            } else {
#line 340
              tmp___6 = 0;
            }
          } else {
#line 340
            tmp___6 = 0;
          }
          {
#line 340
          keep_sep = tmp___6;
#line 341
          memmove((void *)(p + keep_sep), (void const   *)(p + 2), (path_len + 1UL) - (size_t )((p + 2) - abs_path));
#line 342
          path_len -= (size_t )(2 - keep_sep);
#line 343
          p --;
          }
        } else
#line 345
        if ((int )*(p + 2) == 46) {
#line 345
          if ((int )*(p + 3) == 47) {
#line 345
            goto _L;
          } else
#line 345
          if ((int )*(p + 3) == 0) {
            _L: /* CIL Label */ 
#line 350
            parent = p;
#line 350
            scan = parent;
            {
#line 350
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 350
              if (! ((unsigned long )scan > (unsigned long )abs_path)) {
#line 350
                goto while_break___0;
              }
#line 352
              scan --;
#line 352
              if ((int )*scan == 47) {
#line 354
                parent = scan;
#line 355
                goto while_break___0;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
#line 359
            if ((unsigned long )parent == (unsigned long )abs_path) {
#line 359
              if ((int )*(p + 3) == 0) {
#line 359
                tmp___7 = 1;
              } else {
#line 359
                tmp___7 = 0;
              }
            } else {
#line 359
              tmp___7 = 0;
            }
            {
#line 359
            keep_sep___0 = tmp___7;
#line 360
            memmove((void *)(parent + keep_sep___0), (void const   *)(p + 3), (path_len + 1UL) - (size_t )((p + 3) - abs_path));
#line 361
            path_len -= (size_t )((p + 3) - parent);
#line 362
            p = parent - 1;
            }
          }
        }
      }
    }
#line 326
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 370
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 370
    if (path_len > 1UL) {
#line 370
      if (! ((int )*(abs_path + (path_len - 1UL)) == 47)) {
#line 370
        goto while_break___1;
      }
    } else {
#line 370
      goto while_break___1;
    }
#line 371
    path_len --;
#line 371
    *(abs_path + path_len) = (char )'\000';
  }
  while_break___1: /* CIL Label */ ;
  }
#line 373
  return (abs_path);
}
}
#line 395 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/daemon.c"
static int daemon_check_path(char *path , char *explanation , size_t explanation_size ,
                             int level ) 
{ 
  struct stat status[1] ;
  char *sep ;
  int rc ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t lim ;
  char *sym_linked ;
  char *tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;
  ssize_t tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  void *__cil_tmp23 ;
  int __cil_tmp24 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 401
  if (level > 16) {
    {
#line 402
    tmp = set_errno(40);
    }
#line 402
    return (tmp);
  }
  {
#line 404
  tmp___0 = strlen((char const   *)path);
#line 404
  sep = path + tmp___0;
  }
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 404
    if (! sep) {
#line 404
      goto while_break;
    }
    {
#line 406
    *(sep + ((unsigned long )sep == (unsigned long )path)) = (char )'\000';
#line 408
    tmp___1 = lstat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(status));
    }
#line 408
    if (tmp___1 == -1) {
#line 409
      return (-1);
    }
#line 411
    if ((status[0].st_mode & 61440U) == 40960U) {
      {
#line 417
      tmp___3 = limit_path();
#line 417
      lim = (size_t )tmp___3;
#line 418
      tmp___4 = malloc(lim * sizeof(char ));
#line 418
      sym_linked = (char *)tmp___4;
      }
#line 418
      if (! sym_linked) {
#line 419
        return (-1);
      }
      {
#line 421
      memset((void *)sym_linked, 0, lim);
#line 423
      tmp___5 = readlink((char const   */* __restrict  */)path, (char */* __restrict  */)sym_linked,
                         lim);
      }
#line 423
      if (tmp___5 == -1L) {
        {
#line 425
        free((void *)sym_linked);
        }
#line 426
        return (-1);
      }
#line 429
      if ((int )*sym_linked != 47) {
        {
#line 431
        tmp___6 = malloc(lim * sizeof(char ));
#line 431
        tmp___2 = (char *)tmp___6;
        }
#line 431
        if (! tmp___2) {
          {
#line 433
          free((void *)sym_linked);
          }
#line 434
          return (-1);
        }
        {
#line 437
        rc = snprintf((char */* __restrict  */)tmp___2, lim, (char const   */* __restrict  */)"%s%c..%c%s",
                      path, '/', '/', sym_linked);
        }
#line 438
        if (rc == -1) {
          {
#line 440
          free((void *)sym_linked);
#line 441
          free((void *)tmp___2);
#line 442
          tmp___7 = set_errno(36);
          }
#line 442
          return (tmp___7);
        } else
#line 438
        if ((size_t )rc >= lim) {
          {
#line 440
          free((void *)sym_linked);
#line 441
          free((void *)tmp___2);
#line 442
          tmp___7 = set_errno(36);
          }
#line 442
          return (tmp___7);
        }
        {
#line 445
        rc = snprintf((char */* __restrict  */)sym_linked, lim, (char const   */* __restrict  */)"%s",
                      tmp___2);
#line 446
        free((void *)tmp___2);
        }
#line 447
        if (rc == -1) {
          {
#line 449
          free((void *)sym_linked);
#line 450
          tmp___8 = set_errno(36);
          }
#line 450
          return (tmp___8);
        } else
#line 447
        if ((size_t )rc >= lim) {
          {
#line 449
          free((void *)sym_linked);
#line 450
          tmp___8 = set_errno(36);
          }
#line 450
          return (tmp___8);
        }
      }
      {
#line 454
      tmp___2 = daemon_absolute_path((char const   *)sym_linked);
#line 455
      free((void *)sym_linked);
#line 456
      sym_linked = tmp___2;
      }
#line 456
      if (! sym_linked) {
#line 457
        return (-1);
      }
      {
#line 459
      rc = daemon_check_path(sym_linked, explanation, explanation_size, level + 1);
#line 460
      free((void *)sym_linked);
      }
      {
#line 464
      if (rc == -1) {
#line 464
        goto case_neg_1;
      }
#line 465
      if (rc == 0) {
#line 465
        goto case_0;
      }
#line 466
      if (rc == 1) {
#line 466
        goto case_1;
      }
#line 462
      goto switch_break;
      case_neg_1: /* CIL Label */ 
#line 464
      return (-1);
      case_0: /* CIL Label */ 
#line 465
      return (0);
      case_1: /* CIL Label */ 
#line 466
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else
#line 469
    if (status[0].st_mode & (unsigned int )((128 >> 3) | ((128 >> 3) >> 3))) {
#line 471
      if (explanation) {
#line 473
        if (status[0].st_mode & (unsigned int )((128 >> 3) >> 3)) {
#line 473
          tmp___9 = "world";
        } else {
#line 473
          tmp___9 = "";
        }
#line 473
        if ((status[0].st_mode & (unsigned int )((128 >> 3) | ((128 >> 3) >> 3))) == (unsigned int )((128 >> 3) | ((128 >> 3) >> 3))) {
#line 473
          tmp___10 = " and ";
        } else {
#line 473
          tmp___10 = "";
        }
#line 473
        if (status[0].st_mode & (unsigned int )(128 >> 3)) {
#line 473
          tmp___11 = "group";
        } else {
#line 473
          tmp___11 = "";
        }
        {
#line 473
        snprintf((char */* __restrict  */)explanation, explanation_size, (char const   */* __restrict  */)"%s is %s%s%s writable",
                 path, tmp___11, tmp___10, tmp___9);
        }
      }
#line 480
      return (0);
    }
#line 483
    if ((unsigned long )sep == (unsigned long )path) {
#line 484
      goto while_break;
    }
    {
#line 404
    sep = strrchr((char const   *)path, '/');
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 487
  return (1);
}
}
#line 490 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/daemon.c"
int daemon_path_is_safe(char const   *path , char *explanation , size_t explanation_size ) 
{ 
  char *abs_path ;
  int rc ;
  int tmp ;

  {
#line 495
  if (! path) {
    {
#line 496
    tmp = set_errno(22);
    }
#line 496
    return (tmp);
  }
  {
#line 498
  abs_path = daemon_absolute_path(path);
  }
#line 499
  if (! abs_path) {
#line 500
    return (-1);
  }
  {
#line 502
  rc = daemon_check_path(abs_path, explanation, explanation_size, 0);
#line 503
  free((void *)abs_path);
  }
#line 505
  return (rc);
}
}
#line 525 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/daemon.c"
void *daemon_parse_config(char const   *path , void *obj , daemon_config_parser_t *parser ) 
{ 
  FILE *conf ;
  char line[8192] ;
  char buf[8192] ;
  int lineno ;
  int rc ;
  char *start ;
  char *end ;
  size_t length ;
  int cont_line ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 533
  conf = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r");
  }
#line 533
  if (! conf) {
#line 534
    return ((void *)0);
  }
#line 536
  line[0] = (char )'\000';
#line 538
  lineno = 1;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 538
    tmp___1 = fgets((char */* __restrict  */)(buf), 8192, (FILE */* __restrict  */)conf);
    }
#line 538
    if (! tmp___1) {
#line 538
      goto while_break;
    }
    {
#line 540
    start = buf;
#line 547
    end = strchr((char const   *)start, '#');
    }
#line 547
    if (end) {
#line 548
      *end = (char )'\000';
    } else {
      {
#line 550
      tmp = strlen((char const   *)start);
#line 550
      end = start + tmp;
      }
    }
    {
#line 554
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 554
      if ((unsigned long )end > (unsigned long )start) {
        {
#line 554
        tmp___0 = __ctype_b_loc();
        }
#line 554
        if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*(end + -1))) & 8192)) {
#line 554
          goto while_break___0;
        }
      } else {
#line 554
        goto while_break___0;
      }
#line 555
      end --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 559
    if ((int )*start == 0) {
#line 560
      goto __Cont;
    } else
#line 559
    if ((unsigned long )start == (unsigned long )end) {
#line 560
      goto __Cont;
    }
#line 564
    cont_line = (int )*(end + -1) == 92;
#line 564
    if (cont_line) {
#line 565
      end --;
    }
    {
#line 567
    length = strlen((char const   *)(line));
#line 568
    rc = snprintf((char */* __restrict  */)(line + length), 8192UL - length, (char const   */* __restrict  */)"%*.*s",
                  (int )(end - start), (int )(end - start), start);
    }
#line 569
    if (rc == -1) {
#line 570
      return ((void *)0);
    } else
#line 569
    if ((size_t )rc >= 8192UL - length) {
#line 570
      return ((void *)0);
    }
#line 572
    if (cont_line) {
#line 573
      goto __Cont;
    }
    {
#line 577
    (*parser)(obj, path, line, (size_t )lineno);
#line 578
    line[0] = (char )'\000';
    }
    __Cont: /* CIL Label */ 
#line 538
    lineno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 581
  fclose(conf);
  }
#line 583
  return (obj);
}
}
#line 598 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/daemon.c"
static int daemon_construct_pidfile(char const   *name , char **pidfile ) 
{ 
  long path_len ;
  char const   *pid_dir ;
  char *suffix ;
  size_t size ;
  __uid_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 602
  suffix = (char *)".pid";
#line 605
  path_len = limit_path();
#line 606
  tmp___0 = getuid();
  }
#line 606
  if (tmp___0) {
#line 606
    pid_dir = "/tmp";
  } else {
#line 606
    pid_dir = "/var/run";
  }
#line 607
  if ((int const   )*name == 47) {
    {
#line 607
    tmp___1 = strlen(name);
#line 607
    tmp___4 = tmp___1;
    }
  } else {
    {
#line 607
    tmp___2 = strlen(name);
#line 607
    tmp___3 = strlen((char const   *)suffix);
#line 607
    tmp___4 = ((sizeof(pid_dir) + 1UL) + tmp___2) + tmp___3;
    }
  }
#line 607
  size = tmp___4 + 1UL;
#line 609
  if (size > (size_t )path_len) {
    {
#line 610
    tmp___5 = set_errno(36);
    }
#line 610
    return (tmp___5);
  }
#line 612
  if (! *pidfile) {
    {
#line 612
    tmp___7 = malloc((unsigned long )path_len * sizeof(char ));
#line 612
    tmp___6 = (char *)tmp___7;
#line 612
    *pidfile = tmp___6;
    }
#line 612
    if (! tmp___6) {
#line 613
      return (-1);
    }
  }
#line 615
  if ((int const   )*name == 47) {
    {
#line 616
    snprintf((char */* __restrict  */)*pidfile, (size_t )path_len, (char const   */* __restrict  */)"%s",
             name);
    }
  } else {
    {
#line 618
    snprintf((char */* __restrict  */)*pidfile, (size_t )path_len, (char const   */* __restrict  */)"%s%c%s%s",
             pid_dir, '/', name, suffix);
    }
  }
#line 620
  return (0);
}
}
#line 633 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/daemon.c"
static int daemon_lock_pidfile(char *pidfile ) 
{ 
  mode_t mode ;
  struct stat statbuf_fd[1] ;
  struct stat statbuf_fs[1] ;
  int pid_fd ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp12 ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  void *__cil_tmp17 ;

  {
#line 635
  mode = (mode_t )((384 | (256 >> 3)) | ((256 >> 3) >> 3));
  start: 
  {
#line 642
  pid_fd = open((char const   *)pidfile, 194, mode);
  }
#line 642
  if (pid_fd == -1) {
    {
#line 644
    tmp = __errno_location();
    }
#line 644
    if (*tmp != 17) {
#line 645
      return (-1);
    }
    {
#line 654
    pid_fd = open((char const   *)pidfile, 2);
    }
#line 654
    if (pid_fd == -1) {
      {
#line 663
      tmp___0 = __errno_location();
      }
#line 663
      if (*tmp___0 == 2) {
#line 664
        goto start;
      }
#line 666
      return (-1);
    }
  }
  {
#line 670
  tmp___1 = fcntl_lock(pid_fd, 6, 1, 0, 0, 0);
  }
#line 670
  if (tmp___1 == -1) {
    {
#line 672
    close(pid_fd);
    }
#line 673
    return (-1);
  }
  {
#line 688
  tmp___2 = fstat(pid_fd, statbuf_fd);
  }
#line 688
  if (tmp___2 == -1) {
    {
#line 691
    close(pid_fd);
    }
#line 692
    return (-1);
  }
  {
#line 695
  tmp___4 = stat((char const   */* __restrict  */)pidfile, (struct stat */* __restrict  */)(statbuf_fs));
  }
#line 695
  if (tmp___4 == -1) {
    {
#line 699
    tmp___3 = __errno_location();
    }
#line 699
    if (*tmp___3 == 2) {
      {
#line 701
      close(pid_fd);
      }
#line 702
      goto start;
    }
    {
#line 705
    close(pid_fd);
    }
#line 706
    return (-1);
  } else
#line 708
  if (statbuf_fd[0].st_ino != statbuf_fs[0].st_ino) {
    {
#line 712
    close(pid_fd);
    }
#line 713
    goto start;
  }
#line 716
  return (pid_fd);
}
}
#line 728 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/daemon.c"
static int daemon_pidfile_unlocked(char const   *name ) 
{ 
  char pid[32] ;
  int pid_fd ;
  int tmp ;
  int tmp___0 ;
  __pid_t tmp___1 ;
  size_t tmp___2 ;
  ssize_t tmp___3 ;
  size_t tmp___4 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 735
  if (! name) {
    {
#line 736
    tmp = set_errno(22);
    }
#line 736
    return (tmp);
  }
  {
#line 740
  tmp___0 = daemon_construct_pidfile(name, & g___2.pidfile);
  }
#line 740
  if (tmp___0 == -1) {
#line 741
    return (-1);
  }
  {
#line 745
  pid_fd = daemon_lock_pidfile(g___2.pidfile);
  }
#line 745
  if (pid_fd == -1) {
    {
#line 747
    mem_destroy((void **)(& g___2.pidfile));
    }
#line 748
    return (-1);
  }
  {
#line 753
  tmp___1 = getpid();
#line 753
  snprintf((char */* __restrict  */)(pid), (size_t )32, (char const   */* __restrict  */)"%d\n",
           tmp___1);
#line 755
  tmp___2 = strlen((char const   *)(pid));
#line 755
  tmp___3 = write(pid_fd, (void const   *)(pid), tmp___2);
#line 755
  tmp___4 = strlen((char const   *)(pid));
  }
#line 755
  if ((size_t )tmp___3 != tmp___4) {
    {
#line 757
    daemon_close();
    }
#line 758
    return (-1);
  }
#line 767
  return (0);
}
}
#line 790 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/daemon.c"
int daemon_pidfile(char const   *name ) 
{ 
  int rc ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int err___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 794
  tmp = pthread_mutex_lock(& g___2.lock);
#line 794
  err = tmp;
  }
#line 794
  if (err) {
    {
#line 794
    tmp___0 = set_errno(err);
    }
#line 794
    return (tmp___0);
  }
  {
#line 795
  rc = daemon_pidfile_unlocked(name);
#line 796
  tmp___1 = pthread_mutex_unlock(& g___2.lock);
#line 796
  err___0 = tmp___1;
  }
#line 796
  if (err___0) {
    {
#line 796
    tmp___2 = set_errno(err___0);
    }
#line 796
    return (tmp___2);
  }
#line 798
  return (rc);
}
}
#line 876 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/daemon.c"
int daemon_init(char const   *name ) 
{ 
  pid_t pid ;
  long nopen ;
  int fd ;
  struct sigaction act___0[1] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 887
  tmp___0 = daemon_started_by_init();
  }
#line 887
  if (! tmp___0) {
    {
#line 887
    tmp___1 = daemon_started_by_inetd();
    }
#line 887
    if (! tmp___1) {
      {
#line 894
      pid = fork();
      }
#line 894
      if (pid == -1) {
#line 895
        return (-1);
      }
#line 897
      if (pid) {
        {
#line 898
        exit(0);
        }
      }
      {
#line 903
      setsid();
#line 918
      act___0[0].__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 919
      sigemptyset(& act___0[0].sa_mask);
#line 920
      act___0[0].sa_flags = 0;
#line 922
      tmp = sigaction(1, (struct sigaction  const  */* __restrict  */)(act___0), (struct sigaction */* __restrict  */)((void *)0));
      }
#line 922
      if (tmp == -1) {
#line 923
        return (-1);
      }
      {
#line 932
      pid = fork();
      }
#line 932
      if (pid == -1) {
#line 933
        return (-1);
      }
#line 935
      if (pid) {
        {
#line 936
        exit(0);
        }
      }
    }
  }
  {
#line 943
  tmp___2 = chdir("/");
  }
#line 943
  if (tmp___2 == -1) {
#line 944
    return (-1);
  }
  {
#line 948
  umask((__mode_t )0);
#line 960
  nopen = limit_open();
  }
#line 960
  if (nopen == -1L) {
#line 961
    return (-1);
  }
  {
#line 971
  tmp___6 = daemon_started_by_inetd();
  }
#line 971
  if (tmp___6) {
#line 973
    fd = 0;
    {
#line 973
    while (1) {
      while_continue: /* CIL Label */ ;
#line 973
      if (! ((long )fd < nopen)) {
#line 973
        goto while_break;
      }
      {
#line 979
      if (fd == 2) {
#line 979
        goto case_2;
      }
#line 979
      if (fd == 1) {
#line 979
        goto case_2;
      }
#line 979
      if (fd == 0) {
#line 979
        goto case_2;
      }
#line 981
      goto switch_default;
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 980
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 982
      close(fd);
      }
      switch_break: /* CIL Label */ ;
      }
#line 973
      fd ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 988
    fd = 0;
    {
#line 988
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 988
      if (! ((long )fd < nopen)) {
#line 988
        goto while_break___0;
      }
      {
#line 989
      close(fd);
#line 988
      fd ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 996
    fd = open("/dev/null", 2);
    }
#line 996
    if (fd == -1) {
#line 997
      return (-1);
    }
#line 1005
    if (fd != 0) {
      {
#line 1007
      tmp___3 = dup2(fd, 0);
      }
#line 1007
      if (tmp___3 == -1) {
#line 1008
        return (-1);
      }
      {
#line 1010
      close(fd);
      }
    }
    {
#line 1013
    tmp___4 = dup2(0, 1);
    }
#line 1013
    if (tmp___4 == -1) {
#line 1014
      return (-1);
    }
    {
#line 1016
    tmp___5 = dup2(0, 2);
    }
#line 1016
    if (tmp___5 == -1) {
#line 1017
      return (-1);
    }
  }
#line 1022
  if (name) {
    {
#line 1023
    tmp___7 = daemon_pidfile(name);
    }
#line 1023
    return (tmp___7);
  }
#line 1025
  return (0);
}
}
#line 1038 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/daemon.c"
int daemon_close(void) 
{ 
  int err ;
  int tmp ;
  int tmp___0 ;
  int err___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1040
  tmp = pthread_mutex_lock(& g___2.lock);
#line 1040
  err = tmp;
  }
#line 1040
  if (err) {
    {
#line 1040
    tmp___0 = set_errno(err);
    }
#line 1040
    return (tmp___0);
  }
#line 1042
  if (g___2.pidfile) {
    {
#line 1044
    unlink((char const   *)g___2.pidfile);
#line 1045
    mem_destroy((void **)(& g___2.pidfile));
    }
  }
  {
#line 1048
  tmp___1 = pthread_mutex_unlock(& g___2.lock);
#line 1048
  err___0 = tmp___1;
  }
#line 1048
  if (err___0) {
    {
#line 1048
    tmp___2 = set_errno(err___0);
    }
#line 1048
    return (tmp___2);
  }
#line 1050
  return (0);
}
}
#line 1069 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/daemon.c"
pid_t daemon_getpid(char const   *name ) 
{ 
  char *pidfile ;
  char buf[8192] ;
  ssize_t bytes ;
  int pid_fd ;
  int pid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1071
  pidfile = (char *)((void *)0);
#line 1075
  pid = 0;
#line 1079
  if (! name) {
    {
#line 1080
    tmp = set_errno(22);
    }
#line 1080
    return (tmp);
  }
  {
#line 1084
  tmp___0 = daemon_construct_pidfile(name, & pidfile);
  }
#line 1084
  if (tmp___0 == -1) {
#line 1085
    return (-1);
  }
  {
#line 1089
  pid_fd = open((char const   *)pidfile, 0);
#line 1090
  free((void *)pidfile);
  }
#line 1092
  if (pid_fd == -1) {
#line 1093
    return (-1);
  }
  {
#line 1097
  bytes = read(pid_fd, (void *)(buf), (size_t )8192);
#line 1098
  close(pid_fd);
  }
#line 1100
  if (bytes == -1L) {
#line 1101
    return (-1);
  }
  {
#line 1103
  tmp___1 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%d",
                   & pid);
  }
#line 1103
  if (tmp___1 != 1) {
#line 1104
    return (-1);
  }
#line 1106
  return (pid);
}
}
#line 1126 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/daemon.c"
int daemon_is_running(char const   *name ) 
{ 
  char *pidfile ;
  int pid_fd ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 1128
  pidfile = (char *)((void *)0);
#line 1133
  if (! name) {
    {
#line 1134
    tmp = set_errno(22);
    }
#line 1134
    return (tmp);
  }
  {
#line 1138
  tmp___0 = daemon_construct_pidfile(name, & pidfile);
  }
#line 1138
  if (tmp___0 == -1) {
#line 1139
    return (-1);
  }
  {
#line 1143
  pid_fd = open((char const   *)pidfile, 0);
  }
#line 1143
  if (pid_fd == -1) {
    {
#line 1145
    free((void *)pidfile);
#line 1147
    tmp___1 = __errno_location();
    }
#line 1147
    if (*tmp___1 != 2) {
#line 1148
      return (-1);
    }
#line 1152
    return (0);
  }
  {
#line 1157
  tmp___4 = fcntl_lock(pid_fd, 6, 0, 0, 0, 0);
  }
#line 1157
  if (tmp___4 == -1) {
    {
#line 1159
    free((void *)pidfile);
#line 1160
    close(pid_fd);
#line 1162
    tmp___2 = __errno_location();
    }
#line 1162
    if (*tmp___2 != 13) {
      {
#line 1162
      tmp___3 = __errno_location();
      }
#line 1162
      if (*tmp___3 != 11) {
#line 1163
        return (-1);
      }
    }
#line 1165
    return (1);
  }
  {
#line 1168
  free((void *)pidfile);
#line 1169
  close(pid_fd);
  }
#line 1173
  return (0);
}
}
#line 1195 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/daemon.c"
int daemon_stop(char const   *name ) 
{ 
  char *pidfile ;
  char pidbuf[32] ;
  ssize_t bytes ;
  int pid_fd ;
  int pid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 1197
  pidfile = (char *)((void *)0);
#line 1201
  pid = -1;
#line 1205
  if (! name) {
    {
#line 1206
    tmp = set_errno(22);
    }
#line 1206
    return (tmp);
  }
  {
#line 1210
  tmp___0 = daemon_construct_pidfile(name, & pidfile);
  }
#line 1210
  if (tmp___0 == -1) {
#line 1211
    return (-1);
  }
  {
#line 1215
  pid_fd = daemon_lock_pidfile(pidfile);
  }
#line 1215
  if (pid_fd == -1) {
    {
#line 1219
    tmp___4 = __errno_location();
    }
#line 1219
    if (*tmp___4 == 13) {
#line 1219
      goto _L;
    } else {
      {
#line 1219
      tmp___5 = __errno_location();
      }
#line 1219
      if (*tmp___5 == 11) {
        _L: /* CIL Label */ 
        {
#line 1223
        pid_fd = open((char const   *)pidfile, 0);
        }
#line 1223
        if (pid_fd == -1) {
          {
#line 1225
          free((void *)pidfile);
          }
#line 1226
          return (-1);
        }
        {
#line 1229
        free((void *)pidfile);
#line 1231
        bytes = read(pid_fd, (void *)(pidbuf), (size_t )32);
        }
#line 1231
        if (bytes <= 0L) {
          {
#line 1233
          close(pid_fd);
          }
#line 1234
          return (-1);
        }
        {
#line 1237
        close(pid_fd);
#line 1239
        tmp___2 = sscanf((char const   */* __restrict  */)(pidbuf), (char const   */* __restrict  */)"%d",
                         & pid);
        }
#line 1239
        if (tmp___2 != 1) {
          {
#line 1240
          tmp___1 = set_errno(22);
          }
#line 1240
          return (tmp___1);
        } else
#line 1239
        if (pid <= 0) {
          {
#line 1240
          tmp___1 = set_errno(22);
          }
#line 1240
          return (tmp___1);
        }
        {
#line 1244
        tmp___3 = kill(pid, 15);
        }
#line 1244
        return (tmp___3);
      }
    }
    {
#line 1247
    free((void *)pidfile);
    }
#line 1249
    return (-1);
  }
  {
#line 1254
  close(pid_fd);
#line 1255
  unlink((char const   *)pidfile);
#line 1256
  free((void *)pidfile);
#line 1258
  tmp___6 = set_errno(3);
  }
#line 1258
  return (tmp___6);
}
}
#line 284 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 417 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 551
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *__path ,
                                                                                               char * const  *__argv ,
                                                                                               char * const  *__envp ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 35 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/coproc.h"
pid_t coproc_open(int *to , int *from , int *err , char const   *cmd , char * const  *argv ,
                  char * const  *envv , void (*action)(void *data ) , void *data ) ;
#line 36
int coproc_close(pid_t pid , int *to , int *from , int *err ) ;
#line 37
pid_t coproc_pty_open(int *masterfd , char *slavename , size_t slavenamesize , struct termios  const  *slave_termios ,
                      struct winsize  const  *slave_winsize , char const   *cmd ,
                      char * const  *argv , char * const  *envv , void (*action)(void *data ) ,
                      void *data ) ;
#line 38
int coproc_pty_close(pid_t pid , int *masterfd , char const   *slavename ) ;
#line 71 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/coproc.c"
extern char **environ ;
#line 137 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/coproc.c"
static char * const  *new_shargv(char const   *cmd , char * const  *argv ) 
{ 
  char **shargv ;
  int nargs ;
  void *tmp ;
  char *__cil_tmp6 ;

  {
#line 140
  nargs = 0;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! *(argv + nargs)) {
#line 142
      goto while_break;
    }
#line 143
    nargs ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 145
  tmp = malloc((unsigned long )(nargs + 2) * sizeof(char **));
#line 145
  shargv = (char **)tmp;
  }
#line 145
  if (! shargv) {
#line 146
    return ((char * const  *)((void *)0));
  }
#line 148
  *(shargv + 0) = (char *)"/bin/sh";
#line 149
  *(shargv + 1) = (char *)cmd;
#line 151
  nargs = 1;
  {
#line 151
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 151
    if (! *(argv + nargs)) {
#line 151
      goto while_break___0;
    }
#line 152
    *(shargv + (nargs + 1)) = (char *)*(argv + nargs);
#line 151
    nargs ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 154
  *(shargv + (nargs + 1)) = (char *)((void *)0);
#line 156
  return ((char * const  *)shargv);
}
}
#line 159 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/coproc.c"
static void do_exec(int has_meta , char const   *cmd , char * const  *argv , char * const  *envv ) 
{ 
  char const   *shargv[4] ;
  char * const  *tmp ;
  char * const  *tmp___0 ;
  char * const  *shargv___0 ;
  char * const  *tmp___1 ;
  char * const  *tmp___2 ;
  int *tmp___3 ;
  char *path ;
  char *s ;
  char *f ;
  char cmdbuf[512] ;
  __uid_t tmp___5 ;
  size_t tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char * const  *shargv___1 ;
  char * const  *tmp___10 ;
  char * const  *tmp___11 ;
  int *tmp___12 ;
  char * const  *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
#line 161
  if (has_meta) {
#line 165
    shargv[0] = "sh";
#line 166
    shargv[1] = "-c";
#line 167
    shargv[2] = cmd;
#line 168
    shargv[3] = (char const   *)((void *)0);
#line 170
    if (envv) {
#line 170
      tmp = envv;
    } else {
#line 170
      tmp = (char * const  *)environ;
    }
    {
#line 170
    execve("/bin/sh", (char * const  *)(shargv), tmp);
    }
  } else {
    {
#line 172
    tmp___15 = strchr(cmd, '/');
    }
#line 172
    if (tmp___15) {
#line 174
      if (envv) {
#line 174
        tmp___0 = envv;
      } else {
#line 174
        tmp___0 = (char * const  *)environ;
      }
      {
#line 174
      execve(cmd, argv, tmp___0);
#line 176
      tmp___3 = __errno_location();
      }
#line 176
      if (*tmp___3 == 8) {
        {
#line 178
        tmp___1 = new_shargv(cmd, argv);
#line 178
        shargv___0 = tmp___1;
        }
#line 179
        if (envv) {
#line 179
          tmp___2 = envv;
        } else {
#line 179
          tmp___2 = (char * const  *)environ;
        }
        {
#line 179
        execve("/bin/sh", shargv___0, tmp___2);
#line 180
        free((void *)shargv___0);
        }
      }
    } else {
      {
#line 188
      path = getenv("PATH");
      }
#line 188
      if (! path) {
        {
#line 189
        tmp___5 = geteuid();
        }
#line 189
        if (tmp___5) {
#line 189
          path = (char *)":/bin:/usr/bin";
        } else {
#line 189
          path = (char *)"/bin:/usr/bin";
        }
      }
#line 191
      s = path;
      {
#line 191
      while (1) {
        while_continue: /* CIL Label */ ;
#line 191
        if (! s) {
#line 191
          goto while_break;
        }
        {
#line 193
        f = strchr((char const   *)s, ':');
        }
#line 193
        if (! f) {
          {
#line 194
          tmp___6 = strlen((char const   *)s);
#line 194
          f = s + tmp___6;
          }
        }
#line 196
        if (f - s) {
#line 196
          tmp___7 = "/";
        } else {
#line 196
          tmp___7 = "";
        }
        {
#line 196
        tmp___8 = snprintf((char */* __restrict  */)(cmdbuf), (size_t )512, (char const   */* __restrict  */)"%.*s%s%s",
                           (int )(f - s), s, tmp___7, cmd);
        }
#line 196
        if (tmp___8 >= 512) {
#line 197
          goto __Cont;
        }
#line 199
        if (envv) {
#line 199
          tmp___13 = envv;
        } else {
#line 199
          tmp___13 = (char * const  *)environ;
        }
        {
#line 199
        tmp___14 = execve((char const   *)(cmdbuf), argv, tmp___13);
        }
#line 199
        if (tmp___14 == -1) {
          {
#line 201
          tmp___9 = __errno_location();
          }
#line 201
          if (*tmp___9 == 13) {
#line 202
            goto __Cont;
          }
          {
#line 204
          tmp___12 = __errno_location();
          }
#line 204
          if (*tmp___12 == 8) {
            {
#line 206
            tmp___10 = new_shargv((char const   *)(cmdbuf), argv);
#line 206
            shargv___1 = tmp___10;
            }
#line 207
            if (envv) {
#line 207
              tmp___11 = envv;
            } else {
#line 207
              tmp___11 = (char * const  *)environ;
            }
            {
#line 207
            execve("/bin/sh", shargv___1, tmp___11);
#line 208
            free((void *)shargv___1);
            }
#line 209
            goto while_break;
          }
        }
        __Cont: /* CIL Label */ 
#line 191
        if (*f) {
#line 191
          s = f + 1;
        } else {
#line 191
          s = (char *)((void *)0);
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 214
  return;
}
}
#line 216 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/coproc.c"
pid_t coproc_open(int *to , int *from , int *err , char const   *cmd , char * const  *argv ,
                  char * const  *envv , void (*action)(void *data ) , void *data ) 
{ 
  int to_pipe[2] ;
  int from_pipe[2] ;
  int err_pipe[2] ;
  pid_t pid ;
  int has_meta ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 226
  if (! to) {
    {
#line 227
    tmp = set_errno(22);
    }
#line 227
    return (tmp);
  } else
#line 226
  if (! from) {
    {
#line 227
    tmp = set_errno(22);
    }
#line 227
    return (tmp);
  } else
#line 226
  if (! err) {
    {
#line 227
    tmp = set_errno(22);
    }
#line 227
    return (tmp);
  } else
#line 226
  if (! cmd) {
    {
#line 227
    tmp = set_errno(22);
    }
#line 227
    return (tmp);
  }
  {
#line 229
  tmp___0 = strcspn(cmd, "|&;()<>[]{}$`\'~\"\\*? \t\r\n");
#line 229
  has_meta = (int const   )*(cmd + tmp___0) != 0;
  }
#line 231
  if (has_meta) {
#line 231
    if (argv) {
      {
#line 232
      tmp___1 = set_errno(22);
      }
#line 232
      return (tmp___1);
    } else {
#line 231
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 231
  if (! has_meta) {
#line 231
    if (! argv) {
      {
#line 232
      tmp___1 = set_errno(22);
      }
#line 232
      return (tmp___1);
    }
  }
  {
#line 236
  tmp___2 = pipe((int *)(to_pipe));
  }
#line 236
  if (tmp___2 == -1) {
#line 237
    return (-1);
  }
  {
#line 239
  tmp___3 = pipe((int *)(from_pipe));
  }
#line 239
  if (tmp___3 == -1) {
    {
#line 241
    close(to_pipe[0]);
#line 242
    close(to_pipe[1]);
    }
#line 243
    return (-1);
  }
  {
#line 246
  tmp___4 = pipe((int *)(err_pipe));
  }
#line 246
  if (tmp___4 == -1) {
    {
#line 248
    close(to_pipe[0]);
#line 249
    close(to_pipe[1]);
#line 250
    close(from_pipe[0]);
#line 251
    close(from_pipe[1]);
    }
#line 252
    return (-1);
  }
  {
#line 257
  pid = fork();
  }
  {
#line 259
  if (pid == -1) {
#line 259
    goto case_neg_1;
  }
#line 270
  if (pid == 0) {
#line 270
    goto case_0;
  }
#line 313
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 261
  close(to_pipe[0]);
#line 262
  close(to_pipe[1]);
#line 263
  close(from_pipe[0]);
#line 264
  close(from_pipe[1]);
#line 265
  close(err_pipe[0]);
#line 266
  close(err_pipe[1]);
  }
#line 267
  return (-1);
  case_0: /* CIL Label */ 
#line 274
  if (action) {
    {
#line 275
    (*action)(data);
    }
  }
  {
#line 279
  close(to_pipe[1]);
#line 280
  close(from_pipe[0]);
#line 281
  close(err_pipe[0]);
  }
#line 283
  if (to_pipe[0] != 0) {
    {
#line 285
    tmp___5 = dup2(to_pipe[0], 0);
    }
#line 285
    if (tmp___5 == -1) {
      {
#line 286
      _exit(1);
      }
    }
    {
#line 288
    close(to_pipe[0]);
    }
  }
#line 291
  if (from_pipe[1] != 1) {
    {
#line 293
    tmp___6 = dup2(from_pipe[1], 1);
    }
#line 293
    if (tmp___6 == -1) {
      {
#line 294
      _exit(1);
      }
    }
    {
#line 296
    close(from_pipe[1]);
    }
  }
#line 299
  if (err_pipe[1] != 2) {
    {
#line 301
    tmp___7 = dup2(err_pipe[1], 2);
    }
#line 301
    if (tmp___7 == -1) {
      {
#line 302
      _exit(1);
      }
    }
    {
#line 304
    close(err_pipe[1]);
    }
  }
  {
#line 309
  do_exec(has_meta, cmd, argv, envv);
#line 310
  _exit(1);
  }
  switch_default: /* CIL Label */ 
  {
#line 317
  close(to_pipe[0]);
#line 318
  close(from_pipe[1]);
#line 319
  close(err_pipe[1]);
#line 321
  *to = to_pipe[1];
#line 322
  *from = from_pipe[0];
#line 323
  *err = err_pipe[0];
  }
#line 325
  return (pid);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 348 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/coproc.c"
int coproc_close(pid_t pid , int *to , int *from , int *err ) 
{ 
  int status ;
  int tmp ;
  __pid_t tmp___0 ;

  {
#line 350
  status = 0;
#line 352
  if (pid <= 0) {
    {
#line 353
    tmp = set_errno(22);
    }
#line 353
    return (tmp);
  }
#line 355
  if (to) {
#line 355
    if (*to != -1) {
      {
#line 357
      close(*to);
#line 358
      *to = -1;
      }
    }
  }
#line 361
  if (from) {
#line 361
    if (*from != -1) {
      {
#line 363
      close(*from);
#line 364
      *from = -1;
      }
    }
  }
#line 367
  if (err) {
#line 367
    if (*err != -1) {
      {
#line 369
      close(*err);
#line 370
      *err = -1;
      }
    }
  }
  {
#line 373
  tmp___0 = waitpid(pid, & status, 0);
  }
#line 373
  if (tmp___0 == -1) {
#line 374
    return (-1);
  }
#line 376
  return (status);
}
}
#line 405 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/coproc.c"
pid_t coproc_pty_open(int *masterfd , char *slavename , size_t slavenamesize , struct termios  const  *slave_termios ,
                      struct winsize  const  *slave_winsize , char const   *cmd ,
                      char * const  *argv , char * const  *envv , void (*action)(void *data ) ,
                      void *data ) 
{ 
  pid_t pid ;
  int has_meta ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp16 ;

  {
#line 412
  if (! masterfd) {
    {
#line 413
    tmp = set_errno(22);
    }
#line 413
    return (tmp);
  } else
#line 412
  if (! slavename) {
    {
#line 413
    tmp = set_errno(22);
    }
#line 413
    return (tmp);
  } else
#line 412
  if (slavenamesize < 64UL) {
    {
#line 413
    tmp = set_errno(22);
    }
#line 413
    return (tmp);
  } else
#line 412
  if (! cmd) {
    {
#line 413
    tmp = set_errno(22);
    }
#line 413
    return (tmp);
  }
  {
#line 415
  tmp___0 = strcspn(cmd, "|&;()<>[]{}$`\'~\"\\*? \t\r\n");
#line 415
  has_meta = (int const   )*(cmd + tmp___0) != 0;
  }
#line 417
  if (has_meta) {
#line 417
    if (argv) {
      {
#line 418
      tmp___1 = set_errno(22);
      }
#line 418
      return (tmp___1);
    } else {
#line 417
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 417
  if (! has_meta) {
#line 417
    if (! argv) {
      {
#line 418
      tmp___1 = set_errno(22);
      }
#line 418
      return (tmp___1);
    }
  }
  {
#line 422
  pid = pty_fork(masterfd, slavename, slavenamesize, slave_termios, slave_winsize);
  }
  {
#line 424
  if (pid == -1) {
#line 424
    goto case_neg_1;
  }
#line 427
  if (pid == 0) {
#line 427
    goto case_0;
  }
#line 440
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 425
  return (-1);
  case_0: /* CIL Label */ 
#line 431
  if (action) {
    {
#line 432
    (*action)(data);
    }
  }
  {
#line 436
  do_exec(has_meta, cmd, argv, envv);
#line 437
  _exit(1);
  }
  switch_default: /* CIL Label */ 
#line 441
  return (pid);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 464 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/coproc.c"
int coproc_pty_close(pid_t pid , int *masterfd , char const   *slavename ) 
{ 
  int status ;
  int tmp ;
  __pid_t tmp___0 ;

  {
#line 466
  status = 0;
#line 468
  if (pid <= 0) {
    {
#line 469
    tmp = set_errno(22);
    }
#line 469
    return (tmp);
  }
#line 471
  if (masterfd) {
#line 471
    if (*masterfd != -1) {
      {
#line 473
      pty_release(slavename);
#line 474
      close(*masterfd);
#line 475
      *masterfd = -1;
      }
    }
  }
  {
#line 478
  tmp___0 = waitpid(pid, & status, 0);
  }
#line 478
  if (tmp___0 == -1) {
#line 479
    return (-1);
  }
#line 481
  return (status);
}
}
#line 35 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.h"
Agent *agent_create(void) ;
#line 36
Agent *agent_create_with_locker(Locker *locker ) ;
#line 37
Agent *agent_create_measured(void) ;
#line 38
Agent *agent_create_measured_with_locker(Locker *locker ) ;
#line 39
Agent *agent_create_using_select(void) ;
#line 40
Agent *agent_create_using_select_with_locker(Locker *locker ) ;
#line 41
void agent_release(Agent *agent ) ;
#line 42
void *agent_destroy(Agent **agent ) ;
#line 43
int agent_rdlock(Agent const   *agent ) ;
#line 44
int agent_wrlock(Agent const   *agent ) ;
#line 45
int agent_unlock(Agent const   *agent ) ;
#line 46
int agent_connect(Agent *agent , int fd , int events , agent_reaction_t *reaction ,
                  void *arg ) ;
#line 47
int agent_connect_unlocked(Agent *agent , int fd , int events , agent_reaction_t *reaction ,
                           void *arg ) ;
#line 48
int agent_disconnect(Agent *agent , int fd ) ;
#line 49
int agent_disconnect_unlocked(Agent *agent , int fd ) ;
#line 50
int agent_transfer(Agent *agent , int fd , Agent *dst ) ;
#line 51
int agent_transfer_unlocked(Agent *agent , int fd , Agent *dst ) ;
#line 52
int agent_send(Agent *agent , int fd , int sockfd ) ;
#line 53
int agent_send_unlocked(Agent *agent , int fd , int sockfd ) ;
#line 54
int agent_recv(Agent *agent , int sockfd , agent_reaction_t *reaction , void *arg ) ;
#line 55
int agent_recv_unlocked(Agent *agent , int sockfd , agent_reaction_t *reaction , void *arg ) ;
#line 56
int agent_detail(Agent *agent , int fd ) ;
#line 57
int agent_detail_unlocked(Agent *agent , int fd ) ;
#line 58
struct timeval  const  * const  agent_last(Agent *agent , int fd ) ;
#line 59
struct timeval  const  * const  agent_last_unlocked(Agent *agent , int fd ) ;
#line 60
int agent_velocity(Agent *agent , int fd ) ;
#line 61
int agent_velocity_unlocked(Agent *agent , int fd ) ;
#line 62
int agent_acceleration(Agent *agent , int fd ) ;
#line 63
int agent_acceleration_unlocked(Agent *agent , int fd ) ;
#line 64
int agent_dadt(Agent *agent , int fd ) ;
#line 65
int agent_dadt_unlocked(Agent *agent , int fd ) ;
#line 66
void *agent_schedule(Agent *agent , long sec , long usec , agent_action_t *action ,
                     void *arg ) ;
#line 67
void *agent_schedule_unlocked(Agent *agent , long sec , long usec , agent_action_t *action ,
                              void *arg ) ;
#line 68
int agent_cancel(Agent *agent , void *action_id ) ;
#line 69
int agent_cancel_unlocked(Agent *agent , void *action_id ) ;
#line 70
int agent_start(Agent *agent ) ;
#line 71
int agent_stop(Agent *agent ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 250 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
static timewheel_t *timewheel_create(void) 
{ 
  timewheel_t *timewheel ;
  void *tmp ;
  int tmp___0 ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
  {
#line 252
  tmp = malloc(sizeof(timewheel_t ));
#line 252
  timewheel = (timewheel_t *)tmp;
  }
#line 254
  if (! timewheel) {
#line 255
    return ((timewheel_t *)((void *)0));
  }
  {
#line 257
  memset((void *)timewheel, 0, sizeof(timewheel_t ));
#line 259
  tmp___0 = gettimeofday((struct timeval */* __restrict  */)(timewheel->now), (__timezone_ptr_t )((void *)0));
  }
#line 259
  if (tmp___0 == -1) {
#line 260
    return ((timewheel_t *)((void *)0));
  }
#line 262
  return (timewheel);
}
}
#line 273 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
static action_t *release_action(action_t *action ) 
{ 
  action_t *next ;
  void *tmp ;

  {
  {
#line 275
  tmp = dlink_next((void *)action);
#line 275
  next = (action_t *)tmp;
#line 277
  free((void *)action);
  }
#line 279
  return (next);
}
}
#line 282 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
static void release_actions(action_t *action ) 
{ 


  {
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    if (! action) {
#line 284
      goto while_break;
    }
    {
#line 285
    action = release_action(action);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  return;
}
}
#line 288 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
static void timewheel_release(timewheel_t *timewheel ) 
{ 
  size_t i ;

  {
#line 292
  if (! timewheel) {
#line 293
    return;
  }
#line 295
  i = (size_t )0;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    if (! (i < 10UL)) {
#line 295
      goto while_break;
    }
    {
#line 296
    release_actions(timewheel->days[i]);
#line 295
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 298
  i = (size_t )0;
  {
#line 298
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 298
    if (! (i < 24UL)) {
#line 298
      goto while_break___0;
    }
    {
#line 299
    release_actions(timewheel->hours[i]);
#line 298
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 301
  i = (size_t )0;
  {
#line 301
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 301
    if (! (i < 60UL)) {
#line 301
      goto while_break___1;
    }
    {
#line 302
    release_actions(timewheel->minutes[i]);
#line 301
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 304
  i = (size_t )0;
  {
#line 304
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 304
    if (! (i < 60UL)) {
#line 304
      goto while_break___2;
    }
    {
#line 305
    release_actions(timewheel->seconds[i]);
#line 304
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 307
  i = (size_t )0;
  {
#line 307
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 307
    if (! (i < 100UL)) {
#line 307
      goto while_break___3;
    }
    {
#line 308
    release_actions(timewheel->jiffies[i]);
#line 307
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 310
  free((void *)timewheel);
  }
#line 311
  return;
}
}
#line 325 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
Agent *agent_create(void) 
{ 
  Agent *tmp ;

  {
  {
#line 327
  tmp = agent_create_with_locker((Locker *)((void *)0));
  }
#line 327
  return (tmp);
}
}
#line 341 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
Agent *agent_create_with_locker(Locker *locker ) 
{ 
  Agent *agent ;
  void *tmp ;

  {
  {
#line 343
  tmp = malloc(sizeof(Agent ));
#line 343
  agent = (Agent *)tmp;
  }
#line 345
  if (! agent) {
#line 346
    return ((Agent *)((void *)0));
  }
  {
#line 348
  memset((void *)agent, 0, sizeof(Agent ));
#line 351
  agent->method = 0;
#line 356
  agent->locker = locker;
  }
#line 358
  return (agent);
}
}
#line 386 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
Agent *agent_create_measured(void) 
{ 
  Agent *tmp ;

  {
  {
#line 388
  tmp = agent_create_measured_with_locker((Locker *)((void *)0));
  }
#line 388
  return (tmp);
}
}
#line 402 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
Agent *agent_create_measured_with_locker(Locker *locker ) 
{ 
  Agent *agent ;
  void *tmp ;
  activity_t *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 404
  tmp = malloc(sizeof(Agent ));
#line 404
  agent = (Agent *)tmp;
  }
#line 406
  if (! agent) {
#line 407
    return ((Agent *)((void *)0));
  }
  {
#line 409
  memset((void *)agent, 0, sizeof(Agent ));
#line 412
  agent->method = 0;
#line 417
  tmp___1 = malloc(sizeof(activity_t ));
#line 417
  tmp___0 = (activity_t *)tmp___1;
#line 417
  agent->tempo = tmp___0;
  }
#line 417
  if (! tmp___0) {
    {
#line 419
    free((void *)agent);
    }
#line 420
    return ((Agent *)((void *)0));
  }
  {
#line 423
  memset((void *)agent->tempo, 0, sizeof(activity_t ));
#line 424
  agent->locker = locker;
  }
#line 426
  return (agent);
}
}
#line 442 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
Agent *agent_create_using_select(void) 
{ 
  Agent *tmp ;

  {
  {
#line 444
  tmp = agent_create_using_select_with_locker((Locker *)((void *)0));
  }
#line 444
  return (tmp);
}
}
#line 458 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
Agent *agent_create_using_select_with_locker(Locker *locker ) 
{ 
  Agent *agent ;
  void *tmp ;

  {
  {
#line 460
  tmp = malloc(sizeof(Agent ));
#line 460
  agent = (Agent *)tmp;
  }
#line 462
  if (! agent) {
#line 463
    return ((Agent *)((void *)0));
  }
  {
#line 465
  memset((void *)agent, 0, sizeof(Agent ));
#line 466
  agent->method = 1;
#line 467
  agent->locker = locker;
  }
#line 469
  return (agent);
}
}
#line 482 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
void agent_release(Agent *agent ) 
{ 
  Locker *locker ;
  int tmp ;

  {
#line 486
  if (! agent) {
#line 487
    return;
  }
  {
#line 489
  tmp = agent_wrlock((Agent const   *)agent);
  }
#line 489
  if (tmp) {
#line 490
    return;
  }
  {
#line 492
  locker = agent->locker;
#line 493
  free((void *)agent->ids);
  }
#line 496
  if (agent->method == 0) {
    {
#line 497
    free((void *)agent->u.pfds);
    }
  } else {
    {
#line 501
    free((void *)agent->u.s.rfds);
#line 502
    free((void *)agent->u.s.wfds);
#line 503
    free((void *)agent->u.s.xfds);
    }
  }
  {
#line 506
  free((void *)agent->reactions);
#line 507
  free((void *)agent->tempo);
#line 508
  free((void *)agent->activity);
#line 509
  timewheel_release(agent->timewheel);
#line 510
  free((void *)agent);
  }
#line 511
  if (locker) {
    {
#line 511
    (*(locker->unlock))(locker->lock);
    }
  }
#line 512
  return;
}
}
#line 526 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
void *agent_destroy(Agent **agent ) 
{ 


  {
#line 528
  if (agent) {
#line 528
    if (*agent) {
      {
#line 530
      agent_release(*agent);
#line 531
      *agent = (Agent *)((void *)0);
      }
    }
  }
#line 534
  return ((void *)0);
}
}
#line 558 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_rdlock(Agent const   *agent ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 560
  if (agent->locker) {
    {
#line 560
    tmp = (*((agent->locker)->rdlock))((agent->locker)->lock);
#line 560
    tmp___0 = tmp;
    }
  } else {
#line 560
    tmp___0 = 0;
  }
#line 560
  return (tmp___0);
}
}
#line 579 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_wrlock(Agent const   *agent ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 581
  if (agent->locker) {
    {
#line 581
    tmp = (*((agent->locker)->wrlock))((agent->locker)->lock);
#line 581
    tmp___0 = tmp;
    }
  } else {
#line 581
    tmp___0 = 0;
  }
#line 581
  return (tmp___0);
}
}
#line 596 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_unlock(Agent const   *agent ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 598
  if (agent->locker) {
    {
#line 598
    tmp = (*((agent->locker)->unlock))((agent->locker)->lock);
#line 598
    tmp___0 = tmp;
    }
  } else {
#line 598
    tmp___0 = 0;
  }
#line 598
  return (tmp___0);
}
}
#line 620 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_connect(Agent *agent , int fd , int events , agent_reaction_t *reaction ,
                  void *arg ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 624
  if (! agent) {
    {
#line 625
    tmp = set_errno(22);
    }
#line 625
    return (tmp);
  }
#line 627
  if (agent->locker) {
    {
#line 627
    tmp___1 = (*((agent->locker)->wrlock))((agent->locker)->lock);
#line 627
    err = tmp___1;
    }
  } else {
#line 627
    err = 0;
  }
#line 627
  if (err) {
    {
#line 628
    tmp___0 = set_errno(err);
    }
#line 628
    return (tmp___0);
  }
  {
#line 630
  ret = agent_connect_unlocked(agent, fd, events, reaction, arg);
  }
#line 632
  if (agent->locker) {
    {
#line 632
    tmp___3 = (*((agent->locker)->unlock))((agent->locker)->lock);
#line 632
    err = tmp___3;
    }
  } else {
#line 632
    err = 0;
  }
#line 632
  if (err) {
    {
#line 633
    tmp___2 = set_errno(err);
    }
#line 633
    return (tmp___2);
  }
#line 635
  return (ret);
}
}
#line 648 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_connect_unlocked(Agent *agent , int fd , int events , agent_reaction_t *reaction ,
                           void *arg ) 
{ 
  int tmp ;
  ssize_t *tmp___0 ;
  void *tmp___1 ;
  ssize_t *tmp___2 ;
  void *tmp___3 ;
  struct pollfd *tmp___4 ;
  void *tmp___5 ;
  reaction_t *tmp___6 ;
  void *tmp___7 ;
  activity_t *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  fd_set *tmp___14 ;
  void *tmp___15 ;
  int __d0 ;
  int __d1 ;
  fd_set *tmp___16 ;
  void *tmp___17 ;
  int __d0___0 ;
  int __d1___0 ;
  fd_set *tmp___18 ;
  void *tmp___19 ;
  int __d0___1 ;
  int __d1___1 ;
  void *__cil_tmp33 ;
  int __cil_tmp34 ;
  void *__cil_tmp35 ;
  int __cil_tmp36 ;
  void *__cil_tmp37 ;
  int __cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;

  {
#line 652
  if (! agent) {
    {
#line 653
    tmp = set_errno(22);
    }
#line 653
    return (tmp);
  } else
#line 652
  if (fd < 0) {
    {
#line 653
    tmp = set_errno(22);
    }
#line 653
    return (tmp);
  } else
#line 652
  if (! reaction) {
    {
#line 653
    tmp = set_errno(22);
    }
#line 653
    return (tmp);
  } else
#line 652
  if (! (events & 7)) {
    {
#line 653
    tmp = set_errno(22);
    }
#line 653
    return (tmp);
  } else
#line 652
  if (events & -8) {
    {
#line 653
    tmp = set_errno(22);
    }
#line 653
    return (tmp);
  }
#line 657
  if (! agent->ids) {
    {
#line 659
    tmp___1 = malloc((unsigned long )(fd + 1) * sizeof(ssize_t ));
#line 659
    tmp___0 = (ssize_t *)tmp___1;
#line 659
    agent->ids = tmp___0;
    }
#line 659
    if (! tmp___0) {
#line 660
      return (-1);
    }
    {
#line 662
    memset((void *)agent->ids, 255, (unsigned long )(fd + 1) * sizeof(ssize_t ));
#line 663
    agent->ids_size = (size_t )(fd + 1);
    }
  } else
#line 665
  if (agent->ids_size <= (size_t )fd) {
    {
#line 667
    tmp___3 = mem_resize_fn((void **)(& agent->ids), (agent->ids_size << 1) * sizeof(*(agent->ids)));
#line 667
    tmp___2 = (ssize_t *)tmp___3;
#line 667
    agent->ids = tmp___2;
    }
#line 667
    if (! tmp___2) {
#line 668
      return (-1);
    }
    {
#line 670
    memset((void *)(agent->ids + agent->ids_size), 255, agent->ids_size * sizeof(ssize_t ));
#line 671
    agent->ids_size <<= 1;
    }
  }
#line 676
  if (! agent->reactions) {
#line 679
    if (agent->method == 0) {
      {
#line 681
      tmp___5 = malloc(16UL * sizeof(struct pollfd ));
#line 681
      tmp___4 = (struct pollfd *)tmp___5;
#line 681
      agent->u.pfds = tmp___4;
      }
#line 681
      if (! tmp___4) {
#line 682
        return (-1);
      }
      {
#line 684
      memset((void *)agent->u.pfds, 0, 16UL * sizeof(struct pollfd ));
      }
    }
    {
#line 688
    tmp___7 = malloc(16UL * sizeof(reaction_t ));
#line 688
    tmp___6 = (reaction_t *)tmp___7;
#line 688
    agent->reactions = tmp___6;
    }
#line 688
    if (! tmp___6) {
#line 689
      return (-1);
    }
    {
#line 691
    memset((void *)agent->reactions, 0, 16UL * sizeof(reaction_t ));
    }
#line 693
    if (agent->tempo) {
      {
#line 695
      tmp___9 = malloc(16UL * sizeof(activity_t ));
#line 695
      tmp___8 = (activity_t *)tmp___9;
#line 695
      agent->activity = tmp___8;
      }
#line 695
      if (! tmp___8) {
#line 696
        return (-1);
      }
      {
#line 698
      memset((void *)agent->activity, 0, 16UL * sizeof(activity_t ));
      }
    }
#line 701
    agent->size = (size_t )16;
  } else
#line 703
  if (agent->length == agent->size) {
#line 706
    if (agent->method == 0) {
      {
#line 708
      tmp___10 = mem_resize_fn((void **)(& agent->u.pfds), (agent->size << 1) * sizeof(*(agent->u.pfds)));
      }
#line 708
      if (! tmp___10) {
#line 709
        return (-1);
      }
      {
#line 711
      memset((void *)(agent->u.pfds + agent->size), 0, agent->size * sizeof(struct pollfd ));
      }
    }
    {
#line 715
    tmp___11 = mem_resize_fn((void **)(& agent->reactions), (agent->size << 1) * sizeof(*(agent->reactions)));
    }
#line 715
    if (! tmp___11) {
#line 716
      return (-1);
    }
    {
#line 718
    memset((void *)(agent->reactions + agent->size), 0, agent->size * sizeof(reaction_t ));
    }
#line 720
    if (agent->tempo) {
      {
#line 722
      tmp___12 = mem_resize_fn((void **)(& agent->activity), (agent->size << 1) * sizeof(*(agent->activity)));
      }
#line 722
      if (! tmp___12) {
#line 723
        return (-1);
      }
      {
#line 725
      memset((void *)(agent->activity + agent->size), 0, agent->size * sizeof(activity_t ));
      }
    }
#line 728
    agent->size <<= 1;
  }
#line 733
  if (*(agent->ids + fd) == -1L) {
#line 734
    tmp___13 = agent->length;
#line 734
    (agent->length) ++;
#line 734
    *(agent->ids + fd) = (ssize_t )tmp___13;
  }
#line 739
  if (agent->method == 0) {
#line 741
    (agent->u.pfds + *(agent->ids + fd))->fd = fd;
#line 742
    (agent->u.pfds + *(agent->ids + fd))->events = (short)0;
#line 743
    (agent->u.pfds + *(agent->ids + fd))->revents = (short)0;
#line 745
    if (events & 4) {
#line 746
      (agent->u.pfds + *(agent->ids + fd))->events = (short )((int )(agent->u.pfds + *(agent->ids + fd))->events | 1);
    }
#line 748
    if (events & 1) {
#line 749
      (agent->u.pfds + *(agent->ids + fd))->events = (short )((int )(agent->u.pfds + *(agent->ids + fd))->events | 2);
    }
#line 751
    if (events & 2) {
#line 752
      (agent->u.pfds + *(agent->ids + fd))->events = (short )((int )(agent->u.pfds + *(agent->ids + fd))->events | 4);
    }
  } else {
#line 757
    if (events & 4) {
#line 757
      if (! agent->u.s.rfds) {
        {
#line 759
        tmp___15 = malloc(sizeof(fd_set ));
#line 759
        tmp___14 = (fd_set *)tmp___15;
#line 759
        agent->u.s.rfds = tmp___14;
        }
#line 759
        if (! tmp___14) {
#line 760
          return (-1);
        }
        {
#line 762
        while (1) {
          while_continue: /* CIL Label */ ;
#line 762
          __asm__  volatile   ("cld; rep; "
                               "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                               "1" (& (agent->u.s.rfds)->fds_bits[0]): "memory");
#line 762
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
#line 765
    if (events & 1) {
#line 765
      if (! agent->u.s.xfds) {
        {
#line 767
        tmp___17 = malloc(sizeof(fd_set ));
#line 767
        tmp___16 = (fd_set *)tmp___17;
#line 767
        agent->u.s.xfds = tmp___16;
        }
#line 767
        if (! tmp___16) {
#line 768
          return (-1);
        }
        {
#line 770
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 770
          __asm__  volatile   ("cld; rep; "
                               "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0),
                               "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& (agent->u.s.xfds)->fds_bits[0]): "memory");
#line 770
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 773
    if (events & 2) {
#line 773
      if (! agent->u.s.wfds) {
        {
#line 775
        tmp___19 = malloc(sizeof(fd_set ));
#line 775
        tmp___18 = (fd_set *)tmp___19;
#line 775
        agent->u.s.wfds = tmp___18;
        }
#line 775
        if (! tmp___18) {
#line 776
          return (-1);
        }
        {
#line 778
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 778
          __asm__  volatile   ("cld; rep; "
                               "stosq": "=c" (__d0___1), "=D" (__d1___1): "a" (0),
                               "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& (agent->u.s.wfds)->fds_bits[0]): "memory");
#line 778
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 781
    if (events & 4) {
#line 782
      (agent->u.s.rfds)->fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << fd % (8 * (int )sizeof(__fd_mask )));
    }
#line 784
    if (events & 1) {
#line 785
      (agent->u.s.xfds)->fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << fd % (8 * (int )sizeof(__fd_mask )));
    }
#line 787
    if (events & 2) {
#line 788
      (agent->u.s.wfds)->fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << fd % (8 * (int )sizeof(__fd_mask )));
    }
  }
#line 791
  (agent->reactions + *(agent->ids + fd))->fd = fd;
#line 792
  (agent->reactions + *(agent->ids + fd))->events = events;
#line 793
  (agent->reactions + *(agent->ids + fd))->reaction = reaction;
#line 794
  (agent->reactions + *(agent->ids + fd))->arg = arg;
#line 796
  return (0);
}
}
#line 811 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_disconnect(Agent *agent , int fd ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 815
  if (! agent) {
    {
#line 816
    tmp = set_errno(22);
    }
#line 816
    return (tmp);
  }
#line 818
  if (agent->locker) {
    {
#line 818
    tmp___1 = (*((agent->locker)->wrlock))((agent->locker)->lock);
#line 818
    err = tmp___1;
    }
  } else {
#line 818
    err = 0;
  }
#line 818
  if (err) {
    {
#line 819
    tmp___0 = set_errno(err);
    }
#line 819
    return (tmp___0);
  }
  {
#line 821
  ret = agent_disconnect_unlocked(agent, fd);
  }
#line 823
  if (agent->locker) {
    {
#line 823
    tmp___3 = (*((agent->locker)->unlock))((agent->locker)->lock);
#line 823
    err = tmp___3;
    }
  } else {
#line 823
    err = 0;
  }
#line 823
  if (err) {
    {
#line 824
    tmp___2 = set_errno(err);
    }
#line 824
    return (tmp___2);
  }
#line 826
  return (ret);
}
}
#line 840 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_disconnect_unlocked(Agent *agent , int fd ) 
{ 
  ssize_t id ;
  ssize_t last_id ;
  int last_fd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 847
  if (! agent) {
    {
#line 848
    tmp = set_errno(22);
    }
#line 848
    return (tmp);
  } else
#line 847
  if (fd < 0) {
    {
#line 848
    tmp = set_errno(22);
    }
#line 848
    return (tmp);
  }
#line 853
  if (agent->method == 0) {
#line 855
    if (! agent->u.pfds) {
      {
#line 856
      tmp___0 = set_errno(22);
      }
#line 856
      return (tmp___0);
    }
  } else
#line 860
  if (! agent->u.s.rfds) {
#line 860
    if (! agent->u.s.wfds) {
#line 860
      if (! agent->u.s.xfds) {
        {
#line 861
        tmp___1 = set_errno(22);
        }
#line 861
        return (tmp___1);
      }
    }
  }
#line 863
  if (! agent->ids) {
    {
#line 864
    tmp___2 = set_errno(22);
    }
#line 864
    return (tmp___2);
  } else
#line 863
  if (! agent->reactions) {
    {
#line 864
    tmp___2 = set_errno(22);
    }
#line 864
    return (tmp___2);
  } else
#line 863
  if (agent->tempo) {
#line 863
    if (! agent->activity) {
      {
#line 864
      tmp___2 = set_errno(22);
      }
#line 864
      return (tmp___2);
    } else {
#line 863
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 863
  if (agent->ids_size <= (size_t )fd) {
    {
#line 864
    tmp___2 = set_errno(22);
    }
#line 864
    return (tmp___2);
  }
#line 868
  id = *(agent->ids + fd);
#line 868
  if (id == -1L) {
    {
#line 869
    tmp___3 = set_errno(22);
    }
#line 869
    return (tmp___3);
  }
#line 871
  last_fd = (agent->reactions + (agent->length - 1UL))->fd;
#line 872
  last_id = *(agent->ids + last_fd);
#line 875
  if (agent->method == 0) {
    {
#line 877
    *(agent->u.pfds + id) = *(agent->u.pfds + last_id);
#line 878
    memset((void *)(agent->u.pfds + last_id), 0, sizeof(struct pollfd ));
    }
  } else {
#line 883
    if (agent->u.s.rfds) {
#line 884
      (agent->u.s.rfds)->fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ ((__fd_mask )(1UL << fd % (8 * (int )sizeof(__fd_mask ))));
    }
#line 886
    if (agent->u.s.xfds) {
#line 887
      (agent->u.s.xfds)->fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ ((__fd_mask )(1UL << fd % (8 * (int )sizeof(__fd_mask ))));
    }
#line 889
    if (agent->u.s.wfds) {
#line 890
      (agent->u.s.wfds)->fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ ((__fd_mask )(1UL << fd % (8 * (int )sizeof(__fd_mask ))));
    }
  }
#line 893
  *(agent->reactions + id) = *(agent->reactions + last_id);
#line 895
  if (agent->tempo) {
#line 896
    *(agent->activity + id) = *(agent->activity + last_id);
  }
  {
#line 898
  *(agent->ids + last_fd) = id;
#line 899
  (agent->length) --;
#line 901
  memset((void *)(agent->reactions + last_id), 0, sizeof(reaction_t ));
  }
#line 903
  if (agent->tempo) {
    {
#line 904
    memset((void *)(agent->activity + last_id), 0, sizeof(activity_t ));
    }
  }
#line 906
  *(agent->ids + fd) = (ssize_t )-1;
#line 908
  return (0);
}
}
#line 927 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_transfer(Agent *agent , int fd , Agent *dst ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 931
  if (! agent) {
    {
#line 932
    tmp = set_errno(22);
    }
#line 932
    return (tmp);
  }
#line 934
  if (agent->locker) {
    {
#line 934
    tmp___1 = (*((agent->locker)->wrlock))((agent->locker)->lock);
#line 934
    err = tmp___1;
    }
  } else {
#line 934
    err = 0;
  }
#line 934
  if (err) {
    {
#line 935
    tmp___0 = set_errno(err);
    }
#line 935
    return (tmp___0);
  }
  {
#line 937
  ret = agent_transfer_unlocked(agent, fd, dst);
  }
#line 939
  if (agent->locker) {
    {
#line 939
    tmp___3 = (*((agent->locker)->unlock))((agent->locker)->lock);
#line 939
    err = tmp___3;
    }
  } else {
#line 939
    err = 0;
  }
#line 939
  if (err) {
    {
#line 940
    tmp___2 = set_errno(err);
    }
#line 940
    return (tmp___2);
  }
#line 942
  return (ret);
}
}
#line 956 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_transfer_unlocked(Agent *agent , int fd , Agent *dst ) 
{ 
  reaction_t reaction ;
  activity_t activity ;
  ssize_t id ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 964
  if (! agent) {
    {
#line 965
    tmp = set_errno(22);
    }
#line 965
    return (tmp);
  } else
#line 964
  if (fd < 0) {
    {
#line 965
    tmp = set_errno(22);
    }
#line 965
    return (tmp);
  } else
#line 964
  if (! dst) {
    {
#line 965
    tmp = set_errno(22);
    }
#line 965
    return (tmp);
  }
#line 969
  if (! agent->ids) {
    {
#line 970
    tmp___0 = set_errno(22);
    }
#line 970
    return (tmp___0);
  } else
#line 969
  if (! agent->reactions) {
    {
#line 970
    tmp___0 = set_errno(22);
    }
#line 970
    return (tmp___0);
  } else
#line 969
  if (! agent->tempo) {
    {
#line 970
    tmp___0 = set_errno(22);
    }
#line 970
    return (tmp___0);
  } else
#line 969
  if (! agent->activity) {
    {
#line 970
    tmp___0 = set_errno(22);
    }
#line 970
    return (tmp___0);
  } else
#line 969
  if (agent->ids_size <= (size_t )fd) {
    {
#line 970
    tmp___0 = set_errno(22);
    }
#line 970
    return (tmp___0);
  }
#line 974
  if (! dst->tempo) {
    {
#line 975
    tmp___1 = set_errno(22);
    }
#line 975
    return (tmp___1);
  }
#line 979
  id = *(agent->ids + fd);
#line 979
  if (id == -1L) {
    {
#line 980
    tmp___2 = set_errno(22);
    }
#line 980
    return (tmp___2);
  }
  {
#line 982
  reaction = *(agent->reactions + id);
#line 983
  activity = *(agent->activity + id);
#line 985
  tmp___3 = agent_connect(dst, reaction.fd, reaction.events, reaction.reaction, reaction.arg);
  }
#line 985
  if (tmp___3 == -1) {
#line 986
    return (-1);
  }
  {
#line 988
  *(dst->activity + *(dst->ids + fd)) = activity;
#line 990
  tmp___4 = agent_disconnect_unlocked(agent, fd);
  }
#line 990
  if (tmp___4 == -1) {
    {
#line 992
    agent_disconnect(dst, fd);
    }
#line 993
    return (-1);
  }
#line 996
  return (0);
}
}
#line 1027 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_send(Agent *agent , int fd , int sockfd ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1031
  if (! agent) {
    {
#line 1032
    tmp = set_errno(22);
    }
#line 1032
    return (tmp);
  }
#line 1034
  if (agent->locker) {
    {
#line 1034
    tmp___1 = (*((agent->locker)->wrlock))((agent->locker)->lock);
#line 1034
    err = tmp___1;
    }
  } else {
#line 1034
    err = 0;
  }
#line 1034
  if (err) {
    {
#line 1035
    tmp___0 = set_errno(err);
    }
#line 1035
    return (tmp___0);
  }
  {
#line 1037
  ret = agent_send_unlocked(agent, fd, sockfd);
  }
#line 1039
  if (agent->locker) {
    {
#line 1039
    tmp___3 = (*((agent->locker)->unlock))((agent->locker)->lock);
#line 1039
    err = tmp___3;
    }
  } else {
#line 1039
    err = 0;
  }
#line 1039
  if (err) {
    {
#line 1040
    tmp___2 = set_errno(err);
    }
#line 1040
    return (tmp___2);
  }
#line 1042
  return (ret);
}
}
#line 1055 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_send_unlocked(Agent *agent , int fd , int sockfd ) 
{ 
  struct __anonstruct_buf_80 buf ;
  ssize_t id ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;

  {
#line 1062
  if (! agent) {
    {
#line 1063
    tmp = set_errno(22);
    }
#line 1063
    return (tmp);
  } else
#line 1062
  if (fd < 0) {
    {
#line 1063
    tmp = set_errno(22);
    }
#line 1063
    return (tmp);
  } else
#line 1062
  if (sockfd < 0) {
    {
#line 1063
    tmp = set_errno(22);
    }
#line 1063
    return (tmp);
  }
#line 1067
  if (! agent->ids) {
    {
#line 1068
    tmp___0 = set_errno(22);
    }
#line 1068
    return (tmp___0);
  } else
#line 1067
  if (! agent->reactions) {
    {
#line 1068
    tmp___0 = set_errno(22);
    }
#line 1068
    return (tmp___0);
  } else
#line 1067
  if (! agent->tempo) {
    {
#line 1068
    tmp___0 = set_errno(22);
    }
#line 1068
    return (tmp___0);
  } else
#line 1067
  if (! agent->activity) {
    {
#line 1068
    tmp___0 = set_errno(22);
    }
#line 1068
    return (tmp___0);
  } else
#line 1067
  if (agent->ids_size <= (size_t )fd) {
    {
#line 1068
    tmp___0 = set_errno(22);
    }
#line 1068
    return (tmp___0);
  }
#line 1072
  id = *(agent->ids + fd);
#line 1072
  if (id == -1L) {
    {
#line 1073
    tmp___1 = set_errno(22);
    }
#line 1073
    return (tmp___1);
  }
  {
#line 1075
  buf.reaction = *(agent->reactions + id);
#line 1076
  buf.activity = *(agent->activity + id);
#line 1078
  tmp___2 = sendfd(sockfd, (void const   *)(& buf), sizeof(buf), 0, fd);
  }
#line 1078
  if (tmp___2 == -1L) {
#line 1079
    return (-1);
  }
  {
#line 1081
  tmp___3 = agent_disconnect_unlocked(agent, fd);
  }
#line 1081
  if (tmp___3 == -1) {
#line 1082
    return (-1);
  }
#line 1084
  return (0);
}
}
#line 1101 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_recv(Agent *agent , int sockfd , agent_reaction_t *reaction , void *arg ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1105
  if (! agent) {
    {
#line 1106
    tmp = set_errno(22);
    }
#line 1106
    return (tmp);
  } else
#line 1105
  if (sockfd < 0) {
    {
#line 1106
    tmp = set_errno(22);
    }
#line 1106
    return (tmp);
  } else
#line 1105
  if (! reaction) {
    {
#line 1106
    tmp = set_errno(22);
    }
#line 1106
    return (tmp);
  }
#line 1108
  if (agent->locker) {
    {
#line 1108
    tmp___1 = (*((agent->locker)->wrlock))((agent->locker)->lock);
#line 1108
    err = tmp___1;
    }
  } else {
#line 1108
    err = 0;
  }
#line 1108
  if (err) {
    {
#line 1109
    tmp___0 = set_errno(err);
    }
#line 1109
    return (tmp___0);
  }
  {
#line 1111
  ret = agent_recv_unlocked(agent, sockfd, reaction, arg);
  }
#line 1113
  if (agent->locker) {
    {
#line 1113
    tmp___3 = (*((agent->locker)->unlock))((agent->locker)->lock);
#line 1113
    err = tmp___3;
    }
  } else {
#line 1113
    err = 0;
  }
#line 1113
  if (err) {
    {
#line 1114
    tmp___2 = set_errno(err);
    }
#line 1114
    return (tmp___2);
  }
#line 1116
  return (ret);
}
}
#line 1129 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_recv_unlocked(Agent *agent , int sockfd , agent_reaction_t *reaction , void *arg ) 
{ 
  struct __anonstruct_buf_81 buf ;
  ssize_t id ;
  int fd ;
  int tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1137
  if (! agent) {
    {
#line 1138
    tmp = set_errno(22);
    }
#line 1138
    return (tmp);
  } else
#line 1137
  if (sockfd < 0) {
    {
#line 1138
    tmp = set_errno(22);
    }
#line 1138
    return (tmp);
  } else
#line 1137
  if (! reaction) {
    {
#line 1138
    tmp = set_errno(22);
    }
#line 1138
    return (tmp);
  }
  {
#line 1142
  tmp___0 = recvfd(sockfd, (void *)(& buf), sizeof(buf), 0, & fd);
  }
#line 1142
  if ((unsigned long )tmp___0 != sizeof(buf)) {
#line 1143
    return (-1);
  }
#line 1145
  if (! reaction) {
#line 1146
    reaction = buf.reaction.reaction;
  }
#line 1148
  if (! arg) {
#line 1149
    arg = buf.reaction.arg;
  }
  {
#line 1151
  tmp___1 = agent_connect_unlocked(agent, fd, buf.reaction.events, reaction, arg);
  }
#line 1151
  if (tmp___1 == -1) {
#line 1152
    return (-1);
  }
#line 1154
  id = *(agent->ids + fd);
#line 1154
  if (id == -1L) {
    {
#line 1155
    tmp___2 = set_errno(22);
    }
#line 1155
    return (tmp___2);
  }
#line 1157
  *(agent->activity + id) = buf.activity;
#line 1159
  return (0);
}
}
#line 1192 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_detail(Agent *agent , int fd ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1196
  if (! agent) {
    {
#line 1197
    tmp = set_errno(22);
    }
#line 1197
    return (tmp);
  }
#line 1199
  if (agent->locker) {
    {
#line 1199
    tmp___1 = (*((agent->locker)->rdlock))((agent->locker)->lock);
#line 1199
    err = tmp___1;
    }
  } else {
#line 1199
    err = 0;
  }
#line 1199
  if (err) {
    {
#line 1200
    tmp___0 = set_errno(err);
    }
#line 1200
    return (tmp___0);
  }
  {
#line 1202
  ret = agent_detail_unlocked(agent, fd);
  }
#line 1204
  if (agent->locker) {
    {
#line 1204
    tmp___3 = (*((agent->locker)->unlock))((agent->locker)->lock);
#line 1204
    err = tmp___3;
    }
  } else {
#line 1204
    err = 0;
  }
#line 1204
  if (err) {
    {
#line 1205
    tmp___2 = set_errno(err);
    }
#line 1205
    return (tmp___2);
  }
#line 1207
  return (ret);
}
}
#line 1220 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_detail_unlocked(Agent *agent , int fd ) 
{ 
  ssize_t id ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1226
  if (! agent) {
    {
#line 1227
    tmp = set_errno(22);
    }
#line 1227
    return (tmp);
  } else
#line 1226
  if (fd < -1) {
    {
#line 1227
    tmp = set_errno(22);
    }
#line 1227
    return (tmp);
  }
#line 1231
  if (! agent->ids) {
    {
#line 1232
    tmp___0 = set_errno(22);
    }
#line 1232
    return (tmp___0);
  } else
#line 1231
  if (! agent->reactions) {
    {
#line 1232
    tmp___0 = set_errno(22);
    }
#line 1232
    return (tmp___0);
  } else
#line 1231
  if (! agent->tempo) {
    {
#line 1232
    tmp___0 = set_errno(22);
    }
#line 1232
    return (tmp___0);
  } else
#line 1231
  if (! agent->activity) {
    {
#line 1232
    tmp___0 = set_errno(22);
    }
#line 1232
    return (tmp___0);
  } else
#line 1231
  if (agent->ids_size <= (size_t )fd) {
    {
#line 1232
    tmp___0 = set_errno(22);
    }
#line 1232
    return (tmp___0);
  }
#line 1236
  if (fd == -1) {
#line 1237
    return ((int )(agent->tempo)->detail);
  }
#line 1241
  id = *(agent->ids + fd);
#line 1241
  if (id == -1L) {
    {
#line 1242
    tmp___1 = set_errno(22);
    }
#line 1242
    return (tmp___1);
  }
#line 1244
  return ((int )(agent->activity + id)->detail);
}
}
#line 1262 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
struct timeval  const  * const  agent_last(Agent *agent , int fd ) 
{ 
  struct timeval  const  *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  struct timeval  const  *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
#line 1267
  if (! agent) {
    {
#line 1268
    tmp = set_errnull(22);
    }
#line 1268
    return ((struct timeval  const  */* const  */)tmp);
  }
#line 1270
  if (agent->locker) {
    {
#line 1270
    tmp___1 = (*((agent->locker)->rdlock))((agent->locker)->lock);
#line 1270
    err = tmp___1;
    }
  } else {
#line 1270
    err = 0;
  }
#line 1270
  if (err) {
    {
#line 1271
    tmp___0 = set_errnull(err);
    }
#line 1271
    return ((struct timeval  const  */* const  */)tmp___0);
  }
  {
#line 1273
  tmp___2 = (struct timeval  const  *)agent_last_unlocked(agent, fd);
#line 1273
  ret = (struct timeval  const  *)tmp___2;
  }
#line 1275
  if (agent->locker) {
    {
#line 1275
    tmp___4 = (*((agent->locker)->unlock))((agent->locker)->lock);
#line 1275
    err = tmp___4;
    }
  } else {
#line 1275
    err = 0;
  }
#line 1275
  if (err) {
    {
#line 1276
    tmp___3 = set_errnull(err);
    }
#line 1276
    return ((struct timeval  const  */* const  */)tmp___3);
  }
#line 1278
  return ((struct timeval  const  */* const  */)ret);
}
}
#line 1291 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
struct timeval  const  * const  agent_last_unlocked(Agent *agent , int fd ) 
{ 
  ssize_t id ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 1297
  if (! agent) {
    {
#line 1298
    tmp = set_errnull(22);
    }
#line 1298
    return ((struct timeval  const  */* const  */)tmp);
  } else
#line 1297
  if (fd < -1) {
    {
#line 1298
    tmp = set_errnull(22);
    }
#line 1298
    return ((struct timeval  const  */* const  */)tmp);
  }
#line 1302
  if (! agent->ids) {
    {
#line 1303
    tmp___0 = set_errnull(22);
    }
#line 1303
    return ((struct timeval  const  */* const  */)tmp___0);
  } else
#line 1302
  if (! agent->reactions) {
    {
#line 1303
    tmp___0 = set_errnull(22);
    }
#line 1303
    return ((struct timeval  const  */* const  */)tmp___0);
  } else
#line 1302
  if (! agent->tempo) {
    {
#line 1303
    tmp___0 = set_errnull(22);
    }
#line 1303
    return ((struct timeval  const  */* const  */)tmp___0);
  } else
#line 1302
  if (! agent->activity) {
    {
#line 1303
    tmp___0 = set_errnull(22);
    }
#line 1303
    return ((struct timeval  const  */* const  */)tmp___0);
  } else
#line 1302
  if (agent->ids_size <= (size_t )fd) {
    {
#line 1303
    tmp___0 = set_errnull(22);
    }
#line 1303
    return ((struct timeval  const  */* const  */)tmp___0);
  }
#line 1307
  if (fd == -1) {
#line 1309
    if ((agent->tempo)->detail == 0UL) {
      {
#line 1310
      tmp___1 = set_errnull(22);
      }
#line 1310
      return ((struct timeval  const  */* const  */)tmp___1);
    }
#line 1312
    return ((struct timeval  const  */* const  */)(& (agent->tempo)->since));
  }
#line 1317
  id = *(agent->ids + fd);
#line 1317
  if (id == -1L) {
    {
#line 1318
    tmp___2 = set_errnull(22);
    }
#line 1318
    return ((struct timeval  const  */* const  */)tmp___2);
  }
#line 1320
  if ((agent->activity + id)->detail == 0UL) {
    {
#line 1321
    tmp___3 = set_errnull(22);
    }
#line 1321
    return ((struct timeval  const  */* const  */)tmp___3);
  }
#line 1323
  return ((struct timeval  const  */* const  */)(& (agent->activity + id)->since));
}
}
#line 1342 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_velocity(Agent *agent , int fd ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1346
  if (! agent) {
    {
#line 1347
    tmp = set_errno(22);
    }
#line 1347
    return (tmp);
  }
#line 1349
  if (agent->locker) {
    {
#line 1349
    tmp___1 = (*((agent->locker)->rdlock))((agent->locker)->lock);
#line 1349
    err = tmp___1;
    }
  } else {
#line 1349
    err = 0;
  }
#line 1349
  if (err) {
    {
#line 1350
    tmp___0 = set_errno(err);
    }
#line 1350
    return (tmp___0);
  }
  {
#line 1352
  ret = agent_velocity_unlocked(agent, fd);
  }
#line 1354
  if (agent->locker) {
    {
#line 1354
    tmp___3 = (*((agent->locker)->unlock))((agent->locker)->lock);
#line 1354
    err = tmp___3;
    }
  } else {
#line 1354
    err = 0;
  }
#line 1354
  if (err) {
    {
#line 1355
    tmp___2 = set_errno(err);
    }
#line 1355
    return (tmp___2);
  }
#line 1357
  return (ret);
}
}
#line 1370 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_velocity_unlocked(Agent *agent , int fd ) 
{ 
  ssize_t id ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1376
  if (! agent) {
    {
#line 1377
    tmp = set_errno(22);
    }
#line 1377
    return (tmp);
  } else
#line 1376
  if (fd < -1) {
    {
#line 1377
    tmp = set_errno(22);
    }
#line 1377
    return (tmp);
  }
#line 1381
  if (! agent->ids) {
    {
#line 1382
    tmp___0 = set_errno(22);
    }
#line 1382
    return (tmp___0);
  } else
#line 1381
  if (! agent->reactions) {
    {
#line 1382
    tmp___0 = set_errno(22);
    }
#line 1382
    return (tmp___0);
  } else
#line 1381
  if (! agent->tempo) {
    {
#line 1382
    tmp___0 = set_errno(22);
    }
#line 1382
    return (tmp___0);
  } else
#line 1381
  if (! agent->activity) {
    {
#line 1382
    tmp___0 = set_errno(22);
    }
#line 1382
    return (tmp___0);
  } else
#line 1381
  if (agent->ids_size <= (size_t )fd) {
    {
#line 1382
    tmp___0 = set_errno(22);
    }
#line 1382
    return (tmp___0);
  }
#line 1386
  if (fd == -1) {
#line 1388
    if ((agent->tempo)->detail < 2UL) {
      {
#line 1389
      tmp___1 = set_errno(22);
      }
#line 1389
      return (tmp___1);
    }
#line 1391
    return ((agent->tempo)->dt);
  }
#line 1396
  id = *(agent->ids + fd);
#line 1396
  if (id == -1L) {
    {
#line 1397
    tmp___2 = set_errno(22);
    }
#line 1397
    return (tmp___2);
  }
#line 1399
  if ((agent->activity + id)->detail < 2UL) {
    {
#line 1400
    tmp___3 = set_errno(22);
    }
#line 1400
    return (tmp___3);
  }
#line 1402
  return ((agent->activity + id)->dt);
}
}
#line 1423 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_acceleration(Agent *agent , int fd ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1427
  if (! agent) {
    {
#line 1428
    tmp = set_errno(22);
    }
#line 1428
    return (tmp);
  }
#line 1430
  if (agent->locker) {
    {
#line 1430
    tmp___1 = (*((agent->locker)->rdlock))((agent->locker)->lock);
#line 1430
    err = tmp___1;
    }
  } else {
#line 1430
    err = 0;
  }
#line 1430
  if (err) {
    {
#line 1431
    tmp___0 = set_errno(err);
    }
#line 1431
    return (tmp___0);
  }
  {
#line 1433
  ret = agent_acceleration_unlocked(agent, fd);
  }
#line 1435
  if (agent->locker) {
    {
#line 1435
    tmp___3 = (*((agent->locker)->unlock))((agent->locker)->lock);
#line 1435
    err = tmp___3;
    }
  } else {
#line 1435
    err = 0;
  }
#line 1435
  if (err) {
    {
#line 1436
    tmp___2 = set_errno(err);
    }
#line 1436
    return (tmp___2);
  }
#line 1438
  return (ret);
}
}
#line 1452 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_acceleration_unlocked(Agent *agent , int fd ) 
{ 
  ssize_t id ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1458
  if (! agent) {
    {
#line 1459
    tmp = set_errno(22);
    }
#line 1459
    return (tmp);
  } else
#line 1458
  if (fd < -1) {
    {
#line 1459
    tmp = set_errno(22);
    }
#line 1459
    return (tmp);
  }
#line 1463
  if (! agent->ids) {
    {
#line 1464
    tmp___0 = set_errno(22);
    }
#line 1464
    return (tmp___0);
  } else
#line 1463
  if (! agent->reactions) {
    {
#line 1464
    tmp___0 = set_errno(22);
    }
#line 1464
    return (tmp___0);
  } else
#line 1463
  if (! agent->tempo) {
    {
#line 1464
    tmp___0 = set_errno(22);
    }
#line 1464
    return (tmp___0);
  } else
#line 1463
  if (! agent->activity) {
    {
#line 1464
    tmp___0 = set_errno(22);
    }
#line 1464
    return (tmp___0);
  } else
#line 1463
  if (agent->ids_size <= (size_t )fd) {
    {
#line 1464
    tmp___0 = set_errno(22);
    }
#line 1464
    return (tmp___0);
  }
#line 1468
  if (fd == -1) {
#line 1470
    if ((agent->tempo)->detail < 3UL) {
      {
#line 1471
      tmp___1 = set_errno(22);
      }
#line 1471
      return (tmp___1);
    }
#line 1473
    return ((agent->tempo)->ddt);
  }
#line 1478
  id = *(agent->ids + fd);
#line 1478
  if (id == -1L) {
    {
#line 1479
    tmp___2 = set_errno(22);
    }
#line 1479
    return (tmp___2);
  }
#line 1481
  if ((agent->activity + id)->detail < 3UL) {
    {
#line 1482
    tmp___3 = set_errno(22);
    }
#line 1482
    return (tmp___3);
  }
#line 1484
  return ((agent->activity + id)->ddt);
}
}
#line 1507 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_dadt(Agent *agent , int fd ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1511
  if (! agent) {
    {
#line 1512
    tmp = set_errno(22);
    }
#line 1512
    return (tmp);
  }
#line 1514
  if (agent->locker) {
    {
#line 1514
    tmp___1 = (*((agent->locker)->rdlock))((agent->locker)->lock);
#line 1514
    err = tmp___1;
    }
  } else {
#line 1514
    err = 0;
  }
#line 1514
  if (err) {
    {
#line 1515
    tmp___0 = set_errno(err);
    }
#line 1515
    return (tmp___0);
  }
  {
#line 1517
  ret = agent_dadt_unlocked(agent, fd);
  }
#line 1519
  if (agent->locker) {
    {
#line 1519
    tmp___3 = (*((agent->locker)->unlock))((agent->locker)->lock);
#line 1519
    err = tmp___3;
    }
  } else {
#line 1519
    err = 0;
  }
#line 1519
  if (err) {
    {
#line 1520
    tmp___2 = set_errno(err);
    }
#line 1520
    return (tmp___2);
  }
#line 1522
  return (ret);
}
}
#line 1535 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_dadt_unlocked(Agent *agent , int fd ) 
{ 
  ssize_t id ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1541
  if (! agent) {
    {
#line 1542
    tmp = set_errno(22);
    }
#line 1542
    return (tmp);
  } else
#line 1541
  if (fd < -1) {
    {
#line 1542
    tmp = set_errno(22);
    }
#line 1542
    return (tmp);
  }
#line 1546
  if (! agent->ids) {
    {
#line 1547
    tmp___0 = set_errno(22);
    }
#line 1547
    return (tmp___0);
  } else
#line 1546
  if (! agent->reactions) {
    {
#line 1547
    tmp___0 = set_errno(22);
    }
#line 1547
    return (tmp___0);
  } else
#line 1546
  if (! agent->tempo) {
    {
#line 1547
    tmp___0 = set_errno(22);
    }
#line 1547
    return (tmp___0);
  } else
#line 1546
  if (! agent->activity) {
    {
#line 1547
    tmp___0 = set_errno(22);
    }
#line 1547
    return (tmp___0);
  } else
#line 1546
  if (agent->ids_size <= (size_t )fd) {
    {
#line 1547
    tmp___0 = set_errno(22);
    }
#line 1547
    return (tmp___0);
  }
#line 1551
  if (fd == -1) {
#line 1553
    if ((agent->tempo)->detail < 4UL) {
      {
#line 1554
      tmp___1 = set_errno(22);
      }
#line 1554
      return (tmp___1);
    }
#line 1556
    return ((agent->tempo)->dddt);
  }
#line 1561
  id = *(agent->ids + fd);
#line 1561
  if (id == -1L) {
    {
#line 1562
    tmp___2 = set_errno(22);
    }
#line 1562
    return (tmp___2);
  }
#line 1564
  if ((agent->activity + id)->detail < 4UL) {
    {
#line 1565
    tmp___3 = set_errno(22);
    }
#line 1565
    return (tmp___3);
  }
#line 1567
  return ((agent->activity + id)->dddt);
}
}
#line 1585 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
void *agent_schedule(Agent *agent , long sec , long usec , agent_action_t *action ,
                     void *arg ) 
{ 
  void *ret ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 1590
  if (! agent) {
    {
#line 1591
    tmp = set_errnull(22);
    }
#line 1591
    return (tmp);
  }
#line 1593
  if (agent->locker) {
    {
#line 1593
    tmp___1 = (*((agent->locker)->wrlock))((agent->locker)->lock);
#line 1593
    err = tmp___1;
    }
  } else {
#line 1593
    err = 0;
  }
#line 1593
  if (err) {
    {
#line 1594
    tmp___0 = set_errnull(err);
    }
#line 1594
    return (tmp___0);
  }
  {
#line 1596
  ret = agent_schedule_unlocked(agent, sec, usec, action, arg);
  }
#line 1598
  if (agent->locker) {
    {
#line 1598
    tmp___3 = (*((agent->locker)->unlock))((agent->locker)->lock);
#line 1598
    err = tmp___3;
    }
  } else {
#line 1598
    err = 0;
  }
#line 1598
  if (err) {
    {
#line 1599
    tmp___2 = set_errnull(err);
    }
#line 1599
    return (tmp___2);
  }
#line 1601
  return (ret);
}
}
#line 1614 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
static void timeval_diff(timeval *start , timeval *end , timeval *diff ) 
{ 


  {
#line 1616
  diff->tv_sec = end->tv_sec - start->tv_sec;
#line 1618
  if (end->tv_usec < start->tv_usec) {
#line 1619
    diff->tv_usec = (1000000L + end->tv_usec) - start->tv_usec;
#line 1619
    (diff->tv_sec) --;
  } else {
#line 1621
    diff->tv_usec = end->tv_usec - start->tv_usec;
  }
#line 1622
  return;
}
}
#line 1624 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
static void timeval_add(timeval *absolute , timeval *relative , timeval *result ) 
{ 


  {
#line 1626
  result->tv_sec = absolute->tv_sec + relative->tv_sec;
#line 1627
  result->tv_usec = absolute->tv_usec + relative->tv_usec;
#line 1629
  if (result->tv_usec >= 1000000L) {
#line 1630
    (result->tv_sec) ++;
#line 1630
    result->tv_usec -= 1000000L;
  }
#line 1631
  return;
}
}
#line 1633 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
static void timeval_set(timeval *tv , long tv_sec , long tv_usec ) 
{ 


  {
#line 1635
  tv->tv_sec = tv_sec;
#line 1636
  tv->tv_usec = tv_usec;
#line 1637
  return;
}
}
#line 1639 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
static void install(action_t **parent , action_t *action ) 
{ 
  void *tmp ;

  {
  {
#line 1641
  tmp = dlink_insert((void *)*parent, (void *)action);
#line 1641
  *parent = (action_t *)tmp;
#line 1642
  action->parent = parent;
  }
#line 1643
  return;
}
}
#line 1645 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
void *agent_schedule_unlocked(Agent *agent , long sec , long usec , agent_action_t *action ,
                              void *arg ) 
{ 
  action_t *event ;
  timeval now[1] ;
  timeval delta[1] ;
  timeval when[1] ;
  void *tmp ;
  timewheel_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;

  {
#line 1650
  if (! agent) {
    {
#line 1651
    tmp = set_errnull(22);
    }
#line 1651
    return (tmp);
  } else
#line 1650
  if (sec < 0L) {
    {
#line 1651
    tmp = set_errnull(22);
    }
#line 1651
    return (tmp);
  } else
#line 1650
  if (usec < 0L) {
    {
#line 1651
    tmp = set_errnull(22);
    }
#line 1651
    return (tmp);
  } else
#line 1650
  if (! action) {
    {
#line 1651
    tmp = set_errnull(22);
    }
#line 1651
    return (tmp);
  }
#line 1655
  if (! agent->timewheel) {
    {
#line 1655
    tmp___0 = timewheel_create();
#line 1655
    agent->timewheel = tmp___0;
    }
#line 1655
    if (! tmp___0) {
#line 1656
      return ((void *)0);
    }
  }
  {
#line 1660
  tmp___1 = gettimeofday((struct timeval */* __restrict  */)(now), (__timezone_ptr_t )((void *)0));
  }
#line 1660
  if (tmp___1 == -1) {
#line 1661
    return ((void *)0);
  }
#line 1663
  if (now[0].tv_sec == (agent->timewheel)->now[0].tv_sec) {
#line 1663
    tmp___2 = now[0].tv_usec < (agent->timewheel)->now[0].tv_usec;
  } else {
#line 1663
    tmp___2 = now[0].tv_sec < (agent->timewheel)->now[0].tv_sec;
  }
#line 1663
  if (tmp___2) {
#line 1664
    (agent->timewheel)->now[0] = now[0];
  }
  {
#line 1668
  tmp___3 = malloc(sizeof(action_t ));
#line 1668
  event = (action_t *)tmp___3;
  }
#line 1668
  if (! event) {
#line 1669
    return ((void *)0);
  }
  {
#line 1671
  timeval_set(delta, sec, usec);
#line 1672
  timeval_add(now, delta, when);
#line 1674
  event->when = when[0];
#line 1675
  event->action = action;
#line 1676
  event->arg = arg;
#line 1680
  timeval_diff((agent->timewheel)->now, when, delta);
#line 1682
  event->day = (size_t )(delta[0].tv_sec / 86400L);
#line 1683
  delta[0].tv_sec = (__time_t )((size_t )delta[0].tv_sec - ((event->day * 24UL) * 60UL) * 60UL);
#line 1685
  event->hour = (size_t )(delta[0].tv_sec / 3600L);
#line 1686
  delta[0].tv_sec = (__time_t )((size_t )delta[0].tv_sec - (event->hour * 60UL) * 60UL);
#line 1688
  event->minute = (size_t )(delta[0].tv_sec / 60L);
#line 1689
  delta[0].tv_sec = (__time_t )((size_t )delta[0].tv_sec - event->minute * 60UL);
#line 1691
  event->second = (size_t )delta[0].tv_sec;
#line 1693
  event->jiffy = (size_t )(delta[0].tv_usec / 10000L);
#line 1695
  tmp___4 = event->jiffy + (agent->timewheel)->jiffy;
#line 1695
  event->jiffy = tmp___4;
  }
#line 1695
  if (tmp___4 >= 100UL) {
#line 1696
    event->jiffy -= 100UL;
#line 1696
    (event->second) ++;
  }
#line 1698
  tmp___5 = event->second + (agent->timewheel)->second;
#line 1698
  event->second = tmp___5;
#line 1698
  if (tmp___5 >= 60UL) {
#line 1699
    event->second -= 60UL;
#line 1699
    (event->minute) ++;
  }
#line 1701
  tmp___6 = event->minute + (agent->timewheel)->minute;
#line 1701
  event->minute = tmp___6;
#line 1701
  if (tmp___6 >= 60UL) {
#line 1702
    event->minute -= 60UL;
#line 1702
    (event->hour) ++;
  }
#line 1704
  tmp___7 = event->hour + (agent->timewheel)->hour;
#line 1704
  event->hour = tmp___7;
#line 1704
  if (tmp___7 >= 24UL) {
#line 1705
    event->hour -= 24UL;
#line 1705
    (event->day) ++;
  }
#line 1707
  event->day += (agent->timewheel)->day;
#line 1709
  if (event->day != (agent->timewheel)->day) {
    {
#line 1710
    install(& (agent->timewheel)->days[event->day % 10UL], event);
    }
  } else
#line 1711
  if (event->hour != (agent->timewheel)->hour) {
    {
#line 1712
    install(& (agent->timewheel)->hours[event->hour], event);
    }
  } else
#line 1713
  if (event->minute != (agent->timewheel)->minute) {
    {
#line 1714
    install(& (agent->timewheel)->minutes[event->minute], event);
    }
  } else
#line 1715
  if (event->second != (agent->timewheel)->second) {
    {
#line 1716
    install(& (agent->timewheel)->seconds[event->second], event);
    }
  } else {
    {
#line 1718
    install(& (agent->timewheel)->jiffies[event->jiffy], event);
    }
  }
#line 1720
  (agent->timers) ++;
#line 1722
  return ((void *)event);
}
}
#line 1740 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_cancel(Agent *agent , void *action_id ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1744
  if (! agent) {
    {
#line 1745
    tmp = set_errno(22);
    }
#line 1745
    return (tmp);
  }
#line 1747
  if (agent->locker) {
    {
#line 1747
    tmp___1 = (*((agent->locker)->wrlock))((agent->locker)->lock);
#line 1747
    err = tmp___1;
    }
  } else {
#line 1747
    err = 0;
  }
#line 1747
  if (err) {
    {
#line 1748
    tmp___0 = set_errno(err);
    }
#line 1748
    return (tmp___0);
  }
  {
#line 1750
  ret = agent_cancel_unlocked(agent, action_id);
  }
#line 1752
  if (agent->locker) {
    {
#line 1752
    tmp___3 = (*((agent->locker)->unlock))((agent->locker)->lock);
#line 1752
    err = tmp___3;
    }
  } else {
#line 1752
    err = 0;
  }
#line 1752
  if (err) {
    {
#line 1753
    tmp___2 = set_errno(err);
    }
#line 1753
    return (tmp___2);
  }
#line 1755
  return (ret);
}
}
#line 1768 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_cancel_unlocked(Agent *agent , void *action_id ) 
{ 
  action_t *event ;
  action_t *next ;
  int tmp ;
  void *tmp___0 ;

  {
#line 1770
  event = (action_t *)action_id;
#line 1773
  if (! agent) {
    {
#line 1774
    tmp = set_errno(22);
    }
#line 1774
    return (tmp);
  } else
#line 1773
  if (! event) {
    {
#line 1774
    tmp = set_errno(22);
    }
#line 1774
    return (tmp);
  } else
#line 1773
  if (! agent->timewheel) {
    {
#line 1774
    tmp = set_errno(22);
    }
#line 1774
    return (tmp);
  } else
#line 1773
  if (! agent->timers) {
    {
#line 1774
    tmp = set_errno(22);
    }
#line 1774
    return (tmp);
  }
  {
#line 1776
  tmp___0 = dlink_remove((void *)event);
#line 1776
  next = (action_t *)tmp___0;
  }
#line 1778
  if ((unsigned long )*(event->parent) == (unsigned long )event) {
#line 1779
    *(event->parent) = next;
  }
  {
#line 1781
  free((void *)event);
#line 1783
  (agent->timers) --;
  }
#line 1785
  return (0);
}
}
#line 1809 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
static void next_day(Agent *agent ) 
{ 
  action_t *next ;
  action_t *action ;
  size_t i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1815
  (agent->timewheel)->hour = (size_t )0;
#line 1817
  ((agent->timewheel)->day) ++;
#line 1817
  if ((agent->timewheel)->day == 10UL) {
#line 1821
    (agent->timewheel)->day = (size_t )0;
#line 1823
    i = (size_t )0;
    {
#line 1823
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1823
      if (! (i < 10UL)) {
#line 1823
        goto while_break;
      }
#line 1824
      action = (agent->timewheel)->days[i];
      {
#line 1824
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1824
        if (! action) {
#line 1824
          goto while_break___0;
        }
        {
#line 1825
        action->day -= 10UL;
#line 1824
        tmp = dlink_next((void *)action);
#line 1824
        action = (action_t *)tmp;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1823
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1828
  next = (agent->timewheel)->days[(agent->timewheel)->day];
#line 1830
  action = next;
  {
#line 1830
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1830
    if (! action) {
#line 1830
      goto while_break___1;
    }
#line 1832
    if (action->day == (agent->timewheel)->day) {
      {
#line 1834
      tmp___0 = dlink_remove((void *)action);
#line 1834
      next = (action_t *)tmp___0;
      }
#line 1836
      if ((unsigned long )*(action->parent) == (unsigned long )action) {
#line 1837
        *(action->parent) = next;
      }
      {
#line 1839
      install(& (agent->timewheel)->hours[action->hour], action);
      }
    } else {
      {
#line 1842
      tmp___1 = dlink_next((void *)action);
#line 1842
      next = (action_t *)tmp___1;
      }
    }
#line 1830
    action = next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1844
  return;
}
}
#line 1846 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
static void next_hour(Agent *agent ) 
{ 
  action_t *next ;
  action_t *action ;
  void *tmp ;

  {
#line 1852
  (agent->timewheel)->minute = (size_t )0;
#line 1854
  ((agent->timewheel)->hour) ++;
#line 1854
  if ((agent->timewheel)->hour == 24UL) {
    {
#line 1855
    next_day(agent);
    }
  }
#line 1857
  next = (agent->timewheel)->hours[(agent->timewheel)->hour];
#line 1858
  (agent->timewheel)->hours[(agent->timewheel)->hour] = (action_t *)((void *)0);
#line 1860
  action = next;
  {
#line 1860
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1860
    if (! action) {
#line 1860
      goto while_break;
    }
    {
#line 1862
    tmp = dlink_remove((void *)action);
#line 1862
    next = (action_t *)tmp;
#line 1863
    install(& (agent->timewheel)->minutes[action->minute], action);
#line 1860
    action = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1865
  return;
}
}
#line 1867 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
static void next_minute(Agent *agent ) 
{ 
  action_t *next ;
  action_t *action ;
  void *tmp ;

  {
#line 1873
  (agent->timewheel)->second = (size_t )0;
#line 1875
  ((agent->timewheel)->minute) ++;
#line 1875
  if ((agent->timewheel)->minute == 60UL) {
    {
#line 1876
    next_hour(agent);
    }
  }
#line 1878
  next = (agent->timewheel)->minutes[(agent->timewheel)->minute];
#line 1879
  (agent->timewheel)->minutes[(agent->timewheel)->minute] = (action_t *)((void *)0);
#line 1881
  action = next;
  {
#line 1881
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1881
    if (! action) {
#line 1881
      goto while_break;
    }
    {
#line 1883
    tmp = dlink_remove((void *)action);
#line 1883
    next = (action_t *)tmp;
#line 1884
    install(& (agent->timewheel)->seconds[action->second], action);
#line 1881
    action = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1886
  return;
}
}
#line 1888 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
static void next_second(Agent *agent ) 
{ 
  action_t *next ;
  action_t *action ;
  void *tmp ;

  {
#line 1894
  (agent->timewheel)->jiffy = (size_t )0;
#line 1896
  ((agent->timewheel)->second) ++;
#line 1896
  if ((agent->timewheel)->second == 60UL) {
    {
#line 1897
    next_minute(agent);
    }
  }
#line 1899
  next = (agent->timewheel)->seconds[(agent->timewheel)->second];
#line 1900
  (agent->timewheel)->seconds[(agent->timewheel)->second] = (action_t *)((void *)0);
#line 1902
  action = next;
  {
#line 1902
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1902
    if (! action) {
#line 1902
      goto while_break;
    }
    {
#line 1904
    tmp = dlink_remove((void *)action);
#line 1904
    next = (action_t *)tmp;
#line 1905
    install(& (agent->timewheel)->jiffies[action->jiffy], action);
#line 1902
    action = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1907
  return;
}
}
#line 1909 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
static int timeout(Agent *agent ) 
{ 
  int i ;

  {
#line 1913
  if (agent->timers == 0UL) {
#line 1914
    return (-1);
  }
#line 1918
  i = (int )(agent->timewheel)->jiffy;
  {
#line 1918
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1918
    if (! (i < 100)) {
#line 1918
      goto while_break;
    }
#line 1919
    if ((agent->timewheel)->jiffies[i]) {
#line 1920
      goto while_break;
    }
#line 1918
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1924
  return ((int )(((size_t )i - (agent->timewheel)->jiffy) * 10UL));
}
}
#line 1927 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
static int act(agent_action_t *action , Agent *agent , void *arg ) 
{ 
  int err ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1931
  if (agent->locker) {
    {
#line 1931
    tmp___0 = (*((agent->locker)->unlock))((agent->locker)->lock);
#line 1931
    err = tmp___0;
    }
  } else {
#line 1931
    err = 0;
  }
#line 1931
  if (err) {
    {
#line 1932
    tmp = set_errno(err);
    }
#line 1932
    return (tmp);
  }
  {
#line 1934
  ret = (*action)(agent, arg);
  }
#line 1936
  if (agent->locker) {
    {
#line 1936
    tmp___2 = (*((agent->locker)->wrlock))((agent->locker)->lock);
#line 1936
    err = tmp___2;
    }
  } else {
#line 1936
    err = 0;
  }
#line 1936
  if (err) {
    {
#line 1937
    tmp___1 = set_errno(err);
    }
#line 1937
    return (tmp___1);
  }
#line 1939
  return (ret);
}
}
#line 1942 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
static int react(agent_reaction_t *reaction , Agent *agent , int fd , int revents ,
                 void *arg ) 
{ 
  int err ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1946
  if (agent->locker) {
    {
#line 1946
    tmp___0 = (*((agent->locker)->unlock))((agent->locker)->lock);
#line 1946
    err = tmp___0;
    }
  } else {
#line 1946
    err = 0;
  }
#line 1946
  if (err) {
    {
#line 1947
    tmp = set_errno(err);
    }
#line 1947
    return (tmp);
  }
  {
#line 1949
  ret = (*reaction)(agent, fd, revents, arg);
  }
#line 1951
  if (agent->locker) {
    {
#line 1951
    tmp___2 = (*((agent->locker)->wrlock))((agent->locker)->lock);
#line 1951
    err = tmp___2;
    }
  } else {
#line 1951
    err = 0;
  }
#line 1951
  if (err) {
    {
#line 1952
    tmp___1 = set_errno(err);
    }
#line 1952
    return (tmp___1);
  }
#line 1954
  return (ret);
}
}
#line 1957 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
static int expire(Agent *agent ) 
{ 
  action_t *event ;
  agent_action_t *action ;
  void *arg ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1961
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1961
    event = (agent->timewheel)->jiffies[(agent->timewheel)->jiffy];
#line 1961
    if (! event) {
#line 1961
      goto while_break;
    }
    {
#line 1963
    action = event->action;
#line 1964
    arg = event->arg;
#line 1966
    tmp = agent_cancel_unlocked(agent, (void *)event);
    }
#line 1966
    if (tmp == -1) {
#line 1967
      return (-1);
    }
    {
#line 1969
    tmp___0 = act(action, agent, arg);
    }
#line 1969
    if (tmp___0 == -1) {
#line 1970
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1973
  return (0);
}
}
#line 1976 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
static int update(Agent *agent ) 
{ 
  timeval now[1] ;
  timeval delta[1] ;
  int check ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;

  {
#line 1979
  check = 1;
  {
#line 1981
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1981
    if (! check) {
#line 1981
      goto while_break;
    }
    {
#line 1983
    check = 0;
#line 1985
    tmp = gettimeofday((struct timeval */* __restrict  */)(now), (__timezone_ptr_t )((void *)0));
    }
#line 1985
    if (tmp == -1) {
#line 1986
      return (-1);
    }
#line 1988
    if (now[0].tv_sec == (agent->timewheel)->now[0].tv_sec) {
#line 1988
      tmp___0 = now[0].tv_usec < (agent->timewheel)->now[0].tv_usec;
    } else {
#line 1988
      tmp___0 = now[0].tv_sec < (agent->timewheel)->now[0].tv_sec;
    }
#line 1988
    if (tmp___0) {
#line 1989
      (agent->timewheel)->now[0] = now[0];
    }
    {
#line 1991
    timeval_diff((agent->timewheel)->now, now, delta);
#line 1992
    delta[0].tv_usec /= 10000L;
#line 1993
    (agent->timewheel)->now[0] = now[0];
    }
    {
#line 1995
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1995
      if (! delta[0].tv_sec) {
#line 1995
        if (! delta[0].tv_usec) {
#line 1995
          goto while_break___0;
        }
      }
#line 1997
      if (delta[0].tv_usec == 0L) {
#line 1998
        (delta[0].tv_sec) --;
#line 1998
        delta[0].tv_usec = (__suseconds_t )100;
      }
#line 1999
      (delta[0].tv_usec) --;
#line 2001
      ((agent->timewheel)->jiffy) ++;
#line 2001
      if ((agent->timewheel)->jiffy == 100UL) {
        {
#line 2002
        next_second(agent);
        }
      }
#line 2004
      if ((agent->timewheel)->jiffies[(agent->timewheel)->jiffy]) {
        {
#line 2006
        check ++;
#line 2008
        tmp___1 = expire(agent);
        }
#line 2008
        if (tmp___1 == -1) {
#line 2009
          return (-1);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2014
  return (0);
}
}
#line 2017 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
static void measure(Agent *agent , int fd , timeval *now ) 
{ 
  activity_t *activity ;
  timeval delta[1] ;
  int msec ;
  int prev_dt ;
  int prev_ddt ;
  void *__cil_tmp9 ;

  {
#line 2023
  if (fd == -1) {
#line 2023
    activity = agent->tempo;
  } else {
#line 2023
    activity = agent->activity + *(agent->ids + fd);
  }
  {
#line 2027
  if (activity->detail == 0UL) {
#line 2027
    goto case_0;
  }
#line 2032
  if (activity->detail == 1UL) {
#line 2032
    goto case_1;
  }
#line 2040
  if (activity->detail == 2UL) {
#line 2040
    goto case_2;
  }
#line 2051
  if (activity->detail == 4UL) {
#line 2051
    goto case_4;
  }
#line 2051
  if (activity->detail == 3UL) {
#line 2051
    goto case_4;
  }
#line 2025
  goto switch_break;
  case_0: /* CIL Label */ 
#line 2028
  activity->since = *now;
#line 2029
  activity->detail = (size_t )1;
#line 2030
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 2033
  timeval_diff(& activity->since, now, delta);
#line 2034
  msec = (int )(delta[0].tv_sec * 1000L + delta[0].tv_usec / 1000L);
#line 2035
  activity->dt = msec;
#line 2036
  activity->since = *now;
#line 2037
  activity->detail = (size_t )2;
  }
#line 2038
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2041
  timeval_diff(& activity->since, now, delta);
#line 2042
  msec = (int )(delta[0].tv_sec * 1000L + delta[0].tv_usec / 1000L);
#line 2043
  prev_dt = activity->dt;
#line 2044
  activity->dt = msec;
#line 2045
  activity->ddt = activity->dt - prev_dt;
#line 2046
  activity->since = *now;
#line 2047
  activity->detail = (size_t )3;
  }
#line 2048
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 2052
  timeval_diff(& activity->since, now, delta);
#line 2053
  msec = (int )(delta[0].tv_sec * 1000L + delta[0].tv_usec / 1000L);
#line 2054
  prev_dt = activity->dt;
#line 2055
  activity->dt = msec;
#line 2056
  prev_ddt = activity->ddt;
#line 2057
  activity->ddt = activity->dt - prev_dt;
#line 2058
  activity->dddt = activity->ddt - prev_ddt;
#line 2059
  activity->since = *now;
#line 2060
  activity->detail = (size_t )4;
  }
#line 2061
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2063
  return;
}
}
#line 2065 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
static int translate(int revents ) 
{ 
  int ret ;

  {
#line 2067
  ret = 0;
#line 2069
  if (revents & 1) {
#line 2070
    ret |= 4;
  }
#line 2072
  if (revents & 2) {
#line 2073
    ret |= 1;
  }
#line 2075
  if (revents & 4) {
#line 2076
    ret |= 2;
  }
#line 2078
  return (ret);
}
}
#line 2087 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
static int agent_start_unlocked(Agent *agent ) 
{ 
  int tmp ;
  int tmp___0 ;
  int nfds ;
  int timo ;
  size_t i ;
  int *tmp___1 ;
  int tmp___2 ;
  timeval now[1] ;
  int tmp___3 ;
  agent_reaction_t *reaction ;
  int fd ;
  int revents ;
  int tmp___4 ;
  void *arg ;
  int tmp___5 ;
  timeval delta[1] ;
  timeval result[1] ;
  size_t tmp___6 ;
  int tmp___7 ;
  timeval tv[1] ;
  timeval *to ;
  fd_set readset[1] ;
  fd_set *rfds ;
  fd_set writeset[1] ;
  fd_set *wfds ;
  fd_set exceptset[1] ;
  fd_set *xfds ;
  timeval now___0[1] ;
  int tmp___8 ;
  int fd___0 ;
  int revents___0 ;
  agent_reaction_t *reaction___0 ;
  void *arg___0 ;
  int tmp___9 ;
  timeval delta___0[1] ;
  timeval result___0[1] ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;

  {
#line 2089
  if (! agent) {
    {
#line 2090
    tmp = set_errno(22);
    }
#line 2090
    return (tmp);
  } else
#line 2089
  if (agent->state != 0) {
    {
#line 2090
    tmp = set_errno(22);
    }
#line 2090
    return (tmp);
  }
#line 2094
  agent->state = 1;
#line 2098
  if (agent->timers) {
    {
#line 2098
    tmp___0 = update(agent);
    }
#line 2098
    if (tmp___0 == -1) {
#line 2099
      return (-1);
    }
  }
  {
#line 2101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2101
    if (agent->length) {
#line 2101
      goto _L;
    } else
#line 2101
    if (agent->timers) {
      _L: /* CIL Label */ 
#line 2101
      if (! (agent->state != 2)) {
#line 2101
        goto while_break;
      }
    } else {
#line 2101
      goto while_break;
    }
    {
#line 2108
    timo = timeout(agent);
    }
#line 2111
    if (agent->method == 0) {
#line 2118
      if (timo > 10) {
#line 2118
        tmp___2 = timo - 10;
      } else {
#line 2118
        tmp___2 = timo;
      }
      {
#line 2118
      nfds = poll(agent->u.pfds, agent->length, tmp___2);
      }
#line 2118
      if (nfds == -1) {
        {
#line 2121
        tmp___1 = __errno_location();
        }
#line 2121
        if (*tmp___1 == 4) {
#line 2122
          agent->state = 0;
        }
#line 2124
        return (-1);
      }
#line 2127
      if (nfds) {
        {
#line 2131
        tmp___3 = gettimeofday((struct timeval */* __restrict  */)(now), (__timezone_ptr_t )((void *)0));
        }
#line 2131
        if (tmp___3 == -1) {
#line 2132
          return (-1);
        }
#line 2134
        if (agent->tempo) {
          {
#line 2135
          measure(agent, -1, now);
          }
        }
#line 2137
        i = (size_t )0;
        {
#line 2137
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2137
          if (nfds) {
#line 2137
            if (! (i < agent->length)) {
#line 2137
              goto while_break___0;
            }
          } else {
#line 2137
            goto while_break___0;
          }
#line 2139
          if ((agent->u.pfds + i)->revents) {
            {
#line 2141
            reaction = (agent->reactions + i)->reaction;
#line 2142
            fd = (agent->reactions + i)->fd;
#line 2143
            tmp___4 = translate((int )(agent->u.pfds + i)->revents);
#line 2143
            revents = tmp___4;
#line 2144
            arg = (agent->reactions + i)->arg;
#line 2146
            (agent->u.pfds + i)->revents = (short)0;
            }
#line 2148
            if (agent->tempo) {
              {
#line 2149
              measure(agent, fd, now);
              }
            }
            {
#line 2151
            tmp___5 = react(reaction, agent, fd, revents, arg);
            }
#line 2151
            if (tmp___5 == -1) {
#line 2152
              return (-1);
            }
#line 2154
            nfds --;
          }
#line 2137
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 2162
        timeval_set(delta, 0L, (long )(timo * 1000));
#line 2163
        timeval_add((agent->timewheel)->now, delta, result);
#line 2164
        (agent->timewheel)->now[0] = result[0];
#line 2166
        tmp___6 = (agent->timewheel)->jiffy + (size_t )(timo / 10);
#line 2166
        (agent->timewheel)->jiffy = tmp___6;
        }
#line 2166
        if (tmp___6 == 100UL) {
          {
#line 2167
          next_second(agent);
          }
        }
        {
#line 2169
        tmp___7 = expire(agent);
        }
#line 2169
        if (tmp___7 == -1) {
#line 2170
          return (-1);
        }
      }
    } else {
#line 2177
      rfds = (fd_set *)((void *)0);
#line 2178
      wfds = (fd_set *)((void *)0);
#line 2179
      xfds = (fd_set *)((void *)0);
#line 2181
      if (agent->u.s.rfds) {
#line 2182
        rfds = readset;
#line 2182
        *rfds = *(agent->u.s.rfds);
      }
#line 2184
      if (agent->u.s.wfds) {
#line 2185
        wfds = writeset;
#line 2185
        *wfds = *(agent->u.s.wfds);
      }
#line 2187
      if (agent->u.s.xfds) {
#line 2188
        xfds = exceptset;
#line 2188
        *xfds = *(agent->u.s.xfds);
      }
#line 2190
      if (timo == -1) {
#line 2191
        to = (timeval *)((void *)0);
      } else {
#line 2194
        tv[0].tv_sec = (__time_t )(timo / 1000);
#line 2195
        tv[0].tv_usec = (__suseconds_t )((timo % 1000) * 1000);
#line 2196
        to = tv;
      }
      {
#line 2199
      nfds = select((int )agent->ids_size, (fd_set */* __restrict  */)rfds, (fd_set */* __restrict  */)wfds,
                    (fd_set */* __restrict  */)xfds, (struct timeval */* __restrict  */)to);
      }
#line 2199
      if (nfds == -1) {
#line 2200
        return (-1);
      }
#line 2202
      if (nfds) {
        {
#line 2206
        tmp___8 = gettimeofday((struct timeval */* __restrict  */)(now___0), (__timezone_ptr_t )((void *)0));
        }
#line 2206
        if (tmp___8 == -1) {
#line 2207
          return (-1);
        }
#line 2209
        if (agent->tempo) {
          {
#line 2210
          measure(agent, -1, now___0);
          }
        }
#line 2212
        i = (size_t )0;
        {
#line 2212
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2212
          if (nfds) {
#line 2212
            if (! (i < agent->length)) {
#line 2212
              goto while_break___1;
            }
          } else {
#line 2212
            goto while_break___1;
          }
#line 2214
          fd___0 = (agent->reactions + i)->fd;
#line 2215
          revents___0 = 0;
#line 2217
          if (rfds) {
#line 2217
            if ((rfds->fds_bits[fd___0 / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << fd___0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 2218
              revents___0 |= 4;
            }
          }
#line 2220
          if (wfds) {
#line 2220
            if ((wfds->fds_bits[fd___0 / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << fd___0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 2221
              revents___0 |= 2;
            }
          }
#line 2223
          if (xfds) {
#line 2223
            if ((xfds->fds_bits[fd___0 / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << fd___0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 2224
              revents___0 |= 1;
            }
          }
#line 2226
          if (revents___0) {
#line 2228
            reaction___0 = (agent->reactions + i)->reaction;
#line 2229
            arg___0 = (agent->reactions + i)->arg;
#line 2231
            if (agent->tempo) {
              {
#line 2232
              measure(agent, fd___0, now___0);
              }
            }
            {
#line 2234
            tmp___9 = react(reaction___0, agent, fd___0, revents___0, arg___0);
            }
#line 2234
            if (tmp___9 == -1) {
#line 2235
              return (-1);
            }
#line 2237
            nfds --;
          }
#line 2212
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
        {
#line 2245
        timeval_set(delta___0, 0L, (long )(timo * 1000));
#line 2246
        timeval_add((agent->timewheel)->now, delta___0, result___0);
#line 2247
        (agent->timewheel)->now[0] = result___0[0];
#line 2249
        tmp___10 = (agent->timewheel)->jiffy + (size_t )(timo / 10);
#line 2249
        (agent->timewheel)->jiffy = tmp___10;
        }
#line 2249
        if (tmp___10 == 100UL) {
          {
#line 2250
          next_second(agent);
          }
        }
        {
#line 2252
        tmp___11 = expire(agent);
        }
#line 2252
        if (tmp___11 == -1) {
#line 2253
          return (-1);
        }
      }
    }
#line 2259
    if (agent->timers) {
      {
#line 2259
      tmp___12 = update(agent);
      }
#line 2259
      if (tmp___12 == -1) {
#line 2260
        return (-1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2263
  agent->state = 0;
#line 2265
  return (0);
}
}
#line 2270 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_start(Agent *agent ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2274
  if (! agent) {
    {
#line 2275
    tmp = set_errno(22);
    }
#line 2275
    return (tmp);
  }
#line 2277
  if (agent->locker) {
    {
#line 2277
    tmp___1 = (*((agent->locker)->wrlock))((agent->locker)->lock);
#line 2277
    err = tmp___1;
    }
  } else {
#line 2277
    err = 0;
  }
#line 2277
  if (err) {
    {
#line 2278
    tmp___0 = set_errno(err);
    }
#line 2278
    return (tmp___0);
  }
  {
#line 2280
  ret = agent_start_unlocked(agent);
  }
#line 2282
  if (agent->locker) {
    {
#line 2282
    tmp___3 = (*((agent->locker)->unlock))((agent->locker)->lock);
#line 2282
    err = tmp___3;
    }
  } else {
#line 2282
    err = 0;
  }
#line 2282
  if (err) {
    {
#line 2283
    tmp___2 = set_errno(err);
    }
#line 2283
    return (tmp___2);
  }
#line 2285
  return (ret);
}
}
#line 2302 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
static int agent_stop_unlocked(Agent *agent ) 
{ 
  int tmp ;

  {
#line 2304
  if (! agent) {
    {
#line 2305
    tmp = set_errno(22);
    }
#line 2305
    return (tmp);
  } else
#line 2304
  if (agent->state != 1) {
    {
#line 2305
    tmp = set_errno(22);
    }
#line 2305
    return (tmp);
  }
#line 2307
  agent->state = 2;
#line 2309
  return (0);
}
}
#line 2312 "/home/jkwonk/work/benchmark/daemon-0.6.4/libslack/agent.c"
int agent_stop(Agent *agent ) 
{ 
  int ret ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2316
  if (! agent) {
    {
#line 2317
    tmp = set_errno(22);
    }
#line 2317
    return (tmp);
  }
#line 2319
  if (agent->locker) {
    {
#line 2319
    tmp___1 = (*((agent->locker)->wrlock))((agent->locker)->lock);
#line 2319
    err = tmp___1;
    }
  } else {
#line 2319
    err = 0;
  }
#line 2319
  if (err) {
    {
#line 2320
    tmp___0 = set_errno(err);
    }
#line 2320
    return (tmp___0);
  }
  {
#line 2322
  ret = agent_stop_unlocked(agent);
  }
#line 2324
  if (agent->locker) {
    {
#line 2324
    tmp___3 = (*((agent->locker)->unlock))((agent->locker)->lock);
#line 2324
    err = tmp___3;
    }
  } else {
#line 2324
    err = 0;
  }
#line 2324
  if (err) {
    {
#line 2325
    tmp___2 = set_errno(err);
    }
#line 2325
    return (tmp___2);
  }
#line 2327
  return (ret);
}
}
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 519 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 288 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 944
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chroot)(char const   *__path ) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 104 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 110
extern struct group *getgrnam(char const   *__name ) ;
#line 745 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static struct __anonstruct_g_70___0 g___3  = 
#line 745 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
     {0, (char **)((void *)0), (char **)((void *)0), (char *)((void *)0), (char *)((void *)0),
    (char *)((void *)0), (char *)((void *)0), (char *)((void *)0), {(char)0}, {(char)0},
    (char *)((void *)0), (char *)((void *)0), (char *)((void *)0), (mode_t )((128 >> 3) | ((128 >> 3) >> 3)),
    0, (uid_t )0, (uid_t )0, (gid_t )0, (List *)((void *)0), (char **)((void *)0),
    0, 0, 300, 5, 300, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (char *)((void *)0), (char *)((void *)0),
    (char *)((void *)0), (char *)((void *)0), 0, 0, (3 << 3) | 3, (3 << 3) | 7, -1,
    -1, (char *)((void *)0), 0, 0, -1, -1, -1, -1, {(char)0}, (size_t )64, 0, 0, 0,
    (time_t )0, 0, 0, 0, 0, {(tcflag_t )0, 0U, 0U, 0U, (unsigned char)0, {(unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0,
                                                                          (unsigned char)0},
                             0U, 0U}, {(unsigned short)0, (unsigned short)0, (unsigned short)0,
                                       (unsigned short)0}, 0, 0, 0};
#line 902 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void handle_name_option(char const   *spec ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 904
  debugf((size_t )1, "handle_name_option(spec = %s)", spec);
  }
#line 906
  if (g___3.done_config) {
#line 907
    return;
  }
#line 909
  if (g___3.done_name) {
    {
#line 910
    prog_usage_msg("Misplaced option: --name=%s in config file (must be on command line)",
                   spec);
    }
  }
  {
#line 912
  tmp = strspn(spec, "-._abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");
#line 912
  tmp___0 = strlen(spec);
  }
#line 912
  if (tmp != tmp___0) {
    {
#line 913
    prog_usage_msg("Invalid --name argument: \'%s\' (Must consist entirely of [-._a-zA-Z0-9])",
                   spec);
    }
  }
#line 915
  g___3.name = (char *)spec;
#line 916
  return;
}
}
#line 926 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void handle_pidfiles_option(char const   *spec ) 
{ 
  struct stat status[1] ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp7 ;
  int __cil_tmp8 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 930
  debugf((size_t )1, "handle_pidfiles_option(spec = %s)", spec);
#line 932
  tmp = strspn(spec, "-._abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789/");
#line 932
  tmp___0 = strlen(spec);
  }
#line 932
  if (tmp != tmp___0) {
    {
#line 933
    prog_usage_msg("Invalid --pidfiles argument: \'%s\' (Must consist entirely of [-._a-zA-Z0-9/])",
                   spec);
    }
  }
#line 935
  if ((int const   )*spec != 47) {
    {
#line 936
    prog_usage_msg("Invalid --pidfiles argument: \'%s\' (Must be an absolute directory path)",
                   spec);
    }
  }
  {
#line 938
  tmp___1 = stat((char const   */* __restrict  */)spec, (struct stat */* __restrict  */)(status));
  }
#line 938
  if (tmp___1 == -1) {
    {
#line 939
    prog_usage_msg("Invalid --pidfiles argument: \'%s\' (Directory does not exist)",
                   spec);
    }
  } else
#line 938
  if (! ((status[0].st_mode & 61440U) == 16384U)) {
    {
#line 939
    prog_usage_msg("Invalid --pidfiles argument: \'%s\' (Directory does not exist)",
                   spec);
    }
  }
#line 941
  if (! g___3.running) {
    {
#line 941
    tmp___2 = access(spec, 2);
    }
#line 941
    if (tmp___2 == -1) {
      {
#line 942
      prog_usage_msg("Invalid --pidfiles argument: \'%s\' (Directory is not writable)",
                     spec);
      }
    }
  }
#line 944
  g___3.pidfiles = (char *)spec;
#line 945
  return;
}
}
#line 955 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void handle_pidfile_option(char const   *spec ) 
{ 
  struct stat status[1] ;
  char *buf ;
  char *end ;
  size_t size ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp12 ;
  int __cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 961
  debugf((size_t )1, "handle_pidfile_option(spec = %s)", spec);
#line 963
  tmp = strspn(spec, "-._abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789/");
#line 963
  tmp___0 = strlen(spec);
  }
#line 963
  if (tmp != tmp___0) {
    {
#line 964
    prog_usage_msg("Invalid --pidfile argument: \'%s\' (Must consist entirely of [-._a-zA-Z0-9/])",
                   spec);
    }
  }
#line 966
  if ((int const   )*spec != 47) {
    {
#line 967
    prog_usage_msg("Invalid --pidfile argument: \'%s\' (Must be an absolute file path)",
                   spec);
    }
  } else {
    {
#line 966
    tmp___1 = stat((char const   */* __restrict  */)spec, (struct stat */* __restrict  */)(status));
    }
#line 966
    if (tmp___1 == 0) {
#line 966
      if ((status[0].st_mode & 61440U) == 16384U) {
        {
#line 967
        prog_usage_msg("Invalid --pidfile argument: \'%s\' (Must be an absolute file path)",
                       spec);
        }
      }
    }
  }
  {
#line 969
  end = strrchr(spec, '/');
#line 969
  size = (size_t )((end - (char *)spec) + 1L);
  }
#line 969
  if (size == 1UL) {
#line 970
    size ++;
  }
  {
#line 972
  tmp___2 = malloc(size * sizeof(char ));
#line 972
  buf = (char *)tmp___2;
  }
#line 972
  if (! buf) {
    {
#line 973
    fatalsys("out of memory");
    }
  }
  {
#line 975
  snprintf((char */* __restrict  */)buf, size, (char const   */* __restrict  */)"%.*s",
           (int )size - 1, spec);
#line 977
  tmp___3 = stat((char const   */* __restrict  */)buf, (struct stat */* __restrict  */)(status));
  }
#line 977
  if (tmp___3 == -1) {
    {
#line 978
    prog_usage_msg("Invalid --pidfile argument: \'%s\' (Parent directory does not exist)",
                   spec);
    }
  } else
#line 977
  if (! ((status[0].st_mode & 61440U) == 16384U)) {
    {
#line 978
    prog_usage_msg("Invalid --pidfile argument: \'%s\' (Parent directory does not exist)",
                   spec);
    }
  }
#line 980
  if (! g___3.running) {
    {
#line 980
    tmp___4 = access((char const   *)buf, 2);
    }
#line 980
    if (tmp___4 == -1) {
      {
#line 981
      prog_usage_msg("Invalid --pidfile argument: \'%s\' (Parent directory is not writable)",
                     spec);
      }
    }
  }
#line 983
  g___3.pidfile = (char *)spec;
#line 984
  return;
}
}
#line 994 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void handle_user_option(char *spec ) 
{ 
  struct passwd *pwd ;
  struct group *grp ;
  char **member ;
  char *pos ;
  __uid_t tmp ;
  __uid_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 1001
  debugf((size_t )1, "handle_user_option(spec = %s)", spec);
  }
#line 1003
  if (g___3.done_config) {
#line 1004
    return;
  }
#line 1006
  if (g___3.done_user) {
    {
#line 1007
    prog_usage_msg("Misplaced option: --user=%s in config file (must be on command line)",
                   spec);
    }
  }
  {
#line 1009
  tmp = getuid();
  }
#line 1009
  if (tmp) {
    {
#line 1010
    prog_usage_msg("Invalid option: --user (only works for root)");
    }
  } else {
    {
#line 1009
    tmp___0 = geteuid();
    }
#line 1009
    if (tmp___0) {
      {
#line 1010
      prog_usage_msg("Invalid option: --user (only works for root)");
      }
    }
  }
  {
#line 1012
  pos = strchr((char const   *)spec, ':');
  }
#line 1012
  if (pos) {
#line 1012
    goto _L;
  } else {
    {
#line 1012
    pos = strchr((char const   *)spec, '.');
    }
#line 1012
    if (pos) {
      _L: /* CIL Label */ 
#line 1014
      if ((unsigned long )pos > (unsigned long )spec) {
        {
#line 1015
        g___3.user = g___3.userbuf;
#line 1015
        snprintf((char */* __restrict  */)g___3.user, (size_t )8192, (char const   */* __restrict  */)"%*.*s",
                 (int )(pos - spec), (int )(pos - spec), spec);
        }
      }
#line 1016
      pos ++;
#line 1016
      if (*pos) {
        {
#line 1017
        g___3.group = g___3.groupbuf;
#line 1017
        snprintf((char */* __restrict  */)g___3.group, (size_t )8192, (char const   */* __restrict  */)"%s",
                 pos);
        }
      }
    } else {
      {
#line 1021
      g___3.user = g___3.userbuf;
#line 1021
      snprintf((char */* __restrict  */)g___3.user, (size_t )8192, (char const   */* __restrict  */)"%s",
               spec);
      }
    }
  }
#line 1024
  g___3.init_groups = (unsigned long )g___3.group == (unsigned long )((void *)0);
#line 1026
  if (! g___3.user) {
    {
#line 1027
    prog_usage_msg("Invalid --user argument: \'%s\' (no user name)", spec);
    }
  }
  {
#line 1029
  pwd = getpwnam((char const   *)g___3.user);
  }
#line 1029
  if (! pwd) {
    {
#line 1030
    prog_usage_msg("Invalid --user argument: \'%s\' (unknown user %s)", spec, g___3.user);
    }
  }
#line 1032
  g___3.uid = pwd->pw_uid;
#line 1033
  g___3.gid = pwd->pw_gid;
#line 1035
  if (g___3.group) {
    {
#line 1037
    grp = getgrnam((char const   *)g___3.group);
    }
#line 1037
    if (! grp) {
      {
#line 1038
      prog_usage_msg("Invalid --user argument: \'%s\' (unknown group %s)", spec, g___3.group);
      }
    }
#line 1040
    if (grp->gr_gid != pwd->pw_gid) {
#line 1042
      member = grp->gr_mem;
      {
#line 1042
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1042
        if (! *member) {
#line 1042
          goto while_break;
        }
        {
#line 1043
        tmp___1 = strcmp((char const   *)*member, (char const   *)g___3.user);
        }
#line 1043
        if (! tmp___1) {
#line 1044
          goto while_break;
        }
#line 1042
        member ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1046
      if (! *member) {
        {
#line 1047
        prog_usage_msg("Invalid --user argument: \'%s\' (user %s is not in group %s)",
                       spec, g___3.user, g___3.group);
        }
      }
    }
#line 1050
    g___3.gid = grp->gr_gid;
  }
#line 1052
  return;
}
}
#line 1062 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void handle_chroot_option(char const   *spec ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 1064
  debugf((size_t )1, "handle_chroot_option(spec = %s)", spec);
  }
#line 1066
  if (g___3.done_config) {
#line 1067
    return;
  }
#line 1069
  if (g___3.done_chroot) {
    {
#line 1070
    prog_usage_msg("Misplaced option: --chroot=%s in config file (must be on command line)",
                   spec);
    }
  }
#line 1072
  g___3.chroot = (char *)spec;
#line 1073
  return;
}
}
#line 1083 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void handle_umask_option(char const   *spec ) 
{ 
  char *end ;
  long val ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1088
  debugf((size_t )1, "handle_umask_option(spec = %s)", spec);
#line 1090
  val = strtol((char const   */* __restrict  */)spec, (char **/* __restrict  */)(& end),
               8);
  }
#line 1092
  if ((unsigned long )end == (unsigned long )spec) {
    {
#line 1093
    prog_usage_msg("Invalid --umask argument: \'%s\' (must be a valid octal mode)",
                   spec);
    }
  } else
#line 1092
  if (*end) {
    {
#line 1093
    prog_usage_msg("Invalid --umask argument: \'%s\' (must be a valid octal mode)",
                   spec);
    }
  } else
#line 1092
  if (val < 0L) {
    {
#line 1093
    prog_usage_msg("Invalid --umask argument: \'%s\' (must be a valid octal mode)",
                   spec);
    }
  } else
#line 1092
  if (val > 511L) {
    {
#line 1093
    prog_usage_msg("Invalid --umask argument: \'%s\' (must be a valid octal mode)",
                   spec);
    }
  }
#line 1095
  g___3.umask = (mode_t )val;
#line 1096
  return;
}
}
#line 1106 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void handle_env_option(char const   *var ) 
{ 
  List *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 1108
  debugf((size_t )1, "handle_env_option(spec = %s)", var);
  }
#line 1110
  if ((unsigned long )g___3.env == (unsigned long )((void *)0)) {
    {
#line 1110
    g___3.env = list_create((list_release_t *)((void *)0));
    }
#line 1110
    if (! g___3.env) {
      {
#line 1111
      fatalsys("failed to create environment list");
      }
    }
  }
  {
#line 1113
  tmp = list_append(g___3.env, (void *)var);
  }
#line 1113
  if (! tmp) {
    {
#line 1114
    fatalsys("failed to add \'%s\' to environment list", var);
    }
  }
#line 1115
  return;
}
}
#line 1126 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void handle_inherit_option(void) 
{ 
  char **env ;
  List *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 1130
  debugf((size_t )1, "handle_inherit_option()");
  }
#line 1132
  if ((unsigned long )g___3.env == (unsigned long )((void *)0)) {
    {
#line 1132
    g___3.env = list_create((list_release_t *)((void *)0));
    }
#line 1132
    if (! g___3.env) {
      {
#line 1133
      fatalsys("failed to create environment list");
      }
    }
  }
#line 1135
  env = environ;
  {
#line 1135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1135
    if (! *env) {
#line 1135
      goto while_break;
    }
    {
#line 1136
    tmp = list_append(g___3.env, (void *)*env);
    }
#line 1136
    if (! tmp) {
      {
#line 1137
      fatalsys("failed to add \'%s\' to environment list", env);
      }
    }
#line 1135
    env ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1139
  g___3.inherit = 1;
#line 1140
  return;
}
}
#line 1150 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void handle_acceptable_option(int acceptable ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 1152
  debugf((size_t )1, "handle_acceptable_option(acceptable = %d)", acceptable);
  }
#line 1154
  if (! g___3.idiot) {
#line 1154
    if (acceptable < 10) {
      {
#line 1155
      prog_usage_msg("Invalid --acceptable argument: %d (less than %d)\n", acceptable,
                     10);
      }
    }
  }
#line 1157
  g___3.acceptable = acceptable;
#line 1158
  return;
}
}
#line 1168 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void handle_attempts_option(int attempts ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 1170
  debugf((size_t )1, "handle_attempts_option(attempts = %d)", attempts);
  }
#line 1172
  if (! g___3.idiot) {
#line 1172
    if (attempts < 0) {
      {
#line 1173
      prog_usage_msg("Invalid --attempts argument: %d (not between %d and %d)", attempts,
                     0, 100);
      }
    } else
#line 1172
    if (attempts > 100) {
      {
#line 1173
      prog_usage_msg("Invalid --attempts argument: %d (not between %d and %d)", attempts,
                     0, 100);
      }
    }
  }
#line 1175
  g___3.attempts = attempts;
#line 1176
  return;
}
}
#line 1186 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void handle_delay_option(int delay ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 1188
  debugf((size_t )1, "handle_delay_option(delay = %d)", delay);
  }
#line 1190
  if (! g___3.idiot) {
#line 1190
    if (delay < 10) {
      {
#line 1191
      prog_usage_msg("Invalid --delay argument: %d (less than %d)\n", delay, 10);
      }
    }
  }
#line 1193
  g___3.delay = delay;
#line 1194
  return;
}
}
#line 1204 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void handle_limit_option(int limit ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 1206
  debugf((size_t )1, "handle_limit_option(limit = %d)", limit);
  }
#line 1208
  if (limit < 0) {
    {
#line 1209
    prog_usage_msg("Invalid --limit argument: %d (less than %d)\n", limit, 0);
    }
  }
#line 1211
  g___3.limit = limit;
#line 1212
  return;
}
}
#line 1222 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void handle_idiot_option(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;

  {
  {
#line 1224
  debugf((size_t )1, "handle_idiot_option()");
  }
#line 1226
  if (g___3.initial_uid) {
    {
#line 1227
    prog_usage_msg("Invalid option: --idiot (is only for root)");
    }
  }
#line 1229
  g___3.idiot = 1;
#line 1230
  return;
}
}
#line 1240 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void handle_pty_option(char *arg ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 1242
  debugf((size_t )1, "handle_pty_option(arg = %s)", arg);
#line 1244
  g___3.pty = 1;
  }
#line 1246
  if (arg) {
    {
#line 1248
    tmp = strcmp((char const   *)arg, "noecho");
    }
#line 1248
    if (tmp) {
      {
#line 1249
      prog_usage_msg("Invalid --pty argument: \'%s\' (Only \'noecho\' is supported)",
                     arg);
      }
    }
#line 1251
    g___3.noecho = 1;
  }
#line 1253
  return;
}
}
#line 1264 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void store_syslog(char const   *option___0 , char const   *spec , char **str ,
                         int *var ) 
{ 
  int facility ;
  int priority ;
  int tmp ;
  char *__cil_tmp8 ;

  {
  {
#line 1269
  debugf((size_t )1, "store_syslog(spec = %s)", spec);
#line 1271
  tmp = syslog_parse(spec, & facility, & priority);
  }
#line 1271
  if (tmp == -1) {
#line 1273
    *str = (char *)spec;
#line 1274
    *var = 0;
#line 1275
    return;
  }
#line 1278
  *str = (char *)spec;
#line 1279
  *var = facility | priority;
#line 1280
  return;
}
}
#line 1290 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void handle_errlog_option(char const   *spec ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 1292
  debugf((size_t )1, "handle_errlog_option(spec = %s)", spec);
#line 1294
  store_syslog("errlog", spec, & g___3.daemon_err, & g___3.daemon_errlog);
  }
#line 1295
  return;
}
}
#line 1305 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void handle_dbglog_option(char const   *spec ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 1307
  debugf((size_t )1, "handle_dbglog_option(spec = %s)", spec);
#line 1309
  store_syslog("dbglog", spec, & g___3.daemon_dbg, & g___3.daemon_dbglog);
  }
#line 1310
  return;
}
}
#line 1320 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void handle_output_option(char const   *spec ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 1322
  debugf((size_t )1, "handle_output_option(spec = %s)", spec);
#line 1324
  store_syslog("output", spec, & g___3.client_out, & g___3.client_outlog);
#line 1325
  store_syslog("output", spec, & g___3.client_err, & g___3.client_errlog);
  }
#line 1326
  return;
}
}
#line 1336 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void handle_stdout_option(char const   *spec ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 1338
  debugf((size_t )1, "handle_stdout_option(spec = %s)", spec);
#line 1340
  store_syslog("stdout", spec, & g___3.client_out, & g___3.client_outlog);
  }
#line 1341
  return;
}
}
#line 1351 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void handle_stderr_option(char const   *spec ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 1353
  debugf((size_t )1, "handle_stderr_option(spec = %s)", spec);
#line 1355
  store_syslog("stderr", spec, & g___3.client_err, & g___3.client_errlog);
  }
#line 1356
  return;
}
}
#line 1366 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static Option daemon_optab[32]  = 
#line 1366
  {      {"config", (char )'C', "path", "Specify the configuration file", 1, (OptionArgument )2,
      (OptionAction )1, (void *)(& g___3.config), (func_t *)((void *)0)}, 
        {"noconfig", (char )'N', (char const   *)((void *)0), "Bypass the system configuration file",
      0, (OptionArgument )1, (OptionAction )1, (void *)(& g___3.noconfig), (func_t *)((void *)0)}, 
        {"name",
      (char )'n', "name", "Guarantee a single named instance", 1, (OptionArgument )2,
      (OptionAction )2, (void *)0, (func_t *)(& handle_name_option)}, 
        {"command", (char )'X', "cmd", "Specify the client command as an option", 1,
      (OptionArgument )2, (OptionAction )1, (void *)(& g___3.command), (func_t *)((void *)0)}, 
        {"pidfiles",
      (char )'P', "/dir", "Override standard pidfile location", 1, (OptionArgument )2,
      (OptionAction )2, (void *)0, (func_t *)(& handle_pidfiles_option)}, 
        {"pidfile", (char )'F', "/path", "Override standard pidfile name and location\n",
      1, (OptionArgument )2, (OptionAction )2, (void *)0, (func_t *)(& handle_pidfile_option)}, 
        {"user",
      (char )'u', "user[:group]", "Run the client as user[:group]", 1, (OptionArgument )2,
      (OptionAction )2, (void *)0, (func_t *)(& handle_user_option)}, 
        {"chroot", (char )'R', "path", "Run the client with path as root", 1, (OptionArgument )2,
      (OptionAction )2, (void *)0, (func_t *)(& handle_chroot_option)}, 
        {"chdir", (char )'D', "path", "Run the client in directory path", 1, (OptionArgument )2,
      (OptionAction )1, (void *)(& g___3.chdir), (func_t *)((void *)0)}, 
        {"umask", (char )'m', "umask", "Run the client with the given umask", 1, (OptionArgument )2,
      (OptionAction )2, (void *)0, (func_t *)(& handle_umask_option)}, 
        {"env", (char )'e', "\"var=val\"", "Set a client environment variable", 1, (OptionArgument )2,
      (OptionAction )2, (void *)0, (func_t *)(& handle_env_option)}, 
        {"inherit", (char )'i', (char const   *)((void *)0), "Inherit environment variables",
      0, (OptionArgument )0, (OptionAction )2, (void *)0, & handle_inherit_option}, 
        {"unsafe",
      (char )'U', (char const   *)((void *)0), "Allow execution of unsafe executable",
      0, (OptionArgument )0, (OptionAction )1, (void *)(& g___3.unsafe), (func_t *)((void *)0)}, 
        {"safe",
      (char )'S', (char const   *)((void *)0), "Deny execution of unsafe executable",
      0, (OptionArgument )0, (OptionAction )1, (void *)(& g___3.safe), (func_t *)((void *)0)}, 
        {"core",
      (char )'c', (char const   *)((void *)0), "Allow core file generation\n", 0,
      (OptionArgument )0, (OptionAction )1, (void *)(& g___3.core), (func_t *)((void *)0)}, 
        {"respawn",
      (char )'r', (char const   *)((void *)0), "Respawn the client when it terminates",
      0, (OptionArgument )0, (OptionAction )1, (void *)(& g___3.respawn), (func_t *)((void *)0)}, 
        {"acceptable",
      (char )'a', "#", "Minimum acceptable client duration (seconds)", 1, (OptionArgument )1,
      (OptionAction )2, (void *)0, (func_t *)(& handle_acceptable_option)}, 
        {"attempts", (char )'A', "#", "Respawn # times on error before delay", 1, (OptionArgument )1,
      (OptionAction )2, (void *)0, (func_t *)(& handle_attempts_option)}, 
        {"delay", (char )'L', "#", "Delay between spawn attempt bursts (seconds)", 1,
      (OptionArgument )1, (OptionAction )2, (void *)0, (func_t *)(& handle_delay_option)}, 
        {"limit",
      (char )'M', "#", "Maximum number of spawn attempt bursts", 1, (OptionArgument )1,
      (OptionAction )2, (void *)0, (func_t *)(& handle_limit_option)}, 
        {"idiot", (char )'\000', (char const   *)((void *)0), "Idiot mode (trust root with the above)\n",
      0, (OptionArgument )0, (OptionAction )2, (void *)0, & handle_idiot_option}, 
        {"foreground", (char )'f', (char const   *)((void *)0), "Run the client in the foreground",
      0, (OptionArgument )0, (OptionAction )1, (void *)(& g___3.foreground), (func_t *)((void *)0)}, 
        {"pty",
      (char )'p', "noecho", "Allocate a pseudo terminal for the client\n", 2, (OptionArgument )2,
      (OptionAction )2, (void *)0, (func_t *)(& handle_pty_option)}, 
        {"errlog", (char )'l', "spec", "Send daemon\'s error output to syslog or file",
      1, (OptionArgument )2, (OptionAction )2, (void *)0, (func_t *)(& handle_errlog_option)}, 
        {"dbglog",
      (char )'b', "spec", "Send daemon\'s debug output to syslog or file", 1, (OptionArgument )2,
      (OptionAction )2, (void *)0, (func_t *)(& handle_dbglog_option)}, 
        {"output", (char )'o', "spec", "Send client\'s output to syslog or file", 1,
      (OptionArgument )2, (OptionAction )2, (void *)0, (func_t *)(& handle_output_option)}, 
        {"stdout",
      (char )'O', "spec", "Send client\'s stdout to syslog or file", 1, (OptionArgument )2,
      (OptionAction )2, (void *)0, (func_t *)(& handle_stdout_option)}, 
        {"stderr", (char )'E', "spec", "Send client\'s stderr to syslog or file\n", 1,
      (OptionArgument )2, (OptionAction )2, (void *)0, (func_t *)(& handle_stderr_option)}, 
        {"running",
      (char )'\000', (char const   *)((void *)0), "Check if a named daemon is running",
      0, (OptionArgument )0, (OptionAction )1, (void *)(& g___3.running), (func_t *)((void *)0)}, 
        {"restart",
      (char )'\000', (char const   *)((void *)0), "Restart a named daemon client",
      0, (OptionArgument )0, (OptionAction )1, (void *)(& g___3.restart), (func_t *)((void *)0)}, 
        {"stop",
      (char )'\000', (char const   *)((void *)0), "Terminate a named daemon process",
      0, (OptionArgument )0, (OptionAction )1, (void *)(& g___3.stop), (func_t *)((void *)0)}, 
        {(char const   *)((void *)0),
      (char )'\000', (char const   *)((void *)0), (char const   *)((void *)0), 0,
      (OptionArgument )0, (OptionAction )0, (void *)0, (func_t *)((void *)0)}};
#line 1497 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static Options options[1]  = {      {prog_options_table, daemon_optab}};
#line 1507 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static Config *config_create(char *name , char *options___0 ) 
{ 
  Config *config___0 ;
  List *tokens ;
  int i ;
  void *tmp ;
  char *tmp___0 ;
  List *tmp___1 ;
  char *tok ;
  void *tmp___2 ;
  char *tmp___3 ;
  size_t size ;
  size_t tmp___4 ;
  char *option___0 ;
  void *tmp___5 ;
  List *tmp___6 ;
  ssize_t tmp___7 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 1513
  debugf((size_t )1, "config_create(name = \"%s\", options = \"%s\")", name, options___0);
#line 1515
  tmp = malloc(sizeof(Config ));
#line 1515
  config___0 = (Config *)tmp;
  }
#line 1515
  if (! config___0) {
#line 1516
    return ((Config *)((void *)0));
  }
  {
#line 1518
  tmp___0 = mem_strdup((char const   *)name);
#line 1518
  config___0->name = tmp___0;
  }
#line 1518
  if (! tmp___0) {
    {
#line 1520
    free((void *)config___0);
    }
#line 1521
    return ((Config *)((void *)0));
  }
  {
#line 1524
  tmp___1 = list_create((list_release_t *)(& free));
#line 1524
  config___0->options = tmp___1;
  }
#line 1524
  if (! tmp___1) {
    {
#line 1526
    free((void *)config___0->name);
#line 1527
    free((void *)config___0);
    }
#line 1528
    return ((Config *)((void *)0));
  }
  {
#line 1531
  tokens = split((char const   *)options___0, ",");
  }
#line 1531
  if (! tokens) {
    {
#line 1533
    list_release(config___0->options);
#line 1534
    free((void *)config___0->name);
#line 1535
    free((void *)config___0);
    }
#line 1536
    return ((Config *)((void *)0));
  }
#line 1539
  i = 0;
  {
#line 1539
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1539
    tmp___7 = list_length((List const   *)tokens);
    }
#line 1539
    if (! ((ssize_t )i < tmp___7)) {
#line 1539
      goto while_break;
    }
    {
#line 1541
    tmp___2 = list_item((List const   *)tokens, (ssize_t )i);
#line 1541
    tmp___3 = cstr((String const   *)((String *)tmp___2));
#line 1541
    tok = tmp___3;
#line 1542
    tmp___4 = strlen((char const   *)tok);
#line 1542
    size = tmp___4 + 3UL;
#line 1545
    tmp___5 = malloc(size * sizeof(char ));
#line 1545
    option___0 = (char *)tmp___5;
    }
#line 1545
    if (! option___0) {
      {
#line 1547
      list_release(tokens);
#line 1548
      list_release(config___0->options);
#line 1549
      free((void *)config___0->name);
#line 1550
      free((void *)config___0);
      }
#line 1551
      return ((Config *)((void *)0));
    }
    {
#line 1554
    strlcpy(option___0, "--", size);
#line 1555
    strlcat(option___0, (char const   *)tok, size);
#line 1557
    tmp___6 = list_append(config___0->options, (void *)option___0);
    }
#line 1557
    if (! tmp___6) {
      {
#line 1559
      free((void *)option___0);
#line 1560
      list_release(tokens);
#line 1561
      list_release(config___0->options);
#line 1562
      free((void *)config___0->name);
#line 1563
      free((void *)config___0);
      }
#line 1564
      return ((Config *)((void *)0));
    }
#line 1539
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1568
  return (config___0);
}
}
#line 1579 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void config_release(Config *config___0 ) 
{ 


  {
  {
#line 1581
  free((void *)config___0->name);
#line 1582
  list_release(config___0->options);
#line 1583
  free((void *)config___0);
  }
#line 1584
  return;
}
}
#line 1598 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void config_parse(void *obj , char const   *path , char *line , size_t lineno ) 
{ 
  List *list ;
  Config *config___0 ;
  char name[512] ;
  char *n ;
  char options___0[4096] ;
  char *o ;
  char *s ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  List *tmp___6 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 1600
  list = (List *)obj;
#line 1602
  n = name;
#line 1603
  o = options___0;
#line 1604
  s = line;
#line 1606
  debugf((size_t )1, "config_parse(obj = %p, path = %s, line = \"%s\", lineno = %d)",
         obj, path, line, lineno);
  }
  {
#line 1608
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1608
    if (*s) {
      {
#line 1608
      tmp = __ctype_b_loc();
      }
#line 1608
      if (! ((int const   )*(*tmp + (int )((unsigned char )*s)) & 8192)) {
#line 1608
        goto while_break;
      }
    } else {
#line 1608
      goto while_break;
    }
#line 1609
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1611
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1611
    if (n - name < 512L) {
#line 1611
      if (*s) {
        {
#line 1611
        tmp___2 = __ctype_b_loc();
        }
#line 1611
        if ((int const   )*(*tmp___2 + (int )((unsigned char )*s)) & 8192) {
#line 1611
          goto while_break___0;
        }
      } else {
#line 1611
        goto while_break___0;
      }
    } else {
#line 1611
      goto while_break___0;
    }
#line 1613
    if ((int )*s == 92) {
#line 1614
      s ++;
    }
#line 1615
    tmp___0 = n;
#line 1615
    n ++;
#line 1615
    tmp___1 = s;
#line 1615
    s ++;
#line 1615
    *tmp___0 = *tmp___1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1618
  *n = (char )'\000';
  {
#line 1620
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1620
    if (*s) {
      {
#line 1620
      tmp___3 = __ctype_b_loc();
      }
#line 1620
      if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*s)) & 8192)) {
#line 1620
        goto while_break___1;
      }
    } else {
#line 1620
      goto while_break___1;
    }
#line 1621
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1623
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1623
    if (o - options___0 < 4096L) {
#line 1623
      if (! *s) {
#line 1623
        goto while_break___2;
      }
    } else {
#line 1623
      goto while_break___2;
    }
#line 1625
    if ((int )*s == 92) {
#line 1626
      s ++;
    }
#line 1627
    tmp___4 = o;
#line 1627
    o ++;
#line 1627
    tmp___5 = s;
#line 1627
    s ++;
#line 1627
    *tmp___4 = *tmp___5;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1630
  *o = (char )'\000';
#line 1632
  if (! name[0]) {
    {
#line 1633
    fatal("syntax error in %s, line %d:\n%s", path, lineno, line);
    }
  } else
#line 1632
  if (! options___0[0]) {
    {
#line 1633
    fatal("syntax error in %s, line %d:\n%s", path, lineno, line);
    }
  }
  {
#line 1635
  config___0 = config_create(name, options___0);
  }
#line 1635
  if (config___0) {
    {
#line 1635
    tmp___6 = list_append(list, (void *)config___0);
    }
#line 1635
    if (! tmp___6) {
      {
#line 1636
      fatalsys("out of memory");
      }
    }
  } else {
    {
#line 1636
    fatalsys("out of memory");
    }
  }
#line 1637
  return;
}
}
#line 1648 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void config_process(List *conf , char *target ) 
{ 
  int ac ;
  char **av ;
  Config *config___0 ;
  int j ;
  void *tmp ;
  ssize_t tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 1655
  debugf((size_t )1, "config_process(target = %s)", target);
  }
  {
#line 1657
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1657
    tmp___7 = list_has_next(conf);
    }
#line 1657
    if (! (tmp___7 == 1)) {
#line 1657
      goto while_break;
    }
    {
#line 1659
    tmp = list_next(conf);
#line 1659
    config___0 = (Config *)tmp;
#line 1661
    tmp___6 = strcmp((char const   *)config___0->name, (char const   *)target);
    }
#line 1661
    if (! tmp___6) {
      {
#line 1663
      tmp___0 = list_length((List const   *)config___0->options);
#line 1663
      tmp___1 = malloc((unsigned long )(tmp___0 + 2L) * sizeof(char *));
#line 1663
      av = (char **)tmp___1;
      }
#line 1663
      if (! av) {
        {
#line 1664
        fatalsys("out of memory");
        }
      }
      {
#line 1666
      tmp___2 = prog_name();
#line 1666
      *(av + 0) = (char *)tmp___2;
#line 1668
      j = 1;
      }
      {
#line 1668
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1668
        tmp___5 = list_has_next(config___0->options);
        }
#line 1668
        if (! (tmp___5 == 1)) {
#line 1668
          goto while_break___0;
        }
        {
#line 1669
        tmp___4 = list_next(config___0->options);
#line 1669
        tmp___3 = mem_strdup((char const   *)tmp___4);
#line 1669
        *(av + j) = tmp___3;
        }
#line 1669
        if (! tmp___3) {
          {
#line 1670
          fatalsys("out of memory");
          }
        }
#line 1668
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1672
      ac = j;
#line 1672
      *(av + ac) = (char *)((void *)0);
#line 1673
      optind = 0;
#line 1674
      prog_opt_process(ac, av);
#line 1675
      free((void *)av);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1678
  return;
}
}
#line 1690 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void config_load(List **conf , char const   *configfile ) 
{ 
  char explanation[256] ;
  int tmp ;
  __uid_t tmp___0 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1692
  debugf((size_t )1, "config_load(configfile = %s)", configfile);
  }
#line 1696
  if (g___3.safe) {
#line 1696
    goto _L;
  } else {
    {
#line 1696
    tmp___0 = getuid();
    }
#line 1696
    if (tmp___0 == 0U) {
#line 1696
      if (! g___3.unsafe) {
        _L: /* CIL Label */ 
        {
#line 1700
        tmp = daemon_path_is_safe(configfile, explanation, (size_t )256);
        }
        {
#line 1702
        if (tmp == 0) {
#line 1702
          goto case_0;
        }
#line 1703
        if (tmp == -1) {
#line 1703
          goto case_neg_1;
        }
#line 1700
        goto switch_break;
        case_0: /* CIL Label */ 
        {
#line 1702
        error("ignoring unsafe %s (%s)", configfile, explanation);
        }
        case_neg_1: /* CIL Label */ 
#line 1703
        return;
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 1709
  daemon_parse_config(configfile, (void *)*conf, & config_parse);
  }
#line 1710
  return;
}
}
#line 1723 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void config(void) 
{ 
  List *conf ;
  struct passwd *pwd ;
  char *config_user ;
  size_t size ;
  char const   *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  __uid_t tmp___2 ;
  uid_t tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 1725
  conf = (List *)((void *)0);
#line 1730
  debugf((size_t )1, "config()");
#line 1734
  conf = list_create((list_release_t *)(& config_release));
  }
#line 1734
  if (! conf) {
    {
#line 1735
    fatalsys("out of memory");
    }
  }
#line 1739
  if (! g___3.noconfig) {
#line 1740
    if (g___3.config) {
#line 1740
      tmp = (char const   *)g___3.config;
    } else {
#line 1740
      tmp = "/etc/daemon.conf";
    }
    {
#line 1740
    config_load(& conf, tmp);
    }
  }
#line 1744
  if (g___3.uid) {
#line 1744
    tmp___3 = g___3.uid;
  } else {
    {
#line 1744
    tmp___2 = getuid();
#line 1744
    tmp___3 = tmp___2;
    }
  }
  {
#line 1744
  pwd = getpwuid(tmp___3);
  }
#line 1744
  if (pwd) {
    {
#line 1746
    tmp___0 = strlen((char const   *)pwd->pw_dir);
#line 1746
    size = ((tmp___0 + 1UL) + sizeof(".daemonrc")) + 1UL;
#line 1747
    tmp___1 = malloc(size * sizeof(char ));
#line 1747
    config_user = (char *)tmp___1;
    }
#line 1747
    if (! config_user) {
      {
#line 1748
      fatalsys("out of memory");
      }
    }
    {
#line 1749
    snprintf((char */* __restrict  */)config_user, size, (char const   */* __restrict  */)"%s%c%s",
             pwd->pw_dir, '/', ".daemonrc");
#line 1750
    config_load(& conf, (char const   *)config_user);
    }
  }
  {
#line 1755
  config_process(conf, (char *)"*");
  }
#line 1759
  if (g___3.name) {
    {
#line 1760
    config_process(conf, g___3.name);
    }
  }
  {
#line 1764
  optind = 0;
#line 1765
  g___3.done_config = 1;
#line 1766
  prog_opt_process(g___3.ac, g___3.av);
#line 1770
  list_release(conf);
  }
#line 1771
  return;
}
}
#line 1784 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void term(int signo ) 
{ 
  int tmp ;
  __pid_t tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1786
  debugf((size_t )1, "term(signo = %d)", signo);
  }
#line 1788
  if (g___3.pid != 0) {
#line 1788
    if (g___3.pid != -1) {
      {
#line 1788
      tmp___0 = getpid();
      }
#line 1788
      if (g___3.pid != tmp___0) {
        {
#line 1790
        debugf((size_t )2, "kill(term) process %d", g___3.pid);
#line 1792
        tmp = kill(g___3.pid, 15);
        }
#line 1792
        if (tmp == -1) {
          {
#line 1793
          errorsys("failed to terminate client (%d)", g___3.pid);
          }
        }
        {
#line 1795
        debugf((size_t )2, "stopped");
        }
      }
    }
  }
#line 1798
  g___3.terminated = 1;
#line 1799
  return;
}
}
#line 1809 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void chld(int signo ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 1811
  debugf((size_t )1, "chld(signo = %d)", signo);
  }
#line 1812
  return;
}
}
#line 1826 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void usr1(int signo ) 
{ 
  int tmp ;
  __pid_t tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1828
  debugf((size_t )1, "usr1(signo = %d)", signo);
  }
#line 1830
  if (g___3.pid != 0) {
#line 1830
    if (g___3.pid != -1) {
      {
#line 1830
      tmp___0 = getpid();
      }
#line 1830
      if (g___3.pid != tmp___0) {
        {
#line 1832
        debugf((size_t )2, "kill(term) process %d", g___3.pid);
#line 1834
        g___3.spawn_time = (time_t )0;
#line 1835
        g___3.attempt = 0;
#line 1836
        g___3.burst = 0;
#line 1838
        tmp = kill(g___3.pid, 15);
        }
#line 1838
        if (tmp == -1) {
          {
#line 1839
          errorsys("failed to terminate client (%d)", g___3.pid);
          }
        }
        {
#line 1841
        debugf((size_t )2, "stopped");
        }
      }
    }
  }
#line 1843
  return;
}
}
#line 1854 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void winch(int signo ) 
{ 
  struct winsize win ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 1858
  debugf((size_t )1, "winch(signo = %d)", signo);
  }
#line 1860
  if (g___3.masterfd == -1) {
#line 1861
    return;
  }
  {
#line 1863
  debugf((size_t )2, "ioctl(stdin, TIOCGWINSZ)");
#line 1865
  tmp = ioctl(0, 21523UL, & win);
  }
#line 1865
  if (tmp == -1) {
    {
#line 1867
    errorsys("failed to get stdin\'s window size");
    }
#line 1868
    return;
  }
  {
#line 1871
  debugf((size_t )2, "ioctl(masterfd = %d, TIOCSWINSZ, row = %d, col = %d, xpixel = %d, ypixel = %d)",
         g___3.masterfd, (int )win.ws_row, (int )win.ws_col, (int )win.ws_xpixel,
         (int )win.ws_ypixel);
#line 1873
  tmp___0 = ioctl(g___3.masterfd, 21524UL, & win);
  }
#line 1873
  if (tmp___0 == -1) {
    {
#line 1874
    errorsys("failed to set pty\'s window size");
    }
  }
#line 1875
  return;
}
}
#line 1886 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void prepare_environment(void) 
{ 
  int i ;
  ssize_t tmp ;
  void *tmp___0 ;
  char *env ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 1890
  debugf((size_t )1, "prepare_environment()");
  }
#line 1892
  if (! g___3.env) {
#line 1893
    return;
  }
  {
#line 1895
  tmp = list_length((List const   *)g___3.env);
#line 1895
  tmp___0 = malloc((unsigned long )(tmp + 1L) * sizeof(char *));
#line 1895
  g___3.environ = (char **)tmp___0;
  }
#line 1895
  if (! g___3.environ) {
    {
#line 1896
    fatalsys("out of memory");
    }
  }
#line 1898
  i = 0;
  {
#line 1898
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1898
    tmp___3 = list_has_next(g___3.env);
    }
#line 1898
    if (! (tmp___3 == 1)) {
#line 1898
      goto while_break;
    }
    {
#line 1900
    tmp___1 = list_next(g___3.env);
#line 1900
    env = (char *)tmp___1;
#line 1902
    tmp___2 = mem_strdup((char const   *)env);
#line 1902
    *(g___3.environ + i) = tmp___2;
    }
#line 1902
    if (! tmp___2) {
      {
#line 1903
      fatalsys("out of memory");
      }
    }
#line 1898
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1906
  *(g___3.environ + i) = (char *)((void *)0);
#line 1907
  return;
}
}
#line 1918 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static int tty_raw(int fd ) 
{ 
  struct termios attr[1] ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp5 ;
  int __cil_tmp6 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 1922
  debugf((size_t )1, "tty_raw(fd = %d)", fd);
#line 1924
  debugf((size_t )2, "tcgetattr(fd = %d)", fd);
#line 1926
  tmp = tcgetattr(fd, attr);
  }
#line 1926
  if (tmp == -1) {
#line 1927
    return (-1);
  }
  {
#line 1929
  attr[0].c_lflag &= 4294934516U;
#line 1930
  attr[0].c_iflag &= 4294965965U;
#line 1931
  attr[0].c_cflag &= 4294966991U;
#line 1932
  attr[0].c_cflag |= 48U;
#line 1933
  attr[0].c_oflag &= 4294967294U;
#line 1934
  attr[0].c_cc[6] = (cc_t )1;
#line 1935
  attr[0].c_cc[5] = (cc_t )0;
#line 1937
  debugf((size_t )2, "tcsetattr(fd = %d, TCSANOW, raw)", fd);
#line 1939
  tmp___0 = tcsetattr(fd, 0, (struct termios  const  *)(attr));
  }
#line 1939
  return (tmp___0);
}
}
#line 1951 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static int tty_noecho(int fd ) 
{ 
  struct termios attr[1] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp6 ;
  int __cil_tmp7 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 1955
  debugf((size_t )1, "tty_noecho(fd = %d)", fd);
#line 1957
  debugf((size_t )2, "tcgetattr(fd = %d)", fd);
#line 1959
  tmp___0 = tcgetattr(fd, attr);
  }
#line 1959
  if (tmp___0 == -1) {
    {
#line 1960
    tmp = errorsys("failed to get terminal attributes for slave pty");
    }
#line 1960
    return (tmp);
  }
  {
#line 1962
  attr[0].c_lflag &= 4294967175U;
#line 1964
  attr[0].c_oflag &= 4294967291U;
#line 1967
  debugf((size_t )2, "tcsetattr(fd = %d, TCSANOW, noecho)", fd);
#line 1969
  tmp___1 = tcsetattr(fd, 0, (struct termios  const  *)(attr));
  }
#line 1969
  return (tmp___1);
}
}
#line 1980 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void restore_stdin(void) 
{ 
  int tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 1982
  debugf((size_t )1, "restore_stdin()");
#line 1984
  debugf((size_t )2, "tcsetattr(stdin, TCSANOW, orig)");
#line 1986
  tmp = tcsetattr(0, 0, (struct termios  const  *)(& g___3.stdin_termios));
  }
#line 1986
  if (tmp == -1) {
    {
#line 1987
    errorsys("failed to restore stdin terminal attributes");
    }
  }
#line 1988
  return;
}
}
#line 1998 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void prepare_parent(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 2000
  debugf((size_t )1, "prepare_parent()");
#line 2002
  debugf((size_t )2, "setting sigterm action");
#line 2004
  tmp = signal_set_handler(15, 0, & term);
  }
#line 2004
  if (tmp == -1) {
    {
#line 2005
    fatalsys("failed to set sigterm action");
    }
  }
  {
#line 2007
  debugf((size_t )2, "setting sigchld action");
#line 2009
  tmp___0 = signal_set_handler(17, 0, & chld);
  }
#line 2009
  if (tmp___0 == -1) {
    {
#line 2010
    fatalsys("failed to set sigchld action");
    }
  }
  {
#line 2012
  debugf((size_t )2, "setting sigusr1 action");
#line 2014
  tmp___1 = signal_set_handler(10, 0, & usr1);
  }
#line 2014
  if (tmp___1 == -1) {
    {
#line 2015
    fatalsys("failed to set sigusr1 action");
    }
  }
#line 2017
  if (g___3.foreground) {
    {
#line 2017
    tmp___6 = isatty(0);
    }
#line 2017
    if (tmp___6) {
      {
#line 2019
      debugf((size_t )2, "saving stdin\'s terminal attributes");
#line 2023
      debugf((size_t )2, "tcgetattr(stdin)");
#line 2025
      tmp___2 = tcgetattr(0, & g___3.stdin_termios);
      }
#line 2025
      if (tmp___2 == -1) {
        {
#line 2026
        errorsys("failed to get terminal attributes for stdin");
        }
      }
      {
#line 2028
      debugf((size_t )2, "ioctl(stdin, TIOCGWINSZ)");
#line 2030
      tmp___3 = ioctl(0, 21523UL, & g___3.stdin_winsize);
      }
#line 2030
      if (tmp___3 == -1) {
        {
#line 2031
        errorsys("failed to get terminal window size for stdin");
        }
      }
      {
#line 2035
      tmp___4 = tty_raw(0);
      }
#line 2035
      if (tmp___4 == -1) {
        {
#line 2036
        errorsys("failed to set stdin to raw mode");
        }
      }
      {
#line 2040
      debugf((size_t )2, "atexit(restore_stdin)");
#line 2042
      tmp___5 = atexit(& restore_stdin);
      }
#line 2042
      if (tmp___5 == -1) {
        {
#line 2043
        errorsys("failed to atexit(restore_stdin)");
        }
      }
#line 2045
      g___3.stdin_isatty = 1;
    }
  }
#line 2047
  return;
}
}
#line 2058 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void prepare_child(void *data ) 
{ 
  __pid_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 2060
  debugf((size_t )1, "prepare_child()");
#line 2062
  tmp = getpid();
#line 2062
  debugf((size_t )2, "child pid = %d", tmp);
#line 2064
  debugf((size_t )2, "child restoring sigterm action");
#line 2066
  tmp___0 = signal_set_handler(15, 0, (void (*)(int  ))0);
  }
#line 2066
  if (tmp___0 == -1) {
    {
#line 2067
    fatalsys("failed to restore sigterm action, exiting");
    }
  }
  {
#line 2069
  debugf((size_t )2, "child restoring sigchld action");
#line 2071
  tmp___1 = signal_set_handler(17, 0, (void (*)(int  ))0);
  }
#line 2071
  if (tmp___1 == -1) {
    {
#line 2072
    fatalsys("failed to restore sigchld action, exiting");
    }
  }
#line 2074
  if (g___3.stdin_isatty) {
    {
#line 2076
    debugf((size_t )2, "child restoring sigwinch action");
#line 2078
    tmp___2 = signal_set_handler(28, 0, (void (*)(int  ))0);
    }
#line 2078
    if (tmp___2 == -1) {
      {
#line 2079
      fatalsys("failed to restore sigwinch action, exiting");
      }
    }
  }
#line 2082
  if (g___3.noecho) {
    {
#line 2084
    debugf((size_t )2, "child setting slave pty to noecho mode");
#line 2086
    tmp___3 = tty_noecho(0);
    }
#line 2086
    if (tmp___3 == -1) {
      {
#line 2087
      fatalsys("failed to set noecho on slave pty");
      }
    }
  }
#line 2089
  return;
}
}
#line 2110 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void spawn_child(void) 
{ 
  time_t spawn_time ;
  int tmp ;
  int *tmp___0 ;
  struct termios *slave_termios ;
  struct winsize *slave_winsize ;
  int tmp___1 ;
  char **tmp___2 ;
  char **tmp___3 ;
  __pid_t tmp___4 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 2114
  debugf((size_t )1, "spawn_child()");
#line 2116
  spawn_time = time((time_t *)0);
  }
#line 2116
  if (spawn_time == -1L) {
    {
#line 2117
    fatalsys("failed to get the time");
    }
  }
#line 2119
  if (g___3.spawn_time) {
    {
#line 2121
    debugf((size_t )2, "preparing to respawn");
    }
#line 2125
    if (spawn_time < g___3.spawn_time) {
      {
#line 2127
      debugf((size_t )2, "clock has gone backwards, resetting previous spawn time to now");
#line 2129
      g___3.spawn_time = spawn_time;
      }
    }
#line 2134
    if (spawn_time - g___3.spawn_time < (time_t )g___3.acceptable) {
      {
#line 2136
      debugf((size_t )2, "previous instance only lasted %d seconds", spawn_time - g___3.spawn_time);
#line 2138
      (g___3.attempt) ++;
      }
#line 2138
      if (g___3.attempt >= g___3.attempts) {
#line 2140
        if (g___3.limit) {
#line 2140
          (g___3.burst) ++;
#line 2140
          if (g___3.burst >= g___3.limit) {
            {
#line 2141
            fatal("reached respawn attempt burst limit (%d), exiting", g___3.limit);
            }
          }
        }
        {
#line 2143
        error("terminating too quickly, waiting %d seconds", g___3.delay);
        }
        {
#line 2145
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 2145
          tmp = nap((long )g___3.delay, 0L);
          }
#line 2145
          if (tmp == -1) {
            {
#line 2145
            tmp___0 = __errno_location();
            }
#line 2145
            if (! (*tmp___0 == 4)) {
#line 2145
              goto while_break;
            }
          } else {
#line 2145
            goto while_break;
          }
          {
#line 2147
          signal_handle_all();
          }
#line 2149
          if (g___3.terminated) {
            {
#line 2150
            fatal("terminated");
            }
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 2153
        spawn_time = time((time_t *)0);
        }
#line 2153
        if (spawn_time == -1L) {
          {
#line 2154
          fatalsys("failed to get the time");
          }
        }
#line 2156
        g___3.attempt = 0;
      }
    }
  }
  {
#line 2161
  g___3.spawn_time = spawn_time;
#line 2163
  debugf((size_t )2, "starting client");
  }
#line 2165
  if (g___3.foreground) {
#line 2165
    if (g___3.stdin_isatty) {
#line 2165
      goto _L___0;
    } else
#line 2165
    if (g___3.pty) {
      _L___0: /* CIL Label */ 
      {
#line 2167
      slave_termios = (struct termios *)((void *)0);
#line 2168
      slave_winsize = (struct winsize *)((void *)0);
#line 2170
      debugf((size_t )2, "foreground with pty: coproc_pty_open()");
      }
#line 2172
      if (g___3.stdin_isatty) {
        {
#line 2174
        slave_termios = & g___3.stdin_termios;
#line 2175
        slave_winsize = & g___3.stdin_winsize;
#line 2177
        debugf((size_t )2, "setting sigwinch handler");
#line 2179
        tmp___1 = signal_set_handler(28, 0, & winch);
        }
#line 2179
        if (tmp___1 == -1) {
          {
#line 2180
          errorsys("failed to set sigwinch action");
          }
        }
      }
#line 2183
      if (g___3.env) {
#line 2183
        tmp___2 = g___3.environ;
      } else {
#line 2183
        tmp___2 = environ;
      }
      {
#line 2183
      g___3.pid = coproc_pty_open(& g___3.masterfd, g___3.slavename, g___3.slavenamesize,
                                  (struct termios  const  *)slave_termios, (struct winsize  const  *)slave_winsize,
                                  (char const   *)*(g___3.cmd), (char * const  *)g___3.cmd,
                                  (char * const  *)tmp___2, & prepare_child, (void *)0);
      }
#line 2183
      if (g___3.pid == -1) {
        {
#line 2184
        fatalsys("failed to start: %s", *(g___3.cmd));
        }
      }
    } else {
#line 2165
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 2188
    debugf((size_t )2, "no pty: coproc_open()");
    }
#line 2190
    if (g___3.env) {
#line 2190
      tmp___3 = g___3.environ;
    } else {
#line 2190
      tmp___3 = environ;
    }
    {
#line 2190
    g___3.pid = coproc_open(& g___3.in, & g___3.out, & g___3.err, (char const   *)*(g___3.cmd),
                            (char * const  *)g___3.cmd, (char * const  *)tmp___3,
                            & prepare_child, (void *)0);
    }
#line 2190
    if (g___3.pid == -1) {
      {
#line 2191
      fatalsys("failed to start: %s", *(g___3.cmd));
      }
    }
  }
  {
#line 2194
  tmp___4 = getpid();
#line 2194
  debugf((size_t )2, "parent pid = %d, child pid = %d", tmp___4, g___3.pid);
  }
#line 2195
  return;
}
}
#line 2208 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void examine_child(void) 
{ 
  int status ;
  int *tmp ;
  int *tmp___0 ;
  __pid_t tmp___1 ;
  union __anonunion_71 __constr_expr_0 ;
  union __anonunion_72 __constr_expr_1 ;
  union __anonunion_73 __constr_expr_2 ;
  union __anonunion_74 __constr_expr_3 ;
  union __anonunion_75 __constr_expr_4 ;
  union __anonunion_76 __constr_expr_5 ;
  union __anonunion_77 __constr_expr_6 ;
  union __anonunion_78 __constr_expr_7 ;
  union __anonunion_79 __constr_expr_8 ;
  union __anonunion_80 __constr_expr_9 ;
  char const   *tmp___2 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 2212
  debugf((size_t )1, "examine_child(pid = %d)", g___3.pid);
  }
#line 2214
  if (g___3.masterfd != -1) {
    {
#line 2216
    debugf((size_t )2, "coproc_pty_close(pid = %d, masterfd = %d, slavename = %s)",
           g___3.pid, g___3.masterfd, g___3.slavename);
    }
    {
#line 2218
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 2218
      status = coproc_pty_close(g___3.pid, & g___3.masterfd, (char const   *)(g___3.slavename));
      }
#line 2218
      if (status == -1) {
        {
#line 2218
        tmp = __errno_location();
        }
#line 2218
        if (! (*tmp == 4)) {
#line 2218
          goto while_break;
        }
      } else {
#line 2218
        goto while_break;
      }
      {
#line 2219
      signal_handle_all();
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2221
    if (status == -1) {
      {
#line 2222
      fatalsys("coproc_pty_close(pid = %d) failed", g___3.pid);
      }
    }
  } else {
    {
#line 2226
    debugf((size_t )2, "coproc_close(pid = %d, in = %d, out = %d, err = %d)", g___3.pid,
           g___3.in, g___3.out, g___3.err);
    }
    {
#line 2228
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2228
      status = coproc_close(g___3.pid, & g___3.in, & g___3.out, & g___3.err);
      }
#line 2228
      if (status == -1) {
        {
#line 2228
        tmp___0 = __errno_location();
        }
#line 2228
        if (! (*tmp___0 == 4)) {
#line 2228
          goto while_break___0;
        }
      } else {
#line 2228
        goto while_break___0;
      }
      {
#line 2229
      signal_handle_all();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2231
    if (status == -1) {
      {
#line 2232
      fatalsys("coproc_close(pid = %d) failed", g___3.pid);
      }
    }
  }
  {
#line 2235
  tmp___1 = getpid();
#line 2235
  debugf((size_t )2, "pid %d received sigchld for pid %d", tmp___1, g___3.pid);
#line 2237
  __constr_expr_9.__in = status;
  }
#line 2237
  if ((__constr_expr_9.__i & 127) == 0) {
    {
#line 2239
    __constr_expr_0.__in = status;
#line 2239
    debugf((size_t )2, "child terminated with status %d", (__constr_expr_0.__i & 65280) >> 8);
#line 2241
    __constr_expr_2.__in = status;
    }
#line 2241
    if ((__constr_expr_2.__i & 65280) >> 8 != 0) {
      {
#line 2242
      __constr_expr_1.__in = status;
#line 2242
      error("client (pid %d) exited with %d status", g___3.pid, (__constr_expr_1.__i & 65280) >> 8);
      }
    }
  } else {
#line 2244
    __constr_expr_8.__in = status;
#line 2244
    if ((int )((signed char )((__constr_expr_8.__i & 127) + 1)) >> 1 > 0) {
#line 2246
      if (g___3.terminated) {
        {
#line 2247
        __constr_expr_3.__in = status;
#line 2247
        error("client (pid %d) killed by signal %d, stopping", g___3.pid, __constr_expr_3.__i & 127);
        }
      } else
#line 2248
      if (g___3.respawn) {
        {
#line 2249
        __constr_expr_4.__in = status;
#line 2249
        error("client (pid %d) killed by signal %d, respawning", g___3.pid, __constr_expr_4.__i & 127);
        }
      } else {
        {
#line 2251
        __constr_expr_5.__in = status;
#line 2251
        fatal("client (pid %d) killed by signal %d, exiting", g___3.pid, __constr_expr_5.__i & 127);
        }
      }
    } else {
#line 2253
      __constr_expr_7.__in = status;
#line 2253
      if ((__constr_expr_7.__i & 255) == 127) {
        {
#line 2255
        __constr_expr_6.__in = status;
#line 2255
        fatal("client (pid %d) stopped by signal %d, exiting", g___3.pid, (__constr_expr_6.__i & 65280) >> 8);
        }
      } else {
        {
#line 2259
        fatal("client (pid %d) died under mysterious circumstances, exiting", g___3.pid);
        }
      }
    }
  }
#line 2262
  g___3.pid = 0;
#line 2264
  if (g___3.respawn) {
#line 2264
    if (! g___3.terminated) {
      {
#line 2266
      debugf((size_t )2, "about to respawn");
#line 2267
      spawn_child();
      }
    } else {
#line 2264
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 2271
    if (g___3.terminated) {
#line 2271
      tmp___2 = "daemon and ";
    } else {
#line 2271
      tmp___2 = "";
    }
    {
#line 2271
    debugf((size_t )2, "%schild terminated, exiting", tmp___2);
#line 2272
    exit(0);
    }
  }
#line 2274
  return;
}
}
#line 2289 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void run(void) 
{ 
  char buf[8193] ;
  fd_set readfds[1] ;
  int maxfd ;
  int n ;
  char const   *tmp ;
  int __d0 ;
  int __d1 ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char const   *tmp___3 ;
  char *p ;
  char *q ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  ssize_t tmp___9 ;
  char *p___0 ;
  char *q___0 ;
  ssize_t tmp___10 ;
  ssize_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  ssize_t tmp___15 ;
  char *p___1 ;
  char *q___1 ;
  ssize_t tmp___16 ;
  ssize_t tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  ssize_t tmp___20 ;
  ssize_t tmp___21 ;
  int tmp___22 ;
  ssize_t tmp___23 ;
  struct termios attr[1] ;
  char eof ;
  int tmp___24 ;
  ssize_t tmp___25 ;
  int tmp___26 ;
  int *tmp___27 ;
  ssize_t tmp___28 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  int __cil_tmp48 ;
  void *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;

  {
  {
#line 2291
  debugf((size_t )1, "run()");
#line 2293
  prepare_parent();
#line 2294
  spawn_child();
  }
  {
#line 2296
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2298
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2302
      maxfd = -1;
#line 2305
      debugf((size_t )2, "run loop - handle any signals");
#line 2307
      signal_handle_all();
      }
#line 2311
      if (g___3.masterfd == -1) {
#line 2311
        if (g___3.out == -1) {
#line 2311
          if (g___3.err == -1) {
#line 2312
            goto while_break___0;
          }
        }
      }
#line 2314
      if (g___3.masterfd != -1) {
#line 2314
        tmp = "pty";
      } else {
#line 2314
        tmp = "pipes";
      }
      {
#line 2314
      debugf((size_t )2, "select(%s)", tmp);
      }
      {
#line 2316
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2316
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& readfds[0].fds_bits[0]): "memory");
#line 2316
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2318
      if (g___3.foreground) {
#line 2320
        if (! g___3.stdin_eof) {
#line 2322
          readfds[0].fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << 0 % (8 * (int )sizeof(__fd_mask )));
#line 2323
          if (0 > maxfd) {
#line 2324
            maxfd = 0;
          }
        }
      } else
#line 2329
      if (g___3.in != -1) {
        {
#line 2331
        close(g___3.in);
#line 2332
        g___3.in = -1;
        }
      }
#line 2336
      if (g___3.masterfd != -1) {
#line 2338
        readfds[0].fds_bits[g___3.masterfd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << g___3.masterfd % (8 * (int )sizeof(__fd_mask )));
#line 2339
        if (g___3.masterfd > maxfd) {
#line 2340
          maxfd = g___3.masterfd;
        }
      } else {
#line 2344
        if (g___3.out != -1) {
#line 2346
          readfds[0].fds_bits[g___3.out / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << g___3.out % (8 * (int )sizeof(__fd_mask )));
#line 2347
          if (g___3.out > maxfd) {
#line 2348
            maxfd = g___3.out;
          }
        }
#line 2351
        if (g___3.err != -1) {
#line 2353
          readfds[0].fds_bits[g___3.err / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << g___3.err % (8 * (int )sizeof(__fd_mask )));
#line 2354
          if (g___3.err > maxfd) {
#line 2355
            maxfd = g___3.err;
          }
        }
      }
      {
#line 2359
      n = select(maxfd + 1, (fd_set */* __restrict  */)(readfds), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
      }
#line 2359
      if (n == -1) {
        {
#line 2359
        tmp___1 = __errno_location();
        }
#line 2359
        if (*tmp___1 != 4) {
#line 2361
          if (g___3.foreground) {
#line 2361
            tmp___0 = "input/";
          } else {
#line 2361
            tmp___0 = "";
          }
          {
#line 2361
          errorsys("failed to select(2): refusing to handle client %soutput anymore",
                   tmp___0);
          }
#line 2362
          goto while_break___0;
        }
      }
#line 2365
      if (n == -1) {
        {
#line 2365
        tmp___2 = __errno_location();
        }
#line 2365
        if (*tmp___2 == 4) {
          {
#line 2367
          debugf((size_t )9, "select(2) was interrupted by a signal");
          }
#line 2368
          goto __Cont;
        }
      }
#line 2371
      if (g___3.masterfd != -1) {
#line 2371
        tmp___3 = "pty";
      } else {
#line 2371
        tmp___3 = "pipes";
      }
      {
#line 2371
      debugf((size_t )9, "select(%s) returned %d", tmp___3, n);
      }
#line 2373
      if (g___3.out != -1) {
#line 2373
        if ((readfds[0].fds_bits[g___3.out / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << g___3.out % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 2375
          tmp___9 = read(g___3.out, (void *)(buf), (size_t )8192);
#line 2375
          n = (int )tmp___9;
          }
#line 2375
          if (n > 0) {
            {
#line 2379
            debugf((size_t )2, "read(out) returned %d", n);
#line 2380
            buf[n] = (char )'\000';
            }
#line 2382
            if (g___3.foreground) {
              {
#line 2383
              tmp___4 = write(1, (void const   *)(buf), (size_t )n);
              }
#line 2383
              if (tmp___4 == -1L) {
                {
#line 2384
                errorsys("failed to write(fd stdout, buf %*.*s)", n, n, buf);
                }
              }
            }
#line 2386
            if (g___3.client_outfd != -1) {
              {
#line 2388
              debugf((size_t )2, "writing client stdout (fd %d, %d bytes)", g___3.client_outfd,
                     n);
#line 2390
              tmp___5 = write(g___3.client_outfd, (void const   *)(buf), (size_t )n);
              }
#line 2390
              if (tmp___5 == -1L) {
                {
#line 2391
                errorsys("failed to write(client_outfd = %d)", g___3.client_outfd);
                }
              }
            }
#line 2394
            if (g___3.client_outlog) {
#line 2396
              p = buf;
              {
#line 2396
              while (1) {
                while_continue___2: /* CIL Label */ ;
                {
#line 2396
                q = strchr((char const   *)p, '\n');
                }
#line 2396
                if (! q) {
#line 2396
                  goto while_break___2;
                }
                {
#line 2398
                debugf((size_t )2, "stdout syslog(%s, %*.*s)", g___3.client_out, q - p,
                       q - p, p);
#line 2399
                syslog(g___3.client_outlog, "%*.*s", (int )(q - p), (int )(q - p),
                       p);
#line 2396
                p = q + 1;
                }
              }
              while_break___2: /* CIL Label */ ;
              }
#line 2402
              if (*p) {
#line 2402
                if ((int )*p != 10) {
                  {
#line 2404
                  debugf((size_t )2, "stdout syslog(%s, %s)", g___3.client_out, p);
#line 2405
                  syslog(g___3.client_outlog, "%s", p);
                  }
                } else
#line 2402
                if ((int )*(p + 1) != 0) {
                  {
#line 2404
                  debugf((size_t )2, "stdout syslog(%s, %s)", g___3.client_out, p);
#line 2405
                  syslog(g___3.client_outlog, "%s", p);
                  }
                }
              }
            }
          } else
#line 2409
          if (n == -1) {
            {
#line 2409
            tmp___8 = __errno_location();
            }
#line 2409
            if (*tmp___8 == 4) {
              {
#line 2411
              debugf((size_t )2, "read(out) was interrupted by a signal\n");
              }
#line 2412
              goto __Cont;
            } else {
#line 2409
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 2414
          if (n == -1) {
            {
#line 2416
            errorsys("read(out) failed, refusing to handle client stdout anymore");
#line 2418
            tmp___6 = close(g___3.out);
            }
#line 2418
            if (tmp___6 == -1) {
              {
#line 2419
              errorsys("failed to close(out = %d)", g___3.out);
              }
            }
#line 2421
            g___3.out = -1;
          } else {
            {
#line 2425
            debugf((size_t )2, "read(out) returned %d, closing out", n);
#line 2427
            tmp___7 = close(g___3.out);
            }
#line 2427
            if (tmp___7 == -1) {
              {
#line 2428
              errorsys("failed to close(out = %d)", g___3.out);
              }
            }
#line 2430
            g___3.out = -1;
          }
        }
      }
#line 2434
      if (g___3.err != -1) {
#line 2434
        if ((readfds[0].fds_bits[g___3.err / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << g___3.err % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 2436
          tmp___15 = read(g___3.err, (void *)(buf), (size_t )8192);
#line 2436
          n = (int )tmp___15;
          }
#line 2436
          if (n > 0) {
            {
#line 2440
            debugf((size_t )2, "read(err) returned %d", n);
#line 2441
            buf[n] = (char )'\000';
            }
#line 2443
            if (g___3.foreground) {
              {
#line 2444
              tmp___10 = write(2, (void const   *)(buf), (size_t )n);
              }
#line 2444
              if (tmp___10 == -1L) {
                {
#line 2445
                errorsys("failed to write(fd stderr, buf %*.*s)", n, n, buf);
                }
              }
            }
#line 2447
            if (g___3.client_errfd != -1) {
              {
#line 2449
              debugf((size_t )2, "writing client stderr (fd %d, %d bytes)", g___3.client_errfd,
                     n);
#line 2451
              tmp___11 = write(g___3.client_errfd, (void const   *)(buf), (size_t )n);
              }
#line 2451
              if (tmp___11 == -1L) {
                {
#line 2452
                errorsys("failed to write(client_errfd = %d)", g___3.client_errfd);
                }
              }
            }
#line 2455
            if (g___3.client_errlog) {
#line 2457
              p___0 = buf;
              {
#line 2457
              while (1) {
                while_continue___3: /* CIL Label */ ;
                {
#line 2457
                q___0 = strchr((char const   *)p___0, '\n');
                }
#line 2457
                if (! q___0) {
#line 2457
                  goto while_break___3;
                }
                {
#line 2459
                debugf((size_t )2, "stderr syslog(%s, %*.*s)", g___3.client_err, q___0 - p___0,
                       q___0 - p___0, p___0);
#line 2460
                syslog(g___3.client_errlog, "%*.*s", (int )(q___0 - p___0), (int )(q___0 - p___0),
                       p___0);
#line 2457
                p___0 = q___0 + 1;
                }
              }
              while_break___3: /* CIL Label */ ;
              }
#line 2463
              if (*p___0) {
#line 2463
                if ((int )*p___0 != 10) {
                  {
#line 2465
                  debugf((size_t )2, "stderr syslog(%s, %s)", g___3.client_err, p___0);
#line 2466
                  syslog(g___3.client_errlog, "%s", p___0);
                  }
                } else
#line 2463
                if ((int )*(p___0 + 1) != 0) {
                  {
#line 2465
                  debugf((size_t )2, "stderr syslog(%s, %s)", g___3.client_err, p___0);
#line 2466
                  syslog(g___3.client_errlog, "%s", p___0);
                  }
                }
              }
            }
          } else
#line 2470
          if (n == -1) {
            {
#line 2470
            tmp___14 = __errno_location();
            }
#line 2470
            if (*tmp___14 == 4) {
              {
#line 2472
              debugf((size_t )2, "read(err) was interrupted by a signal\n");
              }
#line 2473
              goto __Cont;
            } else {
#line 2470
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 2475
          if (n == -1) {
            {
#line 2477
            errorsys("read(err) failed, refusing to handle client stderr anymore");
#line 2479
            tmp___12 = close(g___3.err);
            }
#line 2479
            if (tmp___12 == -1) {
              {
#line 2480
              errorsys("failed to close(err = %d)", g___3.err);
              }
            }
#line 2482
            g___3.err = -1;
          } else {
            {
#line 2486
            debugf((size_t )2, "read(err) returned %d, closing err", n);
#line 2488
            tmp___13 = close(g___3.err);
            }
#line 2488
            if (tmp___13 == -1) {
              {
#line 2489
              errorsys("failed to close(err = %d)", g___3.err);
              }
            }
#line 2491
            g___3.err = -1;
          }
        }
      }
#line 2495
      if (g___3.masterfd != -1) {
#line 2495
        if ((readfds[0].fds_bits[g___3.masterfd / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << g___3.masterfd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 2497
          tmp___20 = read(g___3.masterfd, (void *)(buf), (size_t )8192);
#line 2497
          n = (int )tmp___20;
          }
#line 2497
          if (n > 0) {
            {
#line 2501
            debugf((size_t )2, "read(masterfd) returned %d", n);
#line 2502
            buf[n] = (char )'\000';
            }
#line 2504
            if (g___3.foreground) {
              {
#line 2505
              tmp___16 = write(1, (void const   *)(buf), (size_t )n);
              }
#line 2505
              if (tmp___16 == -1L) {
                {
#line 2506
                errorsys("failed to write(fd stdout, buf %*.*s)", n, n, buf);
                }
              }
            }
#line 2508
            if (g___3.client_outfd != -1) {
              {
#line 2510
              debugf((size_t )2, "writing client stdout/stderr (fd %d, %d bytes)",
                     g___3.client_outfd, n);
#line 2512
              tmp___17 = write(g___3.client_outfd, (void const   *)(buf), (size_t )n);
              }
#line 2512
              if (tmp___17 == -1L) {
                {
#line 2513
                errorsys("failed to write(client_outfd = %d)", g___3.client_outfd);
                }
              }
            }
#line 2516
            if (g___3.client_outlog) {
#line 2518
              p___1 = buf;
              {
#line 2518
              while (1) {
                while_continue___4: /* CIL Label */ ;
                {
#line 2518
                q___1 = strchr((char const   *)p___1, '\n');
                }
#line 2518
                if (! q___1) {
#line 2518
                  goto while_break___4;
                }
                {
#line 2520
                debugf((size_t )2, "stdout syslog(%s, %*.*s)", g___3.client_out, q___1 - p___1,
                       q___1 - p___1, p___1);
#line 2521
                syslog(g___3.client_outlog, "%*.*s", (int )(q___1 - p___1), (int )(q___1 - p___1),
                       p___1);
#line 2518
                p___1 = q___1 + 1;
                }
              }
              while_break___4: /* CIL Label */ ;
              }
#line 2524
              if (*p___1) {
#line 2524
                if ((int )*p___1 != 10) {
                  {
#line 2526
                  debugf((size_t )2, "stdout syslog(%s, %s)", g___3.client_out, p___1);
#line 2527
                  syslog(g___3.client_outlog, "%s", p___1);
                  }
                } else
#line 2524
                if ((int )*(p___1 + 1) != 0) {
                  {
#line 2526
                  debugf((size_t )2, "stdout syslog(%s, %s)", g___3.client_out, p___1);
#line 2527
                  syslog(g___3.client_outlog, "%s", p___1);
                  }
                }
              }
            }
          } else
#line 2531
          if (n == -1) {
            {
#line 2531
            tmp___19 = __errno_location();
            }
#line 2531
            if (*tmp___19 == 4) {
              {
#line 2533
              debugf((size_t )2, "read(masterfd) was interrupted by a signal\n");
              }
#line 2534
              goto __Cont;
            } else {
#line 2531
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 2536
          if (n == -1) {
            {
#line 2538
            tmp___18 = __errno_location();
            }
#line 2538
            if (*tmp___18 != 5) {
              {
#line 2539
              errorsys("read(masterfd) failed, refusing to handle client output anymore");
              }
            }
#line 2541
            goto while_break___0;
          } else {
            {
#line 2545
            debugf((size_t )2, "read(masterfd) returned %d, closing masterfd", n);
            }
#line 2546
            goto while_break___0;
          }
        }
      }
#line 2550
      if (g___3.foreground) {
#line 2550
        if ((readfds[0].fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << 0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 2552
          tmp___28 = read(0, (void *)(buf), (size_t )8192);
#line 2552
          n = (int )tmp___28;
          }
#line 2552
          if (n > 0) {
            {
#line 2554
            debugf((size_t )2, "read(stdin) returned %d", n);
#line 2555
            buf[n] = (char )'\000';
            }
#line 2557
            if (g___3.masterfd != -1) {
              {
#line 2559
              tmp___21 = write(g___3.masterfd, (void const   *)(buf), (size_t )n);
              }
#line 2559
              if (tmp___21 != (ssize_t )n) {
                {
#line 2561
                errorsys("failed to write(masterfd = %d)", g___3.masterfd);
                }
#line 2562
                goto while_break___0;
              }
            } else
#line 2565
            if (g___3.in != -1) {
              {
#line 2567
              tmp___23 = write(g___3.in, (void const   *)(buf), (size_t )n);
              }
#line 2567
              if (tmp___23 != (ssize_t )n) {
                {
#line 2569
                errorsys("failed to write(in = %d), closing in", g___3.in);
#line 2571
                tmp___22 = close(g___3.in);
                }
#line 2571
                if (tmp___22 == -1) {
                  {
#line 2572
                  errorsys("failed to close(in = %d)", g___3.in);
                  }
                }
#line 2574
                g___3.in = -1;
              }
            }
          } else
#line 2578
          if (n == -1) {
            {
#line 2578
            tmp___27 = __errno_location();
            }
#line 2578
            if (*tmp___27 == 4) {
              {
#line 2580
              debugf((size_t )2, "read(stdin) was interrupted by a signal\n");
              }
#line 2581
              goto __Cont;
            } else {
#line 2578
              goto _L___2;
            }
          } else {
            _L___2: /* CIL Label */ 
#line 2585
            if (g___3.masterfd != -1) {
              {
#line 2588
              eof = (char)4;
#line 2590
              tmp___24 = tcgetattr(g___3.masterfd, attr);
              }
#line 2590
              if (tmp___24 == -1) {
                {
#line 2591
                errorsys("failed to get terminal attributes for masterfd = %d", g___3.masterfd);
                }
              } else {
#line 2593
                eof = (char )attr[0].c_cc[4];
              }
              {
#line 2595
              debugsysf((size_t )2, "read(stdin) returned %d, sending eof(%d) to masterfd",
                        n, (int )eof);
#line 2597
              tmp___25 = write(g___3.masterfd, (void const   *)(& eof), (size_t )1);
              }
#line 2597
              if (tmp___25 == -1L) {
                {
#line 2599
                errorsys("failed to write(masterfd = %d) when sending eof (%d)", g___3.masterfd,
                         (int )eof);
                }
#line 2600
                goto while_break___0;
              }
            } else
#line 2603
            if (g___3.in != -1) {
              {
#line 2605
              debugsysf((size_t )2, "read(stdin) returned %d, closing in", n);
#line 2607
              tmp___26 = close(g___3.in);
              }
#line 2607
              if (tmp___26 == -1) {
                {
#line 2608
                errorsys("failed to close(in = %d)", g___3.in);
                }
              }
#line 2610
              g___3.in = -1;
            }
#line 2613
            g___3.stdin_eof = 1;
          }
        }
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2618
    debugf((size_t )2, "no more output, just wait for child to terminate");
#line 2620
    examine_child();
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2632 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void show(void) 
{ 
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;
  char const   *tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;
  char const   *tmp___31 ;
  char const   *tmp___32 ;
  char const   *tmp___33 ;
  char const   *tmp___34 ;
  char const   *tmp___35 ;
  char const   *tmp___36 ;
  char const   *tmp___37 ;
  char const   *tmp___38 ;
  char const   *tmp___39 ;
  char const   *tmp___40 ;
  char const   *tmp___41 ;
  char const   *tmp___42 ;
  char const   *tmp___43 ;
  char **tmp___44 ;
  char **tmp___45 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;

  {
  {
#line 2636
  debugf((size_t )1, "show()");
#line 2638
  debugf((size_t )2, "options:");
#line 2640
  tmp = prog_debug_level();
#line 2640
  tmp___0 = prog_verbosity_level();
  }
#line 2640
  if (g___3.running) {
#line 2640
    tmp___1 = "yes";
  } else {
#line 2640
    tmp___1 = "no";
  }
#line 2640
  if (g___3.stop) {
#line 2640
    tmp___2 = "yes";
  } else {
#line 2640
    tmp___2 = "no";
  }
#line 2640
  if (g___3.safe) {
#line 2640
    tmp___3 = "yes";
  } else {
#line 2640
    tmp___3 = "no";
  }
#line 2640
  if (g___3.unsafe) {
#line 2640
    tmp___4 = "yes";
  } else {
#line 2640
    tmp___4 = "no";
  }
#line 2640
  if (g___3.core) {
#line 2640
    tmp___5 = "yes";
  } else {
#line 2640
    tmp___5 = "no";
  }
#line 2640
  if (g___3.daemon_dbglog) {
#line 2640
    tmp___7 = "";
  } else {
#line 2640
    if (g___3.daemon_dbg) {
#line 2640
      tmp___6 = (char const   *)g___3.client_out;
    } else {
#line 2640
      tmp___6 = "<none>";
    }
#line 2640
    tmp___7 = tmp___6;
  }
#line 2640
  if (g___3.daemon_dbglog) {
    {
#line 2640
    tmp___8 = syslog_priority_str(g___3.daemon_dbglog);
#line 2640
    tmp___9 = tmp___8;
    }
  } else {
#line 2640
    tmp___9 = "";
  }
#line 2640
  if (g___3.daemon_dbglog) {
#line 2640
    tmp___10 = ".";
  } else {
#line 2640
    tmp___10 = "";
  }
#line 2640
  if (g___3.daemon_dbglog) {
    {
#line 2640
    tmp___11 = syslog_facility_str(g___3.daemon_dbglog);
#line 2640
    tmp___12 = tmp___11;
    }
  } else {
#line 2640
    tmp___12 = "";
  }
#line 2640
  if (g___3.daemon_errlog) {
#line 2640
    tmp___14 = "";
  } else {
#line 2640
    if (g___3.daemon_err) {
#line 2640
      tmp___13 = (char const   *)g___3.client_out;
    } else {
#line 2640
      tmp___13 = "<none>";
    }
#line 2640
    tmp___14 = tmp___13;
  }
#line 2640
  if (g___3.daemon_errlog) {
    {
#line 2640
    tmp___15 = syslog_priority_str(g___3.daemon_errlog);
#line 2640
    tmp___16 = tmp___15;
    }
  } else {
#line 2640
    tmp___16 = "";
  }
#line 2640
  if (g___3.daemon_errlog) {
#line 2640
    tmp___17 = ".";
  } else {
#line 2640
    tmp___17 = "";
  }
#line 2640
  if (g___3.daemon_errlog) {
    {
#line 2640
    tmp___18 = syslog_facility_str(g___3.daemon_errlog);
#line 2640
    tmp___19 = tmp___18;
    }
  } else {
#line 2640
    tmp___19 = "";
  }
#line 2640
  if (g___3.client_errlog) {
#line 2640
    tmp___21 = "";
  } else {
#line 2640
    if (g___3.client_err) {
#line 2640
      tmp___20 = (char const   *)g___3.client_out;
    } else {
#line 2640
      tmp___20 = "<none>";
    }
#line 2640
    tmp___21 = tmp___20;
  }
#line 2640
  if (g___3.client_errlog) {
    {
#line 2640
    tmp___22 = syslog_priority_str(g___3.client_errlog);
#line 2640
    tmp___23 = tmp___22;
    }
  } else {
#line 2640
    tmp___23 = "";
  }
#line 2640
  if (g___3.client_errlog) {
#line 2640
    tmp___24 = ".";
  } else {
#line 2640
    tmp___24 = "";
  }
#line 2640
  if (g___3.client_errlog) {
    {
#line 2640
    tmp___25 = syslog_facility_str(g___3.client_errlog);
#line 2640
    tmp___26 = tmp___25;
    }
  } else {
#line 2640
    tmp___26 = "";
  }
#line 2640
  if (g___3.client_outlog) {
#line 2640
    tmp___28 = "";
  } else {
#line 2640
    if (g___3.client_out) {
#line 2640
      tmp___27 = (char const   *)g___3.client_out;
    } else {
#line 2640
      tmp___27 = "<none>";
    }
#line 2640
    tmp___28 = tmp___27;
  }
#line 2640
  if (g___3.client_outlog) {
    {
#line 2640
    tmp___29 = syslog_priority_str(g___3.client_outlog);
#line 2640
    tmp___30 = tmp___29;
    }
  } else {
#line 2640
    tmp___30 = "";
  }
#line 2640
  if (g___3.client_outlog) {
#line 2640
    tmp___31 = ".";
  } else {
#line 2640
    tmp___31 = "";
  }
#line 2640
  if (g___3.client_outlog) {
    {
#line 2640
    tmp___32 = syslog_facility_str(g___3.client_outlog);
#line 2640
    tmp___33 = tmp___32;
    }
  } else {
#line 2640
    tmp___33 = "";
  }
#line 2640
  if (g___3.noecho) {
#line 2640
    tmp___34 = "yes";
  } else {
#line 2640
    tmp___34 = "no";
  }
#line 2640
  if (g___3.pty) {
#line 2640
    tmp___35 = "yes";
  } else {
#line 2640
    tmp___35 = "no";
  }
#line 2640
  if (g___3.foreground) {
#line 2640
    tmp___36 = "yes";
  } else {
#line 2640
    tmp___36 = "no";
  }
#line 2640
  if (g___3.respawn) {
#line 2640
    tmp___37 = "yes";
  } else {
#line 2640
    tmp___37 = "no";
  }
#line 2640
  if (g___3.inherit) {
#line 2640
    tmp___38 = "yes";
  } else {
#line 2640
    tmp___38 = "no";
  }
#line 2640
  if (g___3.chdir) {
#line 2640
    tmp___39 = (char const   *)g___3.chdir;
  } else {
#line 2640
    tmp___39 = "<none>";
  }
#line 2640
  if (g___3.chroot) {
#line 2640
    tmp___40 = (char const   *)g___3.chroot;
  } else {
#line 2640
    tmp___40 = "<none>";
  }
#line 2640
  if (g___3.command) {
#line 2640
    tmp___41 = (char const   *)g___3.command;
  } else {
#line 2640
    tmp___41 = "<none>";
  }
#line 2640
  if (g___3.name) {
#line 2640
    tmp___42 = (char const   *)g___3.name;
  } else {
#line 2640
    tmp___42 = "<none>";
  }
#line 2640
  if (g___3.config) {
#line 2640
    tmp___43 = (char const   *)g___3.config;
  } else {
#line 2640
    tmp___43 = "<none>";
  }
  {
#line 2640
  debugf((size_t )2, " config %s, noconfig %d, name %s, command \"%s\", uid %d, gid %d, init_groups %d, chroot %s, chdir %s, umask %o, inherit %s, respawn %s, acceptable %d, attempts %d, delay %d, limit %d, idiot %d, foreground %s, pty %s, noecho %s, stdout %s%s%s%s, stderr %s%s%s%s, errlog %s%s%s%s, dbglog %s%s%s%s, core %s, unsafe %s, safe %s, stop %s, running %s, verbose %d, debug %d",
         tmp___43, g___3.noconfig, tmp___42, tmp___41, g___3.uid, g___3.gid, g___3.init_groups,
         tmp___40, tmp___39, g___3.umask, tmp___38, tmp___37, g___3.acceptable, g___3.attempts,
         g___3.delay, g___3.limit, g___3.idiot, tmp___36, tmp___35, tmp___34, tmp___33,
         tmp___31, tmp___30, tmp___28, tmp___26, tmp___24, tmp___23, tmp___21, tmp___19,
         tmp___17, tmp___16, tmp___14, tmp___12, tmp___10, tmp___9, tmp___7, tmp___5,
         tmp___4, tmp___3, tmp___2, tmp___1, tmp___0, tmp);
#line 2686
  debugf((size_t )2, "command line:");
  }
#line 2688
  if (g___3.cmd) {
#line 2690
    i = 0;
    {
#line 2690
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2690
      if (! *(g___3.cmd + i)) {
#line 2690
        goto while_break;
      }
      {
#line 2692
      debugf((size_t )2, " argv[%d] = \"%s\"", i, *(g___3.cmd + i));
#line 2690
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 2696
  debugf((size_t )3, "environment:");
#line 2698
  i = 0;
  }
  {
#line 2698
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2698
    if (g___3.environ) {
#line 2698
      tmp___45 = g___3.environ;
    } else {
#line 2698
      tmp___45 = environ;
    }
#line 2698
    if (! *(tmp___45 + i)) {
#line 2698
      goto while_break___0;
    }
#line 2700
    if (g___3.environ) {
#line 2700
      tmp___44 = g___3.environ;
    } else {
#line 2700
      tmp___44 = environ;
    }
    {
#line 2700
    debugf((size_t )3, " %s", *(tmp___44 + i));
#line 2698
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2702
  return;
}
}
#line 2714
static int safety_check(char const   *cmd , char *explanation , size_t explanation_size ) ;
#line 2716 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static int safety_check_script(char const   *cmd , char *explanation , size_t explanation_size ) 
{ 
  char intbuf[256] ;
  ssize_t bytes ;
  size_t end ;
  int ret ;
  int fd ;
  char oldch ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 2731
  fd = open(cmd, 0);
  }
#line 2731
  if (fd != -1) {
    {
#line 2733
    bytes = read(fd, (void *)(intbuf), (size_t )256);
#line 2734
    intbuf[255] = (char )'\000';
#line 2735
    close(fd);
    }
#line 2737
    if (bytes > 0L) {
#line 2737
      if ((int )intbuf[0] == 35) {
#line 2737
        if ((int )intbuf[1] == 33) {
          {
#line 2739
          end = strcspn((char const   *)(intbuf + 2), " \n");
          }
#line 2739
          if (end) {
            {
#line 2741
            oldch = intbuf[2UL + end];
#line 2743
            intbuf[2UL + end] = (char )'\000';
#line 2745
            debugf((size_t )2, "checking #! interpreter: %s", intbuf + 2);
#line 2747
            ret = daemon_path_is_safe((char const   *)(intbuf + 2), explanation, explanation_size);
            }
#line 2747
            if (ret != 1) {
#line 2748
              return (ret);
            }
            {
#line 2752
            tmp = strncmp((char const   *)(intbuf + 2), "/usr/bin/env", (size_t )12);
            }
#line 2752
            if (! tmp) {
              {
#line 2752
              tmp___0 = __ctype_b_loc();
              }
#line 2752
              if ((int const   )*(*tmp___0 + (int )((unsigned char )oldch)) & 8192) {
                {
#line 2754
                end = strcspn((char const   *)(intbuf + 15), " \n");
                }
#line 2754
                if (end) {
#line 2755
                  intbuf[15UL + end] = (char )'\000';
                }
                {
#line 2757
                debugf((size_t )2, "checking interpreter (via env): %s", intbuf + 15);
#line 2759
                ret = safety_check((char const   *)(intbuf + 15), explanation, explanation_size);
                }
#line 2759
                if (ret != 1) {
#line 2760
                  return (ret);
                }
              }
            }
          }
        }
      }
    }
  }
#line 2766
  return (1);
}
}
#line 2791 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static int safety_check(char const   *cmd , char *explanation , size_t explanation_size ) 
{ 
  struct stat status[1] ;
  char cmdbuf[512] ;
  char *path ;
  char *s ;
  char *f ;
  int ret ;
  char *tmp ;
  __uid_t tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp20 ;
  int __cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
  {
#line 2798
  debugf((size_t )1, "safety_check(\"%s\")", cmd);
  }
#line 2802
  if ((int const   )*(cmd + 0) == 47) {
#line 2802
    goto _L;
  } else {
    {
#line 2802
    tmp = strchr(cmd, '/');
    }
#line 2802
    if (tmp) {
      _L: /* CIL Label */ 
      {
#line 2804
      path = daemon_absolute_path(cmd);
      }
#line 2804
      if (! path) {
#line 2805
        return (-1);
      }
      {
#line 2807
      debugf((size_t )2, "checking \"%s\"", path);
#line 2809
      ret = daemon_path_is_safe((char const   *)path, explanation, explanation_size);
      }
#line 2809
      if (ret != 1) {
        {
#line 2811
        free((void *)path);
        }
#line 2812
        return (ret);
      }
      {
#line 2815
      ret = safety_check_script((char const   *)path, explanation, explanation_size);
#line 2816
      free((void *)path);
      }
#line 2818
      return (ret);
    }
  }
  {
#line 2823
  path = getenv("PATH");
  }
#line 2823
  if (! path) {
    {
#line 2824
    tmp___1 = geteuid();
    }
#line 2824
    if (tmp___1) {
#line 2824
      path = (char *)":/bin:/usr/bin";
    } else {
#line 2824
      path = (char *)"/bin:/usr/bin";
    }
  }
  {
#line 2826
  debugf((size_t )2, "PATH = %s", path);
#line 2828
  s = path;
  }
  {
#line 2828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2828
    if (! s) {
#line 2828
      goto while_break;
    }
    {
#line 2830
    f = strchr((char const   *)s, ':');
    }
#line 2830
    if (! f) {
      {
#line 2831
      tmp___2 = strlen((char const   *)s);
#line 2831
      f = s + tmp___2;
      }
    }
#line 2833
    if (f - s) {
#line 2833
      tmp___3 = "/";
    } else {
#line 2833
      tmp___3 = "";
    }
    {
#line 2833
    tmp___4 = snprintf((char */* __restrict  */)(cmdbuf), (size_t )512, (char const   */* __restrict  */)"%.*s%s%s",
                       (int )(f - s), s, tmp___3, cmd);
    }
#line 2833
    if (tmp___4 >= 512) {
#line 2834
      goto __Cont;
    }
    {
#line 2838
    tmp___6 = stat((char const   */* __restrict  */)(cmdbuf), (struct stat */* __restrict  */)(status));
    }
#line 2838
    if (tmp___6 == -1) {
      {
#line 2840
      tmp___5 = __errno_location();
      }
#line 2840
      if (*tmp___5 != 2) {
        {
#line 2841
        errorsys("failed to stat(\"%s\")", cmdbuf);
        }
      }
#line 2843
      goto __Cont;
    }
#line 2846
    if (status[0].st_mode & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
      {
#line 2848
      debugf((size_t )2, "checking \"%s\"", cmdbuf);
#line 2850
      ret = daemon_path_is_safe((char const   *)(cmdbuf), explanation, explanation_size);
      }
#line 2850
      if (ret != 1) {
#line 2851
        return (ret);
      }
      {
#line 2853
      tmp___7 = safety_check_script((char const   *)(cmdbuf), explanation, explanation_size);
      }
#line 2853
      return (tmp___7);
    }
    __Cont: /* CIL Label */ 
#line 2828
    if (*f) {
#line 2828
      s = f + 1;
    } else {
#line 2828
      s = (char *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2857
  tmp___8 = set_errno(2);
  }
#line 2857
  return (tmp___8);
}
}
#line 2868 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void sanity_check(void) 
{ 
  struct stat status[1] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp5 ;
  int __cil_tmp6 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 2872
  debugf((size_t )1, "sanity_check()");
  }
#line 2874
  if (g___3.acceptable != 300) {
#line 2874
    if (! g___3.respawn) {
      {
#line 2875
      prog_usage_msg("Missing option: --respawn (required for --acceptable)");
      }
    }
  }
#line 2877
  if (g___3.attempts != 5) {
#line 2877
    if (! g___3.respawn) {
      {
#line 2878
      prog_usage_msg("Missing option: --respawn (required for --attempts)");
      }
    }
  }
#line 2880
  if (g___3.delay != 300) {
#line 2880
    if (! g___3.respawn) {
      {
#line 2881
      prog_usage_msg("Missing option: --respawn (required for --delay)");
      }
    }
  }
#line 2883
  if (g___3.limit != 0) {
#line 2883
    if (! g___3.respawn) {
      {
#line 2884
      prog_usage_msg("Missing option: --respawn (required for --limit)");
      }
    }
  }
#line 2886
  if (g___3.idiot) {
#line 2886
    if (! g___3.respawn) {
      {
#line 2887
      prog_usage_msg("Missing option: --respawn (required for --idiot)");
      }
    }
  }
#line 2889
  if (g___3.pty) {
#line 2889
    if (! g___3.foreground) {
      {
#line 2890
      prog_usage_msg("Missing option: --foreground (required for --pty)");
      }
    }
  }
#line 2892
  if (g___3.pidfiles) {
#line 2892
    if (! g___3.name) {
      {
#line 2893
      prog_usage_msg("Missing option: --name (required for --pidfiles)");
      }
    }
  }
#line 2895
  if (g___3.stop) {
#line 2895
    if (! g___3.name) {
      {
#line 2896
      prog_usage_msg("Missing option: --name (required for --stop)");
      }
    }
  }
#line 2898
  if (g___3.running) {
#line 2898
    if (! g___3.name) {
      {
#line 2899
      prog_usage_msg("Missing option: --name (required for --running)");
      }
    }
  }
#line 2901
  if (g___3.restart) {
#line 2901
    if (! g___3.name) {
      {
#line 2902
      prog_usage_msg("Missing option: --name (required for --restart)");
      }
    }
  }
#line 2904
  if (g___3.running) {
#line 2904
    if (g___3.restart) {
      {
#line 2905
      prog_usage_msg("Incompatible options: --running and --restart");
      }
    }
  }
#line 2907
  if (g___3.running) {
#line 2907
    if (g___3.stop) {
      {
#line 2908
      prog_usage_msg("Incompatible options: --running and --stop");
      }
    }
  }
#line 2910
  if (g___3.restart) {
#line 2910
    if (g___3.stop) {
      {
#line 2911
      prog_usage_msg("Incompatible options: --restart and --stop");
      }
    }
  }
#line 2913
  if (g___3.safe) {
#line 2913
    if (g___3.unsafe) {
      {
#line 2914
      prog_usage_msg("Incompatible options: --safe and --unsafe");
      }
    }
  }
#line 2916
  if (g___3.config) {
#line 2916
    if (g___3.noconfig) {
      {
#line 2917
      prog_usage_msg("Incompatible options: --config and --noconfig");
      }
    }
  }
#line 2919
  if (g___3.config) {
    {
#line 2919
    tmp___1 = stat((char const   */* __restrict  */)g___3.config, (struct stat */* __restrict  */)(status));
    }
#line 2919
    if (tmp___1 == -1) {
      {
#line 2920
      tmp = __errno_location();
#line 2920
      tmp___0 = strerror(*tmp);
#line 2920
      prog_usage_msg("Invalid --config option argument %s: %s", g___3.config, tmp___0);
      }
    }
  }
#line 2921
  return;
}
}
#line 2936 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
static void init(int ac , char **av ) 
{ 
  mode_t mode ;
  int flags ;
  List *cmd ;
  int i ;
  int a ;
  char *name ;
  char const   *tmp ;
  __gid_t tmp___0 ;
  __uid_t tmp___1 ;
  __gid_t tmp___2 ;
  __uid_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  struct group *grp ;
  struct group *tmp___7 ;
  struct passwd *pwd ;
  struct passwd *tmp___8 ;
  __gid_t tmp___9 ;
  __uid_t tmp___10 ;
  __gid_t tmp___11 ;
  __uid_t tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char const   *suffix ;
  size_t size ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  void *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  pid_t tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  ssize_t tmp___28 ;
  ssize_t tmp___29 ;
  void *tmp___30 ;
  char *tmp___31 ;
  void *tmp___32 ;
  char *tmp___33 ;
  ssize_t tmp___34 ;
  char explanation[256] ;
  int tmp___35 ;
  __uid_t tmp___36 ;
  char *tmp___37 ;
  int tmp___38 ;
  int rc ;
  char const   *tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  char const   *tmp___42 ;
  char const   *tmp___43 ;
  char const   *tmp___44 ;
  char const   *tmp___45 ;
  char const   *tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  char const   *tmp___49 ;
  char const   *tmp___50 ;
  char const   *tmp___51 ;
  char const   *tmp___52 ;
  char const   *tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  void *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;

  {
  {
#line 2940
  cmd = (List *)((void *)0);
#line 2941
  i = 0;
#line 2943
  name = (char *)((void *)0);
#line 2945
  prog_dbg_stdout();
#line 2946
  debugf((size_t )1, "init()");
#line 2950
  setlocale(6, "");
#line 2951
  prog_init();
#line 2955
  prog_set_name("daemon");
#line 2956
  prog_set_version("0.6.4");
#line 2957
  prog_set_date("20100612");
#line 2958
  prog_set_syntax("[options] [--] [cmd arg...]");
#line 2959
  prog_set_options(options);
#line 2960
  prog_set_author("raf <raf@raf.org>");
#line 2961
  tmp = prog_author();
#line 2961
  prog_set_contact(tmp);
#line 2962
  prog_set_url("http://libslack.org/daemon/");
#line 2964
  prog_set_legal("Copyright (C) 1999-2010 raf <raf@raf.org>\n\nThis is free software released under the terms of the GPL:\n\n    http://www.gnu.org/copyleft/gpl.html\n\nThere is no warranty; not even for merchantability or fitness\nfor a particular purpose.\n");
#line 2981
  prog_set_desc("Daemon turns other processes into daemons.\nSee the daemon(1) manpage for more information.\n");
#line 2989
  debugf((size_t )2, "revoking privileges");
#line 2991
  tmp___4 = daemon_revoke_privileges();
  }
#line 2991
  if (tmp___4 == -1) {
    {
#line 2992
    tmp___0 = getegid();
#line 2992
    tmp___1 = geteuid();
#line 2992
    tmp___2 = getgid();
#line 2992
    tmp___3 = getuid();
#line 2992
    fatalsys("failed to revoke uid/gid privileges: uid/gid = %d/%d euid/egid = %d/%d",
             tmp___3, tmp___2, tmp___1, tmp___0);
    }
  }
  {
#line 2996
  debugf((size_t )2, "processing command line options");
#line 2998
  g___3.initial_uid = getuid();
#line 2999
  g___3.av = av;
#line 2999
  g___3.ac = ac;
#line 2999
  a = prog_opt_process(g___3.ac, g___3.av);
#line 3000
  g___3.done_name = 1;
  }
#line 3004
  if (g___3.chroot) {
    {
#line 3006
    debugf((size_t )2, "chroot %s", g___3.chroot);
#line 3008
    tmp___5 = chdir((char const   *)g___3.chroot);
    }
#line 3008
    if (tmp___5 == -1) {
      {
#line 3009
      fatalsys("failed to change directory to new root directory %s", g___3.chroot);
      }
    }
    {
#line 3011
    tmp___6 = chroot((char const   *)g___3.chroot);
    }
#line 3011
    if (tmp___6 == -1) {
      {
#line 3012
      fatalsys("failed to change root directory to %s", g___3.chroot);
      }
    }
  }
#line 3015
  g___3.done_chroot = 1;
#line 3019
  if (g___3.uid) {
    {
#line 3021
    debugf((size_t )2, "changing to user %s/%d", g___3.user, g___3.uid);
    }
#line 3023
    if (g___3.init_groups) {
#line 3023
      tmp___15 = g___3.user;
    } else {
#line 3023
      tmp___15 = (char *)((void *)0);
    }
    {
#line 3023
    tmp___16 = daemon_become_user(g___3.uid, g___3.gid, tmp___15);
    }
#line 3023
    if (tmp___16 == -1) {
      {
#line 3025
      tmp___7 = getgrgid(g___3.gid);
#line 3025
      grp = tmp___7;
#line 3026
      tmp___8 = getpwuid(g___3.uid);
#line 3026
      pwd = tmp___8;
#line 3027
      tmp___9 = getegid();
#line 3027
      tmp___10 = geteuid();
#line 3027
      tmp___11 = getgid();
#line 3027
      tmp___12 = getuid();
      }
#line 3027
      if (grp) {
#line 3027
        tmp___13 = (char const   *)grp->gr_name;
      } else {
#line 3027
        tmp___13 = "<noname>";
      }
#line 3027
      if (pwd) {
#line 3027
        tmp___14 = (char const   *)pwd->pw_name;
      } else {
#line 3027
        tmp___14 = "<noname>";
      }
      {
#line 3027
      fatalsys("failed to set user/group to %s/%s (%d/%d): uid/gid = %d/%d euid/egid = %d/%d",
               tmp___14, tmp___13, (int )g___3.uid, g___3.pid, (int )tmp___12, (int )tmp___11,
               (int )tmp___10, (int )tmp___9);
      }
    }
  }
  {
#line 3031
  g___3.done_user = 1;
#line 3035
  config();
#line 3039
  sanity_check();
  }
#line 3043
  if (! g___3.core) {
    {
#line 3045
    debugf((size_t )2, "preventing core files");
#line 3047
    tmp___17 = daemon_prevent_core();
    }
#line 3047
    if (tmp___17 == -1) {
      {
#line 3048
      fatalsys("failed to prevent core file generation");
      }
    }
  }
  {
#line 3053
  debugf((size_t )2, "constructing pidfile path");
  }
#line 3055
  if (g___3.pidfile) {
    {
#line 3057
    name = mem_strdup((char const   *)g___3.pidfile);
    }
#line 3057
    if (! name) {
      {
#line 3058
      fatalsys("out of memory");
      }
    }
  } else
#line 3060
  if (g___3.pidfiles) {
#line 3060
    if (g___3.name) {
      {
#line 3062
      suffix = ".pid";
#line 3063
      tmp___18 = strlen((char const   *)g___3.pidfiles);
#line 3063
      tmp___19 = strlen((char const   *)g___3.name);
#line 3063
      tmp___20 = strlen(suffix);
#line 3063
      size = (((tmp___18 + 1UL) + tmp___19) + tmp___20) + 1UL;
#line 3065
      tmp___21 = malloc(size * sizeof(char ));
#line 3065
      name = (char *)tmp___21;
      }
#line 3065
      if (! name) {
        {
#line 3066
        fatalsys("out of memory");
        }
      }
      {
#line 3068
      snprintf((char */* __restrict  */)name, size, (char const   */* __restrict  */)"%s%c%s%s",
               g___3.pidfiles, '/', g___3.name, suffix);
      }
    } else {
#line 3060
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3070
  if (g___3.name) {
    {
#line 3072
    name = mem_strdup((char const   *)g___3.name);
    }
#line 3072
    if (! name) {
      {
#line 3073
      fatalsys("out of memory");
      }
    }
  }
#line 3078
  if (g___3.stop) {
    {
#line 3080
    show();
#line 3082
    debugf((size_t )2, "stopping daemon %s", name);
#line 3084
    tmp___22 = daemon_stop((char const   *)name);
    }
#line 3084
    if (tmp___22 == -1) {
      {
#line 3085
      fatalsys("failed to stop the %s daemon", g___3.name);
      }
    }
    {
#line 3087
    exit(0);
    }
  }
#line 3092
  if (g___3.running) {
    {
#line 3094
    show();
#line 3096
    debugf((size_t )2, "checking if daemon %s is running: pidfile %s", g___3.name,
           name);
#line 3098
    tmp___23 = daemon_is_running((char const   *)name);
    }
    {
#line 3100
    if (tmp___23 == 0) {
#line 3100
      goto case_0;
    }
#line 3104
    if (tmp___23 == 1) {
#line 3104
      goto case_1;
    }
#line 3108
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 3101
    verbose((size_t )1, "%s is not running", g___3.name);
#line 3102
    exit(1);
    }
    case_1: /* CIL Label */ 
    {
#line 3105
    tmp___24 = daemon_getpid((char const   *)name);
#line 3105
    verbose((size_t )1, "%s is running (pid %d)", g___3.name, tmp___24);
#line 3106
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 3109
    fatalsys("failed to tell if the %s daemon is running", g___3.name);
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 3115
  if (g___3.restart) {
    {
#line 3117
    show();
#line 3119
    debugf((size_t )2, "restarting daemon %s: pidfile %s", g___3.name, name);
#line 3121
    g___3.pid = daemon_getpid((char const   *)name);
    }
#line 3121
    if (g___3.pid == -1) {
#line 3122
      if (g___3.name) {
#line 3122
        tmp___25 = g___3.name;
      } else {
#line 3122
        tmp___25 = name;
      }
      {
#line 3122
      fatalsys("failed to find pid for %s", tmp___25);
      }
    }
    {
#line 3124
    tmp___27 = kill(g___3.pid, 10);
    }
#line 3124
    if (tmp___27 == -1) {
#line 3125
      if (g___3.name) {
#line 3125
        tmp___26 = g___3.name;
      } else {
#line 3125
        tmp___26 = name;
      }
      {
#line 3125
      fatalsys("failed to send sigusr1 to %s daemon", tmp___26);
      }
    }
    {
#line 3127
    exit(0);
    }
  }
  {
#line 3132
  debugf((size_t )2, "constructing command line arguments for the client");
  }
#line 3134
  if (g___3.command) {
    {
#line 3134
    cmd = split((char const   *)g___3.command, " ");
    }
#line 3134
    if (! cmd) {
      {
#line 3135
      fatalsys("out of memory");
      }
    }
  }
#line 3137
  if (cmd) {
    {
#line 3137
    tmp___28 = list_length((List const   *)cmd);
#line 3137
    tmp___29 = tmp___28;
    }
  } else {
#line 3137
    tmp___29 = (ssize_t )0;
  }
  {
#line 3137
  tmp___30 = malloc((unsigned long )((tmp___29 + (ssize_t )(ac - a)) + 1L) * sizeof(char *));
#line 3137
  g___3.cmd = (char **)tmp___30;
  }
#line 3137
  if (! g___3.cmd) {
    {
#line 3138
    fatalsys("out of memory");
    }
  }
#line 3140
  i = 0;
  {
#line 3140
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3140
    tmp___34 = list_length((List const   *)cmd);
    }
#line 3140
    if (! ((ssize_t )i < tmp___34)) {
#line 3140
      goto while_break;
    }
    {
#line 3141
    tmp___32 = list_item((List const   *)cmd, (ssize_t )i);
#line 3141
    tmp___33 = cstr((String const   *)((String *)tmp___32));
#line 3141
    tmp___31 = mem_strdup((char const   *)tmp___33);
#line 3141
    *(g___3.cmd + i) = tmp___31;
    }
#line 3141
    if (! tmp___31) {
      {
#line 3142
      fatalsys("out of memory");
      }
    }
#line 3140
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3144
  list_release(cmd);
  }
#line 3146
  if (a != ac) {
    {
#line 3147
    memmove((void *)(g___3.cmd + i), (void const   *)(av + a), (unsigned long )(ac - a) * sizeof(char *));
    }
  }
  {
#line 3149
  *(g___3.cmd + ((i + ac) - a)) = (char *)((void *)0);
#line 3153
  debugf((size_t )2, "checking the client command");
  }
#line 3155
  if ((unsigned long )*(g___3.cmd + 0) == (unsigned long )((void *)0)) {
    {
#line 3156
    prog_usage_msg("Invalid arguments: no command supplied");
    }
  }
#line 3160
  if (g___3.safe) {
#line 3160
    goto _L___0;
  } else {
    {
#line 3160
    tmp___36 = getuid();
    }
#line 3160
    if (tmp___36 == 0U) {
#line 3160
      if (! g___3.unsafe) {
        _L___0: /* CIL Label */ 
        {
#line 3164
        tmp___35 = safety_check((char const   *)*(g___3.cmd + 0), explanation, (size_t )256);
        }
        {
#line 3166
        if (tmp___35 == 1) {
#line 3166
          goto case_1___0;
        }
#line 3167
        if (tmp___35 == 0) {
#line 3167
          goto case_0___0;
        }
#line 3168
        goto switch_default___0;
        case_1___0: /* CIL Label */ 
#line 3166
        goto switch_break___0;
        case_0___0: /* CIL Label */ 
        {
#line 3167
        fatal("refusing to execute unsafe program: %s (%s)", *(g___3.cmd + 0), explanation);
        }
        switch_default___0: /* CIL Label */ 
        {
#line 3168
        fatalsys("failed to tell if %s is safe", *(g___3.cmd + 0));
        }
        switch_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 3174
  if (g___3.name) {
    {
#line 3175
    prog_set_name((char const   *)g___3.name);
    }
  }
#line 3179
  if (g___3.foreground) {
    {
#line 3181
    debugf((size_t )2, "locking pidfile only (foreground)");
    }
#line 3183
    if (name) {
      {
#line 3183
      tmp___38 = daemon_pidfile((char const   *)name);
      }
#line 3183
      if (tmp___38 == -1) {
#line 3184
        if (g___3.name) {
#line 3184
          tmp___37 = g___3.name;
        } else {
#line 3184
          tmp___37 = name;
        }
        {
#line 3184
        fatalsys("failed to create pidfile for %s", tmp___37);
        }
      }
    }
  } else {
    {
#line 3190
    debugf((size_t )2, "becoming a daemon and locking pidfile");
#line 3192
    rc = daemon_init((char const   *)name);
#line 3193
    tmp___39 = prog_name();
#line 3193
    prog_err_syslog(tmp___39, 0, 3 << 3, 3);
    }
#line 3195
    if (rc == -1) {
      {
#line 3196
      fatalsys("failed to become a daemon");
      }
    }
  }
#line 3199
  if (name) {
    {
#line 3201
    debugf((size_t )2, "atexit(daemon_close)");
#line 3203
    tmp___40 = atexit((void (*)(void))(& daemon_close));
    }
#line 3203
    if (tmp___40 == -1) {
      {
#line 3205
      daemon_close();
#line 3206
      fatalsys("%s: failed to atexit(daemon_close)", name);
      }
    }
  }
  {
#line 3212
  debugf((size_t )2, "setting umask to %o", g___3.umask);
#line 3214
  umask(g___3.umask);
  }
#line 3218
  if (g___3.chdir) {
    {
#line 3220
    debugf((size_t )2, "chdir %s", g___3.chdir);
#line 3222
    tmp___41 = chdir((char const   *)g___3.chdir);
    }
#line 3222
    if (tmp___41 == -1) {
      {
#line 3223
      fatalsys("failed to change directory to %s", g___3.chdir);
      }
    }
  }
#line 3228
  if (g___3.daemon_errlog) {
    {
#line 3230
    tmp___42 = syslog_priority_str(g___3.daemon_errlog);
#line 3230
    tmp___43 = syslog_facility_str(g___3.daemon_errlog);
#line 3230
    debugf((size_t )2, "starting error delivery to syslog %s.%s", tmp___43, tmp___42);
#line 3232
    tmp___46 = prog_name();
#line 3232
    tmp___47 = prog_err_syslog(tmp___46, 0, g___3.daemon_errlog & 1016, g___3.daemon_errlog & 7);
    }
#line 3232
    if (tmp___47 == -1) {
      {
#line 3233
      tmp___44 = syslog_priority_str(g___3.daemon_errlog);
#line 3233
      tmp___45 = syslog_facility_str(g___3.daemon_errlog);
#line 3233
      fatalsys("failed to start error delivery to %s.%s", tmp___45, tmp___44);
      }
    }
  } else
#line 3235
  if (g___3.daemon_err) {
    {
#line 3237
    debugf((size_t )2, "starting error delivery to file %s", g___3.daemon_err);
#line 3239
    tmp___48 = prog_err_file((char const   *)g___3.daemon_err);
    }
#line 3239
    if (tmp___48 == -1) {
      {
#line 3240
      fatalsys("failed to start error delivery to %s", g___3.daemon_err);
      }
    }
  }
#line 3245
  if (g___3.daemon_dbglog) {
    {
#line 3247
    tmp___49 = syslog_priority_str(g___3.daemon_dbglog);
#line 3247
    tmp___50 = syslog_facility_str(g___3.daemon_dbglog);
#line 3247
    debugf((size_t )2, "starting debug delivery to syslog %s.%s", tmp___50, tmp___49);
#line 3249
    tmp___53 = prog_name();
#line 3249
    tmp___54 = prog_dbg_syslog(tmp___53, 0, g___3.daemon_dbglog & 1016, g___3.daemon_dbglog & 7);
    }
#line 3249
    if (tmp___54 == -1) {
      {
#line 3250
      tmp___51 = syslog_priority_str(g___3.daemon_dbglog);
#line 3250
      tmp___52 = syslog_facility_str(g___3.daemon_dbglog);
#line 3250
      fatalsys("failed to start debug delivery to %s.%s", tmp___52, tmp___51);
      }
    }
  } else
#line 3252
  if (g___3.daemon_dbg) {
    {
#line 3254
    debugf((size_t )2, "starting debug delivery to file %s", g___3.daemon_dbg);
#line 3256
    tmp___55 = prog_dbg_file((char const   *)g___3.daemon_dbg);
    }
#line 3256
    if (tmp___55 == -1) {
      {
#line 3257
      fatalsys("failed to start debug delivery to %s", g___3.daemon_dbg);
      }
    }
  }
#line 3262
  flags = 1089;
#line 3263
  mode = (mode_t )((((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3));
#line 3265
  if (g___3.client_out) {
#line 3265
    if (! g___3.client_outlog) {
      {
#line 3267
      debugf((size_t )2, "opening client output file %s", g___3.client_out);
#line 3269
      g___3.client_outfd = open((char const   *)g___3.client_out, flags, mode);
      }
#line 3269
      if (g___3.client_outfd == -1) {
        {
#line 3270
        errorsys("failed to open %s to log client stdout", g___3.client_out);
        }
      }
    }
  }
#line 3273
  if (g___3.client_err) {
#line 3273
    if (! g___3.client_errlog) {
      {
#line 3275
      debugf((size_t )2, "opening client error file %s", g___3.client_err);
#line 3277
      g___3.client_errfd = open((char const   *)g___3.client_err, flags, mode);
      }
#line 3277
      if (g___3.client_errfd == -1) {
        {
#line 3278
        errorsys("failed to open %s to log client stderr", g___3.client_err);
        }
      }
    }
  }
  {
#line 3283
  prepare_environment();
#line 3287
  show();
  }
#line 3288
  return;
}
}
#line 3299 "/home/jkwonk/work/benchmark/daemon-0.6.4/daemon.c"
int main(int ac , char **av ) 
{ 


  {
  {
#line 3301
  init(ac, av);
#line 3302
  run();
  }
#line 3304
  return (0);
}
}
