/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 107 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.h"
struct include_field {
   char *name ;
   int found ;
   int reported ;
   struct include_field *next ;
};
#line 114 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.h"
struct output {
   char *name ;
   uint8_t *file_header ;
   uint8_t *file_trailer ;
   uint8_t *header ;
   uint8_t *data ;
   uint8_t *lookup ;
   uint8_t *separator ;
   uint8_t *record_header ;
   uint8_t *record_trailer ;
   uint8_t *group_header ;
   uint8_t *group_trailer ;
   uint8_t *element_header ;
   uint8_t *element_trailer ;
   uint8_t justify ;
   uint8_t *indent ;
   int no_data ;
   char *empty_chars ;
   int print_empty ;
   int hex_cap ;
   struct include_field *fl ;
   char *output_file ;
   FILE *ofp ;
   struct output *next ;
};
#line 140 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.h"
struct lookup_data {
   uint8_t *key ;
   uint8_t *value ;
   int key_len ;
   struct lookup_data *next ;
};
#line 147 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.h"
struct lookup {
   char *name ;
   char type ;
   uint8_t *default_value ;
   int max_key_len ;
   struct lookup_data *data ;
   struct lookup *next ;
};
#line 157 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.h"
struct replace {
   char *field ;
   uint8_t *value ;
   int found ;
   struct replace *next ;
};
#line 179
struct field;
#line 194 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.h"
struct field {
   char *name ;
   char *const_data ;
   int type ;
   int endianess ;
   int position ;
   int bposition ;
   int length ;
   int print ;
   char *lookup_table_name ;
   struct lookup *lookup ;
   struct replace *rep ;
   char *output_name ;
   struct output *o ;
   struct field *next ;
};
#line 213 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.h"
struct print_field {
   struct field *f ;
   uint8_t *data ;
   int justify_length ;
   int empty ;
   struct print_field *next ;
};
#line 221 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.h"
struct id {
   int position ;
   uint8_t *key ;
   int regexp ;
   regex_t reg ;
   int length ;
   struct id *next ;
};
#line 232 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.h"
struct level {
   int level ;
   char *group_name ;
   char *element_name ;
   int indent_count ;
};
#line 240 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.h"
struct record {
   char *name ;
   struct id *i ;
   struct field *f ;
   char *fields_from ;
   struct print_field *pf ;
   struct output *o ;
   char *output_name ;
   int vote ;
   int length ;
   int arb_length ;
   struct level *level ;
   struct record *next ;
};
#line 265 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.h"
struct structure {
   char *name ;
   char type[3] ;
   int max_record_len ;
   char quote ;
   int header ;
   char *output_name ;
   int vote ;
   struct output *o ;
   struct record *r ;
   struct structure *next ;
};
#line 71 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
struct rc_option {
   char *name ;
   char *parameters ;
};
#line 194 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef signed char int8_t;
#line 195 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef short int16_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 197 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long int64_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_15 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_15 regmatch_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 165 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.h"
struct expr_list {
   char *value ;
   int value_len ;
   regex_t reg ;
   struct expr_list *next ;
};
#line 179 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.h"
struct expression {
   char *field ;
   char op ;
   int found ;
   struct field *f ;
   size_t exp_min_len ;
   size_t exp_max_len ;
   size_t fast_entries ;
   size_t fast_expr_hash[62] ;
   struct expr_list *expr_hash[32771] ;
   struct expression *next ;
};
#line 278 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.h"
struct input_file {
   char *name ;
   long lineno ;
   struct input_file *next ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_35 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_36 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_37 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_38 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_39 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_40 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_41 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_34 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_35 _kill ;
   struct __anonstruct__timer_36 _timer ;
   struct __anonstruct__rt_37 _rt ;
   struct __anonstruct__sigchld_38 _sigchld ;
   struct __anonstruct__sigfault_39 _sigfault ;
   struct __anonstruct__sigpoll_40 _sigpoll ;
   struct __anonstruct__sigsys_41 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_33 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_34 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_33 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_53 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_53 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 31 "/usr/include/error.h"
__inline extern void __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__always_inline__)) error)(int __status ,
                                                                                                                         int __errnum ,
                                                                                                                         char const   *__format 
                                                                                                                         , ...) ;
#line 34
__inline extern void __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__always_inline__)) error_at_line)(int __status ,
                                                                                                                                 int __errnum ,
                                                                                                                                 char const   *__fname ,
                                                                                                                                 unsigned int __line ,
                                                                                                                                 char const   *__format 
                                                                                                                                 , ...) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/error.h"
extern void ( /* format attribute */  __error_alias)(int __status , int __errnum ,
                                                     char const   *__format  , ...)  __asm__("error")  ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/error.h"
__inline extern void __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__always_inline__)) error)(int __status ,
                                                                                                                         int __errnum ,
                                                                                                                         char const   *__format 
                                                                                                                         , ...) 
{ 


  {
  {
#line 42
  __error_alias(__status, __errnum, __format, __builtin_va_arg_pack());
  }
#line 43
  return;
}
}
#line 46
extern void ( /* format attribute */  __error_at_line_alias)(int __status , int __errnum ,
                                                             char const   *__fname ,
                                                             unsigned int __line ,
                                                             char const   *__format 
                                                             , ...)  __asm__("error_at_line")  ;
#line 63 "/usr/include/x86_64-linux-gnu/bits/error.h"
__inline extern void __attribute__((__gnu_inline__))  ( /* format attribute */ __attribute__((__always_inline__)) error_at_line)(int __status ,
                                                                                                                                 int __errnum ,
                                                                                                                                 char const   *__fname ,
                                                                                                                                 unsigned int __line ,
                                                                                                                                 char const   *__format 
                                                                                                                                 , ...) 
{ 


  {
  {
#line 71
  __error_at_line_alias(__status, __errnum, __fname, __line, __format, __builtin_va_arg_pack());
  }
#line 73
  return;
}
}
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 582
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 678
extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                         FILE * __restrict  __stream ) ;
#line 319 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.h"
void panic(char *msg , char *info , char *syserror ) ;
#line 325
void *xmalloc(size_t size ) ;
#line 328
char *xstrdup(char *str ) ;
#line 331
void parserc(char *rcfile , char *include_field_list ) ;
#line 340
void *xrealloc(void *ptr , size_t size ) ;
#line 355
char *expand_home(char *path ) ;
#line 358
FILE *xfopen(char *name , char *mode ) ;
#line 409
struct structure *structure ;
#line 410
struct output *output ;
#line 412
struct lookup *lookup ;
#line 415
struct field *const_field ;
#line 416
int system_endianess ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 519
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
static char *program  =    (char *)"ffe";
#line 47 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
static FILE *fp  =    (FILE *)((void *)0);
#line 48 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
static FILE *child  =    (FILE *)((void *)0);
#line 51 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
static int lineno  =    0;
#line 66 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
static size_t command_len  =    (size_t )128;
#line 67 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
static char *command  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
static char *cs_temp_file  =    (char *)((void *)0);
#line 76 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
char *values[100]  ;
#line 131 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
static struct rc_option rc_opts[38]  = 
#line 131
  {      {(char *)"structure", (char *)"S"}, 
        {(char *)"type", (char *)"Scc"}, 
        {(char *)"quoted", (char *)"c"}, 
        {(char *)"header", (char *)"S"}, 
        {(char *)"record", (char *)"S"}, 
        {(char *)"output", (char *)"S"}, 
        {(char *)"id", (char *)"NS"}, 
        {(char *)"rid", (char *)"NS"}, 
        {(char *)"field", (char *)"Ssss"}, 
        {(char *)"fields-from", (char *)"S"}, 
        {(char *)"file-header", (char *)"S"}, 
        {(char *)"file-trailer", (char *)"S"}, 
        {(char *)"data", (char *)"S"}, 
        {(char *)"separator", (char *)"S"}, 
        {(char *)"record-header", (char *)"S"}, 
        {(char *)"record-trailer", (char *)"S"}, 
        {(char *)"group-header", (char *)"S"}, 
        {(char *)"group-trailer", (char *)"S"}, 
        {(char *)"element-header", (char *)"S"}, 
        {(char *)"element-trailer", (char *)"S"}, 
        {(char *)"justify", (char *)"S"}, 
        {(char *)"indent", (char *)"S"}, 
        {(char *)"field-list", (char *)"S"}, 
        {(char *)"no-data-print", (char *)"S"}, 
        {(char *)"field-empty-print", (char *)"S"}, 
        {(char *)"empty-chars", (char *)"S"}, 
        {(char *)"lookup", (char *)"S"}, 
        {(char *)"pair", (char *)"SS"}, 
        {(char *)"file", (char *)"Sc"}, 
        {(char *)"default-value", (char *)"S"}, 
        {(char *)"search", (char *)"S"}, 
        {(char *)"const", (char *)"SS"}, 
        {(char *)"field-count", (char *)"N"}, 
        {(char *)"output-file", (char *)"S"}, 
        {(char *)"level", (char *)"Nss"}, 
        {(char *)"record-length", (char *)"S"}, 
        {(char *)"hex-caps", (char *)"S"}, 
        {(char *)((void *)0), (char *)((void *)0)}};
#line 172 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
int is_digit(char *number ) 
{ 
  unsigned short const   **tmp ;
  char *tmp___0 ;

  {
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! *number) {
#line 175
      goto while_break;
    }
    {
#line 175
    tmp = __ctype_b_loc();
#line 175
    tmp___0 = number;
#line 175
    number ++;
    }
#line 175
    if (! ((int const   )*(*tmp + (int )*tmp___0) & 2048)) {
#line 175
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return (1);
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
void remove_temp_file(void) 
{ 


  {
#line 181
  if (cs_temp_file) {
    {
#line 181
    unlink((char const   *)cs_temp_file);
    }
  }
#line 182
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
void open_rc_file(char *file ) 
{ 


  {
  {
#line 188
  fp = xfopen(file, (char *)"r");
  }
#line 189
  return;
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
void error_in_line(void) 
{ 


  {
  {
#line 194
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Error in rcfile, line %d\n",
          program, lineno);
  }
#line 195
  return;
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
void trim(char *buf ) 
{ 
  register char *wpos ;
  register char *rpos ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 201
  wpos = buf;
#line 201
  rpos = buf;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 203
    tmp = __ctype_b_loc();
    }
#line 203
    if (! ((int const   )*(*tmp + (int )*rpos) & 8192)) {
#line 203
      goto while_break;
    }
#line 203
    rpos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  if ((unsigned long )rpos != (unsigned long )buf) {
    {
#line 207
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 207
      if (! *rpos) {
#line 207
        goto while_break___0;
      }
#line 209
      *wpos = *rpos;
#line 210
      wpos ++;
#line 211
      rpos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 213
    *wpos = (char)0;
  }
#line 216
  if (*buf) {
#line 218
    rpos = buf;
    {
#line 219
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 219
      if (! *rpos) {
#line 219
        goto while_break___1;
      }
#line 219
      rpos ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 220
    rpos --;
    {
#line 221
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 221
      tmp___0 = __ctype_b_loc();
      }
#line 221
      if (! ((int const   )*(*tmp___0 + (int )*rpos) & 8192)) {
#line 221
        goto while_break___2;
      }
#line 221
      rpos --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 222
    rpos ++;
#line 223
    *rpos = (char)0;
  }
#line 225
  return;
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
struct include_field *parse_include_list(char *list ) 
{ 
  struct include_field *ret ;
  struct include_field *c ;
  char *p ;
  char *w ;
  char *s ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 233
  ret = (struct include_field *)((void *)0);
#line 233
  c = (struct include_field *)((void *)0);
#line 234
  p = list;
#line 235
  w = list;
#line 236
  s = list;
#line 238
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 238
    return ((struct include_field *)((void *)0));
  }
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! *p) {
#line 240
      goto while_break;
    }
#line 242
    if ((int )*p == 44) {
#line 242
      if ((int )*(p + 1) == 44) {
#line 244
        p ++;
#line 245
        *w = *p;
#line 246
        w ++;
#line 247
        p ++;
      }
    }
#line 249
    *w = *p;
#line 250
    if ((int )*p == 44) {
#line 250
      goto _L;
    } else
#line 250
    if (! *(p + 1)) {
      _L: /* CIL Label */ 
#line 252
      if (*(p + 1)) {
#line 252
        *w = (char)0;
      }
      {
#line 253
      tmp___1 = strlen((char const   *)s);
      }
#line 253
      if (tmp___1) {
#line 255
        if ((unsigned long )ret == (unsigned long )((void *)0)) {
          {
#line 257
          tmp = xmalloc(sizeof(struct include_field ));
#line 257
          ret = (struct include_field *)tmp;
#line 258
          c = ret;
          }
        } else {
          {
#line 261
          tmp___0 = xmalloc(sizeof(struct include_field ));
#line 261
          c->next = (struct include_field *)tmp___0;
#line 262
          c = c->next;
          }
        }
        {
#line 264
        c->next = (struct include_field *)((void *)0);
#line 265
        c->name = xstrdup(s);
#line 266
        c->found = 0;
#line 267
        c->reported = 0;
        }
      }
#line 269
      p ++;
      {
#line 270
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 270
        if (! ((int )*p == 44)) {
#line 270
          goto while_break___0;
        }
#line 270
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 271
      s = p;
#line 272
      w = s;
#line 273
      p = s;
    } else {
#line 276
      w ++;
#line 277
      p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  return (ret);
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
FILE *execute_child(char *command___0 ) 
{ 
  int fds[2] ;
  pid_t pid ;
  FILE *ret ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 290
  ret = (FILE *)((void *)0);
#line 292
  tmp___1 = pipe((int *)(fds));
  }
#line 292
  if (tmp___1 != 0) {
    {
#line 292
    tmp = __errno_location();
#line 292
    tmp___0 = strerror(*tmp);
#line 292
    panic((char *)"Cannot create pipe", tmp___0, (char *)((void *)0));
    }
  }
  {
#line 293
  pid = fork();
  }
#line 294
  if (pid == 0) {
    {
#line 296
    close(fds[0]);
#line 297
    tmp___4 = dup2(fds[1], 1);
    }
#line 297
    if (tmp___4 == -1) {
      {
#line 297
      tmp___2 = __errno_location();
#line 297
      tmp___3 = strerror(*tmp___2);
#line 297
      panic((char *)"dup2 error", tmp___3, (char *)((void *)0));
      }
    }
    {
#line 298
    tmp___7 = execl("/bin/sh", "sh", "-c", command___0, (void *)0);
    }
#line 298
    if (tmp___7 == -1) {
      {
#line 298
      tmp___5 = __errno_location();
#line 298
      tmp___6 = strerror(*tmp___5);
#line 298
      panic((char *)"Starting a shell with execl failed", command___0, tmp___6);
      }
    }
    {
#line 299
    close(fds[1]);
#line 300
    _exit(0);
    }
  } else
#line 301
  if (pid > 0) {
    {
#line 303
    close(fds[1]);
#line 304
    ret = fdopen(fds[0], "r");
    }
#line 305
    if ((unsigned long )ret == (unsigned long )((void *)0)) {
      {
#line 305
      tmp___8 = __errno_location();
#line 305
      tmp___9 = strerror(*tmp___8);
#line 305
      panic((char *)"Cannot read from command", command___0, tmp___9);
      }
    }
  } else {
    {
#line 308
    tmp___10 = __errno_location();
#line 308
    tmp___11 = strerror(*tmp___10);
#line 308
    panic((char *)"Cannot fork", tmp___11, (char *)((void *)0));
    }
  }
#line 329
  return (ret);
}
}
#line 340
int read_char(void) ;
#line 340 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
static int char_in_buffer  =    0;
#line 336 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
int read_char(void) 
{ 
  int c ;
  size_t i ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 342
  if ((unsigned long )child != (unsigned long )((void *)0)) {
#line 344
    if (char_in_buffer) {
#line 346
      c = char_in_buffer;
#line 347
      char_in_buffer = 0;
    } else {
      {
#line 350
      c = _IO_getc(child);
      }
#line 351
      if (c == 10) {
        {
#line 353
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 353
          c = _IO_getc(child);
          }
#line 353
          if (! (c == 10)) {
#line 353
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 354
        if (c != -1) {
#line 356
          char_in_buffer = c;
#line 357
          c = '\n';
        }
      }
#line 361
      if (c == -1) {
        {
#line 363
        fclose(child);
        }
#line 364
        if (cs_temp_file) {
          {
#line 364
          unlink((char const   *)cs_temp_file);
          }
        }
        {
#line 365
        cs_temp_file = (char *)((void *)0);
#line 366
        child = (FILE *)((void *)0);
#line 367
        c = read_char();
        }
      }
    }
  } else {
    {
#line 372
    c = _IO_getc(fp);
    }
#line 373
    if (c == 96) {
#line 375
      i = (size_t )0;
      {
#line 376
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 378
        c = _IO_getc(fp);
#line 379
        tmp = i;
#line 379
        i ++;
#line 379
        *(command + tmp) = (char )c;
        }
#line 380
        if (i == command_len) {
          {
#line 382
          command_len = 2UL * command_len;
#line 383
          tmp___0 = xrealloc((void *)command, command_len);
#line 383
          command = (char *)tmp___0;
          }
        }
#line 376
        if (c != 96) {
#line 376
          if (! (c != -1)) {
#line 376
            goto while_break___0;
          }
        } else {
#line 376
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 386
      if (c != 96) {
        {
#line 388
        error_in_line();
#line 389
        panic((char *)"No closing \'`\' in command substition", (char *)((void *)0),
              (char *)((void *)0));
        }
      }
      {
#line 391
      i --;
#line 391
      *(command + i) = (char)0;
#line 392
      child = execute_child(command);
#line 393
      c = read_char();
      }
    }
  }
#line 396
  return (c);
}
}
#line 406
int read_logical_line(char **buffer , size_t *bufsize ) ;
#line 406 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
static char last_eol_char  =    (char)0;
#line 403 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
int read_logical_line(char **buffer , size_t *bufsize ) 
{ 
  register char *bp ;
  int prev_char ;
  int c ;
  register int i ;
  int retval ;
  int tmp ;
  void *tmp___0 ;

  {
#line 408
  prev_char = 0;
#line 409
  i = 0;
#line 410
  retval = 0;
#line 412
  bp = *buffer;
#line 414
  *(bp + 0) = (char)0;
  {
#line 418
  if ((int )last_eol_char == 123) {
#line 418
    goto case_123;
  }
#line 422
  if ((int )last_eol_char == 125) {
#line 422
    goto case_125;
  }
#line 416
  goto switch_break;
  case_123: /* CIL Label */ 
#line 419
  last_eol_char = (char)0;
#line 420
  return (2);
#line 421
  goto switch_break;
  case_125: /* CIL Label */ 
#line 423
  last_eol_char = (char)0;
#line 424
  return (3);
#line 425
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 430
    c = read_char();
    }
#line 431
    if (prev_char == 92) {
      {
#line 435
      if (c == 97) {
#line 435
        goto case_97;
      }
#line 440
      if (c == 98) {
#line 440
        goto case_98;
      }
#line 445
      if (c == 116) {
#line 445
        goto case_116;
      }
#line 450
      if (c == 110) {
#line 450
        goto case_110;
      }
#line 455
      if (c == 118) {
#line 455
        goto case_118;
      }
#line 460
      if (c == 102) {
#line 460
        goto case_102;
      }
#line 465
      if (c == 114) {
#line 465
        goto case_114;
      }
#line 470
      if (c == 92) {
#line 470
        goto case_92;
      }
#line 475
      if (c == 35) {
#line 475
        goto case_35;
      }
#line 480
      if (c == 10) {
#line 480
        goto case_10;
      }
#line 486
      goto switch_default;
      case_97: /* CIL Label */ 
#line 436
      *(bp + i) = (char )'\a';
#line 437
      c = 0;
#line 438
      i ++;
#line 439
      goto switch_break___0;
      case_98: /* CIL Label */ 
#line 441
      *(bp + i) = (char )'\b';
#line 442
      c = 0;
#line 443
      i ++;
#line 444
      goto switch_break___0;
      case_116: /* CIL Label */ 
#line 446
      *(bp + i) = (char )'\t';
#line 447
      c = 0;
#line 448
      i ++;
#line 449
      goto switch_break___0;
      case_110: /* CIL Label */ 
#line 451
      *(bp + i) = (char )'\n';
#line 452
      c = 0;
#line 453
      i ++;
#line 454
      goto switch_break___0;
      case_118: /* CIL Label */ 
#line 456
      *(bp + i) = (char )'\v';
#line 457
      c = 0;
#line 458
      i ++;
#line 459
      goto switch_break___0;
      case_102: /* CIL Label */ 
#line 461
      *(bp + i) = (char )'\f';
#line 462
      c = 0;
#line 463
      i ++;
#line 464
      goto switch_break___0;
      case_114: /* CIL Label */ 
#line 466
      *(bp + i) = (char )'\r';
#line 467
      c = 0;
#line 468
      i ++;
#line 469
      goto switch_break___0;
      case_92: /* CIL Label */ 
#line 471
      *(bp + i) = (char )'\\';
#line 472
      c = 0;
#line 473
      i ++;
#line 474
      goto switch_break___0;
      case_35: /* CIL Label */ 
#line 476
      *(bp + i) = (char )'#';
#line 477
      c = 0;
#line 478
      i ++;
#line 479
      goto switch_break___0;
      case_10: /* CIL Label */ 
#line 481
      if ((unsigned long )child == (unsigned long )((void *)0)) {
#line 481
        lineno ++;
      }
      {
#line 482
      tmp = read_char();
#line 482
      *(bp + i) = (char )tmp;
#line 483
      c = 0;
#line 484
      i ++;
      }
#line 485
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 487
      *(bp + i) = (char )'\\';
#line 488
      i ++;
#line 489
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 493
    prev_char = c;
    {
#line 497
    if (c == 35) {
#line 497
      goto case_35___0;
    }
#line 502
    if (c == 10) {
#line 502
      goto case_10___0;
    }
#line 507
    if (c == 123) {
#line 507
      goto case_123___0;
    }
#line 511
    if (c == 125) {
#line 511
      goto case_125___0;
    }
#line 515
    if (c == -1) {
#line 515
      goto case_neg_1;
    }
#line 521
    if (c == 0) {
#line 521
      goto case_0;
    }
#line 521
    if (c == 13) {
#line 521
      goto case_0;
    }
#line 521
    if (c == 92) {
#line 521
      goto case_0;
    }
#line 523
    goto switch_default___0;
    case_35___0: /* CIL Label */ 
    {
#line 498
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 500
      c = read_char();
      }
#line 498
      if (c != 10) {
#line 498
        if (! (c != -1)) {
#line 498
          goto while_break___0;
        }
      } else {
#line 498
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    case_10___0: /* CIL Label */ 
#line 503
    if (c == 10) {
#line 503
      if ((unsigned long )child == (unsigned long )((void *)0)) {
#line 503
        lineno ++;
      }
    }
#line 504
    *(bp + i) = (char)0;
#line 505
    retval = 1;
#line 506
    goto switch_break___1;
    case_123___0: /* CIL Label */ 
#line 508
    *(bp + i) = (char)0;
#line 509
    retval = 1;
#line 510
    goto switch_break___1;
    case_125___0: /* CIL Label */ 
#line 512
    *(bp + i) = (char)0;
#line 513
    retval = 1;
#line 514
    goto switch_break___1;
    case_neg_1: /* CIL Label */ 
#line 516
    *(bp + i) = (char)0;
#line 517
    retval = 1;
#line 518
    goto switch_break___1;
    case_0: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_92___0: /* CIL Label */ 
#line 522
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 524
    if ((size_t )i >= *bufsize - 10UL) {
      {
#line 526
      *bufsize *= 2UL;
#line 527
      tmp___0 = xrealloc((void *)*buffer, *bufsize);
#line 527
      *buffer = (char *)tmp___0;
#line 528
      bp = *buffer;
      }
    }
#line 530
    *(bp + i) = (char )c;
#line 531
    i ++;
#line 532
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 535
    if (retval) {
      {
#line 537
      trim(bp);
      }
      {
#line 540
      if (c == 10) {
#line 540
        goto case_10___1;
      }
#line 550
      if (c == -1) {
#line 550
        goto case_neg_1___0;
      }
#line 556
      if (c == 123) {
#line 556
        goto case_123___1;
      }
#line 565
      if (c == 125) {
#line 565
        goto case_125___1;
      }
#line 538
      goto switch_break___2;
      case_10___1: /* CIL Label */ 
#line 541
      if ((int )*(bp + 0) == 0) {
#line 543
        i = 0;
#line 544
        retval = 0;
      } else {
#line 547
        return (retval);
      }
#line 549
      goto switch_break___2;
      case_neg_1___0: /* CIL Label */ 
#line 551
      if ((int )*(bp + 0) == 0) {
#line 553
        retval = 4;
      }
#line 555
      return (retval);
      case_123___1: /* CIL Label */ 
#line 557
      if ((int )*(bp + 0) == 0) {
#line 559
        retval = 2;
      } else {
#line 562
        last_eol_char = (char )c;
      }
#line 564
      return (retval);
      case_125___1: /* CIL Label */ 
#line 566
      if ((int )*(bp + 0) == 0) {
#line 568
        retval = 3;
      } else {
#line 571
        last_eol_char = (char )c;
      }
#line 573
      return (retval);
#line 574
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 585 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
int parse_option(char *buf ) 
{ 
  register char *rpos ;
  char *end ;
  char *param ;
  register char *p ;
  int i ;
  int j ;
  int valc ;
  int quoted ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;

  {
#line 587
  rpos = buf;
#line 588
  end = buf;
#line 591
  i = 0;
#line 592
  valc = 0;
#line 595
  values[0] = buf;
  {
#line 597
  while (1) {
    while_continue: /* CIL Label */ ;
#line 597
    if (! *end) {
#line 597
      goto while_break;
    }
#line 597
    end ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 599
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 599
    tmp = __ctype_b_loc();
    }
#line 599
    if ((int const   )*(*tmp + (int )*rpos) & 8192) {
#line 599
      goto while_break___0;
    } else
#line 599
    if (! *rpos) {
#line 599
      goto while_break___0;
    }
#line 599
    rpos ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 600
  *rpos = (char)0;
#line 602
  p = buf;
  {
#line 604
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 604
    if (! *p) {
#line 604
      goto while_break___1;
    }
#line 606
    if ((int )*p == 95) {
#line 606
      *p = (char )'-';
    }
#line 607
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 610
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 610
    if ((unsigned long )rc_opts[i].name != (unsigned long )((void *)0)) {
      {
#line 610
      tmp___0 = strcmp((char const   *)rc_opts[i].name, (char const   *)values[0]);
      }
#line 610
      if (! (tmp___0 != 0)) {
#line 610
        goto while_break___2;
      }
    } else {
#line 610
      goto while_break___2;
    }
#line 610
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 612
  if ((unsigned long )rc_opts[i].name != (unsigned long )((void *)0)) {
#line 614
    param = rc_opts[i].parameters;
    {
#line 615
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 615
      if (! ((unsigned long )rpos < (unsigned long )end)) {
#line 615
        goto while_break___3;
      }
#line 617
      if (*param) {
#line 619
        rpos ++;
        {
#line 620
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 620
          tmp___1 = __ctype_b_loc();
          }
#line 620
          if (! ((int const   )*(*tmp___1 + (int )*rpos) & 8192)) {
#line 620
            goto while_break___4;
          }
#line 620
          rpos ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 621
        quoted = 0;
        {
#line 627
        if ((int )*param == 99) {
#line 627
          goto case_99;
        }
#line 627
        if ((int )*param == 67) {
#line 627
          goto case_99;
        }
#line 627
        if ((int )*param == 115) {
#line 627
          goto case_99;
        }
#line 627
        if ((int )*param == 83) {
#line 627
          goto case_99;
        }
#line 720
        if ((int )*param == 110) {
#line 720
          goto case_110;
        }
#line 720
        if ((int )*param == 78) {
#line 720
          goto case_110;
        }
#line 622
        goto switch_break;
        case_99: /* CIL Label */ 
        case_67: /* CIL Label */ 
        case_115: /* CIL Label */ 
        case_83: /* CIL Label */ 
#line 628
        if (*rpos) {
#line 630
          if ((int )*rpos == 34) {
#line 632
            rpos ++;
#line 633
            quoted = 1;
          }
#line 635
          valc ++;
#line 636
          values[valc] = rpos;
#line 637
          if (*(param + 1)) {
#line 639
            if (quoted) {
#line 641
              j = 0;
              {
#line 642
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 642
                if ((int )*rpos != 34) {
#line 642
                  if (! *rpos) {
#line 642
                    goto while_break___5;
                  }
                } else {
#line 642
                  goto while_break___5;
                }
#line 644
                rpos ++;
#line 645
                if ((int )*rpos == 34) {
#line 645
                  if ((int )*(rpos - 1) == 92) {
#line 647
                    j ++;
#line 648
                    *(rpos - j) = *rpos;
#line 649
                    rpos ++;
                  }
                }
#line 651
                if (j) {
#line 651
                  *(rpos - j) = *rpos;
                }
              }
              while_break___5: /* CIL Label */ ;
              }
#line 653
              if ((int )*rpos != 34) {
                {
#line 655
                error_in_line();
#line 656
                panic((char *)"Quotation not ended", (char *)((void *)0), (char *)((void *)0));
                }
              }
#line 658
              *(rpos - j) = (char)0;
#line 659
              *rpos = (char)0;
            } else {
              {
#line 662
              while (1) {
                while_continue___6: /* CIL Label */ ;
                {
#line 662
                tmp___2 = __ctype_b_loc();
                }
#line 662
                if ((int const   )*(*tmp___2 + (int )*rpos) & 8192) {
#line 662
                  goto while_break___6;
                } else
#line 662
                if (! *rpos) {
#line 662
                  goto while_break___6;
                }
#line 662
                rpos ++;
              }
              while_break___6: /* CIL Label */ ;
              }
#line 663
              *rpos = (char)0;
            }
          } else {
#line 667
            j = 0;
            {
#line 668
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 668
              if (! *rpos) {
#line 668
                goto while_break___7;
              }
#line 670
              rpos ++;
#line 671
              if ((int )*rpos == 34) {
#line 673
                if ((int )*(rpos - 1) == 92) {
#line 675
                  j ++;
#line 676
                  *(rpos - j) = *rpos;
#line 677
                  rpos ++;
#line 678
                  if (! *rpos) {
                    {
#line 680
                    error_in_line();
#line 681
                    panic((char *)"Quotation not ended", (char *)((void *)0), (char *)((void *)0));
                    }
                  }
                } else
#line 683
                if (*(rpos + 1)) {
#line 683
                  if (quoted) {
                    {
#line 685
                    error_in_line();
#line 686
                    panic((char *)"Too many parameters", values[0], (char *)((void *)0));
                    }
                  }
                }
              }
#line 689
              if (j) {
#line 689
                if (*rpos) {
#line 689
                  *(rpos - j) = *rpos;
                }
              }
            }
            while_break___7: /* CIL Label */ ;
            }
#line 691
            if (quoted) {
#line 693
              if ((int )*(rpos - 1) != 34) {
                {
#line 695
                error_in_line();
#line 696
                panic((char *)"Quotation not ended", (char *)((void *)0), (char *)((void *)0));
                }
              }
#line 698
              *((rpos - j) - 1) = (char)0;
            } else {
#line 701
              *(rpos - j) = (char)0;
            }
#line 703
            *rpos = (char)0;
          }
#line 705
          if ((int )*param == 67) {
#line 705
            goto _L;
          } else
#line 705
          if ((int )*param == 99) {
            _L: /* CIL Label */ 
#line 705
            if (*(values[valc] + 1)) {
              {
#line 707
              error_in_line();
#line 708
              panic((char *)"Single character parameter expected", values[0], (char *)((void *)0));
              }
            }
          }
        } else
#line 712
        if ((int )*param == 83) {
          {
#line 714
          error_in_line();
#line 715
          panic((char *)"Mandatory parameter missing", values[0], (char *)((void *)0));
          }
        } else
#line 712
        if ((int )*param == 67) {
          {
#line 714
          error_in_line();
#line 715
          panic((char *)"Mandatory parameter missing", values[0], (char *)((void *)0));
          }
        }
#line 718
        goto switch_break;
        case_110: /* CIL Label */ 
        case_78: /* CIL Label */ 
#line 721
        if (*rpos) {
#line 723
          valc ++;
#line 724
          values[valc] = rpos;
#line 725
          if ((int )*rpos == 42) {
            {
#line 725
            tmp___5 = __ctype_b_loc();
            }
#line 725
            if ((int const   )*(*tmp___5 + (int )*(rpos + 1)) & 8192) {
#line 727
              rpos ++;
#line 728
              *rpos = (char)0;
            } else
#line 725
            if (! *(rpos + 1)) {
#line 727
              rpos ++;
#line 728
              *rpos = (char)0;
            } else {
#line 725
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
            {
#line 731
            while (1) {
              while_continue___8: /* CIL Label */ ;
              {
#line 731
              tmp___3 = __ctype_b_loc();
              }
#line 731
              if (! ((int const   )*(*tmp___3 + (int )*rpos) & 2048)) {
#line 731
                goto while_break___8;
              }
#line 731
              rpos ++;
            }
            while_break___8: /* CIL Label */ ;
            }
            {
#line 732
            tmp___4 = __ctype_b_loc();
            }
#line 732
            if (! ((int const   )*(*tmp___4 + (int )*rpos) & 8192)) {
#line 732
              if (*rpos) {
                {
#line 734
                error_in_line();
#line 735
                panic((char *)"A number expected", values[0], (char *)((void *)0));
                }
              }
            }
#line 737
            *rpos = (char)0;
          }
        } else
#line 741
        if ((int )*param == 78) {
          {
#line 743
          error_in_line();
#line 744
          panic((char *)"Mandatory parameter missing", values[0], (char *)((void *)0));
          }
        }
#line 747
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 749
        if (valc > 4) {
          {
#line 751
          error_in_line();
#line 752
          panic((char *)"Too many parameters", values[0], (char *)((void *)0));
          }
        }
      } else {
        {
#line 756
        error_in_line();
#line 757
        panic((char *)"Too many parameters", values[0], (char *)((void *)0));
        }
      }
#line 759
      param ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 761
    tmp___6 = __ctype_b_loc();
    }
#line 761
    if ((int const   )*(*tmp___6 + (int )*param) & 256) {
      {
#line 763
      error_in_line();
#line 764
      panic((char *)"Mandatory parameter missing", values[0], (char *)((void *)0));
      }
    }
  } else {
    {
#line 768
    error_in_line();
#line 769
    panic((char *)"Unknown option", values[0], (char *)((void *)0));
    }
  }
#line 771
  return (valc);
}
}
#line 775 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
char *expand_home(char *path ) 
{ 
  char *r ;
  char *home ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 779
  tmp = getenv("HOME");
#line 779
  home = tmp;
  }
#line 781
  if ((int )*path == 126) {
    {
#line 781
    tmp___3 = strlen("/");
#line 781
    tmp___4 = strncmp((char const   *)(path + 1), "/", tmp___3);
    }
#line 781
    if (tmp___4 == 0) {
#line 781
      if ((unsigned long )home != (unsigned long )((void *)0)) {
        {
#line 783
        tmp___0 = strlen((char const   *)home);
#line 783
        tmp___1 = strlen((char const   *)path);
#line 783
        tmp___2 = xmalloc(tmp___0 + tmp___1);
#line 783
        r = (char *)tmp___2;
#line 784
        strcpy((char */* __restrict  */)r, (char const   */* __restrict  */)home);
#line 785
        strcat((char */* __restrict  */)r, (char const   */* __restrict  */)(path + 1));
        }
      } else {
        {
#line 788
        r = xstrdup(path);
        }
      }
    } else {
      {
#line 788
      r = xstrdup(path);
      }
    }
  } else {
    {
#line 788
    r = xstrdup(path);
    }
  }
#line 790
  return (r);
}
}
#line 796 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
struct lookup_data *read_lookup_from_file(struct lookup_data **data , char *file ,
                                          char separator , int *max_key_len ) 
{ 
  FILE *fp___0 ;
  register int line_len ;
  size_t max_line_size ;
  char *efile ;
  char *line ;
  register char *p ;
  struct lookup_data *c_data ;
  void *tmp ;
  __ssize_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 801
  max_line_size = (size_t )1024;
#line 805
  c_data = *data;
#line 807
  efile = expand_home(file);
#line 809
  fp___0 = xfopen(efile, (char *)"r");
#line 811
  tmp = xmalloc(max_line_size);
#line 811
  line = (char *)tmp;
  }
#line 813
  if ((unsigned long )c_data != (unsigned long )((void *)0)) {
    {
#line 813
    while (1) {
      while_continue: /* CIL Label */ ;
#line 813
      if (! ((unsigned long )c_data->next != (unsigned long )((void *)0))) {
#line 813
        goto while_break;
      }
#line 813
      c_data = c_data->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 818
    tmp___0 = getline((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& max_line_size),
                      (FILE */* __restrict  */)fp___0);
#line 818
    line_len = (int )tmp___0;
    }
#line 828
    if (line_len > 0) {
      {
#line 833
      if ((int )*(line + (line_len - 1)) == 13) {
#line 833
        goto case_13;
      }
#line 833
      if ((int )*(line + (line_len - 1)) == 10) {
#line 833
        goto case_13;
      }
#line 830
      goto switch_break;
      case_13: /* CIL Label */ 
      case_10: /* CIL Label */ 
#line 834
      *(line + (line_len - 1)) = (char)0;
#line 835
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 838
      p = line;
      {
#line 839
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 839
        if (*p) {
#line 839
          if (! ((int )*p != (int )separator)) {
#line 839
            goto while_break___1;
          }
        } else {
#line 839
          goto while_break___1;
        }
#line 839
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 840
      if (*p) {
#line 842
        *p = (char)0;
#line 843
        p ++;
#line 845
        if ((unsigned long )c_data == (unsigned long )((void *)0)) {
          {
#line 847
          tmp___1 = xmalloc(sizeof(struct lookup_data ));
#line 847
          *data = (struct lookup_data *)tmp___1;
#line 848
          c_data = *data;
          }
        } else {
          {
#line 851
          tmp___2 = xmalloc(sizeof(struct lookup_data ));
#line 851
          c_data->next = (struct lookup_data *)tmp___2;
#line 852
          c_data = c_data->next;
          }
        }
        {
#line 854
        c_data->next = (struct lookup_data *)((void *)0);
#line 855
        tmp___3 = xstrdup(line);
#line 855
        c_data->key = (uint8_t *)tmp___3;
#line 856
        tmp___4 = xstrdup(p);
#line 856
        c_data->value = (uint8_t *)tmp___4;
#line 857
        tmp___5 = strlen((char const   *)c_data->key);
#line 857
        c_data->key_len = (int )tmp___5;
        }
#line 858
        if (*max_key_len < c_data->key_len) {
#line 858
          *max_key_len = c_data->key_len;
        }
      }
    }
#line 815
    if (! (line_len != -1)) {
#line 815
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 862
  fclose(fp___0);
#line 863
  free((void *)line);
#line 864
  free((void *)efile);
  }
#line 865
  return (c_data);
}
}
#line 871 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
int expand_non_print(char *s , uint8_t **t ) 
{ 
  char num[5] ;
  char *w ;
  int c ;
  int len ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 878
  num[0] = (char )'0';
#line 879
  num[1] = (char )'x';
#line 880
  num[4] = (char)0;
#line 881
  len = 0;
#line 883
  tmp = xstrdup(s);
#line 883
  *t = (uint8_t *)tmp;
#line 884
  w = (char *)*t;
  }
  {
#line 886
  while (1) {
    while_continue: /* CIL Label */ ;
#line 886
    if (! *s) {
#line 886
      goto while_break;
    }
#line 888
    if ((int )*s == 92) {
#line 888
      if ((int )*(s + 1) == 120) {
        {
#line 888
        tmp___0 = __ctype_b_loc();
        }
#line 888
        if ((int const   )*(*tmp___0 + (int )*(s + 2)) & 4096) {
          {
#line 888
          tmp___1 = __ctype_b_loc();
          }
#line 888
          if ((int const   )*(*tmp___1 + (int )*(s + 3)) & 4096) {
            {
#line 890
            num[2] = *(s + 2);
#line 891
            num[3] = *(s + 3);
#line 892
            sscanf((char const   */* __restrict  */)(num), (char const   */* __restrict  */)"%i",
                   & c);
#line 893
            *w = (char )c;
#line 894
            s += 3;
            }
          } else {
#line 897
            *w = *s;
          }
        } else {
#line 897
          *w = *s;
        }
      } else {
#line 897
        *w = *s;
      }
    } else {
#line 897
      *w = *s;
    }
#line 899
    s ++;
#line 900
    w ++;
#line 901
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 903
  *w = (char)0;
#line 904
  return (len);
}
}
#line 908 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
void parse_field_type(char *t , struct field *f ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;

  {
  {
#line 911
  tmp___35 = strcmp((char const   *)t, "char");
  }
#line 911
  if (tmp___35 == 0) {
#line 913
    f->type = 4;
#line 914
    f->length = (int )sizeof(char );
#line 915
    f->endianess = system_endianess;
  } else {
    {
#line 916
    tmp___34 = strcmp((char const   *)t, "short");
    }
#line 916
    if (tmp___34 == 0) {
#line 918
      f->type = 3;
#line 919
      f->length = (int )sizeof(short );
#line 920
      f->endianess = system_endianess;
    } else {
      {
#line 921
      tmp___33 = strcmp((char const   *)t, "int");
      }
#line 921
      if (tmp___33 == 0) {
#line 923
        f->type = 3;
#line 924
        f->length = (int )sizeof(int );
#line 925
        f->endianess = system_endianess;
      } else {
        {
#line 926
        tmp___32 = strcmp((char const   *)t, "long");
        }
#line 926
        if (tmp___32 == 0) {
#line 928
          f->type = 3;
#line 929
          f->length = (int )sizeof(long );
#line 930
          f->endianess = system_endianess;
        } else {
          {
#line 931
          tmp___31 = strcmp((char const   *)t, "llong");
          }
#line 931
          if (tmp___31 == 0) {
#line 933
            f->type = 3;
#line 934
            f->length = (int )sizeof(long long );
#line 935
            f->endianess = system_endianess;
          } else {
            {
#line 936
            tmp___30 = strcmp((char const   *)t, "ushort");
            }
#line 936
            if (tmp___30 == 0) {
#line 938
              f->type = 10;
#line 939
              f->length = (int )sizeof(unsigned short );
#line 940
              f->endianess = system_endianess;
            } else {
              {
#line 941
              tmp___29 = strcmp((char const   *)t, "uint");
              }
#line 941
              if (tmp___29 == 0) {
#line 943
                f->type = 10;
#line 944
                f->length = (int )sizeof(unsigned int );
#line 945
                f->endianess = system_endianess;
              } else {
                {
#line 946
                tmp___28 = strcmp((char const   *)t, "ulong");
                }
#line 946
                if (tmp___28 == 0) {
#line 948
                  f->type = 10;
#line 949
                  f->length = (int )sizeof(unsigned long );
#line 950
                  f->endianess = system_endianess;
                } else {
                  {
#line 951
                  tmp___27 = strcmp((char const   *)t, "ullong");
                  }
#line 951
                  if (tmp___27 == 0) {
#line 953
                    f->type = 10;
#line 954
                    f->length = (int )sizeof(long long );
#line 955
                    f->endianess = system_endianess;
                  } else {
                    {
#line 956
                    tmp___26 = strcmp((char const   *)t, "float");
                    }
#line 956
                    if (tmp___26 == 0) {
#line 958
                      f->type = 7;
#line 959
                      f->length = (int )sizeof(float );
#line 960
                      f->endianess = system_endianess;
                    } else {
                      {
#line 961
                      tmp___25 = strcmp((char const   *)t, "float_be");
                      }
#line 961
                      if (tmp___25 == 0) {
#line 963
                        f->type = 7;
#line 964
                        f->length = (int )sizeof(float );
#line 965
                        f->endianess = 1;
                      } else {
                        {
#line 966
                        tmp___24 = strcmp((char const   *)t, "float_le");
                        }
#line 966
                        if (tmp___24 == 0) {
#line 968
                          f->type = 7;
#line 969
                          f->length = (int )sizeof(float );
#line 970
                          f->endianess = 3;
                        } else {
                          {
#line 971
                          tmp___23 = strcmp((char const   *)t, "double");
                          }
#line 971
                          if (tmp___23 == 0) {
#line 973
                            f->type = 8;
#line 974
                            f->length = (int )sizeof(double );
#line 975
                            f->endianess = system_endianess;
                          } else {
                            {
#line 976
                            tmp___22 = strcmp((char const   *)t, "double_be");
                            }
#line 976
                            if (tmp___22 == 0) {
#line 978
                              f->type = 8;
#line 979
                              f->length = (int )sizeof(double );
#line 980
                              f->endianess = 1;
                            } else {
                              {
#line 981
                              tmp___21 = strcmp((char const   *)t, "double_le");
                              }
#line 981
                              if (tmp___21 == 0) {
#line 983
                                f->type = 8;
#line 984
                                f->length = (int )sizeof(double );
#line 985
                                f->endianess = 3;
                              } else {
                                {
#line 986
                                tmp___20 = strcmp((char const   *)t, "int8");
                                }
#line 986
                                if (tmp___20 == 0) {
#line 988
                                  f->type = 3;
#line 989
                                  f->length = 1;
#line 990
                                  f->endianess = system_endianess;
                                } else {
                                  {
#line 991
                                  tmp___19 = strcmp((char const   *)t, "int16_be");
                                  }
#line 991
                                  if (tmp___19 == 0) {
#line 993
                                    f->type = 3;
#line 994
                                    f->length = 2;
#line 995
                                    f->endianess = 1;
                                  } else {
                                    {
#line 996
                                    tmp___18 = strcmp((char const   *)t, "int16_le");
                                    }
#line 996
                                    if (tmp___18 == 0) {
#line 998
                                      f->type = 3;
#line 999
                                      f->length = 2;
#line 1000
                                      f->endianess = 3;
                                    } else {
                                      {
#line 1001
                                      tmp___17 = strcmp((char const   *)t, "int32_be");
                                      }
#line 1001
                                      if (tmp___17 == 0) {
#line 1003
                                        f->type = 3;
#line 1004
                                        f->length = 4;
#line 1005
                                        f->endianess = 1;
                                      } else {
                                        {
#line 1006
                                        tmp___16 = strcmp((char const   *)t, "int32_le");
                                        }
#line 1006
                                        if (tmp___16 == 0) {
#line 1008
                                          f->type = 3;
#line 1009
                                          f->length = 4;
#line 1010
                                          f->endianess = 3;
                                        } else {
                                          {
#line 1011
                                          tmp___15 = strcmp((char const   *)t, "int64_be");
                                          }
#line 1011
                                          if (tmp___15 == 0) {
#line 1013
                                            f->type = 3;
#line 1014
                                            f->length = 8;
#line 1015
                                            f->endianess = 1;
                                          } else {
                                            {
#line 1016
                                            tmp___14 = strcmp((char const   *)t, "int64_le");
                                            }
#line 1016
                                            if (tmp___14 == 0) {
#line 1018
                                              f->type = 3;
#line 1019
                                              f->length = 8;
#line 1020
                                              f->endianess = 3;
                                            } else {
                                              {
#line 1021
                                              tmp___13 = strcmp((char const   *)t,
                                                                "uint8");
                                              }
#line 1021
                                              if (tmp___13 == 0) {
#line 1023
                                                f->type = 10;
#line 1024
                                                f->length = 1;
#line 1025
                                                f->endianess = system_endianess;
                                              } else {
                                                {
#line 1026
                                                tmp___12 = strcmp((char const   *)t,
                                                                  "uint16_be");
                                                }
#line 1026
                                                if (tmp___12 == 0) {
#line 1028
                                                  f->type = 10;
#line 1029
                                                  f->length = 2;
#line 1030
                                                  f->endianess = 1;
                                                } else {
                                                  {
#line 1031
                                                  tmp___11 = strcmp((char const   *)t,
                                                                    "uint16_le");
                                                  }
#line 1031
                                                  if (tmp___11 == 0) {
#line 1033
                                                    f->type = 10;
#line 1034
                                                    f->length = 2;
#line 1035
                                                    f->endianess = 3;
                                                  } else {
                                                    {
#line 1036
                                                    tmp___10 = strcmp((char const   *)t,
                                                                      "uint32_be");
                                                    }
#line 1036
                                                    if (tmp___10 == 0) {
#line 1038
                                                      f->type = 10;
#line 1039
                                                      f->length = 4;
#line 1040
                                                      f->endianess = 1;
                                                    } else {
                                                      {
#line 1041
                                                      tmp___9 = strcmp((char const   *)t,
                                                                       "uint32_le");
                                                      }
#line 1041
                                                      if (tmp___9 == 0) {
#line 1043
                                                        f->type = 10;
#line 1044
                                                        f->length = 4;
#line 1045
                                                        f->endianess = 3;
                                                      } else {
                                                        {
#line 1046
                                                        tmp___8 = strcmp((char const   *)t,
                                                                         "uint64_be");
                                                        }
#line 1046
                                                        if (tmp___8 == 0) {
#line 1048
                                                          f->type = 10;
#line 1049
                                                          f->length = 8;
#line 1050
                                                          f->endianess = 1;
                                                        } else {
                                                          {
#line 1051
                                                          tmp___7 = strcmp((char const   *)t,
                                                                           "uint64_le");
                                                          }
#line 1051
                                                          if (tmp___7 == 0) {
#line 1053
                                                            f->type = 10;
#line 1054
                                                            f->length = 8;
#line 1055
                                                            f->endianess = 3;
                                                          } else {
                                                            {
#line 1056
                                                            tmp___6 = strncmp((char const   *)t,
                                                                              "bcd_be_",
                                                                              (size_t )7);
                                                            }
#line 1056
                                                            if (tmp___6 == 0) {
                                                              {
#line 1058
                                                              f->type = 9;
#line 1059
                                                              tmp = is_digit(t + 7);
                                                              }
#line 1059
                                                              if (tmp) {
                                                                {
#line 1059
                                                                sscanf((char const   */* __restrict  */)(t + 7),
                                                                       (char const   */* __restrict  */)"%i",
                                                                       & f->length);
                                                                }
                                                              }
#line 1060
                                                              f->endianess = 1;
                                                            } else {
                                                              {
#line 1061
                                                              tmp___5 = strncmp((char const   *)t,
                                                                                "bcd_le_",
                                                                                (size_t )7);
                                                              }
#line 1061
                                                              if (tmp___5 == 0) {
                                                                {
#line 1063
                                                                f->type = 9;
#line 1064
                                                                tmp___0 = is_digit(t + 7);
                                                                }
#line 1064
                                                                if (tmp___0) {
                                                                  {
#line 1064
                                                                  sscanf((char const   */* __restrict  */)(t + 7),
                                                                         (char const   */* __restrict  */)"%i",
                                                                         & f->length);
                                                                  }
                                                                }
#line 1065
                                                                f->endianess = 3;
                                                              } else {
                                                                {
#line 1066
                                                                tmp___4 = strncmp((char const   *)t,
                                                                                  "hex_be_",
                                                                                  (size_t )7);
                                                                }
#line 1066
                                                                if (tmp___4 == 0) {
                                                                  {
#line 1068
                                                                  f->type = 11;
#line 1069
                                                                  tmp___1 = is_digit(t + 7);
                                                                  }
#line 1069
                                                                  if (tmp___1) {
                                                                    {
#line 1069
                                                                    sscanf((char const   */* __restrict  */)(t + 7),
                                                                           (char const   */* __restrict  */)"%i",
                                                                           & f->length);
                                                                    }
                                                                  }
#line 1070
                                                                  f->endianess = 1;
                                                                } else {
                                                                  {
#line 1071
                                                                  tmp___3 = strncmp((char const   *)t,
                                                                                    "hex_le_",
                                                                                    (size_t )7);
                                                                  }
#line 1071
                                                                  if (tmp___3 == 0) {
                                                                    {
#line 1073
                                                                    f->type = 11;
#line 1074
                                                                    tmp___2 = is_digit(t + 7);
                                                                    }
#line 1074
                                                                    if (tmp___2) {
                                                                      {
#line 1074
                                                                      sscanf((char const   */* __restrict  */)(t + 7),
                                                                             (char const   */* __restrict  */)"%i",
                                                                             & f->length);
                                                                      }
                                                                    }
#line 1075
                                                                    f->endianess = 3;
                                                                  } else {
                                                                    {
#line 1078
                                                                    error_in_line();
#line 1079
                                                                    panic((char *)"Unknown field type",
                                                                          t, (char *)((void *)0));
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 1082
  if (f->length < 1) {
    {
#line 1084
    error_in_line();
#line 1085
    panic((char *)"Error in field type", t, (char *)((void *)0));
    }
  }
#line 1087
  return;
}
}
#line 1100 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
void print_info(void) 
{ 
  struct structure *s ;
  struct record *r ;
  struct field *f ;
  int pos ;
  char const   *tmp ;

  {
#line 1103
  s = structure;
  {
#line 1108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1108
    if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 1108
      goto while_break;
    }
    {
#line 1110
    printf((char const   */* __restrict  */)"Structure %s - ", s->name);
    }
    {
#line 1113
    if ((int )s->type[0] == 98) {
#line 1113
      goto case_98;
    }
#line 1116
    if ((int )s->type[0] == 102) {
#line 1116
      goto case_102;
    }
#line 1119
    if ((int )s->type[0] == 115) {
#line 1119
      goto case_115;
    }
#line 1111
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 1114
    printf((char const   */* __restrict  */)"binary");
    }
#line 1115
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 1117
    printf((char const   */* __restrict  */)"fixed length");
    }
#line 1118
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 1120
    printf((char const   */* __restrict  */)"separated by \'%c\'", (int )s->type[1]);
    }
#line 1121
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1123
    printf((char const   */* __restrict  */)" - %d\n", s->max_record_len);
#line 1125
    r = s->r;
    }
    {
#line 1126
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1126
      if (! ((unsigned long )r != (unsigned long )((void *)0))) {
#line 1126
        goto while_break___0;
      }
      {
#line 1128
      f = r->f;
#line 1129
      pos = 1;
#line 1130
      printf((char const   */* __restrict  */)"  Record %s  %d\n", r->name, r->length);
      }
      {
#line 1131
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1131
        if (! ((unsigned long )f != (unsigned long )((void *)0))) {
#line 1131
          goto while_break___1;
        }
#line 1133
        if ((int )s->type[0] == 115) {
#line 1135
          if ((unsigned long )f->name == (unsigned long )((void *)0)) {
#line 1135
            tmp = "*";
          } else {
#line 1135
            tmp = (char const   *)f->name;
          }
          {
#line 1135
          printf((char const   */* __restrict  */)"    Field %-30s%5d%5d\n", tmp,
                 pos, f->length);
#line 1136
          pos ++;
          }
        } else {
          {
#line 1139
          printf((char const   */* __restrict  */)"    Field %-30s%5d%5d\n", f->name,
                 pos, f->length);
#line 1140
          pos += f->length;
          }
        }
#line 1142
        f = f->next;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1144
      r = r->next;
#line 1145
      printf((char const   */* __restrict  */)"\n");
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1147
    s = s->next;
#line 1148
    printf((char const   */* __restrict  */)"\n\n");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1150
  return;
}
}
#line 1152 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/parserc.c"
void parserc(char *rcfile , char *include_field_list ) 
{ 
  struct structure *c_structure ;
  struct field *c_field ;
  struct id *c_id ;
  struct record *c_record ;
  struct output *c_output ;
  struct lookup *c_lookup ;
  struct lookup_data *c_lookup_data ;
  struct include_field *fl ;
  struct include_field *tmp ;
  char *read_buffer___0 ;
  size_t read_buffer_size___0 ;
  int line_status ;
  int status ;
  int opt_count ;
  int field_count ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  int tmp___30 ;
  int rc ;
  int buflen ;
  char *errbuf ;
  size_t tmp___31 ;
  void *tmp___32 ;
  int tmp___33 ;
  void *tmp___34 ;
  void *tmp___35 ;
  int tmp___36 ;
  void *tmp___37 ;
  void *tmp___38 ;
  int tmp___39 ;
  void *tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  char *tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  void *tmp___95 ;
  void *tmp___96 ;
  char *tmp___97 ;
  char *tmp___98 ;
  size_t tmp___99 ;
  char *tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;

  {
  {
#line 1155
  c_structure = structure;
#line 1156
  c_field = (struct field *)((void *)0);
#line 1157
  c_id = (struct id *)((void *)0);
#line 1158
  c_record = (struct record *)((void *)0);
#line 1159
  c_output = output;
#line 1160
  c_lookup = (struct lookup *)((void *)0);
#line 1161
  c_lookup_data = (struct lookup_data *)((void *)0);
#line 1162
  tmp = parse_include_list(include_field_list);
#line 1162
  fl = tmp;
#line 1167
  status = 1;
#line 1171
  open_rc_file(rcfile);
#line 1173
  read_buffer_size___0 = (size_t )1024;
#line 1174
  tmp___0 = xmalloc(read_buffer_size___0);
#line 1174
  read_buffer___0 = (char *)tmp___0;
#line 1175
  tmp___1 = xmalloc(command_len);
#line 1175
  command = (char *)tmp___1;
#line 1178
  atexit(& remove_temp_file);
  }
#line 1181
  if ((unsigned long )c_structure != (unsigned long )((void *)0)) {
    {
#line 1181
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1181
      if (! ((unsigned long )c_structure->next != (unsigned long )((void *)0))) {
#line 1181
        goto while_break;
      }
#line 1181
      c_structure = c_structure->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1183
  if ((unsigned long )c_output != (unsigned long )((void *)0)) {
    {
#line 1183
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1183
      if (! ((unsigned long )c_output->next != (unsigned long )((void *)0))) {
#line 1183
        goto while_break___0;
      }
#line 1183
      c_output = c_output->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1185
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1185
    line_status = read_logical_line(& read_buffer___0, & read_buffer_size___0);
    }
#line 1185
    if (! (line_status != 4)) {
#line 1185
      goto while_break___1;
    }
    {
#line 1189
    if (line_status == 1) {
#line 1189
      goto case_1;
    }
#line 1745
    if (line_status == 2) {
#line 1745
      goto case_2___0;
    }
#line 1766
    if (line_status == 3) {
#line 1766
      goto case_3___0;
    }
#line 1187
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1190
    opt_count = parse_option(read_buffer___0);
    }
    {
#line 1193
    if (status == 1) {
#line 1193
      goto case_1___0;
    }
#line 1302
    if (status == 2) {
#line 1302
      goto case_2;
    }
#line 1403
    if (status == 3) {
#line 1403
      goto case_3;
    }
#line 1572
    if (status == 4) {
#line 1572
      goto case_4;
    }
#line 1688
    if (status == 8) {
#line 1688
      goto case_8;
    }
#line 1739
    if (status == 9) {
#line 1739
      goto case_9;
    }
#line 1739
    if (status == 5) {
#line 1739
      goto case_9;
    }
#line 1739
    if (status == 7) {
#line 1739
      goto case_9;
    }
#line 1739
    if (status == 6) {
#line 1739
      goto case_9;
    }
#line 1191
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 1194
    tmp___14 = strcmp((char const   *)values[0], "structure");
    }
#line 1194
    if (tmp___14 == 0) {
#line 1196
      if ((unsigned long )structure == (unsigned long )((void *)0)) {
        {
#line 1198
        tmp___2 = xmalloc(sizeof(struct structure ));
#line 1198
        c_structure = (struct structure *)tmp___2;
#line 1199
        structure = c_structure;
        }
      } else {
        {
#line 1202
        tmp___3 = xmalloc(sizeof(struct structure ));
#line 1202
        c_structure->next = (struct structure *)tmp___3;
#line 1203
        c_structure = c_structure->next;
        }
      }
      {
#line 1205
      c_structure->next = (struct structure *)((void *)0);
#line 1206
      c_structure->name = xstrdup(values[1]);
#line 1207
      c_structure->type[0] = (char )'f';
#line 1208
      c_structure->quote = (char)0;
#line 1209
      c_structure->header = 0;
#line 1210
      c_structure->output_name = (char *)((void *)0);
#line 1211
      c_structure->vote = 0;
#line 1212
      c_structure->o = (struct output *)((void *)0);
#line 1213
      c_structure->r = (struct record *)((void *)0);
#line 1214
      status = 5;
      }
    } else {
      {
#line 1215
      tmp___13 = strcmp((char const   *)values[0], "output");
      }
#line 1215
      if (tmp___13 == 0) {
#line 1217
        if ((unsigned long )c_output == (unsigned long )((void *)0)) {
          {
#line 1219
          tmp___4 = xmalloc(sizeof(struct output ));
#line 1219
          c_output = (struct output *)tmp___4;
#line 1220
          output = c_output;
          }
        } else {
          {
#line 1223
          tmp___5 = xmalloc(sizeof(struct output ));
#line 1223
          c_output->next = (struct output *)tmp___5;
#line 1224
          c_output = c_output->next;
          }
        }
        {
#line 1226
        c_output->next = (struct output *)((void *)0);
#line 1227
        c_output->name = xstrdup(values[1]);
#line 1228
        c_output->file_header = (uint8_t *)((void *)0);
#line 1229
        c_output->file_trailer = (uint8_t *)((void *)0);
#line 1230
        c_output->header = (uint8_t *)((void *)0);
#line 1231
        c_output->data = (uint8_t *)"%d";
#line 1232
        c_output->lookup = (uint8_t *)((void *)0);
#line 1233
        c_output->separator = (uint8_t *)((void *)0);
#line 1234
        c_output->record_header = (uint8_t *)((void *)0);
#line 1235
        c_output->record_trailer = (uint8_t *)"\n";
#line 1236
        c_output->group_header = (uint8_t *)((void *)0);
#line 1237
        c_output->group_trailer = (uint8_t *)((void *)0);
#line 1238
        c_output->element_header = (uint8_t *)((void *)0);
#line 1239
        c_output->element_trailer = (uint8_t *)((void *)0);
#line 1240
        c_output->justify = (uint8_t )1;
#line 1241
        c_output->indent = (uint8_t *)((void *)0);
#line 1242
        c_output->no_data = 1;
#line 1243
        c_output->hex_cap = 0;
#line 1244
        c_output->empty_chars = (char *)" \f\n\r\t\v";
#line 1245
        c_output->print_empty = 1;
#line 1246
        c_output->output_file = (char *)((void *)0);
#line 1247
        c_output->ofp = (FILE *)((void *)0);
        }
#line 1248
        if ((unsigned long )fl != (unsigned long )((void *)0)) {
#line 1250
          c_output->fl = fl;
        } else {
#line 1253
          c_output->fl = (struct include_field *)((void *)0);
        }
#line 1255
        status = 7;
      } else {
        {
#line 1256
        tmp___12 = strcmp((char const   *)values[0], "lookup");
        }
#line 1256
        if (tmp___12 == 0) {
#line 1258
          if ((unsigned long )c_lookup == (unsigned long )((void *)0)) {
            {
#line 1260
            tmp___6 = xmalloc(sizeof(struct lookup ));
#line 1260
            c_lookup = (struct lookup *)tmp___6;
#line 1261
            lookup = c_lookup;
            }
          } else {
            {
#line 1264
            tmp___7 = xmalloc(sizeof(struct lookup ));
#line 1264
            c_lookup->next = (struct lookup *)tmp___7;
#line 1265
            c_lookup = c_lookup->next;
            }
          }
          {
#line 1267
          c_lookup->next = (struct lookup *)((void *)0);
#line 1268
          c_lookup->name = xstrdup(values[1]);
#line 1269
          c_lookup->type = (char)1;
#line 1270
          c_lookup->default_value = (uint8_t *)"";
#line 1271
          c_lookup->max_key_len = 0;
#line 1272
          c_lookup->data = (struct lookup_data *)((void *)0);
#line 1273
          status = 9;
          }
        } else {
          {
#line 1274
          tmp___11 = strcmp((char const   *)values[0], "const");
          }
#line 1274
          if (tmp___11 == 0) {
#line 1276
            if ((unsigned long )const_field == (unsigned long )((void *)0)) {
              {
#line 1278
              tmp___8 = xmalloc(sizeof(struct field ));
#line 1278
              c_field = (struct field *)tmp___8;
#line 1279
              const_field = c_field;
              }
            } else {
#line 1282
              c_field = const_field;
              {
#line 1283
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 1283
                if (! ((unsigned long )c_field->next != (unsigned long )((void *)0))) {
#line 1283
                  goto while_break___2;
                }
#line 1283
                c_field = c_field->next;
              }
              while_break___2: /* CIL Label */ ;
              }
              {
#line 1284
              tmp___9 = xmalloc(sizeof(struct field ));
#line 1284
              c_field->next = (struct field *)tmp___9;
#line 1285
              c_field = c_field->next;
              }
            }
            {
#line 1287
            c_field->lookup_table_name = (char *)((void *)0);
#line 1288
            c_field->lookup = (struct lookup *)((void *)0);
#line 1289
            c_field->rep = (struct replace *)((void *)0);
#line 1290
            c_field->next = (struct field *)((void *)0);
#line 1291
            c_field->name = xstrdup(values[1]);
#line 1292
            c_field->const_data = xstrdup(values[2]);
#line 1293
            c_field->position = 0;
#line 1294
            tmp___10 = strlen((char const   *)c_field->const_data);
#line 1294
            c_field->length = (int )tmp___10;
#line 1295
            c_field->o = (struct output *)((void *)0);
            }
          } else {
            {
#line 1298
            error_in_line();
#line 1299
            panic((char *)"Option not inside structure, output or lookup", values[0],
                  (char *)((void *)0));
            }
          }
        }
      }
    }
#line 1301
    goto switch_break___0;
    case_2: /* CIL Label */ 
    {
#line 1303
    tmp___27 = strcmp((char const   *)values[0], "type");
    }
#line 1303
    if (tmp___27 == 0) {
      {
#line 1305
      tmp___17 = strcmp((char const   *)values[1], "fixed");
      }
#line 1305
      if (tmp___17 == 0) {
#line 1307
        c_structure->type[0] = (char )'f';
#line 1308
        if (opt_count > 1) {
          {
#line 1310
          error_in_line();
#line 1311
          panic((char *)"too many parameters for", values[0], (char *)((void *)0));
          }
        }
      } else {
        {
#line 1313
        tmp___16 = strcmp((char const   *)values[1], "separated");
        }
#line 1313
        if (tmp___16 == 0) {
#line 1315
          c_structure->type[0] = (char )'s';
#line 1316
          c_structure->type[1] = (char )',';
#line 1317
          c_structure->type[2] = (char)0;
#line 1319
          if (opt_count > 1) {
#line 1321
            c_structure->type[1] = *(values[2] + 0);
          }
#line 1323
          if (opt_count > 2) {
#line 1325
            if ((int )*(values[3] + 0) == 42) {
#line 1327
              c_structure->type[2] = *(values[3] + 0);
            } else {
              {
#line 1330
              error_in_line();
#line 1331
              panic((char *)"An \'*\' is expected", values[0], (char *)((void *)0));
              }
            }
          }
        } else {
          {
#line 1334
          tmp___15 = strcmp((char const   *)values[1], "binary");
          }
#line 1334
          if (tmp___15 == 0) {
#line 1336
            c_structure->type[0] = (char )'b';
#line 1337
            if (opt_count > 1) {
              {
#line 1339
              error_in_line();
#line 1340
              panic((char *)"too many parameters for", values[0], (char *)((void *)0));
              }
            }
          } else {
            {
#line 1344
            error_in_line();
#line 1345
            panic((char *)"Unknown type", (char *)((void *)0), (char *)((void *)0));
            }
          }
        }
      }
    } else {
      {
#line 1347
      tmp___26 = strcmp((char const   *)values[0], "header");
      }
#line 1347
      if (tmp___26 == 0) {
        {
#line 1349
        tmp___20 = strcmp((char const   *)values[1], "first");
        }
#line 1349
        if (tmp___20 == 0) {
#line 1351
          c_structure->header = 1;
        } else {
          {
#line 1352
          tmp___19 = strcmp((char const   *)values[1], "all");
          }
#line 1352
          if (tmp___19 == 0) {
#line 1354
            c_structure->header = 2;
          } else {
            {
#line 1355
            tmp___18 = strcmp((char const   *)values[1], "no");
            }
#line 1355
            if (tmp___18 == 0) {
#line 1357
              c_structure->header = 0;
            } else {
              {
#line 1360
              error_in_line();
#line 1361
              panic((char *)"first, all or no expected", (char *)((void *)0), (char *)((void *)0));
              }
            }
          }
        }
      } else {
        {
#line 1363
        tmp___25 = strcmp((char const   *)values[0], "output");
        }
#line 1363
        if (tmp___25 == 0) {
          {
#line 1365
          c_structure->output_name = xstrdup(values[1]);
          }
        } else {
          {
#line 1366
          tmp___24 = strcmp((char const   *)values[0], "record");
          }
#line 1366
          if (tmp___24 == 0) {
#line 1368
            if ((unsigned long )c_structure->r == (unsigned long )((void *)0)) {
              {
#line 1370
              tmp___21 = xmalloc(sizeof(struct record ));
#line 1370
              c_record = (struct record *)tmp___21;
#line 1371
              c_structure->r = c_record;
              }
            } else {
              {
#line 1374
              tmp___22 = xmalloc(sizeof(struct record ));
#line 1374
              c_record->next = (struct record *)tmp___22;
#line 1375
              c_record = c_record->next;
              }
            }
            {
#line 1377
            c_record->next = (struct record *)((void *)0);
#line 1378
            c_record->name = xstrdup(values[1]);
#line 1379
            c_record->i = (struct id *)((void *)0);
#line 1380
            c_record->f = (struct field *)((void *)0);
#line 1381
            c_record->fields_from = (char *)((void *)0);
#line 1382
            c_record->o = (struct output *)((void *)0);
#line 1383
            c_record->output_name = (char *)((void *)0);
#line 1384
            c_record->vote = 0;
#line 1385
            c_record->arb_length = 0;
#line 1386
            c_record->level = (struct level *)((void *)0);
#line 1387
            status = 6;
            }
          } else {
            {
#line 1388
            tmp___23 = strcmp((char const   *)values[0], "quoted");
            }
#line 1388
            if (tmp___23 == 0) {
#line 1390
              if (opt_count > 0) {
#line 1392
                c_structure->quote = *(values[1] + 0);
              } else {
#line 1395
                c_structure->quote = (char )'\"';
              }
            } else {
              {
#line 1399
              error_in_line();
#line 1400
              panic((char *)"Unknown option in structure", (char *)((void *)0), (char *)((void *)0));
              }
            }
          }
        }
      }
    }
#line 1402
    goto switch_break___0;
    case_3: /* CIL Label */ 
    {
#line 1404
    tmp___50 = strcmp((char const   *)values[0], "id");
    }
#line 1404
    if (tmp___50 == 0) {
#line 1404
      goto _L___0;
    } else {
      {
#line 1404
      tmp___51 = strcmp((char const   *)values[0], "rid");
      }
#line 1404
      if (tmp___51 == 0) {
        _L___0: /* CIL Label */ 
#line 1406
        if ((unsigned long )c_record->i == (unsigned long )((void *)0)) {
          {
#line 1408
          tmp___28 = xmalloc(sizeof(struct id ));
#line 1408
          c_id = (struct id *)tmp___28;
#line 1409
          c_record->i = c_id;
          }
        } else {
          {
#line 1412
          tmp___29 = xmalloc(sizeof(struct id ));
#line 1412
          c_id->next = (struct id *)tmp___29;
#line 1413
          c_id = c_id->next;
          }
        }
        {
#line 1415
        c_id->next = (struct id *)((void *)0);
#line 1416
        c_id->regexp = 0;
#line 1417
        tmp___30 = sscanf((char const   */* __restrict  */)values[1], (char const   */* __restrict  */)"%d",
                          & c_id->position);
        }
#line 1417
        if (tmp___30 != 1) {
          {
#line 1419
          error_in_line();
#line 1420
          panic((char *)"Error in number", (char *)((void *)0), (char *)((void *)0));
          }
        }
#line 1422
        if (c_id->position < 1) {
          {
#line 1424
          error_in_line();
#line 1425
          panic((char *)"Position must be greater than zero", (char *)((void *)0),
                (char *)((void *)0));
          }
        }
        {
#line 1427
        c_id->length = expand_non_print(values[2], & c_id->key);
#line 1428
        tmp___33 = strcmp((char const   *)values[0], "rid");
        }
#line 1428
        if (tmp___33 == 0) {
          {
#line 1434
          rc = regcomp((regex_t */* __restrict  */)(& c_id->reg), (char const   */* __restrict  */)c_id->key,
                       1 | (((1 << 1) << 1) << 1));
          }
#line 1435
          if (rc) {
            {
#line 1437
            tmp___31 = regerror(rc, (regex_t const   */* __restrict  */)(& c_id->reg),
                                (char */* __restrict  */)((void *)0), (size_t )0);
#line 1437
            buflen = (int )tmp___31;
#line 1438
            tmp___32 = xmalloc((size_t )(buflen + 1));
#line 1438
            errbuf = (char *)tmp___32;
#line 1439
            regerror(rc, (regex_t const   */* __restrict  */)(& c_id->reg), (char */* __restrict  */)errbuf,
                     (size_t )buflen);
#line 1440
            error_in_line();
#line 1441
            panic((char *)"Error in regular expression", (char *)c_id->key, errbuf);
            }
          }
#line 1443
          c_id->regexp = 1;
        }
      } else {
        {
#line 1449
        tmp___49 = strcmp((char const   *)values[0], "field");
        }
#line 1449
        if (tmp___49 == 0) {
#line 1451
          if ((unsigned long )c_record->f == (unsigned long )((void *)0)) {
            {
#line 1453
            tmp___34 = xmalloc(sizeof(struct field ));
#line 1453
            c_field = (struct field *)tmp___34;
#line 1454
            c_record->f = c_field;
            }
          } else {
            {
#line 1457
            tmp___35 = xmalloc(sizeof(struct field ));
#line 1457
            c_field->next = (struct field *)tmp___35;
#line 1458
            c_field = c_field->next;
            }
          }
#line 1460
          c_field->lookup_table_name = (char *)((void *)0);
#line 1461
          c_field->lookup = (struct lookup *)((void *)0);
#line 1462
          c_field->rep = (struct replace *)((void *)0);
#line 1463
          c_field->type = 1;
#line 1464
          c_field->next = (struct field *)((void *)0);
#line 1465
          c_field->const_data = (char *)((void *)0);
#line 1466
          c_field->length = 0;
#line 1467
          c_field->output_name = (char *)((void *)0);
#line 1468
          c_field->o = (struct output *)((void *)0);
#line 1470
          if ((int )*(values[1] + 0) == 42) {
#line 1470
            if (! *(values[1] + 1)) {
#line 1472
              c_field->name = (char *)((void *)0);
            } else {
              {
#line 1475
              c_field->name = xstrdup(values[1]);
              }
            }
          } else {
            {
#line 1475
            c_field->name = xstrdup(values[1]);
            }
          }
#line 1477
          if (opt_count > 1) {
#line 1479
            if ((int )*(values[2] + 0) == 42) {
#line 1479
              if (! (! *(values[2] + 1))) {
#line 1479
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              {
#line 1481
              tmp___36 = is_digit(values[2]);
              }
#line 1481
              if (tmp___36) {
                {
#line 1483
                sscanf((char const   */* __restrict  */)values[2], (char const   */* __restrict  */)"%d",
                       & c_field->length);
                }
              } else {
                {
#line 1486
                parse_field_type(values[2], c_field);
                }
              }
            }
#line 1489
            if (opt_count > 2) {
#line 1491
              if ((int )*(values[3] + 0) == 42) {
#line 1491
                if (! (! *(values[3] + 1))) {
                  {
#line 1493
                  c_field->lookup_table_name = xstrdup(values[3]);
                  }
                }
              } else {
                {
#line 1493
                c_field->lookup_table_name = xstrdup(values[3]);
                }
              }
#line 1495
              if (opt_count > 3) {
                {
#line 1497
                c_field->output_name = xstrdup(values[4]);
                }
              }
            }
          }
        } else {
          {
#line 1501
          tmp___48 = strcmp((char const   *)values[0], "fields-from");
          }
#line 1501
          if (tmp___48 == 0) {
            {
#line 1503
            c_record->fields_from = xstrdup(values[1]);
            }
          } else {
            {
#line 1504
            tmp___47 = strcmp((char const   *)values[0], "output");
            }
#line 1504
            if (tmp___47 == 0) {
              {
#line 1506
              c_record->output_name = xstrdup(values[1]);
              }
            } else {
              {
#line 1507
              tmp___46 = strcmp((char const   *)values[0], "field-count");
              }
#line 1507
              if (tmp___46 == 0) {
                {
#line 1509
                field_count = atoi((char const   *)values[1]);
                }
                {
#line 1510
                while (1) {
                  while_continue___3: /* CIL Label */ ;
#line 1510
                  tmp___39 = field_count;
#line 1510
                  field_count --;
#line 1510
                  if (! tmp___39) {
#line 1510
                    goto while_break___3;
                  }
#line 1512
                  if ((unsigned long )c_record->f == (unsigned long )((void *)0)) {
                    {
#line 1514
                    tmp___37 = xmalloc(sizeof(struct field ));
#line 1514
                    c_field = (struct field *)tmp___37;
#line 1515
                    c_record->f = c_field;
                    }
                  } else {
                    {
#line 1518
                    tmp___38 = xmalloc(sizeof(struct field ));
#line 1518
                    c_field->next = (struct field *)tmp___38;
#line 1519
                    c_field = c_field->next;
                    }
                  }
#line 1521
                  c_field->lookup_table_name = (char *)((void *)0);
#line 1522
                  c_field->lookup = (struct lookup *)((void *)0);
#line 1523
                  c_field->rep = (struct replace *)((void *)0);
#line 1524
                  c_field->next = (struct field *)((void *)0);
#line 1525
                  c_field->const_data = (char *)((void *)0);
#line 1526
                  c_field->length = 0;
#line 1527
                  c_field->name = (char *)((void *)0);
#line 1528
                  c_field->output_name = (char *)((void *)0);
#line 1529
                  c_field->o = (struct output *)((void *)0);
                }
                while_break___3: /* CIL Label */ ;
                }
              } else {
                {
#line 1531
                tmp___45 = strcmp((char const   *)values[0], "level");
                }
#line 1531
                if (tmp___45 == 0) {
                  {
#line 1533
                  tmp___40 = xmalloc(sizeof(struct level ));
#line 1533
                  c_record->level = (struct level *)tmp___40;
#line 1534
                  (c_record->level)->element_name = (char *)((void *)0);
#line 1535
                  (c_record->level)->group_name = (char *)((void *)0);
#line 1536
                  (c_record->level)->level = atoi((char const   *)values[1]);
#line 1537
                  (c_record->level)->indent_count = 0;
                  }
#line 1538
                  if ((c_record->level)->level < 1) {
                    {
#line 1540
                    error_in_line();
#line 1541
                    panic((char *)"Invalid level value", (char *)((void *)0), (char *)((void *)0));
                    }
                  } else
#line 1538
                  if ((c_record->level)->level > 1024) {
                    {
#line 1540
                    error_in_line();
#line 1541
                    panic((char *)"Invalid level value", (char *)((void *)0), (char *)((void *)0));
                    }
                  }
#line 1543
                  if (opt_count > 1) {
                    {
#line 1543
                    tmp___41 = strcmp((char const   *)values[2], "*");
                    }
#line 1543
                    if (tmp___41 != 0) {
                      {
#line 1545
                      (c_record->level)->element_name = xstrdup(values[2]);
#line 1546
                      ((c_record->level)->indent_count) ++;
                      }
                    }
                  }
#line 1548
                  if (opt_count > 2) {
                    {
#line 1550
                    (c_record->level)->group_name = xstrdup(values[3]);
#line 1551
                    ((c_record->level)->indent_count) ++;
                    }
                  }
                } else {
                  {
#line 1553
                  tmp___44 = strcmp((char const   *)values[0], "record-length");
                  }
#line 1553
                  if (tmp___44 == 0) {
                    {
#line 1555
                    tmp___43 = strcmp((char const   *)values[1], "strict");
                    }
#line 1555
                    if (tmp___43 == 0) {
#line 1557
                      c_record->arb_length = 0;
                    } else {
                      {
#line 1558
                      tmp___42 = strcmp((char const   *)values[1], "minimum");
                      }
#line 1558
                      if (tmp___42 == 0) {
#line 1560
                        c_record->arb_length = 1;
                      } else {
                        {
#line 1563
                        error_in_line();
#line 1564
                        panic((char *)"Unknown option value in record", (char *)((void *)0),
                              (char *)((void *)0));
                        }
                      }
                    }
                  } else {
                    {
#line 1568
                    error_in_line();
#line 1569
                    panic((char *)"Unknown option in record", (char *)((void *)0),
                          (char *)((void *)0));
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 1571
    goto switch_break___0;
    case_4: /* CIL Label */ 
    {
#line 1573
    tmp___92 = strcmp((char const   *)values[0], "file-header");
    }
#line 1573
    if (tmp___92 == 0) {
      {
#line 1575
      tmp___52 = xstrdup(values[1]);
#line 1575
      c_output->file_header = (uint8_t *)tmp___52;
      }
    } else {
      {
#line 1576
      tmp___91 = strcmp((char const   *)values[0], "file-trailer");
      }
#line 1576
      if (tmp___91 == 0) {
        {
#line 1578
        tmp___53 = xstrdup(values[1]);
#line 1578
        c_output->file_trailer = (uint8_t *)tmp___53;
        }
      } else {
        {
#line 1579
        tmp___90 = strcmp((char const   *)values[0], "header");
        }
#line 1579
        if (tmp___90 == 0) {
          {
#line 1581
          tmp___54 = xstrdup(values[1]);
#line 1581
          c_output->header = (uint8_t *)tmp___54;
          }
        } else {
          {
#line 1582
          tmp___89 = strcmp((char const   *)values[0], "data");
          }
#line 1582
          if (tmp___89 == 0) {
            {
#line 1584
            tmp___55 = xstrdup(values[1]);
#line 1584
            c_output->data = (uint8_t *)tmp___55;
            }
          } else {
            {
#line 1585
            tmp___88 = strcmp((char const   *)values[0], "lookup");
            }
#line 1585
            if (tmp___88 == 0) {
              {
#line 1587
              tmp___56 = xstrdup(values[1]);
#line 1587
              c_output->lookup = (uint8_t *)tmp___56;
              }
            } else {
              {
#line 1588
              tmp___87 = strcmp((char const   *)values[0], "separator");
              }
#line 1588
              if (tmp___87 == 0) {
                {
#line 1590
                tmp___57 = xstrdup(values[1]);
#line 1590
                c_output->separator = (uint8_t *)tmp___57;
                }
              } else {
                {
#line 1591
                tmp___86 = strcmp((char const   *)values[0], "record-header");
                }
#line 1591
                if (tmp___86 == 0) {
                  {
#line 1593
                  tmp___58 = xstrdup(values[1]);
#line 1593
                  c_output->record_header = (uint8_t *)tmp___58;
                  }
                } else {
                  {
#line 1594
                  tmp___85 = strcmp((char const   *)values[0], "record-trailer");
                  }
#line 1594
                  if (tmp___85 == 0) {
#line 1596
                    if (*(values[1] + 0)) {
                      {
#line 1598
                      tmp___59 = xstrdup(values[1]);
#line 1598
                      c_output->record_trailer = (uint8_t *)tmp___59;
                      }
                    } else {
#line 1601
                      c_output->record_trailer = (uint8_t *)((void *)0);
                    }
                  } else {
                    {
#line 1603
                    tmp___84 = strcmp((char const   *)values[0], "group-header");
                    }
#line 1603
                    if (tmp___84 == 0) {
                      {
#line 1605
                      tmp___60 = xstrdup(values[1]);
#line 1605
                      c_output->group_header = (uint8_t *)tmp___60;
                      }
                    } else {
                      {
#line 1606
                      tmp___83 = strcmp((char const   *)values[0], "group-trailer");
                      }
#line 1606
                      if (tmp___83 == 0) {
                        {
#line 1608
                        tmp___61 = xstrdup(values[1]);
#line 1608
                        c_output->group_trailer = (uint8_t *)tmp___61;
                        }
                      } else {
                        {
#line 1609
                        tmp___82 = strcmp((char const   *)values[0], "element-header");
                        }
#line 1609
                        if (tmp___82 == 0) {
                          {
#line 1611
                          tmp___62 = xstrdup(values[1]);
#line 1611
                          c_output->element_header = (uint8_t *)tmp___62;
                          }
                        } else {
                          {
#line 1612
                          tmp___81 = strcmp((char const   *)values[0], "element-trailer");
                          }
#line 1612
                          if (tmp___81 == 0) {
                            {
#line 1614
                            tmp___63 = xstrdup(values[1]);
#line 1614
                            c_output->element_trailer = (uint8_t *)tmp___63;
                            }
                          } else {
                            {
#line 1615
                            tmp___80 = strcmp((char const   *)values[0], "justify");
                            }
#line 1615
                            if (tmp___80 == 0) {
#line 1617
                              if (! *(values[1] + 1)) {
#line 1619
                                c_output->justify = (uint8_t )*(values[1] + 0);
                              } else {
                                {
#line 1620
                                tmp___65 = strcmp((char const   *)values[1], "right");
                                }
#line 1620
                                if (tmp___65 == 0) {
#line 1622
                                  c_output->justify = (uint8_t )2;
                                } else {
                                  {
#line 1623
                                  tmp___64 = strcmp((char const   *)values[1], "left");
                                  }
#line 1623
                                  if (tmp___64 == 0) {
#line 1625
                                    c_output->justify = (uint8_t )1;
                                  } else {
                                    {
#line 1628
                                    error_in_line();
#line 1629
                                    panic((char *)"Unknown values in justify", (char *)((void *)0),
                                          (char *)((void *)0));
                                    }
                                  }
                                }
                              }
                            } else {
                              {
#line 1631
                              tmp___79 = strcmp((char const   *)values[0], "no-data-print");
                              }
#line 1631
                              if (tmp___79 == 0) {
                                {
#line 1633
                                tmp___67 = strcmp((char const   *)values[1], "yes");
                                }
#line 1633
                                if (tmp___67 == 0) {
#line 1635
                                  c_output->no_data = 1;
                                } else {
                                  {
#line 1636
                                  tmp___66 = strcmp((char const   *)values[1], "no");
                                  }
#line 1636
                                  if (tmp___66 == 0) {
#line 1638
                                    c_output->no_data = 0;
                                  } else {
                                    {
#line 1641
                                    error_in_line();
#line 1642
                                    panic((char *)"Unknown values in print-no-data",
                                          (char *)((void *)0), (char *)((void *)0));
                                    }
                                  }
                                }
                              } else {
                                {
#line 1644
                                tmp___78 = strcmp((char const   *)values[0], "indent");
                                }
#line 1644
                                if (tmp___78 == 0) {
                                  {
#line 1646
                                  tmp___68 = xstrdup(values[1]);
#line 1646
                                  c_output->indent = (uint8_t *)tmp___68;
                                  }
                                } else {
                                  {
#line 1647
                                  tmp___77 = strcmp((char const   *)values[0], "field-list");
                                  }
#line 1647
                                  if (tmp___77 == 0) {
#line 1649
                                    if ((unsigned long )c_output->fl == (unsigned long )((void *)0)) {
                                      {
#line 1649
                                      c_output->fl = parse_include_list(values[1]);
                                      }
                                    }
                                  } else {
                                    {
#line 1650
                                    tmp___76 = strcmp((char const   *)values[0], "field-empty-print");
                                    }
#line 1650
                                    if (tmp___76 == 0) {
                                      {
#line 1652
                                      tmp___70 = strcmp((char const   *)values[1],
                                                        "yes");
                                      }
#line 1652
                                      if (tmp___70 == 0) {
#line 1654
                                        c_output->print_empty = 1;
                                      } else {
                                        {
#line 1655
                                        tmp___69 = strcmp((char const   *)values[1],
                                                          "no");
                                        }
#line 1655
                                        if (tmp___69 == 0) {
#line 1657
                                          c_output->print_empty = 0;
                                        } else {
                                          {
#line 1660
                                          error_in_line();
#line 1661
                                          panic((char *)"Unknown values in field-empty-print",
                                                (char *)((void *)0), (char *)((void *)0));
                                          }
                                        }
                                      }
                                    } else {
                                      {
#line 1663
                                      tmp___75 = strcmp((char const   *)values[0],
                                                        "empty-chars");
                                      }
#line 1663
                                      if (tmp___75 == 0) {
                                        {
#line 1665
                                        c_output->empty_chars = xstrdup(values[1]);
                                        }
                                      } else {
                                        {
#line 1666
                                        tmp___74 = strcmp((char const   *)values[0],
                                                          "output-file");
                                        }
#line 1666
                                        if (tmp___74 == 0) {
                                          {
#line 1668
                                          c_output->output_file = xstrdup(values[1]);
                                          }
                                        } else {
                                          {
#line 1669
                                          tmp___73 = strcmp((char const   *)values[0],
                                                            "hex-caps");
                                          }
#line 1669
                                          if (tmp___73 == 0) {
                                            {
#line 1671
                                            tmp___72 = strcmp((char const   *)values[1],
                                                              "yes");
                                            }
#line 1671
                                            if (tmp___72 == 0) {
#line 1673
                                              c_output->hex_cap = 1;
                                            } else {
                                              {
#line 1674
                                              tmp___71 = strcmp((char const   *)values[1],
                                                                "no");
                                              }
#line 1674
                                              if (tmp___71 == 0) {
#line 1676
                                                c_output->hex_cap = 0;
                                              } else {
                                                {
#line 1679
                                                error_in_line();
#line 1680
                                                panic((char *)"Unknown values in hex_cap",
                                                      (char *)((void *)0), (char *)((void *)0));
                                                }
                                              }
                                            }
                                          } else {
                                            {
#line 1684
                                            error_in_line();
#line 1685
                                            panic((char *)"Unknown option in output definition",
                                                  (char *)((void *)0), (char *)((void *)0));
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 1687
    goto switch_break___0;
    case_8: /* CIL Label */ 
    {
#line 1689
    tmp___104 = strcmp((char const   *)values[0], "search");
    }
#line 1689
    if (tmp___104 == 0) {
      {
#line 1691
      tmp___94 = strcmp((char const   *)values[1], "exact");
      }
#line 1691
      if (tmp___94 == 0) {
#line 1693
        c_lookup->type = (char)1;
      } else {
        {
#line 1694
        tmp___93 = strcmp((char const   *)values[1], "longest");
        }
#line 1694
        if (tmp___93 == 0) {
#line 1696
          c_lookup->type = (char)2;
        } else {
          {
#line 1699
          error_in_line();
#line 1700
          panic((char *)"Unknown value for lookup tables search option", values[1],
                (char *)((void *)0));
          }
        }
      }
    } else {
      {
#line 1702
      tmp___103 = strcmp((char const   *)values[0], "pair");
      }
#line 1702
      if (tmp___103 == 0) {
#line 1704
        if ((unsigned long )c_lookup->data == (unsigned long )((void *)0)) {
          {
#line 1706
          tmp___95 = xmalloc(sizeof(struct lookup_data ));
#line 1706
          c_lookup->data = (struct lookup_data *)tmp___95;
#line 1707
          c_lookup_data = c_lookup->data;
          }
        } else {
          {
#line 1710
          tmp___96 = xmalloc(sizeof(struct lookup_data ));
#line 1710
          c_lookup_data->next = (struct lookup_data *)tmp___96;
#line 1711
          c_lookup_data = c_lookup_data->next;
          }
        }
        {
#line 1713
        c_lookup_data->next = (struct lookup_data *)((void *)0);
#line 1714
        tmp___97 = xstrdup(values[1]);
#line 1714
        c_lookup_data->key = (uint8_t *)tmp___97;
#line 1715
        tmp___98 = xstrdup(values[2]);
#line 1715
        c_lookup_data->value = (uint8_t *)tmp___98;
#line 1716
        tmp___99 = strlen((char const   *)c_lookup_data->key);
#line 1716
        c_lookup_data->key_len = (int )tmp___99;
        }
#line 1717
        if (c_lookup->max_key_len < c_lookup_data->key_len) {
#line 1717
          c_lookup->max_key_len = c_lookup_data->key_len;
        }
      } else {
        {
#line 1718
        tmp___102 = strcmp((char const   *)values[0], "file");
        }
#line 1718
        if (tmp___102 == 0) {
#line 1720
          if (opt_count == 1) {
            {
#line 1722
            c_lookup_data = read_lookup_from_file(& c_lookup->data, values[1], (char )';',
                                                  & c_lookup->max_key_len);
            }
          } else {
            {
#line 1725
            c_lookup_data = read_lookup_from_file(& c_lookup->data, values[1], *(values[2] + 0),
                                                  & c_lookup->max_key_len);
            }
          }
        } else {
          {
#line 1727
          tmp___101 = strcmp((char const   *)values[0], "default-value");
          }
#line 1727
          if (tmp___101 == 0) {
            {
#line 1729
            tmp___100 = xstrdup(values[1]);
#line 1729
            c_lookup->default_value = (uint8_t *)tmp___100;
            }
          } else {
            {
#line 1732
            error_in_line();
#line 1733
            panic((char *)"Unknown option for lookup", values[0], (char *)((void *)0));
            }
          }
        }
      }
    }
#line 1735
    goto switch_break___0;
    case_9: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    {
#line 1740
    error_in_line();
#line 1741
    panic((char *)"{ expected, found", values[0], (char *)((void *)0));
    }
#line 1742
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1744
    goto switch_break;
    case_2___0: /* CIL Label */ 
    {
#line 1748
    if (status == 5) {
#line 1748
      goto case_5___0;
    }
#line 1751
    if (status == 7) {
#line 1751
      goto case_7___0;
    }
#line 1754
    if (status == 6) {
#line 1754
      goto case_6___0;
    }
#line 1757
    if (status == 9) {
#line 1757
      goto case_9___0;
    }
#line 1760
    goto switch_default;
    case_5___0: /* CIL Label */ 
#line 1749
    status = 2;
#line 1750
    goto switch_break___1;
    case_7___0: /* CIL Label */ 
#line 1752
    status = 4;
#line 1753
    goto switch_break___1;
    case_6___0: /* CIL Label */ 
#line 1755
    status = 3;
#line 1756
    goto switch_break___1;
    case_9___0: /* CIL Label */ 
#line 1758
    status = 8;
#line 1759
    goto switch_break___1;
    switch_default: /* CIL Label */ 
    {
#line 1761
    error_in_line();
#line 1762
    panic((char *)"{ not expected", (char *)((void *)0), (char *)((void *)0));
    }
#line 1763
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 1765
    goto switch_break;
    case_3___0: /* CIL Label */ 
    {
#line 1771
    if (status == 8) {
#line 1771
      goto case_8___0;
    }
#line 1771
    if (status == 4) {
#line 1771
      goto case_8___0;
    }
#line 1771
    if (status == 2) {
#line 1771
      goto case_8___0;
    }
#line 1774
    if (status == 3) {
#line 1774
      goto case_3___1;
    }
#line 1777
    goto switch_default___0;
    case_8___0: /* CIL Label */ 
    case_4___0: /* CIL Label */ 
    case_2___1: /* CIL Label */ 
#line 1772
    status = 1;
#line 1773
    goto switch_break___2;
    case_3___1: /* CIL Label */ 
#line 1775
    status = 2;
#line 1776
    goto switch_break___2;
    switch_default___0: /* CIL Label */ 
    {
#line 1778
    error_in_line();
#line 1779
    panic((char *)"} not expected", (char *)((void *)0), (char *)((void *)0));
    }
    switch_break___2: /* CIL Label */ ;
    }
#line 1781
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1784
  if (status != 1) {
    {
#line 1786
    panic((char *)"End of file reached before closing }", (char *)((void *)0), (char *)((void *)0));
    }
  }
  {
#line 1788
  free((void *)read_buffer___0);
#line 1789
  fclose(fp);
  }
#line 1790
  return;
}
}
#line 577 "/usr/include/regex.h"
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 334 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.h"
void set_input_file(char *name ) ;
#line 337
void open_input_file(int stype ) ;
#line 343
char *guess_structure(void) ;
#line 346
void set_output_file(char *name ) ;
#line 349
void close_output_file(void) ;
#line 352
void execute(struct structure *s , int strict , int expression_and , int expression_invert ,
             int expression_case , int debug ) ;
#line 361
FILE *xfopenb(char *name , char *mode ) ;
#line 364
uint8_t *endian_and_align(uint8_t *s , int t_endian , int s_endian , int bytes ) ;
#line 370
char *guess_binary_structure(void) ;
#line 373
void file_to_text(FILE *fp___0 ) ;
#line 376
__inline void writec(uint8_t c ) ;
#line 379
__inline void writes(uint8_t *string ) ;
#line 382
void start_write(void) ;
#line 385
void flush_write(void) ;
#line 388
void reset_levels(int start , int stop ) ;
#line 391
void print_level_before(struct record *prev_record , struct record *curr_record ) ;
#line 394
void print_level_end(struct record *last ) ;
#line 397
int get_indent_depth(int level_count ) ;
#line 400
void print_indent(uint8_t *buffer , int times ) ;
#line 403
size_t hash(char *str , size_t len ) ;
#line 411
struct expression *expression ;
#line 413
struct output *no_output ;
#line 414
struct output *raw ;
#line 417
int max_binary_record_length ;
#line 418
char *ffe_open ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 373
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcasestr)(char const   *__haystack ,
                                                                                                     char const   *__needle )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static char *program___0  =    (char *)"ffe";
#line 43
struct replace *replace ;
#line 45 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
struct input_file *files  =    (struct input_file *)((void *)0);
#line 46 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static struct input_file *current_file  =    (struct input_file *)((void *)0);
#line 47 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static FILE *input_fp  =    (FILE *)((void *)0);
#line 48 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static int ungetchar  =    -1;
#line 49 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static char *default_output_file  =    (char *)((void *)0);
#line 50 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static FILE *default_output_fp  =    (FILE *)((void *)0);
#line 52 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static char *output_file  =    (char *)((void *)0);
#line 53 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static FILE *output_fp  =    (FILE *)((void *)0);
#line 55 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static uint8_t *guess_buffer[10000]  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static int guess_line_length[10000]  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static uint8_t *read_buffer  =    (uint8_t *)((void *)0);
#line 58 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static size_t read_buffer_size  =    (size_t )524288;
#line 59 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static size_t last_consumed  =    (size_t )0;
#line 60 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static uint8_t *field_buffer  =    (uint8_t *)((void *)0);
#line 61 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static int field_buffer_size  =    131072;
#line 62 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static int guess_lines  =    0;
#line 63 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static int read_guess_line  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static int binary_guessed  =    0;
#line 66 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static uint8_t justify_string[128]  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static uint8_t *write_buffer  =    (uint8_t *)((void *)0);
#line 70 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static int write_buffer_size  =    2097152;
#line 71 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static uint8_t *write_pos  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static uint8_t *write_buffer_end  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static long current_file_lineno  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static long current_total_lineno  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static long long current_offset  =    0LL;
#line 78 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static long long current_file_offset  =    0LL;
#line 82 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static int no_matching_lines  =    0;
#line 85 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static int headers  ;
#line 87 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
char *current_file_name  =    (char *)((void *)0);
#line 89 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static char debug_file[128]  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static FILE *debug_fp  =    (FILE *)((void *)0);
#line 91 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static long debug_lineno  =    0L;
#line 93 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static uint8_t bcd_to_ascii_cap[16]  = 
#line 93
  {      (uint8_t )'0',      (uint8_t )'1',      (uint8_t )'2',      (uint8_t )'3', 
        (uint8_t )'4',      (uint8_t )'5',      (uint8_t )'6',      (uint8_t )'7', 
        (uint8_t )'8',      (uint8_t )'9',      (uint8_t )'A',      (uint8_t )'B', 
        (uint8_t )'C',      (uint8_t )'D',      (uint8_t )'E',      (uint8_t )'\000'};
#line 94 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static uint8_t hex_to_ascii_cap[16]  = 
#line 94
  {      (uint8_t )'0',      (uint8_t )'1',      (uint8_t )'2',      (uint8_t )'3', 
        (uint8_t )'4',      (uint8_t )'5',      (uint8_t )'6',      (uint8_t )'7', 
        (uint8_t )'8',      (uint8_t )'9',      (uint8_t )'A',      (uint8_t )'B', 
        (uint8_t )'C',      (uint8_t )'D',      (uint8_t )'E',      (uint8_t )'F'};
#line 96 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static uint8_t bcd_to_ascii_low[16]  = 
#line 96
  {      (uint8_t )'0',      (uint8_t )'1',      (uint8_t )'2',      (uint8_t )'3', 
        (uint8_t )'4',      (uint8_t )'5',      (uint8_t )'6',      (uint8_t )'7', 
        (uint8_t )'8',      (uint8_t )'9',      (uint8_t )'a',      (uint8_t )'b', 
        (uint8_t )'c',      (uint8_t )'d',      (uint8_t )'e',      (uint8_t )'\000'};
#line 97 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static uint8_t hex_to_ascii_low[16]  = 
#line 97
  {      (uint8_t )'0',      (uint8_t )'1',      (uint8_t )'2',      (uint8_t )'3', 
        (uint8_t )'4',      (uint8_t )'5',      (uint8_t )'6',      (uint8_t )'7', 
        (uint8_t )'8',      (uint8_t )'9',      (uint8_t )'a',      (uint8_t )'b', 
        (uint8_t )'c',      (uint8_t )'d',      (uint8_t )'e',      (uint8_t )'f'};
#line 99 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static uint8_t *bcd_to_ascii  ;
#line 100 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static uint8_t *hex_to_ascii  ;
#line 102 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
__inline uint8_t htocl(uint8_t hex ) 
{ 


  {
#line 105
  return (*(hex_to_ascii + ((int )hex & 15)));
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
__inline uint8_t htocb(uint8_t hex ) 
{ 


  {
#line 111
  return (*(hex_to_ascii + (((int )hex >> 4) & 15)));
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
__inline uint8_t bcdtocl(uint8_t bcd ) 
{ 


  {
#line 117
  return (*(bcd_to_ascii + ((int )bcd & 15)));
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
__inline uint8_t bcdtocb(uint8_t bcd ) 
{ 


  {
#line 123
  return (*(bcd_to_ascii + (((int )bcd >> 4) & 15)));
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
void set_output_file(char *name ) 
{ 


  {
#line 130
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 132
    default_output_fp = stdout;
#line 133
    default_output_file = (char *)"(stdout)";
  } else {
    {
#line 136
    default_output_fp = xfopen(name, (char *)"w");
#line 137
    default_output_file = name;
    }
  }
#line 139
  output_fp = default_output_fp;
#line 140
  output_file = default_output_file;
#line 141
  return;
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
void close_output_file(void) 
{ 
  struct output *o ;
  int stdoutclosed ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 146
  o = output;
#line 147
  stdoutclosed = 0;
#line 149
  if ((unsigned long )default_output_fp == (unsigned long )stdout) {
#line 149
    stdoutclosed = 1;
  }
  {
#line 150
  tmp___1 = fclose(default_output_fp);
  }
#line 150
  if (tmp___1 != 0) {
    {
#line 152
    tmp = __errno_location();
#line 152
    tmp___0 = strerror(*tmp);
#line 152
    panic((char *)"Error closing file", default_output_file, tmp___0);
    }
  }
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! ((unsigned long )o != (unsigned long )((void *)0))) {
#line 155
      goto while_break;
    }
#line 157
    if ((unsigned long )o->ofp != (unsigned long )((void *)0)) {
#line 159
      if ((unsigned long )o->ofp == (unsigned long )stdout) {
#line 159
        if (! stdoutclosed) {
#line 159
          goto _L;
        } else {
#line 159
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 159
      if ((unsigned long )o->ofp != (unsigned long )stdout) {
        _L: /* CIL Label */ 
#line 161
        if ((unsigned long )o->ofp == (unsigned long )stdout) {
#line 161
          stdoutclosed = 1;
        }
        {
#line 162
        tmp___4 = fclose(o->ofp);
        }
#line 162
        if (tmp___4 != 0) {
          {
#line 164
          tmp___2 = __errno_location();
#line 164
          tmp___3 = strerror(*tmp___2);
#line 164
          panic((char *)"Error closing file", o->output_file, tmp___3);
          }
        }
      }
    }
#line 168
    o = o->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  return;
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
void set_input_file(char *name ) 
{ 
  register struct input_file *f ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 175
  f = files;
#line 177
  if ((unsigned long )files == (unsigned long )((void *)0)) {
    {
#line 179
    tmp = xmalloc(sizeof(struct input_file ));
#line 179
    files = (struct input_file *)tmp;
#line 180
    f = files;
    }
  } else {
    {
#line 183
    while (1) {
      while_continue: /* CIL Label */ ;
#line 183
      if (! ((unsigned long )f->next != (unsigned long )((void *)0))) {
#line 183
        goto while_break;
      }
#line 183
      f = f->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 184
    tmp___0 = xmalloc(sizeof(struct input_file ));
#line 184
    f->next = (struct input_file *)tmp___0;
#line 185
    f = f->next;
    }
  }
  {
#line 188
  f->next = (struct input_file *)((void *)0);
#line 189
  f->name = xstrdup(name);
#line 190
  f->lineno = 0L;
  }
#line 191
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static FILE *open_input_stream(char *file , char type ) 
{ 
  int fds[2] ;
  pid_t pid ;
  FILE *ret ;
  char command___0[1024] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;

  {
#line 198
  ret = (FILE *)((void *)0);
#line 201
  if ((unsigned long )ffe_open != (unsigned long )((void *)0)) {
#line 201
    if ((int )*(ffe_open + 0) != 0) {
      {
#line 204
      sprintf((char */* __restrict  */)(command___0), (char const   */* __restrict  */)ffe_open,
              file);
#line 205
      tmp___1 = pipe((int *)(fds));
      }
#line 205
      if (tmp___1 != 0) {
        {
#line 205
        tmp = __errno_location();
#line 205
        tmp___0 = strerror(*tmp);
#line 205
        panic((char *)"Cannot create pipe", tmp___0, (char *)((void *)0));
        }
      }
      {
#line 206
      pid = fork();
      }
#line 207
      if (pid == 0) {
        {
#line 209
        close(fds[0]);
#line 210
        tmp___4 = dup2(fds[1], 1);
        }
#line 210
        if (tmp___4 == -1) {
          {
#line 210
          tmp___2 = __errno_location();
#line 210
          tmp___3 = strerror(*tmp___2);
#line 210
          panic((char *)"dup2 error", tmp___3, (char *)((void *)0));
          }
        }
        {
#line 211
        tmp___7 = execl("/bin/sh", "sh", "-c", command___0, (void *)0);
        }
#line 211
        if (tmp___7 == -1) {
          {
#line 211
          tmp___5 = __errno_location();
#line 211
          tmp___6 = strerror(*tmp___5);
#line 211
          panic((char *)"Starting a shell with execl failed", command___0, tmp___6);
          }
        }
        {
#line 212
        close(fds[1]);
#line 213
        _exit(0);
        }
      } else
#line 214
      if (pid > 0) {
        {
#line 216
        close(fds[1]);
#line 217
        ret = fdopen(fds[0], "r");
        }
#line 218
        if ((unsigned long )ret == (unsigned long )((void *)0)) {
          {
#line 218
          tmp___8 = __errno_location();
#line 218
          tmp___9 = strerror(*tmp___8);
#line 218
          panic((char *)"Cannot read from command", command___0, tmp___9);
          }
        }
        {
#line 220
        ungetchar = fgetc(ret);
        }
#line 222
        if (ungetchar == -1) {
          {
#line 224
          ungetchar = -1;
#line 225
          fclose(ret);
#line 226
          ret = (FILE *)((void *)0);
          }
        }
      } else {
        {
#line 230
        tmp___10 = __errno_location();
#line 230
        tmp___11 = strerror(*tmp___10);
#line 230
        panic((char *)"Cannot fork", tmp___11, (char *)((void *)0));
        }
      }
    }
  }
#line 237
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 239
    if ((int )type == 98) {
      {
#line 241
      ret = xfopenb(file, (char *)"r");
      }
    } else {
      {
#line 244
      ret = xfopen(file, (char *)"r");
      }
    }
  }
#line 247
  return (ret);
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
void open_input_file(int stype ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 254
  tmp = xmalloc(read_buffer_size);
#line 254
  read_buffer = (uint8_t *)tmp;
#line 255
  tmp___0 = xmalloc((size_t )field_buffer_size);
#line 255
  field_buffer = (uint8_t *)tmp___0;
  }
#line 257
  if ((int )*(files->name + 0) == 45) {
#line 257
    if (! *(files->name + 1)) {
#line 259
      input_fp = stdin;
#line 260
      files->name = (char *)"(stdin)";
    } else {
      {
#line 263
      input_fp = open_input_stream(files->name, (char )stype);
      }
    }
  } else {
    {
#line 263
    input_fp = open_input_stream(files->name, (char )stype);
    }
  }
#line 265
  current_file = files;
#line 266
  current_file->lineno = 0L;
#line 267
  current_file_name = current_file->name;
#line 268
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
void complete_line_in_bin_buffer(int *ccount___0 ) 
{ 
  int c ;
  int tmp ;

  {
#line 277
  if ((int )*(read_buffer + (*ccount___0 - 1)) != 10) {
    {
#line 279
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 281
      c = fgetc(input_fp);
      }
#line 282
      if ((size_t )*ccount___0 >= read_buffer_size) {
        {
#line 282
        panic((char *)"Input file cannot be guessed, use -s option", (char *)((void *)0),
              (char *)((void *)0));
        }
      }
#line 283
      if (c != -1) {
#line 283
        tmp = *ccount___0;
#line 283
        (*ccount___0) ++;
#line 283
        *(read_buffer + tmp) = (uint8_t )c;
      }
#line 279
      if (c != -1) {
#line 279
        if (! (c != 10)) {
#line 279
          goto while_break;
        }
      } else {
#line 279
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 286
  return;
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static size_t uc_fread(uint8_t *ptr , size_t size , size_t nmemb , FILE *stream ) 
{ 
  size_t ret ;
  size_t tmp ;

  {
#line 296
  ret = (size_t )0;
#line 298
  if (ungetchar != -1) {
#line 300
    *ptr = (uint8_t )ungetchar;
#line 301
    ungetchar = -1;
#line 302
    ptr ++;
#line 303
    nmemb --;
#line 304
    ret = (size_t )1;
  }
  {
#line 307
  tmp = fread((void */* __restrict  */)ptr, size, nmemb, (FILE */* __restrict  */)stream);
#line 307
  ret += tmp;
  }
#line 308
  return (ret);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static int uc_fgets(uint8_t *s , int size , FILE *stream ) 
{ 
  int ret ;
  char *orig_s ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 318
  orig_s = (char *)s;
#line 320
  if (ungetchar != -1) {
#line 322
    *s = (uint8_t )ungetchar;
#line 323
    ungetchar = -1;
#line 324
    if ((int )*s == 10) {
#line 326
      s ++;
#line 327
      *s = (uint8_t )'\000';
#line 328
      return (1);
    }
#line 330
    s ++;
#line 331
    size --;
  }
  {
#line 334
  tmp___0 = fgets((char */* __restrict  */)s, size, (FILE */* __restrict  */)stream);
  }
#line 334
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    {
#line 336
    tmp = strlen((char const   *)orig_s);
#line 336
    ret = (int )tmp;
    }
  } else {
#line 339
    ret = -1;
  }
#line 342
  return (ret);
}
}
#line 354
int read_input_line(int stype ) ;
#line 354 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static int eof  =    0;
#line 355 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static int ccount  =    0;
#line 356 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static uint8_t *bbuffer  =    (uint8_t *)((void *)0);
#line 351 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
int read_input_line(int stype ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  int len ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    if (stype == 98) {
#line 362
      if (last_consumed) {
        {
#line 364
        current_offset += (long long )last_consumed;
#line 365
        current_file_offset += (long long )last_consumed;
#line 366
        memmove((void *)read_buffer, (void const   *)(read_buffer + last_consumed),
                read_buffer_size - last_consumed);
        }
#line 367
        if (! eof) {
          {
#line 369
          tmp = uc_fread(read_buffer + (read_buffer_size - last_consumed), (size_t )1,
                         last_consumed, input_fp);
#line 369
          ccount = (int )tmp;
          }
#line 370
          if ((size_t )ccount < last_consumed) {
#line 370
            eof = 1;
          }
#line 371
          ccount = (int )((size_t )ccount + (read_buffer_size - last_consumed));
        } else {
#line 374
          ccount = (int )((size_t )ccount - last_consumed);
        }
      } else {
#line 378
        if (binary_guessed) {
#line 380
          binary_guessed = 0;
#line 381
          current_file_lineno = current_file->lineno;
#line 382
          return (ccount);
        }
        {
#line 384
        tmp___0 = uc_fread(read_buffer, (size_t )1, read_buffer_size, input_fp);
#line 384
        ccount = (int )tmp___0;
        }
#line 385
        if ((size_t )ccount < read_buffer_size) {
#line 385
          eof = 1;
        }
      }
#line 388
      if (ccount <= 0) {
#line 390
        ccount = -1;
      }
    } else {
#line 394
      if (binary_guessed) {
#line 394
        goto _L;
      } else
#line 394
      if ((unsigned long )bbuffer != (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 398
        binary_guessed = 0;
#line 400
        if ((unsigned long )bbuffer == (unsigned long )((void *)0)) {
          {
#line 402
          complete_line_in_bin_buffer(& ccount);
          }
        } else {
          {
#line 405
          memmove((void *)read_buffer, (void const   *)bbuffer, (size_t )ccount);
#line 406
          (current_file->lineno) ++;
          }
        }
#line 409
        bbuffer = read_buffer;
        {
#line 411
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 411
          if (*bbuffer) {
#line 411
            if ((int )*bbuffer != 10) {
#line 411
              if (! ((int )(bbuffer - read_buffer) < ccount)) {
#line 411
                goto while_break___0;
              }
            } else {
#line 411
              goto while_break___0;
            }
          } else {
#line 411
            goto while_break___0;
          }
#line 411
          bbuffer ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 421
        *bbuffer = (uint8_t )0;
#line 422
        len = (int )(bbuffer - read_buffer);
#line 425
        if ((int )(bbuffer - read_buffer) < ccount) {
#line 425
          bbuffer ++;
        }
#line 427
        ccount -= (int )(bbuffer - read_buffer);
#line 429
        current_file_lineno = current_file->lineno;
#line 431
        if (! ccount) {
#line 431
          bbuffer = (uint8_t *)((void *)0);
        }
#line 433
        return (len);
      }
      {
#line 436
      ccount = uc_fgets(read_buffer, (int )read_buffer_size, input_fp);
      }
    }
#line 442
    if (ccount == -1) {
      {
#line 444
      tmp___3 = fclose(input_fp);
      }
#line 444
      if (tmp___3) {
        {
#line 446
        tmp___1 = __errno_location();
#line 446
        tmp___2 = strerror(*tmp___1);
#line 446
        panic((char *)"Error closing file", files->name, tmp___2);
        }
      }
#line 448
      current_file = current_file->next;
#line 449
      if ((unsigned long )current_file != (unsigned long )((void *)0)) {
#line 451
        if ((int )*(current_file->name + 0) == 45) {
#line 451
          if (! *(current_file->name + 1)) {
#line 453
            input_fp = stdin;
#line 454
            current_file->name = (char *)"(stdin)";
          } else {
#line 451
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 457
          input_fp = open_input_stream(current_file->name, (char )stype);
          }
#line 458
          if (stype == 98) {
#line 460
            last_consumed = (size_t )0;
#line 461
            current_file_offset = 0LL;
          }
#line 463
          eof = 0;
        }
#line 465
        current_file_name = current_file->name;
#line 466
        current_file->lineno = 0L;
#line 467
        current_file_offset = 0LL;
      }
    } else {
#line 471
      (current_file->lineno) ++;
    }
#line 358
    if (ccount == -1) {
#line 358
      if (! ((unsigned long )current_file != (unsigned long )((void *)0))) {
#line 358
        goto while_break;
      }
    } else {
#line 358
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 474
  if (ccount > 0) {
#line 476
    current_file_lineno = current_file->lineno;
#line 477
    if (stype != 98) {
#line 479
      if ((int )*(read_buffer + (ccount - 1)) == 10) {
#line 481
        ccount --;
#line 482
        *(read_buffer + ccount) = (uint8_t )0;
      }
    }
  }
#line 493
  return (ccount);
}
}
#line 497 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
int get_field_count(uint8_t quote , uint8_t *type , uint8_t *line ) 
{ 
  int inside_quote ;
  int fields ;
  register uint8_t *p ;

  {
#line 500
  inside_quote = 0;
#line 501
  fields = 0;
#line 502
  p = line;
#line 504
  if ((int )*(type + 0) != 115) {
#line 504
    return (0);
  }
#line 506
  if (*p) {
#line 506
    fields ++;
  }
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 508
    if (! *p) {
#line 508
      goto while_break;
    }
#line 510
    if ((int )*p == (int )*(type + 1)) {
#line 510
      if (! inside_quote) {
#line 512
        fields ++;
#line 513
        if ((int )*(type + 2) == 42) {
          {
#line 513
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 513
            if (! ((int )*p == (int )*(type + 1))) {
#line 513
              goto while_break___0;
            }
#line 513
            p ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
#line 516
    if ((int )*p == (int )quote) {
#line 516
      if ((int )*(p + 1) == (int )quote) {
#line 516
        goto _L___1;
      } else {
#line 516
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 516
    if ((int )*p == 92) {
#line 516
      if ((int )*(p + 1) == (int )quote) {
        _L___1: /* CIL Label */ 
#line 516
        if (inside_quote) {
#line 516
          if (quote) {
#line 518
            p ++;
          } else {
#line 516
            goto _L___2;
          }
        } else {
#line 516
          goto _L___2;
        }
      } else {
#line 516
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 519
    if ((int )*p == (int )quote) {
#line 519
      if (quote) {
#line 521
        inside_quote = ! inside_quote;
      }
    }
#line 523
    if (*p) {
#line 523
      p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 525
  return (fields);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
uint8_t *get_fixed_field(int position , int length , int line_length , uint8_t *line ) 
{ 
  register uint8_t *t ;
  register uint8_t *s ;
  void *tmp ;

  {
#line 535
  if (length >= field_buffer_size - 1) {
    {
#line 537
    field_buffer_size = length * 2;
#line 538
    tmp = xrealloc((void *)field_buffer, (size_t )field_buffer_size);
#line 538
    field_buffer = (uint8_t *)tmp;
    }
  }
#line 541
  if (position <= line_length) {
#line 541
    if (position) {
      {
#line 543
      position --;
#line 544
      s = line + position;
#line 545
      t = field_buffer;
#line 546
      memcpy((void */* __restrict  */)t, (void const   */* __restrict  */)s, (size_t )length);
#line 547
      *(t + length) = (uint8_t )0;
      }
    } else {
#line 550
      *(field_buffer + 0) = (uint8_t )0;
    }
  } else {
#line 550
    *(field_buffer + 0) = (uint8_t )0;
  }
#line 552
  return (field_buffer);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
uint8_t *get_separated_field(int position , uint8_t quote , char *type , uint8_t *line ) 
{ 
  register uint8_t *p ;
  int fieldno ;
  int inside_quote ;
  register int i ;
  void *tmp ;

  {
#line 559
  p = line;
#line 560
  fieldno = 1;
#line 561
  inside_quote = 0;
#line 562
  i = 0;
  {
#line 564
  while (1) {
    while_continue: /* CIL Label */ ;
#line 564
    if (*p) {
#line 564
      if (! (fieldno <= position)) {
#line 564
        goto while_break;
      }
    } else {
#line 564
      goto while_break;
    }
#line 566
    if ((int )*p == (int )*(type + 1)) {
#line 566
      if (! inside_quote) {
#line 568
        fieldno ++;
#line 569
        if ((int )*(type + 2) == 42) {
          {
#line 569
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 569
            if (! ((int )*p == (int )*(type + 1))) {
#line 569
              goto while_break___0;
            }
#line 569
            p ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
#line 572
    if ((int )*p == (int )quote) {
#line 572
      if ((int )*(p + 1) == (int )quote) {
#line 572
        goto _L___1;
      } else {
#line 572
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 572
    if ((int )*p == 92) {
#line 572
      if ((int )*(p + 1) == (int )quote) {
        _L___1: /* CIL Label */ 
#line 572
        if (inside_quote) {
#line 572
          if (quote) {
#line 574
            p ++;
          } else {
#line 572
            goto _L___2;
          }
        } else {
#line 572
          goto _L___2;
        }
      } else {
#line 572
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 575
    if ((int )*p == (int )quote) {
#line 575
      if (quote) {
#line 577
        inside_quote = ! inside_quote;
#line 578
        if (inside_quote) {
#line 578
          if (*(p + 1)) {
#line 578
            p ++;
          }
        }
      }
    }
#line 581
    if (fieldno == position) {
#line 583
      if ((int )*p == (int )*(type + 1)) {
#line 583
        goto _L___4;
      } else
#line 583
      if ((int )*p == (int )quote) {
#line 583
        if (quote) {
          _L___4: /* CIL Label */ 
#line 585
          if (inside_quote) {
#line 587
            *(field_buffer + i) = *p;
#line 588
            i ++;
          }
        } else {
#line 592
          *(field_buffer + i) = *p;
#line 593
          i ++;
        }
      } else {
#line 592
        *(field_buffer + i) = *p;
#line 593
        i ++;
      }
#line 596
      if (i >= field_buffer_size - 1) {
        {
#line 598
        field_buffer_size = i * 2;
#line 599
        tmp = xrealloc((void *)field_buffer, (size_t )field_buffer_size);
#line 599
        field_buffer = (uint8_t *)tmp;
        }
      }
    }
#line 602
    if (*p) {
#line 602
      p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 604
  *(field_buffer + i) = (uint8_t )0;
#line 605
  return (field_buffer);
}
}
#line 612 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
int vote_record(uint8_t quote , char *type , int header , struct record *record ,
                int length , uint8_t *buffer ) 
{ 
  register struct id *i ;
  int vote___0 ;
  int len ;
  int ids ;
  int tmp ;
  size_t tmp___0 ;
  uint8_t *tmp___1 ;
  int tmp___2 ;
  uint8_t *tmp___3 ;
  int tmp___4 ;
  uint8_t *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  uint8_t *tmp___8 ;
  int tmp___9 ;

  {
#line 615
  i = record->i;
#line 616
  vote___0 = 0;
#line 617
  ids = 0;
  {
#line 619
  while (1) {
    while_continue: /* CIL Label */ ;
#line 619
    if (! ((unsigned long )i != (unsigned long )((void *)0))) {
#line 619
      goto while_break;
    }
#line 621
    ids ++;
    {
#line 624
    if ((int )*(type + 0) == 102) {
#line 624
      goto case_102;
    }
#line 635
    if ((int )*(type + 0) == 115) {
#line 635
      goto case_115;
    }
#line 652
    if ((int )*(type + 0) == 98) {
#line 652
      goto case_98;
    }
#line 622
    goto switch_break;
    case_102: /* CIL Label */ 
#line 626
    if (i->regexp) {
      {
#line 628
      tmp = regexec((regex_t const   */* __restrict  */)(& i->reg), (char const   */* __restrict  */)(buffer + (i->position - 1)),
                    (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
      }
#line 628
      if (tmp == 0) {
#line 628
        vote___0 ++;
      }
    } else {
      {
#line 632
      tmp___0 = strlen((char const   *)i->key);
#line 632
      tmp___1 = get_fixed_field(i->position, (int )tmp___0, length, buffer);
#line 632
      tmp___2 = strcmp((char const   *)i->key, (char const   *)tmp___1);
      }
#line 632
      if (tmp___2 == 0) {
#line 632
        vote___0 ++;
      }
    }
#line 634
    goto switch_break;
    case_115: /* CIL Label */ 
#line 636
    if (header) {
#line 636
      if (current_file_lineno == 1L) {
#line 638
        vote___0 ++;
      } else {
#line 636
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 642
    if (i->regexp) {
      {
#line 644
      tmp___3 = get_separated_field(i->position, quote, type, buffer);
#line 644
      tmp___4 = regexec((regex_t const   */* __restrict  */)(& i->reg), (char const   */* __restrict  */)tmp___3,
                        (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
      }
#line 644
      if (tmp___4 == 0) {
#line 644
        vote___0 ++;
      }
    } else {
      {
#line 648
      tmp___5 = get_separated_field(i->position, quote, type, buffer);
#line 648
      tmp___6 = strcmp((char const   *)i->key, (char const   *)tmp___5);
      }
#line 648
      if (tmp___6 == 0) {
#line 648
        vote___0 ++;
      }
    }
#line 651
    goto switch_break;
    case_98: /* CIL Label */ 
#line 654
    if (i->regexp) {
      {
#line 656
      tmp___7 = regexec((regex_t const   */* __restrict  */)(& i->reg), (char const   */* __restrict  */)(buffer + (i->position - 1)),
                        (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
      }
#line 656
      if (tmp___7 == 0) {
#line 656
        vote___0 ++;
      }
    } else {
      {
#line 660
      tmp___8 = get_fixed_field(i->position, i->length, length, buffer);
#line 660
      tmp___9 = memcmp((void const   *)i->key, (void const   *)tmp___8, (size_t )i->length);
      }
#line 660
      if (tmp___9 == 0) {
#line 660
        vote___0 ++;
      }
    }
#line 662
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 664
    i = i->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 666
  if (vote___0) {
#line 666
    goto _L___4;
  } else
#line 666
  if ((unsigned long )record->i == (unsigned long )((void *)0)) {
    _L___4: /* CIL Label */ 
    {
#line 670
    if ((int )*(type + 0) == 102) {
#line 670
      goto case_102___0;
    }
#line 674
    if ((int )*(type + 0) == 115) {
#line 674
      goto case_115___0;
    }
#line 679
    if ((int )*(type + 0) == 98) {
#line 679
      goto case_98___0;
    }
#line 668
    goto switch_break___0;
    case_102___0: /* CIL Label */ 
#line 671
    if (record->arb_length == 1) {
#line 671
      if (record->length <= length) {
#line 672
        vote___0 ++;
      } else {
#line 671
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 671
    if (record->arb_length == 0) {
#line 671
      if (record->length == length) {
#line 672
        vote___0 ++;
      }
    }
#line 673
    goto switch_break___0;
    case_115___0: /* CIL Label */ 
    {
#line 675
    len = get_field_count(quote, (uint8_t *)type, buffer);
    }
#line 676
    if (record->arb_length == 0) {
#line 676
      if (record->length == len) {
#line 677
        vote___0 ++;
      } else {
#line 676
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 676
    if (record->arb_length == 1) {
#line 676
      if (record->length <= len) {
#line 677
        vote___0 ++;
      }
    }
#line 678
    goto switch_break___0;
    case_98___0: /* CIL Label */ 
#line 680
    if (vote___0 == ids) {
#line 680
      if (ids) {
#line 680
        goto _L___2;
      } else {
#line 680
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 680
    if (! ids) {
      _L___2: /* CIL Label */ 
#line 680
      if (record->length <= length) {
#line 680
        vote___0 ++;
      }
    }
#line 681
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 685
  if (vote___0 == ids + 1) {
#line 687
    return (1);
  } else {
#line 690
    return (0);
  }
}
}
#line 696 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
void vote(int bindex ) 
{ 
  struct structure *s ;
  struct record *r ;
  int votes ;
  int total_votes ;

  {
#line 699
  s = structure;
#line 701
  total_votes = 0;
  {
#line 703
  while (1) {
    while_continue: /* CIL Label */ ;
#line 703
    if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 703
      goto while_break;
    }
#line 705
    r = s->r;
#line 706
    votes = 0;
#line 707
    if (s->vote == bindex) {
#line 707
      if ((int )s->type[0] != 98) {
        {
#line 709
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 709
          if ((unsigned long )r != (unsigned long )((void *)0)) {
#line 709
            if (! (! votes)) {
#line 709
              goto while_break___0;
            }
          } else {
#line 709
            goto while_break___0;
          }
          {
#line 711
          votes = vote_record((uint8_t )s->quote, s->type, s->header, r, guess_line_length[bindex],
                              guess_buffer[bindex]);
#line 712
          s->vote += votes;
#line 713
          r = r->next;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 716
    total_votes += votes;
#line 717
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 719
  if (! total_votes) {
#line 719
    if (no_matching_lines < 1) {
      {
#line 721
      no_matching_lines ++;
#line 722
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Line %ld in \'%s\' does not match, line length = %d\n",
              program___0, current_file->lineno, current_file->name, guess_line_length[bindex]);
      }
    }
  }
#line 724
  return;
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
void vote_binary(int buffer_size ) 
{ 
  struct structure *s ;
  struct record *r ;
  int tmp ;

  {
#line 729
  s = structure;
  {
#line 732
  while (1) {
    while_continue: /* CIL Label */ ;
#line 732
    if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 732
      goto while_break;
    }
#line 734
    r = s->r;
#line 735
    if ((int )s->type[0] == 98) {
      {
#line 737
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 737
        if ((unsigned long )r != (unsigned long )((void *)0)) {
#line 737
          if (! (! s->vote)) {
#line 737
            goto while_break___0;
          }
        } else {
#line 737
          goto while_break___0;
        }
#line 739
        if ((unsigned long )r->i != (unsigned long )((void *)0)) {
          {
#line 741
          tmp = vote_record((uint8_t )s->quote, s->type, s->header, r, buffer_size,
                            read_buffer);
          }
#line 741
          if (tmp) {
#line 741
            s->vote = 1;
          }
        }
#line 743
        r = r->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 746
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 748
  return;
}
}
#line 754 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
char *check_votes(int votes ) 
{ 
  struct structure *s ;
  char *winner ;
  int errors ;

  {
#line 757
  s = structure;
#line 758
  winner = (char *)((void *)0);
#line 759
  errors = 0;
  {
#line 761
  while (1) {
    while_continue: /* CIL Label */ ;
#line 761
    if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 761
      if (! votes) {
#line 761
        goto while_break;
      }
    } else {
#line 761
      goto while_break;
    }
#line 763
    if (s->vote == votes) {
#line 765
      if ((unsigned long )winner == (unsigned long )((void *)0)) {
#line 767
        winner = s->name;
      } else {
#line 770
        if (! errors) {
          {
#line 772
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Input data matches several structures: \'%s\'",
                  program___0, winner);
          }
        }
        {
#line 774
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" \'%s\'",
                s->name);
#line 775
        errors ++;
        }
      }
    }
#line 778
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 780
  if (errors) {
    {
#line 782
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 783
    winner = (char *)((void *)0);
    }
  }
#line 785
  return (winner);
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
char *guess_binary_structure(void) 
{ 
  int buffer_size ;
  char *ret ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 795
  ret = (char *)((void *)0);
#line 797
  if (! max_binary_record_length) {
    {
#line 799
    file_to_text(input_fp);
    }
#line 800
    return ((char *)((void *)0));
  }
  {
#line 803
  read_buffer_size = (size_t )max_binary_record_length;
#line 804
  tmp = xrealloc((void *)read_buffer, read_buffer_size);
#line 804
  read_buffer = (uint8_t *)tmp;
#line 806
  buffer_size = read_input_line('b');
  }
#line 808
  if (buffer_size > 0) {
    {
#line 810
    vote_binary(buffer_size);
#line 811
    ret = check_votes(1);
    }
  }
#line 814
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 816
    file_to_text(input_fp);
#line 817
    read_buffer_size = (size_t )524288;
#line 818
    tmp___0 = xrealloc((void *)read_buffer, read_buffer_size);
#line 818
    read_buffer = (uint8_t *)tmp___0;
    }
  }
#line 821
  binary_guessed = 1;
#line 823
  return (ret);
}
}
#line 831 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
char *guess_structure(void) 
{ 
  int memory_used ;
  int len ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 834
  memory_used = 0;
  {
#line 837
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 839
    len = read_input_line('f');
    }
#line 840
    if (len != -1) {
      {
#line 842
      tmp = xstrdup((char *)read_buffer);
#line 842
      guess_buffer[guess_lines] = (uint8_t *)tmp;
#line 843
      guess_line_length[guess_lines] = len;
#line 844
      memory_used += len;
#line 845
      vote(guess_lines);
#line 846
      guess_lines ++;
      }
    }
#line 837
    if (len != -1) {
#line 837
      if (guess_lines < 10000) {
#line 837
        if (! (memory_used < 1048576)) {
#line 837
          goto while_break;
        }
      } else {
#line 837
        goto while_break;
      }
    } else {
#line 837
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 849
  tmp___0 = check_votes(guess_lines);
  }
#line 849
  return (tmp___0);
}
}
#line 853 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
void start_write(void) 
{ 


  {
#line 856
  write_pos = write_buffer;
#line 857
  return;
}
}
#line 860 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
__inline void writec(uint8_t c ) 
{ 
  int written ;
  void *tmp ;

  {
#line 863
  *write_pos = c;
#line 865
  if ((unsigned long )write_pos == (unsigned long )write_buffer_end) {
    {
#line 867
    written = (int )(write_buffer_end - write_buffer);
#line 869
    write_buffer_size *= 2;
#line 870
    tmp = xrealloc((void *)write_buffer, (size_t )write_buffer_size);
#line 870
    write_buffer = (uint8_t *)tmp;
#line 871
    write_pos = write_buffer + written;
#line 872
    write_buffer_end = write_buffer + (write_buffer_size - 1);
    }
  }
#line 875
  write_pos ++;
#line 876
  return;
}
}
#line 880 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
__inline void writes(uint8_t *string ) 
{ 
  register uint8_t *s ;

  {
#line 883
  s = string;
#line 885
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
#line 887
    while (1) {
      while_continue: /* CIL Label */ ;
#line 887
      if (! *s) {
#line 887
        goto while_break;
      }
      {
#line 889
      writec(*s);
#line 890
      s ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 893
  return;
}
}
#line 895 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
void flush_write(void) 
{ 
  size_t bytes ;
  size_t tmp ;

  {
  {
#line 900
  bytes = (size_t )(write_pos - write_buffer);
#line 902
  tmp = fwrite((void const   */* __restrict  */)write_buffer, (size_t )1, bytes, (FILE */* __restrict  */)output_fp);
  }
#line 902
  if (tmp != bytes) {
    {
#line 904
    panic((char *)"Error writing to", output_file, (char *)((void *)0));
    }
  }
#line 906
  return;
}
}
#line 908 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
void print_raw(int size , uint8_t *buffer , int stype ) 
{ 
  size_t tmp ;

  {
  {
#line 911
  tmp = fwrite((void const   */* __restrict  */)buffer, (size_t )1, (size_t )size,
               (FILE */* __restrict  */)default_output_fp);
  }
#line 911
  if (tmp != (size_t )size) {
    {
#line 913
    panic((char *)"Error writing to", default_output_file, (char *)((void *)0));
    }
  }
#line 915
  if (stype != 98) {
    {
#line 915
    fputc('\n', default_output_fp);
    }
  }
#line 916
  return;
}
}
#line 922 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
void print_text(struct structure *s , struct record *r , uint8_t *buffer ) 
{ 
  register uint8_t *text ;
  char num[64] ;

  {
#line 925
  text = buffer;
#line 928
  if ((unsigned long )text == (unsigned long )((void *)0)) {
#line 928
    return;
  }
#line 929
  if ((unsigned long )r != (unsigned long )((void *)0)) {
#line 929
    if ((unsigned long )r->o == (unsigned long )no_output) {
#line 929
      return;
    } else
#line 929
    if ((unsigned long )r->o == (unsigned long )raw) {
#line 929
      return;
    }
  }
#line 930
  if ((unsigned long )s->o == (unsigned long )no_output) {
#line 930
    return;
  } else
#line 930
  if ((unsigned long )s->o == (unsigned long )raw) {
#line 930
    return;
  }
  {
#line 932
  start_write();
  }
  {
#line 934
  while (1) {
    while_continue: /* CIL Label */ ;
#line 934
    if (! *text) {
#line 934
      goto while_break;
    }
#line 936
    if ((int )*text == 37) {
#line 936
      if (*(text + 1)) {
#line 938
        text ++;
        {
#line 941
        if ((int )*text == 102) {
#line 941
          goto case_102;
        }
#line 944
        if ((int )*text == 115) {
#line 944
          goto case_115;
        }
#line 947
        if ((int )*text == 114) {
#line 947
          goto case_114;
        }
#line 950
        if ((int )*text == 111) {
#line 950
          goto case_111;
        }
#line 954
        if ((int )*text == 79) {
#line 954
          goto case_79;
        }
#line 958
        if ((int )*text == 73) {
#line 958
          goto case_73;
        }
#line 962
        if ((int )*text == 105) {
#line 962
          goto case_105;
        }
#line 966
        if ((int )*text == 103) {
#line 966
          goto case_103;
        }
#line 969
        if ((int )*text == 110) {
#line 969
          goto case_110;
        }
#line 972
        if ((int )*text == 37) {
#line 972
          goto case_37;
        }
#line 975
        goto switch_default;
        case_102: /* CIL Label */ 
        {
#line 942
        writes((uint8_t *)current_file_name);
        }
#line 943
        goto switch_break;
        case_115: /* CIL Label */ 
        {
#line 945
        writes((uint8_t *)s->name);
        }
#line 946
        goto switch_break;
        case_114: /* CIL Label */ 
#line 948
        if ((unsigned long )r != (unsigned long )((void *)0)) {
          {
#line 948
          writes((uint8_t *)r->name);
          }
        }
#line 949
        goto switch_break;
        case_111: /* CIL Label */ 
        {
#line 951
        sprintf((char */* __restrict  */)(num), (char const   */* __restrict  */)"%ld",
                current_file_lineno);
#line 952
        writes((uint8_t *)(num));
        }
#line 953
        goto switch_break;
        case_79: /* CIL Label */ 
        {
#line 955
        sprintf((char */* __restrict  */)(num), (char const   */* __restrict  */)"%ld",
                current_total_lineno);
#line 956
        writes((uint8_t *)(num));
        }
#line 957
        goto switch_break;
        case_73: /* CIL Label */ 
        {
#line 959
        sprintf((char */* __restrict  */)(num), (char const   */* __restrict  */)"%lld",
                current_offset);
#line 960
        writes((uint8_t *)(num));
        }
#line 961
        goto switch_break;
        case_105: /* CIL Label */ 
        {
#line 963
        sprintf((char */* __restrict  */)(num), (char const   */* __restrict  */)"%lld",
                current_file_offset);
#line 964
        writes((uint8_t *)(num));
        }
#line 965
        goto switch_break;
        case_103: /* CIL Label */ 
#line 967
        if (r->level) {
#line 967
          if ((r->level)->group_name) {
            {
#line 967
            writes((uint8_t *)(r->level)->group_name);
            }
          }
        }
#line 968
        goto switch_break;
        case_110: /* CIL Label */ 
#line 970
        if (r->level) {
#line 970
          if ((r->level)->element_name) {
            {
#line 970
            writes((uint8_t *)(r->level)->element_name);
            }
          }
        }
#line 971
        goto switch_break;
        case_37: /* CIL Label */ 
        {
#line 973
        writec((uint8_t )'%');
        }
#line 974
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 976
        writec((uint8_t )'%');
#line 977
        writec(*text);
        }
#line 978
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      } else {
        {
#line 982
        writec(*text);
        }
      }
    } else {
      {
#line 982
      writec(*text);
      }
    }
#line 984
    text ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 986
  flush_write();
  }
#line 987
  return;
}
}
#line 995 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
int print_header(struct structure *s , struct record *r ) 
{ 
  struct print_field *pf ;
  char *text ;

  {
#line 998
  pf = r->pf;
#line 1000
  if ((unsigned long )r->o == (unsigned long )no_output) {
#line 1000
    return (1);
  } else
#line 1000
  if ((unsigned long )r->o == (unsigned long )raw) {
#line 1000
    return (1);
  } else
#line 1000
  if ((unsigned long )(r->o)->header == (unsigned long )((void *)0)) {
#line 1000
    return (1);
  }
#line 1002
  if ((unsigned long )pf == (unsigned long )((void *)0)) {
#line 1002
    return (0);
  }
  {
#line 1004
  start_write();
  }
  {
#line 1006
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1006
    if (! ((unsigned long )pf != (unsigned long )((void *)0))) {
#line 1006
      goto while_break;
    }
#line 1008
    text = (char *)(r->o)->header;
    {
#line 1009
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1009
      if (! *text) {
#line 1009
        goto while_break___0;
      }
#line 1011
      if ((int )*text == 37) {
#line 1011
        if (*(text + 1)) {
#line 1013
          text ++;
          {
#line 1016
          if ((int )*text == 110) {
#line 1016
            goto case_110;
          }
#line 1019
          goto switch_default;
          case_110: /* CIL Label */ 
          {
#line 1017
          writes((uint8_t *)(pf->f)->name);
          }
#line 1018
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 1020
          writec((uint8_t )'%');
#line 1021
          writec((uint8_t )*text);
          }
#line 1022
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        } else {
          {
#line 1026
          writec((uint8_t )*text);
          }
        }
      } else {
        {
#line 1026
        writec((uint8_t )*text);
        }
      }
#line 1028
      text ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1030
    if ((unsigned long )pf->next != (unsigned long )((void *)0)) {
#line 1030
      if ((unsigned long )(r->o)->separator != (unsigned long )((void *)0)) {
        {
#line 1030
        writes((r->o)->separator);
        }
      }
    }
#line 1031
    pf = pf->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1033
  writes((r->o)->record_trailer);
#line 1034
  flush_write();
  }
#line 1036
  return (1);
}
}
#line 1050
uint8_t *get_input_line(int *len , int stype ) ;
#line 1050 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static struct input_file *curr_guess_file  =    (struct input_file *)((void *)0);
#line 1047 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
uint8_t *get_input_line(int *len , int stype ) 
{ 
  uint8_t *ret ;

  {
#line 1051
  ret = (uint8_t *)((void *)0);
#line 1053
  *len = -1;
#line 1055
  if ((unsigned long )curr_guess_file == (unsigned long )((void *)0)) {
#line 1056
    curr_guess_file = files;
#line 1057
    current_file_name = curr_guess_file->name;
  }
  {
#line 1060
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1062
    if (read_guess_line < guess_lines) {
#line 1064
      if (current_file_lineno == curr_guess_file->lineno) {
#line 1066
        curr_guess_file = curr_guess_file->next;
        {
#line 1067
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1067
          if (! (! curr_guess_file->lineno)) {
#line 1067
            goto while_break___0;
          }
#line 1069
          curr_guess_file = curr_guess_file->next;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1071
        current_file_name = curr_guess_file->name;
#line 1072
        current_file_lineno = 0L;
      }
#line 1074
      current_file_lineno ++;
#line 1075
      ret = guess_buffer[read_guess_line];
#line 1076
      *len = guess_line_length[read_guess_line];
#line 1077
      read_guess_line ++;
    } else
#line 1078
    if ((unsigned long )current_file != (unsigned long )((void *)0)) {
      {
#line 1080
      *len = read_input_line(stype);
#line 1081
      ret = read_buffer;
      }
    }
#line 1083
    if (*len == -1) {
#line 1085
      ret = (uint8_t *)((void *)0);
    } else {
#line 1088
      current_total_lineno ++;
    }
#line 1060
    if (current_file_lineno == 1L) {
#line 1060
      if (headers == 2) {
#line 1060
        if (! (current_total_lineno > 1L)) {
#line 1060
          goto while_break;
        }
      } else {
#line 1060
        goto while_break;
      }
    } else {
#line 1060
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1092
  return (ret);
}
}
#line 1097 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
void update_field_positions(char *type , uint8_t quote , int arbit_len , struct field *fields ,
                            int len , uint8_t *buffer ) 
{ 
  register uint8_t *p ;
  register int inside_quote ;
  struct field *f ;

  {
#line 1100
  p = buffer;
#line 1101
  inside_quote = 0;
#line 1102
  f = fields;
  {
#line 1106
  if ((int )*(type + 0) == 98) {
#line 1106
    goto case_98;
  }
#line 1108
  if ((int )*(type + 0) == 102) {
#line 1108
    goto case_102;
  }
#line 1127
  if ((int )*(type + 0) == 115) {
#line 1127
    goto case_115;
  }
#line 1104
  goto switch_break;
  case_98: /* CIL Label */ 
#line 1107
  goto switch_break;
  case_102: /* CIL Label */ 
#line 1109
  if (arbit_len == 1) {
    {
#line 1111
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1111
      if (! ((unsigned long )f != (unsigned long )((void *)0))) {
#line 1111
        goto while_break;
      }
#line 1113
      if ((unsigned long )f->next == (unsigned long )((void *)0)) {
#line 1115
        if (len > f->position) {
#line 1117
          f->bposition = f->position;
        } else {
#line 1120
          f->bposition = -1;
        }
      }
#line 1123
      f = f->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1126
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 1128
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1128
    if (! ((unsigned long )f != (unsigned long )((void *)0))) {
#line 1128
      goto while_break___0;
    }
#line 1130
    f->bposition = -1;
#line 1131
    f = f->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1134
  f = fields;
  {
#line 1136
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1136
    if (*p) {
#line 1136
      if (! ((unsigned long )f != (unsigned long )((void *)0))) {
#line 1136
        goto while_break___1;
      }
    } else {
#line 1136
      goto while_break___1;
    }
#line 1138
    if ((unsigned long )p == (unsigned long )buffer) {
#line 1140
      if ((int )*p != (int )*(type + 1)) {
#line 1140
        f->bposition = 0;
      }
#line 1141
      f = f->next;
    }
#line 1143
    if ((int )*p == (int )*(type + 1)) {
#line 1143
      if (! inside_quote) {
#line 1145
        p ++;
#line 1146
        if ((int )*(type + 2) == 42) {
          {
#line 1146
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1146
            if (! ((int )*p == (int )*(type + 1))) {
#line 1146
              goto while_break___2;
            }
#line 1146
            p ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 1147
        if ((int )*p != (int )*(type + 1)) {
#line 1149
          f->bposition = (int )(p - buffer);
        } else {
#line 1152
          p --;
        }
#line 1154
        f = f->next;
      }
    }
#line 1156
    if ((int )*p == (int )quote) {
#line 1156
      if ((int )*(p + 1) == (int )quote) {
#line 1156
        goto _L___1;
      } else {
#line 1156
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 1156
    if ((int )*p == 92) {
#line 1156
      if ((int )*(p + 1) == (int )quote) {
        _L___1: /* CIL Label */ 
#line 1156
        if (inside_quote) {
#line 1156
          if (quote) {
#line 1158
            p ++;
          } else {
#line 1156
            goto _L___2;
          }
        } else {
#line 1156
          goto _L___2;
        }
      } else {
#line 1156
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1159
    if ((int )*p == (int )quote) {
#line 1159
      if (quote) {
#line 1161
        inside_quote = ! inside_quote;
      }
    }
#line 1163
    if (*p) {
#line 1163
      p ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1165
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1167
  return;
}
}
#line 1170 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
struct record *select_record(struct structure *s , int length , uint8_t *buffer ) 
{ 
  register struct record *r ;
  int tmp ;

  {
#line 1175
  r = s->r;
  {
#line 1177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1177
    if (! ((unsigned long )r != (unsigned long )((void *)0))) {
#line 1177
      goto while_break;
    }
    {
#line 1179
    tmp = vote_record((uint8_t )s->quote, s->type, s->header, r, length, buffer);
    }
#line 1179
    if (tmp) {
#line 1179
      return (r);
    }
#line 1180
    r = r->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1183
  return ((struct record *)((void *)0));
}
}
#line 1187 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
void print_fixed_field(uint8_t format , struct field *f , uint8_t *buffer ) 
{ 
  register int i ;
  register uint8_t *data ;
  uint8_t *start ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 1190
  i = 0;
#line 1192
  start = write_pos;
#line 1194
  if ((unsigned long )f->const_data != (unsigned long )((void *)0)) {
#line 1196
    data = (uint8_t *)f->const_data;
#line 1197
    if ((int )format == 116) {
#line 1197
      format = (uint8_t )'d';
    }
  } else {
#line 1200
    if (f->bposition < 0) {
#line 1200
      return;
    }
#line 1201
    data = buffer + f->bposition;
  }
  {
#line 1210
  if ((int )format == 120) {
#line 1210
    goto case_120;
  }
#line 1210
  if ((int )format == 101) {
#line 1210
    goto case_120;
  }
#line 1210
  if ((int )format == 67) {
#line 1210
    goto case_120;
  }
#line 1210
  if ((int )format == 68) {
#line 1210
    goto case_120;
  }
#line 1210
  if ((int )format == 100) {
#line 1210
    goto case_120;
  }
#line 1219
  if ((int )format == 116) {
#line 1219
    goto case_116;
  }
#line 1204
  goto switch_break;
  case_120: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_100: /* CIL Label */ 
#line 1211
  if (f->length) {
    {
#line 1213
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1213
      if (i < f->length) {
#line 1213
        if (! *(data + i)) {
#line 1213
          goto while_break;
        }
      } else {
#line 1213
        goto while_break;
      }
      {
#line 1213
      tmp = i;
#line 1213
      i ++;
#line 1213
      writec(*(data + tmp));
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1216
    writes(data);
    }
  }
#line 1218
  goto switch_break;
  case_116: /* CIL Label */ 
  {
#line 1220
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1220
    tmp___0 = __ctype_b_loc();
    }
#line 1220
    if (! ((int const   )*(*tmp___0 + (int )*(data + i)) & 8192)) {
#line 1220
      goto while_break___0;
    }
#line 1220
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1221
  if (f->length) {
    {
#line 1223
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1223
      if (i < f->length) {
#line 1223
        if (! *(data + i)) {
#line 1223
          goto while_break___1;
        }
      } else {
#line 1223
        goto while_break___1;
      }
      {
#line 1223
      tmp___1 = i;
#line 1223
      i ++;
#line 1223
      writec(*(data + tmp___1));
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 1226
    writes(data + i);
    }
  }
#line 1228
  if ((unsigned long )write_pos > (unsigned long )start) {
    {
#line 1228
    tmp___3 = __ctype_b_loc();
    }
#line 1228
    if ((int const   )*(*tmp___3 + (int )*(write_pos + -1)) & 8192) {
#line 1230
      write_pos --;
      {
#line 1231
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1231
        if ((unsigned long )write_pos > (unsigned long )start) {
          {
#line 1231
          tmp___2 = __ctype_b_loc();
          }
#line 1231
          if (! ((int const   )*(*tmp___2 + (int )*write_pos) & 8192)) {
#line 1231
            goto while_break___2;
          }
        } else {
#line 1231
          goto while_break___2;
        }
#line 1231
        write_pos --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1232
      write_pos ++;
    }
  }
#line 1234
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1236
  return;
}
}
#line 1247 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static uint8_t pb[262144]  ;
#line 1241 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
void print_binary_field(uint8_t format , struct field *f , uint8_t *buffer ) 
{ 
  register uint8_t *p ;
  register uint8_t *data_end ;
  uint8_t *data ;
  uint8_t c ;
  char *pf ;
  uint8_t tmp ;
  uint8_t tmp___0 ;
  uint8_t tmp___1 ;
  uint8_t tmp___2 ;
  uint8_t tmp___3 ;
  uint8_t tmp___4 ;

  {
#line 1249
  if ((unsigned long )f->const_data != (unsigned long )((void *)0)) {
    {
#line 1251
    print_fixed_field(format, f, buffer);
    }
#line 1252
    return;
  } else
#line 1249
  if (f->type == 1) {
#line 1249
    if ((int )format != 104) {
      {
#line 1251
      print_fixed_field(format, f, buffer);
      }
#line 1252
      return;
    }
  }
  {
#line 1260
  if (f->type == 8) {
#line 1260
    goto case_8;
  }
#line 1260
  if (f->type == 7) {
#line 1260
    goto case_8;
  }
#line 1260
  if (f->type == 10) {
#line 1260
    goto case_8;
  }
#line 1260
  if (f->type == 3) {
#line 1260
    goto case_8;
  }
#line 1263
  goto switch_default;
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 1261
  data = endian_and_align(buffer + f->bposition, system_endianess, f->endianess, f->length);
  }
#line 1262
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1264
  data = buffer + f->bposition;
#line 1265
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1268
  pb[0] = (uint8_t )0;
  {
#line 1272
  if ((int )format == 104) {
#line 1272
    goto case_104;
  }
#line 1287
  if ((int )format == 120) {
#line 1287
    goto case_120;
  }
#line 1287
  if ((int )format == 67) {
#line 1287
    goto case_120;
  }
#line 1287
  if ((int )format == 68) {
#line 1287
    goto case_120;
  }
#line 1287
  if ((int )format == 116) {
#line 1287
    goto case_120;
  }
#line 1287
  if ((int )format == 100) {
#line 1287
    goto case_120;
  }
#line 1270
  goto switch_break___0;
  case_104: /* CIL Label */ 
#line 1273
  p = buffer + f->bposition;
#line 1274
  data_end = p + f->length;
  {
#line 1275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1275
    if (! ((unsigned long )p < (unsigned long )data_end)) {
#line 1275
      goto while_break;
    }
    {
#line 1277
    writec((uint8_t )'x');
#line 1278
    tmp = htocb(*p);
#line 1278
    writec(tmp);
#line 1279
    tmp___0 = htocl(*p);
#line 1279
    writec(tmp___0);
#line 1280
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1282
  goto switch_break___0;
  case_120: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_100: /* CIL Label */ 
  {
#line 1290
  if (f->type == 4) {
#line 1290
    goto case_4;
  }
#line 1293
  if (f->type == 3) {
#line 1293
    goto case_3___0;
  }
#line 1315
  if (f->type == 10) {
#line 1315
    goto case_10___0;
  }
#line 1337
  if (f->type == 7) {
#line 1337
    goto case_7___0;
  }
#line 1341
  if (f->type == 8) {
#line 1341
    goto case_8___2;
  }
#line 1345
  if (f->type == 9) {
#line 1345
    goto case_9;
  }
#line 1378
  if (f->type == 11) {
#line 1378
    goto case_11;
  }
#line 1288
  goto switch_break___1;
  case_4: /* CIL Label */ 
  {
#line 1291
  writec(*data);
  }
#line 1292
  goto switch_break___1;
  case_3___0: /* CIL Label */ 
  {
#line 1296
  if (f->length == 1) {
#line 1296
    goto case_1;
  }
#line 1300
  if (f->length == 2) {
#line 1300
    goto case_2;
  }
#line 1304
  if (f->length == 4) {
#line 1304
    goto case_4___0;
  }
#line 1308
  if (f->length == 8) {
#line 1308
    goto case_8___0;
  }
#line 1294
  goto switch_break___2;
  case_1: /* CIL Label */ 
#line 1297
  if ((int )format == 120) {
#line 1297
    pf = (char *)"%x";
  } else {
#line 1297
    pf = (char *)"%i";
  }
  {
#line 1298
  sprintf((char */* __restrict  */)(pb), (char const   */* __restrict  */)pf, (int )*((int8_t *)data));
  }
#line 1299
  goto switch_break___2;
  case_2: /* CIL Label */ 
#line 1301
  if ((int )format == 120) {
#line 1301
    pf = (char *)"%x";
  } else {
#line 1301
    pf = (char *)"%i";
  }
  {
#line 1302
  sprintf((char */* __restrict  */)(pb), (char const   */* __restrict  */)pf, (int )*((int16_t *)data));
  }
#line 1303
  goto switch_break___2;
  case_4___0: /* CIL Label */ 
#line 1305
  if ((int )format == 120) {
#line 1305
    pf = (char *)"%lx";
  } else {
#line 1305
    pf = (char *)"%li";
  }
  {
#line 1306
  sprintf((char */* __restrict  */)(pb), (char const   */* __restrict  */)pf, (long )*((int32_t *)data));
  }
#line 1307
  goto switch_break___2;
  case_8___0: /* CIL Label */ 
#line 1309
  if ((int )format == 120) {
#line 1309
    pf = (char *)"%llx";
  } else {
#line 1309
    pf = (char *)"%lli";
  }
  {
#line 1310
  sprintf((char */* __restrict  */)(pb), (char const   */* __restrict  */)pf, (long long )*((int64_t *)data));
  }
#line 1311
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
  {
#line 1313
  writes(pb);
  }
#line 1314
  goto switch_break___1;
  case_10___0: /* CIL Label */ 
  {
#line 1318
  if (f->length == 1) {
#line 1318
    goto case_1___0;
  }
#line 1322
  if (f->length == 2) {
#line 1322
    goto case_2___0;
  }
#line 1326
  if (f->length == 4) {
#line 1326
    goto case_4___1;
  }
#line 1330
  if (f->length == 8) {
#line 1330
    goto case_8___1;
  }
#line 1316
  goto switch_break___3;
  case_1___0: /* CIL Label */ 
#line 1319
  if ((int )format == 120) {
#line 1319
    pf = (char *)"%x";
  } else {
#line 1319
    pf = (char *)"%u";
  }
  {
#line 1320
  sprintf((char */* __restrict  */)(pb), (char const   */* __restrict  */)pf, (unsigned int )*data);
  }
#line 1321
  goto switch_break___3;
  case_2___0: /* CIL Label */ 
#line 1323
  if ((int )format == 120) {
#line 1323
    pf = (char *)"%x";
  } else {
#line 1323
    pf = (char *)"%u";
  }
  {
#line 1324
  sprintf((char */* __restrict  */)(pb), (char const   */* __restrict  */)pf, (unsigned int )*((uint16_t *)data));
  }
#line 1325
  goto switch_break___3;
  case_4___1: /* CIL Label */ 
#line 1327
  if ((int )format == 120) {
#line 1327
    pf = (char *)"%lx";
  } else {
#line 1327
    pf = (char *)"%lu";
  }
  {
#line 1328
  sprintf((char */* __restrict  */)(pb), (char const   */* __restrict  */)pf, (unsigned long )*((uint32_t *)data));
  }
#line 1329
  goto switch_break___3;
  case_8___1: /* CIL Label */ 
#line 1331
  if ((int )format == 120) {
#line 1331
    pf = (char *)"%llx";
  } else {
#line 1331
    pf = (char *)"%llu";
  }
  {
#line 1332
  sprintf((char */* __restrict  */)(pb), (char const   */* __restrict  */)pf, (unsigned long long )*((uint64_t *)data));
  }
#line 1333
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
  {
#line 1335
  writes(pb);
  }
#line 1336
  goto switch_break___1;
  case_7___0: /* CIL Label */ 
  {
#line 1338
  sprintf((char */* __restrict  */)(pb), (char const   */* __restrict  */)"%f", (double )*((float *)data));
#line 1339
  writes(pb);
  }
#line 1340
  goto switch_break___1;
  case_8___2: /* CIL Label */ 
  {
#line 1342
  sprintf((char */* __restrict  */)(pb), (char const   */* __restrict  */)"%f", *((double *)data));
#line 1343
  writes(pb);
  }
#line 1344
  goto switch_break___1;
  case_9: /* CIL Label */ 
#line 1346
  p = data;
#line 1347
  data_end = p + f->length;
  {
#line 1350
  if (f->endianess == 1) {
#line 1350
    goto case_1___1;
  }
#line 1363
  if (f->endianess == 3) {
#line 1363
    goto case_3___1;
  }
#line 1348
  goto switch_break___4;
  case_1___1: /* CIL Label */ 
  {
#line 1351
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1353
    c = bcdtocb(*p);
    }
#line 1354
    if (c) {
      {
#line 1356
      writec(c);
#line 1357
      c = bcdtocl(*p);
      }
#line 1358
      if (c) {
        {
#line 1358
        writec(c);
        }
      }
    }
#line 1360
    p ++;
#line 1351
    if ((unsigned long )p < (unsigned long )data_end) {
#line 1351
      if (! c) {
#line 1351
        goto while_break___0;
      }
    } else {
#line 1351
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1362
  goto switch_break___4;
  case_3___1: /* CIL Label */ 
  {
#line 1364
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1366
    c = bcdtocl(*p);
    }
#line 1367
    if (c) {
      {
#line 1369
      writec(c);
#line 1370
      c = bcdtocb(*p);
      }
#line 1371
      if (c) {
        {
#line 1371
        writec(c);
        }
      }
    }
#line 1373
    p ++;
#line 1364
    if ((unsigned long )p < (unsigned long )data_end) {
#line 1364
      if (! c) {
#line 1364
        goto while_break___1;
      }
    } else {
#line 1364
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1375
  goto switch_break___4;
  switch_break___4: /* CIL Label */ ;
  }
#line 1377
  goto switch_break___1;
  case_11: /* CIL Label */ 
#line 1379
  p = data;
#line 1380
  data_end = p + f->length;
  {
#line 1383
  if (f->endianess == 1) {
#line 1383
    goto case_1___2;
  }
#line 1391
  if (f->endianess == 3) {
#line 1391
    goto case_3___2;
  }
#line 1381
  goto switch_break___5;
  case_1___2: /* CIL Label */ 
  {
#line 1384
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1384
    if (! ((unsigned long )p < (unsigned long )data_end)) {
#line 1384
      goto while_break___2;
    }
    {
#line 1386
    tmp___1 = htocb(*p);
#line 1386
    writec(tmp___1);
#line 1387
    tmp___2 = htocl(*p);
#line 1387
    writec(tmp___2);
#line 1388
    p ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1390
  goto switch_break___5;
  case_3___2: /* CIL Label */ 
#line 1392
  p += f->length - 1;
  {
#line 1393
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1393
    if (! ((unsigned long )p >= (unsigned long )data)) {
#line 1393
      goto while_break___3;
    }
    {
#line 1395
    tmp___3 = htocb(*p);
#line 1395
    writec(tmp___3);
#line 1396
    tmp___4 = htocl(*p);
#line 1396
    writec(tmp___4);
#line 1397
    p --;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1399
  goto switch_break___5;
  switch_break___5: /* CIL Label */ ;
  }
#line 1401
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 1404
  return;
}
}
#line 1409 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
void print_separated_field(uint8_t format , uint8_t quote , uint8_t separator , struct field *f ,
                           uint8_t *buffer ) 
{ 
  register uint8_t *p ;
  uint8_t *start ;
  int inside_quote ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
#line 1414
  inside_quote = 0;
#line 1416
  start = write_pos;
#line 1418
  if ((unsigned long )f->const_data != (unsigned long )((void *)0)) {
    {
#line 1420
    print_fixed_field(format, f, buffer);
    }
  } else {
#line 1423
    if (f->bposition < 0) {
#line 1425
      if ((int )format == 68) {
#line 1425
        goto _L;
      } else
#line 1425
      if ((int )format == 67) {
        _L: /* CIL Label */ 
        {
#line 1425
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1425
          if (! (write_pos - start < (long )f->length)) {
#line 1425
            goto while_break;
          }
          {
#line 1425
          writec((uint8_t )' ');
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 1426
      return;
    }
    {
#line 1436
    if ((int )format == 120) {
#line 1436
      goto case_120;
    }
#line 1436
    if ((int )format == 101) {
#line 1436
      goto case_120;
    }
#line 1436
    if ((int )format == 67) {
#line 1436
      goto case_120;
    }
#line 1436
    if ((int )format == 68) {
#line 1436
      goto case_120;
    }
#line 1436
    if ((int )format == 116) {
#line 1436
      goto case_120;
    }
#line 1436
    if ((int )format == 100) {
#line 1436
      goto case_120;
    }
#line 1429
    goto switch_break;
    case_120: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_100: /* CIL Label */ 
#line 1437
    p = buffer + f->bposition;
#line 1438
    if (quote) {
#line 1438
      goto _L___0;
    } else
#line 1438
    if ((int )format == 116) {
      _L___0: /* CIL Label */ 
      {
#line 1438
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1438
        if ((int )*p != (int )separator) {
          {
#line 1438
          tmp = __ctype_b_loc();
          }
#line 1438
          if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 1438
            goto while_break___0;
          }
        } else {
#line 1438
          goto while_break___0;
        }
#line 1438
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1439
    if ((int )*p == (int )quote) {
#line 1439
      if (quote) {
#line 1441
        p ++;
#line 1442
        inside_quote = 1;
#line 1443
        if ((int )format == 116) {
          {
#line 1443
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 1443
            tmp___0 = __ctype_b_loc();
            }
#line 1443
            if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 1443
              goto while_break___1;
            }
#line 1443
            p ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
    }
    {
#line 1445
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1445
      if ((int )*p != (int )separator) {
#line 1445
        goto _L___6;
      } else
#line 1445
      if (inside_quote) {
        _L___6: /* CIL Label */ 
#line 1445
        if (! *p) {
#line 1445
          goto while_break___2;
        }
      } else {
#line 1445
        goto while_break___2;
      }
#line 1447
      if ((int )*p == (int )quote) {
#line 1447
        if ((int )*(p + 1) == (int )quote) {
#line 1447
          goto _L___3;
        } else {
#line 1447
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 1447
      if ((int )*p == 92) {
#line 1447
        if ((int )*(p + 1) == (int )quote) {
          _L___3: /* CIL Label */ 
#line 1447
          if (quote) {
#line 1449
            p ++;
          } else {
#line 1447
            goto _L___4;
          }
        } else {
#line 1447
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 1450
      if ((int )*p == (int )quote) {
#line 1452
        if (inside_quote) {
#line 1454
          if ((int )format == 116) {
            {
#line 1454
            tmp___2 = __ctype_b_loc();
            }
#line 1454
            if ((int const   )*(*tmp___2 + (int )*(write_pos + -1)) & 8192) {
#line 1456
              write_pos --;
              {
#line 1457
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 1457
                if ((unsigned long )write_pos > (unsigned long )start) {
                  {
#line 1457
                  tmp___1 = __ctype_b_loc();
                  }
#line 1457
                  if (! ((int const   )*(*tmp___1 + (int )*write_pos) & 8192)) {
#line 1457
                    goto while_break___3;
                  }
                } else {
#line 1457
                  goto while_break___3;
                }
#line 1457
                write_pos --;
              }
              while_break___3: /* CIL Label */ ;
              }
#line 1458
              write_pos ++;
            }
          }
#line 1460
          if ((int )format == 68) {
#line 1460
            goto _L___1;
          } else
#line 1460
          if ((int )format == 67) {
            _L___1: /* CIL Label */ 
            {
#line 1460
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1460
              if (! (write_pos - start == (long )f->length)) {
#line 1460
                goto while_break___4;
              }
              {
#line 1460
              writec((uint8_t )' ');
              }
            }
            while_break___4: /* CIL Label */ ;
            }
          }
#line 1461
          return;
        }
      }
#line 1465
      if ((int )format == 67) {
#line 1465
        if (write_pos - start == (long )f->length) {
#line 1465
          return;
        }
      }
      {
#line 1466
      writec(*p);
      }
#line 1467
      if (*p) {
#line 1467
        p ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1469
    if ((int )format == 116) {
      {
#line 1469
      tmp___4 = __ctype_b_loc();
      }
#line 1469
      if ((int const   )*(*tmp___4 + (int )*(write_pos + -1)) & 8192) {
#line 1471
        write_pos --;
        {
#line 1472
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1472
          if ((unsigned long )write_pos > (unsigned long )start) {
            {
#line 1472
            tmp___3 = __ctype_b_loc();
            }
#line 1472
            if (! ((int const   )*(*tmp___3 + (int )*write_pos) & 8192)) {
#line 1472
              goto while_break___5;
            }
          } else {
#line 1472
            goto while_break___5;
          }
#line 1472
          write_pos --;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1473
        write_pos ++;
      }
    }
#line 1475
    if ((int )format == 68) {
#line 1475
      goto _L___7;
    } else
#line 1475
    if ((int )format == 67) {
      _L___7: /* CIL Label */ 
      {
#line 1475
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1475
        if (! (write_pos - start < (long )f->length)) {
#line 1475
          goto while_break___6;
        }
        {
#line 1475
        writec((uint8_t )' ');
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 1476
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1479
  return;
}
}
#line 1482 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
uint8_t *make_lookup(struct lookup *l , uint8_t *search ) 
{ 
  register uint8_t *k ;
  register uint8_t *s ;
  int search_len ;
  size_t tmp ;
  int max_len ;
  uint8_t *ret_val ;
  uint8_t *longest ;
  struct lookup_data *d ;

  {
  {
#line 1486
  tmp = strlen((char const   *)search);
#line 1486
  search_len = (int )tmp;
#line 1487
  max_len = -1;
#line 1488
  ret_val = (uint8_t *)((void *)0);
#line 1489
  longest = (uint8_t *)((void *)0);
#line 1490
  d = l->data;
  }
  {
#line 1494
  if ((int )l->type == 1) {
#line 1494
    goto case_1;
  }
#line 1511
  if ((int )l->type == 2) {
#line 1511
    goto case_2;
  }
#line 1492
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1495
  if (search_len <= l->max_key_len) {
    {
#line 1497
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1497
      if ((unsigned long )d != (unsigned long )((void *)0)) {
#line 1497
        if (! ((unsigned long )ret_val == (unsigned long )((void *)0))) {
#line 1497
          goto while_break;
        }
      } else {
#line 1497
        goto while_break;
      }
#line 1499
      k = d->key;
#line 1500
      s = search;
      {
#line 1501
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1501
        if ((int )*k == (int )*s) {
#line 1501
          if (! *k) {
#line 1501
            goto while_break___0;
          }
        } else {
#line 1501
          goto while_break___0;
        }
#line 1503
        k ++;
#line 1504
        s ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1506
      if (! *s) {
#line 1506
        if (! *k) {
#line 1506
          ret_val = d->value;
        }
      }
#line 1507
      d = d->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1510
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1512
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1512
    if ((unsigned long )d != (unsigned long )((void *)0)) {
#line 1512
      if (! (max_len < l->max_key_len)) {
#line 1512
        goto while_break___1;
      }
    } else {
#line 1512
      goto while_break___1;
    }
#line 1514
    k = d->key;
#line 1515
    s = search;
    {
#line 1516
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1516
      if ((int )*k == (int )*s) {
#line 1516
        if (! *k) {
#line 1516
          goto while_break___2;
        }
      } else {
#line 1516
        goto while_break___2;
      }
#line 1518
      k ++;
#line 1519
      s ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1521
    if (! *k) {
#line 1521
      if (d->key_len > max_len) {
#line 1523
        max_len = d->key_len;
#line 1524
        longest = d->value;
      }
    }
#line 1526
    d = d->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1528
  ret_val = longest;
#line 1529
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1532
  if ((unsigned long )ret_val == (unsigned long )((void *)0)) {
#line 1532
    ret_val = l->default_value;
  }
#line 1534
  return (ret_val);
}
}
#line 1537 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
void print_indent(uint8_t *buffer , int times ) 
{ 
  int tmp ;

  {
  {
#line 1540
  start_write();
  }
  {
#line 1541
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1541
    tmp = times;
#line 1541
    times --;
#line 1541
    if (! tmp) {
#line 1541
      goto while_break;
    }
    {
#line 1541
    writes(buffer);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1542
  flush_write();
  }
#line 1543
  return;
}
}
#line 1548 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
int print_fields(struct structure *s , struct record *r , uint8_t *buffer ) 
{ 
  uint8_t num[64] ;
  int max_justify_len ;
  register uint8_t *d ;
  uint8_t *f ;
  int i ;
  uint8_t justify ;
  uint8_t *indent ;
  uint8_t *separator ;
  uint8_t *data_start ;
  uint8_t *rep_start ;
  uint8_t *rep_pos ;
  uint8_t *field_start ;
  uint8_t *lookup_value ;
  int retval ;
  int replacing ;
  int just_replaced ;
  int lookup_len ;
  struct print_field *pf ;
  struct output *o ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int i___0 ;
  int tmp___3 ;

  {
#line 1552
  max_justify_len = 0;
#line 1556
  justify = (uint8_t )1;
#line 1561
  retval = 0;
#line 1564
  pf = r->pf;
  {
#line 1567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1567
    if (! ((unsigned long )pf != (unsigned long )((void *)0))) {
#line 1567
      goto while_break;
    }
#line 1568
    pf->justify_length = -1;
#line 1569
    pf = pf->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1572
  pf = r->pf;
#line 1574
  start_write();
  }
  {
#line 1576
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1576
    if (! ((unsigned long )pf != (unsigned long )((void *)0))) {
#line 1576
      goto while_break___0;
    }
#line 1578
    if ((pf->f)->o) {
#line 1578
      o = (pf->f)->o;
    } else {
#line 1578
      o = r->o;
    }
#line 1580
    if ((unsigned long )o != (unsigned long )no_output) {
#line 1582
      justify = o->justify;
#line 1583
      d = o->data;
#line 1584
      data_start = write_pos;
#line 1585
      pf->data = data_start;
#line 1586
      pf->empty = 1;
#line 1587
      replacing = 0;
#line 1588
      just_replaced = 0;
#line 1589
      lookup_value = (uint8_t *)((void *)0);
#line 1591
      if ((unsigned long )(pf->f)->lookup != (unsigned long )((void *)0)) {
#line 1591
        d = o->lookup;
      }
#line 1593
      if (o->hex_cap) {
#line 1595
        bcd_to_ascii = bcd_to_ascii_cap;
#line 1596
        hex_to_ascii = hex_to_ascii_cap;
      } else {
#line 1599
        bcd_to_ascii = bcd_to_ascii_low;
#line 1600
        hex_to_ascii = hex_to_ascii_low;
      }
      {
#line 1603
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1603
        if (! *d) {
#line 1603
          goto while_break___1;
        }
#line 1605
        if ((int )justify == (int )*d) {
#line 1607
          if ((int )justify != 1) {
#line 1607
            if ((int )justify != 2) {
#line 1607
              if (pf->justify_length == -1) {
#line 1607
                if (! replacing) {
#line 1609
                  pf->justify_length = (int )(write_pos - data_start);
#line 1610
                  if (pf->justify_length > max_justify_len) {
#line 1612
                    max_justify_len = pf->justify_length;
                  }
                }
              }
            }
          }
        }
#line 1617
        if ((int )*d == 37) {
#line 1619
          d ++;
          {
#line 1622
          if ((int )*d == 102) {
#line 1622
            goto case_102;
          }
#line 1625
          if ((int )*d == 115) {
#line 1625
            goto case_115;
          }
#line 1628
          if ((int )*d == 114) {
#line 1628
            goto case_114;
          }
#line 1631
          if ((int )*d == 111) {
#line 1631
            goto case_111;
          }
#line 1635
          if ((int )*d == 79) {
#line 1635
            goto case_79;
          }
#line 1639
          if ((int )*d == 73) {
#line 1639
            goto case_73;
          }
#line 1643
          if ((int )*d == 105) {
#line 1643
            goto case_105;
          }
#line 1647
          if ((int )*d == 112) {
#line 1647
            goto case_112;
          }
#line 1654
          if ((int )*d == 37) {
#line 1654
            goto case_37;
          }
#line 1657
          if ((int )*d == 110) {
#line 1657
            goto case_110;
          }
#line 1661
          if ((int )*d == 76) {
#line 1661
            goto case_76;
          }
#line 1661
          if ((int )*d == 108) {
#line 1661
            goto case_76;
          }
#line 1696
          if ((int )*d == 104) {
#line 1696
            goto case_104;
          }
#line 1704
          if ((int )*d == 120) {
#line 1704
            goto case_120;
          }
#line 1704
          if ((int )*d == 101) {
#line 1704
            goto case_120;
          }
#line 1704
          if ((int )*d == 67) {
#line 1704
            goto case_120;
          }
#line 1704
          if ((int )*d == 68) {
#line 1704
            goto case_120;
          }
#line 1704
          if ((int )*d == 116) {
#line 1704
            goto case_120;
          }
#line 1704
          if ((int )*d == 100) {
#line 1704
            goto case_120;
          }
#line 1745
          goto switch_default;
          case_102: /* CIL Label */ 
          {
#line 1623
          writes((uint8_t *)current_file_name);
          }
#line 1624
          goto switch_break;
          case_115: /* CIL Label */ 
          {
#line 1626
          writes((uint8_t *)s->name);
          }
#line 1627
          goto switch_break;
          case_114: /* CIL Label */ 
#line 1629
          if ((unsigned long )r != (unsigned long )((void *)0)) {
            {
#line 1629
            writes((uint8_t *)r->name);
            }
          }
#line 1630
          goto switch_break;
          case_111: /* CIL Label */ 
          {
#line 1632
          sprintf((char */* __restrict  */)(num), (char const   */* __restrict  */)"%ld",
                  current_file_lineno);
#line 1633
          writes(num);
          }
#line 1634
          goto switch_break;
          case_79: /* CIL Label */ 
          {
#line 1636
          sprintf((char */* __restrict  */)(num), (char const   */* __restrict  */)"%ld",
                  current_total_lineno);
#line 1637
          writes(num);
          }
#line 1638
          goto switch_break;
          case_73: /* CIL Label */ 
          {
#line 1640
          sprintf((char */* __restrict  */)(num), (char const   */* __restrict  */)"%lld",
                  current_offset);
#line 1641
          writes(num);
          }
#line 1642
          goto switch_break;
          case_105: /* CIL Label */ 
          {
#line 1644
          sprintf((char */* __restrict  */)(num), (char const   */* __restrict  */)"%lld",
                  current_file_offset);
#line 1645
          writes(num);
          }
#line 1646
          goto switch_break;
          case_112: /* CIL Label */ 
#line 1648
          if ((unsigned long )(pf->f)->const_data == (unsigned long )((void *)0)) {
#line 1650
            if ((int )s->type[0] != 115) {
#line 1650
              tmp = 1;
            } else {
#line 1650
              tmp = 0;
            }
            {
#line 1650
            sprintf((char */* __restrict  */)(num), (char const   */* __restrict  */)"%d",
                    (pf->f)->position + tmp);
#line 1651
            writes(num);
            }
          }
#line 1653
          goto switch_break;
          case_37: /* CIL Label */ 
          {
#line 1655
          writec((uint8_t )'%');
          }
#line 1656
          goto switch_break;
          case_110: /* CIL Label */ 
          {
#line 1658
          writes((uint8_t *)(pf->f)->name);
          }
#line 1659
          goto switch_break;
          case_76: /* CIL Label */ 
          case_108: /* CIL Label */ 
#line 1662
          if ((unsigned long )(pf->f)->lookup != (unsigned long )((void *)0)) {
#line 1664
            if ((unsigned long )lookup_value == (unsigned long )((void *)0)) {
#line 1666
              field_start = write_pos;
              {
#line 1669
              if ((int )s->type[0] == 102) {
#line 1669
                goto case_102___0;
              }
#line 1672
              if ((int )s->type[0] == 115) {
#line 1672
                goto case_115___0;
              }
#line 1675
              if ((int )s->type[0] == 98) {
#line 1675
                goto case_98;
              }
#line 1667
              goto switch_break___0;
              case_102___0: /* CIL Label */ 
              {
#line 1670
              print_fixed_field((uint8_t )'t', pf->f, buffer);
              }
#line 1671
              goto switch_break___0;
              case_115___0: /* CIL Label */ 
              {
#line 1673
              print_separated_field((uint8_t )'t', (uint8_t )s->quote, (uint8_t )s->type[1],
                                    pf->f, buffer);
              }
#line 1674
              goto switch_break___0;
              case_98: /* CIL Label */ 
              {
#line 1676
              print_binary_field((uint8_t )'t', pf->f, buffer);
              }
#line 1677
              goto switch_break___0;
              switch_break___0: /* CIL Label */ ;
              }
              {
#line 1679
              writec((uint8_t )0);
#line 1680
              lookup_value = make_lookup((pf->f)->lookup, field_start);
#line 1681
              write_pos = field_start;
              }
            }
          } else
#line 1683
          if ((unsigned long )lookup_value == (unsigned long )((void *)0)) {
#line 1685
            lookup_value = (uint8_t *)"";
          }
          {
#line 1688
          writes(lookup_value);
          }
#line 1690
          if ((int )*d == 76) {
            {
#line 1692
            tmp___0 = strlen((char const   *)lookup_value);
#line 1692
            lookup_len = (int )tmp___0;
            }
            {
#line 1693
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 1693
              tmp___1 = lookup_len;
#line 1693
              lookup_len ++;
#line 1693
              if (! (tmp___1 < (pf->f)->length)) {
#line 1693
                goto while_break___2;
              }
              {
#line 1693
              writec((uint8_t )' ');
              }
            }
            while_break___2: /* CIL Label */ ;
            }
          }
#line 1695
          goto switch_break;
          case_104: /* CIL Label */ 
#line 1697
          if ((int )s->type[0] == 98) {
            {
#line 1697
            print_binary_field(*d, pf->f, buffer);
            }
          }
#line 1698
          goto switch_break;
          case_120: /* CIL Label */ 
          case_101: /* CIL Label */ 
          case_67: /* CIL Label */ 
          case_68: /* CIL Label */ 
          case_116: /* CIL Label */ 
          case_100: /* CIL Label */ 
#line 1705
          field_start = write_pos;
#line 1707
          if ((unsigned long )(pf->f)->rep != (unsigned long )((void *)0)) {
#line 1707
            if (! replacing) {
#line 1709
              replacing = 1;
#line 1710
              just_replaced = 1;
#line 1711
              rep_pos = d;
#line 1712
              rep_start = write_pos;
#line 1713
              d = ((pf->f)->rep)->value;
#line 1714
              goto switch_break;
            }
          }
          {
#line 1719
          if ((int )s->type[0] == 102) {
#line 1719
            goto case_102___1;
          }
#line 1722
          if ((int )s->type[0] == 115) {
#line 1722
            goto case_115___1;
          }
#line 1725
          if ((int )s->type[0] == 98) {
#line 1725
            goto case_98___0;
          }
#line 1717
          goto switch_break___1;
          case_102___1: /* CIL Label */ 
          {
#line 1720
          print_fixed_field(*d, pf->f, buffer);
          }
#line 1721
          goto switch_break___1;
          case_115___1: /* CIL Label */ 
          {
#line 1723
          print_separated_field(*d, (uint8_t )s->quote, (uint8_t )s->type[1], pf->f,
                                buffer);
          }
#line 1724
          goto switch_break___1;
          case_98___0: /* CIL Label */ 
          {
#line 1726
          print_binary_field(*d, pf->f, buffer);
          }
#line 1727
          goto switch_break___1;
          switch_break___1: /* CIL Label */ ;
          }
#line 1730
          if (! o->print_empty) {
#line 1732
            f = field_start;
            {
#line 1733
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 1733
              if (! ((unsigned long )f < (unsigned long )write_pos)) {
#line 1733
                goto while_break___3;
              }
              {
#line 1735
              tmp___2 = strchr((char const   *)o->empty_chars, (int )*f);
              }
#line 1735
              if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 1737
                pf->empty = 0;
#line 1738
                f = write_pos;
              }
#line 1740
              f ++;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
#line 1743
          if ((int )*d == 101) {
#line 1743
            write_pos = field_start;
          }
#line 1744
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 1746
          writec((uint8_t )'%');
#line 1747
          writec(*d);
          }
#line 1748
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 1750
          if (! just_replaced) {
#line 1750
            d ++;
          }
        } else {
          {
#line 1753
          writec(*d);
#line 1754
          d ++;
          }
        }
#line 1758
        if (replacing) {
#line 1758
          if (! *d) {
#line 1760
            d = rep_pos;
#line 1761
            d ++;
#line 1762
            replacing = 0;
#line 1763
            if ((int )*rep_pos == 68) {
#line 1763
              goto _L;
            } else
#line 1763
            if ((int )*rep_pos == 67) {
              _L: /* CIL Label */ 
#line 1765
              if (write_pos - rep_start < (long )(pf->f)->length) {
                {
#line 1767
                while (1) {
                  while_continue___4: /* CIL Label */ ;
#line 1767
                  if (! (write_pos - rep_start < (long )(pf->f)->length)) {
#line 1767
                    goto while_break___4;
                  }
                  {
#line 1767
                  writec((uint8_t )' ');
                  }
                }
                while_break___4: /* CIL Label */ ;
                }
              } else
#line 1768
              if (write_pos - rep_start > (long )(pf->f)->length) {
#line 1770
                write_pos = rep_start + (pf->f)->length;
              }
            }
          }
        }
#line 1775
        if (just_replaced) {
#line 1775
          just_replaced = 0;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1778
      if ((int )justify == 2) {
#line 1780
        pf->justify_length = (int )(write_pos - data_start);
#line 1781
        if (pf->justify_length > max_justify_len) {
#line 1783
          max_justify_len = pf->justify_length;
        }
      }
      {
#line 1786
      writec((uint8_t )0);
      }
    }
#line 1788
    pf = pf->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1791
  pf = r->pf;
  {
#line 1796
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1796
    if (! ((unsigned long )pf != (unsigned long )((void *)0))) {
#line 1796
      goto while_break___5;
    }
#line 1798
    if ((pf->f)->o) {
#line 1798
      o = (pf->f)->o;
    } else {
#line 1798
      o = r->o;
    }
#line 1800
    if ((unsigned long )o != (unsigned long )no_output) {
#line 1802
      if (o->print_empty) {
#line 1804
        retval ++;
      } else
#line 1802
      if (! pf->empty) {
#line 1804
        retval ++;
      }
    }
#line 1807
    pf = pf->next;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1810
  pf = r->pf;
  {
#line 1812
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1812
    if ((unsigned long )pf != (unsigned long )((void *)0)) {
#line 1812
      if (! retval) {
#line 1812
        goto while_break___6;
      }
    } else {
#line 1812
      goto while_break___6;
    }
#line 1814
    if ((pf->f)->o) {
#line 1814
      o = (pf->f)->o;
    } else {
#line 1814
      o = r->o;
    }
#line 1816
    if ((unsigned long )o != (unsigned long )no_output) {
#line 1818
      separator = o->separator;
#line 1819
      indent = o->indent;
#line 1820
      if (o->print_empty) {
#line 1820
        goto _L___3;
      } else
#line 1820
      if (! pf->empty) {
        _L___3: /* CIL Label */ 
#line 1822
        if ((unsigned long )indent != (unsigned long )((void *)0)) {
#line 1824
          if (r->level) {
            {
#line 1827
            i___0 = get_indent_depth((r->level)->level);
            }
            {
#line 1828
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 1828
              tmp___3 = i___0;
#line 1828
              i___0 --;
#line 1828
              if (! tmp___3) {
#line 1828
                goto while_break___7;
              }
              {
#line 1828
              fputs((char const   */* __restrict  */)indent, (FILE */* __restrict  */)output_fp);
              }
            }
            while_break___7: /* CIL Label */ ;
            }
          } else {
            {
#line 1831
            fputs((char const   */* __restrict  */)indent, (FILE */* __restrict  */)output_fp);
#line 1832
            fputs((char const   */* __restrict  */)indent, (FILE */* __restrict  */)output_fp);
            }
          }
        }
#line 1835
        if ((int )justify != 1) {
#line 1835
          if ((int )justify != 2) {
#line 1835
            if (max_justify_len) {
#line 1835
              goto _L___0;
            } else {
#line 1835
              goto _L___2;
            }
          } else {
#line 1835
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 1835
        if ((int )justify == 2) {
          _L___0: /* CIL Label */ 
#line 1837
          i = max_justify_len - pf->justify_length;
#line 1838
          if (pf->justify_length > -1) {
#line 1838
            if (i) {
              {
#line 1840
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 1840
                if (! (i > 127)) {
#line 1840
                  goto while_break___8;
                }
                {
#line 1842
                justify_string[127] = (uint8_t )0;
#line 1843
                fputs((char const   */* __restrict  */)(justify_string), (FILE */* __restrict  */)output_fp);
#line 1844
                i -= 127;
                }
              }
              while_break___8: /* CIL Label */ ;
              }
              {
#line 1846
              justify_string[i] = (uint8_t )0;
#line 1847
              fputs((char const   */* __restrict  */)(justify_string), (FILE */* __restrict  */)output_fp);
#line 1848
              justify_string[i] = (uint8_t )' ';
              }
            }
          }
        }
        {
#line 1851
        fputs((char const   */* __restrict  */)pf->data, (FILE */* __restrict  */)output_fp);
        }
      }
#line 1853
      if ((unsigned long )pf->next != (unsigned long )((void *)0)) {
#line 1853
        if ((unsigned long )separator != (unsigned long )((void *)0)) {
          {
#line 1853
          fputs((char const   */* __restrict  */)separator, (FILE */* __restrict  */)output_fp);
          }
        }
      }
    }
#line 1855
    pf = pf->next;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1857
  return (retval);
}
}
#line 1865 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
struct print_field *make_print_list(struct include_field *fl , struct field *f ) 
{ 
  struct print_field *ret ;
  struct print_field *c ;
  struct field *n ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 1868
  ret = (struct print_field *)((void *)0);
#line 1868
  c = (struct print_field *)((void *)0);
#line 1871
  if ((unsigned long )fl == (unsigned long )((void *)0)) {
    {
#line 1873
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1873
      if (! ((unsigned long )f != (unsigned long )((void *)0))) {
#line 1873
        goto while_break;
      }
      {
#line 1875
      tmp___1 = strcmp((char const   *)f->name, "FILLER");
      }
#line 1875
      if (tmp___1 != 0) {
#line 1877
        if ((unsigned long )ret == (unsigned long )((void *)0)) {
          {
#line 1879
          tmp = xmalloc(sizeof(struct print_field ));
#line 1879
          ret = (struct print_field *)tmp;
#line 1880
          c = ret;
          }
        } else {
          {
#line 1883
          tmp___0 = xmalloc(sizeof(struct print_field ));
#line 1883
          c->next = (struct print_field *)tmp___0;
#line 1884
          c = c->next;
          }
        }
#line 1886
        c->f = f;
#line 1887
        c->next = (struct print_field *)((void *)0);
      }
#line 1889
      f = f->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1893
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1893
      if (! ((unsigned long )fl != (unsigned long )((void *)0))) {
#line 1893
        goto while_break___0;
      }
#line 1895
      n = const_field;
      {
#line 1897
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1897
        if ((unsigned long )n != (unsigned long )((void *)0)) {
          {
#line 1897
          tmp___2 = strcasecmp((char const   *)fl->name, (char const   *)n->name);
          }
#line 1897
          if (! (tmp___2 != 0)) {
#line 1897
            goto while_break___1;
          }
        } else {
#line 1897
          goto while_break___1;
        }
#line 1899
        n = n->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1902
      if ((unsigned long )n == (unsigned long )((void *)0)) {
#line 1904
        n = f;
        {
#line 1905
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1905
          if ((unsigned long )n != (unsigned long )((void *)0)) {
            {
#line 1905
            tmp___3 = strcasecmp((char const   *)fl->name, (char const   *)n->name);
            }
#line 1905
            if (! (tmp___3 != 0)) {
#line 1905
              goto while_break___2;
            }
          } else {
#line 1905
            goto while_break___2;
          }
#line 1907
          n = n->next;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 1911
      if ((unsigned long )n != (unsigned long )((void *)0)) {
#line 1913
        if ((unsigned long )ret == (unsigned long )((void *)0)) {
          {
#line 1915
          tmp___4 = xmalloc(sizeof(struct print_field ));
#line 1915
          ret = (struct print_field *)tmp___4;
#line 1916
          c = ret;
          }
        } else {
          {
#line 1919
          tmp___5 = xmalloc(sizeof(struct print_field ));
#line 1919
          c->next = (struct print_field *)tmp___5;
#line 1920
          c = c->next;
          }
        }
#line 1922
        c->f = n;
#line 1923
        c->next = (struct print_field *)((void *)0);
#line 1924
        fl->found = 1;
      }
#line 1926
      fl = fl->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1929
  return (ret);
}
}
#line 1934 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
int check_field_list(struct include_field *fl ) 
{ 
  int ret ;

  {
#line 1937
  ret = 0;
  {
#line 1939
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1939
    if (! ((unsigned long )fl != (unsigned long )((void *)0))) {
#line 1939
      goto while_break;
    }
#line 1941
    if (! fl->found) {
#line 1943
      if (! fl->reported) {
        {
#line 1943
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Field \'%s\' was not found in the current structure\n",
                program___0, fl->name);
        }
      }
#line 1944
      fl->reported = 1;
#line 1945
      ret ++;
    }
#line 1947
    fl = fl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1949
  return (ret);
}
}
#line 1952 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
void init_structure(struct structure *s , struct record *current_record , int length ,
                    uint8_t *buffer ) 
{ 
  struct record *r ;
  struct field *f ;
  struct replace *rep ;
  struct expression *e ;
  int list_errors ;
  uint8_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1959
  list_errors = 0;
#line 1961
  r = s->r;
  {
#line 1963
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1963
    if (! ((unsigned long )r != (unsigned long )((void *)0))) {
#line 1963
      goto while_break;
    }
#line 1965
    f = r->f;
    {
#line 1966
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1966
      if (! ((unsigned long )f != (unsigned long )((void *)0))) {
#line 1966
        goto while_break___0;
      }
#line 1968
      if (s->header) {
#line 1968
        if ((unsigned long )f->name == (unsigned long )((void *)0)) {
          {
#line 1969
          tmp = get_separated_field(f->position, (uint8_t )s->quote, s->type, buffer);
#line 1969
          f->name = xstrdup((char *)tmp);
          }
        }
      }
#line 1971
      rep = replace;
      {
#line 1972
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1972
        if (! ((unsigned long )rep != (unsigned long )((void *)0))) {
#line 1972
          goto while_break___1;
        }
        {
#line 1974
        tmp___0 = strcasecmp((char const   *)f->name, (char const   *)rep->field);
        }
#line 1974
        if (tmp___0 == 0) {
#line 1976
          f->rep = rep;
#line 1977
          rep->found = 1;
        }
#line 1979
        rep = rep->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1982
      e = expression;
      {
#line 1983
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1983
        if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 1983
          goto while_break___2;
        }
        {
#line 1985
        tmp___1 = strcasecmp((char const   *)f->name, (char const   *)e->field);
        }
#line 1985
        if (tmp___1 == 0) {
#line 1987
          e->found = 1;
        }
#line 1989
        e = e->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1992
      f = f->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1994
    r = r->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1997
  r = s->r;
  {
#line 1999
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1999
    if (! ((unsigned long )r != (unsigned long )((void *)0))) {
#line 1999
      goto while_break___3;
    }
#line 2001
    if ((unsigned long )r->o != (unsigned long )no_output) {
      {
#line 2001
      r->pf = make_print_list((r->o)->fl, r->f);
      }
    }
#line 2002
    r = r->next;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2005
  r = s->r;
  {
#line 2007
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2007
    if (! ((unsigned long )r != (unsigned long )((void *)0))) {
#line 2007
      goto while_break___4;
    }
    {
#line 2009
    tmp___2 = check_field_list((r->o)->fl);
    }
#line 2009
    if (tmp___2) {
#line 2009
      list_errors ++;
    }
#line 2010
    r = r->next;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2012
  if (list_errors) {
    {
#line 2012
    panic((char *)"Some fields from field list were not found in the current structure or constant values",
          s->name, (char *)((void *)0));
    }
  }
#line 2014
  rep = replace;
  {
#line 2015
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2015
    if (! ((unsigned long )rep != (unsigned long )((void *)0))) {
#line 2015
      goto while_break___5;
    }
#line 2017
    if (! rep->found) {
      {
#line 2017
      panic((char *)"Field to be replaced was not found in the current structure",
            rep->field, (char *)((void *)0));
      }
    }
#line 2018
    rep = rep->next;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2021
  e = expression;
  {
#line 2022
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 2022
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 2022
      goto while_break___6;
    }
#line 2024
    if (! e->found) {
      {
#line 2024
      panic((char *)"Field in expression was not found in the current structure",
            e->field, (char *)((void *)0));
      }
    }
#line 2025
    e = e->next;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 2027
  return;
}
}
#line 2029 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
void invalid_input(char *file , long lineno___0 , int strict , int length , int stype ) 
{ 


  {
#line 2032
  if (stype == 98) {
#line 2034
    if (strict) {
      {
#line 2036
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Invalid input block in file \'%s\', offset %lld",
              program___0, file, current_file_offset);
      }
#line 2037
      if (debug_lineno) {
        {
#line 2037
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)". Block was written to debug file");
        }
      }
      {
#line 2038
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
  } else {
    {
#line 2042
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Invalid input line in file \'%s\', line %ld, line length = %d",
            program___0, file, lineno___0, length);
    }
#line 2043
    if (debug_lineno) {
      {
#line 2043
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", line %ld in debug file",
              debug_lineno);
      }
    }
    {
#line 2044
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 2046
  if (strict) {
    {
#line 2046
    panic((char *)"Using option -l does not cause program to abort in case of invalid input",
          (char *)((void *)0), (char *)((void *)0));
    }
  }
#line 2047
  return;
}
}
#line 2050 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static int hash_scan_expression(struct expr_list **list , char *value , int casecmp ) 
{ 
  register struct expr_list *l ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2053
  tmp = hash(value, (size_t )0);
#line 2053
  l = *(list + tmp);
  }
  {
#line 2055
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2055
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 2055
      goto while_break;
    }
#line 2057
    if (casecmp) {
      {
#line 2059
      tmp___0 = strcasecmp((char const   *)l->value, (char const   *)value);
      }
#line 2059
      if (tmp___0 == 0) {
#line 2059
        return (1);
      }
    } else {
      {
#line 2062
      tmp___1 = strcmp((char const   *)l->value, (char const   *)value);
      }
#line 2062
      if (tmp___1 == 0) {
#line 2062
        return (1);
      }
    }
#line 2064
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2066
  return (0);
}
}
#line 2069 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static int hash_scan_expression_len(struct expr_list **list , char *value , int casecmp ,
                                    size_t comp_len ) 
{ 
  register struct expr_list *l ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2072
  tmp = hash(value, comp_len);
#line 2072
  l = *(list + tmp);
  }
  {
#line 2074
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2074
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 2074
      goto while_break;
    }
#line 2076
    if (casecmp) {
      {
#line 2078
      tmp___0 = strncasecmp((char const   *)l->value, (char const   *)value, (size_t )l->value_len);
      }
#line 2078
      if (tmp___0 == 0) {
#line 2078
        return (1);
      }
    } else {
      {
#line 2081
      tmp___1 = strncmp((char const   *)l->value, (char const   *)value, (size_t )l->value_len);
      }
#line 2081
      if (tmp___1 == 0) {
#line 2081
        return (1);
      }
    }
#line 2083
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2085
  return (0);
}
}
#line 2088 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
__inline static int scan_expression_list(struct expr_list *l , char *value , char op ,
                                         int casecmp ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 2091
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2091
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 2091
      goto while_break;
    }
    {
#line 2095
    if ((int )op == 94) {
#line 2095
      goto case_94;
    }
#line 2105
    if ((int )op == 33) {
#line 2105
      goto case_33;
    }
#line 2105
    if ((int )op == 61) {
#line 2105
      goto case_33;
    }
#line 2114
    if ((int )op == 126) {
#line 2114
      goto case_126;
    }
#line 2124
    if ((int )op == 63) {
#line 2124
      goto case_63;
    }
#line 2093
    goto switch_break;
    case_94: /* CIL Label */ 
#line 2096
    if (casecmp) {
      {
#line 2098
      tmp = strncasecmp((char const   *)l->value, (char const   *)value, (size_t )l->value_len);
      }
#line 2098
      if (tmp == 0) {
#line 2098
        return (1);
      }
    } else {
      {
#line 2101
      tmp___0 = strncmp((char const   *)l->value, (char const   *)value, (size_t )l->value_len);
      }
#line 2101
      if (tmp___0 == 0) {
#line 2101
        return (1);
      }
    }
#line 2103
    goto switch_break;
    case_33: /* CIL Label */ 
    case_61: /* CIL Label */ 
#line 2106
    if (casecmp) {
      {
#line 2108
      tmp___1 = strcasecmp((char const   *)l->value, (char const   *)value);
      }
#line 2108
      if (tmp___1 == 0) {
#line 2108
        return (1);
      }
    } else {
      {
#line 2111
      tmp___2 = strcmp((char const   *)l->value, (char const   *)value);
      }
#line 2111
      if (tmp___2 == 0) {
#line 2111
        return (1);
      }
    }
#line 2113
    goto switch_break;
    case_126: /* CIL Label */ 
#line 2115
    if (casecmp) {
      {
#line 2117
      tmp___3 = strcasestr((char const   *)value, (char const   *)l->value);
      }
#line 2117
      if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 2117
        return (1);
      }
    } else {
      {
#line 2120
      tmp___4 = strstr((char const   *)value, (char const   *)l->value);
      }
#line 2120
      if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 2120
        return (1);
      }
    }
#line 2122
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 2125
    tmp___5 = regexec((regex_t const   */* __restrict  */)(& l->reg), (char const   */* __restrict  */)value,
                      (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 2125
    if (tmp___5 == 0) {
#line 2125
      return (1);
    }
#line 2126
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2129
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2131
  return (0);
}
}
#line 2134 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static int full_scan_expression(struct expression *e , char *value , int casecmp ) 
{ 
  register int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 2137
  i = 0;
#line 2141
  if (e->fast_entries) {
    {
#line 2143
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2143
      if (! ((size_t )i < e->fast_entries)) {
#line 2143
        goto while_break;
      }
      {
#line 2145
      tmp = scan_expression_list(e->expr_hash[e->fast_expr_hash[i]], value, e->op,
                                 casecmp);
      }
#line 2145
      if (tmp) {
#line 2145
        return (1);
      }
#line 2146
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 2150
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2150
      if (! (i < 32771)) {
#line 2150
        goto while_break___0;
      }
      {
#line 2152
      tmp___0 = scan_expression_list(e->expr_hash[i], value, e->op, casecmp);
      }
#line 2152
      if (tmp___0) {
#line 2152
        return (1);
      }
#line 2153
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2156
  return (0);
}
}
#line 2162 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
int eval_expression(struct structure *s , struct record *r , int and , int invert ,
                    int casecmp , uint8_t *buffer ) 
{ 
  struct expression *e ;
  int retval ;
  int eq_found ;
  int prev_retval ;
  int loop_break ;
  int expression_count ;
  struct output *o ;
  size_t len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2165
  e = expression;
#line 2167
  retval = 0;
#line 2170
  loop_break = 0;
#line 2171
  expression_count = 0;
#line 2175
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 2175
    return (0);
  }
  {
#line 2177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2177
    if ((unsigned long )e != (unsigned long )((void *)0)) {
#line 2177
      if (! (! loop_break)) {
#line 2177
        goto while_break;
      }
    } else {
#line 2177
      goto while_break;
    }
#line 2179
    if ((unsigned long )e->f != (unsigned long )((void *)0)) {
#line 2182
      if ((e->f)->o) {
#line 2182
        o = (e->f)->o;
      } else {
#line 2182
        o = r->o;
      }
#line 2183
      if ((unsigned long )o != (unsigned long )no_output) {
#line 2183
        if (o->hex_cap) {
#line 2185
          bcd_to_ascii = bcd_to_ascii_cap;
#line 2186
          hex_to_ascii = hex_to_ascii_cap;
        } else {
#line 2189
          bcd_to_ascii = bcd_to_ascii_low;
#line 2190
          hex_to_ascii = hex_to_ascii_low;
        }
      } else {
#line 2189
        bcd_to_ascii = bcd_to_ascii_low;
#line 2190
        hex_to_ascii = hex_to_ascii_low;
      }
      {
#line 2194
      start_write();
      }
      {
#line 2197
      if ((int )s->type[0] == 102) {
#line 2197
        goto case_102;
      }
#line 2200
      if ((int )s->type[0] == 115) {
#line 2200
        goto case_115;
      }
#line 2203
      if ((int )s->type[0] == 98) {
#line 2203
        goto case_98;
      }
#line 2195
      goto switch_break;
      case_102: /* CIL Label */ 
      {
#line 2198
      print_fixed_field((uint8_t )'d', e->f, buffer);
      }
#line 2199
      goto switch_break;
      case_115: /* CIL Label */ 
      {
#line 2201
      print_separated_field((uint8_t )'d', (uint8_t )s->quote, (uint8_t )s->type[1],
                            e->f, buffer);
      }
#line 2202
      goto switch_break;
      case_98: /* CIL Label */ 
      {
#line 2204
      print_binary_field((uint8_t )'d', e->f, buffer);
      }
#line 2205
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 2207
      writec((uint8_t )0);
#line 2208
      prev_retval = retval;
#line 2209
      eq_found = 0;
      }
      {
#line 2213
      if ((int )e->op == 94) {
#line 2213
        goto case_94;
      }
#line 2223
      if ((int )e->op == 63) {
#line 2223
        goto case_63;
      }
#line 2223
      if ((int )e->op == 126) {
#line 2223
        goto case_63;
      }
#line 2226
      if ((int )e->op == 61) {
#line 2226
        goto case_61;
      }
#line 2229
      if ((int )e->op == 33) {
#line 2229
        goto case_33;
      }
#line 2211
      goto switch_break___0;
      case_94: /* CIL Label */ 
#line 2214
      len = e->exp_max_len;
#line 2215
      prev_retval = retval;
      {
#line 2216
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2216
        if (len >= e->exp_min_len) {
#line 2216
          if (! (prev_retval == retval)) {
#line 2216
            goto while_break___0;
          }
        } else {
#line 2216
          goto while_break___0;
        }
        {
#line 2218
        tmp = hash_scan_expression_len(e->expr_hash, (char *)write_buffer, casecmp,
                                       len);
#line 2218
        retval += tmp;
#line 2219
        len --;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2221
      goto switch_break___0;
      case_63: /* CIL Label */ 
      case_126: /* CIL Label */ 
      {
#line 2224
      tmp___0 = full_scan_expression(e, (char *)write_buffer, casecmp);
#line 2224
      retval += tmp___0;
      }
#line 2225
      goto switch_break___0;
      case_61: /* CIL Label */ 
      {
#line 2227
      tmp___1 = hash_scan_expression(e->expr_hash, (char *)write_buffer, casecmp);
#line 2227
      retval += tmp___1;
      }
#line 2228
      goto switch_break___0;
      case_33: /* CIL Label */ 
      {
#line 2230
      tmp___2 = hash_scan_expression(e->expr_hash, (char *)write_buffer, casecmp);
      }
#line 2230
      if (tmp___2 == 0) {
#line 2230
        retval ++;
      }
#line 2231
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 2234
    if (! and) {
#line 2234
      if (retval) {
#line 2236
        loop_break = 1;
      }
    }
#line 2238
    expression_count ++;
#line 2239
    if (and) {
#line 2239
      if (retval != expression_count) {
#line 2241
        loop_break = 1;
      }
    }
#line 2243
    e = e->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2245
  if (and) {
#line 2247
    if (retval == expression_count) {
#line 2249
      retval = 1;
    } else {
#line 2252
      retval = 0;
    }
  }
#line 2255
  if (invert) {
#line 2255
    retval = ! retval;
  }
#line 2256
  return (retval);
}
}
#line 2260 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
void init_expression_list(struct record *r ) 
{ 
  struct expression *e ;
  struct field *f ;
  int exp_count ;
  int tmp ;

  {
#line 2264
  f = r->f;
#line 2265
  exp_count = 0;
#line 2267
  e = expression;
  {
#line 2269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2269
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 2269
      goto while_break;
    }
#line 2271
    e->f = (struct field *)((void *)0);
#line 2272
    e = e->next;
#line 2273
    exp_count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2276
  e = expression;
  {
#line 2278
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2278
    if ((unsigned long )f != (unsigned long )((void *)0)) {
#line 2278
      if (! exp_count) {
#line 2278
        goto while_break___0;
      }
    } else {
#line 2278
      goto while_break___0;
    }
#line 2280
    e = expression;
    {
#line 2281
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2281
      if ((unsigned long )e != (unsigned long )((void *)0)) {
#line 2281
        if (! exp_count) {
#line 2281
          goto while_break___1;
        }
      } else {
#line 2281
        goto while_break___1;
      }
#line 2283
      if ((unsigned long )e->f == (unsigned long )((void *)0)) {
        {
#line 2283
        tmp = strcasecmp((char const   *)f->name, (char const   *)e->field);
        }
#line 2283
        if (tmp == 0) {
#line 2285
          e->f = f;
#line 2286
          exp_count --;
        }
      }
#line 2288
      e = e->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2290
    f = f->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2292
  return;
}
}
#line 2294 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
void open_debug_file(int stype ) 
{ 
  __pid_t tmp ;

  {
  {
#line 2297
  tmp = getpid();
#line 2297
  sprintf((char */* __restrict  */)(debug_file), (char const   */* __restrict  */)"ffe_error_%d.log",
          tmp);
  }
#line 2298
  if (stype == 98) {
    {
#line 2300
    debug_fp = xfopenb(debug_file, (char *)"w");
    }
  } else {
    {
#line 2303
    debug_fp = xfopen(debug_file, (char *)"w");
    }
  }
#line 2305
  return;
}
}
#line 2308 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
void write_debug_file(uint8_t *line , int len , int stype ) 
{ 


  {
#line 2311
  if ((unsigned long )debug_fp == (unsigned long )((void *)0)) {
    {
#line 2311
    open_debug_file(stype);
    }
  }
#line 2313
  if (stype == 98) {
    {
#line 2315
    fwrite((void const   */* __restrict  */)line, (size_t )len, (size_t )1, (FILE */* __restrict  */)debug_fp);
    }
  } else
#line 2316
  if ((unsigned long )line != (unsigned long )((void *)0)) {
    {
#line 2318
    fputs((char const   */* __restrict  */)line, (FILE */* __restrict  */)debug_fp);
#line 2319
    fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)debug_fp);
    }
  }
#line 2321
  debug_lineno ++;
#line 2322
  return;
}
}
#line 2324 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
static void select_output(struct output *o ) 
{ 


  {
#line 2327
  if ((unsigned long )o->ofp != (unsigned long )((void *)0)) {
#line 2329
    output_fp = o->ofp;
#line 2330
    output_file = o->output_file;
  } else {
#line 2333
    output_fp = default_output_fp;
#line 2334
    output_file = default_output_file;
  }
#line 2336
  return;
}
}
#line 2340 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/execute.c"
void execute(struct structure *s , int strict , int expression_and , int expression_invert ,
             int expression_case , int debug ) 
{ 
  uint8_t *input_line ;
  struct record *r ;
  struct record *prev_record ;
  int length ;
  int header_printed ;
  int fields_printed ;
  int first_line ;
  int i ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 2344
  r = (struct record *)((void *)0);
#line 2345
  prev_record = (struct record *)((void *)0);
#line 2347
  header_printed = 0;
#line 2349
  first_line = 1;
#line 2352
  current_file_lineno = 0L;
#line 2353
  current_total_lineno = 0L;
#line 2354
  current_file_name = files->name;
#line 2355
  headers = s->header;
#line 2357
  i = 0;
  {
#line 2358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2358
    if (! (i < 128)) {
#line 2358
      goto while_break;
    }
#line 2358
    tmp = i;
#line 2358
    i ++;
#line 2358
    justify_string[tmp] = (uint8_t )' ';
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2360
  reset_levels(0, 1024);
#line 2362
  tmp___0 = xmalloc((size_t )write_buffer_size);
#line 2362
  write_buffer = (uint8_t *)tmp___0;
#line 2363
  write_buffer_end = write_buffer + (write_buffer_size - 1);
  }
#line 2365
  if ((int )s->type[0] == 98) {
#line 2365
    if (read_buffer_size == 524288UL) {
      {
#line 2367
      read_buffer_size = (size_t )s->max_record_len;
#line 2368
      tmp___1 = xrealloc((void *)read_buffer, read_buffer_size);
#line 2368
      read_buffer = (uint8_t *)tmp___1;
      }
    }
  }
  {
#line 2371
  select_output(s->o);
#line 2372
  print_text(s, (struct record *)((void *)0), (s->o)->file_header);
  }
  {
#line 2373
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 2373
    input_line = get_input_line(& length, (int )s->type[0]);
    }
#line 2373
    if (! ((unsigned long )input_line != (unsigned long )((void *)0))) {
#line 2373
      goto while_break___0;
    }
    {
#line 2375
    prev_record = r;
#line 2376
    r = select_record(s, length, input_line);
    }
#line 2377
    if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 2379
      if (debug) {
        {
#line 2379
        write_debug_file(input_line, length, (int )s->type[0]);
        }
      }
      {
#line 2380
      invalid_input(current_file_name, current_file_lineno, strict, length, (int )s->type[0]);
      }
#line 2381
      if ((int )s->type[0] == 98) {
#line 2383
        last_consumed = (size_t )1;
      }
    } else {
#line 2388
      last_consumed = (size_t )r->length;
#line 2389
      if (first_line) {
        {
#line 2391
        init_structure(s, r, length, input_line);
        }
      }
#line 2394
      if ((unsigned long )expression != (unsigned long )((void *)0)) {
#line 2394
        if ((unsigned long )prev_record != (unsigned long )r) {
          {
#line 2396
          init_expression_list(r);
          }
        } else
#line 2394
        if ((unsigned long )prev_record == (unsigned long )((void *)0)) {
          {
#line 2396
          init_expression_list(r);
          }
        }
      }
#line 2399
      if (! first_line) {
#line 2399
        goto _L___3;
      } else
#line 2399
      if (! headers) {
        _L___3: /* CIL Label */ 
#line 2399
        if ((unsigned long )r->o != (unsigned long )no_output) {
#line 2401
          if ((unsigned long )r->pf == (unsigned long )((void *)0)) {
#line 2401
            if ((r->o)->no_data == 1) {
#line 2401
              goto _L___1;
            } else {
#line 2401
              goto _L___2;
            }
          } else
          _L___2: /* CIL Label */ 
#line 2401
          if ((unsigned long )r->pf != (unsigned long )((void *)0)) {
#line 2401
            goto _L___1;
          } else
#line 2401
          if ((unsigned long )r->o == (unsigned long )raw) {
            _L___1: /* CIL Label */ 
            {
#line 2403
            update_field_positions(s->type, (uint8_t )s->quote, r->arb_length, r->f,
                                   length, input_line);
            }
#line 2404
            if ((unsigned long )expression == (unsigned long )((void *)0)) {
#line 2404
              goto _L___0;
            } else {
              {
#line 2404
              tmp___5 = eval_expression(s, r, expression_and, expression_invert, expression_case,
                                        input_line);
              }
#line 2404
              if (tmp___5) {
                _L___0: /* CIL Label */ 
#line 2406
                if ((unsigned long )r->o == (unsigned long )raw) {
#line 2408
                  if ((int )s->type[0] == 98) {
#line 2408
                    tmp___2 = r->length;
                  } else {
#line 2408
                    tmp___2 = length;
                  }
                  {
#line 2408
                  print_raw(tmp___2, input_line, (int )s->type[0]);
                  }
                } else {
                  {
#line 2411
                  select_output(r->o);
#line 2412
                  print_level_before(prev_record, r);
                  }
#line 2413
                  if ((unsigned long )(r->o)->header != (unsigned long )((void *)0)) {
#line 2413
                    if (! header_printed) {
                      {
#line 2415
                      header_printed = print_header(s, r);
                      }
                    }
                  }
#line 2417
                  if ((unsigned long )(r->o)->indent != (unsigned long )((void *)0)) {
#line 2417
                    if ((unsigned long )(r->o)->record_header != (unsigned long )((void *)0)) {
#line 2418
                      if ((unsigned long )r->level != (unsigned long )((void *)0)) {
#line 2418
                        tmp___3 = (r->level)->level;
                      } else {
#line 2418
                        tmp___3 = 1;
                      }
                      {
#line 2418
                      print_indent((r->o)->indent, tmp___3);
                      }
                    }
                  }
                  {
#line 2419
                  print_text(s, r, (r->o)->record_header);
#line 2420
                  fields_printed = print_fields(s, r, input_line);
                  }
#line 2421
                  if (fields_printed) {
#line 2421
                    goto _L;
                  } else
#line 2421
                  if ((r->o)->print_empty) {
                    _L: /* CIL Label */ 
#line 2423
                    if ((unsigned long )(r->o)->indent != (unsigned long )((void *)0)) {
#line 2423
                      if ((unsigned long )(r->o)->record_trailer != (unsigned long )((void *)0)) {
#line 2424
                        if ((unsigned long )r->level != (unsigned long )((void *)0)) {
#line 2424
                          tmp___4 = (r->level)->level;
                        } else {
#line 2424
                          tmp___4 = 1;
                        }
                        {
#line 2424
                        print_indent((r->o)->indent, tmp___4);
                        }
                      }
                    }
                    {
#line 2425
                    print_text(s, r, (r->o)->record_trailer);
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 2431
      if (first_line) {
#line 2431
        first_line = 0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2434
  print_level_end(r);
#line 2435
  select_output(s->o);
#line 2436
  print_text(s, r, (s->o)->file_trailer);
#line 2437
  free((void *)write_buffer);
  }
#line 2438
  if ((unsigned long )debug_fp != (unsigned long )((void *)0)) {
    {
#line 2438
    fclose(debug_fp);
    }
  }
#line 2439
  return;
}
}
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/xmalloc.c"
void *xmalloc(size_t size ) 
{ 
  register void *value ;
  void *tmp ;

  {
  {
#line 35
  tmp = malloc(size);
#line 35
  value = tmp;
  }
#line 36
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    {
#line 36
    panic((char *)"Out of memory", (char *)((void *)0), (char *)((void *)0));
    }
  }
#line 37
  return (value);
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/xmalloc.c"
char *xstrdup(char *str ) 
{ 
  register char *ret ;
  char *tmp ;

  {
  {
#line 43
  tmp = strdup((char const   *)str);
#line 43
  ret = tmp;
  }
#line 44
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 44
    panic((char *)"Out of memory", (char *)((void *)0), (char *)((void *)0));
    }
  }
#line 45
  return (ret);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/xmalloc.c"
void *xrealloc(void *ptr , size_t size ) 
{ 
  register void *value ;
  void *tmp ;

  {
  {
#line 51
  tmp = realloc(ptr, size);
#line 51
  value = tmp;
  }
#line 52
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    {
#line 52
    panic((char *)"Out of memory", (char *)((void *)0), (char *)((void *)0));
    }
  }
#line 53
  return (value);
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/xmalloc.c"
FILE *xxfopen(char *name , char *mode , char bin_asc ) 
{ 
  register FILE *ret ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 61
  ret = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)mode);
  }
#line 62
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 62
    tmp = __errno_location();
#line 62
    tmp___0 = strerror(*tmp);
#line 62
    panic((char *)"Error in opening file", name, tmp___0);
    }
  }
#line 68
  return (ret);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/xmalloc.c"
FILE *xfopen(char *name , char *mode ) 
{ 
  FILE *tmp ;

  {
  {
#line 74
  tmp = xxfopen(name, mode, (char )'a');
  }
#line 74
  return (tmp);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/xmalloc.c"
FILE *xfopenb(char *name , char *mode ) 
{ 
  FILE *tmp ;

  {
  {
#line 80
  tmp = xxfopen(name, mode, (char )'b');
  }
#line 80
  return (tmp);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/xmalloc.c"
void file_to_text(FILE *fp___0 ) 
{ 


  {
#line 89
  return;
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/level.c"
static struct level *levels[1025]  ;
#line 29 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/level.c"
static int last_level  =    0;
#line 30 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/level.c"
static int max_level  =    0;
#line 32 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/level.c"
void reset_levels(int start , int stop ) 
{ 
  int tmp ;

  {
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! (start <= stop)) {
#line 35
      goto while_break;
    }
#line 35
    tmp = start;
#line 35
    start ++;
#line 35
    levels[tmp] = (struct level *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
#line 36
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/level.c"
static void print_level_text(struct level *l , uint8_t *buffer ) 
{ 
  register uint8_t *text ;

  {
#line 41
  text = buffer;
#line 43
  if (! buffer) {
#line 43
    return;
  }
  {
#line 44
  start_write();
  }
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! *text) {
#line 45
      goto while_break;
    }
#line 47
    if ((int )*text == 37) {
#line 47
      if (*(text + 1)) {
#line 49
        text ++;
        {
#line 52
        if ((int )*text == 103) {
#line 52
          goto case_103;
        }
#line 55
        if ((int )*text == 109) {
#line 55
          goto case_109;
        }
#line 58
        if ((int )*text == 37) {
#line 58
          goto case_37;
        }
#line 61
        goto switch_default;
        case_103: /* CIL Label */ 
#line 53
        if (l) {
          {
#line 53
          writes((uint8_t *)l->group_name);
          }
        }
#line 54
        goto switch_break;
        case_109: /* CIL Label */ 
#line 56
        if (l) {
          {
#line 56
          writes((uint8_t *)l->element_name);
          }
        }
#line 57
        goto switch_break;
        case_37: /* CIL Label */ 
        {
#line 59
        writec((uint8_t )'%');
        }
#line 60
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 62
        writec((uint8_t )'%');
#line 63
        writec(*text);
        }
#line 64
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      } else {
        {
#line 68
        writec(*text);
        }
      }
    } else {
      {
#line 68
      writec(*text);
      }
    }
#line 70
    text ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 72
  flush_write();
  }
#line 73
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/level.c"
static void print_level(struct level *l , uint8_t *buffer , uint8_t *indent , int indent_level ) 
{ 


  {
#line 80
  if (! l) {
#line 80
    return;
  }
#line 82
  if (indent) {
    {
#line 82
    print_indent(indent, indent_level);
    }
  }
  {
#line 84
  print_level_text(l, buffer);
  }
#line 85
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/level.c"
int get_indent_depth(int level_count ) 
{ 
  register int i ;
  register int depth ;
  int tmp ;

  {
#line 90
  depth = 1;
#line 92
  i = 1;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! (i <= level_count)) {
#line 92
      goto while_break;
    }
#line 92
    if ((unsigned long )levels[i] != (unsigned long )((void *)0)) {
#line 92
      tmp = (levels[i])->indent_count;
    } else {
#line 92
      tmp = 0;
    }
#line 92
    depth += tmp;
#line 92
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  return (depth);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/level.c"
void print_level_before(struct record *prev_record , struct record *curr_record ) 
{ 
  int pl ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 102
  pl = 0;
#line 104
  if (! curr_record->level) {
#line 106
    if (prev_record) {
#line 106
      if (prev_record->level) {
#line 106
        if ((prev_record->level)->element_name) {
          {
#line 107
          tmp = get_indent_depth((prev_record->level)->level);
#line 107
          print_level(prev_record->level, (prev_record->o)->element_trailer, (prev_record->o)->indent,
                      tmp - 1);
          }
        }
      }
    }
#line 108
    return;
  }
#line 111
  if ((curr_record->level)->level > max_level) {
#line 111
    max_level = (curr_record->level)->level;
  }
#line 112
  last_level = (curr_record->level)->level;
#line 114
  if (prev_record) {
#line 114
    if (prev_record->level) {
#line 114
      pl = (prev_record->level)->level;
    }
  }
#line 116
  if (last_level == pl) {
#line 118
    if ((prev_record->level)->element_name) {
      {
#line 119
      tmp___0 = get_indent_depth(pl);
#line 119
      print_level(prev_record->level, (prev_record->o)->element_trailer, (prev_record->o)->indent,
                  tmp___0 - 1);
      }
    }
#line 121
    if ((prev_record->level)->group_name) {
#line 121
      if ((curr_record->level)->group_name) {
        {
#line 121
        tmp___3 = strcmp((char const   *)(prev_record->level)->group_name, (char const   *)(curr_record->level)->group_name);
        }
#line 121
        if (tmp___3 != 0) {
#line 121
          goto _L___0;
        } else {
#line 121
          goto _L___2;
        }
      } else {
#line 121
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 121
    if (! (prev_record->level)->group_name) {
#line 121
      goto _L___0;
    } else
#line 121
    if (! (curr_record->level)->group_name) {
      _L___0: /* CIL Label */ 
#line 125
      if ((prev_record->level)->group_name) {
        {
#line 126
        tmp___1 = get_indent_depth(pl - 1);
#line 126
        print_level(prev_record->level, (prev_record->o)->group_trailer, (prev_record->o)->indent,
                    tmp___1);
        }
      }
#line 127
      if ((curr_record->level)->group_name) {
        {
#line 128
        tmp___2 = get_indent_depth(last_level - 1);
#line 128
        print_level(curr_record->level, (curr_record->o)->group_header, (curr_record->o)->indent,
                    tmp___2);
        }
      }
    }
  } else
#line 130
  if (last_level > pl) {
#line 132
    if ((curr_record->level)->group_name) {
      {
#line 133
      tmp___4 = get_indent_depth(pl);
#line 133
      print_level(curr_record->level, (curr_record->o)->group_header, (curr_record->o)->indent,
                  tmp___4);
      }
    }
  } else
#line 134
  if (last_level < pl) {
#line 136
    i = pl;
    {
#line 137
    while (1) {
      while_continue: /* CIL Label */ ;
#line 137
      if (! (i >= last_level)) {
#line 137
        goto while_break;
      }
#line 139
      if (levels[i]) {
#line 139
        if ((levels[i])->element_name) {
          {
#line 140
          tmp___5 = get_indent_depth(i);
#line 140
          print_level(levels[i], (curr_record->o)->element_trailer, (curr_record->o)->indent,
                      tmp___5 - 1);
          }
        }
      }
#line 141
      if (i > last_level) {
#line 141
        if (levels[i]) {
#line 141
          if ((levels[i])->group_name) {
            {
#line 142
            tmp___6 = get_indent_depth(i - 1);
#line 142
            print_level(levels[i], (curr_record->o)->group_trailer, (curr_record->o)->indent,
                        tmp___6);
            }
          }
        }
      }
#line 143
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 146
    i ++;
#line 148
    if (levels[i]) {
#line 148
      if ((levels[i])->group_name) {
#line 148
        if ((curr_record->level)->group_name) {
          {
#line 148
          tmp___9 = strcmp((char const   *)(levels[i])->group_name, (char const   *)(curr_record->level)->group_name);
          }
#line 148
          if (tmp___9 != 0) {
#line 148
            goto _L___4;
          } else {
#line 148
            goto _L___6;
          }
        } else {
#line 148
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
#line 148
      if (! (levels[i])->group_name) {
#line 148
        goto _L___4;
      } else
#line 148
      if (! (curr_record->level)->group_name) {
        _L___4: /* CIL Label */ 
#line 151
        if ((levels[i])->group_name) {
          {
#line 152
          tmp___7 = get_indent_depth(i - 1);
#line 152
          print_level(levels[i], (curr_record->o)->group_trailer, (curr_record->o)->indent,
                      tmp___7);
          }
        }
#line 153
        if ((curr_record->level)->group_name) {
          {
#line 154
          tmp___8 = get_indent_depth(last_level - 1);
#line 154
          print_level(curr_record->level, (curr_record->o)->group_header, (curr_record->o)->indent,
                      tmp___8);
          }
        }
      }
    }
    {
#line 157
    reset_levels(last_level + 1, max_level);
    }
  }
#line 160
  levels[last_level] = curr_record->level;
#line 162
  if ((curr_record->level)->element_name) {
    {
#line 163
    tmp___10 = get_indent_depth(last_level);
#line 163
    print_level(curr_record->level, (curr_record->o)->element_header, (curr_record->o)->indent,
                tmp___10 - 1);
    }
  }
#line 164
  return;
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/level.c"
void print_level_end(struct record *last ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 171
  i = last_level;
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (i >= 1)) {
#line 173
      goto while_break;
    }
#line 175
    if ((levels[i])->element_name) {
      {
#line 176
      tmp = get_indent_depth(i);
#line 176
      print_level(levels[i], (last->o)->element_trailer, (last->o)->indent, tmp - 1);
      }
    }
#line 177
    if ((levels[i])->group_name) {
      {
#line 178
      tmp___0 = get_indent_depth(i - 1);
#line 178
      print_level(levels[i], (last->o)->group_trailer, (last->o)->indent, tmp___0);
      }
    }
#line 179
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  return;
}
}
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 322 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.h"
void problem(char *msg , char *info , char *syserror ) ;
#line 367
int check_system_endianess(void) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
static char *program___1  =    (char *)"ffe";
#line 50 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
static char *version  =    (char *)"0.3.4";
#line 56 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
static char *host  =    (char *)"x86_64-unknown-linux-gnu";
#line 62 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
static char *build_date  =    (char *)"2016-03-03";
#line 68 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
static char *email_address  =    (char *)"tjsa@iki.fi";
#line 73 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
static char short_opts[23]  = 
#line 73
  {      (char )'c',      (char )':',      (char )'s',      (char )':', 
        (char )'o',      (char )':',      (char )'p',      (char )':', 
        (char )'f',      (char )':',      (char )'e',      (char )':', 
        (char )'r',      (char )':',      (char )'l',      (char )'?', 
        (char )'V',      (char )'a',      (char )'v',      (char )'d', 
        (char )'I',      (char )'X',      (char )'\000'};
#line 76 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
static struct option long_opts[16]  = 
#line 76
  {      {"configuration", 1, (int *)((void *)0), 'c'}, 
        {"structure", 1, (int *)((void *)0), 's'}, 
        {"output", 1, (int *)((void *)0), 'o'}, 
        {"print", 1, (int *)((void *)0), 'p'}, 
        {"field-list", 1, (int *)((void *)0), 'f'}, 
        {"loose", 0, (int *)((void *)0), 'l'}, 
        {"expression", 1, (int *)((void *)0), 'e'}, 
        {"help", 0, (int *)((void *)0), '?'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {"and", 0, (int *)((void *)0), 'a'}, 
        {"invert-match", 0, (int *)((void *)0), 'v'}, 
        {"replace", 1, (int *)((void *)0), 'r'}, 
        {"debug", 0, (int *)((void *)0), 'd'}, 
        {"info", 0, (int *)((void *)0), 'I'}, 
        {"casecmp", 0, (int *)((void *)0), 'X'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 100 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
int system_endianess  =    0;
#line 101 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
int max_binary_record_length  =    0;
#line 102 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
char *ffe_open  =    (char *)((void *)0);
#line 107 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
struct structure *structure  =    (struct structure *)((void *)0);
#line 108 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
struct output *output  =    (struct output *)((void *)0);
#line 109 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
struct expression *expression  =    (struct expression *)((void *)0);
#line 110 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
struct lookup *lookup  =    (struct lookup *)((void *)0);
#line 111 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
struct replace *replace  =    (struct replace *)((void *)0);
#line 112 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
struct field *const_field  =    (struct field *)((void *)0);
#line 115 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
struct output dummy_no  ;
#line 116 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
struct output *no_output  =    & dummy_no;
#line 117 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
struct output dummy_raw  ;
#line 118 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
struct output *raw  =    & dummy_raw;
#line 120 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
void panic(char *msg , char *info , char *syserror ) 
{ 


  {
#line 123
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 123
    if ((unsigned long )syserror == (unsigned long )((void *)0)) {
      {
#line 125
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
              program___1, msg);
      }
    } else {
#line 123
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 126
  if ((unsigned long )info != (unsigned long )((void *)0)) {
#line 126
    if ((unsigned long )syserror == (unsigned long )((void *)0)) {
      {
#line 128
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
              program___1, msg, info);
      }
    } else {
#line 126
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 129
  if ((unsigned long )info != (unsigned long )((void *)0)) {
#line 129
    if ((unsigned long )syserror != (unsigned long )((void *)0)) {
      {
#line 131
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s; %s\n",
              program___1, msg, info, syserror);
      }
    } else {
#line 129
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 132
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 132
    if ((unsigned long )syserror != (unsigned long )((void *)0)) {
      {
#line 134
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s; %s\n",
              program___1, msg, syserror);
      }
    }
  }
  {
#line 136
  exit(1);
  }
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
void problem(char *msg , char *info , char *syserror ) 
{ 


  {
#line 142
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 142
    if ((unsigned long )syserror == (unsigned long )((void *)0)) {
      {
#line 144
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
              program___1, msg);
      }
    } else {
#line 142
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 145
  if ((unsigned long )info != (unsigned long )((void *)0)) {
#line 145
    if ((unsigned long )syserror == (unsigned long )((void *)0)) {
      {
#line 147
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
              program___1, msg, info);
      }
    } else {
#line 145
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 148
  if ((unsigned long )info != (unsigned long )((void *)0)) {
#line 148
    if ((unsigned long )syserror != (unsigned long )((void *)0)) {
      {
#line 150
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s; %s\n",
              program___1, msg, info, syserror);
      }
    } else {
#line 148
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 151
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 151
    if ((unsigned long )syserror != (unsigned long )((void *)0)) {
      {
#line 153
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s; %s\n",
              program___1, msg, syserror);
      }
    }
  }
#line 155
  return;
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
char *get_default_rc_name(void) 
{ 
  char *home ;
  char *result ;
  char *file ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 166
  file = (char *)".fferc";
#line 169
  result = (char *)((void *)0);
#line 170
  home = getenv("HOME");
  }
#line 181
  if ((unsigned long )home != (unsigned long )((void *)0)) {
    {
#line 183
    tmp = strlen((char const   *)home);
#line 183
    tmp___0 = strlen((char const   *)file);
#line 183
    tmp___1 = strlen("/");
#line 183
    tmp___2 = xmalloc(((tmp + tmp___0) + tmp___1) + 2UL);
#line 183
    result = (char *)tmp___2;
#line 184
    strcpy((char */* __restrict  */)result, (char const   */* __restrict  */)home);
#line 185
    strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"/");
#line 186
    strcat((char */* __restrict  */)result, (char const   */* __restrict  */)file);
    }
  } else {
#line 189
    result = file;
  }
#line 191
  return (result);
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
void help(FILE *stream ) 
{ 
  char *rc ;
  char *tmp ;

  {
  {
#line 197
  tmp = get_default_rc_name();
#line 197
  rc = tmp;
#line 198
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"Usage: %s [OPTION]...\n\n",
          program___1);
#line 200
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-c, --configuration=FILE\n");
#line 201
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\t\tRead configuration from FILE, default is \'%s\'.\n",
          rc);
#line 202
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-s, --structure=STRUCTURE\n");
#line 203
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\t\tUse structure STRUCTURE for input file, suppresses guessing.\n");
#line 204
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-p, --print=FORMAT\n");
#line 205
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\t\tUse output format FORMAT for printing.\n");
#line 206
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-o, --output=NAME\n");
#line 207
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\t\tWrite output to NAME instead of standard output.\n");
#line 208
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-f, --field-list=LIST\n");
#line 209
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\t\tPrint only fields and constants listed in comma separated list LIST.\n");
#line 210
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-e, --expression=EXPRESSION\n");
#line 211
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\t\tPrint only those records for which the EXPRESSION evaluates to true.\n");
#line 212
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-a, --and\n");
#line 213
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\t\tExpressions are combined with logical and, default is logical or.\n");
#line 214
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-X, --casecmp\n");
#line 215
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\t\tExpressions are evaluated case insensitive.\n");
#line 216
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-v, --invert-match\n");
#line 217
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\t\tPrint only those records which don\'t match the expression.\n");
#line 218
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-l, --loose\n");
#line 219
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\t\tAn invalid input line does not cause %s to abort.\n",
          program___1);
#line 220
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-r, --replace=FIELD=VALUE\n");
#line 221
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\t\tReplace FIELDs contents with VALUE in output.\n");
#line 222
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-d, --debug\n");
#line 223
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\t\tWrite invalid input lines to error log.\n");
#line 224
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-I, --info\n");
#line 225
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\t\tShow the structure information and exit.\n");
#line 226
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-?, --help\n");
#line 227
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\t\tDisplay this help and exit.\n");
#line 228
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"-V, --version\n");
#line 260
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\t\tShow version and exit.\n");
#line 261
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\nAll remaining arguments are names of input files;\n");
#line 262
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"if no input files are specified, then the standard input is read.\n");
#line 263
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\nSend bug reports to %s.\n",
          email_address);
#line 264
  free((void *)rc);
  }
#line 265
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
void usage(int opt ) 
{ 


  {
  {
#line 270
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown option \'-%c\'\n",
          (int )((char )opt));
#line 271
  help(stderr);
  }
#line 272
  return;
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
void print_version(void) 
{ 


  {
  {
#line 277
  printf((char const   */* __restrict  */)"%s version %s\n%s %s\n", program___1, version,
         build_date, host);
#line 278
  printf((char const   */* __restrict  */)"Copyright (c) 2007 Timo Savinen\n\n");
#line 279
  printf((char const   */* __restrict  */)"This is free software; see the source for copying conditions.\n");
#line 280
  printf((char const   */* __restrict  */)"There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n");
  }
#line 281
  return;
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
size_t hash(char *str , size_t len ) 
{ 
  register unsigned long h ;
  int c ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 286
  h = 5381UL;
#line 289
  if (len > 0UL) {
    {
#line 291
    while (1) {
      while_continue: /* CIL Label */ ;
#line 291
      tmp = str;
#line 291
      str ++;
#line 291
      c = (int )*tmp;
#line 291
      if (c != 0) {
#line 291
        if (! (len > 0UL)) {
#line 291
          goto while_break;
        }
      } else {
#line 291
        goto while_break;
      }
#line 293
      h = ((h << 5) + h) + (unsigned long )c;
#line 294
      len --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 298
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 298
      tmp___0 = str;
#line 298
      str ++;
#line 298
      c = (int )*tmp___0;
#line 298
      if (! (c != 0)) {
#line 298
        goto while_break___0;
      }
#line 300
      h = ((h << 5) + h) + (unsigned long )c;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 303
  return (h % 32771UL);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
struct output *search_output(char *name ) 
{ 
  struct output *o ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 311
  o = output;
#line 313
  tmp = strcmp((char const   *)name, "no");
  }
#line 313
  if (tmp == 0) {
#line 313
    return (no_output);
  }
  {
#line 314
  tmp___0 = strcmp((char const   *)name, "raw");
  }
#line 314
  if (tmp___0 == 0) {
#line 314
    return (raw);
  }
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! ((unsigned long )o != (unsigned long )((void *)0))) {
#line 316
      goto while_break;
    }
    {
#line 318
    tmp___1 = strcmp((char const   *)name, (char const   *)o->name);
    }
#line 318
    if (tmp___1 == 0) {
#line 318
      return (o);
    }
#line 319
    o = o->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 321
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Unknown output \'%s\'\n",
          program___1, name);
  }
#line 322
  return ((struct output *)((void *)0));
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
struct record *find_record(struct structure *s , char *name ) 
{ 
  struct record *ret ;
  int tmp ;

  {
#line 329
  ret = s->r;
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    if (! ((unsigned long )ret != (unsigned long )((void *)0))) {
#line 331
      goto while_break;
    }
    {
#line 333
    tmp = strcmp((char const   *)ret->name, (char const   *)name);
    }
#line 333
    if (tmp == 0) {
#line 333
      return (ret);
    }
#line 334
    ret = ret->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 336
  return ((struct record *)((void *)0));
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
struct structure *find_structure(char *name ) 
{ 
  struct structure *s ;
  int tmp ;

  {
#line 343
  s = structure;
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 345
    if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 345
      goto while_break;
    }
    {
#line 347
    tmp = strcmp((char const   *)s->name, (char const   *)name);
    }
#line 347
    if (tmp == 0) {
#line 347
      return (s);
    }
#line 348
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  return ((struct structure *)((void *)0));
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
void check_rc(char *use_output ) 
{ 
  struct structure *s ;
  struct output *o ;
  struct record *r ;
  struct record *fr ;
  struct field *f ;
  struct lookup *l ;
  int several_records ;
  int errors ;
  int ordinal ;
  int field_count_first ;
  char num[64] ;
  int tmp ;

  {
#line 363
  several_records = 0;
#line 364
  errors = 0;
#line 369
  s = structure;
#line 370
  o = output;
#line 372
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 374
    errors ++;
#line 375
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: No structure definitions in rc-file\n",
            program___1);
    }
  }
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 378
    if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 378
      goto while_break;
    }
#line 380
    if ((unsigned long )use_output != (unsigned long )((void *)0)) {
      {
#line 382
      free((void *)s->output_name);
#line 383
      s->output_name = xstrdup(use_output);
      }
    }
#line 386
    if ((unsigned long )s->output_name == (unsigned long )((void *)0)) {
#line 388
      s->output_name = (char *)"default";
    }
    {
#line 391
    s->o = search_output(s->output_name);
#line 392
    s->max_record_len = 0;
    }
#line 393
    if ((unsigned long )s->o == (unsigned long )((void *)0)) {
#line 393
      errors ++;
    }
#line 394
    r = s->r;
#line 395
    if ((unsigned long )r == (unsigned long )((void *)0)) {
      {
#line 397
      errors ++;
#line 398
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: No records in structure \'%s\'\n",
              program___1, s->name);
      }
    } else
#line 401
    if ((unsigned long )r->next != (unsigned long )((void *)0)) {
#line 401
      several_records = 1;
    } else {
#line 401
      several_records = 0;
    }
#line 403
    if (s->quote) {
#line 403
      if ((int )s->type[0] == 115) {
#line 405
        if ((int )s->quote == (int )s->type[1]) {
          {
#line 407
          errors ++;
#line 408
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Quotation and separator cannot be the same character, structure \'%s\'\n",
                  program___1, s->name);
          }
        }
      }
    }
#line 411
    if (s->header) {
#line 411
      if ((int )s->type[0] != 115) {
        {
#line 413
        errors ++;
#line 414
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Headers are valid only in separated input, structure \'%s\'\n",
                program___1, s->name);
        }
      }
    }
#line 417
    field_count_first = 0;
    {
#line 419
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 419
      if (! ((unsigned long )r != (unsigned long )((void *)0))) {
#line 419
        goto while_break___0;
      }
#line 421
      if ((unsigned long )r->output_name == (unsigned long )((void *)0)) {
#line 421
        goto _L;
      } else
#line 421
      if ((unsigned long )use_output != (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 423
        if ((unsigned long )r->output_name != (unsigned long )((void *)0)) {
          {
#line 423
          free((void *)r->output_name);
          }
        }
#line 424
        r->output_name = s->output_name;
#line 425
        r->o = s->o;
      } else {
        {
#line 428
        r->o = search_output(r->output_name);
        }
#line 429
        if ((unsigned long )r->o == (unsigned long )((void *)0)) {
#line 429
          errors ++;
        }
      }
#line 432
      if (several_records) {
#line 432
        if ((int )s->type[0] == 98) {
#line 432
          if ((unsigned long )r->i == (unsigned long )((void *)0)) {
            {
#line 434
            errors ++;
#line 435
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Every record in a binary multi-record structure must have an id, structure \'%s\', record \'%s\'\n",
                    program___1, s->name, r->name);
            }
          }
        }
      }
#line 438
      if ((unsigned long )r->fields_from != (unsigned long )((void *)0)) {
#line 440
        if ((unsigned long )r->f != (unsigned long )((void *)0)) {
          {
#line 442
          errors ++;
#line 443
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: field and fields-from are mutually exclusive, structure \'%s\', record \'%s\'\n",
                  program___1, s->name, r->name);
          }
        }
        {
#line 445
        fr = find_record(s, r->fields_from);
        }
#line 446
        if ((unsigned long )fr != (unsigned long )((void *)0)) {
#line 448
          r->f = fr->f;
        } else {
          {
#line 451
          errors ++;
#line 452
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: No record named as \'%s\' in structure \'%s\'\n",
                  program___1, r->fields_from, s->name);
          }
        }
      }
#line 456
      f = r->f;
#line 457
      if ((unsigned long )f == (unsigned long )((void *)0)) {
        {
#line 459
        errors ++;
#line 460
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: No fields in record \'%s\'\n",
                program___1, r->name);
        }
      }
#line 462
      r->length = 0;
#line 463
      ordinal = 1;
      {
#line 464
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 464
        if (! ((unsigned long )f != (unsigned long )((void *)0))) {
#line 464
          goto while_break___1;
        }
#line 466
        if ((int )s->type[0] == 102) {
#line 468
          f->position = r->length;
#line 469
          f->bposition = r->length;
#line 470
          r->length += f->length;
        } else
#line 466
        if ((int )s->type[0] == 98) {
#line 468
          f->position = r->length;
#line 469
          f->bposition = r->length;
#line 470
          r->length += f->length;
        } else {
#line 473
          f->position = ordinal;
#line 474
          (r->length) ++;
#line 475
          if (s->header) {
#line 477
            if ((unsigned long )r == (unsigned long )s->r) {
#line 479
              field_count_first ++;
            }
          }
        }
#line 484
        if (! s->header) {
#line 484
          if ((unsigned long )f->name == (unsigned long )((void *)0)) {
            {
#line 486
            sprintf((char */* __restrict  */)(num), (char const   */* __restrict  */)"%d",
                    ordinal);
#line 487
            f->name = xstrdup(num);
            }
          }
        }
#line 490
        if ((int )s->type[0] == 98) {
#line 490
          if (f->length < 1) {
            {
#line 492
            errors ++;
#line 493
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: The field \'%s\' must have length in binary structure \'%s\' record \'%s\'\n",
                    program___1, f->name, s->name, r->name);
            }
          }
        }
#line 496
        if ((int )s->type[0] == 102) {
#line 496
          if (f->length < 1) {
#line 498
            if (f->next) {
              {
#line 500
              errors ++;
#line 501
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: The field \'%s\' must have length in fixed length structure \'%s\' record \'%s\'\n",
                      program___1, f->name, s->name, r->name);
              }
            } else {
#line 504
              r->arb_length = 1;
            }
          }
        }
#line 508
        if ((unsigned long )f->lookup_table_name != (unsigned long )((void *)0)) {
#line 510
          l = lookup;
          {
#line 512
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 512
            if ((unsigned long )l != (unsigned long )((void *)0)) {
#line 512
              if (! ((unsigned long )f->lookup == (unsigned long )((void *)0))) {
#line 512
                goto while_break___2;
              }
            } else {
#line 512
              goto while_break___2;
            }
            {
#line 514
            tmp = strcmp((char const   *)l->name, (char const   *)f->lookup_table_name);
            }
#line 514
            if (tmp == 0) {
#line 516
              f->lookup = l;
            }
#line 518
            l = l->next;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 521
          if ((unsigned long )f->lookup == (unsigned long )((void *)0)) {
            {
#line 523
            errors ++;
#line 524
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: No lookup table named as \'%s\'\n",
                    program___1, f->lookup_table_name);
            }
          }
        }
#line 528
        if ((unsigned long )f->output_name != (unsigned long )((void *)0)) {
#line 528
          if ((unsigned long )use_output == (unsigned long )((void *)0)) {
            {
#line 530
            f->o = search_output(f->output_name);
            }
#line 531
            if ((unsigned long )f->o == (unsigned long )((void *)0)) {
#line 531
              errors ++;
            }
#line 532
            if ((unsigned long )f->o == (unsigned long )raw) {
              {
#line 533
              errors ++;
#line 534
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Field cannot have output \'raw\', field \'%s\'\n",
                      program___1, f->name);
              }
            }
          }
        }
#line 538
        f = f->next;
#line 539
        ordinal ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 542
      if (r->length > s->max_record_len) {
#line 542
        s->max_record_len = r->length;
      }
#line 543
      if ((int )s->type[0] == 98) {
#line 543
        if (s->max_record_len > max_binary_record_length) {
#line 543
          max_binary_record_length = s->max_record_len;
        }
      }
#line 545
      if (s->header) {
#line 545
        if (r->length != field_count_first) {
          {
#line 547
          errors ++;
#line 548
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: All records in separated structure with header must have equal count of fields, structure \'%s\'\n",
                  program___1, s->name);
          }
        }
      }
#line 550
      r = r->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 552
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 555
  if ((unsigned long )o == (unsigned long )((void *)0)) {
    {
#line 557
    errors ++;
#line 558
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: No output definitions in rc-file\n",
            program___1);
    }
  }
  {
#line 561
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 561
    if (! ((unsigned long )o != (unsigned long )((void *)0))) {
#line 561
      goto while_break___3;
    }
#line 563
    if ((unsigned long )o->lookup == (unsigned long )((void *)0)) {
#line 563
      o->lookup = o->data;
    }
#line 564
    if ((unsigned long )o->output_file != (unsigned long )((void *)0)) {
#line 566
      if ((int )*(o->output_file + 0) == 45) {
#line 566
        if ((int )*(o->output_file + 1) == 0) {
          {
#line 568
          o->ofp = stdout;
#line 569
          free((void *)o->output_file);
#line 570
          o->output_file = (char *)"(stdout)";
          }
        } else {
          {
#line 573
          o->ofp = xfopen(o->output_file, (char *)"w");
          }
        }
      } else {
        {
#line 573
        o->ofp = xfopen(o->output_file, (char *)"w");
        }
      }
    }
#line 576
    o = o->next;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 579
  if (errors) {
    {
#line 581
    panic((char *)"Errors in rc-file", (char *)((void *)0), (char *)((void *)0));
    }
  }
#line 583
  return;
}
}
#line 585 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
void add_replace(char *optarg___0 ) 
{ 
  char *op_pos ;
  struct replace *r ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 591
  op_pos = strchr((char const   *)optarg___0, '=');
  }
#line 591
  if ((unsigned long )op_pos == (unsigned long )((void *)0)) {
    {
#line 593
    panic((char *)"Replace expression must contain =-character", optarg___0, (char *)((void *)0));
    }
  }
#line 596
  *op_pos = (char)0;
#line 598
  r = replace;
#line 600
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    {
#line 602
    tmp = xmalloc(sizeof(struct replace ));
#line 602
    replace = (struct replace *)tmp;
#line 603
    replace->next = (struct replace *)((void *)0);
#line 604
    r = replace;
    }
  } else {
    {
#line 607
    while (1) {
      while_continue: /* CIL Label */ ;
#line 607
      if (! ((unsigned long )r->next != (unsigned long )((void *)0))) {
#line 607
        goto while_break;
      }
#line 607
      r = r->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 608
    tmp___0 = xmalloc(sizeof(struct replace ));
#line 608
    r->next = (struct replace *)tmp___0;
#line 609
    r = r->next;
#line 610
    r->next = (struct replace *)((void *)0);
    }
  }
  {
#line 613
  r->field = xstrdup(optarg___0);
#line 614
  op_pos ++;
#line 615
  tmp___1 = xstrdup(op_pos);
#line 615
  r->value = (uint8_t *)tmp___1;
#line 616
  r->found = 0;
  }
#line 617
  return;
}
}
#line 622 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
static void add_expression_to_list(struct expr_list **list , char *value ) 
{ 
  size_t h ;
  size_t tmp ;
  register struct expr_list *e ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 625
  tmp = hash(value, (size_t )0);
#line 625
  h = tmp;
#line 626
  e = *(list + h);
  }
#line 628
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    {
#line 630
    tmp___0 = xmalloc(sizeof(struct expr_list ));
#line 630
    e = (struct expr_list *)tmp___0;
#line 631
    *(list + h) = e;
    }
  } else {
    {
#line 634
    while (1) {
      while_continue: /* CIL Label */ ;
#line 634
      if (! ((unsigned long )e->next != (unsigned long )((void *)0))) {
#line 634
        goto while_break;
      }
#line 634
      e = e->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 635
    tmp___1 = xmalloc(sizeof(struct expr_list ));
#line 635
    e->next = (struct expr_list *)tmp___1;
#line 636
    e = e->next;
    }
  }
  {
#line 638
  e->value = xstrdup(value);
#line 639
  tmp___2 = strlen((char const   *)e->value);
#line 639
  e->value_len = (int )tmp___2;
#line 640
  e->next = (struct expr_list *)((void *)0);
  }
#line 641
  return;
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
static void read_expression_file(struct expr_list **list , char *file ) 
{ 
  FILE *fp___0 ;
  register int ccount___0 ;
  size_t line_len ;
  char *line ;
  void *tmp ;
  __ssize_t tmp___0 ;

  {
  {
#line 649
  line_len = (size_t )1024;
#line 650
  tmp = xmalloc(line_len);
#line 650
  line = (char *)tmp;
#line 652
  fp___0 = xfopen(file, (char *)"r");
  }
  {
#line 654
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 657
    tmp___0 = getline((char **/* __restrict  */)(& line), (size_t */* __restrict  */)(& line_len),
                      (FILE */* __restrict  */)fp___0);
#line 657
    ccount___0 = (int )tmp___0;
    }
#line 667
    if (ccount___0 > 1) {
      {
#line 669
      *(line + (ccount___0 - 1)) = (char)0;
#line 670
      add_expression_to_list(list, line);
      }
    }
#line 654
    if (! (ccount___0 != -1)) {
#line 654
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 674
  fclose(fp___0);
#line 675
  free((void *)line);
  }
#line 676
  return;
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
static void init_expr_hash(struct expr_list **list ) 
{ 
  register int i ;
  int tmp ;

  {
#line 681
  i = 0;
  {
#line 683
  while (1) {
    while_continue: /* CIL Label */ ;
#line 683
    if (! (i < 32771)) {
#line 683
      goto while_break;
    }
#line 683
    tmp = i;
#line 683
    i ++;
#line 683
    *(list + tmp) = (struct expr_list *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
#line 684
  return;
}
}
#line 687 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
void add_expression(char *optarg___0 ) 
{ 
  char *op_pos ;
  char op ;
  struct expression *e ;
  struct expression *last ;
  int found ;
  char *value_file ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 691
  op = (char)0;
#line 694
  found = 0;
#line 698
  op_pos = strchr((char const   *)optarg___0, '?');
  }
#line 698
  if ((unsigned long )op_pos != (unsigned long )((void *)0)) {
#line 701
    op = (char )'?';
  } else {
    {
#line 705
    op_pos = strchr((char const   *)optarg___0, '=');
    }
#line 705
    if ((unsigned long )op_pos != (unsigned long )((void *)0)) {
#line 707
      op = (char )'=';
    } else {
      {
#line 708
      op_pos = strchr((char const   *)optarg___0, '^');
      }
#line 708
      if ((unsigned long )op_pos != (unsigned long )((void *)0)) {
#line 710
        op = (char )'^';
      } else {
        {
#line 711
        op_pos = strchr((char const   *)optarg___0, '~');
        }
#line 711
        if ((unsigned long )op_pos != (unsigned long )((void *)0)) {
#line 713
          op = (char )'~';
        } else {
          {
#line 714
          op_pos = strchr((char const   *)optarg___0, '!');
          }
#line 714
          if ((unsigned long )op_pos != (unsigned long )((void *)0)) {
#line 716
            op = (char )'!';
          } else {
            {
#line 719
            panic((char *)"Expression must contain an operator: =,^,~,? or !", optarg___0,
                  (char *)((void *)0));
            }
          }
        }
      }
    }
  }
#line 722
  *op_pos = (char)0;
#line 724
  e = expression;
#line 726
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    {
#line 728
    tmp = xmalloc(sizeof(struct expression ));
#line 728
    expression = (struct expression *)tmp;
#line 729
    expression->next = (struct expression *)((void *)0);
#line 730
    e = expression;
#line 731
    e->field = xstrdup(optarg___0);
#line 732
    e->exp_min_len = (size_t )0;
#line 733
    e->exp_max_len = (size_t )0;
#line 734
    e->fast_entries = (size_t )0;
#line 735
    init_expr_hash(e->expr_hash);
    }
  } else {
    {
#line 738
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 740
      tmp___0 = strcasecmp((char const   *)optarg___0, (char const   *)e->field);
      }
#line 740
      if (tmp___0 == 0) {
#line 740
        if ((int )e->op == (int )op) {
#line 742
          found = 1;
        } else {
#line 745
          last = e;
#line 746
          e = e->next;
        }
      } else {
#line 745
        last = e;
#line 746
        e = e->next;
      }
#line 738
      if ((unsigned long )e != (unsigned long )((void *)0)) {
#line 738
        if (! (! found)) {
#line 738
          goto while_break;
        }
      } else {
#line 738
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 751
    if (! found) {
      {
#line 753
      tmp___1 = xmalloc(sizeof(struct expression ));
#line 753
      last->next = (struct expression *)tmp___1;
#line 754
      e = last->next;
#line 755
      e->next = (struct expression *)((void *)0);
#line 756
      e->field = xstrdup(optarg___0);
#line 757
      e->exp_min_len = (size_t )0;
#line 758
      e->exp_max_len = (size_t )0;
#line 759
      e->fast_entries = (size_t )0;
#line 760
      init_expr_hash(e->expr_hash);
      }
    }
  }
  {
#line 764
  op_pos ++;
#line 765
  tmp___2 = strstr((char const   *)op_pos, "file:");
  }
#line 765
  if ((unsigned long )tmp___2 == (unsigned long )op_pos) {
    {
#line 767
    value_file = expand_home(op_pos + 5);
#line 768
    read_expression_file(e->expr_hash, value_file);
#line 769
    free((void *)value_file);
    }
  } else {
    {
#line 772
    add_expression_to_list(e->expr_hash, op_pos);
    }
  }
#line 774
  e->found = 0;
#line 775
  e->op = op;
#line 776
  return;
}
}
#line 778 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
static void init_expression(void) 
{ 
  struct expression *e ;
  register struct expr_list *l ;
  register int i ;
  int rc ;
  int min_init ;
  size_t buflen ;
  char *errbuf ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 781
  e = expression;
  {
#line 788
  while (1) {
    while_continue: /* CIL Label */ ;
#line 788
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 788
      goto while_break;
    }
#line 790
    i = 0;
#line 791
    min_init = 0;
    {
#line 792
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 792
      if (! (i < 32771)) {
#line 792
        goto while_break___0;
      }
#line 794
      l = e->expr_hash[i];
#line 796
      if ((unsigned long )l != (unsigned long )((void *)0)) {
#line 796
        if (e->fast_entries <= 61UL) {
#line 796
          tmp = e->fast_entries;
#line 796
          (e->fast_entries) ++;
#line 796
          e->fast_expr_hash[tmp] = (size_t )i;
        }
      }
      {
#line 798
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 798
        if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 798
          goto while_break___1;
        }
#line 800
        if (! min_init) {
#line 800
          min_init = 1;
#line 800
          e->exp_min_len = (size_t )l->value_len;
        }
#line 801
        if ((size_t )l->value_len < e->exp_min_len) {
#line 801
          e->exp_min_len = (size_t )l->value_len;
        }
#line 802
        if ((size_t )l->value_len > e->exp_max_len) {
#line 802
          e->exp_max_len = (size_t )l->value_len;
        }
#line 805
        if ((int )e->op == 63) {
          {
#line 807
          rc = regcomp((regex_t */* __restrict  */)(& l->reg), (char const   */* __restrict  */)l->value,
                       1 | (((1 << 1) << 1) << 1));
          }
#line 808
          if (rc) {
            {
#line 810
            buflen = regerror(rc, (regex_t const   */* __restrict  */)(& l->reg),
                              (char */* __restrict  */)((void *)0), (size_t )0);
#line 811
            tmp___0 = xmalloc(buflen + 1UL);
#line 811
            errbuf = (char *)tmp___0;
#line 812
            regerror(rc, (regex_t const   */* __restrict  */)(& l->reg), (char */* __restrict  */)errbuf,
                     buflen);
#line 813
            panic((char *)"Error in regular expression", l->value, errbuf);
            }
          }
        }
#line 817
        l = l->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 819
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 821
    if (e->fast_entries > 61UL) {
#line 821
      e->fast_entries = (size_t )0;
    }
#line 822
    e = e->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 824
  return;
}
}
#line 827 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
void set_env(char *name , char *value ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 830
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 830
    return;
  } else
#line 830
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 830
    return;
  }
  {
#line 832
  tmp___1 = setenv((char const   *)name, (char const   *)value, 0);
  }
#line 832
  if (tmp___1 != 0) {
    {
#line 832
    tmp = __errno_location();
#line 832
    tmp___0 = strerror(*tmp);
#line 832
    problem((char *)"Cannot set environment", name, tmp___0);
    }
  }
#line 845
  return;
}
}
#line 852 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
void environment(char *structure___0 , char *format , char *ofile ) 
{ 
  struct input_file *f ;
  char *file_names ;
  size_t files_len ;
  size_t used ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 855
  f = files;
#line 857
  files_len = (size_t )1024;
#line 857
  used = (size_t )0;
#line 859
  set_env((char *)"FFE_STRUCTURE", structure___0);
#line 860
  set_env((char *)"FFE_OUTPUT", ofile);
#line 861
  set_env((char *)"FFE_FORMAT", format);
#line 862
  set_env((char *)"FFE_FIRST_FILE", f->name);
#line 863
  tmp = xmalloc(files_len);
#line 863
  file_names = (char *)tmp;
#line 864
  *(file_names + 0) = (char)0;
  }
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 865
    if (! ((unsigned long )f != (unsigned long )((void *)0))) {
#line 865
      goto while_break;
    }
    {
#line 867
    tmp___0 = strlen((char const   *)f->name);
#line 867
    used += tmp___0 + 1UL;
    }
#line 868
    if (used > files_len) {
      {
#line 870
      files_len *= 2UL;
#line 871
      tmp___1 = xrealloc((void *)file_names, files_len);
#line 871
      file_names = (char *)tmp___1;
      }
    }
    {
#line 873
    strcat((char */* __restrict  */)file_names, (char const   */* __restrict  */)f->name);
    }
#line 874
    if ((unsigned long )f->next != (unsigned long )((void *)0)) {
      {
#line 874
      strcat((char */* __restrict  */)file_names, (char const   */* __restrict  */)" ");
      }
    }
#line 875
    f = f->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 877
  set_env((char *)"FFE_FILES", file_names);
#line 878
  free((void *)file_names);
  }
#line 879
  return;
}
}
#line 883 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/ffe.c"
int main(int argc , char **argv ) 
{ 
  int opt ;
  int strict ;
  int debug ;
  int info ;
  int expression_and ;
  int expression_invert ;
  int expression_casecmp ;
  struct structure *s ;
  char *structure_to_use ;
  char *output_to_use ;
  char *config_to_use ;
  char *ofile_to_use ;
  char *field_list ;
  struct sigaction act ;
  int tmp ;

  {
  {
#line 887
  strict = 1;
#line 888
  debug = 0;
#line 889
  info = 0;
#line 890
  expression_and = 0;
#line 891
  expression_invert = 0;
#line 892
  expression_casecmp = 0;
#line 893
  s = (struct structure *)((void *)0);
#line 894
  structure_to_use = (char *)((void *)0);
#line 895
  output_to_use = (char *)((void *)0);
#line 896
  config_to_use = (char *)((void *)0);
#line 897
  ofile_to_use = (char *)((void *)0);
#line 898
  field_list = (char *)((void *)0);
#line 902
  sigemptyset(& act.sa_mask);
#line 903
  act.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 904
  act.sa_flags = 2;
#line 905
  sigaction(17, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
  }
  {
#line 909
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 909
    opt = getopt_long(argc, (char * const  *)argv, (char const   *)(short_opts), (struct option  const  *)(long_opts),
                      (int *)((void *)0));
    }
#line 909
    if (! (opt != -1)) {
#line 909
      goto while_break;
    }
    {
#line 916
    if (opt == 99) {
#line 916
      goto case_99;
    }
#line 925
    if (opt == 115) {
#line 925
      goto case_115;
    }
#line 934
    if (opt == 112) {
#line 934
      goto case_112;
    }
#line 943
    if (opt == 102) {
#line 943
      goto case_102;
    }
#line 952
    if (opt == 111) {
#line 952
      goto case_111;
    }
#line 961
    if (opt == 101) {
#line 961
      goto case_101;
    }
#line 964
    if (opt == 114) {
#line 964
      goto case_114;
    }
#line 967
    if (opt == 97) {
#line 967
      goto case_97;
    }
#line 970
    if (opt == 88) {
#line 970
      goto case_88;
    }
#line 973
    if (opt == 100) {
#line 973
      goto case_100;
    }
#line 976
    if (opt == 118) {
#line 976
      goto case_118;
    }
#line 979
    if (opt == 108) {
#line 979
      goto case_108;
    }
#line 982
    if (opt == 63) {
#line 982
      goto case_63;
    }
#line 986
    if (opt == 86) {
#line 986
      goto case_86;
    }
#line 990
    if (opt == 73) {
#line 990
      goto case_73;
    }
#line 993
    goto switch_default;
    case_99: /* CIL Label */ 
#line 917
    if ((unsigned long )config_to_use == (unsigned long )((void *)0)) {
      {
#line 919
      config_to_use = xstrdup(optarg);
      }
    } else {
      {
#line 922
      panic((char *)"Only one -c option allowed", (char *)((void *)0), (char *)((void *)0));
      }
    }
#line 924
    goto switch_break;
    case_115: /* CIL Label */ 
#line 926
    if ((unsigned long )structure_to_use == (unsigned long )((void *)0)) {
      {
#line 928
      structure_to_use = xstrdup(optarg);
      }
    } else {
      {
#line 931
      panic((char *)"Only one -s option allowed", (char *)((void *)0), (char *)((void *)0));
      }
    }
#line 933
    goto switch_break;
    case_112: /* CIL Label */ 
#line 935
    if ((unsigned long )output_to_use == (unsigned long )((void *)0)) {
      {
#line 937
      output_to_use = xstrdup(optarg);
      }
    } else {
      {
#line 940
      panic((char *)"Only one -p option allowed", (char *)((void *)0), (char *)((void *)0));
      }
    }
#line 942
    goto switch_break;
    case_102: /* CIL Label */ 
#line 944
    if ((unsigned long )field_list == (unsigned long )((void *)0)) {
      {
#line 946
      field_list = xstrdup(optarg);
      }
    } else {
      {
#line 949
      panic((char *)"Only one -f option allowed", (char *)((void *)0), (char *)((void *)0));
      }
    }
#line 951
    goto switch_break;
    case_111: /* CIL Label */ 
#line 953
    if ((unsigned long )ofile_to_use == (unsigned long )((void *)0)) {
      {
#line 955
      ofile_to_use = xstrdup(optarg);
      }
    } else {
      {
#line 958
      panic((char *)"Only one -o option allowed", (char *)((void *)0), (char *)((void *)0));
      }
    }
#line 960
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 962
    add_expression(optarg);
    }
#line 963
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 965
    add_replace(optarg);
    }
#line 966
    goto switch_break;
    case_97: /* CIL Label */ 
#line 968
    expression_and = 1;
#line 969
    goto switch_break;
    case_88: /* CIL Label */ 
#line 971
    expression_casecmp = 1;
#line 972
    goto switch_break;
    case_100: /* CIL Label */ 
#line 974
    debug = 1;
#line 975
    goto switch_break;
    case_118: /* CIL Label */ 
#line 977
    expression_invert = ! expression_invert;
#line 978
    goto switch_break;
    case_108: /* CIL Label */ 
#line 980
    strict = 0;
#line 981
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 983
    help(stdout);
#line 984
    exit(0);
    }
#line 985
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 987
    print_version();
#line 988
    exit(0);
    }
#line 989
    goto switch_break;
    case_73: /* CIL Label */ 
#line 991
    info = 1;
#line 992
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 994
    usage(opt);
#line 995
    exit(1);
    }
#line 996
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1001
  if (optind < argc) {
    {
#line 1003
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1003
      if (! (optind < argc)) {
#line 1003
        goto while_break___0;
      }
      {
#line 1003
      tmp = optind;
#line 1003
      optind ++;
#line 1003
      set_input_file(*(argv + tmp));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 1006
    set_input_file((char *)"-");
    }
  }
#line 1009
  if ((unsigned long )config_to_use == (unsigned long )((void *)0)) {
    {
#line 1009
    config_to_use = get_default_rc_name();
    }
  }
  {
#line 1011
  environment(structure_to_use, output_to_use, ofile_to_use);
#line 1013
  system_endianess = check_system_endianess();
#line 1015
  parserc(config_to_use, field_list);
#line 1017
  check_rc(output_to_use);
#line 1019
  init_expression();
  }
#line 1021
  if (info) {
    {
#line 1023
    print_info();
#line 1024
    exit(0);
    }
  }
  {
#line 1027
  ffe_open = getenv("FFEOPEN");
  }
#line 1029
  if ((unsigned long )structure_to_use == (unsigned long )((void *)0)) {
    {
#line 1031
    open_input_file('b');
#line 1032
    structure_to_use = guess_binary_structure();
    }
#line 1033
    if ((unsigned long )structure_to_use == (unsigned long )((void *)0)) {
      {
#line 1035
      structure_to_use = guess_structure();
      }
    }
#line 1037
    if ((unsigned long )structure_to_use == (unsigned long )((void *)0)) {
      {
#line 1037
      panic((char *)"Structure cannot be guessed, use -s option", (char *)((void *)0),
            (char *)((void *)0));
      }
    }
    {
#line 1038
    s = find_structure(structure_to_use);
    }
  } else {
    {
#line 1041
    s = find_structure(structure_to_use);
    }
#line 1042
    if ((unsigned long )s != (unsigned long )((void *)0)) {
      {
#line 1044
      open_input_file((int )s->type[0]);
      }
    } else {
      {
#line 1047
      panic((char *)"No structure named as", structure_to_use, (char *)((void *)0));
      }
    }
  }
  {
#line 1051
  free((void *)config_to_use);
#line 1053
  set_output_file(ofile_to_use);
#line 1055
  execute(s, strict, expression_and, expression_invert, expression_casecmp, debug);
#line 1057
  close_output_file();
#line 1059
  exit(0);
  }
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/endian.c"
uint8_t be[4]  = {      (uint8_t )10,      (uint8_t )11,      (uint8_t )12,      (uint8_t )13};
#line 36 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/endian.c"
uint8_t le[4]  = {      (uint8_t )13,      (uint8_t )12,      (uint8_t )11,      (uint8_t )10};
#line 37 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/endian.c"
uint8_t pe[4]  = {      (uint8_t )11,      (uint8_t )10,      (uint8_t )13,      (uint8_t )12};
#line 39 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/endian.c"
size_t target_size  =    (size_t )16;
#line 40 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/endian.c"
uint8_t *target  =    (uint8_t *)((void *)0);
#line 42 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/endian.c"
int check_system_endianess(void) 
{ 
  uint32_t l ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 45
  l = (uint32_t )168496141;
#line 47
  if ((unsigned long )target == (unsigned long )((void *)0)) {
    {
#line 47
    tmp = xmalloc(target_size);
#line 47
    target = (uint8_t *)tmp;
    }
  }
  {
#line 49
  tmp___0 = memcmp((void const   *)(& l), (void const   *)(be), (size_t )4);
  }
#line 49
  if (tmp___0 == 0) {
#line 49
    return (1);
  }
  {
#line 50
  tmp___1 = memcmp((void const   *)(& l), (void const   *)(le), (size_t )4);
  }
#line 50
  if (tmp___1 == 0) {
#line 50
    return (3);
  }
  {
#line 51
  tmp___2 = memcmp((void const   *)(& l), (void const   *)(pe), (size_t )4);
  }
#line 51
  if (tmp___2 == 0) {
    {
#line 53
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Pdp endianness is not supported");
    }
  }
#line 55
  return (0);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/endian.c"
__inline uint8_t *betole_16(uint8_t *s ) 
{ 


  {
#line 65
  *(target + 0) = *(s + 1);
#line 66
  *(target + 1) = *(s + 0);
#line 67
  return (target);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/endian.c"
__inline uint8_t *letobe_16(uint8_t *s ) 
{ 
  uint8_t *tmp ;

  {
  {
#line 73
  tmp = betole_16(s);
  }
#line 73
  return (tmp);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/endian.c"
__inline uint8_t *betole_32(uint8_t *s ) 
{ 


  {
#line 79
  *(target + 0) = *(s + 3);
#line 80
  *(target + 1) = *(s + 2);
#line 81
  *(target + 2) = *(s + 1);
#line 82
  *(target + 3) = *(s + 0);
#line 83
  return (target);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/endian.c"
__inline uint8_t *letobe_32(uint8_t *s ) 
{ 
  uint8_t *tmp ;

  {
  {
#line 89
  tmp = betole_32(s);
  }
#line 89
  return (tmp);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/endian.c"
__inline uint8_t *betole_64(uint8_t *s ) 
{ 


  {
#line 95
  *(target + 0) = *(s + 7);
#line 96
  *(target + 1) = *(s + 6);
#line 97
  *(target + 2) = *(s + 5);
#line 98
  *(target + 3) = *(s + 4);
#line 99
  *(target + 4) = *(s + 3);
#line 100
  *(target + 5) = *(s + 2);
#line 101
  *(target + 6) = *(s + 1);
#line 102
  *(target + 7) = *(s + 0);
#line 103
  return (target);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/endian.c"
__inline uint8_t *letobe_64(uint8_t *s ) 
{ 
  uint8_t *tmp ;

  {
  {
#line 109
  tmp = betole_64(s);
  }
#line 109
  return (tmp);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/endian.c"
__inline uint8_t *betole_128(uint8_t *s ) 
{ 


  {
#line 115
  *(target + 0) = *(s + 15);
#line 116
  *(target + 1) = *(s + 14);
#line 117
  *(target + 2) = *(s + 13);
#line 118
  *(target + 3) = *(s + 12);
#line 119
  *(target + 4) = *(s + 11);
#line 120
  *(target + 5) = *(s + 10);
#line 121
  *(target + 6) = *(s + 9);
#line 122
  *(target + 7) = *(s + 8);
#line 123
  *(target + 8) = *(s + 7);
#line 124
  *(target + 9) = *(s + 6);
#line 125
  *(target + 10) = *(s + 5);
#line 126
  *(target + 11) = *(s + 4);
#line 127
  *(target + 12) = *(s + 3);
#line 128
  *(target + 13) = *(s + 2);
#line 129
  *(target + 14) = *(s + 1);
#line 130
  *(target + 15) = *(s + 0);
#line 131
  return (target);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/endian.c"
__inline uint8_t *letobe_128(uint8_t *s ) 
{ 
  uint8_t *tmp ;

  {
  {
#line 138
  tmp = betole_128(s);
  }
#line 138
  return (tmp);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/ffe-0.3.4/src/endian.c"
uint8_t *endian_and_align(uint8_t *s , int t_endian , int s_endian , int bytes ) 
{ 
  void *tmp ;
  uint8_t *tmp___0 ;
  uint8_t *tmp___1 ;
  uint8_t *tmp___2 ;
  uint8_t *tmp___3 ;
  uint8_t *tmp___4 ;
  uint8_t *tmp___5 ;
  uint8_t *tmp___6 ;
  uint8_t *tmp___7 ;

  {
#line 144
  if (t_endian == s_endian) {
#line 144
    goto _L;
  } else
#line 144
  if (bytes < 2) {
    _L: /* CIL Label */ 
#line 146
    if ((size_t )bytes > target_size) {
      {
#line 148
      while (1) {
        while_continue: /* CIL Label */ ;
#line 148
        if (! ((size_t )bytes > target_size)) {
#line 148
          goto while_break;
        }
#line 148
        target_size *= 2UL;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 149
      tmp = xrealloc((void *)target, target_size);
#line 149
      target = (uint8_t *)tmp;
      }
    }
    {
#line 151
    memcpy((void */* __restrict  */)target, (void const   */* __restrict  */)s, (size_t )bytes);
    }
#line 152
    return (target);
  }
#line 155
  if (t_endian == 1) {
#line 155
    if (s_endian == 3) {
#line 155
      if (bytes == 2) {
        {
#line 155
        tmp___0 = letobe_16(s);
        }
#line 155
        return (tmp___0);
      }
    }
  }
#line 156
  if (t_endian == 3) {
#line 156
    if (s_endian == 1) {
#line 156
      if (bytes == 2) {
        {
#line 156
        tmp___1 = betole_16(s);
        }
#line 156
        return (tmp___1);
      }
    }
  }
#line 157
  if (t_endian == 1) {
#line 157
    if (s_endian == 3) {
#line 157
      if (bytes == 4) {
        {
#line 157
        tmp___2 = letobe_32(s);
        }
#line 157
        return (tmp___2);
      }
    }
  }
#line 158
  if (t_endian == 3) {
#line 158
    if (s_endian == 1) {
#line 158
      if (bytes == 4) {
        {
#line 158
        tmp___3 = betole_32(s);
        }
#line 158
        return (tmp___3);
      }
    }
  }
#line 159
  if (t_endian == 1) {
#line 159
    if (s_endian == 3) {
#line 159
      if (bytes == 8) {
        {
#line 159
        tmp___4 = letobe_64(s);
        }
#line 159
        return (tmp___4);
      }
    }
  }
#line 160
  if (t_endian == 3) {
#line 160
    if (s_endian == 1) {
#line 160
      if (bytes == 8) {
        {
#line 160
        tmp___5 = betole_64(s);
        }
#line 160
        return (tmp___5);
      }
    }
  }
#line 161
  if (t_endian == 1) {
#line 161
    if (s_endian == 3) {
#line 161
      if (bytes == 16) {
        {
#line 161
        tmp___6 = letobe_128(s);
        }
#line 161
        return (tmp___6);
      }
    }
  }
#line 162
  if (t_endian == 3) {
#line 162
    if (s_endian == 1) {
#line 162
      if (bytes == 16) {
        {
#line 162
        tmp___7 = betole_128(s);
        }
#line 162
        return (tmp___7);
      }
    }
  }
  {
#line 163
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d %d %d\n",
          s_endian, t_endian, bytes);
#line 164
  panic((char *)"Internal endian error", (char *)((void *)0), (char *)((void *)0));
  }
#line 165
  return ((uint8_t *)((void *)0));
}
}
