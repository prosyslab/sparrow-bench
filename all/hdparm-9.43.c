/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 27 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/fibmap.c"
struct file_extent {
   __u64 byte_offset ;
   __u64 first_block ;
   __u64 last_block ;
   __u64 block_count ;
};
#line 130 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/fibmap.c"
struct fe_s {
   __u64 logical ;
   __u64 physical ;
   __u64 length ;
   __u64 reserved64[2] ;
   __u32 flags ;
   __u32 reserved32[3] ;
};
#line 139 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/fibmap.c"
struct fm_s {
   __u64 start ;
   __u64 length ;
   __u32 flags ;
   __u32 mapped_extents ;
   __u32 extent_count ;
   __u32 reserved ;
};
#line 148 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/fibmap.c"
struct fs_s {
   struct fm_s fm ;
   struct fe_s fe[8000] ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off_t __loff_t;
#line 44 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 35 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.h"
struct local_hd_big_geometry {
   unsigned char heads ;
   unsigned char sectors ;
   unsigned int cylinders ;
   unsigned long start ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.h"
struct local_hd_geometry {
   unsigned char heads ;
   unsigned char sectors ;
   unsigned short cylinders ;
   unsigned long start ;
};
#line 281 "/usr/include/linux/cdrom.h"
struct request_sense;
#line 281 "/usr/include/linux/cdrom.h"
struct cdrom_generic_command {
   unsigned char cmd[12] ;
   unsigned char *buffer ;
   unsigned int buflen ;
   int stat ;
   struct request_sense *sense ;
   unsigned char data_direction ;
   int quiet ;
   int timeout ;
   void *reserved[1] ;
};
#line 697 "/usr/include/linux/cdrom.h"
struct request_sense {
   __u8 error_code : 7 ;
   __u8 valid : 1 ;
   __u8 segment_number ;
   __u8 sense_key : 4 ;
   __u8 reserved2 : 1 ;
   __u8 ili : 1 ;
   __u8 reserved1 : 2 ;
   __u8 information[4] ;
   __u8 add_sense_len ;
   __u8 command_info[4] ;
   __u8 asc ;
   __u8 ascq ;
   __u8 fruc ;
   __u8 sks[3] ;
   __u8 asb[46] ;
};
#line 82 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.h"
struct ata_lba_regs {
   __u8 feat ;
   __u8 nsect ;
   __u8 lbal ;
   __u8 lbam ;
   __u8 lbah ;
};
#line 89 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.h"
struct ata_tf {
   __u8 dev ;
   __u8 command ;
   __u8 error ;
   __u8 status ;
   __u8 is_lba48 ;
   struct ata_lba_regs lob ;
   struct ata_lba_regs hob ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 119 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.h"
struct __anonstruct_lob_36 {
   unsigned int data : 1 ;
   unsigned int feat : 1 ;
   unsigned int lbal : 1 ;
   unsigned int nsect : 1 ;
   unsigned int lbam : 1 ;
   unsigned int lbah : 1 ;
   unsigned int dev : 1 ;
   unsigned int command : 1 ;
};
#line 119 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.h"
union __anonunion____missing_field_name_35 {
   unsigned int lob_all : 8 ;
   struct __anonstruct_lob_36 lob ;
};
#line 119 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.h"
struct __anonstruct_hob_38 {
   unsigned int data : 1 ;
   unsigned int feat : 1 ;
   unsigned int lbal : 1 ;
   unsigned int nsect : 1 ;
   unsigned int lbam : 1 ;
   unsigned int lbah : 1 ;
   unsigned int dev : 1 ;
   unsigned int command : 1 ;
};
#line 119 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.h"
union __anonunion____missing_field_name_37 {
   unsigned int hob_all : 8 ;
   struct __anonstruct_hob_38 hob ;
};
#line 119 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.h"
union reg_flags {
   unsigned int all : 16 ;
   union __anonunion____missing_field_name_35 __annonCompField1 ;
   union __anonunion____missing_field_name_37 __annonCompField2 ;
} __attribute__((__packed__)) ;
#line 149 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.h"
struct taskfile_regs {
   __u8 data ;
   __u8 feat ;
   __u8 nsect ;
   __u8 lbal ;
   __u8 lbam ;
   __u8 lbah ;
   __u8 dev ;
   __u8 command ;
};
#line 160 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.h"
struct hdio_taskfile {
   struct taskfile_regs lob ;
   struct taskfile_regs hob ;
   union reg_flags oflags ;
   union reg_flags iflags ;
   int dphase ;
   int cmd_req ;
   unsigned long obytes ;
   unsigned long ibytes ;
   __u16 data[0] ;
};
#line 172 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.h"
struct scsi_sg_io_hdr {
   int interface_id ;
   int dxfer_direction ;
   unsigned char cmd_len ;
   unsigned char mx_sb_len ;
   unsigned short iovec_count ;
   unsigned int dxfer_len ;
   void *dxferp ;
   unsigned char *cmdp ;
   void *sbp ;
   unsigned int timeout ;
   unsigned int flags ;
   int pack_id ;
   void *usr_ptr ;
   unsigned char status ;
   unsigned char masked_status ;
   unsigned char msg_status ;
   unsigned char sb_len_wr ;
   unsigned short host_status ;
   unsigned short driver_status ;
   int resid ;
   unsigned int duration ;
   unsigned int info ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 243 "/usr/include/unistd.h"
typedef __off_t off_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 91 "/usr/include/x86_64-linux-gnu/sys/time.h"
enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2
} ;
#line 107 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 118 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef enum __itimer_which __itimer_which_t;
#line 29 "/usr/include/asm-generic/int-ll64.h"
typedef long long __s64;
#line 120 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
struct sector_range_s;
#line 596 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
struct xfermode_entry {
   int val ;
   char const   *name ;
};
#line 1182 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
struct sector_range_s {
   __u64 lba ;
   __u64 nsectors ;
};
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 220 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf )  __asm__("fstat64")  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.h"
int get_dev_t_geometry(dev_t dev , __u32 *cyls , __u32 *heads , __u32 *sects , __u64 *start_lba ,
                       __u64 *nsectors ) ;
#line 21
int do_filemap(char const   *file_name ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/fibmap.c"
static unsigned int const   sector_bytes  =    (unsigned int const   )512;
#line 34 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/fibmap.c"
static void handle_extent(struct file_extent ext , unsigned int sectors_per_block ,
                          __u64 start_lba ) 
{ 
  char lba_info[64] ;
  char len_info[32] ;
  __u64 begin_lba ;
  __u64 end_lba ;
  __u64 nsectors ;

  {
#line 38
  nsectors = ext.block_count * (__u64 )sectors_per_block;
#line 40
  if (ext.first_block) {
#line 41
    begin_lba = start_lba + ext.first_block * (__u64 )sectors_per_block;
#line 42
    end_lba = (start_lba + (ext.last_block + 1ULL) * (__u64 )sectors_per_block) - 1ULL;
  } else {
#line 44
    end_lba = (__u64 )0;
#line 44
    begin_lba = end_lba;
  }
#line 47
  if (ext.first_block) {
    {
#line 48
    sprintf((char */* __restrict  */)(lba_info), (char const   */* __restrict  */)"%10llu %10llu",
            begin_lba, end_lba);
    }
  } else {
    {
#line 50
    strcpy((char */* __restrict  */)(lba_info), (char const   */* __restrict  */)"      -          -   ");
    }
  }
#line 51
  if (! ext.first_block) {
#line 51
    if (! nsectors) {
      {
#line 52
      strcpy((char */* __restrict  */)(len_info), (char const   */* __restrict  */)"      -   ");
      }
    } else {
      {
#line 54
      sprintf((char */* __restrict  */)(len_info), (char const   */* __restrict  */)"%10llu",
              nsectors);
      }
    }
  } else {
    {
#line 54
    sprintf((char */* __restrict  */)(len_info), (char const   */* __restrict  */)"%10llu",
            nsectors);
    }
  }
  {
#line 55
  printf((char const   */* __restrict  */)"%12llu %s %s\n", ext.byte_offset, lba_info,
         len_info);
  }
#line 56
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/fibmap.c"
static int walk_fibmap(int fd , struct stat *st , unsigned int sectors_per_block ,
                       __u64 start_lba ) 
{ 
  struct file_extent ext ;
  unsigned long num_blocks ;
  __u64 blk_idx ;
  __u64 hole ;
  unsigned int blknum ;
  __u64 blknum64 ;
  int err ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 62
  hole = ~ 0ULL;
#line 70
  num_blocks = (unsigned long )(((st->st_size + st->st_blksize) - 1L) / st->st_blksize);
#line 71
  memset((void *)(& ext), 0, sizeof(ext));
#line 83
  blk_idx = (__u64 )0;
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! (blk_idx < (__u64 )num_blocks)) {
#line 83
      goto while_break;
    }
    {
#line 84
    blknum = (unsigned int )blk_idx;
#line 93
    tmp___0 = ioctl(fd, 1UL, & blknum);
    }
#line 93
    if (tmp___0 == -1) {
      {
#line 94
      tmp = __errno_location();
#line 94
      err = *tmp;
#line 95
      perror("ioctl(FIBMAP)");
      }
#line 96
      return (err);
    }
#line 98
    blknum64 = (__u64 )blknum;
#line 100
    if (blk_idx) {
#line 100
      if (blknum64 == ext.last_block + 1ULL) {
#line 104
        if (blknum64) {
#line 104
          ext.last_block = blknum64;
        } else {
#line 104
          ext.last_block = hole;
        }
#line 105
        (ext.block_count) ++;
      } else {
#line 100
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 110
      if (blk_idx) {
        {
#line 111
        handle_extent(ext, sectors_per_block, start_lba);
        }
      }
#line 112
      ext.first_block = blknum64;
#line 113
      if (blknum64) {
#line 113
        ext.last_block = blknum64;
      } else {
#line 113
        ext.last_block = hole;
      }
#line 114
      ext.block_count = (__u64 )1;
#line 115
      ext.byte_offset = blk_idx * (__u64 )st->st_blksize;
    }
#line 83
    blk_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 118
  handle_extent(ext, sectors_per_block, start_lba);
  }
#line 119
  return (0);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/fibmap.c"
static int walk_fiemap(int fd , unsigned int sectors_per_block , __u64 start_lba ) 
{ 
  unsigned int i ;
  unsigned int done ;
  unsigned int blksize ;
  struct fs_s fs ;
  int err ;
  int *tmp ;
  int tmp___0 ;
  struct file_extent ext ;
  __u64 phy_blk ;
  __u64 ext_len ;

  {
  {
#line 157
  done = 0U;
#line 158
  blksize = sectors_per_block * (unsigned int )sector_bytes;
#line 161
  memset((void *)(& fs), 0, sizeof(fs));
  }
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 163
    fs.fm.length = ~ 0ULL;
#line 164
    fs.fm.flags = (__u32 )0;
#line 165
    fs.fm.extent_count = (__u32 )8000;
#line 167
    tmp___0 = ioctl(fd, (unsigned long )(((3U << 30) | (unsigned int )(102 << 8)) | 11U) | (sizeof(struct fm_s ) << 16),
                    & fs);
    }
#line 167
    if (-1 == tmp___0) {
      {
#line 168
      tmp = __errno_location();
#line 168
      err = *tmp;
      }
#line 170
      return (err);
    }
#line 174
    if (! fs.fm.mapped_extents) {
#line 175
      done = 1U;
    } else {
      {
#line 178
      memset((void *)(& ext), 0, sizeof(ext));
#line 179
      i = 0U;
      }
      {
#line 179
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 179
        if (! (i < fs.fm.mapped_extents)) {
#line 179
          goto while_break___0;
        }
#line 182
        ext.byte_offset = fs.fe[i].logical;
#line 185
        if (fs.fe[i].flags & (unsigned int )(((1 << 1) | (1 << 2)) | (1 << 8))) {
#line 186
          ext.first_block = (__u64 )0;
#line 187
          ext.last_block = (__u64 )0;
#line 188
          ext.block_count = (__u64 )0;
        } else {
#line 190
          phy_blk = fs.fe[i].physical / (__u64 )blksize;
#line 191
          ext_len = fs.fe[i].length / (__u64 )blksize;
#line 193
          ext.first_block = phy_blk;
#line 194
          ext.last_block = (phy_blk + ext_len) - 1ULL;
#line 195
          ext.block_count = ext_len;
        }
        {
#line 197
        handle_extent(ext, sectors_per_block, start_lba);
#line 179
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 214
      fs.fm.start = fs.fe[i - 1U].logical + fs.fe[i - 1U].length;
    }
#line 162
    if (! (! done)) {
#line 162
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  return (0);
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/fibmap.c"
int do_filemap(char const   *file_name ) 
{ 
  int fd ;
  int err ;
  struct stat st ;
  __u64 start_lba ;
  unsigned int sectors_per_block ;
  unsigned int blksize ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  struct file_extent ext ;

  {
  {
#line 224
  start_lba = (__u64 )0;
#line 227
  fd = open(file_name, 0);
  }
#line 227
  if (fd == -1) {
    {
#line 228
    tmp = __errno_location();
#line 228
    err = *tmp;
#line 229
    perror(file_name);
    }
#line 230
    return (err);
  }
  {
#line 232
  tmp___1 = fstat(fd, & st);
  }
#line 232
  if (tmp___1 == -1) {
    {
#line 233
    tmp___0 = __errno_location();
#line 233
    err = *tmp___0;
#line 234
    perror(file_name);
    }
#line 235
    return (err);
  }
#line 237
  if (! ((st.st_mode & 61440U) == 32768U)) {
    {
#line 238
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: not a regular file\n",
            file_name);
#line 239
    close(fd);
    }
#line 240
    return (22);
  }
  {
#line 246
  err = get_dev_t_geometry(st.st_dev, (__u32 *)((void *)0), (__u32 *)((void *)0),
                           (__u32 *)((void *)0), & start_lba, (__u64 *)((void *)0));
  }
#line 247
  if (err) {
    {
#line 248
    close(fd);
    }
#line 249
    return (err);
  }
#line 251
  if (start_lba == 0xffffffffffffffffULL) {
    {
#line 252
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to determine start offset LBA for device, aborting.\n");
#line 253
    close(fd);
    }
#line 254
    return (5);
  }
  {
#line 256
  err = ioctl(fd, 2UL, & blksize);
  }
#line 256
  if (err) {
    {
#line 257
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to determine block size, aborting.\n");
#line 258
    close(fd);
    }
#line 259
    return (err);
  }
  {
#line 261
  sectors_per_block = blksize / (unsigned int )sector_bytes;
#line 262
  printf((char const   */* __restrict  */)"\n%s:\n filesystem blocksize %u, begins at LBA %llu; assuming %u byte sectors.\n",
         file_name, blksize, start_lba, sector_bytes);
#line 265
  printf((char const   */* __restrict  */)"%12s %10s %10s %10s\n", "byte_offset",
         "begin_LBA", "end_LBA", "sectors");
  }
#line 267
  if (st.st_size == 0L) {
    {
#line 269
    memset((void *)(& ext), 0, sizeof(ext));
#line 270
    handle_extent(ext, sectors_per_block, start_lba);
#line 271
    close(fd);
    }
#line 272
    return (0);
  }
  {
#line 275
  err = walk_fiemap(fd, sectors_per_block, start_lba);
  }
#line 276
  if (err) {
    {
#line 277
    err = walk_fibmap(fd, & st, sectors_per_block, start_lba);
    }
  }
  {
#line 278
  close(fd);
  }
#line 279
  return (0);
}
}
#line 580 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.h"
void identify(__u16 *id_supplied ) ;
#line 24
void dco_identify_print(__u16 *dco ) ;
#line 33
char const   *BuffType[4] ;
#line 134 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
char const   *pkt_str[32]  = 
#line 134 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
  {      "Direct-access device",      "Sequential-access device",      "Printer",      "Processor", 
        "Write-once device",      "CD-ROM",      "Scanner",      "Optical memory", 
        "Medium changer",      "Communications device",      "ACS-IT8 device",      "ACS-IT8 device", 
        "Array controller",      "Enclosure services",      "Reduced block command device",      "Optical card reader/writer", 
        "",      "",      "",      "", 
        "",      "",      "",      "", 
        "",      "",      "",      "", 
        "",      "",      "",      "Unknown"};
#line 168 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
char const   *ata1_cfg_str[16]  = 
#line 168
  {      "reserved",      "hard sectored",      "soft sectored",      "not MFM encoded ", 
        "head switch time > 15us",      "spindle motor control option",      "fixed drive",      "removable drive", 
        "disk xfer rate <= 5Mbs",      "disk xfer rate > 5Mbs, <= 10Mbs",      "disk xfer rate > 5Mbs",      "rotational speed tol.", 
        "data strobe offset option",      "track offset option",      "format speed tolerance gap reqd",      "ATAPI"};
#line 243 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
char const   *minor_str[36]  = 
#line 243
  {      "Unspecified",      "ATA-1 X3T9.2 781D prior to revision 4",      "ATA-1 published, ANSI X3.221-1994",      "ATA-1 X3T9.2 781D revision 4", 
        "ATA-2 published, ANSI X3.279-1996",      "ATA-2 X3T10 948D prior to revision 2k",      "ATA-3 X3T10 2008D revision 1",      "ATA-2 X3T10 948D revision 2k", 
        "ATA-3 X3T10 2008D revision 0",      "ATA-2 X3T10 948D revision 3",      "ATA-3 published, ANSI X3.298-199x",      "ATA-3 X3T10 2008D revision 6", 
        "ATA-3 X3T13 2008D revision 7 and 7a",      "ATA/ATAPI-4 X3T13 1153D revision 6",      "ATA/ATAPI-4 T13 1153D revision 13",      "ATA/ATAPI-4 X3T13 1153D revision 7", 
        "ATA/ATAPI-4 T13 1153D revision 18",      "ATA/ATAPI-4 T13 1153D revision 15",      "ATA/ATAPI-4 published, ANSI INCITS 317-1998",      "ATA/ATAPI-5 T13 1321D revision 3", 
        "ATA/ATAPI-4 T13 1153D revision 14",      "ATA/ATAPI-5 T13 1321D revision 1",      "ATA/ATAPI-5 published, ANSI INCITS 340-2000",      "ATA/ATAPI-4 T13 1153D revision 17", 
        "ATA/ATAPI-6 T13 1410D revision 0",      "ATA/ATAPI-6 T13 1410D revision 3a",      "ATA/ATAPI-7 T13 1532D revision 1",      "ATA/ATAPI-6 T13 1410D revision 2", 
        "ATA/ATAPI-6 T13 1410D revision 1",      "ATA/ATAPI-7 published, ANSI INCITS 397-2005",      "ATA/ATAPI-7 T13 1532D revision 0",      "Reserved", 
        "Reserved",      "ATA/ATAPI-7 T13 1532D revision 4a",      "ATA/ATAPI-6 published, ANSI INCITS 361-2002",      "Reserved"};
#line 281 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
char const   actual_ver[36]  = 
#line 281
  {      (char const   )0,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )2,      (char const   )2,      (char const   )3,      (char const   )2, 
        (char const   )3,      (char const   )2,      (char const   )3,      (char const   )3, 
        (char const   )3,      (char const   )4,      (char const   )4,      (char const   )4, 
        (char const   )4,      (char const   )4,      (char const   )4,      (char const   )5, 
        (char const   )4,      (char const   )5,      (char const   )5,      (char const   )4, 
        (char const   )6,      (char const   )6,      (char const   )7,      (char const   )6, 
        (char const   )6,      (char const   )7,      (char const   )7,      (char const   )0, 
        (char const   )0,      (char const   )7,      (char const   )6,      (char const   )0};
#line 332 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
static char const   *feat_word69_str[16]  = 
#line 332
  {      "CFast specification support",      "Deterministic read data after TRIM",      "Long physical sector diagnostics",      "DEVICE CONFIGURATION SET/IDENTIFY DMA commands", 
        "READ BUFFER DMA command",      "WRITE BUFFER DMA command",      "SET MAX SETPASSWORD/UNLOCK DMA commands",      "DOWNLOAD MICROCODE DMA command", 
        "reserved 69[7]",      "reserved 69[6]",      "Deterministic read ZEROs after TRIM",      "reserved 69[4]", 
        "reserved 69[3]",      "reserved 69[2]",      "reserved 69[1]",      "reserved 69[0]"};
#line 351 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
static char const   *feat_word82_str[16]  = 
#line 351
  {      "obsolete 82[15]",      "NOP cmd",      "READ_BUFFER command",      "WRITE_BUFFER command", 
        "WRITE_VERIFY command",      "Host Protected Area feature set",      "DEVICE_RESET command",      "SERVICE interrupt", 
        "Release interrupt",      "Look-ahead",      "Write cache",      "PACKET command feature set", 
        "Power Management feature set",      "Removable Media feature set",      "Security Mode feature set",      "SMART feature set"};
#line 369 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
static char const   *feat_word83_str[16]  = 
#line 369
  {      (char const   *)((void *)0),      (char const   *)((void *)0),      "FLUSH_CACHE_EXT",      "Mandatory FLUSH_CACHE", 
        "Device Configuration Overlay feature set",      "48-bit Address feature set",      "Automatic Acoustic Management feature set",      "SET_MAX security extension", 
        "Address Offset Reserved Area Boot",      "SET_FEATURES required to spinup after power up",      "Power-Up In Standby feature set",      "Removable Media Status Notification feature set", 
        "Advanced Power Management feature set",      "CFA feature set",      "READ/WRITE_DMA_QUEUED",      "DOWNLOAD_MICROCODE"};
#line 387 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
static char const   *feat_word84_str[16]  = 
#line 387
  {      (char const   *)((void *)0),      (char const   *)((void *)0),      "IDLE_IMMEDIATE with UNLOAD",      "Command Completion Time Limit (CCTL)", 
        "Time Limited Commands (TLC) feature set",      "URG for WRITE_STREAM[_DMA]_EXT",      "URG for READ_STREAM[_DMA]_EXT",      "64-bit World wide name", 
        "WRITE_DMA_QUEUED_FUA_EXT",      "WRITE_{DMA|MULTIPLE}_FUA_EXT",      "General Purpose Logging feature set",      "Media Card Pass-Through", 
        "Media Card Pass Through Command feature set",      "Media serial number",      "SMART self-test",      "SMART error logging"};
#line 405 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
static char const   *feat_3_str[16]  = 
#line 405
  {      (char const   *)((void *)0),      (char const   *)((void *)0),      "unknown 119[13]",      "unknown 119[12]", 
        "unknown 119[11]",      "unknown 119[10]",      "unknown 119[9]",      "unknown 119[8]", 
        "unknown 119[7]",      "unknown 119[6]",      "Free-fall Control feature set",      "Segmented DOWNLOAD_MICROCODE", 
        "{READ,WRITE}_DMA_EXT_GPL commands",      "WRITE_UNCORRECTABLE_EXT command",      "Write-Read-Verify feature set",      "Disable Data Transfer After Error Detection"};
#line 423 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
static char const   *cap_sata0_str[16]  = 
#line 423
  {      "READ_LOG_DMA_EXT equivalent to READ_LOG_EXT",      "Device automatic Partial to Slumber transitions",      "Host automatic Partial to Slumber transitions",      "NCQ priority information", 
        "Idle-Unload when NCQ is active",      "Phy event counters",      "Host-initiated interface power management",      "Native Command Queueing (NCQ)", 
        "unknown 76[7]",      "unknown 76[6]",      "unknown 76[5]",      "unknown 76[4]", 
        "Gen3 signaling speed (6.0Gb/s)",      "Gen2 signaling speed (3.0Gb/s)",      "Gen1 signaling speed (1.5Gb/s)",      "unknown 76[0]"};
#line 441 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
static char const   *feat_sata0_str[16]  = 
#line 441
  {      "unknown 78[15]",      "unknown 78[14]",      "unknown 78[13]",      "unknown 78[12]", 
        "unknown 78[11]",      "unknown 78[10]",      "unknown 78[9]",      "Device Sleep (DEVSLP)", 
        "unknown 78[7]",      "Software settings preservation",      "Asynchronous notification (eg. media change)",      "In-order data delivery", 
        "Device-initiated interface power management",      "DMA Setup Auto-Activate optimization",      "Non-Zero buffer offsets in DMA Setup FIS",      "unknown 78[0]"};
#line 487 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
char const   *secu_str[6]  = {      "supported",      "enabled",      "locked",      "frozen", 
        "expired: security count",      "supported: enhanced erase"};
#line 503 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
static char const   *feat_sct_str[16]  = 
#line 503
  {      "unknown 206[15] (vendor specific)",      "unknown 206[14] (vendor specific)",      "unknown 206[13] (vendor specific)",      "unknown 206[12] (vendor specific)", 
        "unknown 206[11]",      "unknown 206[10]",      "unknown 206[9]",      "unknown 206[8]", 
        "unknown 206[7]",      "unknown 206[6]",      "SCT Data Tables (AC5)",      "SCT Features Control (AC4)", 
        "SCT Error Recovery Control (AC3)",      "SCT Write Same (AC2)",      "SCT Read/Write Long (AC1), obsolete",      "SMART Command Transport (SCT) feature set"};
#line 526
__u8 mode_loop(__u16 mode_sup , __u16 mode_sel , int cc , __u8 *have_mode ) ;
#line 528 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
static void print_ascii(__u16 *p , unsigned int length ) 
{ 
  __u8 ii ;
  char cl ;
  __u8 c ;

  {
#line 533
  ii = (__u8 )0;
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 533
    if (! ((unsigned int )ii < length)) {
#line 533
      goto while_break;
    }
#line 534
    if ((-1 & ((int )*p >> 8)) != 32) {
#line 534
      goto while_break;
    }
#line 535
    cl = (char )(-1 & (int )*p);
#line 535
    if ((int )cl != 32) {
#line 536
      if ((int )cl != 0) {
        {
#line 536
        printf((char const   */* __restrict  */)"%c", (int )cl);
        }
      }
#line 537
      p ++;
#line 537
      ii = (__u8 )((int )ii + 1);
#line 538
      goto while_break;
    }
#line 540
    p ++;
#line 533
    ii = (__u8 )((int )ii + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 543
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 543
    if (! ((unsigned int )ii < length)) {
#line 543
      goto while_break___0;
    }
#line 546
    c = (__u8 )((int )*p >> 8);
#line 547
    if (c) {
      {
#line 547
      putchar((int )c);
      }
    }
#line 548
    c = (__u8 )*p;
#line 549
    if (c) {
      {
#line 549
      putchar((int )c);
      }
    }
#line 550
    p ++;
#line 543
    ii = (__u8 )((int )ii + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 552
  printf((char const   */* __restrict  */)"\n");
  }
#line 553
  return;
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
static __u16 min_ata_std(__u16 major ) 
{ 


  {
#line 561
  if ((int )major <= 4) {
#line 562
    return ((__u16 )1);
  }
#line 563
  if ((int )major == 5) {
#line 564
    return ((__u16 )2);
  }
#line 565
  if ((int )major <= 7) {
#line 566
    return ((__u16 )3);
  }
#line 567
  return ((__u16 )4);
}
}
#line 570 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
static void print_features(__u16 supported , __u16 enabled , char const   **names ) 
{ 
  int i ;
  __u16 mask ;
  int tmp ;

  {
#line 573
  i = 0;
  {
#line 573
  while (1) {
    while_continue: /* CIL Label */ ;
#line 573
    if (! (i < 16)) {
#line 573
      goto while_break;
    }
#line 574
    mask = (__u16 )(1 << i);
#line 575
    if ((int )supported & (int )mask) {
#line 575
      if (*(names + (15 - i))) {
#line 576
        if ((int )enabled & (int )mask) {
#line 576
          tmp = '*';
        } else {
#line 576
          tmp = ' ';
        }
        {
#line 576
        printf((char const   */* __restrict  */)"\t   %c\t%s\n", tmp, *(names + (15 - i)));
        }
      }
    }
#line 573
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 578
  return;
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
static int print_transport_type(__u16 *val ) 
{ 
  __u16 major ;
  __u16 minor ;
  unsigned int ttype ;
  unsigned int subtype ;
  unsigned int transport ;

  {
#line 582
  major = *(val + 222);
#line 582
  minor = *(val + 223);
#line 583
  transport = 0U;
#line 585
  if ((int )major == 0) {
#line 594
    return ((int )transport);
  } else
#line 585
  if ((int )major == 65535) {
#line 594
    return ((int )transport);
  }
  {
#line 596
  printf((char const   */* __restrict  */)"\t%-20s", "Transport:");
#line 597
  ttype = (unsigned int )((int )major >> 12);
#line 598
  subtype = (unsigned int )((int )major & 4095);
#line 599
  transport = ttype;
  }
  {
#line 601
  if (ttype == 0U) {
#line 601
    goto case_0;
  }
#line 606
  if (ttype == 1U) {
#line 606
    goto case_1;
  }
#line 623
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 602
  printf((char const   */* __restrict  */)"Parallel");
  }
#line 603
  if (subtype & 1U) {
    {
#line 604
    printf((char const   */* __restrict  */)", ATA8-APT");
    }
  }
#line 605
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 607
  printf((char const   */* __restrict  */)"Serial");
  }
#line 608
  if (subtype & 47U) {
#line 609
    if (subtype & 1U) {
      {
#line 610
      printf((char const   */* __restrict  */)", ATA8-AST");
      }
    }
#line 611
    if (subtype & (unsigned int )(1 << 1)) {
      {
#line 612
      printf((char const   */* __restrict  */)", SATA 1.0a");
      }
    }
#line 613
    if (subtype & (unsigned int )(1 << 2)) {
      {
#line 614
      printf((char const   */* __restrict  */)", SATA II Extensions");
      }
    }
#line 615
    if (subtype & (unsigned int )(1 << 3)) {
      {
#line 616
      printf((char const   */* __restrict  */)", SATA Rev 2.5");
      }
    }
#line 617
    if (subtype & (unsigned int )(1 << 4)) {
      {
#line 618
      printf((char const   */* __restrict  */)", SATA Rev 2.6");
      }
    }
#line 619
    if (subtype & (unsigned int )(1 << 5)) {
      {
#line 620
      printf((char const   */* __restrict  */)", SATA Rev 3.0");
      }
    }
  }
#line 622
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 624
  printf((char const   */* __restrict  */)"0x%04x", (int )major);
  }
#line 625
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 627
  if ((int )minor != 0) {
#line 627
    if ((int )minor != 65535) {
      {
#line 628
      printf((char const   */* __restrict  */)"; Revision: ");
      }
      {
#line 630
      if ((int )minor == 33) {
#line 630
        goto case_33;
      }
#line 633
      goto switch_default___0;
      case_33: /* CIL Label */ 
      {
#line 631
      printf((char const   */* __restrict  */)"ATA8-AST T13 Project D1697 Revision 0b");
      }
#line 632
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 634
      printf((char const   */* __restrict  */)"0x%04x", (int )minor);
      }
      switch_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 637
  putchar('\n');
  }
#line 638
  return ((int )transport);
}
}
#line 641 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
static int is_cfa_dev(__u16 *id___0 ) 
{ 
  int tmp ;

  {
#line 648
  if ((int )*(id___0 + 0) == 33930) {
#line 648
    tmp = 1;
  } else
#line 648
  if ((int )*(id___0 + 0) == 33866) {
#line 648
    tmp = 1;
  } else
#line 648
  if (((int )*(id___0 + 83) & 49156) == 16388) {
#line 648
    tmp = 1;
  } else {
#line 648
    tmp = 0;
  }
#line 648
  return (tmp);
}
}
#line 1256 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
static unsigned char const   io_times[4]  = {      (unsigned char const   )255,      (unsigned char const   )120,      (unsigned char const   )100,      (unsigned char const   )80};
#line 1257 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
static unsigned char const   mem_times[4]  = {      (unsigned char const   )250,      (unsigned char const   )120,      (unsigned char const   )100,      (unsigned char const   )80};
#line 652 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
void identify(__u16 *id_supplied ) 
{ 
  unsigned int sector_bytes___0 ;
  __u16 val[256] ;
  __u16 ii ;
  __u16 jj ;
  __u16 kk ;
  __u16 like_std ;
  __u16 std ;
  __u16 min_std ;
  __u16 dev ;
  __u16 eqpt ;
  __u8 have_mode ;
  __u8 err_dma ;
  __u8 chksum ;
  __u32 ll ;
  __u32 mm ;
  __u32 nn ;
  __u64 bb ;
  __u64 bbbig ;
  int transport ;
  int is_cfa ;
  int atapi_has_dmadir ;
  int sdma_ok ;
  int tmp ;
  char const   *used ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int lsize ;
  unsigned int pfactor ;
  unsigned int offset ;
  __u32 tmp___5 ;
  int has_queuing ;
  __u16 w62 ;
  __u8 hi ;
  __u8 lo ;
  __u8 tmp___6 ;
  __u8 tmp___7 ;
  __u8 tmp___8 ;
  __u16 trimd ;
  __u16 trimz ;
  __u16 word69 ;
  char const   *tmp___9 ;
  unsigned int mode ;
  unsigned int max ;
  unsigned int selected ;
  char modes[256] ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  char const   *tmp___14 ;

  {
  {
#line 654
  sector_bytes___0 = 512U;
#line 656
  like_std = (__u16 )1;
#line 656
  std = (__u16 )0;
#line 656
  min_std = (__u16 )65535;
#line 657
  dev = (__u16 )65535;
#line 657
  eqpt = (__u16 )65535;
#line 658
  have_mode = (__u8 )0;
#line 658
  err_dma = (__u8 )0;
#line 659
  chksum = (__u8 )0;
#line 662
  is_cfa = 0;
#line 662
  atapi_has_dmadir = 0;
#line 664
  memcpy((void */* __restrict  */)(val), (void const   */* __restrict  */)id_supplied,
         sizeof(val));
#line 667
  ii = (__u16 )0;
  }
  {
#line 667
  while (1) {
    while_continue: /* CIL Label */ ;
#line 667
    if (! ((int )ii <= 255)) {
#line 667
      goto while_break;
    }
#line 668
    chksum = (__u8 )((int )chksum + ((int )val[ii] + ((int )val[ii] >> 8)));
#line 667
    ii = (__u16 )((int )ii + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 672
  printf((char const   */* __restrict  */)"\n");
#line 675
  tmp = is_cfa_dev(val);
  }
#line 675
  if (tmp) {
    {
#line 676
    is_cfa = 1;
#line 677
    dev = (__u16 )0;
#line 678
    like_std = (__u16 )4;
#line 679
    printf((char const   */* __restrict  */)"CompactFlash ATA device\n");
    }
  } else
#line 680
  if (! ((int )val[0] & 32768)) {
    {
#line 681
    dev = (__u16 )0;
#line 682
    printf((char const   */* __restrict  */)"ATA device, with ");
    }
  } else
#line 683
  if (! ((int )val[0] & 16384)) {
    {
#line 684
    dev = (__u16 )1;
#line 685
    eqpt = (__u16 )(((int )val[0] & 7936) >> 8);
#line 686
    printf((char const   */* __restrict  */)"ATAPI %s, with ", pkt_str[eqpt]);
#line 687
    like_std = (__u16 )3;
    }
  } else {
    {
#line 689
    printf((char const   */* __restrict  */)"Unknown device type:\n\tbits 15&14 of general configuration word 0 both set to 1.\n");
#line 690
    exit(22);
    }
  }
#line 692
  if (! is_cfa) {
#line 693
    if (! ((int )val[0] & 128)) {
      {
#line 694
      printf((char const   */* __restrict  */)"non-");
      }
    }
    {
#line 695
    printf((char const   */* __restrict  */)"removable media\n");
    }
  }
#line 705
  if ((int )val[2] == 14280) {
#line 705
    goto _L___0;
  } else
#line 705
  if ((int )val[2] == 29580) {
#line 705
    goto _L___0;
  } else
#line 705
  if ((int )val[2] == 35955) {
#line 705
    goto _L___0;
  } else
#line 705
  if ((int )val[2] == 51255) {
    _L___0: /* CIL Label */ 
#line 707
    like_std = (__u16 )5;
#line 708
    if ((int )val[2] == 14280) {
      {
#line 709
      printf((char const   */* __restrict  */)"powers-up in standby; SET FEATURES subcmd spins-up.\n");
      }
    } else
#line 708
    if ((int )val[2] == 29580) {
      {
#line 709
      printf((char const   */* __restrict  */)"powers-up in standby; SET FEATURES subcmd spins-up.\n");
      }
    }
#line 710
    if ((int )val[2] == 14280) {
#line 710
      goto _L;
    } else
#line 710
    if ((int )val[2] == 35955) {
      _L: /* CIL Label */ 
#line 710
      if ((int )val[0] & 4) {
        {
#line 712
        printf((char const   */* __restrict  */)"\n\tWARNING: ID response incomplete.\n\tWARNING: Following data may be incorrect.\n\n");
        }
      }
    }
  }
#line 716
  if (val[27]) {
    {
#line 717
    printf((char const   */* __restrict  */)"\t%-20s", "Model Number:");
#line 718
    print_ascii(& val[27], 20U);
    }
  }
#line 720
  if (val[10]) {
    {
#line 721
    printf((char const   */* __restrict  */)"\t%-20s", "Serial Number:");
#line 722
    print_ascii(& val[10], 10U);
    }
  }
#line 724
  if (val[23]) {
    {
#line 725
    printf((char const   */* __restrict  */)"\t%-20s", "Firmware Revision:");
#line 726
    print_ascii(& val[23], 4U);
    }
  }
#line 728
  if (val[176]) {
    {
#line 729
    printf((char const   */* __restrict  */)"\t%-20s", "Media Serial Num:");
#line 730
    print_ascii(& val[176], 20U);
    }
  }
#line 732
  if (val[196]) {
    {
#line 733
    printf((char const   */* __restrict  */)"\t%-20s", "Media Manufacturer:");
#line 734
    print_ascii(& val[196], 10U);
    }
  }
  {
#line 737
  transport = print_transport_type(val);
#line 741
  printf((char const   */* __restrict  */)"Standards:");
  }
#line 742
  if ((int )eqpt != 5) {
#line 744
    used = (char const   *)0;
#line 745
    if (val[81]) {
#line 745
      if ((int )val[81] <= 34) {
#line 746
        if ((int )like_std < 3) {
#line 747
          like_std = (__u16 )3;
        }
#line 748
        std = (__u16 )actual_ver[val[81]];
#line 749
        if (std) {
#line 750
          used = minor_str[val[81]];
        }
      } else {
#line 745
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 755
      if ((int )val[81] == 39) {
#line 755
        goto case_39;
      }
#line 756
      if ((int )val[81] == 51) {
#line 756
        goto case_51;
      }
#line 757
      if ((int )val[81] == 66) {
#line 757
        goto case_66;
      }
#line 758
      if ((int )val[81] == 82) {
#line 758
        goto case_82;
      }
#line 759
      if ((int )val[81] == 263) {
#line 759
        goto case_263;
      }
#line 754
      goto switch_break;
      case_39: /* CIL Label */ 
#line 755
      used = "ATA-8-ACS revision 3c";
#line 755
      goto switch_break;
      case_51: /* CIL Label */ 
#line 756
      used = "ATA-8-ACS revision 3e";
#line 756
      goto switch_break;
      case_66: /* CIL Label */ 
#line 757
      used = "ATA-8-ACS revision 3f";
#line 757
      goto switch_break;
      case_82: /* CIL Label */ 
#line 758
      used = "ATA-8-ACS revision 3b";
#line 758
      goto switch_break;
      case_263: /* CIL Label */ 
#line 759
      used = "ATA-8-ACS revision 2d";
#line 759
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 761
      if (used) {
#line 762
        std = (__u16 )8;
      }
    }
#line 764
    if (used) {
      {
#line 765
      printf((char const   */* __restrict  */)"\n\tUsed: %s ", used);
      }
    } else
#line 766
    if ((int )val[81] >= 31) {
      {
#line 767
      printf((char const   */* __restrict  */)"\n\tUsed: unknown (minor revision code 0x%04x) ",
             (int )val[81]);
      }
    }
#line 772
    if (val[80]) {
#line 772
      if ((int )val[80] != 65535) {
        {
#line 773
        printf((char const   */* __restrict  */)"\n\tSupported: ");
#line 774
        jj = (__u16 )((int )val[80] << 1);
#line 775
        kk = min_ata_std(like_std);
#line 776
        ii = (__u16 )14;
        }
        {
#line 776
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 776
          if (! ((int )ii > (int )kk)) {
#line 776
            goto while_break___0;
          }
#line 777
          if ((int )jj & 32768) {
            {
#line 778
            printf((char const   */* __restrict  */)"%u ", (int )ii);
            }
#line 779
            if ((int )ii > (int )like_std) {
              {
#line 780
              like_std = ii;
#line 781
              kk = min_ata_std(like_std);
              }
            }
#line 783
            if ((int )min_std > (int )ii) {
#line 784
              min_std = ii;
            }
          }
#line 786
          jj = (__u16 )((int )jj << 1);
#line 776
          ii = (__u16 )((int )ii - 1);
        }
        while_break___0: /* CIL Label */ ;
        }
#line 788
        if ((int )like_std < 3) {
#line 789
          like_std = (__u16 )3;
        }
      }
    }
#line 795
    if ((int )like_std < (int )std) {
#line 795
      like_std = std;
    }
#line 796
    if ((int )std == 7) {
#line 796
      goto _L___20;
    } else
#line 796
    if (! std) {
#line 796
      if ((int )like_std < 8) {
        _L___20: /* CIL Label */ 
#line 796
        if ((int )val[206] & 1) {
#line 798
          like_std = (__u16 )8;
        } else {
#line 796
          goto _L___21;
        }
      } else {
#line 796
        goto _L___21;
      }
    } else
    _L___21: /* CIL Label */ 
#line 799
    if ((int )std == 5) {
#line 799
      goto _L___17;
    } else
#line 799
    if (! std) {
#line 799
      if ((int )like_std < 6) {
        _L___17: /* CIL Label */ 
#line 799
        if (((int )val[83] & 49152) == 16384) {
#line 799
          if (((int )val[83] & 16383) > 255) {
#line 804
            like_std = (__u16 )6;
          } else {
#line 799
            goto _L___16;
          }
        } else
        _L___16: /* CIL Label */ 
#line 799
        if (((int )val[84] & 49152) == 16384) {
#line 799
          if ((int )val[84] & 10239) {
#line 804
            like_std = (__u16 )6;
          } else {
#line 799
            goto _L___18;
          }
        } else {
#line 799
          goto _L___18;
        }
      } else {
#line 799
        goto _L___18;
      }
    } else
    _L___18: /* CIL Label */ 
#line 805
    if ((int )std == 4) {
#line 805
      goto _L___13;
    } else
#line 805
    if (! std) {
#line 805
      if ((int )like_std < 5) {
        _L___13: /* CIL Label */ 
#line 805
        if (((int )val[255] & 255) == 165) {
#line 805
          if (! chksum) {
#line 810
            like_std = (__u16 )5;
          } else {
#line 805
            goto _L___12;
          }
        } else
        _L___12: /* CIL Label */ 
#line 805
        if (((int )val[93] & 49152) == 16384) {
#line 810
          like_std = (__u16 )5;
        } else
#line 805
        if (((int )val[83] & 49152) == 16384) {
#line 805
          if (((int )val[83] & 16383) > 31) {
#line 810
            like_std = (__u16 )5;
          } else {
#line 805
            goto _L___14;
          }
        } else {
#line 805
          goto _L___14;
        }
      } else {
#line 805
        goto _L___14;
      }
    } else
    _L___14: /* CIL Label */ 
#line 811
    if ((int )std == 3) {
#line 811
      goto _L___9;
    } else
#line 811
    if (! std) {
#line 811
      if ((int )like_std < 4) {
        _L___9: /* CIL Label */ 
#line 811
        if (((int )val[83] & 49152) == 16384) {
#line 811
          if (((int )val[83] & 16383) > 0) {
#line 818
            like_std = (__u16 )4;
          } else
#line 811
          if (((int )val[82] & 30719) > 15) {
#line 818
            like_std = (__u16 )4;
          } else {
#line 811
            goto _L___8;
          }
        } else
        _L___8: /* CIL Label */ 
#line 811
        if (((int )val[50] & 49152) == 16384) {
#line 818
          like_std = (__u16 )4;
        } else
#line 811
        if ((int )val[53] & 4) {
#line 811
          if (val[88]) {
#line 818
            like_std = (__u16 )4;
          } else {
#line 811
            goto _L___7;
          }
        } else
        _L___7: /* CIL Label */ 
#line 811
        if (((int )val[127] & 3) == 1) {
#line 818
          like_std = (__u16 )4;
        } else {
#line 811
          goto _L___10;
        }
      } else {
#line 811
        goto _L___10;
      }
    } else
    _L___10: /* CIL Label */ 
#line 819
    if ((int )std == 2) {
#line 819
      goto _L___4;
    } else
#line 819
    if (! std) {
#line 819
      if ((int )like_std < 3) {
        _L___4: /* CIL Label */ 
#line 819
        if (((int )val[83] & 49152) == 16384) {
#line 821
          like_std = (__u16 )3;
        } else {
#line 819
          goto _L___5;
        }
      } else {
#line 819
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 822
    if ((int )std == 1) {
#line 822
      goto _L___2;
    } else
#line 822
    if (! std) {
#line 822
      if ((int )like_std < 2) {
        _L___2: /* CIL Label */ 
#line 822
        if ((int )val[49] & 3072) {
#line 825
          like_std = (__u16 )2;
        } else
#line 822
        if ((int )val[53] & 2) {
#line 825
          like_std = (__u16 )2;
        }
      }
    }
#line 827
    if (! std) {
      {
#line 828
      printf((char const   */* __restrict  */)"\n\tLikely used: %u\n", (int )like_std);
      }
    } else
#line 829
    if ((int )like_std > (int )std) {
      {
#line 830
      printf((char const   */* __restrict  */)"& some of %u\n", (int )like_std);
      }
    } else {
      {
#line 831
      printf((char const   */* __restrict  */)"\n");
      }
    }
  } else {
#line 834
    kk = (__u16 )0;
#line 835
    if ((int )val[74] == 9) {
      {
#line 836
      kk = (__u16 )1;
#line 837
      printf((char const   */* __restrict  */)"\n\tUsed: ATAPI for CD-ROMs, SFF-8020i, r2.5");
      }
    }
#line 839
    if (val[73]) {
#line 839
      if ((int )val[73] != 65535) {
        {
#line 840
        kk = (__u16 )1;
#line 841
        printf((char const   */* __restrict  */)"\n\tSupported: CD-ROM ATAPI");
#line 842
        jj = (__u16 )((int )val[73] >> 1);
#line 843
        ii = (__u16 )1;
        }
        {
#line 843
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 843
          if (! ((int )ii < 15)) {
#line 843
            goto while_break___1;
          }
#line 844
          if ((int )jj & 1) {
            {
#line 845
            printf((char const   */* __restrict  */)"-%u ", (int )ii);
            }
          }
#line 847
          jj = (__u16 )((int )jj >> 1);
#line 843
          ii = (__u16 )((int )ii + 1);
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 850
    if (! kk) {
      {
#line 850
      printf((char const   */* __restrict  */)"\n\tLikely used CD-ROM ATAPI-1\n");
      }
    } else {
      {
#line 851
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 853
    like_std = (__u16 )2;
  }
#line 856
  if ((int )min_std == 65535) {
#line 857
    if ((int )like_std > 4) {
#line 857
      min_std = (__u16 )((int )like_std - 3);
    } else {
#line 857
      min_std = (__u16 )1;
    }
  }
  {
#line 859
  printf((char const   */* __restrict  */)"Configuration:\n");
  }
#line 861
  if ((int )eqpt != 5) {
#line 861
    if ((int )like_std == 1) {
#line 862
      jj = (__u16 )((int )val[0] >> 1);
#line 863
      ii = (__u16 )1;
      {
#line 863
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 863
        if (! ((int )ii < 15)) {
#line 863
          goto while_break___2;
        }
#line 864
        if ((int )jj & 1) {
          {
#line 864
          printf((char const   */* __restrict  */)"\t%s\n", ata1_cfg_str[ii]);
          }
        }
#line 865
        jj = (__u16 )((int )jj >> 1);
#line 863
        ii = (__u16 )((int )ii + 1);
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 868
  if ((int )dev == 1) {
    {
#line 869
    printf((char const   */* __restrict  */)"\tDRQ response: ");
    }
    {
#line 871
    if (((int )val[0] & 96) == 0) {
#line 871
      goto case_0;
    }
#line 872
    if (((int )val[0] & 96) == 32) {
#line 872
      goto case_32;
    }
#line 873
    if (((int )val[0] & 96) == 64) {
#line 873
      goto case_64;
    }
#line 874
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 871
    printf((char const   */* __restrict  */)"3ms.\n");
    }
#line 871
    goto switch_break___0;
    case_32: /* CIL Label */ 
    {
#line 872
    printf((char const   */* __restrict  */)"<=10ms with INTRQ\n");
    }
#line 872
    goto switch_break___0;
    case_64: /* CIL Label */ 
    {
#line 873
    printf((char const   */* __restrict  */)"50us.\n");
    }
#line 873
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 874
    printf((char const   */* __restrict  */)"unknown.\n");
    }
#line 874
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 876
    printf((char const   */* __restrict  */)"\tPacket size: ");
    }
    {
#line 878
    if (((int )val[0] & 3) == 0) {
#line 878
      goto case_0___0;
    }
#line 879
    if (((int )val[0] & 3) == 1) {
#line 879
      goto case_1;
    }
#line 880
    goto switch_default___0;
    case_0___0: /* CIL Label */ 
    {
#line 878
    printf((char const   */* __restrict  */)"12 bytes\n");
    }
#line 878
    goto switch_break___1;
    case_1: /* CIL Label */ 
    {
#line 879
    printf((char const   */* __restrict  */)"16 bytes\n");
    }
#line 879
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 880
    printf((char const   */* __restrict  */)"Unknown\n");
    }
#line 880
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  } else {
#line 884
    ll = (__u32 )0;
#line 884
    mm = (__u32 )0;
#line 884
    bb = (__u64 )0;
#line 884
    bbbig = (__u64 )0;
#line 885
    if ((int )val[49] & 512) {
#line 886
      ll = ((__u32 )val[61] << 16) | (unsigned int )val[60];
    }
#line 887
    if (ll > 16514064U) {
#line 887
      if (! val[1]) {
        {
#line 888
        printf((char const   */* __restrict  */)"\tCHS addressing not supported\n");
        }
      } else {
#line 887
        goto _L___22;
      }
    } else {
      _L___22: /* CIL Label */ 
      {
#line 890
      jj = (__u16 )((int )val[53] & 1);
#line 891
      printf((char const   */* __restrict  */)"\tLogical\t\tmax\tcurrent\n");
      }
#line 892
      if (jj) {
#line 892
        tmp___0 = (int )val[54];
      } else {
#line 892
        tmp___0 = 0;
      }
      {
#line 892
      printf((char const   */* __restrict  */)"\tcylinders\t%u\t%u\n", (int )val[1],
             tmp___0);
      }
#line 893
      if (jj) {
#line 893
        tmp___1 = (int )val[55];
      } else {
#line 893
        tmp___1 = 0;
      }
      {
#line 893
      printf((char const   */* __restrict  */)"\theads\t\t%u\t%u\n", (int )val[3],
             tmp___1);
      }
#line 894
      if (jj) {
#line 894
        tmp___2 = (int )val[56];
      } else {
#line 894
        tmp___2 = 0;
      }
      {
#line 894
      printf((char const   */* __restrict  */)"\tsectors/track\t%u\t%u\n", (int )val[6],
             tmp___2);
      }
#line 895
      if (jj) {
#line 896
        bb = ((__u64 )val[54] * (__u64 )val[55]) * (__u64 )val[56];
      } else {
#line 898
        bb = ((__u64 )val[1] * (__u64 )val[3]) * (__u64 )val[6];
      }
      {
#line 899
      printf((char const   */* __restrict  */)"\t--\n");
      }
#line 900
      if ((int )min_std == 1) {
#line 900
        if (val[4]) {
          {
#line 901
          printf((char const   */* __restrict  */)"\tbytes/track: %u", (int )val[4]);
#line 902
          printf((char const   */* __restrict  */)"\tbytes/sector: %u\n", (int )val[5]);
          }
        } else
#line 900
        if (val[5]) {
          {
#line 901
          printf((char const   */* __restrict  */)"\tbytes/track: %u", (int )val[4]);
#line 902
          printf((char const   */* __restrict  */)"\tbytes/sector: %u\n", (int )val[5]);
          }
        }
      }
#line 904
      if (jj) {
#line 905
        mm = ((__u32 )val[58] << 16) | (unsigned int )val[57];
#line 907
        if ((int )like_std < 3) {
          {
#line 908
          nn = ((__u32 )val[57] << 16) | (unsigned int )val[58];
#line 910
          tmp___3 = abs((int )((__u64 )mm - bb));
#line 910
          tmp___4 = abs((int )((__u64 )nn - bb));
          }
#line 910
          if (tmp___3 > tmp___4) {
#line 911
            mm = nn;
          }
        }
        {
#line 913
        printf((char const   */* __restrict  */)"\tCHS current addressable sectors:%11u\n",
               mm);
        }
      }
    }
#line 916
    if ((int )val[49] & 512) {
      {
#line 918
      printf((char const   */* __restrict  */)"\tLBA    user addressable sectors:%11u\n",
             ll);
      }
#line 919
      if (((int )val[83] & 49152) == 16384) {
#line 919
        if ((int )val[83] & 1024) {
          {
#line 921
          bbbig = ((((__u64 )val[103] << 48) | ((__u64 )val[102] << 32)) | ((__u64 )val[101] << 16)) | (unsigned long long )val[100];
#line 925
          printf((char const   */* __restrict  */)"\tLBA48  user addressable sectors:%11llu\n",
                 bbbig);
          }
        }
      }
    }
#line 928
    if (((int )val[106] & 49152) != 16384) {
      {
#line 929
      printf((char const   */* __restrict  */)"\t%-31s %11u bytes\n", "Logical/Physical Sector size:",
             sector_bytes___0);
      }
    } else {
#line 931
      lsize = 256U;
#line 931
      pfactor = 1U;
#line 932
      if ((int )val[106] & (1 << 13)) {
#line 933
        pfactor = (unsigned int )(1 << ((int )val[106] & 15));
      }
#line 934
      if ((int )val[106] & (1 << 12)) {
#line 935
        lsize = (unsigned int )(((int )val[118] << 16) | (int )val[117]);
      }
      {
#line 936
      sector_bytes___0 = 2U * lsize;
#line 937
      printf((char const   */* __restrict  */)"\t%-31s %11u bytes\n", "Logical  Sector size:",
             sector_bytes___0);
#line 938
      printf((char const   */* __restrict  */)"\t%-31s %11u bytes\n", "Physical Sector size:",
             sector_bytes___0 * pfactor);
      }
#line 939
      if (((int )val[209] & 49152) == 16384) {
        {
#line 940
        offset = (unsigned int )((int )val[209] & 8191);
#line 941
        printf((char const   */* __restrict  */)"\t%-31s %11u bytes\n", "Logical Sector-0 offset:",
               offset * sector_bytes___0);
        }
      }
    }
#line 944
    if (! bbbig) {
#line 944
      if (ll > mm) {
#line 944
        tmp___5 = ll;
      } else {
#line 944
        tmp___5 = mm;
      }
#line 944
      bbbig = (__u64 )tmp___5;
    }
#line 945
    if (! bbbig) {
#line 945
      bbbig = bb;
    }
    {
#line 946
    bbbig *= (__u64 )(sector_bytes___0 / 512U);
#line 947
    printf((char const   */* __restrict  */)"\tdevice size with M = 1024*1024: %11llu MBytes\n",
           bbbig >> 11);
#line 948
    bbbig = (bbbig << 9) / 1000000ULL;
#line 949
    printf((char const   */* __restrict  */)"\tdevice size with M = 1000*1000: %11llu MBytes ",
           bbbig);
    }
#line 950
    if (bbbig > 1000ULL) {
      {
#line 950
      printf((char const   */* __restrict  */)"(%llu GB)\n", bbbig / 1000ULL);
      }
    } else {
      {
#line 951
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
  {
#line 955
  printf((char const   */* __restrict  */)"\tcache/buffer size  = ");
  }
#line 956
  if ((int )val[20] <= 3) {
#line 956
    if (val[21]) {
#line 956
      if ((int )val[21] != 65535) {
        {
#line 957
        printf((char const   */* __restrict  */)"%u KBytes", (int )val[21] / 2);
        }
#line 958
        if (val[20]) {
          {
#line 959
          printf((char const   */* __restrict  */)" (type=%s)", BuffType[val[20]]);
          }
        }
      } else {
        {
#line 961
        printf((char const   */* __restrict  */)"unknown");
        }
      }
    } else {
      {
#line 961
      printf((char const   */* __restrict  */)"unknown");
      }
    }
  } else {
    {
#line 961
    printf((char const   */* __restrict  */)"unknown");
    }
  }
  {
#line 963
  putchar('\n');
  }
#line 966
  if (val[168]) {
#line 966
    if (((int )val[168] & 65528) == 0) {
      {
#line 967
      printf((char const   */* __restrict  */)"\tForm Factor: ");
      }
      {
#line 969
      if ((int )val[168] == 1) {
#line 969
        goto case_1___0;
      }
#line 972
      if ((int )val[168] == 2) {
#line 972
        goto case_2;
      }
#line 975
      if ((int )val[168] == 3) {
#line 975
        goto case_3;
      }
#line 978
      if ((int )val[168] == 4) {
#line 978
        goto case_4;
      }
#line 981
      if ((int )val[168] == 5) {
#line 981
        goto case_5;
      }
#line 984
      goto switch_default___1;
      case_1___0: /* CIL Label */ 
      {
#line 970
      printf((char const   */* __restrict  */)"5.25 inch");
      }
#line 971
      goto switch_break___2;
      case_2: /* CIL Label */ 
      {
#line 973
      printf((char const   */* __restrict  */)"3.5 inch");
      }
#line 974
      goto switch_break___2;
      case_3: /* CIL Label */ 
      {
#line 976
      printf((char const   */* __restrict  */)"2.5 inch");
      }
#line 977
      goto switch_break___2;
      case_4: /* CIL Label */ 
      {
#line 979
      printf((char const   */* __restrict  */)"1.8 inch");
      }
#line 980
      goto switch_break___2;
      case_5: /* CIL Label */ 
      {
#line 982
      printf((char const   */* __restrict  */)"less than 1.8 inch");
      }
#line 983
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
      {
#line 985
      printf((char const   */* __restrict  */)"unknown (0x%04x]", (int )val[168]);
      }
#line 986
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
      {
#line 988
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
#line 992
  if ((int )val[217] == 1) {
    {
#line 993
    printf((char const   */* __restrict  */)"\tNominal Media Rotation Rate: Solid State Device\n");
    }
  } else
#line 994
  if ((int )val[217] > 1025) {
    {
#line 995
    printf((char const   */* __restrict  */)"\tNominal Media Rotation Rate: %u\n",
           (int )val[217]);
    }
  }
  {
#line 998
  printf((char const   */* __restrict  */)"Capabilities:\n");
#line 999
  printf((char const   */* __restrict  */)"\t");
  }
#line 1000
  if ((int )dev == 1) {
#line 1001
    if ((int )eqpt != 5) {
#line 1002
      if ((int )val[49] & 16384) {
        {
#line 1002
        printf((char const   */* __restrict  */)"Cmd queuing, ");
        }
      }
    }
#line 1004
    if ((int )val[49] & 8192) {
      {
#line 1004
      printf((char const   */* __restrict  */)"Cmd overlap, ");
      }
    }
  }
#line 1006
  if ((int )val[49] & 512) {
    {
#line 1006
    printf((char const   */* __restrict  */)"LBA, ");
    }
  }
#line 1007
  if ((int )like_std != 1) {
    {
#line 1008
    printf((char const   */* __restrict  */)"IORDY");
    }
#line 1009
    if (! ((int )val[49] & 2048)) {
      {
#line 1009
      printf((char const   */* __restrict  */)"(may be)");
      }
    }
#line 1010
    if ((int )val[49] & 1024) {
      {
#line 1010
      printf((char const   */* __restrict  */)"(can");
      }
    } else {
      {
#line 1011
      printf((char const   */* __restrict  */)"(cannot");
      }
    }
    {
#line 1012
    printf((char const   */* __restrict  */)" be disabled)");
    }
  } else {
    {
#line 1014
    printf((char const   */* __restrict  */)"IORDY not likely");
    }
  }
  {
#line 1016
  printf((char const   */* __restrict  */)"\n");
  }
#line 1017
  if ((int )like_std == 1) {
#line 1017
    if (val[20]) {
      {
#line 1018
      kk = val[20];
#line 1019
      printf((char const   */* __restrict  */)"\tBuffer type: %04x: ", (int )kk);
      }
#line 1020
      if ((int )kk < 2) {
        {
#line 1020
        printf((char const   */* __restrict  */)"single port, single-sector");
        }
      } else {
        {
#line 1021
        printf((char const   */* __restrict  */)"dual port, multi-sector");
        }
      }
#line 1022
      if ((int )kk > 2) {
        {
#line 1022
        printf((char const   */* __restrict  */)" with read caching ability");
        }
      }
      {
#line 1023
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
#line 1025
  jj = (__u16 )0;
#line 1026
  if ((int )min_std == 1) {
#line 1026
    if (val[21]) {
#line 1026
      if ((int )val[21] != 65535) {
        {
#line 1027
        printf((char const   */* __restrict  */)"\tBuffer size: %.1fkB", (double )((float )val[21] / (float )2));
#line 1028
        jj = (__u16 )1;
        }
      }
    }
  }
#line 1030
  if ((int )min_std < 4) {
#line 1030
    if (val[22]) {
      {
#line 1031
      printf((char const   */* __restrict  */)"\tbytes avail on r/w long: %u", (int )val[22]);
#line 1032
      jj = (__u16 )1;
      }
    }
  }
#line 1034
  if ((int )eqpt != 5) {
#line 1034
    if ((int )like_std > 3) {
#line 1035
      has_queuing = 0;
#line 1036
      if (transport == 1) {
#line 1036
        goto _L___23;
      } else
#line 1036
      if (val[76]) {
#line 1036
        if ((int )val[76] != 65535) {
          _L___23: /* CIL Label */ 
#line 1037
          if ((int )val[76] & 256) {
#line 1038
            has_queuing = 1;
          }
        }
      }
#line 1040
      if (((int )val[83] & 49152) == 16384) {
#line 1040
        if ((int )val[83] & 2) {
#line 1041
          has_queuing = 1;
        }
      }
#line 1043
      if (has_queuing) {
        {
#line 1044
        printf((char const   */* __restrict  */)"\tQueue depth: %u", ((int )val[75] & 31) + 1);
#line 1045
        jj = (__u16 )1;
        }
      }
    }
  }
#line 1048
  if (jj) {
    {
#line 1048
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 1049
  if ((int )dev == 0) {
#line 1050
    if ((int )like_std == 1) {
      {
#line 1051
      printf((char const   */* __restrict  */)"\tCan");
      }
#line 1052
      if (! val[48]) {
        {
#line 1052
        printf((char const   */* __restrict  */)"not");
        }
      }
      {
#line 1053
      printf((char const   */* __restrict  */)" perform double-word IO\n");
      }
    } else {
      {
#line 1055
      printf((char const   */* __restrict  */)"\tStandby timer values: spec\'d by ");
      }
#line 1056
      if ((int )val[49] & 8192) {
        {
#line 1056
        printf((char const   */* __restrict  */)"Standard");
        }
      } else {
        {
#line 1057
        printf((char const   */* __restrict  */)"Vendor");
        }
      }
#line 1058
      if ((int )like_std > 3) {
#line 1058
        if (((int )val[50] & 49152) == 16384) {
#line 1059
          if ((int )val[50] & 1) {
            {
#line 1059
            printf((char const   */* __restrict  */)", with ");
            }
          } else {
            {
#line 1060
            printf((char const   */* __restrict  */)", no ");
            }
          }
          {
#line 1061
          printf((char const   */* __restrict  */)"device specific minimum\n");
          }
        } else {
          {
#line 1062
          printf((char const   */* __restrict  */)"\n");
          }
        }
      } else {
        {
#line 1062
        printf((char const   */* __restrict  */)"\n");
        }
      }
    }
    {
#line 1064
    printf((char const   */* __restrict  */)"\tR/W multiple sector transfer: ");
    }
#line 1065
    if ((int )like_std < 3) {
#line 1065
      if (! ((int )val[47] & 255)) {
        {
#line 1066
        printf((char const   */* __restrict  */)"not supported\n");
        }
      } else {
#line 1065
        goto _L___24;
      }
    } else {
      _L___24: /* CIL Label */ 
      {
#line 1068
      printf((char const   */* __restrict  */)"Max = %u\t", (int )val[47] & 255);
#line 1069
      printf((char const   */* __restrict  */)"Current = ");
      }
#line 1070
      if ((int )val[59] & 256) {
        {
#line 1071
        printf((char const   */* __restrict  */)"%u\n", (int )val[59] & 255);
        }
      } else {
        {
#line 1072
        printf((char const   */* __restrict  */)"?\n");
        }
      }
    }
#line 1074
    if ((int )like_std > 3) {
#line 1074
      if (((int )val[83] & 49160) == 16392) {
        {
#line 1075
        printf((char const   */* __restrict  */)"\tAdvanced power management level: ");
        }
#line 1076
        if ((int )val[86] & 8) {
          {
#line 1077
          printf((char const   */* __restrict  */)"%u\n", (int )val[91] & 255);
          }
        } else {
          {
#line 1079
          printf((char const   */* __restrict  */)"disabled\n");
          }
        }
      }
    }
#line 1081
    if ((int )like_std > 5) {
#line 1082
      if (val[94]) {
        {
#line 1083
        printf((char const   */* __restrict  */)"\tRecommended acoustic management value: %u, current value: %u\n",
               ((int )val[94] >> 8) & 255, (int )val[94] & 255);
        }
      }
    }
  } else {
#line 1087
    if ((int )eqpt != 5) {
#line 1088
      if ((int )val[49] & 4096) {
        {
#line 1088
        printf((char const   */* __restrict  */)"\tATA sw reset required\n");
        }
      }
    }
#line 1090
    if (val[71]) {
#line 1090
      goto _L___25;
    } else
#line 1090
    if (val[72]) {
      _L___25: /* CIL Label */ 
      {
#line 1091
      printf((char const   */* __restrict  */)"\tOverlap support:");
      }
#line 1092
      if (val[71]) {
        {
#line 1092
        printf((char const   */* __restrict  */)" %uus to release bus.", (int )val[71]);
        }
      }
#line 1093
      if (val[72]) {
        {
#line 1093
        printf((char const   */* __restrict  */)" %uus to clear BSY after SERVICE cmd.",
               (int )val[72]);
        }
      }
      {
#line 1094
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
#line 1099
  if ((int )dev == 1) {
#line 1099
    if ((int )val[62] & 32768) {
      {
#line 1100
      atapi_has_dmadir = 1;
#line 1101
      sdma_ok = 0;
#line 1102
      printf((char const   */* __restrict  */)"\tDMADIR bit required in PACKET commands\n");
      }
    } else {
#line 1099
      goto _L___26;
    }
  } else {
    _L___26: /* CIL Label */ 
#line 1104
    w62 = val[62];
#line 1105
    hi = (__u8 )((int )w62 >> 8);
#line 1105
    lo = (__u8 )w62;
#line 1106
    if (! w62) {
#line 1107
      sdma_ok = 0;
    } else
#line 1106
    if ((int )lo & 248) {
#line 1107
      sdma_ok = 0;
    } else
#line 1108
    if (hi) {
#line 1108
      if ((int )hi != 1) {
#line 1108
        if ((int )hi != 2) {
#line 1108
          if ((int )hi != 4) {
#line 1109
            sdma_ok = 0;
          } else {
#line 1111
            sdma_ok = 1;
          }
        } else {
#line 1111
          sdma_ok = 1;
        }
      } else {
#line 1111
        sdma_ok = 1;
      }
    } else {
#line 1111
      sdma_ok = 1;
    }
  }
  {
#line 1114
  printf((char const   */* __restrict  */)"\tDMA: ");
  }
#line 1116
  if (! atapi_has_dmadir) {
#line 1116
    if (! ((int )val[49] & 256)) {
      {
#line 1117
      printf((char const   */* __restrict  */)"not supported\n");
      }
    } else {
#line 1116
      goto _L___30;
    }
  } else {
    _L___30: /* CIL Label */ 
#line 1119
    if (val[52]) {
#line 1119
      if (! val[62]) {
#line 1119
        if (! val[63]) {
          {
#line 1120
          printf((char const   */* __restrict  */)"sdma%u", ((int )val[52] & 65280) >> 8);
          }
        } else {
#line 1119
          goto _L___28;
        }
      } else {
#line 1119
        goto _L___28;
      }
    } else {
      _L___28: /* CIL Label */ 
#line 1122
      if (sdma_ok) {
        {
#line 1123
        kk = (__u16 )((int )val[62] >> 8);
#line 1124
        jj = val[62];
#line 1125
        tmp___6 = mode_loop(jj, kk, 's', & have_mode);
#line 1125
        err_dma = (__u8 )((int )err_dma + (int )tmp___6);
        }
      }
#line 1127
      if (val[63]) {
#line 1128
        kk = (__u16 )((int )val[63] >> 8);
#line 1129
        if (atapi_has_dmadir) {
#line 1129
          jj = (__u16 )(((int )val[62] >> 7) & 7);
        } else {
#line 1129
          jj = val[63];
        }
        {
#line 1130
        tmp___7 = mode_loop(jj, kk, 'm', & have_mode);
#line 1130
        err_dma = (__u8 )((int )err_dma + (int )tmp___7);
        }
      }
#line 1132
      if ((int )val[53] & 4) {
#line 1132
        if (val[88]) {
#line 1133
          kk = (__u16 )((int )val[88] >> 8);
#line 1134
          if (atapi_has_dmadir) {
#line 1134
            jj = (__u16 )((int )val[62] & 127);
          } else {
#line 1134
            jj = val[88];
          }
          {
#line 1135
          tmp___8 = mode_loop(jj, kk, 'u', & have_mode);
#line 1135
          err_dma = (__u8 )((int )err_dma + (int )tmp___8);
          }
        }
      }
#line 1137
      if (err_dma) {
        {
#line 1138
        printf((char const   */* __restrict  */)"(?)");
        }
      } else
#line 1137
      if (! have_mode) {
        {
#line 1138
        printf((char const   */* __restrict  */)"(?)");
        }
      }
    }
    {
#line 1140
    printf((char const   */* __restrict  */)"\n");
    }
#line 1142
    if ((int )dev == 1) {
#line 1142
      if ((int )eqpt != 5) {
#line 1142
        if ((int )val[49] & 32768) {
          {
#line 1143
          printf((char const   */* __restrict  */)"\t     Interleaved DMA support\n");
          }
        }
      }
    }
#line 1145
    if ((int )val[53] & 2) {
#line 1145
      if (val[65]) {
#line 1145
        goto _L___29;
      } else
#line 1145
      if (val[66]) {
        _L___29: /* CIL Label */ 
        {
#line 1147
        printf((char const   */* __restrict  */)"\t     Cycle time:");
        }
#line 1148
        if (val[65]) {
          {
#line 1149
          printf((char const   */* __restrict  */)" min=%uns", (int )val[65]);
          }
        }
#line 1150
        if (val[66]) {
          {
#line 1151
          printf((char const   */* __restrict  */)" recommended=%uns", (int )val[66]);
          }
        }
        {
#line 1152
        printf((char const   */* __restrict  */)"\n");
        }
      }
    }
  }
  {
#line 1157
  printf((char const   */* __restrict  */)"\tPIO: ");
  }
#line 1160
  if ((int )val[53] & 2) {
#line 1160
    if ((int )val[64] & 255) {
#line 1161
      jj = (__u16 )((((int )val[64] & 255) << 3) | 7);
#line 1162
      ii = (__u16 )0;
      {
#line 1162
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1162
        if (! ((int )ii <= 8)) {
#line 1162
          goto while_break___3;
        }
#line 1163
        if ((int )jj & 1) {
          {
#line 1164
          printf((char const   */* __restrict  */)"pio%d ", (int )ii);
          }
        }
#line 1165
        jj = (__u16 )((int )jj >> 1);
#line 1162
        ii = (__u16 )((int )ii + 1);
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1167
      printf((char const   */* __restrict  */)"\n");
      }
    } else {
#line 1160
      goto _L___32;
    }
  } else
  _L___32: /* CIL Label */ 
#line 1168
  if ((int )min_std < 5) {
#line 1168
    goto _L___31;
  } else
#line 1168
  if ((int )eqpt == 5) {
    _L___31: /* CIL Label */ 
#line 1168
    if ((int )val[51] >> 8 <= 2) {
#line 1169
      ii = (__u16 )0;
      {
#line 1169
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1169
        if (! ((int )ii <= (int )val[51] >> 8)) {
#line 1169
          goto while_break___4;
        }
        {
#line 1170
        printf((char const   */* __restrict  */)"pio%d ", (int )ii);
#line 1169
        ii = (__u16 )((int )ii + 1);
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1172
      printf((char const   */* __restrict  */)"\n");
      }
    } else {
      {
#line 1173
      printf((char const   */* __restrict  */)"unknown\n");
      }
    }
  } else {
    {
#line 1173
    printf((char const   */* __restrict  */)"unknown\n");
    }
  }
#line 1174
  if ((int )val[53] & 2) {
#line 1175
    if (val[67]) {
#line 1175
      goto _L___33;
    } else
#line 1175
    if (val[68]) {
      _L___33: /* CIL Label */ 
      {
#line 1176
      printf((char const   */* __restrict  */)"\t     Cycle time:");
      }
#line 1177
      if (val[67]) {
        {
#line 1178
        printf((char const   */* __restrict  */)" no flow control=%uns", (int )val[67]);
        }
      }
#line 1179
      if (val[68]) {
        {
#line 1180
        printf((char const   */* __restrict  */)"  IORDY flow control=%uns", (int )val[68]);
        }
      }
      {
#line 1181
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
#line 1185
  if (((int )val[83] & 49152) == 16384) {
    {
#line 1186
    printf((char const   */* __restrict  */)"Commands/features:\n\tEnabled\tSupported:\n");
#line 1187
    print_features((__u16 )((int )val[82] & 32767), val[85], feat_word82_str);
    }
#line 1188
    if (((int )val[83] & 49152) == 16384) {
      {
#line 1189
      print_features((__u16 )((int )val[83] & 16383), val[86], feat_word83_str);
      }
    }
#line 1190
    if (((int )val[84] & 49152) == 16384) {
#line 1190
      if (((int )val[87] & 49152) == 16384) {
        {
#line 1192
        print_features((__u16 )((int )val[84] & 16383), val[87], feat_word84_str);
        }
#line 1193
        if (((int )val[84] & 6144) == 6144) {
#line 1193
          if (val[116]) {
#line 1193
            if ((int )val[116] != 65535) {
              {
#line 1194
              printf((char const   */* __restrict  */)"                (%u msec for TLC completion timer)\n",
                     10U * (unsigned int )val[116]);
              }
            }
          }
        }
      }
    }
#line 1196
    if (((int )val[83] & 49152) == 16384) {
#line 1196
      if (((int )val[86] & 32768) == 32768) {
#line 1196
        if (((int )val[119] & 49152) == 16384) {
#line 1196
          if (((int )val[120] & 49152) == 16384) {
            {
#line 1200
            print_features((__u16 )((int )val[119] & 16383), val[120], feat_3_str);
            }
          }
        }
      }
    }
#line 1201
    if (transport == 1) {
      {
#line 1202
      print_features(val[76], val[76], cap_sata0_str);
      }
    } else
#line 1201
    if (val[76]) {
#line 1201
      if ((int )val[76] != 65535) {
        {
#line 1202
        print_features(val[76], val[76], cap_sata0_str);
        }
      }
    }
#line 1203
    if (transport == 1) {
      {
#line 1204
      print_features(val[78], val[79], feat_sata0_str);
      }
    } else
#line 1203
    if (val[78]) {
#line 1203
      if ((int )val[78] != 65535) {
        {
#line 1204
        print_features(val[78], val[79], feat_sata0_str);
        }
      }
    }
#line 1205
    if ((int )val[206] & 1) {
      {
#line 1206
      print_features(val[206], (__u16 )((int )val[206] & 63), feat_sct_str);
      }
    }
  }
#line 1208
  if ((int )like_std > 6) {
    {
#line 1209
    trimd = (__u16 )(1 << 14);
#line 1210
    trimz = (__u16 )(1 << 5);
#line 1211
    word69 = (__u16 )((int )val[69] & ~ ((int )trimz | (int )trimd));
#line 1212
    print_features(word69, word69, feat_word69_str);
    }
#line 1213
    if ((int )val[169] & 1) {
#line 1213
      if ((int )val[169] != 65535) {
        {
#line 1214
        printf((char const   */* __restrict  */)"\t   *\tData Set Management TRIM supported");
        }
#line 1215
        if (val[105]) {
#line 1215
          if ((int )val[105] != 65535) {
#line 1216
            if ((int )val[105] > 1) {
#line 1216
              tmp___9 = "s";
            } else {
#line 1216
              tmp___9 = "";
            }
            {
#line 1216
            printf((char const   */* __restrict  */)" (limit %u block%s)\n", (int )val[105],
                   tmp___9);
            }
          } else {
            {
#line 1218
            printf((char const   */* __restrict  */)" (limit unknown)\n");
            }
          }
        } else {
          {
#line 1218
          printf((char const   */* __restrict  */)" (limit unknown)\n");
          }
        }
#line 1219
        if ((int )val[69] & (int )trimd) {
#line 1220
          if ((int )val[69] & (int )trimz) {
            {
#line 1221
            print_features(trimz, trimz, feat_word69_str);
            }
          } else {
            {
#line 1223
            print_features(trimd, trimd, feat_word69_str);
            }
          }
        }
      }
    }
  }
#line 1229
  if (is_cfa) {
#line 1232
    modes[0] = (char )'\000';
#line 1235
    max = (unsigned int )((int )val[163] & 7);
#line 1236
    if (max == 1U) {
#line 1236
      goto _L___34;
    } else
#line 1236
    if (max == 2U) {
      _L___34: /* CIL Label */ 
#line 1237
      selected = (unsigned int )(((int )val[163] >> 6) & 7);
#line 1238
      mode = 1U;
      {
#line 1238
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1238
        if (! (mode <= max)) {
#line 1238
          goto while_break___5;
        }
#line 1239
        if (mode == selected) {
          {
#line 1240
          strcat((char */* __restrict  */)(modes), (char const   */* __restrict  */)"*");
          }
        }
        {
#line 1241
        tmp___10 = strlen((char const   *)(modes));
#line 1241
        sprintf((char */* __restrict  */)(modes + tmp___10), (char const   */* __restrict  */)"pio%u ",
                mode + 4U);
#line 1238
        mode ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 1245
    max = (unsigned int )(((int )val[163] >> 3) & 7);
#line 1246
    if (max == 1U) {
#line 1246
      goto _L___35;
    } else
#line 1246
    if (max == 2U) {
      _L___35: /* CIL Label */ 
#line 1247
      selected = (unsigned int )(((int )val[163] >> 9) & 7);
#line 1248
      mode = 1U;
      {
#line 1248
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1248
        if (! (mode <= max)) {
#line 1248
          goto while_break___6;
        }
#line 1249
        if (mode == selected) {
          {
#line 1250
          strcat((char */* __restrict  */)(modes), (char const   */* __restrict  */)"*");
          }
        }
        {
#line 1251
        tmp___11 = strlen((char const   *)(modes));
#line 1251
        sprintf((char */* __restrict  */)(modes + tmp___11), (char const   */* __restrict  */)"mdma%u ",
                mode + 2U);
#line 1248
        mode ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 1254
    if ((int )val[164] & 32768) {
#line 1258
      max = (unsigned int )((int )val[164] & 7);
#line 1259
      if (max <= 3U) {
        {
#line 1260
        printf((char const   */* __restrict  */)"\t\tCFA max advanced io_udma cycle time: %uns\n",
               (int const   )io_times[max]);
        }
      }
#line 1261
      max = (unsigned int )(((int )val[164] >> 3) & 7);
#line 1262
      if (max <= 3U) {
        {
#line 1263
        printf((char const   */* __restrict  */)"\t\tCFA max advanced mem_udma cycle time: %uns\n",
               (int const   )mem_times[max]);
        }
      }
#line 1265
      max = (unsigned int )(((int )val[164] >> 6) & 7);
#line 1266
      if (max <= 6U) {
#line 1267
        selected = (unsigned int )(((int )val[164] >> 12) & 7);
#line 1268
        mode = 0U;
        {
#line 1268
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1268
          if (! (mode <= max)) {
#line 1268
            goto while_break___7;
          }
#line 1269
          if (mode == selected) {
            {
#line 1270
            strcat((char */* __restrict  */)(modes), (char const   */* __restrict  */)"*");
            }
          }
          {
#line 1271
          tmp___12 = strlen((char const   *)(modes));
#line 1271
          sprintf((char */* __restrict  */)(modes + tmp___12), (char const   */* __restrict  */)"io_udma%u ",
                  mode + 4U);
#line 1268
          mode ++;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
      }
#line 1275
      max = (unsigned int )(((int )val[164] >> 9) & 7);
#line 1276
      if (max <= 6U) {
#line 1277
        selected = (unsigned int )(((int )val[164] >> 12) & 7);
#line 1278
        mode = 0U;
        {
#line 1278
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 1278
          if (! (mode <= max)) {
#line 1278
            goto while_break___8;
          }
#line 1279
          if (mode == selected) {
            {
#line 1280
            strcat((char */* __restrict  */)(modes), (char const   */* __restrict  */)"*");
            }
          }
          {
#line 1281
          tmp___13 = strlen((char const   *)(modes));
#line 1281
          sprintf((char */* __restrict  */)(modes + tmp___13), (char const   */* __restrict  */)"mem_udma%u ",
                  mode + 4U);
#line 1278
          mode ++;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
      }
    }
#line 1285
    if (modes[0]) {
      {
#line 1286
      printf((char const   */* __restrict  */)"\t   *\tCFA advanced modes: %s\n",
             modes);
      }
    }
#line 1288
    if ((int )val[160] & 32768) {
      {
#line 1289
      putchar('\t');
      }
#line 1290
      if (((int )val[160] & 8192) == 0) {
        {
#line 1291
        printf((char const   */* __restrict  */)"   *");
        }
      }
      {
#line 1292
      printf((char const   */* __restrict  */)"\tCFA Power Level 1 ");
      }
#line 1293
      if ((int )val[160] & 8192) {
        {
#line 1294
        printf((char const   */* __restrict  */)" not supported");
        }
      }
#line 1295
      if ((int )val[160] & 4095) {
        {
#line 1296
        printf((char const   */* __restrict  */)" (max %umA)", (int )val[160] & 4095);
        }
      }
      {
#line 1297
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 1300
    if (val[162]) {
#line 1300
      if ((int )val[162] != 65535) {
#line 1301
        if ((int )val[162] & 1) {
          {
#line 1302
          printf((char const   */* __restrict  */)"\t\tKey Management (CPRM) feature set\n");
          }
        }
      }
    }
  }
#line 1306
  if (((int )val[127] & 3) == 1) {
    {
#line 1307
    printf((char const   */* __restrict  */)"\t\tRemovable Media Status Notification feature set supported\n");
    }
  }
#line 1310
  if ((int )eqpt != 5) {
#line 1310
    if ((int )like_std > 3) {
#line 1310
      if (val[128]) {
#line 1310
        goto _L___38;
      } else
#line 1310
      if (val[89]) {
#line 1310
        goto _L___38;
      } else
#line 1310
      if (val[90]) {
        _L___38: /* CIL Label */ 
        {
#line 1312
        printf((char const   */* __restrict  */)"Security: \n");
        }
#line 1313
        if (val[92]) {
#line 1313
          if ((int )val[92] != 65535) {
            {
#line 1314
            printf((char const   */* __restrict  */)"\tMaster password revision code = %u\n",
                   (int )val[92]);
            }
          }
        }
#line 1315
        jj = val[128];
#line 1316
        if (jj) {
#line 1317
          ii = (__u16 )0;
          {
#line 1317
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 1317
            if (! ((int )ii < 6)) {
#line 1317
              goto while_break___9;
            }
#line 1318
            if (! ((int )jj & 1)) {
              {
#line 1318
              printf((char const   */* __restrict  */)"\tnot\t");
              }
            } else {
              {
#line 1319
              printf((char const   */* __restrict  */)"\t\t");
              }
            }
            {
#line 1320
            printf((char const   */* __restrict  */)"%s\n", secu_str[ii]);
#line 1321
            jj = (__u16 )((int )jj >> 1);
#line 1317
            ii = (__u16 )((int )ii + 1);
            }
          }
          while_break___9: /* CIL Label */ ;
          }
#line 1323
          if ((int )val[128] & 2) {
            {
#line 1324
            printf((char const   */* __restrict  */)"\tSecurity level ");
            }
#line 1325
            if ((int )val[128] & 256) {
              {
#line 1325
              printf((char const   */* __restrict  */)"maximum\n");
              }
            } else {
              {
#line 1326
              printf((char const   */* __restrict  */)"high\n");
              }
            }
          }
        }
#line 1329
        jj = val[89];
#line 1330
        kk = val[90];
#line 1331
        if (jj) {
#line 1331
          if ((int )jj <= 255) {
#line 1331
            goto _L___36;
          } else {
#line 1331
            goto _L___37;
          }
        } else
        _L___37: /* CIL Label */ 
#line 1331
        if (kk) {
#line 1331
          if ((int )kk <= 255) {
            _L___36: /* CIL Label */ 
            {
#line 1332
            printf((char const   */* __restrict  */)"\t");
            }
#line 1333
            if (jj) {
#line 1334
              if ((int )jj == 255) {
                {
#line 1335
                printf((char const   */* __restrict  */)"more than 508");
                }
              } else {
                {
#line 1337
                printf((char const   */* __restrict  */)"%u", (int )jj * 2);
                }
              }
              {
#line 1338
              printf((char const   */* __restrict  */)"min for SECURITY ERASE UNIT. ");
              }
            }
#line 1340
            if (kk) {
#line 1341
              if ((int )kk == 255) {
                {
#line 1342
                printf((char const   */* __restrict  */)"more than 508");
                }
              } else {
                {
#line 1344
                printf((char const   */* __restrict  */)"%u", (int )kk * 2);
                }
              }
              {
#line 1345
              printf((char const   */* __restrict  */)"min for ENHANCED SECURITY ERASE UNIT. ");
              }
            }
            {
#line 1347
            printf((char const   */* __restrict  */)"\n");
            }
          }
        }
      }
    }
  }
#line 1351
  if ((int )eqpt != 5) {
#line 1351
    if ((int )like_std > 3) {
#line 1351
      if ((int )val[84] & 256) {
        {
#line 1352
        printf((char const   */* __restrict  */)"Logical Unit WWN Device Identifier: %04x%04x%04x%04x\n",
               (int )val[108], (int )val[109], (int )val[110], (int )val[111]);
#line 1353
        printf((char const   */* __restrict  */)"\tNAA\t\t: %x\n", ((int )val[108] & 61440) >> 12);
#line 1354
        printf((char const   */* __restrict  */)"\tIEEE OUI\t: %06x\n", (((int )val[108] & 4095) << 12) | (((int )val[109] & 65520) >> 4));
#line 1355
        printf((char const   */* __restrict  */)"\tUnique ID\t: %x%08x\n", (int )val[109] & 15,
               ((int )val[110] << 16) | (int )val[111]);
        }
      }
    }
  }
#line 1359
  if (((int )val[93] & 49152) == 16384) {
    {
#line 1360
    printf((char const   */* __restrict  */)"HW reset results:\n");
    }
#line 1361
    if ((int )val[93] & 8192) {
      {
#line 1361
      printf((char const   */* __restrict  */)"\tCBLID- above Vih\n");
      }
    } else {
      {
#line 1362
      printf((char const   */* __restrict  */)"\tCBLID- below Vih\n");
      }
    }
#line 1363
    if ((int )val[93] & 1) {
      {
#line 1364
      printf((char const   */* __restrict  */)"\tDevice num = 0");
#line 1365
      jj = val[93];
      }
    } else {
      {
#line 1367
      printf((char const   */* __restrict  */)"\tDevice num = 1");
#line 1368
      jj = (__u16 )((int )val[93] >> 8);
      }
    }
#line 1370
    if (((int )jj & 6) == 2) {
      {
#line 1371
      printf((char const   */* __restrict  */)" determined by the jumper");
      }
    } else
#line 1372
    if (((int )jj & 6) == 4) {
      {
#line 1373
      printf((char const   */* __restrict  */)" determined by CSEL");
      }
    }
    {
#line 1374
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 1378
  if ((int )like_std > 4) {
#line 1378
    if ((int )eqpt != 5) {
#line 1379
      if (((int )val[255] & 255) == 165) {
#line 1380
        if (chksum) {
#line 1380
          tmp___14 = "in";
        } else {
#line 1380
          tmp___14 = "";
        }
        {
#line 1380
        printf((char const   */* __restrict  */)"Checksum: %scorrect", tmp___14);
        }
#line 1381
        if (chksum) {
          {
#line 1382
          printf((char const   */* __restrict  */)" (0x%02x), expected 0x%02x\n",
                 (int )chksum, 256 - (int )chksum);
          }
        }
        {
#line 1383
        putchar('\n');
        }
      } else {
        {
#line 1385
        printf((char const   */* __restrict  */)"Integrity word not set (found 0x%04x, expected 0x%02x%02x)\n",
               (int )val[255], 256 - (int )chksum, 165);
        }
      }
    }
  }
#line 1389
  return;
}
}
#line 1391 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
__u8 mode_loop(__u16 mode_sup , __u16 mode_sel , int cc , __u8 *have_mode ) 
{ 
  __u16 ii ;
  __u8 err_dma ;

  {
#line 1393
  err_dma = (__u8 )0;
#line 1394
  ii = (__u16 )0;
  {
#line 1394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1394
    if (! ((int )ii <= 7)) {
#line 1394
      goto while_break;
    }
#line 1395
    if ((int )mode_sel & 1) {
      {
#line 1396
      printf((char const   */* __restrict  */)"*%cdma%u ", cc, (int )ii);
      }
#line 1397
      if (*have_mode) {
#line 1397
        err_dma = (__u8 )1;
      }
#line 1398
      *have_mode = (__u8 )1;
    } else
#line 1399
    if ((int )mode_sup & 1) {
      {
#line 1400
      printf((char const   */* __restrict  */)"%cdma%u ", cc, (int )ii);
      }
    }
#line 1402
    mode_sup = (__u16 )((int )mode_sup >> 1);
#line 1402
    mode_sel = (__u16 )((int )mode_sel >> 1);
#line 1394
    ii = (__u16 )((int )ii + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1404
  return (err_dma);
}
}
#line 1407 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/identify.c"
void dco_identify_print(__u16 *dco ) 
{ 
  __u64 lba ;

  {
  {
#line 1411
  printf((char const   */* __restrict  */)"DCO Revision: 0x%04x", (int )*(dco + 0));
  }
#line 1412
  if ((int )*(dco + 0) == 0) {
    {
#line 1413
    printf((char const   */* __restrict  */)" -- unknown, treating as 0002");
    }
  } else
#line 1412
  if ((int )*(dco + 0) > 2) {
    {
#line 1413
    printf((char const   */* __restrict  */)" -- unknown, treating as 0002");
    }
  }
  {
#line 1414
  printf((char const   */* __restrict  */)"\nThe following features can be selectively disabled via DCO:\n");
#line 1416
  printf((char const   */* __restrict  */)"\tTransfer modes:\n\t\t");
  }
#line 1417
  if ((int )*(dco + 1) & 7) {
#line 1418
    if ((int )*(dco + 1) & (1 << 2)) {
      {
#line 1418
      printf((char const   */* __restrict  */)" mdma0 mdma1 mdma2");
      }
    } else
#line 1419
    if ((int )*(dco + 1) & (1 << 1)) {
      {
#line 1419
      printf((char const   */* __restrict  */)" mdma0 mdma1");
      }
    } else
#line 1420
    if ((int )*(dco + 1) & 1) {
      {
#line 1420
      printf((char const   */* __restrict  */)" mdma0");
      }
    }
    {
#line 1421
    printf((char const   */* __restrict  */)"\n\t\t");
    }
  }
#line 1423
  if ((int )*(dco + 2) & (1 << 6)) {
    {
#line 1424
    printf((char const   */* __restrict  */)" udma0 udma1 udma2 udma3 udma4 udma5 udma6");
    }
#line 1425
    if ((int )*(dco + 0) < 2) {
      {
#line 1426
      printf((char const   */* __restrict  */)"(?)");
      }
    }
  } else
#line 1428
  if ((int )*(dco + 2) & (1 << 5)) {
    {
#line 1428
    printf((char const   */* __restrict  */)" udma0 udma1 udma2 udma3 udma4 udma5");
    }
  } else
#line 1429
  if ((int )*(dco + 2) & (1 << 4)) {
    {
#line 1429
    printf((char const   */* __restrict  */)" udma0 udma1 udma2 udma3 udma4");
    }
  } else
#line 1430
  if ((int )*(dco + 2) & (1 << 3)) {
    {
#line 1430
    printf((char const   */* __restrict  */)" udma0 udma1 udma2 udma3");
    }
  } else
#line 1431
  if ((int )*(dco + 2) & (1 << 2)) {
    {
#line 1431
    printf((char const   */* __restrict  */)" udma0 udma1 udma2");
    }
  } else
#line 1432
  if ((int )*(dco + 2) & (1 << 1)) {
    {
#line 1432
    printf((char const   */* __restrict  */)" udma0 udma1");
    }
  } else
#line 1433
  if ((int )*(dco + 2) & 1) {
    {
#line 1433
    printf((char const   */* __restrict  */)" udma0");
    }
  }
  {
#line 1434
  putchar('\n');
#line 1436
  lba = ((((__u64 )*(dco + 5) << 32) | (unsigned long long )((int )*(dco + 4) << 16)) | (unsigned long long )*(dco + 3)) + 1ULL;
#line 1437
  printf((char const   */* __restrict  */)"\tReal max sectors: %llu\n", lba);
#line 1439
  printf((char const   */* __restrict  */)"\tATA command/feature sets:");
  }
#line 1440
  if ((int )*(dco + 7) & 511) {
    {
#line 1441
    printf((char const   */* __restrict  */)"\n\t\t");
    }
#line 1442
    if ((int )*(dco + 7) & 1) {
      {
#line 1442
      printf((char const   */* __restrict  */)" SMART");
      }
    }
#line 1443
    if ((int )*(dco + 7) & (1 << 1)) {
      {
#line 1443
      printf((char const   */* __restrict  */)" self_test");
      }
    }
#line 1444
    if ((int )*(dco + 7) & (1 << 2)) {
      {
#line 1444
      printf((char const   */* __restrict  */)" error_log");
      }
    }
#line 1445
    if ((int )*(dco + 7) & (1 << 3)) {
      {
#line 1445
      printf((char const   */* __restrict  */)" security");
      }
    }
#line 1446
    if ((int )*(dco + 7) & (1 << 4)) {
      {
#line 1446
      printf((char const   */* __restrict  */)" PUIS");
      }
    }
#line 1447
    if ((int )*(dco + 7) & (1 << 5)) {
      {
#line 1447
      printf((char const   */* __restrict  */)" TCQ");
      }
    }
#line 1448
    if ((int )*(dco + 7) & (1 << 6)) {
      {
#line 1448
      printf((char const   */* __restrict  */)" AAM");
      }
    }
#line 1449
    if ((int )*(dco + 7) & (1 << 7)) {
      {
#line 1449
      printf((char const   */* __restrict  */)" HPA");
      }
    }
#line 1450
    if ((int )*(dco + 7) & (1 << 8)) {
      {
#line 1450
      printf((char const   */* __restrict  */)" 48_bit");
      }
    }
  }
#line 1452
  if ((int )*(dco + 7) & 65024) {
    {
#line 1453
    printf((char const   */* __restrict  */)"\n\t\t");
    }
#line 1454
    if ((int )*(dco + 0) < 2) {
      {
#line 1455
      printf((char const   */* __restrict  */)" (?):");
      }
    }
#line 1456
    if ((int )*(dco + 7) & (1 << 9)) {
      {
#line 1456
      printf((char const   */* __restrict  */)" streaming");
      }
    }
#line 1457
    if ((int )*(dco + 7) & (1 << 10)) {
      {
#line 1457
      printf((char const   */* __restrict  */)" TLC_Reserved_7[10]");
      }
    }
#line 1458
    if ((int )*(dco + 7) & (1 << 11)) {
      {
#line 1458
      printf((char const   */* __restrict  */)" FUA");
      }
    }
#line 1459
    if ((int )*(dco + 7) & (1 << 12)) {
      {
#line 1459
      printf((char const   */* __restrict  */)" selective_test");
      }
    }
#line 1460
    if ((int )*(dco + 7) & (1 << 13)) {
      {
#line 1460
      printf((char const   */* __restrict  */)" conveyance_test");
      }
    }
#line 1461
    if ((int )*(dco + 7) & (1 << 14)) {
      {
#line 1461
      printf((char const   */* __restrict  */)" write_read_verify");
      }
    }
#line 1462
    if ((int )*(dco + 7) & (1 << 15)) {
      {
#line 1462
      printf((char const   */* __restrict  */)" reserved_7[15]");
      }
    }
  }
#line 1464
  if ((int )*(dco + 21) & 63488) {
    {
#line 1465
    printf((char const   */* __restrict  */)"\n\t\t");
    }
#line 1466
    if ((int )*(dco + 0) < 2) {
      {
#line 1467
      printf((char const   */* __restrict  */)" (?):");
      }
    }
#line 1468
    if ((int )*(dco + 21) & (1 << 11)) {
      {
#line 1468
      printf((char const   */* __restrict  */)" free_fall");
      }
    }
#line 1469
    if ((int )*(dco + 21) & (1 << 12)) {
      {
#line 1469
      printf((char const   */* __restrict  */)" trusted_computing");
      }
    }
#line 1470
    if ((int )*(dco + 21) & (1 << 13)) {
      {
#line 1470
      printf((char const   */* __restrict  */)" WRITE_UNC_EXT");
      }
    }
#line 1471
    if ((int )*(dco + 21) & (1 << 14)) {
      {
#line 1471
      printf((char const   */* __restrict  */)" NV_cache_power_management");
      }
    }
#line 1472
    if ((int )*(dco + 21) & (1 << 15)) {
      {
#line 1472
      printf((char const   */* __restrict  */)" NV_cache");
      }
    }
  }
  {
#line 1474
  putchar('\n');
  }
#line 1476
  if ((int )*(dco + 8) & 31) {
    {
#line 1477
    printf((char const   */* __restrict  */)"\tSATA command/feature sets:\n\t\t");
    }
#line 1478
    if ((int )*(dco + 0) < 2) {
      {
#line 1479
      printf((char const   */* __restrict  */)" (?):");
      }
    }
#line 1480
    if ((int )*(dco + 8) & 1) {
      {
#line 1480
      printf((char const   */* __restrict  */)" NCQ");
      }
    }
#line 1481
    if ((int )*(dco + 8) & (1 << 1)) {
      {
#line 1481
      printf((char const   */* __restrict  */)" NZ_buffer_offsets");
      }
    }
#line 1482
    if ((int )*(dco + 8) & (1 << 2)) {
      {
#line 1482
      printf((char const   */* __restrict  */)" interface_power_management");
      }
    }
#line 1483
    if ((int )*(dco + 8) & (1 << 3)) {
      {
#line 1483
      printf((char const   */* __restrict  */)" async_notification");
      }
    }
#line 1484
    if ((int )*(dco + 8) & (1 << 4)) {
      {
#line 1484
      printf((char const   */* __restrict  */)" SSP");
      }
    }
    {
#line 1485
    putchar('\n');
    }
  }
#line 1487
  return;
}
}
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 956
extern int fsync(int __fd ) ;
#line 1058
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) syscall)(long __sysno 
                                                                               , ...) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.h"
int do_fallocate_syscall(char const   *path___0 , __u64 bytecount ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/fallocate.c"
int do_fallocate_syscall(char const   *path___0 , __u64 bytecount ) 
{ 
  int err ;
  int fd ;
  loff_t offset ;
  loff_t len ;
  int mode ;
  int *tmp ;
  long tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 30
  offset = (loff_t )0;
#line 31
  mode = 0;
#line 33
  fd = open(path___0, 193, 384);
  }
#line 34
  if (fd == -1) {
    {
#line 35
    tmp = __errno_location();
#line 35
    err = *tmp;
    }
  } else {
    {
#line 37
    len = (loff_t )bytecount;
#line 38
    tmp___0 = syscall(285L, fd, mode, offset, len);
#line 38
    err = (int )tmp___0;
    }
#line 39
    if (err >= 0) {
      {
#line 40
      fsync(fd);
#line 41
      exit(0);
      }
    }
    {
#line 43
    tmp___1 = __errno_location();
#line 43
    err = *tmp___1;
#line 44
    unlink(path___0);
    }
  }
  {
#line 46
  perror(path___0);
  }
#line 48
  return (err);
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 27 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 30
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 165
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp )  __asm__("readdir64")  ;
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 17 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.h"
int sysfs_get_attr(int fd , char const   *attr , char const   *fmt , void *val1 ,
                   void *val2 , int verbose___0 ) ;
#line 19
int get_dev_geometry(int fd , __u32 *cyls , __u32 *heads , __u32 *sects , __u64 *start_lba ,
                     __u64 *nsectors ) ;
#line 26
int fd_is_raid(int fd ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/geom.c"
static int get_driver_major(char const   *driver , unsigned int *major ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/geom.c"
static char const   proc_devices[14]  = 
#line 26
  {      (char const   )'/',      (char const   )'p',      (char const   )'r',      (char const   )'o', 
        (char const   )'c',      (char const   )'/',      (char const   )'d',      (char const   )'e', 
        (char const   )'v',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'s',      (char const   )'\000'};
#line 24 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/geom.c"
static int get_driver_major(char const   *driver , unsigned int *major ) 
{ 
  char buf[256] ;
  int err ;
  FILE *fp ;
  FILE *tmp ;
  int len ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 28
  err = 0;
#line 29
  tmp = fopen((char const   */* __restrict  */)(proc_devices), (char const   */* __restrict  */)"r");
#line 29
  fp = tmp;
  }
#line 31
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 32
    err = 5;
  } else {
    {
#line 34
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 34
      tmp___3 = fgets((char */* __restrict  */)(buf), (int )(sizeof(buf) - 1UL), (FILE */* __restrict  */)fp);
      }
#line 34
      if (! tmp___3) {
#line 34
        goto while_break;
      }
      {
#line 35
      tmp___0 = strlen((char const   *)(buf));
#line 35
      len = (int )tmp___0;
      }
#line 36
      if (len > 5) {
#line 36
        if ((int )buf[len - 1] == 10) {
#line 37
          buf[len - 1] = (char )'\000';
#line 38
          if ((int )buf[3] == 32) {
            {
#line 38
            tmp___2 = strcmp((char const   *)(buf + 4), driver);
            }
#line 38
            if (0 == tmp___2) {
              {
#line 39
              tmp___1 = atoi((char const   *)(buf));
#line 39
              *major = (unsigned int )tmp___1;
              }
#line 40
              goto while_break;
            }
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 45
  if (err) {
    {
#line 46
    perror(proc_devices);
    }
  }
#line 47
  if (fp) {
    {
#line 48
    fclose(fp);
    }
  }
#line 49
  return (err);
}
}
#line 54
static unsigned int md_major(void) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/geom.c"
static unsigned int maj  =    0U;
#line 52 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/geom.c"
static unsigned int md_major(void) 
{ 
  unsigned int val ;
  int tmp ;

  {
#line 56
  if (! maj) {
    {
#line 58
    tmp = get_driver_major("md", & val);
    }
#line 58
    if (0 == tmp) {
#line 59
      maj = val;
    }
  }
#line 61
  return (maj);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/geom.c"
int fd_is_raid(int fd ) 
{ 
  struct stat st ;
  unsigned int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 68
  tmp = md_major();
  }
#line 68
  if (! tmp) {
#line 69
    return (0);
  }
  {
#line 70
  tmp___0 = fstat(fd, & st);
  }
#line 70
  if (tmp___0) {
    {
#line 71
    perror("fstat()");
    }
#line 72
    return (0);
  }
  {
#line 74
  tmp___1 = gnu_dev_major((unsigned long long )st.st_rdev);
#line 74
  tmp___2 = md_major();
  }
#line 74
  return (tmp___1 == tmp___2);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/geom.c"
static int get_sector_count(int fd , __u64 *nsectors ) 
{ 
  int err ;
  unsigned int nsects32 ;
  __u64 nbytes64 ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 80
  nsects32 = 0U;
#line 81
  nbytes64 = (__u64 )0;
#line 83
  tmp = sysfs_get_attr(fd, "size", "%llu", (void *)nsectors, (void *)0, 0);
  }
#line 83
  if (0 == tmp) {
#line 84
    return (0);
  }
  {
#line 86
  tmp___0 = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(18 << 8)) | 114U) | (sizeof(__u64 ) << 16),
                  & nbytes64);
  }
#line 86
  if (0 == tmp___0) {
#line 87
    *nsectors = nbytes64 / 512ULL;
#line 88
    return (0);
  }
  {
#line 91
  err = ioctl(fd, (unsigned long )((unsigned int )(18 << 8) | 96U), & nsects32);
  }
#line 92
  if (err == 0) {
#line 93
    *nsectors = (__u64 )nsects32;
  } else {
    {
#line 95
    tmp___1 = __errno_location();
#line 95
    err = *tmp___1;
#line 96
    perror(" BLKGETSIZE failed");
    }
  }
#line 98
  return (err);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/geom.c"
static int get_raid1_start_lba(int fd , __u64 *start_lba ) 
{ 
  char buf[32] ;
  unsigned int member ;
  unsigned int raid_disks ;
  __u64 start ;
  __u64 offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __u64 member_start ;
  __u64 member_offset ;
  char member_path[32] ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 110
  start = (__u64 )0;
#line 110
  offset = (__u64 )0;
#line 112
  tmp = sysfs_get_attr(fd, "md/level", "%s", (void *)(buf), (void *)0, 0);
  }
#line 112
  if (tmp) {
#line 114
    return (19);
  } else {
    {
#line 112
    tmp___0 = sysfs_get_attr(fd, "md/raid_disks", "%u", (void *)(& raid_disks), (void *)0,
                             0);
    }
#line 112
    if (tmp___0) {
#line 114
      return (19);
    }
  }
  {
#line 115
  tmp___1 = strcmp((char const   *)(buf), "raid1");
  }
#line 115
  if (tmp___1) {
#line 116
    return (22);
  } else
#line 115
  if (! raid_disks) {
#line 116
    return (22);
  }
#line 117
  member = 0U;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (member < raid_disks)) {
#line 117
      goto while_break;
    }
    {
#line 120
    sprintf((char */* __restrict  */)(member_path), (char const   */* __restrict  */)"md/rd%u/offset",
            member);
#line 121
    tmp___2 = sysfs_get_attr(fd, (char const   *)(member_path), "%llu", (void *)(& member_offset),
                             (void *)0, 0);
    }
#line 121
    if (tmp___2) {
#line 122
      member_offset = (__u64 )0;
    }
    {
#line 123
    sprintf((char */* __restrict  */)(member_path), (char const   */* __restrict  */)"md/rd%u/block/dev",
            member);
#line 124
    tmp___3 = sysfs_get_attr(fd, (char const   *)(member_path), "%s", (void *)(buf),
                             (void *)0, 0);
    }
#line 124
    if (tmp___3) {
#line 125
      return (22);
    }
    {
#line 126
    tmp___4 = md_major();
#line 126
    tmp___5 = atoi((char const   *)(buf));
    }
#line 126
    if (tmp___4 == (unsigned int )tmp___5) {
#line 127
      return (22);
    }
    {
#line 128
    sprintf((char */* __restrict  */)(member_path), (char const   */* __restrict  */)"md/rd%u/block/start",
            member);
#line 129
    tmp___6 = sysfs_get_attr(fd, (char const   *)(member_path), "%llu", (void *)(& member_start),
                             (void *)0, 0);
    }
#line 129
    if (tmp___6) {
#line 130
      return (19);
    }
#line 131
    if (member == 0U) {
#line 132
      start = member_start;
#line 133
      offset = member_offset;
    } else
#line 134
    if (member_start != start) {
#line 135
      return (22);
    } else
#line 134
    if (member_offset != offset) {
#line 135
      return (22);
    }
#line 117
    member ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  *start_lba = start;
#line 139
  return (0);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/geom.c"
static struct local_hd_geometry g  ;
#line 146 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/geom.c"
static struct local_hd_big_geometry bg  ;
#line 142 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/geom.c"
int get_dev_geometry(int fd , __u32 *cyls , __u32 *heads , __u32 *sects , __u64 *start_lba ,
                     __u64 *nsectors ) 
{ 
  int err ;
  int try_getgeo_big_first ;
  __u64 result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  __u64 hs ;
  __u64 cyl ;
  __u64 chs ;

  {
#line 147
  err = 0;
#line 147
  try_getgeo_big_first = 1;
#line 149
  if (nsectors) {
    {
#line 150
    err = get_sector_count(fd, nsectors);
    }
#line 151
    if (err) {
#line 152
      return (err);
    }
  }
#line 155
  if (start_lba) {
    {
#line 161
    tmp___0 = sysfs_get_attr(fd, "start", "%llu", (void *)(& result), (void *)0, 0);
    }
#line 161
    if (0 == tmp___0) {
#line 164
      *start_lba = result;
#line 165
      start_lba = (__u64 *)((void *)0);
#line 166
      try_getgeo_big_first = 0;
    } else {
      {
#line 161
      tmp___1 = get_raid1_start_lba(fd, & result);
      }
#line 161
      if (0 == tmp___1) {
#line 164
        *start_lba = result;
#line 165
        start_lba = (__u64 *)((void *)0);
#line 166
        try_getgeo_big_first = 0;
      } else {
        {
#line 167
        tmp = fd_is_raid(fd);
        }
#line 167
        if (tmp) {
#line 168
          *start_lba = ~ 0ULL;
#line 169
          start_lba = (__u64 *)((void *)0);
#line 170
          try_getgeo_big_first = 0;
        }
      }
    }
  }
#line 174
  if (cyls) {
#line 174
    goto _L___0;
  } else
#line 174
  if (heads) {
#line 174
    goto _L___0;
  } else
#line 174
  if (sects) {
#line 174
    goto _L___0;
  } else
#line 174
  if (start_lba) {
    _L___0: /* CIL Label */ 
#line 176
    if (try_getgeo_big_first) {
      {
#line 176
      tmp___5 = ioctl(fd, 816UL, & bg);
      }
#line 176
      if (tmp___5) {
#line 176
        goto _L;
      } else {
#line 177
        if (cyls) {
#line 177
          *cyls = bg.cylinders;
        }
#line 178
        if (heads) {
#line 178
          *heads = (__u32 )bg.heads;
        }
#line 179
        if (sects) {
#line 179
          *sects = (__u32 )bg.sectors;
        }
#line 180
        if (start_lba) {
#line 180
          *start_lba = (__u64 )bg.start;
        }
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 181
      tmp___4 = ioctl(fd, 769UL, & g);
      }
#line 181
      if (tmp___4) {
#line 186
        if (! try_getgeo_big_first) {
          {
#line 186
          tmp___3 = ioctl(fd, 816UL, & bg);
          }
#line 186
          if (tmp___3) {
            {
#line 192
            tmp___2 = __errno_location();
#line 192
            err = *tmp___2;
#line 193
            perror(" HDIO_GETGEO failed");
            }
#line 194
            return (err);
          } else {
#line 187
            if (cyls) {
#line 187
              *cyls = bg.cylinders;
            }
#line 188
            if (heads) {
#line 188
              *heads = (__u32 )bg.heads;
            }
#line 189
            if (sects) {
#line 189
              *sects = (__u32 )bg.sectors;
            }
#line 190
            if (start_lba) {
#line 190
              *start_lba = (__u64 )bg.start;
            }
          }
        } else {
          {
#line 192
          tmp___2 = __errno_location();
#line 192
          err = *tmp___2;
#line 193
          perror(" HDIO_GETGEO failed");
          }
#line 194
          return (err);
        }
      } else {
#line 182
        if (cyls) {
#line 182
          *cyls = (__u32 )g.cylinders;
        }
#line 183
        if (heads) {
#line 183
          *heads = (__u32 )g.heads;
        }
#line 184
        if (sects) {
#line 184
          *sects = (__u32 )g.sectors;
        }
#line 185
        if (start_lba) {
#line 185
          *start_lba = (__u64 )g.start;
        }
      }
    }
#line 200
    if (nsectors) {
#line 200
      if (cyls) {
#line 200
        if (heads) {
#line 200
          if (sects) {
#line 201
            hs = (__u64 )(*heads * *sects);
#line 202
            cyl = (__u64 )*cyls;
#line 203
            chs = cyl * hs;
#line 204
            if (chs < *nsectors) {
#line 205
              *cyls = (__u32 )(*nsectors / hs);
            }
          }
        }
      }
    }
  }
#line 209
  return (0);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/geom.c"
static int find_dev_in_directory(dev_t dev , char const   *dir , char *path___0 ,
                                 int verbose___0 ) 
{ 
  DIR *dp ;
  struct dirent *entry ;
  unsigned int maj___0 ;
  unsigned int tmp ;
  unsigned int min ;
  unsigned int tmp___0 ;
  int err ;
  int *tmp___1 ;
  struct stat st ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;

  {
  {
#line 216
  tmp = gnu_dev_major((unsigned long long )dev);
#line 216
  maj___0 = tmp;
#line 216
  tmp___0 = gnu_dev_minor((unsigned long long )dev);
#line 216
  min = tmp___0;
#line 218
  *path___0 = (char )'\000';
#line 219
  dp = opendir(dir);
  }
#line 219
  if (! dp) {
    {
#line 220
    tmp___1 = __errno_location();
#line 220
    err = *tmp___1;
    }
#line 221
    if (verbose___0) {
      {
#line 222
      perror(dir);
      }
    }
#line 223
    return (err);
  }
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 225
    entry = readdir(dp);
    }
#line 225
    if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 225
      goto while_break;
    }
#line 226
    if ((int )entry->d_type == 0) {
#line 226
      goto _L;
    } else
#line 226
    if ((int )entry->d_type == 6) {
      _L: /* CIL Label */ 
      {
#line 228
      sprintf((char */* __restrict  */)path___0, (char const   */* __restrict  */)"%s/%s",
              dir, entry->d_name);
#line 229
      tmp___4 = stat((char const   */* __restrict  */)path___0, (struct stat */* __restrict  */)(& st));
      }
#line 229
      if (tmp___4) {
#line 230
        if (verbose___0) {
          {
#line 231
          perror((char const   *)path___0);
          }
        }
      } else
#line 232
      if ((st.st_mode & 61440U) == 24576U) {
        {
#line 233
        tmp___2 = gnu_dev_major((unsigned long long )st.st_rdev);
        }
#line 233
        if (maj___0 == tmp___2) {
          {
#line 233
          tmp___3 = gnu_dev_minor((unsigned long long )st.st_rdev);
          }
#line 233
          if (min == tmp___3) {
            {
#line 234
            closedir(dp);
            }
#line 235
            return (0);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 240
  closedir(dp);
#line 241
  *path___0 = (char )'\000';
  }
#line 242
  if (verbose___0) {
    {
#line 243
    tmp___5 = gnu_dev_minor((unsigned long long )dev);
#line 243
    tmp___6 = gnu_dev_major((unsigned long long )dev);
#line 243
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d,%d: device not found in %s\n",
            tmp___6, tmp___5, dir);
    }
  }
#line 244
  return (2);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/geom.c"
int get_dev_t_geometry(dev_t dev , __u32 *cyls , __u32 *heads , __u32 *sects , __u64 *start_lba ,
                       __u64 *nsectors ) 
{ 
  char path___0[4096] ;
  int fd ;
  int err ;
  int *tmp ;

  {
  {
#line 253
  err = find_dev_in_directory(dev, "/dev", path___0, 1);
  }
#line 254
  if (err) {
#line 255
    return (err);
  }
  {
#line 257
  fd = open((char const   *)(path___0), 2048);
  }
#line 258
  if (fd == -1) {
    {
#line 259
    tmp = __errno_location();
#line 259
    err = *tmp;
#line 260
    perror((char const   *)(path___0));
    }
#line 261
    return (err);
  }
  {
#line 264
  err = get_dev_geometry(fd, cyls, heads, sects, start_lba, nsectors);
#line 265
  close(fd);
  }
#line 266
  return (err);
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 425 "/usr/include/stdio.h"
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 18 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.h"
int sysfs_set_attr(int fd , char const   *attr , char const   *fmt , void *val_p ,
                   int verbose___0 ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sysfs.c"
static char *path_append(char *path___0 , char const   *new ) 
{ 
  char *pathtail ;
  size_t tmp ;

  {
  {
#line 23
  tmp = strlen((char const   *)path___0);
#line 23
  pathtail = path___0 + tmp;
#line 25
  *pathtail = (char )'/';
#line 26
  strcpy((char */* __restrict  */)(pathtail + 1), (char const   */* __restrict  */)new);
  }
#line 27
  return (pathtail);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sysfs.c"
static int sysfs_write_attr(char *path___0 , char const   *attr , char const   *fmt ,
                            void *val , int verbose___0 ) 
{ 
  FILE *fp ;
  int count ;
  int err ;
  char *pathtail ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 33
  count = -1;
#line 33
  err = 0;
#line 34
  tmp = path_append(path___0, attr);
#line 34
  pathtail = tmp;
#line 36
  fp = fopen((char const   */* __restrict  */)path___0, (char const   */* __restrict  */)"w");
  }
#line 37
  if (! fp) {
    {
#line 38
    tmp___0 = __errno_location();
#line 38
    err = *tmp___0;
    }
  } else
#line 39
  if ((int const   )*(fmt + 0) != 37) {
#line 40
    err = 22;
  } else {
    {
#line 43
    if ((int const   )*(fmt + 1) == 115) {
#line 43
      goto case_115;
    }
#line 47
    if ((int const   )*(fmt + 1) == 117) {
#line 47
      goto case_117;
    }
#line 47
    if ((int const   )*(fmt + 1) == 100) {
#line 47
      goto case_117;
    }
#line 50
    if ((int const   )*(fmt + 1) == 108) {
#line 50
      goto case_108;
    }
#line 56
    goto switch_default;
    case_115: /* CIL Label */ 
    {
#line 44
    count = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)fmt,
                    val);
    }
#line 45
    goto switch_break;
    case_117: /* CIL Label */ 
    case_100: /* CIL Label */ 
    {
#line 48
    count = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)fmt,
                    *((unsigned int *)val));
    }
#line 49
    goto switch_break;
    case_108: /* CIL Label */ 
#line 51
    if ((int const   )*(fmt + 2) == 108) {
      {
#line 52
      count = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)fmt,
                      *((unsigned long long *)val));
      }
    } else {
      {
#line 54
      count = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)fmt,
                      *((unsigned long *)val));
      }
    }
#line 55
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 57
    tmp___1 = __errno_location();
#line 57
    *tmp___1 = 22;
    }
    switch_break: /* CIL Label */ ;
    }
#line 59
    if (count < 0) {
      {
#line 60
      tmp___2 = __errno_location();
#line 60
      err = *tmp___2;
      }
    }
    {
#line 61
    fclose(fp);
    }
  }
#line 63
  if (err) {
#line 63
    if (verbose___0) {
      {
#line 63
      perror((char const   *)path___0);
      }
    }
  }
#line 64
  *pathtail = (char )'\000';
#line 65
  return (err);
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sysfs.c"
static int sysfs_read_attr(char *path___0 , char const   *attr , char const   *fmt ,
                           void *val1 , void *val2 , int verbose___0 ) 
{ 
  FILE *fp ;
  int count ;
  int err ;
  char *pathtail ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 71
  err = 0;
#line 72
  tmp = path_append(path___0, attr);
#line 72
  pathtail = tmp;
#line 74
  fp = fopen((char const   */* __restrict  */)path___0, (char const   */* __restrict  */)"r");
  }
#line 75
  if (! fp) {
    {
#line 76
    tmp___0 = __errno_location();
#line 76
    err = *tmp___0;
    }
  } else {
    {
#line 78
    count = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)fmt,
                   val1, val2);
    }
#line 79
    if (val2) {
#line 79
      tmp___2 = 2;
    } else {
#line 79
      tmp___2 = 1;
    }
#line 79
    if (count != tmp___2) {
#line 80
      if (count == -1) {
        {
#line 80
        tmp___1 = __errno_location();
#line 80
        err = *tmp___1;
        }
      } else {
#line 80
        err = 22;
      }
    }
    {
#line 81
    fclose(fp);
    }
  }
#line 83
  if (err) {
#line 83
    if (verbose___0) {
      {
#line 83
      perror((char const   *)path___0);
      }
    }
  }
#line 84
  *pathtail = (char )'\000';
#line 85
  return (err);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sysfs.c"
static int sysfs_find_dev2(char *path___0 , dev_t dev , int recurse , int verbose___0 ) 
{ 
  DIR *dp ;
  struct dirent *entry ;
  char *pathtail ;
  int err ;
  int *tmp ;
  size_t tmp___0 ;
  unsigned int maj___0 ;
  unsigned int min ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;

  {
  {
#line 94
  dp = opendir((char const   *)path___0);
  }
#line 94
  if (! dp) {
    {
#line 95
    tmp = __errno_location();
#line 95
    err = *tmp;
    }
#line 96
    if (verbose___0) {
      {
#line 96
      perror((char const   *)path___0);
      }
    }
#line 97
    return (err);
  }
  {
#line 99
  tmp___0 = strlen((char const   *)path___0);
#line 99
  pathtail = path___0 + tmp___0;
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 100
    entry = readdir(dp);
    }
#line 100
    if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 100
      goto while_break;
    }
#line 101
    if ((int )entry->d_type == 4) {
#line 101
      goto _L;
    } else
#line 101
    if ((int )entry->d_type == 10) {
      _L: /* CIL Label */ 
#line 101
      if ((int )entry->d_name[0] != 46) {
        {
#line 103
        sprintf((char */* __restrict  */)pathtail, (char const   */* __restrict  */)"/%s",
                entry->d_name);
#line 104
        tmp___3 = sysfs_read_attr(path___0, "/dev", "%u:%u", (void *)(& maj___0),
                                  (void *)(& min), verbose___0);
        }
#line 104
        if (tmp___3) {
          {
#line 105
          tmp___1 = gnu_dev_minor((unsigned long long )dev);
#line 105
          min = ~ tmp___1;
          }
        } else {
          {
#line 106
          tmp___2 = gnu_dev_major((unsigned long long )dev);
          }
#line 106
          if (maj___0 != tmp___2) {
#line 107
            goto while_continue;
          }
        }
        {
#line 108
        tmp___4 = gnu_dev_minor((unsigned long long )dev);
        }
#line 108
        if (min == tmp___4) {
          {
#line 110
          closedir(dp);
          }
#line 111
          return (0);
        } else
#line 108
        if (recurse) {
          {
#line 108
          tmp___5 = sysfs_find_dev2(path___0, dev, recurse - 1, verbose___0);
          }
#line 108
          if (tmp___5 == 0) {
            {
#line 110
            closedir(dp);
            }
#line 111
            return (0);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 115
  closedir(dp);
#line 116
  *pathtail = (char )'\000';
  }
#line 117
  if (verbose___0) {
    {
#line 118
    tmp___6 = gnu_dev_minor((unsigned long long )dev);
#line 118
    tmp___7 = gnu_dev_major((unsigned long long )dev);
#line 118
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%u,%u: device not found in /sys\n",
            tmp___7, tmp___6);
    }
  }
#line 119
  return (2);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sysfs.c"
static int sysfs_find_dev(dev_t dev , char *path___0 , int verbose___0 ) 
{ 
  int err ;
  int recurse ;
  char *tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 124
  recurse = 1;
#line 126
  strcpy((char */* __restrict  */)path___0, (char const   */* __restrict  */)"/sys/block");
#line 127
  err = sysfs_find_dev2(path___0, dev, recurse, 0);
  }
#line 128
  if (err) {
#line 128
    if (verbose___0) {
      {
#line 129
      tmp = strerror(err);
#line 129
      tmp___0 = gnu_dev_minor((unsigned long long )dev);
#line 129
      tmp___1 = gnu_dev_major((unsigned long long )dev);
#line 129
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s(%u:%u): %s\n",
              "sysfs_find_dev", tmp___1, tmp___0, tmp);
      }
    }
  }
#line 131
  return (err);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sysfs.c"
static int get_dev_from_fd(int fd , dev_t *dev , int verbose___0 ) 
{ 
  struct stat st ;
  int err ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 138
  tmp___0 = fstat(fd, & st);
  }
#line 138
  if (0 != tmp___0) {
    {
#line 139
    tmp = __errno_location();
#line 139
    err = *tmp;
    }
#line 140
    if (verbose___0) {
      {
#line 140
      perror(" fstat() failed");
      }
    }
#line 141
    return (err);
  }
#line 143
  if ((st.st_mode & 61440U) == 24576U) {
#line 144
    *dev = st.st_rdev;
  } else
#line 143
  if ((st.st_mode & 61440U) == 8192U) {
#line 144
    *dev = st.st_rdev;
  } else {
#line 146
    *dev = st.st_dev;
  }
#line 147
  return (0);
}
}
#line 152
static int sysfs_find_fd(int fd , char **path_p , int verbose___0 ) ;
#line 152 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sysfs.c"
static int have_prev  =    0;
#line 153 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sysfs.c"
static dev_t prev  ;
#line 154 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sysfs.c"
static char path[4096]  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sysfs.c"
static int sysfs_find_fd(int fd , char **path_p , int verbose___0 ) 
{ 
  dev_t dev ;
  int err ;
  int tmp ;

  {
  {
#line 158
  memset((void *)(& dev), 0, sizeof(dev));
#line 159
  err = get_dev_from_fd(fd, & dev, verbose___0);
  }
#line 160
  if (! err) {
#line 161
    if (have_prev) {
      {
#line 161
      tmp = memcmp((void const   *)(& dev), (void const   *)(& prev), sizeof(dev));
      }
#line 161
      if (! (0 == tmp)) {
        {
#line 164
        prev = dev;
#line 165
        have_prev = 1;
#line 166
        err = sysfs_find_dev(dev, path, verbose___0);
        }
      }
    } else {
      {
#line 164
      prev = dev;
#line 165
      have_prev = 1;
#line 166
      err = sysfs_find_dev(dev, path, verbose___0);
      }
    }
  }
#line 169
  if (err) {
#line 170
    have_prev = 0;
  } else {
#line 172
    *path_p = path;
  }
#line 173
  return (err);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sysfs.c"
int sysfs_get_attr(int fd , char const   *attr , char const   *fmt , void *val1 ,
                   void *val2 , int verbose___0 ) 
{ 
  char *path___0 ;
  int err ;

  {
  {
#line 181
  err = sysfs_find_fd(fd, & path___0, verbose___0);
  }
#line 182
  if (! err) {
    {
#line 183
    err = sysfs_read_attr(path___0, attr, fmt, val1, val2, verbose___0);
    }
  }
#line 184
  return (err);
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sysfs.c"
int sysfs_set_attr(int fd , char const   *attr , char const   *fmt , void *val_p ,
                   int verbose___0 ) 
{ 
  char *path___0 ;
  int err ;

  {
  {
#line 192
  err = sysfs_find_fd(fd, & path___0, verbose___0);
  }
#line 193
  if (! err) {
    {
#line 194
    err = sysfs_write_attr(path___0, attr, fmt, val_p, verbose___0);
    }
  }
#line 195
  return (err);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.h"
int set_dvdspeed(int fd , int speed ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/dvdspeed.c"
int set_dvdspeed(int fd , int speed ) 
{ 
  struct cdrom_generic_command cgc ;
  struct request_sense sense ;
  unsigned char buffer[28] ;
  unsigned long rwsize ;
  int tmp ;

  {
  {
#line 22
  rwsize = (unsigned long )(177 * speed);
#line 24
  memset((void *)(& cgc), 0, sizeof(cgc));
#line 25
  memset((void *)(& sense), 0, sizeof(sense));
#line 26
  memset((void *)(& buffer), 0, sizeof(buffer));
#line 28
  cgc.cmd[0] = (unsigned char)182;
#line 30
  cgc.cmd[10] = (unsigned char)28;
#line 31
  cgc.sense = & sense;
#line 32
  cgc.buffer = buffer;
#line 33
  cgc.buflen = (unsigned int )sizeof(buffer);
#line 34
  cgc.data_direction = (unsigned char)1;
  }
#line 36
  if (speed == 0) {
#line 37
    buffer[0] = (unsigned char)4;
  }
  {
#line 39
  buffer[8] = (unsigned char)255;
#line 40
  buffer[9] = (unsigned char)255;
#line 41
  buffer[10] = (unsigned char)255;
#line 42
  buffer[11] = (unsigned char)255;
#line 45
  buffer[12] = (unsigned char )(rwsize >> 24);
#line 46
  buffer[13] = (unsigned char )(rwsize >> 16);
#line 47
  buffer[14] = (unsigned char )(rwsize >> 8);
#line 48
  buffer[15] = (unsigned char )rwsize;
#line 51
  buffer[18] = (unsigned char)3;
#line 52
  buffer[19] = (unsigned char)232;
#line 55
  buffer[20] = (unsigned char )(rwsize >> 24);
#line 56
  buffer[21] = (unsigned char )(rwsize >> 16);
#line 57
  buffer[22] = (unsigned char )(rwsize >> 8);
#line 58
  buffer[23] = (unsigned char )rwsize;
#line 61
  buffer[26] = (unsigned char)3;
#line 62
  buffer[27] = (unsigned char)232;
#line 64
  tmp = ioctl(fd, 21395UL, & cgc);
  }
#line 64
  return (tmp);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.h"
void tf_init(struct ata_tf *tf , __u8 ata_op , __u64 lba , unsigned int nsect ) ;
#line 229
int sg16(int fd , int rw , int dma___0 , struct ata_tf *tf , void *data , unsigned int data_bytes ,
         unsigned int timeout_secs ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.h"
int wdidle3_set_timeout(int fd , unsigned char timeout ) ;
#line 29
int wdidle3_get_timeout(int fd , unsigned char *timeout ) ;
#line 30
void wdidle3_print_timeout(unsigned char timeout ) ;
#line 31
unsigned char wdidle3_msecs_to_timeout(unsigned int secs ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/wdidle3.c"
int verbose ;
#line 60 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/wdidle3.c"
static int wdidle3_issue(int fd , int rw , struct ata_tf *tf , void *data , char const   *msg ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 62
  if (data) {
#line 62
    tmp = 512;
  } else {
#line 62
    tmp = 0;
  }
  {
#line 62
  tmp___0 = sg16(fd, rw, 0, tf, data, (unsigned int )tmp, 12U);
#line 62
  ret = tmp___0;
  }
#line 63
  if (ret != 0) {
    {
#line 64
    tmp___1 = __errno_location();
#line 64
    ret = *tmp___1;
#line 65
    perror(msg);
    }
  }
#line 67
  return (ret);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/wdidle3.c"
static int wdidle3_vsc_enable_disable(int fd , int setting ) 
{ 
  struct ata_tf tf ;
  unsigned long long vendor_WD0 ;
  int tmp ;

  {
  {
#line 79
  vendor_WD0 = (unsigned long long )((87 << 16) | (68 << 8));
#line 81
  tf_init(& tf, (__u8 )128, vendor_WD0, 0U);
#line 82
  tf.lob.feat = (__u8 )setting;
#line 83
  tf.dev = (__u8 )160;
#line 84
  tmp = wdidle3_issue(fd, 1, & tf, (void *)0, "wdidle3_vsc_enable_disable");
  }
#line 84
  return (tmp);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/wdidle3.c"
static int wdidle3_vsc_send_key(int fd , int rw ) 
{ 
  char data[512] ;
  struct ata_tf tf ;
  int tmp ;

  {
  {
#line 96
  memset((void *)(data), 0, sizeof(data));
#line 97
  tf_init(& tf, (__u8 )176, (__u64 )12734398, 1U);
#line 98
  tf.lob.feat = (__u8 )214;
#line 99
  tf.dev = (__u8 )160;
#line 100
  data[0] = (char)42;
#line 101
  data[2] = (char )rw;
#line 102
  data[4] = (char)2;
#line 103
  data[6] = (char)13;
#line 104
  data[8] = (char)22;
#line 105
  data[10] = (char)1;
#line 106
  tmp = wdidle3_issue(fd, 1, & tf, (void *)(data), "wdidle3_vsc_send_key");
  }
#line 106
  return (tmp);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/wdidle3.c"
static int wdidle3_data_in(int fd , unsigned char *timeout ) 
{ 
  char data[512] ;
  int ret ;
  struct ata_tf tf ;

  {
  {
#line 118
  memset((void *)(data), 0, sizeof(data));
#line 119
  tf_init(& tf, (__u8 )176, (__u64 )12734399, 1U);
#line 120
  tf.lob.feat = (__u8 )213;
#line 121
  tf.dev = (__u8 )160;
#line 122
  ret = wdidle3_issue(fd, 0, & tf, (void *)(data), "wdidle3_data_in");
  }
#line 123
  if (! ret) {
#line 124
    *timeout = (unsigned char )data[0];
  }
#line 125
  return (ret);
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/wdidle3.c"
static int wdidle3_vsc_data_out(int fd , unsigned char timeout ) 
{ 
  char data[512] ;
  struct ata_tf tf ;
  int tmp ;

  {
  {
#line 136
  memset((void *)(data), 0, sizeof(data));
#line 137
  tf_init(& tf, (__u8 )176, (__u64 )12734399, 1U);
#line 138
  tf.lob.feat = (__u8 )214;
#line 139
  tf.dev = (__u8 )160;
#line 140
  data[0] = (char )timeout;
#line 141
  tmp = wdidle3_issue(fd, 1, & tf, (void *)(data), "wdidle3_vsc_data_out");
  }
#line 141
  return (tmp);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/wdidle3.c"
int wdidle3_set_timeout(int fd , unsigned char timeout ) 
{ 
  int ret ;
  int ret2 ;

  {
  {
#line 148
  ret = wdidle3_vsc_enable_disable(fd, 69);
  }
#line 149
  if (! ret) {
    {
#line 150
    ret = wdidle3_vsc_send_key(fd, 2);
    }
#line 151
    if (! ret) {
      {
#line 152
      ret = wdidle3_vsc_data_out(fd, timeout);
      }
    }
    {
#line 153
    ret2 = wdidle3_vsc_enable_disable(fd, 68);
    }
#line 154
    if (! ret) {
#line 155
      ret = ret2;
    }
  }
#line 157
  return (ret);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/wdidle3.c"
int wdidle3_get_timeout(int fd , unsigned char *timeout ) 
{ 
  int ret ;
  int ret2 ;

  {
  {
#line 164
  ret = wdidle3_vsc_enable_disable(fd, 69);
  }
#line 165
  if (! ret) {
    {
#line 166
    ret = wdidle3_vsc_send_key(fd, 1);
    }
#line 167
    if (! ret) {
      {
#line 168
      ret = wdidle3_data_in(fd, timeout);
      }
    }
    {
#line 169
    ret2 = wdidle3_vsc_enable_disable(fd, 68);
    }
#line 170
    if (! ret) {
#line 171
      ret = ret2;
    }
  }
#line 173
  return (ret);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/wdidle3.c"
unsigned char wdidle3_msecs_to_timeout(unsigned int secs ) 
{ 
  unsigned char timeout ;

  {
#line 180
  if (secs == 0U) {
#line 181
    timeout = (unsigned char)0;
  } else
#line 182
  if (secs < 8U) {
#line 183
    timeout = (unsigned char)80;
  } else
#line 184
  if (secs <= 12U) {
#line 185
    timeout = (unsigned char )(secs * 10U);
  } else {
#line 187
    secs += 29U;
#line 188
    if (secs > 300U) {
#line 189
      secs = 300U;
    }
#line 190
    timeout = (unsigned char )(secs / 30U + 128U);
  }
#line 192
  return (timeout);
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/wdidle3.c"
void wdidle3_print_timeout(unsigned char timeout ) 
{ 


  {
#line 197
  if (verbose) {
    {
#line 198
    printf((char const   */* __restrict  */)"[raw=0x%02x] ", (int )timeout);
    }
  }
#line 199
  if ((int )timeout == 0) {
    {
#line 200
    printf((char const   */* __restrict  */)"disabled");
    }
  } else
#line 201
  if ((int )timeout < 80) {
    {
#line 202
    printf((char const   */* __restrict  */)"%u ??", (int )timeout);
    }
  } else
#line 201
  if ((int )timeout == 128) {
    {
#line 202
    printf((char const   */* __restrict  */)"%u ??", (int )timeout);
    }
  } else
#line 203
  if ((int )timeout < 128) {
    {
#line 204
    printf((char const   */* __restrict  */)"%u.%u secs", (int )timeout / 10, (int )timeout % 10);
    }
  } else {
#line 206
    if ((int )timeout > 138) {
      {
#line 207
      printf((char const   */* __restrict  */)"%u ??", (int )timeout);
      }
    } else {
      {
#line 209
      printf((char const   */* __restrict  */)"%u secs", ((int )timeout - 128) * 30);
      }
    }
    {
#line 210
    printf((char const   */* __restrict  */)" (or %u.%u secs for older drives)", (int )timeout / 10,
           (int )timeout % 10);
    }
  }
#line 212
  return;
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 106
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munlock)(void const   *__addr ,
                                                                              size_t __len ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.h"
int fwdownload(int fd , __u16 *id___0 , char const   *fwpath___0 , int xfer_mode___0 ) ;
#line 231 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.h"
int do_taskfile_cmd(int fd , struct hdio_taskfile *r , unsigned int timeout_secs ) ;
#line 233
void init_hdio_taskfile(struct hdio_taskfile *r , __u8 ata_op , int rw , int force_lba48 ,
                        __u64 lba , unsigned int nsect , int data_bytes ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/fwdownload.c"
static int send_firmware(int fd , unsigned int xfer_mode___0 , unsigned int offset ,
                         void const   *data , unsigned int bytecount ) 
{ 
  int err ;
  struct hdio_taskfile *r ;
  unsigned int blockcount ;
  unsigned int timeout_secs ;
  __u64 lba ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 35
  err = 0;
#line 37
  blockcount = bytecount / 512U;
#line 38
  timeout_secs = 20U;
#line 41
  lba = (__u64 )((offset / 512U << 8) | ((blockcount >> 8) & 255U));
#line 42
  tmp = malloc(sizeof(struct hdio_taskfile ) + (unsigned long )bytecount);
#line 42
  r = (struct hdio_taskfile *)tmp;
  }
#line 43
  if (! r) {
#line 44
    if (xfer_mode___0 == 3U) {
      {
#line 44
      putchar('\n');
#line 44
      fflush(stdout);
      }
    }
    {
#line 45
    tmp___0 = __errno_location();
#line 45
    err = *tmp___0;
#line 46
    perror("malloc()");
    }
#line 47
    return (err);
  }
  {
#line 49
  init_hdio_taskfile(r, (__u8 )146, 1, 0, lba, blockcount & 255U, (int )bytecount);
#line 51
  r->lob.feat = (__u8 )xfer_mode___0;
#line 52
  r->oflags.__annonCompField1.lob.feat = 1U;
#line 53
  r->iflags.__annonCompField1.lob.nsect = 1U;
  }
#line 55
  if (data) {
#line 55
    if (bytecount) {
      {
#line 56
      memcpy((void */* __restrict  */)(r->data), (void const   */* __restrict  */)data,
             (size_t )bytecount);
      }
    }
  }
  {
#line 58
  tmp___2 = do_taskfile_cmd(fd, r, timeout_secs);
  }
#line 58
  if (tmp___2) {
    {
#line 59
    tmp___1 = __errno_location();
#line 59
    err = *tmp___1;
    }
#line 60
    if (xfer_mode___0 == 3U) {
      {
#line 60
      putchar('\n');
#line 60
      fflush(stdout);
      }
    }
    {
#line 61
    perror("FAILED");
    }
  } else
#line 63
  if (xfer_mode___0 == 3U) {
#line 64
    if (! verbose) {
      {
#line 64
      putchar('.');
#line 64
      fflush(stdout);
      }
    }
    {
#line 67
    if ((int )r->lob.nsect == 2) {
#line 67
      goto case_2;
    }
#line 67
    if ((int )r->lob.nsect == 1) {
#line 67
      goto case_2;
    }
#line 70
    goto switch_default;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 68
    err = - ((int )r->lob.nsect);
#line 69
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 71
    err = 0;
#line 72
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 76
  free((void *)r);
  }
#line 77
  return (err);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/fwdownload.c"
int fwdownload(int fd , __u16 *id___0 , char const   *fwpath___0 , int xfer_mode___0 ) 
{ 
  int fwfd ;
  int err ;
  struct stat st ;
  char const   *fw ;
  int max_bytes ;
  int xfer_min ;
  int xfer_max ;
  int xfer_size ;
  ssize_t offset ;
  int *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 82
  err = 0;
#line 84
  fw = (char const   *)((void *)0);
#line 85
  max_bytes = 33553920;
#line 86
  xfer_min = 1;
#line 86
  xfer_max = 65535;
#line 89
  fwfd = open(fwpath___0, 0);
  }
#line 89
  if (fwfd == -1) {
    {
#line 90
    tmp = __errno_location();
#line 90
    err = *tmp;
#line 91
    perror(fwpath___0);
    }
#line 92
    return (err);
  } else {
    {
#line 89
    tmp___0 = fstat(fwfd, & st);
    }
#line 89
    if (tmp___0 == -1) {
      {
#line 90
      tmp = __errno_location();
#line 90
      err = *tmp;
#line 91
      perror(fwpath___0);
      }
#line 92
      return (err);
    }
  }
#line 95
  if (! ((st.st_mode & 61440U) == 32768U)) {
    {
#line 96
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: not a regular file\n",
            fwpath___0);
#line 97
    err = 22;
    }
#line 98
    goto done;
  }
#line 101
  if (st.st_size > (__off_t )max_bytes) {
    {
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: file size too large, max=%u bytes\n",
            fwpath___0, max_bytes);
#line 103
    err = 22;
    }
#line 104
    goto done;
  }
#line 107
  if (st.st_size == 0L) {
    {
#line 108
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: file size (%llu) not a multiple of 512\n",
            fwpath___0, (unsigned long long )st.st_size);
#line 110
    err = 22;
    }
#line 111
    goto done;
  } else
#line 107
  if (st.st_size % 512L) {
    {
#line 108
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: file size (%llu) not a multiple of 512\n",
            fwpath___0, (unsigned long long )st.st_size);
#line 110
    err = 22;
    }
#line 111
    goto done;
  }
#line 114
  if (verbose) {
    {
#line 115
    printf((char const   */* __restrict  */)"%s: %llu bytes\n", fwpath___0, (unsigned long long )st.st_size);
    }
  }
  {
#line 117
  tmp___1 = mmap((void *)0, (size_t )st.st_size, 1, 40961, fwfd, (__off_t )0);
#line 117
  fw = (char const   *)tmp___1;
  }
#line 118
  if ((unsigned long )fw == (unsigned long )((void *)-1)) {
    {
#line 119
    tmp___2 = __errno_location();
#line 119
    err = *tmp___2;
#line 120
    perror(fwpath___0);
    }
#line 121
    goto done;
  }
#line 125
  if ((int )*(id___0 + 83) & 1) {
#line 125
    if (! ((int )*(id___0 + 86) & 1)) {
      {
#line 126
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DOWNLOAD_MICROCODE: not supported by device\n");
#line 127
      err = 95;
      }
#line 128
      goto done;
    }
  } else {
    {
#line 126
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DOWNLOAD_MICROCODE: not supported by device\n");
#line 127
    err = 95;
    }
#line 128
    goto done;
  }
#line 130
  if (xfer_mode___0 == 0) {
#line 131
    if ((int )*(id___0 + 119) & 16) {
#line 131
      if ((int )*(id___0 + 120) & 16) {
#line 132
        xfer_mode___0 = 3;
      } else {
#line 134
        xfer_mode___0 = 7;
      }
    } else {
#line 134
      xfer_mode___0 = 7;
    }
  }
#line 137
  if (xfer_mode___0 == 3) {
#line 137
    goto _L;
  } else
#line 137
  if (xfer_mode___0 == 30) {
    _L: /* CIL Label */ 
#line 139
    xfer_min = (int )*(id___0 + 234);
#line 140
    if (xfer_min == 0) {
#line 141
      xfer_min = 1;
    } else
#line 140
    if (xfer_min == 65535) {
#line 141
      xfer_min = 1;
    }
#line 142
    xfer_max = (int )*(id___0 + 235);
#line 143
    if (xfer_max == 0) {
#line 144
      xfer_max = xfer_min;
    } else
#line 143
    if (xfer_max == 65535) {
#line 144
      xfer_max = xfer_min;
    }
  }
#line 147
  if (xfer_mode___0 == 30) {
#line 148
    xfer_mode___0 = 3;
#line 149
    xfer_size = xfer_max;
  } else
#line 150
  if (xfer_mode___0 == 3) {
#line 151
    xfer_size = xfer_min;
  } else {
#line 153
    xfer_size = (int )(st.st_size / 512L);
#line 154
    if (xfer_size > 65535) {
      {
#line 155
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: file size (%llu) too large for mode7 transfers\n",
              (__u64 )st.st_size);
#line 156
      err = 22;
      }
#line 157
      goto done;
    }
  }
  {
#line 161
  xfer_size *= 512;
#line 163
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: xfer_mode=%d min=%u max=%u size=%u\n",
          "fwdownload", xfer_mode___0, xfer_min, xfer_max, xfer_size);
#line 167
  offset = (ssize_t )0;
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! err) {
#line 167
      if (! (offset < st.st_size)) {
#line 167
        goto while_break;
      }
    } else {
#line 167
      goto while_break;
    }
#line 168
    if (offset + (ssize_t )xfer_size >= st.st_size) {
#line 169
      xfer_size = (int )(st.st_size - offset);
    }
    {
#line 170
    err = send_firmware(fd, (unsigned int )xfer_mode___0, (unsigned int )offset, (void const   *)(fw + offset),
                        (unsigned int )xfer_size);
#line 171
    offset += (ssize_t )xfer_size;
    }
#line 173
    if (err == -2) {
#line 174
      if (offset >= st.st_size) {
#line 175
        err = 0;
      } else {
#line 177
        if (xfer_mode___0 == 3) {
          {
#line 177
          putchar('\n');
#line 177
          fflush(stdout);
          }
        }
        {
#line 178
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: drive completed transfer at %llu/%llu bytes\n",
                (unsigned long long )offset, (unsigned long long )st.st_size);
#line 180
        err = 5;
        }
      }
    } else
#line 182
    if (err == -1) {
#line 183
      if (offset >= st.st_size) {
#line 192
        if (xfer_mode___0 == 3) {
          {
#line 192
          putchar('\n');
#line 192
          fflush(stdout);
          }
        }
        {
#line 193
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: drive expects more data than provided,\n");
#line 194
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"but the transfer may have worked regardless.\n");
#line 195
        err = 5;
        }
      } else {
#line 197
        err = 0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  if (! err) {
    {
#line 202
    printf((char const   */* __restrict  */)" Done.\n");
    }
  }
  done: 
  {
#line 204
  munlock((void const   *)fw, (size_t )st.st_size);
#line 205
  close(fwfd);
  }
#line 206
  return (err);
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.h"
__u64 tf_to_lba(struct ata_tf *tf ) ;
#line 230
int do_drive_cmd(int fd , unsigned char *args___1 , unsigned int timeout_secs ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.c"
int prefer_ata12 ;
#line 23 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.c"
static unsigned int const   default_timeout_secs  =    (unsigned int const   )15;
#line 82 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.c"
__inline static int needs_lba48(__u8 ata_op , __u64 lba , unsigned int nsect ) 
{ 


  {
  {
#line 94
  if ((int )ata_op == 234) {
#line 94
    goto case_234;
  }
#line 94
  if ((int )ata_op == 55) {
#line 94
    goto case_234;
  }
#line 94
  if ((int )ata_op == 39) {
#line 94
    goto case_234;
  }
#line 94
  if ((int )ata_op == 69) {
#line 94
    goto case_234;
  }
#line 94
  if ((int )ata_op == 66) {
#line 94
    goto case_234;
  }
#line 94
  if ((int )ata_op == 53) {
#line 94
    goto case_234;
  }
#line 94
  if ((int )ata_op == 52) {
#line 94
    goto case_234;
  }
#line 94
  if ((int )ata_op == 37) {
#line 94
    goto case_234;
  }
#line 94
  if ((int )ata_op == 36) {
#line 94
    goto case_234;
  }
#line 94
  if ((int )ata_op == 6) {
#line 94
    goto case_234;
  }
#line 99
  if ((int )ata_op == 176) {
#line 99
    goto case_176;
  }
#line 99
  if ((int )ata_op == 128) {
#line 99
    goto case_176;
  }
#line 99
  if ((int )ata_op == 244) {
#line 99
    goto case_176;
  }
#line 99
  if ((int )ata_op == 243) {
#line 99
    goto case_176;
  }
#line 84
  goto switch_break;
  case_234: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 95
  return (1);
  case_176: /* CIL Label */ 
  case_128: /* CIL Label */ 
  case_244: /* CIL Label */ 
  case_243: /* CIL Label */ 
#line 100
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 102
  if (lba >= (__u64 )(1 << 28) - 1ULL) {
#line 103
    return (1);
  }
#line 104
  if (nsect) {
#line 105
    if (nsect > 255U) {
#line 106
      return (1);
    }
#line 107
    if ((lba + (__u64 )nsect) - 1ULL >= (__u64 )(1 << 28) - 1ULL) {
#line 108
      return (1);
    }
  }
#line 110
  return (0);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.c"
__inline static int is_dma(__u8 ata_op ) 
{ 


  {
  {
#line 122
  if ((int )ata_op == 202) {
#line 122
    goto case_202;
  }
#line 122
  if ((int )ata_op == 200) {
#line 122
    goto case_202;
  }
#line 122
  if ((int )ata_op == 97) {
#line 122
    goto case_202;
  }
#line 122
  if ((int )ata_op == 53) {
#line 122
    goto case_202;
  }
#line 122
  if ((int )ata_op == 96) {
#line 122
    goto case_202;
  }
#line 122
  if ((int )ata_op == 37) {
#line 122
    goto case_202;
  }
#line 122
  if ((int )ata_op == 6) {
#line 122
    goto case_202;
  }
#line 124
  goto switch_default;
  case_202: /* CIL Label */ 
  case_200: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 123
  return (1);
  switch_default: /* CIL Label */ 
#line 125
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.c"
void tf_init(struct ata_tf *tf , __u8 ata_op , __u64 lba , unsigned int nsect ) 
{ 
  int tmp ;

  {
  {
#line 131
  memset((void *)tf, 0, sizeof(*tf));
#line 132
  tf->command = ata_op;
#line 133
  tf->dev = (__u8 )64;
#line 134
  tf->lob.lbal = (__u8 )lba;
#line 135
  tf->lob.lbam = (__u8 )(lba >> 8);
#line 136
  tf->lob.lbah = (__u8 )(lba >> 16);
#line 137
  tf->lob.nsect = (__u8 )nsect;
#line 138
  tmp = needs_lba48(ata_op, lba, nsect);
  }
#line 138
  if (tmp) {
#line 139
    tf->is_lba48 = (__u8 )1;
#line 140
    tf->hob.nsect = (__u8 )(nsect >> 8);
#line 141
    tf->hob.lbal = (__u8 )(lba >> 24);
#line 142
    tf->hob.lbam = (__u8 )(lba >> 32);
#line 143
    tf->hob.lbah = (__u8 )(lba >> 40);
  } else {
#line 145
    tf->dev = (__u8 )((unsigned long long )tf->dev | ((lba >> 24) & 15ULL));
  }
#line 147
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.c"
__u64 tf_to_lba(struct ata_tf *tf ) 
{ 
  __u32 lba24 ;
  __u32 lbah ;
  __u64 lba64 ;

  {
#line 156
  lba24 = (__u32 )((((int )tf->lob.lbah << 16) | ((int )tf->lob.lbam << 8)) | (int )tf->lob.lbal);
#line 157
  if (tf->is_lba48) {
#line 158
    lbah = (__u32 )((((int )tf->hob.lbah << 16) | ((int )tf->hob.lbam << 8)) | (int )tf->hob.lbal);
  } else {
#line 160
    lbah = (__u32 )((int )tf->dev & 15);
  }
#line 161
  lba64 = ((__u64 )lbah << 24) | (__u64 )lba24;
#line 162
  return (lba64);
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.c"
static void dump_bytes(char const   *prefix , unsigned char *p , int len ) 
{ 
  int i ;

  {
#line 183
  if (prefix) {
    {
#line 184
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            prefix);
    }
  }
#line 185
  i = 0;
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! (i < len)) {
#line 185
      goto while_break;
    }
    {
#line 186
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %02x",
            (int )*(p + i));
#line 185
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 187
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 188
  return;
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.c"
static int second_try  =    0;
#line 310 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.c"
static int second_try___0  =    0;
#line 190 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.c"
int sg16(int fd , int rw , int dma___0 , struct ata_tf *tf , void *data , unsigned int data_bytes ,
         unsigned int timeout_secs ) 
{ 
  unsigned char cdb[16] ;
  unsigned char sb[32] ;
  unsigned char *desc ;
  struct scsi_sg_io_hdr io_hdr ;
  int prefer12 ;
  int demanded_sense ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __u64 tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  unsigned int len ;
  unsigned int maxlen ;
  int *tmp___10 ;

  {
#line 196
  prefer12 = prefer_ata12;
#line 196
  demanded_sense = 0;
#line 198
  if ((int )tf->command == 161) {
#line 199
    prefer12 = 0;
  }
  {
#line 201
  memset((void *)(& cdb), 0, sizeof(cdb));
#line 202
  memset((void *)(& sb), 0, sizeof(sb));
#line 203
  memset((void *)(& io_hdr), 0, sizeof(struct scsi_sg_io_hdr ));
  }
#line 204
  if (data) {
#line 204
    if (data_bytes) {
#line 204
      if (! rw) {
        {
#line 205
        memset(data, 0, (size_t )data_bytes);
        }
      }
    }
  }
#line 207
  if (dma___0) {
#line 209
    if (data) {
#line 209
      cdb[1] = (unsigned char )(6 << 1);
    } else {
#line 209
      cdb[1] = (unsigned char )(3 << 1);
    }
  } else
#line 211
  if (data) {
#line 211
    if (rw) {
#line 211
      tmp = 5 << 1;
    } else {
#line 211
      tmp = 4 << 1;
    }
#line 211
    cdb[1] = (unsigned char )tmp;
  } else {
#line 211
    cdb[1] = (unsigned char )(3 << 1);
  }
#line 215
  if (data) {
#line 216
    cdb[2] = (unsigned char )((int )cdb[2] | 6);
#line 217
    if (rw) {
#line 217
      tmp___0 = 0;
    } else {
#line 217
      tmp___0 = 8;
    }
#line 217
    cdb[2] = (unsigned char )((int )cdb[2] | tmp___0);
  } else {
#line 219
    cdb[2] = (unsigned char)32;
  }
#line 222
  if (! prefer12) {
#line 222
    goto _L;
  } else
#line 222
  if (tf->is_lba48) {
    _L: /* CIL Label */ 
#line 223
    cdb[0] = (unsigned char)133;
#line 224
    cdb[4] = tf->lob.feat;
#line 225
    cdb[6] = tf->lob.nsect;
#line 226
    cdb[8] = tf->lob.lbal;
#line 227
    cdb[10] = tf->lob.lbam;
#line 228
    cdb[12] = tf->lob.lbah;
#line 229
    cdb[13] = tf->dev;
#line 230
    cdb[14] = tf->command;
#line 231
    if (tf->is_lba48) {
#line 232
      cdb[1] = (unsigned char )((int )cdb[1] | 1);
#line 233
      cdb[3] = tf->hob.feat;
#line 234
      cdb[5] = tf->hob.nsect;
#line 235
      cdb[7] = tf->hob.lbal;
#line 236
      cdb[9] = tf->hob.lbam;
#line 237
      cdb[11] = tf->hob.lbah;
    }
#line 239
    io_hdr.cmd_len = (unsigned char)16;
  } else {
#line 241
    cdb[0] = (unsigned char)161;
#line 242
    cdb[3] = tf->lob.feat;
#line 243
    cdb[4] = tf->lob.nsect;
#line 244
    cdb[5] = tf->lob.lbal;
#line 245
    cdb[6] = tf->lob.lbam;
#line 246
    cdb[7] = tf->lob.lbah;
#line 247
    cdb[8] = tf->dev;
#line 248
    cdb[9] = tf->command;
#line 249
    io_hdr.cmd_len = (unsigned char)12;
  }
#line 252
  io_hdr.interface_id = 'S';
#line 253
  io_hdr.mx_sb_len = (unsigned char )sizeof(sb);
#line 254
  if (data) {
#line 254
    if (rw) {
#line 254
      tmp___1 = -2;
    } else {
#line 254
      tmp___1 = -3;
    }
#line 254
    io_hdr.dxfer_direction = tmp___1;
  } else {
#line 254
    io_hdr.dxfer_direction = -1;
  }
#line 255
  if (data) {
#line 255
    io_hdr.dxfer_len = data_bytes;
  } else {
#line 255
    io_hdr.dxfer_len = 0U;
  }
  {
#line 256
  io_hdr.dxferp = data;
#line 257
  io_hdr.cmdp = cdb;
#line 258
  io_hdr.sbp = (void *)(sb);
#line 259
  tmp___2 = tf_to_lba(tf);
#line 259
  io_hdr.pack_id = (int )tmp___2;
  }
#line 260
  if (timeout_secs) {
#line 260
    tmp___3 = timeout_secs;
  } else {
#line 260
    tmp___3 = (unsigned int )default_timeout_secs;
  }
#line 260
  io_hdr.timeout = tmp___3 * 1000U;
#line 262
  if (verbose) {
    {
#line 263
    dump_bytes("outgoing cdb", cdb, (int )sizeof(cdb));
    }
#line 264
    if (rw) {
#line 264
      if (data) {
        {
#line 265
        dump_bytes("outgoing_data", (unsigned char *)data, (int )data_bytes);
        }
      }
    }
  }
  {
#line 268
  tmp___4 = ioctl(fd, 8837UL, & io_hdr);
  }
#line 268
  if (tmp___4 == -1) {
#line 269
    if (verbose) {
      {
#line 270
      perror("ioctl(fd,SG_IO)");
      }
    }
#line 271
    return (-1);
  }
#line 274
  if (verbose) {
    {
#line 275
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SG_IO: ATA_%u status=0x%x, host_status=0x%x, driver_status=0x%x\n",
            (int )io_hdr.cmd_len, (int )io_hdr.status, (int )io_hdr.host_status, (int )io_hdr.driver_status);
    }
  }
#line 278
  if (io_hdr.status) {
#line 278
    if ((int )io_hdr.status != 2) {
#line 279
      if (verbose) {
        {
#line 280
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SG_IO: bad status: 0x%x\n",
                (int )io_hdr.status);
        }
      }
      {
#line 281
      tmp___5 = __errno_location();
#line 281
      *tmp___5 = 52;
      }
#line 282
      return (-1);
    }
  }
#line 284
  if (io_hdr.host_status) {
#line 285
    if (verbose) {
      {
#line 286
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SG_IO: bad host status: 0x%x\n",
              (int )io_hdr.host_status);
      }
    }
    {
#line 287
    tmp___6 = __errno_location();
#line 287
    *tmp___6 = 52;
    }
#line 288
    return (-1);
  }
#line 290
  if (verbose) {
    {
#line 291
    dump_bytes("SG_IO: sb[]", sb, (int )sizeof(sb));
    }
#line 292
    if (! rw) {
#line 292
      if (data) {
        {
#line 293
        dump_bytes("incoming_data", (unsigned char *)data, (int )data_bytes);
        }
      }
    }
  }
#line 296
  if (io_hdr.driver_status) {
#line 296
    if ((int )io_hdr.driver_status != 8) {
#line 297
      if (verbose) {
        {
#line 298
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SG_IO: bad driver status: 0x%x\n",
                (int )io_hdr.driver_status);
        }
      }
      {
#line 299
      tmp___7 = __errno_location();
#line 299
      *tmp___7 = 52;
      }
#line 300
      return (-1);
    }
  }
#line 303
  desc = sb + 8;
#line 304
  if ((int )io_hdr.driver_status != 8) {
#line 305
    if ((((((((((int )sb[0] | (int )sb[1]) | (int )sb[2]) | (int )sb[3]) | (int )sb[4]) | (int )sb[5]) | (int )sb[6]) | (int )sb[7]) | (int )sb[8]) | (int )sb[9]) {
#line 307
      tmp___8 = second_try;
#line 307
      second_try ++;
#line 307
      if (! tmp___8) {
        {
#line 308
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SG_IO: questionable sense data, results may be incorrect\n");
        }
      }
    } else
#line 309
    if (demanded_sense) {
#line 311
      tmp___9 = second_try___0;
#line 311
      second_try___0 ++;
#line 311
      if (! tmp___9) {
        {
#line 312
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SG_IO: missing sense data, results may be incorrect\n");
        }
      }
    }
  } else
#line 314
  if ((int )sb[0] != 114) {
    {
#line 315
    dump_bytes("SG_IO: bad/missing sense data, sb[]", sb, (int )sizeof(sb));
    }
  } else
#line 314
  if ((int )sb[7] < 14) {
    {
#line 315
    dump_bytes("SG_IO: bad/missing sense data, sb[]", sb, (int )sizeof(sb));
    }
  } else
#line 314
  if ((int )*(desc + 0) != 9) {
    {
#line 315
    dump_bytes("SG_IO: bad/missing sense data, sb[]", sb, (int )sizeof(sb));
    }
  } else
#line 314
  if ((int )*(desc + 1) < 12) {
    {
#line 315
    dump_bytes("SG_IO: bad/missing sense data, sb[]", sb, (int )sizeof(sb));
    }
  }
#line 318
  if (verbose) {
#line 319
    len = (unsigned int )((int )*(desc + 1) + 2);
#line 319
    maxlen = (unsigned int )((sizeof(sb) - 8UL) - 2UL);
#line 320
    if (len > maxlen) {
#line 321
      len = maxlen;
    }
    {
#line 322
    dump_bytes("SG_IO: desc[]", desc, (int )len);
    }
  }
#line 325
  tf->is_lba48 = (__u8 )((int )*(desc + 2) & 1);
#line 326
  tf->error = *(desc + 3);
#line 327
  tf->lob.nsect = *(desc + 5);
#line 328
  tf->lob.lbal = *(desc + 7);
#line 329
  tf->lob.lbam = *(desc + 9);
#line 330
  tf->lob.lbah = *(desc + 11);
#line 331
  tf->dev = *(desc + 12);
#line 332
  tf->status = *(desc + 13);
#line 333
  tf->hob.feat = (__u8 )0;
#line 334
  if (tf->is_lba48) {
#line 335
    tf->hob.nsect = *(desc + 4);
#line 336
    tf->hob.lbal = *(desc + 6);
#line 337
    tf->hob.lbam = *(desc + 8);
#line 338
    tf->hob.lbah = *(desc + 10);
  } else {
#line 340
    tf->hob.nsect = (__u8 )0;
#line 341
    tf->hob.lbal = (__u8 )0;
#line 342
    tf->hob.lbam = (__u8 )0;
#line 343
    tf->hob.lbah = (__u8 )0;
  }
#line 346
  if (verbose) {
    {
#line 347
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      ATA_%u stat=%02x err=%02x nsect=%02x lbal=%02x lbam=%02x lbah=%02x dev=%02x\n",
            (int )io_hdr.cmd_len, (int )tf->status, (int )tf->error, (int )tf->lob.nsect,
            (int )tf->lob.lbal, (int )tf->lob.lbam, (int )tf->lob.lbah, (int )tf->dev);
    }
  }
#line 350
  if ((int )tf->status & 9) {
#line 351
    if (verbose) {
      {
#line 352
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"I/O error, ata_op=0x%02x ata_status=0x%02x ata_error=0x%02x\n",
              (int )tf->command, (int )tf->status, (int )tf->error);
      }
    }
    {
#line 355
    tmp___10 = __errno_location();
#line 355
    *tmp___10 = 5;
    }
#line 356
    return (-1);
  }
#line 358
  return (0);
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.c"
int do_drive_cmd(int fd , unsigned char *args___1 , unsigned int timeout_secs ) 
{ 
  struct ata_tf tf ;
  void *data ;
  unsigned int data_bytes ;
  int rc ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 368
  data = (void *)0;
#line 369
  data_bytes = 0U;
#line 372
  if ((unsigned long )args___1 == (unsigned long )((void *)0)) {
#line 373
    goto use_legacy_ioctl;
  }
  {
#line 381
  tf_init(& tf, *(args___1 + 0), (__u64 )0, 0U);
#line 382
  tf.lob.nsect = *(args___1 + 1);
#line 383
  tf.lob.feat = *(args___1 + 2);
  }
#line 384
  if (*(args___1 + 3)) {
#line 385
    data_bytes = (unsigned int )((int )*(args___1 + 3) * 512);
#line 386
    data = (void *)(args___1 + 4);
#line 387
    if (! tf.lob.nsect) {
#line 388
      tf.lob.nsect = *(args___1 + 3);
    }
  }
#line 390
  if ((int )tf.command == 176) {
#line 391
    tf.lob.nsect = *(args___1 + 3);
#line 392
    tf.lob.lbal = *(args___1 + 1);
#line 393
    tf.lob.lbam = (__u8 )79;
#line 394
    tf.lob.lbah = (__u8 )194;
  }
  {
#line 397
  tmp = is_dma(tf.command);
#line 397
  rc = sg16(fd, 0, tmp, & tf, data, data_bytes, timeout_secs);
  }
#line 398
  if (rc == -1) {
    {
#line 399
    tmp___0 = __errno_location();
    }
#line 399
    if (*tmp___0 == 22) {
#line 400
      goto use_legacy_ioctl;
    } else {
      {
#line 399
      tmp___1 = __errno_location();
      }
#line 399
      if (*tmp___1 == 19) {
#line 400
        goto use_legacy_ioctl;
      } else {
        {
#line 399
        tmp___2 = __errno_location();
        }
#line 399
        if (*tmp___2 == 52) {
#line 400
          goto use_legacy_ioctl;
        }
      }
    }
  }
#line 403
  if (rc == 0) {
#line 404
    *(args___1 + 0) = tf.status;
#line 405
    *(args___1 + 1) = tf.error;
#line 406
    *(args___1 + 2) = tf.lob.nsect;
  } else {
    {
#line 403
    tmp___3 = __errno_location();
    }
#line 403
    if (*tmp___3 == 5) {
#line 404
      *(args___1 + 0) = tf.status;
#line 405
      *(args___1 + 1) = tf.error;
#line 406
      *(args___1 + 2) = tf.lob.nsect;
    }
  }
#line 408
  return (rc);
  use_legacy_ioctl: 
#line 412
  if (verbose) {
#line 413
    if (args___1) {
      {
#line 414
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Trying legacy HDIO_DRIVE_CMD\n");
      }
    }
  }
  {
#line 416
  tmp___4 = ioctl(fd, 799UL, args___1);
  }
#line 416
  return (tmp___4);
}
}
#line 419 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.c"
int do_taskfile_cmd(int fd , struct hdio_taskfile *r , unsigned int timeout_secs ) 
{ 
  int rc ;
  struct ata_tf tf ;
  void *data ;
  unsigned int data_bytes ;
  int rw ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int err ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
  {
#line 424
  data = (void *)0;
#line 425
  data_bytes = 0U;
#line 426
  rw = 0;
#line 430
  tf_init(& tf, (__u8 )0, (__u64 )0, 0U);
  }
#line 432
  if (verbose) {
    {
#line 433
    printf((char const   */* __restrict  */)"oflags.lob_all=0x%02x, flags={", r->oflags.__annonCompField1.lob_all);
    }
#line 434
    if (r->oflags.__annonCompField1.lob.feat) {
      {
#line 434
      printf((char const   */* __restrict  */)" feat");
      }
    }
#line 435
    if (r->oflags.__annonCompField1.lob.nsect) {
      {
#line 435
      printf((char const   */* __restrict  */)" nsect");
      }
    }
#line 436
    if (r->oflags.__annonCompField1.lob.lbal) {
      {
#line 436
      printf((char const   */* __restrict  */)" lbal");
      }
    }
#line 437
    if (r->oflags.__annonCompField1.lob.lbam) {
      {
#line 437
      printf((char const   */* __restrict  */)" lbam");
      }
    }
#line 438
    if (r->oflags.__annonCompField1.lob.lbah) {
      {
#line 438
      printf((char const   */* __restrict  */)" lbah");
      }
    }
#line 439
    if (r->oflags.__annonCompField1.lob.dev) {
      {
#line 439
      printf((char const   */* __restrict  */)" dev");
      }
    }
#line 440
    if (r->oflags.__annonCompField1.lob.command) {
      {
#line 440
      printf((char const   */* __restrict  */)" command");
      }
    }
    {
#line 441
    printf((char const   */* __restrict  */)" }\n");
#line 442
    printf((char const   */* __restrict  */)"oflags.hob_all=0x%02x, flags={", r->oflags.__annonCompField2.hob_all);
    }
#line 443
    if (r->oflags.__annonCompField2.hob.feat) {
      {
#line 443
      printf((char const   */* __restrict  */)" feat");
      }
    }
#line 444
    if (r->oflags.__annonCompField2.hob.nsect) {
      {
#line 444
      printf((char const   */* __restrict  */)" nsect");
      }
    }
#line 445
    if (r->oflags.__annonCompField2.hob.lbal) {
      {
#line 445
      printf((char const   */* __restrict  */)" lbal");
      }
    }
#line 446
    if (r->oflags.__annonCompField2.hob.lbam) {
      {
#line 446
      printf((char const   */* __restrict  */)" lbam");
      }
    }
#line 447
    if (r->oflags.__annonCompField2.hob.lbah) {
      {
#line 447
      printf((char const   */* __restrict  */)" lbah");
      }
    }
    {
#line 448
    printf((char const   */* __restrict  */)" }\n");
    }
  }
#line 451
  if (r->oflags.__annonCompField1.lob.feat) {
#line 451
    tf.lob.feat = r->lob.feat;
  }
#line 452
  if (r->oflags.__annonCompField1.lob.lbal) {
#line 452
    tf.lob.lbal = r->lob.lbal;
  }
#line 453
  if (r->oflags.__annonCompField1.lob.nsect) {
#line 453
    tf.lob.nsect = r->lob.nsect;
  }
#line 454
  if (r->oflags.__annonCompField1.lob.lbam) {
#line 454
    tf.lob.lbam = r->lob.lbam;
  }
#line 455
  if (r->oflags.__annonCompField1.lob.lbah) {
#line 455
    tf.lob.lbah = r->lob.lbah;
  }
#line 456
  if (r->oflags.__annonCompField1.lob.dev) {
#line 456
    tf.dev = r->lob.dev;
  }
#line 457
  if (r->oflags.__annonCompField1.lob.command) {
#line 457
    tf.command = r->lob.command;
  }
  {
#line 458
  tmp = needs_lba48(tf.command, (__u64 )0, 0U);
  }
#line 458
  if (tmp) {
#line 458
    goto _L;
  } else
#line 458
  if (r->oflags.__annonCompField2.hob_all) {
#line 458
    goto _L;
  } else
#line 458
  if (r->iflags.__annonCompField2.hob_all) {
    _L: /* CIL Label */ 
#line 459
    tf.is_lba48 = (__u8 )1;
#line 460
    if (r->oflags.__annonCompField2.hob.feat) {
#line 460
      tf.hob.feat = r->hob.feat;
    }
#line 461
    if (r->oflags.__annonCompField2.hob.lbal) {
#line 461
      tf.hob.lbal = r->hob.lbal;
    }
#line 462
    if (r->oflags.__annonCompField2.hob.nsect) {
#line 462
      tf.hob.nsect = r->hob.nsect;
    }
#line 463
    if (r->oflags.__annonCompField2.hob.lbam) {
#line 463
      tf.hob.lbam = r->hob.lbam;
    }
#line 464
    if (r->oflags.__annonCompField2.hob.lbah) {
#line 464
      tf.hob.lbah = r->hob.lbah;
    }
#line 465
    if (verbose) {
      {
#line 466
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"using LBA48 taskfile\n");
      }
    }
  }
  {
#line 470
  if (r->cmd_req == 4) {
#line 470
    goto case_4;
  }
#line 470
  if (r->cmd_req == 3) {
#line 470
    goto case_4;
  }
#line 475
  if (r->cmd_req == 2) {
#line 475
    goto case_2;
  }
#line 468
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 471
  data_bytes = (unsigned int )r->obytes;
#line 472
  data = (void *)(r->data);
#line 473
  rw = 1;
#line 474
  goto switch_break;
  case_2: /* CIL Label */ 
#line 476
  data_bytes = (unsigned int )r->ibytes;
#line 477
  data = (void *)(r->data);
#line 478
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 481
  tmp___0 = is_dma(tf.command);
#line 481
  rc = sg16(fd, rw, tmp___0, & tf, data, data_bytes, timeout_secs);
  }
#line 482
  if (rc == -1) {
    {
#line 483
    tmp___1 = __errno_location();
    }
#line 483
    if (*tmp___1 == 22) {
#line 484
      goto use_legacy_ioctl;
    } else {
      {
#line 483
      tmp___2 = __errno_location();
      }
#line 483
      if (*tmp___2 == 19) {
#line 484
        goto use_legacy_ioctl;
      } else {
        {
#line 483
        tmp___3 = __errno_location();
        }
#line 483
        if (*tmp___3 == 52) {
#line 484
          goto use_legacy_ioctl;
        }
      }
    }
  }
#line 487
  if (rc == 0) {
#line 487
    goto _L___0;
  } else {
    {
#line 487
    tmp___4 = __errno_location();
    }
#line 487
    if (*tmp___4 == 5) {
      _L___0: /* CIL Label */ 
#line 488
      if (r->iflags.__annonCompField1.lob.feat) {
#line 488
        r->lob.feat = tf.error;
      }
#line 489
      if (r->iflags.__annonCompField1.lob.lbal) {
#line 489
        r->lob.lbal = tf.lob.lbal;
      }
#line 490
      if (r->iflags.__annonCompField1.lob.nsect) {
#line 490
        r->lob.nsect = tf.lob.nsect;
      }
#line 491
      if (r->iflags.__annonCompField1.lob.lbam) {
#line 491
        r->lob.lbam = tf.lob.lbam;
      }
#line 492
      if (r->iflags.__annonCompField1.lob.lbah) {
#line 492
        r->lob.lbah = tf.lob.lbah;
      }
#line 493
      if (r->iflags.__annonCompField1.lob.dev) {
#line 493
        r->lob.dev = tf.dev;
      }
#line 494
      if (r->iflags.__annonCompField1.lob.command) {
#line 494
        r->lob.command = tf.status;
      }
#line 495
      if (r->iflags.__annonCompField2.hob.feat) {
#line 495
        r->hob.feat = tf.hob.feat;
      }
#line 496
      if (r->iflags.__annonCompField2.hob.lbal) {
#line 496
        r->hob.lbal = tf.hob.lbal;
      }
#line 497
      if (r->iflags.__annonCompField2.hob.nsect) {
#line 497
        r->hob.nsect = tf.hob.nsect;
      }
#line 498
      if (r->iflags.__annonCompField2.hob.lbam) {
#line 498
        r->hob.lbam = tf.hob.lbam;
      }
#line 499
      if (r->iflags.__annonCompField2.hob.lbah) {
#line 499
        r->hob.lbah = tf.hob.lbah;
      }
    }
  }
#line 501
  return (rc);
  use_legacy_ioctl: 
#line 507
  if (verbose) {
    {
#line 508
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"trying legacy HDIO_DRIVE_TASKFILE\n");
    }
  }
  {
#line 509
  tmp___5 = __errno_location();
#line 509
  *tmp___5 = 0;
#line 511
  rc = ioctl(fd, 797UL, r);
  }
#line 512
  if (verbose) {
    {
#line 513
    tmp___6 = __errno_location();
#line 513
    err = *tmp___6;
#line 514
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rc=%d, errno=%d, returned ATA registers: ",
            rc, err);
    }
#line 515
    if (r->iflags.__annonCompField1.lob.feat) {
      {
#line 515
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" er=%02x",
              (int )r->lob.feat);
      }
    }
#line 516
    if (r->iflags.__annonCompField1.lob.nsect) {
      {
#line 516
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ns=%02x",
              (int )r->lob.nsect);
      }
    }
#line 517
    if (r->iflags.__annonCompField1.lob.lbal) {
      {
#line 517
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" ll=%02x",
              (int )r->lob.lbal);
      }
    }
#line 518
    if (r->iflags.__annonCompField1.lob.lbam) {
      {
#line 518
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" lm=%02x",
              (int )r->lob.lbam);
      }
    }
#line 519
    if (r->iflags.__annonCompField1.lob.lbah) {
      {
#line 519
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" lh=%02x",
              (int )r->lob.lbah);
      }
    }
#line 520
    if (r->iflags.__annonCompField1.lob.dev) {
      {
#line 520
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" dh=%02x",
              (int )r->lob.dev);
      }
    }
#line 521
    if (r->iflags.__annonCompField1.lob.command) {
      {
#line 521
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" st=%02x",
              (int )r->lob.command);
      }
    }
#line 522
    if (r->iflags.__annonCompField2.hob.feat) {
      {
#line 522
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" err=%02x",
              (int )r->hob.feat);
      }
    }
#line 523
    if (r->iflags.__annonCompField2.hob.nsect) {
      {
#line 523
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" err=%02x",
              (int )r->hob.nsect);
      }
    }
#line 524
    if (r->iflags.__annonCompField2.hob.lbal) {
      {
#line 524
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" err=%02x",
              (int )r->hob.lbal);
      }
    }
#line 525
    if (r->iflags.__annonCompField2.hob.lbam) {
      {
#line 525
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" err=%02x",
              (int )r->hob.lbam);
      }
    }
#line 526
    if (r->iflags.__annonCompField2.hob.lbah) {
      {
#line 526
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" err=%02x",
              (int )r->hob.lbah);
      }
    }
    {
#line 527
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 528
    tmp___7 = __errno_location();
#line 528
    *tmp___7 = err;
    }
  }
#line 530
  if (rc == -1) {
    {
#line 530
    tmp___9 = __errno_location();
    }
#line 530
    if (*tmp___9 == 22) {
      {
#line 531
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The running kernel lacks CONFIG_IDE_TASK_IOCTL support for this device.\n");
#line 532
      tmp___8 = __errno_location();
#line 532
      *tmp___8 = 22;
      }
    }
  }
#line 534
  return (rc);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/sgio.c"
void init_hdio_taskfile(struct hdio_taskfile *r , __u8 ata_op , int rw , int force_lba48 ,
                        __u64 lba , unsigned int nsect , int data_bytes ) 
{ 
  int tmp ;

  {
  {
#line 540
  memset((void *)r, 0, sizeof(struct hdio_taskfile ) + (unsigned long )data_bytes);
  }
#line 541
  if (! data_bytes) {
#line 542
    r->dphase = 0;
#line 543
    r->cmd_req = 0;
  } else
#line 544
  if (rw == 1) {
#line 545
    r->dphase = 4;
#line 546
    r->cmd_req = 4;
#line 547
    r->obytes = (unsigned long )data_bytes;
  } else {
#line 549
    r->dphase = 1;
#line 550
    r->cmd_req = 2;
#line 551
    r->ibytes = (unsigned long )data_bytes;
  }
  {
#line 553
  r->lob.command = ata_op;
#line 554
  r->oflags.__annonCompField1.lob.command = 1U;
#line 555
  r->oflags.__annonCompField1.lob.dev = 1U;
#line 556
  r->oflags.__annonCompField1.lob.lbal = 1U;
#line 557
  r->oflags.__annonCompField1.lob.lbam = 1U;
#line 558
  r->oflags.__annonCompField1.lob.lbah = 1U;
#line 559
  r->oflags.__annonCompField1.lob.nsect = 1U;
#line 561
  r->iflags.__annonCompField1.lob.command = 1U;
#line 562
  r->iflags.__annonCompField1.lob.feat = 1U;
#line 564
  r->lob.nsect = (__u8 )nsect;
#line 565
  r->lob.lbal = (__u8 )lba;
#line 566
  r->lob.lbam = (__u8 )(lba >> 8);
#line 567
  r->lob.lbah = (__u8 )(lba >> 16);
#line 568
  r->lob.dev = (__u8 )224;
#line 570
  tmp = needs_lba48(ata_op, lba, nsect);
  }
#line 570
  if (tmp) {
#line 570
    goto _L;
  } else
#line 570
  if (force_lba48) {
    _L: /* CIL Label */ 
#line 571
    r->hob.nsect = (__u8 )(nsect >> 8);
#line 572
    r->hob.lbal = (__u8 )(lba >> 24);
#line 573
    r->hob.lbam = (__u8 )(lba >> 32);
#line 574
    r->hob.lbah = (__u8 )(lba >> 40);
#line 575
    r->oflags.__annonCompField2.hob.nsect = 1U;
#line 576
    r->oflags.__annonCompField2.hob.lbal = 1U;
#line 577
    r->oflags.__annonCompField2.hob.lbam = 1U;
#line 578
    r->oflags.__annonCompField2.hob.lbah = 1U;
  } else {
#line 580
    r->lob.dev = (__u8 )((unsigned long long )r->lob.dev | ((lba >> 24) & 15ULL));
  }
#line 582
  return;
}
}
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 345
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek64)(int __fd ,
                                                                                  __off_t __offset ,
                                                                                  int __whence ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 972
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) sync)(void) ;
#line 1112
extern int fdatasync(int __fildes ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 209
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1), __leaf__)) strtoll)(char const   * __restrict  __nptr ,
                                                                                                    char ** __restrict  __endptr ,
                                                                                                    int __base ) ;
#line 431 "/usr/include/stdio.h"
extern int scanf(char const   * __restrict  __format  , ...)  __asm__("__isoc99_scanf")  ;
#line 538
extern int getchar(void) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 184
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strndup)(char const   *__string ,
                                                                                                size_t __n )  __attribute__((__malloc__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getitimer)(__itimer_which_t __which ,
                                                                                struct itimerval *__value ) ;
#line 131
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setitimer)(__itimer_which_t __which ,
                                                                                struct itimerval  const  * __restrict  __new ,
                                                                                struct itimerval * __restrict  __old ) ;
#line 76 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 103
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) mlock)(void const   *__addr ,
                                                                            size_t __len ) ;
#line 111
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) mlockall)(int __flags ) ;
#line 115
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munlockall)(void) ;
#line 46 "/usr/include/linux/swab.h"
__inline static __u16 __fswab16(__u16 val ) 
{ 


  {
#line 53
  return ((__u16 )((((int )val & 255) << 8) | (((int )val & 65280) >> 8)));
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.h"
void process_dev(char *devname ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int argc  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static char **argv  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static char *argp  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int num_flags_processed  =    0;
#line 54 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
char *progname  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
int verbose  =    0;
#line 56 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
int prefer_ata12  =    0;
#line 57 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int do_defaults  =    0;
#line 57 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int do_flush  =    0;
#line 57 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int do_ctimings  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int do_timings  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int do_identity  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_geom  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int noisy  =    1;
#line 58 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int quiet  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int do_flush_wcache  =    0;
#line 61 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_wdidle3  =    0;
#line 61 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_wdidle3  =    0;
#line 61 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int wdidle3  =    0;
#line 62 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_timings_offset  =    0;
#line 63 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static __u64 timings_offset  =    (__u64 )0;
#line 64 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_fsreadahead  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_fsreadahead  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int fsreadahead  =    0;
#line 65 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_readonly  =    0;
#line 65 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_readonly  =    0;
#line 65 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int readonly  =    0;
#line 66 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_unmask  =    0;
#line 66 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_unmask  =    0;
#line 66 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int unmask  =    0;
#line 67 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_mult  =    0;
#line 67 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_mult  =    0;
#line 67 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int mult  =    0;
#line 68 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_dma  =    0;
#line 68 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_dma  =    0;
#line 68 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int dma  =    0;
#line 69 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_dma_q  =    0;
#line 69 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_dma_q  =    0;
#line 69 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int dma_q  =    0;
#line 70 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_nowerr  =    0;
#line 70 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_nowerr  =    0;
#line 70 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int nowerr  =    0;
#line 71 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_keep  =    0;
#line 71 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_keep  =    0;
#line 71 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int keep  =    0;
#line 72 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_io32bit  =    0;
#line 72 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_io32bit  =    0;
#line 72 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int io32bit  =    0;
#line 73 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_piomode  =    0;
#line 73 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_piomode  =    0;
#line 73 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int piomode  =    0;
#line 74 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_dkeep  =    0;
#line 74 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_dkeep  =    0;
#line 74 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int dkeep  =    0;
#line 75 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_standby  =    0;
#line 75 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_standby  =    0;
#line 75 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int standby  =    0;
#line 76 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_xfermode  =    0;
#line 76 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_xfermode  =    0;
#line 77 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int xfermode_requested  =    0;
#line 78 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_lookahead  =    0;
#line 78 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_lookahead  =    0;
#line 78 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int lookahead  =    0;
#line 79 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_prefetch  =    0;
#line 79 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_prefetch  =    0;
#line 79 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int prefetch  =    0;
#line 80 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_defects  =    0;
#line 80 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_defects  =    0;
#line 80 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int defects  =    0;
#line 81 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_wcache  =    0;
#line 81 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_wcache  =    0;
#line 81 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int wcache  =    0;
#line 82 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_doorlock  =    0;
#line 82 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_doorlock  =    0;
#line 82 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int doorlock  =    0;
#line 83 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_seagate  =    0;
#line 83 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_seagate  =    0;
#line 84 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_idleimmediate  =    0;
#line 84 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_idleimmediate  =    0;
#line 85 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_idleunload  =    0;
#line 85 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_idleunload  =    0;
#line 86 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_standbynow  =    0;
#line 86 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_standbynow  =    0;
#line 87 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_sleepnow  =    0;
#line 87 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_sleepnow  =    0;
#line 88 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_powerup_in_standby  =    0;
#line 88 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_powerup_in_standby  =    0;
#line 88 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int powerup_in_standby  =    0;
#line 89 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_hitachi_temp  =    0;
#line 89 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_hitachi_temp  =    0;
#line 90 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int security_freeze  =    0;
#line 91 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int security_master  =    0;
#line 91 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int security_mode  =    0;
#line 92 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int enhanced_erase  =    0;
#line 93 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_security  =    0;
#line 94 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int do_dco_freeze  =    0;
#line 94 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int do_dco_restore  =    0;
#line 94 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int do_dco_identify  =    0;
#line 95 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static unsigned int security_command  =    242U;
#line 97 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static char security_password[33]  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static char *fwpath  ;
#line 99 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_powermode  =    0;
#line 99 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_powermode  =    0;
#line 100 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_apmmode  =    0;
#line 100 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_apmmode  =    0;
#line 100 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int apmmode  =    0;
#line 101 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_cdromspeed  =    0;
#line 101 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_cdromspeed  =    0;
#line 101 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int cdromspeed  =    0;
#line 102 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int do_IDentity  =    0;
#line 102 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int drq_hsm_error  =    0;
#line 103 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int do_fwdownload  =    0;
#line 103 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int xfer_mode  =    0;
#line 104 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_busstate  =    0;
#line 104 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_busstate  =    0;
#line 104 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int busstate  =    0;
#line 105 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_reread_partn  =    0;
#line 105 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_reread_partn  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_acoustic  =    0;
#line 106 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_acoustic  =    0;
#line 106 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int acoustic  =    0;
#line 107 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int write_read_verify  =    0;
#line 107 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_write_read_verify  =    0;
#line 107 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_write_read_verify  =    0;
#line 109 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int make_bad_sector  =    0;
#line 109 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int make_bad_sector_flagged  ;
#line 110 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static __u64 make_bad_sector_addr  =    ~ 0ULL;
#line 120 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static struct sector_range_s *trim_sector_ranges  =    (struct sector_range_s *)((void *)0);
#line 121 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int trim_sector_ranges_count  =    0;
#line 122 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int trim_from_stdin  =    0;
#line 124 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int write_sector  =    0;
#line 125 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static __u64 write_sector_addr  =    ~ 0ULL;
#line 127 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int read_sector  =    0;
#line 128 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static __u64 read_sector_addr  =    ~ 0ULL;
#line 130 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_max_sectors  =    0;
#line 130 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_max_permanent  ;
#line 130 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_native_max_sectors  =    0;
#line 131 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static __u64 set_max_addr  =    (__u64 )0;
#line 133 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_doreset  =    0;
#line 133 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int set_doreset  =    0;
#line 134 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int i_know_what_i_am_doing  =    0;
#line 135 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int please_destroy_my_drive  =    0;
#line 137 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
int const   timeout_15secs  =    (int const   )15;
#line 138 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
int const   timeout_60secs  =    (int const   )60;
#line 139 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
int const   timeout_5mins  =    (int const   )300;
#line 140 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
int const   timeout_2hrs  =    (int const   )7200;
#line 142 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int open_flags  =    2048;
#line 155 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
char const   *cfg_str[16]  = 
#line 155
  {      "",      " HardSect",      " SoftSect",      " NotMFM", 
        " HdSw>15uSec",      " SpinMotCtl",      " Fixed",      " Removeable", 
        " DTR<=5Mbs",      " DTR>5Mbs",      " DTR>10Mbs",      " RotSpdTol>.5%", 
        " dStbOff",      " TrkOff",      " FmtGapReq",      " nonMagnetic"};
#line 162 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
char const   *SlowMedFast[5]  = {      "slow",      "medium",      "fast",      "eide", 
        "ata"};
#line 163 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
char const   *BuffType[4]  = {      "unknown",      "1Sect",      "DualPort",      "DualPortCache"};
#line 167 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void on_off(unsigned int value ) 
{ 
  char const   *tmp ;

  {
#line 169
  if (value) {
#line 169
    tmp = " (on)\n";
  } else {
#line 169
    tmp = " (off)\n";
  }
  {
#line 169
  printf((char const   */* __restrict  */)tmp);
  }
#line 170
  return;
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void flush_buffer_cache(int fd ) 
{ 
  int tmp ;

  {
  {
#line 178
  sync();
#line 179
  fsync(fd);
#line 180
  fdatasync(fd);
#line 181
  sync();
#line 182
  tmp = ioctl(fd, (unsigned long )((unsigned int )(18 << 8) | 97U), (void *)0);
  }
#line 182
  if (tmp) {
    {
#line 183
    perror("BLKFLSBUF failed");
    }
  } else {
    {
#line 185
    do_drive_cmd(fd, (unsigned char *)((void *)0), 0U);
    }
  }
  {
#line 186
  sync();
  }
#line 187
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int seek_to_zero(int fd ) 
{ 
  __off_t tmp ;

  {
  {
#line 191
  tmp = lseek(fd, (off_t )0, 0);
  }
#line 191
  if (tmp) {
    {
#line 192
    perror("lseek() failed");
    }
#line 193
    return (1);
  }
#line 195
  return (0);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int read_big_block(int fd , char *buf ) 
{ 
  int i ;
  int rc ;
  ssize_t tmp ;

  {
  {
#line 201
  tmp = read(fd, (void *)buf, (size_t )2097152);
#line 201
  rc = (int )tmp;
  }
#line 201
  if (rc != 2097152) {
#line 202
    if (rc) {
#line 203
      if (rc == -1) {
        {
#line 204
        perror("read() failed");
        }
      } else {
        {
#line 206
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"read(%u) returned %u bytes\n",
                2097152, rc);
        }
      }
    } else {
      {
#line 208
      fputs((char const   */* __restrict  */)"read() hit EOF - device too small\n",
            (FILE */* __restrict  */)stderr);
      }
    }
#line 210
    return (1);
  }
#line 213
  i = 0;
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! (i < 2097152)) {
#line 213
      goto while_break;
    }
#line 214
    *(buf + i) = (char )((int )*(buf + i) & 1);
#line 213
    i += 512;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return (0);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void *prepare_timing_buf(unsigned int len ) 
{ 
  unsigned int i ;
  __u8 *buf ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 223
  tmp = mmap((void *)0, (size_t )len, 3, 34, -1, (__off_t )0);
#line 223
  buf = (__u8 *)tmp;
  }
#line 224
  if ((unsigned long )buf == (unsigned long )((void *)-1)) {
    {
#line 225
    perror("could not allocate timing buf");
    }
#line 226
    return ((void *)0);
  }
#line 228
  i = 0U;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! (i < len)) {
#line 228
      goto while_break;
    }
#line 229
    *(buf + i) = (__u8 )0;
#line 228
    i += 4096U;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 230
  tmp___0 = mlock((void const   *)buf, (size_t )len);
  }
#line 230
  if (-1 == tmp___0) {
    {
#line 231
    perror("mlock() failed on timing buf");
#line 232
    munmap((void *)buf, (size_t )len);
    }
#line 233
    return ((void *)0);
  }
  {
#line 235
  mlockall(3);
#line 236
  sync();
#line 239
  sleep(3U);
  }
#line 240
  return ((void *)buf);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void time_cache(int fd ) 
{ 
  char *buf ;
  struct itimerval e1 ;
  struct itimerval e2 ;
  double elapsed ;
  double elapsed2 ;
  unsigned int iterations ;
  unsigned int total_MB ;
  void *tmp ;
  struct itimerval __constr_expr_0 ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 250
  tmp = prepare_timing_buf(2097152U);
#line 250
  buf = (char *)tmp;
  }
#line 251
  if (! buf) {
#line 252
    return;
  }
  {
#line 258
  __constr_expr_0.it_interval.tv_sec = (__time_t )1000;
#line 258
  __constr_expr_0.it_interval.tv_usec = (__suseconds_t )0;
#line 258
  __constr_expr_0.it_value.tv_sec = (__time_t )1000;
#line 258
  __constr_expr_0.it_value.tv_usec = (__suseconds_t )0;
#line 258
  setitimer((__itimer_which_t )0, (struct itimerval  const  */* __restrict  */)(& __constr_expr_0),
            (struct itimerval */* __restrict  */)((void *)0));
#line 259
  tmp___0 = seek_to_zero(fd);
  }
#line 259
  if (tmp___0) {
#line 259
    return;
  }
  {
#line 260
  tmp___1 = read_big_block(fd, buf);
  }
#line 260
  if (tmp___1) {
#line 260
    return;
  }
#line 261
  if (open_flags & 16384) {
#line 261
    tmp___2 = "O_DIRECT ";
  } else {
#line 261
    tmp___2 = "";
  }
  {
#line 261
  printf((char const   */* __restrict  */)" Timing %scached reads:   ", tmp___2);
#line 262
  fflush(stdout);
#line 265
  flush_buffer_cache(fd);
#line 266
  sleep(1U);
#line 269
  iterations = 0U;
#line 270
  getitimer((__itimer_which_t )0, & e1);
  }
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 272
    iterations ++;
#line 273
    tmp___3 = seek_to_zero(fd);
    }
#line 273
    if (tmp___3) {
#line 274
      goto quit;
    } else {
      {
#line 273
      tmp___4 = read_big_block(fd, buf);
      }
#line 273
      if (tmp___4) {
#line 274
        goto quit;
      }
    }
    {
#line 275
    getitimer((__itimer_which_t )0, & e2);
#line 276
    elapsed = (double )(e1.it_value.tv_sec - e2.it_value.tv_sec) + (double )(e1.it_value.tv_usec - e2.it_value.tv_usec) / 1000000.0;
    }
#line 271
    if (! (elapsed < 2.0)) {
#line 271
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 279
  total_MB = iterations * 2U;
#line 281
  elapsed = (double )(e1.it_value.tv_sec - e2.it_value.tv_sec) + (double )(e1.it_value.tv_usec - e2.it_value.tv_usec) / 1000000.0;
#line 285
  getitimer((__itimer_which_t )0, & e1);
  }
  {
#line 286
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 287
    tmp___5 = seek_to_zero(fd);
    }
#line 287
    if (tmp___5) {
#line 288
      goto quit;
    }
    {
#line 289
    getitimer((__itimer_which_t )0, & e2);
#line 290
    elapsed2 = (double )(e1.it_value.tv_sec - e2.it_value.tv_sec) + (double )(e1.it_value.tv_usec - e2.it_value.tv_usec) / 1000000.0;
#line 286
    iterations --;
    }
#line 286
    if (! iterations) {
#line 286
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 294
  elapsed -= elapsed2;
#line 296
  if ((double )total_MB >= elapsed) {
    {
#line 297
    printf((char const   */* __restrict  */)"%3u MB in %5.2f seconds = %6.2f MB/sec\n",
           total_MB, elapsed, (double )total_MB / elapsed);
    }
  } else {
    {
#line 301
    printf((char const   */* __restrict  */)"%3u MB in %5.2f seconds = %6.2f kB/sec\n",
           total_MB, elapsed, ((double )total_MB / elapsed) * (double )1024);
    }
  }
  {
#line 305
  flush_buffer_cache(fd);
#line 306
  sleep(1U);
  }
  quit: 
  {
#line 308
  munlockall();
#line 309
  munmap((void *)buf, (size_t )2097152);
  }
#line 310
  return;
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int time_device(int fd ) 
{ 
  char *buf ;
  double elapsed ;
  struct itimerval e1 ;
  struct itimerval e2 ;
  int err ;
  unsigned int max_iterations ;
  unsigned int total_MB ;
  unsigned int iterations ;
  __u64 nsectors ;
  void *tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  __off_t tmp___2 ;
  struct itimerval __constr_expr_1 ;
  int tmp___3 ;

  {
#line 317
  err = 0;
#line 318
  max_iterations = 1024U;
#line 323
  if (do_ctimings) {
#line 323
    goto _L;
  } else
#line 323
  if (do_timings) {
    _L: /* CIL Label */ 
    {
#line 325
    do_flush = 1;
#line 326
    err = get_dev_geometry(fd, (__u32 *)((void *)0), (__u32 *)((void *)0), (__u32 *)((void *)0),
                           (__u64 *)((void *)0), & nsectors);
    }
#line 327
    if (! err) {
#line 328
      max_iterations = (unsigned int )((nsectors / 2048ULL) / 2ULL);
    }
  }
  {
#line 330
  tmp = prepare_timing_buf(2097152U);
#line 330
  buf = (char *)tmp;
  }
#line 331
  if (! buf) {
#line 332
    err = 12;
  }
#line 333
  if (err) {
#line 334
    goto quit;
  }
#line 336
  if (open_flags & 16384) {
#line 336
    tmp___0 = "O_DIRECT";
  } else {
#line 336
    tmp___0 = "buffered";
  }
  {
#line 336
  printf((char const   */* __restrict  */)" Timing %s disk reads", tmp___0);
  }
#line 337
  if (set_timings_offset) {
    {
#line 338
    printf((char const   */* __restrict  */)" (offset %llu GB)", timings_offset / 1073741824ULL);
    }
  }
  {
#line 339
  printf((char const   */* __restrict  */)": ");
#line 340
  fflush(stdout);
  }
#line 342
  if (set_timings_offset) {
    {
#line 342
    tmp___2 = lseek64(fd, (__off_t )timings_offset, 0);
    }
#line 342
    if (tmp___2 == -1L) {
      {
#line 343
      tmp___1 = __errno_location();
#line 343
      err = *tmp___1;
#line 344
      perror("lseek() failed");
      }
#line 345
      goto quit;
    }
  }
  {
#line 352
  __constr_expr_1.it_interval.tv_sec = (__time_t )1000;
#line 352
  __constr_expr_1.it_interval.tv_usec = (__suseconds_t )0;
#line 352
  __constr_expr_1.it_value.tv_sec = (__time_t )1000;
#line 352
  __constr_expr_1.it_value.tv_usec = (__suseconds_t )0;
#line 352
  setitimer((__itimer_which_t )0, (struct itimerval  const  */* __restrict  */)(& __constr_expr_1),
            (struct itimerval */* __restrict  */)((void *)0));
#line 355
  iterations = 0U;
#line 356
  getitimer((__itimer_which_t )0, & e1);
  }
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 358
    iterations ++;
#line 359
    tmp___3 = read_big_block(fd, buf);
    }
#line 359
    if (tmp___3) {
#line 360
      goto quit;
    }
    {
#line 361
    getitimer((__itimer_which_t )0, & e2);
#line 362
    elapsed = (double )(e1.it_value.tv_sec - e2.it_value.tv_sec) + (double )(e1.it_value.tv_usec - e2.it_value.tv_usec) / 1000000.0;
    }
#line 357
    if (elapsed < 3.0) {
#line 357
      if (! (iterations < max_iterations)) {
#line 357
        goto while_break;
      }
    } else {
#line 357
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  total_MB = iterations * 2U;
#line 367
  if ((double )total_MB / elapsed > 1.0) {
    {
#line 368
    printf((char const   */* __restrict  */)"%3u MB in %5.2f seconds = %6.2f MB/sec\n",
           total_MB, elapsed, (double )total_MB / elapsed);
    }
  } else {
    {
#line 371
    printf((char const   */* __restrict  */)"%3u MB in %5.2f seconds = %6.2f kB/sec\n",
           total_MB, elapsed, ((double )total_MB / elapsed) * (double )1024);
    }
  }
  quit: 
  {
#line 374
  munlockall();
  }
#line 375
  if (buf) {
    {
#line 376
    munmap((void *)buf, (size_t )2097152);
    }
  }
#line 377
  return (err);
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void dmpstr(char const   *prefix , unsigned int i , char const   **s , unsigned int maxi ) 
{ 


  {
#line 382
  if (i > maxi) {
    {
#line 383
    printf((char const   */* __restrict  */)"%s%u", prefix, i);
    }
  } else {
    {
#line 385
    printf((char const   */* __restrict  */)"%s%s", prefix, *(s + i));
    }
  }
#line 386
  return;
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static __u16 *id  ;
#line 389
static void get_identify_data(int fd ) ;
#line 391 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static __u64 get_lba_capacity(__u16 *idw ) 
{ 
  __u64 nsects ;

  {
#line 393
  nsects = (__u64 )(((__u32 )*(idw + 58) << 16) | (unsigned int )*(idw + 57));
#line 395
  if ((int )*(idw + 49) & 512) {
#line 396
    nsects = (__u64 )(((__u32 )*(idw + 61) << 16) | (unsigned int )*(idw + 60));
#line 397
    if (((int )*(idw + 83) & 49152) == 16384) {
#line 397
      if ((int )*(idw + 86) & 1024) {
#line 398
        nsects = ((((__u64 )*(idw + 103) << 48) | ((__u64 )*(idw + 102) << 32)) | ((__u64 )*(idw + 101) << 16)) | (unsigned long long )*(idw + 100);
      }
    }
  }
#line 402
  return (nsects);
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static char *strip(char *s ) 
{ 
  char *e ;
  size_t tmp ;

  {
  {
#line 409
  while (1) {
    while_continue: /* CIL Label */ ;
#line 409
    if (! ((int )*s == 32)) {
#line 409
      goto while_break;
    }
#line 409
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  if (*s) {
    {
#line 411
    tmp = strlen((char const   *)s);
#line 411
    e = s + tmp;
    }
    {
#line 411
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 411
      e --;
#line 411
      if (! ((int )*e == 32)) {
#line 411
        goto while_break___0;
      }
#line 411
      *e = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 412
  return (s);
}
}
#line 415 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void dump_identity(__u16 *idw ) 
{ 
  int i ;
  char pmodes[64] ;
  unsigned int tmp ;
  char dmodes[128] ;
  unsigned int tmp___0 ;
  char umodes[128] ;
  unsigned int tmp___1 ;
  char *model ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *fwrev ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *serno ;
  char *tmp___6 ;
  char *tmp___7 ;
  __u8 tPIO ;
  char const   *tmp___8 ;
  __u64 tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  int count ;
  char const   *tmp___14 ;
  int tmp___15 ;

  {
#line 418
  pmodes[0] = (char)0;
#line 418
  tmp = 1U;
  {
#line 418
  while (1) {
    while_continue: /* CIL Label */ ;
#line 418
    if (tmp >= 64U) {
#line 418
      goto while_break;
    }
#line 418
    pmodes[tmp] = (char)0;
#line 418
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 418
  dmodes[0] = (char)0;
#line 418
  tmp___0 = 1U;
  {
#line 418
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 418
    if (tmp___0 >= 128U) {
#line 418
      goto while_break___0;
    }
#line 418
    dmodes[tmp___0] = (char)0;
#line 418
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 418
  umodes[0] = (char)0;
#line 418
  tmp___1 = 1U;
  {
#line 418
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 418
    if (tmp___1 >= 128U) {
#line 418
      goto while_break___1;
    }
#line 418
    umodes[tmp___1] = (char)0;
#line 418
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 419
  tmp___2 = strndup((char const   *)((char *)(idw + 27)), (size_t )40);
#line 419
  tmp___3 = strip(tmp___2);
#line 419
  model = tmp___3;
#line 420
  tmp___4 = strndup((char const   *)((char *)(idw + 23)), (size_t )8);
#line 420
  tmp___5 = strip(tmp___4);
#line 420
  fwrev = tmp___5;
#line 421
  tmp___6 = strndup((char const   *)((char *)(idw + 10)), (size_t )20);
#line 421
  tmp___7 = strip(tmp___6);
#line 421
  serno = tmp___7;
#line 424
  printf((char const   */* __restrict  */)"\n Model=%.40s, FwRev=%.8s, SerialNo=%.20s",
         model, fwrev, serno);
#line 425
  printf((char const   */* __restrict  */)"\n Config={");
#line 426
  i = 0;
  }
  {
#line 426
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 426
    if (! (i <= 15)) {
#line 426
      goto while_break___2;
    }
#line 427
    if ((int )*(idw + 0) & (1 << i)) {
      {
#line 428
      printf((char const   */* __restrict  */)"%s", cfg_str[i]);
      }
    }
#line 426
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 430
  printf((char const   */* __restrict  */)" }\n");
#line 431
  printf((char const   */* __restrict  */)" RawCHS=%u/%u/%u, TrkSize=%u, SectSize=%u, ECCbytes=%u\n",
         (int )*(idw + 1), (int )*(idw + 3), (int )*(idw + 6), (int )*(idw + 4), (int )*(idw + 5),
         (int )*(idw + 22));
#line 433
  dmpstr(" BuffType=", (unsigned int )*(idw + 20), BuffType, 3U);
  }
#line 434
  if (*(idw + 21)) {
#line 434
    if ((int )*(idw + 21) != 65535) {
      {
#line 435
      printf((char const   */* __restrict  */)", BuffSize=%ukB", (int )*(idw + 21) / 2);
      }
    } else {
      {
#line 437
      printf((char const   */* __restrict  */)", BuffSize=unknown");
      }
    }
  } else {
    {
#line 437
    printf((char const   */* __restrict  */)", BuffSize=unknown");
    }
  }
  {
#line 438
  printf((char const   */* __restrict  */)", MaxMultSect=%u", (int )*(idw + 47) & 255);
  }
#line 439
  if ((int )*(idw + 47) & 255) {
    {
#line 440
    printf((char const   */* __restrict  */)", MultSect=");
    }
#line 441
    if (! ((int )*(idw + 59) & 256)) {
      {
#line 442
      printf((char const   */* __restrict  */)"?%u?", (int )*(idw + 59) & 255);
      }
    } else
#line 443
    if ((int )*(idw + 59) & 255) {
      {
#line 444
      printf((char const   */* __restrict  */)"%u", (int )*(idw + 59) & 255);
      }
    } else {
      {
#line 446
      printf((char const   */* __restrict  */)"off");
      }
    }
  }
  {
#line 448
  putchar('\n');
#line 449
  tPIO = (__u8 )((int )*(idw + 51) >> 8);
  }
#line 450
  if ((int )tPIO <= 5) {
    {
#line 451
    strcat((char */* __restrict  */)(pmodes), (char const   */* __restrict  */)"pio0 ");
    }
#line 452
    if ((int )tPIO >= 1) {
      {
#line 452
      strcat((char */* __restrict  */)(pmodes), (char const   */* __restrict  */)"pio1 ");
      }
    }
#line 453
    if ((int )tPIO >= 2) {
      {
#line 453
      strcat((char */* __restrict  */)(pmodes), (char const   */* __restrict  */)"pio2 ");
      }
    }
  }
#line 455
  if (! ((int )*(idw + 53) & 1)) {
    {
#line 456
    printf((char const   */* __restrict  */)" (maybe):");
    }
  }
  {
#line 457
  printf((char const   */* __restrict  */)" CurCHS=%u/%u/%u, CurSects=%u", (int )*(idw + 54),
         (int )*(idw + 55), (int )*(idw + 56), (int )*(idw + 57) | ((int )*(idw + 58) << 16));
  }
#line 458
  if (((int )*(idw + 49) & 512) == 0) {
#line 458
    tmp___8 = "no";
  } else {
#line 458
    tmp___8 = "yes";
  }
  {
#line 458
  printf((char const   */* __restrict  */)", LBA=%s", tmp___8);
  }
#line 459
  if ((int )*(idw + 49) & 512) {
    {
#line 460
    tmp___9 = get_lba_capacity(idw);
#line 460
    printf((char const   */* __restrict  */)", LBAsects=%llu", tmp___9);
    }
  }
#line 462
  if ((int )*(idw + 49) & 256) {
#line 463
    if ((int )*(idw + 62) | (int )*(idw + 63)) {
#line 464
      if ((int )*(idw + 62) & 256) {
        {
#line 464
        strcat((char */* __restrict  */)(dmodes), (char const   */* __restrict  */)"*");
        }
      }
#line 465
      if ((int )*(idw + 62) & 1) {
        {
#line 465
        strcat((char */* __restrict  */)(dmodes), (char const   */* __restrict  */)"sdma0 ");
        }
      }
#line 466
      if ((int )*(idw + 62) & 512) {
        {
#line 466
        strcat((char */* __restrict  */)(dmodes), (char const   */* __restrict  */)"*");
        }
      }
#line 467
      if ((int )*(idw + 62) & 2) {
        {
#line 467
        strcat((char */* __restrict  */)(dmodes), (char const   */* __restrict  */)"sdma1 ");
        }
      }
#line 468
      if ((int )*(idw + 62) & 1024) {
        {
#line 468
        strcat((char */* __restrict  */)(dmodes), (char const   */* __restrict  */)"*");
        }
      }
#line 469
      if ((int )*(idw + 62) & 4) {
        {
#line 469
        strcat((char */* __restrict  */)(dmodes), (char const   */* __restrict  */)"sdma2 ");
        }
      }
#line 470
      if ((int )*(idw + 62) & 63488) {
        {
#line 470
        strcat((char */* __restrict  */)(dmodes), (char const   */* __restrict  */)"*");
        }
      }
#line 471
      if ((int )*(idw + 62) & 248) {
        {
#line 471
        strcat((char */* __restrict  */)(dmodes), (char const   */* __restrict  */)"sdma? ");
        }
      }
#line 472
      if ((int )*(idw + 63) & 256) {
        {
#line 472
        strcat((char */* __restrict  */)(dmodes), (char const   */* __restrict  */)"*");
        }
      }
#line 473
      if ((int )*(idw + 63) & 1) {
        {
#line 473
        strcat((char */* __restrict  */)(dmodes), (char const   */* __restrict  */)"mdma0 ");
        }
      }
#line 474
      if ((int )*(idw + 63) & 512) {
        {
#line 474
        strcat((char */* __restrict  */)(dmodes), (char const   */* __restrict  */)"*");
        }
      }
#line 475
      if ((int )*(idw + 63) & 2) {
        {
#line 475
        strcat((char */* __restrict  */)(dmodes), (char const   */* __restrict  */)"mdma1 ");
        }
      }
#line 476
      if ((int )*(idw + 63) & 1024) {
        {
#line 476
        strcat((char */* __restrict  */)(dmodes), (char const   */* __restrict  */)"*");
        }
      }
#line 477
      if ((int )*(idw + 63) & 4) {
        {
#line 477
        strcat((char */* __restrict  */)(dmodes), (char const   */* __restrict  */)"mdma2 ");
        }
      }
#line 478
      if ((int )*(idw + 63) & 63488) {
        {
#line 478
        strcat((char */* __restrict  */)(dmodes), (char const   */* __restrict  */)"*");
        }
      }
#line 479
      if ((int )*(idw + 63) & 248) {
        {
#line 479
        strcat((char */* __restrict  */)(dmodes), (char const   */* __restrict  */)"mdma? ");
        }
      }
    }
  }
  {
#line 482
  printf((char const   */* __restrict  */)"\n IORDY=");
  }
#line 483
  if ((int )*(idw + 49) & 2048) {
#line 484
    if ((int )*(idw + 49) & 1024) {
#line 484
      tmp___10 = "on/off";
    } else {
#line 484
      tmp___10 = "yes";
    }
    {
#line 484
    printf((char const   */* __restrict  */)tmp___10);
    }
  } else {
    {
#line 486
    printf((char const   */* __restrict  */)"no");
    }
  }
#line 487
  if ((int )*(idw + 49) & 2048) {
#line 487
    goto _L;
  } else
#line 487
  if ((int )*(idw + 53) & 2) {
    _L: /* CIL Label */ 
#line 488
    if ((int )*(idw + 53) & 2) {
      {
#line 489
      printf((char const   */* __restrict  */)", tPIO={min:%u,w/IORDY:%u}", (int )*(idw + 67),
             (int )*(idw + 68));
      }
#line 490
      if ((int )*(idw + 64) & 1) {
        {
#line 490
        strcat((char */* __restrict  */)(pmodes), (char const   */* __restrict  */)"pio3 ");
        }
      }
#line 491
      if ((int )*(idw + 64) & 2) {
        {
#line 491
        strcat((char */* __restrict  */)(pmodes), (char const   */* __restrict  */)"pio4 ");
        }
      }
#line 492
      if ((int )*(idw + 64) & -4) {
        {
#line 492
        strcat((char */* __restrict  */)(pmodes), (char const   */* __restrict  */)"pio? ");
        }
      }
    }
#line 494
    if ((int )*(idw + 53) & 4) {
#line 495
      if ((int )*(idw + 88) & 256) {
        {
#line 495
        strcat((char */* __restrict  */)(umodes), (char const   */* __restrict  */)"*");
        }
      }
#line 496
      if ((int )*(idw + 88) & 1) {
        {
#line 496
        strcat((char */* __restrict  */)(umodes), (char const   */* __restrict  */)"udma0 ");
        }
      }
#line 497
      if ((int )*(idw + 88) & 512) {
        {
#line 497
        strcat((char */* __restrict  */)(umodes), (char const   */* __restrict  */)"*");
        }
      }
#line 498
      if ((int )*(idw + 88) & 2) {
        {
#line 498
        strcat((char */* __restrict  */)(umodes), (char const   */* __restrict  */)"udma1 ");
        }
      }
#line 499
      if ((int )*(idw + 88) & 1024) {
        {
#line 499
        strcat((char */* __restrict  */)(umodes), (char const   */* __restrict  */)"*");
        }
      }
#line 500
      if ((int )*(idw + 88) & 4) {
        {
#line 500
        strcat((char */* __restrict  */)(umodes), (char const   */* __restrict  */)"udma2 ");
        }
      }
#line 501
      if ((int )*(idw + 88) & 2048) {
        {
#line 501
        strcat((char */* __restrict  */)(umodes), (char const   */* __restrict  */)"*");
        }
      }
#line 502
      if ((int )*(idw + 88) & 8) {
        {
#line 502
        strcat((char */* __restrict  */)(umodes), (char const   */* __restrict  */)"udma3 ");
        }
      }
#line 503
      if ((int )*(idw + 88) & 4096) {
        {
#line 503
        strcat((char */* __restrict  */)(umodes), (char const   */* __restrict  */)"*");
        }
      }
#line 504
      if ((int )*(idw + 88) & 16) {
        {
#line 504
        strcat((char */* __restrict  */)(umodes), (char const   */* __restrict  */)"udma4 ");
        }
      }
#line 505
      if ((int )*(idw + 88) & 8192) {
        {
#line 505
        strcat((char */* __restrict  */)(umodes), (char const   */* __restrict  */)"*");
        }
      }
#line 506
      if ((int )*(idw + 88) & 32) {
        {
#line 506
        strcat((char */* __restrict  */)(umodes), (char const   */* __restrict  */)"udma5 ");
        }
      }
#line 507
      if ((int )*(idw + 88) & 16384) {
        {
#line 507
        strcat((char */* __restrict  */)(umodes), (char const   */* __restrict  */)"*");
        }
      }
#line 508
      if ((int )*(idw + 88) & 64) {
        {
#line 508
        strcat((char */* __restrict  */)(umodes), (char const   */* __restrict  */)"udma6 ");
        }
      }
    }
  }
#line 511
  if ((int )*(idw + 49) & 256) {
#line 511
    if ((int )*(idw + 53) & 2) {
      {
#line 512
      printf((char const   */* __restrict  */)", tDMA={min:%u,rec:%u}", (int )*(idw + 65),
             (int )*(idw + 66));
      }
    }
  }
  {
#line 513
  printf((char const   */* __restrict  */)"\n PIO modes:  %s", pmodes);
  }
#line 514
  if (dmodes[0]) {
    {
#line 515
    printf((char const   */* __restrict  */)"\n DMA modes:  %s", dmodes);
    }
  }
#line 516
  if (umodes[0]) {
    {
#line 517
    printf((char const   */* __restrict  */)"\n UDMA modes: %s", umodes);
    }
  }
#line 519
  if (((int )*(idw + 83) & 8) == 0) {
#line 519
    tmp___11 = "no";
  } else {
#line 519
    tmp___11 = "yes";
  }
  {
#line 519
  printf((char const   */* __restrict  */)"\n AdvancedPM=%s", tmp___11);
  }
#line 520
  if ((int )*(idw + 83) & 8) {
#line 521
    if (! ((int )*(idw + 86) & 8)) {
      {
#line 522
      printf((char const   */* __restrict  */)": disabled (255)");
      }
    } else
#line 523
    if (((int )*(idw + 91) & 65280) != 16384) {
      {
#line 524
      printf((char const   */* __restrict  */)": unknown setting");
      }
    } else {
      {
#line 526
      printf((char const   */* __restrict  */)": mode=0x%02X (%u)", (int )*(idw + 91) & 255,
             (int )*(idw + 91) & 255);
      }
    }
  }
#line 528
  if ((int )*(idw + 82) & 32) {
#line 529
    if ((int )*(idw + 85) & 32) {
#line 529
      tmp___12 = "enabled";
    } else {
#line 529
      tmp___12 = "disabled";
    }
    {
#line 529
    printf((char const   */* __restrict  */)" WriteCache=%s", tmp___12);
    }
  }
#line 530
  if (*(idw + 81)) {
#line 530
    goto _L___0;
  } else
#line 530
  if (*(idw + 80)) {
    _L___0: /* CIL Label */ 
    {
#line 531
    printf((char const   */* __restrict  */)"\n Drive conforms to: ");
    }
#line 532
    if ((int )*(idw + 81) <= 31) {
      {
#line 533
      printf((char const   */* __restrict  */)"%s: ", minor_str[*(idw + 81)]);
      }
    } else {
      {
#line 535
      printf((char const   */* __restrict  */)"unknown: ");
      }
    }
#line 536
    if ((int )*(idw + 80) != 0) {
#line 536
      if ((int )*(idw + 80) != 65535) {
#line 538
        count = 0;
#line 539
        i = 0;
        {
#line 539
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 539
          if (! (i <= 7)) {
#line 539
            goto while_break___3;
          }
#line 540
          if ((int )*(idw + 80) & (1 << i)) {
#line 541
            tmp___15 = count;
#line 541
            count ++;
#line 541
            if (tmp___15) {
#line 541
              tmp___14 = ",";
            } else {
#line 541
              tmp___14 = " ATA/ATAPI-";
            }
            {
#line 541
            printf((char const   */* __restrict  */)"%s%u", tmp___14, i);
            }
          }
#line 539
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 545
  printf((char const   */* __restrict  */)"\n");
#line 546
  printf((char const   */* __restrict  */)"\n * signifies the current active mode\n");
#line 547
  printf((char const   */* __restrict  */)"\n");
  }
#line 548
  return;
}
}
#line 552
static char const   *busstate_str(unsigned int value ) ;
#line 552 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static char const   *states[4]  = {      "off",      "on",      "tristate",      "unknown"};
#line 550 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static char const   *busstate_str(unsigned int value ) 
{ 


  {
#line 554
  if (value > 3U) {
#line 555
    value = 3U;
  }
#line 556
  return (states[value]);
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void interpret_standby(void) 
{ 
  unsigned int secs ;
  unsigned int mins ;
  unsigned int mins___0 ;
  unsigned int hrs ;

  {
  {
#line 561
  printf((char const   */* __restrict  */)" (");
  }
  {
#line 563
  if (standby == 0) {
#line 563
    goto case_0;
  }
#line 565
  if (standby == 252) {
#line 565
    goto case_252;
  }
#line 567
  if (standby == 253) {
#line 567
    goto case_253;
  }
#line 569
  if (standby == 254) {
#line 569
    goto case_254;
  }
#line 571
  if (standby == 255) {
#line 571
    goto case_255;
  }
#line 573
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 563
  printf((char const   */* __restrict  */)"off");
  }
#line 564
  goto switch_break;
  case_252: /* CIL Label */ 
  {
#line 565
  printf((char const   */* __restrict  */)"21 minutes");
  }
#line 566
  goto switch_break;
  case_253: /* CIL Label */ 
  {
#line 567
  printf((char const   */* __restrict  */)"vendor-specific");
  }
#line 568
  goto switch_break;
  case_254: /* CIL Label */ 
  {
#line 569
  printf((char const   */* __restrict  */)"?reserved");
  }
#line 570
  goto switch_break;
  case_255: /* CIL Label */ 
  {
#line 571
  printf((char const   */* __restrict  */)"21 minutes + 15 seconds");
  }
#line 572
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 574
  if (standby <= 240) {
#line 575
    secs = (unsigned int )(standby * 5);
#line 576
    mins = secs / 60U;
#line 577
    secs %= 60U;
#line 578
    if (mins) {
      {
#line 578
      printf((char const   */* __restrict  */)"%u minutes", mins);
      }
    }
#line 579
    if (mins) {
#line 579
      if (secs) {
        {
#line 579
        printf((char const   */* __restrict  */)" + ");
        }
      }
    }
#line 580
    if (secs) {
      {
#line 580
      printf((char const   */* __restrict  */)"%u seconds", secs);
      }
    }
  } else
#line 581
  if (standby <= 251) {
#line 582
    mins___0 = (unsigned int )((standby - 240) * 30);
#line 583
    hrs = mins___0 / 60U;
#line 584
    mins___0 %= 60U;
#line 585
    if (hrs) {
      {
#line 585
      printf((char const   */* __restrict  */)"%u hours", hrs);
      }
    }
#line 586
    if (hrs) {
#line 586
      if (mins___0) {
        {
#line 586
        printf((char const   */* __restrict  */)" + ");
        }
      }
    }
#line 587
    if (mins___0) {
      {
#line 587
      printf((char const   */* __restrict  */)"%u minutes", mins___0);
      }
    }
  } else {
    {
#line 589
    printf((char const   */* __restrict  */)"illegal value");
    }
  }
#line 591
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 593
  printf((char const   */* __restrict  */)")\n");
  }
#line 594
  return;
}
}
#line 601 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static struct xfermode_entry  const  xfermode_table[33]  = 
#line 601
  {      {8, "pio0"}, 
        {9, "pio1"}, 
        {10, "pio2"}, 
        {11, "pio3"}, 
        {12, "pio4"}, 
        {13, "pio5"}, 
        {14, "pio6"}, 
        {15, "pio7"}, 
        {16, "sdma0"}, 
        {17, "sdma1"}, 
        {18, "sdma2"}, 
        {19, "sdma3"}, 
        {20, "sdma4"}, 
        {21, "sdma5"}, 
        {22, "sdma6"}, 
        {23, "sdma7"}, 
        {32, "mdma0"}, 
        {33, "mdma1"}, 
        {34, "mdma2"}, 
        {35, "mdma3"}, 
        {36, "mdma4"}, 
        {37, "mdma5"}, 
        {38, "mdma6"}, 
        {39, "mdma7"}, 
        {64, "udma0"}, 
        {65, "udma1"}, 
        {66, "udma2"}, 
        {67, "udma3"}, 
        {68, "udma4"}, 
        {69, "udma5"}, 
        {70, "udma6"}, 
        {71, "udma7"}, 
        {0, (char const   *)((void *)0)}};
#line 637 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int translate_xfermode(char *name ) 
{ 
  struct xfermode_entry  const  *tmp ;
  char *endptr ;
  int val ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 641
  val = -1;
#line 643
  tmp = xfermode_table;
  {
#line 643
  while (1) {
    while_continue: /* CIL Label */ ;
#line 643
    if (! ((unsigned long )tmp->name != (unsigned long )((void *)0))) {
#line 643
      goto while_break;
    }
    {
#line 644
    tmp___0 = strcmp((char const   *)name, (char const   *)tmp->name);
    }
#line 644
    if (! tmp___0) {
#line 645
      return ((int )tmp->val);
    }
#line 643
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 647
  tmp___1 = strtol((char const   */* __restrict  */)name, (char **/* __restrict  */)(& endptr),
                   10);
#line 647
  val = (int )tmp___1;
  }
#line 648
  if ((int )*endptr == 0) {
#line 649
    return (val);
  }
#line 650
  return (-1);
}
}
#line 653 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void interpret_xfermode(unsigned int xfermode ) 
{ 


  {
  {
#line 655
  printf((char const   */* __restrict  */)" (");
  }
  {
#line 657
  if (xfermode == 0U) {
#line 657
    goto case_0;
  }
#line 659
  if (xfermode == 1U) {
#line 659
    goto case_1;
  }
#line 668
  if (xfermode == 15U) {
#line 668
    goto case_15;
  }
#line 668
  if (xfermode == 14U) {
#line 668
    goto case_15;
  }
#line 668
  if (xfermode == 13U) {
#line 668
    goto case_15;
  }
#line 668
  if (xfermode == 12U) {
#line 668
    goto case_15;
  }
#line 668
  if (xfermode == 11U) {
#line 668
    goto case_15;
  }
#line 668
  if (xfermode == 10U) {
#line 668
    goto case_15;
  }
#line 668
  if (xfermode == 9U) {
#line 668
    goto case_15;
  }
#line 668
  if (xfermode == 8U) {
#line 668
    goto case_15;
  }
#line 677
  if (xfermode == 23U) {
#line 677
    goto case_23;
  }
#line 677
  if (xfermode == 22U) {
#line 677
    goto case_23;
  }
#line 677
  if (xfermode == 21U) {
#line 677
    goto case_23;
  }
#line 677
  if (xfermode == 20U) {
#line 677
    goto case_23;
  }
#line 677
  if (xfermode == 19U) {
#line 677
    goto case_23;
  }
#line 677
  if (xfermode == 18U) {
#line 677
    goto case_23;
  }
#line 677
  if (xfermode == 17U) {
#line 677
    goto case_23;
  }
#line 677
  if (xfermode == 16U) {
#line 677
    goto case_23;
  }
#line 686
  if (xfermode == 39U) {
#line 686
    goto case_39;
  }
#line 686
  if (xfermode == 38U) {
#line 686
    goto case_39;
  }
#line 686
  if (xfermode == 37U) {
#line 686
    goto case_39;
  }
#line 686
  if (xfermode == 36U) {
#line 686
    goto case_39;
  }
#line 686
  if (xfermode == 35U) {
#line 686
    goto case_39;
  }
#line 686
  if (xfermode == 34U) {
#line 686
    goto case_39;
  }
#line 686
  if (xfermode == 33U) {
#line 686
    goto case_39;
  }
#line 686
  if (xfermode == 32U) {
#line 686
    goto case_39;
  }
#line 695
  if (xfermode == 71U) {
#line 695
    goto case_71;
  }
#line 695
  if (xfermode == 70U) {
#line 695
    goto case_71;
  }
#line 695
  if (xfermode == 69U) {
#line 695
    goto case_71;
  }
#line 695
  if (xfermode == 68U) {
#line 695
    goto case_71;
  }
#line 695
  if (xfermode == 67U) {
#line 695
    goto case_71;
  }
#line 695
  if (xfermode == 66U) {
#line 695
    goto case_71;
  }
#line 695
  if (xfermode == 65U) {
#line 695
    goto case_71;
  }
#line 695
  if (xfermode == 64U) {
#line 695
    goto case_71;
  }
#line 697
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 657
  printf((char const   */* __restrict  */)"default PIO mode");
  }
#line 658
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 659
  printf((char const   */* __restrict  */)"default PIO mode, disable IORDY");
  }
#line 660
  goto switch_break;
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  {
#line 668
  printf((char const   */* __restrict  */)"PIO flow control mode%u", xfermode - 8U);
  }
#line 669
  goto switch_break;
  case_23: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  {
#line 677
  printf((char const   */* __restrict  */)"singleword DMA mode%u", xfermode - 16U);
  }
#line 678
  goto switch_break;
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_32: /* CIL Label */ 
  {
#line 686
  printf((char const   */* __restrict  */)"multiword DMA mode%u", xfermode - 32U);
  }
#line 687
  goto switch_break;
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_64: /* CIL Label */ 
  {
#line 695
  printf((char const   */* __restrict  */)"UltraDMA mode%u", xfermode - 64U);
  }
#line 696
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 698
  printf((char const   */* __restrict  */)"unknown, probably not valid");
  }
#line 699
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 701
  printf((char const   */* __restrict  */)")\n");
  }
#line 702
  return;
}
}
#line 704 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static unsigned int get_erase_timeout_secs(int fd , int enhanced ) 
{ 
  unsigned int timeout ;
  unsigned int idx ;
  __u64 lba_limit___0 ;
  __u64 tmp ;
  __u64 estimate ;

  {
  {
#line 706
  timeout = 0U;
#line 707
  idx = (unsigned int )(89 + enhanced);
#line 709
  get_identify_data(fd);
  }
#line 710
  if (id) {
#line 711
    timeout = (unsigned int )*(id + idx);
#line 712
    if (timeout) {
#line 712
      if (timeout <= 255U) {
#line 718
        if (timeout == 255U) {
          {
#line 719
          tmp = get_lba_capacity(id);
#line 719
          lba_limit___0 = tmp;
#line 720
          estimate = ((lba_limit___0 / 2048ULL) / 30ULL) / 60ULL;
#line 721
          timeout = 568U;
          }
#line 722
          if ((__u64 )timeout < estimate) {
#line 723
            timeout = (unsigned int )estimate;
          }
        } else {
#line 725
          timeout = timeout * 2U + 30U;
        }
      }
    }
  }
#line 729
  if (! timeout) {
#line 730
    timeout = 120U;
  }
#line 731
  timeout *= 60U;
#line 732
  return (timeout);
}
}
#line 735 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void do_set_security(int fd ) 
{ 
  int err ;
  char const   *description ;
  struct hdio_taskfile *r ;
  __u8 *data ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  __u16 revcode ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  unsigned int timeout ;
  unsigned int tmp___4 ;
  __u8 args___1[4] ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;

  {
  {
#line 738
  err = 0;
#line 743
  tmp = malloc(sizeof(struct hdio_taskfile ) + 512UL);
#line 743
  r = (struct hdio_taskfile *)tmp;
  }
#line 744
  if (! r) {
    {
#line 745
    tmp___0 = __errno_location();
#line 745
    err = *tmp___0;
#line 746
    perror("malloc()");
#line 747
    exit(err);
    }
  }
  {
#line 750
  memset((void *)r, 0, sizeof(struct hdio_taskfile ) + 512UL);
#line 751
  r->cmd_req = 3;
#line 752
  r->dphase = 4;
#line 753
  r->obytes = 512UL;
#line 754
  r->lob.command = (__u8 )security_command;
#line 755
  r->oflags.__annonCompField1.lob.nsect = 1U;
#line 756
  r->lob.nsect = (__u8 )1;
#line 757
  data = (__u8 *)(r->data);
#line 758
  *(data + 0) = (__u8 )(security_master & 1);
#line 759
  memcpy((void */* __restrict  */)(data + 2), (void const   */* __restrict  */)(security_password),
         (size_t )32);
#line 761
  r->oflags.__annonCompField1.lob.command = 1U;
#line 762
  r->oflags.__annonCompField1.lob.feat = 1U;
  }
  {
#line 765
  if (security_command == 244U) {
#line 765
    goto case_244;
  }
#line 769
  if (security_command == 246U) {
#line 769
    goto case_246;
  }
#line 772
  if (security_command == 242U) {
#line 772
    goto case_242;
  }
#line 775
  if (security_command == 241U) {
#line 775
    goto case_241;
  }
#line 792
  goto switch_default;
  case_244: /* CIL Label */ 
#line 766
  description = "SECURITY_ERASE";
#line 767
  if (enhanced_erase) {
#line 767
    tmp___1 = 2;
  } else {
#line 767
    tmp___1 = 0;
  }
#line 767
  *(data + 0) = (__u8 )((int )*(data + 0) | tmp___1);
#line 768
  goto switch_break;
  case_246: /* CIL Label */ 
#line 770
  description = "SECURITY_DISABLE";
#line 771
  goto switch_break;
  case_242: /* CIL Label */ 
#line 773
  description = "SECURITY_UNLOCK";
#line 774
  goto switch_break;
  case_241: /* CIL Label */ 
#line 776
  description = "SECURITY_SET_PASS";
#line 777
  *(data + 1) = (__u8 )(security_mode & 1);
#line 778
  if (security_master) {
    {
#line 781
    get_identify_data(fd);
    }
#line 782
    if (! id) {
      {
#line 783
      exit(5);
      }
    }
#line 784
    revcode = *(id + 92);
#line 785
    if ((int )revcode == 65534) {
#line 786
      revcode = (__u16 )0;
    }
#line 787
    revcode = (__u16 )((int )revcode + 1);
#line 788
    *(data + 34) = (__u8 )revcode;
#line 789
    *(data + 35) = (__u8 )((int )revcode >> 8);
  }
#line 791
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 793
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BUG in do_set_security(), command1=0x%x\n",
          security_command);
#line 794
  exit(22);
  }
  switch_break: /* CIL Label */ ;
  }
#line 796
  if ((int )*(data + 0) & 1) {
#line 796
    tmp___2 = "master";
  } else {
#line 796
    tmp___2 = "user";
  }
  {
#line 796
  printf((char const   */* __restrict  */)" Issuing %s command, password=\"%s\", user=%s",
         description, security_password, tmp___2);
  }
#line 798
  if (security_command == 241U) {
#line 799
    if (*(data + 1)) {
#line 799
      tmp___3 = "max";
    } else {
#line 799
      tmp___3 = "high";
    }
    {
#line 799
    printf((char const   */* __restrict  */)", mode=%s", tmp___3);
    }
  }
  {
#line 800
  printf((char const   */* __restrict  */)"\n");
  }
#line 815
  if (security_command == 244U) {
    {
#line 816
    tmp___4 = get_erase_timeout_secs(fd, enhanced_erase);
#line 816
    timeout = tmp___4;
#line 817
    args___1[0] = (__u8 )243;
#line 817
    args___1[1] = (__u8 )0;
#line 817
    args___1[2] = (__u8 )0;
#line 817
    args___1[3] = (__u8 )0;
#line 818
    tmp___8 = do_drive_cmd(fd, args___1, 0U);
    }
#line 818
    if (tmp___8) {
      {
#line 819
      tmp___5 = __errno_location();
#line 819
      err = *tmp___5;
#line 820
      perror("ERASE_PREPARE");
      }
    } else {
      {
#line 822
      tmp___7 = do_taskfile_cmd(fd, r, timeout);
      }
#line 822
      if (tmp___7) {
        {
#line 823
        tmp___6 = __errno_location();
#line 823
        err = *tmp___6;
#line 824
        perror("SECURITY_ERASE");
        }
      }
    }
  } else
#line 827
  if (security_command == 246U) {
    {
#line 829
    r->lob.command = (__u8 )242;
#line 830
    tmp___12 = do_taskfile_cmd(fd, r, (unsigned int )timeout_15secs);
    }
#line 830
    if (tmp___12) {
      {
#line 831
      tmp___9 = __errno_location();
#line 831
      err = *tmp___9;
#line 832
      perror("SECURITY_UNLOCK");
      }
    } else {
      {
#line 835
      r->lob.command = (__u8 )security_command;
#line 836
      tmp___11 = do_taskfile_cmd(fd, r, (unsigned int )timeout_15secs);
      }
#line 836
      if (tmp___11) {
        {
#line 837
        tmp___10 = __errno_location();
#line 837
        err = *tmp___10;
#line 838
        perror("SECURITY_DISABLE");
        }
      }
    }
  } else
#line 841
  if (security_command == 242U) {
    {
#line 842
    tmp___14 = do_taskfile_cmd(fd, r, (unsigned int )timeout_15secs);
    }
#line 842
    if (tmp___14) {
      {
#line 843
      tmp___13 = __errno_location();
#line 843
      err = *tmp___13;
#line 844
      perror("SECURITY_UNLOCK");
      }
    }
  } else
#line 846
  if (security_command == 241U) {
    {
#line 847
    tmp___16 = do_taskfile_cmd(fd, r, (unsigned int )timeout_15secs);
    }
#line 847
    if (tmp___16) {
      {
#line 848
      tmp___15 = __errno_location();
#line 848
      err = *tmp___15;
#line 849
      perror("SECURITY_SET_PASS");
      }
    }
  } else {
    {
#line 852
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"BUG in do_set_security(), command2=0x%x\n",
            security_command);
#line 853
    err = 22;
    }
  }
  {
#line 855
  free((void *)r);
  }
#line 856
  if (err) {
    {
#line 857
    exit(err);
    }
  }
#line 858
  return;
}
}
#line 860 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static __u8 last_identify_op  =    (__u8 )0;
#line 864 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static __u8 args[516]  ;
#line 862 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void get_identify_data(int fd ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 867
  if (id) {
#line 868
    return;
  }
  {
#line 869
  memset((void *)(args), 0, sizeof(args));
#line 870
  last_identify_op = (__u8 )236;
#line 871
  args[0] = last_identify_op;
#line 872
  args[3] = (__u8 )1;
#line 873
  tmp___0 = do_drive_cmd(fd, args, 0U);
  }
#line 873
  if (tmp___0) {
    {
#line 874
    prefer_ata12 = 0;
#line 875
    memset((void *)(args), 0, sizeof(args));
#line 876
    last_identify_op = (__u8 )161;
#line 877
    args[0] = last_identify_op;
#line 878
    args[3] = (__u8 )1;
#line 879
    tmp = do_drive_cmd(fd, args, 0U);
    }
#line 879
    if (tmp) {
      {
#line 880
      perror(" HDIO_DRIVE_CMD(identify) failed");
      }
#line 881
      return;
    }
  }
#line 885
  id = (__u16 *)((void *)(args + 4));
#line 886
  i = 0;
  {
#line 886
  while (1) {
    while_continue: /* CIL Label */ ;
#line 886
    if (! (i < 256)) {
#line 886
      goto while_break;
    }
    {
#line 887
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 887
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 886
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 888
  return;
}
}
#line 890 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_id_log_page_data(int fd , __u8 pagenr , __u8 *buf ) 
{ 
  struct hdio_taskfile *r ;
  int err ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 893
  err = 0;
#line 895
  tmp = malloc(sizeof(struct hdio_taskfile ) + 512UL);
#line 895
  r = (struct hdio_taskfile *)tmp;
  }
#line 896
  if (! r) {
    {
#line 897
    tmp___0 = __errno_location();
#line 897
    err = *tmp___0;
#line 898
    perror("malloc()");
    }
#line 899
    return (err);
  }
  {
#line 902
  init_hdio_taskfile(r, (__u8 )47, 0, 1, (__u64 )(48 + ((int )pagenr << 8)), 1U, 512);
#line 903
  tmp___2 = do_taskfile_cmd(fd, r, (unsigned int )timeout_15secs);
  }
#line 903
  if (tmp___2) {
    {
#line 904
    tmp___1 = __errno_location();
#line 904
    err = *tmp___1;
    }
  } else {
    {
#line 906
    memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(r->data),
           (size_t )512);
    }
  }
  {
#line 908
  free((void *)r);
  }
#line 909
  return (err);
}
}
#line 912 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void confirm_i_know_what_i_am_doing(char const   *opt , char const   *explanation ) 
{ 


  {
#line 914
  if (! i_know_what_i_am_doing) {
    {
#line 915
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Use of %s is VERY DANGEROUS.\n%s\nPlease supply the --yes-i-know-what-i-am-doing flag if you really want this.\nProgram aborted.\n",
            opt, explanation);
#line 918
    exit(1);
    }
  }
#line 920
  return;
}
}
#line 922 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void confirm_please_destroy_my_drive(char const   *opt , char const   *explanation ) 
{ 


  {
#line 924
  if (! please_destroy_my_drive) {
    {
#line 925
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Use of %s is EXTREMELY DANGEROUS.\n%s\nPlease also supply the --please-destroy-my-drive flag if you really want this.\nProgram aborted.\n",
            opt, explanation);
#line 928
    exit(1);
    }
  }
#line 930
  return;
}
}
#line 932 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int flush_wcache(int fd ) 
{ 
  __u8 args___1[4] ;
  int err ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 934
  args___1[0] = (__u8 )231;
#line 934
  args___1[1] = (__u8 )0;
#line 934
  args___1[2] = (__u8 )0;
#line 934
  args___1[3] = (__u8 )0;
#line 935
  err = 0;
#line 937
  get_identify_data(fd);
  }
#line 938
  if (id) {
#line 938
    if (((int )*(id + 83) & 57344) == 24576) {
#line 939
      args___1[0] = (__u8 )234;
    }
  }
  {
#line 940
  tmp___0 = do_drive_cmd(fd, args___1, (unsigned int )timeout_60secs);
  }
#line 940
  if (tmp___0) {
    {
#line 941
    tmp = __errno_location();
#line 941
    err = *tmp;
#line 942
    perror(" HDIO_DRIVE_CMD(flushcache) failed");
    }
  }
#line 944
  return (err);
}
}
#line 947 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void dump_sectors(__u16 *w , unsigned int count ) 
{ 
  unsigned int i ;
  int word ;
  int tmp ;

  {
#line 951
  i = 0U;
  {
#line 951
  while (1) {
    while_continue: /* CIL Label */ ;
#line 951
    if (! (i < (count * 256U) / 8U)) {
#line 951
      goto while_break;
    }
#line 958
    word = 0;
    {
#line 958
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 958
      if (! (word < 8)) {
#line 958
        goto while_break___0;
      }
      {
#line 959
      printf((char const   */* __restrict  */)"%04x", (int )*(w + 0));
#line 960
      w ++;
      }
#line 961
      if (word == 7) {
#line 961
        tmp = '\n';
      } else {
#line 961
        tmp = ' ';
      }
      {
#line 961
      putchar(tmp);
#line 958
      word ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 951
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 965
  return;
}
}
#line 967 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int abort_if_not_full_device(int fd , __u64 lba , char const   *devname , char const   *msg ) 
{ 
  __u64 start_lba ;
  int i ;
  int err ;
  int shortened ;
  char *fdevname ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 970
  shortened = 0;
#line 971
  tmp = strdup(devname);
#line 971
  fdevname = tmp;
#line 973
  err = get_dev_geometry(fd, (__u32 *)((void *)0), (__u32 *)((void *)0), (__u32 *)((void *)0),
                         & start_lba, (__u64 *)((void *)0));
  }
#line 974
  if (err) {
    {
#line 975
    exit(err);
    }
  }
  {
#line 976
  tmp___0 = strlen((char const   *)fdevname);
#line 976
  i = (int )tmp___0;
  }
  {
#line 976
  while (1) {
    while_continue: /* CIL Label */ ;
#line 976
    i --;
#line 976
    if (i > 2) {
#line 976
      if ((int )*(fdevname + i) >= 48) {
#line 976
        if (! ((int )*(fdevname + i) <= 57)) {
#line 976
          goto while_break;
        }
      } else {
#line 976
        goto while_break;
      }
    } else {
#line 976
      goto while_break;
    }
#line 977
    *(fdevname + i) = (char )'\000';
#line 978
    shortened = 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 981
  if (! shortened) {
    {
#line 982
    fdevname = strdup("the full disk");
    }
  }
#line 984
  if (start_lba == 0ULL) {
#line 985
    return (0);
  }
#line 986
  if (start_lba == 0xffffffffffffffffULL) {
    {
#line 987
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s is a RAID device: please specify an absolute LBA of a raw member device instead (raid1 only)\n",
            devname);
    }
  } else {
    {
#line 986
    tmp___1 = fd_is_raid(fd);
    }
#line 986
    if (tmp___1) {
      {
#line 987
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s is a RAID device: please specify an absolute LBA of a raw member device instead (raid1 only)\n",
              devname);
      }
    } else
#line 988
    if (msg) {
      {
#line 989
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              msg);
      }
    } else {
      {
#line 991
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Device %s has non-zero LBA starting offset of %llu.\n",
              devname, start_lba);
#line 992
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please use an absolute LBA with the /dev/ entry for the raw device, rather than a partition or raid name.\n");
#line 993
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s is probably a partition of %s (?)\n",
              devname, fdevname);
#line 994
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The absolute LBA of sector %llu from %s should be %llu\n",
              lba, devname, start_lba + lba);
      }
    }
  }
  {
#line 996
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Aborting.\n");
#line 997
  exit(22);
  }
}
}
#line 1002 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static __u8 args___0[516]  ;
#line 1000 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static __u16 *get_dco_identify_data(int fd , int quietly ) 
{ 
  __u16 *dco ;
  int i ;
  int tmp ;

  {
  {
#line 1003
  dco = (__u16 *)((void *)(args___0 + 4));
#line 1006
  memset((void *)(args___0), 0, sizeof(args___0));
#line 1007
  args___0[0] = (__u8 )177;
#line 1008
  args___0[2] = (__u8 )194;
#line 1009
  args___0[3] = (__u8 )1;
#line 1010
  tmp = do_drive_cmd(fd, args___0, 0U);
  }
#line 1010
  if (tmp) {
#line 1011
    if (! quietly) {
      {
#line 1012
      perror(" HDIO_DRIVE_CMD(dco_identify) failed");
      }
    }
#line 1013
    return ((__u16 *)((void *)0));
  } else {
#line 1016
    i = 0;
    {
#line 1016
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1016
      if (! (i < 256)) {
#line 1016
        goto while_break;
      }
      {
#line 1017
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1017
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1016
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1019
    return (dco);
  }
}
}
#line 1023 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static __u64 do_get_native_max_sectors(int fd ) 
{ 
  int err ;
  __u64 max ;
  struct hdio_taskfile r ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 1025
  err = 0;
#line 1026
  max = (__u64 )0;
#line 1029
  get_identify_data(fd);
  }
#line 1030
  if (! id) {
    {
#line 1031
    exit(5);
    }
  }
  {
#line 1032
  memset((void *)(& r), 0, sizeof(r));
#line 1033
  r.cmd_req = 0;
#line 1034
  r.dphase = 0;
#line 1035
  r.oflags.__annonCompField1.lob.dev = 1U;
#line 1036
  r.oflags.__annonCompField1.lob.command = 1U;
#line 1037
  r.iflags.__annonCompField1.lob.command = 1U;
#line 1038
  r.iflags.__annonCompField1.lob.lbal = 1U;
#line 1039
  r.iflags.__annonCompField1.lob.lbam = 1U;
#line 1040
  r.iflags.__annonCompField1.lob.lbah = 1U;
#line 1041
  r.lob.dev = (__u8 )64;
  }
#line 1043
  if (((int )*(id + 83) & 50176) == 17408) {
#line 1043
    if ((int )*(id + 86) & 1024) {
      {
#line 1044
      r.iflags.__annonCompField2.hob.lbal = 1U;
#line 1045
      r.iflags.__annonCompField2.hob.lbam = 1U;
#line 1046
      r.iflags.__annonCompField2.hob.lbah = 1U;
#line 1047
      r.lob.command = (__u8 )39;
#line 1048
      tmp___0 = do_taskfile_cmd(fd, & r, 10U);
      }
#line 1048
      if (tmp___0) {
        {
#line 1049
        tmp = __errno_location();
#line 1049
        err = *tmp;
#line 1050
        perror(" READ_NATIVE_MAX_ADDRESS_EXT failed");
        }
      } else {
#line 1052
        if (verbose) {
          {
#line 1053
          printf((char const   */* __restrict  */)"READ_NATIVE_MAX_ADDRESS_EXT response: hob={%02x %02x %02x} lob={%02x %02x %02x}\n",
                 (int )r.hob.lbah, (int )r.hob.lbam, (int )r.hob.lbal, (int )r.lob.lbah,
                 (int )r.lob.lbam, (int )r.lob.lbal);
          }
        }
#line 1055
        max = (((__u64 )((((int )r.hob.lbah << 16) | ((int )r.hob.lbam << 8)) | (int )r.hob.lbal) << 24) | (unsigned long long )((((int )r.lob.lbah << 16) | ((int )r.lob.lbam << 8)) | (int )r.lob.lbal)) + 1ULL;
      }
    } else {
#line 1043
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1059
    r.iflags.__annonCompField1.lob.dev = 1U;
#line 1060
    r.lob.command = (__u8 )248;
#line 1061
    tmp___2 = do_taskfile_cmd(fd, & r, 0U);
    }
#line 1061
    if (tmp___2) {
      {
#line 1062
      tmp___1 = __errno_location();
#line 1062
      err = *tmp___1;
#line 1063
      perror(" READ_NATIVE_MAX_ADDRESS failed");
      }
    } else {
#line 1065
      max = (__u64 )(((((((int )r.lob.dev & 15) << 24) | ((int )r.lob.lbah << 16)) | ((int )r.lob.lbam << 8)) | (int )r.lob.lbal) + 1);
    }
  }
  {
#line 1068
  tmp___3 = __errno_location();
#line 1068
  *tmp___3 = err;
  }
#line 1069
  return (max);
}
}
#line 1072 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int do_make_bad_sector(int fd , __u64 lba , char const   *devname ) 
{ 
  int err ;
  int has_write_unc ;
  struct hdio_taskfile *r ;
  char const   *flagged ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1074
  err = 0;
#line 1074
  has_write_unc = 0;
#line 1078
  abort_if_not_full_device(fd, lba, devname, (char const   *)((void *)0));
#line 1079
  tmp = malloc(sizeof(struct hdio_taskfile ) + 520UL);
#line 1079
  r = (struct hdio_taskfile *)tmp;
  }
#line 1080
  if (! r) {
    {
#line 1081
    tmp___0 = __errno_location();
#line 1081
    err = *tmp___0;
#line 1082
    perror("malloc()");
    }
#line 1083
    return (err);
  }
  {
#line 1086
  get_identify_data(fd);
  }
#line 1087
  if (id) {
#line 1088
    if (((int )*(id + 83) & 49152) == 16384) {
#line 1088
      if (((int )*(id + 86) & 32768) == 32768) {
#line 1088
        if (((int )*(id + 119) & 49156) == 16388) {
#line 1088
          if (((int )*(id + 120) & 49152) == 16384) {
#line 1088
            tmp___1 = 1;
          } else {
#line 1088
            tmp___1 = 0;
          }
        } else {
#line 1088
          tmp___1 = 0;
        }
      } else {
#line 1088
        tmp___1 = 0;
      }
    } else {
#line 1088
      tmp___1 = 0;
    }
#line 1088
    has_write_unc = tmp___1;
  }
#line 1091
  if (has_write_unc) {
#line 1091
    goto _L;
  } else
#line 1091
  if (make_bad_sector_flagged) {
#line 1091
    goto _L;
  } else
#line 1091
  if (lba >= (__u64 )(1 << 28) - 1ULL) {
    _L: /* CIL Label */ 
#line 1092
    if (! has_write_unc) {
      {
#line 1093
      printf((char const   */* __restrict  */)"Device does not claim to implement the required WRITE_UNC_EXT command\nThis operation will probably fail (continuing regardless).\n");
      }
    }
    {
#line 1096
    init_hdio_taskfile(r, (__u8 )69, 0, 1, lba, 1U, 0);
#line 1097
    r->oflags.__annonCompField1.lob.feat = 1U;
    }
#line 1098
    if (make_bad_sector_flagged) {
#line 1098
      r->lob.feat = (__u8 )170;
    } else {
#line 1098
      r->lob.feat = (__u8 )85;
    }
#line 1099
    if (make_bad_sector_flagged) {
#line 1099
      flagged = "flagged";
    } else {
#line 1099
      flagged = "pseudo";
    }
    {
#line 1100
    printf((char const   */* __restrict  */)"Corrupting sector %llu (WRITE_UNC_EXT as %s): ",
           lba, flagged);
    }
  } else {
    {
#line 1102
    init_hdio_taskfile(r, (__u8 )51, 1, 0, lba, 1U, 520);
#line 1103
    memset((void *)(r->data), 165, (size_t )520);
#line 1104
    printf((char const   */* __restrict  */)"Corrupting sector %llu (WRITE_LONG): ",
           lba);
    }
  }
  {
#line 1106
  fflush(stdout);
#line 1109
  flush_buffer_cache(fd);
#line 1111
  tmp___3 = do_taskfile_cmd(fd, r, (unsigned int )timeout_60secs);
  }
#line 1111
  if (tmp___3) {
    {
#line 1112
    tmp___2 = __errno_location();
#line 1112
    err = *tmp___2;
#line 1113
    perror("FAILED");
    }
  } else {
    {
#line 1115
    printf((char const   */* __restrict  */)"succeeded\n");
    }
  }
  {
#line 1117
  free((void *)r);
  }
#line 1118
  return (err);
}
}
#line 1187 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int trim_sectors(int fd , char const   *devname , int nranges , void *data ,
                        __u64 nsectors ) 
{ 
  struct ata_tf tf ;
  int err ;
  unsigned int data_bytes ;
  unsigned int data_sects ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 1190
  err = 0;
#line 1191
  data_bytes = (unsigned int )((unsigned long )nranges * sizeof(__u64 ));
#line 1192
  data_sects = (data_bytes + 511U) / 512U;
#line 1194
  data_bytes = data_sects * 512U;
#line 1196
  abort_if_not_full_device(fd, (__u64 )0, devname, (char const   *)((void *)0));
#line 1197
  printf((char const   */* __restrict  */)"trimming %llu sectors from %d ranges\n",
         nsectors, nranges);
#line 1198
  fflush(stdout);
#line 1201
  flush_buffer_cache(fd);
#line 1203
  tf_init(& tf, (__u8 )6, (__u64 )0, data_sects);
#line 1204
  tf.lob.feat = (__u8 )1;
#line 1206
  tmp___0 = sg16(fd, 1, 1, & tf, data, data_bytes, 300U);
  }
#line 1206
  if (tmp___0) {
    {
#line 1207
    tmp = __errno_location();
#line 1207
    err = *tmp;
#line 1208
    perror("FAILED");
    }
  } else {
    {
#line 1210
    printf((char const   */* __restrict  */)"succeeded\n");
    }
  }
#line 1212
  return (err);
}
}
#line 1215 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void do_trim_sector_ranges(int fd , char const   *devname , int nranges , struct sector_range_s *sr ) 
{ 
  __u64 range ;
  __u64 *data ;
  __u64 nsectors ;
  unsigned int data_sects ;
  unsigned int data_bytes ;
  int i ;
  int err ;
  void *tmp ;
  int *tmp___0 ;

  {
  {
#line 1217
  nsectors = (__u64 )0;
#line 1219
  err = 0;
#line 1221
  abort_if_not_full_device(fd, (__u64 )0, devname, (char const   *)((void *)0));
#line 1223
  data_sects = (unsigned int )(((unsigned long )nranges * sizeof(range) + 511UL) / 512UL);
#line 1224
  data_bytes = data_sects * 512U;
#line 1226
  tmp = mmap((void *)0, (size_t )data_bytes, 3, 33, -1, (__off_t )0);
#line 1226
  data = (__u64 *)tmp;
  }
#line 1227
  if ((unsigned long )data == (unsigned long )((void *)-1)) {
    {
#line 1228
    tmp___0 = __errno_location();
#line 1228
    err = *tmp___0;
#line 1229
    perror("mmap(MAP_ANONYMOUS)");
#line 1230
    exit(err);
    }
  }
#line 1233
  i = 0;
  {
#line 1233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1233
    if (! (i < nranges)) {
#line 1233
      goto while_break;
    }
#line 1234
    nsectors += sr->nsectors;
#line 1235
    range = sr->nsectors;
#line 1236
    range = (range << 48) | sr->lba;
#line 1237
    *(data + i) = range;
#line 1238
    sr ++;
#line 1233
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1241
  err = trim_sectors(fd, devname, nranges, (void *)data, nsectors);
#line 1242
  munmap((void *)data, (size_t )data_bytes);
#line 1243
  exit(err);
  }
}
}
#line 1246 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void extract_id_string(__u16 *idw , int words , char *dst ) 
{ 
  char *e ;
  int i ;
  int max ;
  __u16 w ;
  __u16 tmp ;

  {
#line 1250
  max = words * 2;
#line 1252
  i = 0;
  {
#line 1252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1252
    if (! (i < words)) {
#line 1252
      goto while_break;
    }
    {
#line 1253
    w = *(idw + i);
#line 1254
    tmp = __fswab16(w);
#line 1254
    w = (__u16 )((int )tmp);
#line 1255
    *(dst + i * 2) = (char )((int )w >> 8);
#line 1256
    *(dst + (i * 2 + 1)) = (char )w;
#line 1252
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1258
  *(dst + max) = (char )'\000';
#line 1259
  e = dst + max;
  {
#line 1259
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1259
    e --;
#line 1259
    if (! ((unsigned long )e != (unsigned long )dst)) {
#line 1259
      goto while_break___0;
    }
#line 1260
    if (*e) {
#line 1260
      if ((int )*e != 32) {
#line 1261
        goto while_break___0;
      }
    }
#line 1262
    *e = (char )'\000';
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1264
  return;
}
}
#line 1266 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_trim_dev_limit(void) 
{ 
  char model[41] ;
  int tmp ;
  int tmp___0 ;

  {
#line 1271
  if (*(id + 105)) {
#line 1271
    if ((int )*(id + 105) != 65535) {
#line 1272
      return ((int )*(id + 105));
    }
  }
  {
#line 1273
  extract_id_string(id + 27, 20, model);
#line 1274
  tmp = strcmp((char const   *)(model), "OCZ VERTEX-LE");
  }
#line 1274
  if (0 == tmp) {
#line 1275
    return (8);
  }
  {
#line 1276
  tmp___0 = strcmp((char const   *)(model), "OCZ-VERTEX");
  }
#line 1276
  if (0 == tmp___0) {
#line 1277
    return (64);
  }
#line 1278
  return (1);
}
}
#line 1281 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int do_trim_from_stdin(int fd , char const   *devname ) 
{ 
  __u64 *data ;
  __u64 range ;
  __u64 nsectors ;
  __u64 lba_limit___0 ;
  unsigned int max_kb ;
  unsigned int data_sects ;
  unsigned int data_bytes ;
  unsigned int total_ranges ;
  unsigned int nranges ;
  unsigned int max_ranges ;
  unsigned int dev_limit ;
  int err ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  __u64 lba ;
  __u64 nsect ;
  int args___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  unsigned int tmp___6 ;

  {
  {
#line 1284
  nsectors = (__u64 )0;
#line 1286
  total_ranges = 0U;
#line 1286
  nranges = 0U;
#line 1287
  err = 0;
#line 1289
  get_identify_data(fd);
  }
#line 1290
  if (! id) {
    {
#line 1291
    exit(5);
    }
  }
  {
#line 1292
  lba_limit___0 = get_lba_capacity(id);
#line 1293
  tmp = get_trim_dev_limit();
#line 1293
  dev_limit = (unsigned int )tmp;
#line 1295
  err = sysfs_get_attr(fd, "queue/max_sectors_kb", "%u", (void *)(& max_kb), (void *)0,
                       0);
  }
#line 1296
  if (err) {
#line 1297
    data_sects = 128U;
  } else
#line 1296
  if (max_kb == 0U) {
#line 1297
    data_sects = 128U;
  } else {
#line 1299
    data_sects = max_kb * 2U;
  }
#line 1300
  if (data_sects > dev_limit) {
#line 1301
    data_sects = dev_limit;
  }
  {
#line 1302
  data_bytes = data_sects * 512U;
#line 1304
  tmp___0 = mmap((void *)0, (size_t )data_bytes, 3, 33, -1, (__off_t )0);
#line 1304
  data = (__u64 *)tmp___0;
  }
#line 1305
  if ((unsigned long )data == (unsigned long )((void *)-1)) {
    {
#line 1306
    tmp___1 = __errno_location();
#line 1306
    err = *tmp___1;
#line 1307
    perror("mmap(MAP_ANONYMOUS)");
#line 1308
    exit(err);
    }
  }
  {
#line 1310
  memset((void *)data, 0, (size_t )data_bytes);
#line 1311
  max_ranges = (unsigned int )((unsigned long )data_bytes / sizeof(range));
  }
  {
#line 1313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1317
    if (nranges == 0U) {
      {
#line 1318
      memset((void *)data, 0, (size_t )data_bytes);
      }
    }
    {
#line 1319
    tmp___2 = __errno_location();
#line 1319
    *tmp___2 = 22;
#line 1320
    args___1 = scanf((char const   */* __restrict  */)"%llu:%llu", & lba, & nsect);
    }
#line 1321
    if (args___1 == -1) {
#line 1322
      goto while_break;
    }
#line 1323
    if (args___1 != 2) {
#line 1323
      goto _L;
    } else
#line 1323
    if (nsect > 65535ULL) {
#line 1323
      goto _L;
    } else
#line 1323
    if (lba >= lba_limit___0) {
      _L: /* CIL Label */ 
#line 1324
      if (args___1 == 2) {
        {
#line 1325
        tmp___3 = __errno_location();
#line 1325
        *tmp___3 = 34;
        }
      }
      {
#line 1326
      tmp___4 = __errno_location();
#line 1326
      err = *tmp___4;
#line 1327
      tmp___5 = strerror(err);
#line 1327
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"stdin: error at lba:count pair #%d: %s\n",
              total_ranges + 1U, tmp___5);
      }
    } else {
#line 1329
      range = (nsect << 48) | lba;
#line 1330
      nsectors += nsect;
#line 1331
      tmp___6 = nranges;
#line 1331
      nranges ++;
#line 1331
      *(data + tmp___6) = range;
#line 1332
      if (nranges == max_ranges) {
        {
#line 1333
        err = trim_sectors(fd, devname, (int )nranges, (void *)data, nsectors);
#line 1334
        memset((void *)data, 0, (size_t )data_bytes);
#line 1335
        nranges = 0U;
#line 1336
        nsectors = (__u64 )0;
        }
      }
#line 1338
      total_ranges ++;
    }
#line 1313
    if (! (! err)) {
#line 1313
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1341
  if (! err) {
#line 1341
    if (nranges) {
      {
#line 1342
      err = trim_sectors(fd, devname, (int )nranges, (void *)data, nsectors);
      }
    }
  }
  {
#line 1343
  munmap((void *)data, (size_t )data_bytes);
  }
#line 1344
  return (err);
}
}
#line 1347 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int do_write_sector(int fd , __u64 lba , char const   *devname ) 
{ 
  int err ;
  __u8 ata_op ;
  struct hdio_taskfile *r ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1349
  err = 0;
#line 1353
  abort_if_not_full_device(fd, lba, devname, (char const   *)((void *)0));
#line 1354
  tmp = malloc(sizeof(struct hdio_taskfile ) + 512UL);
#line 1354
  r = (struct hdio_taskfile *)tmp;
  }
#line 1355
  if (! r) {
    {
#line 1356
    tmp___0 = __errno_location();
#line 1356
    err = *tmp___0;
#line 1357
    perror("malloc()");
    }
#line 1358
    return (err);
  }
#line 1360
  if (lba >= (__u64 )(1 << 28) - 1ULL) {
#line 1360
    ata_op = (__u8 )52;
  } else {
#line 1360
    ata_op = (__u8 )48;
  }
  {
#line 1361
  init_hdio_taskfile(r, ata_op, 1, 0, lba, 1U, 512);
#line 1363
  printf((char const   */* __restrict  */)"re-writing sector %llu: ", lba);
#line 1364
  fflush(stdout);
#line 1367
  flush_buffer_cache(fd);
#line 1369
  tmp___2 = do_taskfile_cmd(fd, r, (unsigned int )timeout_60secs);
  }
#line 1369
  if (tmp___2) {
    {
#line 1370
    tmp___1 = __errno_location();
#line 1370
    err = *tmp___1;
#line 1371
    perror("FAILED");
    }
  } else {
    {
#line 1373
    printf((char const   */* __restrict  */)"succeeded\n");
    }
  }
  {
#line 1376
  free((void *)r);
  }
#line 1377
  return (err);
}
}
#line 1380 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int do_read_sector(int fd , __u64 lba , char const   *devname ) 
{ 
  int err ;
  __u8 ata_op ;
  struct hdio_taskfile *r ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1382
  err = 0;
#line 1386
  abort_if_not_full_device(fd, lba, devname, (char const   *)((void *)0));
#line 1387
  tmp = malloc(sizeof(struct hdio_taskfile ) + 512UL);
#line 1387
  r = (struct hdio_taskfile *)tmp;
  }
#line 1388
  if (! r) {
    {
#line 1389
    tmp___0 = __errno_location();
#line 1389
    err = *tmp___0;
#line 1390
    perror("malloc()");
    }
#line 1391
    return (err);
  }
#line 1393
  if (lba >= (__u64 )(1 << 28) - 1ULL) {
#line 1393
    ata_op = (__u8 )36;
  } else {
#line 1393
    ata_op = (__u8 )32;
  }
  {
#line 1394
  init_hdio_taskfile(r, ata_op, 0, 0, lba, 1U, 512);
#line 1396
  printf((char const   */* __restrict  */)"reading sector %llu: ", lba);
#line 1397
  fflush(stdout);
#line 1399
  tmp___2 = do_taskfile_cmd(fd, r, (unsigned int )timeout_60secs);
  }
#line 1399
  if (tmp___2) {
    {
#line 1400
    tmp___1 = __errno_location();
#line 1400
    err = *tmp___1;
#line 1401
    perror("FAILED");
    }
  } else {
    {
#line 1403
    printf((char const   */* __restrict  */)"succeeded\n");
#line 1404
    dump_sectors(r->data, 1U);
    }
  }
  {
#line 1406
  free((void *)r);
  }
#line 1407
  return (err);
}
}
#line 1410 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int do_idleunload(int fd , char const   *devname ) 
{ 
  int err ;
  struct hdio_taskfile r ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 1412
  err = 0;
#line 1415
  abort_if_not_full_device(fd, (__u64 )0, devname, (char const   *)((void *)0));
#line 1416
  init_hdio_taskfile(& r, (__u8 )225, 0, 0, (__u64 )5590604, 0U, 0);
#line 1417
  r.oflags.__annonCompField1.lob.feat = 1U;
#line 1418
  r.lob.feat = (__u8 )68;
#line 1420
  tmp___0 = do_taskfile_cmd(fd, & r, 0U);
  }
#line 1420
  if (tmp___0) {
    {
#line 1421
    tmp = __errno_location();
#line 1421
    err = *tmp;
#line 1422
    perror("TASKFILE(idle_immediate_unload) failed");
    }
  }
#line 1424
  return (err);
}
}
#line 1427 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int do_set_max_sectors(int fd , __u64 max_lba , int permanent ) 
{ 
  int err ;
  struct hdio_taskfile r ;
  __u8 nsect ;
  int tmp ;
  int *tmp___0 ;
  __u64 tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 1429
  err = 0;
#line 1431
  if (permanent) {
#line 1431
    tmp = 1;
  } else {
#line 1431
    tmp = 0;
  }
  {
#line 1431
  nsect = (__u8 )tmp;
#line 1433
  get_identify_data(fd);
  }
#line 1434
  if (! id) {
    {
#line 1435
    exit(5);
    }
  }
#line 1436
  if (max_lba >= (__u64 )(1 << 28) - 1ULL) {
    {
#line 1437
    init_hdio_taskfile(& r, (__u8 )55, 0, 1, max_lba, (unsigned int )nsect, 0);
    }
  } else
#line 1436
  if (id) {
#line 1436
    if (((int )*(id + 83) & 50176) == 17408) {
#line 1436
      if ((int )*(id + 86) & 1024) {
        {
#line 1437
        init_hdio_taskfile(& r, (__u8 )55, 0, 1, max_lba, (unsigned int )nsect, 0);
        }
      } else {
        {
#line 1439
        init_hdio_taskfile(& r, (__u8 )249, 0, 0, max_lba, (unsigned int )nsect, 0);
#line 1440
        r.oflags.__annonCompField1.lob.feat = 1U;
        }
      }
    } else {
      {
#line 1439
      init_hdio_taskfile(& r, (__u8 )249, 0, 0, max_lba, (unsigned int )nsect, 0);
#line 1440
      r.oflags.__annonCompField1.lob.feat = 1U;
      }
    }
  } else {
    {
#line 1439
    init_hdio_taskfile(& r, (__u8 )249, 0, 0, max_lba, (unsigned int )nsect, 0);
#line 1440
    r.oflags.__annonCompField1.lob.feat = 1U;
    }
  }
  {
#line 1444
  tmp___1 = do_get_native_max_sectors(fd);
  }
#line 1444
  if (! tmp___1) {
    {
#line 1445
    tmp___0 = __errno_location();
    }
#line 1445
    return (*tmp___0);
  }
  {
#line 1448
  tmp___3 = do_taskfile_cmd(fd, & r, 0U);
  }
#line 1448
  if (tmp___3) {
    {
#line 1449
    tmp___2 = __errno_location();
#line 1449
    err = *tmp___2;
#line 1450
    perror(" SET_MAX_ADDRESS failed");
    }
  }
#line 1452
  return (err);
}
}
#line 1455 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void usage_help(int clue , int rc ) 
{ 
  FILE *desc ;
  struct _IO_FILE *tmp ;

  {
#line 1457
  if (rc) {
#line 1457
    tmp = stderr;
  } else {
#line 1457
    tmp = stdout;
  }
  {
#line 1457
  desc = tmp;
#line 1459
  fprintf((FILE */* __restrict  */)desc, (char const   */* __restrict  */)"\n%s - get/set hard disk parameters - version v9.43, by Mark Lord.\n\n",
          progname);
#line 1461
  fprintf((FILE */* __restrict  */)desc, (char const   */* __restrict  */)"Usage:  %s  [options] [device ...]\n\n",
          progname);
#line 1462
  fprintf((FILE */* __restrict  */)desc, (char const   */* __restrict  */)"Options:\n -a   Get/set fs readahead\n -A   Get/set the drive look-ahead flag (0/1)\n -b   Get/set bus state (0 == off, 1 == on, 2 == tristate)\n -B   Set Advanced Power Management setting (1-255)\n -c   Get/set IDE 32-bit IO setting\n -C   Check drive power mode status\n -d   Get/set using_dma flag\n -D   Enable/disable drive defect management\n -E   Set cd/dvd drive speed\n -f   Flush buffer cache for device on exit\n -F   Flush drive write cache\n -g   Display drive geometry\n -h   Display terse usage information\n -H   Read temperature from drive (Hitachi only)\n -i   Display drive identification\n -I   Detailed/current information directly from drive\n -J   Get/set Western DIgital \"Idle3\" timeout for a WDC \"Green\" drive (DANGEROUS)\n -k   Get/set keep_settings_over_reset flag (0/1)\n -K   Set drive keep_features_over_reset flag (0/1)\n -L   Set drive doorlock (0/1) (removable harddisks only)\n -m   Get/set multiple sector count\n -M   Get/set acoustic management (0-254, 128: quiet, 254: fast)\n -n   Get/set ignore-write-errors flag (0/1)\n -N   Get/set max visible number of sectors (HPA) (VERY DANGEROUS)\n -p   Set PIO mode on IDE interface chipset (0,1,2,3,4,...)\n -P   Set drive prefetch count\n -q   Change next setting quietly\n -Q   Get/set DMA queue_depth (if supported)\n -r   Get/set device readonly flag (DANGEROUS to set)\n -R   Get/set device write-read-verify flag\n -s   Set power-up in standby flag (0/1) (DANGEROUS)\n -S   Set standby (spindown) timeout\n -t   Perform device read timings\n -T   Perform cache read timings\n -u   Get/set unmaskirq flag (0/1)\n -U   Obsolete\n -v   Use defaults; same as -acdgkmur for IDE drives\n -V   Display program version and exit immediately\n -w   Perform device reset (DANGEROUS)\n -W   Get/set drive write-caching flag (0/1)\n -x   Obsolete\n -X   Set IDE xfer mode (DANGEROUS)\n -y   Put drive in standby mode\n -Y   Put drive to sleep\n -z   Re-read partition table\n -Z   Disable Seagate auto-powersaving mode\n --dco-freeze      Freeze/lock current device configuration until next power cycle\n --dco-identify    Read/dump device configuration identify data\n --dco-restore     Reset device configuration back to factory defaults\n --direct          Use O_DIRECT to bypass page cache for timings\n --drq-hsm-error   Crash system with a \"stuck DRQ\" error (VERY DANGEROUS)\n --fallocate       Create a file without writing data to disk\n --fibmap          Show device extents (and fragmentation) for a file\n --fwdownload            Download firmware file to drive (EXTREMELY DANGEROUS)\n --fwdownload-mode3      Download firmware using min-size segments (EXTREMELY DANGEROUS)\n --fwdownload-mode3-max  Download firmware using max-size segments (EXTREMELY DANGEROUS)\n --fwdownload-mode7      Download firmware using a single segment (EXTREMELY DANGEROUS)\n --idle-immediate  Idle drive immediately\n --idle-unload     Idle immediately and unload heads\n --Istdin          Read identify data from stdin as ASCII hex\n --Istdout         Write identify data to stdout as ASCII hex\n --make-bad-sector Deliberately corrupt a sector directly on the media (VERY DANGEROUS)\n --offset          use with -t, to begin timings at given offset (in GiB) from start of drive\n --prefer-ata12    Use 12-byte (instead of 16-byte) SAT commands when possible\n --read-sector     Read and dump (in hex) a sector directly from the media\n --security-help   Display help for ATA security commands\n --trim-sector-ranges        Tell SSD firmware to discard unneeded data sectors: lba:count ..\n --trim-sector-ranges-stdin  Same as above, but reads lba:count pairs from stdin\n --verbose         Display extra diagnostics from some commands\n --write-sector    Repair/overwrite a (possibly bad) sector directly on the media (VERY DANGEROUS)\n\n");
#line 1534
  exit(rc);
  }
}
}
#line 1537 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void security_help(int rc ) 
{ 
  FILE *desc ;
  struct _IO_FILE *tmp ;

  {
#line 1539
  if (rc) {
#line 1539
    tmp = stderr;
  } else {
#line 1539
    tmp = stdout;
  }
  {
#line 1539
  desc = tmp;
#line 1541
  fprintf((FILE */* __restrict  */)desc, (char const   */* __restrict  */)"\nATA Security Commands:\n Most of these are VERY DANGEROUS and can destroy all of your data!\n Due to bugs in older Linux kernels, use of these commands may even\n trigger kernel segfaults or worse.  EXPERIMENT AT YOUR OWN RISK!\n\n --security-freeze           Freeze security settings until reset.\n\n --security-set-pass PASSWD  Lock drive, using password PASSWD:\n                                  Use \'NULL\' to set empty password.\n                                  Drive gets locked if user-passwd is selected.\n --security-unlock   PASSWD  Unlock drive.\n --security-disable  PASSWD  Disable drive locking.\n --security-erase    PASSWD  Erase a (locked) drive.\n --security-erase-enhanced PASSWD   Enhanced-erase a (locked) drive.\n\n The above four commands may optionally be preceded by these options:\n --security-mode  LEVEL      Use LEVEL to select security level:\n                                  h   high security (default).\n                                  m   maximum security.\n --user-master    WHICH      Use WHICH to choose password type:\n                                  u   user-password (default).\n                                  m   master-password\n");
#line 1565
  exit(rc);
  }
}
}
#line 1572 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static long parm  ;
#line 1572 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static long multcount  ;
#line 1568 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
void process_dev(char *devname ) 
{ 
  int fd ;
  int err ;
  int *tmp ;
  int tmp___0 ;
  unsigned char timeout ;
  unsigned char tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  __u8 args___1[4] ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;
  int tmp___21 ;
  __u8 args___2[4] ;
  int *tmp___22 ;
  int tmp___23 ;
  __u8 args___3[4] ;
  int *tmp___24 ;
  int tmp___25 ;
  __u8 args___4[4] ;
  int *tmp___26 ;
  int tmp___27 ;
  __u8 args___5[4] ;
  int *tmp___28 ;
  int tmp___29 ;
  __u8 args___6[4] ;
  int *tmp___30 ;
  int tmp___31 ;
  __u8 args___7[4] ;
  int *tmp___32 ;
  int tmp___33 ;
  __u8 args___8[4] ;
  __u8 args1[4] ;
  int *tmp___34 ;
  int tmp___35 ;
  __u8 args___9[4] ;
  int *tmp___36 ;
  int tmp___37 ;
  int err1 ;
  int err2 ;
  int *tmp___38 ;
  __u8 args___10[4] ;
  int *tmp___39 ;
  int tmp___40 ;
  __u8 args___11[4] ;
  int *tmp___41 ;
  int tmp___42 ;
  __u8 setcache[4] ;
  int *tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  __u8 args___12[4] ;
  int *tmp___46 ;
  int tmp___47 ;
  __u16 *dco ;
  __u16 *tmp___48 ;
  __u8 args___13[4] ;
  int *tmp___49 ;
  int tmp___50 ;
  __u8 args___14[4] ;
  int *tmp___51 ;
  int tmp___52 ;
  __u8 args___15[4] ;
  int *tmp___53 ;
  int tmp___54 ;
  __u8 args___16[4] ;
  int *tmp___55 ;
  int tmp___56 ;
  char const   *tmp___57 ;
  int *tmp___58 ;
  int tmp___59 ;
  char const   *tmp___60 ;
  __u64 tmp___61 ;
  __u8 args___17[4] ;
  int *tmp___62 ;
  __u8 args___18[4] ;
  int *tmp___63 ;
  char const   *tmp___64 ;
  int tmp___65 ;
  int *tmp___66 ;
  int *tmp___67 ;
  int tmp___68 ;
  int *tmp___69 ;
  int tmp___70 ;
  int *tmp___71 ;
  int tmp___72 ;
  int *tmp___73 ;
  int tmp___74 ;
  int *tmp___75 ;
  int tmp___76 ;
  int *tmp___77 ;
  int tmp___78 ;
  int *tmp___79 ;
  int tmp___80 ;
  int *tmp___81 ;
  int tmp___82 ;
  __u32 cyls ;
  __u32 heads ;
  __u32 sects ;
  __u64 start_lba ;
  __u64 nsectors ;
  unsigned char timeout___0 ;
  __u8 args___19[4] ;
  char const   *state ;
  int *tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  __u16 id2[256] ;
  int *tmp___86 ;
  int *tmp___87 ;
  int tmp___88 ;
  __u8 buf[512] ;
  int deto ;
  int mdat ;
  int tmp___89 ;
  char const   *tmp___90 ;
  int tmp___91 ;
  char const   *tmp___92 ;
  int tmp___93 ;
  int supported ;
  int supported___0 ;
  int supported___1 ;
  int supported___2 ;
  int *tmp___94 ;
  char const   *tmp___95 ;
  int tmp___96 ;
  __u64 visible ;
  __u64 native ;
  int *tmp___97 ;
  __u16 *dco___0 ;
  __u16 *tmp___98 ;
  __u64 dco_max ;
  int *tmp___99 ;
  int tmp___100 ;
  __u8 args___20[4] ;
  int *tmp___101 ;
  int tmp___102 ;
  __u8 args1___0[4] ;
  __u8 args2[4] ;
  int *tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  __u8 args1___1[4] ;
  __u8 args2___0[4] ;
  int *tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int *tmp___109 ;
  int tmp___110 ;

  {
  {
#line 1571
  err = 0;
#line 1574
  id = (__u16 *)((void *)0);
#line 1575
  fd = open((char const   *)devname, open_flags);
  }
#line 1576
  if (fd < 0) {
    {
#line 1577
    tmp = __errno_location();
#line 1577
    err = *tmp;
#line 1578
    perror((char const   *)devname);
#line 1579
    exit(err);
    }
  }
#line 1581
  if (! quiet) {
    {
#line 1582
    printf((char const   */* __restrict  */)"\n%s:\n", devname);
    }
  }
#line 1584
  if (trim_from_stdin) {
#line 1585
    if (num_flags_processed > 1) {
      {
#line 1586
      usage_help(12, 22);
      }
    } else
#line 1585
    if (argc) {
      {
#line 1586
      usage_help(12, 22);
      }
    }
    {
#line 1587
    confirm_please_destroy_my_drive("--trim-sector-ranges-stdin", "This might destroy the drive and/or all data on it.");
#line 1588
    tmp___0 = do_trim_from_stdin(fd, (char const   *)devname);
#line 1588
    exit(tmp___0);
    }
  }
#line 1591
  if (set_wdidle3) {
    {
#line 1592
    tmp___1 = wdidle3_msecs_to_timeout((unsigned int )wdidle3);
#line 1592
    timeout = tmp___1;
#line 1593
    confirm_please_destroy_my_drive("-J", "This implementation is not as thorough as the official WDIDLE3.EXE. Use at your own risk!");
    }
#line 1594
    if (get_wdidle3) {
      {
#line 1595
      printf((char const   */* __restrict  */)" setting wdidle3 to ");
#line 1596
      wdidle3_print_timeout(timeout);
#line 1597
      putchar('\n');
      }
    }
    {
#line 1599
    err = wdidle3_set_timeout(fd, timeout);
    }
  }
#line 1601
  if (set_fsreadahead) {
#line 1602
    if (get_fsreadahead) {
      {
#line 1603
      printf((char const   */* __restrict  */)" setting fs readahead to %d\n", fsreadahead);
      }
    }
    {
#line 1604
    tmp___3 = ioctl(fd, (unsigned long )((unsigned int )(18 << 8) | 98U), fsreadahead);
    }
#line 1604
    if (tmp___3) {
      {
#line 1605
      tmp___2 = __errno_location();
#line 1605
      err = *tmp___2;
#line 1606
      perror(" BLKRASET failed");
      }
    }
  }
#line 1609
  if (set_piomode) {
#line 1610
    if (get_piomode) {
#line 1611
      if (piomode == 255) {
        {
#line 1612
        printf((char const   */* __restrict  */)" attempting to auto-tune PIO mode\n");
        }
      } else
#line 1613
      if (piomode < 100) {
        {
#line 1614
        printf((char const   */* __restrict  */)" attempting to set PIO mode to %d\n",
               piomode);
        }
      } else
#line 1615
      if (piomode < 200) {
        {
#line 1616
        printf((char const   */* __restrict  */)" attempting to set MDMA mode to %d\n",
               piomode - 100);
        }
      } else {
        {
#line 1618
        printf((char const   */* __restrict  */)" attempting to set UDMA mode to %d\n",
               piomode - 200);
        }
      }
    }
    {
#line 1620
    tmp___5 = ioctl(fd, 807UL, piomode);
    }
#line 1620
    if (tmp___5) {
      {
#line 1621
      tmp___4 = __errno_location();
#line 1621
      err = *tmp___4;
#line 1622
      perror(" HDIO_SET_PIO_MODE failed");
      }
    }
  }
#line 1625
  if (set_io32bit) {
#line 1626
    if (get_io32bit) {
      {
#line 1627
      printf((char const   */* __restrict  */)" setting 32-bit IO_support flag to %d\n",
             io32bit);
      }
    }
    {
#line 1628
    tmp___7 = ioctl(fd, 804UL, io32bit);
    }
#line 1628
    if (tmp___7) {
      {
#line 1629
      tmp___6 = __errno_location();
#line 1629
      err = *tmp___6;
#line 1630
      perror(" HDIO_SET_32BIT failed");
      }
    }
  }
#line 1633
  if (set_mult) {
#line 1634
    if (get_mult) {
      {
#line 1635
      printf((char const   */* __restrict  */)" setting multcount to %d\n", mult);
      }
    }
    {
#line 1636
    tmp___11 = ioctl(fd, 801UL, mult);
    }
#line 1636
    if (tmp___11) {
      {
#line 1641
      tmp___10 = __errno_location();
      }
#line 1641
      if (*tmp___10 != 25) {
        {
#line 1642
        perror(" HDIO_SET_MULTCOUNT failed");
        }
      } else {
        {
#line 1644
        args___1[0] = (__u8 )198;
#line 1644
        args___1[1] = (__u8 )mult;
#line 1644
        args___1[2] = (__u8 )0;
#line 1644
        args___1[3] = (__u8 )0;
#line 1645
        confirm_i_know_what_i_am_doing("-m", "Only the old IDE drivers work correctly with -m with kernels up to at least 2.6.29.\nlibata drives may fail and get hung if you set this flag.");
#line 1646
        tmp___9 = do_drive_cmd(fd, args___1, 0U);
        }
#line 1646
        if (tmp___9) {
          {
#line 1647
          tmp___8 = __errno_location();
#line 1647
          err = *tmp___8;
#line 1648
          perror(" HDIO_DRIVE_CMD(set_multi_count) failed");
          }
        }
      }
    }
  }
#line 1654
  if (set_readonly) {
#line 1655
    if (get_readonly) {
      {
#line 1656
      printf((char const   */* __restrict  */)" setting readonly to %d", readonly);
#line 1657
      on_off((unsigned int )readonly);
      }
    }
    {
#line 1659
    tmp___13 = ioctl(fd, (unsigned long )((unsigned int )(18 << 8) | 93U), & readonly);
    }
#line 1659
    if (tmp___13) {
      {
#line 1660
      tmp___12 = __errno_location();
#line 1660
      err = *tmp___12;
#line 1661
      perror(" BLKROSET failed");
      }
    }
  }
#line 1664
  if (set_unmask) {
#line 1665
    if (get_unmask) {
      {
#line 1666
      printf((char const   */* __restrict  */)" setting unmaskirq to %d", unmask);
#line 1667
      on_off((unsigned int )unmask);
      }
    }
    {
#line 1669
    tmp___15 = ioctl(fd, 802UL, unmask);
    }
#line 1669
    if (tmp___15) {
      {
#line 1670
      tmp___14 = __errno_location();
#line 1670
      err = *tmp___14;
#line 1671
      perror(" HDIO_SET_UNMASKINTR failed");
      }
    }
  }
#line 1674
  if (set_dma) {
#line 1675
    if (get_dma) {
      {
#line 1676
      printf((char const   */* __restrict  */)" setting using_dma to %d", dma);
#line 1677
      on_off((unsigned int )dma);
      }
    }
    {
#line 1679
    tmp___17 = ioctl(fd, 806UL, dma);
    }
#line 1679
    if (tmp___17) {
      {
#line 1680
      tmp___16 = __errno_location();
#line 1680
      err = *tmp___16;
#line 1681
      perror(" HDIO_SET_DMA failed");
      }
    }
  }
#line 1684
  if (set_dma_q) {
#line 1685
    if (get_dma_q) {
      {
#line 1686
      printf((char const   */* __restrict  */)" setting queue_depth to %d\n", dma_q);
      }
    }
    {
#line 1687
    err = sysfs_set_attr(fd, "device/queue_depth", "%u", (void *)(& dma_q), 1);
    }
  }
#line 1689
  if (set_nowerr) {
#line 1690
    if (get_nowerr) {
      {
#line 1691
      printf((char const   */* __restrict  */)" setting nowerr to %d", nowerr);
#line 1692
      on_off((unsigned int )nowerr);
      }
    }
    {
#line 1694
    tmp___19 = ioctl(fd, 805UL, nowerr);
    }
#line 1694
    if (tmp___19) {
      {
#line 1695
      tmp___18 = __errno_location();
#line 1695
      err = *tmp___18;
#line 1696
      perror(" HDIO_SET_NOWERR failed");
      }
    }
  }
#line 1699
  if (set_keep) {
#line 1700
    if (get_keep) {
      {
#line 1701
      printf((char const   */* __restrict  */)" setting keep_settings to %d", keep);
#line 1702
      on_off((unsigned int )keep);
      }
    }
    {
#line 1704
    tmp___21 = ioctl(fd, 803UL, keep);
    }
#line 1704
    if (tmp___21) {
      {
#line 1705
      tmp___20 = __errno_location();
#line 1705
      err = *tmp___20;
#line 1706
      perror(" HDIO_SET_KEEPSETTINGS failed");
      }
    }
  }
#line 1709
  if (set_doorlock) {
#line 1710
    args___2[0] = (__u8 )0;
#line 1710
    args___2[1] = (__u8 )0;
#line 1710
    args___2[2] = (__u8 )0;
#line 1710
    args___2[3] = (__u8 )0;
#line 1711
    if (doorlock) {
#line 1711
      args___2[0] = (__u8 )222;
    } else {
#line 1711
      args___2[0] = (__u8 )223;
    }
#line 1712
    if (get_doorlock) {
      {
#line 1713
      printf((char const   */* __restrict  */)" setting drive doorlock to %d", doorlock);
#line 1714
      on_off((unsigned int )doorlock);
      }
    }
    {
#line 1716
    tmp___23 = do_drive_cmd(fd, args___2, (unsigned int )timeout_15secs);
    }
#line 1716
    if (tmp___23) {
      {
#line 1717
      tmp___22 = __errno_location();
#line 1717
      err = *tmp___22;
#line 1718
      perror(" HDIO_DRIVE_CMD(doorlock) failed");
      }
    }
  }
#line 1721
  if (set_dkeep) {
#line 1723
    args___3[0] = (__u8 )239;
#line 1723
    args___3[1] = (__u8 )0;
#line 1723
    args___3[2] = (__u8 )0;
#line 1723
    args___3[3] = (__u8 )0;
#line 1724
    if (get_dkeep) {
      {
#line 1725
      printf((char const   */* __restrict  */)" setting drive keep features to %d",
             dkeep);
#line 1726
      on_off((unsigned int )dkeep);
      }
    }
#line 1728
    if (dkeep) {
#line 1728
      args___3[2] = (__u8 )102;
    } else {
#line 1728
      args___3[2] = (__u8 )204;
    }
    {
#line 1729
    tmp___25 = do_drive_cmd(fd, args___3, 0U);
    }
#line 1729
    if (tmp___25) {
      {
#line 1730
      tmp___24 = __errno_location();
#line 1730
      err = *tmp___24;
#line 1731
      perror(" HDIO_DRIVE_CMD(keepsettings) failed");
      }
    }
  }
#line 1734
  if (set_defects) {
#line 1735
    args___4[0] = (__u8 )239;
#line 1735
    args___4[1] = (__u8 )0;
#line 1735
    args___4[2] = (__u8 )0;
#line 1735
    args___4[3] = (__u8 )0;
#line 1736
    if (defects) {
#line 1736
      args___4[2] = (__u8 )4;
    } else {
#line 1736
      args___4[2] = (__u8 )132;
    }
#line 1737
    if (get_defects) {
      {
#line 1738
      printf((char const   */* __restrict  */)" setting drive defect management to %d\n",
             defects);
      }
    }
    {
#line 1739
    tmp___27 = do_drive_cmd(fd, args___4, 0U);
    }
#line 1739
    if (tmp___27) {
      {
#line 1740
      tmp___26 = __errno_location();
#line 1740
      err = *tmp___26;
#line 1741
      perror(" HDIO_DRIVE_CMD(defectmgmt) failed");
      }
    }
  }
#line 1744
  if (set_prefetch) {
#line 1745
    args___5[0] = (__u8 )239;
#line 1745
    args___5[1] = (__u8 )0;
#line 1745
    args___5[2] = (__u8 )171;
#line 1745
    args___5[3] = (__u8 )0;
#line 1746
    args___5[1] = (__u8 )prefetch;
#line 1747
    if (get_prefetch) {
      {
#line 1748
      printf((char const   */* __restrict  */)" setting drive prefetch to %d\n", prefetch);
      }
    }
    {
#line 1749
    tmp___29 = do_drive_cmd(fd, args___5, 0U);
    }
#line 1749
    if (tmp___29) {
      {
#line 1750
      tmp___28 = __errno_location();
#line 1750
      err = *tmp___28;
#line 1751
      perror(" HDIO_DRIVE_CMD(setprefetch) failed");
      }
    }
  }
#line 1754
  if (set_xfermode) {
#line 1755
    args___6[0] = (__u8 )239;
#line 1755
    args___6[1] = (__u8 )0;
#line 1755
    args___6[2] = (__u8 )3;
#line 1755
    args___6[3] = (__u8 )0;
#line 1756
    args___6[1] = (__u8 )xfermode_requested;
#line 1757
    if (get_xfermode) {
      {
#line 1758
      printf((char const   */* __restrict  */)" setting xfermode to %d", xfermode_requested);
#line 1759
      interpret_xfermode((unsigned int )xfermode_requested);
      }
    }
    {
#line 1761
    tmp___31 = do_drive_cmd(fd, args___6, 0U);
    }
#line 1761
    if (tmp___31) {
      {
#line 1762
      tmp___30 = __errno_location();
#line 1762
      err = *tmp___30;
#line 1763
      perror(" HDIO_DRIVE_CMD(setxfermode) failed");
      }
    }
  }
#line 1766
  if (set_lookahead) {
#line 1767
    args___7[0] = (__u8 )239;
#line 1767
    args___7[1] = (__u8 )0;
#line 1767
    args___7[2] = (__u8 )0;
#line 1767
    args___7[3] = (__u8 )0;
#line 1768
    if (lookahead) {
#line 1768
      args___7[2] = (__u8 )170;
    } else {
#line 1768
      args___7[2] = (__u8 )85;
    }
#line 1769
    if (get_lookahead) {
      {
#line 1770
      printf((char const   */* __restrict  */)" setting drive read-lookahead to %d",
             lookahead);
#line 1771
      on_off((unsigned int )lookahead);
      }
    }
    {
#line 1773
    tmp___33 = do_drive_cmd(fd, args___7, 0U);
    }
#line 1773
    if (tmp___33) {
      {
#line 1774
      tmp___32 = __errno_location();
#line 1774
      err = *tmp___32;
#line 1775
      perror(" HDIO_DRIVE_CMD(setreadahead) failed");
      }
    }
  }
#line 1778
  if (set_powerup_in_standby) {
#line 1779
    args___8[0] = (__u8 )239;
#line 1779
    args___8[1] = (__u8 )0;
#line 1779
    args___8[2] = (__u8 )0;
#line 1779
    args___8[3] = (__u8 )0;
#line 1780
    if (powerup_in_standby == 0) {
      {
#line 1781
      args1[0] = (__u8 )239;
#line 1781
      args1[1] = (__u8 )0;
#line 1781
      args1[2] = (__u8 )7;
#line 1781
      args1[3] = (__u8 )0;
#line 1782
      printf((char const   */* __restrict  */)" spin-up:");
#line 1783
      fflush(stdout);
#line 1784
      do_drive_cmd(fd, args1, 0U);
      }
    } else {
      {
#line 1786
      confirm_i_know_what_i_am_doing("-s1", "This requires BIOS and kernel support to recognize/boot the drive.");
      }
    }
#line 1789
    if (get_powerup_in_standby) {
      {
#line 1790
      printf((char const   */* __restrict  */)" setting power-up in standby to %d",
             powerup_in_standby);
#line 1791
      fflush(stdout);
#line 1792
      on_off((unsigned int )powerup_in_standby);
      }
    }
#line 1794
    args___8[0] = (__u8 )239;
#line 1795
    if (powerup_in_standby) {
#line 1795
      args___8[2] = (__u8 )6;
    } else {
#line 1795
      args___8[2] = (__u8 )134;
    }
    {
#line 1796
    tmp___35 = do_drive_cmd(fd, args___8, 0U);
    }
#line 1796
    if (tmp___35) {
      {
#line 1797
      tmp___34 = __errno_location();
#line 1797
      err = *tmp___34;
#line 1798
      perror(" HDIO_DRIVE_CMD(powerup_in_standby) failed");
      }
    }
  }
#line 1801
  if (set_apmmode) {
#line 1802
    args___9[0] = (__u8 )239;
#line 1802
    args___9[1] = (__u8 )0;
#line 1802
    args___9[2] = (__u8 )0;
#line 1802
    args___9[3] = (__u8 )0;
#line 1803
    if (get_apmmode) {
      {
#line 1804
      printf((char const   */* __restrict  */)" setting Advanced Power Management level to");
      }
    }
#line 1805
    if (apmmode == 255) {
#line 1807
      args___9[2] = (__u8 )133;
#line 1808
      if (get_apmmode) {
        {
#line 1808
        printf((char const   */* __restrict  */)" disabled\n");
        }
      }
    } else {
#line 1811
      args___9[2] = (__u8 )5;
#line 1812
      args___9[1] = (__u8 )apmmode;
#line 1813
      if (get_apmmode) {
        {
#line 1814
        printf((char const   */* __restrict  */)" 0x%02x (%d)\n", apmmode, apmmode);
        }
      }
    }
    {
#line 1816
    tmp___37 = do_drive_cmd(fd, args___9, 0U);
    }
#line 1816
    if (tmp___37) {
      {
#line 1817
      tmp___36 = __errno_location();
#line 1817
      err = *tmp___36;
#line 1818
      perror(" HDIO_DRIVE_CMD failed");
      }
    }
  }
#line 1821
  if (set_cdromspeed) {
#line 1828
    if (get_cdromspeed) {
      {
#line 1829
      printf((char const   */* __restrict  */)"setting cd/dvd speed to %d\n", cdromspeed);
      }
    }
    {
#line 1830
    err1 = set_dvdspeed(fd, cdromspeed);
#line 1831
    err2 = ioctl(fd, 21282UL, cdromspeed);
    }
#line 1832
    if (err1) {
#line 1832
      if (err2) {
        {
#line 1833
        tmp___38 = __errno_location();
#line 1833
        err = *tmp___38;
#line 1834
        perror(" SET_STREAMING/CDROM_SELECT_SPEED both failed");
        }
      }
    }
  }
#line 1837
  if (set_acoustic) {
#line 1839
    if (get_acoustic) {
      {
#line 1840
      printf((char const   */* __restrict  */)" setting acoustic management to %d\n",
             acoustic);
      }
    }
#line 1841
    args___10[0] = (__u8 )239;
#line 1842
    args___10[1] = (__u8 )acoustic;
#line 1843
    if (acoustic) {
#line 1843
      args___10[2] = (__u8 )66;
    } else {
#line 1843
      args___10[2] = (__u8 )194;
    }
    {
#line 1844
    args___10[3] = (__u8 )0;
#line 1845
    tmp___40 = do_drive_cmd(fd, args___10, 0U);
    }
#line 1845
    if (tmp___40) {
      {
#line 1846
      tmp___39 = __errno_location();
#line 1846
      err = *tmp___39;
#line 1847
      perror(" HDIO_DRIVE_CMD:ACOUSTIC failed");
      }
    }
  }
#line 1850
  if (set_write_read_verify) {
#line 1852
    if (get_write_read_verify) {
      {
#line 1853
      printf((char const   */* __restrict  */)" setting write-read-verify to %d\n",
             write_read_verify);
      }
    }
#line 1854
    args___11[0] = (__u8 )239;
#line 1855
    args___11[1] = (__u8 )write_read_verify;
#line 1856
    if (write_read_verify) {
#line 1856
      args___11[2] = (__u8 )11;
    } else {
#line 1856
      args___11[2] = (__u8 )139;
    }
    {
#line 1857
    args___11[3] = (__u8 )0;
#line 1858
    tmp___42 = do_drive_cmd(fd, args___11, 0U);
    }
#line 1858
    if (tmp___42) {
      {
#line 1859
      tmp___41 = __errno_location();
#line 1859
      err = *tmp___41;
#line 1860
      perror(" HDIO_DRIVE_CMD:WRV failed");
      }
    }
  }
#line 1863
  if (set_wcache) {
#line 1864
    if (get_wcache) {
      {
#line 1865
      printf((char const   */* __restrict  */)" setting drive write-caching to %d",
             wcache);
#line 1866
      on_off((unsigned int )wcache);
      }
    }
#line 1868
    if (! wcache) {
      {
#line 1869
      err = flush_wcache(fd);
      }
    }
    {
#line 1870
    tmp___45 = ioctl(fd, 811UL, wcache);
    }
#line 1870
    if (tmp___45) {
#line 1871
      setcache[0] = (__u8 )239;
#line 1871
      setcache[1] = (__u8 )0;
#line 1871
      setcache[2] = (__u8 )0;
#line 1871
      setcache[3] = (__u8 )0;
#line 1872
      if (wcache) {
#line 1872
        setcache[2] = (__u8 )2;
      } else {
#line 1872
        setcache[2] = (__u8 )130;
      }
      {
#line 1873
      tmp___44 = do_drive_cmd(fd, setcache, 0U);
      }
#line 1873
      if (tmp___44) {
        {
#line 1874
        tmp___43 = __errno_location();
#line 1874
        err = *tmp___43;
#line 1875
        perror(" HDIO_DRIVE_CMD(setcache) failed");
        }
      }
    }
#line 1878
    if (! wcache) {
      {
#line 1879
      err = flush_wcache(fd);
      }
    }
  }
#line 1881
  if (set_standby) {
#line 1882
    args___12[0] = (__u8 )227;
#line 1882
    args___12[1] = (__u8 )standby;
#line 1882
    args___12[2] = (__u8 )0;
#line 1882
    args___12[3] = (__u8 )0;
#line 1883
    if (get_standby) {
      {
#line 1884
      printf((char const   */* __restrict  */)" setting standby to %u", standby);
#line 1885
      interpret_standby();
      }
    }
    {
#line 1887
    tmp___47 = do_drive_cmd(fd, args___12, 0U);
    }
#line 1887
    if (tmp___47) {
      {
#line 1888
      tmp___46 = __errno_location();
#line 1888
      err = *tmp___46;
#line 1889
      perror(" HDIO_DRIVE_CMD(setidle) failed");
      }
    }
  }
#line 1892
  if (set_security) {
    {
#line 1893
    do_set_security(fd);
    }
  }
#line 1895
  if (do_dco_identify) {
    {
#line 1896
    tmp___48 = get_dco_identify_data(fd, 0);
#line 1896
    dco = tmp___48;
    }
#line 1897
    if (dco) {
      {
#line 1898
      dco_identify_print(dco);
      }
    }
  }
#line 1900
  if (do_dco_restore) {
    {
#line 1901
    args___13[0] = (__u8 )177;
#line 1901
    args___13[1] = (__u8 )0;
#line 1901
    args___13[2] = (__u8 )192;
#line 1901
    args___13[3] = (__u8 )0;
#line 1902
    confirm_i_know_what_i_am_doing("--dco-restore", "You are trying to deliberately reset your drive configuration back to the factory defaults.\nThis may change the apparent capacity and feature set of the drive, making all data on it inaccessible.\nYou could lose *everything*.");
#line 1903
    printf((char const   */* __restrict  */)" issuing DCO restore command\n");
#line 1904
    tmp___50 = do_drive_cmd(fd, args___13, 0U);
    }
#line 1904
    if (tmp___50) {
      {
#line 1905
      tmp___49 = __errno_location();
#line 1905
      err = *tmp___49;
#line 1906
      perror(" HDIO_DRIVE_CMD(dco_restore) failed");
      }
    }
  }
#line 1909
  if (do_dco_freeze) {
    {
#line 1910
    args___14[0] = (__u8 )177;
#line 1910
    args___14[1] = (__u8 )0;
#line 1910
    args___14[2] = (__u8 )193;
#line 1910
    args___14[3] = (__u8 )0;
#line 1911
    printf((char const   */* __restrict  */)" issuing DCO freeze command\n");
#line 1912
    tmp___52 = do_drive_cmd(fd, args___14, 0U);
    }
#line 1912
    if (tmp___52) {
      {
#line 1913
      tmp___51 = __errno_location();
#line 1913
      err = *tmp___51;
#line 1914
      perror(" HDIO_DRIVE_CMD(dco_freeze) failed");
      }
    }
  }
#line 1917
  if (security_freeze) {
    {
#line 1918
    args___15[0] = (__u8 )245;
#line 1918
    args___15[1] = (__u8 )0;
#line 1918
    args___15[2] = (__u8 )0;
#line 1918
    args___15[3] = (__u8 )0;
#line 1919
    printf((char const   */* __restrict  */)" issuing security freeze command\n");
#line 1920
    tmp___54 = do_drive_cmd(fd, args___15, 0U);
    }
#line 1920
    if (tmp___54) {
      {
#line 1921
      tmp___53 = __errno_location();
#line 1921
      err = *tmp___53;
#line 1922
      perror(" HDIO_DRIVE_CMD(security_freeze) failed");
      }
    }
  }
#line 1925
  if (set_seagate) {
#line 1926
    args___16[0] = (__u8 )251;
#line 1926
    args___16[1] = (__u8 )0;
#line 1926
    args___16[2] = (__u8 )0;
#line 1926
    args___16[3] = (__u8 )0;
#line 1927
    if (get_seagate) {
      {
#line 1928
      printf((char const   */* __restrict  */)" disabling Seagate auto powersaving mode\n");
      }
    }
    {
#line 1929
    tmp___56 = do_drive_cmd(fd, args___16, 0U);
    }
#line 1929
    if (tmp___56) {
      {
#line 1930
      tmp___55 = __errno_location();
#line 1930
      err = *tmp___55;
#line 1931
      perror(" HDIO_DRIVE_CMD(seagatepwrsave) failed");
      }
    }
  }
#line 1934
  if (set_busstate) {
#line 1935
    if (get_busstate) {
      {
#line 1936
      tmp___57 = busstate_str((unsigned int )busstate);
#line 1936
      printf((char const   */* __restrict  */)" setting bus state to %d (%s)\n", busstate,
             tmp___57);
      }
    }
    {
#line 1937
    tmp___59 = ioctl(fd, 813UL, busstate);
    }
#line 1937
    if (tmp___59) {
      {
#line 1938
      tmp___58 = __errno_location();
#line 1938
      err = *tmp___58;
#line 1939
      perror(" HDIO_SET_BUSSTATE failed");
      }
    }
  }
#line 1942
  if (set_max_sectors) {
#line 1943
    if (get_native_max_sectors) {
#line 1944
      if (set_max_permanent) {
#line 1944
        tmp___60 = "permanent";
      } else {
#line 1944
        tmp___60 = "temporary";
      }
      {
#line 1944
      printf((char const   */* __restrict  */)" setting max visible sectors to %llu (%s)\n",
             set_max_addr, tmp___60);
      }
    }
    {
#line 1945
    get_identify_data(fd);
    }
#line 1946
    if (id) {
      {
#line 1947
      tmp___61 = get_lba_capacity(id);
      }
#line 1947
      if (set_max_addr < tmp___61) {
        {
#line 1948
        confirm_i_know_what_i_am_doing("-Nnnnnn", "You have requested reducing the apparent size of the drive.\nThis is a BAD idea, and can easily destroy all of the drive\'s contents.");
        }
      }
      {
#line 1949
      err = do_set_max_sectors(fd, set_max_addr - 1ULL, set_max_permanent);
#line 1950
      id = (__u16 *)((void *)0);
      }
    }
  }
#line 1953
  if (make_bad_sector) {
    {
#line 1954
    get_identify_data(fd);
    }
#line 1955
    if (id) {
      {
#line 1956
      confirm_i_know_what_i_am_doing("--make-bad-sector", "You are trying to deliberately corrupt a low-level sector on the media.\nThis is a BAD idea, and can easily result in total data loss.");
#line 1957
      err = do_make_bad_sector(fd, make_bad_sector_addr, (char const   *)devname);
      }
    }
  }
#line 1972
  if (trim_sector_ranges_count) {
#line 1973
    if (num_flags_processed > 1) {
      {
#line 1974
      usage_help(13, 22);
      }
    } else
#line 1973
    if (argc) {
      {
#line 1974
      usage_help(13, 22);
      }
    }
    {
#line 1975
    confirm_please_destroy_my_drive("--trim-sector-ranges", "This might destroy the drive and/or all data on it.");
#line 1976
    do_trim_sector_ranges(fd, (char const   *)devname, trim_sector_ranges_count, trim_sector_ranges);
    }
  }
#line 1978
  if (write_sector) {
#line 1979
    if (num_flags_processed > 1) {
      {
#line 1980
      usage_help(14, 22);
      }
    } else
#line 1979
    if (argc) {
      {
#line 1980
      usage_help(14, 22);
      }
    }
    {
#line 1981
    confirm_i_know_what_i_am_doing("--write-sector", "You are trying to deliberately overwrite a low-level sector on the media.\nThis is a BAD idea, and can easily result in total data loss.");
#line 1982
    err = do_write_sector(fd, write_sector_addr, (char const   *)devname);
    }
  }
#line 1984
  if (do_fwdownload) {
#line 1985
    if (num_flags_processed > 1) {
      {
#line 1986
      usage_help(15, 22);
      }
    } else
#line 1985
    if (argc) {
      {
#line 1986
      usage_help(15, 22);
      }
    }
    {
#line 1987
    abort_if_not_full_device(fd, (__u64 )0, (char const   *)devname, "--fwdownload requires the raw device, not a partition.");
#line 1988
    confirm_i_know_what_i_am_doing("--fwdownload", "This flag has not been tested with many drives to date.\nYou are trying to deliberately overwrite the drive firmware with the contents of the specified file.\nIf this fails, your drive could be toast.");
#line 1989
    confirm_please_destroy_my_drive("--fwdownload", "This might destroy the drive and well as all of the data on it.");
#line 1990
    get_identify_data(fd);
    }
#line 1991
    if (id) {
      {
#line 1992
      err = fwdownload(fd, id, (char const   *)fwpath, xfer_mode);
      }
#line 1993
      if (err) {
        {
#line 1994
        exit(err);
        }
      }
    }
  }
#line 1997
  if (read_sector) {
    {
#line 1998
    err = do_read_sector(fd, read_sector_addr, (char const   *)devname);
    }
  }
#line 1999
  if (drq_hsm_error) {
    {
#line 2000
    get_identify_data(fd);
    }
#line 2001
    if (id) {
      {
#line 2002
      args___17[0] = (__u8 )0;
#line 2002
      args___17[1] = (__u8 )0;
#line 2002
      args___17[2] = (__u8 )0;
#line 2002
      args___17[3] = (__u8 )0;
#line 2003
      args___17[0] = last_identify_op;
#line 2004
      printf((char const   */* __restrict  */)" triggering \"stuck DRQ\" host state machine error\n");
#line 2005
      flush_buffer_cache(fd);
#line 2006
      sleep(1U);
#line 2007
      do_drive_cmd(fd, args___17, (unsigned int )timeout_60secs);
#line 2008
      tmp___62 = __errno_location();
#line 2008
      err = *tmp___62;
#line 2009
      perror("drq_hsm_error");
#line 2010
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ata status=0x%02x ata error=0x%02x\n",
              (int )args___17[0], (int )args___17[1]);
      }
    }
  }
#line 2013
  id = (__u16 *)((void *)0);
#line 2014
  if (get_hitachi_temp) {
    {
#line 2015
    args___18[0] = (__u8 )240;
#line 2015
    args___18[1] = (__u8 )0;
#line 2015
    args___18[2] = (__u8 )1;
#line 2015
    args___18[3] = (__u8 )0;
#line 2016
    tmp___65 = do_drive_cmd(fd, args___18, 0U);
    }
#line 2016
    if (tmp___65) {
      {
#line 2017
      tmp___63 = __errno_location();
#line 2017
      err = *tmp___63;
#line 2018
      perror(" HDIO_DRIVE_CMD(hitachisensecondition) failed");
      }
    } else {
      {
#line 2020
      printf((char const   */* __restrict  */)" drive temperature (celsius) is:  ");
      }
#line 2021
      if ((int )args___18[2] == 0) {
        {
#line 2022
        printf((char const   */* __restrict  */)"under -20");
        }
      } else
#line 2023
      if ((int )args___18[2] == 255) {
        {
#line 2024
        printf((char const   */* __restrict  */)"over 107");
        }
      } else {
        {
#line 2026
        printf((char const   */* __restrict  */)"%d", (int )args___18[2] / 2 - 20);
        }
      }
#line 2027
      if (! ((int )args___18[1] & 16) == 0) {
#line 2027
        tmp___64 = "no";
      } else {
#line 2027
        tmp___64 = "yes";
      }
      {
#line 2027
      printf((char const   */* __restrict  */)"\n drive temperature in range:  %s\n",
             tmp___64);
      }
    }
  }
#line 2030
  if (do_defaults) {
#line 2030
    goto _L;
  } else
#line 2030
  if (get_mult) {
#line 2030
    goto _L;
  } else
#line 2030
  if (do_identity) {
    _L: /* CIL Label */ 
    {
#line 2031
    multcount = -1L;
#line 2032
    err = 0;
#line 2033
    tmp___68 = ioctl(fd, 772UL, & multcount);
    }
#line 2033
    if (tmp___68) {
      {
#line 2034
      tmp___66 = __errno_location();
#line 2034
      err = *tmp___66;
#line 2035
      get_identify_data(fd);
      }
#line 2036
      if (id) {
#line 2037
        err = 0;
#line 2038
        if (((int )*(id + 59) & 65280) == 256) {
#line 2039
          multcount = (long )((int )*(id + 59) & 255);
        } else {
#line 2041
          multcount = 0L;
        }
      }
#line 2043
      if (err) {
#line 2043
        if (get_mult) {
          {
#line 2044
          tmp___67 = __errno_location();
#line 2044
          *tmp___67 = err;
#line 2045
          perror(" HDIO_GET_MULTCOUNT failed");
          }
        }
      }
    }
#line 2048
    if (! err) {
#line 2048
      if (do_defaults) {
        {
#line 2049
        printf((char const   */* __restrict  */)" multcount     = %2ld", multcount);
#line 2050
        on_off((unsigned int )multcount);
        }
      } else
#line 2048
      if (get_mult) {
        {
#line 2049
        printf((char const   */* __restrict  */)" multcount     = %2ld", multcount);
#line 2050
        on_off((unsigned int )multcount);
        }
      }
    }
  }
#line 2053
  if (do_defaults) {
#line 2053
    goto _L___0;
  } else
#line 2053
  if (get_io32bit) {
    _L___0: /* CIL Label */ 
    {
#line 2054
    tmp___70 = ioctl(fd, 777UL, & parm);
    }
#line 2054
    if (0 == tmp___70) {
      {
#line 2055
      printf((char const   */* __restrict  */)" IO_support    =%3ld (", parm);
      }
      {
#line 2057
      if (parm == 0L) {
#line 2057
        goto case_0;
      }
#line 2059
      if (parm == 2L) {
#line 2059
        goto case_2;
      }
#line 2061
      if (parm == 1L) {
#line 2061
        goto case_1;
      }
#line 2063
      if (parm == 3L) {
#line 2063
        goto case_3;
      }
#line 2065
      if (parm == 8L) {
#line 2065
        goto case_8;
      }
#line 2067
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 2057
      printf((char const   */* __restrict  */)"default) \n");
      }
#line 2058
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 2059
      printf((char const   */* __restrict  */)"16-bit)\n");
      }
#line 2060
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 2061
      printf((char const   */* __restrict  */)"32-bit)\n");
      }
#line 2062
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 2063
      printf((char const   */* __restrict  */)"32-bit w/sync)\n");
      }
#line 2064
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 2065
      printf((char const   */* __restrict  */)"Request-Queue-Bypass)\n");
      }
#line 2066
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 2067
      printf((char const   */* __restrict  */)"???)\n");
      }
      switch_break: /* CIL Label */ ;
      }
    } else
#line 2069
    if (get_io32bit) {
      {
#line 2070
      tmp___69 = __errno_location();
#line 2070
      err = *tmp___69;
#line 2071
      perror(" HDIO_GET_32BIT failed");
      }
    }
  }
#line 2074
  if (do_defaults) {
#line 2074
    goto _L___1;
  } else
#line 2074
  if (get_unmask) {
    _L___1: /* CIL Label */ 
    {
#line 2075
    tmp___72 = ioctl(fd, 770UL, & parm);
    }
#line 2075
    if (0 == tmp___72) {
      {
#line 2076
      printf((char const   */* __restrict  */)" unmaskirq     = %2ld", parm);
#line 2077
      on_off((unsigned int )parm);
      }
    } else
#line 2078
    if (get_unmask) {
      {
#line 2079
      tmp___71 = __errno_location();
#line 2079
      err = *tmp___71;
#line 2080
      perror(" HDIO_GET_UNMASKINTR failed");
      }
    }
  }
#line 2084
  if (do_defaults) {
#line 2084
    goto _L___2;
  } else
#line 2084
  if (get_dma) {
    _L___2: /* CIL Label */ 
    {
#line 2085
    tmp___74 = ioctl(fd, 779UL, & parm);
    }
#line 2085
    if (0 == tmp___74) {
      {
#line 2086
      printf((char const   */* __restrict  */)" using_dma     = %2ld", parm);
      }
#line 2087
      if (parm == 8L) {
        {
#line 2088
        printf((char const   */* __restrict  */)" (DMA-Assisted-PIO)\n");
        }
      } else {
        {
#line 2090
        on_off((unsigned int )parm);
        }
      }
    } else
#line 2091
    if (get_dma) {
      {
#line 2092
      tmp___73 = __errno_location();
#line 2092
      err = *tmp___73;
#line 2093
      perror(" HDIO_GET_DMA failed");
      }
    }
  }
#line 2096
  if (get_dma_q) {
    {
#line 2097
    err = sysfs_get_attr(fd, "device/queue_depth", "%u", (void *)(& dma_q), (void *)0,
                         1);
    }
#line 2098
    if (! err) {
      {
#line 2099
      printf((char const   */* __restrict  */)" queue_depth   = %2u\n", dma_q);
      }
    }
  }
#line 2101
  if (do_defaults) {
#line 2101
    goto _L___3;
  } else
#line 2101
  if (get_keep) {
    _L___3: /* CIL Label */ 
    {
#line 2102
    tmp___76 = ioctl(fd, 776UL, & parm);
    }
#line 2102
    if (0 == tmp___76) {
      {
#line 2103
      printf((char const   */* __restrict  */)" keepsettings  = %2ld", parm);
#line 2104
      on_off((unsigned int )parm);
      }
    } else
#line 2105
    if (get_keep) {
      {
#line 2106
      tmp___75 = __errno_location();
#line 2106
      err = *tmp___75;
#line 2107
      perror(" HDIO_GET_KEEPSETTINGS failed");
      }
    }
  }
#line 2110
  if (get_nowerr) {
    {
#line 2111
    tmp___78 = ioctl(fd, 778UL, & parm);
    }
#line 2111
    if (tmp___78) {
      {
#line 2112
      tmp___77 = __errno_location();
#line 2112
      err = *tmp___77;
#line 2113
      perror(" HDIO_GET_NOWERR failed");
      }
    } else {
      {
#line 2115
      printf((char const   */* __restrict  */)" nowerr        = %2ld", parm);
#line 2116
      on_off((unsigned int )parm);
      }
    }
  }
#line 2119
  if (do_defaults) {
#line 2119
    goto _L___4;
  } else
#line 2119
  if (get_readonly) {
    _L___4: /* CIL Label */ 
    {
#line 2120
    tmp___80 = ioctl(fd, (unsigned long )((unsigned int )(18 << 8) | 94U), & parm);
    }
#line 2120
    if (tmp___80) {
      {
#line 2121
      tmp___79 = __errno_location();
#line 2121
      err = *tmp___79;
#line 2122
      perror(" BLKROGET failed");
      }
    } else {
      {
#line 2124
      printf((char const   */* __restrict  */)" readonly      = %2ld", parm);
#line 2125
      on_off((unsigned int )parm);
      }
    }
  }
#line 2128
  if (do_defaults) {
#line 2128
    goto _L___5;
  } else
#line 2128
  if (get_fsreadahead) {
    _L___5: /* CIL Label */ 
    {
#line 2129
    tmp___82 = ioctl(fd, (unsigned long )((unsigned int )(18 << 8) | 99U), & parm);
    }
#line 2129
    if (tmp___82) {
      {
#line 2130
      tmp___81 = __errno_location();
#line 2130
      err = *tmp___81;
#line 2131
      perror(" BLKRAGET failed");
      }
    } else {
      {
#line 2133
      printf((char const   */* __restrict  */)" readahead     = %2ld", parm);
#line 2134
      on_off((unsigned int )parm);
      }
    }
  }
#line 2137
  if (do_defaults) {
#line 2137
    goto _L___6;
  } else
#line 2137
  if (get_geom) {
    _L___6: /* CIL Label */ 
    {
#line 2138
    cyls = (__u32 )0;
#line 2138
    heads = (__u32 )0;
#line 2138
    sects = (__u32 )0;
#line 2139
    start_lba = (__u64 )0;
#line 2139
    nsectors = (__u64 )0;
#line 2140
    err = get_dev_geometry(fd, & cyls, & heads, & sects, & start_lba, & nsectors);
    }
#line 2141
    if (! err) {
      {
#line 2142
      printf((char const   */* __restrict  */)" geometry      = %u/%u/%u, sectors = %lld, start = ",
             cyls, heads, sects, nsectors);
      }
#line 2143
      if (start_lba == 0xffffffffffffffffULL) {
        {
#line 2144
        printf((char const   */* __restrict  */)"unknown\n");
        }
      } else {
        {
#line 2146
        printf((char const   */* __restrict  */)"%lld\n", start_lba);
        }
      }
    }
  }
#line 2149
  if (get_wdidle3) {
    {
#line 2150
    timeout___0 = (unsigned char)0;
#line 2151
    err = wdidle3_get_timeout(fd, & timeout___0);
    }
#line 2152
    if (! err) {
      {
#line 2153
      printf((char const   */* __restrict  */)" wdidle3      = ");
#line 2154
      wdidle3_print_timeout(timeout___0);
#line 2155
      putchar('\n');
      }
    }
  }
#line 2158
  if (get_powermode) {
    {
#line 2159
    args___19[0] = (__u8 )229;
#line 2159
    args___19[1] = (__u8 )0;
#line 2159
    args___19[2] = (__u8 )0;
#line 2159
    args___19[3] = (__u8 )0;
#line 2160
    state = "unknown";
#line 2161
    tmp___84 = do_drive_cmd(fd, args___19, 0U);
    }
#line 2161
    if (tmp___84) {
#line 2161
      args___19[0] = (__u8 )152;
#line 2161
      if (args___19[0]) {
        {
#line 2161
        tmp___85 = do_drive_cmd(fd, args___19, 0U);
        }
#line 2161
        if (tmp___85) {
          {
#line 2164
          tmp___83 = __errno_location();
#line 2164
          err = *tmp___83;
          }
        } else {
#line 2161
          goto _L___8;
        }
      } else {
#line 2161
        goto _L___8;
      }
    } else {
      _L___8: /* CIL Label */ 
      {
#line 2167
      if ((int )args___19[2] == 0) {
#line 2167
        goto case_0___0;
      }
#line 2168
      if ((int )args___19[2] == 64) {
#line 2168
        goto case_64;
      }
#line 2169
      if ((int )args___19[2] == 65) {
#line 2169
        goto case_65;
      }
#line 2170
      if ((int )args___19[2] == 128) {
#line 2170
        goto case_128;
      }
#line 2171
      if ((int )args___19[2] == 255) {
#line 2171
        goto case_255;
      }
#line 2166
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 2167
      state = "standby";
#line 2167
      goto switch_break___0;
      case_64: /* CIL Label */ 
#line 2168
      state = "NVcache_spindown";
#line 2168
      goto switch_break___0;
      case_65: /* CIL Label */ 
#line 2169
      state = "NVcache_spinup";
#line 2169
      goto switch_break___0;
      case_128: /* CIL Label */ 
#line 2170
      state = "idle";
#line 2170
      goto switch_break___0;
      case_255: /* CIL Label */ 
#line 2171
      state = "active/idle";
#line 2171
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    {
#line 2174
    printf((char const   */* __restrict  */)" drive state is:  %s\n", state);
    }
  }
#line 2176
  if (do_identity) {
    {
#line 2179
    tmp___88 = ioctl(fd, 781UL, id2);
    }
#line 2179
    if (tmp___88) {
      {
#line 2186
      tmp___87 = __errno_location();
      }
#line 2186
      if (*tmp___87 == -42) {
        {
#line 2187
        printf((char const   */* __restrict  */)" no identification info available\n");
        }
      } else {
        {
#line 2189
        tmp___86 = __errno_location();
#line 2189
        err = *tmp___86;
#line 2190
        perror(" HDIO_GET_IDENTITY failed");
        }
      }
    } else {
#line 2180
      if (multcount != -1L) {
#line 2181
        id2[59] = (__u16 )(multcount | 256L);
      } else {
#line 2183
        id2[59] = (__u16 )((int )id2[59] & -257);
      }
      {
#line 2185
      dump_identity(id2);
      }
    }
  }
#line 2193
  if (do_IDentity) {
    {
#line 2194
    get_identify_data(fd);
    }
#line 2195
    if (id) {
#line 2196
      if (do_IDentity == 2) {
        {
#line 2197
        dump_sectors(id, 1U);
        }
      } else {
        {
#line 2199
        identify((__u16 *)((void *)id));
        }
      }
#line 2202
      if ((int )*(id + 78) & 256) {
        {
#line 2204
        deto = 0;
#line 2205
        mdat = 0;
#line 2207
        memset((void *)(buf), 0, (size_t )512);
#line 2208
        tmp___89 = get_id_log_page_data(fd, (__u8 )8, buf);
        }
#line 2208
        if (! tmp___89) {
#line 2208
          if ((int )buf[55] & 128) {
#line 2210
            mdat = (int )buf[48] & 31;
#line 2211
            deto = (int )buf[49];
          }
        }
        {
#line 2213
        printf((char const   */* __restrict  */)"Device Sleep:\n");
        }
#line 2214
        if (deto) {
#line 2214
          tmp___90 = "drive";
        } else {
#line 2214
          tmp___90 = "default";
        }
#line 2214
        if (deto) {
#line 2214
          tmp___91 = deto;
        } else {
#line 2214
          tmp___91 = 20;
        }
        {
#line 2214
        printf((char const   */* __restrict  */)"\tDEVSLP Exit Timeout (DETO): %d ms (%s)\n",
               tmp___91, tmp___90);
        }
#line 2217
        if (deto) {
#line 2217
          tmp___92 = "drive";
        } else {
#line 2217
          tmp___92 = "default";
        }
#line 2217
        if (mdat) {
#line 2217
          tmp___93 = mdat;
        } else {
#line 2217
          tmp___93 = 10;
        }
        {
#line 2217
        printf((char const   */* __restrict  */)"\tMinimum DEVSLP Assertion Time (MDAT): %d ms (%s)\n",
               tmp___93, tmp___92);
        }
      }
    }
  }
#line 2222
  if (get_lookahead) {
    {
#line 2223
    get_identify_data(fd);
    }
#line 2224
    if (id) {
#line 2225
      supported = (int )*(id + 82) & 64;
#line 2226
      if (supported) {
        {
#line 2227
        lookahead = ! (! ((int )*(id + 85) & 64));
#line 2228
        printf((char const   */* __restrict  */)" look-ahead    = %2d", lookahead);
#line 2229
        on_off((unsigned int )lookahead);
        }
      } else {
        {
#line 2231
        printf((char const   */* __restrict  */)" look-ahead    = not supported\n");
        }
      }
    }
  }
#line 2235
  if (get_wcache) {
    {
#line 2236
    get_identify_data(fd);
    }
#line 2237
    if (id) {
#line 2238
      supported___0 = (int )*(id + 82) & 32;
#line 2239
      if (supported___0) {
        {
#line 2240
        wcache = ! (! ((int )*(id + 85) & 32));
#line 2241
        printf((char const   */* __restrict  */)" write-caching = %2d", wcache);
#line 2242
        on_off((unsigned int )wcache);
        }
      } else {
        {
#line 2244
        printf((char const   */* __restrict  */)" write-caching = not supported\n");
        }
      }
    }
  }
#line 2248
  if (get_apmmode) {
    {
#line 2249
    get_identify_data(fd);
    }
#line 2250
    if (id) {
      {
#line 2251
      printf((char const   */* __restrict  */)" APM_level\t= ");
      }
#line 2252
      if (((int )*(id + 83) & 49160) == 16392) {
#line 2253
        if ((int )*(id + 86) & 8) {
          {
#line 2254
          printf((char const   */* __restrict  */)"%u\n", (int )*(id + 91) & 255);
          }
        } else {
          {
#line 2256
          printf((char const   */* __restrict  */)"off\n");
          }
        }
      } else {
        {
#line 2258
        printf((char const   */* __restrict  */)"not supported\n");
        }
      }
    }
  }
#line 2261
  if (get_acoustic) {
    {
#line 2262
    get_identify_data(fd);
    }
#line 2263
    if (id) {
#line 2264
      supported___1 = (int )*(id + 83) & 512;
#line 2265
      if (supported___1) {
        {
#line 2266
        printf((char const   */* __restrict  */)" acoustic      = %2u (128=quiet ... 254=fast)\n",
               (int )*(id + 94) & 255);
        }
      } else {
        {
#line 2268
        printf((char const   */* __restrict  */)" acoustic      = not supported\n");
        }
      }
    }
  }
#line 2271
  if (get_write_read_verify) {
    {
#line 2272
    get_identify_data(fd);
    }
#line 2273
    if (id) {
#line 2274
      supported___2 = (int )*(id + 119) & 2;
#line 2275
      if (supported___2) {
        {
#line 2276
        printf((char const   */* __restrict  */)" write-read-verify = %2u\n", (int )*(id + 120) & 2);
        }
      } else {
        {
#line 2278
        printf((char const   */* __restrict  */)" write-read-verify = not supported\n");
        }
      }
    }
  }
#line 2281
  if (get_busstate) {
    {
#line 2282
    tmp___96 = ioctl(fd, 794UL, & parm);
    }
#line 2282
    if (tmp___96) {
      {
#line 2283
      tmp___94 = __errno_location();
#line 2283
      err = *tmp___94;
#line 2284
      perror(" HDIO_GET_BUSSTATE failed");
      }
    } else {
      {
#line 2286
      tmp___95 = busstate_str((unsigned int )parm);
#line 2286
      printf((char const   */* __restrict  */)" busstate      = %2ld (%s)\n", parm,
             tmp___95);
      }
    }
  }
#line 2289
  if (get_native_max_sectors) {
    {
#line 2291
    get_identify_data(fd);
    }
#line 2292
    if (id) {
      {
#line 2293
      visible = get_lba_capacity(id);
#line 2294
      native = do_get_native_max_sectors(fd);
      }
#line 2295
      if (! native) {
        {
#line 2296
        tmp___97 = __errno_location();
#line 2296
        err = *tmp___97;
        }
      } else {
        {
#line 2298
        printf((char const   */* __restrict  */)" max sectors   = %llu/%llu", visible,
               native);
        }
#line 2299
        if (visible < native) {
          {
#line 2300
          printf((char const   */* __restrict  */)", HPA is enabled\n");
          }
        } else
#line 2301
        if (visible == native) {
          {
#line 2302
          printf((char const   */* __restrict  */)", HPA is disabled\n");
          }
        } else {
          {
#line 2304
          tmp___98 = get_dco_identify_data(fd, 1);
#line 2304
          dco___0 = tmp___98;
          }
#line 2305
          if (dco___0) {
            {
#line 2306
            dco_max = (__u64 )*(dco___0 + 5);
#line 2307
            dco_max = ((((__u64 )*(dco___0 + 5) << 32) | (unsigned long long )((int )*(dco___0 + 4) << 16)) | (unsigned long long )*(dco___0 + 3)) + 1ULL;
#line 2308
            printf((char const   */* __restrict  */)"(%llu?)", dco_max);
            }
          }
          {
#line 2310
          printf((char const   */* __restrict  */)", HPA setting seems invalid");
          }
#line 2311
          if ((native & 281474959933440ULL) == 0ULL) {
            {
#line 2312
            printf((char const   */* __restrict  */)" (buggy kernel device driver?)");
            }
          }
          {
#line 2313
          putchar('\n');
          }
        }
      }
    }
  }
#line 2319
  if (do_ctimings) {
    {
#line 2320
    time_cache(fd);
    }
  }
#line 2321
  if (do_flush_wcache) {
    {
#line 2322
    err = flush_wcache(fd);
    }
  }
#line 2323
  if (do_timings) {
    {
#line 2324
    err = time_device(fd);
    }
  }
#line 2325
  if (do_flush) {
    {
#line 2326
    flush_buffer_cache(fd);
    }
  }
#line 2327
  if (set_reread_partn) {
#line 2328
    if (get_reread_partn) {
      {
#line 2329
      printf((char const   */* __restrict  */)" re-reading partition table\n");
      }
    }
    {
#line 2330
    tmp___100 = ioctl(fd, (unsigned long )((unsigned int )(18 << 8) | 95U), (void *)0);
    }
#line 2330
    if (tmp___100) {
      {
#line 2331
      tmp___99 = __errno_location();
#line 2331
      err = *tmp___99;
#line 2332
      perror(" BLKRRPART failed");
      }
    }
  }
#line 2335
  if (set_idleimmediate) {
#line 2336
    args___20[0] = (__u8 )225;
#line 2336
    args___20[1] = (__u8 )0;
#line 2336
    args___20[2] = (__u8 )0;
#line 2336
    args___20[3] = (__u8 )0;
#line 2337
    if (get_idleimmediate) {
      {
#line 2338
      printf((char const   */* __restrict  */)" issuing idle_immediate command\n");
      }
    }
    {
#line 2339
    tmp___102 = do_drive_cmd(fd, args___20, 0U);
    }
#line 2339
    if (tmp___102) {
      {
#line 2340
      tmp___101 = __errno_location();
#line 2340
      err = *tmp___101;
#line 2341
      perror(" HDIO_DRIVE_CMD(idle_immediate) failed");
      }
    }
  }
#line 2344
  if (set_standbynow) {
#line 2345
    args1___0[0] = (__u8 )224;
#line 2345
    args1___0[1] = (__u8 )0;
#line 2345
    args1___0[2] = (__u8 )0;
#line 2345
    args1___0[3] = (__u8 )0;
#line 2346
    args2[0] = (__u8 )148;
#line 2346
    args2[1] = (__u8 )0;
#line 2346
    args2[2] = (__u8 )0;
#line 2346
    args2[3] = (__u8 )0;
#line 2347
    if (get_standbynow) {
      {
#line 2348
      printf((char const   */* __restrict  */)" issuing standby command\n");
      }
    }
    {
#line 2349
    tmp___104 = do_drive_cmd(fd, args1___0, 0U);
    }
#line 2349
    if (tmp___104) {
      {
#line 2349
      tmp___105 = do_drive_cmd(fd, args2, 0U);
      }
#line 2349
      if (tmp___105) {
        {
#line 2350
        tmp___103 = __errno_location();
#line 2350
        err = *tmp___103;
#line 2351
        perror(" HDIO_DRIVE_CMD(standby) failed");
        }
      }
    }
  }
#line 2354
  if (set_idleunload) {
#line 2355
    if (get_idleunload) {
      {
#line 2356
      printf((char const   */* __restrict  */)" issuing idle_immediate_unload command\n");
      }
    }
    {
#line 2357
    err = do_idleunload(fd, (char const   *)devname);
    }
  }
#line 2359
  if (set_sleepnow) {
#line 2360
    args1___1[0] = (__u8 )230;
#line 2360
    args1___1[1] = (__u8 )0;
#line 2360
    args1___1[2] = (__u8 )0;
#line 2360
    args1___1[3] = (__u8 )0;
#line 2361
    args2___0[0] = (__u8 )153;
#line 2361
    args2___0[1] = (__u8 )0;
#line 2361
    args2___0[2] = (__u8 )0;
#line 2361
    args2___0[3] = (__u8 )0;
#line 2362
    if (get_sleepnow) {
      {
#line 2363
      printf((char const   */* __restrict  */)" issuing sleep command\n");
      }
    }
    {
#line 2364
    tmp___107 = do_drive_cmd(fd, args1___1, 0U);
    }
#line 2364
    if (tmp___107) {
      {
#line 2364
      tmp___108 = do_drive_cmd(fd, args2___0, 0U);
      }
#line 2364
      if (tmp___108) {
        {
#line 2365
        tmp___106 = __errno_location();
#line 2365
        err = *tmp___106;
#line 2366
        perror(" HDIO_DRIVE_CMD(sleep) failed");
        }
      }
    }
  }
#line 2369
  if (set_doreset) {
#line 2370
    if (get_doreset) {
      {
#line 2371
      printf((char const   */* __restrict  */)" resetting drive\n");
      }
    }
    {
#line 2372
    tmp___110 = ioctl(fd, 796UL, (void *)0);
    }
#line 2372
    if (tmp___110) {
      {
#line 2373
      tmp___109 = __errno_location();
#line 2373
      err = *tmp___109;
#line 2374
      perror(" HDIO_DRIVE_RESET failed");
      }
    }
  }
  {
#line 2377
  close(fd);
  }
#line 2378
  if (err) {
    {
#line 2379
    exit(err);
    }
  }
#line 2380
  return;
}
}
#line 2400 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int fromhex(__u8 c ) 
{ 


  {
#line 2402
  if ((int )c >= 48) {
#line 2402
    if ((int )c <= 57) {
#line 2403
      return ((int )c - 48);
    }
  }
#line 2404
  if ((int )c >= 97) {
#line 2404
    if ((int )c <= 102) {
#line 2405
      return (10 + ((int )c - 97));
    }
  }
#line 2406
  if ((int )c >= 65) {
#line 2406
    if ((int )c <= 70) {
#line 2407
      return (10 + ((int )c - 65));
    }
  }
  {
#line 2408
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad char: \'%c\' 0x%02x\n",
          (int )c, (int )c);
#line 2409
  exit(22);
  }
}
}
#line 2412 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int ishex(char c ) 
{ 
  int tmp ;

  {
#line 2414
  if ((int )c >= 48) {
#line 2414
    if ((int )c <= 57) {
#line 2414
      tmp = 1;
    } else {
#line 2414
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2414
  if ((int )c >= 97) {
#line 2414
    if ((int )c <= 102) {
#line 2414
      tmp = 1;
    } else {
#line 2414
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2414
  if ((int )c >= 65) {
#line 2414
    if ((int )c <= 70) {
#line 2414
      tmp = 1;
    } else {
#line 2414
      tmp = 0;
    }
  } else {
#line 2414
    tmp = 0;
  }
#line 2414
  return (tmp);
}
}
#line 2417 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void identify_from_stdin(void) 
{ 
  __u16 sbuf[512] ;
  int err ;
  int wc ;
  int digit ;
  int d[4] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;

  {
#line 2421
  wc = 0;
  {
#line 2423
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2427
    digit = 0;
#line 2427
    tmp___3 = getchar();
#line 2427
    d[digit] = tmp___3;
#line 2427
    tmp___4 = ishex((char )tmp___3);
    }
#line 2427
    if (tmp___4) {
      {
#line 2427
      digit ++;
#line 2427
      tmp___5 = getchar();
#line 2427
      d[digit] = tmp___5;
#line 2427
      tmp___6 = ishex((char )tmp___5);
      }
#line 2427
      if (tmp___6) {
        {
#line 2427
        digit ++;
#line 2427
        tmp___7 = getchar();
#line 2427
        d[digit] = tmp___7;
#line 2427
        tmp___8 = ishex((char )tmp___7);
        }
#line 2427
        if (tmp___8) {
          {
#line 2427
          digit ++;
#line 2427
          tmp___9 = getchar();
#line 2427
          d[digit] = tmp___9;
#line 2427
          tmp___10 = ishex((char )tmp___9);
          }
#line 2427
          if (tmp___10) {
            {
#line 2431
            tmp = fromhex((__u8 )d[0]);
#line 2431
            tmp___0 = fromhex((__u8 )d[1]);
#line 2431
            tmp___1 = fromhex((__u8 )d[2]);
#line 2431
            tmp___2 = fromhex((__u8 )d[3]);
#line 2431
            sbuf[wc] = (__u16 )((((tmp << 12) | (tmp___0 << 8)) | (tmp___1 << 4)) | tmp___2);
#line 2432
            wc ++;
            }
          } else {
#line 2427
            goto _L___1;
          }
        } else {
#line 2427
          goto _L___1;
        }
      } else {
#line 2427
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 2433
    if (d[digit] == -1) {
#line 2434
      goto eof;
    } else
#line 2435
    if (wc == 0) {
      {
#line 2437
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2437
        if (! (d[digit] != 10)) {
#line 2437
          goto while_break___0;
        }
#line 2438
        if (d[digit] == -1) {
#line 2439
          goto eof;
        }
        {
#line 2440
        digit = 0;
#line 2440
        d[digit] = getchar();
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 2423
    if (! (wc < 256)) {
#line 2423
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2444
  putchar('\n');
#line 2445
  identify(sbuf);
  }
#line 2446
  return;
  eof: 
  {
#line 2448
  tmp___11 = __errno_location();
#line 2448
  err = *tmp___11;
#line 2449
  tmp___12 = strerror(err);
#line 2449
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"read only %u/256 IDENTIFY words from stdin: %s\n",
          wc, tmp___12);
#line 2450
  exit(err);
  }
}
}
#line 2453 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void numeric_parm(char c , char const   *name , int *val , int *setparm , int *getparm ,
                         int min , int max , int set_only ) 
{ 
  int got_digit ;
  char **tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 2456
  got_digit = 0;
#line 2458
  *val = 0;
#line 2459
  *getparm = noisy;
#line 2460
  noisy = 1;
#line 2461
  if (! *argp) {
#line 2461
    if (argc) {
      {
#line 2461
      tmp___0 = __ctype_b_loc();
      }
#line 2461
      if ((int const   )*(*tmp___0 + (int )*(*argv)) & 2048) {
#line 2462
        tmp = argv;
#line 2462
        argv ++;
#line 2462
        argp = *tmp;
#line 2462
        argc --;
      }
    }
  }
  {
#line 2463
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2463
    tmp___2 = __ctype_b_loc();
    }
#line 2463
    if (! ((int const   )*(*tmp___2 + (int )*argp) & 2048)) {
#line 2463
      goto while_break;
    }
#line 2464
    *setparm = 1;
#line 2465
    tmp___1 = argp;
#line 2465
    argp ++;
#line 2465
    *val = *val * 10 + ((int )*tmp___1 - 48);
#line 2466
    got_digit = 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 2468
  if (set_only) {
#line 2468
    if (! got_digit) {
      {
#line 2469
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -%c: bad/missing %s value (%d..%d)\n",
              (int )c, name, min, max);
#line 2470
      exit(22);
      }
    } else {
#line 2468
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2468
  if (*val < min) {
    {
#line 2469
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -%c: bad/missing %s value (%d..%d)\n",
            (int )c, name, min, max);
#line 2470
    exit(22);
    }
  } else
#line 2468
  if (*val > max) {
    {
#line 2469
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -%c: bad/missing %s value (%d..%d)\n",
            (int )c, name, min, max);
#line 2470
    exit(22);
    }
  }
#line 2472
  return;
}
}
#line 2482 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void get_security_password(int handle_NULL ) 
{ 
  unsigned int maxlen ;
  char **tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 2484
  maxlen = (unsigned int )(sizeof(security_password) - 1UL);
#line 2486
  if (argc < 2) {
    {
#line 2487
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"missing PASSWD\n");
#line 2488
    exit(22);
    }
  }
#line 2490
  tmp = argv;
#line 2490
  argv ++;
#line 2490
  argp = *tmp;
#line 2490
  argc --;
#line 2491
  if (! argp) {
    {
#line 2492
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"missing PASSWD\n");
#line 2493
    exit(22);
    }
  }
  {
#line 2495
  tmp___0 = strlen((char const   *)argp);
  }
#line 2495
  if (tmp___0 > (size_t )maxlen) {
    {
#line 2496
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"PASSWD too long (must be %d chars max)\n",
            maxlen);
#line 2497
    exit(22);
    }
  }
  {
#line 2499
  memset((void *)(security_password), 0, (size_t )(maxlen + 1U));
  }
#line 2500
  if (! handle_NULL) {
    {
#line 2501
    strcpy((char */* __restrict  */)(security_password), (char const   */* __restrict  */)argp);
    }
  } else {
    {
#line 2500
    tmp___1 = strcmp((char const   *)argp, "NULL");
    }
#line 2500
    if (tmp___1) {
      {
#line 2501
      strcpy((char */* __restrict  */)(security_password), (char const   */* __restrict  */)argp);
      }
    }
  }
  {
#line 2502
  printf((char const   */* __restrict  */)"security_password=\"%s\"\n", security_password);
  }
  {
#line 2503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2503
    if (! *argp) {
#line 2503
      goto while_break;
    }
#line 2504
    argp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2505
  return;
}
}
#line 2507 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static char const   *lba_emsg  =    "bad/missing sector value";
#line 2508 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static char const   *count_emsg  =    "bad/missing sector count";
#line 2509 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static unsigned long long const   lba_limit  =    (__u64 const   )((1ULL << 48) - 1ULL);
#line 2511 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_u64_parm(int optional , char const   flag_c , int *flag_p , __u64 *value_p ,
                        unsigned int min_value , __u64 limit , char const   *eprefix ,
                        char const   *emsg ) 
{ 
  int got_value ;
  __u64 value ;
  char *endp ;
  char **tmp ;
  unsigned short const   **tmp___0 ;
  int *tmp___1 ;
  long long tmp___2 ;
  int *tmp___3 ;

  {
#line 2515
  got_value = 0;
#line 2516
  value = *value_p;
#line 2517
  endp = (char *)((void *)0);
#line 2519
  if (! *argp) {
#line 2519
    if (argc) {
      {
#line 2519
      tmp___0 = __ctype_b_loc();
      }
#line 2519
      if ((int const   )*(*tmp___0 + (int )*(*argv)) & 2048) {
#line 2520
        tmp = argv;
#line 2520
        argv ++;
#line 2520
        argp = *tmp;
#line 2520
        argc --;
      } else
#line 2519
      if (flag_p) {
#line 2519
        if ((int const   )flag_c == (int const   )*(*argv)) {
#line 2520
          tmp = argv;
#line 2520
          argv ++;
#line 2520
          argp = *tmp;
#line 2520
          argc --;
        }
      }
    }
  }
#line 2522
  if (flag_p) {
#line 2523
    *flag_p = 0;
#line 2524
    if ((int )*argp == (int )flag_c) {
#line 2525
      *flag_p = 1;
#line 2526
      argp ++;
    }
  }
  {
#line 2530
  tmp___1 = __errno_location();
#line 2530
  *tmp___1 = 0;
#line 2531
  tmp___2 = strtoll((char const   */* __restrict  */)argp, (char **/* __restrict  */)(& endp),
                    0);
#line 2531
  value = (__u64 )tmp___2;
#line 2532
  tmp___3 = __errno_location();
  }
#line 2532
  if (*tmp___3 != 0) {
    {
#line 2533
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s: %s\n",
            eprefix, emsg);
#line 2534
    exit(22);
    }
  } else
#line 2532
  if ((unsigned long )endp != (unsigned long )argp) {
#line 2532
    if ((__s64 )value < (__s64 )min_value) {
      {
#line 2533
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s: %s\n",
              eprefix, emsg);
#line 2534
      exit(22);
      }
    } else
#line 2532
    if (value > limit) {
      {
#line 2533
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s: %s\n",
              eprefix, emsg);
#line 2534
      exit(22);
      }
    }
  }
#line 2536
  if ((unsigned long )endp != (unsigned long )argp) {
#line 2537
    got_value = 1;
#line 2538
    *value_p = value;
#line 2539
    argp = endp;
  }
#line 2541
  if (! optional) {
#line 2541
    if (! got_value) {
      {
#line 2542
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s: %s\n",
              eprefix, emsg);
#line 2543
      exit(22);
      }
    }
  }
#line 2545
  return (got_value);
}
}
#line 2548 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void get_set_max_sectors_parms(void) 
{ 


  {
  {
#line 2551
  get_native_max_sectors = noisy;
#line 2552
  noisy = 1;
#line 2553
  set_max_sectors = get_u64_parm(1, (char const   )'p', & set_max_permanent, & set_max_addr,
                                 1U, (__u64 )lba_limit, "-N", lba_emsg);
  }
#line 2554
  return;
}
}
#line 2556 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void handle_standalone_longarg(char *name ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 2559
  if (num_flags_processed) {
#line 2560
    if (verbose) {
      {
#line 2561
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"handle_standalone_longarg: num_flags_processed == %d\n",
              num_flags_processed);
      }
    }
    {
#line 2562
    usage_help(1, 22);
    }
  }
  {
#line 2565
  tmp = strcasecmp((char const   *)name, "Istdin");
  }
#line 2565
  if (0 == tmp) {
#line 2566
    if (argc > 0) {
#line 2567
      if (verbose) {
        {
#line 2568
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"handle_standalone_longarg: argc(%d) > 0\n",
                argc);
        }
      }
      {
#line 2569
      usage_help(2, 22);
      }
    }
    {
#line 2571
    identify_from_stdin();
#line 2572
    exit(0);
    }
  }
  {
#line 2574
  tmp___6 = strcasecmp((char const   *)name, "dco-restore");
  }
#line 2574
  if (0 == tmp___6) {
#line 2575
    do_dco_restore = 1;
  } else {
    {
#line 2576
    tmp___5 = strcasecmp((char const   *)name, "security-help");
    }
#line 2576
    if (0 == tmp___5) {
      {
#line 2577
      security_help(0);
#line 2578
      exit(0);
      }
    } else {
      {
#line 2579
      tmp___4 = strcasecmp((char const   *)name, "security-unlock");
      }
#line 2579
      if (0 == tmp___4) {
        {
#line 2580
        set_security = 1;
#line 2581
        security_command = 242U;
#line 2582
        get_security_password(0);
        }
      } else {
        {
#line 2583
        tmp___3 = strcasecmp((char const   *)name, "security-set-pass");
        }
#line 2583
        if (0 == tmp___3) {
          {
#line 2584
          set_security = 1;
#line 2585
          security_command = 241U;
#line 2586
          get_security_password(1);
          }
        } else {
          {
#line 2587
          tmp___2 = strcasecmp((char const   *)name, "security-disable");
          }
#line 2587
          if (0 == tmp___2) {
            {
#line 2588
            set_security = 1;
#line 2589
            security_command = 246U;
#line 2590
            get_security_password(1);
            }
          } else {
            {
#line 2591
            tmp___1 = strcasecmp((char const   *)name, "security-erase");
            }
#line 2591
            if (0 == tmp___1) {
              {
#line 2592
              set_security = 1;
#line 2593
              security_command = 244U;
#line 2594
              get_security_password(1);
              }
            } else {
              {
#line 2595
              tmp___0 = strcasecmp((char const   *)name, "security-erase-enhanced");
              }
#line 2595
              if (0 == tmp___0) {
                {
#line 2596
                set_security = 1;
#line 2597
                enhanced_erase = 1;
#line 2598
                security_command = 244U;
#line 2599
                get_security_password(1);
                }
              } else {
                {
#line 2601
                usage_help(3, 22);
                }
              }
            }
          }
        }
      }
    }
  }
#line 2603
  return;
}
}
#line 2605 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void get_filename_parm(char **result , char const   *emsg ) 
{ 
  char **tmp ;
  size_t tmp___0 ;

  {
#line 2608
  if (! *argp) {
#line 2608
    if (argc) {
#line 2609
      tmp = argv;
#line 2609
      argv ++;
#line 2609
      argp = *tmp;
#line 2609
      argc --;
    }
  }
#line 2610
  if (! argp) {
    {
#line 2611
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s: bad/missing filename parameter\n",
            emsg);
#line 2612
    exit(22);
    }
  } else
#line 2610
  if (! *argp) {
    {
#line 2611
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s: bad/missing filename parameter\n",
            emsg);
#line 2612
    exit(22);
    }
  }
  {
#line 2614
  *result = argp;
#line 2615
  tmp___0 = strlen((char const   *)argp);
#line 2615
  argp += tmp___0;
  }
#line 2617
  return;
}
}
#line 2619 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void do_fallocate(char const   *name ) 
{ 
  char *path___0 ;
  __u64 blkcount ;
  int tmp ;

  {
  {
#line 2625
  get_u64_parm(0, (char const   )0, (int *)((void *)0), & blkcount, 0U, 1ULL << 53,
               name, "bad/missing block-count");
#line 2626
  get_filename_parm(& path___0, name);
  }
#line 2627
  if (num_flags_processed) {
    {
#line 2628
    usage_help(4, 22);
    }
  } else
#line 2627
  if (argc) {
    {
#line 2628
    usage_help(4, 22);
    }
  }
  {
#line 2629
  tmp = do_fallocate_syscall((char const   *)path___0, blkcount * 1024ULL);
#line 2629
  exit(tmp);
  }
}
}
#line 2632 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static void do_fibmap_file(char const   *name ) 
{ 
  int err ;
  char *path___0 ;

  {
  {
#line 2638
  get_filename_parm(& path___0, name);
  }
#line 2639
  if (num_flags_processed) {
    {
#line 2640
    usage_help(5, 22);
    }
  } else
#line 2639
  if (argc) {
    {
#line 2640
    usage_help(5, 22);
    }
  }
  {
#line 2641
  err = do_filemap((char const   *)path___0);
#line 2642
  exit(err);
  }
}
}
#line 2645 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
static int get_longarg(void) 
{ 
  char *name ;
  int i ;
  int optional ;
  int max_ranges ;
  void *tmp ;
  int err ;
  int *tmp___0 ;
  char err_prefix[64] ;
  struct sector_range_s *p ;
  int tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  char **tmp___4 ;
  unsigned short const   **tmp___5 ;
  char **tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;

  {
#line 2648
  name = argp;
  {
#line 2650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2650
    if (! *argp) {
#line 2650
      goto while_break;
    }
#line 2651
    argp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2652
  tmp___34 = strcasecmp((char const   *)name, "verbose");
  }
#line 2652
  if (0 == tmp___34) {
#line 2653
    verbose = 1;
#line 2654
    num_flags_processed --;
  } else {
    {
#line 2655
    tmp___33 = strcasecmp((char const   *)name, "prefer-ata12");
    }
#line 2655
    if (0 == tmp___33) {
#line 2656
      prefer_ata12 = 1;
#line 2657
      num_flags_processed --;
    } else {
      {
#line 2658
      tmp___32 = strcasecmp((char const   *)name, "offset");
      }
#line 2658
      if (0 == tmp___32) {
        {
#line 2659
        set_timings_offset = 1;
#line 2660
        get_u64_parm(0, (char const   )0, (int *)((void *)0), & timings_offset, 0U,
                     (__u64 )(~ 0), (char const   *)name, "GB offset for -t flag");
#line 2661
        timings_offset *= 1073741824ULL;
        }
      } else {
        {
#line 2662
        tmp___31 = strcasecmp((char const   *)name, "yes-i-know-what-i-am-doing");
        }
#line 2662
        if (0 == tmp___31) {
#line 2663
          i_know_what_i_am_doing = 1;
#line 2664
          num_flags_processed --;
        } else {
          {
#line 2665
          tmp___30 = strcasecmp((char const   *)name, "please-destroy-my-drive");
          }
#line 2665
          if (0 == tmp___30) {
#line 2666
            please_destroy_my_drive = 1;
#line 2667
            num_flags_processed --;
          } else {
            {
#line 2668
            tmp___29 = strcasecmp((char const   *)name, "direct");
            }
#line 2668
            if (0 == tmp___29) {
#line 2669
              open_flags |= 16384;
#line 2670
              num_flags_processed --;
            } else {
              {
#line 2671
              tmp___28 = strcasecmp((char const   *)name, "drq-hsm-error");
              }
#line 2671
              if (0 == tmp___28) {
#line 2672
                drq_hsm_error = 1;
              } else {
                {
#line 2673
                tmp___27 = strcasecmp((char const   *)name, "dco-freeze");
                }
#line 2673
                if (0 == tmp___27) {
#line 2674
                  do_dco_freeze = 1;
                } else {
                  {
#line 2675
                  tmp___26 = strcasecmp((char const   *)name, "dco-identify");
                  }
#line 2675
                  if (0 == tmp___26) {
#line 2676
                    do_dco_identify = 1;
                  } else {
                    {
#line 2677
                    tmp___25 = strcasecmp((char const   *)name, "fallocate");
                    }
#line 2677
                    if (0 == tmp___25) {
                      {
#line 2678
                      do_fallocate((char const   *)name);
                      }
                    } else {
                      {
#line 2679
                      tmp___24 = strcasecmp((char const   *)name, "fibmap");
                      }
#line 2679
                      if (0 == tmp___24) {
                        {
#line 2680
                        do_fibmap_file((char const   *)name);
                        }
                      } else {
                        {
#line 2681
                        tmp___23 = strcasecmp((char const   *)name, "fwdownload-mode3");
                        }
#line 2681
                        if (0 == tmp___23) {
                          {
#line 2682
                          get_filename_parm(& fwpath, (char const   *)name);
#line 2683
                          do_fwdownload = 1;
#line 2684
                          xfer_mode = 3;
                          }
                        } else {
                          {
#line 2685
                          tmp___22 = strcasecmp((char const   *)name, "fwdownload-mode3-max");
                          }
#line 2685
                          if (0 == tmp___22) {
                            {
#line 2686
                            get_filename_parm(& fwpath, (char const   *)name);
#line 2687
                            do_fwdownload = 1;
#line 2688
                            xfer_mode = 30;
                            }
                          } else {
                            {
#line 2689
                            tmp___21 = strcasecmp((char const   *)name, "fwdownload-mode7");
                            }
#line 2689
                            if (0 == tmp___21) {
                              {
#line 2690
                              get_filename_parm(& fwpath, (char const   *)name);
#line 2691
                              do_fwdownload = 1;
#line 2692
                              xfer_mode = 7;
                              }
                            } else {
                              {
#line 2693
                              tmp___20 = strcasecmp((char const   *)name, "fwdownload");
                              }
#line 2693
                              if (0 == tmp___20) {
                                {
#line 2694
                                get_filename_parm(& fwpath, (char const   *)name);
#line 2695
                                do_fwdownload = 1;
#line 2696
                                xfer_mode = 0;
                                }
                              } else {
                                {
#line 2697
                                tmp___19 = strcasecmp((char const   *)name, "idle-immediate");
                                }
#line 2697
                                if (0 == tmp___19) {
#line 2698
                                  get_idleimmediate = noisy;
#line 2698
                                  noisy = 1;
#line 2698
                                  set_idleimmediate = 1;
                                } else {
                                  {
#line 2699
                                  tmp___18 = strcasecmp((char const   *)name, "idle-unload");
                                  }
#line 2699
                                  if (0 == tmp___18) {
#line 2700
                                    get_idleunload = noisy;
#line 2700
                                    noisy = 1;
#line 2700
                                    set_idleunload = 1;
                                  } else {
                                    {
#line 2701
                                    tmp___17 = strcasecmp((char const   *)name, "make-bad-sector");
                                    }
#line 2701
                                    if (0 == tmp___17) {
                                      {
#line 2702
                                      make_bad_sector = 1;
#line 2703
                                      get_u64_parm(0, (char const   )'f', & make_bad_sector_flagged,
                                                   & make_bad_sector_addr, 0U, (__u64 )lba_limit,
                                                   (char const   *)name, lba_emsg);
                                      }
                                    } else {
                                      {
#line 2712
                                      tmp___16 = strcasecmp((char const   *)name,
                                                            "trim-sector-ranges-stdin");
                                      }
#line 2712
                                      if (0 == tmp___16) {
#line 2713
                                        trim_from_stdin = 1;
                                      } else {
                                        {
#line 2714
                                        tmp___15 = strcasecmp((char const   *)name,
                                                              "trim-sector-ranges");
                                        }
#line 2714
                                        if (0 == tmp___15) {
                                          {
#line 2715
                                          optional = 0;
#line 2715
                                          max_ranges = argc;
#line 2716
                                          tmp = malloc(sizeof(struct sector_range_s ) * (unsigned long )max_ranges);
#line 2716
                                          trim_sector_ranges = (struct sector_range_s *)tmp;
                                          }
#line 2717
                                          if (! trim_sector_ranges) {
                                            {
#line 2718
                                            tmp___0 = __errno_location();
#line 2718
                                            err = *tmp___0;
#line 2719
                                            perror("malloc()");
#line 2720
                                            exit(err);
                                            }
                                          }
#line 2722
                                          open_flags |= 2;
#line 2723
                                          i = 0;
                                          {
#line 2723
                                          while (1) {
                                            while_continue___0: /* CIL Label */ ;
#line 2723
                                            if (! (i < max_ranges)) {
#line 2723
                                              goto while_break___0;
                                            }
                                            {
#line 2725
                                            p = trim_sector_ranges + i;
#line 2726
                                            sprintf((char */* __restrict  */)(err_prefix),
                                                    (char const   */* __restrict  */)"%s[%u]",
                                                    name, i);
#line 2727
                                            tmp___1 = get_u64_parm(optional, (char const   )0,
                                                                   (int *)((void *)0),
                                                                   & p->lba, 0U, (__u64 )lba_limit,
                                                                   (char const   *)(err_prefix),
                                                                   lba_emsg);
                                            }
#line 2727
                                            if (! tmp___1) {
#line 2728
                                              goto while_break___0;
                                            }
#line 2729
                                            tmp___2 = argp;
#line 2729
                                            argp ++;
#line 2729
                                            if ((int )*tmp___2 != 58) {
                                              {
#line 2730
                                              fprintf((FILE */* __restrict  */)stderr,
                                                      (char const   */* __restrict  */)"%s: %s\n",
                                                      err_prefix, count_emsg);
#line 2731
                                              exit(22);
                                              }
                                            } else {
                                              {
#line 2729
                                              tmp___3 = __ctype_b_loc();
                                              }
#line 2729
                                              if (! ((int const   )*(*tmp___3 + (int )*argp) & 2048)) {
                                                {
#line 2730
                                                fprintf((FILE */* __restrict  */)stderr,
                                                        (char const   */* __restrict  */)"%s: %s\n",
                                                        err_prefix, count_emsg);
#line 2731
                                                exit(22);
                                                }
                                              }
                                            }
                                            {
#line 2733
                                            get_u64_parm(0, (char const   )0, (int *)((void *)0),
                                                         & p->nsectors, 1U, (__u64 )65535,
                                                         (char const   *)(err_prefix),
                                                         count_emsg);
#line 2734
                                            optional = 1;
#line 2735
                                            trim_sector_ranges_count = i + 1;
#line 2723
                                            i ++;
                                            }
                                          }
                                          while_break___0: /* CIL Label */ ;
                                          }
                                        } else {
                                          {
#line 2737
                                          tmp___13 = strcasecmp((char const   *)name,
                                                                "write-sector");
                                          }
#line 2737
                                          if (0 == tmp___13) {
                                            {
#line 2738
                                            write_sector = 1;
#line 2739
                                            get_u64_parm(0, (char const   )0, (int *)((void *)0),
                                                         & write_sector_addr, 0U,
                                                         (__u64 )lba_limit, (char const   *)name,
                                                         lba_emsg);
                                            }
                                          } else {
                                            {
#line 2737
                                            tmp___14 = strcasecmp((char const   *)name,
                                                                  "repair-sector");
                                            }
#line 2737
                                            if (0 == tmp___14) {
                                              {
#line 2738
                                              write_sector = 1;
#line 2739
                                              get_u64_parm(0, (char const   )0, (int *)((void *)0),
                                                           & write_sector_addr, 0U,
                                                           (__u64 )lba_limit, (char const   *)name,
                                                           lba_emsg);
                                              }
                                            } else {
                                              {
#line 2740
                                              tmp___12 = strcasecmp((char const   *)name,
                                                                    "read-sector");
                                              }
#line 2740
                                              if (0 == tmp___12) {
                                                {
#line 2741
                                                read_sector = 1;
#line 2742
                                                get_u64_parm(0, (char const   )0,
                                                             (int *)((void *)0), & read_sector_addr,
                                                             0U, (__u64 )lba_limit,
                                                             (char const   *)name,
                                                             lba_emsg);
                                                }
                                              } else {
                                                {
#line 2743
                                                tmp___11 = strcasecmp((char const   *)name,
                                                                      "Istdout");
                                                }
#line 2743
                                                if (0 == tmp___11) {
#line 2744
                                                  do_IDentity = 2;
                                                } else {
                                                  {
#line 2745
                                                  tmp___10 = strcasecmp((char const   *)name,
                                                                        "security-mode");
                                                  }
#line 2745
                                                  if (0 == tmp___10) {
#line 2746
                                                    if (argc) {
                                                      {
#line 2746
                                                      tmp___5 = __ctype_b_loc();
                                                      }
#line 2746
                                                      if ((int const   )*(*tmp___5 + (int )*(*argv)) & 1024) {
#line 2747
                                                        tmp___4 = argv;
#line 2747
                                                        argv ++;
#line 2747
                                                        argp = *tmp___4;
#line 2747
                                                        argc --;
#line 2748
                                                        if ((int )*argp == 109) {
#line 2749
                                                          security_mode = 1;
                                                        } else
#line 2750
                                                        if ((int )*argp == 104) {
#line 2751
                                                          security_mode = 0;
                                                        } else {
                                                          {
#line 2753
                                                          security_help(22);
                                                          }
                                                        }
                                                        {
#line 2754
                                                        while (1) {
                                                          while_continue___1: /* CIL Label */ ;
#line 2754
                                                          if (! *argp) {
#line 2754
                                                            goto while_break___1;
                                                          }
#line 2754
                                                          argp ++;
                                                        }
                                                        while_break___1: /* CIL Label */ ;
                                                        }
                                                      }
                                                    }
#line 2756
                                                    num_flags_processed --;
                                                  } else {
                                                    {
#line 2757
                                                    tmp___9 = strcasecmp((char const   *)name,
                                                                         "user-master");
                                                    }
#line 2757
                                                    if (0 == tmp___9) {
#line 2758
                                                      if (argc) {
                                                        {
#line 2758
                                                        tmp___7 = __ctype_b_loc();
                                                        }
#line 2758
                                                        if ((int const   )*(*tmp___7 + (int )*(*argv)) & 1024) {
#line 2759
                                                          tmp___6 = argv;
#line 2759
                                                          argv ++;
#line 2759
                                                          argp = *tmp___6;
#line 2759
                                                          argc --;
#line 2760
                                                          if ((int )*argp == 117) {
#line 2761
                                                            security_master = 0;
                                                          } else
#line 2762
                                                          if ((int )*argp == 109) {
#line 2763
                                                            security_master = 1;
                                                          } else {
                                                            {
#line 2765
                                                            security_help(22);
                                                            }
                                                          }
                                                          {
#line 2766
                                                          while (1) {
                                                            while_continue___2: /* CIL Label */ ;
#line 2766
                                                            if (! *argp) {
#line 2766
                                                              goto while_break___2;
                                                            }
#line 2766
                                                            argp ++;
                                                          }
                                                          while_break___2: /* CIL Label */ ;
                                                          }
                                                        }
                                                      }
#line 2768
                                                      num_flags_processed --;
                                                    } else {
                                                      {
#line 2769
                                                      tmp___8 = strcasecmp((char const   *)name,
                                                                           "security-freeze");
                                                      }
#line 2769
                                                      if (0 == tmp___8) {
#line 2770
                                                        security_freeze = 1;
                                                      } else {
                                                        {
#line 2772
                                                        handle_standalone_longarg(name);
                                                        }
#line 2773
                                                        return (1);
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 2775
  return (0);
}
}
#line 2778 "/home/june/repo/benchmarks/collector/temp/hdparm-9.43/hdparm.c"
int main(int _argc , char **_argv ) 
{ 
  int no_more_flags ;
  int disallow_flags ;
  char c ;
  char name[32] ;
  char *tmp ;
  char **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmpstr ;
  char **tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  char *tmpstr___0 ;
  char **tmp___7 ;
  unsigned short const   **tmp___8 ;
  char *tmp___9 ;
  unsigned short const   **tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
  {
#line 2780
  no_more_flags = 0;
#line 2780
  disallow_flags = 0;
#line 2784
  argc = _argc;
#line 2785
  argv = _argv;
#line 2786
  argp = (char *)((void *)0);
#line 2788
  tmp = strrchr((char const   *)*argv, '/');
#line 2788
  progname = tmp;
  }
#line 2788
  if ((unsigned long )progname == (unsigned long )((void *)0)) {
#line 2789
    progname = *argv;
  } else {
#line 2791
    progname ++;
  }
#line 2792
  argv ++;
#line 2794
  argc --;
#line 2794
  if (! argc) {
    {
#line 2795
    usage_help(6, 22);
    }
  }
  {
#line 2796
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2796
    tmp___12 = argc;
#line 2796
    argc --;
#line 2796
    if (! tmp___12) {
#line 2796
      goto while_break;
    }
#line 2797
    tmp___0 = argv;
#line 2797
    argv ++;
#line 2797
    argp = *tmp___0;
#line 2798
    if (no_more_flags) {
#line 2798
      goto _L;
    } else
#line 2798
    if ((int )*(argp + 0) != 45) {
      _L: /* CIL Label */ 
#line 2799
      if (! num_flags_processed) {
#line 2800
        do_defaults = 1;
      }
      {
#line 2801
      process_dev(argp);
      }
#line 2802
      goto while_continue;
    }
    {
#line 2804
    tmp___1 = strcmp((char const   *)argp, "--");
    }
#line 2804
    if (0 == tmp___1) {
#line 2805
      no_more_flags = 1;
#line 2806
      goto while_continue;
    }
#line 2808
    if (disallow_flags) {
      {
#line 2809
      usage_help(7, 22);
      }
    }
#line 2810
    argp ++;
#line 2810
    if (! *argp) {
      {
#line 2811
      usage_help(8, 22);
      }
    }
    {
#line 2812
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2812
      if (argp) {
#line 2812
        tmp___11 = argp;
#line 2812
        argp ++;
#line 2812
        c = *tmp___11;
#line 2812
        if (! c) {
#line 2812
          goto while_break___0;
        }
      } else {
#line 2812
        goto while_break___0;
      }
      {
#line 2814
      if ((int )c == 97) {
#line 2814
        goto case_97;
      }
#line 2815
      if ((int )c == 65) {
#line 2815
        goto case_65;
      }
#line 2816
      if ((int )c == 98) {
#line 2816
        goto case_98;
      }
#line 2817
      if ((int )c == 66) {
#line 2817
        goto case_66;
      }
#line 2818
      if ((int )c == 99) {
#line 2818
        goto case_99;
      }
#line 2819
      if ((int )c == 67) {
#line 2819
        goto case_67;
      }
#line 2820
      if ((int )c == 100) {
#line 2820
        goto case_100;
      }
#line 2821
      if ((int )c == 68) {
#line 2821
        goto case_68;
      }
#line 2822
      if ((int )c == 69) {
#line 2822
        goto case_69;
      }
#line 2823
      if ((int )c == 102) {
#line 2823
        goto case_102;
      }
#line 2824
      if ((int )c == 70) {
#line 2824
        goto case_70;
      }
#line 2825
      if ((int )c == 103) {
#line 2825
        goto case_103;
      }
#line 2826
      if ((int )c == 104) {
#line 2826
        goto case_104;
      }
#line 2827
      if ((int )c == 72) {
#line 2827
        goto case_72;
      }
#line 2828
      if ((int )c == 105) {
#line 2828
        goto case_105;
      }
#line 2829
      if ((int )c == 73) {
#line 2829
        goto case_73;
      }
#line 2830
      if ((int )c == 74) {
#line 2830
        goto case_74;
      }
#line 2831
      if ((int )c == 107) {
#line 2831
        goto case_107;
      }
#line 2832
      if ((int )c == 75) {
#line 2832
        goto case_75;
      }
#line 2833
      if ((int )c == 76) {
#line 2833
        goto case_76;
      }
#line 2834
      if ((int )c == 109) {
#line 2834
        goto case_109;
      }
#line 2835
      if ((int )c == 77) {
#line 2835
        goto case_77;
      }
#line 2836
      if ((int )c == 110) {
#line 2836
        goto case_110;
      }
#line 2837
      if ((int )c == 78) {
#line 2837
        goto case_78;
      }
#line 2838
      if ((int )c == 80) {
#line 2838
        goto case_80;
      }
#line 2839
      if ((int )c == 113) {
#line 2839
        goto case_113;
      }
#line 2840
      if ((int )c == 81) {
#line 2840
        goto case_81;
      }
#line 2841
      if ((int )c == 115) {
#line 2841
        goto case_115;
      }
#line 2842
      if ((int )c == 83) {
#line 2842
        goto case_83;
      }
#line 2843
      if ((int )c == 114) {
#line 2843
        goto case_114;
      }
#line 2844
      if ((int )c == 82) {
#line 2844
        goto case_82;
      }
#line 2845
      if ((int )c == 116) {
#line 2845
        goto case_116;
      }
#line 2846
      if ((int )c == 84) {
#line 2846
        goto case_84;
      }
#line 2847
      if ((int )c == 117) {
#line 2847
        goto case_117;
      }
#line 2848
      if ((int )c == 118) {
#line 2848
        goto case_118;
      }
#line 2849
      if ((int )c == 86) {
#line 2849
        goto case_86;
      }
#line 2850
      if ((int )c == 119) {
#line 2850
        goto case_119;
      }
#line 2851
      if ((int )c == 87) {
#line 2851
        goto case_87;
      }
#line 2852
      if ((int )c == 121) {
#line 2852
        goto case_121;
      }
#line 2853
      if ((int )c == 89) {
#line 2853
        goto case_89;
      }
#line 2854
      if ((int )c == 122) {
#line 2854
        goto case_122;
      }
#line 2855
      if ((int )c == 90) {
#line 2855
        goto case_90;
      }
#line 2857
      if ((int )c == 45) {
#line 2857
        goto case_45;
      }
#line 2862
      if ((int )c == 112) {
#line 2862
        goto case_112;
      }
#line 2868
      if ((int )c == 88) {
#line 2868
        goto case_88;
      }
#line 2877
      goto switch_default;
      case_97: /* CIL Label */ 
      {
#line 2814
      numeric_parm((char )'a', "filesystem-read-ahead", & fsreadahead, & set_fsreadahead,
                   & get_fsreadahead, 0, 2048, 0);
      }
#line 2814
      goto switch_break;
      case_65: /* CIL Label */ 
      {
#line 2815
      numeric_parm((char )'A', "look-ahead", & lookahead, & set_lookahead, & get_lookahead,
                   0, 1, 0);
      }
#line 2815
      goto switch_break;
      case_98: /* CIL Label */ 
      {
#line 2816
      numeric_parm((char )'b', "bus-state", & busstate, & set_busstate, & get_busstate,
                   0, 2, 0);
      }
#line 2816
      goto switch_break;
      case_66: /* CIL Label */ 
      {
#line 2817
      numeric_parm((char )'B', "power-management-mode", & apmmode, & set_apmmode,
                   & get_apmmode, 0, 255, 0);
      }
#line 2817
      goto switch_break;
      case_99: /* CIL Label */ 
      {
#line 2818
      numeric_parm((char )'c', "32-bit-IO", & io32bit, & set_io32bit, & get_io32bit,
                   0, 3, 0);
      }
#line 2818
      goto switch_break;
      case_67: /* CIL Label */ 
#line 2819
      get_powermode = noisy;
#line 2819
      noisy = 1;
#line 2819
      set_powermode = 1;
#line 2819
      goto switch_break;
      case_100: /* CIL Label */ 
      {
#line 2820
      numeric_parm((char )'d', "dma-enable", & dma, & set_dma, & get_dma, 0, 1, 0);
      }
#line 2820
      goto switch_break;
      case_68: /* CIL Label */ 
      {
#line 2821
      numeric_parm((char )'D', "defects-management", & defects, & set_defects, & get_defects,
                   0, 1, 1);
      }
#line 2821
      goto switch_break;
      case_69: /* CIL Label */ 
      {
#line 2822
      numeric_parm((char )'E', "CDROM/DVD-speed", & cdromspeed, & set_cdromspeed,
                   & get_cdromspeed, 0, 255, 1);
      }
#line 2822
      goto switch_break;
      case_102: /* CIL Label */ 
#line 2823
      do_flush = 1;
#line 2823
      noisy = 1;
#line 2823
      goto switch_break;
      case_70: /* CIL Label */ 
#line 2824
      do_flush_wcache = 1;
#line 2824
      noisy = 1;
#line 2824
      goto switch_break;
      case_103: /* CIL Label */ 
#line 2825
      get_geom = 1;
#line 2825
      noisy = 1;
#line 2825
      goto switch_break;
      case_104: /* CIL Label */ 
      {
#line 2826
      usage_help(9, 0);
      }
#line 2826
      goto switch_break;
      case_72: /* CIL Label */ 
#line 2827
      get_hitachi_temp = noisy;
#line 2827
      noisy = 1;
#line 2827
      set_hitachi_temp = 1;
#line 2827
      goto switch_break;
      case_105: /* CIL Label */ 
#line 2828
      do_identity = 1;
#line 2828
      noisy = 1;
#line 2828
      goto switch_break;
      case_73: /* CIL Label */ 
#line 2829
      do_IDentity = 1;
#line 2829
      noisy = 1;
#line 2829
      goto switch_break;
      case_74: /* CIL Label */ 
      {
#line 2830
      numeric_parm((char )'J', "WDC-idle3-timeout", & wdidle3, & set_wdidle3, & get_wdidle3,
                   0, 300, 0);
      }
#line 2830
      goto switch_break;
      case_107: /* CIL Label */ 
      {
#line 2831
      numeric_parm((char )'k', "kernel-keep-settings", & keep, & set_keep, & get_keep,
                   0, 1, 0);
      }
#line 2831
      goto switch_break;
      case_75: /* CIL Label */ 
      {
#line 2832
      numeric_parm((char )'K', "drive-keep-settings", & dkeep, & set_dkeep, & get_dkeep,
                   0, 1, 1);
      }
#line 2832
      goto switch_break;
      case_76: /* CIL Label */ 
      {
#line 2833
      numeric_parm((char )'L', "door-lock", & doorlock, & set_doorlock, & get_doorlock,
                   0, 1, 1);
      }
#line 2833
      goto switch_break;
      case_109: /* CIL Label */ 
      {
#line 2834
      numeric_parm((char )'m', "multmode-count", & mult, & set_mult, & get_mult, 0,
                   64, 0);
      }
#line 2834
      goto switch_break;
      case_77: /* CIL Label */ 
      {
#line 2835
      numeric_parm((char )'M', "acoustic-management", & acoustic, & set_acoustic,
                   & get_acoustic, 0, 255, 0);
      }
#line 2835
      goto switch_break;
      case_110: /* CIL Label */ 
      {
#line 2836
      numeric_parm((char )'n', "ignore-write-errors", & nowerr, & set_nowerr, & get_nowerr,
                   0, 1, 0);
      }
#line 2836
      goto switch_break;
      case_78: /* CIL Label */ 
      {
#line 2837
      get_set_max_sectors_parms();
      }
#line 2837
      goto switch_break;
      case_80: /* CIL Label */ 
      {
#line 2838
      numeric_parm((char )'P', "prefetch", & prefetch, & set_prefetch, & get_prefetch,
                   0, 255, 1);
      }
#line 2838
      goto switch_break;
      case_113: /* CIL Label */ 
#line 2839
      quiet = 1;
#line 2839
      noisy = 0;
#line 2839
      goto switch_break;
      case_81: /* CIL Label */ 
      {
#line 2840
      numeric_parm((char )'Q', "queue-depth", & dma_q, & set_dma_q, & get_dma_q, 0,
                   1024, 0);
      }
#line 2840
      goto switch_break;
      case_115: /* CIL Label */ 
      {
#line 2841
      numeric_parm((char )'s', "powerup-in-standby", & powerup_in_standby, & set_powerup_in_standby,
                   & get_powerup_in_standby, 0, 1, 1);
      }
#line 2841
      goto switch_break;
      case_83: /* CIL Label */ 
      {
#line 2842
      numeric_parm((char )'S', "standby-interval", & standby, & set_standby, & get_standby,
                   0, 255, 1);
      }
#line 2842
      goto switch_break;
      case_114: /* CIL Label */ 
      {
#line 2843
      numeric_parm((char )'r', "read-only", & readonly, & set_readonly, & get_readonly,
                   0, 1, 0);
      }
#line 2843
      goto switch_break;
      case_82: /* CIL Label */ 
      {
#line 2844
      numeric_parm((char )'R', "write-read-verify", & write_read_verify, & set_write_read_verify,
                   & get_write_read_verify, 0, 3, 0);
      }
#line 2844
      goto switch_break;
      case_116: /* CIL Label */ 
#line 2845
      do_timings = 1;
#line 2845
      noisy = 1;
#line 2845
      goto switch_break;
      case_84: /* CIL Label */ 
#line 2846
      do_ctimings = 1;
#line 2846
      noisy = 1;
#line 2846
      goto switch_break;
      case_117: /* CIL Label */ 
      {
#line 2847
      numeric_parm((char )'u', "unmask-irq", & unmask, & set_unmask, & get_unmask,
                   0, 1, 0);
      }
#line 2847
      goto switch_break;
      case_118: /* CIL Label */ 
#line 2848
      do_defaults = 1;
#line 2848
      noisy = 1;
#line 2848
      goto switch_break;
      case_86: /* CIL Label */ 
      {
#line 2849
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s %s\n",
              progname, "v9.43");
#line 2849
      exit(0);
      }
      case_119: /* CIL Label */ 
#line 2850
      get_doreset = noisy;
#line 2850
      noisy = 1;
#line 2850
      set_doreset = 1;
#line 2850
      goto switch_break;
      case_87: /* CIL Label */ 
      {
#line 2851
      numeric_parm((char )'W', "write-cache", & wcache, & set_wcache, & get_wcache,
                   0, 1, 0);
      }
#line 2851
      goto switch_break;
      case_121: /* CIL Label */ 
#line 2852
      get_standbynow = noisy;
#line 2852
      noisy = 1;
#line 2852
      set_standbynow = 1;
#line 2852
      goto switch_break;
      case_89: /* CIL Label */ 
#line 2853
      get_sleepnow = noisy;
#line 2853
      noisy = 1;
#line 2853
      set_sleepnow = 1;
#line 2853
      goto switch_break;
      case_122: /* CIL Label */ 
#line 2854
      get_reread_partn = noisy;
#line 2854
      noisy = 1;
#line 2854
      set_reread_partn = 1;
#line 2854
      goto switch_break;
      case_90: /* CIL Label */ 
#line 2855
      get_seagate = noisy;
#line 2855
      noisy = 1;
#line 2855
      set_seagate = 1;
#line 2855
      goto switch_break;
      case_45: /* CIL Label */ 
      {
#line 2858
      tmp___2 = get_longarg();
      }
#line 2858
      if (tmp___2) {
#line 2859
        disallow_flags = 1;
      }
#line 2860
      goto switch_break;
      case_112: /* CIL Label */ 
#line 2863
      get_piomode = noisy;
#line 2864
      noisy = 1;
      {
#line 2865
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2865
        tmpstr = name;
#line 2865
        *(tmpstr + 0) = (char )'\000';
#line 2865
        if (! *argp) {
#line 2865
          if (argc) {
            {
#line 2865
            tmp___4 = __ctype_b_loc();
            }
#line 2865
            if ((int const   )*(*tmp___4 + (int )*(*argv)) & 8) {
#line 2865
              tmp___3 = argv;
#line 2865
              argv ++;
#line 2865
              argp = *tmp___3;
#line 2865
              argc --;
            }
          }
        }
        {
#line 2865
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 2865
          tmp___6 = __ctype_b_loc();
          }
#line 2865
          if ((int const   )*(*tmp___6 + (int )*argp) & 8) {
#line 2865
            if (! (tmpstr - name < 31L)) {
#line 2865
              goto while_break___2;
            }
          } else {
#line 2865
            goto while_break___2;
          }
#line 2865
          tmp___5 = argp;
#line 2865
          argp ++;
#line 2865
          *(tmpstr + 0) = *tmp___5;
#line 2865
          *(tmpstr + 1) = (char )'\000';
#line 2865
          tmpstr ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 2865
        piomode = translate_xfermode(name);
        }
#line 2865
        if (piomode == -1) {
#line 2865
          set_piomode = 0;
        } else {
#line 2865
          set_piomode = 1;
        }
#line 2865
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2866
      goto switch_break;
      case_88: /* CIL Label */ 
#line 2869
      get_xfermode = noisy;
#line 2870
      noisy = 1;
      {
#line 2871
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2871
        tmpstr___0 = name;
#line 2871
        *(tmpstr___0 + 0) = (char )'\000';
#line 2871
        if (! *argp) {
#line 2871
          if (argc) {
            {
#line 2871
            tmp___8 = __ctype_b_loc();
            }
#line 2871
            if ((int const   )*(*tmp___8 + (int )*(*argv)) & 8) {
#line 2871
              tmp___7 = argv;
#line 2871
              argv ++;
#line 2871
              argp = *tmp___7;
#line 2871
              argc --;
            }
          }
        }
        {
#line 2871
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 2871
          tmp___10 = __ctype_b_loc();
          }
#line 2871
          if ((int const   )*(*tmp___10 + (int )*argp) & 8) {
#line 2871
            if (! (tmpstr___0 - name < 31L)) {
#line 2871
              goto while_break___4;
            }
          } else {
#line 2871
            goto while_break___4;
          }
#line 2871
          tmp___9 = argp;
#line 2871
          argp ++;
#line 2871
          *(tmpstr___0 + 0) = *tmp___9;
#line 2871
          *(tmpstr___0 + 1) = (char )'\000';
#line 2871
          tmpstr___0 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 2871
        xfermode_requested = translate_xfermode(name);
        }
#line 2871
        if (xfermode_requested == -1) {
#line 2871
          set_xfermode = 0;
        } else {
#line 2871
          set_xfermode = 1;
        }
#line 2871
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2872
      if (! set_xfermode) {
        {
#line 2873
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-X: missing value\n");
        }
      }
#line 2874
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 2878
      usage_help(10, 22);
      }
      switch_break: /* CIL Label */ ;
      }
#line 2880
      num_flags_processed ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2882
    if (! argc) {
      {
#line 2883
      usage_help(11, 22);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2885
  return (0);
}
}
