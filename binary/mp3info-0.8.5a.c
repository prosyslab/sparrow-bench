/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 40 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.h"
struct __anonstruct_mp3header_54 {
   unsigned long sync ;
   unsigned int version ;
   unsigned int layer ;
   unsigned int crc ;
   unsigned int bitrate ;
   unsigned int freq ;
   unsigned int padding ;
   unsigned int extension ;
   unsigned int mode ;
   unsigned int mode_extension ;
   unsigned int copyright ;
   unsigned int original ;
   unsigned int emphasis ;
};
#line 40 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.h"
typedef struct __anonstruct_mp3header_54 mp3header;
#line 56 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.h"
struct __anonstruct_id3tag_55 {
   char title[31] ;
   char artist[31] ;
   char album[31] ;
   char year[5] ;
   char comment[31] ;
   unsigned char track[1] ;
   unsigned char genre[1] ;
};
#line 56 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.h"
typedef struct __anonstruct_id3tag_55 id3tag;
#line 66 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.h"
struct __anonstruct_mp3info_56 {
   char *filename ;
   FILE *file ;
   off_t datasize ;
   int header_isvalid ;
   mp3header header ;
   int id3_isvalid ;
   id3tag id3 ;
   int vbr ;
   float vbr_average ;
   int seconds ;
   int frames ;
   int badframes ;
};
#line 66 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.h"
typedef struct __anonstruct_mp3info_56 mp3info;
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 358
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 152 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 674 "/usr/include/curses.h"
extern int mvprintw(int  , int  , char const   *  , ...) ;
#line 1390
extern int COLS ;
#line 84 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.h"
int header_layer(mp3header *h ) ;
#line 85
int header_bitrate(mp3header *h ) ;
#line 92
int header_frequency(mp3header *h ) ;
#line 93
char *header_emphasis(mp3header *h ) ;
#line 94
char *header_mode(mp3header *h ) ;
#line 30 "/home/wheatley/newnew/temp/mp3info-0.8.5a/textfunc.h"
void CenterText(int line , char *text ) ;
#line 34
void display_help(void) ;
#line 35
void display_genres(int *alphagenreindex___0 , char **typegenre___0 ) ;
#line 36
unsigned int get_genre(char *genre ) ;
#line 38
void translate_escapes(char *string ) ;
#line 39
void determine_tasks(char *format_string , int *want_id3 , int *scantype , int *fullscan_vbr ,
                     int vbr_report ) ;
#line 40
void format_output(char *format_string , mp3info *mp3 , int vbr_report ) ;
#line 109 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3info.h"
char *typegenre[149] ;
#line 28 "/home/wheatley/newnew/temp/mp3info-0.8.5a/textfunc.c"
char *layer_text[3]  = {      (char *)"I",      (char *)"II",      (char *)"III"};
#line 36 "/home/wheatley/newnew/temp/mp3info-0.8.5a/textfunc.c"
void CenterText(int line , char *text ) 
{ 
  size_t tmp ;

  {
  {
#line 37
  tmp = strlen((char const   *)text);
#line 37
  mvprintw(line, COLS / 2 - (int )tmp / 2, (char const   *)text);
  }
#line 38
  return;
}
}
#line 42 "/home/wheatley/newnew/temp/mp3info-0.8.5a/textfunc.c"
int xtoi(char *string ) 
{ 
  char chr ;
  int tmp ;

  {
  {
#line 43
  tmp = toupper((int )*(string + 0));
#line 43
  chr = (char )tmp;
  }
#line 45
  if ((int )chr > 57) {
#line 46
    return (((int )chr - 65) + 10);
  } else {
#line 48
    return ((int )chr - 48);
  }
}
}
#line 57 "/home/wheatley/newnew/temp/mp3info-0.8.5a/textfunc.c"
void display_help(void) 
{ 


  {
  {
#line 59
  printf((char const   */* __restrict  */)"%s %s\n\nUSAGE:\n\n", "MP3Info 0.8.5a",
         "Copyright (C) 2006 Cedric Tefft and Ricardo Cerqueira");
#line 60
  printf((char const   */* __restrict  */)"\tmp3info [ -h | -G ]\n\n\tmp3info [-x] [-F] [-r a|m|v] [-p FORMAT_STRING] file(s)\n\n\tmp3info [-d] file(s)\n\n\tmp3info [-i]  [-t title] [-a artist] [-l album] [-y year]\n\t\t[-c comment] [-n track] [-g genre] file(s)\n\nOPTIONS\n\t-a artist\tSpecify ID3 artist name\n\t-c comment\tSpecify ID3 comment\n\t-g genre\tSpecify ID3 genre (use -G for genre list)\n\t-l album\tSpecify ID3 album name\n\t-n track\tSpecify ID3 v1.1 track number\n\t-t title\tSpecify ID3 track title\n\t-y year\t\tSpecify ID3 copyright year\n\n\t-G\t\tDisplay valid genres\n\t-h\t\tDisplay this help page\n\t-x\t\tDisplay technical attributes of the MP3 file\n\t-r a|m|v\tReport bit rate of (VBR) files as:\n\t\ta - Average bit rate (float)\n\t\tm - Median bit rate (integer)\n\t\tv - Simply  use  the  word \'Variable\' (string) [default]\n\n\t-i\t\tEdit ID3  tag  interactively\n\t-d\t\tDelete ID3 tag (if one exists)\n\t-f\t\tForce processing if file is not a standard MP3\n\t-F\t\tFull Scan (see man page for details)\n\n\n\t-p \"FORMAT_STRING\" Print FORMAT_STRING with substitutions\n\n\t\tConversion Specifiers\n\n\t\t%%f\tFilename without the path (string)\n\t\t%%F\tFilename with the path (string)\n\t\t%%k\tFile size in KB (integer)\n\n\t\t%%a\tArtist (string)\n\t\t%%c\tComment (string)\n\t\t%%g\tMusical genre (string)\n\t\t%%G\tMusical genre (integer)\n\t\t%%l\tAlbum name (string)\n\t\t%%n\tTrack (integer)\n\t\t%%t\tTrack Title (string)\n\t\t%%y\tYear (string)\n\n\t\t%%C\tCopyright flag (string)\n\t\t%%e\tEmphasis (string)\n\t\t%%E\tCRC Error protection (string)\n\t\t%%L\tMPEG Layer (string)\n\t\t%%O\tOriginal material flag (string)\n\t\t%%o\tStereo/mono mode (string)\n\t\t%%p\tPadding (string)\n\t\t%%v\tMPEG Version (float)\n\n\t\t%%u\tNumber of good audio frames (integer)\n\t\t%%b\tNumber of corrupt audio frames (integer)\n\t\t%%Q\tSampling frequency in Hz (integer)\n\t\t%%q\tSampling frequency in kHz (integer)\n\t\t%%r\tBit  Rate  in  kbps  (see also \'-r\')\n\n\t\t%%m\tPlaying time: minutes only (integer)\n\t\t%%s\tPlaying time: seconds only (integer)\n\t\t%%S\tTotal playing time in seconds (integer)\n\n\t\t%%%%\tA single percent sign\n\n\t\tEscape Sequences\n\n\t\t\\n\tNewline\n\t\t\\t\tHorizontal tab\n\t\t\\v\tVertical tab\n\t\t\\b\tBackspace\n\t\t\\r\tCarriage Return\n\t\t\\f\tForm Feed\n\t\t\\a\tAudible Alert (terminal bell)\n\t\t\\xhh\tAny  arbitrary character specified by the\n\t\t\thexidecimal number hh\n\t\t\\ooo\tAny arbitrary character specified by  the\n\t\t\toctal number ooo\n\t\t\\\\\tA single backslash character\n\nThis help screen is only a summary of command-line switches\nSee the man page for complete documentation.\n\n");
  }
#line 130
  return;
}
}
#line 132 "/home/wheatley/newnew/temp/mp3info-0.8.5a/textfunc.c"
void display_genres(int *alphagenreindex___0 , char **typegenre___0 ) 
{ 
  int i ;
  int j ;
  int index___0 ;

  {
  {
#line 134
  printf((char const   */* __restrict  */)"Extended MP3 ID3 Genres\n=======================\n");
#line 135
  i = 0;
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (i < 50)) {
#line 135
      goto while_break;
    }
#line 136
    j = 0;
    {
#line 136
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 136
      if (! (j < 3)) {
#line 136
        goto while_break___0;
      }
#line 137
      index___0 = 50 * j + i;
#line 138
      if (index___0 <= 147) {
        {
#line 139
        printf((char const   */* __restrict  */)"%3d %-21s ", *(alphagenreindex___0 + index___0),
               *(typegenre___0 + *(alphagenreindex___0 + index___0)));
        }
      }
#line 136
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 142
    printf((char const   */* __restrict  */)"\n");
#line 135
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  return;
}
}
#line 146 "/home/wheatley/newnew/temp/mp3info-0.8.5a/textfunc.c"
unsigned int get_genre(char *genre ) 
{ 
  int num_genre ;
  int tmp ;
  int tmp___0 ;

  {
#line 147
  num_genre = 0;
#line 149
  if ((int )*(genre + 0) == 0) {
#line 149
    return (255U);
  }
  {
#line 151
  sscanf((char const   */* __restrict  */)genre, (char const   */* __restrict  */)"%u",
         & num_genre);
  }
#line 152
  if (num_genre == 0) {
#line 153
    if ((int )*(genre + 0) != 48) {
      {
#line 154
      while (1) {
        while_continue: /* CIL Label */ ;
#line 154
        tmp___0 = num_genre;
#line 154
        num_genre ++;
#line 154
        if (! (tmp___0 <= 147)) {
#line 154
          goto while_break;
        }
        {
#line 155
        tmp = strcasecmp((char const   *)genre, (char const   *)typegenre[num_genre - 1]);
        }
#line 155
        if (! tmp) {
#line 156
          return ((unsigned int )(num_genre - 1));
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 159
      num_genre = 256;
    }
  }
#line 163
  if (num_genre < 0) {
#line 164
    num_genre = 256;
  } else
#line 163
  if (num_genre > 147) {
#line 164
    num_genre = 256;
  }
#line 166
  return ((unsigned int )num_genre);
}
}
#line 169 "/home/wheatley/newnew/temp/mp3info-0.8.5a/textfunc.c"
void text_genre(unsigned char *genre , char *buffer ) 
{ 
  int genre_num ;

  {
#line 170
  genre_num = (int )*(genre + 0);
#line 172
  if (genre_num <= 147) {
    {
#line 173
    sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)"%s",
            typegenre[genre_num]);
    }
  } else
#line 174
  if (genre_num < 255) {
    {
#line 175
    sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)"(UNKNOWN) [%d]",
            genre_num);
    }
  } else {
#line 177
    *(buffer + 0) = (char )'\000';
  }
#line 179
  return;
}
}
#line 181 "/home/wheatley/newnew/temp/mp3info-0.8.5a/textfunc.c"
void determine_tasks(char *format_string , int *want_id3 , int *scantype , int *fullscan_vbr ,
                     int vbr_report ) 
{ 
  char *format ;
  char *percent ;
  unsigned short const   **tmp ;

  {
#line 183
  format = format_string;
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 185
    percent = strchr((char const   *)format, '%');
    }
#line 185
    if (! percent) {
#line 185
      goto while_break;
    }
#line 186
    percent ++;
    {
#line 187
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 187
      if (*percent) {
#line 187
        if ((int )*(percent + 0) != 37) {
          {
#line 187
          tmp = __ctype_b_loc();
          }
#line 187
          if ((int const   )*(*tmp + (int )*percent) & 1024) {
#line 187
            goto while_break___0;
          }
        } else {
#line 187
          goto while_break___0;
        }
      } else {
#line 187
        goto while_break___0;
      }
#line 187
      percent ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 196
    if ((int )*(percent + 0) == 71) {
#line 196
      goto case_71;
    }
#line 196
    if ((int )*(percent + 0) == 103) {
#line 196
      goto case_71;
    }
#line 196
    if ((int )*(percent + 0) == 110) {
#line 196
      goto case_71;
    }
#line 196
    if ((int )*(percent + 0) == 99) {
#line 196
      goto case_71;
    }
#line 196
    if ((int )*(percent + 0) == 121) {
#line 196
      goto case_71;
    }
#line 196
    if ((int )*(percent + 0) == 108) {
#line 196
      goto case_71;
    }
#line 196
    if ((int )*(percent + 0) == 97) {
#line 196
      goto case_71;
    }
#line 196
    if ((int )*(percent + 0) == 116) {
#line 196
      goto case_71;
    }
#line 200
    if ((int )*(percent + 0) == 83) {
#line 200
      goto case_83;
    }
#line 200
    if ((int )*(percent + 0) == 117) {
#line 200
      goto case_83;
    }
#line 200
    if ((int )*(percent + 0) == 115) {
#line 200
      goto case_83;
    }
#line 200
    if ((int )*(percent + 0) == 109) {
#line 200
      goto case_83;
    }
#line 201
    if ((int )*(percent + 0) == 114) {
#line 201
      goto case_114;
    }
#line 211
    if ((int )*(percent + 0) == 111) {
#line 211
      goto case_111;
    }
#line 211
    if ((int )*(percent + 0) == 112) {
#line 211
      goto case_111;
    }
#line 211
    if ((int )*(percent + 0) == 76) {
#line 211
      goto case_111;
    }
#line 211
    if ((int )*(percent + 0) == 118) {
#line 211
      goto case_111;
    }
#line 211
    if ((int )*(percent + 0) == 79) {
#line 211
      goto case_111;
    }
#line 211
    if ((int )*(percent + 0) == 67) {
#line 211
      goto case_111;
    }
#line 211
    if ((int )*(percent + 0) == 69) {
#line 211
      goto case_111;
    }
#line 211
    if ((int )*(percent + 0) == 101) {
#line 211
      goto case_111;
    }
#line 211
    if ((int )*(percent + 0) == 81) {
#line 211
      goto case_111;
    }
#line 211
    if ((int )*(percent + 0) == 113) {
#line 211
      goto case_111;
    }
#line 214
    if ((int )*(percent + 0) == 98) {
#line 214
      goto case_98;
    }
#line 188
    goto switch_break;
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_116: /* CIL Label */ 
#line 196
    *want_id3 = 1;
#line 196
    goto switch_break;
    case_83: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_109: /* CIL Label */ 
#line 200
    *fullscan_vbr = 1;
    case_114: /* CIL Label */ 
#line 201
    if (vbr_report != 0) {
#line 201
      *fullscan_vbr = 1;
    }
    case_111: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_113: /* CIL Label */ 
#line 211
    if (*scantype != 2) {
#line 212
      *scantype = 1;
    }
#line 213
    goto switch_break;
    case_98: /* CIL Label */ 
#line 214
    *scantype = 2;
#line 214
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 216
    format = percent + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  return;
}
}
#line 221 "/home/wheatley/newnew/temp/mp3info-0.8.5a/textfunc.c"
void format_output(char *format_string , mp3info *mp3 , int vbr_report ) 
{ 
  char genre[40] ;
  unsigned int tmp ;
  char mod[1000] ;
  char *percent ;
  char *pos ;
  char *code ;
  char *format ;
  int modlen ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char const   *tmp___12 ;

  {
#line 223
  genre[0] = (char )'\000';
#line 223
  tmp = 1U;
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (tmp >= 40U) {
#line 223
      goto while_break;
    }
#line 223
    genre[tmp] = (char)0;
#line 223
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  format = format_string;
  {
#line 228
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 228
    percent = strchr((char const   *)format, '%');
    }
#line 228
    if (! percent) {
#line 228
      goto while_break___0;
    }
    {
#line 229
    *percent = (char)0;
#line 230
    printf((char const   */* __restrict  */)format);
#line 231
    *percent = (char )'%';
#line 232
    code = percent + 1;
    }
    {
#line 233
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 233
      if (*code) {
#line 233
        if ((int )*(code + 0) != 37) {
          {
#line 233
          tmp___0 = __ctype_b_loc();
          }
#line 233
          if ((int const   )*(*tmp___0 + (int )*code) & 1024) {
#line 233
            goto while_break___1;
          }
        } else {
#line 233
          goto while_break___1;
        }
      } else {
#line 233
        goto while_break___1;
      }
#line 233
      code ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 235
    if (*code) {
#line 236
      modlen = (int )((code - percent) + 1L);
#line 237
      if (modlen > 1000) {
        {
#line 238
        printf((char const   */* __restrict  */)"Format modifier beginning at position %d too long!\n",
               (int )(percent - format));
#line 239
        exit(5);
        }
      }
      {
#line 241
      strncpy((char */* __restrict  */)(mod), (char const   */* __restrict  */)percent,
              (size_t )modlen);
#line 242
      mod[modlen] = (char)0;
#line 243
      mod[modlen - 1] = (char )'s';
      }
      {
#line 245
      if ((int )*code == 116) {
#line 245
        goto case_116;
      }
#line 246
      if ((int )*code == 102) {
#line 246
        goto case_102;
      }
#line 249
      if ((int )*code == 70) {
#line 249
        goto case_70;
      }
#line 250
      if ((int )*code == 97) {
#line 250
        goto case_97;
      }
#line 251
      if ((int )*code == 108) {
#line 251
        goto case_108;
      }
#line 252
      if ((int )*code == 107) {
#line 252
        goto case_107;
      }
#line 253
      if ((int )*code == 121) {
#line 253
        goto case_121;
      }
#line 254
      if ((int )*code == 99) {
#line 254
        goto case_99;
      }
#line 255
      if ((int )*code == 110) {
#line 255
        goto case_110;
      }
#line 260
      if ((int )*code == 103) {
#line 260
        goto case_103;
      }
#line 265
      if ((int )*code == 71) {
#line 265
        goto case_71;
      }
#line 270
      if ((int )*code == 114) {
#line 270
        goto case_114;
      }
#line 282
      if ((int )*code == 113) {
#line 282
        goto case_113;
      }
#line 287
      if ((int )*code == 81) {
#line 287
        goto case_81;
      }
#line 292
      if ((int )*code == 101) {
#line 292
        goto case_101;
      }
#line 296
      if ((int )*code == 69) {
#line 296
        goto case_69;
      }
#line 300
      if ((int )*code == 67) {
#line 300
        goto case_67;
      }
#line 304
      if ((int )*code == 79) {
#line 304
        goto case_79;
      }
#line 308
      if ((int )*code == 109) {
#line 308
        goto case_109;
      }
#line 313
      if ((int )*code == 115) {
#line 313
        goto case_115;
      }
#line 318
      if ((int )*code == 83) {
#line 318
        goto case_83;
      }
#line 323
      if ((int )*code == 118) {
#line 323
        goto case_118;
      }
#line 328
      if ((int )*code == 76) {
#line 328
        goto case_76;
      }
#line 332
      if ((int )*code == 111) {
#line 332
        goto case_111;
      }
#line 336
      if ((int )*code == 112) {
#line 336
        goto case_112;
      }
#line 340
      if ((int )*code == 117) {
#line 340
        goto case_117;
      }
#line 345
      if ((int )*code == 98) {
#line 345
        goto case_98;
      }
#line 350
      if ((int )*code == 37) {
#line 350
        goto case_37;
      }
#line 351
      goto switch_default;
      case_116: /* CIL Label */ 
      {
#line 245
      printf((char const   */* __restrict  */)(mod), mp3->id3.title);
      }
#line 245
      goto switch_break;
      case_102: /* CIL Label */ 
      {
#line 246
      pos = strrchr((char const   *)mp3->filename, '/');
      }
#line 246
      if (pos) {
#line 246
        pos ++;
      } else {
#line 246
        pos = mp3->filename;
      }
      {
#line 248
      printf((char const   */* __restrict  */)(mod), pos);
      }
#line 248
      goto switch_break;
      case_70: /* CIL Label */ 
      {
#line 249
      printf((char const   */* __restrict  */)(mod), mp3->filename);
      }
#line 249
      goto switch_break;
      case_97: /* CIL Label */ 
      {
#line 250
      printf((char const   */* __restrict  */)(mod), mp3->id3.artist);
      }
#line 250
      goto switch_break;
      case_108: /* CIL Label */ 
      {
#line 251
      printf((char const   */* __restrict  */)(mod), mp3->id3.album);
      }
#line 251
      goto switch_break;
      case_107: /* CIL Label */ 
      {
#line 252
      mod[modlen - 1] = (char )'d';
#line 252
      printf((char const   */* __restrict  */)(mod), mp3->datasize / 1024L);
      }
#line 252
      goto switch_break;
      case_121: /* CIL Label */ 
      {
#line 253
      printf((char const   */* __restrict  */)(mod), mp3->id3.year);
      }
#line 253
      goto switch_break;
      case_99: /* CIL Label */ 
      {
#line 254
      printf((char const   */* __restrict  */)(mod), mp3->id3.comment);
      }
#line 254
      goto switch_break;
      case_110: /* CIL Label */ 
#line 255
      if (mp3->id3_isvalid) {
#line 255
        if (mp3->id3.track[0]) {
          {
#line 256
          mod[modlen - 1] = (char )'d';
#line 257
          printf((char const   */* __restrict  */)(mod), (int )mp3->id3.track[0]);
          }
        }
      }
#line 259
      goto switch_break;
      case_103: /* CIL Label */ 
#line 260
      if (mp3->id3_isvalid) {
        {
#line 261
        text_genre(mp3->id3.genre, genre);
#line 262
        printf((char const   */* __restrict  */)(mod), genre);
        }
      }
#line 264
      goto switch_break;
      case_71: /* CIL Label */ 
#line 265
      if (mp3->id3_isvalid) {
        {
#line 266
        mod[modlen - 1] = (char )'d';
#line 267
        printf((char const   */* __restrict  */)(mod), (int )mp3->id3.genre[0]);
        }
      }
#line 269
      goto switch_break;
      case_114: /* CIL Label */ 
#line 270
      if (mp3->header_isvalid) {
#line 271
        if (mp3->vbr) {
#line 271
          if (vbr_report == 0) {
            {
#line 272
            printf((char const   */* __restrict  */)(mod), "Variable");
            }
          } else {
#line 271
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 273
        if (vbr_report == 1) {
          {
#line 274
          mod[modlen - 1] = (char )'f';
#line 275
          printf((char const   */* __restrict  */)(mod), (double )mp3->vbr_average);
          }
        } else {
          {
#line 277
          mod[modlen - 1] = (char )'d';
#line 278
          tmp___1 = header_bitrate(& mp3->header);
#line 278
          printf((char const   */* __restrict  */)(mod), tmp___1);
          }
        }
      }
#line 281
      goto switch_break;
      case_113: /* CIL Label */ 
#line 282
      if (mp3->header_isvalid) {
        {
#line 283
        mod[modlen - 1] = (char )'d';
#line 284
        tmp___2 = header_frequency(& mp3->header);
#line 284
        printf((char const   */* __restrict  */)(mod), tmp___2 / 1000);
        }
      }
#line 286
      goto switch_break;
      case_81: /* CIL Label */ 
#line 287
      if (mp3->header_isvalid) {
        {
#line 288
        mod[modlen - 1] = (char )'d';
#line 289
        tmp___3 = header_frequency(& mp3->header);
#line 289
        printf((char const   */* __restrict  */)(mod), tmp___3);
        }
      }
#line 291
      goto switch_break;
      case_101: /* CIL Label */ 
#line 292
      if (mp3->header_isvalid) {
        {
#line 293
        tmp___4 = header_emphasis(& mp3->header);
#line 293
        printf((char const   */* __restrict  */)(mod), tmp___4);
        }
      }
#line 295
      goto switch_break;
      case_69: /* CIL Label */ 
#line 296
      if (mp3->header_isvalid) {
#line 297
        if (! mp3->header.crc) {
#line 297
          tmp___5 = "Yes";
        } else {
#line 297
          tmp___5 = "No";
        }
        {
#line 297
        printf((char const   */* __restrict  */)(mod), tmp___5);
        }
      }
#line 299
      goto switch_break;
      case_67: /* CIL Label */ 
#line 300
      if (mp3->header_isvalid) {
#line 301
        if (mp3->header.copyright) {
#line 301
          tmp___6 = "Yes";
        } else {
#line 301
          tmp___6 = "No";
        }
        {
#line 301
        printf((char const   */* __restrict  */)(mod), tmp___6);
        }
      }
#line 303
      goto switch_break;
      case_79: /* CIL Label */ 
#line 304
      if (mp3->header_isvalid) {
#line 305
        if (mp3->header.original) {
#line 305
          tmp___7 = "Yes";
        } else {
#line 305
          tmp___7 = "No";
        }
        {
#line 305
        printf((char const   */* __restrict  */)(mod), tmp___7);
        }
      }
#line 307
      goto switch_break;
      case_109: /* CIL Label */ 
#line 308
      if (mp3->header_isvalid) {
        {
#line 309
        mod[modlen - 1] = (char )'d';
#line 310
        printf((char const   */* __restrict  */)(mod), mp3->seconds / 60);
        }
      }
#line 312
      goto switch_break;
      case_115: /* CIL Label */ 
#line 313
      if (mp3->header_isvalid) {
        {
#line 314
        mod[modlen - 1] = (char )'d';
#line 315
        printf((char const   */* __restrict  */)(mod), mp3->seconds % 60);
        }
      }
#line 317
      goto switch_break;
      case_83: /* CIL Label */ 
#line 318
      if (mp3->header_isvalid) {
        {
#line 319
        mod[modlen - 1] = (char )'d';
#line 320
        printf((char const   */* __restrict  */)(mod), mp3->seconds);
        }
      }
#line 322
      goto switch_break;
      case_118: /* CIL Label */ 
#line 323
      if (mp3->header_isvalid) {
#line 324
        mod[modlen - 1] = (char )'f';
#line 325
        if (mp3->header.version) {
#line 325
          if (mp3->header.version == 2U) {
#line 325
            tmp___8 = 2.5;
          } else {
#line 325
            tmp___8 = 1.0;
          }
#line 325
          tmp___9 = tmp___8;
        } else {
#line 325
          tmp___9 = 2.0;
        }
        {
#line 325
        printf((char const   */* __restrict  */)(mod), tmp___9);
        }
      }
#line 327
      goto switch_break;
      case_76: /* CIL Label */ 
#line 328
      if (mp3->header_isvalid) {
        {
#line 329
        tmp___10 = header_layer(& mp3->header);
#line 329
        printf((char const   */* __restrict  */)(mod), layer_text[tmp___10 - 1]);
        }
      }
#line 331
      goto switch_break;
      case_111: /* CIL Label */ 
#line 332
      if (mp3->header_isvalid) {
        {
#line 333
        tmp___11 = header_mode(& mp3->header);
#line 333
        printf((char const   */* __restrict  */)(mod), tmp___11);
        }
      }
#line 335
      goto switch_break;
      case_112: /* CIL Label */ 
#line 336
      if (mp3->header_isvalid) {
#line 337
        if (mp3->header.padding) {
#line 337
          tmp___12 = "Yes";
        } else {
#line 337
          tmp___12 = "No";
        }
        {
#line 337
        printf((char const   */* __restrict  */)(mod), tmp___12);
        }
      }
#line 339
      goto switch_break;
      case_117: /* CIL Label */ 
#line 340
      if (mp3->header_isvalid) {
        {
#line 341
        mod[modlen - 1] = (char )'d';
#line 342
        printf((char const   */* __restrict  */)(mod), mp3->frames);
        }
      }
#line 344
      goto switch_break;
      case_98: /* CIL Label */ 
#line 345
      if (mp3->header_isvalid) {
        {
#line 346
        mod[modlen - 1] = (char )'d';
#line 347
        printf((char const   */* __restrict  */)(mod), mp3->badframes);
        }
      }
#line 349
      goto switch_break;
      case_37: /* CIL Label */ 
      {
#line 350
      printf((char const   */* __restrict  */)"%%");
      }
#line 350
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 351
      code = percent + 1;
#line 351
      printf((char const   */* __restrict  */)"%%%c", (int )*code);
      }
#line 351
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 353
      format = code + 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 357
  printf((char const   */* __restrict  */)format);
  }
#line 358
  return;
}
}
#line 362 "/home/wheatley/newnew/temp/mp3info-0.8.5a/textfunc.c"
void translate_escapes(char *string ) 
{ 
  char *read___0 ;
  char *write___0 ;
  int val ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  unsigned short const   **tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  unsigned short const   **tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;

  {
#line 363
  read___0 = string;
#line 364
  write___0 = string;
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (! *read___0) {
#line 367
      goto while_break;
    }
#line 368
    if ((int )*read___0 == 92) {
#line 369
      read___0 ++;
      {
#line 371
      if ((int )*read___0 == 110) {
#line 371
        goto case_110;
      }
#line 372
      if ((int )*read___0 == 116) {
#line 372
        goto case_116;
      }
#line 373
      if ((int )*read___0 == 118) {
#line 373
        goto case_118;
      }
#line 374
      if ((int )*read___0 == 98) {
#line 374
        goto case_98;
      }
#line 375
      if ((int )*read___0 == 114) {
#line 375
        goto case_114;
      }
#line 376
      if ((int )*read___0 == 102) {
#line 376
        goto case_102;
      }
#line 377
      if ((int )*read___0 == 97) {
#line 377
        goto case_97;
      }
#line 379
      if ((int )*read___0 == 120) {
#line 379
        goto case_120;
      }
#line 379
      if ((int )*read___0 == 88) {
#line 379
        goto case_120;
      }
#line 384
      goto switch_default;
      case_110: /* CIL Label */ 
#line 371
      tmp = write___0;
#line 371
      write___0 ++;
#line 371
      *tmp = (char )'\n';
#line 371
      read___0 ++;
#line 371
      goto switch_break;
      case_116: /* CIL Label */ 
#line 372
      tmp___0 = write___0;
#line 372
      write___0 ++;
#line 372
      *tmp___0 = (char )'\t';
#line 372
      read___0 ++;
#line 372
      goto switch_break;
      case_118: /* CIL Label */ 
#line 373
      tmp___1 = write___0;
#line 373
      write___0 ++;
#line 373
      *tmp___1 = (char )'\v';
#line 373
      read___0 ++;
#line 373
      goto switch_break;
      case_98: /* CIL Label */ 
#line 374
      tmp___2 = write___0;
#line 374
      write___0 ++;
#line 374
      *tmp___2 = (char )'\b';
#line 374
      read___0 ++;
#line 374
      goto switch_break;
      case_114: /* CIL Label */ 
#line 375
      tmp___3 = write___0;
#line 375
      write___0 ++;
#line 375
      *tmp___3 = (char )'\r';
#line 375
      read___0 ++;
#line 375
      goto switch_break;
      case_102: /* CIL Label */ 
#line 376
      tmp___4 = write___0;
#line 376
      write___0 ++;
#line 376
      *tmp___4 = (char )'\f';
#line 376
      read___0 ++;
#line 376
      goto switch_break;
      case_97: /* CIL Label */ 
#line 377
      tmp___5 = write___0;
#line 377
      write___0 ++;
#line 377
      *tmp___5 = (char )'\a';
#line 377
      read___0 ++;
#line 377
      goto switch_break;
      case_120: /* CIL Label */ 
      case_88: /* CIL Label */ 
      {
#line 379
      read___0 ++;
#line 380
      val = 0;
#line 381
      tmp___7 = __ctype_b_loc();
      }
#line 381
      if ((int const   )*(*tmp___7 + (int )*read___0) & 4096) {
        {
#line 381
        tmp___6 = read___0;
#line 381
        read___0 ++;
#line 381
        val = xtoi(tmp___6);
        }
      }
      {
#line 382
      tmp___10 = __ctype_b_loc();
      }
#line 382
      if ((int const   )*(*tmp___10 + (int )*read___0) & 4096) {
        {
#line 382
        tmp___8 = read___0;
#line 382
        read___0 ++;
#line 382
        tmp___9 = xtoi(tmp___8);
#line 382
        val = val * 16 + tmp___9;
        }
      }
#line 383
      tmp___11 = write___0;
#line 383
      write___0 ++;
#line 383
      *tmp___11 = (char )(val % 256);
      switch_default: /* CIL Label */ 
#line 384
      if ((int )*read___0 <= 55) {
#line 384
        if ((int )*read___0 >= 48) {
          {
#line 385
          tmp___12 = read___0;
#line 385
          read___0 ++;
#line 385
          val = xtoi(tmp___12);
          }
#line 386
          if ((int )*read___0 <= 55) {
#line 386
            if ((int )*read___0 >= 48) {
              {
#line 386
              tmp___13 = read___0;
#line 386
              read___0 ++;
#line 386
              tmp___14 = xtoi(tmp___13);
#line 386
              val = val * 8 + tmp___14;
              }
            }
          }
#line 387
          if ((int )*read___0 <= 55) {
#line 387
            if ((int )*read___0 >= 48) {
              {
#line 387
              tmp___15 = read___0;
#line 387
              read___0 ++;
#line 387
              tmp___16 = xtoi(tmp___15);
#line 387
              val = val * 8 + tmp___16;
              }
            }
          }
#line 388
          tmp___17 = write___0;
#line 388
          write___0 ++;
#line 388
          *tmp___17 = (char )(val % 256);
        } else {
#line 384
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 390
        tmp___18 = write___0;
#line 390
        write___0 ++;
#line 390
        tmp___19 = read___0;
#line 390
        read___0 ++;
#line 390
        *tmp___18 = *tmp___19;
#line 390
        goto switch_break;
      }
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 394
      tmp___20 = write___0;
#line 394
      write___0 ++;
#line 394
      tmp___21 = read___0;
#line 394
      read___0 ++;
#line 394
      *tmp___20 = *tmp___21;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 398
  *write___0 = (char)0;
#line 399
  return;
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 587 "/usr/include/curses.h"
extern int cbreak(void) ;
#line 608
extern int echo(void) ;
#line 611
extern int endwin(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 642
extern int intrflush(WINDOW * , _Bool  ) ;
#line 647
extern int keypad(WINDOW * , _Bool  ) ;
#line 707
extern WINDOW *newwin(int  , int  , int  , int  ) ;
#line 711
extern int noecho(void) ;
#line 712
extern int nonl(void) ;
#line 799
extern int wborder(WINDOW * , chtype  , chtype  , chtype  , chtype  , chtype  , chtype  ,
                   chtype  , chtype  ) ;
#line 811
extern int wgetnstr(WINDOW * , char * , int  ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 826
extern int wprintw(WINDOW * , char const   *  , ...) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 1386
extern WINDOW *stdscr ;
#line 90 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.h"
char *unpad(char *string ) ;
#line 31 "/home/wheatley/newnew/temp/mp3info-0.8.5a/textfunc.h"
char *checkinput(int c , char *string , int length ) ;
#line 32
char *curs_addparam(WINDOW *win , int line , int length , char *buf ) ;
#line 114 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3info.h"
void tagedit_curs(char *filename , int filenum , int fileoutof , id3tag *tag ) ;
#line 34 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3curs.c"
char *checkinput(int c , char *string , int length ) 
{ 


  {
#line 35
  if (c == 3) {
    {
#line 35
    endwin();
#line 35
    exit(0);
    }
  }
#line 36
  return (string);
}
}
#line 43 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3curs.c"
char *curs_addparam(WINDOW *win , int line , int length , char *buf ) 
{ 
  int c ;
  char string[30] ;
  char *tmp ;

  {
  {
#line 47
  wmove(win, line, 16);
#line 48
  c = wgetnstr(win, string, length);
#line 49
  tmp = checkinput(c, string, length);
#line 49
  strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)tmp);
  }
#line 50
  return (buf);
}
}
#line 57 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3curs.c"
void tagedit_curs(char *filename , int filenum , int fileoutof , id3tag *tag ) 
{ 
  WINDOW *mainwin ;
  char line[50] ;
  char track_text[4] ;
  char *genre ;
  char genre_text[30] ;
  unsigned int track_num ;
  unsigned int genre_num ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;

  {
  {
#line 61
  line[0] = (char )'\000';
#line 63
  initscr();
#line 63
  cbreak();
#line 63
  noecho();
#line 64
  nonl();
#line 65
  mainwin = newwin(9, COLS, 5, 0);
#line 66
  intrflush(mainwin, (_Bool)0);
#line 67
  keypad(mainwin, (_Bool)1);
#line 68
  CenterText(1, (char *)"MP3Info 0.8.5a");
#line 73
  wborder(mainwin, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0,
          (chtype )0, (chtype )0);
#line 74
  wmove(mainwin, 1, 1);
#line 75
  wprintw(mainwin, "Song Title:    %s", tag->title);
#line 76
  wmove(mainwin, 2, 1);
#line 77
  wprintw(mainwin, "Artist Name:   %s", tag->artist);
#line 78
  wmove(mainwin, 3, 1);
#line 79
  wprintw(mainwin, "Album Name:    %s", tag->album);
#line 80
  wmove(mainwin, 4, 1);
#line 81
  wprintw(mainwin, "Year:          %s", tag->year);
#line 82
  wmove(mainwin, 5, 1);
#line 83
  wprintw(mainwin, "Comment:       %s", tag->comment);
#line 84
  wmove(mainwin, 6, 1);
  }
#line 85
  if ((int )tag->track[0] != 0) {
    {
#line 86
    sprintf((char */* __restrict  */)(track_text), (char const   */* __restrict  */)"%d",
            (int )tag->track[0]);
    }
  } else {
#line 88
    track_text[0] = (char )'\000';
  }
  {
#line 90
  wprintw(mainwin, "Track:         %s", track_text);
#line 91
  wmove(mainwin, 7, 1);
  }
#line 92
  if ((int )tag->genre[0] < 127) {
#line 93
    genre = typegenre[tag->genre[0]];
  } else {
#line 95
    genre = (char *)"";
  }
  {
#line 97
  strcpy((char */* __restrict  */)(genre_text), (char const   */* __restrict  */)genre);
#line 98
  wprintw(mainwin, "Genre:         %s", genre);
#line 99
  wmove(mainwin, 8, 4);
#line 100
  wprintw(mainwin, " (%d/%d) %s ", filenum, fileoutof, filename);
#line 105
  wmove(mainwin, 8, COLS - 22);
#line 106
  wprintw(mainwin, " Press ^C to quit ");
#line 108
  wrefresh(stdscr);
#line 109
  echo();
#line 110
  curs_addparam(mainwin, 1, 30, line);
#line 111
  tmp = strlen((char const   *)(line));
#line 111
  strncpy((char */* __restrict  */)(tag->title), (char const   */* __restrict  */)(line),
          tmp);
#line 112
  curs_addparam(mainwin, 2, 30, line);
#line 113
  tmp___0 = strlen((char const   *)(line));
#line 113
  strncpy((char */* __restrict  */)(tag->artist), (char const   */* __restrict  */)(line),
          tmp___0);
#line 114
  curs_addparam(mainwin, 3, 30, line);
#line 115
  tmp___1 = strlen((char const   *)(line));
#line 115
  strncpy((char */* __restrict  */)(tag->album), (char const   */* __restrict  */)(line),
          tmp___1);
#line 116
  curs_addparam(mainwin, 4, 4, line);
#line 117
  tmp___2 = strlen((char const   *)(line));
#line 117
  strncpy((char */* __restrict  */)(tag->year), (char const   */* __restrict  */)(line),
          tmp___2);
#line 118
  curs_addparam(mainwin, 5, 30, line);
#line 119
  tmp___3 = strlen((char const   *)(line));
#line 119
  strncpy((char */* __restrict  */)(tag->comment), (char const   */* __restrict  */)(line),
          tmp___3);
#line 120
  curs_addparam(mainwin, 6, 30, line);
#line 121
  tmp___4 = strlen((char const   *)(line));
#line 121
  tmp___8 = strlen((char const   *)(line));
#line 121
  tmp___9 = strlen((char const   *)(track_text));
  }
#line 121
  if (tmp___8 < tmp___9) {
#line 121
    tmp___7 = 0;
  } else {
#line 121
    tmp___7 = 1;
  }
  {
#line 121
  strncpy((char */* __restrict  */)(track_text), (char const   */* __restrict  */)(line),
          tmp___4 + (size_t )tmp___7);
#line 123
  curs_addparam(mainwin, 7, 30, line);
#line 124
  tmp___10 = strlen((char const   *)(line));
#line 124
  tmp___14 = strlen((char const   *)(line));
#line 124
  tmp___15 = strlen((char const   *)(genre_text));
  }
#line 124
  if (tmp___14 < tmp___15) {
#line 124
    tmp___13 = 0;
  } else {
#line 124
    tmp___13 = 1;
  }
  {
#line 124
  strncpy((char */* __restrict  */)(genre_text), (char const   */* __restrict  */)(line),
          tmp___10 + (size_t )tmp___13);
#line 126
  endwin();
#line 127
  tmp___16 = atoi((char const   *)(track_text));
#line 127
  track_num = (unsigned int )tmp___16;
  }
#line 127
  if (track_num < 256U) {
#line 128
    tag->track[0] = (unsigned char )track_num;
  } else {
    {
#line 130
    printf((char const   */* __restrict  */)"ERROR - \'%s\' is not a valid track number.\n",
           track_text);
    }
  }
  {
#line 132
  unpad(genre_text);
#line 133
  genre_num = get_genre(genre_text);
  }
#line 133
  if (genre_num < 256U) {
#line 134
    tag->genre[0] = (unsigned char )genre_num;
  } else {
    {
#line 136
    printf((char const   */* __restrict  */)"ERROR - \'%s\' is not a valid genre name or number.\nUse \'-G\' for a list of valid genres.\n",
           genre_text);
    }
  }
#line 139
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 82 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.h"
int get_header(FILE *file , mp3header *header ) ;
#line 83
int frame_length(mp3header *header ) ;
#line 86
int sameConstant(mp3header *h1 , mp3header *h2 ) ;
#line 87
int get_mp3_info(mp3info *mp3 , int scantype , int fullscan_vbr ) ;
#line 88
int get_id3(mp3info *mp3 ) ;
#line 89
char *pad(char *string , int length ) ;
#line 91
int write_tag(mp3info *mp3 ) ;
#line 95
int get_first_header(mp3info *mp3 , long startpos ) ;
#line 96
int get_next_header(mp3info *mp3 ) ;
#line 34 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.c"
int layer_tab[4]  = {      0,      3,      2,      1};
#line 36 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.c"
int frequencies[3][4]  = { {        22050,        24000,        16000,        50000}, 
   {        44100,        48000,        32000,        50000}, 
   {        11025,        12000,        8000,        50000}};
#line 42 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.c"
int bitrate[2][3][15]  = { { {          0,          32,          48,          56, 
                64,          80,          96,          112, 
                128,          144,          160,          176, 
                192,          224,          256}, 
     {          0,          8,          16,          24, 
                32,          40,          48,          56, 
                64,          80,          96,          112, 
                128,          144,          160}, 
     {          0,          8,          16,          24, 
                32,          40,          48,          56, 
                64,          80,          96,          112, 
                128,          144,          160}}, 
   { {          0,          32,          64,          96, 
                128,          160,          192,          224, 
                256,          288,          320,          352, 
                384,          416,          448}, 
     {          0,          32,          48,          56, 
                64,          80,          96,          112, 
                128,          160,          192,          224, 
                256,          320,          384}, 
     {          0,          32,          40,          48, 
                56,          64,          80,          96, 
                112,          128,          160,          192, 
                224,          256,          320}}};
#line 57 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.c"
int frame_size_index[3]  = {      24000,      72000,      72000};
#line 60 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.c"
char *mode_text[4]  = {      (char *)"stereo",      (char *)"joint stereo",      (char *)"dual channel",      (char *)"mono"};
#line 64 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.c"
char *emphasis_text[4]  = {      (char *)"none",      (char *)"50/15 microsecs",      (char *)"reserved",      (char *)"CCITT J 17"};
#line 69 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.c"
int get_mp3_info(mp3info *mp3 , int scantype , int fullscan_vbr ) 
{ 
  int had_error ;
  int frame_type[15] ;
  float seconds ;
  float total_rate ;
  int frames ;
  int frame_types ;
  int frames_so_far ;
  int l ;
  int vbr_median ;
  int bitrate___0 ;
  int lastrate ;
  int counter ;
  mp3header header ;
  struct stat filestat ;
  off_t sample_pos ;
  off_t data_start ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 71
  had_error = 0;
#line 72
  frame_type[0] = 0;
#line 72
  frame_type[1] = 0;
#line 72
  frame_type[2] = 0;
#line 72
  frame_type[3] = 0;
#line 72
  frame_type[4] = 0;
#line 72
  frame_type[5] = 0;
#line 72
  frame_type[6] = 0;
#line 72
  frame_type[7] = 0;
#line 72
  frame_type[8] = 0;
#line 72
  frame_type[9] = 0;
#line 72
  frame_type[10] = 0;
#line 72
  frame_type[11] = 0;
#line 72
  frame_type[12] = 0;
#line 72
  frame_type[13] = 0;
#line 72
  frame_type[14] = 0;
#line 73
  seconds = (float )0;
#line 73
  total_rate = (float )0;
#line 74
  frames = 0;
#line 74
  frame_types = 0;
#line 74
  frames_so_far = 0;
#line 75
  vbr_median = -1;
#line 77
  counter = 0;
#line 80
  data_start = (off_t )0;
#line 83
  stat((char const   */* __restrict  */)mp3->filename, (struct stat */* __restrict  */)(& filestat));
#line 84
  mp3->datasize = filestat.st_size;
#line 85
  get_id3(mp3);
  }
#line 87
  if (scantype == 1) {
    {
#line 88
    tmp___3 = get_first_header(mp3, 0L);
    }
#line 88
    if (tmp___3) {
      {
#line 89
      data_start = ftell(mp3->file);
#line 90
      lastrate = (int )(15U - mp3->header.bitrate);
      }
      {
#line 91
      while (1) {
        while_continue: /* CIL Label */ ;
#line 91
        if (counter < 4) {
#line 91
          if (! lastrate) {
#line 91
            goto while_break;
          }
        } else {
#line 91
          goto while_break;
        }
        {
#line 92
        sample_pos = (off_t )counter * (mp3->datasize / 4L + 1L) + data_start;
#line 93
        tmp = get_first_header(mp3, sample_pos);
        }
#line 93
        if (tmp) {
#line 94
          bitrate___0 = (int )(15U - mp3->header.bitrate);
        } else {
#line 96
          bitrate___0 = -1;
        }
#line 99
        if (bitrate___0 != lastrate) {
#line 100
          mp3->vbr = 1;
#line 101
          if (fullscan_vbr) {
#line 102
            counter = 4;
#line 103
            scantype = 2;
          }
        }
#line 106
        lastrate = bitrate___0;
#line 107
        counter ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 110
      if (! (scantype == 2)) {
        {
#line 111
        l = frame_length(& mp3->header);
#line 111
        mp3->frames = (int )((mp3->datasize - data_start) / (off_t )l);
#line 112
        tmp___0 = frame_length(& mp3->header);
#line 112
        tmp___1 = header_bitrate(& mp3->header);
#line 112
        mp3->seconds = (int )((double )((float )(tmp___0 * mp3->frames) / (float )(tmp___1 * 125)) + 0.5);
#line 114
        tmp___2 = header_bitrate(& mp3->header);
#line 114
        mp3->vbr_average = (float )tmp___2;
        }
      }
    }
  }
#line 120
  if (scantype == 2) {
    {
#line 121
    tmp___7 = get_first_header(mp3, 0L);
    }
#line 121
    if (tmp___7) {
      {
#line 122
      data_start = ftell(mp3->file);
      }
      {
#line 123
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 123
        bitrate___0 = get_next_header(mp3);
        }
#line 123
        if (! bitrate___0) {
#line 123
          goto while_break___0;
        }
#line 124
        (frame_type[15 - bitrate___0]) ++;
#line 125
        frames ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 127
      memcpy((void */* __restrict  */)(& header), (void const   */* __restrict  */)(& mp3->header),
             sizeof(mp3header ));
#line 128
      counter = 0;
      }
      {
#line 128
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 128
        if (! (counter < 15)) {
#line 128
          goto while_break___1;
        }
#line 129
        if (frame_type[counter]) {
          {
#line 130
          frame_types ++;
#line 131
          header.bitrate = (unsigned int )counter;
#line 132
          frames_so_far += frame_type[counter];
#line 133
          tmp___4 = frame_length(& header);
#line 133
          tmp___5 = header_bitrate(& header);
#line 133
          seconds += (float )(tmp___4 * frame_type[counter]) / (float )(tmp___5 * 125);
#line 135
          tmp___6 = header_bitrate(& header);
#line 135
          total_rate += (float )(tmp___6 * frame_type[counter]);
          }
#line 136
          if (vbr_median == -1) {
#line 136
            if (frames_so_far >= frames / 2) {
#line 137
              vbr_median = counter;
            }
          }
        }
#line 128
        counter ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 140
      mp3->seconds = (int )((double )seconds + 0.5);
#line 141
      mp3->header.bitrate = (unsigned int )vbr_median;
#line 142
      mp3->vbr_average = total_rate / (float )frames;
#line 143
      mp3->frames = frames;
#line 144
      if (frame_types > 1) {
#line 145
        mp3->vbr = 1;
      }
    }
  }
#line 149
  return (had_error);
}
}
#line 153 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.c"
int get_first_header(mp3info *mp3 , long startpos ) 
{ 
  int k ;
  int l ;
  int c ;
  mp3header h ;
  mp3header h2 ;
  long valid_start ;
  int tmp ;
  long tmp___0 ;

  {
  {
#line 155
  l = 0;
#line 157
  valid_start = 0L;
#line 159
  fseek(mp3->file, startpos, 0);
  }
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 161
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 161
      c = fgetc(mp3->file);
      }
#line 161
      if (c != 255) {
#line 161
        if (! (c != -1)) {
#line 161
          goto while_break___0;
        }
      } else {
#line 161
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 162
    if (c == 255) {
      {
#line 163
      ungetc(c, mp3->file);
#line 164
      valid_start = ftell(mp3->file);
#line 165
      l = get_header(mp3->file, & h);
      }
#line 165
      if (l) {
        {
#line 166
        fseek(mp3->file, (long )(l - 4), 1);
#line 167
        k = 1;
        }
        {
#line 167
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 167
          if (k < 4) {
            {
#line 167
            tmp___0 = ftell(mp3->file);
            }
#line 167
            if (! (mp3->datasize - tmp___0 >= 4L)) {
#line 167
              goto while_break___1;
            }
          } else {
#line 167
            goto while_break___1;
          }
          {
#line 168
          l = get_header(mp3->file, & h2);
          }
#line 168
          if (! l) {
#line 168
            goto while_break___1;
          }
          {
#line 169
          tmp = sameConstant(& h, & h2);
          }
#line 169
          if (! tmp) {
#line 169
            goto while_break___1;
          }
          {
#line 170
          fseek(mp3->file, (long )(l - 4), 1);
#line 167
          k ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 172
        if (k == 4) {
          {
#line 173
          fseek(mp3->file, valid_start, 0);
#line 174
          memcpy((void */* __restrict  */)(& mp3->header), (void const   */* __restrict  */)(& h2),
                 sizeof(mp3header ));
#line 175
          mp3->header_isvalid = 1;
          }
#line 176
          return (1);
        }
      }
    } else {
#line 180
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  return (0);
}
}
#line 190 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.c"
int get_next_header(mp3info *mp3 ) 
{ 
  int l ;
  int c ;
  int skip_bytes ;
  mp3header h ;
  long tmp ;

  {
#line 192
  l = 0;
#line 192
  skip_bytes = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 196
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 196
      c = fgetc(mp3->file);
      }
#line 196
      if (c != 255) {
        {
#line 196
        tmp = ftell(mp3->file);
        }
#line 196
        if (! (tmp < mp3->datasize)) {
#line 196
          goto while_break___0;
        }
      } else {
#line 196
        goto while_break___0;
      }
#line 196
      skip_bytes ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 197
    if (c == 255) {
      {
#line 198
      ungetc(c, mp3->file);
#line 199
      l = get_header(mp3->file, & h);
      }
#line 199
      if (l) {
#line 200
        if (skip_bytes) {
#line 200
          (mp3->badframes) ++;
        }
        {
#line 201
        fseek(mp3->file, (long )(l - 4), 1);
        }
#line 202
        return ((int )(15U - h.bitrate));
      } else {
#line 204
        skip_bytes += 4;
      }
    } else {
#line 207
      if (skip_bytes) {
#line 207
        (mp3->badframes) ++;
      }
#line 208
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 220 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.c"
int get_header(FILE *file , mp3header *header ) 
{ 
  unsigned char buffer[4] ;
  int fl ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 225
  tmp = fread((void */* __restrict  */)(& buffer), (size_t )4, (size_t )1, (FILE */* __restrict  */)file);
  }
#line 225
  if (tmp < 1UL) {
#line 226
    header->sync = 0UL;
#line 227
    return (0);
  }
#line 229
  header->sync = (unsigned long )(((int )buffer[0] << 4) | (((int )buffer[1] & 224) >> 4));
#line 230
  if ((int )buffer[1] & 16) {
#line 230
    header->version = (unsigned int )(((int )buffer[1] >> 3) & 1);
  } else {
#line 231
    header->version = 2U;
  }
#line 232
  header->layer = (unsigned int )(((int )buffer[1] >> 1) & 3);
#line 233
  header->bitrate = (unsigned int )(((int )buffer[2] >> 4) & 15);
#line 234
  if (header->sync != 4094UL) {
#line 235
    header->sync = 0UL;
#line 236
    return (0);
  } else
#line 234
  if (header->layer != 1U) {
#line 235
    header->sync = 0UL;
#line 236
    return (0);
  } else
#line 234
  if (header->bitrate == 15U) {
#line 235
    header->sync = 0UL;
#line 236
    return (0);
  }
#line 238
  header->crc = (unsigned int )((int )buffer[1] & 1);
#line 239
  header->freq = (unsigned int )(((int )buffer[2] >> 2) & 3);
#line 240
  header->padding = (unsigned int )(((int )buffer[2] >> 1) & 1);
#line 241
  header->extension = (unsigned int )((int )buffer[2] & 1);
#line 242
  header->mode = (unsigned int )(((int )buffer[3] >> 6) & 3);
#line 243
  header->mode_extension = (unsigned int )(((int )buffer[3] >> 4) & 3);
#line 244
  header->copyright = (unsigned int )(((int )buffer[3] >> 3) & 1);
#line 245
  header->original = (unsigned int )(((int )buffer[3] >> 2) & 1);
#line 246
  header->emphasis = (unsigned int )((int )buffer[3] & 3);
#line 249
  if (header->bitrate == 15U) {
#line 250
    return (0);
  } else
#line 249
  if (header->freq == 3U) {
#line 250
    return (0);
  }
  {
#line 253
  fl = frame_length(header);
  }
#line 253
  if (fl >= 21) {
#line 253
    tmp___0 = fl;
  } else {
#line 253
    tmp___0 = 0;
  }
#line 253
  return (tmp___0);
}
}
#line 256 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.c"
int frame_length(mp3header *header ) 
{ 
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 257
  if (header->sync == 4094UL) {
    {
#line 257
    tmp = header_bitrate(header);
#line 257
    tmp___0 = header_frequency(header);
#line 257
    tmp___1 = (((unsigned int )frame_size_index[3U - header->layer] * ((header->version & 1U) + 1U)) * (unsigned int )tmp) / (unsigned int )tmp___0 + header->padding;
    }
  } else {
#line 257
    tmp___1 = 1U;
  }
#line 257
  return ((int )tmp___1);
}
}
#line 263 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.c"
int header_layer(mp3header *h ) 
{ 


  {
#line 263
  return (layer_tab[h->layer]);
}
}
#line 265 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.c"
int header_bitrate(mp3header *h ) 
{ 


  {
#line 266
  return (bitrate[h->version & 1U][3U - h->layer][h->bitrate]);
}
}
#line 269 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.c"
int header_frequency(mp3header *h ) 
{ 


  {
#line 270
  return (frequencies[h->version][h->freq]);
}
}
#line 273 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.c"
char *header_emphasis(mp3header *h ) 
{ 


  {
#line 274
  return (emphasis_text[h->emphasis]);
}
}
#line 277 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.c"
char *header_mode(mp3header *h ) 
{ 


  {
#line 278
  return (mode_text[h->mode]);
}
}
#line 281 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.c"
int sameConstant(mp3header *h1 , mp3header *h2 ) 
{ 


  {
#line 282
  if (*((uint *)h1) == *((uint *)h2)) {
#line 282
    return (1);
  }
#line 284
  if (h1->version == h2->version) {
#line 284
    if (h1->layer == h2->layer) {
#line 284
      if (h1->crc == h2->crc) {
#line 284
        if (h1->freq == h2->freq) {
#line 284
          if (h1->mode == h2->mode) {
#line 284
            if (h1->copyright == h2->copyright) {
#line 284
              if (h1->original == h2->original) {
#line 284
                if (h1->emphasis == h2->emphasis) {
#line 292
                  return (1);
                } else {
#line 293
                  return (0);
                }
              } else {
#line 293
                return (0);
              }
            } else {
#line 293
              return (0);
            }
          } else {
#line 293
            return (0);
          }
        } else {
#line 293
          return (0);
        }
      } else {
#line 293
        return (0);
      }
    } else {
#line 293
      return (0);
    }
  } else {
#line 293
    return (0);
  }
}
}
#line 297 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.c"
int get_id3(mp3info *mp3 ) 
{ 
  int retcode ;
  char fbuf[4] ;
  int tmp ;
  int tmp___0 ;

  {
#line 298
  retcode = 0;
#line 301
  if (mp3->datasize >= 128L) {
    {
#line 302
    tmp___0 = fseek(mp3->file, -128L, 2);
    }
#line 302
    if (tmp___0) {
      {
#line 303
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Couldn\'t read last 128 bytes of %s!!\n",
              mp3->filename);
#line 304
      retcode |= 4;
      }
    } else {
      {
#line 306
      fread((void */* __restrict  */)(fbuf), (size_t )1, (size_t )3, (FILE */* __restrict  */)mp3->file);
#line 306
      fbuf[3] = (char )'\000';
#line 307
      mp3->id3.genre[0] = (unsigned char)255;
#line 310
      tmp = strcmp("TAG", (char const   *)(fbuf));
      }
#line 310
      if (! tmp) {
        {
#line 313
        mp3->id3_isvalid = 1;
#line 314
        mp3->datasize -= 128L;
#line 315
        fseek(mp3->file, -125L, 2);
#line 316
        fread((void */* __restrict  */)(mp3->id3.title), (size_t )1, (size_t )30,
              (FILE */* __restrict  */)mp3->file);
#line 316
        mp3->id3.title[30] = (char )'\000';
#line 317
        fread((void */* __restrict  */)(mp3->id3.artist), (size_t )1, (size_t )30,
              (FILE */* __restrict  */)mp3->file);
#line 317
        mp3->id3.artist[30] = (char )'\000';
#line 318
        fread((void */* __restrict  */)(mp3->id3.album), (size_t )1, (size_t )30,
              (FILE */* __restrict  */)mp3->file);
#line 318
        mp3->id3.album[30] = (char )'\000';
#line 319
        fread((void */* __restrict  */)(mp3->id3.year), (size_t )1, (size_t )4, (FILE */* __restrict  */)mp3->file);
#line 319
        mp3->id3.year[4] = (char )'\000';
#line 320
        fread((void */* __restrict  */)(mp3->id3.comment), (size_t )1, (size_t )30,
              (FILE */* __restrict  */)mp3->file);
#line 320
        mp3->id3.comment[30] = (char )'\000';
        }
#line 321
        if ((int )mp3->id3.comment[28] == 0) {
#line 322
          mp3->id3.track[0] = (unsigned char )mp3->id3.comment[29];
        }
        {
#line 324
        fread((void */* __restrict  */)(mp3->id3.genre), (size_t )1, (size_t )1, (FILE */* __restrict  */)mp3->file);
#line 325
        unpad(mp3->id3.title);
#line 326
        unpad(mp3->id3.artist);
#line 327
        unpad(mp3->id3.album);
#line 328
        unpad(mp3->id3.year);
#line 329
        unpad(mp3->id3.comment);
        }
      }
    }
  }
#line 333
  return (retcode);
}
}
#line 337 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.c"
char *pad(char *string , int length ) 
{ 
  int l ;
  size_t tmp ;

  {
  {
#line 340
  tmp = strlen((char const   *)string);
#line 340
  l = (int )tmp;
  }
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! (l < length)) {
#line 341
      goto while_break;
    }
#line 342
    *(string + l) = (char )' ';
#line 343
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  *(string + l) = (char )'\000';
#line 347
  return (string);
}
}
#line 352 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.c"
char *unpad(char *string ) 
{ 
  char *pos ;
  size_t tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 353
  tmp = strlen((char const   *)string);
#line 353
  pos = (string + tmp) - 1;
  }
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 354
    tmp___1 = __ctype_b_loc();
    }
#line 354
    if (! ((int const   )*(*tmp___1 + (int )*(pos + 0)) & 8192)) {
#line 354
      goto while_break;
    }
#line 354
    tmp___0 = pos;
#line 354
    pos --;
#line 354
    *(tmp___0 + 0) = (char)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  return (string);
}
}
#line 363 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3tech.c"
int write_tag(mp3info *mp3 ) 
{ 
  char buf[129] ;
  size_t tmp ;

  {
  {
#line 367
  strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"TAG");
#line 368
  pad(mp3->id3.title, 30);
#line 369
  strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)(mp3->id3.title),
          (size_t )30);
#line 370
  pad(mp3->id3.artist, 30);
#line 371
  strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)(mp3->id3.artist),
          (size_t )30);
#line 372
  pad(mp3->id3.album, 30);
#line 373
  strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)(mp3->id3.album),
          (size_t )30);
#line 374
  pad(mp3->id3.year, 4);
#line 375
  strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)(mp3->id3.year),
          (size_t )4);
#line 376
  pad(mp3->id3.comment, 30);
#line 377
  strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)(mp3->id3.comment),
          (size_t )30);
#line 378
  strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)((char *)(& mp3->id3.genre)),
          (size_t )1);
  }
#line 379
  if ((int )mp3->id3.track[0] != 0) {
#line 380
    buf[125] = (char )'\000';
#line 381
    buf[126] = (char )mp3->id3.track[0];
  }
  {
#line 383
  fseek(mp3->file, (long )(-128 * mp3->id3_isvalid), 2);
#line 384
  tmp = fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )128, (FILE */* __restrict  */)mp3->file);
  }
#line 384
  return ((int )tmp);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 993 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) truncate)(char const   *__file ,
                                                                                               __off_t __length ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 54 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3info.h"
char *typegenre[149]  = 
#line 54 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3info.h"
  {      (char *)"Blues",      (char *)"Classic Rock",      (char *)"Country",      (char *)"Dance", 
        (char *)"Disco",      (char *)"Funk",      (char *)"Grunge",      (char *)"Hip-Hop", 
        (char *)"Jazz",      (char *)"Metal",      (char *)"New Age",      (char *)"Oldies", 
        (char *)"Other",      (char *)"Pop",      (char *)"R&B",      (char *)"Rap", 
        (char *)"Reggae",      (char *)"Rock",      (char *)"Techno",      (char *)"Industrial", 
        (char *)"Alternative",      (char *)"Ska",      (char *)"Death Metal",      (char *)"Pranks", 
        (char *)"Soundtrack",      (char *)"Euro-Techno",      (char *)"Ambient",      (char *)"Trip-Hop", 
        (char *)"Vocal",      (char *)"Jazz+Funk",      (char *)"Fusion",      (char *)"Trance", 
        (char *)"Classical",      (char *)"Instrumental",      (char *)"Acid",      (char *)"House", 
        (char *)"Game",      (char *)"Sound Clip",      (char *)"Gospel",      (char *)"Noise", 
        (char *)"Alt. Rock",      (char *)"Bass",      (char *)"Soul",      (char *)"Punk", 
        (char *)"Space",      (char *)"Meditative",      (char *)"Instrumental Pop",      (char *)"Instrumental Rock", 
        (char *)"Ethnic",      (char *)"Gothic",      (char *)"Darkwave",      (char *)"Techno-Industrial", 
        (char *)"Electronic",      (char *)"Pop-Folk",      (char *)"Eurodance",      (char *)"Dream", 
        (char *)"Southern Rock",      (char *)"Comedy",      (char *)"Cult",      (char *)"Gangsta Rap", 
        (char *)"Top 40",      (char *)"Christian Rap",      (char *)"Pop/Funk",      (char *)"Jungle", 
        (char *)"Native American",      (char *)"Cabaret",      (char *)"New Wave",      (char *)"Psychedelic", 
        (char *)"Rave",      (char *)"Showtunes",      (char *)"Trailer",      (char *)"Lo-Fi", 
        (char *)"Tribal",      (char *)"Acid Punk",      (char *)"Acid Jazz",      (char *)"Polka", 
        (char *)"Retro",      (char *)"Musical",      (char *)"Rock & Roll",      (char *)"Hard Rock", 
        (char *)"Folk",      (char *)"Folk/Rock",      (char *)"National Folk",      (char *)"Swing", 
        (char *)"Fast-Fusion",      (char *)"Bebob",      (char *)"Latin",      (char *)"Revival", 
        (char *)"Celtic",      (char *)"Bluegrass",      (char *)"Avantgarde",      (char *)"Gothic Rock", 
        (char *)"Progressive Rock",      (char *)"Psychedelic Rock",      (char *)"Symphonic Rock",      (char *)"Slow Rock", 
        (char *)"Big Band",      (char *)"Chorus",      (char *)"Easy Listening",      (char *)"Acoustic", 
        (char *)"Humour",      (char *)"Speech",      (char *)"Chanson",      (char *)"Opera", 
        (char *)"Chamber Music",      (char *)"Sonata",      (char *)"Symphony",      (char *)"Booty Bass", 
        (char *)"Primus",      (char *)"Porn Groove",      (char *)"Satire",      (char *)"Slow Jam", 
        (char *)"Club",      (char *)"Tango",      (char *)"Samba",      (char *)"Folklore", 
        (char *)"Ballad",      (char *)"Power Ballad",      (char *)"Rhythmic Soul",      (char *)"Freestyle", 
        (char *)"Duet",      (char *)"Punk Rock",      (char *)"Drum Solo",      (char *)"A Cappella", 
        (char *)"Euro-House",      (char *)"Dance Hall",      (char *)"Goa",      (char *)"Drum & Bass", 
        (char *)"Club-House",      (char *)"Hardcore",      (char *)"Terror",      (char *)"Indie", 
        (char *)"BritPop",      (char *)"Negerpunk",      (char *)"Polsk Punk",      (char *)"Beat", 
        (char *)"Christian Gangsta Rap",      (char *)"Heavy Metal",      (char *)"Black Metal",      (char *)"Crossover", 
        (char *)"Contemporary Christian",      (char *)"Christian Rock",      (char *)"Merengue",      (char *)"Salsa", 
        (char *)"Thrash Metal",      (char *)"Anime",      (char *)"JPop",      (char *)"Synthpop", 
        (char *)""};
#line 84 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3info.h"
int galphagenreindex[149]  = 
#line 84
  {      148,      123,      74,      73, 
        34,      99,      40,      20, 
        26,      145,      90,      116, 
        41,      135,      85,      96, 
        138,      89,      0,      107, 
        132,      65,      88,      104, 
        102,      97,      136,      61, 
        141,      1,      32,      128, 
        112,      57,      140,      2, 
        139,      58,      125,      3, 
        50,      22,      4,      55, 
        127,      122,      120,      98, 
        52,      48,      124,      25, 
        54,      84,      81,      115, 
        80,      119,      5,      30, 
        36,      59,      126,      38, 
        91,      49,      6,      79, 
        129,      137,      7,      35, 
        100,      131,      19,      46, 
        47,      33,      146,      29, 
        8,      63,      86,      71, 
        45,      142,      9,      77, 
        82,      64,      133,      10, 
        66,      39,      11,      103, 
        12,      75,      134,      53, 
        62,      13,      109,      117, 
        23,      108,      92,      93, 
        67,      121,      43,      14, 
        15,      68,      16,      76, 
        87,      118,      78,      17, 
        143,      114,      110,      69, 
        21,      111,      95,      105, 
        42,      37,      24,      56, 
        44,      101,      83,      94, 
        106,      147,      113,      51, 
        18,      130,      144,      60, 
        70,      31,      72,      27, 
        28};
#line 101 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3info.h"
int *alphagenreindex  =    & galphagenreindex[1];
#line 35 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3info.c"
char FILENAME_FORMAT_STRING[10]  = 
#line 35 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3info.c"
  {      (char )'F',      (char )'i',      (char )'l',      (char )'e', 
        (char )':',      (char )' ',      (char )'%',      (char )'F', 
        (char )'\n',      (char )'\000'};
#line 36 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3info.c"
char ID3_FORMAT_STRING[93]  = 
#line 36
  {      (char )'T',      (char )'i',      (char )'t',      (char )'l', 
        (char )'e',      (char )':',      (char )' ',      (char )' ', 
        (char )' ',      (char )'%',      (char )'-',      (char )'3', 
        (char )'0',      (char )'t',      (char )' ',      (char )'T', 
        (char )'r',      (char )'a',      (char )'c',      (char )'k', 
        (char )':',      (char )' ',      (char )'%',      (char )'n', 
        (char )'\n',      (char )'A',      (char )'r',      (char )'t', 
        (char )'i',      (char )'s',      (char )'t',      (char )':', 
        (char )' ',      (char )' ',      (char )'%',      (char )'a', 
        (char )'\n',      (char )'A',      (char )'l',      (char )'b', 
        (char )'u',      (char )'m',      (char )':',      (char )' ', 
        (char )' ',      (char )' ',      (char )'%',      (char )'-', 
        (char )'3',      (char )'0',      (char )'l',      (char )' ', 
        (char )'Y',      (char )'e',      (char )'a',      (char )'r', 
        (char )':',      (char )' ',      (char )' ',      (char )'%', 
        (char )'y',      (char )'\n',      (char )'C',      (char )'o', 
        (char )'m',      (char )'m',      (char )'e',      (char )'n', 
        (char )'t',      (char )':',      (char )' ',      (char )'%', 
        (char )'-',      (char )'3',      (char )'0',      (char )'c', 
        (char )' ',      (char )'G',      (char )'e',      (char )'n', 
        (char )'r',      (char )'e',      (char )':',      (char )' ', 
        (char )'%',      (char )'g',      (char )' ',      (char )'[', 
        (char )'%',      (char )'G',      (char )']',      (char )'\n', 
        (char )'\000'};
#line 37 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3info.c"
char TECH_FORMAT_STRING[169]  = 
#line 37
  {      (char )'M',      (char )'e',      (char )'d',      (char )'i', 
        (char )'a',      (char )' ',      (char )'T',      (char )'y', 
        (char )'p',      (char )'e',      (char )':',      (char )' ', 
        (char )' ',      (char )'M',      (char )'P',      (char )'E', 
        (char )'G',      (char )' ',      (char )'%',      (char )'2', 
        (char )'.',      (char )'1',      (char )'v',      (char )' ', 
        (char )'L',      (char )'a',      (char )'y',      (char )'e', 
        (char )'r',      (char )' ',      (char )'%',      (char )'L', 
        (char )'\n',      (char )'A',      (char )'u',      (char )'d', 
        (char )'i',      (char )'o',      (char )':',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'%',      (char )'r', 
        (char )' ',      (char )'k',      (char )'b',      (char )'p', 
        (char )'s',      (char )',',      (char )' ',      (char )'%', 
        (char )'q',      (char )' ',      (char )'k',      (char )'H', 
        (char )'z',      (char )' ',      (char )'(',      (char )'%', 
        (char )'o',      (char )')',      (char )'\n',      (char )'E', 
        (char )'m',      (char )'p',      (char )'h',      (char )'a', 
        (char )'s',      (char )'i',      (char )'s',      (char )':', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'%',      (char )'e',      (char )'\n',      (char )'C', 
        (char )'R',      (char )'C',      (char )':',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'%',      (char )'E',      (char )'\n',      (char )'C', 
        (char )'o',      (char )'p',      (char )'y',      (char )'r', 
        (char )'i',      (char )'g',      (char )'h',      (char )'t', 
        (char )':',      (char )' ',      (char )' ',      (char )' ', 
        (char )'%',      (char )'C',      (char )'\n',      (char )'O', 
        (char )'r',      (char )'i',      (char )'g',      (char )'i', 
        (char )'n',      (char )'a',      (char )'l',      (char )':', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'%',      (char )'O',      (char )'\n',      (char )'P', 
        (char )'a',      (char )'d',      (char )'d',      (char )'i', 
        (char )'n',      (char )'g',      (char )':',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'%',      (char )'p',      (char )'\n',      (char )'L', 
        (char )'e',      (char )'n',      (char )'g',      (char )'t', 
        (char )'h',      (char )':',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'%',      (char )'m',      (char )':',      (char )'%', 
        (char )'0',      (char )'2',      (char )'s',      (char )'\n', 
        (char )'\000'};
#line 39 "/home/wheatley/newnew/temp/mp3info-0.8.5a/mp3info.c"
int main(int argc , char **argv ) 
{ 
  FILE *fp ;
  int c ;
  int i ;
  int interactive ;
  int view_only ;
  int delete_tag ;
  int file_open ;
  int retcode ;
  int want_id3 ;
  int scantype ;
  int fullscan_vbr ;
  int show_techinfo ;
  int force_mode ;
  int quickscan ;
  int new_track ;
  int new_genre ;
  int firstfilearg ;
  id3tag new_tag ;
  char *print_format ;
  char error_msg[256] ;
  unsigned int g ;
  unsigned int n ;
  int vbr_report ;
  mp3info mp3 ;
  int tmp ;

  {
#line 41
  interactive = 0;
#line 41
  view_only = 1;
#line 41
  delete_tag = 0;
#line 41
  retcode = 0;
#line 42
  want_id3 = 1;
#line 42
  scantype = 0;
#line 42
  fullscan_vbr = 0;
#line 43
  show_techinfo = 0;
#line 43
  force_mode = 0;
#line 43
  quickscan = 1;
#line 44
  new_track = 0;
#line 44
  new_genre = 0;
#line 46
  print_format = (char *)((void *)0);
#line 49
  vbr_report = 0;
#line 53
  new_tag.genre[0] = (unsigned char)1;
#line 53
  new_tag.track[0] = new_tag.genre[0];
#line 53
  new_tag.comment[0] = (char )new_tag.track[0];
#line 53
  new_tag.year[0] = new_tag.comment[0];
#line 53
  new_tag.album[0] = new_tag.year[0];
#line 53
  new_tag.artist[0] = new_tag.album[0];
#line 53
  new_tag.title[0] = new_tag.artist[0];
#line 57
  if (argc < 2) {
    {
#line 58
    printf((char const   */* __restrict  */)"%s %s\n\n  MP3Info comes with ABSOLUTELY NO WARRANTY.  This is free software, and\n  you are welcome to redistribute it under certain conditions.\n  See the file \'LICENSE\' for more information.\n\nUse \'mp3info -h\' for a usage summary or see the mp3info man page for a\ncomplete description.\n",
           "MP3Info 0.8.5a", "Copyright (C) 2006 Cedric Tefft and Ricardo Cerqueira");
    }
#line 64
    return (0);
  }
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 69
    c = getopt(argc, (char * const  *)argv, "vhGidfxFt:a:l:y:c:n:g:p:r:");
    }
#line 69
    if (! (c != -1)) {
#line 69
      goto while_break;
    }
    {
#line 72
    if (c == 118) {
#line 72
      goto case_118;
    }
#line 76
    if (c == 104) {
#line 76
      goto case_104;
    }
#line 79
    if (c == 71) {
#line 79
      goto case_71;
    }
#line 82
    if (c == 105) {
#line 82
      goto case_105;
    }
#line 86
    if (c == 100) {
#line 86
      goto case_100;
    }
#line 90
    if (c == 112) {
#line 90
      goto case_112;
    }
#line 95
    if (c == 102) {
#line 95
      goto case_102;
    }
#line 98
    if (c == 120) {
#line 98
      goto case_120;
    }
#line 101
    if (c == 116) {
#line 101
      goto case_116;
    }
#line 105
    if (c == 97) {
#line 105
      goto case_97;
    }
#line 109
    if (c == 108) {
#line 109
      goto case_108;
    }
#line 113
    if (c == 121) {
#line 113
      goto case_121;
    }
#line 117
    if (c == 99) {
#line 117
      goto case_99;
    }
#line 121
    if (c == 110) {
#line 121
      goto case_110;
    }
#line 135
    if (c == 103) {
#line 135
      goto case_103;
    }
#line 149
    if (c == 114) {
#line 149
      goto case_114;
    }
#line 161
    if (c == 70) {
#line 161
      goto case_70;
    }
#line 71
    goto switch_break;
    case_118: /* CIL Label */ 
#line 75
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 77
    display_help();
    }
#line 77
    return (0);
#line 78
    goto switch_break;
    case_71: /* CIL Label */ 
    {
#line 80
    display_genres(alphagenreindex, typegenre);
    }
#line 80
    return (0);
#line 81
    goto switch_break;
    case_105: /* CIL Label */ 
#line 83
    view_only = 0;
#line 84
    interactive = 1;
#line 85
    goto switch_break;
    case_100: /* CIL Label */ 
#line 87
    view_only = 0;
#line 88
    delete_tag = 1;
#line 89
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 91
    print_format = optarg;
#line 92
    translate_escapes(print_format);
#line 93
    want_id3 = 0;
    }
#line 94
    goto switch_break;
    case_102: /* CIL Label */ 
#line 96
    force_mode = 1;
#line 97
    goto switch_break;
    case_120: /* CIL Label */ 
#line 99
    show_techinfo = 1;
#line 100
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 102
    strncpy((char */* __restrict  */)(new_tag.title), (char const   */* __restrict  */)optarg,
            (size_t )30);
#line 103
    view_only = 0;
    }
#line 104
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 106
    strncpy((char */* __restrict  */)(new_tag.artist), (char const   */* __restrict  */)optarg,
            (size_t )30);
#line 107
    view_only = 0;
    }
#line 108
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 110
    strncpy((char */* __restrict  */)(new_tag.album), (char const   */* __restrict  */)optarg,
            (size_t )30);
#line 111
    view_only = 0;
    }
#line 112
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 114
    strncpy((char */* __restrict  */)(new_tag.year), (char const   */* __restrict  */)optarg,
            (size_t )4);
#line 115
    view_only = 0;
    }
#line 116
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 118
    strncpy((char */* __restrict  */)(new_tag.comment), (char const   */* __restrict  */)optarg,
            (size_t )30);
#line 119
    view_only = 0;
    }
#line 120
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 122
    tmp = atoi((char const   *)optarg);
#line 122
    n = (unsigned int )tmp;
    }
#line 123
    if (n <= 255U) {
#line 124
      new_tag.track[0] = (unsigned char )n;
#line 125
      new_track = 1;
#line 126
      view_only = 0;
    } else {
      {
#line 128
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: \'%s\' is not a valid track number.\n",
              optarg);
#line 129
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Valid track numbers are integers from 0 to 255.\n");
#line 130
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Use a value of \'0\' to remove the track number field\n");
#line 131
      retcode |= 6;
      }
#line 132
      return (retcode);
    }
#line 134
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 136
    g = get_genre(optarg);
    }
#line 137
    if (g <= 255U) {
#line 138
      new_tag.genre[0] = (unsigned char )g;
#line 139
      new_genre = 1;
#line 140
      view_only = 0;
    } else {
      {
#line 142
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: \'%s\' is not a recognized genre name or number.\n",
              optarg);
#line 143
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Use the \'-G\' option to see a list of valid genre names and numbers\n");
#line 144
      retcode |= 6;
      }
#line 145
      return (retcode);
    }
    {
#line 147
    sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%u",
           & g);
    }
#line 148
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 151
    if ((int )*(optarg + 0) == 97) {
#line 151
      goto case_97___0;
    }
#line 152
    if ((int )*(optarg + 0) == 109) {
#line 152
      goto case_109;
    }
#line 153
    if ((int )*(optarg + 0) == 118) {
#line 153
      goto case_118___0;
    }
#line 154
    goto switch_default;
    case_97___0: /* CIL Label */ 
#line 151
    vbr_report = 1;
#line 151
    goto switch_break___0;
    case_109: /* CIL Label */ 
#line 152
    vbr_report = 2;
#line 152
    goto switch_break___0;
    case_118___0: /* CIL Label */ 
#line 153
    vbr_report = 0;
#line 153
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 155
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: %s is not a valid option to the VBR reporting switch (-r)\n",
            optarg);
#line 156
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Valid options are \'a\', \'m\' and \'v\'.  Run \'%s -h\' for more info.\n",
            *(argv + 0));
#line 157
    retcode |= 6;
    }
#line 158
    return (retcode);
    switch_break___0: /* CIL Label */ ;
    }
#line 160
    goto switch_break;
    case_70: /* CIL Label */ 
#line 161
    quickscan = 0;
#line 161
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  if (! view_only) {
#line 166
    scantype = 1;
  }
#line 168
  if (print_format) {
    {
#line 169
    determine_tasks(print_format, & want_id3, & scantype, & fullscan_vbr, vbr_report);
    }
  } else
#line 170
  if (view_only) {
    {
#line 171
    determine_tasks(ID3_FORMAT_STRING, & want_id3, & scantype, & fullscan_vbr, vbr_report);
    }
#line 172
    if (show_techinfo) {
      {
#line 173
      determine_tasks(TECH_FORMAT_STRING, & want_id3, & scantype, & fullscan_vbr,
                      vbr_report);
      }
    }
  }
#line 177
  if (! quickscan) {
#line 177
    if (scantype == 1) {
#line 178
      scantype = 2;
    }
  }
#line 180
  firstfilearg = optind;
#line 182
  i = optind;
  {
#line 182
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 182
    if (! (i < argc)) {
#line 182
      goto while_break___0;
    }
#line 183
    file_open = 0;
#line 184
    if (view_only == 1) {
      {
#line 185
      fp = fopen((char const   */* __restrict  */)*(argv + i), (char const   */* __restrict  */)"rb");
      }
#line 185
      if (fp) {
#line 190
        file_open = 1;
      } else {
        {
#line 186
        snprintf((char */* __restrict  */)(error_msg), sizeof(error_msg), (char const   */* __restrict  */)"Error opening MP3: %s",
                 *(argv + i));
#line 187
        perror((char const   *)(error_msg));
#line 188
        retcode |= 1;
        }
      }
    } else {
      {
#line 193
      fp = fopen((char const   */* __restrict  */)*(argv + i), (char const   */* __restrict  */)"rb+");
      }
#line 193
      if (fp) {
#line 198
        file_open = 1;
      } else {
        {
#line 194
        snprintf((char */* __restrict  */)(error_msg), sizeof(error_msg), (char const   */* __restrict  */)"Error opening MP3: %s",
                 *(argv + i));
#line 195
        perror((char const   *)(error_msg));
#line 196
        retcode |= 1;
        }
      }
    }
#line 202
    if (file_open == 1) {
      {
#line 203
      memset((void *)(& mp3), 0, sizeof(mp3info ));
#line 204
      mp3.filename = *(argv + i);
#line 205
      mp3.file = fp;
#line 206
      get_mp3_info(& mp3, scantype, fullscan_vbr);
      }
#line 208
      if (scantype != 0) {
#line 208
        if (! mp3.header_isvalid) {
#line 208
          if (! force_mode) {
            {
#line 209
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s is corrupt or is not a standard MP3 file.\n",
                    mp3.filename);
#line 210
            retcode |= 2;
            }
          }
        }
      }
#line 213
      if (view_only) {
#line 214
        if (want_id3) {
#line 214
          if (! mp3.id3_isvalid) {
            {
#line 215
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s does not have an ID3 1.x tag.\n",
                    mp3.filename);
#line 216
            retcode |= 16;
            }
          }
        }
#line 219
        if (print_format) {
          {
#line 220
          format_output(print_format, & mp3, vbr_report);
          }
        } else {
#line 223
          if (mp3.id3_isvalid) {
            {
#line 224
            format_output(FILENAME_FORMAT_STRING, & mp3, vbr_report);
            }
          } else
#line 223
          if (show_techinfo) {
#line 223
            if (mp3.header_isvalid) {
              {
#line 224
              format_output(FILENAME_FORMAT_STRING, & mp3, vbr_report);
              }
            }
          }
#line 226
          if (mp3.id3_isvalid) {
            {
#line 227
            format_output(ID3_FORMAT_STRING, & mp3, vbr_report);
            }
          }
#line 229
          if (show_techinfo) {
#line 229
            if (mp3.header_isvalid) {
              {
#line 230
              format_output(TECH_FORMAT_STRING, & mp3, vbr_report);
              }
            }
          }
          {
#line 232
          printf((char const   */* __restrict  */)"\n");
          }
        }
      } else
#line 236
      if (mp3.header_isvalid) {
#line 236
        goto _L;
      } else
#line 236
      if (force_mode) {
        _L: /* CIL Label */ 
#line 238
        if ((int )new_tag.title[0] != 1) {
          {
#line 239
          strncpy((char */* __restrict  */)(mp3.id3.title), (char const   */* __restrict  */)(new_tag.title),
                  (size_t )30);
          }
        }
#line 242
        if ((int )new_tag.artist[0] != 1) {
          {
#line 243
          strncpy((char */* __restrict  */)(mp3.id3.artist), (char const   */* __restrict  */)(new_tag.artist),
                  (size_t )30);
          }
        }
#line 246
        if ((int )new_tag.album[0] != 1) {
          {
#line 247
          strncpy((char */* __restrict  */)(mp3.id3.album), (char const   */* __restrict  */)(new_tag.album),
                  (size_t )30);
          }
        }
#line 250
        if ((int )new_tag.comment[0] != 1) {
          {
#line 251
          strncpy((char */* __restrict  */)(mp3.id3.comment), (char const   */* __restrict  */)(new_tag.comment),
                  (size_t )30);
          }
        }
#line 254
        if (new_track) {
#line 255
          mp3.id3.track[0] = new_tag.track[0];
#line 256
          if ((int )new_tag.track[0] == 0) {
            {
#line 257
            pad(mp3.id3.comment, 30);
            }
          }
        }
#line 261
        if ((int )new_tag.year[0] != 1) {
          {
#line 262
          strncpy((char */* __restrict  */)(mp3.id3.year), (char const   */* __restrict  */)(new_tag.year),
                  (size_t )4);
          }
        }
#line 265
        if (new_genre) {
#line 266
          mp3.id3.genre[0] = new_tag.genre[0];
        }
#line 269
        if (interactive) {
          {
#line 270
          tagedit_curs(mp3.filename, (i - firstfilearg) + 1, argc - firstfilearg,
                       & mp3.id3);
          }
        }
#line 276
        if (! delete_tag) {
          {
#line 277
          write_tag(& mp3);
          }
        }
      } else {
        {
#line 281
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Use the -f switch to add ID3 info to this file anyway.\n");
        }
      }
      {
#line 284
      fclose(mp3.file);
      }
#line 286
      if (delete_tag) {
#line 286
        if (mp3.id3_isvalid) {
          {
#line 287
          truncate((char const   *)mp3.filename, mp3.datasize);
          }
        }
      }
    }
#line 182
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 295
  if (optind == argc) {
    {
#line 296
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No MP3 files specified!\n");
#line 297
    retcode |= 8;
    }
  }
#line 301
  return (retcode);
}
}
