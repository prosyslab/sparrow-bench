/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 177 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   __time_t st_atime ;
   __syscall_ulong_t st_atimensec ;
   __time_t st_mtime ;
   __syscall_ulong_t st_mtimensec ;
   __time_t st_ctime ;
   __syscall_ulong_t st_ctimensec ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 42 "/home/june/collector/temp/and-1.2.2/and.h"
struct and_procent {
   int pid ;
   int ppid ;
   int uid ;
   int gid ;
   int nice ;
   unsigned int utime ;
   char command[1024] ;
   struct and_procent *parent ;
   struct and_procent *next ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 27 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef __id_t id_t;
#line 44 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __priority_which_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_28 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_28 regmatch_t;
#line 131 "/home/june/collector/temp/and-1.2.2/and.c"
struct priority_db_entry {
   int uid ;
   int gid ;
   char command_str[128] ;
   regex_t *command ;
   char parent_str[128] ;
   regex_t *parent ;
   int parentmode ;
   int nl[3] ;
};
#line 146 "/home/june/collector/temp/and-1.2.2/and.c"
struct __anonstruct_and_db_30 {
   int n ;
   struct priority_db_entry entry[100] ;
};
#line 156 "/home/june/collector/temp/and-1.2.2/and.c"
struct __anonstruct_and_config_31 {
   char hostname[512] ;
   int test ;
   int foreground ;
   char *program ;
   char *config_file ;
   char *database_file ;
   int verbose ;
   int to_stdout ;
   int nice_default ;
   char lock_interval ;
   unsigned int interval ;
   unsigned int time_mark[3] ;
   char affinity[5] ;
   int weight[4] ;
   int min_uid ;
   int min_gid ;
};
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 208
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) rewinddir)(DIR *__dirp ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 66 "/home/june/collector/temp/and-1.2.2/and.h"
void and_printf(int required_verbosity , char *fmt  , ...) ;
#line 81
void and_setprocreader(struct and_procent *(*getfirst)() , struct and_procent *(*getnext)() ) ;
#line 90
int and_main(int argc , char **argv ) ;
#line 52 "/home/june/collector/temp/and-1.2.2/and-Linux.c"
static DIR *linux_procdir  =    (DIR *)0;
#line 55 "/home/june/collector/temp/and-1.2.2/and-Linux.c"
static struct and_procent linux_proc  ;
#line 58 "/home/june/collector/temp/and-1.2.2/and-Linux.c"
int linux_readproc(char *fn ) 
{ 
  FILE *f ;
  int i ;
  long li ;
  unsigned long u ;
  unsigned long ujf ;
  unsigned long sjf ;
  char state ;
  char buffer[1024] ;
  size_t tmp ;

  {
  {
#line 73
  f = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"rt");
  }
#line 73
  if (! f) {
#line 73
    return (0);
  }
  {
#line 74
  fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%d %1023s %c %d",
         & linux_proc.pid, buffer, & state, & linux_proc.ppid);
#line 75
  fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%d %d %d %d",
         & i, & i, & i, & i);
#line 76
  fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%lu %lu %lu %lu %lu",
         & u, & u, & u, & u, & u);
#line 77
  fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%lu %lu %ld %ld",
         & ujf, & sjf, & li, & li);
#line 78
  fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%ld %d", & li,
         & linux_proc.nice);
#line 79
  i = feof(f);
#line 80
  fclose(f);
  }
#line 81
  if (i) {
#line 81
    return (0);
  }
#line 82
  if ((int )state == 90) {
#line 82
    return (0);
  }
#line 83
  ujf += sjf;
#line 84
  ujf /= 100UL;
#line 85
  if (ujf > 2147483647UL) {
#line 85
    linux_proc.utime = 2147483647U;
  } else {
#line 85
    linux_proc.utime = (unsigned int )((int )ujf);
  }
  {
#line 86
  tmp = strlen((char const   *)(buffer));
#line 86
  buffer[tmp - 1UL] = (char)0;
#line 87
  strncpy((char */* __restrict  */)(linux_proc.command), (char const   */* __restrict  */)(& buffer[1]),
          (size_t )1023);
#line 88
  linux_proc.command[1023] = (char)0;
#line 89
  and_printf(3, (char *)"Linux: process %s pid: %d ppid: %d\n", linux_proc.command,
             linux_proc.pid, linux_proc.ppid);
  }
#line 91
  return (1);
}
}
#line 106
extern int ( /* missing proto */  snprintf)() ;
#line 95 "/home/june/collector/temp/and-1.2.2/and-Linux.c"
struct and_procent *linux_getnext(void) 
{ 
  char name[1024] ;
  struct dirent *entry ;
  struct stat dirstat ;
  unsigned short const   **tmp ;
  struct and_procent *tmp___0 ;
  int tmp___1 ;
  struct and_procent *tmp___2 ;
  int tmp___3 ;

  {
#line 100
  if (! linux_procdir) {
#line 100
    return ((struct and_procent *)((void *)0));
  }
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 101
    entry = readdir(linux_procdir);
    }
#line 101
    if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 101
      goto while_break;
    }
    {
#line 102
    tmp = __ctype_b_loc();
    }
#line 102
    if ((int const   )*(*tmp + (int )entry->d_name[0]) & 2048) {
#line 102
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if (! entry) {
#line 104
    return ((struct and_procent *)((void *)0));
  }
  {
#line 106
  snprintf(name, 1024, "/proc/%s", entry->d_name);
#line 107
  tmp___1 = stat((char const   */* __restrict  */)(name), (struct stat */* __restrict  */)(& dirstat));
  }
#line 107
  if (tmp___1) {
    {
#line 107
    tmp___0 = linux_getnext();
    }
#line 107
    return (tmp___0);
  }
  {
#line 109
  snprintf(name, 1024, "/proc/%s/stat", entry->d_name);
#line 110
  tmp___3 = linux_readproc(name);
  }
#line 110
  if (! tmp___3) {
    {
#line 110
    tmp___2 = linux_getnext();
    }
#line 110
    return (tmp___2);
  }
#line 111
  linux_proc.uid = (int )dirstat.st_uid;
#line 112
  linux_proc.gid = (int )dirstat.st_gid;
#line 113
  return (& linux_proc);
}
}
#line 117 "/home/june/collector/temp/and-1.2.2/and-Linux.c"
struct and_procent *linux_getfirst(void) 
{ 
  struct and_procent *tmp ;

  {
#line 119
  if (linux_procdir) {
    {
#line 120
    rewinddir(linux_procdir);
    }
  } else {
    {
#line 122
    linux_procdir = opendir("/proc");
    }
#line 123
    if (! linux_procdir) {
      {
#line 124
      and_printf(0, (char *)"cannot open /proc, aborting.\n");
#line 125
      abort();
      }
    }
  }
  {
#line 128
  tmp = linux_getnext();
  }
#line 128
  return (tmp);
}
}
#line 132 "/home/june/collector/temp/and-1.2.2/and-Linux.c"
int main(int argc , char **argv ) 
{ 
  int tmp ;

  {
  {
#line 134
  and_setprocreader(& linux_getfirst, & linux_getnext);
#line 135
  tmp = and_main(argc, argv);
  }
#line 135
  return (tmp);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 111 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 97 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpriority)(__priority_which_t __which ,
                                                                                  id_t __who ,
                                                                                  int __prio ) ;
#line 107 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) )  __asm__("__sysv_signal")  ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 582
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 61 "/home/june/collector/temp/and-1.2.2/and.c"
extern int vsnprintf(char *str , size_t n , char const   *format , va_list ap ) ;
#line 146 "/home/june/collector/temp/and-1.2.2/and.c"
struct __anonstruct_and_db_30 and_db  ;
#line 156 "/home/june/collector/temp/and-1.2.2/and.c"
struct __anonstruct_and_config_31 and_config  ;
#line 194
extern int ( /* missing proto */  gethostname)() ;
#line 180 "/home/june/collector/temp/and-1.2.2/and.c"
void set_defaults(int argc , char **argv ) 
{ 


  {
  {
#line 182
  and_config.test = 0;
#line 183
  and_config.foreground = 0;
#line 184
  and_config.verbose = 0;
#line 185
  and_config.to_stdout = 0;
#line 186
  and_config.program = *(argv + 0);
#line 187
  and_config.lock_interval = (char)0;
#line 188
  and_config.interval = 60U;
#line 189
  and_config.config_file = (char *)"/etc/and.conf";
#line 190
  and_config.database_file = (char *)"/etc/and.priorities";
#line 191
  and_config.nice_default = 0;
#line 192
  and_config.min_uid = 0;
#line 193
  and_config.min_gid = 0;
#line 194
  gethostname(and_config.hostname, 511);
#line 195
  and_config.hostname[511] = (char)0;
  }
#line 196
  return;
}
}
#line 207 "/home/june/collector/temp/and-1.2.2/and.c"
static int syslog_open  =    0;
#line 208 "/home/june/collector/temp/and-1.2.2/and.c"
static FILE *out  =    (FILE *)((void *)0);
#line 204 "/home/june/collector/temp/and-1.2.2/and.c"
void and_printf(int required_verbosity , char *fmt  , ...) 
{ 
  va_list args ;
  char buffer[2048] ;
  time_t t ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 211
  __builtin_va_start(args, fmt);
  }
#line 212
  if (and_config.verbose >= required_verbosity) {
#line 214
    if (and_config.test) {
#line 216
      if (! and_config.to_stdout) {
#line 216
        if (! out) {
          {
#line 217
          out = fopen((char const   */* __restrict  */)"./debug.and", (char const   */* __restrict  */)"wt");
          }
#line 218
          if (! out) {
#line 219
            out = stderr;
          }
        }
      }
      {
#line 223
      t = time((time_t *)((void *)0));
#line 224
      tmp = ctime((time_t const   *)(& t));
#line 224
      strncpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)tmp,
              (size_t )2047);
#line 225
      tmp___0 = strlen((char const   *)(buffer));
#line 225
      buffer[tmp___0 - 1UL] = (char )' ';
      }
#line 226
      if (and_config.to_stdout) {
        {
#line 227
        fputs((char const   */* __restrict  */)(buffer), (FILE */* __restrict  */)stdout);
        }
      } else {
        {
#line 229
        fputs((char const   */* __restrict  */)(buffer), (FILE */* __restrict  */)out);
        }
      }
    }
    {
#line 233
    vsnprintf(buffer, (size_t )2048, (char const   *)fmt, args);
    }
#line 238
    if (and_config.to_stdout) {
      {
#line 239
      fputs((char const   */* __restrict  */)(buffer), (FILE */* __restrict  */)stdout);
#line 240
      fflush(stdout);
      }
    } else
#line 242
    if (and_config.test) {
      {
#line 244
      fputs((char const   */* __restrict  */)(buffer), (FILE */* __restrict  */)out);
#line 245
      fflush(out);
      }
    } else {
#line 248
      if (! syslog_open) {
        {
#line 249
        openlog((char const   *)and_config.program, 33, 3 << 3);
#line 250
        syslog_open = 1;
        }
      }
      {
#line 252
      syslog(4, "%s", buffer);
      }
    }
  }
  {
#line 256
  __builtin_va_end(args);
  }
#line 257
  return;
}
}
#line 262 "/home/june/collector/temp/and-1.2.2/and.c"
void print_priorities(void) 
{ 
  int i ;
  char const   *tmp ;

  {
  {
#line 265
  and_printf(0, (char *)"Priority database:\n");
#line 266
  and_printf(0, (char *)"UID:   GID:   Command               Parent:                             NLs:\n");
#line 267
  i = 0;
  }
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! (i < and_db.n)) {
#line 267
      goto while_break;
    }
#line 268
    if (and_db.entry[i].parentmode == 0) {
#line 268
      tmp = "(parent)";
    } else {
#line 268
      tmp = "(ancestors)";
    }
    {
#line 268
    and_printf(0, (char *)"%5i  %5i  %-20s  %-20s %-13s  %2i,%2i,%2i\n", and_db.entry[i].uid,
               and_db.entry[i].gid, and_db.entry[i].command_str, and_db.entry[i].parent_str,
               tmp, and_db.entry[i].nl[0], and_db.entry[i].nl[1], and_db.entry[i].nl[2]);
#line 267
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  and_printf(0, (char *)"%i entries.\n\n", and_db.n);
  }
#line 277
  return;
}
}
#line 282 "/home/june/collector/temp/and-1.2.2/and.c"
void print_config(void) 
{ 
  char const   *tmp ;

  {
#line 284
  if (and_config.test) {
#line 284
    tmp = "just checkin\'";
  } else {
#line 284
    tmp = "I\'m serious.";
  }
  {
#line 284
  and_printf(0, (char *)"Configuration parameters:\nhost name:            %s\noperational mode:     %s\nverbosity:             %2i\ndefault nicelevel:     %2i\ninterval     [sec]:   %3u\nlevel 0 from [sec]:   %3u\nlevel 1 from [sec]:   %3u\nlevel 2 from [sec]:   %3u\nminimum uid:          %i\nminimum gid:          %i\naffinity:             %s\n          U: %i\n          G: %i\n          C: %i\n          P: %i\n\n",
             and_config.hostname, tmp, and_config.verbose, and_config.nice_default,
             and_config.interval, and_config.time_mark[0], and_config.time_mark[1],
             and_config.time_mark[2], and_config.min_uid, and_config.min_gid, and_config.affinity,
             and_config.weight[0], and_config.weight[1], and_config.weight[2], and_config.weight[3]);
  }
#line 310
  return;
}
}
#line 315 "/home/june/collector/temp/and-1.2.2/and.c"
void read_priorities(void) 
{ 
  FILE *priority ;
  int bad_count ;
  int line_count ;
  char buffer[1024] ;
  int uid ;
  char uid_s[1024] ;
  int gid ;
  char gid_s[1024] ;
  char command[1024] ;
  int parentmode ;
  char parent[1024] ;
  char parent_s[1024] ;
  int nl0 ;
  int nl1 ;
  int nl2 ;
  struct passwd *lookup_p ;
  struct group *lookup_g ;
  int error ;
  char error_msg[1024] ;
  int i ;
  int entry ;
  int linelen ;
  regex_t *rex ;
  char section_matches ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  int tmp___19 ;

  {
  {
#line 338
  section_matches = (char)1;
#line 340
  priority = fopen((char const   */* __restrict  */)and_config.database_file, (char const   */* __restrict  */)"rt");
  }
#line 340
  if ((unsigned long )priority == (unsigned long )((FILE *)0)) {
    {
#line 341
    and_printf(0, (char *)"Priority database %s not found. Aborting.\n", and_config.database_file);
#line 343
    abort();
    }
  }
  {
#line 345
  and_printf(0, (char *)"Priority database is: %s\n", and_config.database_file);
#line 347
  bad_count = 0;
#line 347
  line_count = bad_count;
#line 348
  and_db.n = 0;
  }
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 349
    tmp___19 = feof(priority);
    }
#line 349
    if (tmp___19) {
#line 349
      goto while_break;
    }
    {
#line 350
    memset((void *)(buffer), 0, (size_t )1024);
#line 351
    tmp = fgets((char */* __restrict  */)(buffer), 1022, (FILE */* __restrict  */)priority);
    }
#line 351
    if ((unsigned long )tmp == (unsigned long )((char *)0)) {
#line 351
      goto while_break;
    }
    {
#line 352
    line_count ++;
#line 354
    tmp___0 = strlen((char const   *)(buffer));
#line 354
    linelen = (int )tmp___0;
    }
#line 355
    if (linelen == 0) {
#line 356
      goto while_continue;
    }
#line 358
    if ((int )buffer[0] == 10) {
#line 359
      goto while_continue;
    } else
#line 358
    if ((int )buffer[0] == 13) {
#line 359
      goto while_continue;
    } else
#line 358
    if ((int )buffer[0] == 35) {
#line 359
      goto while_continue;
    }
#line 361
    if (linelen > 1022) {
      {
#line 362
      and_printf(0, (char *)"Priority database line %i too long: %s\n", line_count,
                 buffer);
#line 364
      bad_count ++;
      }
#line 365
      goto while_continue;
    }
#line 368
    if ((int )buffer[0] == 111) {
#line 368
      if ((int )buffer[1] == 110) {
#line 368
        if ((int )buffer[2] == 32) {
          {
#line 369
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 369
            tmp___2 = strlen((char const   *)(buffer));
            }
#line 369
            if (! ((int )buffer[tmp___2 - 1UL] < 32)) {
#line 369
              goto while_break___0;
            }
            {
#line 370
            tmp___1 = strlen((char const   *)(buffer));
#line 370
            buffer[tmp___1 - 1UL] = (char)0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 372
          tmp___3 = malloc(sizeof(regex_t ));
#line 372
          rex = (regex_t *)tmp___3;
#line 373
          regcomp((regex_t */* __restrict  */)rex, (char const   */* __restrict  */)(& buffer[3]),
                  (((1 << 1) << 1) << 1) | 1);
#line 374
          tmp___4 = regexec((regex_t const   */* __restrict  */)rex, (char const   */* __restrict  */)(and_config.hostname),
                            (size_t )0, (regmatch_t */* __restrict  */)0, 0);
#line 374
          section_matches = (char )(tmp___4 == 0);
          }
#line 375
          if (section_matches) {
#line 375
            tmp___5 = "read";
          } else {
#line 375
            tmp___5 = "skipped";
          }
          {
#line 375
          and_printf(0, (char *)"Priority database line %i: section for host(s) %s will be %s.\n",
                     line_count, & buffer[3], tmp___5);
#line 377
          regfree(rex);
          }
#line 378
          goto while_continue;
        }
      }
    }
#line 380
    if (! section_matches) {
#line 381
      goto while_continue;
    }
    {
#line 383
    i = sscanf((char const   */* __restrict  */)(buffer), (char const   */* __restrict  */)"%s %s %s %s %i %i %i",
               uid_s, gid_s, command, parent_s, & nl0, & nl1, & nl2);
    }
#line 385
    if (i != 7) {
      {
#line 386
      and_printf(0, (char *)"Priority database line %i is invalid: %s\n", line_count,
                 buffer);
#line 388
      bad_count ++;
      }
#line 389
      goto while_continue;
    }
    {
#line 392
    tmp___6 = strcmp((char const   *)(uid_s), "*");
    }
#line 392
    if (tmp___6 == 0) {
#line 393
      uid = -1;
    } else {
      {
#line 394
      lookup_p = getpwnam((char const   *)(uid_s));
      }
#line 394
      if ((unsigned long )lookup_p != (unsigned long )((struct passwd *)0)) {
#line 395
        uid = (int )lookup_p->pw_uid;
      } else {
        {
#line 396
        i = atoi((char const   *)(uid_s));
        }
#line 396
        if (i > 0) {
#line 397
          uid = i;
        } else {
          {
#line 399
          and_printf(0, (char *)"Priority database line %i with invalid UID: %s\n",
                     line_count, uid_s);
#line 401
          bad_count ++;
          }
#line 402
          goto while_continue;
        }
      }
    }
    {
#line 405
    tmp___7 = strcmp((char const   *)(gid_s), "*");
    }
#line 405
    if (tmp___7 == 0) {
#line 406
      gid = -1;
    } else {
      {
#line 407
      lookup_g = getgrnam((char const   *)(gid_s));
      }
#line 407
      if ((unsigned long )lookup_g != (unsigned long )((struct group *)0)) {
#line 408
        gid = (int )lookup_g->gr_gid;
      } else {
        {
#line 409
        i = atoi((char const   *)(gid_s));
        }
#line 409
        if (i > 0) {
#line 410
          gid = i;
        } else {
          {
#line 412
          and_printf(0, (char *)"Priority database line %i with invalid GID: %s\n",
                     line_count, gid_s);
#line 414
          bad_count ++;
          }
#line 415
          goto while_continue;
        }
      }
    }
    {
#line 418
    tmp___14 = strcmp((char const   *)(parent_s), "*");
    }
#line 418
    if (tmp___14 == 0) {
      {
#line 419
      strcpy((char */* __restrict  */)(parent), (char const   */* __restrict  */)"*");
#line 420
      parentmode = 0;
      }
    } else {
      {
#line 421
      tmp___12 = strlen("parent=");
#line 421
      tmp___13 = strncmp((char const   *)(parent_s), "parent=", tmp___12);
      }
#line 421
      if (tmp___13 == 0) {
        {
#line 423
        tmp___8 = strlen("parent=");
#line 423
        strcpy((char */* __restrict  */)(parent), (char const   */* __restrict  */)(& parent_s[tmp___8]));
#line 424
        parentmode = 0;
        }
      } else {
        {
#line 425
        tmp___10 = strlen("ancestor=");
#line 425
        tmp___11 = strncmp((char const   *)(parent_s), "ancestor=", tmp___10);
        }
#line 425
        if (tmp___11 == 0) {
          {
#line 427
          tmp___9 = strlen("ancestor=");
#line 427
          strcpy((char */* __restrict  */)(parent), (char const   */* __restrict  */)(& parent_s[tmp___9]));
#line 428
          parentmode = 1;
          }
        } else {
          {
#line 430
          and_printf(0, (char *)"Priority database line %i with bad parent keyword: %s\n",
                     line_count, parent_s);
#line 432
          bad_count ++;
          }
#line 433
          goto while_continue;
        }
      }
    }
#line 436
    entry = and_db.n;
#line 437
    i = 0;
    {
#line 437
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 437
      if (! (i < and_db.n)) {
#line 437
        goto while_break___1;
      }
#line 438
      if (and_db.entry[i].uid == uid) {
#line 438
        if (and_db.entry[i].gid == gid) {
          {
#line 438
          tmp___15 = strcmp((char const   *)(and_db.entry[i].command_str), (char const   *)(command));
          }
#line 438
          if (tmp___15 == 0) {
            {
#line 438
            tmp___16 = strcmp((char const   *)(and_db.entry[i].parent_str), (char const   *)(parent));
            }
#line 438
            if (tmp___16 == 0) {
#line 441
              entry = i;
#line 442
              goto while_break___1;
            }
          }
        }
      }
#line 437
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 447
    if (! and_db.entry[entry].command) {
      {
#line 448
      and_db.entry[entry].uid = uid;
#line 449
      and_db.entry[entry].gid = gid;
#line 450
      tmp___17 = malloc(sizeof(regex_t ));
#line 450
      and_db.entry[entry].command = (regex_t *)tmp___17;
#line 451
      error = regcomp((regex_t */* __restrict  */)and_db.entry[entry].command, (char const   */* __restrict  */)(command),
                      ((1 << 1) << 1) << 1);
      }
#line 452
      if (error) {
        {
#line 453
        regerror(error, (regex_t const   */* __restrict  */)and_db.entry[entry].command,
                 (char */* __restrict  */)(error_msg), (size_t )1023);
#line 454
        regfree(and_db.entry[entry].command);
#line 455
        free((void *)and_db.entry[entry].command);
#line 456
        and_db.entry[entry].command = (regex_t *)((void *)0);
#line 457
        and_printf(0, (char *)"Priority database line %i with bad command regexp %s (%s)\n",
                   line_count, command, error_msg);
#line 459
        bad_count ++;
        }
#line 460
        goto while_continue;
      }
      {
#line 462
      strncpy((char */* __restrict  */)(and_db.entry[entry].command_str), (char const   */* __restrict  */)(command),
              (size_t )127);
#line 463
      and_db.entry[entry].command_str[127] = (char)0;
#line 464
      tmp___18 = malloc(sizeof(regex_t ));
#line 464
      and_db.entry[entry].parent = (regex_t *)tmp___18;
#line 465
      error = regcomp((regex_t */* __restrict  */)and_db.entry[entry].parent, (char const   */* __restrict  */)(parent),
                      ((1 << 1) << 1) << 1);
      }
#line 466
      if (error) {
        {
#line 467
        regerror(error, (regex_t const   */* __restrict  */)and_db.entry[entry].parent,
                 (char */* __restrict  */)(error_msg), (size_t )1023);
#line 468
        regfree(and_db.entry[entry].parent);
#line 469
        free((void *)and_db.entry[entry].parent);
#line 470
        and_db.entry[entry].parent = (regex_t *)((void *)0);
#line 471
        and_printf(0, (char *)"Priority database line %i with bad parent regexp %s (%s)\n",
                   line_count, parent, error_msg);
#line 473
        bad_count ++;
        }
#line 474
        goto while_continue;
      }
      {
#line 476
      strncpy((char */* __restrict  */)(and_db.entry[entry].parent_str), (char const   */* __restrict  */)(parent),
              (size_t )127);
#line 477
      and_db.entry[entry].parent_str[127] = (char)0;
#line 478
      and_db.entry[entry].parentmode = parentmode;
      }
    }
#line 480
    and_db.entry[entry].nl[0] = nl0;
#line 481
    and_db.entry[entry].nl[1] = nl1;
#line 482
    and_db.entry[entry].nl[2] = nl2;
#line 483
    if (entry == and_db.n) {
#line 484
      (and_db.n) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 488
  fclose(priority);
  }
#line 489
  if (and_config.verbose > 1) {
    {
#line 490
    print_priorities();
    }
  }
#line 492
  if (bad_count) {
    {
#line 493
    and_printf(0, (char *)"Priority database contains %i bad lines. Aborting.\n",
               bad_count);
#line 495
    abort();
    }
  }
#line 497
  return;
}
}
#line 500 "/home/june/collector/temp/and-1.2.2/and.c"
void read_config(void) 
{ 
  FILE *f ;
  int i ;
  int val ;
  int bad ;
  int bad_f ;
  int line ;
  int u ;
  int g ;
  int c ;
  int p ;
  unsigned int uval ;
  char buffer[1024] ;
  char param[1024] ;
  char value[1024] ;
  regex_t *rex ;
  char section_matches ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;

  {
  {
#line 509
  section_matches = (char)1;
#line 510
  f = fopen((char const   */* __restrict  */)and_config.config_file, (char const   */* __restrict  */)"rt");
  }
#line 510
  if ((unsigned long )f == (unsigned long )((FILE *)0)) {
    {
#line 511
    and_printf(0, (char *)"Configuration file %s not found. Aborting.\n", and_config.config_file);
#line 513
    abort();
    }
  }
  {
#line 515
  and_printf(0, (char *)"Configuration file is: %s\n", and_config.config_file);
#line 517
  strcpy((char */* __restrict  */)(and_config.affinity), (char const   */* __restrict  */)"ugcp");
#line 518
  and_config.weight[0] = 8;
#line 519
  and_config.weight[1] = 4;
#line 520
  and_config.weight[2] = 2;
#line 521
  and_config.weight[3] = 1;
#line 522
  and_config.time_mark[0] = 120U;
#line 523
  and_config.time_mark[1] = 1200U;
#line 524
  and_config.time_mark[2] = 3600U;
#line 526
  line = 0;
#line 527
  bad = 0;
#line 528
  fgets((char */* __restrict  */)(buffer), 1023, (FILE */* __restrict  */)f);
  }
  {
#line 529
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 529
    tmp___19 = feof(f);
    }
#line 529
    if (tmp___19) {
#line 529
      goto while_break;
    }
#line 530
    line ++;
#line 531
    if ((int )buffer[0] == 10) {
#line 531
      goto _L;
    } else
#line 531
    if ((int )buffer[0] == 13) {
#line 531
      goto _L;
    } else
#line 531
    if ((int )buffer[0] == 35) {
      _L: /* CIL Label */ 
      {
#line 532
      memset((void *)(buffer), 0, (size_t )1024);
#line 533
      tmp = fgets((char */* __restrict  */)(buffer), 1022, (FILE */* __restrict  */)f);
      }
#line 533
      if ((unsigned long )tmp == (unsigned long )((char *)0)) {
#line 533
        goto while_break;
      }
#line 534
      goto while_continue;
    }
#line 536
    if ((int )buffer[0] == 111) {
#line 536
      if ((int )buffer[1] == 110) {
#line 536
        if ((int )buffer[2] == 32) {
          {
#line 537
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 537
            tmp___1 = strlen((char const   *)(buffer));
            }
#line 537
            if (! ((int )buffer[tmp___1 - 1UL] < 32)) {
#line 537
              goto while_break___0;
            }
            {
#line 538
            tmp___0 = strlen((char const   *)(buffer));
#line 538
            buffer[tmp___0 - 1UL] = (char)0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 540
          tmp___2 = malloc(sizeof(regex_t ));
#line 540
          rex = (regex_t *)tmp___2;
#line 541
          regcomp((regex_t */* __restrict  */)rex, (char const   */* __restrict  */)(& buffer[3]),
                  (((1 << 1) << 1) << 1) | 1);
#line 542
          tmp___3 = regexec((regex_t const   */* __restrict  */)rex, (char const   */* __restrict  */)(and_config.hostname),
                            (size_t )0, (regmatch_t */* __restrict  */)0, 0);
#line 542
          section_matches = (char )(tmp___3 == 0);
          }
#line 543
          if (section_matches) {
#line 543
            tmp___4 = "read";
          } else {
#line 543
            tmp___4 = "skipped";
          }
          {
#line 543
          and_printf(0, (char *)"Configuration file line %i: section for host(s) %s will be %s.\n",
                     line, & buffer[3], tmp___4);
#line 545
          regfree(rex);
#line 546
          buffer[0] = (char )'#';
          }
#line 547
          goto while_continue;
        }
      }
    }
#line 549
    if (! section_matches) {
#line 550
      buffer[0] = (char )'#';
#line 551
      goto while_continue;
    }
    {
#line 553
    tmp___6 = sscanf((char const   */* __restrict  */)(buffer), (char const   */* __restrict  */)"%s %s",
                     param, value);
    }
#line 553
    if (tmp___6 != 2) {
      {
#line 554
      bad ++;
#line 555
      and_printf(0, (char *)"Configuration file line %i is invalid: %s\n", line, buffer);
#line 557
      memset((void *)(buffer), 0, (size_t )1024);
#line 558
      tmp___5 = fgets((char */* __restrict  */)(buffer), 1022, (FILE */* __restrict  */)f);
      }
#line 558
      if ((unsigned long )tmp___5 == (unsigned long )((char *)0)) {
#line 558
        goto while_break;
      }
#line 559
      goto while_continue;
    }
    {
#line 561
    tmp___7 = sscanf((char const   */* __restrict  */)(value), (char const   */* __restrict  */)"%i",
                     & val);
    }
#line 561
    if (tmp___7 != 1) {
#line 561
      val = -1;
    }
    {
#line 562
    tmp___8 = sscanf((char const   */* __restrict  */)(value), (char const   */* __restrict  */)"%u",
                     & uval);
    }
#line 562
    if (tmp___8 != 1) {
#line 562
      uval = 4294967295U;
    }
    {
#line 563
    tmp___17 = strcmp((char const   *)(param), "defaultnice");
    }
#line 563
    if (tmp___17 == 0) {
#line 564
      if (val > -1) {
#line 565
        and_config.nice_default = val;
      } else {
        {
#line 567
        bad ++;
#line 568
        and_printf(0, (char *)"Configuration file line %i has invalid value for defaultnice: %s.\n",
                   line, value);
        }
      }
    } else {
      {
#line 571
      tmp___16 = strcmp((char const   *)(param), "interval");
      }
#line 571
      if (tmp___16 == 0) {
#line 572
        if (and_config.lock_interval) {
          {
#line 573
          and_printf(0, (char *)"Configuration file line %i: interval locked by -i command-line option.\n",
                     line);
          }
        } else
#line 576
        if (uval < 4294967295U) {
#line 577
          and_config.interval = uval;
        } else {
          {
#line 579
          bad ++;
#line 580
          and_printf(0, (char *)"Configuration file line %i has invalid value for interval: %s.\n",
                     line, value);
          }
        }
      } else {
        {
#line 584
        tmp___15 = strcmp((char const   *)(param), "minuid");
        }
#line 584
        if (tmp___15 == 0) {
#line 585
          if (uval < 4294967295U) {
#line 586
            and_config.min_uid = (int )uval;
          } else {
            {
#line 588
            bad ++;
#line 589
            and_printf(0, (char *)"Configuration file line %i has invalid value for minuid: %s.\n",
                       line, value);
            }
          }
        } else {
          {
#line 592
          tmp___14 = strcmp((char const   *)(param), "mingid");
          }
#line 592
          if (tmp___14 == 0) {
#line 593
            if (uval < 4294967295U) {
#line 594
              and_config.min_gid = (int )uval;
            } else {
              {
#line 596
              bad ++;
#line 597
              and_printf(0, (char *)"Configuration file line %i has invalid value for mingid: %s.\n",
                         line, value);
              }
            }
          } else {
            {
#line 600
            tmp___13 = strcmp((char const   *)(param), "lv1time");
            }
#line 600
            if (tmp___13 == 0) {
#line 601
              if (uval < 4294967295U) {
#line 602
                and_config.time_mark[0] = uval;
              } else {
                {
#line 604
                bad ++;
#line 605
                and_printf(0, (char *)"Configuration file line %i has invalid value for lv1time: %s.\n",
                           line, value);
                }
              }
            } else {
              {
#line 608
              tmp___12 = strcmp((char const   *)(param), "lv2time");
              }
#line 608
              if (tmp___12 == 0) {
#line 609
                if (uval < 4294967295U) {
#line 610
                  and_config.time_mark[1] = uval;
                } else {
                  {
#line 612
                  bad ++;
#line 613
                  and_printf(0, (char *)"Configuration file line %i has invalid value for lv2time: %s.\n",
                             line, value);
                  }
                }
              } else {
                {
#line 616
                tmp___11 = strcmp((char const   *)(param), "lv3time");
                }
#line 616
                if (tmp___11 == 0) {
#line 617
                  if (uval < 4294967295U) {
#line 618
                    and_config.time_mark[2] = uval;
                  } else {
                    {
#line 620
                    bad ++;
#line 621
                    and_printf(0, (char *)"Configuration file line %i has invalid value for lv3time: %s.\n",
                               line, value);
                    }
                  }
                } else {
                  {
#line 624
                  tmp___10 = strcmp((char const   *)(param), "affinity");
                  }
#line 624
                  if (tmp___10 == 0) {
                    {
#line 625
                    bad_f = -1;
#line 626
                    p = 0;
#line 626
                    c = p;
#line 626
                    g = c;
#line 626
                    u = g;
#line 627
                    tmp___9 = strlen((char const   *)(value));
                    }
#line 627
                    if (tmp___9 != 4UL) {
                      {
#line 628
                      and_printf(0, (char *)"Configuration file line %i has invalid affinity: %s.\n",
                                 line, value);
#line 630
                      bad ++;
                      }
                    } else {
#line 632
                      i = 0;
                      {
#line 632
                      while (1) {
                        while_continue___1: /* CIL Label */ ;
#line 632
                        if (! (i < 4)) {
#line 632
                          goto while_break___1;
                        }
                        {
#line 634
                        if ((int )value[3 - i] == 117) {
#line 634
                          goto case_117;
                        }
#line 638
                        if ((int )value[3 - i] == 103) {
#line 638
                          goto case_103;
                        }
#line 642
                        if ((int )value[3 - i] == 99) {
#line 642
                          goto case_99;
                        }
#line 646
                        if ((int )value[3 - i] == 112) {
#line 646
                          goto case_112;
                        }
#line 650
                        goto switch_default;
                        case_117: /* CIL Label */ 
#line 635
                        if (! u) {
#line 635
                          and_config.weight[0] = 1 << i;
#line 635
                          u = and_config.weight[0];
                        } else {
#line 636
                          bad_f = i;
                        }
#line 637
                        goto switch_break;
                        case_103: /* CIL Label */ 
#line 639
                        if (! g) {
#line 639
                          and_config.weight[1] = 1 << i;
#line 639
                          g = and_config.weight[1];
                        } else {
#line 640
                          bad_f = i;
                        }
#line 641
                        goto switch_break;
                        case_99: /* CIL Label */ 
#line 643
                        if (! c) {
#line 643
                          and_config.weight[2] = 1 << i;
#line 643
                          c = and_config.weight[2];
                        } else {
#line 644
                          bad_f = i;
                        }
#line 645
                        goto switch_break;
                        case_112: /* CIL Label */ 
#line 647
                        if (! p) {
#line 647
                          and_config.weight[3] = 1 << i;
#line 647
                          p = and_config.weight[3];
                        } else {
#line 648
                          bad_f = i;
                        }
#line 649
                        goto switch_break;
                        switch_default: /* CIL Label */ 
#line 651
                        bad_f = 3 - i;
                        switch_break: /* CIL Label */ ;
                        }
#line 632
                        i ++;
                      }
                      while_break___1: /* CIL Label */ ;
                      }
#line 654
                      if (bad_f > -1) {
                        {
#line 655
                        and_printf(0, (char *)"Configuration file line %i has invalid affinity: %s[%i]=%c.\n",
                                   line, value, bad_f, (int )value[bad_f]);
#line 657
                        bad ++;
                        }
                      } else {
                        {
#line 659
                        strncpy((char */* __restrict  */)(and_config.affinity), (char const   */* __restrict  */)(value),
                                (size_t )4);
#line 660
                        and_config.affinity[4] = (char)0;
                        }
                      }
                    }
                  } else {
                    {
#line 664
                    bad ++;
#line 665
                    and_printf(0, (char *)"Configuration file line %i has invalid parameter: %s.\n",
                               line, param);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 668
    memset((void *)(buffer), 0, (size_t )1024);
#line 669
    tmp___18 = fgets((char */* __restrict  */)(buffer), 1022, (FILE */* __restrict  */)f);
    }
#line 669
    if ((unsigned long )tmp___18 == (unsigned long )((char *)0)) {
#line 669
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 672
  fclose(f);
  }
#line 673
  if (and_config.verbose > 1) {
    {
#line 673
    print_config();
    }
  }
#line 674
  if (bad) {
    {
#line 675
    and_printf(0, (char *)"Configuration file contains %i bad lines. Aborting.\n",
               bad);
#line 677
    abort();
    }
  }
#line 679
  return;
}
}
#line 684 "/home/june/collector/temp/and-1.2.2/and.c"
int and_getnice(int uid , int gid , char *command , struct and_procent *parent , unsigned int cpu_seconds ) 
{ 
  int i ;
  int level ;
  int entry ;
  int exact ;
  int last ;
  struct and_procent *par ;
  int exactness[100] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;

  {
#line 686
  exact = -1;
#line 689
  if (! command) {
    {
#line 690
    and_printf(0, (char *)"Process without command string encountered. Aborting.\n");
#line 691
    abort();
    }
  }
#line 693
  if (uid == 0) {
    {
#line 694
    and_printf(3, (char *)"root is untouchable: %s\n", command);
    }
#line 695
    return (0);
  }
#line 697
  if (uid < and_config.min_uid) {
    {
#line 698
    and_printf(3, (char *)"uid %i is untouchable: %s\n", uid, command);
    }
#line 699
    return (0);
  }
#line 701
  if (gid < and_config.min_gid) {
    {
#line 702
    and_printf(3, (char *)"gid %i is untouchable: %s\n", gid, command);
    }
#line 703
    return (0);
  }
#line 712
  i = 0;
  {
#line 712
  while (1) {
    while_continue: /* CIL Label */ ;
#line 712
    if (! (i < and_db.n)) {
#line 712
      goto while_break;
    }
#line 714
    if (uid == and_db.entry[i].uid) {
#line 715
      exactness[i] = and_config.weight[0];
    } else
#line 716
    if (and_db.entry[i].uid == -1) {
#line 717
      exactness[i] = 0;
    } else {
#line 719
      exactness[i] = -2147483647;
    }
#line 722
    if (gid == and_db.entry[i].gid) {
#line 723
      exactness[i] += and_config.weight[1];
    } else
#line 724
    if (and_db.entry[i].gid == -1) {
#line 725
      exactness[i] = exactness[i];
    } else {
#line 727
      exactness[i] = -2147483647;
    }
#line 730
    if ((unsigned long )command != (unsigned long )((void *)0)) {
      {
#line 730
      tmp___0 = regexec((regex_t const   */* __restrict  */)and_db.entry[i].command,
                        (char const   */* __restrict  */)command, (size_t )0, (regmatch_t */* __restrict  */)0,
                        0);
      }
#line 730
      if (tmp___0 == 0) {
#line 731
        exactness[i] += and_config.weight[2];
      } else {
#line 730
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 732
      tmp = strcmp((char const   *)(and_db.entry[i].command_str), "*");
      }
#line 732
      if (tmp == 0) {
#line 733
        exactness[i] = exactness[i];
      } else {
#line 735
        exactness[i] = -2147483647;
      }
    }
#line 738
    par = parent;
    {
#line 739
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 739
      if (! ((unsigned long )par != (unsigned long )((void *)0))) {
#line 739
        goto while_break___0;
      }
#line 741
      if (and_db.entry[i].parentmode == 0) {
#line 741
        tmp___1 = 1;
      } else
#line 741
      if ((unsigned long )par->parent == (unsigned long )((void *)0)) {
#line 741
        tmp___1 = 1;
      } else {
#line 741
        tmp___1 = 0;
      }
      {
#line 741
      last = tmp___1;
#line 743
      tmp___3 = regexec((regex_t const   */* __restrict  */)and_db.entry[i].parent,
                        (char const   */* __restrict  */)(par->command), (size_t )0,
                        (regmatch_t */* __restrict  */)0, 0);
      }
#line 743
      if (tmp___3 == 0) {
#line 744
        exactness[i] += and_config.weight[3];
#line 745
        goto while_break___0;
      } else
#line 746
      if (last) {
        {
#line 746
        tmp___2 = strcmp((char const   *)(and_db.entry[i].parent_str), "*");
        }
#line 746
        if (tmp___2 == 0) {
#line 747
          exactness[i] = exactness[i];
#line 748
          goto while_break___0;
        } else {
#line 746
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 749
      if (last) {
#line 750
        exactness[i] = -2147483647;
#line 751
        goto while_break___0;
      }
#line 753
      par = par->parent;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 712
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 756
  entry = 0;
#line 757
  exact = -1;
#line 758
  i = 0;
  {
#line 758
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 758
    if (! (i < and_db.n)) {
#line 758
      goto while_break___1;
    }
#line 759
    if (exactness[i] >= exact) {
#line 761
      entry = i;
#line 762
      exact = exactness[i];
    }
#line 758
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 765
  if (exact < 0) {
#line 766
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 766
      tmp___4 = (char const   *)(parent->command);
    } else {
#line 766
      tmp___4 = "(orphan)";
    }
    {
#line 766
    and_printf(2, (char *)"no match for uid=%i gid=%i cmd=%s\n par=%s\n", uid, gid,
               command, tmp___4);
    }
#line 768
    return (and_config.nice_default);
  }
#line 770
  level = 2;
  {
#line 771
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 771
    if (level >= 0) {
#line 771
      if (! (and_config.time_mark[level] > cpu_seconds)) {
#line 771
        goto while_break___2;
      }
    } else {
#line 771
      goto while_break___2;
    }
#line 772
    level --;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 774
  if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 774
    tmp___5 = (char const   *)(parent->command);
  } else {
#line 774
    tmp___5 = "(orphan)";
  }
  {
#line 774
  and_printf(2, (char *)"command=%s (%i,%i,%s) hit on entry=%i, exactness=%i, level=%i.\n",
             command, uid, gid, tmp___5, entry, exact, level);
  }
#line 777
  if (level >= 0) {
#line 777
    tmp___6 = and_db.entry[entry].nl[level];
  } else {
#line 777
    tmp___6 = 0;
  }
#line 777
  return (tmp___6);
}
}
#line 788 "/home/june/collector/temp/and-1.2.2/and.c"
static struct and_procent *(*and_getfirst)()  =    (struct and_procent *(*)())((void *)0);
#line 789 "/home/june/collector/temp/and-1.2.2/and.c"
static struct and_procent *(*and_getnext)()  =    (struct and_procent *(*)())((void *)0);
#line 792 "/home/june/collector/temp/and-1.2.2/and.c"
void and_setprocreader(struct and_procent *(*getfirst)() , struct and_procent *(*getnext)() ) 
{ 


  {
#line 795
  and_getfirst = getfirst;
#line 796
  and_getnext = getnext;
#line 797
  return;
}
}
#line 800 "/home/june/collector/temp/and-1.2.2/and.c"
struct and_procent *and_find_proc(struct and_procent *head , int ppid ) 
{ 
  struct and_procent *current ;

  {
#line 802
  current = head;
  {
#line 803
  while (1) {
    while_continue: /* CIL Label */ ;
#line 803
    if (! ((unsigned long )current != (unsigned long )((void *)0))) {
#line 803
      goto while_break;
    }
#line 805
    if (current->pid == ppid) {
#line 806
      return (current);
    }
#line 807
    current = current->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 809
  and_printf(1, (char *)"no parent for ppid: %d\n", ppid);
  }
#line 810
  return ((struct and_procent *)((void *)0));
}
}
#line 871
extern int ( /* missing proto */  kill)() ;
#line 814 "/home/june/collector/temp/and-1.2.2/and.c"
void and_loop(void) 
{ 
  struct and_procent *head ;
  struct and_procent *current ;
  struct and_procent *new ;
  struct and_procent *proc ;
  int newnice ;
  int njobs ;
  void *tmp ;
  char const   *tmp___0 ;

  {
#line 818
  njobs = 0;
#line 819
  if (! ((unsigned long )and_getfirst != (unsigned long )((void *)0))) {
    {
#line 819
    __assert_fail("and_getfirst != ((void *)0)", "/home/june/collector/temp/and-1.2.2/and.c",
                  819U, "and_loop");
    }
  }
#line 820
  if (! ((unsigned long )and_getnext != (unsigned long )((void *)0))) {
    {
#line 820
    __assert_fail("and_getnext != ((void *)0)", "/home/june/collector/temp/and-1.2.2/and.c",
                  820U, "and_loop");
    }
  }
  {
#line 821
  head = (struct and_procent *)((void *)0);
#line 822
  current = (struct and_procent *)((void *)0);
#line 823
  proc = (*and_getfirst)();
  }
  {
#line 824
  while (1) {
    while_continue: /* CIL Label */ ;
#line 824
    if (! ((unsigned long )proc != (unsigned long )((void *)0))) {
#line 824
      goto while_break;
    }
    {
#line 825
    tmp = malloc(sizeof(struct and_procent ));
#line 825
    new = (struct and_procent *)tmp;
#line 826
    memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)proc, sizeof(struct and_procent ));
#line 827
    new->next = (struct and_procent *)((void *)0);
    }
#line 828
    if ((unsigned long )current != (unsigned long )((void *)0)) {
#line 829
      current->next = new;
    } else {
#line 831
      head = new;
    }
    {
#line 833
    current = new;
#line 834
    proc = (*and_getnext)();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 836
  current = head;
  {
#line 837
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 837
    if (! ((unsigned long )current != (unsigned long )((void *)0))) {
#line 837
      goto while_break___0;
    }
#line 838
    if (current->pid != current->ppid) {
      {
#line 839
      current->parent = and_find_proc(head, current->ppid);
      }
    } else {
#line 841
      current->parent = (struct and_procent *)((void *)0);
    }
#line 842
    if ((unsigned long )current->parent != (unsigned long )((void *)0)) {
#line 842
      tmp___0 = (char const   *)((current->parent)->command);
    } else {
#line 842
      tmp___0 = "(none)";
    }
    {
#line 842
    and_printf(2, (char *)"process %s parent : %s\n", current->command, tmp___0);
#line 844
    current = current->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 846
  current = head;
  {
#line 847
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 847
    if (! ((unsigned long )current != (unsigned long )((void *)0))) {
#line 847
      goto while_break___1;
    }
    {
#line 848
    njobs ++;
#line 849
    newnice = and_getnice(current->uid, current->gid, current->command, current->parent,
                          current->utime);
    }
#line 851
    if (current->uid != 0) {
#line 852
      if (newnice) {
#line 853
        if (newnice > 0) {
#line 854
          if (newnice > current->nice) {
#line 855
            if (and_config.test) {
              {
#line 856
              and_printf(0, (char *)"would renice to %i: %i (%s)\n", newnice, current->pid,
                         current->command);
              }
            } else {
              {
#line 859
              and_printf(1, (char *)"renice to %i: %i (%s)\n", newnice, current->pid,
                         current->command);
#line 861
              setpriority(0, (id_t )current->pid, newnice);
              }
            }
          }
        } else
#line 865
        if (and_config.test) {
          {
#line 866
          and_printf(0, (char *)"would kill %i %i (%s)\n", newnice, current->pid,
                     current->command);
          }
        } else {
          {
#line 869
          and_printf(1, (char *)"kill %i %i (%s)\n", newnice, current->pid, current->command);
#line 871
          kill(current->pid, - newnice);
          }
        }
      }
    }
#line 876
    current = current->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 878
  current = head;
  {
#line 879
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 879
    if (! ((unsigned long )current != (unsigned long )((void *)0))) {
#line 879
      goto while_break___2;
    }
    {
#line 880
    proc = current;
#line 881
    current = current->next;
#line 882
    free((void *)proc);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 884
  return;
}
}
#line 887 "/home/june/collector/temp/and-1.2.2/and.c"
void and_getopt(int argc , char **argv ) 
{ 
  int opt ;
  int value ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 891
  opt = getopt(argc, (char * const  *)argv, "c:d:i:vstxfh");
  }
  {
#line 892
  while (1) {
    while_continue: /* CIL Label */ ;
#line 892
    if (! (opt != -1)) {
#line 892
      goto while_break;
    }
    {
#line 894
    if (opt == 99) {
#line 894
      goto case_99;
    }
#line 899
    if (opt == 100) {
#line 899
      goto case_100;
    }
#line 904
    if (opt == 105) {
#line 904
      goto case_105;
    }
#line 914
    if (opt == 115) {
#line 914
      goto case_115;
    }
#line 917
    if (opt == 118) {
#line 917
      goto case_118;
    }
#line 920
    if (opt == 116) {
#line 920
      goto case_116;
    }
#line 923
    if (opt == 120) {
#line 923
      goto case_120;
    }
#line 926
    if (opt == 102) {
#line 926
      goto case_102;
    }
#line 929
    if (opt == 104) {
#line 929
      goto case_104;
    }
#line 943
    goto switch_default;
    case_99: /* CIL Label */ 
    {
#line 895
    tmp = strlen((char const   *)optarg);
#line 895
    tmp___0 = malloc(tmp + 1UL);
#line 895
    and_config.config_file = (char *)tmp___0;
    }
#line 896
    if (! and_config.config_file) {
      {
#line 896
      __assert_fail("and_config.config_file", "/home/june/collector/temp/and-1.2.2/and.c",
                    896U, "and_getopt");
      }
    }
    {
#line 897
    strcpy((char */* __restrict  */)and_config.config_file, (char const   */* __restrict  */)optarg);
    }
#line 898
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 900
    tmp___1 = strlen((char const   *)optarg);
#line 900
    tmp___2 = malloc(tmp___1 + 1UL);
#line 900
    and_config.database_file = (char *)tmp___2;
    }
#line 901
    if (! and_config.database_file) {
      {
#line 901
      __assert_fail("and_config.database_file", "/home/june/collector/temp/and-1.2.2/and.c",
                    901U, "and_getopt");
      }
    }
    {
#line 902
    strcpy((char */* __restrict  */)and_config.database_file, (char const   */* __restrict  */)optarg);
    }
#line 903
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 905
    value = atoi((char const   *)optarg);
    }
#line 906
    if (value > 0) {
#line 907
      and_config.lock_interval = (char)1;
#line 908
      and_config.interval = (unsigned int )value;
    } else {
      {
#line 910
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: illegal interval: %s\n",
              *(argv + 0), optarg);
#line 911
      exit(1);
      }
    }
#line 913
    goto switch_break;
    case_115: /* CIL Label */ 
#line 915
    and_config.to_stdout = 1;
#line 916
    goto switch_break;
    case_118: /* CIL Label */ 
#line 918
    (and_config.verbose) ++;
#line 919
    goto switch_break;
    case_116: /* CIL Label */ 
#line 921
    and_config.test = 1;
#line 922
    goto switch_break;
    case_120: /* CIL Label */ 
#line 924
    and_config.test = 0;
#line 925
    goto switch_break;
    case_102: /* CIL Label */ 
#line 927
    and_config.foreground = 1;
#line 928
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 930
    printf((char const   */* __restrict  */)"auto nice daemon version %s (%s)\n%s [-v] [-s]  [-t] [-x] [-c configfile] [-d databasefile] [-i interval]\n-v: verbosity -v, -vv, -vvv etc\n-s: log to stdout (default is syslog, or debug.and)\n-x: really execute renices and kills (default)\n-f: don\'t daemonize, stay in foreground\n-t: test configuration (don\'t really renice)\n-i interval: loop interval in seconds (default %i)\n-c configfile: specify config file (default %s)\n-d databasefile: specify priority database file (default %s)\n",
           "1.2.2", "27 Mar 2005", *(argv + 0), 60, "/etc/and.conf", "/etc/and.priorities");
#line 942
    exit(1);
    }
    switch_default: /* CIL Label */ 
    {
#line 944
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try %s -h for help.\n",
            *(argv + 0));
#line 945
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 947
    opt = getopt(argc, (char * const  *)argv, "c:d:i:vstxfh");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 950
  return;
}
}
#line 953 "/home/june/collector/temp/and-1.2.2/and.c"
static int g_reload_conf  ;
#line 956 "/home/june/collector/temp/and-1.2.2/and.c"
void and_trigger_readconf(int sig ) 
{ 


  {
#line 958
  g_reload_conf = sig == 1;
#line 959
  return;
}
}
#line 962 "/home/june/collector/temp/and-1.2.2/and.c"
void and_readconf(void) 
{ 


  {
  {
#line 964
  and_printf(0, (char *)"Re-reading configuration and priority database...\n");
#line 965
  read_config();
#line 966
  read_priorities();
#line 967
  g_reload_conf = 0;
  }
#line 968
  return;
}
}
#line 971 "/home/june/collector/temp/and-1.2.2/and.c"
void and_worker(void) 
{ 


  {
  {
#line 973
  read_config();
#line 974
  read_priorities();
#line 975
  signal(1, & and_trigger_readconf);
#line 976
  and_printf(0, (char *)"AND ready.\n");
#line 977
  g_reload_conf = 0;
  }
  {
#line 978
  while (1) {
    while_continue: /* CIL Label */ ;
#line 979
    if (g_reload_conf) {
      {
#line 980
      and_readconf();
      }
    }
    {
#line 982
    and_loop();
#line 983
    sleep(and_config.interval);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 988 "/home/june/collector/temp/and-1.2.2/and.c"
int and_main(int argc , char **argv ) 
{ 
  __pid_t tmp ;

  {
  {
#line 990
  set_defaults(argc, argv);
#line 991
  and_getopt(argc, argv);
  }
#line 992
  if (and_config.test) {
    {
#line 993
    and_worker();
    }
  } else
#line 995
  if (and_config.foreground) {
    {
#line 996
    and_worker();
    }
  } else {
    {
#line 998
    tmp = fork();
    }
#line 998
    if (tmp == 0) {
      {
#line 998
      and_worker();
      }
    }
  }
#line 1001
  return (0);
}
}
