/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 137 "/usr/include/ncurses.h"
typedef unsigned long chtype;
#line 322
struct _win_st;
#line 322 "/usr/include/ncurses.h"
typedef struct _win_st WINDOW;
#line 324 "/usr/include/ncurses.h"
typedef chtype attr_t;
#line 369
struct ldat;
#line 371 "/usr/include/ncurses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 371 "/usr/include/ncurses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 37 "/home/wslee/benchmarks/sound/mp3c-0.29/src/window_lifo.c"
struct tmp {
   WINDOW *win ;
   void (*proc)(WINDOW *win , int arg1 , int arg2 ) ;
   int arg1 ;
   int arg2 ;
   void *pointer ;
   struct tmp *next ;
   struct tmp *prev ;
};
#line 37 "/home/wslee/benchmarks/sound/mp3c-0.29/src/window_lifo.c"
typedef struct tmp lifo_type;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 192 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 35 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 174 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 97 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 141 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 142 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 225 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 99 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 256 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 44 "/home/wslee/benchmarks/sound/mp3c-0.29/src/socket.c"
union __anonunion_addr_34 {
   struct sockaddr sa ;
   struct sockaddr_in si ;
   struct sockaddr_un su ;
};
#line 11 "/home/wslee/benchmarks/sound/mp3c-0.29/src/mp3creat.h"
struct _field_select_typ {
   char *field ;
   char *dest ;
   char *information ;
   struct _field_select_typ *next ;
   struct _field_select_typ *prev ;
};
#line 11 "/home/wslee/benchmarks/sound/mp3c-0.29/src/mp3creat.h"
typedef struct _field_select_typ field_select_typ;
#line 19 "/home/wslee/benchmarks/sound/mp3c-0.29/src/mp3creat.h"
struct _song_typ {
   unsigned char convert ;
   char *artist ;
   char *title ;
   char *album ;
   char *comment ;
   int year ;
   int genre ;
   char *filename ;
   char *dirname ;
   unsigned char on_fly ;
   char toc ;
   unsigned char fn_auto ;
   long cddb_id ;
   char *tmp_wav_file ;
   long frame_len ;
   unsigned char sampler ;
   struct _song_typ *next ;
   struct _song_typ *prev ;
};
#line 19 "/home/wslee/benchmarks/sound/mp3c-0.29/src/mp3creat.h"
typedef struct _song_typ song_typ;
#line 84 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 150 "/usr/include/bits/types.h"
typedef unsigned int __useconds_t;
#line 180 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 511 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
union __anonunion_53 {
   int __in ;
   int __i ;
};
#line 526 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
union __anonunion_54 {
   int __in ;
   int __i ;
};
#line 649 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
union __anonunion_55 {
   int __in ;
   int __i ;
};
#line 663 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
union __anonunion_56 {
   int __in ;
   int __i ;
};
#line 883 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
union __anonunion_57 {
   int __in ;
   int __i ;
};
#line 888 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
union __anonunion_58 {
   int __in ;
   int __i ;
};
#line 1001 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
union __anonunion_59 {
   int __in ;
   int __i ;
};
#line 1038 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
union __anonunion_60 {
   int __in ;
   int __i ;
};
#line 1058 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
union __anonunion_61 {
   int __in ;
   int __i ;
};
#line 1148 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
union __anonunion_62 {
   int __in ;
   int __i ;
};
#line 1162 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
union __anonunion_63 {
   int __in ;
   int __i ;
};
#line 57 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 134 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 85 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
struct _content {
   char *name ;
   struct _content *prev ;
   struct _content *next ;
};
#line 85 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
typedef struct _content content;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 154 "/usr/include/linux/cdrom.h"
struct cdrom_msf0 {
   __u8 minute ;
   __u8 second ;
   __u8 frame ;
};
#line 162 "/usr/include/linux/cdrom.h"
union cdrom_addr {
   struct cdrom_msf0 msf ;
   int lba ;
};
#line 180 "/usr/include/linux/cdrom.h"
struct cdrom_ti {
   __u8 cdti_trk0 ;
   __u8 cdti_ind0 ;
   __u8 cdti_trk1 ;
   __u8 cdti_ind1 ;
};
#line 189 "/usr/include/linux/cdrom.h"
struct cdrom_tochdr {
   __u8 cdth_trk0 ;
   __u8 cdth_trk1 ;
};
#line 196 "/usr/include/linux/cdrom.h"
struct cdrom_volctrl {
   __u8 channel0 ;
   __u8 channel1 ;
   __u8 channel2 ;
   __u8 channel3 ;
};
#line 205 "/usr/include/linux/cdrom.h"
struct cdrom_subchnl {
   __u8 cdsc_format ;
   __u8 cdsc_audiostatus ;
   __u8 cdsc_adr : 4 ;
   __u8 cdsc_ctrl : 4 ;
   __u8 cdsc_trk ;
   __u8 cdsc_ind ;
   union cdrom_addr cdsc_absaddr ;
   union cdrom_addr cdsc_reladdr ;
};
#line 219 "/usr/include/linux/cdrom.h"
struct cdrom_tocentry {
   __u8 cdte_track ;
   __u8 cdte_adr : 4 ;
   __u8 cdte_ctrl : 4 ;
   __u8 cdte_format ;
   union cdrom_addr cdte_addr ;
   __u8 cdte_datamode ;
};
#line 66 "/home/wslee/benchmarks/sound/mp3c-0.29/src/iocd.c"
struct __anonstruct_cdtoc_35 {
   int min ;
   int sec ;
   int frame ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 819 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 567 "/usr/include/ncurses.h"
extern int delwin(WINDOW * ) ;
#line 671
extern WINDOW *newwin(int  , int  , int  , int  ) ;
#line 792
extern int wrefresh(WINDOW * ) ;
#line 802
extern int wtouchln(WINDOW * , int  , int  , int  ) ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 35 "/home/wslee/benchmarks/sound/mp3c-0.29/src/window_lifo.c"
void wuuush(int code ) ;
#line 47 "/home/wslee/benchmarks/sound/mp3c-0.29/src/window_lifo.c"
lifo_type *active_win  =    (lifo_type *)((void *)0);
#line 48 "/home/wslee/benchmarks/sound/mp3c-0.29/src/window_lifo.c"
lifo_type *lifo_anchor  =    (lifo_type *)((void *)0);
#line 50 "/home/wslee/benchmarks/sound/mp3c-0.29/src/window_lifo.c"
WINDOW *c_newwin(int h , int l , int y , int x , void *proc , int arg1 , int arg2 ) 
{ 
  lifo_type *new ;
  int i ;
  void *tmp ;
  char *__cil_tmp11 ;

  {
  {
#line 55
  tmp = malloc((size_t )sizeof(lifo_type ));
#line 55
  new = (lifo_type *)tmp;
  }
#line 56
  if ((unsigned long )new == (unsigned long )((void *)0)) {
    {
#line 57
    perror("malloc");
#line 58
    wuuush(1);
    }
  }
  {
#line 60
  new->win = newwin(h, l, y, x);
#line 61
  new->proc = (void (*)(WINDOW *win , int arg1 , int arg2 ))proc;
#line 62
  new->arg1 = arg1;
#line 63
  new->arg2 = arg2;
#line 64
  new->next = (struct tmp *)((void *)0);
#line 65
  new->prev = lifo_anchor;
  }
#line 66
  if (lifo_anchor) {
#line 66
    lifo_anchor->next = new;
  } else {
#line 67
    lifo_anchor = new;
  }
#line 68
  active_win = new;
#line 75
  i = 0;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if ((unsigned long )new->win == (unsigned long )((void *)0)) {
#line 76
      if (! (i < 100)) {
#line 76
        goto while_break;
      }
    } else {
#line 76
      goto while_break;
    }
    {
#line 77
    new->win = newwin(h, l, y, x);
#line 78
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  if ((unsigned long )new->win == (unsigned long )((void *)0)) {
    {
#line 83
    new->win = newwin(0, 0, 0, 0);
    }
  }
#line 87
  if ((unsigned long )new->win == (unsigned long )((void *)0)) {
    {
#line 88
    wuuush(3);
    }
  }
#line 91
  return (new->win);
}
}
#line 94 "/home/wslee/benchmarks/sound/mp3c-0.29/src/window_lifo.c"
void lifo_rebuild(lifo_type *win ) 
{ 
  int tmp ;

  {
  {
#line 96
  (*(win->proc))(win->win, win->arg1, win->arg2);
  }
#line 97
  if (win->win) {
#line 97
    tmp = (int )(win->win)->_maxy + 1;
  } else {
#line 97
    tmp = -1;
  }
  {
#line 97
  wtouchln(win->win, 0, tmp, 1);
#line 98
  wrefresh(win->win);
  }
#line 99
  return;
}
}
#line 101 "/home/wslee/benchmarks/sound/mp3c-0.29/src/window_lifo.c"
void lifo_refresh(void) 
{ 
  lifo_type *curr ;

  {
#line 105
  curr = lifo_anchor;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! curr) {
#line 106
      goto while_break;
    }
    {
#line 107
    lifo_rebuild(curr);
    }
#line 108
    if ((unsigned long )curr == (unsigned long )active_win) {
#line 108
      goto while_break;
    }
#line 109
    curr = curr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  return;
}
}
#line 113 "/home/wslee/benchmarks/sound/mp3c-0.29/src/window_lifo.c"
int set_active_win(WINDOW *win ) 
{ 
  lifo_type *curr ;

  {
#line 117
  curr = lifo_anchor;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! curr) {
#line 118
      goto while_break;
    }
#line 119
    if ((unsigned long )win == (unsigned long )curr->win) {
      {
#line 120
      active_win = curr;
#line 121
      lifo_refresh();
      }
#line 122
      return (0);
    }
#line 124
    curr = curr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  return (-1);
}
}
#line 129 "/home/wslee/benchmarks/sound/mp3c-0.29/src/window_lifo.c"
void c_delwin(WINDOW *win ) 
{ 
  lifo_type *curr ;

  {
#line 133
  curr = lifo_anchor;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! ((unsigned long )curr != (unsigned long )((void *)0))) {
#line 134
      goto while_break;
    }
#line 135
    if ((unsigned long )curr->win == (unsigned long )win) {
      {
#line 136
      delwin(curr->win);
      }
#line 137
      if ((unsigned long )curr->prev != (unsigned long )((void *)0)) {
#line 138
        if ((unsigned long )curr->next != (unsigned long )((void *)0)) {
          {
#line 139
          (curr->next)->prev = curr->prev;
#line 140
          (curr->prev)->next = curr->next;
#line 141
          set_active_win((curr->next)->win);
#line 142
          free((void *)curr);
          }
#line 143
          return;
        } else {
          {
#line 145
          (curr->prev)->next = (struct tmp *)((void *)0);
#line 146
          set_active_win((curr->prev)->win);
#line 147
          free((void *)curr);
          }
#line 148
          return;
        }
      } else
#line 150
      if ((unsigned long )curr->next != (unsigned long )((void *)0)) {
        {
#line 151
        lifo_anchor = curr->next;
#line 152
        set_active_win((curr->next)->win);
#line 153
        free((void *)curr);
        }
#line 154
        return;
      } else {
        {
#line 156
        free((void *)curr);
#line 157
        lifo_anchor = (lifo_type *)((void *)0);
        }
#line 158
        return;
      }
    }
#line 161
    curr = curr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  return;
}
}
#line 165 "/home/wslee/benchmarks/sound/mp3c-0.29/src/window_lifo.c"
void store_win_poi(WINDOW *win , void *pointer ) 
{ 
  lifo_type *curr ;

  {
#line 169
  curr = lifo_anchor;
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! curr) {
#line 170
      goto while_break;
    }
#line 171
    if ((unsigned long )curr->win == (unsigned long )win) {
#line 172
      curr->pointer = pointer;
#line 173
      return;
    }
#line 175
    curr = curr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  return;
}
}
#line 179 "/home/wslee/benchmarks/sound/mp3c-0.29/src/window_lifo.c"
void *pop_win_poi(WINDOW *win ) 
{ 
  lifo_type *curr ;

  {
#line 183
  curr = lifo_anchor;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! curr) {
#line 184
      goto while_break;
    }
#line 185
    if ((unsigned long )curr->win == (unsigned long )win) {
#line 186
      return (curr->pointer);
    }
#line 188
    curr = curr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  return ((void *)0);
}
}
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 551 "/usr/include/ncurses.h"
extern int cbreak(void) ;
#line 585
extern int halfdelay(int  ) ;
#line 611
extern int keypad(WINDOW * , _Bool  ) ;
#line 654
extern int mvwin(WINDOW * , int  , int  ) ;
#line 674
extern int nodelay(WINDOW * , _Bool  ) ;
#line 675
extern int noecho(void) ;
#line 751
extern int waddnstr(WINDOW * , char const   * , int  ) ;
#line 760
extern int wbkgd(WINDOW * , chtype  ) ;
#line 761
extern void wbkgdset(WINDOW * , chtype  ) ;
#line 762
extern int wborder(WINDOW * , chtype  , chtype  , chtype  , chtype  , chtype  , chtype  ,
                   chtype  , chtype  ) ;
#line 764
extern int wclear(WINDOW * ) ;
#line 773
extern int wgetch(WINDOW * ) ;
#line 776
extern int whline(WINDOW * , chtype  , int  ) ;
#line 787
extern int wmove(WINDOW * , int  , int  ) ;
#line 865
extern int wresize(WINDOW * , int  , int  ) ;
#line 1327
extern WINDOW *stdscr ;
#line 397 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 40 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *gettext(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 40 "/home/wslee/benchmarks/sound/mp3c-0.29/src/status_win.c"
void win_effect(WINDOW *win , unsigned char e_refresh , unsigned char save_coor ) ;
#line 41
signed char config_fancy_colors ;
#line 42
unsigned char careful_batch ;
#line 44 "/home/wslee/benchmarks/sound/mp3c-0.29/src/status_win.c"
WINDOW *stat_win  ;
#line 45 "/home/wslee/benchmarks/sound/mp3c-0.29/src/status_win.c"
int s_length  ;
#line 46 "/home/wslee/benchmarks/sound/mp3c-0.29/src/status_win.c"
int count_stat_win  =    0;
#line 47 "/home/wslee/benchmarks/sound/mp3c-0.29/src/status_win.c"
int sw_x  ;
#line 47 "/home/wslee/benchmarks/sound/mp3c-0.29/src/status_win.c"
int sw_y  ;
#line 47 "/home/wslee/benchmarks/sound/mp3c-0.29/src/status_win.c"
int sw_l  ;
#line 47 "/home/wslee/benchmarks/sound/mp3c-0.29/src/status_win.c"
int sw_h  ;
#line 49
void print_stat_win(char *text ) ;
#line 51 "/home/wslee/benchmarks/sound/mp3c-0.29/src/status_win.c"
void stat_rebuild(WINDOW *win , int dummy1 , int dummy2 ) 
{ 
  int maxy ;
  int maxx ;
  void *tmp ;

  {
#line 55
  if (stdscr) {
#line 55
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 55
    maxy = -1;
  }
#line 55
  if (stdscr) {
#line 55
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 55
    maxx = -1;
  }
#line 56
  if (maxy < sw_y + sw_h) {
#line 56
    goto _L;
  } else
#line 56
  if (maxx < sw_x + sw_l) {
    _L: /* CIL Label */ 
#line 57
    if (sw_l > maxx) {
#line 57
      sw_l = maxx;
    }
#line 58
    if (sw_h > maxy) {
#line 58
      sw_h = maxy;
    }
    {
#line 59
    sw_x = (maxx - sw_l) >> 1;
#line 60
    sw_y = (maxy - sw_h) >> 1;
#line 62
    mvwin(win, sw_y, sw_x);
#line 63
    wresize(win, sw_h, sw_l);
#line 64
    mvwin(win, sw_y, sw_x);
    }
  }
  {
#line 67
  wclear(win);
#line 68
  wbkgd(win, (unsigned long )(1 << 8) | (1UL << 21));
#line 69
  wborder(win, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0,
          (chtype )0, (chtype )0);
#line 70
  tmp = pop_win_poi(win);
#line 70
  print_stat_win((char *)tmp);
#line 72
  wrefresh(win);
  }
#line 73
  return;
}
}
#line 75 "/home/wslee/benchmarks/sound/mp3c-0.29/src/status_win.c"
void setup_stat_win(int max_length ) 
{ 
  int i ;
  int maxx ;
  int maxy ;

  {
#line 80
  if (careful_batch) {
#line 80
    return;
  }
#line 81
  count_stat_win ++;
#line 82
  if (count_stat_win != 1) {
#line 82
    return;
  }
#line 84
  if (stdscr) {
#line 84
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 84
    maxy = -1;
  }
#line 84
  if (stdscr) {
#line 84
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 84
    maxx = -1;
  }
#line 85
  i = max_length + 2;
#line 86
  if (i > maxx) {
#line 86
    i = maxx;
  }
  {
#line 87
  stat_win = c_newwin(3, i, (maxy - 3) >> 1, (maxx - i) >> 1, (void *)(& stat_rebuild),
                      0, 0);
#line 88
  sw_x = (maxx - i) >> 1;
#line 89
  sw_y = (maxy - 3) >> 1;
#line 90
  sw_h = 3;
#line 91
  sw_l = i;
#line 92
  s_length = i - 2;
#line 94
  wclear(stat_win);
#line 95
  wbkgd(stat_win, (unsigned long )(1 << 8) | (1UL << 21));
#line 96
  wborder(stat_win, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0,
          (chtype )0, (chtype )0);
#line 98
  wrefresh(stat_win);
  }
#line 99
  return;
}
}
#line 101 "/home/wslee/benchmarks/sound/mp3c-0.29/src/status_win.c"
void print_stat_win(char *text ) 
{ 
  int i ;
  chtype old_ch ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;

  {
#line 106
  if (careful_batch) {
    {
#line 107
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            text);
    }
#line 108
    return;
  }
#line 111
  if (count_stat_win < 1) {
#line 111
    return;
  }
#line 112
  if (! text) {
#line 112
    return;
  }
  {
#line 114
  store_win_poi(stat_win, (void *)text);
#line 115
  old_ch = stat_win->_bkgd;
#line 116
  wbkgdset(stat_win, (unsigned long )(2 << 8) | (1UL << 21));
#line 118
  wmove(stat_win, 1, 1);
#line 119
  whline(stat_win, (chtype )' ', s_length);
#line 121
  tmp___0 = strlen((char const   *)text);
  }
#line 121
  if (tmp___0 > (size_t )s_length) {
#line 121
    i = 1;
  } else {
    {
#line 123
    tmp = strlen((char const   *)text);
#line 123
    i = (int )((((size_t )s_length - tmp) >> 1) + 1U);
    }
  }
  {
#line 125
  tmp___1 = wmove(stat_win, 1, i);
  }
#line 125
  if (! (tmp___1 == -1)) {
    {
#line 125
    waddnstr(stat_win, (char const   *)text, s_length);
    }
  }
  {
#line 127
  wbkgdset(stat_win, old_ch);
#line 128
  wrefresh(stat_win);
  }
#line 129
  return;
}
}
#line 131 "/home/wslee/benchmarks/sound/mp3c-0.29/src/status_win.c"
void destroy_stat_win(void) 
{ 


  {
#line 133
  if (careful_batch) {
#line 133
    return;
  }
#line 134
  count_stat_win --;
#line 135
  if (count_stat_win == -1) {
#line 136
    count_stat_win = 0;
#line 137
    return;
  }
#line 139
  if (count_stat_win != 0) {
#line 139
    return;
  }
  {
#line 141
  c_delwin(stat_win);
  }
#line 142
  return;
}
}
#line 144 "/home/wslee/benchmarks/sound/mp3c-0.29/src/status_win.c"
void popup_error_win(char *tx ) 
{ 
  int inp_ch ;
  int maxy ;
  int maxx ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 149
  if (careful_batch) {
    {
#line 150
    tmp = gettext("ERROR: %s\n");
#line 150
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            tx);
    }
#line 151
    return;
  }
#line 154
  if (! tx) {
#line 154
    return;
  }
  {
#line 156
  tmp___0 = strlen((char const   *)tx);
#line 156
  setup_stat_win((int )tmp___0);
#line 157
  print_stat_win(tx);
  }
#line 158
  if (stat_win) {
#line 158
    maxy = (int )stat_win->_maxy + 1;
  } else {
#line 158
    maxy = -1;
  }
#line 158
  if (stat_win) {
#line 158
    maxx = (int )stat_win->_maxx + 1;
  } else {
#line 158
    maxx = -1;
  }
  {
#line 159
  tmp___2 = wmove(stat_win, 2, 1 + ((maxx - 12) >> 1));
  }
#line 159
  if (! (tmp___2 == -1)) {
    {
#line 159
    tmp___1 = gettext("press a key");
#line 159
    waddnstr(stat_win, (char const   *)tmp___1, maxx);
    }
  }
  {
#line 161
  cbreak();
#line 162
  noecho();
#line 163
  keypad(stat_win, (_Bool)1);
  }
#line 164
  if (config_fancy_colors) {
    {
#line 165
    halfdelay(1);
    }
  } else {
    {
#line 167
    nodelay(stat_win, (_Bool)0);
    }
  }
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 170
    inp_ch = wgetch(stat_win);
    }
#line 171
    if (config_fancy_colors) {
      {
#line 172
      win_effect(stat_win, (unsigned char)1, (unsigned char)0);
      }
    }
    {
#line 174
    if (inp_ch == 12) {
#line 174
      goto case_12;
    }
#line 185
    if (inp_ch == 39) {
#line 185
      goto case_39;
    }
#line 185
    if (inp_ch == 27) {
#line 185
      goto case_39;
    }
#line 185
    if (inp_ch == 32) {
#line 185
      goto case_39;
    }
#line 185
    if (inp_ch == 113) {
#line 185
      goto case_39;
    }
#line 185
    if (inp_ch == 81) {
#line 185
      goto case_39;
    }
#line 185
    if (inp_ch == 276) {
#line 185
      goto case_39;
    }
#line 185
    if (inp_ch == 10) {
#line 185
      goto case_39;
    }
#line 185
    if (inp_ch == 13) {
#line 185
      goto case_39;
    }
#line 185
    if (inp_ch == 343) {
#line 185
      goto case_39;
    }
#line 173
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 175
    set_active_win(stat_win);
    }
#line 176
    goto switch_break;
    case_39: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_276: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_343: /* CIL Label */ 
    {
#line 186
    destroy_stat_win();
    }
#line 187
    return;
#line 188
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 105 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 129
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 370 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t htons(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 35 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t inet_addr(char const   *__cp ) ;
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 127
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 341 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 122 "/usr/include/netdb.h"
extern void endhostent(void) ;
#line 143
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 275
extern void endservent(void) ;
#line 289
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 64 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 441 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 40 "/home/wslee/benchmarks/sound/mp3c-0.29/src/socket.c"
int cache_remain ;
#line 44 "/home/wslee/benchmarks/sound/mp3c-0.29/src/socket.c"
static union __anonunion_addr_34 addr  ;
#line 50 "/home/wslee/benchmarks/sound/mp3c-0.29/src/socket.c"
int open_socket(char const   *address ) 
{ 
  int sockfd ;
  int connst ;
  char *hostname ;
  char *servname ;
  char buffer[256] ;
  unsigned char protocol_typ ;
  struct hostent *hp ;
  struct servent *sp ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  unsigned short const   **tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;

  {
  {
#line 63
  tmp___0 = strlen(address);
  }
#line 63
  if (tmp___0 > 255U) {
    {
#line 64
    tmp = gettext("socketaddress is illegal (usage host:port)");
#line 64
    print_stat_win(tmp);
#line 65
    sleep(1U);
    }
#line 66
    return (-1);
  }
  {
#line 69
  memset((void *)((char *)(& addr)), 0, (size_t )sizeof(addr));
#line 70
  hostname = strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)address);
#line 71
  servname = strchr((char const   *)(buffer), ':');
  }
#line 72
  if ((unsigned long )servname == (unsigned long )((void *)0)) {
    {
#line 73
    tmp___1 = gettext("socket is illegal (usage host:port)");
#line 73
    print_stat_win(tmp___1);
#line 74
    sleep(1U);
    }
#line 75
    return (-1);
  }
#line 77
  tmp___2 = servname;
#line 77
  servname ++;
#line 77
  *tmp___2 = (char)0;
#line 78
  if ((unsigned long )hostname == (unsigned long )((void *)0)) {
    {
#line 79
    tmp___3 = gettext("hostname missing (usage host:port)");
#line 79
    print_stat_win(tmp___3);
#line 80
    sleep(1U);
    }
#line 81
    return (-1);
  }
#line 83
  if ((unsigned long )servname == (unsigned long )((void *)0)) {
    {
#line 84
    tmp___4 = gettext("port missing (usage host:port)");
#line 84
    print_stat_win(tmp___4);
#line 85
    sleep(1U);
    }
#line 86
    return (-1);
  }
  {
#line 89
  cache_remain = 0;
#line 92
  tmp___13 = strcasecmp((char const   *)hostname, "local");
  }
#line 92
  if (tmp___13 == 0) {
    {
#line 96
    addr.su.sun_family = (sa_family_t )1;
#line 97
    strcpy((char */* __restrict  */)(addr.su.sun_path), (char const   */* __restrict  */)servname);
#line 98
    protocol_typ = (unsigned char)1;
    }
  } else {
    {
#line 92
    tmp___14 = strcasecmp((char const   *)hostname, "unix");
    }
#line 92
    if (tmp___14 == 0) {
      {
#line 96
      addr.su.sun_family = (sa_family_t )1;
#line 97
      strcpy((char */* __restrict  */)(addr.su.sun_path), (char const   */* __restrict  */)servname);
#line 98
      protocol_typ = (unsigned char)1;
      }
    } else {
      {
#line 106
      addr.si.sin_family = (sa_family_t )2;
#line 108
      tmp___8 = strcmp((char const   *)hostname, "*");
      }
#line 108
      if (tmp___8 == 0) {
#line 109
        addr.si.sin_addr.s_addr = (in_addr_t )0;
      } else {
        {
#line 110
        tmp___7 = strcmp((char const   *)hostname, "loopback");
        }
#line 110
        if (tmp___7 == 0) {
          {
#line 111
          addr.si.sin_addr.s_addr = inet_addr("127.0.0.1");
          }
        } else {
          {
#line 113
          addr.si.sin_addr.s_addr = inet_addr((char const   *)hostname);
          }
#line 114
          if (addr.si.sin_addr.s_addr == 4294967295U) {
            {
#line 115
            tmp___5 = gettext("lookup hostname");
#line 115
            print_stat_win(tmp___5);
#line 119
            hp = gethostbyname((char const   *)hostname);
#line 120
            endhostent();
            }
#line 121
            if ((unsigned long )hp == (unsigned long )((void *)0)) {
              {
#line 122
              tmp___6 = gettext("hostname unknown");
#line 122
              print_stat_win(tmp___6);
#line 123
              sleep(1U);
              }
#line 124
              return (-1);
            }
#line 126
            addr.si.sin_addr.s_addr = ((struct in_addr *)*(hp->h_addr_list + 0))->s_addr;
          }
        }
      }
      {
#line 133
      tmp___12 = __ctype_b_loc();
      }
#line 133
      if ((int const   )*(*tmp___12 + ((int )*servname & 255)) & 2048) {
        {
#line 134
        tmp___9 = atoi((char const   *)servname);
#line 134
        addr.si.sin_port = htons((uint16_t )tmp___9);
        }
      } else {
        {
#line 136
        tmp___10 = gettext("lookup servicename");
#line 136
        print_stat_win(tmp___10);
#line 140
        sp = getservbyname((char const   *)servname, "tcp");
#line 141
        endservent();
        }
#line 142
        if ((unsigned long )sp == (unsigned long )((void *)0)) {
          {
#line 143
          tmp___11 = gettext("service \"%s\" is unknown");
#line 143
          sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)tmp___11,
                  servname);
#line 144
          print_stat_win(buffer);
          }
#line 145
          return (-1);
        }
#line 147
        addr.si.sin_port = (in_port_t )sp->s_port;
      }
#line 149
      protocol_typ = (unsigned char)2;
    }
  }
  {
#line 153
  tmp___15 = gettext("open connection to server");
#line 153
  print_stat_win(tmp___15);
  }
#line 154
  if ((int )protocol_typ == 1) {
    {
#line 155
    sockfd = socket((int )addr.su.sun_family, 1, 0);
    }
  } else {
    {
#line 157
    sockfd = socket((int )addr.si.sin_family, 1, 0);
    }
  }
#line 159
  if (sockfd == -1) {
    {
#line 160
    tmp___16 = gettext("opening socket failed");
#line 160
    print_stat_win(tmp___16);
    }
#line 164
    return (-1);
  }
  {
#line 172
  tmp___17 = gettext("connect to server");
#line 172
  print_stat_win(tmp___17);
  }
#line 173
  if ((int )protocol_typ == 1) {
    {
#line 174
    connst = connect(sockfd, (struct sockaddr  const  *)(& addr.sa), (socklen_t )sizeof(struct sockaddr_un ));
    }
  } else {
    {
#line 176
    connst = connect(sockfd, (struct sockaddr  const  *)(& addr.sa), (socklen_t )sizeof(struct sockaddr_in ));
    }
  }
#line 178
  if (connst == -1) {
    {
#line 179
    tmp___18 = gettext("connecting socket failed");
#line 179
    print_stat_win(tmp___18);
    }
#line 183
    return (-1);
  }
  {
#line 190
  connst = fcntl(sockfd, 4, 2048);
  }
#line 191
  if (connst == -1) {
    {
#line 192
    tmp___19 = gettext("setting socket to nonblock mode failed.\n");
#line 192
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___19);
    }
#line 196
    return (-1);
  }
#line 199
  cache_remain = 0;
#line 201
  return (sockfd);
}
}
#line 575 "/usr/include/ncurses.h"
extern int endwin(void) ;
#line 596
extern WINDOW *initscr(void) ;
#line 101 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 41 "/home/wslee/benchmarks/sound/mp3c-0.29/src/signal.c"
unsigned char select_yesno_box(char *tx ) ;
#line 44
song_typ *lay_curr_anchor[2] ;
#line 45
int lay_select_line[2] ;
#line 46
field_select_typ *curr_an ;
#line 47
int curr_line ;
#line 49
static void handle_int(int sig ) ;
#line 50
static void handle_winch(int sig ) ;
#line 51
static void handle_pipe(int sig ) ;
#line 53 "/home/wslee/benchmarks/sound/mp3c-0.29/src/signal.c"
void act_signal_handler(void) 
{ 


  {
  {
#line 55
  signal(2, & handle_int);
#line 56
  signal(28, & handle_winch);
#line 57
  signal(1, & handle_int);
#line 58
  signal(13, & handle_pipe);
  }
#line 59
  return;
}
}
#line 61 "/home/wslee/benchmarks/sound/mp3c-0.29/src/signal.c"
static void handle_int(int sig ) 
{ 
  char *tmp ;
  unsigned char tmp___0 ;
  char *__cil_tmp4 ;

  {
  {
#line 64
  tmp = gettext("Interrupt. Leave program?");
#line 64
  tmp___0 = select_yesno_box(tmp);
  }
#line 64
  if (tmp___0) {
    {
#line 65
    wuuush(2);
    }
  }
  {
#line 69
  signal(2, & handle_int);
#line 70
  signal(1, & handle_int);
  }
#line 71
  return;
}
}
#line 75 "/home/wslee/benchmarks/sound/mp3c-0.29/src/signal.c"
static void handle_winch(int sig ) 
{ 
  int maxy ;
  int maxx ;
  int i ;

  {
  {
#line 81
  signal(28, & handle_winch);
#line 83
  endwin();
#line 84
  wrefresh(stdscr);
#line 85
  initscr();
  }
#line 88
  if (stdscr) {
#line 88
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 88
    maxy = -1;
  }
#line 88
  if (stdscr) {
#line 88
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 88
    maxx = -1;
  }
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (i <= 1)) {
#line 91
      goto while_break;
    }
    {
#line 92
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 92
      if (! (lay_select_line[i] > maxy - 8)) {
#line 92
        goto while_break___0;
      }
#line 93
      (lay_select_line[i]) --;
#line 94
      if (lay_curr_anchor[i]) {
#line 94
        if ((lay_curr_anchor[i])->prev) {
#line 94
          lay_curr_anchor[i] = (lay_curr_anchor[i])->prev;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 91
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 99
    if (! (curr_line > maxy >> 1)) {
#line 99
      goto while_break___1;
    }
#line 100
    curr_line --;
#line 101
    if (curr_an) {
#line 101
      if (curr_an->prev) {
#line 101
        curr_an = curr_an->prev;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 105
  lifo_refresh();
  }
#line 106
  return;
}
}
#line 109 "/home/wslee/benchmarks/sound/mp3c-0.29/src/signal.c"
static void handle_pipe(int sig ) 
{ 


  {
  {
#line 112
  signal(13, & handle_pipe);
  }
#line 113
  return;
}
}
#line 485 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 566
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 231 "/usr/include/ncurses.h"
extern chtype acs_map[] ;
#line 561
extern int curs_set(int  ) ;
#line 748
extern int waddch(WINDOW * , chtype const    ) ;
#line 288 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
#line 350
extern int close(int __fd ) ;
#line 357
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 363
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 414
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 456
extern int usleep(__useconds_t __useconds ) ;
#line 529
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) execvp)(char const   *__file ,
                                                                                   char * const  *__argv ) ;
#line 773
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 842
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 126 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 63 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
char *build_mp3_filenm(song_typ *track ) ;
#line 64
char *create_sub_string(song_typ *track , int mode ) ;
#line 65
char **build_arg_tree(char const   *line ) ;
#line 66
void free_char_array(char **array ) ;
#line 71
int create_sub_dirs(char *filename , unsigned char mode ) ;
#line 72
char *return_track_tmpname(song_typ *track ) ;
#line 73
void is_stat(WINDOW *win , int ys , int ye , int x , int abs___0 , int tot ) ;
#line 76
char *def_mp3_info ;
#line 77
char *def_cd_rip_nf ;
#line 78
char *def_cd_rip_of ;
#line 79
char *def_mp3_enc_nf ;
#line 80
char *def_mp3_enc_of ;
#line 81
int of_fifo_buf ;
#line 84
unsigned char str_path_check(char *program ) ;
#line 85 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
WINDOW *proc_out_win  ;
#line 86 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
char **proc_stat  ;
#line 87 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
int proc_line  ;
#line 87 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
int proc_pos  ;
#line 87 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
int proc_outl  ;
#line 87 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
int proc_reserv  ;
#line 88 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
unsigned char proc_scroll  ;
#line 89 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
pid_t proc_child1  ;
#line 89 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
pid_t proc_child2  ;
#line 90 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
int proc_stdin1  ;
#line 90 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
int proc_stdout1  ;
#line 90 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
int proc_stderr1  ;
#line 91 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
int proc_stdin2  ;
#line 91 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
int proc_stdout2  ;
#line 91 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
int proc_stderr2  ;
#line 92 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
char *proc_sub  =    (char *)((void *)0);
#line 93 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
char *proc_fifo  ;
#line 94 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
int proc_fifo_in  ;
#line 94 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
int proc_fifo_out  ;
#line 95 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
int fifo_for_maxx  ;
#line 97 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
void proc_win_linstat(WINDOW *win ) 
{ 
  int maxy ;
  int maxx ;
  int i ;
  int j ;
  int line ;
  int x ;
  int tmp ;

  {
#line 103
  if (! proc_stat) {
#line 103
    return;
  } else
#line 103
  if (proc_outl > proc_reserv - 1) {
#line 103
    return;
  }
#line 105
  if (win) {
#line 105
    maxy = (int )win->_maxy + 1;
  } else {
#line 105
    maxy = -1;
  }
#line 105
  if (win) {
#line 105
    maxx = (int )win->_maxx + 1;
  } else {
#line 105
    maxx = -1;
  }
  {
#line 106
  is_stat(win, 3, maxy - 2, maxx - 1, proc_outl, proc_reserv - 1);
#line 107
  fifo_for_maxx = maxx;
#line 108
  line = 3;
#line 109
  wmove(win, 3, 1);
#line 110
  whline(win, (chtype )' ', maxx - 2);
#line 112
  j = 0;
#line 113
  i = proc_outl;
#line 114
  proc_scroll = (unsigned char)0;
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! *(proc_stat + i)) {
      {
#line 118
      wrefresh(win);
      }
#line 119
      return;
    }
#line 121
    x = 1;
    {
#line 121
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 121
      if (! (x < maxx - 1)) {
#line 121
        goto while_break___0;
      }
#line 122
      if ((int )*(*(proc_stat + i) + j) == 0) {
#line 122
        goto while_break___0;
      }
      {
#line 123
      tmp = j;
#line 123
      j ++;
#line 123
      waddch(win, (chtype const   )*(*(proc_stat + i) + tmp));
#line 121
      x ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 125
    line ++;
#line 126
    if (line == maxy - 1) {
      {
#line 127
      proc_scroll = (unsigned char)1;
#line 128
      wrefresh(win);
      }
#line 129
      return;
    }
    {
#line 131
    wmove(win, line, 1);
#line 132
    whline(win, (chtype )' ', maxx - 2);
    }
#line 133
    if ((int )*(*(proc_stat + i) + j) == 0) {
#line 134
      i ++;
#line 135
      j = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 139
  wrefresh(win);
  }
#line 140
  return;
}
}
#line 143 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
void proc_win_rebuild(WINDOW *win , int arg1 , int arg2 ) 
{ 
  int maxy ;
  int maxx ;
  int x ;
  char *tx ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 149
  if (stdscr) {
#line 149
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 149
    maxy = -1;
  }
#line 149
  if (stdscr) {
#line 149
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 149
    maxx = -1;
  }
  {
#line 150
  fifo_for_maxx = maxx;
#line 151
  wresize(win, maxy >> 1, maxx);
#line 152
  mvwin(win, maxy >> 2, 0);
#line 154
  wbkgd(win, (unsigned long )(1 << 8) | (1UL << 21));
#line 155
  wclear(win);
#line 156
  wborder(win, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0,
          (chtype )0, (chtype )0);
#line 157
  tmp = wmove(win, 2, 0);
  }
#line 157
  if (! (tmp == -1)) {
    {
#line 157
    waddch(win, (chtype const   )acs_map[(unsigned char )'t']);
    }
  }
  {
#line 158
  whline(win, acs_map[(unsigned char )'q'], maxx - 2);
#line 159
  tmp___0 = wmove(win, 2, maxx - 1);
  }
#line 159
  if (! (tmp___0 == -1)) {
    {
#line 159
    waddch(win, (chtype const   )acs_map[(unsigned char )'u']);
    }
  }
  {
#line 161
  tmp___1 = pop_win_poi(win);
#line 161
  tx = (char *)tmp___1;
  }
#line 162
  if (tx) {
    {
#line 163
    tmp___2 = strlen((char const   *)tx);
#line 163
    x = (int )(((size_t )maxx - tmp___2) >> 1);
    }
#line 164
    if (x < 1) {
#line 164
      x = 1;
    }
    {
#line 165
    tmp___3 = wmove(win, 1, x);
    }
#line 165
    if (! (tmp___3 == -1)) {
      {
#line 165
      waddnstr(win, (char const   *)tx, maxx - 2);
      }
    }
  }
  {
#line 168
  tmp___4 = gettext("F10 to cancel");
#line 168
  tmp___5 = strlen((char const   *)tmp___4);
#line 168
  x = (int )((size_t )maxx - (tmp___5 + 1U));
  }
#line 169
  if (x < 1) {
#line 169
    x = 1;
  }
  {
#line 170
  tmp___7 = wmove(win, (maxy >> 1) - 1, x);
  }
#line 170
  if (! (tmp___7 == -1)) {
    {
#line 170
    tmp___6 = gettext("F10 to cancel");
#line 170
    waddnstr(win, (char const   *)tmp___6, maxx - 2);
    }
  }
#line 172
  proc_outl = 0;
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 174
    proc_win_linstat(win);
    }
#line 175
    if (proc_scroll) {
#line 175
      proc_outl ++;
    } else {
#line 176
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 178
  curs_set(0);
  }
#line 179
  return;
}
}
#line 181 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
void open_process_win(char *tx ) 
{ 
  int maxy ;
  int maxx ;
  void *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 185
  tmp = malloc((size_t )sizeof(char *));
#line 185
  proc_stat = (char **)tmp;
  }
#line 186
  if (! proc_stat) {
    {
#line 187
    perror("malloc");
#line 188
    wuuush(1);
    }
  }
#line 191
  *(proc_stat + 0) = (char *)((void *)0);
#line 192
  proc_line = 0;
#line 193
  proc_outl = 0;
#line 194
  proc_pos = 0;
#line 195
  proc_reserv = 1;
#line 196
  proc_scroll = (unsigned char)0;
#line 198
  if (stdscr) {
#line 198
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 198
    maxy = -1;
  }
#line 198
  if (stdscr) {
#line 198
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 198
    maxx = -1;
  }
  {
#line 199
  fifo_for_maxx = maxx;
#line 200
  proc_out_win = c_newwin(maxy >> 1, maxx, maxy >> 2, 0, (void *)(& proc_win_rebuild),
                          0, 0);
#line 201
  store_win_poi(proc_out_win, (void *)tx);
#line 202
  proc_win_rebuild(proc_out_win, 0, 0);
  }
#line 203
  return;
}
}
#line 205 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
void del_process_win(void) 
{ 


  {
  {
#line 207
  c_delwin(proc_out_win);
#line 208
  free_char_array(proc_stat);
  }
#line 209
  return;
}
}
#line 211 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
void proc_add_fd(int fd ) 
{ 
  char buf ;
  char *poi ;
  int len ;
  int pos ;
  int bytes ;
  ssize_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  unsigned short const   **tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 219
  len = 0;
#line 220
  pos = 0;
#line 221
  poi = (char *)((void *)0);
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 223
    tmp = read(fd, (void *)(& buf), (size_t )1);
    }
#line 223
    if (tmp != 1) {
#line 223
      goto while_break;
    }
#line 224
    if (buf) {
#line 225
      if ((int )buf == 10) {
#line 225
        goto _L;
      } else
#line 225
      if ((int )buf == 13) {
        _L: /* CIL Label */ 
#line 226
        if (proc_reserv <= proc_line + 1) {
          {
#line 227
          proc_reserv = proc_line + 2;
#line 228
          tmp___0 = realloc((void *)proc_stat, (size_t )(sizeof(char *) * (unsigned long )proc_reserv));
#line 228
          proc_stat = (char **)tmp___0;
          }
#line 229
          if (! proc_stat) {
            {
#line 230
            perror("realloc");
#line 231
            wuuush(1);
            }
          }
#line 233
          *(proc_stat + (proc_reserv - 1)) = (char *)((void *)0);
        }
        {
#line 235
        bytes = (proc_pos + pos) + 1;
#line 236
        tmp___1 = realloc((void *)*(proc_stat + proc_line), (size_t )(sizeof(char ) * (unsigned long )bytes));
#line 236
        *(proc_stat + proc_line) = (char *)tmp___1;
        }
#line 238
        if (! *(proc_stat + proc_line)) {
          {
#line 239
          perror("realloc");
#line 240
          wuuush(1);
          }
        }
#line 242
        if (pos) {
          {
#line 242
          memcpy((void */* __restrict  */)(*(proc_stat + proc_line) + proc_pos), (void const   */* __restrict  */)poi,
                 (size_t )pos);
          }
        }
#line 243
        *(*(proc_stat + proc_line) + (bytes - 1)) = (char)0;
#line 244
        proc_pos = 0;
#line 245
        pos = 0;
#line 246
        if ((int )buf == 10) {
          {
#line 247
          proc_line ++;
#line 248
          proc_win_linstat(proc_out_win);
          }
#line 249
          if (proc_scroll) {
            {
#line 250
            proc_outl ++;
#line 251
            proc_win_linstat(proc_out_win);
            }
          }
#line 253
          if (proc_reserv <= proc_line + 1) {
            {
#line 254
            proc_reserv = proc_line + 2;
#line 255
            tmp___2 = realloc((void *)proc_stat, (size_t )(sizeof(char *) * (unsigned long )proc_reserv));
#line 255
            proc_stat = (char **)tmp___2;
            }
#line 256
            if (! proc_stat) {
              {
#line 257
              perror("realloc");
#line 258
              wuuush(1);
              }
            }
#line 260
            *(proc_stat + (proc_reserv - 1)) = (char *)((void *)0);
          }
        }
      } else {
        {
#line 263
        tmp___4 = __ctype_b_loc();
        }
#line 263
        if ((int const   )*(*tmp___4 + (int )buf) & 16384) {
#line 264
          if (pos >= len - 1) {
            {
#line 265
            len += 128;
#line 266
            tmp___3 = realloc((void *)poi, (size_t )(sizeof(char ) * (unsigned long )len));
#line 266
            poi = (char *)tmp___3;
            }
#line 267
            if (! poi) {
              {
#line 268
              perror("realloc");
#line 269
              wuuush(1);
              }
            }
          }
#line 272
          *(poi + pos) = buf;
#line 273
          pos ++;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 278
  if (pos) {
#line 279
    if (proc_reserv <= proc_line + 1) {
      {
#line 280
      proc_reserv = proc_line + 2;
#line 281
      tmp___5 = realloc((void *)proc_stat, (size_t )(sizeof(char *) * (unsigned long )proc_reserv));
#line 281
      proc_stat = (char **)tmp___5;
      }
#line 282
      if (! proc_stat) {
        {
#line 283
        perror("realloc");
#line 284
        wuuush(1);
        }
      }
#line 286
      *(proc_stat + (proc_reserv - 1)) = (char *)((void *)0);
    }
    {
#line 288
    bytes = (proc_pos + pos) + 1;
#line 289
    tmp___6 = realloc((void *)*(proc_stat + proc_line), (size_t )(sizeof(char ) * (unsigned long )bytes));
#line 289
    *(proc_stat + proc_line) = (char *)tmp___6;
    }
#line 291
    if (! *(proc_stat + proc_line)) {
      {
#line 292
      perror("realloc");
#line 293
      wuuush(1);
      }
    }
    {
#line 295
    memcpy((void */* __restrict  */)(*(proc_stat + proc_line) + proc_pos), (void const   */* __restrict  */)poi,
           (size_t )pos);
#line 296
    *(*(proc_stat + proc_line) + (bytes - 1)) = (char)0;
#line 297
    proc_pos = bytes - 1;
    }
  }
#line 300
  if (poi) {
    {
#line 300
    free((void *)poi);
    }
  }
#line 301
  return;
}
}
#line 303 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
int evaluate_proc(int fd1 , int fd2 , int fd3 , unsigned char flag , unsigned char emergency ) 
{ 
  int inp_ch ;
  unsigned char break_out ;

  {
#line 308
  if (fd1 != -1) {
    {
#line 308
    proc_add_fd(fd1);
    }
  }
#line 309
  if (fd2 != -1) {
    {
#line 309
    proc_add_fd(fd2);
    }
  }
#line 310
  if (fd3 != -1) {
    {
#line 310
    proc_add_fd(fd3);
    }
  }
  {
#line 311
  proc_win_linstat(proc_out_win);
#line 313
  cbreak();
#line 314
  noecho();
#line 315
  keypad(proc_out_win, (_Bool)1);
  }
#line 316
  if (flag) {
    {
#line 316
    nodelay(proc_out_win, (_Bool)1);
    }
  } else {
    {
#line 317
    halfdelay(2);
    }
  }
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    break_out = (unsigned char)1;
#line 321
    if (config_fancy_colors) {
#line 321
      if (! flag) {
        {
#line 321
        win_effect(proc_out_win, (unsigned char)1, (unsigned char)0);
        }
      }
    }
    {
#line 322
    inp_ch = wgetch(proc_out_win);
    }
    {
#line 325
    if (inp_ch == 48) {
#line 325
      goto case_48;
    }
#line 325
    if (inp_ch == 274) {
#line 325
      goto case_48;
    }
#line 329
    if (inp_ch == 12) {
#line 329
      goto case_12;
    }
#line 334
    if (inp_ch == 259) {
#line 334
      goto case_259;
    }
#line 342
    if (inp_ch == 258) {
#line 342
      goto case_258;
    }
#line 358
    if (inp_ch == 27) {
#line 358
      goto case_27;
    }
#line 358
    if (inp_ch == 32) {
#line 358
      goto case_27;
    }
#line 358
    if (inp_ch == 113) {
#line 358
      goto case_27;
    }
#line 358
    if (inp_ch == 81) {
#line 358
      goto case_27;
    }
#line 358
    if (inp_ch == 39) {
#line 358
      goto case_27;
    }
#line 358
    if (inp_ch == 276) {
#line 358
      goto case_27;
    }
#line 358
    if (inp_ch == 10) {
#line 358
      goto case_27;
    }
#line 358
    if (inp_ch == 13) {
#line 358
      goto case_27;
    }
#line 358
    if (inp_ch == 343) {
#line 358
      goto case_27;
    }
#line 323
    goto switch_break;
    case_48: /* CIL Label */ 
    case_274: /* CIL Label */ 
#line 326
    return (1);
#line 327
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 330
    set_active_win(proc_out_win);
#line 331
    break_out = (unsigned char)0;
    }
#line 332
    goto switch_break;
    case_259: /* CIL Label */ 
#line 335
    if (proc_outl) {
      {
#line 336
      proc_outl --;
#line 337
      proc_win_linstat(proc_out_win);
      }
    }
#line 339
    break_out = (unsigned char)0;
#line 340
    goto switch_break;
    case_258: /* CIL Label */ 
#line 343
    if (proc_scroll) {
      {
#line 344
      proc_outl ++;
#line 345
      proc_win_linstat(proc_out_win);
      }
    }
#line 347
    break_out = (unsigned char)0;
#line 348
    goto switch_break;
    case_27: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_39: /* CIL Label */ 
    case_276: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_343: /* CIL Label */ 
#line 359
    if (emergency) {
#line 360
      return (1);
    }
#line 362
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 364
    if (break_out) {
#line 364
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  return (0);
}
}
#line 370 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
void shell_change_proc_title(char *tx ) 
{ 


  {
  {
#line 372
  store_win_poi(proc_out_win, (void *)tx);
#line 373
  set_active_win(proc_out_win);
  }
#line 374
  return;
}
}
#line 376 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
void shell_wait_for_close_proc(int fd1 , int fd2 , int fd3 ) 
{ 
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 378
  tmp = gettext("Failure: read error message before exit");
#line 378
  shell_change_proc_title(tmp);
  }
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 379
    tmp___0 = evaluate_proc(fd1, fd2, fd3, (unsigned char)0, (unsigned char)1);
    }
#line 379
    if (tmp___0) {
#line 379
      goto while_break;
    }
    {
#line 380
    usleep((__useconds_t )50000);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 382
  return;
}
}
#line 385 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
int rip_non_fly(song_typ *track ) 
{ 
  int new_pipe1[2] ;
  int new_pipe2[2] ;
  char *cmd_line ;
  char **cmd_args ;
  int status ;
  char *filenm ;
  char *tmp_file ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;
  unsigned char tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  unsigned char tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  void *tmp___22 ;
  char *tmp___23 ;
  __pid_t tmp___24 ;
  int tmp___25 ;
  union __anonunion_53 __constr_expr_0 ;
  char *tmp___26 ;
  union __anonunion_54 __constr_expr_1 ;
  char *tmp___27 ;
  void *__cil_tmp40 ;
  void *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;

  {
  {
#line 395
  tmp_file = return_track_tmpname(track);
#line 397
  tmp = create_sub_dirs(tmp_file, (unsigned char)1);
  }
#line 397
  if (tmp) {
#line 397
    return (1);
  }
  {
#line 399
  tmp___4 = access((char const   *)tmp_file, 0);
  }
#line 399
  if (tmp___4 == 0) {
    {
#line 400
    tmp___1 = access((char const   *)tmp_file, 2);
    }
#line 400
    if (tmp___1 != 0) {
      {
#line 401
      tmp___0 = gettext("tempfile not writable");
#line 401
      popup_error_win(tmp___0);
      }
#line 402
      return (1);
    }
    {
#line 404
    tmp___3 = unlink((char const   *)tmp_file);
    }
#line 404
    if (tmp___3 != 0) {
      {
#line 405
      tmp___2 = gettext("could not delete tempfile");
#line 405
      popup_error_win(tmp___2);
      }
#line 406
      return (1);
    }
  }
  {
#line 410
  filenm = build_mp3_filenm(track);
#line 412
  tmp___5 = create_sub_dirs(filenm, (unsigned char)1);
  }
#line 412
  if (tmp___5) {
#line 412
    return (1);
  }
  {
#line 414
  tmp___12 = access((char const   *)filenm, 0);
  }
#line 414
  if (tmp___12 == 0) {
    {
#line 416
    tmp___7 = access((char const   *)filenm, 2);
    }
#line 416
    if (tmp___7 != 0) {
      {
#line 418
      tmp___6 = gettext("mp3-file already exists and isn\'t writable");
#line 418
      popup_error_win(tmp___6);
      }
#line 419
      return (1);
    }
    {
#line 422
    tmp___8 = strlen((char const   *)filenm);
#line 422
    tmp___9 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___8 + 40U)));
#line 422
    cmd_line = (char *)tmp___9;
    }
#line 423
    if ((unsigned long )cmd_line == (unsigned long )((void *)0)) {
      {
#line 424
      perror("malloc");
#line 425
      wuuush(1);
      }
    }
    {
#line 427
    tmp___10 = gettext("overwrite \"%s\"?");
#line 427
    sprintf((char */* __restrict  */)cmd_line, (char const   */* __restrict  */)tmp___10,
            filenm);
#line 428
    tmp___11 = select_yesno_box(cmd_line);
    }
#line 428
    if (! tmp___11) {
      {
#line 429
      free((void *)cmd_line);
      }
#line 430
      return (2);
    }
    {
#line 432
    free((void *)cmd_line);
    }
  }
  {
#line 436
  tmp___14 = str_path_check(def_cd_rip_nf);
  }
#line 436
  if (! tmp___14) {
    {
#line 437
    tmp___13 = gettext("couldn\'t rip, no prg in $PATH");
#line 437
    popup_error_win(tmp___13);
    }
#line 438
    return (1);
  }
  {
#line 441
  tmp___16 = pipe((int *)(new_pipe1));
  }
#line 441
  if (tmp___16 != 0) {
    {
#line 442
    tmp___15 = gettext("error opening pipe for STDOUT");
#line 442
    popup_error_win(tmp___15);
    }
#line 443
    return (1);
  }
  {
#line 445
  tmp___18 = pipe((int *)(new_pipe2));
  }
#line 445
  if (tmp___18 != 0) {
    {
#line 446
    tmp___17 = gettext("error opening pipe for STDERR");
#line 446
    popup_error_win(tmp___17);
    }
#line 447
    return (1);
  }
  {
#line 450
  proc_stdout1 = new_pipe1[0];
#line 451
  proc_stderr1 = new_pipe2[0];
#line 453
  proc_child1 = fork();
  }
#line 454
  if (proc_child1 == -1) {
    {
#line 455
    tmp___19 = gettext("forking failed");
#line 455
    popup_error_win(tmp___19);
    }
#line 456
    return (1);
  }
#line 459
  if (proc_child1 == 0) {
    {
#line 460
    tmp___20 = dup2(new_pipe1[1], 1);
    }
#line 460
    if (tmp___20 == -1) {
      {
#line 461
      exit(1);
      }
    }
    {
#line 463
    tmp___21 = dup2(new_pipe2[1], 2);
    }
#line 463
    if (tmp___21 == -1) {
      {
#line 464
      exit(1);
      }
    }
    {
#line 467
    close(new_pipe1[0]);
#line 468
    close(new_pipe2[0]);
#line 475
    cmd_line = create_sub_string(track, 3);
    }
#line 476
    if (! cmd_line) {
      {
#line 477
      exit(1);
      }
    }
    {
#line 480
    cmd_args = build_arg_tree((char const   *)cmd_line);
    }
#line 481
    if (! cmd_args) {
      {
#line 482
      exit(1);
      }
    }
    {
#line 485
    execvp((char const   *)*(cmd_args + 0), (char * const  *)cmd_args);
#line 486
    exit(1);
    }
  }
  {
#line 490
  fcntl(proc_stdout1, 4, 2048);
#line 491
  close(new_pipe1[1]);
#line 492
  fcntl(proc_stderr1, 4, 2048);
#line 493
  close(new_pipe2[1]);
#line 494
  tmp___22 = malloc((size_t )(sizeof(char ) * 50UL));
#line 494
  proc_sub = (char *)tmp___22;
  }
#line 495
  if (! proc_sub) {
    {
#line 496
    perror("malloc");
#line 497
    wuuush(1);
    }
  }
  {
#line 499
  tmp___23 = gettext("ripping track %d...");
#line 499
  sprintf((char */* __restrict  */)proc_sub, (char const   */* __restrict  */)tmp___23,
          (int )track->toc + 1);
#line 500
  open_process_win(proc_sub);
  }
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 503
    tmp___24 = waitpid(proc_child1, & status, 1);
    }
#line 503
    if (tmp___24 == proc_child1) {
#line 503
      goto while_break;
    }
    {
#line 504
    tmp___25 = evaluate_proc(proc_stdout1, proc_stderr1, -1, (unsigned char)0, (unsigned char)0);
    }
#line 504
    if (tmp___25) {
#line 505
      status = 65530;
#line 506
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 511
  if (status != 65530) {
#line 511
    __constr_expr_0.__in = status;
#line 511
    if ((__constr_expr_0.__i & 65280) >> 8 != 0) {
      {
#line 513
      shell_wait_for_close_proc(proc_stdout1, proc_stderr1, -1);
      }
    }
  }
  {
#line 515
  free((void *)proc_sub);
#line 516
  del_process_win();
#line 517
  close(proc_stdout1);
#line 518
  close(proc_stderr1);
  }
#line 519
  if (status == 65530) {
    {
#line 520
    kill(proc_child1, 2);
#line 521
    tmp___26 = gettext("action was canceled");
#line 521
    popup_error_win(tmp___26);
#line 522
    unlink((char const   *)tmp_file);
#line 523
    kill(proc_child1, 9);
    }
#line 524
    return (1);
  }
#line 526
  __constr_expr_1.__in = status;
#line 526
  if ((__constr_expr_1.__i & 65280) >> 8 == 0) {
#line 526
    return (0);
  }
  {
#line 527
  tmp___27 = gettext("child (cd-ripper) died unexpected");
#line 527
  popup_error_win(tmp___27);
#line 528
  unlink((char const   *)tmp_file);
  }
#line 529
  return (1);
}
}
#line 532 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
int enc_non_fly(song_typ *track , unsigned char del_tmp_file ) 
{ 
  int new_pipe1[2] ;
  int new_pipe2[2] ;
  char *cmd_line ;
  char **cmd_args ;
  int status ;
  char *tmp_file ;
  char *filenm ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  unsigned char tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  unsigned char tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  void *tmp___20 ;
  char *tmp___21 ;
  __pid_t tmp___22 ;
  int tmp___23 ;
  union __anonunion_55 __constr_expr_2 ;
  char *tmp___24 ;
  union __anonunion_56 __constr_expr_3 ;
  char *tmp___25 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;

  {
  {
#line 542
  tmp_file = return_track_tmpname(track);
#line 544
  tmp___0 = access((char const   *)tmp_file, 0);
  }
#line 544
  if (tmp___0 != 0) {
    {
#line 545
    tmp = gettext("tempfile not found");
#line 545
    popup_error_win(tmp);
    }
#line 546
    return (1);
  }
  {
#line 548
  tmp___2 = access((char const   *)tmp_file, 4);
  }
#line 548
  if (tmp___2 != 0) {
    {
#line 549
    tmp___1 = gettext("tempfile not readable");
#line 549
    popup_error_win(tmp___1);
    }
#line 550
    return (1);
  }
  {
#line 553
  filenm = build_mp3_filenm(track);
#line 555
  tmp___3 = create_sub_dirs(filenm, (unsigned char)1);
  }
#line 555
  if (tmp___3) {
#line 555
    return (1);
  }
  {
#line 557
  tmp___10 = access((char const   *)filenm, 0);
  }
#line 557
  if (tmp___10 == 0) {
    {
#line 559
    tmp___5 = access((char const   *)filenm, 2);
    }
#line 559
    if (tmp___5 != 0) {
      {
#line 561
      tmp___4 = gettext("mp3-file already exists and isn\'t writable");
#line 561
      popup_error_win(tmp___4);
      }
#line 562
      return (1);
    }
    {
#line 565
    tmp___6 = strlen((char const   *)filenm);
#line 565
    tmp___7 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___6 + 40U)));
#line 565
    cmd_line = (char *)tmp___7;
    }
#line 566
    if ((unsigned long )cmd_line == (unsigned long )((void *)0)) {
      {
#line 567
      perror("malloc");
#line 568
      wuuush(1);
      }
    }
    {
#line 570
    tmp___8 = gettext("overwrite \"%s\"?");
#line 570
    sprintf((char */* __restrict  */)cmd_line, (char const   */* __restrict  */)tmp___8,
            filenm);
#line 571
    tmp___9 = select_yesno_box(cmd_line);
    }
#line 571
    if (! tmp___9) {
      {
#line 572
      free((void *)cmd_line);
      }
#line 573
      return (2);
    }
    {
#line 575
    free((void *)cmd_line);
    }
  }
  {
#line 578
  tmp___12 = str_path_check(def_mp3_enc_nf);
  }
#line 578
  if (! tmp___12) {
    {
#line 579
    tmp___11 = gettext("couldn\'t encode, no prg in $PATH");
#line 579
    popup_error_win(tmp___11);
    }
#line 580
    return (1);
  }
  {
#line 583
  tmp___14 = pipe((int *)(new_pipe1));
  }
#line 583
  if (tmp___14 != 0) {
    {
#line 584
    tmp___13 = gettext("error opening pipe for STDOUT");
#line 584
    popup_error_win(tmp___13);
    }
#line 585
    return (1);
  }
  {
#line 587
  tmp___16 = pipe((int *)(new_pipe2));
  }
#line 587
  if (tmp___16 != 0) {
    {
#line 588
    tmp___15 = gettext("error opening pipe for STDERR");
#line 588
    popup_error_win(tmp___15);
    }
#line 589
    return (1);
  }
  {
#line 592
  proc_stdout1 = new_pipe1[0];
#line 593
  proc_stderr1 = new_pipe2[0];
#line 595
  proc_child1 = fork();
  }
#line 596
  if (proc_child1 == -1) {
    {
#line 597
    tmp___17 = gettext("forking failed");
#line 597
    popup_error_win(tmp___17);
    }
#line 598
    return (1);
  }
#line 601
  if (proc_child1 == 0) {
    {
#line 602
    tmp___18 = dup2(new_pipe1[1], 1);
    }
#line 602
    if (tmp___18 == -1) {
      {
#line 603
      exit(1);
      }
    }
    {
#line 605
    tmp___19 = dup2(new_pipe2[1], 2);
    }
#line 605
    if (tmp___19 == -1) {
      {
#line 606
      exit(1);
      }
    }
    {
#line 609
    close(proc_stdout1);
#line 610
    close(proc_stderr1);
#line 612
    cmd_line = create_sub_string(track, 1);
    }
#line 613
    if (! cmd_line) {
      {
#line 614
      exit(1);
      }
    }
    {
#line 617
    cmd_args = build_arg_tree((char const   *)cmd_line);
    }
#line 618
    if (! cmd_args) {
      {
#line 619
      exit(1);
      }
    }
    {
#line 622
    execvp((char const   *)*(cmd_args + 0), (char * const  *)cmd_args);
#line 623
    exit(1);
    }
  }
  {
#line 627
  fcntl(proc_stdout1, 4, 2048);
#line 628
  close(new_pipe1[1]);
#line 629
  fcntl(proc_stderr1, 4, 2048);
#line 630
  close(new_pipe2[1]);
#line 632
  tmp___20 = malloc((size_t )(sizeof(char ) * 50UL));
#line 632
  proc_sub = (char *)tmp___20;
  }
#line 633
  if (! proc_sub) {
    {
#line 634
    perror("malloc");
#line 635
    wuuush(1);
    }
  }
  {
#line 637
  tmp___21 = gettext("encoding track %d...");
#line 637
  sprintf((char */* __restrict  */)proc_sub, (char const   */* __restrict  */)tmp___21,
          (int )track->toc + 1);
#line 638
  open_process_win(proc_sub);
  }
  {
#line 640
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 641
    tmp___22 = waitpid(proc_child1, & status, 1);
    }
#line 641
    if (tmp___22 == proc_child1) {
#line 641
      goto while_break;
    }
    {
#line 642
    tmp___23 = evaluate_proc(proc_stdout1, proc_stderr1, -1, (unsigned char)0, (unsigned char)0);
    }
#line 642
    if (tmp___23) {
#line 643
      status = 65530;
#line 644
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 649
  if (status != 65530) {
#line 649
    __constr_expr_2.__in = status;
#line 649
    if ((__constr_expr_2.__i & 65280) >> 8 != 0) {
      {
#line 651
      shell_wait_for_close_proc(proc_stdout1, proc_stderr1, -1);
      }
    }
  }
  {
#line 653
  free((void *)proc_sub);
#line 654
  del_process_win();
#line 655
  close(proc_stdout1);
#line 656
  close(proc_stderr1);
  }
#line 657
  if (status == 65530) {
    {
#line 658
    kill(proc_child1, 2);
#line 659
    tmp___24 = gettext("action was canceled");
#line 659
    popup_error_win(tmp___24);
#line 660
    kill(proc_child1, 9);
    }
#line 661
    return (1);
  }
#line 663
  __constr_expr_3.__in = status;
#line 663
  if ((__constr_expr_3.__i & 65280) >> 8 == 0) {
#line 664
    if (del_tmp_file) {
      {
#line 664
      unlink((char const   *)tmp_file);
      }
    }
#line 665
    return (0);
  }
  {
#line 667
  tmp___25 = gettext("child (encoder) died unexpected");
#line 667
  popup_error_win(tmp___25);
  }
#line 668
  return (1);
}
}
#line 671 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
int put_fifo(int fd ) 
{ 
  char buf[16384] ;
  int bytes ;
  int fifo_size ;
  char *tmp ;
  int tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 677
  fifo_size = of_fifo_buf * 1024;
#line 679
  if (proc_fifo_in == proc_fifo_out) {
#line 679
    bytes = fifo_size;
  } else
#line 680
  if (proc_fifo_in > proc_fifo_out) {
#line 680
    bytes = (fifo_size - proc_fifo_in) + proc_fifo_out;
  } else {
#line 681
    bytes = proc_fifo_out - proc_fifo_in;
  }
#line 683
  if (bytes < 16390) {
#line 683
    return (0);
  }
  {
#line 685
  tmp = gettext("FIFO: %3d%% full");
#line 685
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp, ((fifo_size - bytes) * 100) / fifo_size);
#line 686
  tmp___0 = wmove(proc_out_win, 0, 1);
  }
#line 686
  if (! (tmp___0 == -1)) {
    {
#line 686
    waddnstr(proc_out_win, (char const   *)(buf), fifo_for_maxx - 2);
    }
  }
  {
#line 688
  bytes = read(fd, (void *)(& buf), (size_t )16384);
  }
#line 689
  if (bytes < 1) {
#line 689
    return (0);
  }
#line 691
  if (bytes <= fifo_size - proc_fifo_in) {
    {
#line 692
    memcpy((void */* __restrict  */)(proc_fifo + proc_fifo_in), (void const   */* __restrict  */)(buf),
           (size_t )bytes);
#line 693
    proc_fifo_in += bytes;
    }
#line 694
    if (proc_fifo_in == fifo_size) {
#line 694
      proc_fifo_in = 0;
    }
#line 695
    return (1);
  }
  {
#line 698
  memcpy((void */* __restrict  */)(proc_fifo + proc_fifo_in), (void const   */* __restrict  */)(& buf),
         (size_t )(fifo_size - proc_fifo_in));
#line 699
  bytes -= fifo_size - proc_fifo_in;
#line 700
  memcpy((void */* __restrict  */)proc_fifo, (void const   */* __restrict  */)(& buf[fifo_size - proc_fifo_in]),
         (size_t )bytes);
#line 701
  proc_fifo_in = bytes;
  }
#line 703
  return (1);
}
}
#line 706 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
int get_fifo(int fd ) 
{ 
  char buf[16384] ;
  int bytes ;
  int fifo_size ;
  int remain ;
  char *tmp ;
  int tmp___0 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 711
  fifo_size = of_fifo_buf * 1024;
#line 713
  if (proc_fifo_in == proc_fifo_out) {
#line 713
    return (0);
  }
#line 715
  bytes = proc_fifo_in - proc_fifo_out;
#line 716
  if (bytes < 0) {
#line 716
    bytes = (fifo_size - proc_fifo_out) + proc_fifo_in;
  }
  {
#line 717
  tmp = gettext("FIFO: %3d%% full");
#line 717
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp, (bytes * 100) / fifo_size);
#line 718
  tmp___0 = wmove(proc_out_win, 0, 1);
  }
#line 718
  if (! (tmp___0 == -1)) {
    {
#line 718
    waddnstr(proc_out_win, (char const   *)(buf), fifo_for_maxx - 2);
    }
  }
#line 720
  if (proc_fifo_out > proc_fifo_in) {
#line 721
    bytes = fifo_size - proc_fifo_out;
#line 722
    if (bytes < 16384) {
      {
#line 723
      memcpy((void */* __restrict  */)(& buf), (void const   */* __restrict  */)(proc_fifo + proc_fifo_out),
             (size_t )bytes);
      }
    } else {
      {
#line 725
      memcpy((void */* __restrict  */)(& buf), (void const   */* __restrict  */)(proc_fifo + proc_fifo_out),
             (size_t )16384);
#line 726
      bytes = 16384;
      }
    }
#line 728
    if (bytes < 16384) {
#line 729
      remain = proc_fifo_in;
#line 730
      if (remain + bytes > 16384) {
        {
#line 731
        memcpy((void */* __restrict  */)(& buf[bytes]), (void const   */* __restrict  */)proc_fifo,
               (size_t )(16384 - bytes));
#line 732
        bytes = 16384;
        }
      } else {
        {
#line 734
        memcpy((void */* __restrict  */)(& buf[bytes]), (void const   */* __restrict  */)proc_fifo,
               (size_t )remain);
#line 735
        bytes += remain;
        }
      }
    }
  } else {
#line 739
    remain = proc_fifo_in - proc_fifo_out;
#line 740
    if (remain > 16384) {
      {
#line 741
      memcpy((void */* __restrict  */)(& buf), (void const   */* __restrict  */)(proc_fifo + proc_fifo_out),
             (size_t )16384);
#line 742
      bytes = 16384;
      }
    } else {
      {
#line 744
      memcpy((void */* __restrict  */)(& buf), (void const   */* __restrict  */)(proc_fifo + proc_fifo_out),
             (size_t )remain);
#line 745
      bytes = remain;
      }
    }
  }
  {
#line 749
  bytes = write(fd, (void const   *)(& buf), (size_t )bytes);
  }
#line 750
  if (bytes > 0) {
#line 751
    proc_fifo_out = (proc_fifo_out + bytes) % fifo_size;
#line 752
    return (1);
  }
#line 754
  return (0);
}
}
#line 757 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
int conv_on_fly(song_typ *track ) 
{ 
  int new_pipe1[2] ;
  int new_pipe2[2] ;
  int new_pipe3[2] ;
  char *cmd_line ;
  char **cmd_args ;
  int status ;
  int eval_cou ;
  char *filenm ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  unsigned char tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  unsigned char tmp___8 ;
  char *tmp___9 ;
  unsigned char tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  char *tmp___20 ;
  __pid_t tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  union __anonunion_57 __constr_expr_4 ;
  union __anonunion_58 __constr_expr_5 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  char *tmp___36 ;
  union __anonunion_59 __constr_expr_6 ;
  __pid_t tmp___37 ;
  __pid_t tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  union __anonunion_60 __constr_expr_7 ;
  char *tmp___41 ;
  union __anonunion_61 __constr_expr_8 ;
  char *tmp___42 ;
  void *__cil_tmp59 ;
  void *__cil_tmp60 ;
  void *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;

  {
  {
#line 768
  filenm = build_mp3_filenm(track);
#line 770
  tmp = create_sub_dirs(filenm, (unsigned char)1);
  }
#line 770
  if (tmp) {
#line 770
    return (1);
  }
  {
#line 772
  tmp___6 = access((char const   *)filenm, 0);
  }
#line 772
  if (tmp___6 == 0) {
    {
#line 774
    tmp___1 = access((char const   *)filenm, 2);
    }
#line 774
    if (tmp___1 != 0) {
      {
#line 776
      tmp___0 = gettext("mp3-file already exists and isn\'t writable");
#line 776
      popup_error_win(tmp___0);
      }
#line 777
      return (1);
    }
    {
#line 780
    tmp___2 = strlen((char const   *)filenm);
#line 780
    tmp___3 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___2 + 50U)));
#line 780
    cmd_line = (char *)tmp___3;
    }
#line 781
    if ((unsigned long )cmd_line == (unsigned long )((void *)0)) {
      {
#line 782
      perror("malloc");
#line 783
      wuuush(1);
      }
    }
    {
#line 785
    tmp___4 = gettext("overwrite \"%s\"?");
#line 785
    sprintf((char */* __restrict  */)cmd_line, (char const   */* __restrict  */)tmp___4,
            filenm);
#line 786
    tmp___5 = select_yesno_box(cmd_line);
    }
#line 786
    if (! tmp___5) {
      {
#line 787
      free((void *)cmd_line);
      }
#line 788
      return (2);
    }
    {
#line 790
    free((void *)cmd_line);
    }
  }
  {
#line 793
  tmp___8 = str_path_check(def_cd_rip_of);
  }
#line 793
  if (! tmp___8) {
    {
#line 794
    tmp___7 = gettext("no ripper for on-fly in $PATH");
#line 794
    popup_error_win(tmp___7);
    }
#line 795
    return (1);
  }
  {
#line 797
  tmp___10 = str_path_check(def_mp3_enc_of);
  }
#line 797
  if (! tmp___10) {
    {
#line 798
    tmp___9 = gettext("no encoder for on-fly in $PATH");
#line 798
    popup_error_win(tmp___9);
    }
#line 799
    return (1);
  }
  {
#line 802
  tmp___12 = pipe((int *)(new_pipe1));
  }
#line 802
  if (tmp___12 != 0) {
    {
#line 803
    tmp___11 = gettext("error opening pipe for STDOUT");
#line 803
    popup_error_win(tmp___11);
    }
#line 804
    return (1);
  }
  {
#line 806
  tmp___14 = pipe((int *)(new_pipe2));
  }
#line 806
  if (tmp___14 != 0) {
    {
#line 807
    tmp___13 = gettext("error opening pipe for STDERR");
#line 807
    popup_error_win(tmp___13);
    }
#line 808
    return (1);
  }
  {
#line 811
  proc_stdout1 = new_pipe1[0];
#line 812
  proc_stderr1 = new_pipe2[0];
#line 814
  proc_child1 = fork();
  }
#line 815
  if (proc_child1 == -1) {
    {
#line 816
    tmp___15 = gettext("could not fork");
#line 816
    popup_error_win(tmp___15);
    }
#line 817
    return (1);
  }
#line 820
  if (proc_child1 == 0) {
    {
#line 821
    tmp___16 = dup2(new_pipe1[1], 1);
    }
#line 821
    if (tmp___16 == -1) {
      {
#line 822
      exit(1);
      }
    }
    {
#line 824
    tmp___17 = dup2(new_pipe2[1], 2);
    }
#line 824
    if (tmp___17 == -1) {
      {
#line 825
      exit(1);
      }
    }
    {
#line 828
    close(new_pipe1[0]);
#line 829
    close(new_pipe2[0]);
#line 830
    close(proc_stdout1);
#line 831
    close(proc_stderr1);
#line 833
    cmd_line = create_sub_string(track, 4);
    }
#line 834
    if (! cmd_line) {
      {
#line 835
      exit(1);
      }
    }
    {
#line 838
    cmd_args = build_arg_tree((char const   *)cmd_line);
    }
#line 839
    if (! cmd_args) {
      {
#line 840
      exit(1);
      }
    }
    {
#line 843
    execvp((char const   *)*(cmd_args + 0), (char * const  *)cmd_args);
#line 844
    exit(1);
    }
  }
  {
#line 847
  tmp___18 = malloc((size_t )((sizeof(char ) * 1024UL) * (unsigned long )of_fifo_buf));
#line 847
  proc_fifo = (char *)tmp___18;
  }
#line 848
  if (! proc_fifo) {
    {
#line 849
    perror("malloc");
#line 850
    wuuush(1);
    }
  }
  {
#line 852
  proc_fifo_in = 0;
#line 853
  proc_fifo_out = 0;
#line 855
  tmp___19 = malloc((size_t )(sizeof(char ) * 50UL));
#line 855
  proc_sub = (char *)tmp___19;
  }
#line 856
  if (! proc_sub) {
    {
#line 857
    perror("malloc");
#line 858
    wuuush(1);
    }
  }
  {
#line 860
  tmp___20 = gettext("converting track %d...");
#line 860
  sprintf((char */* __restrict  */)proc_sub, (char const   */* __restrict  */)tmp___20,
          (int )track->toc + 1);
#line 861
  open_process_win(proc_sub);
#line 864
  fcntl(proc_stdout1, 4, 2048);
#line 865
  close(new_pipe1[1]);
#line 866
  fcntl(proc_stderr1, 4, 2048);
#line 867
  close(new_pipe2[1]);
  }
  {
#line 869
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 870
    tmp___21 = waitpid(proc_child1, & status, 1);
    }
#line 870
    if (tmp___21 == proc_child1) {
#line 870
      goto while_break;
    }
    {
#line 871
    tmp___22 = evaluate_proc(proc_stderr1, -1, -1, (unsigned char)1, (unsigned char)0);
    }
#line 871
    if (tmp___22) {
#line 872
      status = 65530;
#line 873
      goto while_break;
    }
    {
#line 875
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 875
      tmp___23 = put_fifo(proc_stdout1);
      }
#line 875
      if (! tmp___23) {
#line 875
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 876
    if (proc_fifo_in > of_fifo_buf * 1024 >> 1) {
#line 877
      status = 65531;
#line 878
      goto while_break;
    }
    {
#line 880
    usleep((__useconds_t )250);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 883
  if (status != 65531) {
#line 883
    if (status != 65530) {
#line 883
      __constr_expr_4.__in = status;
#line 883
      if ((__constr_expr_4.__i & 65280) >> 8 != 0) {
        {
#line 885
        shell_wait_for_close_proc(proc_stderr1, -1, -1);
        }
      }
    }
  }
#line 888
  if (status != 65531) {
#line 888
    __constr_expr_5.__in = status;
#line 888
    if ((__constr_expr_5.__i & 65280) >> 8 == 0) {
#line 889
      status = 65531;
#line 890
      proc_child1 = 0;
    }
  }
#line 893
  if (status != 65531) {
    {
#line 895
    free((void *)proc_fifo);
#line 896
    free((void *)proc_sub);
#line 897
    del_process_win();
#line 898
    close(proc_stdout1);
#line 899
    close(proc_stderr1);
    }
#line 900
    if (status == 65530) {
      {
#line 901
      kill(proc_child1, 2);
#line 902
      tmp___24 = gettext("action was canceled");
#line 902
      popup_error_win(tmp___24);
#line 903
      kill(proc_child1, 9);
      }
#line 904
      return (1);
    }
    {
#line 906
    tmp___25 = gettext("child (cd-ripper) died unexpected");
#line 906
    popup_error_win(tmp___25);
    }
#line 907
    return (1);
  }
  {
#line 911
  tmp___27 = pipe((int *)(new_pipe1));
  }
#line 911
  if (tmp___27 != 0) {
    {
#line 912
    kill(proc_child1, 2);
#line 913
    tmp___26 = gettext("error opening pipe for STDOUT");
#line 913
    popup_error_win(tmp___26);
#line 914
    free((void *)proc_fifo);
#line 915
    free((void *)proc_sub);
#line 916
    del_process_win();
#line 917
    close(proc_stdout1);
#line 918
    close(proc_stderr1);
#line 919
    kill(proc_child1, 9);
    }
#line 920
    return (1);
  }
  {
#line 922
  tmp___29 = pipe((int *)(new_pipe2));
  }
#line 922
  if (tmp___29 != 0) {
    {
#line 923
    kill(proc_child1, 2);
#line 924
    tmp___28 = gettext("error opening pipe for STDERR");
#line 924
    popup_error_win(tmp___28);
#line 925
    free((void *)proc_fifo);
#line 926
    free((void *)proc_sub);
#line 927
    del_process_win();
#line 928
    close(proc_stdout1);
#line 929
    close(proc_stderr1);
#line 930
    kill(proc_child1, 9);
    }
#line 931
    return (1);
  }
  {
#line 933
  tmp___31 = pipe((int *)(new_pipe3));
  }
#line 933
  if (tmp___31 != 0) {
    {
#line 934
    kill(proc_child1, 2);
#line 935
    tmp___30 = gettext("error opening pipe for STDIN");
#line 935
    popup_error_win(tmp___30);
#line 936
    free((void *)proc_fifo);
#line 937
    free((void *)proc_sub);
#line 938
    del_process_win();
#line 939
    close(proc_stdout1);
#line 940
    close(proc_stderr1);
#line 941
    kill(proc_child1, 9);
    }
#line 942
    return (1);
  }
  {
#line 945
  proc_stdout2 = new_pipe1[0];
#line 946
  proc_stderr2 = new_pipe2[0];
#line 947
  proc_stdin2 = new_pipe3[1];
#line 949
  proc_child2 = fork();
  }
#line 950
  if (proc_child2 == -1) {
    {
#line 951
    kill(proc_child1, 2);
#line 952
    tmp___32 = gettext("forking for encoder subprocess failed");
#line 952
    popup_error_win(tmp___32);
#line 953
    free((void *)proc_fifo);
#line 954
    free((void *)proc_sub);
#line 955
    del_process_win();
#line 956
    close(proc_stdout1);
#line 957
    close(proc_stderr1);
#line 958
    kill(proc_child1, 9);
    }
#line 959
    return (1);
  }
#line 962
  if (proc_child2 == 0) {
    {
#line 963
    tmp___33 = dup2(new_pipe1[1], 1);
    }
#line 963
    if (tmp___33 == -1) {
      {
#line 964
      exit(1);
      }
    }
    {
#line 966
    tmp___34 = dup2(new_pipe2[1], 2);
    }
#line 966
    if (tmp___34 == -1) {
      {
#line 967
      exit(1);
      }
    }
    {
#line 969
    tmp___35 = dup2(new_pipe3[0], 0);
    }
#line 969
    if (tmp___35 == -1) {
      {
#line 970
      exit(1);
      }
    }
    {
#line 973
    close(new_pipe1[0]);
#line 974
    close(new_pipe2[0]);
#line 975
    close(new_pipe3[1]);
#line 977
    cmd_line = create_sub_string(track, 2);
    }
#line 978
    if (! cmd_line) {
      {
#line 979
      exit(1);
      }
    }
    {
#line 982
    cmd_args = build_arg_tree((char const   *)cmd_line);
    }
#line 983
    if (! cmd_args) {
      {
#line 984
      exit(1);
      }
    }
    {
#line 987
    execvp((char const   *)*(cmd_args + 0), (char * const  *)cmd_args);
#line 988
    exit(1);
    }
  }
  {
#line 991
  fcntl(proc_stdout2, 4, 2048);
#line 992
  close(new_pipe1[1]);
#line 993
  fcntl(proc_stderr2, 4, 2048);
#line 994
  close(new_pipe2[1]);
#line 995
  fcntl(proc_stdin2, 4, 2048);
#line 996
  close(new_pipe3[0]);
  }
  {
#line 998
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 999
    if (proc_child1) {
      {
#line 1000
      tmp___37 = waitpid(proc_child1, & status, 1);
      }
#line 1000
      if (tmp___37 == proc_child1) {
#line 1001
        __constr_expr_6.__in = status;
#line 1001
        if ((__constr_expr_6.__i & 65280) >> 8 != 0) {
          {
#line 1002
          kill(proc_child2, 2);
#line 1003
          tmp___36 = gettext("child (cd-ripper) died unexpected");
#line 1003
          popup_error_win(tmp___36);
#line 1004
          free((void *)proc_fifo);
#line 1005
          free((void *)proc_sub);
#line 1006
          del_process_win();
#line 1007
          close(proc_stdout1);
#line 1008
          close(proc_stderr1);
#line 1009
          close(proc_stdout2);
#line 1010
          close(proc_stderr2);
#line 1011
          close(proc_stdin2);
#line 1012
          kill(proc_child2, 9);
          }
#line 1013
          return (1);
        }
#line 1015
        proc_child1 = 0;
      }
    }
    {
#line 1018
    tmp___38 = waitpid(proc_child2, & status, 1);
    }
#line 1018
    if (tmp___38 == proc_child2) {
#line 1018
      goto while_break___1;
    }
#line 1019
    eval_cou = 0;
    {
#line 1019
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1019
      if (! (eval_cou < 10)) {
#line 1019
        goto while_break___2;
      }
#line 1020
      if (proc_child1) {
        {
#line 1020
        put_fifo(proc_stdout1);
        }
      }
      {
#line 1021
      get_fifo(proc_stdin2);
#line 1022
      usleep((__useconds_t )250);
#line 1019
      eval_cou ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1024
    if (proc_child1) {
      {
#line 1024
      tmp___40 = evaluate_proc(proc_stderr1, proc_stdout2, proc_stderr2, (unsigned char)1,
                               (unsigned char)0);
      }
#line 1024
      if (tmp___40) {
#line 1025
        status = 65530;
#line 1026
        goto while_break___1;
      } else {
#line 1024
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1027
      tmp___39 = evaluate_proc(proc_stdout2, proc_stderr2, -1, (unsigned char)1, (unsigned char)0);
      }
#line 1027
      if (tmp___39) {
#line 1028
        status = 65530;
#line 1029
        goto while_break___1;
      }
    }
#line 1032
    if (! proc_child1) {
#line 1032
      if (proc_fifo_in == proc_fifo_out) {
        {
#line 1033
        close(proc_stdin2);
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1038
  if (status != 65530) {
#line 1038
    __constr_expr_7.__in = status;
#line 1038
    if ((__constr_expr_7.__i & 65280) >> 8 != 0) {
      {
#line 1040
      shell_wait_for_close_proc(proc_stderr1, proc_stdout2, proc_stderr2);
      }
    }
  }
  {
#line 1042
  free((void *)proc_sub);
#line 1043
  free((void *)proc_fifo);
#line 1044
  del_process_win();
#line 1045
  close(proc_stdout1);
#line 1046
  close(proc_stderr1);
#line 1047
  close(proc_stdout2);
#line 1048
  close(proc_stderr2);
#line 1049
  close(proc_stdin2);
  }
#line 1050
  if (status == 65530) {
    {
#line 1051
    kill(proc_child1, 2);
#line 1052
    kill(proc_child2, 2);
#line 1053
    tmp___41 = gettext("action was canceled");
#line 1053
    popup_error_win(tmp___41);
#line 1054
    kill(proc_child1, 9);
#line 1055
    kill(proc_child2, 9);
    }
#line 1056
    return (1);
  }
#line 1058
  __constr_expr_8.__in = status;
#line 1058
  if ((__constr_expr_8.__i & 65280) >> 8 == 0) {
#line 1058
    return (0);
  }
  {
#line 1059
  tmp___42 = gettext("child (encoder) died unexpected");
#line 1059
  popup_error_win(tmp___42);
  }
#line 1060
  return (1);
}
}
#line 1063 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
int set_mp3_inf(song_typ *track ) 
{ 
  int new_pipe1[2] ;
  int new_pipe2[2] ;
  char *cmd_line ;
  char **cmd_args ;
  int status ;
  int tmp ;
  char *tmp___0 ;
  unsigned char tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;
  __pid_t tmp___11 ;
  int tmp___12 ;
  union __anonunion_62 __constr_expr_9 ;
  char *tmp___13 ;
  union __anonunion_63 __constr_expr_10 ;
  char *tmp___14 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 1071
  if (def_mp3_info) {
    {
#line 1071
    tmp = strcmp((char const   *)def_mp3_info, "0");
    }
#line 1071
    if (tmp == 0) {
#line 1072
      return (0);
    }
  }
  {
#line 1075
  tmp___1 = str_path_check(def_mp3_info);
  }
#line 1075
  if (! tmp___1) {
    {
#line 1076
    tmp___0 = gettext("missing mp3-info program");
#line 1076
    popup_error_win(tmp___0);
    }
#line 1077
    return (1);
  }
  {
#line 1080
  tmp___3 = pipe((int *)(new_pipe1));
  }
#line 1080
  if (tmp___3 != 0) {
    {
#line 1081
    tmp___2 = gettext("error opening pipe for STDOUT");
#line 1081
    popup_error_win(tmp___2);
    }
#line 1082
    return (1);
  }
  {
#line 1084
  tmp___5 = pipe((int *)(new_pipe2));
  }
#line 1084
  if (tmp___5 != 0) {
    {
#line 1085
    tmp___4 = gettext("error opening pipe for STDERR");
#line 1085
    popup_error_win(tmp___4);
    }
#line 1086
    return (1);
  }
  {
#line 1089
  proc_stdout1 = new_pipe1[0];
#line 1090
  proc_stderr1 = new_pipe2[0];
#line 1092
  proc_child1 = fork();
  }
#line 1093
  if (proc_child1 == -1) {
    {
#line 1094
    tmp___6 = gettext("forking not possible");
#line 1094
    popup_error_win(tmp___6);
    }
#line 1095
    return (1);
  }
#line 1098
  if (proc_child1 == 0) {
    {
#line 1099
    tmp___7 = dup2(new_pipe1[1], 1);
    }
#line 1099
    if (tmp___7 == -1) {
      {
#line 1100
      exit(1);
      }
    }
    {
#line 1102
    tmp___8 = dup2(new_pipe2[1], 2);
    }
#line 1102
    if (tmp___8 == -1) {
      {
#line 1103
      exit(1);
      }
    }
    {
#line 1106
    close(new_pipe1[0]);
#line 1107
    close(new_pipe2[0]);
#line 1108
    close(proc_stdout1);
#line 1109
    close(proc_stderr1);
#line 1111
    cmd_line = create_sub_string(track, 5);
    }
#line 1112
    if (! cmd_line) {
      {
#line 1113
      exit(1);
      }
    }
    {
#line 1116
    cmd_args = build_arg_tree((char const   *)cmd_line);
    }
#line 1117
    if (! cmd_args) {
      {
#line 1118
      exit(1);
      }
    }
    {
#line 1121
    execvp((char const   *)*(cmd_args + 0), (char * const  *)cmd_args);
#line 1122
    exit(1);
    }
  }
  {
#line 1126
  fcntl(proc_stdout1, 4, 2048);
#line 1127
  close(new_pipe1[1]);
#line 1128
  fcntl(proc_stderr1, 4, 2048);
#line 1129
  close(new_pipe2[1]);
#line 1131
  tmp___9 = malloc((size_t )(sizeof(char ) * 100UL));
#line 1131
  proc_sub = (char *)tmp___9;
  }
#line 1132
  if (! proc_sub) {
    {
#line 1133
    perror("malloc");
#line 1134
    wuuush(1);
    }
  }
  {
#line 1136
  tmp___10 = gettext("setting mp3-infos for track %d...");
#line 1136
  sprintf((char */* __restrict  */)proc_sub, (char const   */* __restrict  */)tmp___10,
          (int )track->toc + 1);
#line 1137
  open_process_win(proc_sub);
  }
  {
#line 1139
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1140
    tmp___11 = waitpid(proc_child1, & status, 1);
    }
#line 1140
    if (tmp___11 == proc_child1) {
#line 1140
      goto while_break;
    }
    {
#line 1141
    tmp___12 = evaluate_proc(proc_stdout1, proc_stderr1, -1, (unsigned char)0, (unsigned char)0);
    }
#line 1141
    if (tmp___12) {
#line 1142
      status = 65530;
#line 1143
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1148
  if (status != 65530) {
#line 1148
    __constr_expr_9.__in = status;
#line 1148
    if ((__constr_expr_9.__i & 65280) >> 8 != 0) {
      {
#line 1150
      shell_wait_for_close_proc(proc_stdout1, proc_stderr1, -1);
      }
    }
  }
  {
#line 1152
  free((void *)proc_sub);
#line 1153
  del_process_win();
#line 1154
  close(proc_stdout1);
#line 1155
  close(proc_stderr1);
  }
#line 1156
  if (status == 65530) {
    {
#line 1157
    kill(proc_child1, 2);
#line 1158
    tmp___13 = gettext("action was canceled");
#line 1158
    popup_error_win(tmp___13);
#line 1159
    kill(proc_child1, 9);
    }
#line 1160
    return (1);
  }
#line 1162
  __constr_expr_10.__in = status;
#line 1162
  if ((__constr_expr_10.__i & 65280) >> 8 == 0) {
#line 1162
    return (0);
  }
  {
#line 1163
  tmp___14 = gettext("child (mp3-info) died unexpected");
#line 1163
  popup_error_win(tmp___14);
  }
#line 1164
  return (1);
}
}
#line 1168 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
unsigned char prg_path_check(char *program ) 
{ 
  char *path ;
  int i ;
  int j ;
  char *name ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp13 ;

  {
#line 1175
  if ((int )*program == 47) {
    {
#line 1176
    tmp = access((char const   *)program, 1);
    }
#line 1176
    if (tmp) {
#line 1179
      return ((unsigned char)0);
    } else {
#line 1177
      return ((unsigned char)1);
    }
  }
  {
#line 1183
  tmp___0 = access((char const   *)program, 1);
  }
#line 1183
  if (! tmp___0) {
#line 1183
    return ((unsigned char)1);
  }
  {
#line 1185
  path = getenv("PATH");
  }
#line 1186
  if (! path) {
#line 1186
    return ((unsigned char)1);
  }
#line 1188
  j = 0;
#line 1189
  i = 0;
  {
#line 1190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1191
    if ((int )*(path + j) == 0) {
#line 1191
      goto _L;
    } else
#line 1191
    if ((int )*(path + j) == 59) {
#line 1191
      goto _L;
    } else
#line 1191
    if ((int )*(path + j) == 58) {
      _L: /* CIL Label */ 
#line 1192
      if (j != i) {
        {
#line 1193
        tmp___1 = strlen((char const   *)program);
#line 1193
        tmp___2 = malloc((size_t )(sizeof(char ) * (unsigned long )((tmp___1 + (size_t )(j - i)) + 2U)));
#line 1193
        name = (char *)tmp___2;
        }
#line 1194
        if (! name) {
          {
#line 1195
          wuuush(1);
          }
        }
        {
#line 1197
        memcpy((void */* __restrict  */)name, (void const   */* __restrict  */)(path + i),
               (size_t )(j - i));
#line 1198
        *(name + (j - i)) = (char )'/';
#line 1199
        tmp___3 = strlen((char const   *)program);
#line 1199
        memcpy((void */* __restrict  */)((name + (j - i)) + 1), (void const   */* __restrict  */)program,
               tmp___3);
#line 1200
        tmp___4 = strlen((char const   *)program);
#line 1200
        *(((name + (j - i)) + tmp___4) + 1) = (char)0;
#line 1201
        tmp___5 = access((char const   *)name, 1);
        }
#line 1201
        if (! tmp___5) {
          {
#line 1202
          free((void *)name);
          }
#line 1203
          return ((unsigned char)1);
        }
        {
#line 1205
        free((void *)name);
        }
      }
#line 1207
      if ((int )*(path + j) == 0) {
#line 1207
        return ((unsigned char)0);
      }
#line 1208
      j ++;
#line 1209
      i = j;
    } else {
#line 1211
      j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1217 "/home/wslee/benchmarks/sound/mp3c-0.29/src/shell.c"
unsigned char str_path_check(char *program ) 
{ 
  char *prg ;
  int i ;
  int j ;
  unsigned char quote ;
  unsigned char start ;
  void *tmp ;

  {
#line 1224
  if (! program) {
#line 1224
    return ((unsigned char)0);
  }
#line 1226
  i = 0;
#line 1227
  j = 0;
#line 1228
  quote = (unsigned char)0;
#line 1229
  start = (unsigned char)0;
  {
#line 1230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1230
    if (! *(program + j)) {
#line 1230
      goto while_break;
    }
#line 1231
    if ((int )*(program + j) == 32) {
#line 1232
      if (! start) {
#line 1232
        i = j + 1;
      } else
#line 1234
      if (! quote) {
#line 1235
        j --;
#line 1236
        goto while_break;
      }
    } else
#line 1239
    if ((int )*(program + j) == 34) {
#line 1240
      if (! start) {
#line 1241
        i = j + 1;
#line 1242
        quote = (unsigned char)1;
      } else
#line 1244
      if (quote) {
#line 1245
        j --;
#line 1246
        goto while_break;
      }
    } else {
#line 1250
      start = (unsigned char)1;
    }
#line 1252
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1255
  if (j - i < 0) {
#line 1255
    return ((unsigned char)0);
  }
  {
#line 1257
  tmp = malloc((size_t )(sizeof(char ) * (unsigned long )((j - i) + 2)));
#line 1257
  prg = (char *)tmp;
  }
#line 1258
  if (! prg) {
    {
#line 1259
    wuuush(1);
    }
  }
  {
#line 1262
  memcpy((void */* __restrict  */)prg, (void const   */* __restrict  */)(program + i),
         (size_t )((j - i) + 1));
#line 1263
  *((prg + (j - i)) + 1) = (char)0;
#line 1265
  start = prg_path_check(prg);
#line 1267
  free((void *)prg);
  }
#line 1269
  return (start);
}
}
#line 35 "/home/wslee/benchmarks/sound/mp3c-0.29/src/select_box.c"
char *mp3_genre[148] ;
#line 40
void free_field_select(field_select_typ **anchor ) ;
#line 44
char *copy_char_str(char *old ) ;
#line 47
char *def_unknown_gen ;
#line 49 "/home/wslee/benchmarks/sound/mp3c-0.29/src/select_box.c"
field_select_typ *top_an  ;
#line 49 "/home/wslee/benchmarks/sound/mp3c-0.29/src/select_box.c"
field_select_typ *curr_an  ;
#line 50 "/home/wslee/benchmarks/sound/mp3c-0.29/src/select_box.c"
int curr_line  ;
#line 51 "/home/wslee/benchmarks/sound/mp3c-0.29/src/select_box.c"
int sb_pressed_key  ;
#line 53 "/home/wslee/benchmarks/sound/mp3c-0.29/src/select_box.c"
void build_win(WINDOW *fs_win , char *tx , int i ) 
{ 
  chtype old_ch ;
  int maxx ;
  int maxy ;
  int j ;
  int pos ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 60
  if (stdscr) {
#line 60
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 60
    maxy = -1;
  }
#line 60
  if (stdscr) {
#line 60
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 60
    maxx = -1;
  }
  {
#line 61
  j = maxy >> 1;
#line 62
  wclear(fs_win);
#line 63
  wbkgd(fs_win, (unsigned long )(1 << 8) | (1UL << 21));
#line 64
  wborder(fs_win, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0,
          (chtype )0, (chtype )0);
#line 65
  old_ch = fs_win->_bkgd;
#line 66
  wbkgdset(fs_win, (unsigned long )(2 << 8) | (1UL << 21));
#line 67
  tmp = strlen((char const   *)tx);
#line 67
  pos = (int )((size_t )i - tmp);
  }
#line 68
  if (pos < 2) {
#line 68
    pos = 2;
  }
  {
#line 69
  tmp___0 = wmove(fs_win, 0, pos >> 1);
  }
#line 69
  if (! (tmp___0 == -1)) {
    {
#line 69
    waddnstr(fs_win, (char const   *)tx, i - 2);
    }
  }
#line 70
  return;
}
}
#line 72 "/home/wslee/benchmarks/sound/mp3c-0.29/src/select_box.c"
void sign_line(field_select_typ *elem , int len , unsigned char marked , int line ,
               WINDOW *fs_win ) 
{ 
  chtype old_ch ;
  int maxy ;
  int maxx ;
  int remain_len ;
  chtype col_1 ;
  chtype col_2 ;
  size_t tmp ;
  size_t tmp___0 ;
  char *__cil_tmp14 ;

  {
#line 79
  if (stdscr) {
#line 79
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 79
    maxy = -1;
  }
#line 79
  if (stdscr) {
#line 79
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 79
    maxx = -1;
  }
#line 80
  old_ch = fs_win->_bkgd;
#line 82
  if (marked) {
#line 83
    col_1 = (chtype )(3 << 8);
#line 84
    col_2 = (unsigned long )(4 << 8) | (1UL << 21);
  } else {
#line 86
    col_1 = (chtype )(1 << 8);
#line 87
    col_2 = (unsigned long )(2 << 8) | (1UL << 21);
  }
  {
#line 90
  wbkgdset(fs_win, col_1);
#line 91
  wmove(fs_win, line, 1);
#line 92
  whline(fs_win, (chtype )' ', len);
#line 93
  waddnstr(fs_win, (char const   *)elem->field, len);
  }
#line 94
  if (elem->dest) {
    {
#line 95
    tmp = strlen((char const   *)elem->field);
#line 95
    remain_len = (int )((size_t )len - tmp);
#line 96
    waddnstr(fs_win, " [", remain_len);
#line 97
    remain_len -= 2;
#line 98
    wbkgdset(fs_win, col_2);
#line 99
    waddnstr(fs_win, (char const   *)elem->dest, remain_len);
#line 100
    wbkgdset(fs_win, col_1);
#line 101
    tmp___0 = strlen((char const   *)elem->dest);
#line 101
    remain_len = (int )((size_t )remain_len - tmp___0);
    }
#line 102
    if (remain_len > 0) {
      {
#line 102
      waddch(fs_win, (chtype const   )']');
      }
    }
  }
  {
#line 105
  wbkgdset(fs_win, old_ch);
  }
#line 106
  return;
}
}
#line 108 "/home/wslee/benchmarks/sound/mp3c-0.29/src/select_box.c"
void fill_lines(int len , WINDOW *fs_win ) 
{ 
  int maxy ;
  int maxx ;
  int i ;
  int j ;
  field_select_typ *curr ;

  {
#line 114
  if (stdscr) {
#line 114
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 114
    maxy = -1;
  }
#line 114
  if (stdscr) {
#line 114
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 114
    maxx = -1;
  }
#line 115
  j = maxy >> 1;
#line 117
  curr = top_an;
#line 118
  i = 1;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if ((unsigned long )curr != (unsigned long )((void *)0)) {
#line 119
      if (! (i <= j)) {
#line 119
        goto while_break;
      }
    } else {
#line 119
      goto while_break;
    }
#line 120
    if ((unsigned long )curr == (unsigned long )curr_an) {
      {
#line 120
      sign_line(curr, len, (unsigned char)1, i, fs_win);
      }
    } else {
      {
#line 121
      sign_line(curr, len, (unsigned char)0, i, fs_win);
      }
    }
#line 122
    i ++;
#line 123
    curr = curr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  return;
}
}
#line 127 "/home/wslee/benchmarks/sound/mp3c-0.29/src/select_box.c"
void rebuild(WINDOW *fs_win , int i , int i2 ) 
{ 
  int maxy ;
  int maxx ;
  int j ;
  void *tmp ;

  {
#line 132
  if (stdscr) {
#line 132
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 132
    maxy = -1;
  }
#line 132
  if (stdscr) {
#line 132
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 132
    maxx = -1;
  }
#line 133
  j = maxy >> 1;
#line 134
  if (i2) {
#line 134
    if (j > i2) {
#line 134
      j = i2;
    }
  }
  {
#line 135
  wresize(fs_win, j + 2, i + 2);
#line 136
  maxx = (maxx - (i + 2)) >> 1;
#line 137
  maxy = (maxy - (j + 2)) >> 1;
#line 138
  mvwin(fs_win, maxy, maxx);
#line 139
  tmp = pop_win_poi(fs_win);
#line 139
  build_win(fs_win, (char *)tmp, i);
#line 140
  fill_lines(i, fs_win);
#line 142
  wrefresh(fs_win);
  }
#line 143
  return;
}
}
#line 145 "/home/wslee/benchmarks/sound/mp3c-0.29/src/select_box.c"
void do_pos1(int len , int height , WINDOW *fs_win ) 
{ 


  {
#line 147
  if (curr_line != 1) {
    {
#line 148
    sign_line(curr_an, len, (unsigned char)0, curr_line, fs_win);
#line 149
    curr_an = top_an;
#line 150
    curr_line = 1;
#line 151
    sign_line(curr_an, len, (unsigned char)1, curr_line, fs_win);
#line 152
    wrefresh(fs_win);
    }
#line 153
    return;
  }
#line 155
  if (top_an->prev) {
    {
#line 156
    while (1) {
      while_continue: /* CIL Label */ ;
#line 156
      if (! top_an->prev) {
#line 156
        goto while_break;
      }
#line 156
      top_an = top_an->prev;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 157
    curr_an = top_an;
#line 158
    fill_lines(len, fs_win);
#line 159
    wrefresh(fs_win);
    }
  }
#line 161
  return;
}
}
#line 164 "/home/wslee/benchmarks/sound/mp3c-0.29/src/select_box.c"
void do_end(int len , int height , WINDOW *fs_win ) 
{ 


  {
#line 166
  if ((unsigned long )curr_an->next == (unsigned long )((void *)0)) {
#line 166
    return;
  }
#line 168
  if (curr_line != height) {
    {
#line 169
    sign_line(curr_an, len, (unsigned char)0, curr_line, fs_win);
    }
    {
#line 170
    while (1) {
      while_continue: /* CIL Label */ ;
#line 170
      if (! (curr_line != height)) {
#line 170
        goto while_break;
      }
#line 171
      curr_an = curr_an->next;
#line 172
      curr_line ++;
#line 173
      if ((unsigned long )curr_an->next == (unsigned long )((void *)0)) {
#line 173
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 175
    sign_line(curr_an, len, (unsigned char)1, curr_line, fs_win);
    }
  } else {
    {
#line 177
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 177
      if (! ((unsigned long )curr_an->next != (unsigned long )((void *)0))) {
#line 177
        goto while_break___0;
      }
#line 178
      curr_an = curr_an->next;
#line 179
      top_an = top_an->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 181
    fill_lines(len, fs_win);
    }
  }
  {
#line 183
  wrefresh(fs_win);
  }
#line 184
  return;
}
}
#line 186 "/home/wslee/benchmarks/sound/mp3c-0.29/src/select_box.c"
void do_ppage(int len , int height , WINDOW *fs_win ) 
{ 
  int i ;

  {
#line 190
  if ((unsigned long )top_an->prev == (unsigned long )((void *)0)) {
#line 191
    if (curr_line != 1) {
      {
#line 191
      do_pos1(len, height, fs_win);
      }
    }
#line 192
    return;
  }
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (i < height)) {
#line 195
      goto while_break;
    }
#line 196
    if ((unsigned long )top_an->prev != (unsigned long )((void *)0)) {
#line 197
      top_an = top_an->prev;
#line 198
      curr_an = curr_an->prev;
    } else
#line 200
    if (curr_line == 1) {
#line 200
      goto while_break;
    } else {
#line 202
      curr_line --;
#line 203
      curr_an = curr_an->prev;
    }
#line 195
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 206
  fill_lines(len, fs_win);
#line 207
  wrefresh(fs_win);
  }
#line 208
  return;
}
}
#line 210 "/home/wslee/benchmarks/sound/mp3c-0.29/src/select_box.c"
void do_npage(int len , int height , WINDOW *fs_win ) 
{ 
  int i ;
  unsigned char fill ;

  {
#line 215
  if ((unsigned long )curr_an->next == (unsigned long )((void *)0)) {
#line 215
    return;
  }
  {
#line 217
  fill = (unsigned char)0;
#line 218
  sign_line(curr_an, len, (unsigned char)0, curr_line, fs_win);
#line 219
  i = 0;
  }
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! (i < height)) {
#line 219
      goto while_break;
    }
#line 220
    if ((unsigned long )curr_an->next == (unsigned long )((void *)0)) {
#line 220
      goto while_break;
    }
#line 221
    if (curr_line != height) {
#line 222
      curr_an = curr_an->next;
#line 223
      curr_line ++;
    } else {
#line 225
      fill = (unsigned char)1;
#line 226
      curr_an = curr_an->next;
#line 227
      top_an = top_an->next;
    }
#line 219
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  if (! fill) {
    {
#line 231
    sign_line(curr_an, len, (unsigned char)1, curr_line, fs_win);
    }
  } else {
    {
#line 232
    fill_lines(len, fs_win);
    }
  }
  {
#line 234
  wrefresh(fs_win);
  }
#line 235
  return;
}
}
#line 237 "/home/wslee/benchmarks/sound/mp3c-0.29/src/select_box.c"
field_select_typ *select_field_box(field_select_typ *fs_anchor , int max_length ,
                                   char *stat_text , unsigned char use_old , unsigned char allow_space ) 
{ 
  int i ;
  int j ;
  int i2 ;
  int maxx ;
  int maxy ;
  int inp_ch ;
  WINDOW *fs_win ;
  field_select_typ *curr ;

  {
#line 246
  sb_pressed_key = 0;
#line 248
  if (careful_batch) {
#line 248
    return ((field_select_typ *)((void *)0));
  }
#line 250
  if ((unsigned long )fs_anchor == (unsigned long )((void *)0)) {
#line 250
    return ((field_select_typ *)((void *)0));
  }
#line 252
  if (stdscr) {
#line 252
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 252
    maxy = -1;
  }
#line 252
  if (stdscr) {
#line 252
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 252
    maxx = -1;
  }
#line 253
  i = max_length + 2;
#line 254
  if (i > maxx) {
#line 254
    i = maxx;
  }
#line 255
  j = maxy >> 1;
#line 256
  i2 = 0;
#line 257
  curr = fs_anchor;
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (! curr) {
#line 258
      goto while_break;
    }
#line 259
    i2 ++;
#line 260
    curr = curr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  if (i2) {
#line 262
    if (j > i2) {
#line 262
      j = i2;
    }
  }
  {
#line 263
  fs_win = c_newwin(j + 2, i, (maxy - (j + 2)) >> 1, (maxx - i) >> 1, (void *)(& rebuild),
                    i - 2, i2);
#line 264
  store_win_poi(fs_win, (void *)stat_text);
#line 265
  i -= 2;
#line 267
  build_win(fs_win, stat_text, i);
  }
#line 268
  if (use_old) {
#line 269
    if (! top_an) {
#line 269
      use_old = (unsigned char)0;
    } else
#line 269
    if (! curr_an) {
#line 269
      use_old = (unsigned char)0;
    }
#line 270
    if (curr_line > maxy >> 1) {
#line 270
      use_old = (unsigned char)0;
    }
  }
#line 273
  if (! use_old) {
#line 274
    top_an = fs_anchor;
#line 275
    curr_an = fs_anchor;
#line 276
    curr_line = 1;
  }
  {
#line 278
  fill_lines(i, fs_win);
#line 279
  wrefresh(fs_win);
#line 281
  cbreak();
#line 282
  noecho();
#line 283
  keypad(fs_win, (_Bool)1);
  }
#line 284
  if (config_fancy_colors) {
    {
#line 285
    halfdelay(1);
    }
  } else {
    {
#line 287
    nodelay(fs_win, (_Bool)0);
    }
  }
  {
#line 289
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 290
    inp_ch = wgetch(fs_win);
    }
#line 291
    if (config_fancy_colors) {
      {
#line 291
      win_effect(fs_win, (unsigned char)1, (unsigned char)0);
      }
    }
#line 292
    if (stdscr) {
#line 292
      maxy = (int )stdscr->_maxy + 1;
    } else {
#line 292
      maxy = -1;
    }
#line 292
    if (stdscr) {
#line 292
      maxx = (int )stdscr->_maxx + 1;
    } else {
#line 292
      maxx = -1;
    }
#line 293
    j = maxy >> 1;
    {
#line 297
    if (inp_ch == 343) {
#line 297
      goto case_343;
    }
#line 297
    if (inp_ch == 13) {
#line 297
      goto case_343;
    }
#line 297
    if (inp_ch == 10) {
#line 297
      goto case_343;
    }
#line 301
    if (inp_ch == 32) {
#line 301
      goto case_32;
    }
#line 312
    if (inp_ch == 39) {
#line 312
      goto case_39;
    }
#line 312
    if (inp_ch == 276) {
#line 312
      goto case_39;
    }
#line 312
    if (inp_ch == 81) {
#line 312
      goto case_39;
    }
#line 312
    if (inp_ch == 113) {
#line 312
      goto case_39;
    }
#line 312
    if (inp_ch == 27) {
#line 312
      goto case_39;
    }
#line 316
    if (inp_ch == 12) {
#line 316
      goto case_12;
    }
#line 319
    if (inp_ch == 258) {
#line 319
      goto case_258;
    }
#line 334
    if (inp_ch == 259) {
#line 334
      goto case_259;
    }
#line 349
    if (inp_ch == 339) {
#line 349
      goto case_339;
    }
#line 352
    if (inp_ch == 338) {
#line 352
      goto case_338;
    }
#line 356
    if (inp_ch == 362) {
#line 356
      goto case_362;
    }
#line 356
    if (inp_ch == 262) {
#line 356
      goto case_362;
    }
#line 360
    if (inp_ch == 385) {
#line 360
      goto case_385;
    }
#line 360
    if (inp_ch == 360) {
#line 360
      goto case_385;
    }
#line 294
    goto switch_break;
    case_343: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    {
#line 298
    c_delwin(fs_win);
    }
#line 299
    return (curr_an);
#line 300
    goto switch_break;
    case_32: /* CIL Label */ 
#line 302
    if (allow_space) {
      {
#line 303
      c_delwin(fs_win);
#line 304
      sb_pressed_key = inp_ch;
      }
#line 305
      return (curr_an);
    }
#line 307
    goto switch_break;
    case_39: /* CIL Label */ 
    case_276: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_27: /* CIL Label */ 
    {
#line 313
    c_delwin(fs_win);
    }
#line 314
    return ((field_select_typ *)((void *)0));
#line 315
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 317
    set_active_win(fs_win);
    }
#line 318
    goto switch_break;
    case_258: /* CIL Label */ 
#line 320
    if (curr_an->next) {
      {
#line 321
      sign_line(curr_an, i, (unsigned char)0, curr_line, fs_win);
      }
#line 322
      if (curr_line < j) {
        {
#line 323
        curr_line ++;
#line 324
        curr_an = curr_an->next;
#line 325
        sign_line(curr_an, i, (unsigned char)1, curr_line, fs_win);
        }
      } else {
        {
#line 327
        top_an = top_an->next;
#line 328
        curr_an = curr_an->next;
#line 329
        fill_lines(i, fs_win);
        }
      }
      {
#line 331
      wrefresh(fs_win);
      }
    }
#line 333
    goto switch_break;
    case_259: /* CIL Label */ 
#line 335
    if (curr_an->prev) {
      {
#line 336
      sign_line(curr_an, i, (unsigned char)0, curr_line, fs_win);
      }
#line 337
      if (curr_line > 1) {
        {
#line 338
        curr_line --;
#line 339
        curr_an = curr_an->prev;
#line 340
        sign_line(curr_an, i, (unsigned char)1, curr_line, fs_win);
        }
      } else {
        {
#line 342
        top_an = top_an->prev;
#line 343
        curr_an = curr_an->prev;
#line 344
        fill_lines(i, fs_win);
        }
      }
      {
#line 346
      wrefresh(fs_win);
      }
    }
#line 348
    goto switch_break;
    case_339: /* CIL Label */ 
    {
#line 350
    do_ppage(i, j, fs_win);
    }
#line 351
    goto switch_break;
    case_338: /* CIL Label */ 
    {
#line 353
    do_npage(i, j, fs_win);
    }
#line 354
    goto switch_break;
    case_362: /* CIL Label */ 
    case_262: /* CIL Label */ 
    {
#line 357
    do_pos1(i, j, fs_win);
    }
#line 358
    goto switch_break;
    case_385: /* CIL Label */ 
    case_360: /* CIL Label */ 
    {
#line 361
    do_end(i, j, fs_win);
    }
#line 362
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 367 "/home/wslee/benchmarks/sound/mp3c-0.29/src/select_box.c"
int select_genre(void) 
{ 
  int i ;
  field_select_typ *new ;
  field_select_typ *anchor ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 373
  anchor = (field_select_typ *)((void *)0);
#line 374
  i = 147;
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if (! (i >= 0)) {
#line 374
      goto while_break;
    }
    {
#line 375
    tmp___0 = malloc((size_t )sizeof(field_select_typ ));
#line 375
    new = (field_select_typ *)tmp___0;
    }
#line 376
    if ((unsigned long )new == (unsigned long )((void *)0)) {
      {
#line 377
      perror("malloc");
#line 378
      wuuush(1);
      }
    }
    {
#line 380
    new->dest = (char *)((void *)0);
#line 381
    tmp___1 = malloc((size_t )sizeof(char ));
#line 381
    tmp = (char *)tmp___1;
    }
#line 382
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 383
      perror("malloc");
#line 384
      wuuush(1);
      }
    }
#line 386
    *tmp = (char )((unsigned char )i);
#line 387
    new->information = tmp;
#line 389
    if (i == 147) {
      {
#line 390
      new->field = copy_char_str(def_unknown_gen);
      }
    } else {
      {
#line 392
      new->field = copy_char_str(mp3_genre[i]);
      }
    }
#line 394
    new->prev = (struct _field_select_typ *)((void *)0);
#line 395
    new->next = anchor;
#line 396
    if (anchor) {
#line 396
      anchor->prev = new;
    }
#line 397
    anchor = new;
#line 374
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 400
  tmp___2 = gettext("select genre");
#line 400
  new = select_field_box(anchor, 25, tmp___2, (unsigned char)0, (unsigned char)0);
  }
#line 401
  if (new) {
#line 401
    i = (int )((unsigned char )*(new->information));
  } else {
#line 402
    i = -1;
  }
  {
#line 404
  free_field_select(& anchor);
  }
#line 405
  return (i);
}
}
#line 408 "/home/wslee/benchmarks/sound/mp3c-0.29/src/select_box.c"
unsigned char ynb_field  ;
#line 410 "/home/wslee/benchmarks/sound/mp3c-0.29/src/select_box.c"
void ynb_show(WINDOW *win , unsigned char flag ) 
{ 
  int maxy ;
  int maxx ;
  chtype old_ch ;
  int i ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 416
  if (win) {
#line 416
    maxy = (int )win->_maxy + 1;
  } else {
#line 416
    maxy = -1;
  }
#line 416
  if (win) {
#line 416
    maxx = (int )win->_maxx + 1;
  } else {
#line 416
    maxx = -1;
  }
#line 418
  old_ch = win->_bkgd;
#line 419
  if (flag) {
    {
#line 419
    wbkgdset(win, (unsigned long )(4 << 8) | (1UL << 21));
    }
  } else {
    {
#line 420
    wbkgdset(win, (chtype )(1 << 8));
    }
  }
  {
#line 421
  i = 1 + ((maxx - 12) >> 2);
#line 422
  tmp___0 = wmove(win, 2, i);
  }
#line 422
  if (! (tmp___0 == -1)) {
    {
#line 422
    tmp = gettext("[Yes]");
#line 422
    waddnstr(win, (char const   *)tmp, -1);
    }
  }
#line 424
  if (flag) {
    {
#line 424
    wbkgdset(win, (chtype )(1 << 8));
    }
  } else {
    {
#line 425
    wbkgdset(win, (unsigned long )(4 << 8) | (1UL << 21));
    }
  }
  {
#line 426
  i = 1 + ((maxx - 12) >> 2);
#line 427
  tmp___2 = wmove(win, 2, (maxx - i) - 4);
  }
#line 427
  if (! (tmp___2 == -1)) {
    {
#line 427
    tmp___1 = gettext("[No]");
#line 427
    waddnstr(win, (char const   *)tmp___1, -1);
    }
  }
  {
#line 429
  wbkgdset(win, old_ch);
#line 430
  wrefresh(win);
  }
#line 431
  return;
}
}
#line 433 "/home/wslee/benchmarks/sound/mp3c-0.29/src/select_box.c"
void ynb_build(WINDOW *win , int dum1 , int dum2 ) 
{ 
  int maxy ;
  int maxx ;
  int i ;
  char *tx ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 439
  if (stdscr) {
#line 439
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 439
    maxy = -1;
  }
#line 439
  if (stdscr) {
#line 439
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 439
    maxx = -1;
  }
  {
#line 440
  tmp = pop_win_poi(win);
#line 440
  tx = (char *)tmp;
#line 441
  i = 0;
  }
#line 442
  if (tx) {
    {
#line 442
    tmp___0 = strlen((char const   *)tx);
#line 442
    i = (int )(tmp___0 + 2U);
    }
  }
#line 443
  if (i < 12) {
#line 443
    i = 12;
  }
#line 444
  if (i > maxx) {
#line 444
    i = maxx;
  }
  {
#line 445
  mvwin(win, (maxy - 4) >> 1, (maxx - i) >> 1);
#line 446
  wresize(win, 4, i);
#line 448
  wbkgd(win, (unsigned long )(1 << 8) | (1UL << 21));
#line 449
  wclear(win);
#line 450
  wborder(win, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0,
          (chtype )0, (chtype )0);
  }
#line 452
  if (tx) {
    {
#line 453
    tmp___1 = strlen((char const   *)tx);
#line 453
    i = (int )((size_t )(i - 1) - tmp___1);
    }
#line 454
    if (i < 0) {
#line 454
      i = 0;
    }
    {
#line 455
    i >>= 1;
#line 456
    tmp___2 = wmove(win, 1, i + 1);
    }
#line 456
    if (! (tmp___2 == -1)) {
      {
#line 456
      waddnstr(win, (char const   *)tx, maxx - 2);
      }
    }
  }
  {
#line 458
  ynb_show(win, ynb_field);
  }
#line 459
  return;
}
}
#line 462 "/home/wslee/benchmarks/sound/mp3c-0.29/src/select_box.c"
unsigned char select_yesno_box(char *tx ) 
{ 
  WINDOW *ynb_win ;
  int maxy ;
  int maxx ;
  int inp_ch ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 468
  if (careful_batch) {
#line 468
    return ((unsigned char)1);
  }
#line 469
  ynb_field = (unsigned char)0;
#line 471
  if (stdscr) {
#line 471
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 471
    maxy = -1;
  }
#line 471
  if (stdscr) {
#line 471
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 471
    maxx = -1;
  }
#line 472
  inp_ch = 0;
#line 473
  if (tx) {
    {
#line 473
    tmp = strlen((char const   *)tx);
#line 473
    inp_ch = (int )(tmp + 2U);
    }
  }
#line 474
  if (inp_ch < 12) {
#line 474
    inp_ch = 12;
  }
#line 475
  if (inp_ch > maxx) {
#line 475
    inp_ch = maxx;
  }
  {
#line 476
  ynb_win = c_newwin((maxy - 4) >> 1, (maxx - inp_ch) >> 1, 4, inp_ch, (void *)(& ynb_build),
                     0, 0);
#line 478
  store_win_poi(ynb_win, (void *)tx);
#line 479
  ynb_build(ynb_win, 0, 0);
#line 481
  cbreak();
#line 482
  noecho();
#line 483
  keypad(ynb_win, (_Bool)1);
  }
#line 484
  if (config_fancy_colors) {
    {
#line 485
    halfdelay(1);
    }
  } else {
    {
#line 487
    nodelay(ynb_win, (_Bool)0);
    }
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 490
    inp_ch = wgetch(ynb_win);
    }
#line 491
    if (config_fancy_colors) {
      {
#line 492
      win_effect(ynb_win, (unsigned char)1, (unsigned char)0);
      }
    }
    {
#line 494
    tmp___2 = gettext("yY");
#line 494
    tmp___3 = strchr((char const   *)tmp___2, inp_ch);
    }
#line 494
    if (tmp___3) {
#line 494
      inp_ch = 'y';
    } else {
      {
#line 495
      tmp___0 = gettext("nN");
#line 495
      tmp___1 = strchr((char const   *)tmp___0, inp_ch);
      }
#line 495
      if (tmp___1) {
#line 495
        inp_ch = 'n';
      }
    }
    {
#line 501
    if (inp_ch == 259) {
#line 501
      goto case_259;
    }
#line 501
    if (inp_ch == 258) {
#line 501
      goto case_259;
    }
#line 501
    if (inp_ch == 260) {
#line 501
      goto case_259;
    }
#line 501
    if (inp_ch == 261) {
#line 501
      goto case_259;
    }
#line 501
    if (inp_ch == 9) {
#line 501
      goto case_259;
    }
#line 508
    if (inp_ch == 39) {
#line 508
      goto case_39;
    }
#line 508
    if (inp_ch == 276) {
#line 508
      goto case_39;
    }
#line 508
    if (inp_ch == 27) {
#line 508
      goto case_39;
    }
#line 514
    if (inp_ch == 13) {
#line 514
      goto case_13;
    }
#line 514
    if (inp_ch == 10) {
#line 514
      goto case_13;
    }
#line 514
    if (inp_ch == 343) {
#line 514
      goto case_13;
    }
#line 518
    if (inp_ch == 121) {
#line 518
      goto case_121;
    }
#line 522
    if (inp_ch == 110) {
#line 522
      goto case_110;
    }
#line 496
    goto switch_break;
    case_259: /* CIL Label */ 
    case_258: /* CIL Label */ 
    case_260: /* CIL Label */ 
    case_261: /* CIL Label */ 
    case_9: /* CIL Label */ 
#line 502
    if (ynb_field) {
#line 502
      ynb_field = (unsigned char)0;
    } else {
#line 503
      ynb_field = (unsigned char)1;
    }
    {
#line 504
    ynb_show(ynb_win, ynb_field);
    }
#line 505
    goto switch_break;
    case_39: /* CIL Label */ 
    case_276: /* CIL Label */ 
    case_27: /* CIL Label */ 
    {
#line 509
    c_delwin(ynb_win);
    }
#line 510
    return ((unsigned char)0);
#line 511
    goto switch_break;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_343: /* CIL Label */ 
    {
#line 515
    c_delwin(ynb_win);
    }
#line 516
    return (ynb_field);
#line 517
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 519
    c_delwin(ynb_win);
    }
#line 520
    return ((unsigned char)1);
#line 521
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 523
    c_delwin(ynb_win);
    }
#line 524
    return ((unsigned char)0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 214 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 555
extern int fputc(int __c , FILE *__stream ) ;
#line 662
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 151 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 44 "/home/wslee/benchmarks/sound/mp3c-0.29/src/rip_hand.c"
void free_song_typ(song_typ **anchor ) ;
#line 45
void calc_tot_frm(void) ;
#line 46
void fill_in_songs(WINDOW *win ) ;
#line 50
int add_to_m3u(song_typ *song ) ;
#line 51
void add_field_entry(field_select_typ **anchor , char *des , int nr , char *value ) ;
#line 57
int read_from_sock2(char **line , int sock_fd , unsigned char wait ) ;
#line 59
int lock_lock_file(char *lockfile , unsigned char extension ) ;
#line 60
int lock_unlock_file(char *lockfile , unsigned char extension ) ;
#line 61
song_typ *lay_global_anchor[2] ;
#line 62
song_typ *lay_top_anchor[2] ;
#line 65
int lay_act_side ;
#line 66
unsigned long lay_tot_frm[2] ;
#line 70 "/home/wslee/benchmarks/sound/mp3c-0.29/src/rip_hand.c"
int num_ripped_tracks  ;
#line 73 "/home/wslee/benchmarks/sound/mp3c-0.29/src/rip_hand.c"
char *copy_char_str(char *old ) 
{ 
  char *new ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 77
  if (! old) {
#line 77
    return ((char *)((void *)0));
  }
  {
#line 78
  tmp = strlen((char const   *)old);
#line 78
  tmp___0 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp + 1U)));
#line 78
  new = (char *)tmp___0;
  }
#line 79
  if (! new) {
    {
#line 80
    wuuush(1);
    }
  }
  {
#line 82
  strcpy((char */* __restrict  */)new, (char const   */* __restrict  */)old);
  }
#line 84
  return (new);
}
}
#line 88 "/home/wslee/benchmarks/sound/mp3c-0.29/src/rip_hand.c"
song_typ *copy_song_typ(song_typ *old ) 
{ 
  song_typ *new ;
  void *tmp ;

  {
  {
#line 92
  tmp = malloc((size_t )sizeof(song_typ ));
#line 92
  new = (song_typ *)tmp;
  }
#line 93
  if (! new) {
    {
#line 94
    wuuush(1);
    }
  }
  {
#line 97
  new->convert = old->convert;
#line 98
  new->artist = copy_char_str(old->artist);
#line 99
  new->title = copy_char_str(old->title);
#line 100
  new->album = copy_char_str(old->album);
#line 101
  new->comment = copy_char_str(old->comment);
#line 102
  new->year = old->year;
#line 103
  new->genre = old->genre;
#line 104
  new->filename = copy_char_str(old->filename);
#line 105
  new->dirname = copy_char_str(old->dirname);
#line 106
  new->on_fly = old->on_fly;
#line 107
  new->toc = old->toc;
#line 108
  new->fn_auto = old->fn_auto;
#line 109
  new->cddb_id = old->cddb_id;
#line 110
  new->tmp_wav_file = copy_char_str(old->tmp_wav_file);
#line 111
  new->frame_len = old->frame_len;
#line 112
  new->sampler = old->sampler;
#line 113
  new->next = old->next;
#line 114
  new->prev = old->prev;
  }
#line 116
  return (new);
}
}
#line 119 "/home/wslee/benchmarks/sound/mp3c-0.29/src/rip_hand.c"
void rhand_add_ripped(song_typ *track , WINDOW *win ) 
{ 
  song_typ *new ;
  song_typ *curr ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 124
  if (! track->tmp_wav_file) {
    {
#line 125
    tmp = return_track_tmpname(track);
#line 125
    tmp___0 = access((char const   *)tmp, 4);
    }
#line 125
    if (tmp___0 != 0) {
#line 126
      return;
    }
  } else {
    {
#line 129
    tmp___1 = access((char const   *)track->tmp_wav_file, 4);
    }
#line 129
    if (tmp___1 != 0) {
#line 130
      return;
    }
  }
  {
#line 134
  new = copy_song_typ(track);
#line 135
  new->on_fly = (unsigned char)1;
#line 136
  new->convert = (unsigned char)1;
#line 137
  track->convert = (unsigned char)0;
  }
#line 139
  if (! new->tmp_wav_file) {
    {
#line 139
    tmp___2 = return_track_tmpname(track);
#line 139
    new->tmp_wav_file = copy_char_str(tmp___2);
    }
  }
#line 140
  if (new->tmp_wav_file) {
#line 141
    curr = lay_global_anchor[1];
    {
#line 142
    while (1) {
      while_continue: /* CIL Label */ ;
#line 142
      if (! curr) {
#line 142
        goto while_break;
      }
#line 143
      if (curr->tmp_wav_file) {
        {
#line 143
        tmp___3 = strcmp((char const   *)new->tmp_wav_file, (char const   *)curr->tmp_wav_file);
        }
#line 143
        if (tmp___3 == 0) {
          {
#line 144
          new->next = (struct _song_typ *)((void *)0);
#line 145
          new->prev = (struct _song_typ *)((void *)0);
#line 146
          free_song_typ(& new);
#line 147
          new = (song_typ *)((void *)0);
          }
#line 148
          return;
        }
      }
#line 150
      curr = curr->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 154
  new->next = (struct _song_typ *)((void *)0);
#line 155
  if (! lay_global_anchor[1]) {
#line 156
    lay_global_anchor[1] = new;
#line 157
    new->prev = (struct _song_typ *)((void *)0);
#line 158
    lay_top_anchor[1] = new;
#line 159
    lay_curr_anchor[1] = new;
  } else {
#line 161
    curr = lay_global_anchor[1];
    {
#line 162
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 162
      if (! curr->next) {
#line 162
        goto while_break___0;
      }
#line 162
      curr = curr->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 163
    curr->next = new;
#line 164
    new->prev = curr;
  }
  {
#line 167
  num_ripped_tracks ++;
#line 168
  calc_tot_frm();
#line 169
  fill_in_songs(win);
  }
#line 170
  return;
}
}
#line 172 "/home/wslee/benchmarks/sound/mp3c-0.29/src/rip_hand.c"
void rhand_delete_from_list(song_typ *track , WINDOW *win ) 
{ 
  int i ;
  song_typ *curr ;

  {
#line 177
  if (! track) {
#line 177
    return;
  }
#line 179
  if (track->on_fly) {
#line 179
    if (track->tmp_wav_file) {
      {
#line 180
      unlink((char const   *)track->tmp_wav_file);
      }
    }
  }
#line 182
  lay_tot_frm[1] -= (unsigned long )track->frame_len;
#line 184
  if (track->prev) {
#line 184
    (track->prev)->next = track->next;
  } else {
#line 185
    lay_global_anchor[1] = track->next;
  }
#line 186
  if (track->next) {
#line 186
    (track->next)->prev = track->prev;
  }
#line 188
  if ((unsigned long )lay_top_anchor[1] == (unsigned long )track) {
#line 189
    if ((lay_top_anchor[1])->next) {
#line 189
      lay_top_anchor[1] = (lay_top_anchor[1])->next;
    } else
#line 190
    if ((lay_top_anchor[1])->prev) {
#line 190
      lay_top_anchor[1] = (lay_top_anchor[1])->prev;
    } else {
#line 191
      lay_top_anchor[1] = (song_typ *)((void *)0);
    }
  }
#line 194
  if ((unsigned long )track == (unsigned long )lay_curr_anchor[1]) {
#line 194
    if ((unsigned long )track->next == (unsigned long )((void *)0)) {
#line 195
      if (lay_select_line[1] > 1) {
#line 195
        (lay_select_line[1]) --;
      }
    } else {
#line 194
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 196
  if (lay_top_anchor[1]) {
#line 196
    if (lay_curr_anchor[1]) {
#line 197
      curr = lay_top_anchor[1];
#line 198
      i = 1;
      {
#line 199
      while (1) {
        while_continue: /* CIL Label */ ;
#line 199
        if (! curr) {
#line 199
          goto while_break;
        }
#line 200
        if ((unsigned long )curr == (unsigned long )lay_curr_anchor[1]) {
#line 201
          lay_select_line[1] = i;
#line 202
          goto while_break;
        }
#line 204
        curr = curr->next;
#line 205
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 209
  track->next = (struct _song_typ *)((void *)0);
#line 210
  track->prev = (struct _song_typ *)((void *)0);
#line 211
  free_song_typ(& track);
#line 212
  track = (song_typ *)((void *)0);
#line 214
  num_ripped_tracks --;
  }
#line 215
  if (! num_ripped_tracks) {
#line 215
    lay_act_side = 0;
  }
#line 216
  if (win) {
    {
#line 216
    fill_in_songs(win);
    }
  }
#line 217
  return;
}
}
#line 219 "/home/wslee/benchmarks/sound/mp3c-0.29/src/rip_hand.c"
void rhand_do_enc(song_typ *track , WINDOW *win ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 221
  tmp = enc_non_fly(track, track->on_fly);
  }
#line 221
  if (! tmp) {
    {
#line 221
    tmp___0 = set_mp3_inf(track);
    }
#line 221
    if (! tmp___0) {
      {
#line 221
      tmp___1 = add_to_m3u(track);
      }
#line 221
      if (! tmp___1) {
        {
#line 223
        rhand_delete_from_list(track, win);
        }
      }
    }
  }
#line 225
  return;
}
}
#line 227 "/home/wslee/benchmarks/sound/mp3c-0.29/src/rip_hand.c"
void rhand_del_actual(WINDOW *win ) 
{ 


  {
#line 229
  if (lay_curr_anchor[1]) {
    {
#line 230
    rhand_delete_from_list(lay_curr_anchor[1], win);
    }
  }
#line 232
  return;
}
}
#line 234 "/home/wslee/benchmarks/sound/mp3c-0.29/src/rip_hand.c"
void rhand_del_marked(WINDOW *win ) 
{ 
  song_typ *curr ;
  song_typ *next ;

  {
#line 238
  curr = lay_global_anchor[1];
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 239
    if (! curr) {
#line 239
      goto while_break;
    }
#line 240
    next = curr->next;
#line 241
    if (curr->convert) {
      {
#line 242
      rhand_delete_from_list(curr, (WINDOW *)((void *)0));
      }
    }
#line 244
    curr = next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 247
  fill_in_songs(win);
  }
#line 248
  return;
}
}
#line 250 "/home/wslee/benchmarks/sound/mp3c-0.29/src/rip_hand.c"
void rhand_export_track(FILE *fd , song_typ *track , unsigned char clear_del ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 251
  fputs((char const   */* __restrict  */)"#MP3c#\n", (FILE */* __restrict  */)fd);
  }
#line 254
  if (track->artist) {
    {
#line 254
    fputs((char const   */* __restrict  */)track->artist, (FILE */* __restrict  */)fd);
    }
  }
  {
#line 255
  fputc('\n', fd);
  }
#line 256
  if (track->title) {
    {
#line 256
    fputs((char const   */* __restrict  */)track->title, (FILE */* __restrict  */)fd);
    }
  }
  {
#line 257
  fputc('\n', fd);
  }
#line 258
  if (track->album) {
    {
#line 258
    fputs((char const   */* __restrict  */)track->album, (FILE */* __restrict  */)fd);
    }
  }
  {
#line 259
  fputc('\n', fd);
  }
#line 260
  if (track->comment) {
    {
#line 260
    fputs((char const   */* __restrict  */)track->comment, (FILE */* __restrict  */)fd);
    }
  }
  {
#line 261
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n%d\n%d\n",
          track->year, track->genre);
  }
#line 262
  if (track->filename) {
    {
#line 262
    fputs((char const   */* __restrict  */)track->filename, (FILE */* __restrict  */)fd);
    }
  }
  {
#line 263
  fputc('\n', fd);
  }
#line 264
  if (track->dirname) {
    {
#line 264
    fputs((char const   */* __restrict  */)track->dirname, (FILE */* __restrict  */)fd);
    }
  }
  {
#line 265
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n%d\n%d %d\n%ld\n",
          (int )track->toc, (int )track->fn_auto, (int )track->sampler, track->cddb_id);
  }
#line 266
  if (track->tmp_wav_file) {
    {
#line 266
    fputs((char const   */* __restrict  */)track->tmp_wav_file, (FILE */* __restrict  */)fd);
    }
  }
  {
#line 267
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n%ld\n",
          track->frame_len);
  }
#line 269
  if (clear_del) {
#line 269
    track->on_fly = (unsigned char)0;
  }
#line 270
  return;
}
}
#line 277 "/home/wslee/benchmarks/sound/mp3c-0.29/src/rip_hand.c"
int rhand_save_ripped(char *file_name , unsigned char clear_del , int sel_code ) 
{ 
  FILE *save_fd ;
  char *error_str ;
  field_select_typ *anchor ;
  field_select_typ *new ;
  int code ;
  song_typ *curr ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 285
  if (sel_code < 0) {
#line 285
    return (1);
  } else
#line 285
  if (sel_code > 2) {
#line 285
    return (1);
  }
#line 287
  if (! lay_global_anchor[1]) {
#line 287
    return (0);
  }
  {
#line 289
  create_sub_dirs(file_name, (unsigned char)1);
#line 292
  tmp___0 = lock_lock_file(file_name, (unsigned char)1);
  }
#line 292
  if (tmp___0 == 3) {
    {
#line 293
    tmp = gettext("listfile is locked, write aborted");
#line 293
    popup_error_win(tmp);
    }
#line 294
    return (1);
  }
  {
#line 297
  tmp___11 = access((char const   *)file_name, 0);
  }
#line 297
  if (tmp___11 == 0) {
    {
#line 298
    tmp___10 = access((char const   *)file_name, 2);
    }
#line 298
    if (tmp___10 != 0) {
      {
#line 299
      tmp___1 = strlen((char const   *)file_name);
#line 299
      tmp___2 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___1 + 100U)));
#line 299
      error_str = (char *)tmp___2;
      }
#line 300
      if (! error_str) {
        {
#line 301
        wuuush(1);
        }
      }
      {
#line 303
      tmp___3 = gettext("file \"%s\" exists, and isn\'t writeable");
#line 303
      sprintf((char */* __restrict  */)error_str, (char const   */* __restrict  */)tmp___3,
              file_name);
#line 304
      popup_error_win(error_str);
#line 305
      free((void *)error_str);
#line 306
      error_str = (char *)((void *)0);
#line 307
      lock_unlock_file(file_name, (unsigned char)1);
      }
#line 308
      return (1);
    } else {
      {
#line 310
      anchor = (field_select_typ *)((void *)0);
#line 311
      tmp___4 = gettext("Overwrite file");
#line 311
      add_field_entry(& anchor, tmp___4, 1, (char *)((void *)0));
#line 312
      tmp___5 = gettext("Append to file");
#line 312
      add_field_entry(& anchor, tmp___5, 2, (char *)((void *)0));
#line 313
      tmp___6 = gettext("Abort");
#line 313
      add_field_entry(& anchor, tmp___6, 3, (char *)((void *)0));
#line 314
      tmp___7 = strlen((char const   *)file_name);
#line 314
      tmp___8 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___7 + 100U)));
#line 314
      error_str = (char *)tmp___8;
      }
#line 315
      if (! error_str) {
        {
#line 316
        wuuush(1);
        }
      }
      {
#line 318
      tmp___9 = gettext("file \"%s\" exists, what to do?");
#line 318
      sprintf((char */* __restrict  */)error_str, (char const   */* __restrict  */)tmp___9,
              file_name);
#line 319
      new = select_field_box(anchor, 60, error_str, (unsigned char)0, (unsigned char)0);
#line 320
      free((void *)error_str);
#line 321
      error_str = (char *)((void *)0);
      }
#line 322
      if (! new) {
#line 322
        code = 0;
      } else {
#line 323
        code = (int )((unsigned char )*(new->information));
      }
      {
#line 324
      free_field_select(& anchor);
#line 325
      anchor = (field_select_typ *)((void *)0);
      }
#line 326
      if (code == 1) {
        {
#line 327
        unlink((char const   *)file_name);
        }
      } else
#line 328
      if (code == 0) {
        {
#line 329
        lock_unlock_file(file_name, (unsigned char)1);
        }
#line 330
        return (1);
      } else
#line 331
      if (code == 3) {
        {
#line 332
        lock_unlock_file(file_name, (unsigned char)1);
        }
#line 333
        return (0);
      }
    }
  }
  {
#line 338
  save_fd = fopen((char const   */* __restrict  */)file_name, (char const   */* __restrict  */)"a");
  }
#line 339
  if (! save_fd) {
    {
#line 340
    tmp___12 = strlen((char const   *)file_name);
#line 340
    tmp___13 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___12 + 100U)));
#line 340
    error_str = (char *)tmp___13;
#line 341
    tmp___14 = gettext("could not open file \"%s\" for writing");
#line 341
    sprintf((char */* __restrict  */)error_str, (char const   */* __restrict  */)tmp___14,
            file_name);
#line 342
    popup_error_win(error_str);
#line 343
    free((void *)error_str);
#line 344
    error_str = (char *)((void *)0);
#line 345
    lock_unlock_file(file_name, (unsigned char)1);
    }
#line 346
    return (1);
  }
#line 349
  if (sel_code == 0) {
    {
#line 350
    rhand_export_track(save_fd, lay_curr_anchor[1], clear_del);
#line 351
    fclose(save_fd);
#line 353
    tmp___15 = gettext("Track exported");
#line 353
    popup_error_win(tmp___15);
#line 354
    lock_unlock_file(file_name, (unsigned char)1);
    }
#line 355
    return (0);
  }
#line 357
  curr = lay_global_anchor[1];
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! curr) {
#line 358
      goto while_break;
    }
#line 359
    if (curr->convert) {
      {
#line 360
      rhand_export_track(save_fd, curr, clear_del);
      }
    } else
#line 359
    if (sel_code == 2) {
      {
#line 360
      rhand_export_track(save_fd, curr, clear_del);
      }
    }
#line 362
    curr = curr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 365
  fclose(save_fd);
#line 367
  tmp___16 = gettext("Tracks exported");
#line 367
  popup_error_win(tmp___16);
#line 368
  lock_unlock_file(file_name, (unsigned char)1);
  }
#line 369
  return (0);
}
}
#line 372 "/home/wslee/benchmarks/sound/mp3c-0.29/src/rip_hand.c"
int rhand_load_ripped(char *file_name , WINDOW *win ) 
{ 
  int load_fd ;
  char *error_str ;
  song_typ *curr ;
  char *inp_line ;
  unsigned char ignore_mode ;
  field_select_typ *anchor ;
  field_select_typ *new ;
  int i ;
  char *pat ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  size_t tmp___33 ;
  size_t tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  size_t tmp___38 ;
  void *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  char *tmp___44 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;

  {
  {
#line 383
  tmp___0 = lock_lock_file(file_name, (unsigned char)1);
  }
#line 383
  if (tmp___0 == 3) {
    {
#line 384
    tmp = gettext("listfile is locked, read aborted");
#line 384
    popup_error_win(tmp);
    }
#line 385
    return (1);
  }
  {
#line 388
  load_fd = open((char const   *)file_name, 0);
  }
#line 389
  if (load_fd < 1) {
    {
#line 390
    tmp___1 = strlen((char const   *)file_name);
#line 390
    tmp___2 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___1 + 100U)));
#line 390
    error_str = (char *)tmp___2;
#line 391
    tmp___3 = gettext("could not open \"%s\"");
#line 391
    sprintf((char */* __restrict  */)error_str, (char const   */* __restrict  */)tmp___3,
            file_name);
#line 392
    popup_error_win(error_str);
#line 393
    free((void *)error_str);
#line 394
    error_str = (char *)((void *)0);
#line 395
    lock_unlock_file(file_name, (unsigned char)1);
    }
#line 396
    return (1);
  }
#line 399
  cache_remain = 0;
#line 400
  ignore_mode = (unsigned char)0;
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 402
    tmp___43 = read_from_sock2(& inp_line, load_fd, (unsigned char)0);
    }
#line 402
    if (! (tmp___43 == 0)) {
#line 402
      goto while_break;
    }
    {
#line 403
    curr = (song_typ *)((void *)0);
#line 404
    tmp___5 = strcmp((char const   *)inp_line, "#MP3c#");
    }
#line 404
    if (tmp___5 != 0) {
      {
#line 405
      tmp___4 = gettext("importfile is in illegal format!");
#line 405
      popup_error_win(tmp___4);
      }
#line 406
      if (inp_line) {
        {
#line 407
        free((void *)inp_line);
#line 408
        inp_line = (char *)((void *)0);
        }
      }
      {
#line 410
      close(load_fd);
#line 411
      lock_unlock_file(file_name, (unsigned char)1);
      }
#line 412
      return (1);
    }
#line 414
    if (inp_line) {
      {
#line 415
      free((void *)inp_line);
#line 416
      inp_line = (char *)((void *)0);
      }
    }
    {
#line 418
    tmp___6 = malloc((size_t )sizeof(song_typ ));
#line 418
    curr = (song_typ *)tmp___6;
    }
#line 419
    if (! curr) {
      {
#line 420
      wuuush(1);
      }
    }
    {
#line 422
    curr->convert = (unsigned char)1;
#line 423
    curr->artist = (char *)((void *)0);
#line 424
    curr->title = (char *)((void *)0);
#line 425
    curr->album = (char *)((void *)0);
#line 426
    curr->comment = (char *)((void *)0);
#line 427
    curr->year = 1999;
#line 428
    curr->genre = 0;
#line 429
    curr->filename = (char *)((void *)0);
#line 430
    curr->dirname = (char *)((void *)0);
#line 431
    curr->on_fly = (unsigned char)0;
#line 432
    curr->toc = (char)1;
#line 433
    curr->fn_auto = (unsigned char)1;
#line 434
    curr->cddb_id = 0L;
#line 435
    curr->tmp_wav_file = (char *)((void *)0);
#line 436
    curr->frame_len = 1L;
#line 437
    curr->sampler = (unsigned char)0;
#line 438
    curr->next = (struct _song_typ *)((void *)0);
#line 439
    curr->prev = (struct _song_typ *)((void *)0);
#line 442
    tmp___7 = read_from_sock2(& inp_line, load_fd, (unsigned char)0);
    }
#line 442
    if (tmp___7 != 0) {
#line 442
      goto while_break;
    }
    {
#line 443
    curr->artist = inp_line;
#line 444
    tmp___8 = read_from_sock2(& inp_line, load_fd, (unsigned char)0);
    }
#line 444
    if (tmp___8 != 0) {
#line 444
      goto while_break;
    }
    {
#line 445
    curr->title = inp_line;
#line 446
    tmp___9 = read_from_sock2(& inp_line, load_fd, (unsigned char)0);
    }
#line 446
    if (tmp___9 != 0) {
#line 446
      goto while_break;
    }
    {
#line 447
    curr->album = inp_line;
#line 448
    tmp___10 = read_from_sock2(& inp_line, load_fd, (unsigned char)0);
    }
#line 448
    if (tmp___10 != 0) {
#line 448
      goto while_break;
    }
    {
#line 449
    curr->comment = inp_line;
#line 450
    tmp___11 = read_from_sock2(& inp_line, load_fd, (unsigned char)0);
    }
#line 450
    if (tmp___11 != 0) {
#line 450
      goto while_break;
    }
    {
#line 451
    tmp___12 = strlen((char const   *)inp_line);
    }
#line 451
    if (tmp___12 > 0U) {
      {
#line 451
      tmp___13 = strlen((char const   *)inp_line);
      }
#line 451
      if (tmp___13 < 5U) {
        {
#line 452
        curr->year = atoi((char const   *)inp_line);
        }
      }
    }
    {
#line 453
    free((void *)inp_line);
#line 454
    inp_line = (char *)((void *)0);
#line 455
    tmp___14 = read_from_sock2(& inp_line, load_fd, (unsigned char)0);
    }
#line 455
    if (tmp___14 != 0) {
#line 455
      goto while_break;
    }
    {
#line 456
    tmp___15 = strlen((char const   *)inp_line);
    }
#line 456
    if (tmp___15 > 0U) {
      {
#line 456
      tmp___16 = strlen((char const   *)inp_line);
      }
#line 456
      if (tmp___16 < 4U) {
        {
#line 457
        curr->genre = atoi((char const   *)inp_line);
        }
#line 458
        if (curr->genre < 0) {
#line 458
          curr->genre = 0;
        } else
#line 458
        if (curr->genre > 147) {
#line 458
          curr->genre = 0;
        }
      }
    }
    {
#line 460
    free((void *)inp_line);
#line 461
    inp_line = (char *)((void *)0);
#line 462
    tmp___17 = read_from_sock2(& inp_line, load_fd, (unsigned char)0);
    }
#line 462
    if (tmp___17 != 0) {
#line 462
      goto while_break;
    }
    {
#line 463
    curr->filename = inp_line;
#line 464
    tmp___18 = read_from_sock2(& inp_line, load_fd, (unsigned char)0);
    }
#line 464
    if (tmp___18 != 0) {
#line 464
      goto while_break;
    }
    {
#line 465
    curr->dirname = inp_line;
#line 466
    tmp___19 = read_from_sock2(& inp_line, load_fd, (unsigned char)0);
    }
#line 466
    if (tmp___19 != 0) {
#line 466
      goto while_break;
    }
    {
#line 467
    tmp___21 = strlen((char const   *)inp_line);
    }
#line 467
    if (tmp___21 > 0U) {
      {
#line 467
      tmp___22 = strlen((char const   *)inp_line);
      }
#line 467
      if (tmp___22 < 3U) {
        {
#line 468
        tmp___20 = atoi((char const   *)inp_line);
#line 468
        curr->toc = (char )tmp___20;
        }
      }
    }
#line 470
    if ((int )curr->toc < 0) {
#line 470
      curr->toc = (char)0;
    } else
#line 470
    if ((int )curr->toc > 99) {
#line 470
      curr->toc = (char)0;
    }
    {
#line 471
    free((void *)inp_line);
#line 472
    inp_line = (char *)((void *)0);
#line 473
    tmp___23 = read_from_sock2(& inp_line, load_fd, (unsigned char)0);
    }
#line 473
    if (tmp___23 != 0) {
#line 473
      goto while_break;
    }
    {
#line 474
    tmp___26 = strlen((char const   *)inp_line);
    }
#line 474
    if (tmp___26 > 0U) {
      {
#line 474
      tmp___27 = strlen((char const   *)inp_line);
      }
#line 474
      if (tmp___27 < 5U) {
        {
#line 475
        pat = strchr((char const   *)inp_line, ' ');
        }
#line 476
        if (pat) {
#line 476
          *pat = (char)0;
        }
        {
#line 477
        tmp___24 = atoi((char const   *)inp_line);
#line 477
        curr->fn_auto = (unsigned char )tmp___24;
        }
#line 478
        if (pat) {
          {
#line 478
          tmp___25 = atoi((char const   *)(pat + 1));
#line 478
          curr->sampler = (unsigned char )tmp___25;
          }
        }
      }
    }
#line 480
    if ((int )curr->fn_auto != 1) {
#line 480
      if ((int )curr->fn_auto != 0) {
#line 480
        curr->fn_auto = (unsigned char)1;
      }
    }
#line 481
    if ((int )curr->sampler != 1) {
#line 481
      if ((int )curr->sampler != 0) {
#line 481
        curr->sampler = (unsigned char)0;
      }
    }
    {
#line 482
    free((void *)inp_line);
#line 483
    inp_line = (char *)((void *)0);
#line 484
    tmp___28 = read_from_sock2(& inp_line, load_fd, (unsigned char)0);
    }
#line 484
    if (tmp___28 != 0) {
#line 484
      goto while_break;
    }
    {
#line 485
    tmp___29 = strlen((char const   *)inp_line);
    }
#line 485
    if (tmp___29 > 0U) {
      {
#line 485
      tmp___30 = strlen((char const   *)inp_line);
      }
#line 485
      if (tmp___30 < 12U) {
        {
#line 486
        curr->cddb_id = atol((char const   *)inp_line);
        }
      }
    }
    {
#line 487
    free((void *)inp_line);
#line 488
    inp_line = (char *)((void *)0);
#line 489
    tmp___31 = read_from_sock2(& inp_line, load_fd, (unsigned char)0);
    }
#line 489
    if (tmp___31 != 0) {
#line 489
      goto while_break;
    }
    {
#line 490
    curr->tmp_wav_file = inp_line;
#line 491
    tmp___32 = read_from_sock2(& inp_line, load_fd, (unsigned char)0);
    }
#line 491
    if (tmp___32 != 0) {
#line 491
      goto while_break;
    }
    {
#line 492
    tmp___33 = strlen((char const   *)inp_line);
    }
#line 492
    if (tmp___33 > 0U) {
      {
#line 492
      tmp___34 = strlen((char const   *)inp_line);
      }
#line 492
      if (tmp___34 < 12U) {
        {
#line 493
        curr->frame_len = atol((char const   *)inp_line);
        }
#line 494
        if (curr->frame_len < 0L) {
#line 494
          curr->frame_len = 1L;
        }
      }
    }
    {
#line 496
    free((void *)inp_line);
#line 497
    inp_line = (char *)((void *)0);
    }
#line 499
    if (curr->tmp_wav_file) {
      {
#line 500
      tmp___42 = access((char const   *)curr->tmp_wav_file, 4);
      }
#line 500
      if (tmp___42 != 0) {
#line 501
        if (! ignore_mode) {
          {
#line 502
          anchor = (field_select_typ *)((void *)0);
#line 503
          tmp___35 = gettext("Ignore");
#line 503
          add_field_entry(& anchor, tmp___35, 1, (char *)((void *)0));
#line 504
          tmp___36 = gettext("Ignore all");
#line 504
          add_field_entry(& anchor, tmp___36, 2, (char *)((void *)0));
#line 505
          tmp___37 = gettext("Abort");
#line 505
          add_field_entry(& anchor, tmp___37, 3, (char *)((void *)0));
#line 506
          tmp___38 = strlen((char const   *)curr->tmp_wav_file);
#line 506
          tmp___39 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___38 + 100U)));
#line 506
          error_str = (char *)tmp___39;
          }
#line 507
          if (! error_str) {
            {
#line 508
            wuuush(1);
            }
          }
          {
#line 510
          tmp___40 = gettext("trackfile \"%s\" is not available");
#line 510
          sprintf((char */* __restrict  */)error_str, (char const   */* __restrict  */)tmp___40,
                  curr->tmp_wav_file);
#line 511
          new = select_field_box(anchor, 72, error_str, (unsigned char)0, (unsigned char)0);
#line 512
          free((void *)error_str);
#line 513
          error_str = (char *)((void *)0);
          }
#line 514
          if (! new) {
#line 515
            i = 0;
          } else {
#line 517
            i = (int )((unsigned char )*(new->information));
          }
          {
#line 519
          free_field_select(& anchor);
          }
#line 520
          if (i == 2) {
#line 521
            ignore_mode = (unsigned char)1;
          } else
#line 522
          if (i == 3) {
            {
#line 523
            free_song_typ(& curr);
#line 524
            curr = (song_typ *)((void *)0);
            }
#line 525
            if (inp_line) {
              {
#line 526
              free((void *)inp_line);
#line 527
              inp_line = (char *)((void *)0);
              }
            }
            {
#line 529
            close(load_fd);
#line 530
            tmp___41 = gettext("Aborted");
#line 530
            popup_error_win(tmp___41);
#line 531
            lock_unlock_file(file_name, (unsigned char)1);
            }
#line 532
            return (0);
          }
        }
      } else {
        {
#line 536
        rhand_add_ripped(curr, win);
        }
      }
    }
    {
#line 539
    free_song_typ(& curr);
#line 540
    curr = (song_typ *)((void *)0);
#line 541
    inp_line = (char *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  if (inp_line) {
    {
#line 545
    free((void *)inp_line);
#line 546
    inp_line = (char *)((void *)0);
    }
  }
#line 548
  if (curr) {
    {
#line 549
    free_song_typ(& curr);
#line 550
    curr = (song_typ *)((void *)0);
    }
  }
  {
#line 552
  close(load_fd);
#line 554
  tmp___44 = gettext("Tracks imported");
#line 554
  popup_error_win(tmp___44);
#line 555
  lock_unlock_file(file_name, (unsigned char)1);
  }
#line 556
  return (0);
}
}
#line 559 "/home/wslee/benchmarks/sound/mp3c-0.29/src/rip_hand.c"
void rhand_remove_dead_files(WINDOW *win ) 
{ 
  song_typ *curr ;
  song_typ *next ;
  int tmp ;

  {
#line 563
  curr = lay_global_anchor[1];
  {
#line 564
  while (1) {
    while_continue: /* CIL Label */ ;
#line 564
    if (! curr) {
#line 564
      goto while_break;
    }
    {
#line 565
    next = curr->next;
#line 566
    tmp = access((char const   *)curr->tmp_wav_file, 4);
    }
#line 566
    if (tmp != 0) {
      {
#line 567
      rhand_delete_from_list(curr, win);
      }
    }
#line 569
    curr = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 571
  return;
}
}
#line 507 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
#line 705 "/usr/include/ncurses.h"
extern int scrollok(WINDOW * , _Bool  ) ;
#line 803
extern int wvline(WINDOW * , chtype  , int  ) ;
#line 48 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 135
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 260
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 340
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
#line 135 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 150
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 163
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 209 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkdir)(char const   *__path ,
                                                                                  __mode_t __mode ) ;
#line 73 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
char *input_line(int y_line , char *def_str , char *usage_str , unsigned char select___0 ) ;
#line 75
char *input_line2(int y_line , char *def_str , char *usage_str , char *des1 , char *des2 ,
                  char *des3 , char *des4 , char *des5 , char *des6 , unsigned char select___0 ) ;
#line 78
char *file_glob_out_name(char *name ) ;
#line 79
char *file_glob_in_name(char *name ) ;
#line 80
char *kill_double_slashs(char *string ) ;
#line 82
unsigned char config_curs_dir ;
#line 83
unsigned char config_req_hidden ;
#line 91 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
unsigned char req_refresh_needed  =    (unsigned char)0;
#line 94 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
char *req_correct_dir(char *in_file ) 
{ 
  char *cwd_name ;
  char *pat ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 99
  if (! in_file) {
#line 99
    return ((char *)((void *)0));
  }
#line 101
  if ((int )*in_file != 47) {
    {
#line 102
    cwd_name = getcwd((char *)((void *)0), (size_t )0);
    }
#line 103
    if (! cwd_name) {
      {
#line 104
      tmp = gettext("getcwd() does not work");
#line 104
      popup_error_win(tmp);
#line 105
      free((void *)in_file);
#line 106
      in_file = (char *)((void *)0);
      }
#line 107
      return ((char *)((void *)0));
    }
    {
#line 110
    tmp___0 = strlen((char const   *)in_file);
#line 110
    tmp___1 = strlen((char const   *)cwd_name);
#line 110
    tmp___2 = malloc((size_t )(sizeof(char ) * (unsigned long )((tmp___0 + tmp___1) + 2U)));
#line 110
    pat = (char *)tmp___2;
    }
#line 111
    if (! pat) {
      {
#line 112
      wuuush(1);
      }
    }
    {
#line 115
    sprintf((char */* __restrict  */)pat, (char const   */* __restrict  */)"%s/%s",
            cwd_name, in_file);
#line 116
    free((void *)cwd_name);
#line 117
    free((void *)in_file);
#line 118
    cwd_name = (char *)((void *)0);
#line 119
    in_file = (char *)((void *)0);
#line 120
    in_file = pat;
    }
  }
  {
#line 123
  in_file = kill_double_slashs(in_file);
  }
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 126
    cwd_name = strstr((char const   *)in_file, "/./");
    }
#line 127
    if (! cwd_name) {
#line 127
      goto while_break;
    }
    {
#line 128
    tmp___3 = strlen((char const   *)cwd_name);
#line 128
    memmove((void *)cwd_name, (void const   *)(cwd_name + 2), tmp___3 - 1U);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 132
    cwd_name = strstr((char const   *)in_file, "/../");
    }
#line 133
    if (! cwd_name) {
#line 133
      goto while_break___0;
    }
    {
#line 134
    *cwd_name = (char)0;
#line 135
    pat = strrchr((char const   *)in_file, '/');
    }
#line 136
    if (! pat) {
      {
#line 137
      tmp___4 = gettext("illegal directoryname");
#line 137
      popup_error_win(tmp___4);
#line 138
      free((void *)in_file);
#line 139
      in_file = (char *)((void *)0);
      }
#line 140
      return ((char *)((void *)0));
    }
    {
#line 142
    tmp___5 = strlen((char const   *)(cwd_name + 1));
#line 142
    memmove((void *)pat, (void const   *)(cwd_name + 3), tmp___5 - 1U);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 145
  return (in_file);
}
}
#line 149 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
void req_free_content_list(content **list ) 
{ 
  content *curr ;
  content *next ;

  {
#line 153
  curr = *list;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! curr) {
#line 154
      goto while_break;
    }
#line 155
    if (curr->name) {
      {
#line 155
      free((void *)curr->name);
      }
    }
    {
#line 156
    next = curr;
#line 157
    curr = curr->next;
#line 158
    free((void *)next);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  *list = (content *)((void *)0);
#line 162
  return;
}
}
#line 165 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
void req_insert_content(content *new , content **data ) 
{ 
  content *curr ;
  content *next ;
  int tmp ;
  int tmp___0 ;

  {
#line 169
  curr = *data;
#line 170
  if (! curr) {
#line 170
    goto _L;
  } else {
    {
#line 170
    tmp___0 = strcmp((char const   *)new->name, (char const   *)curr->name);
    }
#line 170
    if (tmp___0 < 0) {
      _L: /* CIL Label */ 
#line 171
      new->next = curr;
#line 172
      if (curr) {
#line 172
        curr->prev = new;
      }
#line 173
      *data = new;
    } else {
#line 175
      next = curr->next;
      {
#line 176
      while (1) {
        while_continue: /* CIL Label */ ;
#line 176
        if (next) {
          {
#line 176
          tmp = strcmp((char const   *)new->name, (char const   *)next->name);
          }
#line 176
          if (! (tmp > 0)) {
#line 176
            goto while_break;
          }
        } else {
#line 176
          goto while_break;
        }
#line 177
        curr = next;
#line 178
        next = next->next;
      }
      while_break: /* CIL Label */ ;
      }
#line 180
      new->next = next;
#line 181
      if (next) {
#line 181
        next->prev = new;
      }
#line 182
      new->prev = curr;
#line 183
      curr->next = new;
    }
  }
#line 185
  return;
}
}
#line 190 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
int req_read_dir_data(char const   *path , content **dir_data , int *dir_count , content **file_data ,
                      int *file_count , unsigned char hidden , char *old_dir_name ,
                      content **old_dir , unsigned char *dir_found ) 
{ 
  DIR *direc ;
  struct stat st ;
  struct dirent *de ;
  content *new ;
  char *name ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 200
  *dir_count = 0;
#line 201
  *file_count = 0;
#line 202
  *dir_data = (content *)((void *)0);
#line 203
  *dir_found = (unsigned char)0;
#line 204
  if (file_data) {
#line 204
    *file_data = (content *)((void *)0);
  }
  {
#line 206
  direc = opendir(path);
  }
#line 207
  if (! direc) {
#line 207
    return (1);
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 209
    de = readdir(direc);
    }
#line 209
    if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 209
      goto while_break;
    }
    {
#line 211
    tmp___6 = strcmp((char const   *)(de->d_name), ".");
    }
#line 211
    if (tmp___6 != 0) {
      {
#line 211
      tmp___7 = strcmp((char const   *)(de->d_name), "..");
      }
#line 211
      if (tmp___7 != 0) {
#line 211
        if ((int )de->d_name[0] != 46) {
#line 211
          goto _L;
        } else
#line 211
        if (hidden) {
          _L: /* CIL Label */ 
          {
#line 213
          tmp = strlen(path);
#line 213
          tmp___0 = strlen((char const   *)(de->d_name));
#line 213
          tmp___1 = malloc((size_t )(sizeof(char ) * (unsigned long )((tmp + tmp___0) + 2U)));
#line 213
          name = (char *)tmp___1;
          }
#line 214
          if (! name) {
            {
#line 215
            wuuush(1);
            }
          }
          {
#line 217
          sprintf((char */* __restrict  */)name, (char const   */* __restrict  */)"%s/%s",
                  path, de->d_name);
#line 218
          tmp___5 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
          }
#line 218
          if (tmp___5 != -1) {
#line 219
            if ((st.st_mode & 61440U) == 16384U) {
              {
#line 221
              tmp___2 = malloc((size_t )sizeof(content ));
#line 221
              new = (content *)tmp___2;
              }
#line 222
              if (! new) {
                {
#line 223
                wuuush(1);
                }
              }
              {
#line 225
              new->name = copy_char_str(de->d_name);
#line 226
              new->next = (struct _content *)((void *)0);
#line 227
              new->prev = (struct _content *)((void *)0);
              }
#line 228
              if (old_dir_name) {
                {
#line 228
                tmp___3 = strcmp((char const   *)(de->d_name), (char const   *)old_dir_name);
                }
#line 228
                if (tmp___3 == 0) {
#line 229
                  *old_dir = new;
#line 230
                  *dir_found = (unsigned char)1;
                }
              }
              {
#line 232
              req_insert_content(new, dir_data);
#line 233
              (*dir_count) ++;
              }
            } else
#line 234
            if (file_data) {
              {
#line 236
              tmp___4 = malloc((size_t )sizeof(content ));
#line 236
              new = (content *)tmp___4;
              }
#line 237
              if (! new) {
                {
#line 238
                wuuush(1);
                }
              }
              {
#line 240
              new->name = copy_char_str(de->d_name);
#line 241
              new->next = (struct _content *)((void *)0);
#line 242
              new->prev = (struct _content *)((void *)0);
#line 243
              req_insert_content(new, file_data);
#line 244
              (*file_count) ++;
              }
            }
          }
          {
#line 247
          free((void *)name);
#line 248
          name = (char *)((void *)0);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 252
  closedir(direc);
#line 253
  tmp___9 = strcmp(path, "/");
  }
#line 253
  if (tmp___9 != 0) {
    {
#line 255
    tmp___8 = malloc((size_t )sizeof(content ));
#line 255
    new = (content *)tmp___8;
    }
#line 256
    if (! new) {
      {
#line 257
      wuuush(1);
      }
    }
    {
#line 259
    new->name = copy_char_str((char *)"..");
#line 260
    new->next = *dir_data;
    }
#line 261
    if (new->next) {
#line 261
      (new->next)->prev = new;
    }
#line 262
    new->prev = (struct _content *)((void *)0);
#line 263
    *dir_data = new;
#line 264
    (*dir_count) ++;
  }
#line 267
  return (0);
}
}
#line 279 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
void req_draw_stat(WINDOW *win , int ys , int ye , int x , int abs___0 , int rel ,
                   int tot ) 
{ 
  int i ;
  int y1 ;
  int y2 ;
  int yb ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 283
  yb = (ye - ys) + 1;
#line 284
  if (yb >= tot) {
    {
#line 285
    wmove(win, ys, x);
#line 286
    wvline(win, acs_map[(unsigned char )'x'], yb);
    }
#line 287
    return;
  }
#line 289
  ys --;
#line 291
  if (! tot) {
#line 292
    y1 = 0;
#line 293
    y2 = 0;
#line 294
    rel = 0;
  } else {
#line 296
    y1 = (abs___0 * yb) / tot;
#line 297
    y2 = (y1 + (yb * yb) / tot) + 1;
#line 298
    y1 ++;
#line 299
    if (y2 > yb) {
#line 299
      y1 = yb - (y2 - y1);
    }
#line 300
    if (tot <= yb) {
#line 301
      rel = (yb * rel) / tot;
    } else {
#line 303
      rel = y1 + (((yb * yb) / tot) * rel) / yb;
    }
#line 305
    if (rel < y1) {
#line 305
      rel = y1;
    }
#line 306
    if (rel > y2) {
#line 306
      rel = y2;
    }
#line 307
    if (rel < 1) {
#line 307
      rel = 1;
    }
#line 308
    if (rel > yb) {
#line 308
      rel = yb;
    }
  }
#line 311
  i = 1;
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    if (! (i <= yb)) {
#line 311
      goto while_break;
    }
#line 312
    if (i >= y1) {
#line 312
      if (i <= y2) {
        {
#line 312
        tmp = wmove(win, ys + i, x);
        }
#line 312
        if (! (tmp == -1)) {
          {
#line 312
          waddch(win, (chtype const   )acs_map[(unsigned char )'0']);
          }
        }
      } else {
#line 312
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 313
      tmp___0 = wmove(win, ys + i, x);
      }
#line 313
      if (! (tmp___0 == -1)) {
        {
#line 313
        waddch(win, (chtype const   )acs_map[(unsigned char )'x']);
        }
      }
    }
#line 314
    if (i == rel) {
      {
#line 314
      tmp___1 = wmove(win, ys + i, x);
      }
#line 314
      if (! (tmp___1 == -1)) {
        {
#line 314
        waddch(win, (chtype const   )acs_map[(unsigned char )'h']);
        }
      }
    }
#line 311
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 316
  return;
}
}
#line 325 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
void req_draw_mark(WINDOW *win , int y , int xe , char *name , chtype const   ch ) 
{ 
  int i ;
  chtype old_ch ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 330
  old_ch = win->_bkgd;
#line 331
  if (ch == (chtype const   )(1UL << 18)) {
    {
#line 332
    wbkgdset(win, (chtype )(3 << 8));
    }
  } else {
    {
#line 334
    wbkgdset(win, old_ch ^ (unsigned long )ch);
    }
  }
#line 336
  if (name) {
    {
#line 337
    tmp = strlen((char const   *)name);
#line 337
    i = (int )tmp;
    }
#line 338
    if (i > xe) {
#line 338
      i = xe;
    }
    {
#line 339
    tmp___0 = wmove(win, y, 1);
    }
#line 339
    if (! (tmp___0 == -1)) {
      {
#line 339
      waddnstr(win, (char const   *)name, i);
      }
    }
  } else {
#line 341
    i = 0;
  }
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! (i < xe)) {
#line 343
      goto while_break;
    }
    {
#line 343
    waddch(win, (chtype const   )' ');
#line 343
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 344
  wbkgdset(win, old_ch);
  }
#line 345
  return;
}
}
#line 347 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
void req_draw_help(WINDOW *win , int y1 , int y2 , unsigned char hid ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 349
  wmove(win, y1 - 1, 1);
  }
#line 350
  if (y2) {
    {
#line 351
    tmp = gettext("F1: New File * ");
#line 351
    waddnstr(win, (char const   *)tmp, -1);
    }
  } else {
    {
#line 353
    tmp___0 = gettext("F1: OK * ");
#line 353
    waddnstr(win, (char const   *)tmp___0, -1);
    }
  }
  {
#line 356
  tmp___1 = gettext("F3: Home * F4: hidden ");
#line 356
  waddnstr(win, (char const   *)tmp___1, -1);
  }
#line 357
  if (hid) {
    {
#line 357
    tmp___2 = gettext("off");
#line 357
    waddnstr(win, (char const   *)tmp___2, -1);
    }
  } else {
    {
#line 358
    tmp___3 = gettext("on");
#line 358
    waddnstr(win, (char const   *)tmp___3, -1);
    }
  }
  {
#line 359
  tmp___4 = gettext(" * F7: MKdir * F12: Abort   ");
#line 359
  waddnstr(win, (char const   *)tmp___4, -1);
  }
#line 360
  return;
}
}
#line 371 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
void req_draw_layout(WINDOW *win , int y1 , int y2 , int x , unsigned char hid , char const   *description ) 
{ 
  int i ;
  chtype old_ch ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 377
  wclear(win);
#line 378
  wmove(win, 0, 0);
#line 378
  waddch(win, (chtype const   )acs_map[(unsigned char )'l']);
#line 378
  whline(win, acs_map[(unsigned char )'q'], x - 1);
#line 379
  wmove(win, 0, x);
#line 379
  waddch(win, (chtype const   )acs_map[(unsigned char )'k']);
#line 381
  i = 1;
  }
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
#line 381
    if (! (i < y1)) {
#line 381
      goto while_break;
    }
    {
#line 382
    wmove(win, i, 0);
#line 382
    waddch(win, (chtype const   )acs_map[(unsigned char )'x']);
#line 383
    wmove(win, i, x);
#line 383
    waddch(win, (chtype const   )acs_map[(unsigned char )'x']);
#line 381
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 386
  wmove(win, y1, 0);
#line 386
  waddch(win, (chtype const   )acs_map[(unsigned char )'m']);
#line 386
  whline(win, acs_map[(unsigned char )'q'], x - 1);
#line 387
  wmove(win, y1, x);
#line 387
  waddch(win, (chtype const   )acs_map[(unsigned char )'j']);
#line 388
  wmove(win, y1 - 2, 0);
#line 388
  waddch(win, (chtype const   )acs_map[(unsigned char )'t']);
#line 388
  whline(win, acs_map[(unsigned char )'q'], x - 1);
#line 389
  wmove(win, y1 - 2, x);
#line 389
  waddch(win, (chtype const   )acs_map[(unsigned char )'u']);
  }
#line 390
  if (y2) {
    {
#line 391
    wmove(win, y2, 0);
#line 391
    waddch(win, (chtype const   )acs_map[(unsigned char )'t']);
#line 391
    whline(win, acs_map[(unsigned char )'q'], x - 1);
#line 392
    wmove(win, y2, x);
#line 392
    waddch(win, (chtype const   )acs_map[(unsigned char )'u']);
    }
  }
  {
#line 394
  req_draw_help(win, y1, y2, hid);
  }
#line 396
  if (description) {
    {
#line 397
    tmp = strlen(description);
#line 397
    i = (int )tmp;
    }
#line 398
    if (i > x - 3) {
#line 398
      i = x - 3;
    }
    {
#line 399
    i = (x - 3) - i;
#line 400
    old_ch = win->_bkgd;
#line 401
    wbkgdset(win, (unsigned long )(2 << 8) | (1UL << 21));
#line 402
    tmp___0 = wmove(win, y1 - 2, (i >> 1) + 2);
    }
#line 402
    if (! (tmp___0 == -1)) {
      {
#line 402
      waddnstr(win, description, x - 3);
      }
    }
    {
#line 403
    wbkgdset(win, old_ch);
    }
  }
#line 405
  return;
}
}
#line 414 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
void req_dir_fill(WINDOW *win , int ys , int ye , int x , content *list ) 
{ 
  content *curr ;
  int y ;
  int len ;
  size_t tmp ;

  {
#line 419
  y = ys;
#line 420
  curr = list;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (y <= ye) {
#line 421
      if (! curr) {
#line 421
        goto while_break;
      }
    } else {
#line 421
      goto while_break;
    }
    {
#line 422
    wmove(win, y, 1);
#line 423
    tmp = strlen((char const   *)curr->name);
#line 423
    len = (int )tmp;
    }
#line 424
    if (len > x) {
#line 424
      len = x;
    }
    {
#line 425
    waddnstr(win, (char const   *)curr->name, len);
    }
    {
#line 426
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 426
      if (! (len < x)) {
#line 426
        goto while_break___0;
      }
      {
#line 426
      waddch(win, (chtype const   )' ');
#line 426
      len ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 427
    y ++;
#line 428
    curr = curr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 430
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 430
    if (! (y <= ye)) {
#line 430
      goto while_break___1;
    }
    {
#line 431
    wmove(win, y, 1);
#line 432
    whline(win, (chtype )' ', x);
#line 433
    y ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 435
  return;
}
}
#line 437 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
void req_refresh(WINDOW *win , int arg1 , int arg2 ) 
{ 


  {
#line 439
  req_refresh_needed = (unsigned char)1;
#line 440
  return;
}
}
#line 442 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
char *req_finish_path(char *path ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 444
  tmp = file_glob_in_name(path);
#line 444
  path = req_correct_dir(tmp);
  }
#line 445
  if (! path) {
    {
#line 446
    tmp___0 = getenv("HOME");
    }
#line 446
    if (! tmp___0) {
#line 446
      return ((char *)((void *)0));
    }
    {
#line 447
    tmp___1 = getenv("HOME");
#line 447
    path = copy_char_str(tmp___1);
    }
  }
#line 450
  return (path);
}
}
#line 453 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
void req_draw_dirname(WINDOW *win , int y , int len , char *path ) 
{ 
  chtype old_ch ;
  char *own_path ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 458
  wmove(win, y, 1);
#line 459
  whline(win, acs_map[(unsigned char )'q'], len);
  }
#line 460
  if (! path) {
#line 460
    return;
  }
  {
#line 461
  tmp = copy_char_str(path);
#line 461
  own_path = file_glob_out_name(tmp);
#line 462
  old_ch = win->_bkgd;
#line 463
  wbkgdset(win, (chtype )(7 << 8));
#line 464
  tmp___0 = wmove(win, y, 1);
  }
#line 464
  if (! (tmp___0 == -1)) {
    {
#line 464
    waddch(win, (chtype const   )'<');
    }
  }
  {
#line 465
  tmp___1 = wmove(win, y, 3);
  }
#line 465
  if (! (tmp___1 == -1)) {
    {
#line 465
    waddnstr(win, (char const   *)own_path, len - 2);
    }
  }
  {
#line 466
  wbkgdset(win, old_ch);
#line 467
  free((void *)own_path);
  }
#line 468
  return;
}
}
#line 470 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
void req_toggle_hidden(WINDOW *win , int y1 , int y2 ) 
{ 


  {
#line 472
  if (config_req_hidden) {
#line 472
    config_req_hidden = (unsigned char)0;
  } else {
#line 473
    config_req_hidden = (unsigned char)1;
  }
  {
#line 475
  req_draw_help(win, y1, y2, config_req_hidden);
#line 476
  wrefresh(win);
  }
#line 477
  return;
}
}
#line 479 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
void req_handle_key_up(WINDOW *win , int *pos_abs , int *pos_rel , int ys , int ye ,
                       int xe , int tot_files , content **cl_abs , content **cl_rel ) 
{ 
  int i ;

  {
#line 485
  if ((*cl_rel)->prev) {
#line 487
    if (*pos_rel > 1) {
      {
#line 489
      req_draw_mark(win, (*pos_rel + ys) - 1, xe, (*cl_rel)->name, (chtype const   )0UL);
#line 490
      *cl_rel = (*cl_rel)->prev;
#line 491
      (*pos_rel) --;
      }
    } else {
#line 494
      (*pos_abs) --;
#line 495
      *cl_abs = (*cl_abs)->prev;
#line 496
      *cl_rel = *cl_abs;
#line 498
      i = 0;
      {
#line 498
      while (1) {
        while_continue: /* CIL Label */ ;
#line 498
        if (! (i <= (ye - ys) >> 1)) {
#line 498
          goto while_break;
        }
#line 499
        if (! (*cl_abs)->prev) {
#line 499
          goto while_break;
        }
#line 500
        (*pos_abs) --;
#line 501
        *cl_abs = (*cl_abs)->prev;
#line 502
        (*pos_rel) ++;
#line 498
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 504
      req_dir_fill(win, ys, ye, xe, *cl_abs);
      }
    }
    {
#line 506
    req_draw_mark(win, (*pos_rel + ys) - 1, xe, (*cl_rel)->name, (chtype const   )(1UL << 18));
#line 507
    req_draw_stat(win, ys, ye, xe + 1, *pos_abs, *pos_rel, tot_files);
#line 508
    wrefresh(win);
    }
  }
#line 510
  return;
}
}
#line 512 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
void req_handle_key_down(WINDOW *win , int *pos_abs , int *pos_rel , int ys , int ye ,
                         int xe , int tot_files , content **cl_abs , content **cl_rel ) 
{ 
  int i ;
  content *counter ;

  {
#line 519
  if ((*cl_rel)->next) {
#line 521
    if (*pos_rel <= ye - ys) {
      {
#line 523
      req_draw_mark(win, (*pos_rel + ys) - 1, xe, (*cl_rel)->name, (chtype const   )0UL);
#line 524
      *cl_rel = (*cl_rel)->next;
#line 525
      (*pos_rel) ++;
      }
    } else {
#line 528
      (*pos_abs) ++;
#line 529
      *cl_abs = (*cl_abs)->next;
#line 530
      *cl_rel = (*cl_rel)->next;
#line 532
      counter = *cl_rel;
#line 533
      i = 0;
      {
#line 533
      while (1) {
        while_continue: /* CIL Label */ ;
#line 533
        if (! (i <= (ye - ys) >> 1)) {
#line 533
          goto while_break;
        }
#line 534
        if (! counter->next) {
#line 534
          goto while_break;
        }
#line 535
        (*pos_abs) ++;
#line 536
        *cl_abs = (*cl_abs)->next;
#line 537
        (*pos_rel) --;
#line 538
        counter = counter->next;
#line 533
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 540
      req_dir_fill(win, ys, ye, xe, *cl_abs);
      }
    }
    {
#line 542
    req_draw_mark(win, (*pos_rel + ys) - 1, xe, (*cl_rel)->name, (chtype const   )(1UL << 18));
#line 543
    req_draw_stat(win, ys, ye, xe + 1, *pos_abs, *pos_rel, tot_files);
#line 544
    wrefresh(win);
    }
  }
#line 546
  return;
}
}
#line 548 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
void req_handle_key_home(WINDOW *win , int *pos_abs , int *pos_rel , int ys , int ye ,
                         int xe , int tot_files , content **cl_abs , content **cl_rel ,
                         content *cl_first ) 
{ 


  {
#line 552
  if ((*cl_rel)->prev) {
#line 554
    if (*pos_rel > 1) {
      {
#line 556
      req_draw_mark(win, (*pos_rel + ys) - 1, xe, (*cl_rel)->name, (chtype const   )0UL);
#line 557
      *cl_rel = *cl_abs;
#line 558
      *pos_rel = 1;
      }
    } else {
      {
#line 561
      *cl_abs = cl_first;
#line 562
      *cl_rel = cl_first;
#line 563
      *pos_rel = 1;
#line 564
      *pos_abs = 1;
#line 565
      req_dir_fill(win, ys, ye, xe, *cl_abs);
      }
    }
    {
#line 567
    req_draw_mark(win, (*pos_rel + ys) - 1, xe, (*cl_rel)->name, (chtype const   )(1UL << 18));
#line 568
    req_draw_stat(win, ys, ye, xe + 1, *pos_abs, *pos_rel, tot_files);
#line 569
    wrefresh(win);
    }
  }
#line 571
  return;
}
}
#line 573 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
void req_handle_key_end(WINDOW *win , int *pos_abs , int *pos_rel , int ys , int ye ,
                        int xe , int tot_files , content **cl_abs , content **cl_rel ) 
{ 


  {
#line 577
  if ((*cl_rel)->next) {
#line 579
    if (*pos_rel <= ye - ys) {
      {
#line 581
      req_draw_mark(win, (*pos_rel + ys) - 1, xe, (*cl_rel)->name, (chtype const   )0UL);
      }
      {
#line 582
      while (1) {
        while_continue: /* CIL Label */ ;
#line 582
        if ((*cl_rel)->next) {
#line 582
          if (! (*pos_rel <= ye - ys)) {
#line 582
            goto while_break;
          }
        } else {
#line 582
          goto while_break;
        }
#line 583
        (*pos_rel) ++;
#line 584
        *cl_rel = (*cl_rel)->next;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 588
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 588
        if (! (*cl_rel)->next) {
#line 588
          goto while_break___0;
        }
#line 589
        (*pos_abs) ++;
#line 590
        *cl_abs = (*cl_abs)->next;
#line 591
        *cl_rel = (*cl_rel)->next;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 593
      req_dir_fill(win, ys, ye, xe, *cl_abs);
      }
    }
    {
#line 595
    req_draw_mark(win, (*pos_rel + ys) - 1, xe, (*cl_rel)->name, (chtype const   )(1UL << 18));
#line 596
    req_draw_stat(win, ys, ye, xe + 1, *pos_abs, *pos_rel, tot_files);
#line 597
    wrefresh(win);
    }
  }
#line 599
  return;
}
}
#line 601 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
void req_handle_key_ppage(WINDOW *win , int *pos_abs , int *pos_rel , int ys , int ye ,
                          int xe , int tot_files , content **cl_abs , content **cl_rel ) 
{ 
  int i ;
  unsigned char refill_flag ;

  {
#line 608
  if ((*cl_rel)->prev) {
    {
#line 610
    req_draw_mark(win, (*pos_rel + ys) - 1, xe, (*cl_rel)->name, (chtype const   )0UL);
#line 611
    refill_flag = (unsigned char)0;
#line 612
    i = 0;
    }
    {
#line 612
    while (1) {
      while_continue: /* CIL Label */ ;
#line 612
      if (! (i < ye - ys)) {
#line 612
        goto while_break;
      }
#line 613
      if ((*cl_abs)->prev) {
#line 615
        refill_flag = (unsigned char)1;
#line 616
        (*pos_abs) --;
#line 617
        *cl_abs = (*cl_abs)->prev;
#line 618
        *cl_rel = (*cl_rel)->prev;
      } else
#line 619
      if ((*cl_rel)->prev) {
#line 621
        (*pos_rel) --;
#line 622
        *cl_rel = (*cl_rel)->prev;
      } else {
#line 624
        goto while_break;
      }
#line 612
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 627
    if (refill_flag) {
      {
#line 628
      req_dir_fill(win, ys, ye, xe, *cl_abs);
      }
    }
    {
#line 630
    req_draw_mark(win, (*pos_rel + ys) - 1, xe, (*cl_rel)->name, (chtype const   )(1UL << 18));
#line 631
    req_draw_stat(win, ys, ye, xe + 1, *pos_abs, *pos_rel, tot_files);
#line 632
    wrefresh(win);
    }
  }
#line 634
  return;
}
}
#line 636 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
void req_handle_key_npage(WINDOW *win , int *pos_abs , int *pos_rel , int ys , int ye ,
                          int xe , int tot_files , content **cl_abs , content **cl_rel ) 
{ 
  int i ;
  unsigned char refill_flag ;

  {
#line 643
  if ((*cl_rel)->next) {
    {
#line 645
    req_draw_mark(win, (*pos_rel + ys) - 1, xe, (*cl_rel)->name, (chtype const   )0UL);
#line 646
    refill_flag = (unsigned char)0;
#line 647
    i = 0;
    }
    {
#line 647
    while (1) {
      while_continue: /* CIL Label */ ;
#line 647
      if (! (i < ye - ys)) {
#line 647
        goto while_break;
      }
#line 648
      if (*pos_abs + (ye - ys) < tot_files) {
#line 650
        refill_flag = (unsigned char)1;
#line 651
        (*pos_abs) ++;
#line 652
        *cl_abs = (*cl_abs)->next;
#line 653
        *cl_rel = (*cl_rel)->next;
      } else
#line 654
      if ((*cl_rel)->next) {
#line 656
        (*pos_rel) ++;
#line 657
        *cl_rel = (*cl_rel)->next;
      } else {
#line 659
        goto while_break;
      }
#line 647
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 662
    if (refill_flag) {
      {
#line 663
      req_dir_fill(win, ys, ye, xe, *cl_abs);
      }
    }
    {
#line 665
    req_draw_mark(win, (*pos_rel + ys) - 1, xe, (*cl_rel)->name, (chtype const   )(1UL << 18));
#line 666
    req_draw_stat(win, ys, ye, xe + 1, *pos_abs, *pos_rel, tot_files);
#line 667
    wrefresh(win);
    }
  }
#line 669
  return;
}
}
#line 671 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
char *req_curs_dir(char *path , char const   *description ) 
{ 
  int maxy ;
  int maxx ;
  WINDOW *requester ;
  content *dir_list ;
  content *dir_abs ;
  content *dir_rel ;
  content *dir_old ;
  int tot_dirs ;
  int pos_abs ;
  int pos_rel ;
  unsigned char dir_found ;
  char *old_name ;
  char *new_path ;
  int dummy ;
  DIR *direc ;
  int inp_char ;
  int exit_code ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;

  {
  {
#line 684
  direc = opendir((char const   *)path);
  }
#line 685
  if (! direc) {
#line 686
    if (path) {
      {
#line 686
      free((void *)path);
      }
    }
    {
#line 687
    path = req_finish_path((char *)((void *)0));
    }
  } else {
    {
#line 689
    closedir(direc);
    }
  }
#line 692
  if (stdscr) {
#line 692
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 692
    maxy = -1;
  }
#line 692
  if (stdscr) {
#line 692
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 692
    maxx = -1;
  }
  {
#line 693
  requester = c_newwin(maxy, maxx, 0, 0, (void *)(& req_refresh), 0, 0);
#line 694
  req_refresh_needed = (unsigned char)1;
#line 696
  dir_list = (content *)((void *)0);
#line 697
  old_name = (char *)((void *)0);
#line 698
  tmp___0 = req_read_dir_data((char const   *)path, & dir_list, & tot_dirs, (content **)((void *)0),
                              & dummy, config_req_hidden, (char *)((void *)0), & dir_old,
                              & dir_found);
  }
#line 698
  if (tmp___0) {
    {
#line 700
    tmp = gettext("reading dir failed");
#line 700
    popup_error_win(tmp);
    }
#line 701
    return ((char *)((void *)0));
  }
#line 703
  dir_abs = dir_list;
#line 704
  dir_rel = dir_list;
#line 705
  pos_abs = 1;
#line 706
  pos_rel = 1;
#line 707
  exit_code = 0;
  {
#line 709
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 710
    halfdelay(10);
    }
#line 711
    if (req_refresh_needed) {
#line 712
      if (stdscr) {
#line 712
        maxy = (int )stdscr->_maxy + 1;
      } else {
#line 712
        maxy = -1;
      }
#line 712
      if (stdscr) {
#line 712
        maxx = (int )stdscr->_maxx + 1;
      } else {
#line 712
        maxx = -1;
      }
      {
#line 713
      wresize(requester, maxy, maxx);
#line 714
      mvwin(requester, 0, 0);
      }
#line 715
      if (pos_rel > maxy - 4) {
#line 716
        pos_rel = 1;
#line 717
        dir_rel = dir_abs;
      }
      {
#line 719
      scrollok(requester, (_Bool)0);
#line 720
      keypad(requester, (_Bool)1);
#line 721
      wbkgd(requester, (chtype )(1 << 8));
#line 722
      req_draw_layout(requester, maxy - 1, 0, maxx - 1, config_req_hidden, description);
#line 724
      req_dir_fill(requester, 1, maxy - 4, maxx - 2, dir_abs);
#line 725
      req_draw_mark(requester, pos_rel, maxx - 2, dir_rel->name, (chtype const   )(1UL << 18));
#line 726
      req_draw_stat(requester, 1, maxy - 4, maxx - 1, pos_abs, pos_rel, tot_dirs);
#line 727
      req_draw_dirname(requester, 0, maxx - 2, path);
#line 728
      wrefresh(requester);
#line 729
      req_refresh_needed = (unsigned char)0;
      }
    }
    {
#line 732
    inp_char = wgetch(requester);
#line 733
    dummy = 0;
#line 734
    new_path = (char *)((void *)0);
    }
    {
#line 738
    if (inp_char == 13) {
#line 738
      goto case_13;
    }
#line 738
    if (inp_char == 10) {
#line 738
      goto case_13;
    }
#line 738
    if (inp_char == 343) {
#line 738
      goto case_13;
    }
#line 769
    if (inp_char == 49) {
#line 769
      goto case_49;
    }
#line 769
    if (inp_char == 265) {
#line 769
      goto case_49;
    }
#line 775
    if (inp_char == 51) {
#line 775
      goto case_51;
    }
#line 775
    if (inp_char == 267) {
#line 775
      goto case_51;
    }
#line 782
    if (inp_char == 52) {
#line 782
      goto case_52;
    }
#line 782
    if (inp_char == 268) {
#line 782
      goto case_52;
    }
#line 790
    if (inp_char == 55) {
#line 790
      goto case_55;
    }
#line 790
    if (inp_char == 271) {
#line 790
      goto case_55;
    }
#line 820
    if (inp_char == 39) {
#line 820
      goto case_39;
    }
#line 820
    if (inp_char == 81) {
#line 820
      goto case_39;
    }
#line 820
    if (inp_char == 113) {
#line 820
      goto case_39;
    }
#line 820
    if (inp_char == 27) {
#line 820
      goto case_39;
    }
#line 820
    if (inp_char == 276) {
#line 820
      goto case_39;
    }
#line 825
    if (inp_char == 12) {
#line 825
      goto case_12;
    }
#line 830
    if (inp_char == 259) {
#line 830
      goto case_259;
    }
#line 836
    if (inp_char == 258) {
#line 836
      goto case_258;
    }
#line 843
    if (inp_char == 362) {
#line 843
      goto case_362;
    }
#line 843
    if (inp_char == 262) {
#line 843
      goto case_362;
    }
#line 850
    if (inp_char == 385) {
#line 850
      goto case_385;
    }
#line 850
    if (inp_char == 360) {
#line 850
      goto case_385;
    }
#line 856
    if (inp_char == 339) {
#line 856
      goto case_339;
    }
#line 862
    if (inp_char == 338) {
#line 862
      goto case_338;
    }
#line 735
    goto switch_break;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_343: /* CIL Label */ 
    {
#line 740
    tmp___5 = strcmp((char const   *)dir_rel->name, "..");
    }
#line 740
    if (tmp___5 != 0) {
      {
#line 741
      tmp___1 = strlen((char const   *)path);
#line 741
      tmp___2 = strlen((char const   *)dir_rel->name);
#line 741
      tmp___3 = malloc((size_t )(sizeof(char ) * (unsigned long )((tmp___1 + tmp___2) + 2U)));
#line 741
      new_path = (char *)tmp___3;
      }
#line 742
      if (! new_path) {
        {
#line 743
        wuuush(1);
        }
      }
      {
#line 745
      tmp___4 = strcmp((char const   *)path, "/");
      }
#line 745
      if (tmp___4 != 0) {
        {
#line 746
        sprintf((char */* __restrict  */)new_path, (char const   */* __restrict  */)"%s/%s",
                path, dir_rel->name);
        }
      } else {
        {
#line 748
        sprintf((char */* __restrict  */)new_path, (char const   */* __restrict  */)"/%s",
                dir_rel->name);
        }
      }
    } else {
      {
#line 751
      old_name = strrchr((char const   *)path, '/');
      }
#line 752
      if (! old_name) {
#line 753
        new_path = (char *)((void *)0);
      } else {
#line 755
        *old_name = (char)0;
#line 756
        if (! *path) {
          {
#line 757
          new_path = copy_char_str((char *)"/");
          }
        } else {
          {
#line 759
          new_path = copy_char_str(path);
          }
        }
        {
#line 761
        *old_name = (char )'/';
#line 762
        old_name = copy_char_str(old_name + 1);
        }
      }
    }
#line 765
    dummy = 1;
#line 766
    goto switch_break;
    case_49: /* CIL Label */ 
    case_265: /* CIL Label */ 
#line 771
    exit_code = 2;
#line 772
    goto switch_break;
    case_51: /* CIL Label */ 
    case_267: /* CIL Label */ 
    {
#line 777
    tmp___6 = getenv("HOME");
#line 777
    new_path = copy_char_str(tmp___6);
#line 778
    dummy = 1;
    }
#line 779
    goto switch_break;
    case_52: /* CIL Label */ 
    case_268: /* CIL Label */ 
    {
#line 784
    req_toggle_hidden(requester, maxy - 1, 0);
#line 785
    new_path = copy_char_str(path);
#line 786
    dummy = 1;
    }
#line 787
    goto switch_break;
    case_55: /* CIL Label */ 
    case_271: /* CIL Label */ 
    {
#line 792
    tmp___7 = gettext("enter new directory name");
#line 792
    old_name = input_line(10, (char *)((void *)0), tmp___7, (unsigned char)0);
    }
#line 793
    if (old_name) {
      {
#line 794
      tmp___8 = strlen((char const   *)path);
#line 794
      tmp___9 = strlen((char const   *)old_name);
#line 794
      tmp___10 = malloc((size_t )(sizeof(char ) * (unsigned long )((tmp___8 + tmp___9) + 2U)));
#line 794
      new_path = (char *)tmp___10;
      }
#line 795
      if (! new_path) {
        {
#line 796
        wuuush(1);
        }
      }
      {
#line 798
      tmp___11 = strcmp((char const   *)path, "/");
      }
#line 798
      if (tmp___11 != 0) {
        {
#line 799
        sprintf((char */* __restrict  */)new_path, (char const   */* __restrict  */)"%s/%s",
                path, old_name);
        }
      } else {
        {
#line 801
        sprintf((char */* __restrict  */)new_path, (char const   */* __restrict  */)"/%s",
                old_name);
        }
      }
      {
#line 803
      free((void *)old_name);
#line 804
      old_name = (char *)((void *)0);
#line 805
      tmp___13 = mkdir((char const   *)new_path, (__mode_t )511);
      }
#line 805
      if (tmp___13) {
        {
#line 806
        tmp___12 = gettext("could not create directory");
#line 806
        popup_error_win(tmp___12);
#line 807
        free((void *)new_path);
#line 808
        new_path = (char *)((void *)0);
        }
      } else {
#line 810
        dummy = 1;
      }
    }
#line 813
    req_refresh_needed = (unsigned char)1;
#line 814
    goto switch_break;
    case_39: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_276: /* CIL Label */ 
#line 822
    exit_code = 1;
#line 823
    goto switch_break;
    case_12: /* CIL Label */ 
#line 827
    req_refresh_needed = (unsigned char)1;
#line 828
    goto switch_break;
    case_259: /* CIL Label */ 
    {
#line 832
    req_handle_key_up(requester, & pos_abs, & pos_rel, 1, maxy - 4, maxx - 2, tot_dirs,
                      & dir_abs, & dir_rel);
    }
#line 834
    goto switch_break;
    case_258: /* CIL Label */ 
    {
#line 838
    req_handle_key_down(requester, & pos_abs, & pos_rel, 1, maxy - 4, maxx - 2, tot_dirs,
                        & dir_abs, & dir_rel);
    }
#line 840
    goto switch_break;
    case_362: /* CIL Label */ 
    case_262: /* CIL Label */ 
    {
#line 845
    req_handle_key_home(requester, & pos_abs, & pos_rel, 1, maxy - 4, maxx - 2, tot_dirs,
                        & dir_abs, & dir_rel, dir_list);
    }
#line 847
    goto switch_break;
    case_385: /* CIL Label */ 
    case_360: /* CIL Label */ 
    {
#line 852
    req_handle_key_end(requester, & pos_abs, & pos_rel, 1, maxy - 4, maxx - 2, tot_dirs,
                       & dir_abs, & dir_rel);
    }
#line 854
    goto switch_break;
    case_339: /* CIL Label */ 
    {
#line 858
    req_handle_key_ppage(requester, & pos_abs, & pos_rel, 1, maxy - 4, maxx - 2, tot_dirs,
                         & dir_abs, & dir_rel);
    }
#line 860
    goto switch_break;
    case_338: /* CIL Label */ 
    {
#line 864
    req_handle_key_npage(requester, & pos_abs, & pos_rel, 1, maxy - 4, maxx - 2, tot_dirs,
                         & dir_abs, & dir_rel);
    }
#line 866
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 868
    if (dummy) {
#line 870
      if (new_path) {
        {
#line 870
        tmp___17 = access((char const   *)new_path, 1);
        }
#line 870
        if (tmp___17) {
          {
#line 911
          tmp___16 = gettext("accessing directory failed");
#line 911
          popup_error_win(tmp___16);
#line 912
          req_refresh_needed = (unsigned char)1;
          }
        } else {
          {
#line 872
          free((void *)path);
#line 873
          path = new_path;
#line 874
          new_path = (char *)((void *)0);
#line 875
          req_free_content_list(& dir_list);
#line 876
          dir_list = (content *)((void *)0);
#line 877
          tmp___15 = req_read_dir_data((char const   *)path, & dir_list, & tot_dirs,
                                       (content **)((void *)0), & dummy, config_req_hidden,
                                       old_name, & dir_old, & dir_found);
          }
#line 877
          if (tmp___15) {
            {
#line 880
            tmp___14 = gettext("reading dir failed");
#line 880
            popup_error_win(tmp___14);
#line 881
            exit_code = 1;
            }
          }
#line 883
          dir_abs = dir_list;
#line 884
          dir_rel = dir_list;
#line 885
          pos_abs = 1;
#line 886
          pos_rel = 1;
#line 887
          if (dir_found) {
            {
#line 888
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 888
              if (dir_abs) {
#line 888
                if (! ((unsigned long )dir_abs != (unsigned long )dir_old)) {
#line 888
                  goto while_break___0;
                }
              } else {
#line 888
                goto while_break___0;
              }
#line 889
              pos_abs ++;
#line 890
              dir_abs = dir_abs->next;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 892
            if (! dir_abs) {
#line 893
              dir_abs = dir_list;
#line 894
              pos_abs = 1;
            } else {
#line 896
              dir_rel = dir_abs;
#line 897
              dummy = 0;
              {
#line 897
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 897
                if (! (dummy <= (maxy - 5) >> 1)) {
#line 897
                  goto while_break___1;
                }
#line 898
                if (! dir_abs->prev) {
#line 898
                  goto while_break___1;
                }
#line 899
                pos_abs --;
#line 900
                dir_abs = dir_abs->prev;
#line 901
                pos_rel ++;
#line 897
                dummy ++;
              }
              while_break___1: /* CIL Label */ ;
              }
            }
          }
          {
#line 905
          req_dir_fill(requester, 1, maxy - 4, maxx - 2, dir_abs);
#line 906
          req_draw_mark(requester, pos_rel, maxx - 2, dir_rel->name, (chtype const   )(1UL << 18));
#line 907
          req_draw_stat(requester, 1, maxy - 4, maxx - 1, pos_abs, pos_rel, tot_dirs);
#line 908
          req_draw_dirname(requester, 0, maxx - 2, path);
#line 909
          wrefresh(requester);
          }
        }
      } else {
        {
#line 911
        tmp___16 = gettext("accessing directory failed");
#line 911
        popup_error_win(tmp___16);
#line 912
        req_refresh_needed = (unsigned char)1;
        }
      }
#line 914
      if (old_name) {
        {
#line 915
        free((void *)old_name);
#line 916
        old_name = (char *)((void *)0);
        }
      }
#line 918
      dummy = 0;
    }
#line 921
    if (exit_code) {
#line 921
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 925
  if (exit_code == 1) {
#line 925
    goto case_1;
  }
#line 929
  if (exit_code == 2) {
#line 929
    goto case_2;
  }
#line 924
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 926
  if (path) {
    {
#line 926
    free((void *)path);
    }
  }
#line 927
  path = (char *)((void *)0);
#line 928
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 930
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 933
  req_free_content_list(& dir_list);
  }
#line 934
  if (old_name) {
    {
#line 935
    free((void *)old_name);
#line 936
    old_name = (char *)((void *)0);
    }
  }
  {
#line 939
  c_delwin(requester);
  }
#line 941
  return (path);
}
}
#line 944 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
char *req_curs_file(char *path , char const   *description ) 
{ 
  int maxy ;
  int maxx ;
  WINDOW *requester ;
  content *dir_list[2] ;
  content *dir_abs[2] ;
  content *dir_rel[2] ;
  content *dir_old ;
  int tot_dirs[2] ;
  int pos_abs[2] ;
  int pos_rel[2] ;
  unsigned char dir_found ;
  char *old_name ;
  char *new_path ;
  int dummy ;
  DIR *direc ;
  int inp_char ;
  int exit_code ;
  int act_side ;
  int ys[2] ;
  int ye[2] ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  void *tmp___22 ;
  int tmp___23 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;

  {
  {
#line 959
  direc = opendir((char const   *)path);
  }
#line 960
  if (! direc) {
#line 960
    if (path) {
      {
#line 961
      old_name = strrchr((char const   *)path, '/');
      }
#line 962
      if (old_name) {
        {
#line 963
        *old_name = (char)0;
#line 964
        direc = opendir((char const   *)path);
        }
      }
    }
  }
#line 967
  if (! direc) {
#line 968
    if (path) {
      {
#line 968
      free((void *)path);
      }
    }
    {
#line 969
    path = req_finish_path((char *)((void *)0));
    }
  } else {
    {
#line 971
    closedir(direc);
    }
  }
#line 974
  if (stdscr) {
#line 974
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 974
    maxy = -1;
  }
#line 974
  if (stdscr) {
#line 974
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 974
    maxx = -1;
  }
  {
#line 975
  requester = c_newwin(maxy, maxx, 0, 0, (void *)(& req_refresh), 0, 0);
#line 976
  req_refresh_needed = (unsigned char)1;
#line 978
  dir_list[0] = (content *)((void *)0);
#line 979
  dir_list[1] = (content *)((void *)0);
#line 980
  old_name = (char *)((void *)0);
#line 981
  tmp___0 = req_read_dir_data((char const   *)path, & dir_list[0], & tot_dirs[0],
                              & dir_list[1], & tot_dirs[1], config_req_hidden, (char *)((void *)0),
                              & dir_old, & dir_found);
  }
#line 981
  if (tmp___0) {
    {
#line 984
    tmp = gettext("reading dir failed");
#line 984
    popup_error_win(tmp);
    }
#line 985
    return ((char *)((void *)0));
  }
#line 988
  act_side = 0;
#line 989
  dir_abs[0] = dir_list[0];
#line 990
  dir_abs[1] = dir_list[1];
#line 991
  dir_rel[0] = dir_list[0];
#line 992
  dir_rel[1] = dir_list[1];
#line 993
  pos_abs[0] = 1;
#line 994
  pos_abs[1] = 1;
#line 995
  pos_rel[0] = 1;
#line 996
  pos_rel[1] = 1;
#line 997
  exit_code = 0;
  {
#line 999
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1000
    halfdelay(10);
    }
#line 1001
    if (req_refresh_needed) {
#line 1002
      if (stdscr) {
#line 1002
        maxy = (int )stdscr->_maxy + 1;
      } else {
#line 1002
        maxy = -1;
      }
#line 1002
      if (stdscr) {
#line 1002
        maxx = (int )stdscr->_maxx + 1;
      } else {
#line 1002
        maxx = -1;
      }
      {
#line 1003
      wresize(requester, maxy, maxx);
#line 1004
      mvwin(requester, 0, 0);
#line 1005
      ys[0] = 1;
#line 1006
      ys[1] = (maxy - 2) >> 1;
#line 1007
      ye[0] = ys[1] - 2;
#line 1008
      ye[1] = maxy - 4;
#line 1009
      scrollok(requester, (_Bool)0);
      }
#line 1010
      if (pos_rel[0] > ye[0]) {
#line 1011
        pos_rel[0] = 1;
#line 1012
        dir_rel[0] = dir_abs[0];
      }
#line 1014
      if (pos_rel[1] > (ye[1] - ys[1]) + 1) {
#line 1015
        pos_rel[1] = 1;
#line 1016
        dir_rel[1] = dir_abs[1];
      }
      {
#line 1018
      keypad(requester, (_Bool)1);
#line 1019
      wbkgd(requester, (chtype )(1 << 8));
#line 1020
      req_draw_layout(requester, maxy - 1, ye[0] + 1, maxx - 1, config_req_hidden,
                      description);
#line 1022
      req_dir_fill(requester, ys[0], ye[0], maxx - 2, dir_abs[0]);
#line 1023
      req_dir_fill(requester, ys[1], ye[1], maxx - 2, dir_abs[1]);
#line 1024
      req_draw_mark(requester, pos_rel[act_side] + (ys[act_side] - 1), maxx - 2, (dir_rel[act_side])->name,
                    (chtype const   )(1UL << 18));
#line 1026
      req_draw_stat(requester, ys[0], ye[0], maxx - 1, pos_abs[0], pos_rel[0], tot_dirs[0]);
#line 1028
      req_draw_stat(requester, ys[1], ye[1], maxx - 1, pos_abs[1], pos_rel[1], tot_dirs[1]);
#line 1030
      req_draw_dirname(requester, 0, maxx - 2, path);
#line 1031
      wrefresh(requester);
#line 1032
      req_refresh_needed = (unsigned char)0;
      }
    }
    {
#line 1035
    inp_char = wgetch(requester);
#line 1036
    dummy = 0;
#line 1037
    new_path = (char *)((void *)0);
    }
    {
#line 1041
    if (inp_char == 13) {
#line 1041
      goto case_13;
    }
#line 1041
    if (inp_char == 10) {
#line 1041
      goto case_13;
    }
#line 1041
    if (inp_char == 343) {
#line 1041
      goto case_13;
    }
#line 1080
    if (inp_char == 49) {
#line 1080
      goto case_49;
    }
#line 1080
    if (inp_char == 265) {
#line 1080
      goto case_49;
    }
#line 1094
    if (inp_char == 51) {
#line 1094
      goto case_51;
    }
#line 1094
    if (inp_char == 267) {
#line 1094
      goto case_51;
    }
#line 1101
    if (inp_char == 52) {
#line 1101
      goto case_52;
    }
#line 1101
    if (inp_char == 268) {
#line 1101
      goto case_52;
    }
#line 1109
    if (inp_char == 55) {
#line 1109
      goto case_55;
    }
#line 1109
    if (inp_char == 271) {
#line 1109
      goto case_55;
    }
#line 1140
    if (inp_char == 81) {
#line 1140
      goto case_81;
    }
#line 1140
    if (inp_char == 113) {
#line 1140
      goto case_81;
    }
#line 1140
    if (inp_char == 27) {
#line 1140
      goto case_81;
    }
#line 1140
    if (inp_char == 39) {
#line 1140
      goto case_81;
    }
#line 1140
    if (inp_char == 276) {
#line 1140
      goto case_81;
    }
#line 1145
    if (inp_char == 12) {
#line 1145
      goto case_12;
    }
#line 1152
    if (inp_char == 9) {
#line 1152
      goto case_9;
    }
#line 1152
    if (inp_char == 341) {
#line 1152
      goto case_9;
    }
#line 1152
    if (inp_char == 340) {
#line 1152
      goto case_9;
    }
#line 1165
    if (inp_char == 259) {
#line 1165
      goto case_259;
    }
#line 1172
    if (inp_char == 258) {
#line 1172
      goto case_258;
    }
#line 1180
    if (inp_char == 362) {
#line 1180
      goto case_362;
    }
#line 1180
    if (inp_char == 262) {
#line 1180
      goto case_362;
    }
#line 1189
    if (inp_char == 385) {
#line 1189
      goto case_385;
    }
#line 1189
    if (inp_char == 360) {
#line 1189
      goto case_385;
    }
#line 1196
    if (inp_char == 339) {
#line 1196
      goto case_339;
    }
#line 1203
    if (inp_char == 338) {
#line 1203
      goto case_338;
    }
#line 1038
    goto switch_break;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_343: /* CIL Label */ 
#line 1043
    if (! act_side) {
      {
#line 1045
      tmp___5 = strcmp((char const   *)(dir_rel[0])->name, "..");
      }
#line 1045
      if (tmp___5 != 0) {
        {
#line 1046
        tmp___1 = strlen((char const   *)path);
#line 1046
        tmp___2 = strlen((char const   *)(dir_rel[0])->name);
#line 1046
        tmp___3 = malloc((size_t )(sizeof(char ) * (unsigned long )((tmp___1 + tmp___2) + 2U)));
#line 1046
        new_path = (char *)tmp___3;
        }
#line 1048
        if (! new_path) {
          {
#line 1049
          wuuush(1);
          }
        }
        {
#line 1051
        tmp___4 = strcmp((char const   *)path, "/");
        }
#line 1051
        if (tmp___4 != 0) {
          {
#line 1052
          sprintf((char */* __restrict  */)new_path, (char const   */* __restrict  */)"%s/%s",
                  path, (dir_rel[0])->name);
          }
        } else {
          {
#line 1054
          sprintf((char */* __restrict  */)new_path, (char const   */* __restrict  */)"/%s",
                  (dir_rel[0])->name);
          }
        }
      } else {
        {
#line 1057
        old_name = strrchr((char const   *)path, '/');
        }
#line 1058
        if (! old_name) {
#line 1059
          new_path = (char *)((void *)0);
        } else {
#line 1061
          *old_name = (char)0;
#line 1062
          if (! *path) {
            {
#line 1063
            new_path = copy_char_str((char *)"/");
            }
          } else {
            {
#line 1065
            new_path = copy_char_str(path);
            }
          }
          {
#line 1067
          *old_name = (char )'/';
#line 1068
          old_name = copy_char_str(old_name + 1);
          }
        }
      }
#line 1071
      dummy = 1;
    } else {
      {
#line 1074
      old_name = copy_char_str((dir_rel[1])->name);
#line 1075
      exit_code = 2;
      }
    }
#line 1077
    goto switch_break;
    case_49: /* CIL Label */ 
    case_265: /* CIL Label */ 
#line 1082
    if (act_side) {
      {
#line 1083
      tmp___6 = gettext("enter new filename");
#line 1083
      old_name = input_line(10, (dir_rel[1])->name, tmp___6, (unsigned char)1);
      }
    } else {
      {
#line 1085
      tmp___7 = gettext("enter new filename");
#line 1085
      old_name = input_line(10, (char *)((void *)0), tmp___7, (unsigned char)0);
      }
    }
#line 1087
    if (old_name) {
#line 1088
      exit_code = 2;
    }
#line 1090
    req_refresh_needed = (unsigned char)1;
#line 1091
    goto switch_break;
    case_51: /* CIL Label */ 
    case_267: /* CIL Label */ 
    {
#line 1096
    tmp___8 = getenv("HOME");
#line 1096
    new_path = copy_char_str(tmp___8);
#line 1097
    dummy = 1;
    }
#line 1098
    goto switch_break;
    case_52: /* CIL Label */ 
    case_268: /* CIL Label */ 
    {
#line 1103
    req_toggle_hidden(requester, maxy - 1, ye[0] + 1);
#line 1104
    new_path = copy_char_str(path);
#line 1105
    dummy = 1;
    }
#line 1106
    goto switch_break;
    case_55: /* CIL Label */ 
    case_271: /* CIL Label */ 
    {
#line 1111
    tmp___9 = gettext("enter new directory name");
#line 1111
    old_name = input_line(10, (char *)((void *)0), tmp___9, (unsigned char)0);
    }
#line 1112
    if (old_name) {
      {
#line 1113
      tmp___10 = strlen((char const   *)path);
#line 1113
      tmp___11 = strlen((char const   *)old_name);
#line 1113
      tmp___12 = malloc((size_t )(sizeof(char ) * (unsigned long )((tmp___10 + tmp___11) + 2U)));
#line 1113
      new_path = (char *)tmp___12;
      }
#line 1115
      if (! new_path) {
        {
#line 1116
        wuuush(1);
        }
      }
      {
#line 1118
      tmp___13 = strcmp((char const   *)path, "/");
      }
#line 1118
      if (tmp___13 != 0) {
        {
#line 1119
        sprintf((char */* __restrict  */)new_path, (char const   */* __restrict  */)"%s/%s",
                path, old_name);
        }
      } else {
        {
#line 1121
        sprintf((char */* __restrict  */)new_path, (char const   */* __restrict  */)"/%s",
                old_name);
        }
      }
      {
#line 1123
      free((void *)old_name);
#line 1124
      old_name = (char *)((void *)0);
#line 1125
      tmp___15 = mkdir((char const   *)new_path, (__mode_t )511);
      }
#line 1125
      if (tmp___15) {
        {
#line 1126
        tmp___14 = gettext("could not create directory");
#line 1126
        popup_error_win(tmp___14);
#line 1127
        free((void *)new_path);
#line 1128
        new_path = (char *)((void *)0);
        }
      } else {
#line 1130
        dummy = 1;
      }
    }
#line 1133
    req_refresh_needed = (unsigned char)1;
#line 1134
    goto switch_break;
    case_81: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_39: /* CIL Label */ 
    case_276: /* CIL Label */ 
#line 1142
    exit_code = 1;
#line 1143
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1147
    req_refresh_needed = (unsigned char)1;
#line 1148
    goto switch_break;
    case_9: /* CIL Label */ 
    case_341: /* CIL Label */ 
    case_340: /* CIL Label */ 
#line 1154
    if (dir_rel[1]) {
      {
#line 1156
      req_draw_mark(requester, pos_rel[act_side] + (ys[act_side] - 1), maxx - 2, (dir_rel[act_side])->name,
                    (chtype const   )0UL);
#line 1158
      act_side = 1 - act_side;
#line 1159
      req_draw_mark(requester, pos_rel[act_side] + (ys[act_side] - 1), maxx - 2, (dir_rel[act_side])->name,
                    (chtype const   )(1UL << 18));
#line 1161
      wrefresh(requester);
      }
    }
#line 1163
    goto switch_break;
    case_259: /* CIL Label */ 
    {
#line 1167
    req_handle_key_up(requester, & pos_abs[act_side], & pos_rel[act_side], ys[act_side],
                      ye[act_side], maxx - 2, tot_dirs[act_side], & dir_abs[act_side],
                      & dir_rel[act_side]);
    }
#line 1170
    goto switch_break;
    case_258: /* CIL Label */ 
    {
#line 1174
    req_handle_key_down(requester, & pos_abs[act_side], & pos_rel[act_side], ys[act_side],
                        ye[act_side], maxx - 2, tot_dirs[act_side], & dir_abs[act_side],
                        & dir_rel[act_side]);
    }
#line 1177
    goto switch_break;
    case_362: /* CIL Label */ 
    case_262: /* CIL Label */ 
    {
#line 1182
    req_handle_key_home(requester, & pos_abs[act_side], & pos_rel[act_side], ys[act_side],
                        ye[act_side], maxx - 2, tot_dirs[act_side], & dir_abs[act_side],
                        & dir_rel[act_side], dir_list[act_side]);
    }
#line 1186
    goto switch_break;
    case_385: /* CIL Label */ 
    case_360: /* CIL Label */ 
    {
#line 1191
    req_handle_key_end(requester, & pos_abs[act_side], & pos_rel[act_side], ys[act_side],
                       ye[act_side], maxx - 2, tot_dirs[act_side], & dir_abs[act_side],
                       & dir_rel[act_side]);
    }
#line 1194
    goto switch_break;
    case_339: /* CIL Label */ 
    {
#line 1198
    req_handle_key_ppage(requester, & pos_abs[act_side], & pos_rel[act_side], ys[act_side],
                         ye[act_side], maxx - 2, tot_dirs[act_side], & dir_abs[act_side],
                         & dir_rel[act_side]);
    }
#line 1201
    goto switch_break;
    case_338: /* CIL Label */ 
    {
#line 1205
    req_handle_key_npage(requester, & pos_abs[act_side], & pos_rel[act_side], ys[act_side],
                         ye[act_side], maxx - 2, tot_dirs[act_side], & dir_abs[act_side],
                         & dir_rel[act_side]);
    }
#line 1208
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1210
    if (dummy) {
#line 1212
      if (new_path) {
        {
#line 1212
        tmp___19 = access((char const   *)new_path, 1);
        }
#line 1212
        if (tmp___19) {
          {
#line 1265
          tmp___18 = gettext("accessing directory failed");
#line 1265
          popup_error_win(tmp___18);
#line 1266
          req_refresh_needed = (unsigned char)1;
          }
        } else {
          {
#line 1214
          free((void *)path);
#line 1215
          path = new_path;
#line 1216
          new_path = (char *)((void *)0);
#line 1217
          req_free_content_list(& dir_list[0]);
#line 1218
          req_free_content_list(& dir_list[1]);
#line 1219
          dir_list[0] = (content *)((void *)0);
#line 1220
          dir_list[1] = (content *)((void *)0);
#line 1221
          tmp___17 = req_read_dir_data((char const   *)path, & dir_list[0], & tot_dirs[0],
                                       & dir_list[1], & tot_dirs[1], config_req_hidden,
                                       old_name, & dir_old, & dir_found);
          }
#line 1221
          if (tmp___17) {
            {
#line 1224
            tmp___16 = gettext("reading dir failed");
#line 1224
            popup_error_win(tmp___16);
#line 1225
            exit_code = 1;
            }
          }
#line 1227
          dir_abs[0] = dir_list[0];
#line 1228
          dir_abs[1] = dir_list[1];
#line 1229
          dir_rel[0] = dir_list[0];
#line 1230
          dir_rel[1] = dir_list[1];
#line 1231
          pos_abs[0] = 1;
#line 1232
          pos_abs[1] = 1;
#line 1233
          pos_rel[0] = 1;
#line 1234
          pos_rel[1] = 1;
#line 1235
          if (dir_found) {
            {
#line 1236
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 1236
              if (dir_abs[0]) {
#line 1236
                if (! ((unsigned long )dir_abs[0] != (unsigned long )dir_old)) {
#line 1236
                  goto while_break___0;
                }
              } else {
#line 1236
                goto while_break___0;
              }
#line 1237
              (pos_abs[0]) ++;
#line 1238
              dir_abs[0] = (dir_abs[0])->next;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 1240
            if (! dir_abs[0]) {
#line 1241
              dir_abs[0] = dir_list[0];
#line 1242
              pos_abs[0] = 1;
            } else {
#line 1244
              dir_rel[0] = dir_abs[0];
#line 1245
              dummy = 0;
              {
#line 1245
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 1245
                if (! (dummy <= (ye[0] - ys[0]) >> 1)) {
#line 1245
                  goto while_break___1;
                }
#line 1246
                if (! (dir_abs[0])->prev) {
#line 1246
                  goto while_break___1;
                }
#line 1247
                (pos_abs[0]) --;
#line 1248
                dir_abs[0] = (dir_abs[0])->prev;
#line 1249
                (pos_rel[0]) ++;
#line 1245
                dummy ++;
              }
              while_break___1: /* CIL Label */ ;
              }
            }
          }
          {
#line 1253
          act_side = 0;
#line 1254
          req_dir_fill(requester, ys[0], ye[0], maxx - 2, dir_abs[0]);
#line 1255
          req_dir_fill(requester, ys[1], ye[1], maxx - 2, dir_abs[1]);
#line 1256
          req_draw_mark(requester, pos_rel[0] + (ys[0] - 1), maxx - 2, (dir_rel[0])->name,
                        (chtype const   )(1UL << 18));
#line 1258
          req_draw_stat(requester, ys[0], ye[0], maxx - 1, pos_abs[0], pos_rel[0],
                        tot_dirs[0]);
#line 1260
          req_draw_stat(requester, ys[1], ye[1], maxx - 1, pos_abs[1], pos_rel[1],
                        tot_dirs[1]);
#line 1262
          req_draw_dirname(requester, 0, maxx - 2, path);
#line 1263
          wrefresh(requester);
          }
        }
      } else {
        {
#line 1265
        tmp___18 = gettext("accessing directory failed");
#line 1265
        popup_error_win(tmp___18);
#line 1266
        req_refresh_needed = (unsigned char)1;
        }
      }
#line 1268
      if (old_name) {
        {
#line 1269
        free((void *)old_name);
#line 1270
        old_name = (char *)((void *)0);
        }
      }
#line 1272
      dummy = 0;
    }
#line 1275
    if (exit_code) {
#line 1275
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1279
  if (exit_code == 1) {
#line 1279
    goto case_1;
  }
#line 1283
  if (exit_code == 2) {
#line 1283
    goto case_2;
  }
#line 1278
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 1280
  if (path) {
    {
#line 1280
    free((void *)path);
    }
  }
#line 1281
  path = (char *)((void *)0);
#line 1282
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 1284
  tmp___20 = strlen((char const   *)path);
#line 1284
  tmp___21 = strlen((char const   *)old_name);
#line 1284
  tmp___22 = realloc((void *)path, (size_t )(sizeof(char ) * (unsigned long )((tmp___20 + tmp___21) + 2U)));
#line 1284
  path = (char *)tmp___22;
  }
#line 1286
  if (! path) {
    {
#line 1287
    wuuush(1);
    }
  }
  {
#line 1289
  tmp___23 = strcmp((char const   *)path, "/");
  }
#line 1289
  if (tmp___23 != 0) {
    {
#line 1289
    strcat((char */* __restrict  */)path, (char const   */* __restrict  */)"/");
    }
  }
  {
#line 1290
  strcat((char */* __restrict  */)path, (char const   */* __restrict  */)old_name);
#line 1291
  path = req_finish_path(path);
  }
#line 1292
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1295
  req_free_content_list(& dir_list[0]);
#line 1296
  req_free_content_list(& dir_list[1]);
  }
#line 1297
  if (old_name) {
    {
#line 1298
    free((void *)old_name);
#line 1299
    old_name = (char *)((void *)0);
    }
  }
  {
#line 1302
  c_delwin(requester);
  }
#line 1304
  return (path);
}
}
#line 1307 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
char *req_get_dir(char const   *path , char const   *description ) 
{ 
  char *dir ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 1311
  dir = copy_char_str((char *)path);
#line 1312
  dir = req_finish_path(dir);
  }
#line 1313
  if (config_curs_dir) {
    {
#line 1313
    tmp = req_curs_dir(dir, description);
    }
#line 1313
    return (tmp);
  }
  {
#line 1315
  tmp___0 = gettext("currently TAB-expansion does not work :-(");
#line 1315
  tmp___1 = gettext("(you can use a directory-requester by changing value in preferences)");
#line 1315
  tmp___2 = gettext("please input path of directory");
#line 1315
  dir = input_line2(5, dir, (char *)description, tmp___2, tmp___1, (char *)((void *)0),
                    tmp___0, (char *)((void *)0), (char *)((void *)0), (unsigned char)1);
#line 1321
  tmp___3 = req_finish_path(dir);
  }
#line 1321
  return (tmp___3);
}
}
#line 1324 "/home/wslee/benchmarks/sound/mp3c-0.29/src/requester.c"
char *req_get_file(char const   *path , char const   *description ) 
{ 
  char *file ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 1328
  file = copy_char_str((char *)path);
#line 1329
  file = req_finish_path(file);
  }
#line 1330
  if (config_curs_dir) {
    {
#line 1330
    tmp = req_curs_file(file, description);
    }
#line 1330
    return (tmp);
  }
  {
#line 1332
  tmp___0 = gettext("currently TAB-expansion does not work :-(");
#line 1332
  tmp___1 = gettext("(you can use a file-requester by changing value in preferences)");
#line 1332
  tmp___2 = gettext("please input path of file");
#line 1332
  file = input_line2(5, file, (char *)description, tmp___2, tmp___1, (char *)((void *)0),
                     tmp___0, (char *)((void *)0), (char *)((void *)0), (unsigned char)1);
#line 1338
  tmp___3 = req_finish_path(file);
  }
#line 1338
  return (tmp___3);
}
}
#line 37 "/home/wslee/benchmarks/sound/mp3c-0.29/src/options.c"
void check_config(void) ;
#line 43
void reinit_volume(WINDOW *win ) ;
#line 44
void init_config(void) ;
#line 46
int get_config(char *file ) ;
#line 47
int put_config(char *file , unsigned char ask ) ;
#line 50
void filenm_generate(song_typ *track ) ;
#line 59
char *def_cddb_server ;
#line 60
char *def_cddb_bank ;
#line 61
char *def_cdrom_dev ;
#line 62
char *def_tmp_file ;
#line 63
char *def_mp3_dir ;
#line 69
char *def_m3u_pattern ;
#line 70
char *def_m3u_patmix ;
#line 71
char *def_m3u_dir ;
#line 72
char *def_comment ;
#line 73
char *fn_pattern ;
#line 74
char *fn_pattern_mix ;
#line 75
char *def_ill_chars ;
#line 76
char *def_exp_file ;
#line 77
int fn_mode ;
#line 78
char replace_space_ch ;
#line 79
unsigned char fn_toupper ;
#line 82
int auto_save ;
#line 83
char *external_config_file ;
#line 84
char *external_cdrom_dev ;
#line 86
unsigned char def_on_fly ;
#line 87
unsigned char eased_char_hand ;
#line 88
char replace_slash_ch ;
#line 91
unsigned char rip_enc_ordered ;
#line 93
int del_tmp_on_exit ;
#line 94
unsigned char clear_del_on_exp ;
#line 96
int def_m3u_rel_name ;
#line 97
unsigned char config_cddb_enbl ;
#line 98
unsigned char config_para_mp3c ;
#line 99
int config_case_chg ;
#line 100
char *def_cddb_email ;
#line 101
char *def_smtp_server ;
#line 102
char *def_my_email ;
#line 103
unsigned char config_open_tray ;
#line 104
unsigned char config_ill_remove ;
#line 106
unsigned char config_pat_prot ;
#line 108
void change_comment(song_typ *anchor , char *old , char *new ) ;
#line 109
void change_onfly_flag(unsigned char new_val , song_typ *anchor ) ;
#line 112 "/home/wslee/benchmarks/sound/mp3c-0.29/src/options.c"
void reb_field_entry(field_select_typ *anchor , char *des , char *value ) 
{ 


  {
#line 114
  if (anchor->dest) {
    {
#line 114
    free((void *)anchor->dest);
    }
  }
  {
#line 115
  anchor->dest = copy_char_str(value);
  }
#line 117
  if (des) {
#line 118
    if (anchor->field) {
      {
#line 118
      free((void *)anchor->field);
      }
    }
    {
#line 119
    anchor->field = copy_char_str(des);
    }
  }
#line 121
  return;
}
}
#line 124 "/home/wslee/benchmarks/sound/mp3c-0.29/src/options.c"
void reb_filenm(void) 
{ 
  song_typ *curr ;
  int i ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  char *__cil_tmp6 ;

  {
#line 129
  i = 0;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! (i <= 1)) {
#line 129
      goto while_break;
    }
#line 130
    curr = lay_global_anchor[i];
    {
#line 131
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 131
      if (! curr) {
#line 131
        goto while_break___0;
      }
#line 132
      if (curr->fn_auto) {
#line 133
        if (curr->dirname) {
          {
#line 133
          free((void *)curr->dirname);
          }
        }
        {
#line 134
        tmp = strlen((char const   *)def_mp3_dir);
#line 134
        tmp___0 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp + 1U)));
#line 134
        curr->dirname = (char *)tmp___0;
        }
#line 135
        if (! curr->dirname) {
          {
#line 136
          perror("malloc");
#line 137
          wuuush(1);
          }
        }
        {
#line 139
        tmp___1 = strlen((char const   *)def_mp3_dir);
#line 139
        memcpy((void */* __restrict  */)curr->dirname, (void const   */* __restrict  */)def_mp3_dir,
               tmp___1 + 1U);
#line 140
        filenm_generate(curr);
        }
      }
#line 142
      curr = curr->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 129
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  return;
}
}
#line 148 "/home/wslee/benchmarks/sound/mp3c-0.29/src/options.c"
void add_field_entry(field_select_typ **anchor , char *des , int nr , char *value ) 
{ 
  field_select_typ *curr ;
  field_select_typ *new ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 152
  tmp = malloc((size_t )sizeof(field_select_typ ));
#line 152
  new = (field_select_typ *)tmp;
  }
#line 153
  if ((unsigned long )new == (unsigned long )((void *)0)) {
    {
#line 154
    perror("malloc");
#line 155
    wuuush(1);
    }
  }
  {
#line 158
  new->field = copy_char_str(des);
#line 159
  new->dest = copy_char_str(value);
#line 161
  tmp___0 = malloc((size_t )sizeof(char ));
#line 161
  new->information = (char *)tmp___0;
  }
#line 162
  if ((unsigned long )new->information == (unsigned long )((void *)0)) {
    {
#line 163
    perror("malloc");
#line 164
    wuuush(1);
    }
  }
#line 166
  *(new->information) = (char )((unsigned char )nr);
#line 168
  new->next = (struct _field_select_typ *)((void *)0);
#line 169
  new->prev = (struct _field_select_typ *)((void *)0);
#line 171
  curr = *anchor;
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    if (! curr) {
#line 172
      goto while_break;
    }
#line 173
    if (! curr->next) {
#line 173
      goto while_break;
    }
#line 174
    curr = curr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  if (! curr) {
#line 177
    *anchor = new;
  } else {
#line 179
    curr->next = new;
#line 180
    new->prev = curr;
  }
#line 182
  return;
}
}
#line 185 "/home/wslee/benchmarks/sound/mp3c-0.29/src/options.c"
void option_menu(WINDOW *win ) 
{ 
  field_select_typ *new ;
  field_select_typ *anchor ;
  unsigned char reinit_cddev ;
  unsigned char use_old ;
  unsigned char loaded_def ;
  char *pointer ;
  char mini_str[256] ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  int tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;
  char *tmp___69 ;
  char *tmp___70 ;
  char *tmp___71 ;
  char *tmp___72 ;
  char *tmp___73 ;
  char *tmp___74 ;
  char *tmp___75 ;
  char *tmp___76 ;
  char *tmp___77 ;
  char *tmp___78 ;
  char *tmp___79 ;
  char *tmp___80 ;
  char *tmp___81 ;
  char *tmp___82 ;
  char *tmp___83 ;
  char *tmp___84 ;
  char *tmp___85 ;
  char *tmp___86 ;
  char *tmp___87 ;
  char *tmp___88 ;
  char *tmp___89 ;
  int tmp___90 ;
  char *tmp___91 ;
  char *tmp___92 ;
  char *tmp___93 ;
  char *tmp___94 ;
  char *tmp___95 ;
  char *tmp___96 ;
  char *tmp___97 ;
  char *tmp___98 ;
  char *tmp___99 ;
  char *tmp___100 ;
  char *tmp___101 ;
  size_t tmp___102 ;
  char *tmp___103 ;
  char *tmp___104 ;
  char *tmp___105 ;
  unsigned char tmp___106 ;
  char *tmp___107 ;
  char *tmp___108 ;
  char *tmp___109 ;
  unsigned char tmp___110 ;
  char *tmp___111 ;
  char *tmp___112 ;
  char *tmp___113 ;
  char *tmp___114 ;
  int tmp___115 ;
  size_t tmp___116 ;
  char *tmp___117 ;
  char *tmp___118 ;
  char *tmp___119 ;
  char *tmp___120 ;
  char *tmp___121 ;
  char *tmp___122 ;
  char *tmp___123 ;
  char *tmp___124 ;
  char *tmp___125 ;
  char *tmp___126 ;
  char *tmp___127 ;
  char *tmp___128 ;
  char *tmp___129 ;
  char *tmp___130 ;
  char *tmp___131 ;
  char *tmp___132 ;
  char *tmp___133 ;
  char *tmp___134 ;
  char *tmp___135 ;
  char *tmp___136 ;
  char *tmp___137 ;
  char *tmp___138 ;
  char *tmp___139 ;
  char *tmp___140 ;
  char *tmp___141 ;
  char *tmp___142 ;
  char *tmp___143 ;
  size_t tmp___144 ;
  size_t tmp___145 ;
  char *tmp___146 ;
  size_t tmp___147 ;
  void *tmp___148 ;
  size_t tmp___149 ;
  char *tmp___150 ;
  char *tmp___151 ;
  char *tmp___152 ;
  char *tmp___153 ;
  char *tmp___154 ;
  char *tmp___155 ;
  char *tmp___156 ;
  void *tmp___157 ;
  char *tmp___158 ;
  char *tmp___159 ;
  int tmp___160 ;
  char *tmp___161 ;
  unsigned char tmp___162 ;
  int tmp___163 ;
  char *tmp___164 ;
  char *tmp___165 ;
  char *tmp___166 ;
  char *tmp___167 ;
  char *tmp___168 ;
  char *tmp___169 ;
  char *tmp___170 ;
  char *tmp___171 ;
  unsigned char tmp___172 ;
  char *tmp___173 ;
  unsigned char tmp___174 ;
  char *tmp___175 ;
  char *tmp___176 ;
  char *tmp___177 ;
  char *tmp___178 ;
  char *tmp___179 ;
  char *tmp___180 ;
  unsigned char tmp___181 ;
  char *tmp___182 ;
  char *tmp___183 ;
  size_t tmp___184 ;
  size_t tmp___185 ;
  char *tmp___186 ;
  char *tmp___187 ;
  char *tmp___188 ;
  unsigned char tmp___189 ;
  char *tmp___190 ;
  char *tmp___191 ;
  char *tmp___192 ;
  char *tmp___193 ;
  char *tmp___194 ;
  char *tmp___195 ;
  char *tmp___196 ;
  size_t tmp___197 ;
  char *tmp___198 ;
  size_t tmp___199 ;
  void *tmp___200 ;
  size_t tmp___201 ;
  char *tmp___202 ;
  char *tmp___203 ;
  char *tmp___204 ;
  unsigned char tmp___205 ;
  char *tmp___206 ;
  char *tmp___207 ;
  char *tmp___208 ;
  unsigned char tmp___209 ;
  char *tmp___210 ;
  char *tmp___211 ;
  char *tmp___212 ;
  char *tmp___213 ;
  char *tmp___214 ;
  char *tmp___215 ;
  char *tmp___216 ;
  size_t tmp___217 ;
  char *tmp___218 ;
  char *tmp___219 ;
  char *tmp___220 ;
  unsigned char tmp___221 ;
  char *tmp___222 ;
  char *tmp___223 ;
  char *tmp___224 ;
  unsigned char tmp___225 ;
  char *tmp___226 ;
  char *tmp___227 ;
  char *tmp___228 ;
  char *tmp___229 ;
  char *tmp___230 ;
  char *tmp___231 ;
  char *tmp___232 ;
  char *tmp___233 ;
  char *tmp___234 ;
  size_t tmp___235 ;
  char *tmp___236 ;
  char *tmp___237 ;
  char *tmp___238 ;
  char *tmp___239 ;
  char *tmp___240 ;
  char *tmp___241 ;
  char *tmp___242 ;
  char *tmp___243 ;
  char *tmp___244 ;
  char *tmp___245 ;
  char *tmp___246 ;
  char *tmp___247 ;
  char *tmp___248 ;
  unsigned char tmp___249 ;
  char *tmp___250 ;
  char *tmp___251 ;
  char *tmp___252 ;
  unsigned char tmp___253 ;
  char *tmp___254 ;
  char *tmp___255 ;
  char *tmp___256 ;
  char *tmp___257 ;
  char *tmp___258 ;
  char *tmp___259 ;
  char *tmp___260 ;
  char *tmp___261 ;
  char *tmp___262 ;
  char *tmp___263 ;
  char *tmp___264 ;
  char *tmp___265 ;
  char *tmp___266 ;
  char *tmp___267 ;
  char *tmp___268 ;
  char *tmp___269 ;
  char *tmp___270 ;
  char *tmp___271 ;
  unsigned char tmp___272 ;
  char *tmp___273 ;
  char *tmp___274 ;
  size_t tmp___275 ;
  size_t tmp___276 ;
  char *tmp___277 ;
  char *tmp___278 ;
  char *tmp___279 ;
  char *tmp___280 ;
  char *tmp___281 ;
  char *tmp___282 ;
  void *__cil_tmp294 ;
  char *__cil_tmp295 ;
  char *__cil_tmp296 ;
  char *__cil_tmp297 ;
  char *__cil_tmp298 ;
  char *__cil_tmp299 ;
  char *__cil_tmp300 ;
  char *__cil_tmp301 ;
  char *__cil_tmp302 ;
  char *__cil_tmp303 ;
  char *__cil_tmp304 ;
  char *__cil_tmp305 ;
  char *__cil_tmp306 ;
  char *__cil_tmp307 ;
  char *__cil_tmp308 ;
  char *__cil_tmp309 ;
  char *__cil_tmp310 ;
  char *__cil_tmp311 ;
  char *__cil_tmp312 ;
  char *__cil_tmp313 ;
  char *__cil_tmp314 ;
  char *__cil_tmp315 ;
  char *__cil_tmp316 ;
  char *__cil_tmp317 ;
  char *__cil_tmp318 ;
  char *__cil_tmp319 ;
  char *__cil_tmp320 ;
  char *__cil_tmp321 ;
  char *__cil_tmp322 ;
  char *__cil_tmp323 ;
  char *__cil_tmp324 ;
  char *__cil_tmp325 ;
  char *__cil_tmp326 ;
  char *__cil_tmp327 ;
  char *__cil_tmp328 ;
  char *__cil_tmp329 ;
  char *__cil_tmp330 ;
  char *__cil_tmp331 ;
  char *__cil_tmp332 ;
  char *__cil_tmp333 ;
  char *__cil_tmp334 ;
  char *__cil_tmp335 ;
  char *__cil_tmp336 ;
  char *__cil_tmp337 ;
  char *__cil_tmp338 ;
  char *__cil_tmp339 ;
  char *__cil_tmp340 ;
  char *__cil_tmp341 ;
  char *__cil_tmp342 ;
  char *__cil_tmp343 ;
  char *__cil_tmp344 ;
  char *__cil_tmp345 ;
  char *__cil_tmp346 ;
  char *__cil_tmp347 ;
  char *__cil_tmp348 ;
  char *__cil_tmp349 ;
  char *__cil_tmp350 ;
  char *__cil_tmp351 ;
  char *__cil_tmp352 ;
  char *__cil_tmp353 ;
  char *__cil_tmp354 ;
  char *__cil_tmp355 ;
  char *__cil_tmp356 ;
  char *__cil_tmp357 ;
  char *__cil_tmp358 ;
  char *__cil_tmp359 ;
  char *__cil_tmp360 ;
  char *__cil_tmp361 ;
  char *__cil_tmp362 ;
  char *__cil_tmp363 ;
  char *__cil_tmp364 ;
  char *__cil_tmp365 ;
  char *__cil_tmp366 ;
  char *__cil_tmp367 ;
  char *__cil_tmp368 ;
  char *__cil_tmp369 ;
  char *__cil_tmp370 ;
  char *__cil_tmp371 ;
  char *__cil_tmp372 ;
  char *__cil_tmp373 ;
  char *__cil_tmp374 ;
  char *__cil_tmp375 ;
  char *__cil_tmp376 ;
  char *__cil_tmp377 ;
  char *__cil_tmp378 ;
  char *__cil_tmp379 ;
  char *__cil_tmp380 ;
  char *__cil_tmp381 ;
  char *__cil_tmp382 ;
  char *__cil_tmp383 ;
  char *__cil_tmp384 ;
  char *__cil_tmp385 ;
  char *__cil_tmp386 ;
  char *__cil_tmp387 ;
  char *__cil_tmp388 ;
  char *__cil_tmp389 ;
  char *__cil_tmp390 ;
  char *__cil_tmp391 ;
  char *__cil_tmp392 ;
  char *__cil_tmp393 ;
  char *__cil_tmp394 ;
  char *__cil_tmp395 ;
  char *__cil_tmp396 ;
  char *__cil_tmp397 ;
  char *__cil_tmp398 ;
  char *__cil_tmp399 ;
  char *__cil_tmp400 ;
  char *__cil_tmp401 ;
  char *__cil_tmp402 ;
  char *__cil_tmp403 ;
  char *__cil_tmp404 ;
  char *__cil_tmp405 ;
  char *__cil_tmp406 ;
  char *__cil_tmp407 ;
  char *__cil_tmp408 ;
  char *__cil_tmp409 ;
  char *__cil_tmp410 ;
  char *__cil_tmp411 ;
  char *__cil_tmp412 ;
  char *__cil_tmp413 ;
  char *__cil_tmp414 ;
  char *__cil_tmp415 ;
  char *__cil_tmp416 ;
  char *__cil_tmp417 ;
  char *__cil_tmp418 ;
  char *__cil_tmp419 ;
  char *__cil_tmp420 ;
  char *__cil_tmp421 ;
  char *__cil_tmp422 ;
  char *__cil_tmp423 ;
  char *__cil_tmp424 ;
  char *__cil_tmp425 ;
  char *__cil_tmp426 ;
  char *__cil_tmp427 ;
  char *__cil_tmp428 ;
  char *__cil_tmp429 ;
  char *__cil_tmp430 ;
  char *__cil_tmp431 ;
  char *__cil_tmp432 ;
  char *__cil_tmp433 ;
  char *__cil_tmp434 ;
  char *__cil_tmp435 ;
  char *__cil_tmp436 ;
  char *__cil_tmp437 ;
  char *__cil_tmp438 ;
  char *__cil_tmp439 ;
  char *__cil_tmp440 ;
  char *__cil_tmp441 ;
  char *__cil_tmp442 ;
  char *__cil_tmp443 ;
  char *__cil_tmp444 ;
  char *__cil_tmp445 ;
  char *__cil_tmp446 ;
  char *__cil_tmp447 ;
  char *__cil_tmp448 ;
  char *__cil_tmp449 ;
  char *__cil_tmp450 ;
  char *__cil_tmp451 ;
  char *__cil_tmp452 ;
  char *__cil_tmp453 ;
  char *__cil_tmp454 ;
  char *__cil_tmp455 ;
  char *__cil_tmp456 ;
  char *__cil_tmp457 ;
  char *__cil_tmp458 ;
  char *__cil_tmp459 ;
  char *__cil_tmp460 ;
  char *__cil_tmp461 ;
  char *__cil_tmp462 ;
  char *__cil_tmp463 ;
  char *__cil_tmp464 ;
  char *__cil_tmp465 ;
  char *__cil_tmp466 ;
  char *__cil_tmp467 ;
  char *__cil_tmp468 ;
  char *__cil_tmp469 ;
  char *__cil_tmp470 ;
  char *__cil_tmp471 ;
  char *__cil_tmp472 ;
  char *__cil_tmp473 ;
  char *__cil_tmp474 ;
  char *__cil_tmp475 ;
  char *__cil_tmp476 ;
  char *__cil_tmp477 ;
  char *__cil_tmp478 ;
  char *__cil_tmp479 ;
  char *__cil_tmp480 ;
  char *__cil_tmp481 ;
  char *__cil_tmp482 ;
  char *__cil_tmp483 ;
  char *__cil_tmp484 ;
  char *__cil_tmp485 ;
  char *__cil_tmp486 ;
  char *__cil_tmp487 ;
  char *__cil_tmp488 ;
  char *__cil_tmp489 ;
  char *__cil_tmp490 ;
  char *__cil_tmp491 ;
  char *__cil_tmp492 ;
  char *__cil_tmp493 ;
  char *__cil_tmp494 ;
  char *__cil_tmp495 ;
  char *__cil_tmp496 ;
  char *__cil_tmp497 ;
  char *__cil_tmp498 ;
  char *__cil_tmp499 ;
  char *__cil_tmp500 ;
  char *__cil_tmp501 ;
  char *__cil_tmp502 ;
  char *__cil_tmp503 ;
  char *__cil_tmp504 ;
  char *__cil_tmp505 ;
  char *__cil_tmp506 ;
  char *__cil_tmp507 ;
  char *__cil_tmp508 ;
  char *__cil_tmp509 ;
  char *__cil_tmp510 ;
  char *__cil_tmp511 ;
  char *__cil_tmp512 ;
  char *__cil_tmp513 ;
  char *__cil_tmp514 ;
  char *__cil_tmp515 ;
  char *__cil_tmp516 ;
  char *__cil_tmp517 ;
  char *__cil_tmp518 ;
  char *__cil_tmp519 ;
  char *__cil_tmp520 ;
  char *__cil_tmp521 ;
  char *__cil_tmp522 ;
  char *__cil_tmp523 ;
  char *__cil_tmp524 ;
  char *__cil_tmp525 ;
  char *__cil_tmp526 ;
  char *__cil_tmp527 ;
  char *__cil_tmp528 ;
  char *__cil_tmp529 ;
  char *__cil_tmp530 ;
  char *__cil_tmp531 ;
  char *__cil_tmp532 ;
  char *__cil_tmp533 ;
  char *__cil_tmp534 ;
  char *__cil_tmp535 ;
  char *__cil_tmp536 ;
  char *__cil_tmp537 ;
  char *__cil_tmp538 ;
  char *__cil_tmp539 ;
  char *__cil_tmp540 ;
  char *__cil_tmp541 ;
  char *__cil_tmp542 ;
  char *__cil_tmp543 ;
  char *__cil_tmp544 ;
  char *__cil_tmp545 ;
  char *__cil_tmp546 ;
  char *__cil_tmp547 ;
  char *__cil_tmp548 ;
  char *__cil_tmp549 ;
  char *__cil_tmp550 ;
  char *__cil_tmp551 ;
  char *__cil_tmp552 ;
  char *__cil_tmp553 ;
  char *__cil_tmp554 ;
  char *__cil_tmp555 ;
  char *__cil_tmp556 ;
  char *__cil_tmp557 ;
  char *__cil_tmp558 ;
  char *__cil_tmp559 ;
  char *__cil_tmp560 ;
  char *__cil_tmp561 ;
  char *__cil_tmp562 ;
  char *__cil_tmp563 ;
  char *__cil_tmp564 ;
  char *__cil_tmp565 ;
  char *__cil_tmp566 ;
  char *__cil_tmp567 ;
  char *__cil_tmp568 ;
  char *__cil_tmp569 ;
  char *__cil_tmp570 ;
  char *__cil_tmp571 ;
  char *__cil_tmp572 ;
  char *__cil_tmp573 ;

  {
#line 195
  anchor = (field_select_typ *)((void *)0);
#line 196
  reinit_cddev = (unsigned char)0;
#line 197
  use_old = (unsigned char)0;
#line 198
  loaded_def = (unsigned char)1;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (loaded_def) {
      {
#line 203
      tmp = gettext("CDrom device");
#line 203
      add_field_entry(& anchor, tmp, 1, def_cdrom_dev);
#line 205
      tmp___0 = gettext("CDDB server");
#line 205
      add_field_entry(& anchor, tmp___0, 2, def_cddb_server);
#line 207
      tmp___1 = gettext("CDDB eMail address");
#line 207
      add_field_entry(& anchor, tmp___1, 33, def_cddb_email);
#line 209
      tmp___2 = gettext("SMTP server");
#line 209
      add_field_entry(& anchor, tmp___2, 34, def_smtp_server);
#line 211
      tmp___3 = gettext("My eMail address");
#line 211
      add_field_entry(& anchor, tmp___3, 35, def_my_email);
#line 213
      tmp___4 = gettext("local CDDB directory");
#line 213
      add_field_entry(& anchor, tmp___4, 3, def_cddb_bank);
      }
#line 215
      if (config_cddb_enbl) {
        {
#line 216
        tmp___5 = gettext("yes");
#line 216
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___5);
        }
      } else {
        {
#line 218
        tmp___6 = gettext("no");
#line 218
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___6);
        }
      }
      {
#line 220
      tmp___7 = gettext("allow remote CDDB access?");
#line 220
      add_field_entry(& anchor, tmp___7, 30, mini_str);
#line 222
      tmp___8 = gettext("MP3/OGG destination directory");
#line 222
      add_field_entry(& anchor, tmp___8, 4, def_mp3_dir);
#line 224
      tmp___9 = gettext("Pattern for mp3/ogg-filename creation");
#line 224
      add_field_entry(& anchor, tmp___9, 5, fn_pattern);
#line 226
      tmp___10 = gettext("Pattern for mp3/ogg-filename (sampler cds)");
#line 226
      add_field_entry(& anchor, tmp___10, 39, fn_pattern_mix);
#line 228
      sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%d",
              fn_mode);
#line 229
      tmp___11 = gettext("Patternmode");
#line 229
      add_field_entry(& anchor, tmp___11, 6, mini_str);
#line 231
      sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%c",
              (int )replace_space_ch);
#line 232
      tmp___12 = gettext("space replace character");
#line 232
      add_field_entry(& anchor, tmp___12, 42, mini_str);
      }
#line 234
      if (config_case_chg == 0) {
        {
#line 234
        tmp___13 = gettext("no");
#line 234
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___13);
        }
      } else
#line 235
      if (config_case_chg == 1) {
        {
#line 235
        tmp___14 = gettext("to lower");
#line 235
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___14);
        }
      } else {
        {
#line 236
        tmp___15 = gettext("to upper");
#line 236
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___15);
        }
      }
      {
#line 237
      tmp___16 = gettext("Case change");
#line 237
      add_field_entry(& anchor, tmp___16, 32, mini_str);
      }
#line 239
      if (fn_toupper) {
        {
#line 240
        tmp___17 = gettext("on");
#line 240
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___17);
        }
      } else {
        {
#line 242
        tmp___18 = gettext("off");
#line 242
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___18);
        }
      }
      {
#line 244
      tmp___19 = gettext("To-Upper mode");
#line 244
      add_field_entry(& anchor, tmp___19, 7, mini_str);
#line 246
      tmp___20 = gettext("illegal characters for filenames");
#line 246
      add_field_entry(& anchor, tmp___20, 21, def_ill_chars);
      }
#line 248
      if (config_ill_remove) {
        {
#line 249
        tmp___21 = gettext("remove them");
#line 249
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___21);
        }
      } else {
        {
#line 251
        tmp___22 = gettext("use patternmode");
#line 251
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___22);
        }
      }
      {
#line 253
      tmp___23 = gettext("what to do with ill characters");
#line 253
      add_field_entry(& anchor, tmp___23, 37, mini_str);
      }
#line 255
      if (config_pat_prot) {
        {
#line 256
        tmp___24 = gettext("yes");
#line 256
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___24);
        }
      } else {
        {
#line 258
        tmp___25 = gettext("no");
#line 258
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___25);
        }
      }
      {
#line 260
      tmp___26 = gettext("protect pattern masks");
#line 260
      add_field_entry(& anchor, tmp___26, 41, mini_str);
#line 262
      sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%c",
              (int )replace_slash_ch);
#line 263
      tmp___27 = gettext("slash replace character");
#line 263
      add_field_entry(& anchor, tmp___27, 23, mini_str);
      }
#line 265
      if (eased_char_hand) {
        {
#line 266
        tmp___28 = gettext("non-strict (8-bit Western)");
#line 266
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___28);
        }
      } else {
        {
#line 268
        tmp___29 = gettext("strict (7-bit ASCII)");
#line 268
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___29);
        }
      }
      {
#line 271
      tmp___30 = gettext("handling of allowed characters");
#line 271
      add_field_entry(& anchor, tmp___30, 22, mini_str);
#line 273
      tmp___31 = gettext("Pattern for m3u-playlist creation");
#line 273
      add_field_entry(& anchor, tmp___31, 17, def_m3u_pattern);
#line 275
      tmp___32 = gettext("Pattern for m3u-playlists (sampler cds)");
#line 275
      add_field_entry(& anchor, tmp___32, 40, def_m3u_patmix);
      }
#line 277
      if (def_m3u_dir) {
        {
#line 277
        tmp___35 = strcmp((char const   *)def_m3u_dir, "0");
        }
#line 277
        if (tmp___35 == 0) {
          {
#line 278
          tmp___33 = gettext("M3U destination directory");
#line 278
          add_field_entry(& anchor, tmp___33, 18, def_mp3_dir);
          }
        } else {
          {
#line 280
          tmp___34 = gettext("M3U destination directory");
#line 280
          add_field_entry(& anchor, tmp___34, 18, def_m3u_dir);
          }
        }
      } else {
        {
#line 280
        tmp___34 = gettext("M3U destination directory");
#line 280
        add_field_entry(& anchor, tmp___34, 18, def_m3u_dir);
        }
      }
#line 283
      if (def_m3u_rel_name == 0) {
        {
#line 284
        tmp___36 = gettext("full path");
#line 284
        sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___36);
        }
      } else
#line 285
      if (def_m3u_rel_name == 1) {
        {
#line 286
        tmp___37 = gettext("relative to m3u-dir");
#line 286
        sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___37);
        }
      } else {
        {
#line 288
        tmp___38 = gettext("relative to m3u-file");
#line 288
        sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___38);
        }
      }
      {
#line 290
      tmp___39 = gettext("how to create m3u-entries");
#line 290
      add_field_entry(& anchor, tmp___39, 29, mini_str);
      }
#line 292
      if (auto_save) {
        {
#line 293
        tmp___40 = gettext("on");
#line 293
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___40);
        }
      } else {
        {
#line 295
        tmp___41 = gettext("off");
#line 295
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___41);
        }
      }
      {
#line 297
      tmp___42 = gettext("auto save flag");
#line 297
      add_field_entry(& anchor, tmp___42, 8, mini_str);
      }
#line 299
      if (def_on_fly) {
        {
#line 300
        tmp___43 = gettext("yes");
#line 300
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___43);
        }
      } else {
        {
#line 302
        tmp___44 = gettext("no");
#line 302
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___44);
        }
      }
      {
#line 304
      tmp___45 = gettext("encode on-fly as default?");
#line 304
      add_field_entry(& anchor, tmp___45, 20, mini_str);
      }
#line 306
      if (rip_enc_ordered) {
        {
#line 306
        tmp___46 = gettext("yes");
#line 306
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___46);
        }
      } else {
        {
#line 307
        tmp___47 = gettext("no");
#line 307
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___47);
        }
      }
      {
#line 308
      tmp___48 = gettext("rip all tracks before encoding?");
#line 308
      add_field_entry(& anchor, tmp___48, 24, mini_str);
#line 310
      sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%d",
              (int )config_fancy_colors);
#line 311
      tmp___49 = gettext("fancy colors");
#line 311
      add_field_entry(& anchor, tmp___49, 9, mini_str);
#line 313
      tmp___50 = gettext("CDripper non-fly (output to file)");
#line 313
      add_field_entry(& anchor, tmp___50, 10, def_cd_rip_nf);
#line 315
      tmp___51 = gettext("CDripper on-fly (output to stdout)");
#line 315
      add_field_entry(& anchor, tmp___51, 11, def_cd_rip_of);
#line 317
      tmp___52 = gettext("MP3/Oggencoder non-fly (input from file)");
#line 317
      add_field_entry(& anchor, tmp___52, 12, def_mp3_enc_nf);
#line 319
      tmp___53 = gettext("MP3/Oggencoder on-fly (input from stdin)");
#line 319
      add_field_entry(& anchor, tmp___53, 13, def_mp3_enc_of);
#line 321
      tmp___54 = gettext("Program for setting MP3/OGG-ID-fields");
#line 321
      add_field_entry(& anchor, tmp___54, 14, def_mp3_info);
#line 323
      tmp___55 = gettext("MP3/OGG-comment");
#line 323
      add_field_entry(& anchor, tmp___55, 19, def_comment);
#line 325
      tmp___56 = gettext("String for unknown genre");
#line 325
      add_field_entry(& anchor, tmp___56, 38, def_unknown_gen);
      }
#line 327
      if (config_open_tray) {
        {
#line 328
        tmp___57 = gettext("yes");
#line 328
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___57);
        }
      } else {
        {
#line 330
        tmp___58 = gettext("no");
#line 330
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___58);
        }
      }
      {
#line 332
      tmp___59 = gettext("open tray after encoding?");
#line 332
      add_field_entry(& anchor, tmp___59, 36, mini_str);
#line 334
      sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%d",
              of_fifo_buf);
#line 335
      tmp___60 = gettext("Size of FIFO-buffer in KB (for on-fly encoding)");
#line 335
      add_field_entry(& anchor, tmp___60, 15, mini_str);
#line 337
      tmp___61 = gettext("Tempfile (for non-fly encoding)");
#line 337
      add_field_entry(& anchor, tmp___61, 16, def_tmp_file);
      }
#line 339
      if (del_tmp_on_exit == 0) {
        {
#line 339
        tmp___62 = gettext("never");
#line 339
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___62);
        }
      } else
#line 340
      if (del_tmp_on_exit == 1) {
        {
#line 340
        tmp___63 = gettext("only if delflag is set");
#line 340
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___63);
        }
      } else {
        {
#line 341
        tmp___64 = gettext("yes, ever");
#line 341
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___64);
        }
      }
      {
#line 342
      tmp___65 = gettext("Delete tempfiles on exit?");
#line 342
      add_field_entry(& anchor, tmp___65, 25, mini_str);
#line 344
      tmp___66 = gettext("Exportfile for ripped tracks");
#line 344
      add_field_entry(& anchor, tmp___66, 26, def_exp_file);
      }
#line 346
      if (clear_del_on_exp) {
        {
#line 346
        tmp___67 = gettext("yes");
#line 346
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___67);
        }
      } else {
        {
#line 347
        tmp___68 = gettext("no");
#line 347
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___68);
        }
      }
      {
#line 348
      tmp___69 = gettext("Clear delflag on export?");
#line 348
      add_field_entry(& anchor, tmp___69, 27, mini_str);
      }
#line 350
      if (config_para_mp3c) {
        {
#line 350
        tmp___70 = gettext("yes");
#line 350
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___70);
        }
      } else {
        {
#line 351
        tmp___71 = gettext("no");
#line 351
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___71);
        }
      }
      {
#line 352
      tmp___72 = gettext("Allow parallel running sessions of MP3c?");
#line 352
      add_field_entry(& anchor, tmp___72, 31, mini_str);
      }
#line 354
      if (config_curs_dir) {
        {
#line 354
        tmp___73 = gettext("yes");
#line 354
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___73);
        }
      } else {
        {
#line 355
        tmp___74 = gettext("no");
#line 355
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___74);
        }
      }
      {
#line 356
      tmp___75 = gettext("Use directory requester for selecting directories?");
#line 356
      add_field_entry(& anchor, tmp___75, 28, mini_str);
#line 358
      tmp___76 = gettext("Load defaults");
#line 358
      add_field_entry(& anchor, tmp___76, 122, (char *)((void *)0));
#line 360
      tmp___77 = gettext("Load Presets (OGG/oggenc)");
#line 360
      add_field_entry(& anchor, tmp___77, 123, (char *)((void *)0));
#line 361
      tmp___78 = gettext("Load Presets (MP3/lame)");
#line 361
      add_field_entry(& anchor, tmp___78, 124, (char *)((void *)0));
#line 363
      tmp___79 = gettext("Load Config");
#line 363
      add_field_entry(& anchor, tmp___79, 120, (char *)((void *)0));
#line 365
      tmp___80 = gettext("Save Config");
#line 365
      add_field_entry(& anchor, tmp___80, 121, (char *)((void *)0));
#line 367
      tmp___81 = gettext("Exit Optionmenu");
#line 367
      add_field_entry(& anchor, tmp___81, 125, (char *)((void *)0));
#line 369
      loaded_def = (unsigned char)0;
      }
    }
    {
#line 372
    tmp___82 = gettext("Optionmenu");
#line 372
    new = select_field_box(anchor, 150, tmp___82, use_old, (unsigned char)0);
#line 373
    use_old = (unsigned char)1;
    }
#line 374
    if (! new) {
#line 374
      goto while_break;
    }
#line 375
    if ((int )((unsigned char )*(new->information)) == 125) {
#line 375
      goto while_break;
    }
    {
#line 377
    if ((int )((unsigned char )*(new->information)) == 1) {
#line 377
      goto case_1;
    }
#line 389
    if ((int )((unsigned char )*(new->information)) == 2) {
#line 389
      goto case_2;
    }
#line 404
    if ((int )((unsigned char )*(new->information)) == 3) {
#line 404
      goto case_3;
    }
#line 414
    if ((int )((unsigned char )*(new->information)) == 4) {
#line 414
      goto case_4;
    }
#line 432
    if ((int )((unsigned char )*(new->information)) == 5) {
#line 432
      goto case_5;
    }
#line 446
    if ((int )((unsigned char )*(new->information)) == 6) {
#line 446
      goto case_6;
    }
#line 466
    if ((int )((unsigned char )*(new->information)) == 7) {
#line 466
      goto case_7;
    }
#line 479
    if ((int )((unsigned char )*(new->information)) == 8) {
#line 479
      goto case_8;
    }
#line 491
    if ((int )((unsigned char )*(new->information)) == 9) {
#line 491
      goto case_9;
    }
#line 510
    if ((int )((unsigned char )*(new->information)) == 10) {
#line 510
      goto case_10;
    }
#line 524
    if ((int )((unsigned char )*(new->information)) == 11) {
#line 524
      goto case_11;
    }
#line 537
    if ((int )((unsigned char )*(new->information)) == 12) {
#line 537
      goto case_12;
    }
#line 553
    if ((int )((unsigned char )*(new->information)) == 13) {
#line 553
      goto case_13;
    }
#line 569
    if ((int )((unsigned char )*(new->information)) == 14) {
#line 569
      goto case_14;
    }
#line 585
    if ((int )((unsigned char )*(new->information)) == 15) {
#line 585
      goto case_15;
    }
#line 600
    if ((int )((unsigned char )*(new->information)) == 16) {
#line 600
      goto case_16;
    }
#line 620
    if ((int )((unsigned char )*(new->information)) == 17) {
#line 620
      goto case_17;
    }
#line 634
    if ((int )((unsigned char )*(new->information)) == 18) {
#line 634
      goto case_18;
    }
#line 661
    if ((int )((unsigned char )*(new->information)) == 19) {
#line 661
      goto case_19;
    }
#line 678
    if ((int )((unsigned char )*(new->information)) == 20) {
#line 678
      goto case_20;
    }
#line 700
    if ((int )((unsigned char )*(new->information)) == 21) {
#line 700
      goto case_21;
    }
#line 711
    if ((int )((unsigned char )*(new->information)) == 22) {
#line 711
      goto case_22;
    }
#line 722
    if ((int )((unsigned char )*(new->information)) == 23) {
#line 722
      goto case_23;
    }
#line 740
    if ((int )((unsigned char )*(new->information)) == 24) {
#line 740
      goto case_24;
    }
#line 751
    if ((int )((unsigned char )*(new->information)) == 25) {
#line 751
      goto case_25;
    }
#line 771
    if ((int )((unsigned char )*(new->information)) == 26) {
#line 771
      goto case_26;
    }
#line 789
    if ((int )((unsigned char )*(new->information)) == 27) {
#line 789
      goto case_27;
    }
#line 800
    if ((int )((unsigned char )*(new->information)) == 28) {
#line 800
      goto case_28;
    }
#line 811
    if ((int )((unsigned char )*(new->information)) == 29) {
#line 811
      goto case_29;
    }
#line 835
    if ((int )((unsigned char )*(new->information)) == 30) {
#line 835
      goto case_30;
    }
#line 846
    if ((int )((unsigned char )*(new->information)) == 31) {
#line 846
      goto case_31;
    }
#line 857
    if ((int )((unsigned char )*(new->information)) == 32) {
#line 857
      goto case_32;
    }
#line 881
    if ((int )((unsigned char )*(new->information)) == 33) {
#line 881
      goto case_33;
    }
#line 894
    if ((int )((unsigned char )*(new->information)) == 34) {
#line 894
      goto case_34;
    }
#line 907
    if ((int )((unsigned char )*(new->information)) == 35) {
#line 907
      goto case_35;
    }
#line 919
    if ((int )((unsigned char )*(new->information)) == 36) {
#line 919
      goto case_36;
    }
#line 930
    if ((int )((unsigned char )*(new->information)) == 37) {
#line 930
      goto case_37;
    }
#line 941
    if ((int )((unsigned char )*(new->information)) == 38) {
#line 941
      goto case_38;
    }
#line 950
    if ((int )((unsigned char )*(new->information)) == 39) {
#line 950
      goto case_39;
    }
#line 964
    if ((int )((unsigned char )*(new->information)) == 40) {
#line 964
      goto case_40;
    }
#line 978
    if ((int )((unsigned char )*(new->information)) == 41) {
#line 978
      goto case_41;
    }
#line 990
    if ((int )((unsigned char )*(new->information)) == 42) {
#line 990
      goto case_42;
    }
#line 1008
    if ((int )((unsigned char )*(new->information)) == 120) {
#line 1008
      goto case_120;
    }
#line 1018
    if ((int )((unsigned char )*(new->information)) == 121) {
#line 1018
      goto case_121;
    }
#line 1022
    if ((int )((unsigned char )*(new->information)) == 122) {
#line 1022
      goto case_122;
    }
#line 1032
    if ((int )((unsigned char )*(new->information)) == 123) {
#line 1032
      goto case_123;
    }
#line 1053
    if ((int )((unsigned char )*(new->information)) == 124) {
#line 1053
      goto case_124;
    }
#line 376
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 378
    tmp___83 = gettext("enter cdrom device");
#line 378
    pointer = input_line(16, def_cdrom_dev, tmp___83, (unsigned char)1);
    }
#line 379
    if (pointer) {
#line 380
      external_cdrom_dev = (char *)((void *)0);
#line 381
      if (def_cdrom_dev) {
        {
#line 381
        free((void *)def_cdrom_dev);
        }
      }
      {
#line 382
      def_cdrom_dev = file_glob_in_name(pointer);
#line 383
      reinit_cddev = (unsigned char)1;
#line 384
      check_config();
#line 385
      reb_field_entry(new, (char *)((void *)0), def_cdrom_dev);
      }
    }
#line 387
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 390
    tmp___84 = gettext("note: cddb.com is not longer usable!");
#line 390
    tmp___85 = gettext("a comma, eg. \"freedb.freedb.org:8880,cddb.cddb.com:8880\"");
#line 390
    tmp___86 = gettext("you can input more servers, by seperating them with");
#line 390
    tmp___87 = gettext("enter CDDB-server [host:port] (0 to disable)");
#line 390
    pointer = input_line2(16, def_cddb_server, tmp___87, tmp___86, tmp___85, tmp___84,
                          (char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
                          (unsigned char)1);
    }
#line 396
    if (pointer) {
#line 397
      if (def_cddb_server) {
        {
#line 397
        free((void *)def_cddb_server);
        }
      }
      {
#line 398
      def_cddb_server = pointer;
#line 399
      check_config();
#line 400
      reb_field_entry(new, (char *)((void *)0), def_cddb_server);
      }
    }
#line 402
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 405
    tmp___88 = gettext("select CDDB base directory");
#line 405
    pointer = req_get_dir((char const   *)def_cddb_bank, (char const   *)tmp___88);
    }
#line 406
    if (pointer) {
#line 407
      if (def_cddb_bank) {
        {
#line 407
        free((void *)def_cddb_bank);
        }
      }
      {
#line 408
      def_cddb_bank = pointer;
#line 409
      check_config();
#line 410
      reb_field_entry(new, (char *)((void *)0), def_cddb_bank);
      }
    }
#line 412
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 415
    tmp___89 = gettext("select MP3/OGG destination directory");
#line 415
    pointer = req_get_dir((char const   *)def_mp3_dir, (char const   *)tmp___89);
    }
#line 416
    if (pointer) {
#line 417
      if (def_mp3_dir) {
        {
#line 417
        free((void *)def_mp3_dir);
        }
      }
      {
#line 418
      def_mp3_dir = pointer;
#line 419
      reb_filenm();
#line 420
      check_config();
      }
#line 421
      if (def_m3u_dir) {
        {
#line 421
        tmp___90 = strcmp((char const   *)def_m3u_dir, "0");
        }
#line 421
        if (tmp___90 == 0) {
          {
#line 422
          free_field_select(& anchor);
#line 423
          anchor = (field_select_typ *)((void *)0);
#line 424
          loaded_def = (unsigned char)1;
#line 425
          use_old = (unsigned char)0;
          }
        } else {
          {
#line 427
          reb_field_entry(new, (char *)((void *)0), def_mp3_dir);
          }
        }
      } else {
        {
#line 427
        reb_field_entry(new, (char *)((void *)0), def_mp3_dir);
        }
      }
    }
#line 430
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 433
    tmp___91 = gettext("%8: CDDB-ID");
#line 433
    tmp___92 = gettext("%6: Track, %7: Track with leading zeros");
#line 433
    tmp___93 = gettext("%4: Genre, %5: Year");
#line 433
    tmp___94 = gettext("%3: Albumname");
#line 433
    tmp___95 = gettext("%2: Songtitle");
#line 433
    tmp___96 = gettext("%1: Artistname");
#line 433
    tmp___97 = gettext("Enter pattern for filename creation");
#line 433
    pointer = input_line2(16, fn_pattern, tmp___97, tmp___96, tmp___95, tmp___94,
                          tmp___93, tmp___92, tmp___91, (unsigned char)1);
    }
#line 437
    if (pointer) {
#line 438
      if (fn_pattern) {
        {
#line 438
        free((void *)fn_pattern);
        }
      }
      {
#line 439
      fn_pattern = pointer;
#line 440
      reb_filenm();
#line 441
      check_config();
#line 442
      reb_field_entry(new, (char *)((void *)0), fn_pattern);
      }
    }
#line 444
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 447
    sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%d",
            fn_mode);
#line 448
    tmp___98 = gettext("2: every space will be killed");
#line 448
    tmp___99 = gettext("1: Spaces will be converted to specified character");
#line 448
    tmp___100 = gettext("0: Spaces in filename allowed");
#line 448
    tmp___101 = gettext("Enter pattern mode (0, 1 or 2)");
#line 448
    pointer = input_line2(16, mini_str, tmp___101, tmp___100, tmp___99, tmp___98,
                          (char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
                          (unsigned char)1);
    }
#line 453
    if (pointer) {
      {
#line 454
      tmp___102 = strlen((char const   *)pointer);
      }
#line 454
      if (tmp___102 == 1U) {
        {
#line 455
        fn_mode = atoi((char const   *)pointer);
        }
#line 456
        if (fn_mode < 0) {
#line 456
          fn_mode = 1;
        } else
#line 456
        if (fn_mode > 2) {
#line 456
          fn_mode = 1;
        }
        {
#line 457
        reb_filenm();
#line 458
        check_config();
#line 459
        sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%d",
                fn_mode);
#line 460
        reb_field_entry(new, (char *)((void *)0), mini_str);
        }
      }
      {
#line 462
      free((void *)pointer);
      }
    }
#line 464
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 467
    tmp___105 = gettext("Convert first letter in filename toupper?");
#line 467
    tmp___106 = select_yesno_box(tmp___105);
    }
#line 467
    if (tmp___106) {
      {
#line 468
      fn_toupper = (unsigned char)1;
#line 469
      tmp___103 = gettext("on");
#line 469
      strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___103);
      }
    } else {
      {
#line 471
      fn_toupper = (unsigned char)0;
#line 472
      tmp___104 = gettext("off");
#line 472
      strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___104);
      }
    }
    {
#line 474
    reb_field_entry(new, (char *)((void *)0), mini_str);
#line 475
    reb_filenm();
#line 476
    check_config();
    }
#line 477
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 480
    tmp___109 = gettext("Save Config on exit?");
#line 480
    tmp___110 = select_yesno_box(tmp___109);
    }
#line 480
    if (tmp___110) {
      {
#line 481
      auto_save = 1;
#line 482
      tmp___107 = gettext("on");
#line 482
      strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___107);
      }
    } else {
      {
#line 484
      auto_save = 0;
#line 485
      tmp___108 = gettext("off");
#line 485
      strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___108);
      }
    }
    {
#line 487
    reb_field_entry(new, (char *)((void *)0), mini_str);
#line 488
    check_config();
    }
#line 489
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 492
    sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%d",
            (int )config_fancy_colors);
#line 493
    tmp___111 = gettext("2: Yes, everytime");
#line 493
    tmp___112 = gettext("1: Sometimes");
#line 493
    tmp___113 = gettext("0: Never");
#line 493
    tmp___114 = gettext("Show fancy colors in windows (0, 1 or 2)");
#line 493
    pointer = input_line2(16, mini_str, tmp___114, tmp___113, tmp___112, tmp___111,
                          (char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
                          (unsigned char)1);
    }
#line 498
    if (pointer) {
      {
#line 499
      tmp___116 = strlen((char const   *)pointer);
      }
#line 499
      if (tmp___116 == 1U) {
        {
#line 500
        tmp___115 = atoi((char const   *)pointer);
#line 500
        config_fancy_colors = (signed char )tmp___115;
        }
#line 501
        if ((int )config_fancy_colors < 0) {
#line 501
          config_fancy_colors = (signed char)1;
        } else
#line 501
        if ((int )config_fancy_colors > 2) {
#line 501
          config_fancy_colors = (signed char)1;
        }
        {
#line 502
        check_config();
#line 503
        sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%d",
                (int )config_fancy_colors);
#line 504
        reb_field_entry(new, (char *)((void *)0), mini_str);
        }
      }
      {
#line 506
      free((void *)pointer);
      }
    }
#line 508
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 511
    tmp___117 = gettext("%3: outputfile");
#line 511
    tmp___118 = gettext("%2: track (numeric)");
#line 511
    tmp___119 = gettext("%1: cdrom device");
#line 511
    tmp___120 = gettext("Program for ripping audiocds with output to file");
#line 511
    pointer = input_line2(16, def_cd_rip_nf, tmp___120, tmp___119, tmp___118, tmp___117,
                          (char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
                          (unsigned char)1);
    }
#line 516
    if (pointer) {
#line 517
      if (def_cd_rip_nf) {
        {
#line 517
        free((void *)def_cd_rip_nf);
        }
      }
      {
#line 518
      def_cd_rip_nf = file_glob_in_name(pointer);
#line 519
      check_config();
#line 520
      reb_field_entry(new, (char *)((void *)0), def_cd_rip_nf);
      }
    }
#line 522
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 525
    tmp___121 = gettext("%2: track (numeric)");
#line 525
    tmp___122 = gettext("%1: cdrom device");
#line 525
    tmp___123 = gettext("Program for ripping audiocds with output to stdout");
#line 525
    pointer = input_line2(16, def_cd_rip_of, tmp___123, tmp___122, tmp___121, (char *)((void *)0),
                          (char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
                          (unsigned char)1);
    }
#line 529
    if (pointer) {
#line 530
      if (def_cd_rip_of) {
        {
#line 530
        free((void *)def_cd_rip_of);
        }
      }
      {
#line 531
      def_cd_rip_of = file_glob_in_name(pointer);
#line 532
      check_config();
#line 533
      reb_field_entry(new, (char *)((void *)0), def_cd_rip_of);
      }
    }
#line 535
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 538
    tmp___124 = gettext("%c: artist, %d: title");
#line 538
    tmp___125 = gettext("%a: track, %b: track (with leading zeros)");
#line 538
    tmp___126 = gettext("%6: comment, %7: filename, %8: genre by name");
#line 538
    tmp___127 = gettext("%3: album, %4: genre by number, %5: year");
#line 538
    tmp___128 = gettext("%1: inputfile, %2: outputfile");
#line 538
    tmp___129 = gettext("Program for encoding wav->mp3/ogg (input from file)");
#line 538
    pointer = input_line2(16, def_mp3_enc_nf, tmp___129, tmp___128, tmp___127, tmp___126,
                          tmp___125, tmp___124, (char *)((void *)0), (unsigned char)1);
    }
#line 545
    if (pointer) {
#line 546
      if (def_mp3_enc_nf) {
        {
#line 546
        free((void *)def_mp3_enc_nf);
        }
      }
      {
#line 547
      def_mp3_enc_nf = file_glob_in_name(pointer);
#line 548
      check_config();
#line 549
      reb_field_entry(new, (char *)((void *)0), def_mp3_enc_nf);
      }
    }
#line 551
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 554
    tmp___130 = gettext("%c: artist, %d: title");
#line 554
    tmp___131 = gettext("%a: track, %b: track (with leading zeros)");
#line 554
    tmp___132 = gettext("%6: comment, %7: filename, %8: genre by name");
#line 554
    tmp___133 = gettext("%3: album, %4: genre by number, %5: year");
#line 554
    tmp___134 = gettext("%1: outputfile");
#line 554
    tmp___135 = gettext("Program for encoding wav->mp3/ogg (input from stdin)");
#line 554
    pointer = input_line2(16, def_mp3_enc_of, tmp___135, tmp___134, tmp___133, tmp___132,
                          tmp___131, tmp___130, (char *)((void *)0), (unsigned char)1);
    }
#line 561
    if (pointer) {
#line 562
      if (def_mp3_enc_of) {
        {
#line 562
        free((void *)def_mp3_enc_of);
        }
      }
      {
#line 563
      def_mp3_enc_of = file_glob_in_name(pointer);
#line 564
      check_config();
#line 565
      reb_field_entry(new, (char *)((void *)0), def_mp3_enc_of);
      }
    }
#line 567
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 570
    tmp___136 = gettext("%a: tracknumber without, %b: with leading zeros");
#line 570
    tmp___137 = gettext("%7: Filename of MP3-file");
#line 570
    tmp___138 = gettext("%5: Year,  %6: Comment");
#line 570
    tmp___139 = gettext("%4: Genre (by number),  %8: Genre (by name)");
#line 570
    tmp___140 = gettext("%3: Albumname");
#line 570
    tmp___141 = gettext("%1: Artistname,  %2: Songtitle");
#line 570
    tmp___142 = gettext("Program for setting MP3/OGG ID-Fields (0 to disable)");
#line 570
    pointer = input_line2(16, def_mp3_info, tmp___142, tmp___141, tmp___140, tmp___139,
                          tmp___138, tmp___137, tmp___136, (unsigned char)1);
    }
#line 577
    if (pointer) {
#line 578
      if (def_mp3_info) {
        {
#line 578
        free((void *)def_mp3_info);
        }
      }
      {
#line 579
      def_mp3_info = file_glob_in_name(pointer);
#line 580
      check_config();
#line 581
      reb_field_entry(new, (char *)((void *)0), def_mp3_info);
      }
    }
#line 583
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 586
    sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%d",
            of_fifo_buf);
#line 587
    tmp___143 = gettext("size of FIFO-buffer in KB (for on-the-fly encoding) [16 - 8192]");
#line 587
    pointer = input_line(16, mini_str, tmp___143, (unsigned char)1);
    }
#line 588
    if (pointer) {
      {
#line 589
      tmp___144 = strlen((char const   *)pointer);
      }
#line 589
      if (tmp___144 > 1U) {
        {
#line 589
        tmp___145 = strlen((char const   *)pointer);
        }
#line 589
        if (tmp___145 < 5U) {
          {
#line 590
          of_fifo_buf = atoi((char const   *)pointer);
          }
#line 591
          if (of_fifo_buf < 16) {
#line 591
            of_fifo_buf = 512;
          } else
#line 591
          if (of_fifo_buf > 8192) {
#line 591
            of_fifo_buf = 512;
          }
          {
#line 592
          check_config();
#line 593
          sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%d",
                  of_fifo_buf);
#line 594
          reb_field_entry(new, (char *)((void *)0), mini_str);
          }
        }
      }
      {
#line 596
      free((void *)pointer);
      }
    }
#line 598
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 601
    tmp___146 = gettext("select tempfile name");
#line 601
    pointer = req_get_file((char const   *)def_tmp_file, (char const   *)tmp___146);
    }
#line 602
    if (pointer) {
#line 603
      if (def_tmp_file) {
        {
#line 603
        free((void *)def_tmp_file);
        }
      }
      {
#line 604
      def_tmp_file = pointer;
#line 605
      tmp___149 = strlen((char const   *)def_tmp_file);
      }
#line 605
      if ((int )*(def_tmp_file + (tmp___149 - 1U)) == 47) {
        {
#line 606
        tmp___147 = strlen((char const   *)pointer);
#line 606
        tmp___148 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___147 + 17U)));
#line 606
        def_tmp_file = (char *)tmp___148;
        }
#line 607
        if (! def_tmp_file) {
          {
#line 608
          perror("malloc");
#line 609
          wuuush(1);
          }
        }
        {
#line 611
        sprintf((char */* __restrict  */)def_tmp_file, (char const   */* __restrict  */)"%sWSPse-MP3Creat",
                pointer);
#line 612
        free((void *)pointer);
        }
      }
      {
#line 614
      check_config();
#line 615
      def_tmp_file = file_glob_in_name(def_tmp_file);
#line 616
      reb_field_entry(new, (char *)((void *)0), def_tmp_file);
      }
    }
#line 618
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 621
    tmp___150 = gettext("%8: CDDB-ID");
#line 621
    tmp___151 = gettext("%6: Track, %7: Track with leading zeros");
#line 621
    tmp___152 = gettext("%4: Genre, %5: Year");
#line 621
    tmp___153 = gettext("%3: Albumname");
#line 621
    tmp___154 = gettext("%2: Songtitle");
#line 621
    tmp___155 = gettext("%1: Artistname");
#line 621
    tmp___156 = gettext("Enter pattern for playlist creation (0 to disable)");
#line 621
    pointer = input_line2(16, def_m3u_pattern, tmp___156, tmp___155, tmp___154, tmp___153,
                          tmp___152, tmp___151, tmp___150, (unsigned char)1);
    }
#line 626
    if (pointer) {
#line 627
      if (def_m3u_pattern) {
        {
#line 627
        free((void *)def_m3u_pattern);
        }
      }
      {
#line 628
      def_m3u_pattern = pointer;
#line 629
      check_config();
#line 630
      reb_field_entry(new, (char *)((void *)0), def_m3u_pattern);
      }
    }
#line 632
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 635
    tmp___161 = gettext("use mp3/ogg-dir for playlists?");
#line 635
    tmp___162 = select_yesno_box(tmp___161);
    }
#line 635
    if (tmp___162) {
#line 636
      if (def_m3u_dir) {
        {
#line 636
        free((void *)def_m3u_dir);
        }
      }
      {
#line 637
      tmp___157 = malloc((size_t )(sizeof(char ) * 2UL));
#line 637
      def_m3u_dir = (char *)tmp___157;
      }
#line 638
      if (! def_m3u_dir) {
        {
#line 639
        perror("malloc");
#line 640
        wuuush(1);
        }
      }
#line 642
      *def_m3u_dir = (char )'0';
#line 643
      *(def_m3u_dir + 1) = (char)0;
    } else {
#line 645
      if (def_m3u_dir) {
        {
#line 645
        tmp___160 = strcmp((char const   *)def_m3u_dir, "0");
        }
#line 645
        if (tmp___160 == 0) {
          {
#line 646
          tmp___158 = gettext("select directory for M3U playlists");
#line 646
          pointer = req_get_dir((char const   *)((void *)0), (char const   *)tmp___158);
          }
        } else {
          {
#line 648
          tmp___159 = gettext("select directory for M3U playlists");
#line 648
          pointer = req_get_dir((char const   *)def_m3u_dir, (char const   *)tmp___159);
          }
        }
      } else {
        {
#line 648
        tmp___159 = gettext("select directory for M3U playlists");
#line 648
        pointer = req_get_dir((char const   *)def_m3u_dir, (char const   *)tmp___159);
        }
      }
#line 649
      if (pointer) {
#line 650
        if (def_m3u_dir) {
          {
#line 650
          free((void *)def_m3u_dir);
          }
        }
#line 651
        def_m3u_dir = pointer;
      }
    }
    {
#line 654
    check_config();
    }
#line 655
    if (def_m3u_dir) {
      {
#line 655
      tmp___163 = strcmp((char const   *)def_m3u_dir, "0");
      }
#line 655
      if (tmp___163 == 0) {
        {
#line 656
        reb_field_entry(new, (char *)((void *)0), def_mp3_dir);
        }
      } else {
        {
#line 658
        reb_field_entry(new, (char *)((void *)0), def_m3u_dir);
        }
      }
    } else {
      {
#line 658
      reb_field_entry(new, (char *)((void *)0), def_m3u_dir);
      }
    }
#line 659
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 662
    tmp___164 = gettext("%i: Tracklen (minutes), %j: Tracklen (seconds), %9: CDDBID");
#line 662
    tmp___165 = gettext("%g: Encode-hour, %h: Encode-minute (not so useful ;-)");
#line 662
    tmp___166 = gettext("%e: Encode-weekday (3 letter), %f: Encode-month (3 letter)");
#line 662
    tmp___167 = gettext("%b: Encode-month, %c: Encode-year (2 digits), %d: Encode-year (4 dig)");
#line 662
    tmp___168 = gettext("%7: Track (leading zeros), %8: MP3c-Version, %a: Encode-day");
#line 662
    tmp___169 = gettext("%1: Artist, %2: Title, %3: Album, %4: Genre, %5: Year, %6: Track");
#line 662
    tmp___170 = gettext("Enter pattern for mp3/ogg-comment");
#line 662
    pointer = input_line2(16, def_comment, tmp___170, tmp___169, tmp___168, tmp___167,
                          tmp___166, tmp___165, tmp___164, (unsigned char)1);
    }
#line 669
    if (pointer) {
      {
#line 670
      change_comment(lay_global_anchor[0], def_comment, pointer);
#line 671
      change_comment(lay_global_anchor[1], def_comment, pointer);
      }
#line 672
      if (def_comment) {
        {
#line 672
        free((void *)def_comment);
        }
      }
      {
#line 673
      def_comment = pointer;
#line 674
      reb_field_entry(new, (char *)((void *)0), def_comment);
      }
    }
#line 676
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 679
    i = 0;
#line 680
    tmp___171 = gettext("would you like to use on-fly encoding as default?");
#line 680
    tmp___172 = select_yesno_box(tmp___171);
    }
#line 680
    if (tmp___172) {
#line 682
      if (! def_on_fly) {
#line 682
        i = 1;
      }
#line 683
      def_on_fly = (unsigned char)1;
    } else {
#line 685
      if (def_on_fly) {
#line 685
        i = 1;
      }
#line 686
      def_on_fly = (unsigned char)0;
    }
#line 688
    if (i) {
#line 688
      if (lay_global_anchor[0]) {
        {
#line 689
        tmp___173 = gettext("reset on-fly flag for your actual cd?");
#line 689
        tmp___174 = select_yesno_box(tmp___173);
        }
#line 689
        if (tmp___174) {
          {
#line 690
          change_onfly_flag(def_on_fly, lay_global_anchor[0]);
          }
        }
      }
    }
#line 693
    if (i) {
#line 694
      if (def_on_fly) {
        {
#line 694
        tmp___175 = gettext("yes");
#line 694
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___175);
        }
      } else {
        {
#line 695
        tmp___176 = gettext("no");
#line 695
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___176);
        }
      }
      {
#line 696
      reb_field_entry(new, (char *)((void *)0), mini_str);
      }
    }
#line 698
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 701
    tmp___177 = gettext("enter unallowed characters in filenames");
#line 701
    pointer = input_line(16, def_ill_chars, tmp___177, (unsigned char)1);
    }
#line 702
    if (pointer) {
#line 703
      if (def_ill_chars) {
        {
#line 703
        free((void *)def_ill_chars);
        }
      }
      {
#line 704
      def_ill_chars = pointer;
#line 705
      reb_filenm();
#line 706
      check_config();
#line 707
      reb_field_entry(new, (char *)((void *)0), def_ill_chars);
      }
    }
#line 709
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 712
    tmp___180 = gettext("allow more characters in CDDB and inputbox?");
#line 712
    tmp___181 = select_yesno_box(tmp___180);
    }
#line 712
    if (tmp___181) {
      {
#line 713
      eased_char_hand = (unsigned char)1;
#line 714
      tmp___178 = gettext("non-strict (8-bit Western)");
#line 714
      strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___178);
      }
    } else {
      {
#line 716
      eased_char_hand = (unsigned char)0;
#line 717
      tmp___179 = gettext("strict (7-bit ASCII)");
#line 717
      strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___179);
      }
    }
    {
#line 719
    reb_field_entry(new, (char *)((void *)0), mini_str);
    }
#line 720
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 723
    sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%c",
            (int )replace_slash_ch);
#line 724
    tmp___182 = gettext("character for replacing slashes (to avoid sensless dir-creation)");
#line 724
    pointer = input_line(16, mini_str, tmp___182, (unsigned char)1);
    }
#line 726
    if (pointer) {
      {
#line 727
      replace_slash_ch = *pointer;
#line 728
      tmp___185 = strlen((char const   *)pointer);
      }
#line 728
      if (tmp___185 < 1U) {
#line 728
        replace_slash_ch = (char )'-';
      } else {
        {
#line 729
        tmp___184 = strlen((char const   *)pointer);
        }
#line 729
        if (tmp___184 > 1U) {
          {
#line 730
          tmp___183 = gettext("too many chars, skipping trailing garbage");
#line 730
          popup_error_win(tmp___183);
          }
        }
      }
      {
#line 732
      free((void *)pointer);
#line 733
      reb_filenm();
#line 734
      check_config();
#line 735
      sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%c",
              (int )replace_slash_ch);
#line 736
      reb_field_entry(new, (char *)((void *)0), mini_str);
      }
    }
#line 738
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 741
    tmp___188 = gettext("rip all tracks at once before encoding?");
#line 741
    tmp___189 = select_yesno_box(tmp___188);
    }
#line 741
    if (tmp___189) {
      {
#line 742
      rip_enc_ordered = (unsigned char)1;
#line 743
      tmp___186 = gettext("yes");
#line 743
      strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___186);
      }
    } else {
      {
#line 745
      rip_enc_ordered = (unsigned char)0;
#line 746
      tmp___187 = gettext("no");
#line 746
      strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___187);
      }
    }
    {
#line 748
    reb_field_entry(new, (char *)((void *)0), mini_str);
    }
#line 749
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 752
    sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%d",
            del_tmp_on_exit);
#line 753
    tmp___190 = gettext("2: delete them all");
#line 753
    tmp___191 = gettext("1: delete all files with set delflag");
#line 753
    tmp___192 = gettext("0: leave them untouched");
#line 753
    tmp___193 = gettext("what to do with remaining tmpfiles on exit");
#line 753
    pointer = input_line2(16, mini_str, tmp___193, tmp___192, tmp___191, tmp___190,
                          (char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
                          (unsigned char)1);
    }
#line 758
    if (pointer) {
      {
#line 759
      tmp___197 = strlen((char const   *)pointer);
      }
#line 759
      if (tmp___197 == 1U) {
        {
#line 760
        del_tmp_on_exit = atoi((char const   *)pointer);
        }
#line 761
        if (del_tmp_on_exit < 0) {
#line 761
          del_tmp_on_exit = 1;
        } else
#line 761
        if (del_tmp_on_exit > 2) {
#line 761
          del_tmp_on_exit = 1;
        }
#line 762
        if (del_tmp_on_exit == 0) {
          {
#line 762
          tmp___194 = gettext("never");
#line 762
          strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___194);
          }
        } else
#line 763
        if (del_tmp_on_exit == 1) {
          {
#line 763
          tmp___195 = gettext("only if delflag is set");
#line 763
          strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___195);
          }
        } else {
          {
#line 764
          tmp___196 = gettext("yes, ever");
#line 764
          strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___196);
          }
        }
        {
#line 765
        reb_field_entry(new, (char *)((void *)0), mini_str);
        }
      }
      {
#line 767
      free((void *)pointer);
      }
    }
#line 769
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 772
    tmp___198 = gettext("select default exportfile for ripped tracks");
#line 772
    pointer = req_get_file((char const   *)def_exp_file, (char const   *)tmp___198);
    }
#line 773
    if (pointer) {
#line 774
      if (def_exp_file) {
        {
#line 774
        free((void *)def_exp_file);
        }
      }
      {
#line 775
      def_exp_file = pointer;
#line 776
      tmp___201 = strlen((char const   *)def_exp_file);
      }
#line 776
      if ((int )*(def_exp_file + (tmp___201 - 1U)) == 47) {
        {
#line 777
        tmp___199 = strlen((char const   *)def_exp_file);
#line 777
        tmp___200 = realloc((void *)def_exp_file, (size_t )(sizeof(char ) * (unsigned long )(tmp___199 + 15U)));
#line 777
        def_exp_file = (char *)tmp___200;
        }
#line 778
        if (! def_exp_file) {
          {
#line 779
          wuuush(1);
          }
        }
        {
#line 781
        strcat((char */* __restrict  */)def_exp_file, (char const   */* __restrict  */)".mp3c-exported");
        }
      }
      {
#line 783
      def_exp_file = file_glob_in_name(def_exp_file);
#line 784
      reb_field_entry(new, (char *)((void *)0), def_exp_file);
#line 785
      check_config();
      }
    }
#line 787
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 790
    tmp___204 = gettext("clear delflag on export?");
#line 790
    tmp___205 = select_yesno_box(tmp___204);
    }
#line 790
    if (tmp___205) {
      {
#line 791
      clear_del_on_exp = (unsigned char)1;
#line 792
      tmp___202 = gettext("yes");
#line 792
      strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___202);
      }
    } else {
      {
#line 794
      clear_del_on_exp = (unsigned char)0;
#line 795
      tmp___203 = gettext("no");
#line 795
      strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___203);
      }
    }
    {
#line 797
    reb_field_entry(new, (char *)((void *)0), mini_str);
    }
#line 798
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 801
    tmp___208 = gettext("use directory requester instead of inputbox for dir select?");
#line 801
    tmp___209 = select_yesno_box(tmp___208);
    }
#line 801
    if (tmp___209) {
      {
#line 802
      config_curs_dir = (unsigned char)1;
#line 803
      tmp___206 = gettext("yes");
#line 803
      strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___206);
      }
    } else {
      {
#line 805
      config_curs_dir = (unsigned char)0;
#line 806
      tmp___207 = gettext("no");
#line 806
      strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___207);
      }
    }
    {
#line 808
    reb_field_entry(new, (char *)((void *)0), mini_str);
    }
#line 809
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 812
    sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%d",
            def_m3u_rel_name);
#line 813
    tmp___210 = gettext("2: use a relative path to the playlist");
#line 813
    tmp___211 = gettext("1: use a relative path to m3u-maindir");
#line 813
    tmp___212 = gettext("0: use fullpath to mp3-file");
#line 813
    tmp___213 = gettext("How to create the filename for a playlist-entry");
#line 813
    pointer = input_line2(16, mini_str, tmp___213, tmp___212, tmp___211, tmp___210,
                          (char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
                          (unsigned char)1);
    }
#line 818
    if (pointer) {
      {
#line 819
      tmp___217 = strlen((char const   *)pointer);
      }
#line 819
      if (tmp___217 == 1U) {
        {
#line 820
        def_m3u_rel_name = atoi((char const   *)pointer);
        }
#line 821
        if (def_m3u_rel_name == 0) {
          {
#line 822
          tmp___214 = gettext("full path");
#line 822
          sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___214);
          }
        } else
#line 823
        if (def_m3u_rel_name == 1) {
          {
#line 824
          tmp___215 = gettext("relative to m3u-dir");
#line 824
          sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___215);
          }
        } else {
          {
#line 826
          def_m3u_rel_name = 2;
#line 827
          tmp___216 = gettext("relative to m3u-file");
#line 827
          sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___216);
          }
        }
        {
#line 829
        reb_field_entry(new, (char *)((void *)0), mini_str);
        }
      }
      {
#line 831
      free((void *)pointer);
      }
    }
#line 833
    goto switch_break;
    case_30: /* CIL Label */ 
    {
#line 836
    tmp___220 = gettext("allow remote CDDB access?");
#line 836
    tmp___221 = select_yesno_box(tmp___220);
    }
#line 836
    if (tmp___221) {
      {
#line 837
      config_cddb_enbl = (unsigned char)1;
#line 838
      tmp___218 = gettext("yes");
#line 838
      strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___218);
      }
    } else {
      {
#line 840
      config_cddb_enbl = (unsigned char)0;
#line 841
      tmp___219 = gettext("no");
#line 841
      strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___219);
      }
    }
    {
#line 843
    reb_field_entry(new, (char *)((void *)0), mini_str);
    }
#line 844
    goto switch_break;
    case_31: /* CIL Label */ 
    {
#line 847
    tmp___224 = gettext("allow parallel running MP3c sessions?");
#line 847
    tmp___225 = select_yesno_box(tmp___224);
    }
#line 847
    if (tmp___225) {
      {
#line 848
      config_para_mp3c = (unsigned char)1;
#line 849
      tmp___222 = gettext("yes");
#line 849
      strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___222);
      }
    } else {
      {
#line 851
      config_para_mp3c = (unsigned char)0;
#line 852
      tmp___223 = gettext("no");
#line 852
      strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___223);
      }
    }
    {
#line 854
    reb_field_entry(new, (char *)((void *)0), mini_str);
    }
#line 855
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 858
    sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%d",
            config_case_chg);
#line 859
    tmp___226 = gettext("if 1 and toupper is also set it will be converted to \"Artist\"");
#line 859
    tmp___227 = gettext("\"ArTiSt\" will be converted to \"artist\" if 1, to \"ARTIST\" if 2");
#line 859
    tmp___228 = gettext("2: convert all to upper case");
#line 859
    tmp___229 = gettext("1: convert all to lower case");
#line 859
    tmp___230 = gettext("0: leave case as it is");
#line 859
    tmp___231 = gettext("Enter mode for case changing (0, 1 or 2)");
#line 859
    pointer = input_line2(16, mini_str, tmp___231, tmp___230, tmp___229, tmp___228,
                          (char *)((void *)0), tmp___227, tmp___226, (unsigned char)1);
    }
#line 866
    if (pointer) {
      {
#line 867
      tmp___235 = strlen((char const   *)pointer);
      }
#line 867
      if (tmp___235 == 1U) {
        {
#line 868
        config_case_chg = atoi((char const   *)pointer);
        }
#line 869
        if (config_case_chg < 0) {
#line 869
          config_case_chg = 0;
        } else
#line 869
        if (config_case_chg > 2) {
#line 869
          config_case_chg = 0;
        }
        {
#line 870
        reb_filenm();
        }
#line 871
        if (config_case_chg == 0) {
          {
#line 871
          tmp___232 = gettext("no");
#line 871
          strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___232);
          }
        } else
#line 872
        if (config_case_chg == 1) {
          {
#line 872
          tmp___233 = gettext("to lower");
#line 872
          strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___233);
          }
        } else {
          {
#line 873
          tmp___234 = gettext("to upper");
#line 873
          strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___234);
          }
        }
        {
#line 874
        reb_field_entry(new, (char *)((void *)0), mini_str);
        }
      }
      {
#line 876
      free((void *)pointer);
#line 877
      pointer = (char *)((void *)0);
      }
    }
#line 879
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 882
    tmp___236 = gettext("at least \"freedb-submit@freedb.org\" should accept your entries");
#line 882
    tmp___237 = gettext("you can input more servers, by seperating them with a comma");
#line 882
    tmp___238 = gettext("enter CDDBs eMail address");
#line 882
    pointer = input_line2(16, def_cddb_email, tmp___238, tmp___237, (char *)((void *)0),
                          tmp___236, (char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
                          (unsigned char)1);
    }
#line 887
    if (pointer) {
#line 888
      if (def_cddb_email) {
        {
#line 888
        free((void *)def_cddb_email);
        }
      }
      {
#line 889
      def_cddb_email = pointer;
#line 890
      reb_field_entry(new, (char *)((void *)0), def_cddb_email);
      }
    }
#line 892
    goto switch_break;
    case_34: /* CIL Label */ 
    {
#line 895
    tmp___239 = gettext("\"localhost:smtp\".");
#line 895
    tmp___240 = gettext("if you have a local daemon running you can use");
#line 895
    tmp___241 = gettext("this server is used to relay your CDDB-entries via eMail");
#line 895
    tmp___242 = gettext("enter your relaying SMTP server [host:port]");
#line 895
    pointer = input_line2(16, def_smtp_server, tmp___242, tmp___241, tmp___240, tmp___239,
                          (char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
                          (unsigned char)1);
    }
#line 900
    if (pointer) {
#line 901
      if (def_smtp_server) {
        {
#line 901
        free((void *)def_smtp_server);
        }
      }
      {
#line 902
      def_smtp_server = pointer;
#line 903
      reb_field_entry(new, (char *)((void *)0), def_smtp_server);
      }
    }
#line 905
    goto switch_break;
    case_35: /* CIL Label */ 
    {
#line 908
    tmp___243 = gettext("might deny relaying.");
#line 908
    tmp___244 = gettext("please use the right address, otherwise your SMTP-server");
#line 908
    tmp___245 = gettext("enter your eMail address");
#line 908
    pointer = input_line2(16, def_my_email, tmp___245, tmp___244, tmp___243, (char *)((void *)0),
                          (char *)((void *)0), (char *)((void *)0), (char *)((void *)0),
                          (unsigned char)1);
    }
#line 912
    if (pointer) {
#line 913
      if (def_my_email) {
        {
#line 913
        free((void *)def_my_email);
        }
      }
      {
#line 914
      def_my_email = pointer;
#line 915
      reb_field_entry(new, (char *)((void *)0), def_my_email);
      }
    }
#line 917
    goto switch_break;
    case_36: /* CIL Label */ 
    {
#line 920
    tmp___248 = gettext("open tray after encoding?");
#line 920
    tmp___249 = select_yesno_box(tmp___248);
    }
#line 920
    if (tmp___249) {
      {
#line 921
      config_open_tray = (unsigned char)1;
#line 922
      tmp___246 = gettext("yes");
#line 922
      strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___246);
      }
    } else {
      {
#line 924
      config_open_tray = (unsigned char)0;
#line 925
      tmp___247 = gettext("no");
#line 925
      strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___247);
      }
    }
    {
#line 927
    reb_field_entry(new, (char *)((void *)0), mini_str);
    }
#line 928
    goto switch_break;
    case_37: /* CIL Label */ 
    {
#line 931
    tmp___252 = gettext("remove illegal characters (otherwise use patternmode)?");
#line 931
    tmp___253 = select_yesno_box(tmp___252);
    }
#line 931
    if (tmp___253) {
      {
#line 932
      config_ill_remove = (unsigned char)1;
#line 933
      tmp___250 = gettext("remove them");
#line 933
      strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___250);
      }
    } else {
      {
#line 935
      config_ill_remove = (unsigned char)0;
#line 936
      tmp___251 = gettext("use patternmode");
#line 936
      strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___251);
      }
    }
    {
#line 938
    reb_field_entry(new, (char *)((void *)0), mini_str);
    }
#line 939
    goto switch_break;
    case_38: /* CIL Label */ 
    {
#line 942
    tmp___254 = gettext("String for unknown genre");
#line 942
    pointer = input_line(16, def_unknown_gen, tmp___254, (unsigned char)1);
    }
#line 943
    if (pointer) {
#line 944
      if (def_unknown_gen) {
        {
#line 944
        free((void *)def_unknown_gen);
        }
      }
      {
#line 945
      def_unknown_gen = pointer;
#line 946
      reb_field_entry(new, (char *)((void *)0), def_unknown_gen);
      }
    }
#line 948
    goto switch_break;
    case_39: /* CIL Label */ 
    {
#line 951
    tmp___255 = gettext("%8: CDDB-ID");
#line 951
    tmp___256 = gettext("%6: Track, %7: Track with leading zeros");
#line 951
    tmp___257 = gettext("%4: Genre, %5: Year");
#line 951
    tmp___258 = gettext("%3: Albumname");
#line 951
    tmp___259 = gettext("%2: Songtitle");
#line 951
    tmp___260 = gettext("%1: Artistname");
#line 951
    tmp___261 = gettext("Enter pattern for filename creation (sampler cds)");
#line 951
    pointer = input_line2(16, fn_pattern_mix, tmp___261, tmp___260, tmp___259, tmp___258,
                          tmp___257, tmp___256, tmp___255, (unsigned char)1);
    }
#line 955
    if (pointer) {
#line 956
      if (fn_pattern_mix) {
        {
#line 956
        free((void *)fn_pattern_mix);
        }
      }
      {
#line 957
      fn_pattern_mix = pointer;
#line 958
      reb_filenm();
#line 959
      check_config();
#line 960
      reb_field_entry(new, (char *)((void *)0), fn_pattern_mix);
      }
    }
#line 962
    goto switch_break;
    case_40: /* CIL Label */ 
    {
#line 965
    tmp___262 = gettext("%8: CDDB-ID");
#line 965
    tmp___263 = gettext("%6: Track, %7: Track with leading zeros");
#line 965
    tmp___264 = gettext("%4: Genre, %5: Year");
#line 965
    tmp___265 = gettext("%3: Albumname");
#line 965
    tmp___266 = gettext("%2: Songtitle");
#line 965
    tmp___267 = gettext("%1: Artistname");
#line 965
    tmp___268 = gettext("Enter pattern for playlist creation, sampler cds (0 to disable)");
#line 965
    pointer = input_line2(16, def_m3u_patmix, tmp___268, tmp___267, tmp___266, tmp___265,
                          tmp___264, tmp___263, tmp___262, (unsigned char)1);
    }
#line 970
    if (pointer) {
#line 971
      if (def_m3u_patmix) {
        {
#line 971
        free((void *)def_m3u_patmix);
        }
      }
      {
#line 972
      def_m3u_patmix = pointer;
#line 973
      check_config();
#line 974
      reb_field_entry(new, (char *)((void *)0), def_m3u_patmix);
      }
    }
#line 976
    goto switch_break;
    case_41: /* CIL Label */ 
    {
#line 979
    tmp___271 = gettext("Protect patternmasks from substitutions?");
#line 979
    tmp___272 = select_yesno_box(tmp___271);
    }
#line 979
    if (tmp___272) {
      {
#line 980
      config_pat_prot = (unsigned char)1;
#line 981
      tmp___269 = gettext("yes");
#line 981
      strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___269);
      }
    } else {
      {
#line 983
      config_pat_prot = (unsigned char)0;
#line 984
      tmp___270 = gettext("no");
#line 984
      strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___270);
      }
    }
    {
#line 986
    reb_field_entry(new, (char *)((void *)0), mini_str);
#line 987
    reb_filenm();
    }
#line 988
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 991
    sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%c",
            (int )replace_space_ch);
#line 992
    tmp___273 = gettext("character for replacing spaces");
#line 992
    pointer = input_line(16, mini_str, tmp___273, (unsigned char)1);
    }
#line 994
    if (pointer) {
      {
#line 995
      replace_space_ch = *pointer;
#line 996
      tmp___276 = strlen((char const   *)pointer);
      }
#line 996
      if (tmp___276 < 1U) {
#line 996
        replace_space_ch = (char )'-';
      } else {
        {
#line 997
        tmp___275 = strlen((char const   *)pointer);
        }
#line 997
        if (tmp___275 > 1U) {
          {
#line 998
          tmp___274 = gettext("too many chars, skipping trailing garbage");
#line 998
          popup_error_win(tmp___274);
          }
        }
      }
      {
#line 1000
      free((void *)pointer);
#line 1001
      reb_filenm();
#line 1002
      check_config();
#line 1003
      sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%c",
              (int )replace_space_ch);
#line 1004
      reb_field_entry(new, (char *)((void *)0), mini_str);
      }
    }
#line 1006
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 1009
    get_config(external_config_file);
#line 1010
    check_config();
#line 1011
    reinit_cddev = (unsigned char)1;
#line 1012
    free_field_select(& anchor);
#line 1013
    anchor = (field_select_typ *)((void *)0);
#line 1014
    loaded_def = (unsigned char)1;
#line 1015
    use_old = (unsigned char)0;
    }
#line 1016
    goto switch_break;
    case_121: /* CIL Label */ 
    {
#line 1019
    put_config(external_config_file, (unsigned char)1);
    }
#line 1020
    goto switch_break;
    case_122: /* CIL Label */ 
    {
#line 1023
    init_config();
#line 1024
    check_config();
#line 1025
    reinit_cddev = (unsigned char)1;
#line 1026
    free_field_select(& anchor);
#line 1027
    anchor = (field_select_typ *)((void *)0);
#line 1028
    loaded_def = (unsigned char)1;
#line 1029
    use_old = (unsigned char)0;
    }
#line 1030
    goto switch_break;
    case_123: /* CIL Label */ 
#line 1034
    if (fn_pattern) {
      {
#line 1034
      free((void *)fn_pattern);
      }
    }
#line 1035
    if (fn_pattern_mix) {
      {
#line 1035
      free((void *)fn_pattern_mix);
      }
    }
#line 1036
    if (def_mp3_enc_nf) {
      {
#line 1036
      free((void *)def_mp3_enc_nf);
      }
    }
#line 1037
    if (def_mp3_enc_of) {
      {
#line 1037
      free((void *)def_mp3_enc_of);
      }
    }
#line 1038
    if (def_mp3_info) {
      {
#line 1038
      free((void *)def_mp3_info);
      }
    }
    {
#line 1040
    fn_pattern = copy_char_str((char *)"%7-%8.ogg");
#line 1041
    fn_pattern_mix = copy_char_str((char *)"%3/%1-%2.ogg");
#line 1042
    tmp___277 = copy_char_str((char *)"oggenc -b 192 -l \"%3\" -d \"%5\" -c \"%6\" -N \"%a\" -a \"%c\" -t \"%d\" -o \"%2\" \"%1\"");
#line 1042
    def_mp3_enc_nf = file_glob_in_name(tmp___277);
#line 1043
    tmp___278 = copy_char_str((char *)"oggenc -b 192 -l \"%3\" -d \"%5\" -c \"%6\" -N \"%a\" -a \"%c\" -t \"%d\" -o \"%2\" -");
#line 1043
    def_mp3_enc_of = file_glob_in_name(tmp___278);
#line 1044
    tmp___279 = copy_char_str((char *)"0");
#line 1044
    def_mp3_info = file_glob_in_name(tmp___279);
#line 1046
    check_config();
#line 1047
    free_field_select(& anchor);
#line 1048
    anchor = (field_select_typ *)((void *)0);
#line 1049
    loaded_def = (unsigned char)1;
#line 1050
    use_old = (unsigned char)0;
    }
#line 1051
    goto switch_break;
    case_124: /* CIL Label */ 
#line 1055
    if (fn_pattern) {
      {
#line 1055
      free((void *)fn_pattern);
      }
    }
#line 1056
    if (fn_pattern_mix) {
      {
#line 1056
      free((void *)fn_pattern_mix);
      }
    }
#line 1057
    if (def_mp3_enc_nf) {
      {
#line 1057
      free((void *)def_mp3_enc_nf);
      }
    }
#line 1058
    if (def_mp3_enc_of) {
      {
#line 1058
      free((void *)def_mp3_enc_of);
      }
    }
#line 1059
    if (def_mp3_info) {
      {
#line 1059
      free((void *)def_mp3_info);
      }
    }
    {
#line 1061
    fn_pattern = copy_char_str((char *)"%7-%8.mp3");
#line 1062
    fn_pattern_mix = copy_char_str((char *)"%3/%1-%2.mp3");
#line 1063
    tmp___280 = copy_char_str((char *)"lame --preset standard --tt \"%d\" --ta \"%c\" --tl \"%3\" --ty \"%5\" --tc \"%6\" --tn \"%a\" --tg \"%4\" \"%1\" \"%2\"");
#line 1063
    def_mp3_enc_nf = file_glob_in_name(tmp___280);
#line 1064
    tmp___281 = copy_char_str((char *)"lame --preset standard --tt \"%d\" --ta \"%c\" --tl \"%3\" --ty \"%5\" --tc \"%6\" --tn \"%a\" --tg \"%4\" - \"%1\"");
#line 1064
    def_mp3_enc_of = file_glob_in_name(tmp___281);
#line 1065
    tmp___282 = copy_char_str((char *)"0");
#line 1065
    def_mp3_info = file_glob_in_name(tmp___282);
#line 1067
    check_config();
#line 1068
    free_field_select(& anchor);
#line 1069
    anchor = (field_select_typ *)((void *)0);
#line 1070
    loaded_def = (unsigned char)1;
#line 1071
    use_old = (unsigned char)0;
    }
#line 1072
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1076
  free_field_select(& anchor);
  }
#line 1077
  if (reinit_cddev) {
    {
#line 1078
    reinit_volume(win);
    }
  }
#line 1080
  return;
}
}
#line 1082 "/home/wslee/benchmarks/sound/mp3c-0.29/src/options.c"
void change_comment(song_typ *anchor , char *old , char *new ) 
{ 
  song_typ *curr ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp9 ;

  {
#line 1086
  curr = anchor;
  {
#line 1087
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1087
    if (! curr) {
#line 1087
      goto while_break;
    }
#line 1088
    if (curr->comment) {
#line 1088
      if (old) {
        {
#line 1088
        tmp___2 = strcmp((char const   *)curr->comment, (char const   *)old);
        }
#line 1088
        if (! (tmp___2 != 0)) {
#line 1088
          goto _L___0;
        }
      } else {
#line 1088
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1089
      if (curr->comment) {
        {
#line 1089
        free((void *)curr->comment);
        }
      }
      {
#line 1090
      tmp = strlen((char const   *)new);
#line 1090
      tmp___0 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp + 1U)));
#line 1090
      curr->comment = (char *)tmp___0;
      }
#line 1091
      if (! curr->comment) {
        {
#line 1092
        perror("malloc");
#line 1093
        wuuush(1);
        }
      }
      {
#line 1095
      tmp___1 = strlen((char const   *)new);
#line 1095
      memcpy((void */* __restrict  */)curr->comment, (void const   */* __restrict  */)new,
             tmp___1 + 1U);
      }
    }
#line 1097
    curr = curr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1099
  return;
}
}
#line 1101 "/home/wslee/benchmarks/sound/mp3c-0.29/src/options.c"
void change_onfly_flag(unsigned char new_val , song_typ *anchor ) 
{ 
  song_typ *curr ;

  {
#line 1105
  curr = anchor;
  {
#line 1106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1106
    if (! curr) {
#line 1106
      goto while_break;
    }
#line 1107
    curr->on_fly = new_val;
#line 1108
    curr = curr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1110
  return;
}
}
#line 1112 "/home/wslee/benchmarks/sound/mp3c-0.29/src/options.c"
void alter_track_infos_menu(song_typ *track ) 
{ 
  field_select_typ *new ;
  field_select_typ *anchor ;
  song_typ song_chg_fields ;
  song_typ *song_curr ;
  char *pointer ;
  char mini_str[35] ;
  int i ;
  unsigned char use_old ;
  unsigned char loaded_def ;
  unsigned char yesno_flag ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  size_t tmp___34 ;
  void *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  size_t tmp___38 ;
  void *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  size_t tmp___42 ;
  void *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  char *tmp___59 ;
  size_t tmp___60 ;
  void *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;
  char *tmp___69 ;
  char *tmp___70 ;
  char *tmp___71 ;
  char *tmp___72 ;
  char *tmp___73 ;
  char *tmp___74 ;
  char *tmp___75 ;
  char *tmp___76 ;
  char *tmp___77 ;
  char *tmp___78 ;
  char *tmp___79 ;
  char *tmp___80 ;
  char *tmp___81 ;
  size_t tmp___82 ;
  char *tmp___83 ;
  char *tmp___84 ;
  char *tmp___85 ;
  char *tmp___86 ;
  char *tmp___87 ;
  char *tmp___88 ;
  char *tmp___89 ;
  char *tmp___90 ;
  char *tmp___91 ;
  char *tmp___92 ;
  char *tmp___93 ;
  char *tmp___94 ;
  char *tmp___95 ;
  char *tmp___96 ;
  char *tmp___97 ;
  char *tmp___98 ;
  char *tmp___99 ;
  char *tmp___100 ;
  char *tmp___101 ;
  char *tmp___102 ;
  char *tmp___103 ;
  char *tmp___104 ;
  char *tmp___105 ;
  char *tmp___106 ;
  char *tmp___107 ;
  char *tmp___108 ;
  char *tmp___109 ;
  char *tmp___110 ;
  size_t tmp___111 ;
  void *tmp___112 ;
  size_t tmp___113 ;
  void *tmp___114 ;
  size_t tmp___115 ;
  void *tmp___116 ;
  size_t tmp___117 ;
  void *tmp___118 ;
  size_t tmp___119 ;
  void *tmp___120 ;
  size_t tmp___121 ;
  void *tmp___122 ;
  size_t tmp___123 ;
  void *tmp___124 ;
  size_t tmp___125 ;
  void *tmp___126 ;
  void *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;
  char *__cil_tmp214 ;
  char *__cil_tmp215 ;
  char *__cil_tmp216 ;
  char *__cil_tmp217 ;
  char *__cil_tmp218 ;
  char *__cil_tmp219 ;
  char *__cil_tmp220 ;
  char *__cil_tmp221 ;
  char *__cil_tmp222 ;
  char *__cil_tmp223 ;
  char *__cil_tmp224 ;
  char *__cil_tmp225 ;
  char *__cil_tmp226 ;
  char *__cil_tmp227 ;
  char *__cil_tmp228 ;
  char *__cil_tmp229 ;
  char *__cil_tmp230 ;
  char *__cil_tmp231 ;
  char *__cil_tmp232 ;
  char *__cil_tmp233 ;
  char *__cil_tmp234 ;
  char *__cil_tmp235 ;
  char *__cil_tmp236 ;
  char *__cil_tmp237 ;
  char *__cil_tmp238 ;
  char *__cil_tmp239 ;
  char *__cil_tmp240 ;
  char *__cil_tmp241 ;
  char *__cil_tmp242 ;
  char *__cil_tmp243 ;
  char *__cil_tmp244 ;
  char *__cil_tmp245 ;
  char *__cil_tmp246 ;
  char *__cil_tmp247 ;
  char *__cil_tmp248 ;
  char *__cil_tmp249 ;
  char *__cil_tmp250 ;
  char *__cil_tmp251 ;
  char *__cil_tmp252 ;
  char *__cil_tmp253 ;
  char *__cil_tmp254 ;
  char *__cil_tmp255 ;
  char *__cil_tmp256 ;
  char *__cil_tmp257 ;
  char *__cil_tmp258 ;

  {
#line 1123
  anchor = (field_select_typ *)((void *)0);
#line 1124
  use_old = (unsigned char)0;
#line 1125
  loaded_def = (unsigned char)1;
#line 1127
  song_chg_fields.artist = (char *)((void *)0);
#line 1128
  song_chg_fields.title = (char *)((void *)0);
#line 1129
  song_chg_fields.album = (char *)((void *)0);
#line 1130
  song_chg_fields.comment = (char *)((void *)0);
#line 1131
  song_chg_fields.year = -1;
#line 1132
  song_chg_fields.genre = -1;
#line 1133
  song_chg_fields.toc = (char)0;
#line 1134
  song_chg_fields.fn_auto = (unsigned char)0;
  {
#line 1136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1137
    if (loaded_def) {
#line 1139
      if (song_chg_fields.artist) {
        {
#line 1140
        tmp = gettext("[*] Artist");
#line 1140
        add_field_entry(& anchor, tmp, 1, song_chg_fields.artist);
        }
      } else {
        {
#line 1142
        tmp___0 = gettext("[ ] Artist");
#line 1142
        add_field_entry(& anchor, tmp___0, 1, track->artist);
        }
      }
#line 1144
      if (song_chg_fields.title) {
        {
#line 1145
        tmp___1 = gettext("[*] Title");
#line 1145
        add_field_entry(& anchor, tmp___1, 2, song_chg_fields.title);
        }
      } else {
        {
#line 1147
        tmp___2 = gettext("[ ] Title");
#line 1147
        add_field_entry(& anchor, tmp___2, 2, track->title);
        }
      }
#line 1149
      if (song_chg_fields.album) {
        {
#line 1150
        tmp___3 = gettext("[*] Album");
#line 1150
        add_field_entry(& anchor, tmp___3, 3, song_chg_fields.album);
        }
      } else {
        {
#line 1152
        tmp___4 = gettext("[ ] Album");
#line 1152
        add_field_entry(& anchor, tmp___4, 3, track->album);
        }
      }
#line 1154
      if (song_chg_fields.year != -1) {
        {
#line 1155
        sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%4d",
                song_chg_fields.year);
#line 1156
        tmp___5 = gettext("[*] Year");
#line 1156
        add_field_entry(& anchor, tmp___5, 4, mini_str);
        }
      } else {
        {
#line 1158
        sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%4d",
                track->year);
#line 1159
        tmp___6 = gettext("[ ] Year");
#line 1159
        add_field_entry(& anchor, tmp___6, 4, mini_str);
        }
      }
#line 1162
      if (song_chg_fields.genre != -1) {
#line 1163
        if (song_chg_fields.genre != 147) {
#line 1163
          tmp___7 = mp3_genre[song_chg_fields.genre];
        } else {
#line 1163
          tmp___7 = def_unknown_gen;
        }
        {
#line 1163
        tmp___8 = gettext("[*] Genre");
#line 1163
        add_field_entry(& anchor, tmp___8, 5, tmp___7);
        }
      } else {
#line 1167
        if (track->genre != 147) {
#line 1167
          tmp___9 = mp3_genre[track->genre];
        } else {
#line 1167
          tmp___9 = def_unknown_gen;
        }
        {
#line 1167
        tmp___10 = gettext("[ ] Genre");
#line 1167
        add_field_entry(& anchor, tmp___10, 5, tmp___9);
        }
      }
#line 1171
      if (song_chg_fields.comment) {
        {
#line 1172
        tmp___11 = gettext("[*] Comment");
#line 1172
        add_field_entry(& anchor, tmp___11, 7, song_chg_fields.comment);
        }
      } else {
        {
#line 1174
        tmp___12 = gettext("[ ] Comment");
#line 1174
        add_field_entry(& anchor, tmp___12, 7, track->comment);
        }
      }
#line 1176
      if ((int )song_chg_fields.toc != 0) {
#line 1177
        if (song_chg_fields.on_fly) {
          {
#line 1177
          tmp___13 = gettext("YES");
#line 1177
          strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___13);
          }
        } else {
          {
#line 1178
          tmp___14 = gettext("NO");
#line 1178
          strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___14);
          }
        }
#line 1179
        if (lay_act_side == 0) {
          {
#line 1179
          tmp___15 = gettext("[*] Onfly convert");
#line 1179
          add_field_entry(& anchor, tmp___15, 6, mini_str);
          }
        } else {
          {
#line 1180
          tmp___16 = gettext("[*] Delete after enc");
#line 1180
          add_field_entry(& anchor, tmp___16, 6, mini_str);
          }
        }
      } else {
#line 1182
        if (track->on_fly) {
          {
#line 1182
          tmp___17 = gettext("YES");
#line 1182
          strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___17);
          }
        } else {
          {
#line 1183
          tmp___18 = gettext("NO");
#line 1183
          strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___18);
          }
        }
#line 1184
        if (lay_act_side == 0) {
          {
#line 1184
          tmp___19 = gettext("[ ] Onfly convert");
#line 1184
          add_field_entry(& anchor, tmp___19, 6, mini_str);
          }
        } else {
          {
#line 1185
          tmp___20 = gettext("[ ] Delete after enc");
#line 1185
          add_field_entry(& anchor, tmp___20, 6, mini_str);
          }
        }
      }
#line 1188
      if (song_chg_fields.fn_auto) {
#line 1189
        if (song_chg_fields.sampler) {
          {
#line 1189
          tmp___21 = gettext("YES");
#line 1189
          strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___21);
          }
        } else {
          {
#line 1190
          tmp___22 = gettext("NO");
#line 1190
          strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___22);
          }
        }
        {
#line 1191
        tmp___23 = gettext("[*] Sampler CD");
#line 1191
        add_field_entry(& anchor, tmp___23, 8, mini_str);
        }
      } else {
#line 1193
        if (track->sampler) {
          {
#line 1193
          tmp___24 = gettext("YES");
#line 1193
          strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___24);
          }
        } else {
          {
#line 1194
          tmp___25 = gettext("NO");
#line 1194
          strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___25);
          }
        }
        {
#line 1195
        tmp___26 = gettext("[ ] Sampler CD");
#line 1195
        add_field_entry(& anchor, tmp___26, 8, mini_str);
        }
      }
      {
#line 1198
      tmp___27 = gettext("Reload original values");
#line 1198
      add_field_entry(& anchor, tmp___27, 120, (char *)((void *)0));
#line 1199
      tmp___28 = gettext("Set values for this track");
#line 1199
      add_field_entry(& anchor, tmp___28, 121, (char *)((void *)0));
#line 1200
      tmp___29 = gettext("Set values for all marked tracks");
#line 1200
      add_field_entry(& anchor, tmp___29, 122, (char *)((void *)0));
#line 1201
      tmp___30 = gettext("Set values for ALL tracks");
#line 1201
      add_field_entry(& anchor, tmp___30, 123, (char *)((void *)0));
#line 1202
      tmp___31 = gettext("Exit");
#line 1202
      add_field_entry(& anchor, tmp___31, 125, (char *)((void *)0));
#line 1204
      loaded_def = (unsigned char)0;
      }
    }
    {
#line 1207
    tmp___32 = gettext("Alter informations for track %d");
#line 1207
    sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___32,
            (int )track->toc + 1);
#line 1208
    new = select_field_box(anchor, 150, mini_str, use_old, (unsigned char)1);
#line 1209
    use_old = (unsigned char)1;
    }
#line 1211
    if (! new) {
#line 1211
      goto while_break;
    }
#line 1212
    if (sb_pressed_key == 32) {
      {
#line 1214
      if ((int )((unsigned char )*(new->information)) == 1) {
#line 1214
        goto case_1;
      }
#line 1230
      if ((int )((unsigned char )*(new->information)) == 2) {
#line 1230
        goto case_2;
      }
#line 1246
      if ((int )((unsigned char )*(new->information)) == 3) {
#line 1246
        goto case_3;
      }
#line 1262
      if ((int )((unsigned char )*(new->information)) == 4) {
#line 1262
        goto case_4;
      }
#line 1274
      if ((int )((unsigned char )*(new->information)) == 5) {
#line 1274
        goto case_5;
      }
#line 1288
      if ((int )((unsigned char )*(new->information)) == 6) {
#line 1288
        goto case_6;
      }
#line 1305
      if ((int )((unsigned char )*(new->information)) == 7) {
#line 1305
        goto case_7;
      }
#line 1321
      if ((int )((unsigned char )*(new->information)) == 8) {
#line 1321
        goto case_8;
      }
#line 1213
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1215
      if (song_chg_fields.artist) {
        {
#line 1216
        free((void *)song_chg_fields.artist);
#line 1217
        song_chg_fields.artist = (char *)((void *)0);
#line 1218
        tmp___33 = gettext("[ ] Artist");
#line 1218
        reb_field_entry(new, tmp___33, track->artist);
        }
      } else {
        {
#line 1220
        tmp___34 = strlen((char const   *)track->artist);
#line 1220
        tmp___35 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___34 + 1U)));
#line 1220
        song_chg_fields.artist = (char *)tmp___35;
        }
#line 1221
        if (! song_chg_fields.artist) {
          {
#line 1222
          perror("malloc");
#line 1223
          wuuush(1);
          }
        }
        {
#line 1225
        strcpy((char */* __restrict  */)song_chg_fields.artist, (char const   */* __restrict  */)track->artist);
#line 1226
        tmp___36 = gettext("[*] Artist");
#line 1226
        reb_field_entry(new, tmp___36, song_chg_fields.artist);
        }
      }
#line 1228
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1231
      if (song_chg_fields.title) {
        {
#line 1232
        free((void *)song_chg_fields.title);
#line 1233
        song_chg_fields.title = (char *)((void *)0);
#line 1234
        tmp___37 = gettext("[ ] Title");
#line 1234
        reb_field_entry(new, tmp___37, track->title);
        }
      } else {
        {
#line 1236
        tmp___38 = strlen((char const   *)track->title);
#line 1236
        tmp___39 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___38 + 1U)));
#line 1236
        song_chg_fields.title = (char *)tmp___39;
        }
#line 1237
        if (! song_chg_fields.title) {
          {
#line 1238
          perror("malloc");
#line 1239
          wuuush(1);
          }
        }
        {
#line 1241
        strcpy((char */* __restrict  */)song_chg_fields.title, (char const   */* __restrict  */)track->title);
#line 1242
        tmp___40 = gettext("[*] Title");
#line 1242
        reb_field_entry(new, tmp___40, song_chg_fields.title);
        }
      }
#line 1244
      goto switch_break;
      case_3: /* CIL Label */ 
#line 1247
      if (song_chg_fields.album) {
        {
#line 1248
        free((void *)song_chg_fields.album);
#line 1249
        song_chg_fields.album = (char *)((void *)0);
#line 1250
        tmp___41 = gettext("[ ] Album");
#line 1250
        reb_field_entry(new, tmp___41, track->album);
        }
      } else {
        {
#line 1252
        tmp___42 = strlen((char const   *)track->album);
#line 1252
        tmp___43 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___42 + 1U)));
#line 1252
        song_chg_fields.album = (char *)tmp___43;
        }
#line 1253
        if (! song_chg_fields.album) {
          {
#line 1254
          perror("malloc");
#line 1255
          wuuush(1);
          }
        }
        {
#line 1257
        strcpy((char */* __restrict  */)song_chg_fields.album, (char const   */* __restrict  */)track->album);
#line 1258
        tmp___44 = gettext("[*] Album");
#line 1258
        reb_field_entry(new, tmp___44, song_chg_fields.album);
        }
      }
#line 1260
      goto switch_break;
      case_4: /* CIL Label */ 
#line 1263
      if (song_chg_fields.year != -1) {
        {
#line 1264
        song_chg_fields.year = -1;
#line 1265
        sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%4d",
                track->year);
#line 1266
        tmp___45 = gettext("[ ] Year");
#line 1266
        reb_field_entry(new, tmp___45, mini_str);
        }
      } else {
        {
#line 1268
        song_chg_fields.year = track->year;
#line 1269
        sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%4d",
                song_chg_fields.year);
#line 1270
        tmp___46 = gettext("[*] Year");
#line 1270
        reb_field_entry(new, tmp___46, mini_str);
        }
      }
#line 1272
      goto switch_break;
      case_5: /* CIL Label */ 
#line 1275
      if (song_chg_fields.genre != -1) {
#line 1276
        song_chg_fields.genre = -1;
#line 1277
        if (track->genre != 147) {
#line 1277
          tmp___47 = mp3_genre[track->genre];
        } else {
#line 1277
          tmp___47 = def_unknown_gen;
        }
        {
#line 1277
        tmp___48 = gettext("[ ] Genre");
#line 1277
        reb_field_entry(new, tmp___48, tmp___47);
        }
      } else {
#line 1281
        song_chg_fields.genre = track->genre;
#line 1282
        if (song_chg_fields.genre != 147) {
#line 1282
          tmp___49 = mp3_genre[song_chg_fields.genre];
        } else {
#line 1282
          tmp___49 = def_unknown_gen;
        }
        {
#line 1282
        tmp___50 = gettext("[*] Genre");
#line 1282
        reb_field_entry(new, tmp___50, tmp___49);
        }
      }
#line 1286
      goto switch_break;
      case_6: /* CIL Label */ 
#line 1289
      if ((int )song_chg_fields.toc != 0) {
#line 1290
        song_chg_fields.toc = (char)0;
#line 1291
        if (track->on_fly) {
          {
#line 1291
          tmp___51 = gettext("YES");
#line 1291
          strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___51);
          }
        } else {
          {
#line 1292
          tmp___52 = gettext("NO");
#line 1292
          strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___52);
          }
        }
#line 1293
        if (lay_act_side == 0) {
          {
#line 1293
          tmp___53 = gettext("[ ] Onfly convert");
#line 1293
          reb_field_entry(new, tmp___53, mini_str);
          }
        } else {
          {
#line 1294
          tmp___54 = gettext("[ ] Delete after enc");
#line 1294
          reb_field_entry(new, tmp___54, mini_str);
          }
        }
      } else {
#line 1296
        song_chg_fields.toc = (char)1;
#line 1297
        song_chg_fields.on_fly = track->on_fly;
#line 1298
        if (song_chg_fields.on_fly) {
          {
#line 1298
          tmp___55 = gettext("YES");
#line 1298
          strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___55);
          }
        } else {
          {
#line 1299
          tmp___56 = gettext("NO");
#line 1299
          strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___56);
          }
        }
#line 1300
        if (lay_act_side == 0) {
          {
#line 1300
          tmp___57 = gettext("[*] Onfly convert");
#line 1300
          reb_field_entry(new, tmp___57, mini_str);
          }
        } else {
          {
#line 1301
          tmp___58 = gettext("[*] Delete after enc");
#line 1301
          reb_field_entry(new, tmp___58, mini_str);
          }
        }
      }
#line 1303
      goto switch_break;
      case_7: /* CIL Label */ 
#line 1306
      if (song_chg_fields.comment) {
        {
#line 1307
        free((void *)song_chg_fields.comment);
#line 1308
        song_chg_fields.comment = (char *)((void *)0);
#line 1309
        tmp___59 = gettext("[ ] Comment");
#line 1309
        reb_field_entry(new, tmp___59, track->comment);
        }
      } else {
        {
#line 1311
        tmp___60 = strlen((char const   *)track->comment);
#line 1311
        tmp___61 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___60 + 1U)));
#line 1311
        song_chg_fields.comment = (char *)tmp___61;
        }
#line 1312
        if (! song_chg_fields.comment) {
          {
#line 1313
          perror("malloc");
#line 1314
          wuuush(1);
          }
        }
        {
#line 1316
        strcpy((char */* __restrict  */)song_chg_fields.comment, (char const   */* __restrict  */)track->comment);
#line 1317
        tmp___62 = gettext("[*] Comment");
#line 1317
        reb_field_entry(new, tmp___62, song_chg_fields.comment);
        }
      }
#line 1319
      goto switch_break;
      case_8: /* CIL Label */ 
#line 1322
      if (song_chg_fields.fn_auto) {
#line 1323
        song_chg_fields.fn_auto = (unsigned char)0;
#line 1324
        if (track->sampler) {
          {
#line 1324
          tmp___63 = gettext("YES");
#line 1324
          strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___63);
          }
        } else {
          {
#line 1325
          tmp___64 = gettext("NO");
#line 1325
          strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___64);
          }
        }
        {
#line 1326
        tmp___65 = gettext("[ ] Sampler CD");
#line 1326
        reb_field_entry(new, tmp___65, mini_str);
        }
      } else {
#line 1328
        song_chg_fields.fn_auto = (unsigned char)1;
#line 1329
        song_chg_fields.sampler = track->sampler;
#line 1330
        if (song_chg_fields.sampler) {
          {
#line 1330
          tmp___66 = gettext("YES");
#line 1330
          strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___66);
          }
        } else {
          {
#line 1331
          tmp___67 = gettext("NO");
#line 1331
          strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___67);
          }
        }
        {
#line 1332
        tmp___68 = gettext("[*] Sampler CD");
#line 1332
        reb_field_entry(new, tmp___68, mini_str);
        }
      }
#line 1334
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 1337
      if ((int )((unsigned char )*(new->information)) == 125) {
#line 1337
        goto while_break;
      }
      {
#line 1339
      if ((int )((unsigned char )*(new->information)) == 1) {
#line 1339
        goto case_1___0;
      }
#line 1353
      if ((int )((unsigned char )*(new->information)) == 2) {
#line 1353
        goto case_2___0;
      }
#line 1367
      if ((int )((unsigned char )*(new->information)) == 3) {
#line 1367
        goto case_3___0;
      }
#line 1381
      if ((int )((unsigned char )*(new->information)) == 4) {
#line 1381
        goto case_4___0;
      }
#line 1399
      if ((int )((unsigned char )*(new->information)) == 5) {
#line 1399
        goto case_5___0;
      }
#line 1409
      if ((int )((unsigned char )*(new->information)) == 6) {
#line 1409
        goto case_6___0;
      }
#line 1424
      if ((int )((unsigned char )*(new->information)) == 7) {
#line 1424
        goto case_7___0;
      }
#line 1450
      if ((int )((unsigned char )*(new->information)) == 8) {
#line 1450
        goto case_8___0;
      }
#line 1463
      if ((int )((unsigned char )*(new->information)) == 120) {
#line 1463
        goto case_120;
      }
#line 1482
      if ((int )((unsigned char )*(new->information)) == 121) {
#line 1482
        goto case_121;
      }
#line 1514
      if ((int )((unsigned char )*(new->information)) == 122) {
#line 1514
        goto case_122;
      }
#line 1580
      if ((int )((unsigned char )*(new->information)) == 123) {
#line 1580
        goto case_123;
      }
#line 1338
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1340
      if (song_chg_fields.artist) {
        {
#line 1341
        tmp___69 = gettext("Input artistname");
#line 1341
        pointer = input_line(16, song_chg_fields.artist, tmp___69, (unsigned char)1);
        }
      } else {
        {
#line 1343
        tmp___70 = gettext("Input artistname");
#line 1343
        pointer = input_line(16, track->artist, tmp___70, (unsigned char)1);
        }
      }
#line 1345
      if (song_chg_fields.artist) {
        {
#line 1345
        free((void *)song_chg_fields.artist);
        }
      }
#line 1346
      song_chg_fields.artist = pointer;
#line 1347
      if (pointer) {
        {
#line 1348
        tmp___71 = gettext("[*] Artist");
#line 1348
        reb_field_entry(new, tmp___71, pointer);
        }
      } else {
        {
#line 1350
        tmp___72 = gettext("[ ] Artist");
#line 1350
        reb_field_entry(new, tmp___72, pointer);
        }
      }
#line 1351
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 1354
      if (song_chg_fields.title) {
        {
#line 1355
        tmp___73 = gettext("Input songtitle");
#line 1355
        pointer = input_line(16, song_chg_fields.title, tmp___73, (unsigned char)1);
        }
      } else {
        {
#line 1357
        tmp___74 = gettext("Input songtitle");
#line 1357
        pointer = input_line(16, track->title, tmp___74, (unsigned char)1);
        }
      }
#line 1359
      if (song_chg_fields.title) {
        {
#line 1359
        free((void *)song_chg_fields.title);
        }
      }
#line 1360
      song_chg_fields.title = pointer;
#line 1361
      if (pointer) {
        {
#line 1362
        tmp___75 = gettext("[*] Title");
#line 1362
        reb_field_entry(new, tmp___75, pointer);
        }
      } else {
        {
#line 1364
        tmp___76 = gettext("[ ] Title");
#line 1364
        reb_field_entry(new, tmp___76, pointer);
        }
      }
#line 1365
      goto switch_break___0;
      case_3___0: /* CIL Label */ 
#line 1368
      if (song_chg_fields.album) {
        {
#line 1369
        tmp___77 = gettext("Input albumname");
#line 1369
        pointer = input_line(16, song_chg_fields.album, tmp___77, (unsigned char)1);
        }
      } else {
        {
#line 1371
        tmp___78 = gettext("Input albumname");
#line 1371
        pointer = input_line(16, track->album, tmp___78, (unsigned char)1);
        }
      }
#line 1373
      if (song_chg_fields.album) {
        {
#line 1373
        free((void *)song_chg_fields.album);
        }
      }
#line 1374
      song_chg_fields.album = pointer;
#line 1375
      if (pointer) {
        {
#line 1376
        tmp___79 = gettext("[*] Album");
#line 1376
        reb_field_entry(new, tmp___79, pointer);
        }
      } else {
        {
#line 1378
        reb_field_entry(new, (char *)"[ ] Album", pointer);
        }
      }
#line 1379
      goto switch_break___0;
      case_4___0: /* CIL Label */ 
#line 1382
      if (song_chg_fields.year != -1) {
        {
#line 1383
        sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%4d",
                song_chg_fields.year);
        }
      } else {
        {
#line 1385
        sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%4d",
                track->year);
        }
      }
      {
#line 1387
      tmp___80 = gettext("Input year");
#line 1387
      pointer = input_line(16, mini_str, tmp___80, (unsigned char)1);
      }
#line 1388
      if (pointer) {
        {
#line 1388
        tmp___82 = strlen((char const   *)pointer);
        }
#line 1388
        if (tmp___82 <= 4U) {
          {
#line 1389
          song_chg_fields.year = atoi((char const   *)pointer);
          }
#line 1390
          if (song_chg_fields.year < 0) {
#line 1391
            song_chg_fields.year = 1999;
          } else
#line 1390
          if (song_chg_fields.year > 9999) {
#line 1391
            song_chg_fields.year = 1999;
          }
          {
#line 1392
          sprintf((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)"%4d",
                  song_chg_fields.year);
#line 1393
          tmp___81 = gettext("[*] Year");
#line 1393
          reb_field_entry(new, tmp___81, pointer);
          }
        }
      }
#line 1396
      if (pointer) {
        {
#line 1396
        free((void *)pointer);
        }
      }
#line 1397
      goto switch_break___0;
      case_5___0: /* CIL Label */ 
      {
#line 1400
      i = select_genre();
      }
#line 1401
      if (i != -1) {
#line 1402
        song_chg_fields.genre = i;
#line 1403
        if (i != 147) {
#line 1403
          tmp___83 = mp3_genre[i];
        } else {
#line 1403
          tmp___83 = def_unknown_gen;
        }
        {
#line 1403
        tmp___84 = gettext("[*] Genre");
#line 1403
        reb_field_entry(new, tmp___84, tmp___83);
        }
      }
#line 1406
      use_old = (unsigned char)0;
#line 1407
      goto switch_break___0;
      case_6___0: /* CIL Label */ 
#line 1410
      if (lay_act_side == 0) {
        {
#line 1410
        tmp___85 = gettext("onfly encoding?");
#line 1410
        yesno_flag = select_yesno_box(tmp___85);
        }
      } else {
        {
#line 1411
        tmp___86 = gettext("delete after encoding?");
#line 1411
        yesno_flag = select_yesno_box(tmp___86);
        }
      }
#line 1412
      if (yesno_flag) {
        {
#line 1413
        song_chg_fields.on_fly = (unsigned char)1;
#line 1414
        tmp___87 = gettext("YES");
#line 1414
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___87);
        }
      } else {
        {
#line 1416
        song_chg_fields.on_fly = (unsigned char)0;
#line 1417
        tmp___88 = gettext("NO");
#line 1417
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___88);
        }
      }
#line 1419
      song_chg_fields.toc = (char)1;
#line 1420
      if (lay_act_side == 0) {
        {
#line 1420
        tmp___89 = gettext("[*] Onfly convert");
#line 1420
        reb_field_entry(new, tmp___89, mini_str);
        }
      } else {
        {
#line 1421
        tmp___90 = gettext("[*] Delete after enc");
#line 1421
        reb_field_entry(new, tmp___90, mini_str);
        }
      }
#line 1422
      goto switch_break___0;
      case_7___0: /* CIL Label */ 
#line 1425
      if (song_chg_fields.comment) {
        {
#line 1426
        tmp___91 = gettext("%i: Tracklen (minutes), %j: Tracklen (seconds), %9: CDDBID");
#line 1426
        tmp___92 = gettext("%g: Encode-hour, %h: Encode-minute (not so useful ;-)");
#line 1426
        tmp___93 = gettext("%e: Encode-weekday (3 letter), %f: Encode-month (3 letter)");
#line 1426
        tmp___94 = gettext("%b: Encode-month, %c: Encode-year (2 digits), %d: Encode-year (4 dig)");
#line 1426
        tmp___95 = gettext("%7: Track (leading zeros), %8: MP3c-Version, %a: Encode-day");
#line 1426
        tmp___96 = gettext("%1: Artist, %2: Title, %3: Album, %4: Genre, %5: Year, %6: Track");
#line 1426
        tmp___97 = gettext("Input comment pattern");
#line 1426
        pointer = input_line2(16, song_chg_fields.comment, tmp___97, tmp___96, tmp___95,
                              tmp___94, tmp___93, tmp___92, tmp___91, (unsigned char)1);
        }
      } else {
        {
#line 1434
        tmp___98 = gettext("%i: Tracklen (minutes), %j: Tracklen (seconds), %9: CDDBID");
#line 1434
        tmp___99 = gettext("%g: Encode-hour, %h: Encode-minute (not so useful ;-)");
#line 1434
        tmp___100 = gettext("%e: Encode-weekday (3 letter), %f: Encode-month (3 letter)");
#line 1434
        tmp___101 = gettext("%b: Encode-month, %c: Encode-year (2 digits), %d: Encode-year (4 dig)");
#line 1434
        tmp___102 = gettext("%7: Track (leading zeros), %8: MP3c-Version, %a: Encode-day");
#line 1434
        tmp___103 = gettext("%1: Artist, %2: Title, %3: Album, %4: Genre, %5: Year, %6: Track");
#line 1434
        tmp___104 = gettext("Input comment pattern");
#line 1434
        pointer = input_line2(16, track->comment, tmp___104, tmp___103, tmp___102,
                              tmp___101, tmp___100, tmp___99, tmp___98, (unsigned char)1);
        }
      }
#line 1442
      if (song_chg_fields.comment) {
        {
#line 1442
        free((void *)song_chg_fields.comment);
        }
      }
#line 1443
      song_chg_fields.comment = pointer;
#line 1444
      if (song_chg_fields.comment) {
        {
#line 1445
        tmp___105 = gettext("[*] Comment");
#line 1445
        reb_field_entry(new, tmp___105, song_chg_fields.comment);
        }
      } else {
        {
#line 1447
        tmp___106 = gettext("[ ] Comment");
#line 1447
        reb_field_entry(new, tmp___106, track->comment);
        }
      }
#line 1448
      goto switch_break___0;
      case_8___0: /* CIL Label */ 
      {
#line 1451
      tmp___107 = gettext("sampler cd?");
#line 1451
      yesno_flag = select_yesno_box(tmp___107);
      }
#line 1452
      if (yesno_flag) {
        {
#line 1453
        song_chg_fields.sampler = (unsigned char)1;
#line 1454
        tmp___108 = gettext("YES");
#line 1454
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___108);
        }
      } else {
        {
#line 1456
        song_chg_fields.sampler = (unsigned char)0;
#line 1457
        tmp___109 = gettext("NO");
#line 1457
        strcpy((char */* __restrict  */)(mini_str), (char const   */* __restrict  */)tmp___109);
        }
      }
      {
#line 1459
      song_chg_fields.fn_auto = (unsigned char)1;
#line 1460
      tmp___110 = gettext("[*] Sampler CD");
#line 1460
      reb_field_entry(new, tmp___110, mini_str);
      }
#line 1461
      goto switch_break___0;
      case_120: /* CIL Label */ 
#line 1464
      if (song_chg_fields.artist) {
        {
#line 1464
        free((void *)song_chg_fields.artist);
        }
      }
#line 1465
      song_chg_fields.artist = (char *)((void *)0);
#line 1466
      if (song_chg_fields.title) {
        {
#line 1466
        free((void *)song_chg_fields.title);
        }
      }
#line 1467
      song_chg_fields.title = (char *)((void *)0);
#line 1468
      if (song_chg_fields.album) {
        {
#line 1468
        free((void *)song_chg_fields.album);
        }
      }
#line 1469
      song_chg_fields.album = (char *)((void *)0);
#line 1470
      if (song_chg_fields.comment) {
        {
#line 1470
        free((void *)song_chg_fields.comment);
        }
      }
      {
#line 1471
      song_chg_fields.comment = (char *)((void *)0);
#line 1472
      song_chg_fields.year = -1;
#line 1473
      song_chg_fields.genre = -1;
#line 1474
      song_chg_fields.toc = (char)0;
#line 1475
      song_chg_fields.fn_auto = (unsigned char)0;
#line 1476
      free_field_select(& anchor);
#line 1477
      anchor = (field_select_typ *)((void *)0);
#line 1478
      loaded_def = (unsigned char)1;
#line 1479
      use_old = (unsigned char)0;
      }
#line 1480
      goto switch_break___0;
      case_121: /* CIL Label */ 
#line 1483
      if (song_chg_fields.artist) {
#line 1484
        if (track->artist) {
          {
#line 1484
          free((void *)track->artist);
          }
        }
#line 1485
        track->artist = song_chg_fields.artist;
#line 1486
        song_chg_fields.artist = (char *)((void *)0);
      }
#line 1488
      if (song_chg_fields.title) {
#line 1489
        if (track->title) {
          {
#line 1489
          free((void *)track->title);
          }
        }
#line 1490
        track->title = song_chg_fields.title;
#line 1491
        song_chg_fields.title = (char *)((void *)0);
      }
#line 1493
      if (song_chg_fields.album) {
#line 1494
        if (track->album) {
          {
#line 1494
          free((void *)track->album);
          }
        }
#line 1495
        track->album = song_chg_fields.album;
#line 1496
        song_chg_fields.album = (char *)((void *)0);
      }
#line 1498
      if (song_chg_fields.comment) {
#line 1499
        if (track->comment) {
          {
#line 1499
          free((void *)track->comment);
          }
        }
#line 1500
        track->comment = song_chg_fields.comment;
#line 1501
        song_chg_fields.comment = (char *)((void *)0);
      }
#line 1503
      if (song_chg_fields.year != -1) {
#line 1503
        track->year = song_chg_fields.year;
      }
#line 1504
      if (song_chg_fields.genre != -1) {
#line 1504
        track->genre = song_chg_fields.genre;
      }
#line 1505
      if ((int )song_chg_fields.toc != 0) {
#line 1505
        track->on_fly = song_chg_fields.on_fly;
      }
#line 1506
      if (song_chg_fields.fn_auto) {
#line 1506
        track->sampler = song_chg_fields.sampler;
      }
      {
#line 1507
      filenm_generate(track);
#line 1508
      free_field_select(& anchor);
#line 1509
      anchor = (field_select_typ *)((void *)0);
#line 1510
      loaded_def = (unsigned char)1;
#line 1511
      use_old = (unsigned char)0;
      }
#line 1512
      goto switch_break___0;
      case_122: /* CIL Label */ 
#line 1515
      song_curr = lay_global_anchor[lay_act_side];
      {
#line 1516
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1516
        if (! song_curr) {
#line 1516
          goto while_break___0;
        }
#line 1517
        if (song_curr->convert) {
#line 1518
          if (song_chg_fields.artist) {
#line 1519
            if (song_curr->artist) {
              {
#line 1519
              free((void *)song_curr->artist);
              }
            }
            {
#line 1520
            tmp___111 = strlen((char const   *)song_chg_fields.artist);
#line 1520
            tmp___112 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___111 + 1U)));
#line 1520
            song_curr->artist = (char *)tmp___112;
            }
#line 1521
            if (! song_curr->artist) {
              {
#line 1522
              perror("malloc");
#line 1523
              wuuush(1);
              }
            }
            {
#line 1525
            strcpy((char */* __restrict  */)song_curr->artist, (char const   */* __restrict  */)song_chg_fields.artist);
            }
          }
#line 1527
          if (song_chg_fields.title) {
#line 1528
            if (song_curr->title) {
              {
#line 1528
              free((void *)song_curr->title);
              }
            }
            {
#line 1529
            tmp___113 = strlen((char const   *)song_chg_fields.title);
#line 1529
            tmp___114 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___113 + 1U)));
#line 1529
            song_curr->title = (char *)tmp___114;
            }
#line 1530
            if (! song_curr->title) {
              {
#line 1531
              perror("malloc");
#line 1532
              wuuush(1);
              }
            }
            {
#line 1534
            strcpy((char */* __restrict  */)song_curr->title, (char const   */* __restrict  */)song_chg_fields.title);
            }
          }
#line 1536
          if (song_chg_fields.album) {
#line 1537
            if (song_curr->album) {
              {
#line 1537
              free((void *)song_curr->album);
              }
            }
            {
#line 1538
            tmp___115 = strlen((char const   *)song_chg_fields.album);
#line 1538
            tmp___116 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___115 + 1U)));
#line 1538
            song_curr->album = (char *)tmp___116;
            }
#line 1539
            if (! song_curr->album) {
              {
#line 1540
              perror("malloc");
#line 1541
              wuuush(1);
              }
            }
            {
#line 1543
            strcpy((char */* __restrict  */)song_curr->album, (char const   */* __restrict  */)song_chg_fields.album);
            }
          }
#line 1545
          if (song_chg_fields.comment) {
#line 1546
            if (song_curr->comment) {
              {
#line 1546
              free((void *)song_curr->comment);
              }
            }
            {
#line 1547
            tmp___117 = strlen((char const   *)song_chg_fields.comment);
#line 1547
            tmp___118 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___117 + 1U)));
#line 1547
            song_curr->comment = (char *)tmp___118;
            }
#line 1548
            if (! song_curr->comment) {
              {
#line 1549
              perror("malloc");
#line 1550
              wuuush(1);
              }
            }
            {
#line 1552
            strcpy((char */* __restrict  */)song_curr->comment, (char const   */* __restrict  */)song_chg_fields.comment);
            }
          }
#line 1554
          if (song_chg_fields.year != -1) {
#line 1554
            song_curr->year = song_chg_fields.year;
          }
#line 1555
          if (song_chg_fields.genre != -1) {
#line 1555
            song_curr->genre = song_chg_fields.genre;
          }
#line 1556
          if ((int )song_chg_fields.toc != 0) {
#line 1556
            song_curr->on_fly = song_chg_fields.on_fly;
          }
#line 1557
          if (song_chg_fields.fn_auto) {
#line 1557
            song_curr->sampler = song_chg_fields.sampler;
          }
          {
#line 1558
          filenm_generate(song_curr);
          }
        }
#line 1560
        song_curr = song_curr->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1562
      if (song_chg_fields.artist) {
        {
#line 1562
        free((void *)song_chg_fields.artist);
        }
      }
#line 1563
      song_chg_fields.artist = (char *)((void *)0);
#line 1564
      if (song_chg_fields.title) {
        {
#line 1564
        free((void *)song_chg_fields.title);
        }
      }
#line 1565
      song_chg_fields.title = (char *)((void *)0);
#line 1566
      if (song_chg_fields.album) {
        {
#line 1566
        free((void *)song_chg_fields.album);
        }
      }
#line 1567
      song_chg_fields.album = (char *)((void *)0);
#line 1568
      if (song_chg_fields.comment) {
        {
#line 1568
        free((void *)song_chg_fields.comment);
        }
      }
      {
#line 1569
      song_chg_fields.comment = (char *)((void *)0);
#line 1570
      song_chg_fields.year = -1;
#line 1571
      song_chg_fields.genre = -1;
#line 1572
      song_chg_fields.toc = (char)0;
#line 1573
      song_chg_fields.fn_auto = (unsigned char)0;
#line 1574
      free_field_select(& anchor);
#line 1575
      anchor = (field_select_typ *)((void *)0);
#line 1576
      loaded_def = (unsigned char)1;
#line 1577
      use_old = (unsigned char)0;
      }
#line 1578
      goto switch_break___0;
      case_123: /* CIL Label */ 
#line 1581
      song_curr = lay_global_anchor[lay_act_side];
      {
#line 1582
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1582
        if (! song_curr) {
#line 1582
          goto while_break___1;
        }
#line 1583
        if (song_chg_fields.artist) {
#line 1584
          if (song_curr->artist) {
            {
#line 1584
            free((void *)song_curr->artist);
            }
          }
          {
#line 1585
          tmp___119 = strlen((char const   *)song_chg_fields.artist);
#line 1585
          tmp___120 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___119 + 1U)));
#line 1585
          song_curr->artist = (char *)tmp___120;
          }
#line 1586
          if (! song_curr->artist) {
            {
#line 1587
            perror("malloc");
#line 1588
            wuuush(1);
            }
          }
          {
#line 1590
          strcpy((char */* __restrict  */)song_curr->artist, (char const   */* __restrict  */)song_chg_fields.artist);
          }
        }
#line 1592
        if (song_chg_fields.title) {
#line 1593
          if (song_curr->title) {
            {
#line 1593
            free((void *)song_curr->title);
            }
          }
          {
#line 1594
          tmp___121 = strlen((char const   *)song_chg_fields.title);
#line 1594
          tmp___122 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___121 + 1U)));
#line 1594
          song_curr->title = (char *)tmp___122;
          }
#line 1595
          if (! song_curr->title) {
            {
#line 1596
            perror("malloc");
#line 1597
            wuuush(1);
            }
          }
          {
#line 1599
          strcpy((char */* __restrict  */)song_curr->title, (char const   */* __restrict  */)song_chg_fields.title);
          }
        }
#line 1601
        if (song_chg_fields.album) {
#line 1602
          if (song_curr->album) {
            {
#line 1602
            free((void *)song_curr->album);
            }
          }
          {
#line 1603
          tmp___123 = strlen((char const   *)song_chg_fields.album);
#line 1603
          tmp___124 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___123 + 1U)));
#line 1603
          song_curr->album = (char *)tmp___124;
          }
#line 1604
          if (! song_curr->album) {
            {
#line 1605
            perror("malloc");
#line 1606
            wuuush(1);
            }
          }
          {
#line 1608
          strcpy((char */* __restrict  */)song_curr->album, (char const   */* __restrict  */)song_chg_fields.album);
          }
        }
#line 1610
        if (song_chg_fields.comment) {
#line 1611
          if (song_curr->comment) {
            {
#line 1611
            free((void *)song_curr->comment);
            }
          }
          {
#line 1612
          tmp___125 = strlen((char const   *)song_chg_fields.comment);
#line 1612
          tmp___126 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___125 + 1U)));
#line 1612
          song_curr->comment = (char *)tmp___126;
          }
#line 1613
          if (! song_curr->comment) {
            {
#line 1614
            perror("malloc");
#line 1615
            wuuush(1);
            }
          }
          {
#line 1617
          strcpy((char */* __restrict  */)song_curr->comment, (char const   */* __restrict  */)song_chg_fields.comment);
          }
        }
#line 1619
        if (song_chg_fields.year != -1) {
#line 1619
          song_curr->year = song_chg_fields.year;
        }
#line 1620
        if (song_chg_fields.genre != -1) {
#line 1620
          song_curr->genre = song_chg_fields.genre;
        }
#line 1621
        if ((int )song_chg_fields.toc != 0) {
#line 1621
          song_curr->on_fly = song_chg_fields.on_fly;
        }
#line 1622
        if (song_chg_fields.fn_auto) {
#line 1622
          song_curr->sampler = song_chg_fields.sampler;
        }
        {
#line 1623
        filenm_generate(song_curr);
#line 1624
        song_curr = song_curr->next;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1626
      if (song_chg_fields.artist) {
        {
#line 1626
        free((void *)song_chg_fields.artist);
        }
      }
#line 1627
      song_chg_fields.artist = (char *)((void *)0);
#line 1628
      if (song_chg_fields.title) {
        {
#line 1628
        free((void *)song_chg_fields.title);
        }
      }
#line 1629
      song_chg_fields.title = (char *)((void *)0);
#line 1630
      if (song_chg_fields.album) {
        {
#line 1630
        free((void *)song_chg_fields.album);
        }
      }
#line 1631
      song_chg_fields.album = (char *)((void *)0);
#line 1632
      if (song_chg_fields.comment) {
        {
#line 1632
        free((void *)song_chg_fields.comment);
        }
      }
      {
#line 1633
      song_chg_fields.comment = (char *)((void *)0);
#line 1634
      song_chg_fields.year = -1;
#line 1635
      song_chg_fields.genre = -1;
#line 1636
      song_chg_fields.toc = (char)0;
#line 1637
      song_chg_fields.fn_auto = (unsigned char)0;
#line 1638
      free_field_select(& anchor);
#line 1639
      anchor = (field_select_typ *)((void *)0);
#line 1640
      loaded_def = (unsigned char)1;
#line 1641
      use_old = (unsigned char)0;
      }
#line 1642
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1647
  free_field_select(& anchor);
  }
#line 1648
  if (song_chg_fields.artist) {
    {
#line 1648
    free((void *)song_chg_fields.artist);
    }
  }
#line 1649
  if (song_chg_fields.title) {
    {
#line 1649
    free((void *)song_chg_fields.title);
    }
  }
#line 1650
  if (song_chg_fields.album) {
    {
#line 1650
    free((void *)song_chg_fields.album);
    }
  }
#line 1651
  if (song_chg_fields.comment) {
    {
#line 1651
    free((void *)song_chg_fields.comment);
    }
  }
#line 1652
  return;
}
}
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 35 "/home/wslee/benchmarks/sound/mp3c-0.29/src/news.c"
char **is_build_array(char *str , int *lines ) ;
#line 36
void is_popup_text(char const   **text , int len , int height ) ;
#line 40
char *def_version_str ;
#line 42 "/home/wslee/benchmarks/sound/mp3c-0.29/src/news.c"
int news_get_version(char const   *ver_str , int *major , int *minor ) 
{ 
  char *pat ;

  {
#line 46
  *major = 0;
#line 47
  *minor = 0;
#line 49
  if (! ver_str) {
#line 49
    return (1);
  }
  {
#line 51
  pat = strchr(ver_str, '.');
  }
#line 52
  if (! pat) {
    {
#line 52
    pat = strchr(ver_str, '-');
    }
  }
#line 53
  if (! pat) {
    {
#line 54
    *minor = atoi(ver_str);
    }
#line 55
    return (0);
  }
  {
#line 58
  *minor = atoi((char const   *)(pat + 1));
#line 59
  *major = atoi(ver_str);
  }
#line 61
  return (0);
}
}
#line 64 "/home/wslee/benchmarks/sound/mp3c-0.29/src/news.c"
char *news_insert_text(char *curr , char *new ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 66
  if (! curr) {
#line 66
    return (curr);
  } else
#line 66
  if (! new) {
#line 66
    return (curr);
  }
  {
#line 68
  tmp = strlen((char const   *)curr);
#line 68
  tmp___0 = strlen((char const   *)new);
#line 68
  tmp___1 = realloc((void *)curr, (size_t )(sizeof(char ) * (unsigned long )((tmp + tmp___0) + 2U)));
#line 68
  curr = (char *)tmp___1;
  }
#line 69
  if (! curr) {
    {
#line 70
    wuuush(1);
    }
  }
  {
#line 73
  strcat((char */* __restrict  */)curr, (char const   */* __restrict  */)new);
  }
#line 75
  return (curr);
}
}
#line 78 "/home/wslee/benchmarks/sound/mp3c-0.29/src/news.c"
char *news_insert_news_item(char *curr , int item ) 
{ 
  char *new ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 82
  new = curr;
  {
#line 85
  if (item == 29) {
#line 85
    goto case_29;
  }
#line 97
  if (item == 28) {
#line 97
    goto case_28;
  }
#line 108
  if (item == 27) {
#line 108
    goto case_27;
  }
#line 133
  if (item == 26) {
#line 133
    goto case_26;
  }
#line 143
  if (item == 25) {
#line 143
    goto case_25;
  }
#line 163
  if (item == 24) {
#line 163
    goto case_24;
  }
#line 84
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 86
  tmp = gettext("New in 0.29:\n-presets to switch between MP3/lame and OGG/oggenc   \n encodings.                                          \n-defaults changed to lame and cdda2wav.              \n-some changes to make MP3c more generic (and not MP3 \n specific)                                           \n\nThe MP3c lives on release, enjoy 0.29\n\n");
#line 86
  new = news_insert_text(curr, tmp);
  }
#line 95
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 98
  tmp___0 = gettext("New in 0.28:\n-replace spaces with an own defined character instead\n of underscore.                                      \n-some batchscript fixes.                             \n-a lot of bugfixes.                                  \n\nThe MP3c is not dead release, enjoy 0.28\n\n");
#line 98
  new = news_insert_text(curr, tmp___0);
  }
#line 106
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 109
  tmp___1 = gettext("New in 0.27:\n-CDDB.com is not longer useable as CDDB-server.      \n please switch to \"freedb.freedb.org:8880\" now.      \n-added option to protect patternmasks from           \n substitution.                                       \n-use different patterns for MP3 and M3U files,       \n depending if cd is a sampler with different artists \n or just a normal cd with one artist.                \n-added possibility to use the encoder for tagging the\n files too. If your encoder supports tagging, you    \n do not need a seperate program any longer and you   \n can disable the tag-program by changing the value to\n \"0\".                                                \n-improved detection of sampler-cds. Furthermore you  \n can force sampler-detection by pressing SHIFT+V     \n instead of just \"v\" after inserting a new cd.       \n-added support for BSD and 64-bit systems.           \n-new and updated translations, as well as the usual  \n bugfixes.                                           \n\nI know it took long, but I hope you enjoy 0.27\n\n");
#line 109
  new = news_insert_text(curr, tmp___1);
  }
#line 131
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 134
  tmp___2 = gettext("New in 0.26:\n-Replacestring for unknown genre.                    \n-Special handling for illegal characters: removing by\n default, or using patternmode (and replacing by     \n space or underscore, or removing).                  \n-Fixed broken ripping (introduced with 0.25).        \n\n");
#line 134
  new = news_insert_text(curr, tmp___2);
  }
#line 141
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 144
  tmp___3 = gettext("New in 0.25:\n-Save CDDB entries by pressing \'m\' or transmit them  \n to CDDB server by pressing \'M\' (transmit requires   \n proper settings of SMTP-server, see Options->SMTP   \n Server, \"CDDB eMail address\" and \"My eMail\").       \n-Press \'d\' to get rid of dead files on right side.   \n-Open tray after encoding (see Options->Open tray    \n after encoding).                                    \n-Option to change case of filenames (see             \n Options->Case Change).                              \n-Totally rewrote directory and filerequester. Please \n make sure that you activate the requester in option-\n menu.                                               \n-Improved key-handling, so that backspace and end-key\n should now work even in Xterms                      \n-MP3c is now also available via CVS (see READMEs)    \n\n");
#line 144
  new = news_insert_text(curr, tmp___3);
  }
#line 161
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 164
  tmp___4 = gettext("New in 0.24:\n-Portuguese translation (done by Lucas Correia Villa \n Real)                                               \n-Improved handling of relative filenames in playlists\n-Usage of more CDDB-servers possible (seperate each  \n server by a comma in optionmenu).                   \n\n");
#line 164
  new = news_insert_text(curr, tmp___4);
  }
#line 171
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 174
  return (new);
}
}
#line 177 "/home/wslee/benchmarks/sound/mp3c-0.29/src/news.c"
void news_show_summery(unsigned char windowed ) 
{ 
  int old_major_ver ;
  int old_minor_ver ;
  int new_major_ver ;
  int new_minor_ver ;
  char *text ;
  char **text_array ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 184
  tmp = news_get_version((char const   *)def_version_str, & old_major_ver, & old_minor_ver);
  }
#line 184
  if (tmp) {
#line 185
    return;
  }
  {
#line 186
  tmp___0 = news_get_version("0.29", & new_major_ver, & new_minor_ver);
  }
#line 186
  if (tmp___0) {
#line 187
    return;
  }
#line 189
  text = (char *)((void *)0);
#line 191
  if (old_major_ver != new_major_ver) {
    {
#line 192
    tmp___1 = gettext("WARNING\n-------\nYour configfile is newer than this version\nof MP3c. So if you run into trouble please\nuse a recent version of MP3c.             \n");
#line 192
    text = copy_char_str(tmp___1);
    }
  } else
#line 191
  if (old_minor_ver > new_minor_ver) {
    {
#line 192
    tmp___1 = gettext("WARNING\n-------\nYour configfile is newer than this version\nof MP3c. So if you run into trouble please\nuse a recent version of MP3c.             \n");
#line 192
    text = copy_char_str(tmp___1);
    }
  } else
#line 197
  if (old_minor_ver < new_minor_ver) {
    {
#line 198
    tmp___2 = malloc((size_t )(sizeof(char ) * 250UL));
#line 198
    text = (char *)tmp___2;
    }
#line 199
    if (! text) {
      {
#line 200
      wuuush(1);
      }
    }
#line 202
    if (! old_minor_ver) {
      {
#line 203
      tmp___3 = gettext("HOT-NEWS\n\nYou just updated MP3c to Version %d.%d\n\n");
#line 203
      sprintf((char */* __restrict  */)text, (char const   */* __restrict  */)tmp___3,
              new_major_ver, new_minor_ver);
      }
    } else {
      {
#line 207
      tmp___4 = gettext("HOT-NEWS\n\nYou just updated MP3c from V%d.%d to V%d.%d\n\n");
#line 207
      sprintf((char */* __restrict  */)text, (char const   */* __restrict  */)tmp___4,
              old_major_ver, old_minor_ver, new_major_ver, new_minor_ver);
      }
    }
    {
#line 211
    while (1) {
      while_continue: /* CIL Label */ ;
#line 211
      if (! (new_minor_ver > old_minor_ver)) {
#line 211
        goto while_break;
      }
      {
#line 212
      text = news_insert_news_item(text, new_minor_ver);
#line 213
      new_minor_ver --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 217
  if (text) {
#line 218
    if (! windowed) {
      {
#line 219
      fputc('\n', stdout);
#line 220
      fputs((char const   */* __restrict  */)text, (FILE */* __restrict  */)stdout);
      }
    } else {
      {
#line 222
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 222
        tmp___6 = strlen((char const   *)text);
        }
#line 222
        if (! ((int )*(text + (tmp___6 - 1U)) == 10)) {
#line 222
          goto while_break___0;
        }
        {
#line 222
        tmp___5 = strlen((char const   *)text);
#line 222
        *(text + (tmp___5 - 1U)) = (char)0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 223
      text_array = is_build_array(text, & new_major_ver);
#line 224
      is_popup_text((char const   **)text_array, 68, 13);
#line 225
      free_char_array(text_array);
      }
    }
    {
#line 227
    free((void *)text);
    }
  }
#line 229
  return;
}
}
#line 40 "/home/wslee/benchmarks/sound/mp3c-0.29/src/movement.c"
void draw_song_status(WINDOW *win , song_typ *song ) ;
#line 41
void draw_song_line(WINDOW *win , song_typ *song , unsigned char marked , int line ) ;
#line 43
void fill_in_side(WINDOW *win , int side ) ;
#line 46 "/home/wslee/benchmarks/sound/mp3c-0.29/src/movement.c"
void song_move_down(WINDOW *win , unsigned char do_refresh ) 
{ 
  int maxy ;
  int maxx ;

  {
#line 51
  if (! lay_curr_anchor[lay_act_side]) {
#line 51
    return;
  }
#line 52
  if ((unsigned long )(lay_curr_anchor[lay_act_side])->next == (unsigned long )((void *)0)) {
#line 52
    return;
  }
#line 54
  if (win) {
#line 54
    maxy = (int )win->_maxy + 1;
  } else {
#line 54
    maxy = -1;
  }
#line 54
  if (win) {
#line 54
    maxx = (int )win->_maxx + 1;
  } else {
#line 54
    maxx = -1;
  }
#line 57
  if (lay_select_line[lay_act_side] == maxy - 9) {
    {
#line 59
    lay_top_anchor[lay_act_side] = (lay_top_anchor[lay_act_side])->next;
#line 60
    fill_in_side(win, lay_act_side);
    }
  } else {
    {
#line 63
    draw_song_line(win, lay_curr_anchor[lay_act_side], (unsigned char)0, lay_select_line[lay_act_side]);
#line 64
    lay_curr_anchor[lay_act_side] = (lay_curr_anchor[lay_act_side])->next;
#line 65
    (lay_select_line[lay_act_side]) ++;
#line 66
    draw_song_line(win, lay_curr_anchor[lay_act_side], (unsigned char)1, lay_select_line[lay_act_side]);
#line 67
    draw_song_status(win, lay_curr_anchor[lay_act_side]);
    }
  }
#line 70
  if (do_refresh) {
    {
#line 70
    wrefresh(win);
    }
  }
#line 71
  return;
}
}
#line 74 "/home/wslee/benchmarks/sound/mp3c-0.29/src/movement.c"
void song_move_up(WINDOW *win , unsigned char do_refresh ) 
{ 


  {
#line 77
  if (! lay_curr_anchor[lay_act_side]) {
#line 77
    return;
  }
#line 78
  if ((unsigned long )(lay_curr_anchor[lay_act_side])->prev == (unsigned long )((void *)0)) {
#line 78
    return;
  }
#line 81
  if (lay_select_line[lay_act_side] == 1) {
    {
#line 83
    lay_top_anchor[lay_act_side] = (lay_top_anchor[lay_act_side])->prev;
#line 84
    fill_in_side(win, lay_act_side);
    }
  } else {
    {
#line 87
    draw_song_line(win, lay_curr_anchor[lay_act_side], (unsigned char)0, lay_select_line[lay_act_side]);
#line 88
    lay_curr_anchor[lay_act_side] = (lay_curr_anchor[lay_act_side])->prev;
#line 89
    (lay_select_line[lay_act_side]) --;
#line 90
    draw_song_line(win, lay_curr_anchor[lay_act_side], (unsigned char)1, lay_select_line[lay_act_side]);
#line 91
    draw_song_status(win, lay_curr_anchor[lay_act_side]);
    }
  }
#line 94
  if (do_refresh) {
    {
#line 94
    wrefresh(win);
    }
  }
#line 95
  return;
}
}
#line 98 "/home/wslee/benchmarks/sound/mp3c-0.29/src/movement.c"
void song_move_top(WINDOW *win , unsigned char do_refresh ) 
{ 


  {
#line 100
  if (lay_select_line[lay_act_side] != 1) {
    {
#line 102
    draw_song_line(win, lay_curr_anchor[lay_act_side], (unsigned char)0, lay_select_line[lay_act_side]);
#line 103
    lay_select_line[lay_act_side] = 1;
#line 104
    lay_curr_anchor[lay_act_side] = lay_top_anchor[lay_act_side];
#line 105
    draw_song_line(win, lay_curr_anchor[lay_act_side], (unsigned char)1, 1);
#line 106
    draw_song_status(win, lay_curr_anchor[lay_act_side]);
    }
  } else
#line 107
  if ((unsigned long )lay_top_anchor[lay_act_side] != (unsigned long )lay_global_anchor[lay_act_side]) {
    {
#line 108
    lay_top_anchor[lay_act_side] = lay_global_anchor[lay_act_side];
#line 109
    fill_in_side(win, lay_act_side);
    }
  }
#line 112
  if (do_refresh) {
    {
#line 112
    wrefresh(win);
    }
  }
#line 113
  return;
}
}
#line 116 "/home/wslee/benchmarks/sound/mp3c-0.29/src/movement.c"
void song_move_bottom(WINDOW *win , unsigned char do_refresh ) 
{ 
  int maxy ;
  int maxx ;

  {
#line 120
  if (! lay_curr_anchor[lay_act_side]) {
#line 120
    return;
  }
#line 121
  if ((unsigned long )(lay_curr_anchor[lay_act_side])->next == (unsigned long )((void *)0)) {
#line 121
    return;
  }
#line 123
  if (win) {
#line 123
    maxy = (int )win->_maxy + 1;
  } else {
#line 123
    maxy = -1;
  }
#line 123
  if (win) {
#line 123
    maxx = (int )win->_maxx + 1;
  } else {
#line 123
    maxx = -1;
  }
#line 124
  if (lay_select_line[lay_act_side] != maxy - 9) {
    {
#line 125
    draw_song_line(win, lay_curr_anchor[lay_act_side], (unsigned char)0, lay_select_line[lay_act_side]);
    }
    {
#line 126
    while (1) {
      while_continue: /* CIL Label */ ;
#line 126
      if (! (lay_select_line[lay_act_side] != maxy - 9)) {
#line 126
        goto while_break;
      }
#line 127
      lay_curr_anchor[lay_act_side] = (lay_curr_anchor[lay_act_side])->next;
#line 128
      (lay_select_line[lay_act_side]) ++;
#line 129
      if ((unsigned long )(lay_curr_anchor[lay_act_side])->next == (unsigned long )((void *)0)) {
#line 129
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 131
    draw_song_line(win, lay_curr_anchor[lay_act_side], (unsigned char)1, lay_select_line[lay_act_side]);
#line 132
    draw_song_status(win, lay_curr_anchor[lay_act_side]);
    }
  } else {
    {
#line 134
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 134
      if (! ((unsigned long )(lay_curr_anchor[lay_act_side])->next != (unsigned long )((void *)0))) {
#line 134
        goto while_break___0;
      }
#line 135
      lay_top_anchor[lay_act_side] = (lay_top_anchor[lay_act_side])->next;
#line 136
      lay_curr_anchor[lay_act_side] = (lay_curr_anchor[lay_act_side])->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 138
    fill_in_side(win, lay_act_side);
    }
  }
#line 141
  if (do_refresh) {
    {
#line 141
    wrefresh(win);
    }
  }
#line 142
  return;
}
}
#line 145 "/home/wslee/benchmarks/sound/mp3c-0.29/src/movement.c"
void song_move_pup(WINDOW *win , unsigned char do_refresh ) 
{ 
  int i ;
  int maxy ;
  int maxx ;

  {
#line 150
  if (! lay_top_anchor[lay_act_side]) {
#line 150
    return;
  }
#line 153
  if ((unsigned long )(lay_top_anchor[lay_act_side])->prev == (unsigned long )((void *)0)) {
#line 155
    if (lay_select_line[lay_act_side] != 1) {
      {
#line 156
      song_move_top(win, do_refresh);
      }
    }
#line 158
    return;
  }
#line 161
  if (win) {
#line 161
    maxy = (int )win->_maxy + 1;
  } else {
#line 161
    maxy = -1;
  }
#line 161
  if (win) {
#line 161
    maxx = (int )win->_maxx + 1;
  } else {
#line 161
    maxx = -1;
  }
#line 164
  i = 0;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (i < maxy - 9)) {
#line 164
      goto while_break;
    }
#line 165
    if ((unsigned long )(lay_top_anchor[lay_act_side])->prev != (unsigned long )((void *)0)) {
#line 166
      lay_top_anchor[lay_act_side] = (lay_top_anchor[lay_act_side])->prev;
    } else
#line 167
    if (lay_select_line[lay_act_side] == 1) {
#line 167
      goto while_break;
    } else {
#line 169
      (lay_select_line[lay_act_side]) --;
    }
#line 164
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 172
  fill_in_side(win, lay_act_side);
  }
#line 174
  if (do_refresh) {
    {
#line 174
    wrefresh(win);
    }
  }
#line 175
  return;
}
}
#line 178 "/home/wslee/benchmarks/sound/mp3c-0.29/src/movement.c"
void song_move_pdown(WINDOW *win , unsigned char do_refresh ) 
{ 
  int i ;
  int maxy ;
  int maxx ;
  unsigned char fill ;

  {
#line 183
  if (! lay_curr_anchor[lay_act_side]) {
#line 183
    return;
  }
#line 186
  if ((unsigned long )(lay_curr_anchor[lay_act_side])->next == (unsigned long )((void *)0)) {
#line 186
    return;
  }
#line 188
  fill = (unsigned char)0;
#line 189
  if (win) {
#line 189
    maxy = (int )win->_maxy + 1;
  } else {
#line 189
    maxy = -1;
  }
#line 189
  if (win) {
#line 189
    maxx = (int )win->_maxx + 1;
  } else {
#line 189
    maxx = -1;
  }
  {
#line 190
  draw_song_line(win, lay_curr_anchor[lay_act_side], (unsigned char)0, lay_select_line[lay_act_side]);
#line 193
  i = 0;
  }
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (! (i < maxy - 9)) {
#line 193
      goto while_break;
    }
#line 194
    if ((unsigned long )(lay_curr_anchor[lay_act_side])->next == (unsigned long )((void *)0)) {
#line 194
      goto while_break;
    }
#line 196
    if (lay_select_line[lay_act_side] != maxy - 9) {
#line 197
      lay_curr_anchor[lay_act_side] = (lay_curr_anchor[lay_act_side])->next;
#line 198
      (lay_select_line[lay_act_side]) ++;
    } else {
#line 200
      fill = (unsigned char)1;
#line 201
      lay_top_anchor[lay_act_side] = (lay_top_anchor[lay_act_side])->next;
#line 202
      lay_curr_anchor[lay_act_side] = (lay_curr_anchor[lay_act_side])->next;
    }
#line 193
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  if (! fill) {
    {
#line 208
    draw_song_line(win, lay_curr_anchor[lay_act_side], (unsigned char)1, lay_select_line[lay_act_side]);
#line 209
    draw_song_status(win, lay_curr_anchor[lay_act_side]);
    }
  } else {
    {
#line 212
    fill_in_side(win, lay_act_side);
    }
  }
#line 215
  if (do_refresh) {
    {
#line 215
    wrefresh(win);
    }
  }
#line 216
  return;
}
}
#line 339 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 598 "/usr/include/ncurses.h"
extern int init_pair(short  , short  , short  ) ;
#line 606
extern int intrflush(WINDOW * , _Bool  ) ;
#line 728
extern int start_color(void) ;
#line 795 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 145 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 83 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *textdomain(char const   *__domainname ) ;
#line 87
extern  __attribute__((__nothrow__)) char *bindtextdomain(char const   *__domainname ,
                                                          char const   *__dirname ) ;
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 38 "/home/wslee/benchmarks/sound/mp3c-0.29/src/main.c"
int close_cdrom(void) ;
#line 39
int init_cd(void) ;
#line 40
int build_data_tree(char *cddb_server , char *local_cddb_db , song_typ **ret_tree ,
                    unsigned char force_sampler ) ;
#line 42
void main_loop(WINDOW *win ) ;
#line 46
void pop_up_info(void) ;
#line 52
void draw_main_win(WINDOW *win , int dummy1 , int dummy2 ) ;
#line 55
int start_non_interact(char *batchfile ) ;
#line 69
int cd_drv ;
#line 71
char *batch_alt_tmp_file ;
#line 76
int lay_divider ;
#line 84 "/home/wslee/benchmarks/sound/mp3c-0.29/src/main.c"
char *external_config_file  ;
#line 85 "/home/wslee/benchmarks/sound/mp3c-0.29/src/main.c"
char *external_cdrom_dev  ;
#line 86 "/home/wslee/benchmarks/sound/mp3c-0.29/src/main.c"
char external_version_str[256]  ;
#line 90 "/home/wslee/benchmarks/sound/mp3c-0.29/src/main.c"
void shut_down_prg(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;

  {
  {
#line 92
  wclear(stdscr);
#line 93
  wrefresh(stdscr);
#line 94
  endwin();
#line 95
  close_cdrom();
#line 97
  tmp = gettext("\n\nMP3c, by WSPse 1999-2004, Matthias Hensler, <matthias@wspse.de>\nThanks for using this program\n\n");
#line 97
  printf((char const   */* __restrict  */)tmp);
  }
#line 99
  return;
}
}
#line 108 "/home/wslee/benchmarks/sound/mp3c-0.29/src/main.c"
void wuuush(int code ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 111
  if (code == 1) {
#line 111
    goto case_1;
  }
#line 117
  if (code == 2) {
#line 117
    goto case_2;
  }
#line 123
  if (code == 3) {
#line 123
    goto case_3;
  }
#line 127
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 114
  tmp = gettext("ups, we ran out of memory :-(");
#line 114
  popup_error_win(tmp);
  }
#line 115
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 118
  tmp___0 = gettext("terminated...");
#line 118
  popup_error_win(tmp___0);
  }
#line 119
  if (auto_save) {
    {
#line 120
    put_config(external_config_file, (unsigned char)0);
    }
  }
#line 121
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 124
  tmp___1 = gettext("creating new window caused in NULL-pointer (ncurses-bug?!)");
#line 124
  popup_error_win(tmp___1);
  }
#line 125
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 128
  tmp___2 = gettext("sorry, unspecified error occured");
#line 128
  popup_error_win(tmp___2);
  }
#line 129
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 132
  shut_down_prg();
  }
#line 133
  if (code == 2) {
    {
#line 133
    exit(0);
    }
  } else {
    {
#line 134
    exit(1);
    }
  }
}
}
#line 137 "/home/wslee/benchmarks/sound/mp3c-0.29/src/main.c"
void usage(char *arg ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 139
  printf((char const   */* __restrict  */)"\n%s", external_version_str);
#line 140
  tmp = gettext("\n\nUseful arguments for \"%s\":\n-i <configfile>\n-b <batchfile>\n-t <tmp-dir> (only in context with -b)\n-d <cdrom-device>\n-v\n-n (show news)\n\nif you start %s with \"-b\" argument given, a\nscriptfile will created non-interactivly and program\nexits.\n\n");
#line 140
  printf((char const   */* __restrict  */)tmp, arg, arg);
#line 151
  exit(0);
  }
}
}
#line 155 "/home/wslee/benchmarks/sound/mp3c-0.29/src/main.c"
int main(int argc , char **argv ) 
{ 
  WINDOW *win ;
  song_typ *anchor ;
  char *tx ;
  int i ;
  unsigned char batch_mode ;
  char *batch_file ;
  unsigned char existing_lockfile ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  unsigned char tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  size_t tmp___20 ;
  void *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;

  {
  {
#line 162
  batch_file = (char *)((void *)0);
#line 163
  existing_lockfile = (unsigned char)0;
#line 165
  sprintf((char */* __restrict  */)(external_version_str), (char const   */* __restrict  */)"%s-%s",
          "mp3c", "0.29");
#line 169
  setlocale(6, "");
#line 170
  bindtextdomain((char const   *)((char *)"mp3c"), "/usr/local/share/locale");
#line 171
  textdomain((char const   *)((char *)"mp3c"));
#line 172
  strcat((char */* __restrict  */)(external_version_str), (char const   */* __restrict  */)" (NLS)");
#line 175
  tmp = gettext(" - ENGLISH (");
#line 175
  strcat((char */* __restrict  */)(external_version_str), (char const   */* __restrict  */)tmp);
#line 176
  strcat((char */* __restrict  */)(external_version_str), (char const   */* __restrict  */)"Feb 17 2014");
#line 177
  strcat((char */* __restrict  */)(external_version_str), (char const   */* __restrict  */)") Default:");
#line 182
  strcat((char */* __restrict  */)(external_version_str), (char const   */* __restrict  */)"MP3");
#line 185
  external_cdrom_dev = (char *)((void *)0);
#line 186
  external_config_file = (char *)((void *)0);
#line 187
  batch_mode = (unsigned char)0;
#line 188
  batch_alt_tmp_file = (char *)((void *)0);
  }
#line 190
  if (argc > 1) {
#line 191
    i = 1;
    {
#line 191
    while (1) {
      while_continue: /* CIL Label */ ;
#line 191
      if (! (i < argc)) {
#line 191
        goto while_break;
      }
      {
#line 192
      tmp___11 = strlen((char const   *)*(argv + i));
#line 192
      tmp___12 = strncmp((char const   *)*(argv + i), "-batch", tmp___11);
      }
#line 192
      if (tmp___12 == 0) {
#line 193
        i ++;
#line 194
        if (i == argc) {
          {
#line 194
          usage(*(argv + 0));
          }
        }
#line 195
        batch_file = *(argv + i);
#line 196
        batch_mode = (unsigned char)1;
      } else {
        {
#line 197
        tmp___9 = strlen((char const   *)*(argv + i));
#line 197
        tmp___10 = strncmp((char const   *)*(argv + i), "-device", tmp___9);
        }
#line 197
        if (tmp___10 == 0) {
#line 198
          i ++;
#line 199
          if (i == argc) {
            {
#line 199
            usage(*(argv + 0));
            }
          }
#line 200
          external_cdrom_dev = *(argv + i);
        } else {
          {
#line 201
          tmp___7 = strlen((char const   *)*(argv + i));
#line 201
          tmp___8 = strncmp((char const   *)*(argv + i), "-tempfile", tmp___7);
          }
#line 201
          if (tmp___8 == 0) {
#line 202
            i ++;
#line 203
            if (i == argc) {
              {
#line 203
              usage(*(argv + 0));
              }
            }
#line 204
            batch_alt_tmp_file = *(argv + i);
          } else {
            {
#line 205
            tmp___5 = strlen((char const   *)*(argv + i));
#line 205
            tmp___6 = strncmp((char const   *)*(argv + i), "-initfile", tmp___5);
            }
#line 205
            if (tmp___6 == 0) {
#line 206
              i ++;
#line 207
              if (i == argc) {
                {
#line 207
                usage(*(argv + 0));
                }
              }
#line 208
              external_config_file = *(argv + i);
            } else {
              {
#line 209
              tmp___3 = strlen((char const   *)*(argv + i));
#line 209
              tmp___4 = strncmp((char const   *)*(argv + i), "-version", tmp___3);
              }
#line 209
              if (tmp___4 == 0) {
                {
#line 210
                tmp___0 = gettext("\nThis is MP3c, an automated, CDDB-based, MP3/OGG-encoder\nversion V%s, compiled on %s\n\nMP3c is written by Matthias Hensler <matthias@wspse.de>\nCopyright WSPse 1999-2004, distributed under GNU General Public License\n\nMP3c-Homepage: http://mp3c.wspse.de/\nDownload:      ftp://ftp.wspse.de/pub/linux/wspse/\n\nI want to thank for any suggestion I received (take a look in README-\nfile and ChangeLog for details)\n\nIf you have any wish for a feature not currently included in MP3c, or\nif you found a bug, or an unexpected error, please feel free to contact\nme. I would like to implement new features and fix bugs. It is really\nhelpful if you can send me a detailed bugreport, and maybe how to\nreproduce the problem. If you get a segmentation fault, *please* send me\nthe core-dump AND your binary-file (and maybe your config-file)\nMy eMail-address: Matthias Hensler <matthias@wspse.de>\n\nThanks for reading this. Hope you like this program.\n\n");
#line 210
                printf((char const   */* __restrict  */)tmp___0, "0.29", "Feb 17 2014");
#line 227
                exit(0);
                }
              } else {
                {
#line 228
                tmp___1 = strlen((char const   *)*(argv + i));
#line 228
                tmp___2 = strncmp((char const   *)*(argv + i), "-news", tmp___1);
                }
#line 228
                if (tmp___2 == 0) {
                  {
#line 229
                  careful_batch = (unsigned char)1;
#line 230
                  init_config();
#line 231
                  get_config(external_config_file);
#line 232
                  news_show_summery((unsigned char)0);
#line 233
                  exit(0);
                  }
                } else {
                  {
#line 235
                  usage(*(argv + 0));
                  }
                }
              }
            }
          }
        }
      }
#line 191
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 240
  if (batch_mode) {
    {
#line 241
    start_non_interact(batch_file);
#line 242
    exit(0);
    }
  }
  {
#line 248
  tmp___14 = isatty(0);
  }
#line 248
  if (! tmp___14) {
    {
#line 249
    tmp___13 = gettext("MP3c was started in interactive mode without controlling terminal!\nThis normally causes high load of CPU-time, so MP3c exits now.\n(if you think this is wrong, please contact the author wsp@gmx.de)\n");
#line 249
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___13);
#line 252
    exit(1);
    }
  }
  {
#line 256
  initscr();
#line 257
  start_color();
#line 258
  intrflush(stdscr, (_Bool)0);
#line 260
  init_pair((short)1, (short)7, (short)4);
#line 261
  init_pair((short)2, (short)3, (short)4);
#line 262
  init_pair((short)3, (short)0, (short)6);
#line 263
  init_pair((short)4, (short)3, (short)6);
#line 264
  init_pair((short)5, (short)1, (short)3);
#line 265
  init_pair((short)6, (short)1, (short)4);
#line 266
  init_pair((short)7, (short)0, (short)7);
#line 268
  lay_top_anchor[0] = (song_typ *)((void *)0);
#line 269
  lay_global_anchor[0] = (song_typ *)((void *)0);
#line 270
  lay_top_anchor[1] = (song_typ *)((void *)0);
#line 271
  lay_global_anchor[1] = (song_typ *)((void *)0);
#line 272
  lay_divider = 50;
#line 275
  lay_act_side = 0;
#line 276
  num_ripped_tracks = 0;
#line 278
  init_config();
#line 279
  act_signal_handler();
#line 280
  pop_up_info();
#line 282
  get_config(external_config_file);
#line 284
  check_config();
  }
#line 287
  if (! config_para_mp3c) {
    {
#line 289
    tmp___15 = copy_char_str((char *)"~/.mp3c.lock");
#line 289
    batch_file = file_glob_in_name(tmp___15);
#line 290
    i = lock_lock_file(batch_file, (unsigned char)0);
#line 291
    free((void *)batch_file);
#line 292
    batch_file = (char *)((void *)0);
    }
#line 294
    if (i == 3) {
      {
#line 295
      tmp___16 = gettext("An other MP3c process is still running, continue anyway?");
#line 295
      tmp___17 = select_yesno_box(tmp___16);
      }
#line 295
      if (tmp___17) {
#line 296
        existing_lockfile = (unsigned char)1;
      } else {
        {
#line 298
        shut_down_prg();
        }
#line 299
        return (0);
      }
    }
  }
  {
#line 304
  news_show_summery((unsigned char)1);
#line 306
  win = c_newwin(0, 0, 0, 0, (void *)(& draw_main_win), 0, 0);
#line 307
  draw_main_win(win, 0, 0);
#line 308
  wrefresh(win);
#line 315
  anchor = (song_typ *)((void *)0);
#line 316
  setup_stat_win(75);
#line 318
  tmp___18 = gettext("cdrom initialisation in progress.....");
#line 318
  print_stat_win(tmp___18);
#line 319
  tmp___25 = init_cd();
  }
#line 319
  if (tmp___25 != 0) {
#line 320
    if (cd_drv == -2) {
      {
#line 321
      tmp___19 = gettext("device is ok, but no cd inserted, eh?");
#line 321
      popup_error_win(tmp___19);
      }
    } else {
      {
#line 323
      tmp___20 = strlen((char const   *)def_cdrom_dev);
#line 323
      tmp___21 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___20 + 70U)));
#line 323
      tx = (char *)tmp___21;
      }
#line 324
      if (! tx) {
        {
#line 325
        perror("malloc");
#line 326
        wuuush(1);
        }
      }
      {
#line 328
      tmp___22 = gettext("uh, device \"%s\" failure (please get permissions and/or devicename)");
#line 328
      sprintf((char */* __restrict  */)tx, (char const   */* __restrict  */)tmp___22,
              def_cdrom_dev);
#line 329
      popup_error_win(tx);
#line 330
      free((void *)tx);
      }
    }
  } else {
    {
#line 333
    tmp___23 = gettext("cool, you configured it right, ya");
#line 333
    print_stat_win(tmp___23);
#line 334
    build_data_tree(def_cddb_server, def_cddb_bank, & anchor, (unsigned char)0);
#line 335
    tmp___24 = gettext("well done, initialisation finished successful");
#line 335
    print_stat_win(tmp___24);
    }
  }
  {
#line 338
  destroy_stat_win();
#line 341
  lay_top_anchor[0] = anchor;
#line 342
  lay_global_anchor[0] = anchor;
#line 343
  lay_select_line[0] = 1;
#line 344
  lay_select_line[1] = 1;
#line 345
  calc_tot_frm();
#line 346
  fill_in_songs(win);
#line 349
  main_loop(win);
#line 352
  c_delwin(win);
  }
#line 355
  if (del_tmp_on_exit > 0) {
#line 355
    if (lay_global_anchor[1]) {
      {
#line 356
      setup_stat_win(60);
#line 357
      tmp___26 = gettext("deleting tmpfiles");
#line 357
      print_stat_win(tmp___26);
#line 358
      anchor = lay_global_anchor[1];
      }
      {
#line 359
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 359
        if (! anchor) {
#line 359
          goto while_break___0;
        }
#line 360
        if (anchor->tmp_wav_file) {
#line 360
          if (del_tmp_on_exit == 2) {
            {
#line 361
            print_stat_win(anchor->tmp_wav_file);
#line 362
            unlink((char const   *)anchor->tmp_wav_file);
            }
          } else
#line 360
          if (anchor->on_fly) {
            {
#line 361
            print_stat_win(anchor->tmp_wav_file);
#line 362
            unlink((char const   *)anchor->tmp_wav_file);
            }
          }
        }
#line 364
        anchor = anchor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 366
      destroy_stat_win();
      }
    }
  }
  {
#line 369
  free_song_typ(& lay_global_anchor[0]);
#line 370
  free_song_typ(& lay_global_anchor[1]);
  }
#line 373
  if (auto_save) {
    {
#line 374
    put_config(external_config_file, (unsigned char)0);
    }
  }
#line 378
  if (! config_para_mp3c) {
#line 378
    if (! existing_lockfile) {
      {
#line 380
      tmp___27 = copy_char_str((char *)"~/.mp3c.lock");
#line 380
      batch_file = file_glob_in_name(tmp___27);
#line 381
      lock_unlock_file(batch_file, (unsigned char)0);
#line 382
      free((void *)batch_file);
#line 383
      batch_file = (char *)((void *)0);
      }
    }
  }
  {
#line 386
  shut_down_prg();
  }
#line 387
  return (0);
}
}
#line 407 "/usr/include/stdio.h"
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 623 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 47 "/home/wslee/benchmarks/sound/mp3c-0.29/src/lock.c"
char *lock_add_extension(char *lockfile ) 
{ 
  char *new ;
  size_t tmp ;
  void *tmp___0 ;
  char *__cil_tmp5 ;

  {
#line 51
  if (! lockfile) {
#line 51
    return ((char *)((void *)0));
  }
  {
#line 53
  tmp = strlen((char const   *)lockfile);
#line 53
  tmp___0 = malloc((size_t )(sizeof(char ) * (unsigned long )tmp + 6UL));
#line 53
  new = (char *)tmp___0;
  }
#line 54
  if (! new) {
    {
#line 55
    wuuush(1);
    }
  }
  {
#line 58
  sprintf((char */* __restrict  */)new, (char const   */* __restrict  */)"%s.lock",
          lockfile);
  }
#line 60
  return (new);
}
}
#line 69 "/home/wslee/benchmarks/sound/mp3c-0.29/src/lock.c"
int lock_lock_file(char *lockfile , unsigned char extension ) 
{ 
  FILE *lckdes ;
  pid_t lckpid ;
  char *file ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  __pid_t tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 75
  if (! lockfile) {
#line 75
    return (1);
  }
#line 77
  if (extension) {
    {
#line 78
    file = lock_add_extension(lockfile);
    }
  } else {
#line 80
    file = lockfile;
  }
  {
#line 83
  lckdes = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 84
  if (lckdes) {
    {
#line 85
    tmp___2 = fscanf((FILE */* __restrict  */)lckdes, (char const   */* __restrict  */)"%d",
                     & lckpid);
    }
#line 85
    if (tmp___2 == 1) {
      {
#line 86
      tmp = kill(lckpid, 0);
      }
#line 86
      if (tmp == -1) {
        {
#line 86
        tmp___0 = __errno_location();
        }
#line 86
        if (*tmp___0 == 3) {
          {
#line 88
          fclose(lckdes);
#line 89
          unlink((char const   *)file);
          }
        } else {
#line 86
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 91
        fclose(lckdes);
        }
#line 92
        if (extension) {
          {
#line 93
          free((void *)file);
#line 94
          file = (char *)((void *)0);
          }
        }
#line 96
        return (3);
      }
    } else {
      {
#line 99
      tmp___1 = gettext("error while reading pid from existing lockfile");
#line 99
      popup_error_win(tmp___1);
#line 100
      fclose(lckdes);
      }
#line 101
      return (1);
    }
  } else {
    {
#line 103
    tmp___4 = __errno_location();
    }
#line 103
    if (*tmp___4 != 2) {
      {
#line 104
      tmp___3 = gettext("lockfile exists and is not readable");
#line 104
      popup_error_win(tmp___3);
      }
#line 105
      return (1);
    }
  }
  {
#line 108
  lckdes = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"w");
  }
#line 109
  if (! lckdes) {
#line 110
    if (extension) {
      {
#line 111
      free((void *)file);
#line 112
      file = (char *)((void *)0);
      }
    }
#line 114
    return (2);
  }
  {
#line 117
  tmp___5 = getpid();
#line 117
  fprintf((FILE */* __restrict  */)lckdes, (char const   */* __restrict  */)"%d",
          tmp___5);
#line 118
  fclose(lckdes);
  }
#line 119
  return (0);
}
}
#line 122 "/home/wslee/benchmarks/sound/mp3c-0.29/src/lock.c"
int lock_unlock_file(char *lockfile , unsigned char extension ) 
{ 
  char *file ;
  int tmp ;

  {
#line 126
  if (! lockfile) {
#line 126
    return (0);
  }
#line 128
  if (extension) {
    {
#line 129
    file = lock_add_extension(lockfile);
    }
  } else {
#line 131
    file = lockfile;
  }
  {
#line 134
  tmp = unlink((char const   *)file);
  }
#line 134
  if (tmp) {
#line 135
    if (extension) {
      {
#line 136
      free((void *)file);
#line 137
      file = (char *)((void *)0);
      }
    }
#line 139
    return (1);
  }
#line 142
  if (extension) {
    {
#line 143
    free((void *)file);
#line 144
    file = (char *)((void *)0);
    }
  }
#line 146
  return (0);
}
}
#line 186 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 47 "/home/wslee/benchmarks/sound/mp3c-0.29/src/line_opt.c"
char cache_buf[512]  ;
#line 48 "/home/wslee/benchmarks/sound/mp3c-0.29/src/line_opt.c"
int cache_remain  =    0;
#line 49 "/home/wslee/benchmarks/sound/mp3c-0.29/src/line_opt.c"
int cache_last_fd  =    -1;
#line 51 "/home/wslee/benchmarks/sound/mp3c-0.29/src/line_opt.c"
int read_from_sock(char **line , int sock_fd , unsigned char wait ) 
{ 
  int i ;
  int j ;
  int len ;
  char *ret_line ;
  int status ;
  time_t start ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  int *tmp___6 ;
  time_t tmp___7 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 58
  if (cache_last_fd != sock_fd) {
#line 58
    cache_remain = 0;
  }
#line 59
  cache_last_fd = sock_fd;
#line 61
  ret_line = (char *)((void *)0);
#line 62
  len = 0;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (cache_remain > 0) {
#line 66
      i = 0;
      {
#line 66
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 66
        if (! (i < cache_remain)) {
#line 66
          goto while_break___0;
        }
#line 67
        if ((int )cache_buf[i] == 0) {
#line 69
          j = i + 1;
          {
#line 69
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 69
            if (! (j < cache_remain)) {
#line 69
              goto while_break___1;
            }
#line 69
            cache_buf[j - 1] = cache_buf[j];
#line 69
            j ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 70
          cache_remain --;
        }
#line 72
        if ((int )cache_buf[i] == 10) {
          {
#line 73
          tmp = realloc((void *)ret_line, (size_t )(sizeof(char ) * (unsigned long )(len + (i + 2))));
#line 73
          ret_line = (char *)tmp;
          }
#line 74
          if ((unsigned long )ret_line == (unsigned long )((void *)0)) {
            {
#line 75
            perror("realloc");
#line 76
            wuuush(1);
            }
          }
          {
#line 78
          memcpy((void */* __restrict  */)(ret_line + len), (void const   */* __restrict  */)(& cache_buf),
                 (size_t )(i + 1));
#line 79
          *(((ret_line + i) + 1) + len) = (char)0;
#line 80
          len = 0;
          }
          {
#line 80
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 80
            if (! (len <= cache_remain - i)) {
#line 80
              goto while_break___2;
            }
#line 81
            cache_buf[len] = cache_buf[(len + i) + 1];
#line 80
            len ++;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 83
          cache_remain -= i + 1;
#line 85
          tmp___4 = strlen((char const   *)ret_line);
          }
#line 85
          if (tmp___4 > 2U) {
#line 86
            i = 0;
            {
#line 86
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 86
              tmp___3 = strlen((char const   *)ret_line);
              }
#line 86
              if (! ((size_t )i < tmp___3 - 2U)) {
#line 86
                goto while_break___3;
              }
              {
#line 87
              tmp___2 = __ctype_b_loc();
              }
#line 87
              if ((int const   )*(*tmp___2 + (int )*(ret_line + i)) & 2) {
#line 87
                if (eased_char_hand) {
#line 87
                  if ((int )*(ret_line + i) > 32) {
#line 87
                    if (! ((int )((unsigned char )*(ret_line + i)) < 128)) {
#line 87
                      goto _L;
                    }
                  } else
                  _L: /* CIL Label */ 
#line 87
                  if (! ((int )((unsigned char )*(ret_line + i)) > 159)) {
                    {
#line 90
                    tmp___0 = strlen((char const   *)ret_line);
#line 90
                    status = (int )tmp___0;
#line 91
                    tmp___1 = strlen((char const   *)((ret_line + i) + 1));
#line 91
                    memmove((void *)(ret_line + i), (void const   *)((ret_line + i) + 1),
                            tmp___1);
#line 92
                    *((ret_line + status) - 1) = (char)0;
                    }
                  }
                } else {
                  {
#line 90
                  tmp___0 = strlen((char const   *)ret_line);
#line 90
                  status = (int )tmp___0;
#line 91
                  tmp___1 = strlen((char const   *)((ret_line + i) + 1));
#line 91
                  memmove((void *)(ret_line + i), (void const   *)((ret_line + i) + 1),
                          tmp___1);
#line 92
                  *((ret_line + status) - 1) = (char)0;
                  }
                }
              }
#line 86
              i ++;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
#line 96
          *line = ret_line;
#line 97
          return (0);
        }
#line 66
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 100
      tmp___5 = realloc((void *)ret_line, (size_t )(sizeof(char ) * (unsigned long )(len + cache_remain)));
#line 100
      ret_line = (char *)tmp___5;
      }
#line 101
      if ((unsigned long )ret_line == (unsigned long )((void *)0)) {
        {
#line 102
        perror("realloc");
#line 103
        wuuush(1);
        }
      }
      {
#line 105
      memcpy((void */* __restrict  */)(ret_line + len), (void const   */* __restrict  */)(& cache_buf),
             (size_t )cache_remain);
#line 106
      len += cache_remain;
#line 107
      cache_remain = 0;
      }
    }
    {
#line 110
    start = time((time_t *)((void *)0));
    }
    {
#line 111
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 112
      status = read(sock_fd, (void *)(& cache_buf), (size_t )512);
      }
#line 113
      if (status == -1) {
        {
#line 113
        tmp___6 = __errno_location();
        }
#line 113
        if (*tmp___6 != 11) {
          {
#line 114
          perror("read");
#line 115
          wuuush(1);
          }
        }
      }
      {
#line 117
      tmp___7 = time((time_t *)((void *)0));
      }
#line 117
      if (tmp___7 - start > 60L) {
#line 117
        return (-1);
      }
#line 118
      if (status > 0) {
#line 119
        cache_remain = status;
#line 120
        goto while_break___4;
      }
#line 122
      if (! wait) {
#line 122
        return (-1);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 127 "/home/wslee/benchmarks/sound/mp3c-0.29/src/line_opt.c"
int write_to_sock(char *buf , int len , int sock_fd ) 
{ 
  int status ;
  time_t start ;
  int *tmp ;
  time_t tmp___0 ;
  char *__cil_tmp8 ;

  {
  {
#line 132
  start = time((time_t *)((void *)0));
  }
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 134
    status = write(sock_fd, (void const   *)buf, (size_t )len);
    }
#line 135
    if (status == -1) {
      {
#line 135
      tmp = __errno_location();
      }
#line 135
      if (*tmp != 11) {
        {
#line 136
        perror("write");
#line 137
        wuuush(1);
        }
      }
    }
    {
#line 139
    tmp___0 = time((time_t *)((void *)0));
    }
#line 139
    if (tmp___0 - start > 60L) {
#line 139
      return (-1);
    }
#line 140
    if (status > 0) {
#line 140
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  if (status != len) {
#line 142
    return (-1);
  }
#line 143
  return (0);
}
}
#line 146 "/home/wslee/benchmarks/sound/mp3c-0.29/src/line_opt.c"
int read_from_sock2(char **line , int sock_fd , unsigned char wait ) 
{ 
  int code ;
  int len ;
  size_t tmp ;

  {
  {
#line 151
  code = read_from_sock(line, sock_fd, wait);
  }
#line 153
  if (code == 0) {
#line 153
    if (line) {
      {
#line 154
      tmp = strlen((char const   *)*line);
#line 154
      len = (int )(tmp - 1U);
      }
      {
#line 155
      while (1) {
        while_continue: /* CIL Label */ ;
#line 155
        if (! (len >= 0)) {
#line 155
          goto while_break;
        }
#line 156
        if ((int )*(*line + len) == 10) {
#line 157
          *(*line + len) = (char)0;
        } else
#line 156
        if ((int )*(*line + len) == 13) {
#line 157
          *(*line + len) = (char)0;
        } else {
#line 158
          goto while_break;
        }
#line 159
        len --;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 163
  return (code);
}
}
#line 38 "/home/wslee/benchmarks/sound/mp3c-0.29/src/layout.c"
int track_last ;
#line 39
int mp3_frame_mult ;
#line 53 "/home/wslee/benchmarks/sound/mp3c-0.29/src/layout.c"
song_typ *lay_global_anchor[2]  ;
#line 54 "/home/wslee/benchmarks/sound/mp3c-0.29/src/layout.c"
song_typ *lay_top_anchor[2]  ;
#line 55 "/home/wslee/benchmarks/sound/mp3c-0.29/src/layout.c"
song_typ *lay_curr_anchor[2]  ;
#line 56 "/home/wslee/benchmarks/sound/mp3c-0.29/src/layout.c"
int lay_select_line[2]  ;
#line 57 "/home/wslee/benchmarks/sound/mp3c-0.29/src/layout.c"
unsigned long lay_tot_frm[2]  ;
#line 58 "/home/wslee/benchmarks/sound/mp3c-0.29/src/layout.c"
int lay_divider  ;
#line 59 "/home/wslee/benchmarks/sound/mp3c-0.29/src/layout.c"
int lay_act_side  ;
#line 63 "/home/wslee/benchmarks/sound/mp3c-0.29/src/layout.c"
long sub_frame_calc(song_typ *anchor ) 
{ 
  song_typ *curr ;
  long frames ;

  {
#line 68
  frames = 0L;
#line 69
  curr = anchor;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! curr) {
#line 70
      goto while_break;
    }
#line 71
    if (curr->convert) {
#line 72
      frames += curr->frame_len;
    }
#line 74
    curr = curr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  return (frames);
}
}
#line 80 "/home/wslee/benchmarks/sound/mp3c-0.29/src/layout.c"
void calc_tot_frm(void) 
{ 
  long tmp ;
  long tmp___0 ;

  {
  {
#line 82
  tmp = sub_frame_calc(lay_global_anchor[0]);
#line 82
  lay_tot_frm[0] = (unsigned long )tmp;
#line 83
  tmp___0 = sub_frame_calc(lay_global_anchor[1]);
#line 83
  lay_tot_frm[1] = (unsigned long )tmp___0;
  }
#line 84
  return;
}
}
#line 86 "/home/wslee/benchmarks/sound/mp3c-0.29/src/layout.c"
int calc_divider_pos(int maxx ) 
{ 


  {
#line 88
  if (lay_divider == 0) {
#line 88
    return (-1);
  } else
#line 88
  if (lay_divider == 100) {
#line 88
    return (-1);
  } else {
#line 89
    return ((lay_divider * maxx) / 100);
  }
}
}
#line 92 "/home/wslee/benchmarks/sound/mp3c-0.29/src/layout.c"
void draw_main_win(WINDOW *win , int dummy1 , int dummy2 ) 
{ 
  int maxx ;
  int maxy ;
  int divider ;
  char help_str[50] ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  void *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
#line 98
  curs_set(0);
#line 99
  wclear(win);
#line 100
  scrollok(win, (_Bool)0);
#line 101
  keypad(win, (_Bool)1);
#line 103
  wbkgd(win, (chtype )(1 << 8));
  }
#line 104
  if (stdscr) {
#line 104
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 104
    maxy = -1;
  }
#line 104
  if (stdscr) {
#line 104
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 104
    maxx = -1;
  }
  {
#line 106
  divider = calc_divider_pos(maxx);
#line 108
  wborder(win, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0,
          (chtype )0, (chtype )0);
#line 110
  wmove(win, maxy - 8, 0);
#line 111
  waddch(win, (chtype const   )acs_map[(unsigned char )'t']);
#line 112
  whline(win, (chtype )0, maxx - 2);
#line 113
  wmove(win, maxy - 8, maxx - 1);
#line 114
  waddch(win, (chtype const   )acs_map[(unsigned char )'u']);
#line 116
  tmp = gettext("press F1 or \'H\' for help");
#line 116
  strcpy((char */* __restrict  */)(help_str), (char const   */* __restrict  */)tmp);
  }
#line 118
  if (divider != -1) {
    {
#line 119
    tmp___0 = wmove(win, 0, divider);
    }
#line 119
    if (! (tmp___0 == -1)) {
      {
#line 119
      waddch(win, (chtype const   )acs_map[(unsigned char )'w']);
      }
    }
    {
#line 120
    tmp___1 = wmove(win, 1, divider);
    }
#line 120
    if (! (tmp___1 == -1)) {
      {
#line 120
      wvline(win, acs_map[(unsigned char )'x'], maxy - 9);
      }
    }
    {
#line 121
    tmp___2 = wmove(win, maxy - 8, divider);
    }
#line 121
    if (! (tmp___2 == -1)) {
      {
#line 121
      waddch(win, (chtype const   )acs_map[(unsigned char )'v']);
      }
    }
  }
  {
#line 124
  tmp___4 = wmove(win, maxy - 7, 1);
  }
#line 124
  if (! (tmp___4 == -1)) {
    {
#line 124
    tmp___3 = gettext("Track  :   /   [  :  ,~     KB] - Total:   :   [~      KB]");
#line 124
    waddnstr(win, (char const   *)tmp___3, -1);
    }
  }
  {
#line 125
  tmp___6 = wmove(win, maxy - 6, 1);
  }
#line 125
  if (! (tmp___6 == -1)) {
    {
#line 125
    tmp___5 = gettext("Title  :");
#line 125
    waddnstr(win, (char const   *)tmp___5, -1);
    }
  }
  {
#line 126
  tmp___8 = wmove(win, maxy - 5, 1);
  }
#line 126
  if (! (tmp___8 == -1)) {
    {
#line 126
    tmp___7 = gettext("Artist :");
#line 126
    waddnstr(win, (char const   *)tmp___7, -1);
    }
  }
  {
#line 127
  tmp___10 = wmove(win, maxy - 4, 1);
  }
#line 127
  if (! (tmp___10 == -1)) {
    {
#line 127
    tmp___9 = gettext("Album  :");
#line 127
    waddnstr(win, (char const   *)tmp___9, -1);
    }
  }
  {
#line 128
  tmp___12 = wmove(win, maxy - 3, 1);
  }
#line 128
  if (! (tmp___12 == -1)) {
    {
#line 128
    tmp___11 = gettext("File   :");
#line 128
    waddnstr(win, (char const   *)tmp___11, -1);
    }
  }
  {
#line 129
  tmp___14 = wmove(win, maxy - 2, 1);
  }
#line 129
  if (! (tmp___14 == -1)) {
    {
#line 129
    tmp___13 = gettext("Year   :       Genre:");
#line 129
    waddnstr(win, (char const   *)tmp___13, -1);
    }
  }
  {
#line 131
  tmp___17 = strlen((char const   *)(help_str));
  }
#line 131
  if ((size_t )maxx > tmp___17) {
    {
#line 132
    tmp___15 = strlen((char const   *)(help_str));
#line 132
    tmp___16 = wmove(win, maxy - 1, (int )(((size_t )maxx - tmp___15) - 1U));
    }
#line 132
    if (! (tmp___16 == -1)) {
      {
#line 132
      waddnstr(win, (char const   *)(help_str), -1);
      }
    }
  }
  {
#line 133
  tmp___20 = strlen("WSPse MP3-Creator");
  }
#line 133
  if ((size_t )maxx > tmp___20) {
    {
#line 134
    tmp___18 = strlen("WSPse MP3-Creator");
#line 134
    tmp___19 = wmove(win, 0, (int )(((size_t )maxx - tmp___18) >> 1));
    }
#line 134
    if (! (tmp___19 == -1)) {
      {
#line 134
      waddnstr(win, "WSPse MP3-Creator", -1);
      }
    }
  }
  {
#line 136
  fill_in_songs(win);
  }
#line 137
  return;
}
}
#line 139 "/home/wslee/benchmarks/sound/mp3c-0.29/src/layout.c"
void draw_song_status(WINDOW *win , song_typ *song ) 
{ 
  int maxx ;
  int maxy ;
  chtype old_ch ;
  char year[10] ;
  int i ;
  long j ;
  char *dirname ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  void *tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  size_t tmp___29 ;
  int tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  void *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;

  {
#line 148
  if (stdscr) {
#line 148
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 148
    maxy = -1;
  }
#line 148
  if (stdscr) {
#line 148
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 148
    maxx = -1;
  }
#line 149
  if (lay_act_side == 0) {
    {
#line 150
    tmp___0 = wmove(win, maxy - 7, 1);
    }
#line 150
    if (! (tmp___0 == -1)) {
      {
#line 150
      tmp = gettext("Track  :   /   [  :  ,~     KB] - Total:   :   [~      KB]");
#line 150
      waddnstr(win, (char const   *)tmp, -1);
      }
    }
  } else {
    {
#line 152
    tmp___2 = wmove(win, maxy - 7, 1);
    }
#line 152
    if (! (tmp___2 == -1)) {
      {
#line 152
      tmp___1 = gettext("Tracks :       [  :  ,~     KB] - Total:   :   [~      KB]");
#line 152
      waddnstr(win, (char const   *)tmp___1, -1);
      }
    }
  }
  {
#line 154
  old_ch = win->_bkgd;
#line 155
  wbkgdset(win, (unsigned long )(2 << 8) | (1UL << 21));
  }
#line 157
  if (lay_act_side == 0) {
    {
#line 158
    sprintf((char */* __restrict  */)(year), (char const   */* __restrict  */)"%02d",
            (int )song->toc + 1);
#line 159
    tmp___3 = wmove(win, maxy - 7, 10);
    }
#line 159
    if (! (tmp___3 == -1)) {
      {
#line 159
      waddnstr(win, (char const   *)(year), -1);
      }
    }
    {
#line 160
    sprintf((char */* __restrict  */)(year), (char const   */* __restrict  */)"%02d",
            track_last);
#line 161
    tmp___4 = wmove(win, maxy - 7, 13);
    }
#line 161
    if (! (tmp___4 == -1)) {
      {
#line 161
      waddnstr(win, (char const   *)(year), -1);
      }
    }
  } else {
    {
#line 163
    sprintf((char */* __restrict  */)(year), (char const   */* __restrict  */)"%05d",
            num_ripped_tracks);
#line 164
    tmp___5 = wmove(win, maxy - 7, 10);
    }
#line 164
    if (! (tmp___5 == -1)) {
      {
#line 164
      waddnstr(win, (char const   *)(year), -1);
      }
    }
  }
  {
#line 167
  j = song->frame_len;
#line 168
  sprintf((char */* __restrict  */)(year), (char const   */* __restrict  */)"%02ld",
          j / 4500L);
#line 169
  tmp___6 = wmove(win, maxy - 7, 17);
  }
#line 169
  if (! (tmp___6 == -1)) {
    {
#line 169
    waddnstr(win, (char const   *)(year), -1);
    }
  }
  {
#line 170
  sprintf((char */* __restrict  */)(year), (char const   */* __restrict  */)"%02ld",
          (j / 75L) % 60L);
#line 171
  tmp___7 = wmove(win, maxy - 7, 20);
  }
#line 171
  if (! (tmp___7 == -1)) {
    {
#line 171
    waddnstr(win, (char const   *)(year), -1);
    }
  }
  {
#line 172
  sprintf((char */* __restrict  */)(year), (char const   */* __restrict  */)"%-5ld",
          (j * (long )mp3_frame_mult) / 1024L);
#line 173
  tmp___8 = wmove(win, maxy - 7, 24);
  }
#line 173
  if (! (tmp___8 == -1)) {
    {
#line 173
    waddnstr(win, (char const   *)(year), -1);
    }
  }
  {
#line 175
  sprintf((char */* __restrict  */)(year), (char const   */* __restrict  */)"%02ld",
          lay_tot_frm[lay_act_side] / 4500UL);
#line 176
  tmp___9 = wmove(win, maxy - 7, 42);
  }
#line 176
  if (! (tmp___9 == -1)) {
    {
#line 176
    waddnstr(win, (char const   *)(year), -1);
    }
  }
  {
#line 177
  sprintf((char */* __restrict  */)(year), (char const   */* __restrict  */)"%02ld",
          (lay_tot_frm[lay_act_side] / 75UL) % 60UL);
#line 178
  tmp___10 = wmove(win, maxy - 7, 45);
  }
#line 178
  if (! (tmp___10 == -1)) {
    {
#line 178
    waddnstr(win, (char const   *)(year), -1);
    }
  }
  {
#line 179
  sprintf((char */* __restrict  */)(year), (char const   */* __restrict  */)"%-6ld",
          (lay_tot_frm[lay_act_side] * (unsigned long )mp3_frame_mult) / 1024UL);
#line 180
  tmp___11 = wmove(win, maxy - 7, 50);
  }
#line 180
  if (! (tmp___11 == -1)) {
    {
#line 180
    waddnstr(win, (char const   *)(year), -1);
    }
  }
  {
#line 182
  sprintf((char */* __restrict  */)(year), (char const   */* __restrict  */)"%04d",
          song->year);
#line 183
  i = maxy - 6;
  }
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! (i < maxy - 2)) {
#line 183
      goto while_break;
    }
    {
#line 184
    wmove(win, i, 10);
#line 185
    whline(win, (chtype )' ', maxx - 11);
#line 183
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 187
  wmove(win, maxy - 2, 23);
#line 188
  whline(win, (chtype )' ', maxx - 26);
#line 189
  tmp___12 = wmove(win, maxy - 6, 10);
  }
#line 189
  if (! (tmp___12 == -1)) {
    {
#line 189
    waddnstr(win, (char const   *)song->title, maxx - 11);
    }
  }
  {
#line 190
  tmp___14 = strlen((char const   *)song->title);
  }
#line 190
  if ((size_t )(maxx - 11) < tmp___14) {
    {
#line 190
    tmp___13 = wmove(win, maxy - 6, maxx - 2);
    }
#line 190
    if (! (tmp___13 == -1)) {
      {
#line 190
      waddch(win, (chtype const   )'~');
      }
    }
  }
  {
#line 191
  tmp___15 = wmove(win, maxy - 5, 10);
  }
#line 191
  if (! (tmp___15 == -1)) {
    {
#line 191
    waddnstr(win, (char const   *)song->artist, maxx - 11);
    }
  }
  {
#line 192
  tmp___17 = strlen((char const   *)song->artist);
  }
#line 192
  if ((size_t )(maxx - 11) < tmp___17) {
    {
#line 192
    tmp___16 = wmove(win, maxy - 5, maxx - 2);
    }
#line 192
    if (! (tmp___16 == -1)) {
      {
#line 192
      waddch(win, (chtype const   )'~');
      }
    }
  }
  {
#line 193
  tmp___18 = wmove(win, maxy - 4, 10);
  }
#line 193
  if (! (tmp___18 == -1)) {
    {
#line 193
    waddnstr(win, (char const   *)song->album, maxx - 11);
    }
  }
  {
#line 194
  tmp___20 = strlen((char const   *)song->album);
  }
#line 194
  if ((size_t )(maxx - 11) < tmp___20) {
    {
#line 194
    tmp___19 = wmove(win, maxy - 4, maxx - 2);
    }
#line 194
    if (! (tmp___19 == -1)) {
      {
#line 194
      waddch(win, (chtype const   )'~');
      }
    }
  }
  {
#line 199
  wmove(win, maxy - 3, 10);
#line 200
  i = maxx - 11;
#line 201
  tmp___28 = strlen((char const   *)song->filename);
  }
#line 201
  if (tmp___28 + 1U >= (size_t )i) {
    {
#line 203
    waddch(win, (chtype const   )'~');
#line 204
    i --;
    }
  } else
#line 205
  if (song->dirname) {
    {
#line 207
    tmp___23 = strlen((char const   *)song->dirname);
    }
#line 207
    if ((int )*((song->dirname + tmp___23) - 1) != 47) {
      {
#line 208
      tmp___21 = strlen((char const   *)song->dirname);
#line 208
      tmp___22 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___21 + 2U)));
#line 208
      dirname = (char *)tmp___22;
      }
#line 209
      if (! dirname) {
        {
#line 210
        wuuush(1);
        }
      }
      {
#line 212
      sprintf((char */* __restrict  */)dirname, (char const   */* __restrict  */)"%s/",
              song->dirname);
      }
    } else {
      {
#line 214
      dirname = copy_char_str(song->dirname);
      }
    }
    {
#line 217
    tmp___24 = strlen((char const   *)song->filename);
#line 217
    j = (long )((size_t )i - tmp___24);
#line 218
    tmp___27 = strlen((char const   *)dirname);
    }
#line 218
    if (j < (long )tmp___27) {
      {
#line 219
      waddch(win, (chtype const   )'~');
#line 220
      j --;
#line 221
      i = (int )((long )i - j);
#line 222
      tmp___25 = strlen((char const   *)dirname);
#line 222
      waddnstr(win, (char const   *)(dirname + ((long )tmp___25 - j)), -1);
      }
    } else {
      {
#line 225
      waddnstr(win, (char const   *)dirname, -1);
#line 227
      tmp___26 = strlen((char const   *)dirname);
#line 227
      i = (int )((size_t )i - tmp___26);
      }
    }
    {
#line 230
    free((void *)dirname);
    }
  }
  {
#line 234
  tmp___29 = strlen((char const   *)song->filename);
  }
#line 234
  if ((size_t )i < tmp___29) {
    {
#line 235
    waddnstr(win, (char const   *)song->filename, i - 1);
#line 236
    waddch(win, (chtype const   )'~');
    }
  } else {
    {
#line 238
    waddnstr(win, (char const   *)song->filename, -1);
    }
  }
  {
#line 241
  tmp___30 = wmove(win, maxy - 2, 10);
  }
#line 241
  if (! (tmp___30 == -1)) {
    {
#line 241
    waddnstr(win, (char const   *)(year), 4);
    }
  }
  {
#line 242
  tmp___32 = wmove(win, maxy - 2, 23);
  }
#line 242
  if (! (tmp___32 == -1)) {
#line 242
    if (song->genre != 147) {
#line 242
      tmp___31 = mp3_genre[song->genre];
    } else {
#line 242
      tmp___31 = def_unknown_gen;
    }
    {
#line 242
    waddnstr(win, (char const   *)tmp___31, 20);
    }
  }
  {
#line 244
  waddnstr(win, "  ", -1);
  }
#line 245
  if (! song->on_fly) {
    {
#line 245
    wbkgdset(win, old_ch);
    }
  } else {
    {
#line 246
    wbkgdset(win, (chtype )(4 << 8));
    }
  }
#line 247
  if (lay_act_side == 0) {
    {
#line 247
    tmp___33 = gettext("[on fly]");
#line 247
    waddnstr(win, (char const   *)tmp___33, -1);
    }
  } else {
    {
#line 248
    tmp___34 = gettext("[delete]");
#line 248
    waddnstr(win, (char const   *)tmp___34, -1);
    }
  }
  {
#line 250
  wbkgdset(win, old_ch);
#line 251
  waddnstr(win, " ", -1);
  }
#line 252
  if (config_cddb_enbl) {
    {
#line 252
    wbkgdset(win, (chtype )(4 << 8));
    }
  }
  {
#line 253
  tmp___35 = gettext("[CDDB]");
#line 253
  waddnstr(win, (char const   *)tmp___35, -1);
#line 255
  wbkgdset(win, old_ch);
#line 256
  waddnstr(win, " ", -1);
  }
#line 257
  if (song->sampler) {
    {
#line 257
    wbkgdset(win, (chtype )(4 << 8));
    }
  }
  {
#line 258
  tmp___36 = gettext("[Sampler]");
#line 258
  waddnstr(win, (char const   *)tmp___36, -1);
#line 260
  wbkgdset(win, old_ch);
  }
#line 261
  return;
}
}
#line 263 "/home/wslee/benchmarks/sound/mp3c-0.29/src/layout.c"
void draw_song_line(WINDOW *win , song_typ *song , unsigned char marked , int line ) 
{ 
  int maxx ;
  int maxy ;
  chtype old_ch ;
  chtype new_ch ;
  char *buf ;
  int i ;
  int divider ;
  int start ;
  int end ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 271
  if (stdscr) {
#line 271
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 271
    maxy = -1;
  }
#line 271
  if (stdscr) {
#line 271
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 271
    maxx = -1;
  }
#line 272
  old_ch = win->_bkgd;
#line 273
  i = 0;
#line 274
  if (marked) {
#line 274
    i |= 2;
  }
#line 275
  if (song->convert) {
#line 275
    i |= 1;
  }
#line 276
  new_ch = (chtype )((i + 1) << 8);
#line 277
  if (song->convert) {
#line 277
    new_ch |= 1UL << 21;
  }
  {
#line 278
  wbkgdset(win, new_ch);
#line 280
  divider = calc_divider_pos(maxx);
#line 282
  start = 1;
#line 283
  end = maxx - 2;
  }
#line 284
  if (divider != -1) {
#line 285
    if (lay_act_side == 0) {
#line 285
      end = divider - 1;
    } else {
#line 286
      start = divider + 1;
    }
  }
  {
#line 289
  wmove(win, line, start);
#line 290
  whline(win, (chtype )' ', (end - start) + 1);
#line 292
  tmp = strlen((char const   *)song->title);
#line 292
  tmp___0 = strlen((char const   *)song->artist);
#line 292
  tmp___1 = malloc((size_t )(sizeof(char ) * (unsigned long )((tmp + tmp___0) + 4U)));
#line 292
  buf = (char *)tmp___1;
  }
#line 294
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 295
    perror("malloc");
#line 296
    wuuush(1);
    }
  }
  {
#line 299
  sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%s (%s)",
          song->title, song->artist);
#line 300
  waddnstr(win, (char const   *)buf, (end - start) + 1);
#line 301
  free((void *)buf);
#line 303
  wbkgdset(win, old_ch);
  }
#line 304
  return;
}
}
#line 306 "/home/wslee/benchmarks/sound/mp3c-0.29/src/layout.c"
void lay_fill_left(WINDOW *win , unsigned char do_mark ) 
{ 
  int i ;
  int maxx ;
  int maxy ;
  song_typ *curr ;
  int divider ;
  int end ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 313
  lay_curr_anchor[0] = (song_typ *)((void *)0);
#line 315
  if (lay_divider == 0) {
#line 315
    return;
  }
#line 317
  if (stdscr) {
#line 317
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 317
    maxy = -1;
  }
#line 317
  if (stdscr) {
#line 317
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 317
    maxx = -1;
  }
  {
#line 318
  divider = calc_divider_pos(maxx);
  }
#line 320
  if (divider != -1) {
#line 320
    end = divider - 1;
  } else {
#line 321
    end = maxx - 1;
  }
#line 323
  i = 1;
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (! (i <= maxy - 9)) {
#line 323
      goto while_break;
    }
    {
#line 323
    tmp = wmove(win, i, 1);
    }
#line 323
    if (! (tmp == -1)) {
      {
#line 323
      whline(win, (chtype )' ', end - 1);
      }
    }
#line 323
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 325
  i = 1;
#line 326
  curr = lay_top_anchor[0];
#line 329
  if (! curr) {
    {
#line 330
    tmp___1 = wmove(win, 1, 1);
    }
#line 330
    if (! (tmp___1 == -1)) {
      {
#line 330
      tmp___0 = gettext("no cd-volume or illegal device");
#line 330
      waddnstr(win, (char const   *)tmp___0, end - 1);
      }
    }
    {
#line 331
    tmp___3 = wmove(win, 2, 2);
    }
#line 331
    if (! (tmp___3 == -1)) {
      {
#line 331
      tmp___2 = gettext("press \"F2\" for configmenu");
#line 331
      waddnstr(win, (char const   *)tmp___2, end - 2);
      }
    }
    {
#line 332
    tmp___5 = wmove(win, 3, 2);
    }
#line 332
    if (! (tmp___5 == -1)) {
      {
#line 332
      tmp___4 = gettext("or insert cd an press \"V\"");
#line 332
      waddnstr(win, (char const   *)tmp___4, end - 2);
      }
    }
#line 333
    return;
  }
  {
#line 336
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 336
    if (! ((unsigned long )curr != (unsigned long )((void *)0))) {
#line 336
      goto while_break___0;
    }
#line 337
    if (i == lay_select_line[0]) {
      {
#line 338
      draw_song_line(win, curr, do_mark, i);
#line 339
      draw_song_status(win, curr);
#line 340
      lay_curr_anchor[0] = curr;
      }
    } else {
      {
#line 342
      draw_song_line(win, curr, (unsigned char)0, i);
      }
    }
#line 344
    if (i == maxy - 9) {
#line 344
      goto while_break___0;
    }
#line 345
    i ++;
#line 346
    curr = curr->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 348
  return;
}
}
#line 350 "/home/wslee/benchmarks/sound/mp3c-0.29/src/layout.c"
void lay_fill_right(WINDOW *win , unsigned char do_mark ) 
{ 
  int i ;
  int maxx ;
  int maxy ;
  song_typ *curr ;
  int divider ;
  int start ;
  int tmp ;

  {
#line 357
  lay_curr_anchor[1] = (song_typ *)((void *)0);
#line 359
  if (lay_divider == 100) {
#line 359
    return;
  }
#line 361
  if (stdscr) {
#line 361
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 361
    maxy = -1;
  }
#line 361
  if (stdscr) {
#line 361
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 361
    maxx = -1;
  }
  {
#line 362
  divider = calc_divider_pos(maxx);
  }
#line 364
  if (divider != -1) {
#line 364
    start = divider + 1;
  } else {
#line 365
    start = 1;
  }
#line 367
  i = 1;
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (! (i <= maxy - 9)) {
#line 367
      goto while_break;
    }
    {
#line 367
    tmp = wmove(win, i, start);
    }
#line 367
    if (! (tmp == -1)) {
      {
#line 367
      whline(win, (chtype )' ', (maxx - 1) - start);
      }
    }
#line 367
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  i = 1;
#line 370
  curr = lay_top_anchor[1];
  {
#line 372
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 372
    if (! ((unsigned long )curr != (unsigned long )((void *)0))) {
#line 372
      goto while_break___0;
    }
#line 373
    if (i == lay_select_line[1]) {
      {
#line 374
      draw_song_line(win, curr, do_mark, i);
#line 375
      draw_song_status(win, curr);
#line 376
      lay_curr_anchor[1] = curr;
      }
    } else {
      {
#line 378
      draw_song_line(win, curr, (unsigned char)0, i);
      }
    }
#line 380
    if (i == maxy - 9) {
#line 380
      goto while_break___0;
    }
#line 381
    i ++;
#line 382
    curr = curr->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 384
  return;
}
}
#line 386 "/home/wslee/benchmarks/sound/mp3c-0.29/src/layout.c"
void fill_in_songs(WINDOW *win ) 
{ 


  {
#line 388
  if (lay_act_side == 1) {
    {
#line 389
    lay_act_side = 0;
#line 390
    lay_fill_left(win, (unsigned char)0);
#line 391
    lay_act_side = 1;
#line 392
    lay_fill_right(win, (unsigned char)1);
    }
  } else {
    {
#line 394
    lay_act_side = 1;
#line 395
    lay_fill_right(win, (unsigned char)0);
#line 396
    lay_act_side = 0;
#line 397
    lay_fill_left(win, (unsigned char)1);
    }
  }
#line 399
  return;
}
}
#line 401 "/home/wslee/benchmarks/sound/mp3c-0.29/src/layout.c"
void fill_in_side(WINDOW *win , int side ) 
{ 


  {
#line 403
  if (side == 0) {
    {
#line 403
    lay_fill_left(win, (unsigned char)1);
    }
  } else {
    {
#line 404
    lay_fill_right(win, (unsigned char)1);
    }
  }
#line 405
  return;
}
}
#line 407 "/home/wslee/benchmarks/sound/mp3c-0.29/src/layout.c"
void layout_update_cddb_flag(WINDOW *win ) 
{ 


  {
#line 409
  if (lay_global_anchor[lay_act_side]) {
#line 409
    if (lay_curr_anchor[lay_act_side]) {
      {
#line 410
      draw_song_status(win, lay_curr_anchor[lay_act_side]);
      }
    } else {
      {
#line 412
      fill_in_songs(win);
      }
    }
  } else {
    {
#line 412
    fill_in_songs(win);
    }
  }
#line 415
  return;
}
}
#line 51 "/home/wslee/benchmarks/sound/mp3c-0.29/src/keys.c"
int play_track(int tr_begin , int tr_end ) ;
#line 52
int stop_cd(void) ;
#line 67
void pop_up_help(void) ;
#line 78
int cddb_internet_lookup(char *addr___0 , char *cddb_path , unsigned char force ) ;
#line 80
int output_batch(song_typ *anchor , char *filenm , unsigned char ask_overwrite ) ;
#line 83
int eject_cd(void) ;
#line 84
int close_tray(void) ;
#line 94
int cddb_save_cddb_entry(song_typ *song_list , char *cddb_path ) ;
#line 95
int cddb_submit_cddb_entry(song_typ *song_list ) ;
#line 119 "/home/wslee/benchmarks/sound/mp3c-0.29/src/keys.c"
void a_t_swap(song_typ *song ) 
{ 
  char *pointer ;

  {
  {
#line 123
  pointer = song->title;
#line 124
  song->title = song->artist;
#line 125
  song->artist = pointer;
#line 126
  filenm_generate(song);
  }
#line 127
  return;
}
}
#line 130 "/home/wslee/benchmarks/sound/mp3c-0.29/src/keys.c"
void reinit_volume(WINDOW *win ) 
{ 
  song_typ *anchor ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 135
  free_song_typ(& lay_global_anchor[0]);
#line 137
  lay_global_anchor[0] = (song_typ *)((void *)0);
#line 138
  lay_top_anchor[0] = (song_typ *)((void *)0);
#line 139
  lay_curr_anchor[0] = (song_typ *)((void *)0);
#line 140
  lay_select_line[0] = 1;
#line 141
  setup_stat_win(50);
#line 143
  tmp = gettext("reinitialising cd");
#line 143
  print_stat_win(tmp);
#line 144
  close_cdrom();
#line 145
  tmp___2 = init_cd();
  }
#line 145
  if (tmp___2 != 0) {
#line 146
    if (cd_drv == -2) {
      {
#line 147
      tmp___0 = gettext("no cd-volume inserted");
#line 147
      popup_error_win(tmp___0);
      }
    } else {
      {
#line 149
      tmp___1 = gettext("failed to open cdrom device");
#line 149
      popup_error_win(tmp___1);
      }
    }
  } else {
    {
#line 152
    build_data_tree(def_cddb_server, def_cddb_bank, & anchor, (unsigned char)0);
#line 153
    lay_top_anchor[0] = anchor;
#line 154
    lay_global_anchor[0] = anchor;
#line 155
    calc_tot_frm();
    }
  }
  {
#line 158
  destroy_stat_win();
#line 159
  fill_in_songs(win);
  }
#line 160
  return;
}
}
#line 162 "/home/wslee/benchmarks/sound/mp3c-0.29/src/keys.c"
void init_sampler(WINDOW *win ) 
{ 
  song_typ *anchor ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 166
  free_song_typ(& lay_global_anchor[0]);
#line 168
  lay_global_anchor[0] = (song_typ *)((void *)0);
#line 169
  lay_top_anchor[0] = (song_typ *)((void *)0);
#line 170
  lay_curr_anchor[0] = (song_typ *)((void *)0);
#line 171
  lay_select_line[0] = 1;
#line 172
  setup_stat_win(50);
#line 174
  tmp = gettext("interpreting CDDB as sampler");
#line 174
  print_stat_win(tmp);
#line 175
  build_data_tree(def_cddb_server, def_cddb_bank, & anchor, (unsigned char)1);
#line 176
  lay_top_anchor[0] = anchor;
#line 177
  lay_global_anchor[0] = anchor;
#line 178
  calc_tot_frm();
#line 180
  destroy_stat_win();
#line 181
  fill_in_songs(win);
  }
#line 182
  return;
}
}
#line 185 "/home/wslee/benchmarks/sound/mp3c-0.29/src/keys.c"
void keys_open_tray(WINDOW *win ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 187
  setup_stat_win(50);
#line 188
  tmp = gettext("ejecting cdrom");
#line 188
  print_stat_win(tmp);
#line 189
  tmp___2 = eject_cd();
  }
#line 189
  if (tmp___2) {
    {
#line 190
    tmp___0 = gettext("ejecting failed...");
#line 190
    popup_error_win(tmp___0);
    }
  } else {
    {
#line 192
    tmp___1 = gettext("ok");
#line 192
    print_stat_win(tmp___1);
    }
  }
  {
#line 195
  free_song_typ(& lay_global_anchor[0]);
#line 196
  lay_global_anchor[0] = (song_typ *)((void *)0);
#line 197
  lay_top_anchor[0] = (song_typ *)((void *)0);
#line 198
  lay_curr_anchor[0] = (song_typ *)((void *)0);
#line 199
  lay_select_line[0] = 1;
#line 201
  destroy_stat_win();
  }
#line 203
  if (lay_global_anchor[1]) {
    {
#line 204
    lay_act_side = 1;
#line 205
    fill_in_songs(win);
    }
  } else {
    {
#line 207
    fill_in_side(win, 0);
    }
  }
#line 209
  return;
}
}
#line 212 "/home/wslee/benchmarks/sound/mp3c-0.29/src/keys.c"
unsigned char keys_joblist_is_empty(song_typ *list ) 
{ 
  song_typ *curr ;

  {
#line 216
  curr = list;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! curr) {
#line 217
      goto while_break;
    }
#line 218
    if (curr->convert) {
#line 218
      return ((unsigned char)0);
    }
#line 219
    curr = curr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return ((unsigned char)1);
}
}
#line 226 "/home/wslee/benchmarks/sound/mp3c-0.29/src/keys.c"
void main_loop(WINDOW *win ) 
{ 
  int inp_ch ;
  char *pointer1 ;
  char *pointer3 ;
  char *pointer4 ;
  song_typ *pointer2 ;
  song_typ *old_song ;
  int i ;
  unsigned char abort_flag ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  unsigned char tmp___12 ;
  unsigned char tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  unsigned char tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  size_t tmp___23 ;
  void *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  size_t tmp___31 ;
  void *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  size_t tmp___35 ;
  void *tmp___36 ;
  char *tmp___37 ;
  size_t tmp___38 ;
  void *tmp___39 ;
  char *tmp___40 ;
  void *tmp___41 ;
  void *tmp___42 ;
  char *tmp___43 ;
  size_t tmp___44 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;

  {
  {
#line 234
  cbreak();
#line 235
  noecho();
#line 236
  keypad(win, (_Bool)1);
  }
#line 237
  if (config_fancy_colors) {
    {
#line 238
    halfdelay(1);
    }
  } else {
    {
#line 240
    nodelay(win, (_Bool)0);
    }
  }
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (config_fancy_colors) {
      {
#line 243
      win_effect(win, (unsigned char)1, (unsigned char)0);
      }
    }
    {
#line 244
    waitpid(0, (int *)((void *)0), 1);
#line 245
    inp_ch = wgetch(win);
    }
#line 246
    if ((unsigned long )lay_curr_anchor[lay_act_side] != (unsigned long )((void *)0)) {
      {
#line 248
      if (inp_ch == 258) {
#line 248
        goto case_258;
      }
#line 252
      if (inp_ch == 259) {
#line 252
        goto case_259;
      }
#line 257
      if (inp_ch == 362) {
#line 257
        goto case_362;
      }
#line 257
      if (inp_ch == 262) {
#line 257
        goto case_362;
      }
#line 262
      if (inp_ch == 385) {
#line 262
        goto case_385;
      }
#line 262
      if (inp_ch == 360) {
#line 262
        goto case_385;
      }
#line 266
      if (inp_ch == 339) {
#line 266
        goto case_339;
      }
#line 270
      if (inp_ch == 338) {
#line 270
        goto case_338;
      }
#line 275
      if (inp_ch == 32) {
#line 275
        goto case_32;
      }
#line 275
      if (inp_ch == 330) {
#line 275
        goto case_32;
      }
#line 289
      if (inp_ch == 76) {
#line 289
        goto case_76;
      }
#line 302
      if (inp_ch == 83) {
#line 302
        goto case_83;
      }
#line 302
      if (inp_ch == 115) {
#line 302
        goto case_83;
      }
#line 310
      if (inp_ch == 79) {
#line 310
        goto case_79;
      }
#line 310
      if (inp_ch == 111) {
#line 310
        goto case_79;
      }
#line 318
      if (inp_ch == 80) {
#line 318
        goto case_80;
      }
#line 318
      if (inp_ch == 112) {
#line 318
        goto case_80;
      }
#line 324
      if (inp_ch == 88) {
#line 324
        goto case_88;
      }
#line 324
      if (inp_ch == 120) {
#line 324
        goto case_88;
      }
#line 331
      if (inp_ch == 55) {
#line 331
        goto case_55;
      }
#line 331
      if (inp_ch == 271) {
#line 331
        goto case_55;
      }
#line 331
      if (inp_ch == 52) {
#line 331
        goto case_55;
      }
#line 331
      if (inp_ch == 268) {
#line 331
        goto case_55;
      }
#line 371
      if (inp_ch == 56) {
#line 371
        goto case_56;
      }
#line 371
      if (inp_ch == 272) {
#line 371
        goto case_56;
      }
#line 378
      if (inp_ch == 57) {
#line 378
        goto case_57;
      }
#line 378
      if (inp_ch == 273) {
#line 378
        goto case_57;
      }
#line 385
      if (inp_ch == 71) {
#line 385
        goto case_71;
      }
#line 385
      if (inp_ch == 103) {
#line 385
        goto case_71;
      }
#line 395
      if (inp_ch == 84) {
#line 395
        goto case_84;
      }
#line 395
      if (inp_ch == 116) {
#line 395
        goto case_84;
      }
#line 412
      if (inp_ch == 65) {
#line 412
        goto case_65;
      }
#line 412
      if (inp_ch == 97) {
#line 412
        goto case_65;
      }
#line 427
      if (inp_ch == 66) {
#line 427
        goto case_66;
      }
#line 427
      if (inp_ch == 98) {
#line 427
        goto case_66;
      }
#line 442
      if (inp_ch == 67) {
#line 442
        goto case_67;
      }
#line 442
      if (inp_ch == 99) {
#line 442
        goto case_67;
      }
#line 457
      if (inp_ch == 89) {
#line 457
        goto case_89;
      }
#line 457
      if (inp_ch == 121) {
#line 457
        goto case_89;
      }
#line 484
      if (inp_ch == 13) {
#line 484
        goto case_13;
      }
#line 484
      if (inp_ch == 10) {
#line 484
        goto case_13;
      }
#line 484
      if (inp_ch == 343) {
#line 484
        goto case_13;
      }
#line 489
      if (inp_ch == 119) {
#line 489
        goto case_119;
      }
#line 495
      if (inp_ch == 87) {
#line 495
        goto case_87;
      }
#line 247
      goto switch_break;
      case_258: /* CIL Label */ 
      {
#line 249
      song_move_down(win, (unsigned char)1);
      }
#line 250
      goto switch_break;
      case_259: /* CIL Label */ 
      {
#line 253
      song_move_up(win, (unsigned char)1);
      }
#line 254
      goto switch_break;
      case_362: /* CIL Label */ 
      case_262: /* CIL Label */ 
      {
#line 258
      song_move_top(win, (unsigned char)1);
      }
#line 259
      goto switch_break;
      case_385: /* CIL Label */ 
      case_360: /* CIL Label */ 
      {
#line 263
      song_move_bottom(win, (unsigned char)1);
      }
#line 264
      goto switch_break;
      case_339: /* CIL Label */ 
      {
#line 267
      song_move_pup(win, (unsigned char)1);
      }
#line 268
      goto switch_break;
      case_338: /* CIL Label */ 
      {
#line 271
      song_move_pdown(win, (unsigned char)1);
      }
#line 272
      goto switch_break;
      case_32: /* CIL Label */ 
      case_330: /* CIL Label */ 
#line 276
      if ((lay_curr_anchor[lay_act_side])->convert) {
#line 277
        (lay_curr_anchor[lay_act_side])->convert = (unsigned char)0;
#line 278
        lay_tot_frm[lay_act_side] -= (unsigned long )(lay_curr_anchor[lay_act_side])->frame_len;
      } else {
#line 280
        (lay_curr_anchor[lay_act_side])->convert = (unsigned char)1;
#line 281
        lay_tot_frm[lay_act_side] += (unsigned long )(lay_curr_anchor[lay_act_side])->frame_len;
      }
      {
#line 283
      draw_song_line(win, lay_curr_anchor[lay_act_side], (unsigned char)1, lay_select_line[lay_act_side]);
#line 284
      draw_song_status(win, lay_curr_anchor[lay_act_side]);
#line 285
      song_move_down(win, (unsigned char)0);
#line 286
      wrefresh(win);
      }
#line 287
      goto switch_break;
      case_76: /* CIL Label */ 
#line 290
      if ((lay_curr_anchor[lay_act_side])->sampler) {
#line 291
        (lay_curr_anchor[lay_act_side])->sampler = (unsigned char)0;
      } else {
#line 293
        (lay_curr_anchor[lay_act_side])->sampler = (unsigned char)1;
      }
      {
#line 295
      filenm_generate(lay_curr_anchor[lay_act_side]);
#line 296
      draw_song_status(win, lay_curr_anchor[lay_act_side]);
#line 297
      song_move_down(win, (unsigned char)0);
#line 298
      wrefresh(win);
      }
#line 299
      goto switch_break;
      case_83: /* CIL Label */ 
      case_115: /* CIL Label */ 
      {
#line 303
      a_t_swap(lay_curr_anchor[lay_act_side]);
#line 304
      draw_song_line(win, lay_curr_anchor[lay_act_side], (unsigned char)1, lay_select_line[lay_act_side]);
#line 305
      draw_song_status(win, lay_curr_anchor[lay_act_side]);
#line 306
      wrefresh(win);
      }
#line 307
      goto switch_break;
      case_79: /* CIL Label */ 
      case_111: /* CIL Label */ 
#line 311
      if ((lay_curr_anchor[lay_act_side])->on_fly) {
#line 311
        (lay_curr_anchor[lay_act_side])->on_fly = (unsigned char)0;
      } else {
#line 312
        (lay_curr_anchor[lay_act_side])->on_fly = (unsigned char)1;
      }
      {
#line 313
      draw_song_status(win, lay_curr_anchor[lay_act_side]);
#line 314
      wrefresh(win);
      }
#line 315
      goto switch_break;
      case_80: /* CIL Label */ 
      case_112: /* CIL Label */ 
#line 319
      if (lay_act_side == 0) {
        {
#line 320
        play_track((int )(lay_curr_anchor[lay_act_side])->toc + 1, (int )(lay_curr_anchor[lay_act_side])->toc + 1);
        }
      }
#line 321
      goto switch_break;
      case_88: /* CIL Label */ 
      case_120: /* CIL Label */ 
      {
#line 325
      stop_cd();
      }
#line 326
      goto switch_break;
      case_55: /* CIL Label */ 
      case_271: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_268: /* CIL Label */ 
#line 332
      if (lay_act_side == 0) {
#line 333
        if (inp_ch == 268) {
#line 333
          goto _L;
        } else
#line 333
        if (inp_ch == 52) {
#line 333
          goto _L;
        } else
#line 333
        if ((lay_curr_anchor[lay_act_side])->on_fly) {
          _L: /* CIL Label */ 
#line 334
          if ((lay_curr_anchor[lay_act_side])->on_fly) {
            {
#line 335
            tmp = conv_on_fly(lay_curr_anchor[lay_act_side]);
            }
#line 335
            if (tmp) {
#line 335
              goto switch_break;
            }
            {
#line 336
            tmp___0 = set_mp3_inf(lay_curr_anchor[lay_act_side]);
            }
#line 336
            if (tmp___0) {
#line 336
              goto switch_break;
            }
            {
#line 337
            add_to_m3u(lay_curr_anchor[lay_act_side]);
            }
#line 338
            if ((lay_curr_anchor[lay_act_side])->convert) {
#line 339
              (lay_curr_anchor[lay_act_side])->convert = (unsigned char)0;
#line 340
              lay_tot_frm[lay_act_side] -= (unsigned long )(lay_curr_anchor[lay_act_side])->frame_len;
            }
            {
#line 342
            song_move_down(win, (unsigned char)1);
#line 343
            draw_song_status(win, lay_curr_anchor[lay_act_side]);
            }
          } else {
            {
#line 345
            tmp___1 = rip_non_fly(lay_curr_anchor[lay_act_side]);
            }
#line 345
            if (tmp___1) {
#line 345
              goto switch_break;
            }
            {
#line 346
            tmp___2 = enc_non_fly(lay_curr_anchor[lay_act_side], (unsigned char)1);
            }
#line 346
            if (tmp___2) {
              {
#line 347
              rhand_add_ripped(lay_curr_anchor[lay_act_side], win);
#line 348
              song_move_down(win, (unsigned char)1);
              }
#line 349
              goto switch_break;
            }
            {
#line 351
            tmp___3 = set_mp3_inf(lay_curr_anchor[lay_act_side]);
            }
#line 351
            if (tmp___3) {
#line 351
              goto switch_break;
            }
            {
#line 352
            add_to_m3u(lay_curr_anchor[lay_act_side]);
            }
#line 353
            if ((lay_curr_anchor[lay_act_side])->convert) {
#line 354
              (lay_curr_anchor[lay_act_side])->convert = (unsigned char)0;
#line 355
              lay_tot_frm[lay_act_side] -= (unsigned long )(lay_curr_anchor[lay_act_side])->frame_len;
            }
            {
#line 357
            draw_song_status(win, lay_curr_anchor[lay_act_side]);
#line 358
            song_move_down(win, (unsigned char)1);
            }
          }
        } else {
          {
#line 361
          tmp___4 = rip_non_fly(lay_curr_anchor[lay_act_side]);
          }
#line 361
          if (tmp___4) {
#line 361
            goto switch_break;
          }
          {
#line 362
          rhand_add_ripped(lay_curr_anchor[lay_act_side], win);
#line 363
          song_move_down(win, (unsigned char)1);
          }
        }
      } else {
        {
#line 366
        rhand_do_enc(lay_curr_anchor[lay_act_side], win);
        }
      }
#line 368
      goto switch_break;
      case_56: /* CIL Label */ 
      case_272: /* CIL Label */ 
#line 372
      if (lay_act_side == 1) {
        {
#line 373
        rhand_del_marked(win);
        }
      }
#line 375
      goto switch_break;
      case_57: /* CIL Label */ 
      case_273: /* CIL Label */ 
#line 379
      if (lay_act_side == 1) {
        {
#line 380
        rhand_del_actual(win);
        }
      }
#line 382
      goto switch_break;
      case_71: /* CIL Label */ 
      case_103: /* CIL Label */ 
      {
#line 386
      i = select_genre();
      }
#line 387
      if (i != -1) {
        {
#line 388
        (lay_curr_anchor[lay_act_side])->genre = i;
#line 389
        draw_song_status(win, lay_curr_anchor[lay_act_side]);
#line 390
        wrefresh(win);
        }
      }
#line 392
      goto switch_break;
      case_84: /* CIL Label */ 
      case_116: /* CIL Label */ 
      {
#line 396
      pointer2 = lay_curr_anchor[lay_act_side];
#line 397
      tmp___5 = gettext("Input title for this track");
#line 397
      pointer1 = input_line(7, (lay_curr_anchor[lay_act_side])->title, tmp___5, (unsigned char)1);
      }
#line 398
      if (pointer1) {
        {
#line 399
        free((void *)pointer2->title);
#line 400
        pointer2->title = pointer1;
#line 401
        filenm_generate(pointer2);
        }
      }
#line 403
      if ((unsigned long )pointer2 == (unsigned long )lay_curr_anchor[lay_act_side]) {
        {
#line 404
        draw_song_line(win, lay_curr_anchor[lay_act_side], (unsigned char)1, lay_select_line[lay_act_side]);
#line 405
        draw_song_status(win, lay_curr_anchor[lay_act_side]);
        }
      } else {
        {
#line 407
        fill_in_songs(win);
        }
      }
#line 409
      goto switch_break;
      case_65: /* CIL Label */ 
      case_97: /* CIL Label */ 
      {
#line 413
      pointer2 = lay_curr_anchor[lay_act_side];
#line 414
      tmp___6 = gettext("Input artist for this track");
#line 414
      pointer1 = input_line(7, (lay_curr_anchor[lay_act_side])->artist, tmp___6, (unsigned char)1);
      }
#line 415
      if (pointer1) {
        {
#line 416
        free((void *)pointer2->artist);
#line 417
        pointer2->artist = pointer1;
#line 418
        filenm_generate(pointer2);
        }
      }
#line 420
      if ((unsigned long )pointer2 == (unsigned long )lay_curr_anchor[lay_act_side]) {
        {
#line 421
        draw_song_line(win, lay_curr_anchor[lay_act_side], (unsigned char)1, lay_select_line[lay_act_side]);
#line 422
        draw_song_status(win, lay_curr_anchor[lay_act_side]);
        }
      } else {
        {
#line 423
        fill_in_side(win, lay_act_side);
        }
      }
#line 424
      goto switch_break;
      case_66: /* CIL Label */ 
      case_98: /* CIL Label */ 
      {
#line 428
      pointer2 = lay_curr_anchor[lay_act_side];
#line 429
      tmp___7 = gettext("Input albumname for this track");
#line 429
      pointer1 = input_line(7, (lay_curr_anchor[lay_act_side])->album, tmp___7, (unsigned char)1);
      }
#line 430
      if (pointer1) {
        {
#line 431
        free((void *)pointer2->album);
#line 432
        pointer2->album = pointer1;
#line 433
        filenm_generate(pointer2);
        }
      }
#line 435
      if ((unsigned long )pointer2 == (unsigned long )lay_curr_anchor[lay_act_side]) {
        {
#line 436
        draw_song_line(win, lay_curr_anchor[lay_act_side], (unsigned char)1, lay_select_line[lay_act_side]);
#line 437
        draw_song_status(win, lay_curr_anchor[lay_act_side]);
        }
      } else {
        {
#line 438
        fill_in_side(win, lay_act_side);
        }
      }
#line 439
      goto switch_break;
      case_67: /* CIL Label */ 
      case_99: /* CIL Label */ 
      {
#line 443
      pointer2 = lay_curr_anchor[lay_act_side];
#line 444
      tmp___8 = gettext("Input comment for this track");
#line 444
      pointer1 = input_line(7, (lay_curr_anchor[lay_act_side])->comment, tmp___8,
                            (unsigned char)1);
      }
#line 445
      if (pointer1) {
        {
#line 446
        free((void *)pointer2->comment);
#line 447
        pointer2->comment = pointer1;
#line 448
        filenm_generate(pointer2);
        }
      }
#line 450
      if ((unsigned long )pointer2 == (unsigned long )lay_curr_anchor[lay_act_side]) {
        {
#line 451
        draw_song_line(win, lay_curr_anchor[lay_act_side], (unsigned char)1, lay_select_line[lay_act_side]);
#line 452
        draw_song_status(win, lay_curr_anchor[lay_act_side]);
        }
      } else {
        {
#line 453
        fill_in_side(win, lay_act_side);
        }
      }
#line 454
      goto switch_break;
      case_89: /* CIL Label */ 
      case_121: /* CIL Label */ 
      {
#line 458
      pointer2 = lay_curr_anchor[lay_act_side];
#line 459
      tmp___9 = malloc((size_t )(sizeof(char ) * 7UL));
#line 459
      pointer3 = (char *)tmp___9;
      }
#line 460
      if (! pointer3) {
        {
#line 461
        perror("malloc");
#line 462
        wuuush(1);
        }
      }
      {
#line 464
      sprintf((char */* __restrict  */)pointer3, (char const   */* __restrict  */)"%d",
              (lay_curr_anchor[lay_act_side])->year);
#line 465
      tmp___10 = gettext("Input year for this track");
#line 465
      pointer1 = input_line(7, pointer3, tmp___10, (unsigned char)1);
#line 466
      free((void *)pointer3);
      }
#line 467
      if (pointer1) {
        {
#line 468
        tmp___11 = strlen((char const   *)pointer1);
        }
#line 468
        if (tmp___11 <= 4U) {
          {
#line 469
          (lay_curr_anchor[lay_act_side])->year = atoi((char const   *)pointer1);
          }
#line 470
          if ((lay_curr_anchor[lay_act_side])->year < 0) {
#line 471
            (lay_curr_anchor[lay_act_side])->year = 1999;
          } else
#line 470
          if ((lay_curr_anchor[lay_act_side])->year > 9999) {
#line 471
            (lay_curr_anchor[lay_act_side])->year = 1999;
          }
        }
        {
#line 473
        free((void *)pointer1);
#line 474
        filenm_generate(pointer2);
        }
      }
#line 476
      if ((unsigned long )pointer2 == (unsigned long )lay_curr_anchor[lay_act_side]) {
        {
#line 477
        draw_song_line(win, lay_curr_anchor[lay_act_side], (unsigned char)1, lay_select_line[lay_act_side]);
#line 478
        draw_song_status(win, lay_curr_anchor[lay_act_side]);
        }
      } else {
        {
#line 479
        fill_in_songs(win);
        }
      }
#line 480
      goto switch_break;
      case_13: /* CIL Label */ 
      case_10: /* CIL Label */ 
      case_343: /* CIL Label */ 
      {
#line 485
      alter_track_infos_menu(lay_curr_anchor[lay_act_side]);
#line 486
      fill_in_songs(win);
      }
#line 487
      goto switch_break;
      case_119: /* CIL Label */ 
#line 490
      if (lay_act_side == 1) {
        {
#line 491
        rhand_save_ripped(def_exp_file, clear_del_on_exp, 0);
        }
      }
#line 493
      goto switch_break;
      case_87: /* CIL Label */ 
      {
#line 496
      rhand_save_ripped(def_exp_file, clear_del_on_exp, 1);
      }
#line 497
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 502
    if (inp_ch == 12) {
#line 502
      goto case_12;
    }
#line 502
    if (inp_ch == 373) {
#line 502
      goto case_12;
    }
#line 508
    if (inp_ch == 9) {
#line 508
      goto case_9;
    }
#line 508
    if (inp_ch == 341) {
#line 508
      goto case_9;
    }
#line 508
    if (inp_ch == 340) {
#line 508
      goto case_9;
    }
#line 518
    if (inp_ch == 101) {
#line 518
      goto case_101;
    }
#line 522
    if (inp_ch == 69) {
#line 522
      goto case_69;
    }
#line 527
    if (inp_ch == 108) {
#line 527
      goto case_108;
    }
#line 534
    if (inp_ch == 68) {
#line 534
      goto case_68;
    }
#line 534
    if (inp_ch == 100) {
#line 534
      goto case_68;
    }
#line 538
    if (inp_ch == 109) {
#line 538
      goto case_109;
    }
#line 542
    if (inp_ch == 77) {
#line 542
      goto case_77;
    }
#line 546
    if (inp_ch == 42) {
#line 546
      goto case_42;
    }
#line 557
    if (inp_ch == 118) {
#line 557
      goto case_118;
    }
#line 561
    if (inp_ch == 86) {
#line 561
      goto case_86;
    }
#line 565
    if (inp_ch == 114) {
#line 565
      goto case_114;
    }
#line 572
    if (inp_ch == 49) {
#line 572
      goto case_49;
    }
#line 572
    if (inp_ch == 72) {
#line 572
      goto case_49;
    }
#line 572
    if (inp_ch == 104) {
#line 572
      goto case_49;
    }
#line 572
    if (inp_ch == 265) {
#line 572
      goto case_49;
    }
#line 577
    if (inp_ch == 50) {
#line 577
      goto case_50;
    }
#line 577
    if (inp_ch == 266) {
#line 577
      goto case_50;
    }
#line 584
    if (inp_ch == 54) {
#line 584
      goto case_54;
    }
#line 584
    if (inp_ch == 270) {
#line 584
      goto case_54;
    }
#line 584
    if (inp_ch == 51) {
#line 584
      goto case_54;
    }
#line 584
    if (inp_ch == 267) {
#line 584
      goto case_54;
    }
#line 718
    if (inp_ch == 53) {
#line 718
      goto case_53;
    }
#line 718
    if (inp_ch == 269) {
#line 718
      goto case_53;
    }
#line 735
    if (inp_ch == 70) {
#line 735
      goto case_70;
    }
#line 745
    if (inp_ch == 39) {
#line 745
      goto case_39;
    }
#line 745
    if (inp_ch == 81) {
#line 745
      goto case_39;
    }
#line 745
    if (inp_ch == 113) {
#line 745
      goto case_39;
    }
#line 745
    if (inp_ch == 276) {
#line 745
      goto case_39;
    }
#line 749
    if (inp_ch == 27) {
#line 749
      goto case_27;
    }
#line 500
    goto switch_break___0;
    case_12: /* CIL Label */ 
    case_373: /* CIL Label */ 
    {
#line 503
    set_active_win(win);
    }
#line 504
    goto switch_break___0;
    case_9: /* CIL Label */ 
    case_341: /* CIL Label */ 
    case_340: /* CIL Label */ 
#line 509
    if (lay_act_side == 0) {
#line 509
      if (lay_global_anchor[1]) {
        {
#line 510
        lay_act_side = 1;
#line 511
        fill_in_songs(win);
        }
      } else {
#line 509
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 512
    if (lay_act_side == 1) {
#line 512
      if (lay_global_anchor[0]) {
        {
#line 513
        lay_act_side = 0;
#line 514
        fill_in_songs(win);
        }
      }
    }
#line 516
    goto switch_break___0;
    case_101: /* CIL Label */ 
    {
#line 519
    keys_open_tray(win);
    }
#line 520
    goto switch_break___0;
    case_69: /* CIL Label */ 
    {
#line 523
    close_tray();
#line 524
    reinit_volume(win);
    }
#line 525
    goto switch_break___0;
    case_108: /* CIL Label */ 
#line 528
    if (config_cddb_enbl) {
#line 528
      config_cddb_enbl = (unsigned char)0;
    } else {
#line 529
      config_cddb_enbl = (unsigned char)1;
    }
    {
#line 530
    layout_update_cddb_flag(win);
    }
#line 531
    goto switch_break___0;
    case_68: /* CIL Label */ 
    case_100: /* CIL Label */ 
    {
#line 535
    rhand_remove_dead_files(win);
    }
#line 536
    goto switch_break___0;
    case_109: /* CIL Label */ 
    {
#line 539
    cddb_save_cddb_entry(lay_global_anchor[0], def_cddb_bank);
    }
#line 540
    goto switch_break___0;
    case_77: /* CIL Label */ 
    {
#line 543
    cddb_submit_cddb_entry(lay_global_anchor[0]);
    }
#line 544
    goto switch_break___0;
    case_42: /* CIL Label */ 
#line 547
    pointer2 = lay_global_anchor[lay_act_side];
    {
#line 548
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 548
      if (! pointer2) {
#line 548
        goto while_break___0;
      }
#line 549
      if (pointer2->convert) {
#line 549
        pointer2->convert = (unsigned char)0;
      } else {
#line 550
        pointer2->convert = (unsigned char)1;
      }
#line 551
      pointer2 = pointer2->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 553
    calc_tot_frm();
#line 554
    fill_in_side(win, lay_act_side);
    }
#line 555
    goto switch_break___0;
    case_118: /* CIL Label */ 
    {
#line 558
    reinit_volume(win);
    }
#line 559
    goto switch_break___0;
    case_86: /* CIL Label */ 
    {
#line 562
    init_sampler(win);
    }
#line 563
    goto switch_break___0;
    case_114: /* CIL Label */ 
    {
#line 566
    rhand_load_ripped(def_exp_file, win);
    }
#line 567
    goto switch_break___0;
    case_49: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_265: /* CIL Label */ 
    {
#line 573
    pop_up_help();
    }
#line 574
    goto switch_break___0;
    case_50: /* CIL Label */ 
    case_266: /* CIL Label */ 
    {
#line 578
    option_menu(win);
    }
#line 579
    goto switch_break___0;
    case_54: /* CIL Label */ 
    case_270: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_267: /* CIL Label */ 
#line 585
    pointer2 = lay_global_anchor[lay_act_side];
#line 586
    if (lay_act_side == 1) {
      {
#line 587
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 587
        if (! pointer2) {
#line 587
          goto while_break___1;
        }
#line 588
        old_song = pointer2->next;
#line 589
        if (pointer2->convert) {
          {
#line 590
          rhand_do_enc(pointer2, win);
          }
        }
#line 592
        pointer2 = old_song;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 594
      goto switch_break___0;
    }
#line 597
    abort_flag = (unsigned char)0;
#line 598
    old_song = (song_typ *)((void *)0);
#line 599
    if (rip_enc_ordered) {
#line 599
      goto _L___3;
    } else
#line 599
    if (inp_ch == 270) {
#line 599
      goto _L___3;
    } else
#line 599
    if (inp_ch == 54) {
      _L___3: /* CIL Label */ 
      {
#line 606
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 606
        if (pointer2) {
#line 606
          if (! (! abort_flag)) {
#line 606
            goto while_break___2;
          }
        } else {
#line 606
          goto while_break___2;
        }
#line 607
        i = 0;
#line 608
        if (pointer2->convert) {
#line 609
          if (pointer2->on_fly) {
            {
#line 610
            i = conv_on_fly(pointer2);
            }
#line 611
            if (! i) {
              {
#line 611
              i = set_mp3_inf(pointer2);
              }
            }
#line 612
            if (! i) {
              {
#line 613
              add_to_m3u(pointer2);
#line 614
              pointer2->convert = (unsigned char)0;
#line 615
              lay_tot_frm[lay_act_side] -= (unsigned long )pointer2->frame_len;
              }
#line 616
              if ((unsigned long )pointer2 == (unsigned long )lay_curr_anchor[lay_act_side]) {
                {
#line 616
                song_move_down(win, (unsigned char)1);
                }
              }
            }
          } else {
            {
#line 619
            i = rip_non_fly(pointer2);
            }
#line 620
            if (! i) {
#line 620
              if (inp_ch == 270) {
#line 620
                goto _L___1;
              } else
#line 620
              if (inp_ch == 54) {
                _L___1: /* CIL Label */ 
                {
#line 623
                rhand_add_ripped(pointer2, win);
                }
#line 624
                if ((unsigned long )pointer2 == (unsigned long )lay_curr_anchor[lay_act_side]) {
                  {
#line 624
                  song_move_down(win, (unsigned char)1);
                  }
                }
              }
            }
          }
        }
#line 628
        if (i) {
#line 629
          if (inp_ch == 270) {
#line 630
            abort_flag = (unsigned char)1;
#line 631
            goto while_break___2;
          } else
#line 629
          if (inp_ch == 54) {
#line 630
            abort_flag = (unsigned char)1;
#line 631
            goto while_break___2;
          }
#line 633
          old_song = pointer2->prev;
#line 634
          if (! old_song) {
#line 635
            abort_flag = (unsigned char)1;
#line 636
            goto while_break___2;
          }
#line 638
          pointer2 = (song_typ *)((void *)0);
        } else {
#line 640
          pointer2 = pointer2->next;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 643
      if (inp_ch == 270) {
#line 643
        goto _L___2;
      } else
#line 643
      if (inp_ch == 54) {
        _L___2: /* CIL Label */ 
#line 644
        if (lay_act_side == 0) {
#line 644
          if (config_open_tray) {
            {
#line 644
            tmp___12 = keys_joblist_is_empty(lay_global_anchor[0]);
            }
#line 644
            if (tmp___12) {
              {
#line 646
              keys_open_tray(win);
              }
            }
          }
        }
#line 648
        goto switch_break___0;
      }
    }
#line 651
    if (abort_flag) {
#line 651
      goto switch_break___0;
    }
#line 662
    pointer2 = lay_global_anchor[lay_act_side];
    {
#line 663
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 663
      if (pointer2) {
#line 663
        if (! (! abort_flag)) {
#line 663
          goto while_break___3;
        }
      } else {
#line 663
        goto while_break___3;
      }
#line 664
      if (pointer2->convert) {
#line 665
        if (rip_enc_ordered) {
          {
#line 666
          i = enc_non_fly(pointer2, (unsigned char)1);
          }
#line 667
          if (! i) {
            {
#line 667
            i = set_mp3_inf(pointer2);
            }
          }
#line 668
          if (! i) {
            {
#line 669
            add_to_m3u(pointer2);
#line 670
            pointer2->convert = (unsigned char)0;
#line 671
            lay_tot_frm[lay_act_side] -= (unsigned long )pointer2->frame_len;
            }
#line 672
            if ((unsigned long )pointer2 == (unsigned long )lay_curr_anchor[lay_act_side]) {
              {
#line 672
              song_move_down(win, (unsigned char)1);
              }
            }
          } else {
#line 674
            abort_flag = (unsigned char)1;
            {
#line 675
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 675
              if (! pointer2) {
#line 675
                goto while_break___4;
              }
#line 676
              if (pointer2->convert) {
                {
#line 676
                rhand_add_ripped(pointer2, win);
                }
              }
#line 677
              if ((unsigned long )pointer2 == (unsigned long )old_song) {
#line 677
                goto while_break___4;
              }
#line 678
              pointer2 = pointer2->next;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
        } else {
#line 682
          if (pointer2->on_fly) {
            {
#line 683
            i = conv_on_fly(pointer2);
            }
          } else {
            {
#line 685
            i = rip_non_fly(pointer2);
            }
#line 686
            if (! i) {
              {
#line 687
              i = enc_non_fly(pointer2, (unsigned char)1);
              }
#line 688
              if (i) {
                {
#line 689
                rhand_add_ripped(pointer2, win);
#line 690
                abort_flag = (unsigned char)1;
                }
              }
            }
          }
#line 694
          if (! i) {
            {
#line 694
            i = set_mp3_inf(pointer2);
            }
          }
#line 695
          if (! i) {
            {
#line 696
            add_to_m3u(pointer2);
#line 697
            pointer2->convert = (unsigned char)0;
#line 698
            lay_tot_frm[lay_act_side] -= (unsigned long )pointer2->frame_len;
            }
#line 699
            if ((unsigned long )pointer2 == (unsigned long )lay_curr_anchor[lay_act_side]) {
              {
#line 699
              song_move_down(win, (unsigned char)1);
              }
            }
          } else {
#line 701
            abort_flag = (unsigned char)1;
          }
        }
      }
#line 705
      if (rip_enc_ordered) {
#line 705
        if ((unsigned long )pointer2 == (unsigned long )old_song) {
#line 705
          abort_flag = (unsigned char)1;
        } else {
#line 706
          pointer2 = pointer2->next;
        }
      } else {
#line 706
        pointer2 = pointer2->next;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 709
    if (lay_act_side == 0) {
#line 709
      if (config_open_tray) {
        {
#line 709
        tmp___13 = keys_joblist_is_empty(lay_global_anchor[0]);
        }
#line 709
        if (tmp___13) {
          {
#line 711
          keys_open_tray(win);
          }
        } else {
          {
#line 713
          fill_in_songs(win);
          }
        }
      } else {
        {
#line 713
        fill_in_songs(win);
        }
      }
    } else {
      {
#line 713
      fill_in_songs(win);
      }
    }
#line 715
    goto switch_break___0;
    case_53: /* CIL Label */ 
    case_269: /* CIL Label */ 
#line 719
    if (lay_global_anchor[lay_act_side]) {
      {
#line 721
      tmp___14 = gettext("select file for batch-script");
#line 721
      pointer1 = req_get_file((char const   *)((void *)0), (char const   *)tmp___14);
      }
#line 722
      if (pointer1) {
        {
#line 723
        tmp___17 = output_batch(lay_global_anchor[lay_act_side], pointer1, (unsigned char)1);
        }
#line 723
        if (tmp___17 == 0) {
          {
#line 724
          tmp___15 = gettext("script created");
#line 724
          popup_error_win(tmp___15);
          }
        } else {
          {
#line 726
          tmp___16 = gettext("scriptcreation failed");
#line 726
          popup_error_win(tmp___16);
          }
        }
        {
#line 728
        free((void *)pointer1);
        }
      }
    } else {
      {
#line 731
      tmp___18 = gettext("no datas for scriptcreation");
#line 731
      popup_error_win(tmp___18);
      }
    }
#line 733
    goto switch_break___0;
    case_70: /* CIL Label */ 
    {
#line 736
    setup_stat_win(50);
#line 737
    cddb_internet_lookup(def_cddb_server, def_cddb_bank, (unsigned char)1);
#line 738
    destroy_stat_win();
#line 739
    reinit_volume(win);
    }
#line 740
    goto switch_break___0;
    case_39: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_276: /* CIL Label */ 
    {
#line 746
    tmp___19 = gettext("Really leave this program?");
#line 746
    tmp___20 = select_yesno_box(tmp___19);
    }
#line 746
    if (tmp___20) {
#line 746
      return;
    }
#line 747
    goto switch_break___0;
    case_27: /* CIL Label */ 
    {
#line 750
    halfdelay(1);
#line 751
    inp_ch = wgetch(win);
    }
    {
#line 753
    if (inp_ch == 115) {
#line 753
      goto case_115___0;
    }
#line 762
    if (inp_ch == 103) {
#line 762
      goto case_103___0;
    }
#line 777
    if (inp_ch == 111) {
#line 777
      goto case_111___0;
    }
#line 789
    if (inp_ch == 97) {
#line 789
      goto case_97___0;
    }
#line 815
    if (inp_ch == 98) {
#line 815
      goto case_98___0;
    }
#line 841
    if (inp_ch == 99) {
#line 841
      goto case_99___0;
    }
#line 865
    if (inp_ch == 84) {
#line 865
      goto case_84___0;
    }
#line 890
    if (inp_ch == 106) {
#line 890
      goto case_106;
    }
#line 890
    if (inp_ch == 89) {
#line 890
      goto case_106;
    }
#line 912
    if (inp_ch == 116) {
#line 912
      goto case_116___0;
    }
#line 934
    if (inp_ch == 121) {
#line 934
      goto case_121___0;
    }
#line 752
    goto switch_break___1;
    case_115___0: /* CIL Label */ 
#line 754
    pointer2 = lay_global_anchor[lay_act_side];
    {
#line 755
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 755
      if (! pointer2) {
#line 755
        goto while_break___5;
      }
#line 756
      if (pointer2->convert) {
        {
#line 756
        a_t_swap(pointer2);
        }
      }
#line 757
      pointer2 = pointer2->next;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 759
    fill_in_side(win, lay_act_side);
    }
#line 760
    goto switch_break___1;
    case_103___0: /* CIL Label */ 
#line 763
    pointer2 = lay_global_anchor[lay_act_side];
#line 764
    if (pointer2) {
      {
#line 764
      i = select_genre();
      }
    } else {
#line 765
      goto switch_break___1;
    }
#line 766
    if (i == -1) {
#line 766
      goto switch_break___1;
    }
    {
#line 767
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 767
      if (! pointer2) {
#line 767
        goto while_break___6;
      }
#line 768
      if (pointer2->convert) {
        {
#line 769
        pointer2->genre = i;
#line 770
        filenm_generate(pointer2);
        }
      }
#line 772
      pointer2 = pointer2->next;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 774
    fill_in_side(win, lay_act_side);
    }
#line 775
    goto switch_break___1;
    case_111___0: /* CIL Label */ 
#line 778
    pointer2 = lay_global_anchor[lay_act_side];
    {
#line 779
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 779
      if (! pointer2) {
#line 779
        goto while_break___7;
      }
#line 780
      if (pointer2->convert) {
#line 781
        if (pointer2->on_fly) {
#line 781
          pointer2->on_fly = (unsigned char)0;
        } else {
#line 782
          pointer2->on_fly = (unsigned char)1;
        }
      }
#line 784
      pointer2 = pointer2->next;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 786
    if (lay_curr_anchor[lay_act_side]) {
      {
#line 786
      draw_song_status(win, lay_curr_anchor[lay_act_side]);
      }
    }
#line 787
    goto switch_break___1;
    case_97___0: /* CIL Label */ 
#line 790
    pointer2 = lay_global_anchor[lay_act_side];
#line 791
    if (! pointer2) {
#line 791
      goto switch_break___1;
    }
#line 792
    if (lay_curr_anchor[lay_act_side]) {
      {
#line 792
      tmp___21 = gettext("input artistname for selected tracks");
#line 792
      pointer1 = input_line(8, (lay_curr_anchor[lay_act_side])->artist, tmp___21,
                            (unsigned char)1);
      }
    } else {
      {
#line 795
      tmp___22 = gettext("input artistname for selected tracks");
#line 795
      pointer1 = input_line(8, (char *)((void *)0), tmp___22, (unsigned char)1);
      }
    }
#line 796
    if ((unsigned long )pointer1 == (unsigned long )((void *)0)) {
#line 796
      goto switch_break___1;
    }
    {
#line 797
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 797
      if (! pointer2) {
#line 797
        goto while_break___8;
      }
#line 798
      if (pointer2->convert) {
#line 799
        if (pointer2->artist) {
          {
#line 799
          free((void *)pointer2->artist);
          }
        }
        {
#line 800
        tmp___23 = strlen((char const   *)pointer1);
#line 800
        tmp___24 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___23 + 1U)));
#line 800
        pointer3 = (char *)tmp___24;
        }
#line 801
        if ((unsigned long )pointer3 == (unsigned long )((void *)0)) {
          {
#line 802
          perror("malloc");
#line 803
          wuuush(1);
          }
        }
        {
#line 805
        strcpy((char */* __restrict  */)pointer3, (char const   */* __restrict  */)pointer1);
#line 806
        pointer2->artist = pointer3;
#line 807
        filenm_generate(pointer2);
        }
      }
#line 809
      pointer2 = pointer2->next;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 811
    free((void *)pointer1);
#line 812
    fill_in_side(win, lay_act_side);
    }
#line 813
    goto switch_break___1;
    case_98___0: /* CIL Label */ 
#line 816
    pointer2 = lay_global_anchor[lay_act_side];
#line 817
    if (! pointer2) {
#line 817
      goto switch_break___1;
    }
#line 818
    if (lay_curr_anchor[lay_act_side]) {
      {
#line 818
      tmp___25 = gettext("input albumname for selected tracks");
#line 818
      pointer1 = input_line(8, (lay_curr_anchor[lay_act_side])->album, tmp___25, (unsigned char)1);
      }
    } else {
      {
#line 821
      tmp___26 = gettext("input albumname for selected tracks");
#line 821
      pointer1 = input_line(8, (char *)((void *)0), tmp___26, (unsigned char)1);
      }
    }
#line 822
    if ((unsigned long )pointer1 == (unsigned long )((void *)0)) {
#line 822
      goto switch_break___1;
    }
    {
#line 823
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 823
      if (! pointer2) {
#line 823
        goto while_break___9;
      }
#line 824
      if (pointer2->convert) {
#line 825
        if (pointer2->album) {
          {
#line 825
          free((void *)pointer2->album);
          }
        }
        {
#line 826
        tmp___27 = strlen((char const   *)pointer1);
#line 826
        tmp___28 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___27 + 1U)));
#line 826
        pointer3 = (char *)tmp___28;
        }
#line 827
        if ((unsigned long )pointer3 == (unsigned long )((void *)0)) {
          {
#line 828
          perror("malloc");
#line 829
          wuuush(1);
          }
        }
        {
#line 831
        strcpy((char */* __restrict  */)pointer3, (char const   */* __restrict  */)pointer1);
#line 832
        pointer2->album = pointer3;
#line 833
        filenm_generate(pointer2);
        }
      }
#line 835
      pointer2 = pointer2->next;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 837
    free((void *)pointer1);
#line 838
    fill_in_side(win, lay_act_side);
    }
#line 839
    goto switch_break___1;
    case_99___0: /* CIL Label */ 
#line 842
    pointer2 = lay_global_anchor[lay_act_side];
#line 843
    if (! pointer2) {
#line 843
      goto switch_break___1;
    }
#line 844
    if (lay_curr_anchor[lay_act_side]) {
      {
#line 844
      tmp___29 = gettext("input comment for selected tracks");
#line 844
      pointer1 = input_line(8, (lay_curr_anchor[lay_act_side])->comment, tmp___29,
                            (unsigned char)1);
      }
    } else {
      {
#line 846
      tmp___30 = gettext("input comment for selected tracks");
#line 846
      pointer1 = input_line(8, (char *)((void *)0), tmp___30, (unsigned char)1);
      }
    }
#line 847
    if ((unsigned long )pointer1 == (unsigned long )((void *)0)) {
#line 847
      goto switch_break___1;
    }
    {
#line 848
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 848
      if (! pointer2) {
#line 848
        goto while_break___10;
      }
#line 849
      if (pointer2->convert) {
#line 850
        if (pointer2->comment) {
          {
#line 850
          free((void *)pointer2->comment);
          }
        }
        {
#line 851
        tmp___31 = strlen((char const   *)pointer1);
#line 851
        tmp___32 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___31 + 1U)));
#line 851
        pointer2->comment = (char *)tmp___32;
        }
#line 852
        if (! pointer2->comment) {
          {
#line 853
          perror("malloc");
#line 854
          wuuush(1);
          }
        }
        {
#line 856
        strcpy((char */* __restrict  */)pointer2->comment, (char const   */* __restrict  */)pointer1);
#line 857
        filenm_generate(pointer2);
        }
      }
#line 859
      pointer2 = pointer2->next;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 861
    free((void *)pointer1);
#line 862
    fill_in_side(win, lay_act_side);
    }
#line 863
    goto switch_break___1;
    case_84___0: /* CIL Label */ 
#line 866
    pointer2 = lay_global_anchor[lay_act_side];
#line 867
    if (! pointer2) {
#line 867
      goto switch_break___1;
    }
#line 868
    if (lay_curr_anchor[lay_act_side]) {
      {
#line 868
      tmp___33 = gettext("input title for selected tracks");
#line 868
      pointer1 = input_line(8, (lay_curr_anchor[lay_act_side])->title, tmp___33, (unsigned char)1);
      }
    } else {
      {
#line 870
      tmp___34 = gettext("input title for selected tracks");
#line 870
      pointer1 = input_line(8, (char *)((void *)0), tmp___34, (unsigned char)1);
      }
    }
#line 871
    if ((unsigned long )pointer1 == (unsigned long )((void *)0)) {
#line 871
      goto switch_break___1;
    }
    {
#line 872
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 872
      if (! pointer2) {
#line 872
        goto while_break___11;
      }
#line 873
      if (pointer2->convert) {
#line 874
        if (pointer2->title) {
          {
#line 874
          free((void *)pointer2->title);
          }
        }
        {
#line 875
        tmp___35 = strlen((char const   *)pointer1);
#line 875
        tmp___36 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___35 + 1U)));
#line 875
        pointer2->title = (char *)tmp___36;
        }
#line 876
        if (! pointer2->title) {
          {
#line 877
          perror("malloc");
#line 878
          wuuush(1);
          }
        }
        {
#line 880
        strcpy((char */* __restrict  */)pointer2->title, (char const   */* __restrict  */)pointer1);
#line 881
        filenm_generate(pointer2);
        }
      }
#line 883
      pointer2 = pointer2->next;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 885
    free((void *)pointer1);
#line 886
    fill_in_side(win, lay_act_side);
    }
#line 887
    goto switch_break___1;
    case_106: /* CIL Label */ 
    case_89___0: /* CIL Label */ 
#line 891
    pointer2 = lay_global_anchor[lay_act_side];
#line 892
    if (! pointer2) {
#line 892
      goto switch_break___1;
    }
    {
#line 893
    tmp___37 = gettext("input year for all selected tracks");
#line 893
    pointer1 = input_line(8, (char *)((void *)0), tmp___37, (unsigned char)1);
    }
#line 894
    if (! pointer1) {
#line 894
      goto switch_break___1;
    }
    {
#line 895
    tmp___38 = strlen((char const   *)pointer1);
    }
#line 895
    if (tmp___38 > 4U) {
      {
#line 896
      free((void *)pointer1);
      }
#line 897
      goto switch_break___1;
    }
    {
#line 899
    i = atoi((char const   *)pointer1);
#line 900
    free((void *)pointer1);
    }
#line 901
    if (i < 0) {
#line 901
      i = 1999;
    } else
#line 901
    if (i > 9999) {
#line 901
      i = 1999;
    }
    {
#line 902
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 902
      if (! pointer2) {
#line 902
        goto while_break___12;
      }
#line 903
      if (pointer2->convert) {
        {
#line 904
        pointer2->year = i;
#line 905
        filenm_generate(pointer2);
        }
      }
#line 907
      pointer2 = pointer2->next;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 909
    fill_in_side(win, lay_act_side);
    }
#line 910
    goto switch_break___1;
    case_116___0: /* CIL Label */ 
#line 913
    pointer2 = lay_global_anchor[lay_act_side];
    {
#line 914
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 914
      if (! pointer2) {
#line 914
        goto while_break___13;
      }
#line 915
      if (pointer2->convert) {
        {
#line 916
        tmp___39 = malloc((size_t )(sizeof(char ) * 100UL));
#line 916
        pointer1 = (char *)tmp___39;
        }
#line 917
        if ((unsigned long )pointer1 == (unsigned long )((void *)0)) {
          {
#line 918
          perror("malloc");
#line 919
          wuuush(1);
          }
        }
        {
#line 921
        tmp___40 = gettext("input tracktitle for nr.%d");
#line 921
        sprintf((char */* __restrict  */)pointer1, (char const   */* __restrict  */)tmp___40,
                (int )pointer2->toc + 1);
#line 922
        pointer3 = input_line(8, pointer2->title, pointer1, (unsigned char)1);
#line 923
        free((void *)pointer1);
        }
#line 924
        if (! pointer3) {
#line 924
          goto while_break___13;
        }
#line 925
        if (pointer2->title) {
          {
#line 925
          free((void *)pointer2->title);
          }
        }
        {
#line 926
        pointer2->title = pointer3;
#line 927
        filenm_generate(pointer2);
        }
      }
#line 929
      pointer2 = pointer2->next;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 931
    fill_in_side(win, lay_act_side);
    }
#line 932
    goto switch_break___1;
    case_121___0: /* CIL Label */ 
#line 935
    pointer2 = lay_global_anchor[lay_act_side];
    {
#line 936
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 936
      if (! pointer2) {
#line 936
        goto while_break___14;
      }
#line 937
      if (pointer2->convert) {
        {
#line 938
        tmp___41 = malloc((size_t )(sizeof(char ) * 100UL));
#line 938
        pointer1 = (char *)tmp___41;
#line 939
        tmp___42 = malloc((size_t )(sizeof(char ) * 7UL));
#line 939
        pointer3 = (char *)tmp___42;
        }
#line 940
        if ((unsigned long )pointer1 == (unsigned long )((void *)0)) {
          {
#line 941
          perror("malloc");
#line 942
          wuuush(1);
          }
        } else
#line 940
        if ((unsigned long )pointer3 == (unsigned long )((void *)0)) {
          {
#line 941
          perror("malloc");
#line 942
          wuuush(1);
          }
        }
        {
#line 944
        tmp___43 = gettext("input year for nr.%d");
#line 944
        sprintf((char */* __restrict  */)pointer1, (char const   */* __restrict  */)tmp___43,
                (int )pointer2->toc + 1);
#line 945
        sprintf((char */* __restrict  */)pointer3, (char const   */* __restrict  */)"%d",
                pointer2->year);
#line 946
        pointer4 = input_line(8, pointer3, pointer1, (unsigned char)1);
#line 947
        free((void *)pointer1);
#line 948
        free((void *)pointer3);
        }
#line 949
        if (! pointer4) {
#line 949
          goto while_break___14;
        }
        {
#line 950
        tmp___44 = strlen((char const   *)pointer4);
        }
#line 950
        if (tmp___44 <= 4U) {
          {
#line 951
          pointer2->year = atoi((char const   *)pointer4);
          }
#line 952
          if (pointer2->year < 0) {
#line 953
            pointer2->year = 1999;
          } else
#line 952
          if (pointer2->year > 9999) {
#line 953
            pointer2->year = 1999;
          }
          {
#line 954
          filenm_generate(pointer2);
          }
        }
        {
#line 956
        free((void *)pointer4);
        }
      }
#line 958
      pointer2 = pointer2->next;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 960
    fill_in_side(win, lay_act_side);
    }
#line 961
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 963
    if (! config_fancy_colors) {
      {
#line 963
      nodelay(win, (_Bool)0);
      }
    }
#line 964
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 42 "/usr/include/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 50 "/home/wslee/benchmarks/sound/mp3c-0.29/src/iocd.c"
struct cdrom_tochdr tochdr  ;
#line 51 "/home/wslee/benchmarks/sound/mp3c-0.29/src/iocd.c"
struct cdrom_volctrl volctrl  ;
#line 52 "/home/wslee/benchmarks/sound/mp3c-0.29/src/iocd.c"
struct cdrom_ti ti  ;
#line 53 "/home/wslee/benchmarks/sound/mp3c-0.29/src/iocd.c"
struct cdrom_tocentry tocentry  ;
#line 54 "/home/wslee/benchmarks/sound/mp3c-0.29/src/iocd.c"
struct cdrom_subchnl sc  ;
#line 66 "/home/wslee/benchmarks/sound/mp3c-0.29/src/iocd.c"
struct __anonstruct_cdtoc_35 cdtoc[100]  ;
#line 73
unsigned long cddb_discid(int tot_trks ) ;
#line 74 "/home/wslee/benchmarks/sound/mp3c-0.29/src/iocd.c"
int track_first  ;
#line 74 "/home/wslee/benchmarks/sound/mp3c-0.29/src/iocd.c"
int track_last  ;
#line 75 "/home/wslee/benchmarks/sound/mp3c-0.29/src/iocd.c"
int cd_drv  =    -1;
#line 78 "/home/wslee/benchmarks/sound/mp3c-0.29/src/iocd.c"
int close_cdrom(void) 
{ 


  {
#line 80
  if (cd_drv >= 0) {
    {
#line 81
    close(cd_drv);
#line 82
    cd_drv = -2;
    }
  }
#line 85
  return (cd_drv);
}
}
#line 89 "/home/wslee/benchmarks/sound/mp3c-0.29/src/iocd.c"
int open_cdrom(void) 
{ 


  {
  {
#line 91
  close_cdrom();
#line 92
  cd_drv = open((char const   *)def_cdrom_dev, 2048);
  }
#line 93
  if (cd_drv <= 0) {
#line 93
    cd_drv = -1;
  }
#line 95
  return (cd_drv);
}
}
#line 99 "/home/wslee/benchmarks/sound/mp3c-0.29/src/iocd.c"
int ioctl_cdrom(int cmd ) 
{ 
  int tmp ;

  {
#line 103
  if (cd_drv >= 0) {
    {
#line 104
    tmp = ioctl(cd_drv, (unsigned long )cmd);
    }
  } else {
    {
#line 106
    tmp = open_cdrom();
    }
#line 107
    if (tmp >= 0) {
      {
#line 108
      tmp = ioctl(cd_drv, (unsigned long )cmd);
#line 109
      close_cdrom();
      }
    }
  }
#line 113
  return (tmp);
}
}
#line 117 "/home/wslee/benchmarks/sound/mp3c-0.29/src/iocd.c"
int eject_cd(void) 
{ 
  int tmp ;

  {
  {
#line 122
  tmp = ioctl_cdrom(21257);
  }
#line 126
  if (tmp != 0) {
#line 126
    return (1);
  }
#line 127
  return (0);
}
}
#line 131 "/home/wslee/benchmarks/sound/mp3c-0.29/src/iocd.c"
int close_tray(void) 
{ 
  int tmp ;

  {
  {
#line 136
  tmp = ioctl_cdrom(21273);
  }
#line 140
  if (tmp != 0) {
#line 140
    return (1);
  }
#line 141
  return (0);
}
}
#line 145 "/home/wslee/benchmarks/sound/mp3c-0.29/src/iocd.c"
int init_cd(void) 
{ 
  int tmp ;
  int i ;
  unsigned char closeing_needed ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 151
  track_first = 0;
#line 152
  track_last = 0;
#line 153
  closeing_needed = (unsigned char)0;
#line 155
  if (cd_drv < 0) {
    {
#line 156
    tmp___0 = open_cdrom();
    }
#line 156
    if (tmp___0 < 0) {
#line 157
      return (-1);
    }
#line 159
    closeing_needed = (unsigned char)1;
  }
  {
#line 163
  tmp = ioctl(cd_drv, 21253UL, & tochdr);
  }
#line 167
  if (tmp != 0) {
#line 168
    if (closeing_needed) {
      {
#line 168
      close_cdrom();
      }
    }
#line 169
    return (-1);
  }
  {
#line 173
  track_first = (int )tochdr.cdth_trk0;
#line 174
  track_last = (int )tochdr.cdth_trk1;
#line 176
  tocentry.cdte_track = (__u8 )170;
#line 177
  tocentry.cdte_format = (__u8 )2;
#line 191
  tmp___1 = ioctl(cd_drv, 21254UL, & tocentry);
  }
#line 191
  if (tmp___1 != 0) {
#line 197
    if (closeing_needed) {
      {
#line 197
      close_cdrom();
      }
    }
#line 198
    return (-1);
  }
#line 202
  cdtoc[track_last].min = (int )tocentry.cdte_addr.msf.minute;
#line 203
  cdtoc[track_last].sec = (int )tocentry.cdte_addr.msf.second;
#line 204
  cdtoc[track_last].frame = (int )tocentry.cdte_addr.msf.frame;
#line 211
  i = track_last;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (i >= track_first)) {
#line 211
      goto while_break;
    }
    {
#line 213
    tocentry.cdte_track = (__u8 )i;
#line 214
    tocentry.cdte_format = (__u8 )2;
#line 216
    tmp___2 = ioctl(cd_drv, 21254UL, & tocentry);
    }
#line 216
    if (tmp___2 != 0) {
#line 223
      if (closeing_needed) {
        {
#line 223
        close_cdrom();
        }
      }
#line 224
      return (-1);
    }
#line 228
    cdtoc[i - 1].min = (int )tocentry.cdte_addr.msf.minute;
#line 229
    cdtoc[i - 1].sec = (int )tocentry.cdte_addr.msf.second;
#line 230
    cdtoc[i - 1].frame = (int )tocentry.cdte_addr.msf.frame;
#line 211
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  if (closeing_needed) {
    {
#line 238
    close_cdrom();
    }
  }
#line 239
  return (0);
}
}
#line 243 "/home/wslee/benchmarks/sound/mp3c-0.29/src/iocd.c"
int hard_reset(void) 
{ 
  int tmp ;

  {
  {
#line 248
  tmp = ioctl_cdrom(21266);
  }
#line 252
  return (tmp);
}
}
#line 256 "/home/wslee/benchmarks/sound/mp3c-0.29/src/iocd.c"
int play_track(int tr_begin , int tr_end ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 261
  ti.cdti_trk0 = (__u8 )tr_begin;
#line 262
  ti.cdti_trk1 = (__u8 )tr_end;
#line 263
  ti.cdti_ind0 = (__u8 )0;
#line 264
  ti.cdti_ind1 = (__u8 )0;
#line 272
  if (cd_drv < 0) {
    {
#line 273
    tmp___0 = open_cdrom();
    }
#line 273
    if (tmp___0 < 0) {
#line 274
      return (-1);
    }
    {
#line 277
    tmp = ioctl(cd_drv, 21252UL, & ti);
#line 281
    close_cdrom();
    }
  } else {
    {
#line 284
    tmp = ioctl(cd_drv, 21252UL, & ti);
    }
  }
#line 289
  if (tmp != 0) {
#line 289
    return (-1);
  }
#line 290
  return (0);
}
}
#line 294 "/home/wslee/benchmarks/sound/mp3c-0.29/src/iocd.c"
int stop_cd(void) 
{ 
  int tmp ;

  {
  {
#line 298
  tmp = ioctl_cdrom(21255);
  }
#line 302
  if (tmp != 0) {
#line 302
    return (-1);
  }
#line 303
  return (0);
}
}
#line 307 "/home/wslee/benchmarks/sound/mp3c-0.29/src/iocd.c"
int pause_cd(void) 
{ 
  int tmp ;

  {
  {
#line 312
  tmp = ioctl_cdrom(21249);
  }
#line 316
  if (tmp != 0) {
#line 316
    return (-1);
  }
#line 317
  return (0);
}
}
#line 321 "/home/wslee/benchmarks/sound/mp3c-0.29/src/iocd.c"
int resume_cd(void) 
{ 
  int tmp ;

  {
  {
#line 326
  tmp = ioctl_cdrom(21250);
  }
#line 330
  if (tmp != 0) {
#line 330
    return (-1);
  }
#line 331
  return (0);
}
}
#line 336 "/home/wslee/benchmarks/sound/mp3c-0.29/src/iocd.c"
int cddb_sum(int n ) 
{ 
  int ret ;

  {
#line 340
  ret = 0;
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 342
    if (! (n > 0)) {
#line 342
      goto while_break;
    }
#line 343
    ret += n % 10;
#line 344
    n /= 10;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  return (ret);
}
}
#line 350 "/home/wslee/benchmarks/sound/mp3c-0.29/src/iocd.c"
unsigned long cddb_discid(int tot_trks ) 
{ 
  int i ;
  int t ;
  int n ;
  int tmp ;

  {
#line 354
  i = 0;
#line 355
  t = 0;
#line 356
  n = 0;
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! (i < tot_trks)) {
#line 358
      goto while_break;
    }
    {
#line 359
    tmp = cddb_sum(cdtoc[i].min * 60 + cdtoc[i].sec);
#line 359
    n += tmp;
#line 360
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  t = (cdtoc[tot_trks].min * 60 + cdtoc[tot_trks].sec) - (cdtoc[0].min * 60 + cdtoc[0].sec);
#line 369
  return ((unsigned long )((unsigned int )(((n % 255 << 24) | (t << 8)) | tot_trks) & 4294967295U));
}
}
#line 51 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
int ib_startpos  ;
#line 51 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
int ib_curspos  ;
#line 52 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
int ib_len  ;
#line 53 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
char *ib_string  ;
#line 54 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
unsigned char ib_cancel  ;
#line 55 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
unsigned char ib_changed  ;
#line 56 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
unsigned char ib_first  ;
#line 57 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
char *ib_des1  =    (char *)((void *)0);
#line 58 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
char *ib_des2  =    (char *)((void *)0);
#line 59 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
char *ib_des3  =    (char *)((void *)0);
#line 60 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
char *ib_des4  =    (char *)((void *)0);
#line 61 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
char *ib_des5  =    (char *)((void *)0);
#line 62 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
char *ib_des6  =    (char *)((void *)0);
#line 63 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
unsigned char ib_destr  =    (unsigned char)0;
#line 66 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
void ib_setcancel(WINDOW *win , int x , unsigned char act ) 
{ 
  chtype old_ch ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 70
  old_ch = win->_bkgd;
#line 71
  if (act) {
    {
#line 71
    wbkgdset(win, (unsigned long )(4 << 8) | (1UL << 21));
    }
  } else {
    {
#line 72
    wbkgdset(win, (chtype )(1 << 8));
    }
  }
  {
#line 73
  tmp___0 = wmove(win, 3, x);
  }
#line 73
  if (! (tmp___0 == -1)) {
    {
#line 73
    tmp = gettext(" Cancel ");
#line 73
    waddnstr(win, (char const   *)tmp, -1);
    }
  }
  {
#line 74
  wbkgdset(win, old_ch);
  }
#line 76
  if (act) {
    {
#line 76
    curs_set(0);
    }
  } else {
    {
#line 77
    curs_set(1);
    }
  }
#line 78
  return;
}
}
#line 81 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
void ib_text(WINDOW *win , int maxx ) 
{ 
  chtype old_ch ;

  {
  {
#line 83
  old_ch = (chtype )0;
#line 85
  wmove(win, 1, 1);
#line 86
  whline(win, (chtype )' ', maxx - 2);
  }
#line 87
  if (ib_first) {
#line 87
    if (! ib_cancel) {
      {
#line 88
      old_ch = win->_bkgd;
#line 89
      wbkgdset(win, old_ch | (1UL << 18));
      }
    }
  }
  {
#line 91
  waddnstr(win, (char const   *)(ib_string + ib_startpos), maxx - 2);
  }
#line 92
  if (ib_first) {
#line 92
    if (! ib_cancel) {
      {
#line 92
      wbkgdset(win, old_ch);
      }
    }
  }
#line 93
  return;
}
}
#line 96 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
void ib_refresh(WINDOW *win , int arg1 , int arg2 ) 
{ 
  int maxy ;
  int maxx ;
  unsigned char refr ;
  char *usage___0 ;
  chtype old_ch ;
  int inp_ch ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  char *__cil_tmp25 ;

  {
  {
#line 104
  tmp = pop_win_poi(win);
#line 104
  usage___0 = (char *)tmp;
  }
#line 105
  if (stdscr) {
#line 105
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 105
    maxy = -1;
  }
#line 105
  if (stdscr) {
#line 105
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 105
    maxx = -1;
  }
#line 106
  refr = (unsigned char)0;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! (ib_curspos > maxx - 2)) {
#line 108
      goto while_break;
    }
#line 109
    ib_curspos -= maxx >> 1;
#line 110
    ib_startpos += maxx >> 1;
#line 111
    refr = (unsigned char)1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 114
    if (ib_startpos > 0) {
#line 114
      if (! (ib_curspos < maxx >> 1)) {
#line 114
        goto while_break___0;
      }
    } else {
#line 114
      goto while_break___0;
    }
#line 115
    ib_curspos += maxx >> 1;
#line 116
    ib_startpos -= maxx >> 1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 118
  if (ib_startpos < 0) {
#line 119
    ib_curspos += ib_startpos;
#line 120
    ib_startpos = 0;
  }
#line 123
  if (arg2 != maxx) {
#line 123
    refr = (unsigned char)1;
  }
#line 124
  if (ib_destr) {
#line 125
    if (arg1 > maxy - 11) {
      {
#line 126
      refr = (unsigned char)1;
#line 127
      mvwin(win, maxy - 12, 0);
      }
    }
  } else
#line 130
  if (arg1 > maxy - 4) {
    {
#line 131
    refr = (unsigned char)1;
#line 132
    mvwin(win, maxy - 5, 0);
    }
  }
#line 135
  if (refr) {
    {
#line 136
    wresize(win, 5, maxx);
#line 137
    ib_changed = (unsigned char)1;
    }
  }
  {
#line 140
  wclear(win);
#line 141
  wborder(win, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0,
          (chtype )0, (chtype )0);
#line 142
  tmp___0 = wmove(win, 2, 0);
  }
#line 142
  if (! (tmp___0 == -1)) {
    {
#line 142
    waddch(win, (chtype const   )acs_map[(unsigned char )'t']);
    }
  }
  {
#line 143
  whline(win, acs_map[(unsigned char )'q'], maxx - 2);
#line 144
  tmp___1 = wmove(win, 2, maxx - 1);
  }
#line 144
  if (! (tmp___1 == -1)) {
    {
#line 144
    waddch(win, (chtype const   )acs_map[(unsigned char )'u']);
    }
  }
#line 146
  if (ib_destr) {
    {
#line 147
    tmp___2 = wmove(win, 4, 0);
    }
#line 147
    if (! (tmp___2 == -1)) {
      {
#line 147
      waddch(win, (chtype const   )acs_map[(unsigned char )'t']);
      }
    }
    {
#line 148
    whline(win, acs_map[(unsigned char )'q'], maxx - 2);
#line 149
    tmp___3 = wmove(win, 4, maxx - 1);
    }
#line 149
    if (! (tmp___3 == -1)) {
      {
#line 149
      waddch(win, (chtype const   )acs_map[(unsigned char )'u']);
      }
    }
#line 151
    if (ib_des1) {
      {
#line 151
      tmp___4 = wmove(win, 5, 1);
      }
#line 151
      if (! (tmp___4 == -1)) {
        {
#line 151
        waddnstr(win, (char const   *)ib_des1, maxx - 1);
        }
      }
    }
#line 152
    if (ib_des2) {
      {
#line 152
      tmp___5 = wmove(win, 6, 1);
      }
#line 152
      if (! (tmp___5 == -1)) {
        {
#line 152
        waddnstr(win, (char const   *)ib_des2, maxx - 1);
        }
      }
    }
#line 153
    if (ib_des3) {
      {
#line 153
      tmp___6 = wmove(win, 7, 1);
      }
#line 153
      if (! (tmp___6 == -1)) {
        {
#line 153
        waddnstr(win, (char const   *)ib_des3, maxx - 1);
        }
      }
    }
#line 154
    if (ib_des4) {
      {
#line 154
      tmp___7 = wmove(win, 8, 1);
      }
#line 154
      if (! (tmp___7 == -1)) {
        {
#line 154
        waddnstr(win, (char const   *)ib_des4, maxx - 1);
        }
      }
    }
#line 155
    if (ib_des5) {
      {
#line 155
      tmp___8 = wmove(win, 9, 1);
      }
#line 155
      if (! (tmp___8 == -1)) {
        {
#line 155
        waddnstr(win, (char const   *)ib_des5, maxx - 1);
        }
      }
    }
#line 156
    if (ib_des6) {
      {
#line 156
      tmp___9 = wmove(win, 10, 1);
      }
#line 156
      if (! (tmp___9 == -1)) {
        {
#line 156
        waddnstr(win, (char const   *)ib_des6, maxx - 1);
        }
      }
    }
  }
#line 159
  if (usage___0) {
    {
#line 160
    old_ch = win->_bkgd;
#line 161
    wbkgdset(win, (unsigned long )(2 << 8) | (1UL << 21));
#line 162
    tmp___10 = strlen((char const   *)usage___0);
#line 162
    inp_ch = (int )((size_t )maxx - tmp___10);
    }
#line 163
    if (inp_ch < 2) {
#line 163
      inp_ch = 2;
    }
    {
#line 164
    tmp___11 = wmove(win, 0, inp_ch >> 1);
    }
#line 164
    if (! (tmp___11 == -1)) {
      {
#line 164
      waddnstr(win, (char const   *)usage___0, maxx - 2);
      }
    }
    {
#line 165
    wbkgdset(win, old_ch);
    }
  }
  {
#line 168
  tmp___12 = gettext(" Cancel ");
#line 168
  tmp___13 = strlen((char const   *)tmp___12);
#line 168
  ib_setcancel(win, (int )(((size_t )maxx - tmp___13) >> 1), ib_cancel);
#line 169
  ib_text(win, maxx);
#line 170
  wmove(win, 1, ib_curspos + 1);
#line 171
  wrefresh(win);
  }
#line 172
  return;
}
}
#line 175 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
void ib_handle_left(WINDOW *win , int maxx ) 
{ 
  unsigned char refresh___0 ;

  {
#line 179
  if (ib_cancel) {
#line 179
    return;
  }
#line 181
  refresh___0 = (unsigned char)0;
#line 182
  if (ib_startpos + ib_curspos > 0) {
#line 183
    if (ib_curspos == 0) {
#line 184
      ib_startpos --;
#line 185
      refresh___0 = (unsigned char)1;
    } else {
#line 186
      ib_curspos --;
    }
    {
#line 187
    while (1) {
      while_continue: /* CIL Label */ ;
#line 187
      if (ib_startpos > 0) {
#line 187
        if (! (ib_curspos < 10)) {
#line 187
          goto while_break;
        }
      } else {
#line 187
        goto while_break;
      }
#line 188
      ib_curspos += maxx >> 1;
#line 189
      ib_startpos -= maxx >> 1;
#line 190
      refresh___0 = (unsigned char)1;
    }
    while_break: /* CIL Label */ ;
    }
#line 192
    if (ib_startpos < 0) {
#line 193
      ib_curspos += ib_startpos;
#line 194
      ib_startpos = 0;
    }
#line 196
    if (refresh___0) {
      {
#line 196
      ib_text(win, maxx);
      }
    }
    {
#line 197
    wmove(win, 1, ib_curspos + 1);
    }
  }
#line 199
  return;
}
}
#line 202 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
void ib_handle_right(WINDOW *win , int maxx ) 
{ 
  unsigned char refresh___0 ;

  {
#line 206
  if (ib_cancel) {
#line 206
    return;
  }
#line 208
  refresh___0 = (unsigned char)0;
#line 209
  if ((int )*((ib_string + ib_startpos) + ib_curspos) != 0) {
#line 210
    if (ib_curspos == maxx - 2) {
#line 211
      ib_startpos ++;
#line 212
      refresh___0 = (unsigned char)1;
    } else {
#line 213
      ib_curspos ++;
    }
#line 214
    if (ib_curspos > maxx - 10) {
#line 215
      refresh___0 = (unsigned char)1;
#line 216
      ib_startpos += maxx >> 1;
#line 217
      ib_curspos -= maxx >> 1;
    }
#line 219
    if (refresh___0) {
      {
#line 219
      ib_text(win, maxx);
      }
    }
    {
#line 220
    wmove(win, 1, ib_curspos + 1);
    }
  }
#line 222
  return;
}
}
#line 225 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
void ib_handle_del(WINDOW *win , int maxx ) 
{ 


  {
#line 227
  if (ib_startpos + ib_curspos == 0) {
#line 227
    return;
  }
  {
#line 229
  memmove((void *)(((ib_string + ib_startpos) + ib_curspos) - 1), (void const   *)((ib_string + ib_startpos) + ib_curspos),
          (size_t )(ib_len - (ib_startpos + ib_curspos)));
#line 232
  ib_text(win, maxx);
#line 233
  ib_handle_left(win, maxx);
#line 234
  wrefresh(win);
  }
#line 235
  return;
}
}
#line 238 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
void ib_handle_insert(WINDOW *win , int maxx , int key ) 
{ 
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *__cil_tmp8 ;

  {
  {
#line 240
  tmp___0 = strlen((char const   *)ib_string);
  }
#line 240
  if (tmp___0 < (size_t )ib_len) {
    {
#line 241
    ib_len += 16;
#line 242
    tmp = realloc((void *)ib_string, (size_t )(sizeof(char ) * (unsigned long )ib_len));
#line 242
    ib_string = (char *)tmp;
    }
#line 243
    if ((unsigned long )ib_string == (unsigned long )((void *)0)) {
      {
#line 244
      perror("realloc");
#line 245
      wuuush(1);
      }
    }
  }
  {
#line 248
  tmp___1 = strlen((char const   *)ib_string);
#line 248
  *((ib_string + tmp___1) + 1) = (char)0;
#line 249
  tmp___2 = strlen((char const   *)((ib_string + ib_startpos) + ib_curspos));
#line 249
  memmove((void *)(((ib_string + ib_startpos) + ib_curspos) + 1), (void const   *)((ib_string + ib_startpos) + ib_curspos),
          tmp___2);
#line 252
  *((ib_string + ib_startpos) + ib_curspos) = (char )key;
#line 253
  ib_text(win, maxx);
#line 254
  ib_handle_right(win, maxx);
#line 255
  wrefresh(win);
  }
#line 256
  return;
}
}
#line 259 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
void ib_handle_first(WINDOW *win , int maxx ) 
{ 


  {
#line 261
  if (! ib_first) {
#line 261
    return;
  } else
#line 261
  if (ib_cancel) {
#line 261
    return;
  }
  {
#line 262
  ib_first = (unsigned char)0;
#line 263
  ib_text(win, maxx);
#line 264
  wmove(win, 1, ib_curspos + 1);
#line 265
  wrefresh(win);
  }
#line 266
  return;
}
}
#line 267 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
void ib_handle_first2(WINDOW *win , int maxx ) 
{ 


  {
#line 269
  if (! ib_first) {
#line 269
    return;
  } else
#line 269
  if (ib_cancel) {
#line 269
    return;
  }
  {
#line 270
  ib_first = (unsigned char)0;
#line 271
  *ib_string = (char)0;
#line 272
  ib_startpos = 0;
#line 273
  ib_curspos = 0;
#line 274
  ib_text(win, maxx);
#line 275
  wmove(win, 1, 1);
#line 276
  wrefresh(win);
  }
#line 277
  return;
}
}
#line 287 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
char *input_line(int y_line , char *def_str , char *usage_str , unsigned char select___0 ) 
{ 
  int maxy ;
  int maxx ;
  WINDOW *ib_win ;
  int inp_ch ;
  char *ret_str ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 294
  if (stdscr) {
#line 294
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 294
    maxy = -1;
  }
#line 294
  if (stdscr) {
#line 294
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 294
    maxx = -1;
  }
#line 295
  if (ib_destr) {
#line 296
    if (y_line < 1) {
#line 296
      y_line = maxy - 12;
    } else
#line 296
    if (y_line > maxy - 13) {
#line 296
      y_line = maxy - 12;
    }
    {
#line 297
    ib_win = c_newwin(12, maxx, y_line - 1, 0, (void *)(& ib_refresh), y_line, maxx);
    }
  } else {
#line 299
    if (y_line < 1) {
#line 299
      y_line = maxy - 5;
    } else
#line 299
    if (y_line > maxy - 6) {
#line 299
      y_line = maxy - 5;
    }
    {
#line 300
    ib_win = c_newwin(5, maxx, y_line - 1, 0, (void *)(& ib_refresh), y_line, maxx);
    }
  }
  {
#line 302
  ib_changed = (unsigned char)0;
#line 303
  wbkgd(ib_win, (unsigned long )(1 << 8) | (1UL << 21));
#line 304
  store_win_poi(ib_win, (void *)usage_str);
#line 305
  ib_cancel = (unsigned char)0;
#line 306
  ib_first = select___0;
  }
#line 308
  if (def_str) {
    {
#line 308
    tmp = strlen((char const   *)def_str);
#line 308
    tmp___0 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp + 1U)));
#line 308
    ib_string = (char *)tmp___0;
    }
  } else {
    {
#line 309
    tmp___1 = malloc((size_t )sizeof(char ));
#line 309
    ib_string = (char *)tmp___1;
    }
  }
#line 310
  if ((unsigned long )ib_string == (unsigned long )((void *)0)) {
    {
#line 311
    perror("malloc");
#line 312
    wuuush(1);
    }
  }
#line 314
  if (def_str) {
    {
#line 315
    tmp___2 = strlen((char const   *)def_str);
#line 315
    memcpy((void */* __restrict  */)ib_string, (void const   */* __restrict  */)def_str,
           tmp___2 + 1U);
#line 316
    tmp___3 = strlen((char const   *)def_str);
#line 316
    ib_len = (int )(tmp___3 + 1U);
#line 317
    ib_startpos = 0;
#line 318
    tmp___4 = strlen((char const   *)def_str);
#line 318
    ib_curspos = (int )tmp___4;
    }
    {
#line 319
    while (1) {
      while_continue: /* CIL Label */ ;
#line 319
      if (! (ib_curspos >= maxx - 2)) {
#line 319
        goto while_break;
      }
#line 320
      ib_startpos += maxx >> 1;
#line 321
      ib_curspos -= maxx >> 1;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 324
    *ib_string = (char)0;
#line 325
    ib_startpos = 0;
#line 326
    ib_curspos = 0;
#line 327
    ib_len = 1;
  }
  {
#line 329
  ib_refresh(ib_win, y_line, maxx);
#line 331
  cbreak();
#line 332
  noecho();
#line 333
  keypad(ib_win, (_Bool)1);
  }
#line 334
  if (config_fancy_colors) {
    {
#line 335
    halfdelay(1);
    }
  } else {
    {
#line 337
    nodelay(ib_win, (_Bool)0);
    }
  }
  {
#line 339
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 340
    inp_ch = wgetch(ib_win);
    }
#line 341
    if (ib_changed) {
#line 342
      if (ib_win) {
#line 342
        maxy = (int )ib_win->_maxy + 1;
      } else {
#line 342
        maxy = -1;
      }
#line 342
      if (ib_win) {
#line 342
        maxx = (int )ib_win->_maxx + 1;
      } else {
#line 342
        maxx = -1;
      }
#line 343
      ib_changed = (unsigned char)0;
    }
#line 345
    if (config_fancy_colors) {
      {
#line 346
      win_effect(ib_win, (unsigned char)1, (unsigned char)0);
#line 347
      wmove(ib_win, 1, ib_curspos + 1);
      }
    }
#line 349
    if (ib_cancel) {
#line 349
      if (inp_ch == 32) {
        {
#line 350
        c_delwin(ib_win);
#line 351
        curs_set(0);
#line 352
        free((void *)ib_string);
        }
#line 353
        return ((char *)((void *)0));
      } else
#line 349
      if (inp_ch == 113) {
        {
#line 350
        c_delwin(ib_win);
#line 351
        curs_set(0);
#line 352
        free((void *)ib_string);
        }
#line 353
        return ((char *)((void *)0));
      } else
#line 349
      if (inp_ch == 81) {
        {
#line 350
        c_delwin(ib_win);
#line 351
        curs_set(0);
#line 352
        free((void *)ib_string);
        }
#line 353
        return ((char *)((void *)0));
      }
    }
    {
#line 356
    if (inp_ch == 9) {
#line 356
      goto case_9;
    }
#line 364
    if (inp_ch == 13) {
#line 364
      goto case_13;
    }
#line 364
    if (inp_ch == 10) {
#line 364
      goto case_13;
    }
#line 364
    if (inp_ch == 343) {
#line 364
      goto case_13;
    }
#line 380
    if (inp_ch == 27) {
#line 380
      goto case_27;
    }
#line 386
    if (inp_ch == 260) {
#line 386
      goto case_260;
    }
#line 390
    if (inp_ch == 261) {
#line 390
      goto case_261;
    }
#line 396
    if (inp_ch == 127) {
#line 396
      goto case_127;
    }
#line 396
    if (inp_ch == 8) {
#line 396
      goto case_127;
    }
#line 396
    if (inp_ch == 263) {
#line 396
      goto case_127;
    }
#line 400
    if (inp_ch == 330) {
#line 400
      goto case_330;
    }
#line 407
    if (inp_ch == 362) {
#line 407
      goto case_362;
    }
#line 407
    if (inp_ch == 262) {
#line 407
      goto case_362;
    }
#line 422
    if (inp_ch == 385) {
#line 422
      goto case_385;
    }
#line 422
    if (inp_ch == 360) {
#line 422
      goto case_385;
    }
#line 435
    if (inp_ch == 12) {
#line 435
      goto case_12;
    }
#line 438
    goto switch_default;
    case_9: /* CIL Label */ 
#line 357
    if (ib_cancel) {
#line 357
      ib_cancel = (unsigned char)0;
    } else {
#line 358
      ib_cancel = (unsigned char)1;
    }
    {
#line 359
    ib_setcancel(ib_win, (maxx - 8) >> 1, ib_cancel);
#line 360
    ib_text(ib_win, maxx);
    }
#line 361
    goto switch_break;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_343: /* CIL Label */ 
    {
#line 365
    c_delwin(ib_win);
#line 366
    curs_set(0);
    }
#line 367
    if (ib_cancel) {
      {
#line 368
      free((void *)ib_string);
      }
#line 369
      return ((char *)((void *)0));
    }
    {
#line 371
    tmp___5 = strlen((char const   *)ib_string);
#line 371
    tmp___6 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___5 + 1U)));
#line 371
    ret_str = (char *)tmp___6;
    }
#line 372
    if ((unsigned long )ret_str == (unsigned long )((void *)0)) {
      {
#line 373
      perror("malloc");
#line 374
      wuuush(1);
      }
    }
    {
#line 376
    tmp___7 = strlen((char const   *)ib_string);
#line 376
    memcpy((void */* __restrict  */)ret_str, (void const   */* __restrict  */)ib_string,
           tmp___7 + 1U);
#line 377
    free((void *)ib_string);
    }
#line 378
    return (ret_str);
#line 379
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 381
    c_delwin(ib_win);
#line 382
    curs_set(0);
#line 383
    free((void *)ib_string);
    }
#line 384
    return ((char *)((void *)0));
#line 385
    goto switch_break;
    case_260: /* CIL Label */ 
    {
#line 387
    ib_handle_first(ib_win, maxx);
#line 388
    ib_handle_left(ib_win, maxx);
    }
#line 389
    goto switch_break;
    case_261: /* CIL Label */ 
    {
#line 391
    ib_handle_first(ib_win, maxx);
#line 392
    ib_handle_right(ib_win, maxx);
    }
#line 393
    goto switch_break;
    case_127: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_263: /* CIL Label */ 
    {
#line 397
    ib_handle_first2(ib_win, maxx);
#line 398
    ib_handle_del(ib_win, maxx);
    }
#line 399
    goto switch_break;
    case_330: /* CIL Label */ 
#line 401
    if ((int )*((ib_string + ib_startpos) + ib_curspos) != 0) {
      {
#line 402
      ib_handle_right(ib_win, maxx);
#line 403
      ib_handle_del(ib_win, maxx);
      }
    }
#line 405
    goto switch_break;
    case_362: /* CIL Label */ 
    case_262: /* CIL Label */ 
    {
#line 408
    ib_handle_first(ib_win, maxx);
    }
#line 409
    if (ib_startpos) {
#line 409
      goto _L;
    } else
#line 409
    if (ib_curspos) {
      _L: /* CIL Label */ 
#line 410
      if (ib_startpos == 0) {
        {
#line 411
        ib_curspos = 0;
#line 412
        wmove(ib_win, 1, 1);
        }
      } else {
        {
#line 414
        ib_curspos = 0;
#line 415
        ib_startpos = 0;
#line 416
        ib_text(ib_win, maxx);
#line 417
        wmove(ib_win, 1, 1);
        }
      }
    }
#line 420
    goto switch_break;
    case_385: /* CIL Label */ 
    case_360: /* CIL Label */ 
    {
#line 423
    ib_handle_first(ib_win, maxx);
    }
#line 424
    if ((int )*((ib_string + ib_startpos) + ib_curspos) != 0) {
      {
#line 425
      tmp___8 = strlen((char const   *)ib_string);
#line 425
      ib_curspos = (int )tmp___8;
#line 426
      ib_startpos = 0;
      }
      {
#line 427
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 427
        if (! (ib_curspos >= maxx - 2)) {
#line 427
          goto while_break___1;
        }
#line 428
        ib_startpos += maxx >> 1;
#line 429
        ib_curspos -= maxx >> 1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 431
      ib_text(ib_win, maxx);
#line 432
      wmove(ib_win, 1, ib_curspos + 1);
      }
    }
#line 434
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 436
    set_active_win(ib_win);
    }
#line 437
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 439
    inp_ch &= 255;
#line 440
    if (inp_ch == 127) {
#line 440
      inp_ch = '_';
    }
    {
#line 441
    tmp___9 = __ctype_b_loc();
    }
#line 441
    if ((int const   )*(*tmp___9 + inp_ch) & 16384) {
      {
#line 442
      ib_handle_first2(ib_win, maxx);
#line 443
      ib_handle_insert(ib_win, maxx, inp_ch);
      }
    } else
#line 441
    if (eased_char_hand) {
#line 441
      if (inp_ch > 32) {
#line 441
        if (inp_ch < 256) {
          {
#line 442
          ib_handle_first2(ib_win, maxx);
#line 443
          ib_handle_insert(ib_win, maxx, inp_ch);
          }
        }
      }
    }
#line 445
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 450 "/home/wslee/benchmarks/sound/mp3c-0.29/src/input_box.c"
char *input_line2(int y_line , char *def_str , char *usage_str , char *des1 , char *des2 ,
                  char *des3 , char *des4 , char *des5 , char *des6 , unsigned char select___0 ) 
{ 
  char *ret ;

  {
  {
#line 456
  ib_des1 = des1;
#line 457
  ib_des2 = des2;
#line 458
  ib_des3 = des3;
#line 459
  ib_des4 = des4;
#line 460
  ib_des5 = des5;
#line 461
  ib_des6 = des6;
#line 463
  ib_destr = (unsigned char)1;
#line 465
  ret = input_line(y_line, def_str, usage_str, select___0);
#line 467
  ib_des1 = (char *)((void *)0);
#line 468
  ib_des2 = (char *)((void *)0);
#line 469
  ib_des3 = (char *)((void *)0);
#line 470
  ib_des4 = (char *)((void *)0);
#line 471
  ib_des5 = (char *)((void *)0);
#line 472
  ib_des6 = (char *)((void *)0);
#line 474
  ib_destr = (unsigned char)0;
  }
#line 476
  return (ret);
}
}
#line 44 "/home/wslee/benchmarks/sound/mp3c-0.29/src/info_screen.c"
int is_curr_line  ;
#line 45 "/home/wslee/benchmarks/sound/mp3c-0.29/src/info_screen.c"
int is_max_len  ;
#line 46 "/home/wslee/benchmarks/sound/mp3c-0.29/src/info_screen.c"
int is_like_len  ;
#line 46 "/home/wslee/benchmarks/sound/mp3c-0.29/src/info_screen.c"
int is_like_height  ;
#line 49 "/home/wslee/benchmarks/sound/mp3c-0.29/src/info_screen.c"
char **is_online_help  =    (char **)((void *)0);
#line 51 "/home/wslee/benchmarks/sound/mp3c-0.29/src/info_screen.c"
int is_count_lines(char const   **text ) 
{ 
  int lines ;
  int tmp ;

  {
#line 55
  if (! text) {
#line 55
    return (0);
  }
#line 57
  lines = 0;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! *(text + lines)) {
#line 58
      goto while_break;
    }
#line 58
    lines ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  if (lines == 0) {
#line 60
    tmp = lines;
  } else {
#line 60
    tmp = lines - 1;
  }
#line 60
  return (tmp);
}
}
#line 63 "/home/wslee/benchmarks/sound/mp3c-0.29/src/info_screen.c"
void is_stat(WINDOW *win , int ys , int ye , int x , int abs___0 , int tot ) 
{ 
  int i ;
  int y1 ;
  int y2 ;
  int yb ;
  int tmp ;
  int tmp___0 ;

  {
#line 67
  yb = (ye - ys) + 1;
#line 68
  if (yb >= tot) {
#line 68
    return;
  }
#line 69
  ys --;
#line 71
  if (! tot) {
#line 71
    return;
  }
#line 73
  y1 = (abs___0 * yb) / tot;
#line 74
  y2 = (y1 + (yb * yb) / tot) + 1;
#line 75
  y1 ++;
#line 76
  if (y2 > yb) {
#line 76
    y1 = yb - (y2 - y1);
  }
#line 78
  i = 1;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (i <= yb)) {
#line 78
      goto while_break;
    }
#line 79
    if (i >= y1) {
#line 79
      if (i <= y2) {
        {
#line 79
        tmp = wmove(win, ys + i, x);
        }
#line 79
        if (! (tmp == -1)) {
          {
#line 79
          waddch(win, (chtype const   )acs_map[(unsigned char )'0']);
          }
        }
      } else {
#line 79
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 80
      tmp___0 = wmove(win, ys + i, x);
      }
#line 80
      if (! (tmp___0 == -1)) {
        {
#line 80
        waddch(win, (chtype const   )acs_map[(unsigned char )'x']);
        }
      }
    }
#line 78
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return;
}
}
#line 84 "/home/wslee/benchmarks/sound/mp3c-0.29/src/info_screen.c"
void is_line(WINDOW *win , int h , int l , char const   **text ) 
{ 
  int x ;
  int y ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 88
  y = 1;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (y < h)) {
#line 88
      goto while_break;
    }
    {
#line 89
    tmp = wmove(win, y, 1);
    }
#line 89
    if (! (tmp == -1)) {
      {
#line 89
      whline(win, (chtype )' ', l - 2);
      }
    }
#line 90
    if ((y - 1) + is_curr_line <= is_max_len) {
#line 91
      if (! *(text + ((y - 1) + is_curr_line))) {
#line 91
        goto while_break;
      }
      {
#line 92
      tmp___0 = strlen(*(text + ((y - 1) + is_curr_line)));
#line 92
      x = (int )((size_t )l - tmp___0);
      }
#line 93
      if (x < 2) {
#line 93
        x = 2;
      }
      {
#line 94
      x >>= 1;
#line 95
      tmp___1 = wmove(win, y, x);
      }
#line 95
      if (! (tmp___1 == -1)) {
        {
#line 95
        waddnstr(win, *(text + ((y - 1) + is_curr_line)), l - 2);
        }
      }
    }
#line 88
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  is_stat(win, 1, h - 1, l - 1, is_curr_line, is_max_len);
#line 100
  wrefresh(win);
  }
#line 101
  return;
}
}
#line 103 "/home/wslee/benchmarks/sound/mp3c-0.29/src/info_screen.c"
void is_up(WINDOW *win , char const   **text ) 
{ 
  int maxy ;
  int maxx ;
  int l ;
  int h ;

  {
#line 108
  if (is_curr_line == 0) {
#line 108
    return;
  }
#line 109
  is_curr_line --;
#line 110
  if (win) {
#line 110
    maxy = (int )win->_maxy + 1;
  } else {
#line 110
    maxy = -1;
  }
#line 110
  if (win) {
#line 110
    maxx = (int )win->_maxx + 1;
  } else {
#line 110
    maxx = -1;
  }
#line 111
  l = is_like_len;
#line 112
  h = is_like_height;
#line 113
  if (l > maxx) {
#line 113
    l = maxx;
  }
#line 114
  if (h > maxy) {
#line 114
    h = maxy;
  }
  {
#line 116
  is_line(win, h - 1, l, text);
  }
#line 117
  return;
}
}
#line 119 "/home/wslee/benchmarks/sound/mp3c-0.29/src/info_screen.c"
void is_down(WINDOW *win , char const   **text ) 
{ 
  int maxy ;
  int maxx ;
  int l ;
  int h ;

  {
#line 124
  if (win) {
#line 124
    maxy = (int )win->_maxy + 1;
  } else {
#line 124
    maxy = -1;
  }
#line 124
  if (win) {
#line 124
    maxx = (int )win->_maxx + 1;
  } else {
#line 124
    maxx = -1;
  }
#line 125
  l = is_like_len;
#line 126
  h = is_like_height;
#line 127
  if (l > maxx) {
#line 127
    l = maxx;
  }
#line 128
  if (h > maxy) {
#line 128
    h = maxy;
  }
#line 130
  if (is_curr_line + (h - 2) <= is_max_len) {
    {
#line 131
    is_curr_line ++;
#line 132
    is_line(win, h - 1, l, text);
    }
  }
#line 134
  return;
}
}
#line 136 "/home/wslee/benchmarks/sound/mp3c-0.29/src/info_screen.c"
void is_pup(WINDOW *win , char const   **text ) 
{ 
  int maxy ;
  int maxx ;
  int l ;
  int h ;

  {
#line 141
  if (is_curr_line == 0) {
#line 141
    return;
  }
#line 142
  if (win) {
#line 142
    maxy = (int )win->_maxy + 1;
  } else {
#line 142
    maxy = -1;
  }
#line 142
  if (win) {
#line 142
    maxx = (int )win->_maxx + 1;
  } else {
#line 142
    maxx = -1;
  }
#line 143
  l = is_like_len;
#line 144
  h = is_like_height;
#line 145
  if (l > maxx) {
#line 145
    l = maxx;
  }
#line 146
  if (h > maxy) {
#line 146
    h = maxy;
  }
#line 148
  is_curr_line -= h - 4;
#line 149
  if (is_curr_line < 0) {
#line 149
    is_curr_line = 0;
  }
  {
#line 150
  is_line(win, h - 1, l, text);
  }
#line 151
  return;
}
}
#line 153 "/home/wslee/benchmarks/sound/mp3c-0.29/src/info_screen.c"
void is_pdown(WINDOW *win , char const   **text ) 
{ 
  int maxy ;
  int maxx ;
  int l ;
  int h ;

  {
#line 158
  if (win) {
#line 158
    maxy = (int )win->_maxy + 1;
  } else {
#line 158
    maxy = -1;
  }
#line 158
  if (win) {
#line 158
    maxx = (int )win->_maxx + 1;
  } else {
#line 158
    maxx = -1;
  }
#line 159
  l = is_like_len;
#line 160
  h = is_like_height;
#line 161
  if (l > maxx) {
#line 161
    l = maxx;
  }
#line 162
  if (h > maxy) {
#line 162
    h = maxy;
  }
#line 164
  if (is_curr_line + (h - 2) <= is_max_len) {
#line 165
    is_curr_line += h - 4;
#line 166
    if (is_curr_line + (h - 3) > is_max_len) {
#line 166
      is_curr_line = is_max_len - (h - 3);
    }
    {
#line 167
    is_line(win, h - 1, l, text);
    }
  }
#line 169
  return;
}
}
#line 171 "/home/wslee/benchmarks/sound/mp3c-0.29/src/info_screen.c"
void is_home(WINDOW *win , char const   **text ) 
{ 
  int maxy ;
  int maxx ;
  int l ;
  int h ;

  {
#line 176
  if (is_curr_line == 0) {
#line 176
    return;
  }
#line 177
  if (win) {
#line 177
    maxy = (int )win->_maxy + 1;
  } else {
#line 177
    maxy = -1;
  }
#line 177
  if (win) {
#line 177
    maxx = (int )win->_maxx + 1;
  } else {
#line 177
    maxx = -1;
  }
#line 178
  l = is_like_len;
#line 179
  h = is_like_height;
#line 180
  if (l > maxx) {
#line 180
    l = maxx;
  }
#line 181
  if (h > maxy) {
#line 181
    h = maxy;
  }
  {
#line 183
  is_curr_line = 0;
#line 184
  is_line(win, h - 1, l, text);
  }
#line 185
  return;
}
}
#line 187 "/home/wslee/benchmarks/sound/mp3c-0.29/src/info_screen.c"
void is_end(WINDOW *win , char const   **text ) 
{ 
  int maxy ;
  int maxx ;
  int l ;
  int h ;

  {
#line 192
  if (win) {
#line 192
    maxy = (int )win->_maxy + 1;
  } else {
#line 192
    maxy = -1;
  }
#line 192
  if (win) {
#line 192
    maxx = (int )win->_maxx + 1;
  } else {
#line 192
    maxx = -1;
  }
#line 193
  l = is_like_len;
#line 194
  h = is_like_height;
#line 195
  if (l > maxx) {
#line 195
    l = maxx;
  }
#line 196
  if (h > maxy) {
#line 196
    h = maxy;
  }
#line 198
  if (is_curr_line + (h - 2) <= is_max_len) {
    {
#line 199
    is_curr_line = is_max_len - (h - 3);
#line 200
    is_line(win, h - 1, l, text);
    }
  }
#line 202
  return;
}
}
#line 204 "/home/wslee/benchmarks/sound/mp3c-0.29/src/info_screen.c"
void is_win_rebuild(WINDOW *win , int arg1 , int arg2 ) 
{ 
  int maxy ;
  int maxx ;
  int l ;
  int h ;
  int x ;
  int y ;
  void *tmp ;

  {
#line 209
  if (stdscr) {
#line 209
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 209
    maxy = -1;
  }
#line 209
  if (stdscr) {
#line 209
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 209
    maxx = -1;
  }
#line 210
  l = is_like_len;
#line 211
  h = is_like_height;
#line 212
  if (l > maxx) {
#line 212
    l = maxx;
  }
#line 213
  if (h > maxy) {
#line 213
    h = maxy;
  }
  {
#line 214
  x = (maxx - l) >> 1;
#line 215
  y = (maxy - h) >> 1;
#line 216
  wresize(win, h, l);
#line 217
  mvwin(win, y, x);
#line 219
  wbkgd(win, (unsigned long )(1 << 8) | (1UL << 21));
#line 220
  wclear(win);
#line 221
  wborder(win, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0,
          (chtype )0, (chtype )0);
#line 223
  tmp = pop_win_poi(win);
#line 223
  is_line(win, h - 1, l, (char const   **)tmp);
#line 225
  cbreak();
#line 226
  noecho();
#line 227
  keypad(win, (_Bool)1);
#line 228
  nodelay(win, (_Bool)0);
#line 229
  curs_set(0);
  }
#line 230
  return;
}
}
#line 234 "/home/wslee/benchmarks/sound/mp3c-0.29/src/info_screen.c"
void is_popup_text(char const   **text , int len , int height ) 
{ 
  WINDOW *win ;
  int maxy ;
  int maxx ;
  int l ;
  int h ;
  int x ;
  int y ;
  int inp_char ;

  {
#line 241
  if (! text) {
#line 241
    return;
  } else
#line 241
  if (! *(text + 0)) {
#line 241
    return;
  }
  {
#line 243
  is_max_len = is_count_lines(text);
  }
#line 245
  if (stdscr) {
#line 245
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 245
    maxy = -1;
  }
#line 245
  if (stdscr) {
#line 245
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 245
    maxx = -1;
  }
#line 246
  l = len;
#line 247
  h = height;
#line 248
  if (l > maxx) {
#line 248
    l = maxx;
  }
#line 249
  if (h > maxy) {
#line 249
    h = maxy;
  }
  {
#line 250
  x = (maxx - l) >> 1;
#line 251
  y = (maxy - h) >> 1;
#line 252
  is_like_len = len;
#line 253
  is_like_height = height;
#line 255
  win = c_newwin(h, l, y, x, (void *)(& is_win_rebuild), maxy, maxx);
#line 256
  store_win_poi(win, (void *)text);
#line 257
  is_curr_line = 0;
#line 258
  is_win_rebuild(win, maxy, maxx);
  }
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 261
    inp_char = wgetch(win);
    }
    {
#line 263
    if (inp_char == 259) {
#line 263
      goto case_259;
    }
#line 267
    if (inp_char == 258) {
#line 267
      goto case_258;
    }
#line 271
    if (inp_char == 339) {
#line 271
      goto case_339;
    }
#line 275
    if (inp_char == 338) {
#line 275
      goto case_338;
    }
#line 280
    if (inp_char == 362) {
#line 280
      goto case_362;
    }
#line 280
    if (inp_char == 262) {
#line 280
      goto case_362;
    }
#line 285
    if (inp_char == 385) {
#line 285
      goto case_385;
    }
#line 285
    if (inp_char == 360) {
#line 285
      goto case_385;
    }
#line 289
    if (inp_char == 12) {
#line 289
      goto case_12;
    }
#line 300
    if (inp_char == 81) {
#line 300
      goto case_81;
    }
#line 300
    if (inp_char == 113) {
#line 300
      goto case_81;
    }
#line 300
    if (inp_char == 13) {
#line 300
      goto case_81;
    }
#line 300
    if (inp_char == 10) {
#line 300
      goto case_81;
    }
#line 300
    if (inp_char == 39) {
#line 300
      goto case_81;
    }
#line 300
    if (inp_char == 276) {
#line 300
      goto case_81;
    }
#line 300
    if (inp_char == 343) {
#line 300
      goto case_81;
    }
#line 300
    if (inp_char == 32) {
#line 300
      goto case_81;
    }
#line 262
    goto switch_break;
    case_259: /* CIL Label */ 
    {
#line 264
    is_up(win, text);
    }
#line 265
    goto switch_break;
    case_258: /* CIL Label */ 
    {
#line 268
    is_down(win, text);
    }
#line 269
    goto switch_break;
    case_339: /* CIL Label */ 
    {
#line 272
    is_pup(win, text);
    }
#line 273
    goto switch_break;
    case_338: /* CIL Label */ 
    {
#line 276
    is_pdown(win, text);
    }
#line 277
    goto switch_break;
    case_362: /* CIL Label */ 
    case_262: /* CIL Label */ 
    {
#line 281
    is_home(win, text);
    }
#line 282
    goto switch_break;
    case_385: /* CIL Label */ 
    case_360: /* CIL Label */ 
    {
#line 286
    is_end(win, text);
    }
#line 287
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 290
    is_win_rebuild(win, maxy, maxx);
    }
#line 291
    goto switch_break;
    case_81: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_39: /* CIL Label */ 
    case_276: /* CIL Label */ 
    case_343: /* CIL Label */ 
    case_32: /* CIL Label */ 
    {
#line 301
    c_delwin(win);
    }
#line 302
    return;
#line 303
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 310 "/home/wslee/benchmarks/sound/mp3c-0.29/src/info_screen.c"
char **is_build_array(char *str , int *lines ) 
{ 
  char **ret_str ;
  int line ;
  int pos ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 316
  tmp = malloc((size_t )sizeof(char *));
#line 316
  ret_str = (char **)tmp;
  }
#line 317
  if (! ret_str) {
    {
#line 318
    wuuush(1);
    }
  }
#line 320
  *(ret_str + 0) = (char *)((void *)0);
#line 322
  i = 0;
#line 323
  line = 0;
#line 324
  pos = 0;
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if ((int )*(str + pos) == 0) {
#line 327
      goto _L;
    } else
#line 327
    if ((int )*(str + pos) == 10) {
      _L: /* CIL Label */ 
      {
#line 328
      tmp___0 = realloc((void *)ret_str, (size_t )(sizeof(char *) * (unsigned long )(line + 2)));
#line 328
      ret_str = (char **)tmp___0;
      }
#line 329
      if (! ret_str) {
        {
#line 330
        wuuush(1);
        }
      }
      {
#line 332
      *(ret_str + (line + 1)) = (char *)((void *)0);
#line 333
      tmp___1 = malloc((size_t )(sizeof(char ) * (unsigned long )((pos - i) + 1)));
#line 333
      *(ret_str + line) = (char *)tmp___1;
      }
#line 334
      if (! *(ret_str + line)) {
        {
#line 335
        wuuush(1);
        }
      }
#line 337
      if (pos - i) {
        {
#line 337
        memcpy((void */* __restrict  */)*(ret_str + line), (void const   */* __restrict  */)(str + i),
               (size_t )(pos - i));
        }
      }
#line 338
      *(*(ret_str + line) + (pos - i)) = (char)0;
#line 339
      line ++;
#line 340
      if ((int )*(str + pos) == 0) {
#line 340
        goto while_break;
      }
#line 341
      pos ++;
#line 342
      i = pos;
    } else {
#line 344
      pos ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 348
  *lines = line;
#line 349
  return (ret_str);
}
}
#line 352 "/home/wslee/benchmarks/sound/mp3c-0.29/src/info_screen.c"
void pop_up_info(void) 
{ 
  char *temp_buf ;
  char **info_text ;
  int len ;
  void *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 359
  tmp = malloc((size_t )(sizeof(char ) * 1024UL));
#line 359
  temp_buf = (char *)tmp;
  }
#line 360
  if (! temp_buf) {
    {
#line 361
    wuuush(1);
    }
  }
  {
#line 363
  tmp___0 = gettext("WSPse - MP3Creator\n\nwritten by Matthias Hensler 1999-2001\nlicensed under GPL\n\nhttp://mp3c.wspse.de/\neMail: matthias@wspse.de\n\ncontains CDDB functions\n\nprogram version:\n%s");
#line 363
  sprintf((char */* __restrict  */)temp_buf, (char const   */* __restrict  */)tmp___0,
          external_version_str);
#line 374
  info_text = is_build_array(temp_buf, & len);
#line 375
  free((void *)temp_buf);
#line 377
  is_popup_text((char const   **)info_text, 65, len + 2);
#line 380
  free_char_array(info_text);
  }
#line 381
  return;
}
}
#line 383 "/home/wslee/benchmarks/sound/mp3c-0.29/src/info_screen.c"
void pop_up_help(void) 
{ 
  int len ;
  char *tmp ;
  char *__cil_tmp3 ;

  {
#line 388
  if (! is_online_help) {
    {
#line 389
    tmp = gettext("Onlinehelp for MP3Creator\n\non both sides:\nF1: This help\nF2: Optionsmenu\nF12: Quit program\n\non left side:\nF3: Start encoding (marked tracks)\nF4: Encode only actual track\nF5: Output Batch-script\nF6: Start ripping (marked tracks) and\n    put them into right window       \nF7: Rip only actual track\n\non right side:\nF3+F6: Start encoding (marked tracks)\nF4+F7: Encode only actual track\nF8: Delete marked tracks\nF9: Delete actual track\n\nNote for F-keys:\nSince F-keys won\'t work in all enviroments,\nyou can use number-keys instead. Press \'1\'\nfor F1, \'2\' for F2, and so on\n\nCRSR-keys: move in window up/down\nPage-keys: fast up and down\nPos1/End: jump to first/last track on\n          screen/list                \nDel/Space: swap encoding flag         \n           (if file should be encoded)\n\'*\': swap encoding flag for all tracks\nTAB: switch between left and right window\n\nEnter: open window to change information for track(s)\nHere you can make changes for one or all tracks at once,   \nwithout knowing all the shortcuts that follow later.       \nYou can see there fields with \"[ ]\" which shows information\nwhich shouldn\'t change and fields with \"[*]\" for data you  \nwant to change.                                            \nEvery time you enter new data a field is converted to \"[*]\"\nYou can swap these flags by pressing SPACE.                \n\na (#): input artist name for current track        \nt (#): input title for current track              \nb (#): input albumname for current track          \ny (#): input year for current track               \nc (#): input comment for current track            \ng (#): select genre for current track             \no (#): swap \"on the fly\" flag for current track   \ns (#): swap artist and interpret for current track\nALT+j: input year for all tracks (all selected)   \n\nw    : export actual track (only on right side)   \nW    : export marked tracks                       \nr    : import tracklist                           \n       (see HINTS about tracklist export)         \nd    : remove dead files from list                \n\np    : play actual track from cd                  \nx    : stop playing                               \ne    : eject tray of cdrom-device                 \nE    : close tray of cdrom-device                 \n\nv    : reinit cd-volume (necessary after new cd)  \nV    : force CDDB interpretation for sampler cds  \nF    : force loading of CDDB (even if there is an \n       local entry)                               \nl    : lock/unlock remote CDDB access             \nL    : toggle sampler flag for actual track       \nm    : write CDDB entry to local file             \nM    : transfer CDDB entry to remote database     \n\nq    : used to cancel and leave most windows      \n\nNote: if a key is marked with (#) you can perform\n      the operation on all selected tracks, if   \n      you press down ALT-key too. (e.g. press    \n      ALT+s to swap artist and title for all     \n      marked tracks, or ALT+g to select genre for\n      marked tracks)                             \nNote2: some (#) keys let you input information   \n       for each track seperately (e.g. year or   \n       title). Here you can press SHIFT down too,\n       to input information for all selected     \n       tracks at once. (e.g. press ALT+SHIFT+y to\n       input year once for all selected tracks). \n       This isn\'t really useful for tracktitles, \n       I think, but maybe..... ;-)               \n\n\nHINTS\n-------\n\nOn-the fly encoding\nMP3-file will be created without using a temporary-\nfile. Must be supported by your ripper (output wav \nor cda to stdout) and your encoder (use wav or cda \ninput from stdin). This sometimes causes \"klicks\"  \non mp3-files. Streams will be buffered over a FIFO,\nset size of FIFO in option-menu.                   \n\nRipping all tracks before encoding\nIf you want to rip all tracks before encoding just \nactivate the flag in option-menu. Remember that you\nshould have enough space on your harddisk, since   \nwav-data uses much space.                          \nRipped data is stored in the same temp-directory   \nlike normally, you don\'t have to change your old   \nsetting. An unique number is inserted without      \ndestroying any \".wav\"-ending.                      \n\nReplace slash character\nYou can set a character which is inserted instead  \nof slashs in option-menu. This prevents sensless   \ndirectory creation if a songtitle contains a slash.\n\nCharacter set\nYou cannot input all characters or some characters \nare missing in CDBB-entries (eg Umlauts, etc)? Just\nset character-handling to \"non-strict\" in option-  \nmenu.                                              \n\nCDDB\nNo internet-connection? Just input \"0\" as CDDB-    \nserver, and only local database is used.           \n\nFilename-Creation\nYou have lots of options for filename-creation.    \nThe first thing is to set the root-directory for   \nyour mp3-files. Then create a pattern-mask for the \nfilenames (here you can use several patterns for   \ninserting artistname, songtitle, etc. You can even \nuse slashes to split the files into different      \ndirectorys). Furthermore you can set if you accept \nspaces in filenames or not and you can input a list\nwith all characters you don\'t like in filenames.   \nEach character which is killed is then replaced by \nan defined char or left out. You can select what   \nyou like by setting \"Patternmode\" in option-menu.  \nA nice additional feature is to convert characters \ntoupper if the previous was killed. This is really \nnice if you kill every space without converting    \nthem to underscores. Just try option-menu for all  \nthe features.                                      \n\nRipping several cds before encoding\nAs introduced with version 0.21 you can rip several\ntracks, without doing encoding. Each ripped track  \nis placed on the right window. Of course the old   \nbehavior is still possible (F3 and F4), but you can\nalso use F6 to rip all marked tracks (or F7 to rip \nthe actual track) without encoding. (If you use F3 \nor F4 and encoding fails, the already ripped track \nis saved).                                         \nOn the right side you can do the same like on the  \nleft one: mark tracks, encode one or all and open a\nsetup window with ENTER-key. Furthermore you can   \ndelete one or all marked tracks by using F8 and F9.\nMaybe you will notice that there is no \"on-the-fly\"\nflag on the right side, but a \"delete\"-flag. This  \nflag shows if a track should be deleted after en-  \ncoding. Its setting is also checked on exit if the \n\"Delete Tempfiles on Exit\" option is set to \"1\".   \nLater you will be able to import new wav-files.    \n\nTracklist export and import\nSince version 0.21 it is possible to rip several cds  \nwithout doing the encoding directly after it. But what\nif you have no time to encode and want to leave MP3c? \nWell, no problem. Just export the ripped tracks and do\nthe encoding in the next session. You can select a    \nfile to store the datas in option-menu. Then you can  \npress \"W\" to save all marked tracks in the right win- \ndow, or \"w\" to save only the actual track. If a file  \nis already existing you can overwrite it, or add the  \nnew tracks. Don\'t worry if you export some tracks     \ndouble, MP3c will allow only one unique track in list.\nBut be careful, watch the deleteflag of the tracks and\nthe setting \"delete tempfiles on exit\" in optionmenu, \notherwise you could lose your ripped files if you quit\nMP3c. Note: you can set an option to clear the delete-\nflag on export in option-menu.                        \nYou can read export tracks just by pressing \"r\".      \nBy pressing \"d\" you can remove every dead track.      \n\nConfiguration\nMP3c saves his configuration in \"~/.mp3crc\". You can \nalso put a global configuration file \"mp3crc\" (no    \ndot) into \"$prefix/etc/\", where $prefix is the global\npath MP3c was stored in (\"/usr/etc\" for distributed  \nversions and \"/usr/local/etc\" if you self installed  \nMP3c). You can set global-path to \"/etc\" by changing \n\"mp3creat.h\" before compiling it.                    \nTo dump actual configuration just use \"Save Config\"  \nin option-menu, or enable \"Auto Save\" to save before \nleaving MP3c.                                        \nThe configurationfile is an normal ascii-text file.  \nYou can edit it manually without any risks, each key \nstored in it has a lot of comments, so you should    \nunderstand the file easily.                          \n\n\nHope you find this program useful. If you found a\nbug, write to: matthias@wspse.de\nsee file FAQ for reporting bugs or start MP3c like this:\n\"mp3c -v\"\n\nlook on http://mp3c.wspse.de/\nfor new versions\n\nWSPse 1999-2004");
#line 389
    is_online_help = is_build_array(tmp, & len);
    }
  }
  {
#line 606
  is_popup_text((char const   **)is_online_help, 76, 20);
  }
#line 607
  return;
}
}
#line 35 "/home/wslee/benchmarks/sound/mp3c-0.29/src/genre.c"
char *mp3_genre[148]  = 
#line 35 "/home/wslee/benchmarks/sound/mp3c-0.29/src/genre.c"
  {      (char *)"Blues",      (char *)"Classic Rock",      (char *)"Country",      (char *)"Dance", 
        (char *)"Disco",      (char *)"Funk",      (char *)"Grunge",      (char *)"Hip-Hop", 
        (char *)"Jazz",      (char *)"Metal",      (char *)"New Age",      (char *)"Oldies", 
        (char *)"Other",      (char *)"Pop",      (char *)"R&B",      (char *)"Rap", 
        (char *)"Reggae",      (char *)"Rock",      (char *)"Techno",      (char *)"Industrial", 
        (char *)"Alternative",      (char *)"Ska",      (char *)"Death Metal",      (char *)"Pranks", 
        (char *)"Soundtrack",      (char *)"Euro-Techno",      (char *)"Ambient",      (char *)"Trip-Hop", 
        (char *)"Vocal",      (char *)"Jazz+Funk",      (char *)"Fusion",      (char *)"Trance", 
        (char *)"Classical",      (char *)"Instrumental",      (char *)"Acid",      (char *)"House", 
        (char *)"Game",      (char *)"Sound Clip",      (char *)"Gospel",      (char *)"Noise", 
        (char *)"AlternRock",      (char *)"Bass",      (char *)"Soul",      (char *)"Punk", 
        (char *)"Space",      (char *)"Meditative",      (char *)"Instrumental Pop",      (char *)"Instrumental Rock", 
        (char *)"Ethnic",      (char *)"Gothic",      (char *)"Darkwave",      (char *)"Techno-Industrial", 
        (char *)"Electronic",      (char *)"Pop-Folk",      (char *)"Eurodance",      (char *)"Dream", 
        (char *)"Southern Rock",      (char *)"Comedy",      (char *)"Cult",      (char *)"Gangsta", 
        (char *)"Top 40",      (char *)"Christian Rap",      (char *)"Pop/Funk",      (char *)"Jungle", 
        (char *)"Native American",      (char *)"Cabaret",      (char *)"New Wave",      (char *)"Psychadelic", 
        (char *)"Rave",      (char *)"Showtunes",      (char *)"Trailer",      (char *)"Lo-Fi", 
        (char *)"Tribal",      (char *)"Acid Punk",      (char *)"Acid Jazz",      (char *)"Polka", 
        (char *)"Retro",      (char *)"Musical",      (char *)"Rock & Roll",      (char *)"Hard Rock", 
        (char *)"Folk",      (char *)"Folk/Rock",      (char *)"National Folk",      (char *)"Swing", 
        (char *)"Bebob",      (char *)"Latin",      (char *)"Revival",      (char *)"Celtic", 
        (char *)"Bluegrass",      (char *)"Avantgarde",      (char *)"Gothic Rock",      (char *)"Progressive Rock", 
        (char *)"Psychedelic Rock",      (char *)"Symphonic Rock",      (char *)"Slow Rock",      (char *)"Big Band", 
        (char *)"Chorus",      (char *)"Easy Listening",      (char *)"Acoustic",      (char *)"Humour", 
        (char *)"Speech",      (char *)"Chanson",      (char *)"Opera",      (char *)"Chamber Music", 
        (char *)"Sonata",      (char *)"Symphony",      (char *)"Booty Bass",      (char *)"Primus", 
        (char *)"Porn Groove",      (char *)"Satire",      (char *)"Slow Jam",      (char *)"Club", 
        (char *)"Tango",      (char *)"Samba",      (char *)"Folklore",      (char *)"Ballad", 
        (char *)"Power Ballad",      (char *)"Rhytmic Soul",      (char *)"Freestyle",      (char *)"Duet", 
        (char *)"Punk Rock",      (char *)"Drum Solo",      (char *)"Acapella",      (char *)"Euro-House", 
        (char *)"Dance Hall",      (char *)"Goa",      (char *)"Drum & Bass",      (char *)"Club-House", 
        (char *)"Hardcore",      (char *)"Terror",      (char *)"Indie",      (char *)"BritPop", 
        (char *)"Negerpunk",      (char *)"Polsk Punk",      (char *)"Beat",      (char *)"Christian Gangsta Rap", 
        (char *)"Heavy Metal",      (char *)"Black Metal",      (char *)"Crossover",      (char *)"Contemporary Christian", 
        (char *)"Christian Rock",      (char *)"Merengue",      (char *)"Salsa",      (char *)"Trash Metal", 
        (char *)"Anime",      (char *)"JPop",      (char *)"SynthPop",      (char *)"Unknown"};
#line 34 "/home/wslee/benchmarks/sound/mp3c-0.29/src/free.c"
void free_field_select(field_select_typ **anchor ) 
{ 
  field_select_typ *curr ;
  field_select_typ *next ;

  {
#line 38
  curr = *anchor;
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    if (! ((unsigned long )curr != (unsigned long )((void *)0))) {
#line 39
      goto while_break;
    }
#line 43
    if (curr->field) {
      {
#line 43
      free((void *)curr->field);
      }
    }
#line 44
    if (curr->dest) {
      {
#line 44
      free((void *)curr->dest);
      }
    }
#line 45
    if (curr->information) {
      {
#line 45
      free((void *)curr->information);
      }
    }
    {
#line 46
    next = curr->next;
#line 47
    free((void *)curr);
#line 48
    curr = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return;
}
}
#line 52 "/home/wslee/benchmarks/sound/mp3c-0.29/src/free.c"
void free_song_typ(song_typ **anchor ) 
{ 
  song_typ *curr ;
  song_typ *next ;

  {
#line 56
  curr = *anchor;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! ((unsigned long )curr != (unsigned long )((void *)0))) {
#line 57
      goto while_break;
    }
#line 61
    if (curr->artist) {
      {
#line 61
      free((void *)curr->artist);
      }
    }
#line 62
    if (curr->title) {
      {
#line 62
      free((void *)curr->title);
      }
    }
#line 63
    if (curr->album) {
      {
#line 63
      free((void *)curr->album);
      }
    }
#line 64
    if (curr->comment) {
      {
#line 64
      free((void *)curr->comment);
      }
    }
#line 65
    if (curr->filename) {
      {
#line 65
      free((void *)curr->filename);
      }
    }
#line 66
    if (curr->dirname) {
      {
#line 66
      free((void *)curr->dirname);
      }
    }
#line 67
    if (curr->tmp_wav_file) {
      {
#line 67
      free((void *)curr->tmp_wav_file);
      }
    }
    {
#line 69
    next = curr->next;
#line 70
    free((void *)curr);
#line 71
    curr = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return;
}
}
#line 75 "/home/wslee/benchmarks/sound/mp3c-0.29/src/free.c"
void free_char_array(char **array ) 
{ 
  int i ;

  {
#line 79
  i = 0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! array) {
#line 80
      goto while_break;
    }
#line 81
    if (! *(array + i)) {
#line 81
      goto while_break;
    }
    {
#line 82
    free((void *)*(array + i));
#line 83
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if (array) {
    {
#line 85
    free((void *)array);
    }
  }
#line 86
  return;
}
}
#line 363 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 604
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 801
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 237 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 116 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 119
extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 92 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
char *cddb_genres ;
#line 108 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
char *extnl_MP3_name  =    (char *)((void *)0);
#line 109 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
char *extnl_TMP_name  =    (char *)((void *)0);
#line 110 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
char *extnl_M3U_name  =    (char *)((void *)0);
#line 111 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
char *extnl_PROC_mask  =    (char *)((void *)0);
#line 112 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
char const   *weekday[7]  = {      "Sun",      "Mon",      "Tue",      "Wed", 
        "Thu",      "Fri",      "Sat"};
#line 113 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
char const   *month[12]  = 
#line 113
  {      "Jan",      "Feb",      "Mar",      "Apr", 
        "May",      "Jun",      "Jul",      "Aug", 
        "Sep",      "Oct",      "Nov",      "Dec"};
#line 122
char *file_build_m3u_entry(song_typ *track ) ;
#line 130 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
char *filenm_short(char *file_name , int mode , unsigned char toup , char *protect_mask ) 
{ 
  char *ret_name ;
  int i ;
  int j ;
  unsigned char was_space ;
  unsigned char uscr_inserted ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 152
  tmp = strlen((char const   *)file_name);
#line 152
  tmp___0 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp + 1U)));
#line 152
  ret_name = (char *)tmp___0;
  }
#line 153
  if ((unsigned long )ret_name == (unsigned long )((void *)0)) {
    {
#line 154
    perror("malloc");
#line 155
    wuuush(1);
    }
  }
#line 158
  was_space = (unsigned char)1;
#line 159
  uscr_inserted = (unsigned char)0;
#line 160
  j = 0;
#line 161
  i = 0;
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 161
    tmp___11 = strlen((char const   *)file_name);
    }
#line 161
    if (! ((size_t )i < tmp___11)) {
#line 161
      goto while_break;
    }
#line 162
    if (config_pat_prot) {
#line 162
      if (protect_mask) {
#line 162
        if (*(protect_mask + i)) {
          {
#line 163
          *(ret_name + j) = *(file_name + i);
#line 164
          tmp___1 = strchr(" -_/\"=?!.", (int )*(ret_name + j));
          }
#line 164
          if (tmp___1) {
#line 164
            was_space = (unsigned char)1;
          } else {
#line 165
            uscr_inserted = (unsigned char)0;
          }
#line 166
          j ++;
        } else {
#line 162
          goto _L___1;
        }
      } else {
#line 162
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 168
      if (config_case_chg == 1) {
        {
#line 169
        tmp___2 = tolower((int )*(file_name + i));
#line 169
        *(file_name + i) = (char )tmp___2;
        }
      } else
#line 170
      if (config_case_chg == 2) {
        {
#line 171
        tmp___3 = toupper((int )*(file_name + i));
#line 171
        *(file_name + i) = (char )tmp___3;
        }
      }
#line 173
      if ((int )*(file_name + i) == 32) {
#line 175
        was_space = (unsigned char)1;
#line 176
        if (mode == 0) {
#line 176
          tmp___4 = j;
#line 176
          j ++;
#line 176
          *(ret_name + tmp___4) = (char )' ';
        } else
#line 177
        if (mode == 1) {
#line 177
          if (! uscr_inserted) {
#line 178
            tmp___5 = j;
#line 178
            j ++;
#line 178
            *(ret_name + tmp___5) = replace_space_ch;
#line 179
            uscr_inserted = (unsigned char)1;
          }
        }
      } else {
        {
#line 181
        tmp___10 = strchr((char const   *)def_ill_chars, (int )*(file_name + i));
        }
#line 181
        if (tmp___10) {
#line 183
          was_space = (unsigned char)1;
#line 184
          if (! config_ill_remove) {
#line 185
            if (mode == 1) {
#line 185
              if (! uscr_inserted) {
#line 186
                tmp___6 = j;
#line 186
                j ++;
#line 186
                *(ret_name + tmp___6) = (char )'_';
#line 187
                uscr_inserted = (unsigned char)1;
              } else {
#line 185
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
#line 188
            if (mode == 0) {
#line 189
              tmp___7 = j;
#line 189
              j ++;
#line 189
              *(ret_name + tmp___7) = (char )' ';
            }
          }
        } else {
#line 194
          if (toup) {
#line 194
            if (was_space) {
              {
#line 196
              tmp___8 = toupper((int )*(file_name + i));
#line 196
              *(ret_name + j) = (char )tmp___8;
#line 197
              was_space = (unsigned char)0;
              }
            } else {
#line 200
              *(ret_name + j) = *(file_name + i);
            }
          } else {
#line 200
            *(ret_name + j) = *(file_name + i);
          }
          {
#line 202
          tmp___9 = strchr(" -_/\"=?!.", (int )*(ret_name + j));
          }
#line 202
          if (tmp___9) {
#line 202
            was_space = (unsigned char)1;
          } else {
#line 203
            uscr_inserted = (unsigned char)0;
          }
#line 204
          j ++;
        }
      }
    }
#line 161
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 209
  *(ret_name + j) = (char)0;
#line 211
  tmp___14 = strlen((char const   *)ret_name);
#line 211
  tmp___15 = strlen((char const   *)file_name);
  }
#line 211
  if (tmp___14 != tmp___15) {
    {
#line 213
    tmp___12 = strlen((char const   *)ret_name);
#line 213
    tmp___13 = realloc((void *)ret_name, (size_t )(sizeof(char ) * (unsigned long )(tmp___12 + 1U)));
#line 213
    ret_name = (char *)tmp___13;
    }
#line 214
    if (! ret_name) {
      {
#line 215
      perror("realloc");
#line 216
      wuuush(1);
      }
    }
  }
#line 220
  return (ret_name);
}
}
#line 223 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
void correct_slashes(char *string ) 
{ 
  char *str_poi ;

  {
#line 227
  if ((int )replace_slash_ch == 48) {
#line 227
    return;
  }
#line 229
  str_poi = string;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (str_poi) {
#line 230
      if (! *str_poi) {
#line 230
        goto while_break;
      }
    } else {
#line 230
      goto while_break;
    }
#line 231
    if ((int )*str_poi == 47) {
#line 231
      *str_poi = replace_slash_ch;
    }
#line 232
    str_poi ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return;
}
}
#line 236 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
void filenm_generate(song_typ *track ) 
{ 
  char *fn_new ;
  char *add_poi ;
  char def_add[9] ;
  int i ;
  int j ;
  int k ;
  unsigned char pat ;
  char *pattern ;
  char *protect_mask ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  size_t tmp___14 ;
  void *tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  void *tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  void *tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  char *tmp___27 ;
  void *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;

  {
#line 246
  if (track) {
#line 246
    if (! track->fn_auto) {
#line 246
      return;
    }
  } else {
#line 246
    return;
  }
#line 248
  if (track->filename) {
    {
#line 248
    free((void *)track->filename);
    }
  }
  {
#line 249
  track->filename = (char *)((void *)0);
#line 251
  tmp___0 = strcmp((char const   *)track->artist, "unknown");
  }
#line 251
  if (tmp___0 == 0) {
#line 251
    goto _L___0;
  } else
#line 251
  if ((int )*(track->artist) == 0) {
    _L___0: /* CIL Label */ 
    {
#line 251
    tmp___1 = strcmp((char const   *)track->title, "unknown");
    }
#line 251
    if (tmp___1 == 0) {
#line 251
      goto _L;
    } else
#line 251
    if ((int )*(track->title) == 0) {
      _L: /* CIL Label */ 
      {
#line 255
      tmp = malloc((size_t )(sizeof(char ) * 30UL));
#line 255
      fn_new = (char *)tmp;
      }
#line 256
      if ((unsigned long )fn_new == (unsigned long )((void *)0)) {
        {
#line 257
        perror("malloc");
#line 258
        wuuush(1);
        }
      }
      {
#line 263
      snprintf((char */* __restrict  */)fn_new, (size_t )30, (char const   */* __restrict  */)"unknown-%02d_%08lX.mp3",
               (int )track->toc + 1, track->cddb_id);
#line 265
      track->filename = kill_double_slashs(fn_new);
      }
#line 266
      return;
    }
  }
  {
#line 269
  tmp___2 = malloc((size_t )sizeof(char ));
#line 269
  fn_new = (char *)tmp___2;
  }
#line 270
  if ((unsigned long )fn_new == (unsigned long )((void *)0)) {
    {
#line 271
    perror("malloc");
#line 272
    wuuush(1);
    }
  }
  {
#line 274
  *fn_new = (char)0;
#line 276
  tmp___3 = malloc((size_t )sizeof(char ));
#line 276
  protect_mask = (char *)tmp___3;
  }
#line 277
  if (! protect_mask) {
    {
#line 278
    wuuush(1);
    }
  }
#line 280
  *protect_mask = (char)0;
#line 282
  i = 0;
#line 283
  pat = (unsigned char)0;
#line 285
  if (track->sampler) {
#line 286
    pattern = fn_pattern_mix;
  } else {
#line 288
    pattern = fn_pattern;
  }
#line 290
  if (! pattern) {
#line 290
    return;
  }
#line 292
  j = 0;
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 292
    tmp___19 = strlen((char const   *)pattern);
    }
#line 292
    if (! ((size_t )j < tmp___19)) {
#line 292
      goto while_break;
    }
#line 293
    if (pat) {
#line 294
      pat = (unsigned char)0;
#line 295
      k = (j - 1) - i;
#line 296
      if (k > 0) {
        {
#line 297
        tmp___4 = strlen((char const   *)fn_new);
#line 297
        tmp___5 = realloc((void *)protect_mask, (size_t )(sizeof(char ) * (unsigned long )((tmp___4 + (size_t )k) + 1U)));
#line 297
        protect_mask = (char *)tmp___5;
        }
#line 299
        if (! protect_mask) {
          {
#line 300
          wuuush(1);
          }
        }
        {
#line 302
        tmp___6 = strlen((char const   *)fn_new);
#line 302
        memcpy((void */* __restrict  */)(protect_mask + tmp___6), (void const   */* __restrict  */)(pattern + i),
               (size_t )k);
#line 304
        tmp___7 = strlen((char const   *)fn_new);
#line 304
        tmp___8 = realloc((void *)fn_new, (size_t )(sizeof(char ) * (unsigned long )((tmp___7 + (size_t )k) + 1U)));
#line 304
        fn_new = (char *)tmp___8;
        }
#line 306
        if ((unsigned long )fn_new == (unsigned long )((void *)0)) {
          {
#line 307
          perror("realloc");
#line 308
          wuuush(1);
          }
        }
        {
#line 310
        tmp___9 = strlen((char const   *)fn_new);
#line 310
        *((fn_new + tmp___9) + k) = (char)0;
#line 311
        tmp___10 = strlen((char const   *)fn_new);
#line 311
        memcpy((void */* __restrict  */)(fn_new + tmp___10), (void const   */* __restrict  */)(pattern + i),
               (size_t )k);
        }
      }
#line 313
      i = j + 1;
      {
#line 315
      if ((int )*(pattern + j) == 37) {
#line 315
        goto case_37;
      }
#line 320
      if ((int )*(pattern + j) == 49) {
#line 320
        goto case_49;
      }
#line 323
      if ((int )*(pattern + j) == 50) {
#line 323
        goto case_50;
      }
#line 326
      if ((int )*(pattern + j) == 51) {
#line 326
        goto case_51;
      }
#line 329
      if ((int )*(pattern + j) == 52) {
#line 329
        goto case_52;
      }
#line 336
      if ((int )*(pattern + j) == 53) {
#line 336
        goto case_53;
      }
#line 340
      if ((int )*(pattern + j) == 54) {
#line 340
        goto case_54;
      }
#line 344
      if ((int )*(pattern + j) == 55) {
#line 344
        goto case_55;
      }
#line 348
      if ((int )*(pattern + j) == 56) {
#line 348
        goto case_56;
      }
#line 352
      goto switch_default;
      case_37: /* CIL Label */ 
#line 316
      def_add[0] = (char )'%';
#line 317
      def_add[1] = (char)0;
#line 318
      add_poi = def_add;
#line 319
      goto switch_break;
      case_49: /* CIL Label */ 
#line 321
      add_poi = track->artist;
#line 322
      goto switch_break;
      case_50: /* CIL Label */ 
#line 324
      add_poi = track->title;
#line 325
      goto switch_break;
      case_51: /* CIL Label */ 
#line 327
      add_poi = track->album;
#line 328
      goto switch_break;
      case_52: /* CIL Label */ 
#line 330
      if (track->genre != 147) {
#line 331
        add_poi = mp3_genre[track->genre];
      } else {
#line 333
        add_poi = def_unknown_gen;
      }
#line 335
      goto switch_break;
      case_53: /* CIL Label */ 
      {
#line 337
      sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%d",
              track->year);
#line 338
      add_poi = def_add;
      }
#line 339
      goto switch_break;
      case_54: /* CIL Label */ 
      {
#line 341
      sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%d",
              (int )track->toc + 1);
#line 342
      add_poi = def_add;
      }
#line 343
      goto switch_break;
      case_55: /* CIL Label */ 
      {
#line 345
      sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%02d",
              (int )track->toc + 1);
#line 346
      add_poi = def_add;
      }
#line 347
      goto switch_break;
      case_56: /* CIL Label */ 
      {
#line 349
      snprintf((char */* __restrict  */)(def_add), (size_t )9, (char const   */* __restrict  */)"%08lX",
               track->cddb_id);
#line 350
      add_poi = def_add;
      }
#line 351
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 353
      def_add[0] = (char)0;
#line 354
      add_poi = def_add;
      switch_break: /* CIL Label */ ;
      }
      {
#line 356
      tmp___11 = strlen((char const   *)add_poi);
#line 356
      k = (int )tmp___11;
      }
#line 357
      if (k > 0) {
        {
#line 358
        tmp___12 = strlen((char const   *)fn_new);
#line 358
        tmp___13 = realloc((void *)fn_new, (size_t )(sizeof(char ) * (unsigned long )((tmp___12 + (size_t )k) + 1U)));
#line 358
        fn_new = (char *)tmp___13;
        }
#line 360
        if ((unsigned long )fn_new == (unsigned long )((void *)0)) {
          {
#line 361
          perror("realloc");
#line 362
          wuuush(1);
          }
        }
        {
#line 365
        tmp___14 = strlen((char const   *)fn_new);
#line 365
        tmp___15 = realloc((void *)protect_mask, (size_t )(sizeof(char ) * (unsigned long )((tmp___14 + (size_t )k) + 1U)));
#line 365
        protect_mask = (char *)tmp___15;
        }
#line 367
        if (! protect_mask) {
          {
#line 368
          wuuush(1);
          }
        }
        {
#line 371
        tmp___16 = strlen((char const   *)fn_new);
#line 371
        memset((void *)(protect_mask + tmp___16), 0, (size_t )k);
#line 373
        strcat((char */* __restrict  */)fn_new, (char const   */* __restrict  */)add_poi);
#line 374
        tmp___17 = strlen((char const   *)fn_new);
#line 374
        tmp___18 = strlen((char const   *)add_poi);
#line 374
        correct_slashes(fn_new + (tmp___17 - tmp___18));
        }
      }
    } else
#line 376
    if ((int )*(pattern + j) == 37) {
#line 376
      pat = (unsigned char)1;
    }
#line 292
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  k = j - i;
#line 379
  if (k > 0) {
    {
#line 380
    tmp___20 = strlen((char const   *)fn_new);
#line 380
    tmp___21 = realloc((void *)protect_mask, (size_t )(sizeof(char ) * (unsigned long )((tmp___20 + (size_t )k) + 1U)));
#line 380
    protect_mask = (char *)tmp___21;
    }
#line 382
    if (! protect_mask) {
      {
#line 383
      wuuush(1);
      }
    }
    {
#line 385
    tmp___22 = strlen((char const   *)fn_new);
#line 385
    memcpy((void */* __restrict  */)(protect_mask + tmp___22), (void const   */* __restrict  */)(pattern + i),
           (size_t )k);
#line 387
    tmp___23 = strlen((char const   *)fn_new);
#line 387
    tmp___24 = realloc((void *)fn_new, (size_t )(sizeof(char ) * (unsigned long )((tmp___23 + (size_t )k) + 1U)));
#line 387
    fn_new = (char *)tmp___24;
    }
#line 389
    if ((unsigned long )fn_new == (unsigned long )((void *)0)) {
      {
#line 390
      perror("realloc");
#line 391
      wuuush(1);
      }
    }
    {
#line 393
    tmp___25 = strlen((char const   *)fn_new);
#line 393
    *((fn_new + tmp___25) + k) = (char)0;
#line 394
    tmp___26 = strlen((char const   *)fn_new);
#line 394
    memcpy((void */* __restrict  */)(fn_new + tmp___26), (void const   */* __restrict  */)(pattern + i),
           (size_t )k);
    }
  }
  {
#line 397
  tmp___27 = filenm_short(fn_new, fn_mode, fn_toupper, protect_mask);
#line 397
  track->filename = kill_double_slashs(tmp___27);
#line 398
  free((void *)fn_new);
#line 399
  free((void *)protect_mask);
  }
#line 400
  return;
}
}
#line 403 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
int save_config(char *fn ) 
{ 
  FILE *conf_fd ;
  time_t lt ;
  struct tm *ltm ;
  char *glob_str ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;

  {
  {
#line 410
  setup_stat_win(40);
#line 411
  tmp = gettext("saving configuration");
#line 411
  print_stat_win(tmp);
#line 412
  tmp___0 = create_sub_dirs(fn, (unsigned char)1);
  }
#line 412
  if (tmp___0) {
#line 412
    return (-1);
  }
  {
#line 413
  conf_fd = fopen((char const   */* __restrict  */)fn, (char const   */* __restrict  */)"w");
  }
#line 414
  if ((unsigned long )conf_fd == (unsigned long )((void *)0)) {
    {
#line 415
    tmp___1 = gettext("failed...");
#line 415
    print_stat_win(tmp___1);
#line 416
    sleep(1U);
#line 417
    destroy_stat_win();
    }
#line 418
    return (-1);
  }
  {
#line 421
  fputs((char const   */* __restrict  */)"# WSPse\'s MP3-Creator (Configfile)\n",
        (FILE */* __restrict  */)conf_fd);
#line 422
  tmp___2 = gettext("# automaticly created, but you may edit this file manually.\n");
#line 422
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)conf_fd);
#line 423
  lt = time((time_t *)((void *)0));
#line 424
  ltm = localtime((time_t const   *)(& lt));
#line 425
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"# [%02d.%02d.%02d %02d:%02d] - program version: 0.29\n# {%s}\n",
          ltm->tm_mday, ltm->tm_mon + 1, ltm->tm_year + 1900, ltm->tm_hour, ltm->tm_min,
          external_version_str);
#line 430
  fputs((char const   */* __restrict  */)"\n# version number (to detect updates and inform about news)\n",
        (FILE */* __restrict  */)conf_fd);
#line 431
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"mp3c_version = \"0.29\"\n");
#line 433
  fputs((char const   */* __restrict  */)"\n# cdrom-device\n", (FILE */* __restrict  */)conf_fd);
#line 434
  glob_str = file_glob_out_name(def_cdrom_dev);
#line 435
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"cd_dev = \"%s\"\n",
          glob_str);
#line 436
  def_cdrom_dev = file_glob_in_name(glob_str);
#line 438
  fputs((char const   */* __restrict  */)"\n# CDDB-server [host:port] (more servers maybe seperated by commas)\n# use \"0\" to disable server-access\n# note: cddb.cddb.com:8880 is not longer usable\n",
        (FILE */* __restrict  */)conf_fd);
#line 441
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"cddb_serv = \"%s\"\n",
          def_cddb_server);
#line 443
  fputs((char const   */* __restrict  */)"\n# local CDDB database\n", (FILE */* __restrict  */)conf_fd);
#line 444
  glob_str = file_glob_out_name(def_cddb_bank);
#line 445
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"cddb_loc = \"%s\"\n",
          glob_str);
#line 446
  def_cddb_bank = file_glob_in_name(glob_str);
#line 448
  fputs((char const   */* __restrict  */)"\n# if remote CDDB access is allowed\n",
        (FILE */* __restrict  */)conf_fd);
#line 449
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"rem_cddb = %d\n",
          (int )config_cddb_enbl);
#line 451
  fputs((char const   */* __restrict  */)"\n# mailaddress to which CDDB should be sent (more addresses maybe seperated\n# by commas)\n",
        (FILE */* __restrict  */)conf_fd);
#line 453
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"cddb_email = \"%s\"\n",
          def_cddb_email);
#line 455
  fputs((char const   */* __restrict  */)"\n# relaying smtp-server who handle my emails [host:port]\n",
        (FILE */* __restrict  */)conf_fd);
#line 456
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"smtp_serv = \"%s\"\n",
          def_smtp_server);
#line 458
  fputs((char const   */* __restrict  */)"\n# my email address for authorizing [user@host]\n",
        (FILE */* __restrict  */)conf_fd);
#line 459
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"my_email = \"%s\"\n",
          def_my_email);
#line 461
  fputs((char const   */* __restrict  */)"\n# directory for mp3-files\n", (FILE */* __restrict  */)conf_fd);
#line 462
  glob_str = file_glob_out_name(def_mp3_dir);
#line 463
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"mp3_dir = \"%s\"\n",
          glob_str);
#line 464
  def_mp3_dir = file_glob_in_name(glob_str);
#line 466
  fputs((char const   */* __restrict  */)"\n# program for ripping cd-tracks (to file)\n#  %1 = cdrom device\n#  %2 = track (numeric)\n#  %3 = outputfile\n",
        (FILE */* __restrict  */)conf_fd);
#line 471
  glob_str = file_glob_out_name(def_cd_rip_nf);
#line 472
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"rip_nf_prg = \"%s\"\n",
          glob_str);
#line 473
  def_cd_rip_nf = file_glob_in_name(glob_str);
#line 475
  fputs((char const   */* __restrict  */)"\n# program for ripping cd-tracks (to stdout)\n#  %1 = cdrom device\n#  %2 = track (numeric)\n",
        (FILE */* __restrict  */)conf_fd);
#line 479
  glob_str = file_glob_out_name(def_cd_rip_of);
#line 480
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"rip_of_prg = \"%s\"\n",
          glob_str);
#line 481
  def_cd_rip_of = file_glob_in_name(glob_str);
#line 483
  fputs((char const   */* __restrict  */)"\n# program for encoding wav->mp3 (from file to file)\n#   %1 = inputfile\n#   %2 = outputfile\n#   %3 = albumname\n#   %4 = MP3 genre by number\n#   %5 = year\n#   %6 = comment\n#   %7 = filename\n#   %8 = MP3 genre by name\n#   %a = tracknumber\n#   %b = tracknumber (with leading zeros)\n#   %c = artistname\n#   %d = title\n",
        (FILE */* __restrict  */)conf_fd);
#line 497
  glob_str = file_glob_out_name(def_mp3_enc_nf);
#line 498
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"enc_nf_prg = \"%s\"\n",
          glob_str);
#line 499
  def_mp3_enc_nf = file_glob_in_name(glob_str);
#line 501
  fputs((char const   */* __restrict  */)"\n# program for encoding wav->mp3 (from stdin to file)\n#  %1 = outputfile\n#  %3 = albumname\n#  %4 = MP3 genre by number\n#  %5 = year\n#  %6 = comment\n#  %7 = filename\n#  %8 = MP3 genre by name\n#  %a = tracknumber\n#  %b = tracknumber (with leading zeros)\n#  %c = artistname\n#  %d = title\n",
        (FILE */* __restrict  */)conf_fd);
#line 514
  glob_str = file_glob_out_name(def_mp3_enc_of);
#line 515
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"enc_of_prg = \"%s\"\n",
          glob_str);
#line 516
  def_mp3_enc_of = file_glob_in_name(glob_str);
#line 518
  fputs((char const   */* __restrict  */)"\n# program for creating mp3 info\n#  use mp3_info_prg = \"0\" to disable usage of tagprogram\n#  %1 = artistname\n#  %2 = title\n#  %3 = albumname\n#  %4 = genre (by number)\n#  %5 = year\n#  %6 = comment\n#  %7 = filename\n#  %8 = genre (by name)\n#  %a = tracknumber\n#  %b = tracknumber (with leading zeros)\n",
        (FILE */* __restrict  */)conf_fd);
#line 531
  glob_str = file_glob_out_name(def_mp3_info);
#line 532
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"mp3_info_prg = \"%s\"\n",
          glob_str);
#line 533
  def_mp3_info = file_glob_in_name(glob_str);
#line 535
  fputs((char const   */* __restrict  */)"\n# string which replaced %8 in mp3_info_prg, if genre is unknown\n",
        (FILE */* __restrict  */)conf_fd);
#line 537
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"unknown_genre = \"%s\"\n",
          def_unknown_gen);
#line 539
  fputs((char const   */* __restrict  */)"\n# size of fifo-buffer for on the fly encoding (KB)\n",
        (FILE */* __restrict  */)conf_fd);
#line 540
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"of_fifo = %d\n",
          of_fifo_buf);
#line 542
  fputs((char const   */* __restrict  */)"\n# pattern for mp3-filename-creation\n#  %1 = artistname\n#  %2 = title\n#  %3 = albumname\n#  %4 = genrestring\n#  %5 = year\n#  %6 = tracknumber\n#  %7 = tracknumber (with leading zeros)\n#  %8 = cddb-id\n",
        (FILE */* __restrict  */)conf_fd);
#line 552
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"mp3_pattern = \"%s\"\n",
          fn_pattern);
#line 554
  fputs((char const   */* __restrict  */)"\n# pattern fro mp3-filename-creation for sampler cds\n#  same pattern like in mp3_pattern\n",
        (FILE */* __restrict  */)conf_fd);
#line 557
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"mp3_pattern_mix = \"%s\"\n",
          fn_pattern_mix);
#line 559
  fputs((char const   */* __restrict  */)"\n# mode for handling spaces in filenames\n#  0: spaces allowed, 1: spaces will be converted to specified replace character\n#  2: spaces will be killed\n",
        (FILE */* __restrict  */)conf_fd);
#line 562
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"pat_mode = %d\n",
          fn_mode);
#line 563
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"space_rep_char = \"%c\"\n",
          (int )replace_space_ch);
#line 565
  fputs((char const   */* __restrict  */)"\n# appereance of filename case\n#  0: as it is in CDDB entry\n#  1: convert to lowercase (first letter will be uppercase if pat_upc = 1\n#  2: convert to uppercase\n",
        (FILE */* __restrict  */)conf_fd);
#line 569
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"case_chg = %d\n",
          config_case_chg);
#line 571
  fputs((char const   */* __restrict  */)"\n# convert first letter of filename to uppercase\n#  0: no, 1: yes\n",
        (FILE */* __restrict  */)conf_fd);
#line 573
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"pat_upc = %d\n",
          (int )fn_toupper);
#line 575
  fputs((char const   */* __restrict  */)"\n# illegal characters which aren\'t allowed in filenames\n# (converted to \'_\' if mode != 2, else killed\n",
        (FILE */* __restrict  */)conf_fd);
#line 577
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"ill_chars = \"%s\"\n",
          def_ill_chars);
#line 579
  fputs((char const   */* __restrict  */)"\n# what to do with illegal characters, should they be removed?\n# (otherwise convert to \'_\' or space, depending on pat_mode)\n#  0: no, use pat_mode, 1: yes, remove\n",
        (FILE */* __restrict  */)conf_fd);
#line 582
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"rem_ill_char = %d\n",
          (int )config_ill_remove);
#line 584
  fputs((char const   */* __restrict  */)"\n# protect pattern from substitution operations?\n#  0: no, 1: yes\n",
        (FILE */* __restrict  */)conf_fd);
#line 586
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"pattern_protect = %d\n",
          (int )config_pat_prot);
#line 588
  fputs((char const   */* __restrict  */)"\n# character which should replace slashes in album, artist, title\n# (only one character allowed, use \"0\" to accept slashes in these\n   fields, which causes strange directory creation)\n",
        (FILE */* __restrict  */)conf_fd);
#line 591
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"slash_rep_char = \"%c\"\n",
          (int )replace_slash_ch);
#line 593
  fputs((char const   */* __restrict  */)"\n# non-strict character handling\n# 0: only printable chars allowed, 1: eased allowed chars\n",
        (FILE */* __restrict  */)conf_fd);
#line 595
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"eased_char_hand = %d\n",
          (int )eased_char_hand);
#line 597
  fputs((char const   */* __restrict  */)"\n# default comment for mp3-files\n#  %1 = artistname\n#  %2 = title\n#  %3 = albumname\n#  %4 = genrestring\n#  %5 = year\n#  %6 = tracknumber\n#  %7 = tracknumber (with leading zeros)\n#  %8 = version-string of MP3c\n#  %9 = cddb-id\n#  %a = actual day (is set when encoding starts, or batchfile created)\n#  %b = actual month\n#  %c = actual year (2 digits)\n#  %d = actual year (4 digits)\n#  %e = weekday (3 letters)\n#  %f = month (3 letters)\n#  %g = actual hour\n#  %h = actual minute\n#  %i = minute-part of track-length\n#  %j = second-part of track-length\n",
        (FILE */* __restrict  */)conf_fd);
#line 618
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"mp3_comment = \"%s\"\n",
          def_comment);
#line 620
  fputs((char const   */* __restrict  */)"\n# fancy color for windows (0: never, 1: sometimes, 2: ever)\n",
        (FILE */* __restrict  */)conf_fd);
#line 621
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"fancy_color = %d\n",
          (int )config_fancy_colors);
#line 623
  fputs((char const   */* __restrict  */)"\n# autosave configuration on exit (0: no, 1: yes)\n",
        (FILE */* __restrict  */)conf_fd);
#line 624
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"auto_save = %d\n",
          auto_save);
#line 626
  fputs((char const   */* __restrict  */)"\n# default flag (0: default non-fly, 1: default on-fly)\n",
        (FILE */* __restrict  */)conf_fd);
#line 627
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"def_on_fly = %d\n",
          (int )def_on_fly);
#line 629
  fputs((char const   */* __restrict  */)"\n# rip-encode order (0: rip one track, then encode; 1: rip all tracks,\n#                   then encode)\n",
        (FILE */* __restrict  */)conf_fd);
#line 631
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"rip_enc_ord = %d\n",
          (int )rip_enc_ordered);
#line 633
  fputs((char const   */* __restrict  */)"\n# open tray after encoding (0: no, 1:yes)\n",
        (FILE */* __restrict  */)conf_fd);
#line 634
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"open_tray = %d\n",
          (int )config_open_tray);
#line 636
  fputs((char const   */* __restrict  */)"\n# tmpfile (for non-on-the-fly convert)\n",
        (FILE */* __restrict  */)conf_fd);
#line 637
  glob_str = file_glob_out_name(def_tmp_file);
#line 638
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"tmp_file = \"%s\"\n",
          glob_str);
#line 639
  def_tmp_file = file_glob_in_name(glob_str);
#line 641
  fputs((char const   */* __restrict  */)"\n# what to do with tempfiles on exits\n# 0: nothing, 1: delete marked, 2: delete all\n",
        (FILE */* __restrict  */)conf_fd);
#line 643
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"del_tmp_on_exit = %d\n",
          del_tmp_on_exit);
#line 645
  fputs((char const   */* __restrict  */)"\n# default exportfile for ripped tracks\n",
        (FILE */* __restrict  */)conf_fd);
#line 646
  glob_str = file_glob_out_name(def_exp_file);
#line 647
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"def_exp_file = \"%s\"\n",
          glob_str);
#line 648
  def_exp_file = file_glob_in_name(glob_str);
#line 650
  fputs((char const   */* __restrict  */)"\n# if deleteflag should cleared on export (0: no, 1: yes)\n",
        (FILE */* __restrict  */)conf_fd);
#line 651
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"clear_del_on_exp = %d\n",
          (int )clear_del_on_exp);
#line 653
  fputs((char const   */* __restrict  */)"\n# framemultiplikator (to calculate size)\n",
        (FILE */* __restrict  */)conf_fd);
#line 654
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"frame_mult = %d\n",
          mp3_frame_mult);
#line 656
  fputs((char const   */* __restrict  */)"\n# pattern for m3u-playlist, use \"0\" to disable\n#  %1 = artistname\n#  %2 = title\n#  %3 = albumname\n#  %4 = genrestring\n#  %5 = year\n#  %6 = tracknumber\n#  %7 = tracknumber (with leading zeros)\n#  %8 = cddb-id\n",
        (FILE */* __restrict  */)conf_fd);
#line 666
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"m3u_pattern = \"%s\"\n",
          def_m3u_pattern);
#line 668
  fputs((char const   */* __restrict  */)"\n# pattern for m3u-playlist for sampler cds, use \"0\" to disable\n#  same pattern like in m3u_pattern\n",
        (FILE */* __restrict  */)conf_fd);
#line 671
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"m3u_patmix = \"%s\"\n",
          def_m3u_patmix);
#line 673
  fputs((char const   */* __restrict  */)"\n# directory for m3u-playlist, or \"0\" to use mp3-dir\n",
        (FILE */* __restrict  */)conf_fd);
#line 674
  glob_str = file_glob_out_name(def_m3u_dir);
#line 675
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"m3u_dir = \"%s\"\n",
          glob_str);
#line 676
  def_m3u_dir = file_glob_in_name(glob_str);
#line 678
  fputs((char const   */* __restrict  */)"\n# how to build the filename for m3u-list\n#  0 = full path\n#  1 = relative to m3u-maindir\n#  2 = relative to m3u-file\n",
        (FILE */* __restrict  */)conf_fd);
#line 682
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"m3u_rel_name_type = %d\n",
          def_m3u_rel_name);
#line 684
  fputs((char const   */* __restrict  */)"\n# existing CDDB genres, do not change manually\n",
        (FILE */* __restrict  */)conf_fd);
  }
#line 685
  if (cddb_genres) {
    {
#line 686
    fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"cddb_genre_list = \"%s\"\n",
            cddb_genres);
    }
  } else {
    {
#line 688
    fputs((char const   */* __restrict  */)"cddb_genre_list = 0\n", (FILE */* __restrict  */)conf_fd);
    }
  }
  {
#line 691
  fputs((char const   */* __restrict  */)"\n# allow parallel running sessions of MP3c\n",
        (FILE */* __restrict  */)conf_fd);
#line 692
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"para_sessions_allowed = %d\n",
          (int )config_para_mp3c);
#line 694
  fputs((char const   */* __restrict  */)"\n# use internal directory requester\n",
        (FILE */* __restrict  */)conf_fd);
#line 695
  fprintf((FILE */* __restrict  */)conf_fd, (char const   */* __restrict  */)"use_dir_request = %d\n",
          (int )config_curs_dir);
#line 697
  fclose(conf_fd);
#line 698
  tmp___3 = gettext("configuration saved");
#line 698
  print_stat_win(tmp___3);
#line 699
  usleep((__useconds_t )300000);
#line 700
  destroy_stat_win();
  }
#line 701
  return (0);
}
}
#line 705 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
int load_config(char *fn ) 
{ 
  int conf_fd ;
  int lines ;
  char *inp_line ;
  int i ;
  int j ;
  int k ;
  int l ;
  char *key ;
  char *arg ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t tmp___23 ;
  void *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  char *tmp___72 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;

  {
  {
#line 713
  setup_stat_win(70);
#line 714
  tmp = gettext("loading configuration");
#line 714
  print_stat_win(tmp);
#line 716
  conf_fd = open((char const   *)fn, 0);
  }
#line 717
  if (conf_fd < 1) {
    {
#line 718
    tmp___0 = gettext("loading failed...");
#line 718
    print_stat_win(tmp___0);
#line 719
    sleep(1U);
#line 720
    destroy_stat_win();
    }
#line 721
    return (-1);
  }
#line 724
  lines = 0;
#line 725
  cache_remain = 0;
  {
#line 726
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 726
    tmp___71 = read_from_sock(& inp_line, conf_fd, (unsigned char)0);
    }
#line 726
    if (! (tmp___71 == 0)) {
#line 726
      goto while_break;
    }
#line 727
    lines ++;
#line 728
    if ((int )*inp_line != 35) {
#line 729
      key = (char *)((void *)0);
#line 730
      arg = (char *)((void *)0);
#line 731
      i = 0;
      {
#line 731
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 731
        tmp___1 = strlen((char const   *)inp_line);
        }
#line 731
        if (! ((size_t )i < tmp___1 - 1U)) {
#line 731
          goto while_break___0;
        }
#line 731
        if ((int )*(inp_line + i) == 61) {
#line 731
          goto while_break___0;
        }
#line 731
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 732
      j = i;
#line 733
      i = 0;
      {
#line 733
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 733
        if (! (i < j)) {
#line 733
          goto while_break___1;
        }
#line 733
        if ((int )*(inp_line + i) != 32) {
#line 733
          goto while_break___1;
        }
#line 733
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 734
      k = i;
#line 735
      if (j) {
#line 735
        i = j - 1;
        {
#line 735
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 735
          if (! (i >= 0)) {
#line 735
            goto while_break___2;
          }
#line 735
          if ((int )*(inp_line + i) != 32) {
#line 735
            goto while_break___2;
          }
#line 735
          i --;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 736
      l = i;
#line 738
      if ((l - k) + 1 > 0) {
        {
#line 739
        tmp___2 = malloc((size_t )(sizeof(char ) * (unsigned long )((l - k) + 2)));
#line 739
        key = (char *)tmp___2;
        }
#line 740
        if ((unsigned long )key == (unsigned long )((void *)0)) {
          {
#line 741
          perror("malloc");
#line 742
          wuuush(1);
          }
        }
        {
#line 744
        memcpy((void */* __restrict  */)key, (void const   */* __restrict  */)(inp_line + k),
               (size_t )((l - k) + 1));
#line 745
        *((key + (l - k)) + 1) = (char)0;
        }
      }
#line 748
      i = j + 1;
      {
#line 748
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 748
        tmp___3 = strlen((char const   *)inp_line);
        }
#line 748
        if (! ((size_t )i < tmp___3 - 1U)) {
#line 748
          goto while_break___3;
        }
#line 748
        if ((int )*(inp_line + i) != 32) {
#line 748
          goto while_break___3;
        }
#line 748
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 749
      k = i;
#line 750
      tmp___4 = strlen((char const   *)inp_line);
#line 750
      i = (int )tmp___4;
      }
      {
#line 750
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 750
        if (! (i > k)) {
#line 750
          goto while_break___4;
        }
#line 750
        if ((int )*(inp_line + i) != 0) {
#line 750
          if ((int )*(inp_line + i) != 32) {
#line 750
            if ((int )*(inp_line + i) != 13) {
#line 750
              if ((int )*(inp_line + i) != 10) {
#line 753
                goto while_break___4;
              }
            }
          }
        }
#line 750
        i --;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 754
      l = i;
#line 756
      if ((l - k) + 1 > 0) {
        {
#line 757
        tmp___5 = malloc((size_t )(sizeof(char ) * (unsigned long )((l - k) + 2)));
#line 757
        arg = (char *)tmp___5;
        }
#line 758
        if ((unsigned long )arg == (unsigned long )((void *)0)) {
          {
#line 759
          perror("malloc");
#line 760
          wuuush(1);
          }
        }
        {
#line 762
        memcpy((void */* __restrict  */)arg, (void const   */* __restrict  */)(inp_line + k),
               (size_t )((l - k) + 1));
#line 763
        *((arg + (l - k)) + 1) = (char)0;
        }
#line 764
        if ((int )*arg == 34) {
#line 764
          if ((int )*(arg + (l - k)) == 34) {
#line 765
            *(arg + (l - k)) = (char)0;
#line 766
            if ((l - k) - 1 > 0) {
              {
#line 767
              memmove((void *)arg, (void const   *)(arg + 1), (size_t )(l - k));
              }
            }
          }
        }
      }
#line 772
      if (key) {
#line 772
        if (arg) {
#line 772
          if (*key) {
#line 772
            if (*arg) {
              {
#line 773
              tmp___70 = strcmp((char const   *)key, "cd_dev");
              }
#line 773
              if (tmp___70 == 0) {
#line 774
                if (! external_cdrom_dev) {
#line 775
                  if (def_cdrom_dev) {
                    {
#line 775
                    free((void *)def_cdrom_dev);
                    }
                  }
                  {
#line 776
                  def_cdrom_dev = file_glob_in_name(arg);
#line 777
                  arg = (char *)((void *)0);
                  }
                }
              } else {
                {
#line 779
                tmp___69 = strcmp((char const   *)key, "mp3c_version");
                }
#line 779
                if (tmp___69 == 0) {
#line 780
                  if (def_version_str) {
                    {
#line 780
                    free((void *)def_version_str);
                    }
                  }
#line 781
                  def_version_str = arg;
#line 782
                  arg = (char *)((void *)0);
                } else {
                  {
#line 783
                  tmp___68 = strcmp((char const   *)key, "cddb_serv");
                  }
#line 783
                  if (tmp___68 == 0) {
#line 784
                    if (def_cddb_server) {
                      {
#line 784
                      free((void *)def_cddb_server);
                      }
                    }
#line 785
                    def_cddb_server = arg;
#line 786
                    arg = (char *)((void *)0);
                  } else {
                    {
#line 787
                    tmp___67 = strcmp((char const   *)key, "cddb_loc");
                    }
#line 787
                    if (tmp___67 == 0) {
#line 788
                      if (def_cddb_bank) {
                        {
#line 788
                        free((void *)def_cddb_bank);
                        }
                      }
                      {
#line 789
                      def_cddb_bank = file_glob_in_name(arg);
#line 790
                      arg = (char *)((void *)0);
                      }
                    } else {
                      {
#line 791
                      tmp___66 = strcmp((char const   *)key, "mp3_dir");
                      }
#line 791
                      if (tmp___66 == 0) {
#line 792
                        if (def_mp3_dir) {
                          {
#line 792
                          free((void *)def_mp3_dir);
                          }
                        }
                        {
#line 793
                        def_mp3_dir = file_glob_in_name(arg);
#line 794
                        arg = (char *)((void *)0);
                        }
                      } else {
                        {
#line 795
                        tmp___65 = strcmp((char const   *)key, "rip_nf_prg");
                        }
#line 795
                        if (tmp___65 == 0) {
#line 796
                          if (def_cd_rip_nf) {
                            {
#line 796
                            free((void *)def_cd_rip_nf);
                            }
                          }
                          {
#line 797
                          def_cd_rip_nf = file_glob_in_name(arg);
#line 798
                          arg = (char *)((void *)0);
                          }
                        } else {
                          {
#line 799
                          tmp___64 = strcmp((char const   *)key, "rip_of_prg");
                          }
#line 799
                          if (tmp___64 == 0) {
#line 800
                            if (def_cd_rip_of) {
                              {
#line 800
                              free((void *)def_cd_rip_of);
                              }
                            }
                            {
#line 801
                            def_cd_rip_of = file_glob_in_name(arg);
#line 802
                            arg = (char *)((void *)0);
                            }
                          } else {
                            {
#line 803
                            tmp___63 = strcmp((char const   *)key, "enc_nf_prg");
                            }
#line 803
                            if (tmp___63 == 0) {
#line 804
                              if (def_mp3_enc_nf) {
                                {
#line 804
                                free((void *)def_mp3_enc_nf);
                                }
                              }
                              {
#line 805
                              def_mp3_enc_nf = file_glob_in_name(arg);
#line 806
                              arg = (char *)((void *)0);
                              }
                            } else {
                              {
#line 807
                              tmp___62 = strcmp((char const   *)key, "enc_of_prg");
                              }
#line 807
                              if (tmp___62 == 0) {
#line 808
                                if (def_mp3_enc_of) {
                                  {
#line 808
                                  free((void *)def_mp3_enc_of);
                                  }
                                }
                                {
#line 809
                                def_mp3_enc_of = file_glob_in_name(arg);
#line 810
                                arg = (char *)((void *)0);
                                }
                              } else {
                                {
#line 811
                                tmp___61 = strcmp((char const   *)key, "mp3_info_prg");
                                }
#line 811
                                if (tmp___61 == 0) {
#line 812
                                  if (def_mp3_info) {
                                    {
#line 812
                                    free((void *)def_mp3_info);
                                    }
                                  }
                                  {
#line 813
                                  def_mp3_info = file_glob_in_name(arg);
#line 814
                                  arg = (char *)((void *)0);
                                  }
                                } else {
                                  {
#line 815
                                  tmp___60 = strcmp((char const   *)key, "mp3_pattern");
                                  }
#line 815
                                  if (tmp___60 == 0) {
#line 816
                                    if (fn_pattern) {
                                      {
#line 816
                                      free((void *)fn_pattern);
                                      }
                                    }
#line 817
                                    fn_pattern = arg;
#line 818
                                    arg = (char *)((void *)0);
                                  } else {
                                    {
#line 819
                                    tmp___59 = strcmp((char const   *)key, "mp3_pattern_mix");
                                    }
#line 819
                                    if (tmp___59 == 0) {
#line 820
                                      if (fn_pattern_mix) {
                                        {
#line 820
                                        free((void *)fn_pattern_mix);
                                        }
                                      }
#line 821
                                      fn_pattern_mix = arg;
#line 822
                                      arg = (char *)((void *)0);
                                    } else {
                                      {
#line 823
                                      tmp___58 = strcmp((char const   *)key, "m3u_pattern");
                                      }
#line 823
                                      if (tmp___58 == 0) {
#line 824
                                        if (def_m3u_pattern) {
                                          {
#line 824
                                          free((void *)def_m3u_pattern);
                                          }
                                        }
#line 825
                                        def_m3u_pattern = arg;
#line 826
                                        arg = (char *)((void *)0);
                                      } else {
                                        {
#line 827
                                        tmp___57 = strcmp((char const   *)key, "m3u_patmix");
                                        }
#line 827
                                        if (tmp___57 == 0) {
#line 828
                                          if (def_m3u_patmix) {
                                            {
#line 828
                                            free((void *)def_m3u_patmix);
                                            }
                                          }
#line 829
                                          def_m3u_patmix = arg;
#line 830
                                          arg = (char *)((void *)0);
                                        } else {
                                          {
#line 831
                                          tmp___56 = strcmp((char const   *)key, "m3u_dir");
                                          }
#line 831
                                          if (tmp___56 == 0) {
#line 832
                                            if (def_m3u_dir) {
                                              {
#line 832
                                              free((void *)def_m3u_dir);
                                              }
                                            }
                                            {
#line 833
                                            def_m3u_dir = file_glob_in_name(arg);
#line 834
                                            arg = (char *)((void *)0);
                                            }
                                          } else {
                                            {
#line 835
                                            tmp___55 = strcmp((char const   *)key,
                                                              "mp3_comment");
                                            }
#line 835
                                            if (tmp___55 == 0) {
#line 836
                                              if (def_comment) {
                                                {
#line 836
                                                free((void *)def_comment);
                                                }
                                              }
#line 837
                                              def_comment = arg;
#line 838
                                              arg = (char *)((void *)0);
                                            } else {
                                              {
#line 839
                                              tmp___54 = strcmp((char const   *)key,
                                                                "ill_chars");
                                              }
#line 839
                                              if (tmp___54 == 0) {
#line 840
                                                if (def_ill_chars) {
                                                  {
#line 840
                                                  free((void *)def_ill_chars);
                                                  }
                                                }
#line 841
                                                def_ill_chars = arg;
#line 842
                                                arg = (char *)((void *)0);
                                              } else {
                                                {
#line 843
                                                tmp___53 = strcmp((char const   *)key,
                                                                  "def_exp_file");
                                                }
#line 843
                                                if (tmp___53 == 0) {
#line 844
                                                  if (def_exp_file) {
                                                    {
#line 844
                                                    free((void *)def_exp_file);
                                                    }
                                                  }
                                                  {
#line 845
                                                  def_exp_file = file_glob_in_name(arg);
#line 846
                                                  arg = (char *)((void *)0);
                                                  }
                                                } else {
                                                  {
#line 847
                                                  tmp___52 = strcmp((char const   *)key,
                                                                    "pat_mode");
                                                  }
#line 847
                                                  if (tmp___52 == 0) {
                                                    {
#line 848
                                                    fn_mode = atoi((char const   *)arg);
                                                    }
#line 849
                                                    if (fn_mode < 0) {
                                                      {
#line 850
                                                      tmp___6 = gettext("illegal value for pat_mode");
#line 850
                                                      print_stat_win(tmp___6);
#line 851
                                                      fn_mode = 1;
#line 852
                                                      usleep((__useconds_t )500000);
                                                      }
                                                    } else
#line 849
                                                    if (fn_mode > 2) {
                                                      {
#line 850
                                                      tmp___6 = gettext("illegal value for pat_mode");
#line 850
                                                      print_stat_win(tmp___6);
#line 851
                                                      fn_mode = 1;
#line 852
                                                      usleep((__useconds_t )500000);
                                                      }
                                                    }
                                                  } else {
                                                    {
#line 854
                                                    tmp___51 = strcmp((char const   *)key,
                                                                      "space_rep_char");
                                                    }
#line 854
                                                    if (tmp___51 == 0) {
                                                      {
#line 855
                                                      replace_space_ch = *arg;
#line 856
                                                      tmp___9 = strlen((char const   *)arg);
                                                      }
#line 856
                                                      if (tmp___9 == 0U) {
#line 856
                                                        replace_space_ch = (char )'_';
                                                      } else {
                                                        {
#line 857
                                                        tmp___8 = strlen((char const   *)arg);
                                                        }
#line 857
                                                        if (tmp___8 > 1U) {
                                                          {
#line 858
                                                          tmp___7 = gettext("more than one character in \"space_rep_char\", skipping trailing garbage");
#line 858
                                                          print_stat_win(tmp___7);
#line 859
                                                          usleep((__useconds_t )500000);
                                                          }
                                                        }
                                                      }
                                                    } else {
                                                      {
#line 861
                                                      tmp___50 = strcmp((char const   *)key,
                                                                        "case_chg");
                                                      }
#line 861
                                                      if (tmp___50 == 0) {
                                                        {
#line 862
                                                        config_case_chg = atoi((char const   *)arg);
                                                        }
#line 863
                                                        if (config_case_chg < 0) {
#line 864
                                                          config_case_chg = 0;
                                                        } else
#line 863
                                                        if (config_case_chg > 2) {
#line 864
                                                          config_case_chg = 0;
                                                        }
                                                      } else {
                                                        {
#line 866
                                                        tmp___49 = strcmp((char const   *)key,
                                                                          "del_tmp_on_exit");
                                                        }
#line 866
                                                        if (tmp___49 == 0) {
                                                          {
#line 867
                                                          del_tmp_on_exit = atoi((char const   *)arg);
                                                          }
#line 868
                                                          if (del_tmp_on_exit < 0) {
                                                            {
#line 869
                                                            tmp___10 = gettext("illegal value for del_tmp_on_exit");
#line 869
                                                            print_stat_win(tmp___10);
#line 870
                                                            del_tmp_on_exit = 1;
#line 871
                                                            usleep((__useconds_t )500000);
                                                            }
                                                          } else
#line 868
                                                          if (del_tmp_on_exit > 2) {
                                                            {
#line 869
                                                            tmp___10 = gettext("illegal value for del_tmp_on_exit");
#line 869
                                                            print_stat_win(tmp___10);
#line 870
                                                            del_tmp_on_exit = 1;
#line 871
                                                            usleep((__useconds_t )500000);
                                                            }
                                                          }
                                                        } else {
                                                          {
#line 873
                                                          tmp___48 = strcmp((char const   *)key,
                                                                            "of_fifo");
                                                          }
#line 873
                                                          if (tmp___48 == 0) {
                                                            {
#line 874
                                                            of_fifo_buf = atoi((char const   *)arg);
                                                            }
#line 875
                                                            if (of_fifo_buf < 16) {
#line 875
                                                              of_fifo_buf = 512;
                                                            } else
#line 875
                                                            if (of_fifo_buf > 8192) {
#line 875
                                                              of_fifo_buf = 512;
                                                            }
                                                          } else {
                                                            {
#line 876
                                                            tmp___47 = strcmp((char const   *)key,
                                                                              "frame_mult");
                                                            }
#line 876
                                                            if (tmp___47 == 0) {
                                                              {
#line 877
                                                              mp3_frame_mult = atoi((char const   *)arg);
                                                              }
#line 878
                                                              if (mp3_frame_mult < 1) {
#line 878
                                                                mp3_frame_mult = 214;
                                                              } else
#line 878
                                                              if (mp3_frame_mult > 32000) {
#line 878
                                                                mp3_frame_mult = 214;
                                                              }
                                                            } else {
                                                              {
#line 879
                                                              tmp___46 = strcmp((char const   *)key,
                                                                                "pat_upc");
                                                              }
#line 879
                                                              if (tmp___46 == 0) {
#line 880
                                                                fn_toupper = (unsigned char)1;
#line 881
                                                                if ((int )*arg == 48) {
#line 881
                                                                  fn_toupper = (unsigned char)0;
                                                                }
                                                              } else {
                                                                {
#line 882
                                                                tmp___45 = strcmp((char const   *)key,
                                                                                  "def_on_fly");
                                                                }
#line 882
                                                                if (tmp___45 == 0) {
#line 883
                                                                  def_on_fly = (unsigned char)0;
#line 884
                                                                  if ((int )*arg == 49) {
#line 884
                                                                    def_on_fly = (unsigned char)1;
                                                                  }
                                                                } else {
                                                                  {
#line 885
                                                                  tmp___44 = strcmp((char const   *)key,
                                                                                    "rip_enc_ord");
                                                                  }
#line 885
                                                                  if (tmp___44 == 0) {
#line 886
                                                                    rip_enc_ordered = (unsigned char)0;
#line 887
                                                                    if ((int )*arg == 49) {
#line 887
                                                                      rip_enc_ordered = (unsigned char)1;
                                                                    }
                                                                  } else {
                                                                    {
#line 888
                                                                    tmp___43 = strcmp((char const   *)key,
                                                                                      "pattern_protect");
                                                                    }
#line 888
                                                                    if (tmp___43 == 0) {
#line 889
                                                                      config_pat_prot = (unsigned char)1;
#line 890
                                                                      if ((int )*arg == 48) {
#line 890
                                                                        config_pat_prot = (unsigned char)0;
                                                                      }
                                                                    } else {
                                                                      {
#line 891
                                                                      tmp___42 = strcmp((char const   *)key,
                                                                                        "slash_rep_char");
                                                                      }
#line 891
                                                                      if (tmp___42 == 0) {
                                                                        {
#line 892
                                                                        replace_slash_ch = *arg;
#line 893
                                                                        tmp___13 = strlen((char const   *)arg);
                                                                        }
#line 893
                                                                        if (tmp___13 == 0U) {
#line 893
                                                                          replace_slash_ch = (char )'-';
                                                                        } else {
                                                                          {
#line 894
                                                                          tmp___12 = strlen((char const   *)arg);
                                                                          }
#line 894
                                                                          if (tmp___12 > 1U) {
                                                                            {
#line 895
                                                                            tmp___11 = gettext("more than one character in \"slash_rep_char\", skipping trailing garbage");
#line 895
                                                                            print_stat_win(tmp___11);
#line 896
                                                                            usleep((__useconds_t )500000);
                                                                            }
                                                                          }
                                                                        }
                                                                      } else {
                                                                        {
#line 898
                                                                        tmp___41 = strcmp((char const   *)key,
                                                                                          "eased_char_hand");
                                                                        }
#line 898
                                                                        if (tmp___41 == 0) {
#line 899
                                                                          eased_char_hand = (unsigned char)0;
#line 900
                                                                          if ((int )*arg == 49) {
#line 900
                                                                            eased_char_hand = (unsigned char)1;
                                                                          }
                                                                        } else {
                                                                          {
#line 901
                                                                          tmp___40 = strcmp((char const   *)key,
                                                                                            "fancy_color");
                                                                          }
#line 901
                                                                          if (tmp___40 == 0) {
                                                                            {
#line 902
                                                                            tmp___14 = atoi((char const   *)arg);
#line 902
                                                                            config_fancy_colors = (signed char )tmp___14;
                                                                            }
#line 903
                                                                            if ((int )config_fancy_colors < 0) {
                                                                              {
#line 904
                                                                              tmp___15 = gettext("illegal value for fancy_colors");
#line 904
                                                                              print_stat_win(tmp___15);
#line 905
                                                                              config_fancy_colors = (signed char)1;
#line 906
                                                                              usleep((__useconds_t )500000);
                                                                              }
                                                                            } else
#line 903
                                                                            if ((int )config_fancy_colors > 2) {
                                                                              {
#line 904
                                                                              tmp___15 = gettext("illegal value for fancy_colors");
#line 904
                                                                              print_stat_win(tmp___15);
#line 905
                                                                              config_fancy_colors = (signed char)1;
#line 906
                                                                              usleep((__useconds_t )500000);
                                                                              }
                                                                            }
                                                                          } else {
                                                                            {
#line 908
                                                                            tmp___39 = strcmp((char const   *)key,
                                                                                              "m3u_rel_name_type");
                                                                            }
#line 908
                                                                            if (tmp___39 == 0) {
                                                                              {
#line 909
                                                                              def_m3u_rel_name = atoi((char const   *)arg);
                                                                              }
#line 910
                                                                              if (def_m3u_rel_name < 0) {
#line 911
                                                                                def_m3u_rel_name = 2;
                                                                              } else
#line 910
                                                                              if (def_m3u_rel_name > 2) {
#line 911
                                                                                def_m3u_rel_name = 2;
                                                                              }
                                                                            } else {
                                                                              {
#line 913
                                                                              tmp___38 = strcmp((char const   *)key,
                                                                                                "auto_save");
                                                                              }
#line 913
                                                                              if (tmp___38 == 0) {
                                                                                {
#line 914
                                                                                auto_save = atoi((char const   *)arg);
                                                                                }
#line 915
                                                                                if (auto_save != 1) {
#line 915
                                                                                  auto_save = 0;
                                                                                }
                                                                              } else {
                                                                                {
#line 916
                                                                                tmp___37 = strcmp((char const   *)key,
                                                                                                  "use_dir_request");
                                                                                }
#line 916
                                                                                if (tmp___37 == 0) {
                                                                                  {
#line 917
                                                                                  tmp___16 = atoi((char const   *)arg);
#line 917
                                                                                  config_curs_dir = (unsigned char )tmp___16;
                                                                                  }
#line 918
                                                                                  if ((int )config_curs_dir != 0) {
#line 918
                                                                                    config_curs_dir = (unsigned char)1;
                                                                                  }
                                                                                } else {
                                                                                  {
#line 919
                                                                                  tmp___36 = strcmp((char const   *)key,
                                                                                                    "rem_cddb");
                                                                                  }
#line 919
                                                                                  if (tmp___36 == 0) {
                                                                                    {
#line 920
                                                                                    tmp___17 = atoi((char const   *)arg);
#line 920
                                                                                    config_cddb_enbl = (unsigned char )tmp___17;
                                                                                    }
#line 921
                                                                                    if ((int )config_cddb_enbl != 0) {
#line 921
                                                                                      config_cddb_enbl = (unsigned char)1;
                                                                                    }
                                                                                  } else {
                                                                                    {
#line 922
                                                                                    tmp___35 = strcmp((char const   *)key,
                                                                                                      "para_sessions_allowed");
                                                                                    }
#line 922
                                                                                    if (tmp___35 == 0) {
                                                                                      {
#line 923
                                                                                      tmp___18 = atoi((char const   *)arg);
#line 923
                                                                                      config_para_mp3c = (unsigned char )tmp___18;
                                                                                      }
#line 924
                                                                                      if ((int )config_para_mp3c != 0) {
#line 924
                                                                                        config_para_mp3c = (unsigned char)1;
                                                                                      }
                                                                                    } else {
                                                                                      {
#line 925
                                                                                      tmp___34 = strcmp((char const   *)key,
                                                                                                        "open_tray");
                                                                                      }
#line 925
                                                                                      if (tmp___34 == 0) {
                                                                                        {
#line 926
                                                                                        tmp___19 = atoi((char const   *)arg);
#line 926
                                                                                        config_open_tray = (unsigned char )tmp___19;
                                                                                        }
#line 927
                                                                                        if ((int )config_open_tray != 0) {
#line 927
                                                                                          config_open_tray = (unsigned char)1;
                                                                                        }
                                                                                      } else {
                                                                                        {
#line 928
                                                                                        tmp___33 = strcmp((char const   *)key,
                                                                                                          "rem_ill_char");
                                                                                        }
#line 928
                                                                                        if (tmp___33 == 0) {
                                                                                          {
#line 929
                                                                                          tmp___20 = atoi((char const   *)arg);
#line 929
                                                                                          config_ill_remove = (unsigned char )tmp___20;
                                                                                          }
#line 930
                                                                                          if ((int )config_ill_remove != 0) {
#line 930
                                                                                            config_ill_remove = (unsigned char)1;
                                                                                          }
                                                                                        } else {
                                                                                          {
#line 931
                                                                                          tmp___32 = strcmp((char const   *)key,
                                                                                                            "clear_del_on_exp");
                                                                                          }
#line 931
                                                                                          if (tmp___32 == 0) {
                                                                                            {
#line 932
                                                                                            tmp___21 = atoi((char const   *)arg);
#line 932
                                                                                            clear_del_on_exp = (unsigned char )tmp___21;
                                                                                            }
#line 933
                                                                                            if ((int )clear_del_on_exp != 0) {
#line 933
                                                                                              clear_del_on_exp = (unsigned char)1;
                                                                                            }
                                                                                          } else {
                                                                                            {
#line 934
                                                                                            tmp___31 = strcmp((char const   *)key,
                                                                                                              "tmp_file");
                                                                                            }
#line 934
                                                                                            if (tmp___31 == 0) {
#line 935
                                                                                              if (def_tmp_file) {
                                                                                                {
#line 935
                                                                                                free((void *)def_tmp_file);
                                                                                                }
                                                                                              }
                                                                                              {
#line 936
                                                                                              def_tmp_file = file_glob_in_name(arg);
#line 937
                                                                                              arg = (char *)((void *)0);
                                                                                              }
                                                                                            } else {
                                                                                              {
#line 938
                                                                                              tmp___30 = strcmp((char const   *)key,
                                                                                                                "cddb_email");
                                                                                              }
#line 938
                                                                                              if (tmp___30 == 0) {
#line 939
                                                                                                if (def_cddb_email) {
                                                                                                  {
#line 939
                                                                                                  free((void *)def_cddb_email);
                                                                                                  }
                                                                                                }
#line 940
                                                                                                def_cddb_email = arg;
#line 941
                                                                                                arg = (char *)((void *)0);
                                                                                              } else {
                                                                                                {
#line 942
                                                                                                tmp___29 = strcmp((char const   *)key,
                                                                                                                  "smtp_serv");
                                                                                                }
#line 942
                                                                                                if (tmp___29 == 0) {
#line 943
                                                                                                  if (def_smtp_server) {
                                                                                                    {
#line 943
                                                                                                    free((void *)def_smtp_server);
                                                                                                    }
                                                                                                  }
#line 944
                                                                                                  def_smtp_server = arg;
#line 945
                                                                                                  arg = (char *)((void *)0);
                                                                                                } else {
                                                                                                  {
#line 946
                                                                                                  tmp___28 = strcmp((char const   *)key,
                                                                                                                    "my_email");
                                                                                                  }
#line 946
                                                                                                  if (tmp___28 == 0) {
#line 947
                                                                                                    if (def_my_email) {
                                                                                                      {
#line 947
                                                                                                      free((void *)def_my_email);
                                                                                                      }
                                                                                                    }
#line 948
                                                                                                    def_my_email = arg;
#line 949
                                                                                                    arg = (char *)((void *)0);
                                                                                                  } else {
                                                                                                    {
#line 950
                                                                                                    tmp___27 = strcmp((char const   *)key,
                                                                                                                      "unknown_genre");
                                                                                                    }
#line 950
                                                                                                    if (tmp___27 == 0) {
#line 951
                                                                                                      if (def_unknown_gen) {
                                                                                                        {
#line 951
                                                                                                        free((void *)def_unknown_gen);
                                                                                                        }
                                                                                                      }
#line 952
                                                                                                      def_unknown_gen = arg;
#line 953
                                                                                                      arg = (char *)((void *)0);
                                                                                                    } else {
                                                                                                      {
#line 954
                                                                                                      tmp___26 = strcmp((char const   *)key,
                                                                                                                        "cddb_genre_list");
                                                                                                      }
#line 954
                                                                                                      if (tmp___26 == 0) {
#line 955
                                                                                                        if (cddb_genres) {
                                                                                                          {
#line 955
                                                                                                          free((void *)cddb_genres);
                                                                                                          }
                                                                                                        }
#line 956
                                                                                                        cddb_genres = arg;
#line 957
                                                                                                        arg = (char *)((void *)0);
#line 958
                                                                                                        if (cddb_genres) {
                                                                                                          {
#line 958
                                                                                                          tmp___22 = strcmp((char const   *)cddb_genres,
                                                                                                                            "0");
                                                                                                          }
#line 958
                                                                                                          if (tmp___22 == 0) {
                                                                                                            {
#line 959
                                                                                                            free((void *)cddb_genres);
#line 960
                                                                                                            cddb_genres = (char *)((void *)0);
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      } else {
#line 963
                                                                                                        if (arg) {
                                                                                                          {
#line 963
                                                                                                          free((void *)arg);
                                                                                                          }
                                                                                                        }
                                                                                                        {
#line 964
                                                                                                        tmp___23 = strlen((char const   *)key);
#line 964
                                                                                                        tmp___24 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___23 + 70U)));
#line 964
                                                                                                        arg = (char *)tmp___24;
                                                                                                        }
#line 965
                                                                                                        if ((unsigned long )arg == (unsigned long )((void *)0)) {
                                                                                                          {
#line 966
                                                                                                          perror("malloc");
#line 967
                                                                                                          wuuush(1);
                                                                                                          }
                                                                                                        }
                                                                                                        {
#line 969
                                                                                                        tmp___25 = gettext("unknown key \"%s\" in line %d");
#line 969
                                                                                                        sprintf((char */* __restrict  */)arg,
                                                                                                                (char const   */* __restrict  */)tmp___25,
                                                                                                                key,
                                                                                                                lines);
#line 970
                                                                                                        popup_error_win(arg);
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 974
      if (key) {
        {
#line 974
        free((void *)key);
        }
      }
#line 975
      if (arg) {
        {
#line 975
        free((void *)arg);
        }
      }
    }
    {
#line 977
    free((void *)inp_line);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 980
  close(conf_fd);
#line 981
  tmp___72 = gettext("configuration loaded");
#line 981
  print_stat_win(tmp___72);
#line 982
  usleep((__useconds_t )300000);
#line 983
  destroy_stat_win();
  }
#line 984
  return (0);
}
}
#line 987 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
int get_config(char *file ) 
{ 
  char *pointer ;
  char *name ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 991
  if (file) {
    {
#line 992
    tmp = load_config(file);
    }
#line 992
    if (tmp) {
#line 992
      return (-1);
    } else {
#line 993
      return (0);
    }
  }
  {
#line 996
  pointer = getenv("HOME");
  }
#line 997
  if (pointer) {
    {
#line 998
    tmp___0 = strlen((char const   *)pointer);
#line 998
    tmp___1 = strlen("mp3crc");
#line 998
    tmp___2 = malloc((size_t )(sizeof(char ) * (unsigned long )((tmp___0 + tmp___1) + 3U)));
#line 998
    name = (char *)tmp___2;
    }
#line 999
    if ((unsigned long )name == (unsigned long )((void *)0)) {
      {
#line 1000
      perror("malloc");
#line 1001
      wuuush(1);
      }
    }
    {
#line 1003
    sprintf((char */* __restrict  */)name, (char const   */* __restrict  */)"%s/.%s",
            pointer, "mp3crc");
#line 1004
    tmp___4 = access((char const   *)name, 4);
    }
#line 1004
    if (tmp___4 == 0) {
      {
#line 1005
      tmp___3 = load_config(name);
      }
#line 1005
      if (tmp___3 == 0) {
        {
#line 1006
        free((void *)name);
        }
#line 1007
        return (0);
      }
    }
    {
#line 1010
    free((void *)name);
    }
  }
  {
#line 1013
  tmp___5 = strlen("mp3crc");
#line 1013
  tmp___6 = strlen("/usr/local/etc");
#line 1013
  tmp___7 = malloc((size_t )(sizeof(char ) * (unsigned long )((tmp___5 + tmp___6) + 2U)));
#line 1013
  name = (char *)tmp___7;
  }
#line 1014
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 1015
    perror("malloc");
#line 1016
    wuuush(1);
    }
  }
  {
#line 1018
  sprintf((char */* __restrict  */)name, (char const   */* __restrict  */)"%s/%s",
          "/usr/local/etc", "mp3crc");
#line 1019
  tmp___9 = access((char const   *)name, 4);
  }
#line 1019
  if (tmp___9 == 0) {
    {
#line 1020
    tmp___8 = load_config(file);
    }
#line 1020
    if (tmp___8 == 0) {
      {
#line 1021
      free((void *)name);
      }
#line 1022
      return (0);
    }
    {
#line 1024
    free((void *)name);
    }
#line 1025
    return (-1);
  }
  {
#line 1027
  free((void *)name);
#line 1029
  setup_stat_win(55);
#line 1030
  tmp___10 = gettext("no configfile found, using defaults");
#line 1030
  print_stat_win(tmp___10);
#line 1031
  usleep((__useconds_t )500000);
#line 1032
  destroy_stat_win();
  }
#line 1034
  return (-1);
}
}
#line 1037 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
int put_config(char *file , unsigned char ask ) 
{ 
  char *pointer ;
  char *name ;
  int status ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  unsigned char tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  unsigned char tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 1043
  if (file) {
    {
#line 1044
    tmp___0 = access((char const   *)file, 0);
    }
#line 1044
    if (tmp___0 != 0) {
      {
#line 1046
      tmp = save_config(file);
      }
#line 1046
      return (tmp);
    }
    {
#line 1048
    tmp___2 = access((char const   *)file, 2);
    }
#line 1048
    if (tmp___2 != 0) {
      {
#line 1049
      setup_stat_win(35);
#line 1050
      tmp___1 = gettext("permission denied to save config");
#line 1050
      print_stat_win(tmp___1);
#line 1051
      sleep(1U);
#line 1052
      destroy_stat_win();
      }
#line 1053
      return (-1);
    }
#line 1055
    if (ask) {
      {
#line 1056
      tmp___3 = gettext("overwrite config file?");
#line 1056
      tmp___4 = select_yesno_box(tmp___3);
      }
#line 1056
      if (! tmp___4) {
#line 1057
        return (1);
      }
    }
    {
#line 1060
    tmp___5 = save_config(file);
    }
#line 1060
    return (tmp___5);
  }
  {
#line 1063
  pointer = getenv("HOME");
  }
#line 1064
  if ((unsigned long )pointer == (unsigned long )((void *)0)) {
#line 1064
    return (-1);
  }
  {
#line 1066
  tmp___6 = strlen((char const   *)pointer);
#line 1066
  tmp___7 = strlen("mp3crc");
#line 1066
  tmp___8 = malloc((size_t )(sizeof(char ) * (unsigned long )((tmp___6 + tmp___7) + 3U)));
#line 1066
  name = (char *)tmp___8;
  }
#line 1068
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 1069
    perror("malloc");
#line 1070
    wuuush(1);
    }
  }
  {
#line 1073
  sprintf((char */* __restrict  */)name, (char const   */* __restrict  */)"%s/.%s",
          pointer, "mp3crc");
#line 1075
  tmp___13 = access((char const   *)name, 0);
  }
#line 1075
  if (tmp___13 != 0) {
    {
#line 1077
    status = save_config(name);
    }
  } else {
    {
#line 1079
    tmp___12 = access((char const   *)name, 2);
    }
#line 1079
    if (tmp___12 != 0) {
      {
#line 1081
      setup_stat_win(55);
#line 1082
      tmp___9 = gettext("permission denied to save config");
#line 1082
      print_stat_win(tmp___9);
#line 1083
      sleep(1U);
#line 1084
      status = -1;
#line 1085
      destroy_stat_win();
      }
    } else
#line 1088
    if (ask) {
      {
#line 1090
      tmp___10 = gettext("overwrite config file?");
#line 1090
      tmp___11 = select_yesno_box(tmp___10);
      }
#line 1090
      if (tmp___11) {
        {
#line 1093
        status = save_config(name);
        }
      } else {
#line 1091
        status = 1;
      }
    } else {
      {
#line 1096
      status = save_config(name);
      }
    }
  }
  {
#line 1101
  free((void *)name);
  }
#line 1102
  return (status);
}
}
#line 1105 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
char *build_mp3_filenm(song_typ *track ) 
{ 
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1107
  if (extnl_MP3_name) {
    {
#line 1107
    free((void *)extnl_MP3_name);
    }
  }
#line 1108
  extnl_MP3_name = (char *)((void *)0);
#line 1110
  if (! track->filename) {
#line 1110
    goto _L;
  } else
#line 1110
  if (! track->dirname) {
    _L: /* CIL Label */ 
    {
#line 1111
    tmp = malloc((size_t )(sizeof(char ) * 15UL));
#line 1111
    extnl_MP3_name = (char *)tmp;
    }
#line 1112
    if ((unsigned long )extnl_MP3_name == (unsigned long )((void *)0)) {
      {
#line 1113
      perror("malloc");
#line 1114
      wuuush(1);
      }
    }
    {
#line 1119
    sprintf((char */* __restrict  */)extnl_MP3_name, (char const   */* __restrict  */)"track-%d.mp3",
            (int )track->toc + 1);
#line 1121
    tmp___0 = kill_double_slashs(extnl_MP3_name);
    }
#line 1121
    return (tmp___0);
  }
  {
#line 1124
  tmp___1 = strlen((char const   *)track->filename);
#line 1124
  tmp___2 = strlen((char const   *)track->dirname);
#line 1124
  tmp___3 = malloc((size_t )(sizeof(char ) * (unsigned long )((tmp___1 + tmp___2) + 2U)));
#line 1124
  extnl_MP3_name = (char *)tmp___3;
  }
#line 1126
  if ((unsigned long )extnl_MP3_name == (unsigned long )((void *)0)) {
    {
#line 1127
    perror("malloc");
#line 1128
    wuuush(1);
    }
  }
  {
#line 1130
  sprintf((char */* __restrict  */)extnl_MP3_name, (char const   */* __restrict  */)"%s/%s",
          track->dirname, track->filename);
#line 1131
  tmp___4 = kill_double_slashs(extnl_MP3_name);
  }
#line 1131
  return (tmp___4);
}
}
#line 1134 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
char *create_sub_string(song_typ *track , int mode ) 
{ 
  char *sub_str ;
  char *add_poi ;
  char *def_str ;
  int i ;
  int j ;
  int k ;
  unsigned char pat ;
  char def_add[15] ;
  time_t lt ;
  struct tm *ltm ;
  unsigned long track_len ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  void *tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  void *tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  void *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;

  {
#line 1144
  if (! track) {
#line 1144
    return ((char *)((void *)0));
  }
#line 1146
  if (extnl_PROC_mask) {
    {
#line 1147
    free((void *)extnl_PROC_mask);
#line 1148
    extnl_PROC_mask = (char *)((void *)0);
    }
  }
  {
#line 1151
  lt = time((time_t *)((void *)0));
#line 1152
  ltm = localtime((time_t const   *)(& lt));
#line 1154
  track_len = (unsigned long )((cdtoc[(int )track->toc + 1].frame + 75 * (60 * cdtoc[(int )track->toc + 1].min + cdtoc[(int )track->toc + 1].sec)) - (cdtoc[(int )track->toc].frame + 75 * (60 * cdtoc[(int )track->toc].min + cdtoc[(int )track->toc].sec)));
  }
  {
#line 1162
  if (mode == 1) {
#line 1162
    goto case_1;
  }
#line 1165
  if (mode == 2) {
#line 1165
    goto case_2;
  }
#line 1168
  if (mode == 3) {
#line 1168
    goto case_3;
  }
#line 1171
  if (mode == 4) {
#line 1171
    goto case_4;
  }
#line 1174
  if (mode == 5) {
#line 1174
    goto case_5;
  }
#line 1177
  if (mode == 6) {
#line 1177
    goto case_6;
  }
#line 1184
  if (mode == 7) {
#line 1184
    goto case_7;
  }
#line 1187
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1163
  def_str = def_mp3_enc_nf;
#line 1164
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1166
  def_str = def_mp3_enc_of;
#line 1167
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1169
  def_str = def_cd_rip_nf;
#line 1170
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1172
  def_str = def_cd_rip_of;
#line 1173
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1175
  def_str = def_mp3_info;
#line 1176
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1178
  if (track->sampler) {
#line 1179
    def_str = def_m3u_patmix;
  } else {
#line 1181
    def_str = def_m3u_pattern;
  }
#line 1183
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1185
  def_str = track->comment;
#line 1186
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1188
  return ((char *)((void *)0));
#line 1189
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1192
  tmp = malloc((size_t )sizeof(char ));
#line 1192
  sub_str = (char *)tmp;
  }
#line 1193
  if ((unsigned long )sub_str == (unsigned long )((void *)0)) {
    {
#line 1194
    perror("malloc");
#line 1195
    wuuush(1);
    }
  }
  {
#line 1197
  *sub_str = (char)0;
#line 1199
  tmp___0 = malloc((size_t )sizeof(char ));
#line 1199
  extnl_PROC_mask = (char *)tmp___0;
  }
#line 1200
  if (! extnl_PROC_mask) {
    {
#line 1201
    wuuush(1);
    }
  }
#line 1203
  *extnl_PROC_mask = (char)0;
#line 1205
  i = 0;
#line 1206
  pat = (unsigned char)0;
#line 1207
  j = 0;
  {
#line 1207
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1207
    tmp___17 = strlen((char const   *)def_str);
    }
#line 1207
    if (! ((size_t )j < tmp___17)) {
#line 1207
      goto while_break;
    }
#line 1208
    if (pat) {
#line 1209
      pat = (unsigned char)0;
#line 1210
      k = (j - 1) - i;
#line 1211
      if (k > 0) {
        {
#line 1212
        tmp___1 = strlen((char const   *)sub_str);
#line 1212
        tmp___2 = realloc((void *)extnl_PROC_mask, (size_t )(sizeof(char ) * (unsigned long )((tmp___1 + (size_t )k) + 1U)));
#line 1212
        extnl_PROC_mask = (char *)tmp___2;
        }
#line 1214
        if (! extnl_PROC_mask) {
          {
#line 1215
          wuuush(1);
          }
        }
        {
#line 1217
        tmp___3 = strlen((char const   *)sub_str);
#line 1217
        memcpy((void */* __restrict  */)(extnl_PROC_mask + tmp___3), (void const   */* __restrict  */)(def_str + i),
               (size_t )k);
#line 1219
        tmp___4 = strlen((char const   *)sub_str);
#line 1219
        tmp___5 = realloc((void *)sub_str, (size_t )(sizeof(char ) * (unsigned long )((tmp___4 + (size_t )k) + 1U)));
#line 1219
        sub_str = (char *)tmp___5;
        }
#line 1220
        if ((unsigned long )sub_str == (unsigned long )((void *)0)) {
          {
#line 1221
          perror("realloc");
#line 1222
          wuuush(1);
          }
        }
        {
#line 1224
        tmp___6 = strlen((char const   *)sub_str);
#line 1224
        *((sub_str + tmp___6) + k) = (char)0;
#line 1225
        tmp___7 = strlen((char const   *)sub_str);
#line 1225
        memcpy((void */* __restrict  */)(sub_str + tmp___7), (void const   */* __restrict  */)(def_str + i),
               (size_t )k);
        }
      }
#line 1227
      i = j + 1;
#line 1228
      add_poi = (char *)((void *)0);
#line 1229
      if ((int )*(def_str + j) == 37) {
#line 1230
        def_add[0] = (char )'%';
#line 1231
        def_add[1] = (char)0;
#line 1232
        add_poi = def_add;
      } else {
        {
#line 1235
        if (mode == 1) {
#line 1235
          goto case_1___0;
        }
#line 1290
        if (mode == 2) {
#line 1290
          goto case_2___0;
        }
#line 1343
        if (mode == 4) {
#line 1343
          goto case_4___0;
        }
#line 1343
        if (mode == 3) {
#line 1343
          goto case_4___0;
        }
#line 1366
        if (mode == 5) {
#line 1366
          goto case_5___0;
        }
#line 1415
        if (mode == 6) {
#line 1415
          goto case_6___0;
        }
#line 1461
        if (mode == 7) {
#line 1461
          goto case_7___0;
        }
#line 1234
        goto switch_break___0;
        case_1___0: /* CIL Label */ 
        {
#line 1237
        if ((int )*(def_str + j) == 49) {
#line 1237
          goto case_49;
        }
#line 1240
        if ((int )*(def_str + j) == 50) {
#line 1240
          goto case_50;
        }
#line 1243
        if ((int )*(def_str + j) == 51) {
#line 1243
          goto case_51;
        }
#line 1246
        if ((int )*(def_str + j) == 52) {
#line 1246
          goto case_52;
        }
#line 1250
        if ((int )*(def_str + j) == 53) {
#line 1250
          goto case_53;
        }
#line 1254
        if ((int )*(def_str + j) == 54) {
#line 1254
          goto case_54;
        }
#line 1259
        if ((int )*(def_str + j) == 55) {
#line 1259
          goto case_55;
        }
#line 1262
        if ((int )*(def_str + j) == 56) {
#line 1262
          goto case_56;
        }
#line 1269
        if ((int )*(def_str + j) == 97) {
#line 1269
          goto case_97;
        }
#line 1273
        if ((int )*(def_str + j) == 98) {
#line 1273
          goto case_98;
        }
#line 1277
        if ((int )*(def_str + j) == 99) {
#line 1277
          goto case_99;
        }
#line 1280
        if ((int )*(def_str + j) == 100) {
#line 1280
          goto case_100;
        }
#line 1283
        goto switch_default___0;
        case_49: /* CIL Label */ 
        {
#line 1238
        add_poi = return_track_tmpname(track);
        }
#line 1239
        goto switch_break___1;
        case_50: /* CIL Label */ 
        {
#line 1241
        add_poi = build_mp3_filenm(track);
        }
#line 1242
        goto switch_break___1;
        case_51: /* CIL Label */ 
#line 1244
        add_poi = track->album;
#line 1245
        goto switch_break___1;
        case_52: /* CIL Label */ 
        {
#line 1247
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%d",
                track->genre);
#line 1248
        add_poi = def_add;
        }
#line 1249
        goto switch_break___1;
        case_53: /* CIL Label */ 
        {
#line 1251
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%d",
                track->year);
#line 1252
        add_poi = def_add;
        }
#line 1253
        goto switch_break___1;
        case_54: /* CIL Label */ 
#line 1255
        if (extnl_MP3_name) {
          {
#line 1255
          free((void *)extnl_MP3_name);
          }
        }
        {
#line 1256
        extnl_MP3_name = create_sub_string(track, 7);
#line 1257
        add_poi = extnl_MP3_name;
        }
#line 1258
        goto switch_break___1;
        case_55: /* CIL Label */ 
        {
#line 1260
        add_poi = build_mp3_filenm(track);
        }
#line 1261
        goto switch_break___1;
        case_56: /* CIL Label */ 
#line 1263
        if (track->genre != 147) {
#line 1264
          add_poi = mp3_genre[track->genre];
        } else {
#line 1266
          add_poi = def_unknown_gen;
        }
#line 1268
        goto switch_break___1;
        case_97: /* CIL Label */ 
        {
#line 1270
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%d",
                (int )track->toc + 1);
#line 1271
        add_poi = def_add;
        }
#line 1272
        goto switch_break___1;
        case_98: /* CIL Label */ 
        {
#line 1274
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%02d",
                (int )track->toc + 1);
#line 1275
        add_poi = def_add;
        }
#line 1276
        goto switch_break___1;
        case_99: /* CIL Label */ 
#line 1278
        add_poi = track->artist;
#line 1279
        goto switch_break___1;
        case_100: /* CIL Label */ 
#line 1281
        add_poi = track->title;
#line 1282
        goto switch_break___1;
        switch_default___0: /* CIL Label */ 
#line 1284
        def_add[0] = (char)0;
#line 1285
        add_poi = def_add;
#line 1286
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
#line 1288
        goto switch_break___0;
        case_2___0: /* CIL Label */ 
        {
#line 1292
        if ((int )*(def_str + j) == 49) {
#line 1292
          goto case_49___0;
        }
#line 1295
        if ((int )*(def_str + j) == 51) {
#line 1295
          goto case_51___0;
        }
#line 1298
        if ((int )*(def_str + j) == 52) {
#line 1298
          goto case_52___0;
        }
#line 1302
        if ((int )*(def_str + j) == 53) {
#line 1302
          goto case_53___0;
        }
#line 1306
        if ((int )*(def_str + j) == 54) {
#line 1306
          goto case_54___0;
        }
#line 1311
        if ((int )*(def_str + j) == 55) {
#line 1311
          goto case_55___0;
        }
#line 1314
        if ((int )*(def_str + j) == 56) {
#line 1314
          goto case_56___0;
        }
#line 1321
        if ((int )*(def_str + j) == 97) {
#line 1321
          goto case_97___0;
        }
#line 1325
        if ((int )*(def_str + j) == 98) {
#line 1325
          goto case_98___0;
        }
#line 1329
        if ((int )*(def_str + j) == 99) {
#line 1329
          goto case_99___0;
        }
#line 1332
        if ((int )*(def_str + j) == 100) {
#line 1332
          goto case_100___0;
        }
#line 1335
        goto switch_default___1;
        case_49___0: /* CIL Label */ 
        {
#line 1293
        add_poi = build_mp3_filenm(track);
        }
#line 1294
        goto switch_break___2;
        case_51___0: /* CIL Label */ 
#line 1296
        add_poi = track->album;
#line 1297
        goto switch_break___2;
        case_52___0: /* CIL Label */ 
        {
#line 1299
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%d",
                track->genre);
#line 1300
        add_poi = def_add;
        }
#line 1301
        goto switch_break___2;
        case_53___0: /* CIL Label */ 
        {
#line 1303
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%d",
                track->year);
#line 1304
        add_poi = def_add;
        }
#line 1305
        goto switch_break___2;
        case_54___0: /* CIL Label */ 
#line 1307
        if (extnl_MP3_name) {
          {
#line 1307
          free((void *)extnl_MP3_name);
          }
        }
        {
#line 1308
        extnl_MP3_name = create_sub_string(track, 7);
#line 1309
        add_poi = extnl_MP3_name;
        }
#line 1310
        goto switch_break___2;
        case_55___0: /* CIL Label */ 
        {
#line 1312
        add_poi = build_mp3_filenm(track);
        }
#line 1313
        goto switch_break___2;
        case_56___0: /* CIL Label */ 
#line 1315
        if (track->genre != 147) {
#line 1316
          add_poi = mp3_genre[track->genre];
        } else {
#line 1318
          add_poi = def_unknown_gen;
        }
#line 1320
        goto switch_break___2;
        case_97___0: /* CIL Label */ 
        {
#line 1322
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%d",
                (int )track->toc + 1);
#line 1323
        add_poi = def_add;
        }
#line 1324
        goto switch_break___2;
        case_98___0: /* CIL Label */ 
        {
#line 1326
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%02d",
                (int )track->toc + 1);
#line 1327
        add_poi = def_add;
        }
#line 1328
        goto switch_break___2;
        case_99___0: /* CIL Label */ 
#line 1330
        add_poi = track->artist;
#line 1331
        goto switch_break___2;
        case_100___0: /* CIL Label */ 
#line 1333
        add_poi = track->title;
#line 1334
        goto switch_break___2;
        switch_default___1: /* CIL Label */ 
#line 1336
        def_add[0] = (char)0;
#line 1337
        add_poi = def_add;
#line 1338
        goto switch_break___2;
        switch_break___2: /* CIL Label */ ;
        }
#line 1340
        goto switch_break___0;
        case_4___0: /* CIL Label */ 
        case_3___0: /* CIL Label */ 
        {
#line 1345
        if ((int )*(def_str + j) == 49) {
#line 1345
          goto case_49___1;
        }
#line 1348
        if ((int )*(def_str + j) == 50) {
#line 1348
          goto case_50___0;
        }
#line 1352
        if ((int )*(def_str + j) == 51) {
#line 1352
          goto case_51___1;
        }
#line 1359
        goto switch_default___2;
        case_49___1: /* CIL Label */ 
#line 1346
        add_poi = def_cdrom_dev;
#line 1347
        goto switch_break___3;
        case_50___0: /* CIL Label */ 
        {
#line 1349
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%d",
                (int )track->toc + 1);
#line 1350
        add_poi = def_add;
        }
#line 1351
        goto switch_break___3;
        case_51___1: /* CIL Label */ 
        {
#line 1353
        add_poi = return_track_tmpname(track);
        }
#line 1354
        if (mode == 4) {
#line 1355
          def_add[0] = (char)0;
#line 1356
          add_poi = def_add;
        }
#line 1358
        goto switch_break___3;
        switch_default___2: /* CIL Label */ 
#line 1360
        def_add[0] = (char)0;
#line 1361
        add_poi = def_add;
#line 1362
        goto switch_break___3;
        switch_break___3: /* CIL Label */ ;
        }
#line 1364
        goto switch_break___0;
        case_5___0: /* CIL Label */ 
        {
#line 1368
        if ((int )*(def_str + j) == 49) {
#line 1368
          goto case_49___2;
        }
#line 1371
        if ((int )*(def_str + j) == 50) {
#line 1371
          goto case_50___1;
        }
#line 1374
        if ((int )*(def_str + j) == 51) {
#line 1374
          goto case_51___2;
        }
#line 1377
        if ((int )*(def_str + j) == 52) {
#line 1377
          goto case_52___1;
        }
#line 1381
        if ((int )*(def_str + j) == 53) {
#line 1381
          goto case_53___1;
        }
#line 1385
        if ((int )*(def_str + j) == 54) {
#line 1385
          goto case_54___1;
        }
#line 1390
        if ((int )*(def_str + j) == 55) {
#line 1390
          goto case_55___1;
        }
#line 1393
        if ((int )*(def_str + j) == 56) {
#line 1393
          goto case_56___1;
        }
#line 1400
        if ((int )*(def_str + j) == 97) {
#line 1400
          goto case_97___1;
        }
#line 1404
        if ((int )*(def_str + j) == 98) {
#line 1404
          goto case_98___1;
        }
#line 1408
        goto switch_default___3;
        case_49___2: /* CIL Label */ 
#line 1369
        add_poi = track->artist;
#line 1370
        goto switch_break___4;
        case_50___1: /* CIL Label */ 
#line 1372
        add_poi = track->title;
#line 1373
        goto switch_break___4;
        case_51___2: /* CIL Label */ 
#line 1375
        add_poi = track->album;
#line 1376
        goto switch_break___4;
        case_52___1: /* CIL Label */ 
        {
#line 1378
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%d",
                track->genre);
#line 1379
        add_poi = def_add;
        }
#line 1380
        goto switch_break___4;
        case_53___1: /* CIL Label */ 
        {
#line 1382
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%d",
                track->year);
#line 1383
        add_poi = def_add;
        }
#line 1384
        goto switch_break___4;
        case_54___1: /* CIL Label */ 
#line 1386
        if (extnl_MP3_name) {
          {
#line 1386
          free((void *)extnl_MP3_name);
          }
        }
        {
#line 1387
        extnl_MP3_name = create_sub_string(track, 7);
#line 1388
        add_poi = extnl_MP3_name;
        }
#line 1389
        goto switch_break___4;
        case_55___1: /* CIL Label */ 
        {
#line 1391
        add_poi = build_mp3_filenm(track);
        }
#line 1392
        goto switch_break___4;
        case_56___1: /* CIL Label */ 
#line 1394
        if (track->genre != 147) {
#line 1395
          add_poi = mp3_genre[track->genre];
        } else {
#line 1397
          add_poi = def_unknown_gen;
        }
#line 1399
        goto switch_break___4;
        case_97___1: /* CIL Label */ 
        {
#line 1401
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%d",
                (int )track->toc + 1);
#line 1402
        add_poi = def_add;
        }
#line 1403
        goto switch_break___4;
        case_98___1: /* CIL Label */ 
        {
#line 1405
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%02d",
                (int )track->toc + 1);
#line 1406
        add_poi = def_add;
        }
#line 1407
        goto switch_break___4;
        switch_default___3: /* CIL Label */ 
#line 1409
        def_add[0] = (char)0;
#line 1410
        add_poi = def_add;
#line 1411
        goto switch_break___4;
        switch_break___4: /* CIL Label */ ;
        }
#line 1413
        goto switch_break___0;
        case_6___0: /* CIL Label */ 
        {
#line 1417
        if ((int )*(def_str + j) == 49) {
#line 1417
          goto case_49___3;
        }
#line 1420
        if ((int )*(def_str + j) == 50) {
#line 1420
          goto case_50___2;
        }
#line 1423
        if ((int )*(def_str + j) == 51) {
#line 1423
          goto case_51___3;
        }
#line 1426
        if ((int )*(def_str + j) == 52) {
#line 1426
          goto case_52___2;
        }
#line 1433
        if ((int )*(def_str + j) == 53) {
#line 1433
          goto case_53___2;
        }
#line 1437
        if ((int )*(def_str + j) == 54) {
#line 1437
          goto case_54___2;
        }
#line 1441
        if ((int )*(def_str + j) == 55) {
#line 1441
          goto case_55___2;
        }
#line 1445
        if ((int )*(def_str + j) == 56) {
#line 1445
          goto case_56___2;
        }
#line 1449
        if ((int )*(def_str + j) == 37) {
#line 1449
          goto case_37;
        }
#line 1454
        goto switch_default___4;
        case_49___3: /* CIL Label */ 
#line 1418
        add_poi = track->artist;
#line 1419
        goto switch_break___5;
        case_50___2: /* CIL Label */ 
#line 1421
        add_poi = track->title;
#line 1422
        goto switch_break___5;
        case_51___3: /* CIL Label */ 
#line 1424
        add_poi = track->album;
#line 1425
        goto switch_break___5;
        case_52___2: /* CIL Label */ 
#line 1427
        if (track->genre != 147) {
#line 1428
          add_poi = mp3_genre[track->genre];
        } else {
#line 1430
          add_poi = def_unknown_gen;
        }
#line 1432
        goto switch_break___5;
        case_53___2: /* CIL Label */ 
        {
#line 1434
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%d",
                track->year);
#line 1435
        add_poi = def_add;
        }
#line 1436
        goto switch_break___5;
        case_54___2: /* CIL Label */ 
        {
#line 1438
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%d",
                (int )track->toc + 1);
#line 1439
        add_poi = def_add;
        }
#line 1440
        goto switch_break___5;
        case_55___2: /* CIL Label */ 
        {
#line 1442
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%02d",
                (int )track->toc + 1);
#line 1443
        add_poi = def_add;
        }
#line 1444
        goto switch_break___5;
        case_56___2: /* CIL Label */ 
        {
#line 1446
        snprintf((char */* __restrict  */)(def_add), (size_t )9, (char const   */* __restrict  */)"%08lX",
                 track->cddb_id);
#line 1447
        add_poi = def_add;
        }
#line 1448
        goto switch_break___5;
        case_37: /* CIL Label */ 
#line 1450
        def_add[0] = (char )'%';
#line 1451
        def_add[1] = (char)0;
#line 1452
        add_poi = def_add;
#line 1453
        goto switch_break___5;
        switch_default___4: /* CIL Label */ 
#line 1455
        def_add[0] = (char)0;
#line 1456
        add_poi = def_add;
#line 1457
        goto switch_break___5;
        switch_break___5: /* CIL Label */ ;
        }
#line 1459
        goto switch_break___0;
        case_7___0: /* CIL Label */ 
        {
#line 1463
        if ((int )*(def_str + j) == 37) {
#line 1463
          goto case_37___0;
        }
#line 1468
        if ((int )*(def_str + j) == 49) {
#line 1468
          goto case_49___4;
        }
#line 1471
        if ((int )*(def_str + j) == 50) {
#line 1471
          goto case_50___3;
        }
#line 1474
        if ((int )*(def_str + j) == 51) {
#line 1474
          goto case_51___4;
        }
#line 1477
        if ((int )*(def_str + j) == 52) {
#line 1477
          goto case_52___3;
        }
#line 1484
        if ((int )*(def_str + j) == 53) {
#line 1484
          goto case_53___3;
        }
#line 1488
        if ((int )*(def_str + j) == 54) {
#line 1488
          goto case_54___3;
        }
#line 1492
        if ((int )*(def_str + j) == 55) {
#line 1492
          goto case_55___3;
        }
#line 1496
        if ((int )*(def_str + j) == 56) {
#line 1496
          goto case_56___3;
        }
#line 1500
        if ((int )*(def_str + j) == 57) {
#line 1500
          goto case_57;
        }
#line 1504
        if ((int )*(def_str + j) == 97) {
#line 1504
          goto case_97___2;
        }
#line 1508
        if ((int )*(def_str + j) == 98) {
#line 1508
          goto case_98___2;
        }
#line 1512
        if ((int )*(def_str + j) == 99) {
#line 1512
          goto case_99___1;
        }
#line 1516
        if ((int )*(def_str + j) == 100) {
#line 1516
          goto case_100___1;
        }
#line 1521
        if ((int )*(def_str + j) == 101) {
#line 1521
          goto case_101;
        }
#line 1525
        if ((int )*(def_str + j) == 102) {
#line 1525
          goto case_102;
        }
#line 1529
        if ((int )*(def_str + j) == 103) {
#line 1529
          goto case_103;
        }
#line 1533
        if ((int )*(def_str + j) == 104) {
#line 1533
          goto case_104;
        }
#line 1537
        if ((int )*(def_str + j) == 105) {
#line 1537
          goto case_105;
        }
#line 1541
        if ((int )*(def_str + j) == 106) {
#line 1541
          goto case_106;
        }
#line 1545
        goto switch_default___5;
        case_37___0: /* CIL Label */ 
#line 1464
        def_add[0] = (char )'%';
#line 1465
        def_add[1] = (char)0;
#line 1466
        add_poi = def_add;
#line 1467
        goto switch_break___6;
        case_49___4: /* CIL Label */ 
#line 1469
        add_poi = track->artist;
#line 1470
        goto switch_break___6;
        case_50___3: /* CIL Label */ 
#line 1472
        add_poi = track->title;
#line 1473
        goto switch_break___6;
        case_51___4: /* CIL Label */ 
#line 1475
        add_poi = track->album;
#line 1476
        goto switch_break___6;
        case_52___3: /* CIL Label */ 
#line 1478
        if (track->genre != 147) {
#line 1479
          add_poi = mp3_genre[track->genre];
        } else {
#line 1481
          add_poi = def_unknown_gen;
        }
#line 1483
        goto switch_break___6;
        case_53___3: /* CIL Label */ 
        {
#line 1485
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%04d",
                track->year);
#line 1486
        add_poi = def_add;
        }
#line 1487
        goto switch_break___6;
        case_54___3: /* CIL Label */ 
        {
#line 1489
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%d",
                (int )track->toc + 1);
#line 1490
        add_poi = def_add;
        }
#line 1491
        goto switch_break___6;
        case_55___3: /* CIL Label */ 
        {
#line 1493
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%02d",
                (int )track->toc + 1);
#line 1494
        add_poi = def_add;
        }
#line 1495
        goto switch_break___6;
        case_56___3: /* CIL Label */ 
        {
#line 1497
        strcpy((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"0.29");
#line 1498
        add_poi = def_add;
        }
#line 1499
        goto switch_break___6;
        case_57: /* CIL Label */ 
        {
#line 1501
        snprintf((char */* __restrict  */)(def_add), (size_t )9, (char const   */* __restrict  */)"%08lX",
                 track->cddb_id);
#line 1502
        add_poi = def_add;
        }
#line 1503
        goto switch_break___6;
        case_97___2: /* CIL Label */ 
        {
#line 1505
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%02d",
                ltm->tm_mday);
#line 1506
        add_poi = def_add;
        }
#line 1507
        goto switch_break___6;
        case_98___2: /* CIL Label */ 
        {
#line 1509
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%02d",
                ltm->tm_mon + 1);
#line 1510
        add_poi = def_add;
        }
#line 1511
        goto switch_break___6;
        case_99___1: /* CIL Label */ 
        {
#line 1513
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%02d",
                ltm->tm_year % 100);
#line 1514
        add_poi = def_add;
        }
#line 1515
        goto switch_break___6;
        case_100___1: /* CIL Label */ 
#line 1517
        if (ltm->tm_year < 1900) {
          {
#line 1517
          sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%04d",
                  ltm->tm_year + 1900);
          }
        } else {
          {
#line 1518
          sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%04d",
                  ltm->tm_year);
          }
        }
#line 1519
        add_poi = def_add;
#line 1520
        goto switch_break___6;
        case_101: /* CIL Label */ 
        {
#line 1522
        strcpy((char */* __restrict  */)(def_add), (char const   */* __restrict  */)weekday[ltm->tm_wday]);
#line 1523
        add_poi = def_add;
        }
#line 1524
        goto switch_break___6;
        case_102: /* CIL Label */ 
        {
#line 1526
        strcpy((char */* __restrict  */)(def_add), (char const   */* __restrict  */)month[ltm->tm_mon]);
#line 1527
        add_poi = def_add;
        }
#line 1528
        goto switch_break___6;
        case_103: /* CIL Label */ 
        {
#line 1530
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%02d",
                ltm->tm_hour);
#line 1531
        add_poi = def_add;
        }
#line 1532
        goto switch_break___6;
        case_104: /* CIL Label */ 
        {
#line 1534
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%02d",
                ltm->tm_min);
#line 1535
        add_poi = def_add;
        }
#line 1536
        goto switch_break___6;
        case_105: /* CIL Label */ 
        {
#line 1538
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%02ld",
                track_len / 4500UL);
#line 1539
        add_poi = def_add;
        }
#line 1540
        goto switch_break___6;
        case_106: /* CIL Label */ 
        {
#line 1542
        sprintf((char */* __restrict  */)(def_add), (char const   */* __restrict  */)"%02ld",
                (track_len / 75UL) % 60UL);
#line 1543
        add_poi = def_add;
        }
#line 1544
        goto switch_break___6;
        switch_default___5: /* CIL Label */ 
#line 1546
        def_add[0] = (char)0;
#line 1547
        add_poi = def_add;
#line 1548
        goto switch_break___6;
        switch_break___6: /* CIL Label */ ;
        }
#line 1550
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
      {
#line 1555
      tmp___8 = strlen((char const   *)add_poi);
#line 1555
      k = (int )tmp___8;
      }
#line 1556
      if (k > 0) {
        {
#line 1557
        tmp___9 = strlen((char const   *)sub_str);
#line 1557
        tmp___10 = realloc((void *)extnl_PROC_mask, (size_t )(sizeof(char ) * (unsigned long )((tmp___9 + (size_t )k) + 1U)));
#line 1557
        extnl_PROC_mask = (char *)tmp___10;
        }
#line 1559
        if (! extnl_PROC_mask) {
          {
#line 1560
          wuuush(1);
          }
        }
        {
#line 1562
        tmp___11 = strlen((char const   *)sub_str);
#line 1562
        memset((void *)(extnl_PROC_mask + tmp___11), 0, (size_t )k);
#line 1564
        tmp___12 = strlen((char const   *)sub_str);
#line 1564
        tmp___13 = realloc((void *)sub_str, (size_t )(sizeof(char ) * (unsigned long )((tmp___12 + (size_t )k) + 1U)));
#line 1564
        sub_str = (char *)tmp___13;
        }
#line 1566
        if ((unsigned long )sub_str == (unsigned long )((void *)0)) {
          {
#line 1567
          perror("realloc");
#line 1568
          wuuush(1);
          }
        }
        {
#line 1570
        strcat((char */* __restrict  */)sub_str, (char const   */* __restrict  */)add_poi);
#line 1571
        tmp___14 = strlen((char const   *)sub_str);
#line 1571
        tmp___15 = strlen((char const   *)add_poi);
#line 1571
        k = (int )(tmp___14 - tmp___15);
        }
        {
#line 1571
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 1571
          tmp___16 = strlen((char const   *)sub_str);
          }
#line 1571
          if (! ((size_t )k < tmp___16)) {
#line 1571
            goto while_break___0;
          }
#line 1572
          if ((int )*(sub_str + k) == 34) {
#line 1572
            *(sub_str + k) = (char )'\'';
          }
#line 1571
          k ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else
#line 1575
    if ((int )*(def_str + j) == 37) {
#line 1575
      pat = (unsigned char)1;
    }
#line 1207
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1577
  k = j - i;
#line 1578
  if (k > 0) {
    {
#line 1579
    tmp___18 = strlen((char const   *)sub_str);
#line 1579
    tmp___19 = realloc((void *)extnl_PROC_mask, (size_t )(sizeof(char ) * (unsigned long )((tmp___18 + (size_t )k) + 1U)));
#line 1579
    extnl_PROC_mask = (char *)tmp___19;
    }
#line 1581
    if (! extnl_PROC_mask) {
      {
#line 1582
      wuuush(1);
      }
    }
    {
#line 1584
    tmp___20 = strlen((char const   *)sub_str);
#line 1584
    memcpy((void */* __restrict  */)(extnl_PROC_mask + tmp___20), (void const   */* __restrict  */)(def_str + i),
           (size_t )k);
#line 1586
    tmp___21 = strlen((char const   *)sub_str);
#line 1586
    tmp___22 = realloc((void *)sub_str, (size_t )(sizeof(char ) * (unsigned long )((tmp___21 + (size_t )k) + 1U)));
#line 1586
    sub_str = (char *)tmp___22;
    }
#line 1588
    if ((unsigned long )sub_str == (unsigned long )((void *)0)) {
      {
#line 1589
      perror("realloc");
#line 1590
      wuuush(1);
      }
    }
    {
#line 1592
    tmp___23 = strlen((char const   *)sub_str);
#line 1592
    *((sub_str + tmp___23) + k) = (char)0;
#line 1593
    tmp___24 = strlen((char const   *)sub_str);
#line 1593
    memcpy((void */* __restrict  */)(sub_str + tmp___24), (void const   */* __restrict  */)(def_str + i),
           (size_t )k);
    }
  }
#line 1596
  return (sub_str);
}
}
#line 1600 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
char **build_arg_tree(char const   *line ) 
{ 
  int i ;
  int j ;
  int k ;
  unsigned char quote ;
  unsigned char space ;
  char **ret ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 1607
  quote = (unsigned char)0;
#line 1608
  space = (unsigned char)1;
#line 1609
  j = 0;
#line 1611
  if (! line) {
#line 1611
    return ((char **)((void *)0));
  }
#line 1613
  i = 0;
  {
#line 1613
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1613
    tmp = strlen(line);
    }
#line 1613
    if (! ((size_t )i < tmp)) {
#line 1613
      goto while_break;
    }
#line 1614
    if ((int const   )*(line + i) == 34) {
#line 1615
      space = (unsigned char)0;
#line 1616
      if (! quote) {
#line 1616
        quote = (unsigned char)1;
      } else {
#line 1618
        quote = (unsigned char)0;
#line 1619
        j ++;
#line 1620
        space = (unsigned char)1;
      }
    } else
#line 1622
    if ((int const   )*(line + i) == 32) {
#line 1623
      if (! quote) {
#line 1623
        if (! space) {
#line 1624
          space = (unsigned char)1;
#line 1625
          j ++;
        }
      }
    } else {
#line 1628
      space = (unsigned char)0;
    }
#line 1613
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1632
  if (quote) {
#line 1632
    return ((char **)((void *)0));
  }
#line 1633
  if (space) {
#line 1633
    j ++;
  }
  {
#line 1635
  tmp___0 = malloc((size_t )(sizeof(char *) * (unsigned long )(j + 1)));
#line 1635
  ret = (char **)tmp___0;
  }
#line 1636
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 1637
    perror("malloc");
#line 1638
    wuuush(1);
    }
  }
#line 1641
  j = 0;
#line 1642
  k = 0;
#line 1643
  space = (unsigned char)1;
#line 1644
  quote = (unsigned char)0;
#line 1645
  i = 0;
  {
#line 1645
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1645
    tmp___3 = strlen(line);
    }
#line 1645
    if (! ((size_t )i < tmp___3)) {
#line 1645
      goto while_break___0;
    }
#line 1646
    if ((int const   )*(line + i) == 34) {
#line 1647
      if (! quote) {
#line 1648
        quote = (unsigned char)1;
#line 1649
        k = i + 1;
      } else {
        {
#line 1651
        quote = (unsigned char)0;
#line 1652
        tmp___1 = malloc((size_t )(sizeof(char ) * (unsigned long )((i - k) + 1)));
#line 1652
        *(ret + j) = (char *)tmp___1;
        }
#line 1653
        if ((unsigned long )*(ret + j) == (unsigned long )((void *)0)) {
          {
#line 1654
          perror("malloc");
#line 1655
          wuuush(1);
          }
        }
#line 1657
        *(*(ret + j) + (i - k)) = (char)0;
#line 1658
        if (i - k > 0) {
          {
#line 1659
          memcpy((void */* __restrict  */)*(ret + j), (void const   */* __restrict  */)(line + k),
                 (size_t )(i - k));
          }
        }
#line 1661
        j ++;
#line 1662
        space = (unsigned char)1;
      }
    } else
#line 1664
    if ((int const   )*(line + i) == 32) {
#line 1665
      if (! space) {
#line 1665
        if (! quote) {
          {
#line 1666
          tmp___2 = malloc((size_t )(sizeof(char ) * (unsigned long )((i - k) + 1)));
#line 1666
          *(ret + j) = (char *)tmp___2;
          }
#line 1667
          if ((unsigned long )*(ret + j) == (unsigned long )((void *)0)) {
            {
#line 1668
            perror("malloc");
#line 1669
            wuuush(1);
            }
          }
#line 1671
          *(*(ret + j) + (i - k)) = (char)0;
#line 1672
          if (i - k > 0) {
            {
#line 1673
            memcpy((void */* __restrict  */)*(ret + j), (void const   */* __restrict  */)(line + k),
                   (size_t )(i - k));
            }
          }
#line 1675
          j ++;
#line 1676
          space = (unsigned char)1;
        }
      }
    } else {
#line 1679
      if (space) {
#line 1679
        k = i;
      }
#line 1680
      space = (unsigned char)0;
    }
#line 1645
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1684
  if (! space) {
    {
#line 1685
    tmp___4 = malloc((size_t )(sizeof(char ) * (unsigned long )((i - k) + 1)));
#line 1685
    *(ret + j) = (char *)tmp___4;
    }
#line 1686
    if ((unsigned long )*(ret + j) == (unsigned long )((void *)0)) {
      {
#line 1687
      perror("malloc");
#line 1688
      wuuush(1);
      }
    }
#line 1690
    *(*(ret + j) + (i - k)) = (char)0;
#line 1691
    if (i - k > 0) {
      {
#line 1692
      memcpy((void */* __restrict  */)*(ret + j), (void const   */* __restrict  */)(line + k),
             (size_t )(i - k));
      }
    }
#line 1694
    j ++;
  }
#line 1696
  *(ret + j) = (char *)((void *)0);
#line 1697
  return (ret);
}
}
#line 1701 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
char *build_m3u_fname(song_typ *song ) 
{ 
  char *ret_str ;
  char *tmp_str ;
  char *filenm ;
  char *pattern ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 1708
  if (song->sampler) {
#line 1709
    pattern = def_m3u_patmix;
  } else {
#line 1711
    pattern = def_m3u_pattern;
  }
#line 1714
  if (! pattern) {
#line 1714
    return ((char *)((void *)0));
  }
  {
#line 1715
  tmp = strcmp((char const   *)pattern, "0");
  }
#line 1715
  if (tmp == 0) {
#line 1715
    return ((char *)((void *)0));
  }
#line 1716
  if (! def_m3u_dir) {
#line 1716
    return ((char *)((void *)0));
  }
  {
#line 1718
  tmp___0 = strcmp((char const   *)def_m3u_dir, "0");
  }
#line 1718
  if (tmp___0 == 0) {
#line 1718
    tmp_str = def_mp3_dir;
  } else {
#line 1719
    tmp_str = def_m3u_dir;
  }
#line 1721
  if (! tmp_str) {
#line 1721
    return ((char *)((void *)0));
  }
  {
#line 1723
  ret_str = create_sub_string(song, 6);
  }
#line 1724
  if (! ret_str) {
#line 1724
    return ((char *)((void *)0));
  }
  {
#line 1725
  filenm = filenm_short(ret_str, fn_mode, fn_toupper, extnl_PROC_mask);
#line 1726
  free((void *)ret_str);
#line 1728
  tmp___1 = strlen((char const   *)tmp_str);
#line 1728
  tmp___2 = strlen((char const   *)filenm);
#line 1728
  tmp___3 = malloc((size_t )(sizeof(char ) * (unsigned long )((tmp___1 + tmp___2) + 2U)));
#line 1728
  ret_str = (char *)tmp___3;
  }
#line 1729
  if (! ret_str) {
    {
#line 1730
    perror("malloc");
#line 1731
    wuuush(1);
    }
  }
  {
#line 1733
  sprintf((char */* __restrict  */)ret_str, (char const   */* __restrict  */)"%s/%s",
          tmp_str, filenm);
#line 1734
  free((void *)filenm);
#line 1736
  tmp___4 = kill_double_slashs(ret_str);
  }
#line 1736
  return (tmp___4);
}
}
#line 1740 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
int add_to_m3u(song_typ *song ) 
{ 
  char *filenm ;
  char *m3u_fm ;
  FILE *m3u_fd ;
  int i ;
  char *tmp_str ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 1748
  filenm = file_build_m3u_entry(song);
#line 1749
  m3u_fm = build_m3u_fname(song);
#line 1750
  create_sub_dirs(m3u_fm, (unsigned char)1);
  }
#line 1751
  if (! m3u_fm) {
#line 1751
    return (1);
  }
  {
#line 1752
  tmp___5 = access((char const   *)m3u_fm, 0);
  }
#line 1752
  if (tmp___5 == 0) {
    {
#line 1753
    tmp___0 = access((char const   *)m3u_fm, 2);
    }
#line 1753
    if (tmp___0 != 0) {
      {
#line 1754
      tmp = gettext("could not write to playlist!");
#line 1754
      popup_error_win(tmp);
#line 1755
      free((void *)m3u_fm);
      }
#line 1756
      return (1);
    }
    {
#line 1758
    tmp___1 = strlen((char const   *)filenm);
#line 1758
    i = (int )tmp___1;
#line 1759
    tmp___2 = malloc((size_t )(sizeof(char ) * (unsigned long )(i + 3)));
#line 1759
    tmp_str = (char *)tmp___2;
    }
#line 1760
    if (! tmp_str) {
      {
#line 1761
      perror("malloc");
#line 1762
      wuuush(1);
      }
    }
    {
#line 1764
    m3u_fd = fopen((char const   */* __restrict  */)m3u_fm, (char const   */* __restrict  */)"r");
    }
#line 1765
    if (m3u_fd) {
      {
#line 1766
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1767
        fgets((char */* __restrict  */)tmp_str, i + 1, (FILE */* __restrict  */)m3u_fd);
#line 1768
        tmp___3 = feof(m3u_fd);
        }
#line 1768
        if (tmp___3) {
#line 1768
          goto while_break;
        }
        {
#line 1769
        tmp___4 = strcmp((char const   *)tmp_str, (char const   *)filenm);
        }
#line 1769
        if (tmp___4 == 0) {
          {
#line 1770
          fclose(m3u_fd);
#line 1771
          free((void *)m3u_fm);
#line 1772
          free((void *)tmp_str);
          }
#line 1773
          return (1);
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1776
      fclose(m3u_fd);
#line 1777
      free((void *)tmp_str);
      }
    }
  }
  {
#line 1781
  m3u_fd = fopen((char const   */* __restrict  */)m3u_fm, (char const   */* __restrict  */)"a");
  }
#line 1782
  if (! m3u_fd) {
    {
#line 1783
    tmp___6 = gettext("couldn\'t write to playlistfile");
#line 1783
    popup_error_win(tmp___6);
#line 1784
    free((void *)m3u_fm);
    }
#line 1785
    return (1);
  }
  {
#line 1787
  fprintf((FILE */* __restrict  */)m3u_fd, (char const   */* __restrict  */)"%s\n",
          filenm);
#line 1788
  fclose(m3u_fd);
#line 1789
  free((void *)m3u_fm);
  }
#line 1791
  return (0);
}
}
#line 1795 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
char *kill_double_slashs(char *string ) 
{ 
  int i ;
  unsigned char was_slash ;
  size_t tmp ;

  {
#line 1800
  if (! string) {
#line 1800
    return ((char *)((void *)0));
  }
#line 1802
  was_slash = (unsigned char)0;
#line 1803
  i = 0;
  {
#line 1804
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1805
    if ((int )*(string + i) == 0) {
#line 1805
      goto while_break;
    }
#line 1806
    if ((int )*(string + i) == 47) {
#line 1807
      if (! was_slash) {
#line 1807
        was_slash = (unsigned char)1;
      } else {
        {
#line 1809
        tmp = strlen((char const   *)string);
#line 1809
        memmove((void *)(string + i), (void const   *)((string + i) + 1), tmp - (size_t )i);
#line 1810
        i --;
        }
      }
    } else {
#line 1812
      was_slash = (unsigned char)0;
    }
#line 1813
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1816
  return (string);
}
}
#line 1821 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
char *extract_dirname(char *file_str ) 
{ 
  int i ;
  char *ret_str ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp7 ;

  {
#line 1826
  if (! file_str) {
#line 1826
    return ((char *)((void *)0));
  } else {
    {
#line 1826
    tmp = strlen((char const   *)file_str);
    }
#line 1826
    if (tmp < 1U) {
#line 1826
      return ((char *)((void *)0));
    }
  }
  {
#line 1827
  tmp___0 = strlen((char const   *)file_str);
#line 1827
  i = (int )(tmp___0 - 1U);
  }
  {
#line 1827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1827
    if (! (i >= 0)) {
#line 1827
      goto while_break;
    }
#line 1827
    if ((int )*(file_str + i) == 47) {
#line 1827
      goto while_break;
    }
#line 1827
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1830
  if (i < 1) {
#line 1830
    return ((char *)((void *)0));
  }
  {
#line 1832
  i += 2;
#line 1833
  tmp___1 = malloc((size_t )(sizeof(char ) * (unsigned long )i));
#line 1833
  ret_str = (char *)tmp___1;
  }
#line 1834
  if (! ret_str) {
    {
#line 1835
    perror("malloc");
#line 1836
    wuuush(1);
    }
  }
  {
#line 1839
  memcpy((void */* __restrict  */)ret_str, (void const   */* __restrict  */)file_str,
         (size_t )(i - 1));
#line 1840
  *(ret_str + (i - 1)) = (char)0;
  }
#line 1841
  return (ret_str);
}
}
#line 1845 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
int create_sub_dirs(char *filename , unsigned char mode ) 
{ 
  char *dir_str ;
  char *error_str ;
  int i ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 1850
  if (mode) {
    {
#line 1851
    dir_str = extract_dirname(filename);
    }
  } else {
#line 1853
    if (! filename) {
#line 1853
      return (0);
    }
    {
#line 1854
    tmp = strlen((char const   *)filename);
#line 1854
    tmp___0 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp + 2U)));
#line 1854
    dir_str = (char *)tmp___0;
    }
#line 1855
    if (! dir_str) {
      {
#line 1856
      perror("malloc");
#line 1857
      wuuush(1);
      }
    }
    {
#line 1859
    strcpy((char */* __restrict  */)dir_str, (char const   */* __restrict  */)filename);
#line 1860
    tmp___1 = strlen((char const   *)dir_str);
    }
#line 1860
    if ((int )*((dir_str + tmp___1) - 1) != 47) {
      {
#line 1860
      strcat((char */* __restrict  */)dir_str, (char const   */* __restrict  */)"/");
      }
    }
  }
#line 1862
  if (! dir_str) {
#line 1862
    return (0);
  }
#line 1864
  i = 1;
  {
#line 1865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1866
    if ((int )*(dir_str + i) == 0) {
#line 1866
      goto while_break;
    }
#line 1867
    if ((int )*(dir_str + i) == 47) {
      {
#line 1868
      *(dir_str + i) = (char)0;
#line 1869
      tmp___6 = access((char const   *)dir_str, 0);
      }
#line 1869
      if (tmp___6 != 0) {
        {
#line 1871
        tmp___5 = mkdir((char const   *)dir_str, (__mode_t )511);
        }
#line 1871
        if (tmp___5) {
          {
#line 1873
          tmp___2 = strlen((char const   *)dir_str);
#line 1873
          tmp___3 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___2 + 80U)));
#line 1873
          error_str = (char *)tmp___3;
          }
#line 1874
          if (! error_str) {
            {
#line 1875
            perror("malloc");
#line 1876
            wuuush(1);
            }
          }
          {
#line 1878
          tmp___4 = gettext("creating of directory \"%s\" failed");
#line 1878
          sprintf((char */* __restrict  */)error_str, (char const   */* __restrict  */)tmp___4,
                  dir_str);
#line 1879
          popup_error_win(error_str);
#line 1880
          free((void *)error_str);
#line 1881
          free((void *)dir_str);
          }
#line 1882
          return (1);
        }
      }
#line 1885
      *(dir_str + i) = (char )'/';
    }
#line 1887
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1890
  free((void *)dir_str);
  }
#line 1891
  return (0);
}
}
#line 1904 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
char *return_track_tmpname(song_typ *track ) 
{ 
  int i ;
  char track_nr[12] ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1909
  if (track->tmp_wav_file) {
#line 1909
    return (track->tmp_wav_file);
  }
#line 1911
  if (! def_tmp_file) {
#line 1911
    return ((char *)((void *)0));
  }
#line 1913
  if (extnl_TMP_name) {
    {
#line 1913
    free((void *)extnl_TMP_name);
    }
  }
  {
#line 1914
  tmp = strlen((char const   *)def_tmp_file);
#line 1914
  tmp___0 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp + 12U)));
#line 1914
  extnl_TMP_name = (char *)tmp___0;
  }
#line 1915
  if (! extnl_TMP_name) {
    {
#line 1916
    perror("malloc");
#line 1917
    wuuush(1);
    }
  }
  {
#line 1920
  snprintf((char */* __restrict  */)(track_nr), (size_t )12, (char const   */* __restrict  */)"%08lx_%02d",
           track->cddb_id, (int )track->toc % 100);
#line 1921
  tmp___1 = strlen((char const   *)def_tmp_file);
#line 1921
  i = (int )tmp___1;
  }
  {
#line 1921
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1921
    if (! (i >= 0)) {
#line 1921
      goto while_break;
    }
#line 1921
    if ((int )*(def_tmp_file + i) == 46) {
#line 1921
      goto while_break;
    }
#line 1921
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1922
  if (i > 0) {
    {
#line 1922
    tmp___2 = strchr((char const   *)(def_tmp_file + i), '/');
    }
#line 1922
    if (tmp___2) {
#line 1922
      i = 0;
    }
  }
#line 1923
  if (i <= 0) {
    {
#line 1924
    strcpy((char */* __restrict  */)extnl_TMP_name, (char const   */* __restrict  */)def_tmp_file);
#line 1925
    strcat((char */* __restrict  */)extnl_TMP_name, (char const   */* __restrict  */)(track_nr));
    }
  } else {
    {
#line 1927
    memcpy((void */* __restrict  */)extnl_TMP_name, (void const   */* __restrict  */)def_tmp_file,
           (size_t )i);
#line 1928
    memcpy((void */* __restrict  */)(extnl_TMP_name + i), (void const   */* __restrict  */)(track_nr),
           (size_t )12);
#line 1929
    strcat((char */* __restrict  */)extnl_TMP_name, (char const   */* __restrict  */)(def_tmp_file + i));
    }
  }
#line 1932
  return (extnl_TMP_name);
}
}
#line 1936 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
char *file_glob_out_name(char *name ) 
{ 
  char *home ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 1940
  if (! name) {
#line 1940
    return ((char *)((void *)0));
  }
  {
#line 1942
  home = getenv("HOME");
  }
#line 1943
  if (! home) {
#line 1943
    return (name);
  }
  {
#line 1945
  tmp___2 = strlen((char const   *)home);
  }
#line 1945
  if ((int )*((home + tmp___2) - 1) != 47) {
    {
#line 1946
    tmp = strlen((char const   *)home);
#line 1946
    tmp___0 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp + 2U)));
#line 1946
    home = (char *)tmp___0;
    }
#line 1947
    if (! home) {
      {
#line 1948
      wuuush(1);
      }
    }
    {
#line 1950
    tmp___1 = getenv("HOME");
#line 1950
    sprintf((char */* __restrict  */)home, (char const   */* __restrict  */)"%s/",
            tmp___1);
    }
  } else {
    {
#line 1952
    home = copy_char_str(home);
    }
  }
  {
#line 1955
  tmp___9 = strlen((char const   *)home);
#line 1955
  tmp___10 = strncmp((char const   *)name, (char const   *)home, tmp___9);
  }
#line 1955
  if (! tmp___10) {
    {
#line 1956
    tmp___5 = strlen((char const   *)home);
    }
#line 1956
    if (tmp___5 < 2U) {
      {
#line 1957
      tmp___3 = strlen((char const   *)name);
#line 1957
      tmp___4 = realloc((void *)name, (size_t )(sizeof(char ) * (unsigned long )(tmp___3 + 3U)));
#line 1957
      name = (char *)tmp___4;
      }
#line 1958
      if (! name) {
        {
#line 1959
        wuuush(1);
        }
      }
    }
    {
#line 1962
    tmp___6 = strlen((char const   *)home);
#line 1962
    tmp___7 = strlen((char const   *)(name + tmp___6));
#line 1962
    tmp___8 = strlen((char const   *)home);
#line 1962
    memmove((void *)(name + 2), (void const   *)(name + tmp___8), tmp___7 + 1U);
#line 1963
    *name = (char )'~';
#line 1964
    *(name + 1) = (char )'/';
    }
  }
  {
#line 1967
  free((void *)home);
#line 1969
  tmp___11 = kill_double_slashs(name);
  }
#line 1969
  return (tmp___11);
}
}
#line 1973 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
char *file_glob_in_name(char *name ) 
{ 
  char *home ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 1977
  if (! name) {
#line 1977
    return ((char *)((void *)0));
  }
  {
#line 1979
  home = (char *)((void *)0);
#line 1981
  tmp___6 = strncmp((char const   *)name, "~/", (size_t )2);
  }
#line 1981
  if (! tmp___6) {
#line 1982
    if (! home) {
      {
#line 1983
      home = getenv("HOME");
      }
#line 1984
      if (! home) {
#line 1985
        return (name);
      }
    }
    {
#line 1989
    tmp = strlen((char const   *)name);
#line 1989
    tmp___0 = strlen((char const   *)home);
#line 1989
    tmp___1 = realloc((void *)name, (size_t )(sizeof(char ) * (unsigned long )((tmp + tmp___0) + 1U)));
#line 1989
    name = (char *)tmp___1;
    }
#line 1990
    if (! name) {
      {
#line 1991
      wuuush(1);
      }
    }
    {
#line 1994
    tmp___2 = strlen((char const   *)name);
#line 1994
    tmp___3 = strlen((char const   *)home);
#line 1994
    memmove((void *)((name + tmp___3) + 1), (void const   *)(name + 1), tmp___2);
#line 1995
    tmp___4 = strlen((char const   *)home);
#line 1995
    memmove((void *)name, (void const   *)home, tmp___4);
#line 1996
    tmp___5 = strlen((char const   *)home);
#line 1996
    *(name + tmp___5) = (char )'/';
    }
  }
  {
#line 1999
  tmp___7 = kill_double_slashs(name);
  }
#line 1999
  return (tmp___7);
}
}
#line 2023 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
char *file_build_relative_name(char *src_dir , char *dest_file , unsigned char should_dir ) 
{ 
  int beginning ;
  int pos ;
  char *match ;
  char *rel_file ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 2029
  if (! src_dir) {
#line 2029
    return ((char *)((void *)0));
  } else
#line 2029
  if (! *src_dir) {
#line 2029
    return ((char *)((void *)0));
  } else
#line 2029
  if (! dest_file) {
#line 2029
    return ((char *)((void *)0));
  } else
#line 2029
  if (! *src_dir) {
#line 2029
    return ((char *)((void *)0));
  }
#line 2031
  beginning = 1;
  {
#line 2032
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2032
    match = strchr((char const   *)(src_dir + beginning), '/');
    }
#line 2032
    if (! match) {
#line 2032
      goto while_break;
    }
    {
#line 2033
    pos = (int )(match - src_dir);
#line 2034
    tmp = strncmp((char const   *)src_dir, (char const   *)dest_file, (size_t )(pos + 1));
    }
#line 2034
    if (tmp) {
#line 2034
      goto while_break;
    }
#line 2035
    beginning = pos + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 2038
  pos = 0;
#line 2039
  match = src_dir + beginning;
  {
#line 2041
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 2041
    match = strchr((char const   *)match, '/');
    }
#line 2041
    if (! match) {
#line 2041
      goto while_break___0;
    }
#line 2042
    match ++;
#line 2043
    pos ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2046
  if (should_dir) {
    {
#line 2046
    tmp___0 = strlen((char const   *)src_dir);
    }
#line 2046
    if ((int )*((src_dir + tmp___0) - 1) != 47) {
#line 2047
      pos ++;
    }
  }
  {
#line 2050
  dest_file += beginning;
#line 2051
  tmp___1 = strlen((char const   *)dest_file);
#line 2051
  tmp___2 = malloc((size_t )(sizeof(char ) * (unsigned long )((tmp___1 + (size_t )(pos * 3)) + 3U)));
#line 2051
  rel_file = (char *)tmp___2;
  }
#line 2052
  if (! rel_file) {
    {
#line 2053
    wuuush(1);
    }
  }
#line 2056
  beginning = 0;
#line 2057
  if (! pos) {
#line 2058
    *rel_file = (char )'.';
#line 2059
    *(rel_file + 1) = (char )'/';
#line 2060
    beginning = 2;
  } else {
    {
#line 2062
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2062
      if (! (pos > 0)) {
#line 2062
        goto while_break___1;
      }
#line 2063
      *(rel_file + beginning) = (char )'.';
#line 2064
      *((rel_file + beginning) + 1) = (char )'.';
#line 2065
      *((rel_file + beginning) + 2) = (char )'/';
#line 2066
      beginning += 3;
#line 2062
      pos --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 2070
  *(rel_file + beginning) = (char)0;
#line 2071
  strcat((char */* __restrict  */)rel_file, (char const   */* __restrict  */)dest_file);
  }
#line 2073
  return (rel_file);
}
}
#line 2077 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
char *file_build_m3u_entry(song_typ *track ) 
{ 
  char *full_m3u ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp7 ;

  {
#line 2081
  if (extnl_M3U_name) {
    {
#line 2081
    free((void *)extnl_M3U_name);
    }
  }
#line 2082
  extnl_M3U_name = (char *)((void *)0);
  {
#line 2085
  if (def_m3u_rel_name == 0) {
#line 2085
    goto case_0;
  }
#line 2088
  if (def_m3u_rel_name == 1) {
#line 2088
    goto case_1;
  }
#line 2098
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 2086
  tmp = build_mp3_filenm(track);
  }
#line 2086
  return (tmp);
#line 2087
  goto switch_break;
  case_1: /* CIL Label */ 
#line 2089
  if (! def_m3u_dir) {
#line 2089
    return ((char *)((void *)0));
  }
  {
#line 2090
  tmp___0 = strcmp((char const   *)def_m3u_dir, "0");
  }
#line 2090
  if (tmp___0 == 0) {
    {
#line 2091
    full_m3u = kill_double_slashs(def_mp3_dir);
    }
  } else {
    {
#line 2093
    full_m3u = kill_double_slashs(def_m3u_dir);
    }
  }
  {
#line 2095
  tmp___1 = build_mp3_filenm(track);
#line 2095
  extnl_M3U_name = file_build_relative_name(full_m3u, tmp___1, (unsigned char)1);
  }
#line 2096
  return (extnl_M3U_name);
#line 2097
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2099
  full_m3u = build_m3u_fname(track);
#line 2100
  tmp___2 = build_mp3_filenm(track);
#line 2100
  extnl_M3U_name = file_build_relative_name(full_m3u, tmp___2, (unsigned char)0);
  }
#line 2101
  if (full_m3u) {
    {
#line 2101
    free((void *)full_m3u);
    }
  }
#line 2102
  return (extnl_M3U_name);
  switch_break: /* CIL Label */ ;
  }
#line 2104
  return ((char *)0);
}
}
#line 2107 "/home/wslee/benchmarks/sound/mp3c-0.29/src/file.c"
unsigned char file_is_directory(char *path ) 
{ 
  struct stat st ;
  char *error_string ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp8 ;

  {
#line 2112
  if (! path) {
#line 2112
    return ((unsigned char)0);
  }
  {
#line 2114
  tmp___2 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& st));
  }
#line 2114
  if (tmp___2 != -1) {
#line 2115
    if ((st.st_mode & 61440U) == 16384U) {
#line 2115
      return ((unsigned char)1);
    }
    {
#line 2116
    tmp = strlen((char const   *)path);
#line 2116
    tmp___0 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp + 50U)));
#line 2116
    error_string = (char *)tmp___0;
    }
#line 2117
    if (! error_string) {
      {
#line 2118
      wuuush(1);
      }
    }
    {
#line 2120
    tmp___1 = gettext("\"%s\" is no directory");
#line 2120
    sprintf((char */* __restrict  */)error_string, (char const   */* __restrict  */)tmp___1,
            path);
#line 2121
    popup_error_win(error_string);
#line 2122
    free((void *)error_string);
    }
  }
#line 2125
  return ((unsigned char)0);
}
}
#line 777 "/usr/include/ncurses.h"
extern chtype winch(WINDOW * ) ;
#line 36 "/home/wslee/benchmarks/sound/mp3c-0.29/src/effect.c"
WINDOW *eff_win  =    (WINDOW *)((void *)0);
#line 37 "/home/wslee/benchmarks/sound/mp3c-0.29/src/effect.c"
char eff_course  =    (char)0;
#line 37 "/home/wslee/benchmarks/sound/mp3c-0.29/src/effect.c"
char eff_color  =    (char)0;
#line 38 "/home/wslee/benchmarks/sound/mp3c-0.29/src/effect.c"
signed char eff_pos  =    (signed char)0;
#line 40 "/home/wslee/benchmarks/sound/mp3c-0.29/src/effect.c"
short const   eff_color_tab[3]  = {      (short const   )1,      (short const   )2,      (short const   )6};
#line 48 "/home/wslee/benchmarks/sound/mp3c-0.29/src/effect.c"
void win_effect(WINDOW *win , unsigned char e_refresh , unsigned char save_coor ) 
{ 
  chtype old_ch ;
  int oldx ;
  int oldy ;
  int maxy ;
  int maxx ;
  int i ;
  chtype tmp ;
  chtype tmp___0 ;
  chtype tmp___1 ;
  chtype tmp___2 ;
  chtype tmp___3 ;
  chtype tmp___4 ;
  chtype tmp___5 ;
  chtype tmp___6 ;

  {
#line 51
  oldx = 0;
#line 51
  oldy = 0;
#line 56
  if ((unsigned long )eff_win != (unsigned long )win) {
#line 57
    eff_win = win;
#line 58
    eff_course = (char )(1 - (int )eff_course);
  }
#line 61
  if (eff_win) {
#line 61
    maxy = (int )eff_win->_maxy + 1;
  } else {
#line 61
    maxy = -1;
  }
#line 61
  if (eff_win) {
#line 61
    maxx = (int )eff_win->_maxx + 1;
  } else {
#line 61
    maxx = -1;
  }
#line 62
  old_ch = eff_win->_bkgd;
#line 65
  if (save_coor) {
#line 66
    if (eff_win) {
#line 66
      oldy = (int )eff_win->_cury;
    } else {
#line 66
      oldy = -1;
    }
#line 66
    if (eff_win) {
#line 66
      oldx = (int )eff_win->_curx;
    } else {
#line 66
      oldx = -1;
    }
  }
  {
#line 69
  wbkgdset(eff_win, (chtype )((int const   )eff_color_tab[(int )eff_color] << 8));
  }
  {
#line 71
  if ((int )eff_pos == 0) {
#line 71
    goto case_0;
  }
#line 75
  if ((int )eff_pos == 1) {
#line 75
    goto case_1;
  }
#line 79
  if ((int )eff_pos == 2) {
#line 79
    goto case_2;
  }
#line 85
  if ((int )eff_pos == 3) {
#line 85
    goto case_3;
  }
#line 91
  if ((int )eff_pos == 4) {
#line 91
    goto case_4;
  }
#line 95
  if ((int )eff_pos == 5) {
#line 95
    goto case_5;
  }
#line 99
  if ((int )eff_pos == 6) {
#line 99
    goto case_6;
  }
#line 105
  if ((int )eff_pos == 7) {
#line 105
    goto case_7;
  }
#line 70
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 72
  wmove(eff_win, 0, 0);
#line 73
  i = 0;
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! (i < maxx >> 1)) {
#line 73
      goto while_break;
    }
    {
#line 73
    tmp = winch(win);
#line 73
    waddch(eff_win, (chtype const   )(tmp & ((((1UL << 8) - 1UL) << 8) ^ 16777215UL)));
#line 73
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 76
  wmove(eff_win, 0, maxx >> 1);
#line 77
  i = maxx >> 1;
  }
  {
#line 77
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 77
    if (! (i < maxx)) {
#line 77
      goto while_break___0;
    }
    {
#line 77
    tmp___0 = winch(win);
#line 77
    waddch(eff_win, (chtype const   )(tmp___0 & ((((1UL << 8) - 1UL) << 8) ^ 16777215UL)));
#line 77
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 78
  goto switch_break;
  case_2: /* CIL Label */ 
#line 80
  i = 0;
  {
#line 80
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 80
    if (! (i < maxy >> 1)) {
#line 80
      goto while_break___1;
    }
    {
#line 81
    wmove(eff_win, i, maxx - 1);
#line 82
    tmp___1 = winch(win);
#line 82
    waddch(eff_win, (chtype const   )(tmp___1 & ((((1UL << 8) - 1UL) << 8) ^ 16777215UL)));
#line 80
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 84
  goto switch_break;
  case_3: /* CIL Label */ 
#line 86
  i = maxy >> 1;
  {
#line 86
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 86
    if (! (i < maxy)) {
#line 86
      goto while_break___2;
    }
    {
#line 87
    wmove(eff_win, i, maxx - 1);
#line 88
    tmp___2 = winch(win);
#line 88
    waddch(eff_win, (chtype const   )(tmp___2 & ((((1UL << 8) - 1UL) << 8) ^ 16777215UL)));
#line 86
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 90
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 92
  wmove(eff_win, maxy - 1, maxx >> 1);
#line 93
  i = maxx >> 1;
  }
  {
#line 93
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 93
    if (! (i < maxx)) {
#line 93
      goto while_break___3;
    }
    {
#line 93
    tmp___3 = winch(win);
#line 93
    waddch(eff_win, (chtype const   )(tmp___3 & ((((1UL << 8) - 1UL) << 8) ^ 16777215UL)));
#line 93
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 94
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 96
  wmove(eff_win, maxy - 1, 0);
#line 97
  i = 0;
  }
  {
#line 97
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 97
    if (! (i < maxx >> 1)) {
#line 97
      goto while_break___4;
    }
    {
#line 97
    tmp___4 = winch(win);
#line 97
    waddch(eff_win, (chtype const   )(tmp___4 & ((((1UL << 8) - 1UL) << 8) ^ 16777215UL)));
#line 97
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 98
  goto switch_break;
  case_6: /* CIL Label */ 
#line 100
  i = maxy >> 1;
  {
#line 100
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 100
    if (! (i < maxy - 1)) {
#line 100
      goto while_break___5;
    }
    {
#line 101
    wmove(eff_win, i, 0);
#line 102
    tmp___5 = winch(win);
#line 102
    waddch(eff_win, (chtype const   )(tmp___5 & ((((1UL << 8) - 1UL) << 8) ^ 16777215UL)));
#line 100
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 104
  goto switch_break;
  case_7: /* CIL Label */ 
#line 106
  i = 0;
  {
#line 106
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 106
    if (! (i < maxy >> 1)) {
#line 106
      goto while_break___6;
    }
    {
#line 107
    wmove(eff_win, i, 0);
#line 108
    tmp___6 = winch(win);
#line 108
    waddch(eff_win, (chtype const   )(tmp___6 & ((((1UL << 8) - 1UL) << 8) ^ 16777215UL)));
#line 106
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 110
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 112
  wbkgdset(eff_win, old_ch);
  }
#line 114
  if (eff_course) {
#line 114
    eff_pos = (signed char )((int )eff_pos + 1);
  } else {
#line 115
    eff_pos = (signed char )((int )eff_pos - 1);
  }
#line 117
  if ((int )eff_pos == -1) {
#line 117
    goto _L;
  } else
#line 117
  if ((int )eff_pos == 8) {
    _L: /* CIL Label */ 
#line 118
    eff_color = (char )(((int )eff_color + 1) % 3);
#line 119
    if ((int )eff_pos == -1) {
#line 119
      eff_pos = (signed char)7;
    } else {
#line 120
      eff_pos = (signed char)0;
    }
  }
#line 123
  if (save_coor) {
    {
#line 124
    wmove(eff_win, oldy, oldx);
    }
  }
#line 127
  if (e_refresh) {
    {
#line 127
    wrefresh(eff_win);
    }
  }
#line 128
  return;
}
}
#line 865 "/usr/include/unistd.h"
extern char *getlogin(void) ;
#line 97 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
signed char config_fancy_colors  =    (signed char)0;
#line 98 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
unsigned char fn_toupper  =    (unsigned char)1;
#line 99 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
int fn_mode  =    1;
#line 100 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char replace_space_ch  =    (char )'_';
#line 101 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *fn_pattern  =    (char *)((void *)0);
#line 102 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *fn_pattern_mix  =    (char *)((void *)0);
#line 103 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *def_cddb_server  =    (char *)((void *)0);
#line 104 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *def_cddb_bank  =    (char *)((void *)0);
#line 105 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *def_cdrom_dev  =    (char *)((void *)0);
#line 106 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *def_tmp_file  =    (char *)((void *)0);
#line 107 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *def_mp3_dir  =    (char *)((void *)0);
#line 108 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *def_mp3_info  =    (char *)((void *)0);
#line 109 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *def_cd_rip_nf  =    (char *)((void *)0);
#line 110 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *def_cd_rip_of  =    (char *)((void *)0);
#line 111 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *def_mp3_enc_nf  =    (char *)((void *)0);
#line 112 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *def_mp3_enc_of  =    (char *)((void *)0);
#line 113 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *def_m3u_pattern  =    (char *)((void *)0);
#line 114 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *def_m3u_patmix  =    (char *)((void *)0);
#line 115 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *def_m3u_dir  =    (char *)((void *)0);
#line 116 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *def_comment  =    (char *)((void *)0);
#line 117 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *def_ill_chars  =    (char *)((void *)0);
#line 118 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *def_exp_file  =    (char *)((void *)0);
#line 119 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *def_version_str  =    (char *)((void *)0);
#line 120 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *def_cddb_email  =    (char *)((void *)0);
#line 121 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *def_smtp_server  =    (char *)((void *)0);
#line 122 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *def_my_email  =    (char *)((void *)0);
#line 123 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *cddb_genres  =    (char *)((void *)0);
#line 124 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char *def_unknown_gen  =    (char *)((void *)0);
#line 125 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
int auto_save  =    0;
#line 126 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
int of_fifo_buf  =    512;
#line 127 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
int mp3_frame_mult  =    214;
#line 128 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
unsigned char def_on_fly  =    (unsigned char)0;
#line 129 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
unsigned char eased_char_hand  =    (unsigned char)0;
#line 130 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
char replace_slash_ch  =    (char )'-';
#line 131 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
unsigned char rip_enc_ordered  =    (unsigned char)0;
#line 132 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
int del_tmp_on_exit  =    1;
#line 133 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
unsigned char clear_del_on_exp  =    (unsigned char)1;
#line 134 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
unsigned char config_curs_dir  =    (unsigned char)1;
#line 135 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
int def_m3u_rel_name  =    2;
#line 136 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
unsigned char config_cddb_enbl  =    (unsigned char)1;
#line 137 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
unsigned char config_req_hidden  =    (unsigned char)0;
#line 138 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
unsigned char config_para_mp3c  =    (unsigned char)1;
#line 139 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
int config_case_chg  =    0;
#line 140 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
unsigned char config_open_tray  =    (unsigned char)1;
#line 141 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
unsigned char config_ill_remove  =    (unsigned char)1;
#line 142 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
unsigned char config_pat_prot  =    (unsigned char)1;
#line 145 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
void init_config(void) 
{ 
  char *pat ;
  char *pat2 ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 149
  if (fn_pattern) {
    {
#line 149
    free((void *)fn_pattern);
    }
  }
#line 150
  if (fn_pattern_mix) {
    {
#line 150
    free((void *)fn_pattern_mix);
    }
  }
#line 151
  if (def_cddb_server) {
    {
#line 151
    free((void *)def_cddb_server);
    }
  }
#line 152
  if (def_cddb_bank) {
    {
#line 152
    free((void *)def_cddb_bank);
    }
  }
#line 153
  if (def_cdrom_dev) {
    {
#line 153
    free((void *)def_cdrom_dev);
    }
  }
#line 154
  if (def_tmp_file) {
    {
#line 154
    free((void *)def_tmp_file);
    }
  }
#line 155
  if (def_mp3_dir) {
    {
#line 155
    free((void *)def_mp3_dir);
    }
  }
#line 156
  if (def_mp3_info) {
    {
#line 156
    free((void *)def_mp3_info);
    }
  }
#line 157
  if (def_cd_rip_nf) {
    {
#line 157
    free((void *)def_cd_rip_nf);
    }
  }
#line 158
  if (def_cd_rip_of) {
    {
#line 158
    free((void *)def_cd_rip_of);
    }
  }
#line 159
  if (def_mp3_enc_nf) {
    {
#line 159
    free((void *)def_mp3_enc_nf);
    }
  }
#line 160
  if (def_mp3_enc_of) {
    {
#line 160
    free((void *)def_mp3_enc_of);
    }
  }
#line 161
  if (def_m3u_pattern) {
    {
#line 161
    free((void *)def_m3u_pattern);
    }
  }
#line 162
  if (def_m3u_patmix) {
    {
#line 162
    free((void *)def_m3u_patmix);
    }
  }
#line 163
  if (def_m3u_dir) {
    {
#line 163
    free((void *)def_m3u_dir);
    }
  }
#line 164
  if (def_comment) {
    {
#line 164
    free((void *)def_comment);
    }
  }
#line 165
  if (def_ill_chars) {
    {
#line 165
    free((void *)def_ill_chars);
    }
  }
#line 166
  if (def_exp_file) {
    {
#line 166
    free((void *)def_exp_file);
    }
  }
#line 167
  if (def_version_str) {
    {
#line 167
    free((void *)def_version_str);
    }
  }
#line 168
  if (def_cddb_email) {
    {
#line 168
    free((void *)def_cddb_email);
    }
  }
#line 169
  if (def_smtp_server) {
    {
#line 169
    free((void *)def_smtp_server);
    }
  }
#line 170
  if (def_my_email) {
    {
#line 170
    free((void *)def_my_email);
    }
  }
#line 171
  if (def_unknown_gen) {
    {
#line 171
    free((void *)def_unknown_gen);
    }
  }
  {
#line 173
  auto_save = 0;
#line 174
  of_fifo_buf = 512;
#line 175
  config_fancy_colors = (signed char)0;
#line 176
  fn_toupper = (unsigned char)1;
#line 177
  fn_mode = 1;
#line 178
  replace_space_ch = (char )'_';
#line 179
  mp3_frame_mult = 214;
#line 180
  def_on_fly = (unsigned char)0;
#line 181
  eased_char_hand = (unsigned char)0;
#line 182
  replace_slash_ch = (char )'-';
#line 183
  rip_enc_ordered = (unsigned char)0;
#line 184
  del_tmp_on_exit = 1;
#line 185
  clear_del_on_exp = (unsigned char)1;
#line 186
  config_curs_dir = (unsigned char)1;
#line 187
  def_m3u_rel_name = 2;
#line 188
  config_cddb_enbl = (unsigned char)1;
#line 189
  config_para_mp3c = (unsigned char)1;
#line 190
  config_case_chg = 0;
#line 191
  config_open_tray = (unsigned char)1;
#line 192
  config_ill_remove = (unsigned char)1;
#line 193
  config_pat_prot = (unsigned char)1;
#line 195
  fn_pattern = copy_char_str((char *)"%7-%8.mp3");
#line 196
  fn_pattern_mix = copy_char_str((char *)"%3/%1-%2.mp3");
#line 197
  def_cddb_server = copy_char_str((char *)"freedb.freedb.org:8880");
#line 198
  tmp = copy_char_str((char *)"~/.cddb");
#line 198
  def_cddb_bank = file_glob_in_name(tmp);
  }
#line 200
  if (external_cdrom_dev) {
    {
#line 201
    def_cdrom_dev = copy_char_str(external_cdrom_dev);
    }
  } else {
    {
#line 203
    def_cdrom_dev = copy_char_str((char *)"/dev/cdrom");
    }
  }
  {
#line 206
  def_tmp_file = copy_char_str((char *)"/tmp/WSPse-MP3Creat.wav");
#line 207
  def_mp3_dir = copy_char_str((char *)"./");
#line 208
  def_mp3_info = copy_char_str((char *)"0");
#line 209
  def_cd_rip_nf = copy_char_str((char *)"cdda2wav -D \"%1\" -t %2 -O wav -paranoia \"%3\"");
#line 210
  def_cd_rip_of = copy_char_str((char *)"cdda2wav -D \"%1\" -t %2 -O wav -paranoia -");
#line 211
  def_mp3_enc_nf = copy_char_str((char *)"lame --preset standard --tt \"%d\" --ta \"%c\" --tl \"%3\" --ty \"%5\" --tc \"%6\" --tn \"%a\" --tg \"%4\" \"%1\" \"%2\"");
#line 212
  def_mp3_enc_of = copy_char_str((char *)"lame --preset standard --tt \"%d\" --ta \"%c\" --tl \"%3\" --ty \"%5\" --tc \"%6\" --tn \"%a\" --tg \"%4\" - \"%1\"");
#line 213
  def_m3u_pattern = copy_char_str((char *)"%1-%3.m3u");
#line 214
  def_m3u_patmix = copy_char_str((char *)"%3.m3u");
#line 215
  def_m3u_dir = copy_char_str((char *)"0");
#line 216
  def_comment = copy_char_str((char *)"gen by WSPse-MP3c %8 [%b/%c]");
#line 217
  def_ill_chars = copy_char_str((char *)"~[]()!*?\"");
#line 218
  def_exp_file = copy_char_str((char *)"./.mp3c-exported");
#line 219
  def_version_str = copy_char_str((char *)"0.00");
#line 220
  def_cddb_email = copy_char_str((char *)"freedb-submit@freedb.org");
#line 221
  def_unknown_gen = copy_char_str((char *)"Unknown");
  }
#line 223
  if (! cddb_genres) {
    {
#line 224
    cddb_genres = copy_char_str((char *)"blues,classical,country,data,folk,jazz,misc,newage,reggae,rock,soundtrack");
    }
  }
  {
#line 228
  pat = getenv("HOSTNAME");
  }
#line 229
  if (! pat) {
    {
#line 230
    def_smtp_server = copy_char_str((char *)"localhost:smtp");
    }
  } else {
    {
#line 232
    tmp___0 = strlen((char const   *)pat);
#line 232
    tmp___1 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___0 + 6U)));
#line 232
    def_smtp_server = (char *)tmp___1;
    }
#line 233
    if (! def_smtp_server) {
      {
#line 234
      wuuush(1);
      }
    }
    {
#line 236
    sprintf((char */* __restrict  */)def_smtp_server, (char const   */* __restrict  */)"%s:smtp",
            pat);
    }
  }
#line 239
  if (pat) {
    {
#line 240
    def_my_email = copy_char_str(pat);
    }
  } else {
    {
#line 242
    def_my_email = copy_char_str((char *)"localhost");
    }
  }
  {
#line 245
  pat = getenv("LOGNAME");
  }
#line 246
  if (! pat) {
    {
#line 247
    pat = getlogin();
    }
  }
#line 250
  if (! pat) {
    {
#line 251
    tmp___2 = strlen((char const   *)def_my_email);
#line 251
    tmp___3 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___2 + 9U)));
#line 251
    pat = (char *)tmp___3;
    }
#line 252
    if (! pat) {
      {
#line 253
      wuuush(1);
      }
    }
    {
#line 255
    sprintf((char */* __restrict  */)pat, (char const   */* __restrict  */)"unknown@%s",
            def_my_email);
#line 256
    free((void *)def_my_email);
#line 257
    def_my_email = pat;
    }
  } else {
    {
#line 259
    tmp___4 = strlen((char const   *)def_my_email);
#line 259
    tmp___5 = strlen((char const   *)pat);
#line 259
    tmp___6 = malloc((size_t )(sizeof(char ) * (unsigned long )((tmp___4 + tmp___5) + 2U)));
#line 259
    pat2 = (char *)tmp___6;
    }
#line 260
    if (! pat2) {
      {
#line 261
      wuuush(1);
      }
    }
    {
#line 263
    sprintf((char */* __restrict  */)pat2, (char const   */* __restrict  */)"%s@%s",
            pat, def_my_email);
#line 264
    free((void *)def_my_email);
#line 265
    def_my_email = pat2;
    }
  }
#line 267
  return;
}
}
#line 269 "/home/wslee/benchmarks/sound/mp3c-0.29/src/conf.c"
void check_config(void) 
{ 
  char *text ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned char tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  void *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  size_t tmp___20 ;
  void *tmp___21 ;
  char *tmp___22 ;
  size_t tmp___23 ;
  void *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  size_t tmp___30 ;
  void *tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;
  char *tmp___34 ;
  unsigned char tmp___35 ;
  char *tmp___36 ;
  unsigned char tmp___37 ;
  char *tmp___38 ;
  unsigned char tmp___39 ;
  char *tmp___40 ;
  unsigned char tmp___41 ;
  char *tmp___42 ;
  int tmp___43 ;
  unsigned char tmp___44 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;

  {
#line 273
  if (! def_cddb_bank) {
    {
#line 274
    tmp = gettext("no CDDB-directory specified");
#line 274
    popup_error_win(tmp);
    }
  } else {
    {
#line 276
    tmp___9 = access((char const   *)def_cddb_bank, 0);
    }
#line 276
    if (tmp___9 != 0) {
      {
#line 277
      tmp___0 = strlen((char const   *)def_cddb_bank);
#line 277
      tmp___1 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___0 + 80U)));
#line 277
      text = (char *)tmp___1;
      }
#line 278
      if ((unsigned long )text == (unsigned long )((void *)0)) {
        {
#line 279
        perror("malloc");
#line 280
        wuuush(1);
        }
      }
      {
#line 282
      tmp___2 = gettext("CDDB-dir \"%s\" does not exist!");
#line 282
      sprintf((char */* __restrict  */)text, (char const   */* __restrict  */)tmp___2,
              def_cddb_bank);
#line 283
      popup_error_win(text);
#line 284
      tmp___3 = gettext("Maybe you want to create \"%s\"?");
#line 284
      sprintf((char */* __restrict  */)text, (char const   */* __restrict  */)tmp___3,
              def_cddb_bank);
#line 285
      tmp___4 = select_yesno_box(text);
      }
#line 285
      if (tmp___4) {
        {
#line 286
        create_sub_dirs(def_cddb_bank, (unsigned char)0);
        }
      }
      {
#line 288
      free((void *)text);
      }
    } else {
      {
#line 289
      tmp___8 = access((char const   *)def_cddb_bank, 2);
      }
#line 289
      if (tmp___8 != 0) {
        {
#line 290
        tmp___5 = strlen((char const   *)def_cddb_bank);
#line 290
        tmp___6 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___5 + 80U)));
#line 290
        text = (char *)tmp___6;
        }
#line 291
        if ((unsigned long )text == (unsigned long )((void *)0)) {
          {
#line 292
          perror("malloc");
#line 293
          wuuush(1);
          }
        }
        {
#line 295
        tmp___7 = gettext("no write permission for \"%s\"");
#line 295
        sprintf((char */* __restrict  */)text, (char const   */* __restrict  */)tmp___7,
                def_cddb_bank);
#line 296
        popup_error_win(text);
#line 297
        free((void *)text);
        }
      } else {
        {
#line 299
        file_is_directory(def_cddb_bank);
        }
      }
    }
  }
#line 303
  if (! def_mp3_dir) {
    {
#line 304
    tmp___10 = gettext("no MP3-directory specified");
#line 304
    popup_error_win(tmp___10);
    }
  } else {
    {
#line 306
    tmp___18 = access((char const   *)def_mp3_dir, 0);
    }
#line 306
    if (tmp___18 != 0) {
      {
#line 307
      tmp___11 = strlen((char const   *)def_mp3_dir);
#line 307
      tmp___12 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___11 + 50U)));
#line 307
      text = (char *)tmp___12;
      }
#line 308
      if ((unsigned long )text == (unsigned long )((void *)0)) {
        {
#line 309
        perror("malloc");
#line 310
        wuuush(1);
        }
      }
      {
#line 312
      tmp___13 = gettext("no dir \"%s\"");
#line 312
      sprintf((char */* __restrict  */)text, (char const   */* __restrict  */)tmp___13,
              def_mp3_dir);
#line 313
      popup_error_win(text);
#line 314
      free((void *)text);
      }
    } else {
      {
#line 315
      tmp___17 = access((char const   *)def_mp3_dir, 2);
      }
#line 315
      if (tmp___17 != 0) {
        {
#line 316
        tmp___14 = strlen((char const   *)def_mp3_dir);
#line 316
        tmp___15 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___14 + 100U)));
#line 316
        text = (char *)tmp___15;
        }
#line 317
        if ((unsigned long )text == (unsigned long )((void *)0)) {
          {
#line 318
          perror("malloc");
#line 319
          wuuush(1);
          }
        }
        {
#line 321
        tmp___16 = gettext("no write permission for \"%s\"");
#line 321
        sprintf((char */* __restrict  */)text, (char const   */* __restrict  */)tmp___16,
                def_mp3_dir);
#line 322
        popup_error_win(text);
#line 323
        free((void *)text);
        }
      } else {
        {
#line 325
        file_is_directory(def_mp3_dir);
        }
      }
    }
  }
#line 329
  if (! def_m3u_dir) {
    {
#line 330
    tmp___19 = gettext("no M3U-directory specified");
#line 330
    popup_error_win(tmp___19);
    }
  } else {
    {
#line 331
    tmp___28 = strcmp((char const   *)def_m3u_dir, "0");
    }
#line 331
    if (tmp___28 != 0) {
      {
#line 332
      tmp___27 = access((char const   *)def_m3u_dir, 0);
      }
#line 332
      if (tmp___27 != 0) {
        {
#line 333
        tmp___20 = strlen((char const   *)def_m3u_dir);
#line 333
        tmp___21 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___20 + 50U)));
#line 333
        text = (char *)tmp___21;
        }
#line 334
        if (! text) {
          {
#line 335
          perror("malloc");
#line 336
          wuuush(1);
          }
        }
        {
#line 338
        tmp___22 = gettext("no dir \"%s\"");
#line 338
        sprintf((char */* __restrict  */)text, (char const   */* __restrict  */)tmp___22,
                def_m3u_dir);
#line 339
        popup_error_win(text);
#line 340
        free((void *)text);
        }
      } else {
        {
#line 341
        tmp___26 = access((char const   *)def_m3u_dir, 2);
        }
#line 341
        if (tmp___26 != 0) {
          {
#line 342
          tmp___23 = strlen((char const   *)def_m3u_dir);
#line 342
          tmp___24 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___23 + 60U)));
#line 342
          text = (char *)tmp___24;
          }
#line 343
          if (! text) {
            {
#line 344
            perror("malloc");
#line 345
            wuuush(1);
            }
          }
          {
#line 347
          tmp___25 = gettext("no write permission for \"%s\"");
#line 347
          sprintf((char */* __restrict  */)text, (char const   */* __restrict  */)tmp___25,
                  def_m3u_dir);
#line 348
          popup_error_win(text);
#line 349
          free((void *)text);
          }
        } else {
          {
#line 351
          file_is_directory(def_m3u_dir);
          }
        }
      }
    }
  }
#line 355
  if (! def_cdrom_dev) {
    {
#line 356
    tmp___29 = gettext("no cdrom device specified");
#line 356
    popup_error_win(tmp___29);
    }
  } else {
    {
#line 358
    tmp___33 = access((char const   *)def_cdrom_dev, 4);
    }
#line 358
    if (tmp___33 != 0) {
      {
#line 359
      tmp___30 = strlen((char const   *)def_cdrom_dev);
#line 359
      tmp___31 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___30 + 50U)));
#line 359
      text = (char *)tmp___31;
      }
#line 360
      if ((unsigned long )text == (unsigned long )((void *)0)) {
        {
#line 361
        perror("malloc");
#line 362
        wuuush(1);
        }
      }
      {
#line 364
      tmp___32 = gettext("no permissions for \"%s\"");
#line 364
      sprintf((char */* __restrict  */)text, (char const   */* __restrict  */)tmp___32,
              def_cdrom_dev);
#line 365
      popup_error_win(text);
#line 366
      free((void *)text);
      }
    }
  }
#line 370
  if (! def_on_fly) {
    {
#line 371
    tmp___35 = str_path_check(def_cd_rip_nf);
    }
#line 371
    if (! tmp___35) {
      {
#line 372
      tmp___34 = gettext("ripperprg non-fly not found!");
#line 372
      popup_error_win(tmp___34);
      }
    }
    {
#line 374
    tmp___37 = str_path_check(def_mp3_enc_nf);
    }
#line 374
    if (! tmp___37) {
      {
#line 375
      tmp___36 = gettext("encoderprg non-fly not found!");
#line 375
      popup_error_win(tmp___36);
      }
    }
  } else {
    {
#line 378
    tmp___39 = str_path_check(def_cd_rip_of);
    }
#line 378
    if (! tmp___39) {
      {
#line 379
      tmp___38 = gettext("ripperprg on-fly not found!");
#line 379
      popup_error_win(tmp___38);
      }
    }
    {
#line 381
    tmp___41 = str_path_check(def_mp3_enc_of);
    }
#line 381
    if (! tmp___41) {
      {
#line 382
      tmp___40 = gettext("encoderprg on-fly not found!");
#line 382
      popup_error_win(tmp___40);
      }
    }
  }
#line 385
  if (def_mp3_info) {
    {
#line 385
    tmp___43 = strcmp((char const   *)def_mp3_info, "0");
    }
#line 385
    if (tmp___43) {
      {
#line 385
      tmp___44 = str_path_check(def_mp3_info);
      }
#line 385
      if (! tmp___44) {
        {
#line 386
        tmp___42 = gettext("mp3info-prg missing!");
#line 386
        popup_error_win(tmp___42);
        }
      }
    }
  }
#line 388
  return;
}
}
#line 258 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 50 "/home/wslee/benchmarks/sound/mp3c-0.29/src/cddb_put.c"
int cddb_open_cddbp(char *addr___0 ) ;
#line 72
unsigned char cddb_cddb_entry_is_clean ;
#line 73
int cddb_cddb_entry_revision ;
#line 84 "/home/wslee/benchmarks/sound/mp3c-0.29/src/cddb_put.c"
int cddb_get_genre_list(char *addr___0 ) 
{ 
  int cddb_fd ;
  char *inp_buf ;
  char *pat ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 90
  setup_stat_win(50);
#line 92
  cddb_fd = cddb_open_cddbp(addr___0);
  }
#line 93
  if (cddb_fd < 0) {
    {
#line 94
    destroy_stat_win();
    }
#line 95
    return (1);
  }
  {
#line 98
  tmp = gettext("asking for categories");
#line 98
  print_stat_win(tmp);
#line 99
  tmp___1 = write_to_sock((char *)"cddb lscat\r\n", 12, cddb_fd);
  }
#line 99
  if (tmp___1 != 0) {
    {
#line 100
    tmp___0 = gettext("failed");
#line 100
    print_stat_win(tmp___0);
#line 101
    close(cddb_fd);
#line 102
    destroy_stat_win();
    }
#line 103
    return (1);
  }
  {
#line 106
  tmp___3 = read_from_sock(& inp_buf, cddb_fd, (unsigned char)1);
  }
#line 106
  if (tmp___3 != 0) {
    {
#line 107
    tmp___2 = gettext("failed");
#line 107
    print_stat_win(tmp___2);
#line 108
    close(cddb_fd);
#line 109
    destroy_stat_win();
    }
#line 110
    return (1);
  }
  {
#line 113
  tmp___5 = strncmp((char const   *)inp_buf, "210", (size_t )3);
  }
#line 113
  if (tmp___5 != 0) {
    {
#line 114
    tmp___4 = gettext("failed");
#line 114
    print_stat_win(tmp___4);
#line 115
    free((void *)inp_buf);
#line 116
    close(cddb_fd);
#line 117
    destroy_stat_win();
    }
#line 118
    return (1);
  }
  {
#line 121
  free((void *)inp_buf);
#line 122
  inp_buf = (char *)((void *)0);
  }
#line 125
  if (cddb_genres) {
    {
#line 126
    free((void *)cddb_genres);
#line 127
    cddb_genres = (char *)((void *)0);
    }
  }
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 131
    tmp___7 = read_from_sock(& inp_buf, cddb_fd, (unsigned char)1);
    }
#line 131
    if (tmp___7 != 0) {
      {
#line 132
      tmp___6 = gettext("receiving failed");
#line 132
      print_stat_win(tmp___6);
#line 133
      close(cddb_fd);
#line 134
      destroy_stat_win();
      }
#line 135
      return (1);
    }
#line 137
    if ((int )*inp_buf == 46) {
      {
#line 138
      free((void *)inp_buf);
      }
#line 139
      goto while_break;
    }
    {
#line 141
    pat = strchr((char const   *)inp_buf, '\n');
    }
#line 142
    if (pat) {
#line 142
      *pat = (char)0;
    }
    {
#line 143
    pat = strchr((char const   *)inp_buf, '\r');
    }
#line 144
    if (pat) {
#line 144
      *pat = (char)0;
    }
#line 145
    if (*inp_buf) {
      {
#line 146
      print_stat_win(inp_buf);
      }
#line 147
      if (! cddb_genres) {
#line 148
        cddb_genres = inp_buf;
#line 149
        inp_buf = (char *)((void *)0);
      } else {
        {
#line 151
        tmp___8 = strlen((char const   *)cddb_genres);
#line 151
        tmp___9 = strlen((char const   *)inp_buf);
#line 151
        tmp___10 = realloc((void *)cddb_genres, (size_t )(sizeof(char ) * (unsigned long )((tmp___8 + tmp___9) + 2U)));
#line 151
        cddb_genres = (char *)tmp___10;
        }
#line 153
        if (! cddb_genres) {
          {
#line 154
          wuuush(1);
          }
        }
        {
#line 156
        strcat((char */* __restrict  */)cddb_genres, (char const   */* __restrict  */)",");
#line 157
        strcat((char */* __restrict  */)cddb_genres, (char const   */* __restrict  */)inp_buf);
        }
      }
    }
#line 160
    if (inp_buf) {
      {
#line 161
      free((void *)inp_buf);
#line 162
      inp_buf = (char *)((void *)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  tmp___11 = gettext("closing connection");
#line 167
  print_stat_win(tmp___11);
#line 168
  tmp___15 = write_to_sock((char *)"quit\r\n", 6, cddb_fd);
  }
#line 168
  if (tmp___15 == 0) {
    {
#line 169
    tmp___14 = read_from_sock(& inp_buf, cddb_fd, (unsigned char)1);
    }
#line 169
    if (tmp___14 != 0) {
      {
#line 170
      tmp___12 = gettext("failed");
#line 170
      print_stat_win(tmp___12);
      }
    } else {
      {
#line 172
      tmp___13 = gettext("closed");
#line 172
      print_stat_win(tmp___13);
#line 173
      free((void *)inp_buf);
      }
    }
  }
  {
#line 177
  close(cddb_fd);
#line 178
  destroy_stat_win();
  }
#line 179
  return (0);
}
}
#line 182 "/home/wslee/benchmarks/sound/mp3c-0.29/src/cddb_put.c"
char *cddb_select_cddb_genre(char *addr___0 ) 
{ 
  field_select_typ *anchor ;
  field_select_typ *curr ;
  field_select_typ *new ;
  char *pat ;
  char *pat2 ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    anchor = (field_select_typ *)((void *)0);
#line 189
    curr = (field_select_typ *)((void *)0);
#line 190
    pat = cddb_genres;
    {
#line 191
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 191
      if (! pat) {
#line 191
        goto while_break___0;
      }
      {
#line 192
      pat2 = strchr((char const   *)pat, ',');
      }
#line 193
      if (pat2) {
#line 193
        *pat2 = (char)0;
      }
#line 194
      if (*pat) {
        {
#line 195
        tmp = malloc((size_t )sizeof(field_select_typ ));
#line 195
        new = (field_select_typ *)tmp;
        }
#line 196
        if (! new) {
          {
#line 197
          wuuush(1);
          }
        }
        {
#line 199
        new->field = copy_char_str(pat);
#line 200
        new->dest = (char *)((void *)0);
#line 201
        new->information = (char *)((void *)0);
#line 202
        new->next = (struct _field_select_typ *)((void *)0);
#line 203
        new->prev = curr;
        }
#line 204
        if (curr) {
#line 204
          curr->next = new;
        }
#line 205
        if (! anchor) {
#line 205
          anchor = new;
        }
#line 206
        curr = new;
      }
#line 208
      if (pat2) {
#line 209
        *pat2 = (char )',';
#line 210
        pat2 ++;
      }
#line 212
      pat = pat2;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 215
    tmp___0 = malloc((size_t )sizeof(field_select_typ ));
#line 215
    new = (field_select_typ *)tmp___0;
    }
#line 216
    if (! new) {
      {
#line 217
      wuuush(1);
      }
    }
    {
#line 219
    tmp___1 = gettext("refresh genres (requires CDDB-access)");
#line 219
    new->field = copy_char_str(tmp___1);
#line 220
    new->dest = (char *)((void *)0);
#line 221
    new->information = copy_char_str((char *)"0");
#line 222
    new->next = (struct _field_select_typ *)((void *)0);
#line 223
    new->prev = curr;
    }
#line 224
    if (curr) {
#line 224
      curr->next = new;
    }
#line 225
    if (! anchor) {
#line 225
      anchor = new;
    }
    {
#line 226
    curr = new;
#line 228
    tmp___2 = malloc((size_t )sizeof(field_select_typ ));
#line 228
    new = (field_select_typ *)tmp___2;
    }
#line 229
    if (! new) {
      {
#line 230
      wuuush(1);
      }
    }
    {
#line 232
    tmp___3 = gettext("Abort");
#line 232
    new->field = copy_char_str(tmp___3);
#line 233
    new->dest = (char *)((void *)0);
#line 234
    new->information = copy_char_str((char *)"1");
#line 235
    new->next = (struct _field_select_typ *)((void *)0);
#line 236
    new->prev = curr;
    }
#line 237
    if (curr) {
#line 237
      curr->next = new;
    }
#line 238
    if (! anchor) {
#line 238
      anchor = new;
    }
    {
#line 239
    curr = new;
#line 242
    tmp___4 = gettext("select CDDB genre");
#line 242
    new = select_field_box(anchor, 60, tmp___4, (unsigned char)0, (unsigned char)0);
    }
#line 243
    if (! new) {
      {
#line 244
      free_field_select(& anchor);
      }
#line 245
      return ((char *)((void *)0));
    } else
#line 243
    if (new->information) {
#line 243
      if ((int )*(new->information) == 49) {
        {
#line 244
        free_field_select(& anchor);
        }
#line 245
        return ((char *)((void *)0));
      }
    }
#line 248
    if (! new->information) {
      {
#line 249
      pat = copy_char_str(new->field);
#line 250
      free_field_select(& anchor);
      }
#line 251
      return (pat);
    }
    {
#line 254
    free_field_select(& anchor);
#line 255
    anchor = (field_select_typ *)((void *)0);
#line 256
    cddb_get_genre_list(addr___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 263 "/home/wslee/benchmarks/sound/mp3c-0.29/src/cddb_put.c"
int cddb_add_keyword(FILE *fd , char *keyword , char *value ) 
{ 
  int i ;
  int j ;
  char pat ;
  size_t tmp ;
  size_t tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 268
  if (! keyword) {
#line 269
    return (1);
  }
#line 272
  if (! value) {
    {
#line 273
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%s\n",
            keyword);
    }
#line 274
    return (0);
  }
  {
#line 277
  i = 0;
#line 278
  tmp = strlen((char const   *)keyword);
#line 278
  j = (int )tmp;
  }
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 279
    tmp___0 = strlen((char const   *)(value + i));
    }
#line 279
    if (! ((size_t )j + tmp___0 > 80U)) {
#line 279
      goto while_break;
    }
    {
#line 280
    pat = *((value + i) + (80 - j));
#line 281
    *((value + i) + (80 - j)) = (char)0;
#line 282
    fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%s%s\n",
            keyword, value + i);
#line 283
    *((value + i) + (80 - j)) = pat;
#line 284
    i += 80 - j;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 287
  fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%s%s\n",
          keyword, value + i);
  }
#line 288
  return (0);
}
}
#line 291 "/home/wslee/benchmarks/sound/mp3c-0.29/src/cddb_put.c"
int cddb_create_entry(char *filename , song_typ *song_list ) 
{ 
  unsigned char if_various ;
  song_typ *curr ;
  char *artist ;
  char *album ;
  FILE *cddb_out_fd ;
  time_t lt ;
  struct tm *ltm ;
  char *pat ;
  char *tmp_str ;
  int i ;
  char keyword[10] ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  void *tmp___6 ;
  unsigned long tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
#line 303
  if (! song_list) {
#line 304
    return (1);
  } else
#line 303
  if (! filename) {
#line 304
    return (1);
  }
#line 307
  if_various = (unsigned char)0;
#line 309
  curr = song_list;
#line 310
  artist = curr->artist;
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    if (! curr) {
#line 311
      goto while_break;
    }
#line 312
    if (! artist) {
#line 313
      artist = curr->artist;
    } else
#line 312
    if (! *artist) {
#line 313
      artist = curr->artist;
    } else
#line 314
    if (curr->artist) {
#line 314
      if (*(curr->artist)) {
        {
#line 315
        tmp = strcmp((char const   *)artist, (char const   *)curr->artist);
        }
#line 315
        if (tmp != 0) {
#line 316
          if_various = (unsigned char)1;
#line 317
          goto while_break;
        }
      }
    }
#line 320
    curr = curr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 323
  artist = (char *)((void *)0);
#line 324
  album = (char *)((void *)0);
#line 325
  curr = song_list;
  {
#line 326
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 326
    if (! curr) {
#line 326
      goto while_break___0;
    }
#line 327
    if (! artist) {
#line 327
      goto _L;
    } else
#line 327
    if (! *artist) {
      _L: /* CIL Label */ 
#line 327
      if (curr->artist) {
#line 328
        artist = curr->artist;
      }
    }
#line 330
    if (! album) {
#line 330
      goto _L___0;
    } else
#line 330
    if (! *album) {
      _L___0: /* CIL Label */ 
#line 330
      if (curr->album) {
#line 331
        album = curr->album;
      }
    }
#line 333
    if (artist) {
#line 333
      if (*artist) {
#line 333
        if (album) {
#line 333
          if (*album) {
#line 333
            goto while_break___0;
          }
        }
      }
    }
#line 334
    curr = curr->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 337
  if (artist) {
#line 337
    if (! *artist) {
#line 337
      artist = (char *)((void *)0);
    }
  }
#line 338
  if (album) {
#line 338
    if (! *album) {
#line 338
      album = (char *)((void *)0);
    }
  }
#line 340
  if (! artist) {
    {
#line 341
    tmp___0 = gettext("all artist fields are empty");
#line 341
    popup_error_win(tmp___0);
    }
#line 342
    return (1);
  }
#line 345
  if (! album) {
    {
#line 346
    tmp___1 = gettext("album title is missing");
#line 346
    popup_error_win(tmp___1);
    }
#line 347
    return (1);
  }
  {
#line 350
  cddb_out_fd = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"w");
  }
#line 351
  if (! cddb_out_fd) {
    {
#line 352
    tmp___2 = strlen((char const   *)filename);
#line 352
    tmp___3 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___2 + 100U)));
#line 352
    pat = (char *)tmp___3;
    }
#line 353
    if (! pat) {
      {
#line 354
      wuuush(1);
      }
    }
    {
#line 356
    tmp___4 = gettext("opening \"%s\" for writing failed.");
#line 356
    sprintf((char */* __restrict  */)pat, (char const   */* __restrict  */)tmp___4,
            filename);
#line 357
    popup_error_win(pat);
#line 358
    free((void *)pat);
#line 359
    pat = (char *)((void *)0);
    }
#line 360
    return (1);
  }
  {
#line 363
  lt = time((time_t *)((void *)0));
#line 364
  ltm = localtime((time_t const   *)(& lt));
#line 365
  tmp___5 = ctime((time_t const   *)(& lt));
#line 365
  tmp_str = copy_char_str(tmp___5);
  }
#line 366
  if (tmp_str) {
    {
#line 367
    pat = strchr((char const   *)tmp_str, '\n');
    }
#line 368
    if (pat) {
#line 368
      *pat = (char)0;
    }
    {
#line 369
    pat = strchr((char const   *)tmp_str, '\r');
    }
#line 370
    if (pat) {
#line 370
      *pat = (char)0;
    }
  } else {
    {
#line 372
    tmp___6 = malloc((size_t )(sizeof(char ) * 100UL));
#line 372
    tmp_str = (char *)tmp___6;
    }
#line 373
    if (! tmp_str) {
      {
#line 374
      wuuush(1);
      }
    }
    {
#line 376
    sprintf((char */* __restrict  */)tmp_str, (char const   */* __restrict  */)"%s %s %2d %02d:%02d:%02d %4d",
            weekday[ltm->tm_wday], month[ltm->tm_mon], ltm->tm_mday, ltm->tm_hour,
            ltm->tm_min, ltm->tm_sec, ltm->tm_year + 100);
    }
  }
  {
#line 380
  fprintf((FILE */* __restrict  */)cddb_out_fd, (char const   */* __restrict  */)"# xmcd CD database file\n# Generated: %s by WSPse\'s MP3c\n#\n# Track frame offsets:\n",
          tmp_str);
#line 384
  free((void *)tmp_str);
#line 385
  tmp_str = (char *)((void *)0);
#line 387
  i = 0;
  }
  {
#line 387
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 387
    if (! (i < track_last)) {
#line 387
      goto while_break___1;
    }
    {
#line 388
    fprintf((FILE */* __restrict  */)cddb_out_fd, (char const   */* __restrict  */)"#       %d\n",
            cdtoc[i].frame + 75 * (cdtoc[i].sec + 60 * cdtoc[i].min));
#line 387
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 392
  fprintf((FILE */* __restrict  */)cddb_out_fd, (char const   */* __restrict  */)"#\n# Disc length: %d seconds\n#\n",
          cdtoc[track_last].sec + 60 * cdtoc[i].min);
  }
#line 395
  if (cddb_cddb_entry_is_clean) {
#line 397
    cddb_cddb_entry_revision ++;
#line 398
    cddb_cddb_entry_is_clean = (unsigned char)0;
  }
#line 400
  if (cddb_cddb_entry_revision < 0) {
#line 401
    cddb_cddb_entry_revision = 0;
  }
  {
#line 404
  tmp___7 = cddb_discid(track_last);
#line 404
  fprintf((FILE */* __restrict  */)cddb_out_fd, (char const   */* __restrict  */)"# Revision: %d\n# Submitted via: MP3c 0.29\n#   WSPse %s\n#\nDISCID=%08lx\n",
          cddb_cddb_entry_revision, external_version_str, tmp___7);
  }
#line 411
  if (if_various) {
    {
#line 412
    tmp___8 = strlen((char const   *)album);
#line 412
    tmp___9 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___8 + 15U)));
#line 412
    pat = (char *)tmp___9;
    }
#line 413
    if (! pat) {
      {
#line 414
      wuuush(1);
      }
    }
    {
#line 416
    sprintf((char */* __restrict  */)pat, (char const   */* __restrict  */)"Various / %s",
            album);
    }
  } else {
    {
#line 418
    tmp___10 = strlen((char const   *)artist);
#line 418
    tmp___11 = strlen((char const   *)album);
#line 418
    tmp___12 = malloc((size_t )(sizeof(char ) * (unsigned long )((tmp___10 + tmp___11) + 4U)));
#line 418
    pat = (char *)tmp___12;
    }
#line 419
    if (! pat) {
      {
#line 420
      wuuush(1);
      }
    }
    {
#line 422
    sprintf((char */* __restrict  */)pat, (char const   */* __restrict  */)"%s / %s",
            artist, album);
    }
  }
  {
#line 425
  cddb_add_keyword(cddb_out_fd, (char *)"DTITLE=", pat);
#line 426
  free((void *)pat);
#line 427
  pat = (char *)((void *)0);
#line 429
  curr = song_list;
#line 430
  i = 0;
  }
  {
#line 430
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 430
    if (! (i < track_last)) {
#line 430
      goto while_break___2;
    }
    {
#line 431
    sprintf((char */* __restrict  */)(keyword), (char const   */* __restrict  */)"TTITLE%d=",
            i);
    }
#line 432
    if (curr) {
      {
#line 433
      cddb_add_keyword(cddb_out_fd, keyword, curr->title);
#line 434
      curr = curr->next;
      }
    } else {
      {
#line 436
      cddb_add_keyword(cddb_out_fd, keyword, (char *)((void *)0));
      }
    }
#line 430
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 440
  cddb_add_keyword(cddb_out_fd, (char *)"EXTD=", (char *)((void *)0));
#line 442
  curr = song_list;
#line 443
  i = 0;
  }
  {
#line 443
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 443
    if (! (i < track_last)) {
#line 443
      goto while_break___3;
    }
    {
#line 444
    sprintf((char */* __restrict  */)(keyword), (char const   */* __restrict  */)"EXTT%d=",
            i);
    }
#line 445
    if (if_various) {
#line 445
      if (curr) {
        {
#line 446
        cddb_add_keyword(cddb_out_fd, keyword, curr->artist);
#line 447
        curr = curr->next;
        }
      } else {
        {
#line 449
        cddb_add_keyword(cddb_out_fd, keyword, (char *)((void *)0));
        }
      }
    } else {
      {
#line 449
      cddb_add_keyword(cddb_out_fd, keyword, (char *)((void *)0));
      }
    }
#line 443
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 453
  cddb_add_keyword(cddb_out_fd, (char *)"PLAYORDER=", (char *)((void *)0));
#line 455
  fclose(cddb_out_fd);
  }
#line 456
  return (0);
}
}
#line 460 "/home/wslee/benchmarks/sound/mp3c-0.29/src/cddb_put.c"
int cddb_save_cddb_entry(song_typ *song_list , char *cddb_path ) 
{ 
  char *genre ;
  char *filename ;
  char discid[9] ;
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  unsigned char tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
#line 467
  if (! song_list) {
    {
#line 468
    tmp = gettext("no CD inserted");
#line 468
    popup_error_win(tmp);
    }
#line 469
    return (1);
  }
#line 472
  if (! cddb_path) {
    {
#line 473
    tmp___0 = gettext("no local cddb-database specified");
#line 473
    popup_error_win(tmp___0);
    }
#line 474
    return (1);
  }
  {
#line 477
  tmp___2 = access((char const   *)cddb_path, 0);
  }
#line 477
  if (tmp___2) {
    {
#line 478
    tmp___1 = gettext("no cddb-path, try to create");
#line 478
    print_stat_win(tmp___1);
#line 479
    create_sub_dirs(cddb_path, (unsigned char)0);
    }
  }
  {
#line 481
  tmp___4 = access((char const   *)cddb_path, 0);
  }
#line 481
  if (tmp___4) {
    {
#line 482
    tmp___3 = gettext("Uh, cannot write entries without valid CDDB-path.");
#line 482
    popup_error_win(tmp___3);
    }
#line 483
    return (1);
  }
  {
#line 485
  tmp___6 = access((char const   *)cddb_path, 2);
  }
#line 485
  if (tmp___6) {
    {
#line 486
    tmp___5 = gettext("STOP! No write permissions for CDDB-directory. <EMERGENCY ABORT>");
#line 486
    popup_error_win(tmp___5);
    }
#line 487
    return (1);
  }
  {
#line 491
  tmp___8 = cddb_discid(track_last);
  }
#line 491
  if (tmp___8 == 0UL) {
    {
#line 492
    tmp___7 = gettext("illegal discid");
#line 492
    popup_error_win(tmp___7);
    }
#line 493
    return (1);
  }
  {
#line 495
  tmp___9 = cddb_discid(track_last);
#line 495
  snprintf((char */* __restrict  */)(discid), (size_t )9, (char const   */* __restrict  */)"%08lx",
           tmp___9);
#line 497
  genre = cddb_select_cddb_genre(def_cddb_server);
  }
#line 498
  if (! genre) {
#line 499
    return (1);
  }
  {
#line 502
  tmp___10 = strlen((char const   *)genre);
#line 502
  tmp___11 = strlen((char const   *)cddb_path);
#line 502
  tmp___12 = malloc((size_t )(sizeof(char ) * (unsigned long )((tmp___10 + tmp___11) + 11U)));
#line 502
  filename = (char *)tmp___12;
  }
#line 504
  if (! filename) {
    {
#line 505
    wuuush(1);
    }
  }
  {
#line 508
  sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s/%s/%s",
          cddb_path, genre, discid);
#line 509
  free((void *)genre);
#line 510
  genre = (char *)((void *)0);
#line 511
  filename = kill_double_slashs(filename);
#line 512
  create_sub_dirs(filename, (unsigned char)1);
#line 514
  i = 0;
#line 515
  tmp___17 = access((char const   *)filename, 0);
  }
#line 515
  if (tmp___17 == 0) {
    {
#line 517
    tmp___16 = access((char const   *)filename, 2);
    }
#line 517
    if (tmp___16 != 0) {
      {
#line 519
      tmp___13 = gettext("CDDB entry exists and could not be overwritten");
#line 519
      popup_error_win(tmp___13);
#line 520
      i = 1;
      }
    } else {
      {
#line 522
      tmp___14 = gettext("overwrite existing CDDB entry?");
#line 522
      tmp___15 = select_yesno_box(tmp___14);
      }
#line 522
      if (! tmp___15) {
#line 523
        i = 2;
      }
    }
  }
#line 528
  if (! i) {
    {
#line 529
    i = cddb_create_entry(filename, song_list);
    }
#line 530
    if (! i) {
      {
#line 531
      tmp___18 = gettext("CDDB entry saved");
#line 531
      popup_error_win(tmp___18);
      }
    }
  }
  {
#line 535
  free((void *)filename);
#line 536
  filename = (char *)((void *)0);
  }
#line 538
  return (i);
}
}
#line 541 "/home/wslee/benchmarks/sound/mp3c-0.29/src/cddb_put.c"
int cddb_wait_smtp_code(int sock_fd ) 
{ 
  char *line ;
  char *line2 ;
  int ret_val ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 547
  usleep((__useconds_t )150000);
#line 548
  tmp___0 = read_from_sock(& line, sock_fd, (unsigned char)1);
  }
#line 548
  if (tmp___0) {
    {
#line 549
    tmp = gettext("timeout");
#line 549
    popup_error_win(tmp);
    }
#line 550
    return (-1);
  }
#line 553
  line2 = (char *)((void *)0);
  {
#line 554
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 554
    tmp___1 = read_from_sock(& line2, sock_fd, (unsigned char)0);
    }
#line 554
    if (tmp___1) {
#line 554
      goto while_break;
    }
#line 555
    if (line) {
      {
#line 555
      free((void *)line);
      }
    }
#line 556
    line = line2;
#line 557
    line2 = (char *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
#line 560
  if (line2) {
#line 561
    if (line) {
      {
#line 561
      free((void *)line);
      }
    }
#line 562
    line = line2;
  }
#line 565
  if (! line) {
    {
#line 566
    tmp___2 = gettext("no data from mailserver");
#line 566
    popup_error_win(tmp___2);
    }
#line 567
    return (-1);
  }
  {
#line 570
  line2 = strchr((char const   *)line, '\n');
  }
#line 571
  if (line2) {
#line 571
    *line2 = (char)0;
  }
  {
#line 572
  line2 = strchr((char const   *)line, '\r');
  }
#line 573
  if (line2) {
#line 573
    *line2 = (char)0;
  }
#line 575
  if ((int )*line == 50) {
#line 575
    ret_val = 2;
  } else
#line 576
  if ((int )*line == 51) {
#line 576
    ret_val = 3;
  } else {
    {
#line 578
    ret_val = -2;
#line 579
    popup_error_win(line);
#line 580
    write_to_sock((char *)"QUIT\n", 5, sock_fd);
    }
  }
  {
#line 583
  free((void *)line);
  }
#line 585
  return (ret_val);
}
}
#line 589 "/home/wslee/benchmarks/sound/mp3c-0.29/src/cddb_put.c"
int cddb_remote_transfer_entry(char *filename , char *subject , char *smtp_serv ,
                               char *from , char **rcpt , char *rcpt_list ) 
{ 
  int smtp_fd ;
  char *buf ;
  char *tmp ;
  int i ;
  int j ;
  FILE *mail ;
  char buffer[512] ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  void *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  size_t tmp___22 ;
  void *tmp___23 ;
  char *tmp___24 ;
  size_t tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  char *tmp___31 ;
  size_t tmp___32 ;
  size_t tmp___33 ;
  size_t tmp___34 ;
  void *tmp___35 ;
  char *tmp___36 ;
  size_t tmp___37 ;
  int tmp___38 ;
  char *tmp___39 ;
  int tmp___40 ;
  size_t tmp___41 ;
  size_t tmp___42 ;
  size_t tmp___43 ;
  size_t tmp___44 ;
  int tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  int tmp___48 ;
  char *tmp___49 ;
  void *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;

  {
#line 598
  if (! filename) {
#line 599
    return (1);
  } else
#line 598
  if (! subject) {
#line 599
    return (1);
  }
#line 602
  if (! smtp_serv) {
    {
#line 603
    tmp___0 = gettext("no SMTP server set");
#line 603
    popup_error_win(tmp___0);
    }
#line 604
    return (1);
  }
#line 607
  if (! from) {
    {
#line 608
    tmp___1 = gettext("missing eMail address");
#line 608
    popup_error_win(tmp___1);
    }
#line 609
    return (1);
  }
#line 612
  if (! rcpt) {
    {
#line 613
    tmp___2 = gettext("missing CDDB recipient");
#line 613
    popup_error_win(tmp___2);
    }
#line 614
    return (1);
  } else
#line 612
  if (! *(rcpt + 0)) {
    {
#line 613
    tmp___2 = gettext("missing CDDB recipient");
#line 613
    popup_error_win(tmp___2);
    }
#line 614
    return (1);
  } else
#line 612
  if (! rcpt_list) {
    {
#line 613
    tmp___2 = gettext("missing CDDB recipient");
#line 613
    popup_error_win(tmp___2);
    }
#line 614
    return (1);
  }
  {
#line 617
  tmp___3 = gettext("connect to SMTP-server");
#line 617
  print_stat_win(tmp___3);
#line 619
  smtp_fd = open_socket((char const   *)smtp_serv);
  }
#line 620
  if (smtp_fd == -1) {
#line 621
    return (1);
  }
  {
#line 625
  tmp___4 = gettext("waiting for greeting");
#line 625
  print_stat_win(tmp___4);
  }
  {
#line 626
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 627
    tmp___5 = read_from_sock(& buf, smtp_fd, (unsigned char)1);
    }
#line 627
    if (tmp___5 != 0) {
      {
#line 628
      close(smtp_fd);
      }
#line 629
      return (1);
    }
    {
#line 631
    tmp___6 = strncmp((char const   *)buf, "2", (size_t )1);
    }
#line 631
    if (tmp___6 == 0) {
#line 631
      goto while_break;
    }
    {
#line 632
    free((void *)buf);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 634
  free((void *)buf);
#line 636
  tmp = getenv("HOSTNAME");
  }
#line 637
  if (tmp) {
    {
#line 637
    tmp___7 = strlen((char const   *)tmp);
#line 637
    i = (int )(tmp___7 + 10U);
    }
  } else {
#line 638
    i = 20;
  }
  {
#line 640
  tmp___8 = malloc((size_t )(sizeof(char ) * (unsigned long )i));
#line 640
  buf = (char *)tmp___8;
  }
#line 641
  if (! buf) {
    {
#line 642
    wuuush(1);
    }
  }
#line 645
  if (tmp) {
    {
#line 646
    sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"EHLO %s\r\n",
            tmp);
    }
  } else {
    {
#line 648
    strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)"EHLO localhost\r\n");
    }
  }
  {
#line 651
  tmp___9 = gettext("saying hello to SMTP-server");
#line 651
  print_stat_win(tmp___9);
#line 653
  tmp___11 = strlen((char const   *)buf);
#line 653
  tmp___12 = write_to_sock(buf, (int )tmp___11, smtp_fd);
  }
#line 653
  if (tmp___12 != 0) {
    {
#line 654
    tmp___10 = gettext("SMTP EHLO failed");
#line 654
    popup_error_win(tmp___10);
#line 655
    close(smtp_fd);
#line 656
    free((void *)buf);
    }
#line 657
    return (1);
  }
  {
#line 659
  free((void *)buf);
#line 661
  i = cddb_wait_smtp_code(smtp_fd);
  }
#line 662
  if (i != 2) {
    {
#line 663
    tmp___13 = gettext("SMTP defered connection (EHLO)");
#line 663
    popup_error_win(tmp___13);
#line 664
    close(smtp_fd);
    }
#line 665
    return (1);
  }
  {
#line 668
  tmp___14 = strlen((char const   *)from);
#line 668
  tmp___15 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___14 + 20U)));
#line 668
  buf = (char *)tmp___15;
  }
#line 669
  if (! buf) {
    {
#line 670
    wuuush(1);
    }
  }
  {
#line 672
  sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"MAIL FROM: <%s>\r\n",
          from);
#line 673
  tmp___16 = gettext("submitting from address");
#line 673
  print_stat_win(tmp___16);
#line 675
  tmp___18 = strlen((char const   *)buf);
#line 675
  tmp___19 = write_to_sock(buf, (int )tmp___18, smtp_fd);
  }
#line 675
  if (tmp___19 != 0) {
    {
#line 676
    tmp___17 = gettext("MAIL FROM failed");
#line 676
    popup_error_win(tmp___17);
#line 677
    close(smtp_fd);
#line 678
    free((void *)buf);
    }
#line 679
    return (1);
  }
  {
#line 681
  free((void *)buf);
#line 683
  i = cddb_wait_smtp_code(smtp_fd);
  }
#line 684
  if (i != 2) {
    {
#line 685
    tmp___20 = gettext("SMTP defered connection (MAIL FROM)");
#line 685
    popup_error_win(tmp___20);
#line 686
    close(smtp_fd);
    }
#line 687
    return (1);
  }
  {
#line 690
  tmp___21 = gettext("submitting recipient address");
#line 690
  print_stat_win(tmp___21);
#line 691
  j = 0;
  }
  {
#line 693
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 693
    if (! *(rcpt + j)) {
#line 693
      goto while_break___0;
    }
    {
#line 694
    tmp___22 = strlen((char const   *)*(rcpt + j));
#line 694
    tmp___23 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___22 + 20U)));
#line 694
    buf = (char *)tmp___23;
    }
#line 695
    if (! buf) {
      {
#line 696
      wuuush(1);
      }
    }
    {
#line 698
    sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"RCPT TO: <%s>",
            *(rcpt + j));
#line 699
    print_stat_win(buf);
#line 700
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"\r\n");
#line 702
    tmp___25 = strlen((char const   *)buf);
#line 702
    tmp___26 = write_to_sock(buf, (int )tmp___25, smtp_fd);
    }
#line 702
    if (tmp___26 != 0) {
      {
#line 703
      tmp___24 = gettext("RCPT TO failed");
#line 703
      popup_error_win(tmp___24);
#line 704
      close(smtp_fd);
#line 705
      free((void *)buf);
      }
#line 706
      return (1);
    }
    {
#line 709
    i = cddb_wait_smtp_code(smtp_fd);
    }
#line 710
    if (i != 2) {
      {
#line 711
      tmp___27 = gettext("relay defered: %s");
#line 711
      sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)tmp___27,
              *(rcpt + j));
#line 712
      popup_error_win(buf);
#line 713
      close(smtp_fd);
#line 714
      free((void *)buf);
      }
#line 715
      return (1);
    }
    {
#line 717
    free((void *)buf);
#line 718
    buf = (char *)((void *)0);
#line 720
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 723
  tmp___28 = gettext("preparing data transfer");
#line 723
  print_stat_win(tmp___28);
#line 724
  tmp___30 = write_to_sock((char *)"DATA\r\n", 5, smtp_fd);
  }
#line 724
  if (tmp___30 != 0) {
    {
#line 725
    tmp___29 = gettext("SMTP: DATA cmd failed");
#line 725
    popup_error_win(tmp___29);
#line 726
    close(smtp_fd);
    }
#line 727
    return (1);
  }
  {
#line 730
  i = cddb_wait_smtp_code(smtp_fd);
  }
#line 731
  if (i != 3) {
    {
#line 732
    tmp___31 = gettext("SMTP defered data transfer");
#line 732
    popup_error_win(tmp___31);
#line 733
    close(smtp_fd);
    }
#line 734
    return (1);
  }
  {
#line 737
  tmp___32 = strlen((char const   *)from);
#line 737
  tmp___33 = strlen((char const   *)subject);
#line 737
  tmp___34 = strlen((char const   *)rcpt_list);
#line 737
  tmp___35 = malloc((size_t )(sizeof(char ) * (unsigned long )(((tmp___32 * 2U + tmp___33) + tmp___34) + 100U)));
#line 737
  buf = (char *)tmp___35;
  }
#line 739
  if (! buf) {
    {
#line 740
    wuuush(1);
    }
  }
  {
#line 743
  sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"From: %s\r\nReply-To: %s\r\nTo: %s\r\nSubject: %s\r\n\r\n\r\n",
          from, from, rcpt_list, subject);
#line 749
  tmp___37 = strlen((char const   *)buf);
#line 749
  tmp___38 = write_to_sock(buf, (int )tmp___37, smtp_fd);
  }
#line 749
  if (tmp___38 != 0) {
    {
#line 750
    tmp___36 = gettext("SMTP: sending header failed");
#line 750
    popup_error_win(tmp___36);
#line 751
    close(smtp_fd);
#line 752
    free((void *)buf);
    }
#line 753
    return (1);
  }
  {
#line 755
  free((void *)buf);
#line 757
  mail = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 758
  if (! mail) {
    {
#line 759
    tmp___39 = gettext("failed to open CDDB entry");
#line 759
    popup_error_win(tmp___39);
#line 760
    close(smtp_fd);
    }
#line 761
    return (1);
  }
  {
#line 764
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 765
    fgets((char */* __restrict  */)(buffer), 510, (FILE */* __restrict  */)mail);
#line 766
    tmp___40 = feof(mail);
    }
#line 766
    if (tmp___40) {
#line 766
      goto while_break___1;
    }
    {
#line 767
    tmp___45 = strcmp((char const   *)(buffer), ".\n");
    }
#line 767
    if (tmp___45 == 0) {
      {
#line 768
      i = write_to_sock((char *)". \r\n", 3, smtp_fd);
      }
    } else {
      {
#line 770
      tmp___42 = strlen((char const   *)(buffer));
      }
#line 770
      if (tmp___42) {
        {
#line 770
        tmp___43 = strlen((char const   *)(buffer));
        }
#line 770
        if ((int )buffer[tmp___43 - 1U] == 10) {
          {
#line 771
          tmp___41 = strlen((char const   *)(buffer));
#line 771
          i = (int )tmp___41;
#line 772
          buffer[i - 1] = (char )'\r';
#line 773
          buffer[i] = (char )'\n';
#line 774
          buffer[i + 1] = (char)0;
          }
        }
      }
      {
#line 776
      tmp___44 = strlen((char const   *)(buffer));
#line 776
      i = write_to_sock(buffer, (int )tmp___44, smtp_fd);
      }
    }
#line 778
    if (i) {
      {
#line 779
      tmp___46 = gettext("failure while sending data to server");
#line 779
      popup_error_win(tmp___46);
#line 780
      close(smtp_fd);
      }
#line 781
      return (1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 785
  fclose(mail);
#line 787
  tmp___48 = write_to_sock((char *)".\r\n", 2, smtp_fd);
  }
#line 787
  if (tmp___48) {
    {
#line 788
    tmp___47 = gettext("SMTP: mail closing timeout");
#line 788
    popup_error_win(tmp___47);
#line 789
    close(smtp_fd);
    }
#line 790
    return (1);
  }
  {
#line 793
  i = cddb_wait_smtp_code(smtp_fd);
  }
#line 794
  if (i != 2) {
    {
#line 795
    tmp___49 = gettext("error delivering mail");
#line 795
    popup_error_win(tmp___49);
#line 796
    j = 1;
    }
  } else {
    {
#line 798
    write_to_sock((char *)"QUIT\r\n", 5, smtp_fd);
#line 799
    j = 0;
    }
  }
  {
#line 802
  close(smtp_fd);
  }
#line 803
  return (j);
}
}
#line 806 "/home/wslee/benchmarks/sound/mp3c-0.29/src/cddb_put.c"
void cddb_add_rcpt(char ***list , char *entry ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 810
  if (! *list) {
    {
#line 811
    tmp = malloc((size_t )(sizeof(char *) * 2UL));
#line 811
    *list = (char **)tmp;
    }
#line 812
    if (! *list) {
      {
#line 813
      wuuush(1);
      }
    }
    {
#line 815
    *(*list + 0) = copy_char_str(entry);
#line 816
    *(*list + 1) = (char *)((void *)0);
    }
  } else {
#line 818
    i = 0;
    {
#line 819
    while (1) {
      while_continue: /* CIL Label */ ;
#line 819
      if (! *(*list + i)) {
#line 819
        goto while_break;
      }
#line 819
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 821
    tmp___0 = realloc((void *)*list, (size_t )(sizeof(char *) * (unsigned long )(i + 2)));
#line 821
    *list = (char **)tmp___0;
    }
#line 822
    if (! *list) {
      {
#line 823
      wuuush(1);
      }
    }
    {
#line 825
    *(*list + i) = copy_char_str(entry);
#line 826
    *(*list + (i + 1)) = (char *)((void *)0);
    }
  }
#line 828
  return;
}
}
#line 831 "/home/wslee/benchmarks/sound/mp3c-0.29/src/cddb_put.c"
int cddb_submit_cddb_entry(song_typ *song_list ) 
{ 
  char *genre ;
  char discid[9] ;
  char *filename ;
  char *subject ;
  int i ;
  char *serv ;
  char *match ;
  unsigned char replaced ;
  char **rcpt ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  __pid_t tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 842
  if (! song_list) {
    {
#line 843
    tmp = gettext("no CD inserted");
#line 843
    popup_error_win(tmp);
    }
#line 844
    return (1);
  }
#line 847
  if (! config_cddb_enbl) {
    {
#line 848
    tmp___0 = gettext("CDDB access is locked, use \"l\" to unlock");
#line 848
    popup_error_win(tmp___0);
    }
#line 849
    return (1);
  }
  {
#line 853
  tmp___2 = cddb_discid(track_last);
  }
#line 853
  if (tmp___2 == 0UL) {
    {
#line 854
    tmp___1 = gettext("illegal discid");
#line 854
    popup_error_win(tmp___1);
    }
#line 855
    return (1);
  }
  {
#line 857
  tmp___3 = cddb_discid(track_last);
#line 857
  snprintf((char */* __restrict  */)(discid), (size_t )9, (char const   */* __restrict  */)"%08lx",
           tmp___3);
  }
#line 859
  if (def_tmp_file) {
    {
#line 860
    tmp___4 = strlen((char const   *)def_tmp_file);
#line 860
    tmp___5 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___4 + 25U)));
#line 860
    filename = (char *)tmp___5;
    }
#line 861
    if (! filename) {
      {
#line 862
      wuuush(1);
      }
    }
    {
#line 864
    tmp___6 = getpid();
#line 864
    sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s_tmp_%s_%d",
            def_tmp_file, discid, tmp___6);
    }
  } else {
    {
#line 866
    filename = copy_char_str((char *)"/tmp/mp3c_tmp_cddb_entry");
    }
  }
  {
#line 869
  tmp___8 = cddb_create_entry(filename, song_list);
  }
#line 869
  if (tmp___8) {
    {
#line 870
    tmp___7 = gettext("could not create tmpfile with CDDB entry");
#line 870
    popup_error_win(tmp___7);
#line 871
    unlink((char const   *)filename);
#line 872
    free((void *)filename);
    }
#line 873
    return (1);
  }
  {
#line 876
  genre = cddb_select_cddb_genre(def_cddb_server);
  }
#line 877
  if (! genre) {
    {
#line 878
    unlink((char const   *)filename);
#line 879
    free((void *)filename);
    }
#line 880
    return (1);
  }
  {
#line 883
  tmp___9 = strlen((char const   *)genre);
#line 883
  tmp___10 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___9 + 15U)));
#line 883
  subject = (char *)tmp___10;
  }
#line 884
  if (! subject) {
    {
#line 885
    wuuush(1);
    }
  }
  {
#line 888
  sprintf((char */* __restrict  */)subject, (char const   */* __restrict  */)"cddb %s %s",
          genre, discid);
#line 889
  free((void *)genre);
#line 890
  genre = (char *)((void *)0);
#line 892
  serv = def_cddb_email;
#line 893
  rcpt = (char **)((void *)0);
  }
  {
#line 894
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 895
    replaced = (unsigned char)0;
#line 896
    match = strchr((char const   *)serv, ',');
    }
#line 897
    if (match) {
#line 898
      *match = (char)0;
#line 899
      replaced = (unsigned char)1;
    }
    {
#line 901
    cddb_add_rcpt(& rcpt, serv);
    }
#line 902
    if (replaced) {
#line 903
      *match = (char )',';
#line 904
      serv = match + 1;
    }
#line 906
    if (! replaced) {
#line 906
      goto while_break;
    } else
#line 906
    if (! *serv) {
#line 906
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 909
  setup_stat_win(70);
#line 910
  i = cddb_remote_transfer_entry(filename, subject, def_smtp_server, def_my_email,
                                 rcpt, def_cddb_email);
#line 912
  free_char_array(rcpt);
#line 913
  destroy_stat_win();
#line 915
  free((void *)subject);
#line 916
  subject = (char *)((void *)0);
#line 918
  unlink((char const   *)filename);
#line 919
  free((void *)filename);
#line 920
  filename = (char *)((void *)0);
  }
#line 922
  if (i) {
    {
#line 923
    tmp___11 = gettext("transmission failed");
#line 923
    popup_error_win(tmp___11);
    }
  } else {
    {
#line 925
    tmp___12 = gettext("CDDB entry transmitted successfully");
#line 925
    popup_error_win(tmp___12);
#line 926
    cddb_cddb_entry_is_clean = (unsigned char)1;
    }
  }
#line 929
  return (i);
}
}
#line 513 "/usr/include/stdio.h"
extern int fgetc(FILE *__stream ) ;
#line 331 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 113 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncasecmp)(char const   *__s1 ,
                                                                                          char const   *__s2 ,
                                                                                          size_t __n )  __attribute__((__pure__)) ;
#line 71 "/home/wslee/benchmarks/sound/mp3c-0.29/src/cddb_get.c"
unsigned char cddb_cddb_entry_is_clean  =    (unsigned char)0;
#line 72 "/home/wslee/benchmarks/sound/mp3c-0.29/src/cddb_get.c"
int cddb_cddb_entry_revision  =    -1;
#line 74
int cddb_internet_server_lookup(char *addr___0 , char *cddb_path , unsigned char force ) ;
#line 78 "/home/wslee/benchmarks/sound/mp3c-0.29/src/cddb_get.c"
int cddb_local_lookup(char *path , char **cddb_fn ) 
{ 
  char discid[9] ;
  field_select_typ *fs_anchor ;
  field_select_typ *fs_new ;
  char *local_filename ;
  DIR *cddb_dir ;
  struct dirent *de ;
  struct stat st ;
  int found_entries ;
  FILE *cddb_file ;
  char tmp_buf[256] ;
  char *pat ;
  char *tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  void *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  field_select_typ *tmp___23 ;
  size_t tmp___24 ;
  void *tmp___25 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;

  {
  {
#line 92
  tmp___0 = cddb_discid(track_last);
  }
#line 92
  if (tmp___0 == 0UL) {
    {
#line 93
    tmp = gettext("illegal discid");
#line 93
    print_stat_win(tmp);
    }
#line 94
    return (-1);
  }
  {
#line 97
  tmp___1 = cddb_discid(track_last);
#line 97
  snprintf((char */* __restrict  */)(discid), (size_t )9, (char const   */* __restrict  */)"%08lx",
           tmp___1);
#line 99
  tmp___2 = gettext("look in local CDDB");
#line 99
  print_stat_win(tmp___2);
#line 104
  cddb_dir = opendir((char const   *)path);
  }
#line 105
  if ((unsigned long )cddb_dir == (unsigned long )((void *)0)) {
#line 106
    return (-1);
  }
  {
#line 108
  tmp___3 = strlen((char const   *)path);
#line 108
  tmp___4 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___3 + 1U)));
#line 108
  local_filename = (char *)tmp___4;
  }
#line 109
  if ((unsigned long )local_filename == (unsigned long )((void *)0)) {
    {
#line 110
    perror("malloc");
#line 111
    wuuush(1);
    }
  }
#line 114
  found_entries = 0;
#line 115
  fs_anchor = (field_select_typ *)((void *)0);
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 117
    de = readdir(cddb_dir);
    }
#line 117
    if (! ((unsigned long )de != (unsigned long )((void *)0))) {
#line 117
      goto while_break;
    }
    {
#line 118
    tmp___5 = strlen((char const   *)path);
#line 118
    tmp___6 = strlen((char const   *)(de->d_name));
#line 118
    tmp___7 = realloc((void *)local_filename, (size_t )(sizeof(char ) * (unsigned long )((tmp___5 + tmp___6) + 2U)));
#line 118
    local_filename = (char *)tmp___7;
    }
#line 120
    if ((unsigned long )local_filename == (unsigned long )((void *)0)) {
      {
#line 121
      perror("realloc");
#line 122
      wuuush(1);
      }
    }
    {
#line 124
    strcpy((char */* __restrict  */)local_filename, (char const   */* __restrict  */)path);
#line 125
    strcat((char */* __restrict  */)local_filename, (char const   */* __restrict  */)"/");
#line 126
    strcat((char */* __restrict  */)local_filename, (char const   */* __restrict  */)(de->d_name));
#line 128
    tmp___21 = stat((char const   */* __restrict  */)local_filename, (struct stat */* __restrict  */)(& st));
    }
#line 128
    if (tmp___21 == 0) {
#line 128
      if ((st.st_mode & 61440U) == 16384U) {
        {
#line 133
        tmp___8 = strlen((char const   *)local_filename);
#line 133
        tmp___9 = realloc((void *)local_filename, (size_t )(sizeof(char ) * (unsigned long )(tmp___8 + 10U)));
#line 133
        local_filename = (char *)tmp___9;
        }
#line 135
        if ((unsigned long )local_filename == (unsigned long )((void *)0)) {
          {
#line 136
          perror("realloc");
#line 137
          wuuush(1);
          }
        }
        {
#line 140
        strcat((char */* __restrict  */)local_filename, (char const   */* __restrict  */)"/");
#line 141
        strcat((char */* __restrict  */)local_filename, (char const   */* __restrict  */)(discid));
#line 143
        tmp___20 = access((char const   *)local_filename, 4);
        }
#line 143
        if (tmp___20 == 0) {
          {
#line 144
          tmp___10 = malloc((size_t )sizeof(field_select_typ ));
#line 144
          fs_new = (field_select_typ *)tmp___10;
          }
#line 145
          if ((unsigned long )fs_new == (unsigned long )((void *)0)) {
            {
#line 146
            perror("malloc");
#line 147
            wuuush(1);
            }
          }
#line 149
          fs_new->information = local_filename;
#line 150
          fs_new->dest = (char *)((void *)0);
#line 151
          fs_new->next = fs_anchor;
#line 152
          fs_new->prev = (struct _field_select_typ *)((void *)0);
#line 153
          if (fs_anchor) {
#line 153
            fs_anchor->prev = fs_new;
          }
          {
#line 154
          fs_anchor = fs_new;
#line 156
          cddb_file = fopen((char const   */* __restrict  */)local_filename, (char const   */* __restrict  */)"r");
          }
#line 163
          if ((unsigned long )cddb_file != (unsigned long )((void *)0)) {
            {
#line 164
            tmp___11 = strlen((char const   *)(de->d_name));
#line 164
            tmp___12 = malloc((size_t )(sizeof(char ) * (unsigned long )tmp___11 + 2UL));
#line 164
            local_filename = (char *)tmp___12;
            }
#line 166
            if ((unsigned long )local_filename == (unsigned long )((void *)0)) {
              {
#line 167
              perror("malloc");
#line 168
              wuuush(1);
              }
            }
            {
#line 170
            strcpy((char */* __restrict  */)local_filename, (char const   */* __restrict  */)(de->d_name));
#line 171
            strcat((char */* __restrict  */)local_filename, (char const   */* __restrict  */)" ");
            }
            {
#line 172
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 173
              fgets((char */* __restrict  */)(tmp_buf), 254, (FILE */* __restrict  */)cddb_file);
#line 174
              tmp___13 = feof(cddb_file);
              }
#line 174
              if (tmp___13) {
#line 174
                goto while_break___0;
              }
              {
#line 175
              tmp___17 = strncmp((char const   *)(tmp_buf), "DTITLE=", (size_t )7);
              }
#line 175
              if (tmp___17 == 0) {
                {
#line 176
                pat = strchr((char const   *)(tmp_buf), '\n');
                }
#line 177
                if (pat) {
#line 177
                  *pat = (char)0;
                }
                {
#line 178
                pat = strchr((char const   *)(tmp_buf), '\r');
                }
#line 179
                if (pat) {
#line 179
                  *pat = (char)0;
                }
                {
#line 180
                tmp___14 = strlen((char const   *)local_filename);
#line 180
                tmp___15 = strlen((char const   *)(tmp_buf));
#line 180
                tmp___16 = realloc((void *)local_filename, (size_t )(sizeof(char ) * (unsigned long )(tmp___14 + tmp___15)));
#line 180
                local_filename = (char *)tmp___16;
                }
#line 183
                if ((unsigned long )local_filename == (unsigned long )((void *)0)) {
                  {
#line 184
                  perror("realloc");
#line 185
                  wuuush(1);
                  }
                }
                {
#line 188
                strcat((char */* __restrict  */)local_filename, (char const   */* __restrict  */)"\"");
#line 189
                strcat((char */* __restrict  */)local_filename, (char const   */* __restrict  */)(tmp_buf + 7));
#line 190
                strcat((char */* __restrict  */)local_filename, (char const   */* __restrict  */)"\"");
                }
              }
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 193
            fclose(cddb_file);
            }
          }
          {
#line 195
          fs_new->field = local_filename;
#line 196
          found_entries ++;
#line 202
          tmp___18 = strlen((char const   *)path);
#line 202
          tmp___19 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___18 + 1U)));
#line 202
          local_filename = (char *)tmp___19;
          }
#line 203
          if ((unsigned long )local_filename == (unsigned long )((void *)0)) {
            {
#line 204
            perror("malloc");
#line 205
            wuuush(1);
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 210
  closedir(cddb_dir);
#line 212
  free((void *)local_filename);
  }
#line 214
  if (found_entries == 0) {
    {
#line 215
    free_field_select(& fs_anchor);
    }
#line 216
    return (1);
  }
#line 219
  if (found_entries > 1) {
    {
#line 220
    tmp___22 = gettext("select entry");
#line 220
    tmp___23 = select_field_box(fs_anchor, 70, tmp___22, (unsigned char)0, (unsigned char)0);
#line 220
    fs_new = tmp___23;
    }
#line 221
    if ((unsigned long )fs_new == (unsigned long )((void *)0)) {
#line 221
      fs_new = fs_anchor;
    }
  } else {
#line 222
    fs_new = fs_anchor;
  }
  {
#line 224
  tmp___24 = strlen((char const   *)fs_new->information);
#line 224
  tmp___25 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___24 + 1U)));
#line 224
  local_filename = (char *)tmp___25;
  }
#line 226
  if ((unsigned long )local_filename == (unsigned long )((void *)0)) {
    {
#line 227
    perror("malloc");
#line 228
    wuuush(1);
    }
  }
  {
#line 230
  strcpy((char */* __restrict  */)local_filename, (char const   */* __restrict  */)fs_new->information);
#line 232
  *cddb_fn = local_filename;
#line 233
  free_field_select(& fs_anchor);
  }
#line 234
  return (0);
}
}
#line 240 "/home/wslee/benchmarks/sound/mp3c-0.29/src/cddb_get.c"
int cddb_internet_lookup(char *addr___0 , char *cddb_path , unsigned char force ) 
{ 
  char *serv ;
  char *match ;
  unsigned char replaced ;
  int status ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 246
  if (! addr___0) {
    {
#line 247
    tmp = gettext("no hostaddress specified");
#line 247
    popup_error_win(tmp);
    }
#line 248
    return (-1);
  }
  {
#line 251
  tmp___1 = strcmp((char const   *)addr___0, "0");
  }
#line 251
  if (tmp___1 == 0) {
    {
#line 252
    tmp___0 = gettext("remote cddb disabled");
#line 252
    print_stat_win(tmp___0);
    }
#line 253
    return (-1);
  }
#line 256
  if (! cddb_path) {
    {
#line 257
    tmp___2 = gettext("no local cddb-database specified");
#line 257
    popup_error_win(tmp___2);
    }
#line 258
    return (-1);
  }
  {
#line 261
  tmp___4 = access((char const   *)cddb_path, 0);
  }
#line 261
  if (tmp___4) {
    {
#line 262
    tmp___3 = gettext("no cddb-path, try to create");
#line 262
    print_stat_win(tmp___3);
#line 263
    create_sub_dirs(cddb_path, (unsigned char)0);
    }
  }
  {
#line 265
  tmp___6 = access((char const   *)cddb_path, 0);
  }
#line 265
  if (tmp___6) {
    {
#line 266
    tmp___5 = gettext("Uh, cannot receive entries without valid CDDB-path.");
#line 266
    popup_error_win(tmp___5);
    }
#line 267
    return (-1);
  }
  {
#line 269
  tmp___8 = access((char const   *)cddb_path, 2);
  }
#line 269
  if (tmp___8) {
    {
#line 270
    tmp___7 = gettext("STOP! No write permissions for CDDB-directory. <EMERGENCY ABORT>");
#line 270
    popup_error_win(tmp___7);
    }
#line 271
    return (-1);
  }
#line 274
  if (! config_cddb_enbl) {
#line 274
    if (! force) {
      {
#line 275
      tmp___9 = gettext("CDDB access is locked, use \"l\" to unlock");
#line 275
      popup_error_win(tmp___9);
      }
#line 276
      return (-1);
    }
  }
#line 279
  serv = addr___0;
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 281
    replaced = (unsigned char)0;
#line 282
    match = strchr((char const   *)serv, ',');
    }
#line 283
    if (match) {
#line 284
      *match = (char)0;
#line 285
      replaced = (unsigned char)1;
    }
    {
#line 287
    print_stat_win(serv);
#line 288
    status = cddb_internet_server_lookup(serv, cddb_path, force);
    }
#line 289
    if (replaced) {
#line 290
      *match = (char )',';
#line 291
      serv = match + 1;
    }
#line 294
    if (! status) {
#line 294
      goto while_break;
    } else
#line 294
    if (! replaced) {
#line 294
      goto while_break;
    } else
#line 294
    if (! *serv) {
#line 294
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  return (0);
}
}
#line 303 "/home/wslee/benchmarks/sound/mp3c-0.29/src/cddb_get.c"
int cddb_open_cddbp(char *addr___0 ) 
{ 
  int cddb_fd ;
  char *buf ;
  char *tmp_str ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  char *tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
#line 308
  if (! addr___0) {
#line 308
    return (-1);
  }
  {
#line 309
  tmp = gettext("connect to cddb-server");
#line 309
  print_stat_win(tmp);
#line 310
  cddb_fd = open_socket((char const   *)addr___0);
  }
#line 311
  if (cddb_fd == -1) {
#line 311
    return (-1);
  }
  {
#line 318
  tmp___0 = gettext("waiting for greeting");
#line 318
  print_stat_win(tmp___0);
  }
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 320
    tmp___1 = read_from_sock(& buf, cddb_fd, (unsigned char)1);
    }
#line 320
    if (tmp___1 != 0) {
      {
#line 324
      close(cddb_fd);
      }
#line 325
      return (-1);
    }
    {
#line 327
    tmp___2 = strncmp((char const   *)buf, "20", (size_t )2);
    }
#line 327
    if (tmp___2 == 0) {
#line 327
      goto while_break;
    }
    {
#line 328
    tmp___3 = strncmp((char const   *)buf, "4", (size_t )1);
    }
#line 328
    if (tmp___3 == 0) {
#line 328
      goto while_break;
    }
    {
#line 329
    free((void *)buf);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 334
  if ((int )*buf == 52) {
    {
#line 335
    tmp___4 = gettext("too many users, try later");
#line 335
    print_stat_win(tmp___4);
#line 336
    sleep(1U);
#line 337
    close(cddb_fd);
#line 338
    free((void *)buf);
    }
#line 339
    return (-1);
  }
  {
#line 341
  tmp_str = getenv("LOGNAME");
  }
#line 342
  if (! tmp_str) {
    {
#line 343
    tmp_str = getlogin();
    }
  }
#line 345
  if (! tmp_str) {
    {
#line 346
    tmp___5 = malloc((size_t )(sizeof(char ) * 17UL));
#line 346
    buf = (char *)tmp___5;
    }
  } else {
    {
#line 348
    tmp___6 = strlen((char const   *)tmp_str);
#line 348
    tmp___7 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___6 + 12U)));
#line 348
    buf = (char *)tmp___7;
    }
  }
#line 350
  if (! buf) {
    {
#line 351
    perror("malloc");
#line 352
    wuuush(1);
    }
  }
  {
#line 355
  strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)"cddb hello ");
  }
#line 356
  if ((unsigned long )tmp_str == (unsigned long )((void *)0)) {
    {
#line 356
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"WSPse");
    }
  } else {
    {
#line 357
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)tmp_str);
    }
  }
  {
#line 359
  tmp_str = getenv("HOSTNAME");
  }
#line 360
  if ((unsigned long )tmp_str == (unsigned long )((void *)0)) {
    {
#line 361
    tmp___8 = strlen((char const   *)buf);
#line 361
    tmp___9 = strlen("0.29");
#line 361
    tmp___10 = realloc((void *)buf, (size_t )(sizeof(char ) * (unsigned long )((tmp___8 + 28U) + tmp___9)));
#line 361
    buf = (char *)tmp___10;
    }
  } else {
    {
#line 364
    tmp___11 = strlen((char const   *)buf);
#line 364
    tmp___12 = strlen("0.29");
#line 364
    tmp___13 = strlen((char const   *)tmp_str);
#line 364
    tmp___14 = realloc((void *)buf, (size_t )(sizeof(char ) * (unsigned long )(((tmp___11 + 21U) + tmp___12) + tmp___13)));
#line 364
    buf = (char *)tmp___14;
    }
  }
#line 368
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 369
    perror("malloc");
#line 370
    wuuush(1);
    }
  }
  {
#line 373
  strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)" ");
  }
#line 374
  if ((unsigned long )tmp_str == (unsigned long )((void *)0)) {
    {
#line 374
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"unknown");
    }
  } else {
    {
#line 375
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)tmp_str);
    }
  }
  {
#line 377
  strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)" WSPse-MP3creat V0.29\r\n");
#line 378
  tmp___15 = gettext("saying hello to cddb-server");
#line 378
  print_stat_win(tmp___15);
#line 383
  tmp___16 = strlen((char const   *)buf);
#line 383
  tmp___17 = write_to_sock(buf, (int )tmp___16, cddb_fd);
  }
#line 383
  if (tmp___17 != 0) {
    {
#line 387
    close(cddb_fd);
#line 388
    free((void *)buf);
    }
#line 389
    return (-1);
  }
  {
#line 391
  free((void *)buf);
#line 393
  tmp___18 = read_from_sock(& buf, cddb_fd, (unsigned char)1);
  }
#line 393
  if (tmp___18 != 0) {
    {
#line 394
    close(cddb_fd);
    }
#line 395
    return (-1);
  }
#line 400
  if ((int )*(buf + 0) != 50) {
    {
#line 401
    tmp_str = strchr((char const   *)buf, '\n');
    }
#line 402
    if (tmp_str) {
#line 402
      *tmp_str = (char)0;
    }
    {
#line 403
    popup_error_win(buf);
#line 404
    free((void *)buf);
#line 405
    close(cddb_fd);
    }
#line 406
    return (-1);
  }
  {
#line 408
  free((void *)buf);
  }
#line 410
  return (cddb_fd);
}
}
#line 414 "/home/wslee/benchmarks/sound/mp3c-0.29/src/cddb_get.c"
int cddb_internet_server_lookup(char *addr___0 , char *cddb_path , unsigned char force ) 
{ 
  int cddb_fd ;
  char *buf ;
  char *tmp_str ;
  int i ;
  int j ;
  field_select_typ *cat_anchor ;
  field_select_typ *cat_new ;
  FILE *cddb_file ;
  FILE *sec_file ;
  struct stat st ;
  char cd_discid[9] ;
  void *tmp ;
  unsigned long tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  void *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  void *tmp___18 ;
  size_t tmp___19 ;
  void *tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  void *tmp___23 ;
  size_t tmp___24 ;
  void *tmp___25 ;
  int tmp___26 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  size_t tmp___29 ;
  char *tmp___30 ;
  size_t tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  char *tmp___34 ;
  int tmp___35 ;
  size_t tmp___36 ;
  void *tmp___37 ;
  size_t tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  char *tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  void *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;

  {
  {
#line 425
  cddb_fd = cddb_open_cddbp(addr___0);
  }
#line 426
  if (cddb_fd < 0) {
#line 426
    return (cddb_fd);
  }
  {
#line 430
  tmp = malloc((size_t )(sizeof(char ) * (unsigned long )(7 * (track_last + 1)) + 23UL));
#line 430
  buf = (char *)tmp;
  }
#line 431
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 432
    perror("malloc");
#line 433
    wuuush(1);
    }
  }
  {
#line 435
  tmp___0 = cddb_discid(track_last);
#line 435
  snprintf((char */* __restrict  */)(cd_discid), (size_t )9, (char const   */* __restrict  */)"%08lx",
           tmp___0);
#line 436
  sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"cddb query %8s %d",
          cd_discid, track_last);
#line 438
  tmp___1 = malloc((size_t )(sizeof(char ) * 7UL));
#line 438
  tmp_str = (char *)tmp___1;
  }
#line 439
  if ((unsigned long )tmp_str == (unsigned long )((void *)0)) {
    {
#line 440
    perror("malloc");
#line 441
    wuuush(1);
    }
  }
#line 443
  i = 0;
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 443
    if (! (i < track_last)) {
#line 443
      goto while_break;
    }
    {
#line 444
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)" ");
#line 445
    sprintf((char */* __restrict  */)tmp_str, (char const   */* __restrict  */)"%d",
            cdtoc[i].frame + 75 * (cdtoc[i].sec + 60 * cdtoc[i].min));
#line 447
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)tmp_str);
#line 443
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 449
  sprintf((char */* __restrict  */)tmp_str, (char const   */* __restrict  */)"%d",
          cdtoc[track_last].sec + 60 * cdtoc[i].min);
#line 450
  strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)" ");
#line 451
  strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)tmp_str);
#line 452
  free((void *)tmp_str);
#line 456
  strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"\r\n");
#line 457
  tmp___2 = gettext("query category of cd");
#line 457
  print_stat_win(tmp___2);
#line 462
  tmp___3 = strlen((char const   *)buf);
#line 462
  tmp___4 = write_to_sock(buf, (int )tmp___3, cddb_fd);
  }
#line 462
  if (tmp___4 != 0) {
    {
#line 466
    close(cddb_fd);
#line 467
    free((void *)buf);
    }
#line 468
    return (-1);
  }
  {
#line 470
  free((void *)buf);
#line 472
  tmp___5 = read_from_sock(& buf, cddb_fd, (unsigned char)1);
  }
#line 472
  if (tmp___5 != 0) {
    {
#line 473
    close(cddb_fd);
    }
#line 474
    return (-1);
  }
#line 480
  if ((int )*(buf + 0) != 50) {
#line 480
    goto _L;
  } else
#line 480
  if ((int )*(buf + 2) == 50) {
    _L: /* CIL Label */ 
    {
#line 481
    free((void *)buf);
#line 482
    tmp___6 = gettext("not found...");
#line 482
    print_stat_win(tmp___6);
#line 483
    write_to_sock((char *)"quit\r\n", 6, cddb_fd);
#line 484
    tmp___7 = read_from_sock(& buf, cddb_fd, (unsigned char)1);
    }
#line 484
    if (tmp___7 == 0) {
      {
#line 488
      free((void *)buf);
      }
    }
    {
#line 490
    close(cddb_fd);
    }
#line 491
    return (1);
  }
#line 500
  if ((int )*(buf + 1) == 48) {
    {
#line 501
    tmp___8 = gettext("found exact match");
#line 501
    print_stat_win(tmp___8);
#line 502
    tmp___9 = malloc((size_t )sizeof(field_select_typ ));
#line 502
    cat_anchor = (field_select_typ *)tmp___9;
    }
#line 503
    if ((unsigned long )cat_anchor == (unsigned long )((void *)0)) {
      {
#line 504
      perror("malloc");
#line 505
      wuuush(1);
      }
    }
#line 507
    cat_anchor->next = (struct _field_select_typ *)((void *)0);
#line 508
    cat_anchor->dest = (char *)((void *)0);
#line 509
    i = 0;
    {
#line 509
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 509
      tmp___10 = strlen((char const   *)buf);
      }
#line 509
      if (! ((size_t )i < tmp___10)) {
#line 509
        goto while_break___0;
      }
#line 509
      if ((int )*(buf + i) == 32) {
#line 509
        goto while_break___0;
      }
#line 509
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 510
    j = i + 1;
    {
#line 510
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 510
      tmp___11 = strlen((char const   *)buf);
      }
#line 510
      if (! ((size_t )j < tmp___11)) {
#line 510
        goto while_break___1;
      }
#line 510
      if ((int )*(buf + j) == 32) {
#line 510
        goto while_break___1;
      }
#line 510
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 511
    tmp___12 = malloc((size_t )(sizeof(char ) * (unsigned long )(j - i)));
#line 511
    tmp_str = (char *)tmp___12;
    }
#line 512
    if ((unsigned long )tmp_str == (unsigned long )((void *)0)) {
      {
#line 513
      perror("malloc");
#line 514
      wuuush(1);
      }
    }
    {
#line 516
    memcpy((void */* __restrict  */)tmp_str, (void const   */* __restrict  */)((buf + i) + 1),
           (size_t )((j - i) - 1));
#line 517
    *((tmp_str + (j - i)) - 1) = (char)0;
#line 518
    cat_anchor->field = tmp_str;
#line 520
    tmp___13 = strlen((char const   *)cddb_path);
#line 520
    tmp___14 = strlen((char const   *)cat_anchor->field);
#line 520
    tmp___15 = malloc((size_t )(sizeof(char ) * (unsigned long )((tmp___13 + tmp___14) + 11U)));
#line 520
    tmp_str = (char *)tmp___15;
    }
#line 523
    if ((unsigned long )tmp_str == (unsigned long )((void *)0)) {
      {
#line 524
      perror("malloc");
#line 525
      wuuush(1);
      }
    }
    {
#line 528
    *((buf + j) + 9) = (char)0;
#line 529
    sprintf((char */* __restrict  */)tmp_str, (char const   */* __restrict  */)"%s/%s/%8s",
            cddb_path, cat_anchor->field, (buf + j) + 1);
#line 530
    free((void *)buf);
#line 531
    cat_anchor->information = tmp_str;
    }
  } else {
    {
#line 534
    tmp___16 = gettext("serveral matches for cd");
#line 534
    print_stat_win(tmp___16);
#line 535
    cat_anchor = (field_select_typ *)((void *)0);
#line 536
    free((void *)buf);
    }
    {
#line 537
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 538
      tmp___17 = read_from_sock(& buf, cddb_fd, (unsigned char)1);
      }
#line 538
      if (tmp___17 != 0) {
        {
#line 542
        close(cddb_fd);
        }
#line 543
        return (-1);
      }
#line 545
      if ((int )*(buf + 0) == 46) {
        {
#line 546
        free((void *)buf);
        }
#line 547
        goto while_break___2;
      }
      {
#line 552
      tmp___18 = malloc((size_t )sizeof(field_select_typ ));
#line 552
      cat_new = (field_select_typ *)tmp___18;
      }
#line 553
      if ((unsigned long )cat_new == (unsigned long )((void *)0)) {
        {
#line 554
        perror("malloc");
#line 555
        wuuush(1);
        }
      }
#line 557
      cat_new->dest = (char *)((void *)0);
#line 559
      i = 0;
      {
#line 559
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 559
        tmp___19 = strlen((char const   *)buf);
        }
#line 559
        if (! ((size_t )i < tmp___19)) {
#line 559
          goto while_break___3;
        }
#line 559
        if ((int )*(buf + i) == 32) {
#line 559
          goto while_break___3;
        }
#line 559
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 560
      tmp___20 = malloc((size_t )(sizeof(char ) * (unsigned long )(i + 1)));
#line 560
      tmp_str = (char *)tmp___20;
      }
#line 561
      if ((unsigned long )tmp_str == (unsigned long )((void *)0)) {
        {
#line 562
        perror("malloc");
#line 563
        wuuush(1);
        }
      }
      {
#line 565
      memcpy((void */* __restrict  */)tmp_str, (void const   */* __restrict  */)buf,
             (size_t )i);
#line 566
      *(tmp_str + i) = (char)0;
#line 567
      cat_new->field = tmp_str;
#line 569
      tmp___21 = strlen((char const   *)cddb_path);
#line 569
      tmp___22 = strlen((char const   *)cat_new->field);
#line 569
      tmp___23 = malloc((size_t )(sizeof(char ) * (unsigned long )((tmp___21 + tmp___22) + 11U)));
#line 569
      tmp_str = (char *)tmp___23;
      }
#line 572
      if ((unsigned long )tmp_str == (unsigned long )((void *)0)) {
        {
#line 573
        perror("malloc");
#line 574
        wuuush(1);
        }
      }
      {
#line 577
      *((buf + i) + 9) = (char)0;
#line 578
      sprintf((char */* __restrict  */)tmp_str, (char const   */* __restrict  */)"%s/%s/%8s",
              cddb_path, cat_new->field, (buf + i) + 1);
#line 579
      free((void *)buf);
#line 580
      cat_new->information = tmp_str;
#line 584
      cat_new->next = cat_anchor;
#line 585
      cat_anchor = cat_new;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 593
  cat_new = cat_anchor;
  {
#line 594
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 594
    if (! ((unsigned long )cat_new != (unsigned long )((void *)0))) {
#line 594
      goto while_break___4;
    }
    {
#line 595
    tmp___24 = strlen((char const   *)cat_new->information);
#line 595
    i = (int )(tmp___24 - 1U);
    }
    {
#line 595
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 595
      if (! (i >= 0)) {
#line 595
        goto while_break___5;
      }
#line 596
      if ((int )*(cat_new->information + i) == 47) {
#line 596
        goto while_break___5;
      }
#line 595
      i --;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 597
    tmp___25 = malloc((size_t )(sizeof(char ) * (unsigned long )(i + 1)));
#line 597
    tmp_str = (char *)tmp___25;
    }
#line 598
    if ((unsigned long )tmp_str == (unsigned long )((void *)0)) {
      {
#line 599
      perror("malloc");
#line 600
      wuuush(1);
      }
    }
    {
#line 602
    memcpy((void */* __restrict  */)tmp_str, (void const   */* __restrict  */)cat_new->information,
           (size_t )i);
#line 603
    *(tmp_str + i) = (char)0;
#line 604
    tmp___26 = access((char const   *)tmp_str, 0);
    }
#line 604
    if (tmp___26 != 0) {
      {
#line 606
      mkdir((char const   *)tmp_str, (__mode_t )511);
      }
    }
    {
#line 608
    tmp___44 = stat((char const   */* __restrict  */)tmp_str, (struct stat */* __restrict  */)(& st));
    }
#line 608
    if (tmp___44 != 0) {
      {
#line 612
      free((void *)tmp_str);
      }
    } else
#line 613
    if (! ((st.st_mode & 61440U) == 16384U)) {
      {
#line 617
      free((void *)tmp_str);
      }
    } else {
      {
#line 619
      free((void *)tmp_str);
#line 620
      tmp___43 = access((char const   *)cat_new->information, 0);
      }
#line 620
      if (tmp___43 == 0) {
#line 620
        if (! (! force)) {
#line 620
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        {
#line 625
        cddb_file = fopen((char const   */* __restrict  */)cat_new->information, (char const   */* __restrict  */)"w");
        }
#line 626
        if (! ((unsigned long )cddb_file == (unsigned long )((void *)0))) {
          {
#line 632
          tmp___27 = strlen((char const   *)cat_new->field);
#line 632
          tmp___28 = malloc((size_t )(sizeof(char ) * (unsigned long )(30U + tmp___27)));
#line 632
          tmp_str = (char *)tmp___28;
          }
#line 634
          if ((unsigned long )tmp_str == (unsigned long )((void *)0)) {
            {
#line 635
            perror("malloc");
#line 636
            wuuush(1);
            }
          }
          {
#line 638
          tmp___29 = strlen((char const   *)cat_new->information);
#line 638
          sprintf((char */* __restrict  */)tmp_str, (char const   */* __restrict  */)"cddb read %s %8s\r\n",
                  cat_new->field, cat_new->information + (tmp___29 - 8U));
#line 640
          tmp___30 = gettext("send request for data transfer");
#line 640
          print_stat_win(tmp___30);
#line 644
          tmp___31 = strlen((char const   *)tmp_str);
#line 644
          tmp___32 = write_to_sock(tmp_str, (int )tmp___31, cddb_fd);
          }
#line 644
          if (tmp___32 != 0) {
            {
#line 648
            free((void *)tmp_str);
#line 649
            fclose(cddb_file);
#line 650
            unlink((char const   *)cat_new->information);
#line 651
            free_field_select(& cat_anchor);
            }
#line 655
            return (-1);
          }
          {
#line 657
          free((void *)tmp_str);
#line 658
          tmp___33 = read_from_sock(& tmp_str, cddb_fd, (unsigned char)1);
          }
#line 658
          if (tmp___33 != 0) {
            {
#line 662
            fclose(cddb_file);
#line 663
            unlink((char const   *)cat_new->information);
#line 664
            free_field_select(& cat_anchor);
            }
#line 665
            return (-1);
          }
          {
#line 667
          tmp___42 = strncmp((char const   *)tmp_str, "210", (size_t )3);
          }
#line 667
          if (tmp___42 != 0) {
            {
#line 673
            free((void *)tmp_str);
#line 674
            fclose(cddb_file);
#line 675
            unlink((char const   *)cat_new->information);
            }
          } else {
            {
#line 677
            tmp___34 = gettext("receiving CDDB entry");
#line 677
            print_stat_win(tmp___34);
            }
            {
#line 678
            while (1) {
              while_continue___6: /* CIL Label */ ;
              {
#line 679
              tmp___35 = read_from_sock(& tmp_str, cddb_fd, (unsigned char)1);
              }
#line 679
              if (tmp___35 != 0) {
                {
#line 684
                fclose(cddb_file);
#line 685
                unlink((char const   *)cat_new->information);
#line 686
                free_field_select(& cat_anchor);
                }
#line 688
                return (-1);
              }
#line 690
              if ((int )*(tmp_str + 0) == 46) {
#line 690
                goto while_break___6;
              }
              {
#line 691
              fputs((char const   */* __restrict  */)tmp_str, (FILE */* __restrict  */)cddb_file);
#line 692
              free((void *)tmp_str);
              }
            }
            while_break___6: /* CIL Label */ ;
            }
            {
#line 694
            free((void *)tmp_str);
#line 695
            fclose(cddb_file);
#line 696
            tmp___36 = strlen((char const   *)cat_new->information);
#line 696
            tmp___37 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___36 + 1U)));
#line 696
            tmp_str = (char *)tmp___37;
            }
#line 698
            if ((unsigned long )tmp_str == (unsigned long )((void *)0)) {
              {
#line 699
              perror("malloc");
#line 700
              wuuush(1);
              }
            }
            {
#line 702
            strcpy((char */* __restrict  */)tmp_str, (char const   */* __restrict  */)cat_new->information);
#line 703
            tmp___38 = strlen((char const   *)tmp_str);
#line 703
            memcpy((void */* __restrict  */)((tmp_str + tmp___38) - 8), (void const   */* __restrict  */)(cd_discid),
                   (size_t )8);
#line 704
            tmp___40 = strcmp((char const   *)tmp_str, (char const   *)cat_new->information);
            }
#line 704
            if (tmp___40 != 0) {
              {
#line 704
              tmp___41 = access((char const   *)tmp_str, 0);
              }
#line 704
              if (tmp___41 != 0) {
#line 704
                goto _L___0;
              } else
#line 704
              if (force) {
                _L___0: /* CIL Label */ 
                {
#line 706
                cddb_file = fopen((char const   */* __restrict  */)cat_new->information,
                                  (char const   */* __restrict  */)"r");
                }
#line 707
                if ((unsigned long )cddb_file != (unsigned long )((void *)0)) {
                  {
#line 708
                  sec_file = fopen((char const   */* __restrict  */)tmp_str, (char const   */* __restrict  */)"w");
                  }
#line 709
                  if ((unsigned long )sec_file != (unsigned long )((void *)0)) {
                    {
#line 710
                    while (1) {
                      while_continue___7: /* CIL Label */ ;
                      {
#line 711
                      i = fgetc(cddb_file);
#line 712
                      tmp___39 = feof(cddb_file);
                      }
#line 712
                      if (tmp___39) {
#line 712
                        goto while_break___7;
                      }
                      {
#line 713
                      fputc(i, sec_file);
                      }
                    }
                    while_break___7: /* CIL Label */ ;
                    }
                    {
#line 715
                    fclose(sec_file);
                    }
                  }
                  {
#line 717
                  fclose(cddb_file);
                  }
                }
              }
            }
            {
#line 720
            free((void *)tmp_str);
            }
          }
        }
      }
    }
#line 725
    cat_new = cat_new->next;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 728
  free_field_select(& cat_anchor);
#line 731
  tmp___45 = gettext("closing connection");
#line 731
  print_stat_win(tmp___45);
#line 732
  tmp___47 = write_to_sock((char *)"quit\r\n", 6, cddb_fd);
  }
#line 732
  if (tmp___47 == 0) {
    {
#line 733
    tmp___46 = read_from_sock(& buf, cddb_fd, (unsigned char)1);
    }
#line 733
    if (tmp___46 == 0) {
      {
#line 737
      free((void *)buf);
      }
    }
  }
  {
#line 740
  close(cddb_fd);
  }
#line 742
  return (0);
}
}
#line 751 "/home/wslee/benchmarks/sound/mp3c-0.29/src/cddb_get.c"
int lookup_track_data(int track , int cddb_fd , song_typ **ret_struct , unsigned char force_sampler ) 
{ 
  int i ;
  int j ;
  song_typ *new_song ;
  char *buf ;
  char *album ;
  char *title ;
  char *extented ;
  char pattern[10] ;
  char pattern2[8] ;
  void *tmp ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  void *tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  void *tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;
  int tmp___31 ;
  size_t tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  size_t tmp___37 ;
  size_t tmp___38 ;
  size_t tmp___39 ;
  void *tmp___40 ;
  size_t tmp___41 ;
  size_t tmp___42 ;
  void *tmp___43 ;
  void *tmp___44 ;
  size_t tmp___45 ;
  size_t tmp___46 ;
  size_t tmp___47 ;
  size_t tmp___48 ;
  size_t tmp___49 ;
  void *tmp___50 ;
  size_t tmp___51 ;
  size_t tmp___52 ;
  void *tmp___53 ;
  size_t tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  void *__cil_tmp77 ;
  void *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;

  {
  {
#line 761
  lseek(cddb_fd, 0L, 0);
#line 763
  tmp = malloc((size_t )sizeof(song_typ ));
#line 763
  new_song = (song_typ *)tmp;
  }
#line 764
  if ((unsigned long )new_song == (unsigned long )((void *)0)) {
    {
#line 765
    perror("malloc");
#line 766
    wuuush(1);
    }
  }
  {
#line 769
  new_song->next = (struct _song_typ *)((void *)0);
#line 770
  new_song->prev = (struct _song_typ *)((void *)0);
#line 771
  new_song->convert = (unsigned char)1;
#line 772
  new_song->on_fly = def_on_fly;
#line 773
  new_song->year = 1999;
#line 774
  new_song->genre = 147;
#line 775
  tmp___0 = cddb_discid(track_last);
#line 775
  new_song->cddb_id = (long )tmp___0;
#line 776
  new_song->tmp_wav_file = (char *)((void *)0);
#line 777
  new_song->sampler = (unsigned char)0;
#line 779
  tmp___1 = strlen((char const   *)def_comment);
#line 779
  tmp___2 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___1 + 1U)));
#line 779
  new_song->comment = (char *)tmp___2;
  }
#line 780
  if ((unsigned long )new_song->comment == (unsigned long )((void *)0)) {
    {
#line 781
    perror("malloc");
#line 782
    wuuush(1);
    }
  }
  {
#line 784
  strcpy((char */* __restrict  */)new_song->comment, (char const   */* __restrict  */)def_comment);
#line 786
  tmp___3 = malloc((size_t )sizeof(char ));
#line 786
  album = (char *)tmp___3;
#line 787
  tmp___4 = malloc((size_t )sizeof(char ));
#line 787
  title = (char *)tmp___4;
#line 788
  tmp___5 = malloc((size_t )sizeof(char ));
#line 788
  extented = (char *)tmp___5;
  }
#line 789
  if ((unsigned long )album == (unsigned long )((void *)0)) {
    {
#line 790
    perror("malloc");
#line 791
    wuuush(1);
    }
  } else
#line 789
  if ((unsigned long )title == (unsigned long )((void *)0)) {
    {
#line 790
    perror("malloc");
#line 791
    wuuush(1);
    }
  } else
#line 789
  if ((unsigned long )extented == (unsigned long )((void *)0)) {
    {
#line 790
    perror("malloc");
#line 791
    wuuush(1);
    }
  }
  {
#line 793
  *album = (char)0;
#line 794
  *title = (char)0;
#line 795
  *extented = (char)0;
#line 796
  sprintf((char */* __restrict  */)(pattern), (char const   */* __restrict  */)"TTITLE%d=",
          track - 1);
#line 797
  sprintf((char */* __restrict  */)(pattern2), (char const   */* __restrict  */)"EXTT%d=",
          track - 1);
  }
  {
#line 799
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 800
    tmp___6 = read_from_sock(& buf, cddb_fd, (unsigned char)0);
    }
#line 800
    if (tmp___6 != 0) {
#line 800
      goto while_break;
    }
    {
#line 801
    tmp___8 = strlen((char const   *)buf);
    }
#line 801
    if ((int )*((buf + tmp___8) - 1) == 10) {
      {
#line 802
      tmp___7 = strlen((char const   *)buf);
#line 802
      *((buf + tmp___7) - 1) = (char)0;
      }
    } else {
      {
#line 801
      tmp___9 = strlen((char const   *)buf);
      }
#line 801
      if ((int )*((buf + tmp___9) - 1) == 13) {
        {
#line 802
        tmp___7 = strlen((char const   *)buf);
#line 802
        *((buf + tmp___7) - 1) = (char)0;
        }
      }
    }
    {
#line 803
    tmp___11 = strlen((char const   *)buf);
    }
#line 803
    if ((int )*((buf + tmp___11) - 1) == 10) {
      {
#line 803
      tmp___10 = strlen((char const   *)buf);
#line 803
      *((buf + tmp___10) - 1) = (char)0;
      }
    } else {
      {
#line 803
      tmp___12 = strlen((char const   *)buf);
      }
#line 803
      if ((int )*((buf + tmp___12) - 1) == 13) {
        {
#line 803
        tmp___10 = strlen((char const   *)buf);
#line 803
        *((buf + tmp___10) - 1) = (char)0;
        }
      }
    }
    {
#line 804
    tmp___36 = strncmp((char const   *)buf, "# Generated: ", (size_t )13);
    }
#line 804
    if (tmp___36 == 0) {
#line 805
      j = 0;
#line 806
      i = 13;
      {
#line 806
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 806
        tmp___13 = strlen((char const   *)buf);
        }
#line 806
        if (! ((size_t )i < tmp___13)) {
#line 806
          goto while_break___0;
        }
#line 807
        if ((int )*(buf + i) == 32) {
#line 807
          j ++;
        }
#line 808
        if (j == 4) {
#line 808
          goto while_break___0;
        }
#line 806
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 810
      i ++;
#line 811
      tmp___16 = strlen((char const   *)buf);
      }
#line 811
      if (tmp___16 - (size_t )i >= 4U) {
        {
#line 812
        tmp___14 = strlen((char const   *)buf);
        }
#line 812
        if (tmp___14 - (size_t )i > 4U) {
#line 812
          if ((int )*((buf + i) + 4) == 32) {
#line 812
            *((buf + i) + 4) = (char)0;
          }
        }
        {
#line 813
        tmp___15 = strlen((char const   *)buf);
        }
#line 813
        if (tmp___15 - (size_t )i == 4U) {
#line 814
          j = 0;
          {
#line 814
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 814
            if (! (j < 4)) {
#line 814
              goto while_break___1;
            }
#line 815
            if ((int )*((buf + i) + j) < 48) {
#line 815
              goto while_break___1;
            } else
#line 815
            if ((int )*((buf + i) + j) > 57) {
#line 815
              goto while_break___1;
            }
#line 814
            j ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 817
          if (j == 4) {
            {
#line 818
            new_song->year = atoi((char const   *)(buf + i));
            }
          }
        }
      }
    } else {
      {
#line 825
      tmp___35 = strncmp((char const   *)buf, "# Revision: ", (size_t )12);
      }
#line 825
      if (tmp___35 == 0) {
        {
#line 826
        cddb_cddb_entry_revision = atoi((char const   *)(buf + 12));
        }
#line 827
        if (cddb_cddb_entry_revision < 0) {
#line 828
          cddb_cddb_entry_revision = 0;
        }
      } else {
        {
#line 830
        tmp___34 = strncmp((char const   *)buf, "DTITLE=", (size_t )7);
        }
#line 830
        if (tmp___34 == 0) {
          {
#line 831
          tmp___17 = strlen((char const   *)album);
#line 831
          tmp___18 = strlen((char const   *)(buf + 6));
#line 831
          tmp___19 = realloc((void *)album, (size_t )(sizeof(char ) * (unsigned long )(tmp___17 + tmp___18)));
#line 831
          album = (char *)tmp___19;
          }
#line 833
          if ((unsigned long )album == (unsigned long )((void *)0)) {
            {
#line 834
            perror("realloc");
#line 835
            wuuush(1);
            }
          }
          {
#line 837
          strcat((char */* __restrict  */)album, (char const   */* __restrict  */)(buf + 7));
          }
        } else {
          {
#line 838
          tmp___32 = strlen((char const   *)(pattern));
#line 838
          tmp___33 = strncmp((char const   *)buf, (char const   *)(pattern), tmp___32);
          }
#line 838
          if (tmp___33 == 0) {
            {
#line 839
            tmp___20 = strlen((char const   *)title);
#line 839
            tmp___21 = strlen((char const   *)(pattern));
#line 839
            tmp___22 = strlen((char const   *)(buf + tmp___21));
#line 839
            tmp___23 = realloc((void *)title, (size_t )(sizeof(char ) * (unsigned long )((tmp___20 + tmp___22) + 1U)));
#line 839
            title = (char *)tmp___23;
            }
#line 841
            if ((unsigned long )title == (unsigned long )((void *)0)) {
              {
#line 842
              perror("realloc");
#line 843
              wuuush(1);
              }
            }
            {
#line 845
            tmp___24 = strlen((char const   *)(pattern));
#line 845
            strcat((char */* __restrict  */)title, (char const   */* __restrict  */)(buf + tmp___24));
            }
          } else {
            {
#line 846
            tmp___30 = strlen((char const   *)(pattern2));
#line 846
            tmp___31 = strncmp((char const   *)buf, (char const   *)(pattern2), tmp___30);
            }
#line 846
            if (tmp___31 == 0) {
              {
#line 847
              tmp___25 = strlen((char const   *)extented);
#line 847
              tmp___26 = strlen((char const   *)(pattern2));
#line 847
              tmp___27 = strlen((char const   *)(buf + tmp___26));
#line 847
              tmp___28 = realloc((void *)extented, (size_t )(sizeof(char ) * (unsigned long )((tmp___25 + tmp___27) + 1U)));
#line 847
              extented = (char *)tmp___28;
              }
#line 849
              if ((unsigned long )extented == (unsigned long )((void *)0)) {
                {
#line 850
                perror("realloc");
#line 851
                wuuush(1);
                }
              }
              {
#line 853
              tmp___29 = strlen((char const   *)(pattern2));
#line 853
              strcat((char */* __restrict  */)extented, (char const   */* __restrict  */)(buf + tmp___29));
              }
            }
          }
        }
      }
    }
    {
#line 855
    free((void *)buf);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 857
  new_song->title = title;
#line 861
  j = 0;
#line 862
  i = 0;
  {
#line 862
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 862
    tmp___38 = strlen((char const   *)album);
    }
#line 862
    if (! ((size_t )i < tmp___38)) {
#line 862
      goto while_break___2;
    }
#line 863
    if ((int )*(album + i) == 47) {
#line 864
      if (i > 0) {
        {
#line 864
        tmp___37 = strlen((char const   *)album);
        }
#line 864
        if ((size_t )i < tmp___37 - 1U) {
#line 864
          if ((int )*((album + i) - 1) == 32) {
#line 864
            if ((int )*((album + i) + 1) == 32) {
#line 865
              j = i;
            }
          }
        }
      }
    }
#line 862
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 869
  if (j == 0) {
#line 870
    i = 0;
    {
#line 870
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 870
      tmp___39 = strlen((char const   *)album);
      }
#line 870
      if (! ((size_t )i < tmp___39)) {
#line 870
        goto while_break___3;
      }
#line 870
      if ((int )*(album + i) == 47) {
#line 870
        goto while_break___3;
      }
#line 870
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else {
#line 872
    i = j;
  }
#line 874
  if (i > 0) {
    {
#line 874
    tmp___45 = strlen((char const   *)album);
    }
#line 874
    if ((size_t )i < tmp___45) {
#line 875
      j = i - 1;
      {
#line 875
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 875
        if (! (j >= 0)) {
#line 875
          goto while_break___4;
        }
#line 875
        if ((int )*(album + j) != 32) {
#line 875
          goto while_break___4;
        }
#line 875
        j --;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 876
      tmp___40 = malloc((size_t )(sizeof(char ) * (unsigned long )(j + 2)));
#line 876
      buf = (char *)tmp___40;
      }
#line 877
      if ((unsigned long )buf == (unsigned long )((void *)0)) {
        {
#line 878
        perror("malloc");
#line 879
        wuuush(1);
        }
      }
      {
#line 881
      memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)album,
             (size_t )(j + 1));
#line 882
      *((buf + j) + 1) = (char)0;
#line 883
      new_song->artist = buf;
#line 885
      j = i + 1;
      }
      {
#line 885
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 885
        tmp___41 = strlen((char const   *)album);
        }
#line 885
        if (! ((size_t )j < tmp___41)) {
#line 885
          goto while_break___5;
        }
#line 885
        if ((int )*(album + j) != 32) {
#line 885
          goto while_break___5;
        }
#line 885
        j ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 886
      tmp___42 = strlen((char const   *)(album + j));
#line 886
      tmp___43 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___42 + 1U)));
#line 886
      buf = (char *)tmp___43;
      }
#line 887
      if ((unsigned long )buf == (unsigned long )((void *)0)) {
        {
#line 888
        perror("malloc");
#line 889
        wuuush(1);
        }
      }
      {
#line 891
      strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)(album + j));
#line 892
      new_song->album = buf;
#line 893
      free((void *)album);
      }
    } else {
#line 874
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 895
    new_song->album = album;
#line 896
    tmp___44 = malloc((size_t )(sizeof(char ) * 8UL));
#line 896
    new_song->artist = (char *)tmp___44;
    }
#line 897
    if ((unsigned long )new_song->artist == (unsigned long )((void *)0)) {
      {
#line 898
      perror("malloc");
#line 899
      wuuush(1);
      }
    }
    {
#line 901
    strcpy((char */* __restrict  */)new_song->artist, (char const   */* __restrict  */)"unknown");
    }
  }
  {
#line 913
  tmp___55 = strncasecmp((char const   *)new_song->artist, "various", (size_t )7);
  }
#line 913
  if (tmp___55 == 0) {
#line 913
    goto _L___0;
  } else {
    {
#line 913
    tmp___56 = strncasecmp((char const   *)new_song->artist, "compilation", (size_t )11);
    }
#line 913
    if (tmp___56 == 0) {
#line 913
      goto _L___0;
    } else {
      {
#line 913
      tmp___57 = strncasecmp((char const   *)new_song->artist, "varios", (size_t )6);
      }
#line 913
      if (tmp___57 == 0) {
#line 913
        goto _L___0;
      } else {
        {
#line 913
        tmp___58 = strncasecmp((char const   *)new_song->artist, "sampler", (size_t )7);
        }
#line 913
        if (tmp___58 == 0) {
#line 913
          goto _L___0;
        } else {
          {
#line 913
          tmp___59 = strncasecmp((char const   *)new_song->artist, "divers", (size_t )6);
          }
#line 913
          if (tmp___59 == 0) {
#line 913
            goto _L___0;
          } else {
            {
#line 913
            tmp___60 = strncasecmp((char const   *)new_song->artist, "v.a.", (size_t )4);
            }
#line 913
            if (tmp___60 == 0) {
#line 913
              goto _L___0;
            } else {
              {
#line 913
              tmp___61 = strncasecmp((char const   *)new_song->artist, "misc", (size_t )4);
              }
#line 913
              if (tmp___61 == 0) {
#line 913
                goto _L___0;
              } else
#line 913
              if (force_sampler) {
                _L___0: /* CIL Label */ 
                {
#line 924
                new_song->sampler = (unsigned char)1;
#line 926
                tmp___46 = strlen((char const   *)extented);
                }
#line 926
                if (tmp___46 > 0U) {
#line 927
                  new_song->artist = extented;
#line 928
                  extented = (char *)((void *)0);
                }
#line 930
                i = 0;
                {
#line 930
                while (1) {
                  while_continue___6: /* CIL Label */ ;
                  {
#line 930
                  tmp___48 = strlen((char const   *)new_song->title);
                  }
#line 930
                  if (! ((size_t )i < tmp___48)) {
#line 930
                    goto while_break___6;
                  }
#line 931
                  if ((int )*(new_song->title + i) == 47) {
#line 934
                    goto while_break___6;
                  } else
#line 931
                  if ((int )*(new_song->title + i) == 45) {
#line 934
                    goto while_break___6;
                  } else
#line 931
                  if ((int )*(new_song->title + i) == 40) {
                    {
#line 931
                    tmp___47 = strlen((char const   *)new_song->title);
                    }
#line 931
                    if ((int )*((new_song->title + tmp___47) - 1) == 41) {
#line 934
                      goto while_break___6;
                    }
                  }
#line 930
                  i ++;
                }
                while_break___6: /* CIL Label */ ;
                }
#line 936
                if (i > 0) {
                  {
#line 936
                  tmp___54 = strlen((char const   *)new_song->title);
                  }
#line 936
                  if ((size_t )i < tmp___54) {
#line 937
                    if ((int )*(new_song->title + i) == 40) {
                      {
#line 938
                      tmp___49 = strlen((char const   *)new_song->title);
#line 938
                      *((new_song->title + tmp___49) - 1) = (char)0;
                      }
                    }
#line 939
                    j = i - 1;
                    {
#line 939
                    while (1) {
                      while_continue___7: /* CIL Label */ ;
#line 939
                      if (! (j >= 0)) {
#line 939
                        goto while_break___7;
                      }
#line 939
                      if ((int )*(new_song->title + j) != 32) {
#line 939
                        goto while_break___7;
                      }
#line 939
                      j --;
                    }
                    while_break___7: /* CIL Label */ ;
                    }
                    {
#line 940
                    tmp___50 = malloc((size_t )(sizeof(char ) * (unsigned long )(j + 2)));
#line 940
                    buf = (char *)tmp___50;
                    }
#line 941
                    if ((unsigned long )buf == (unsigned long )((void *)0)) {
                      {
#line 942
                      perror("malloc");
#line 943
                      wuuush(1);
                      }
                    }
                    {
#line 945
                    memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)new_song->title,
                           (size_t )(j + 1));
#line 946
                    *((buf + j) + 1) = (char)0;
#line 947
                    free((void *)new_song->artist);
#line 948
                    new_song->artist = buf;
#line 950
                    j = i + 1;
                    }
                    {
#line 950
                    while (1) {
                      while_continue___8: /* CIL Label */ ;
                      {
#line 950
                      tmp___51 = strlen((char const   *)new_song->title);
                      }
#line 950
                      if (! ((size_t )j < tmp___51)) {
#line 950
                        goto while_break___8;
                      }
#line 950
                      if ((int )*(new_song->title + j) != 32) {
#line 951
                        goto while_break___8;
                      }
#line 950
                      j ++;
                    }
                    while_break___8: /* CIL Label */ ;
                    }
                    {
#line 952
                    tmp___52 = strlen((char const   *)(new_song->title + j));
#line 952
                    tmp___53 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___52 + 1U)));
#line 952
                    buf = (char *)tmp___53;
                    }
#line 953
                    if ((unsigned long )buf == (unsigned long )((void *)0)) {
                      {
#line 954
                      perror("malloc");
#line 955
                      wuuush(1);
                      }
                    }
                    {
#line 957
                    strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)(new_song->title + j));
#line 958
                    free((void *)new_song->title);
#line 959
                    new_song->title = buf;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 967
  if (extented) {
    {
#line 967
    free((void *)extented);
    }
  }
#line 968
  *ret_struct = new_song;
#line 969
  return (0);
}
}
#line 976 "/home/wslee/benchmarks/sound/mp3c-0.29/src/cddb_get.c"
int build_data_tree(char *cddb_server , char *local_cddb_db , song_typ **ret_tree ,
                    unsigned char force_sampler ) 
{ 
  char *cddb_file ;
  song_typ *new ;
  song_typ *anchor ;
  song_typ *curr ;
  int i ;
  int j ;
  int cddb_fd ;
  int genre ;
  char *buf ;
  void *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 986
  setup_stat_win(50);
#line 987
  print_stat_win((char *)"lookup CDDB entry");
#line 989
  cddb_cddb_entry_is_clean = (unsigned char)0;
#line 990
  cddb_cddb_entry_revision = -1;
#line 992
  anchor = (song_typ *)((void *)0);
#line 993
  curr = (song_typ *)((void *)0);
#line 996
  tmp___2 = cddb_local_lookup(local_cddb_db, & cddb_file);
  }
#line 996
  if (tmp___2 != 0) {
#line 998
    if (cddb_server) {
      {
#line 998
      cddb_internet_lookup(cddb_server, local_cddb_db, (unsigned char)0);
      }
    }
    {
#line 1000
    tmp___1 = cddb_local_lookup(local_cddb_db, & cddb_file);
    }
#line 1000
    if (tmp___1 != 0) {
#line 1002
      i = 0;
      {
#line 1002
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1002
        if (! (i < track_last)) {
#line 1002
          goto while_break;
        }
        {
#line 1003
        tmp = malloc((size_t )sizeof(song_typ ));
#line 1003
        new = (song_typ *)tmp;
        }
#line 1004
        if ((unsigned long )new == (unsigned long )((void *)0)) {
          {
#line 1005
          perror("malloc");
#line 1006
          wuuush(1);
          }
        }
        {
#line 1008
        new->convert = (unsigned char)1;
#line 1009
        new->artist = copy_char_str((char *)"unknown");
#line 1010
        new->title = copy_char_str((char *)"unknown");
#line 1011
        new->album = copy_char_str((char *)"unknown");
#line 1012
        new->comment = copy_char_str(def_comment);
#line 1013
        new->dirname = copy_char_str(def_mp3_dir);
#line 1014
        new->year = 1999;
#line 1015
        new->genre = 147;
#line 1016
        new->on_fly = def_on_fly;
#line 1017
        new->toc = (char )i;
#line 1018
        new->fn_auto = (unsigned char)1;
#line 1019
        new->filename = (char *)((void *)0);
#line 1020
        tmp___0 = cddb_discid(track_last);
#line 1020
        new->cddb_id = (long )tmp___0;
#line 1021
        new->frame_len = (long )((cdtoc[i + 1].frame + 75 * (60 * cdtoc[i + 1].min + cdtoc[i + 1].sec)) - (cdtoc[i].frame + 75 * (60 * cdtoc[i].min + cdtoc[i].sec)));
#line 1023
        new->tmp_wav_file = (char *)((void *)0);
#line 1024
        new->sampler = force_sampler;
#line 1025
        filenm_generate(new);
#line 1027
        new->next = (struct _song_typ *)((void *)0);
#line 1028
        new->prev = curr;
        }
#line 1029
        if (curr) {
#line 1029
          curr->next = new;
        }
#line 1030
        if (! anchor) {
#line 1030
          anchor = new;
        }
#line 1031
        curr = new;
#line 1002
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1033
      *ret_tree = anchor;
#line 1034
      destroy_stat_win();
      }
#line 1035
      return (0);
    }
  }
  {
#line 1040
  tmp___3 = strlen((char const   *)cddb_file);
#line 1040
  i = (int )(tmp___3 - 1U);
  }
  {
#line 1040
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1040
    if (! (i >= 0)) {
#line 1040
      goto while_break___0;
    }
#line 1040
    if ((int )*(cddb_file + i) == 47) {
#line 1040
      goto while_break___0;
    }
#line 1040
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1041
  j = i - 1;
  {
#line 1041
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1041
    if (! (j >= 0)) {
#line 1041
      goto while_break___1;
    }
#line 1041
    if ((int )*(cddb_file + j) == 47) {
#line 1041
      goto while_break___1;
    }
#line 1041
    j --;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1042
  tmp___4 = malloc((size_t )(sizeof(char ) * (unsigned long )(i - j)));
#line 1042
  buf = (char *)tmp___4;
  }
#line 1043
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 1044
    perror("malloc");
#line 1045
    wuuush(1);
    }
  }
  {
#line 1047
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)((cddb_file + j) + 1),
         (size_t )(i - j));
#line 1048
  *((buf + (i - j)) - 1) = (char)0;
#line 1052
  i = 0;
  }
  {
#line 1052
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1052
    if (! (i < 147)) {
#line 1052
      goto while_break___2;
    }
    {
#line 1052
    tmp___5 = strcasecmp((char const   *)mp3_genre[i], (char const   *)buf);
    }
#line 1052
    if (tmp___5 == 0) {
#line 1052
      goto while_break___2;
    }
#line 1052
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1056
  free((void *)buf);
#line 1057
  genre = i;
#line 1059
  cddb_fd = open((char const   *)cddb_file, 0);
#line 1060
  cddb_cddb_entry_is_clean = (unsigned char)1;
#line 1061
  i = 1;
  }
  {
#line 1061
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1061
    if (! (i <= track_last)) {
#line 1061
      goto while_break___3;
    }
    {
#line 1062
    lookup_track_data(i, cddb_fd, & new, force_sampler);
    }
#line 1063
    if (! new) {
      {
#line 1064
      tmp___6 = malloc((size_t )sizeof(song_typ ));
#line 1064
      new = (song_typ *)tmp___6;
      }
#line 1065
      if ((unsigned long )new == (unsigned long )((void *)0)) {
        {
#line 1066
        perror("malloc");
#line 1067
        wuuush(1);
        }
      }
#line 1069
      new->convert = (unsigned char)1;
#line 1070
      new->year = 1999;
#line 1071
      new->on_fly = def_on_fly;
#line 1072
      new->sampler = force_sampler;
    }
#line 1074
    if (! new->artist) {
      {
#line 1075
      new->artist = copy_char_str((char *)"unknown");
      }
    }
#line 1077
    if (! new->title) {
      {
#line 1078
      new->title = copy_char_str((char *)"unknown");
      }
    }
#line 1080
    if (! new->album) {
      {
#line 1081
      new->album = copy_char_str((char *)"unknown");
      }
    }
#line 1083
    if (! new->comment) {
      {
#line 1084
      new->comment = copy_char_str(def_comment);
      }
    }
    {
#line 1086
    new->dirname = copy_char_str(def_mp3_dir);
#line 1088
    new->genre = genre;
#line 1089
    new->toc = (char )(i - 1);
#line 1090
    new->fn_auto = (unsigned char)1;
#line 1091
    new->filename = (char *)((void *)0);
#line 1092
    new->frame_len = (long )((cdtoc[i].frame + 75 * (60 * cdtoc[i].min + cdtoc[i].sec)) - (cdtoc[i - 1].frame + 75 * (60 * cdtoc[i - 1].min + cdtoc[i - 1].sec)));
#line 1094
    new->tmp_wav_file = (char *)((void *)0);
#line 1095
    filenm_generate(new);
#line 1097
    new->next = (struct _song_typ *)((void *)0);
#line 1098
    new->prev = curr;
    }
#line 1099
    if ((unsigned long )curr != (unsigned long )((void *)0)) {
#line 1099
      curr->next = new;
    }
#line 1100
    if ((unsigned long )anchor == (unsigned long )((void *)0)) {
#line 1100
      anchor = new;
    }
#line 1101
    curr = new;
#line 1061
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1104
  close(cddb_fd);
#line 1105
  *ret_tree = anchor;
#line 1106
  destroy_stat_win();
  }
#line 1107
  return (0);
}
}
#line 284 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chmod)(char const   *__file ,
                                                                                  __mode_t __mode ) ;
#line 75 "/home/wslee/benchmarks/sound/mp3c-0.29/src/batch.c"
unsigned char careful_batch  ;
#line 76 "/home/wslee/benchmarks/sound/mp3c-0.29/src/batch.c"
char *batch_alt_tmp_file  ;
#line 84 "/home/wslee/benchmarks/sound/mp3c-0.29/src/batch.c"
char *batch_set_shell_escapes(char *input ) 
{ 
  char *output ;
  char escaped[5] ;
  int len ;
  int i ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 91
  if (! input) {
#line 91
    return ((char *)((void *)0));
  }
  {
#line 92
  tmp = strlen((char const   *)input);
#line 92
  len = (int )(tmp + 1U);
#line 93
  tmp___0 = malloc((size_t )(sizeof(char ) * (unsigned long )len));
#line 93
  output = (char *)tmp___0;
  }
#line 94
  if (! output) {
    {
#line 95
    wuuush(1);
    }
  }
#line 98
  *output = (char )'\000';
#line 99
  i = 0;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 99
    tmp___3 = strlen((char const   *)input);
    }
#line 99
    if (! ((size_t )i < tmp___3)) {
#line 99
      goto while_break;
    }
#line 100
    escaped[0] = *(input + i);
#line 101
    escaped[1] = (char )'\000';
    {
#line 106
    if ((int )*(input + i) == 96) {
#line 106
      goto case_96;
    }
#line 102
    goto switch_break;
    case_96: /* CIL Label */ 
    {
#line 107
    strcpy((char */* __restrict  */)(escaped), (char const   */* __restrict  */)"\\`");
    }
#line 108
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 110
    if ((int )escaped[1] == 0) {
      {
#line 111
      strcat((char */* __restrict  */)output, (char const   */* __restrict  */)(escaped));
      }
    } else {
      {
#line 113
      tmp___1 = strlen((char const   *)(escaped));
#line 113
      len = (int )((size_t )len + (tmp___1 - 1U));
#line 114
      tmp___2 = realloc((void *)output, (size_t )(sizeof(char ) * (unsigned long )len));
#line 114
      output = (char *)tmp___2;
      }
#line 115
      if (! output) {
        {
#line 116
        wuuush(1);
        }
      }
      {
#line 118
      strcat((char */* __restrict  */)output, (char const   */* __restrict  */)(escaped));
      }
    }
#line 99
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  return (output);
}
}
#line 125 "/home/wslee/benchmarks/sound/mp3c-0.29/src/batch.c"
char *batch_create_sub_string(song_typ *track , int mode ) 
{ 
  char *input ;
  char *output ;

  {
  {
#line 130
  input = create_sub_string(track, mode);
  }
#line 131
  if (! input) {
#line 131
    return ((char *)((void *)0));
  }
  {
#line 133
  output = batch_set_shell_escapes(input);
#line 134
  free((void *)input);
  }
#line 136
  return (output);
}
}
#line 139 "/home/wslee/benchmarks/sound/mp3c-0.29/src/batch.c"
int batch_task_single_rip(song_typ *track , FILE *script ) 
{ 
  char *cmd_line ;
  char *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 143
  fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"#--- Batchtask: ripping track %d-----------------------------------\n",
          (int )track->toc + 1);
#line 144
  tmp = return_track_tmpname(track);
#line 144
  cmd_line = extract_dirname(tmp);
  }
#line 145
  if (cmd_line) {
    {
#line 146
    fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"mkdir -p \"%s\"\t\t\t\t\t\t# So, we need tmpdir, eh\n",
            cmd_line);
#line 147
    free((void *)cmd_line);
    }
  }
  {
#line 149
  fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"if [ $verbose ]; then echo \"ripping track %d in progress\"; fi;\n",
          (int )track->toc + 1);
#line 150
  cmd_line = batch_create_sub_string(track, 3);
  }
#line 151
  if (cmd_line) {
    {
#line 152
    fputs((char const   */* __restrict  */)cmd_line, (FILE */* __restrict  */)script);
#line 153
    fputs((char const   */* __restrict  */)" 1> $dev1 2> $dev2 \t# Grabprogram\n",
          (FILE */* __restrict  */)script);
#line 154
    free((void *)cmd_line);
    }
  } else {
#line 156
    return (1);
  }
  {
#line 158
  fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"if [ ! \"$?\" = \"0\" ]; then\n  echo \"ripping track %d failed, abort now\"\n  exit 1\nfi\nif [ $verbose ]; then echo \"track %d ripped.\"; fi;\n\n",
          (int )track->toc + 1, (int )track->toc + 1);
  }
#line 165
  return (0);
}
}
#line 168 "/home/wslee/benchmarks/sound/mp3c-0.29/src/batch.c"
int batch_task_single_enc(song_typ *track , FILE *script ) 
{ 
  char *cmd_line ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 172
  fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"#--- Batchtask: encoding track %d----------------------------------\n",
          (int )track->toc + 1);
#line 173
  tmp = build_mp3_filenm(track);
#line 173
  cmd_line = extract_dirname(tmp);
  }
#line 174
  if (cmd_line) {
    {
#line 175
    fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"mkdir -p \"%s\"\t\t\t\t\t\t# MP3-destination dir\n",
            cmd_line);
#line 176
    free((void *)cmd_line);
    }
  }
  {
#line 178
  fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"if [ $verbose ]; then echo \"encoding track %d in progress\"; fi;\n",
          (int )track->toc + 1);
#line 179
  cmd_line = batch_create_sub_string(track, 1);
  }
#line 180
  if (cmd_line) {
    {
#line 181
    fputs((char const   */* __restrict  */)cmd_line, (FILE */* __restrict  */)script);
#line 182
    fputs((char const   */* __restrict  */)" 1> $dev1 2> $dev2\t# Encoder\n", (FILE */* __restrict  */)script);
#line 183
    free((void *)cmd_line);
    }
  } else {
#line 185
    return (1);
  }
  {
#line 187
  tmp___0 = return_track_tmpname(track);
#line 187
  fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"if [ \"$?\" != \"0\" ]; then\n  echo \"encoding track %d failed, abort now\"\n  exit 1\nfi\nrm -f \"%s\"\t\t# delete tempfile\nif [ $verbose ]; then echo \"track %d encoded.\"; fi;\n\n",
          (int )track->toc + 1, tmp___0, (int )track->toc + 1);
  }
#line 195
  return (0);
}
}
#line 198 "/home/wslee/benchmarks/sound/mp3c-0.29/src/batch.c"
int batch_task_rip_and_enc(song_typ *track , FILE *script ) 
{ 
  char *cmd_line ;
  char *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 202
  fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"#--- Batchtask: ripping and encoding track %d (on the fly)---------\n",
          (int )track->toc + 1);
#line 203
  tmp = build_mp3_filenm(track);
#line 203
  cmd_line = extract_dirname(tmp);
  }
#line 204
  if (cmd_line) {
    {
#line 205
    fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"mkdir -p \"%s\"\t\t\t\t\t\t# MP3-destination dir\n",
            cmd_line);
#line 206
    free((void *)cmd_line);
    }
  }
  {
#line 208
  fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"if [ $verbose ]; then echo \"on the fly creation of track %d in progress\"; fi;\n",
          (int )track->toc + 1);
#line 209
  cmd_line = batch_create_sub_string(track, 4);
  }
#line 210
  if (cmd_line) {
    {
#line 211
    fputs((char const   */* __restrict  */)cmd_line, (FILE */* __restrict  */)script);
#line 212
    free((void *)cmd_line);
#line 213
    cmd_line = batch_create_sub_string(track, 2);
    }
#line 214
    if (cmd_line) {
      {
#line 215
      fputs((char const   */* __restrict  */)" 2> $dev2 | ", (FILE */* __restrict  */)script);
#line 216
      fputs((char const   */* __restrict  */)cmd_line, (FILE */* __restrict  */)script);
#line 217
      free((void *)cmd_line);
#line 218
      fputs((char const   */* __restrict  */)" 1> $dev1 2> $dev2\n", (FILE */* __restrict  */)script);
      }
    } else {
#line 220
      return (1);
    }
  } else {
#line 223
    return (1);
  }
  {
#line 225
  fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"if [ \"$?\" != \"0\" ]; then\n  echo \"encoding track %d failed, abort now\"\n  exit 1\nfi\nif [ $verbose ]; then echo \"track %d encoded.\"; fi;\n\n",
          (int )track->toc + 1, (int )track->toc + 1);
  }
#line 232
  return (0);
}
}
#line 235 "/home/wslee/benchmarks/sound/mp3c-0.29/src/batch.c"
int batch_task_set_tag(song_typ *track , FILE *script ) 
{ 
  char *cmd_line ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 239
  if (def_mp3_info) {
    {
#line 239
    tmp = strcmp((char const   *)def_mp3_info, "0");
    }
#line 239
    if (tmp == 0) {
      {
#line 240
      fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"true\n");
      }
#line 241
      return (0);
    }
  }
  {
#line 244
  fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"#--- Batchtask: set mp3-tags for track %d--------------------------\n",
          (int )track->toc + 1);
#line 245
  fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"if [ $verbose ]; then echo \"setting tags for track %d\"; fi;\n",
          (int )track->toc + 1);
#line 246
  cmd_line = batch_create_sub_string(track, 5);
  }
#line 247
  if (cmd_line) {
    {
#line 248
    fputs((char const   */* __restrict  */)cmd_line, (FILE */* __restrict  */)script);
#line 249
    fputs((char const   */* __restrict  */)" 1> $dev1 2> $dev2\t# ID-Tagprg\n", (FILE */* __restrict  */)script);
#line 250
    free((void *)cmd_line);
    }
  } else {
#line 252
    return (1);
  }
  {
#line 254
  fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"if [ \"$?\" != \"0\" ]; then\n  echo \"setting of tags for track %d failed, abort now\"\n  exit 1\nfi\nif [ $verbose ]; then echo \"track %d ready.\"; fi;\n\n",
          (int )track->toc + 1, (int )track->toc + 1);
  }
#line 261
  return (0);
}
}
#line 264 "/home/wslee/benchmarks/sound/mp3c-0.29/src/batch.c"
int batch_task_update_m3u(song_typ *track , FILE *script ) 
{ 
  char *cmd_line ;
  char *dir_name ;
  char *file_name ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 270
  file_name = build_m3u_fname(track);
  }
#line 271
  if (! file_name) {
    {
#line 272
    fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"true\n");
    }
#line 273
    return (0);
  }
  {
#line 276
  fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"#--- Batchtask: insert track %d into m3u-file----------------------\n",
          (int )track->toc + 1);
#line 277
  cmd_line = batch_set_shell_escapes(file_name);
  }
#line 278
  if (file_name) {
    {
#line 279
    free((void *)file_name);
#line 280
    file_name = (char *)((void *)0);
    }
  }
#line 282
  if (cmd_line) {
    {
#line 283
    tmp = build_mp3_filenm(track);
#line 283
    file_name = batch_set_shell_escapes(tmp);
#line 284
    fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"if test -e \"%s\"; then\t# if mp3-file exists\n",
            file_name);
    }
#line 285
    if (file_name) {
      {
#line 286
      free((void *)file_name);
#line 287
      file_name = (char *)((void *)0);
      }
    }
    {
#line 289
    dir_name = extract_dirname(cmd_line);
    }
#line 290
    if (dir_name) {
      {
#line 291
      fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"  mkdir -p \"%s\"\t\t# directory for m3u-file\n",
              dir_name);
#line 292
      free((void *)dir_name);
      }
    }
    {
#line 294
    tmp___0 = file_build_m3u_entry(track);
#line 294
    file_name = batch_set_shell_escapes(tmp___0);
#line 295
    fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"  echo \"%s\" >> \"%s\"\nelse\n  echo \"warning, new mp3-file wasn\'t found\"\nfi\n",
            file_name, cmd_line);
    }
#line 300
    if (file_name) {
      {
#line 301
      free((void *)file_name);
#line 302
      file_name = (char *)((void *)0);
      }
    }
    {
#line 304
    free((void *)cmd_line);
    }
  } else {
#line 306
    return (1);
  }
  {
#line 308
  fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"if [ $verbose ]; then echo \"m3u-list updated.\"; fi;\n\n");
  }
#line 310
  return (0);
}
}
#line 315 "/home/wslee/benchmarks/sound/mp3c-0.29/src/batch.c"
int batch_task_output_header(song_typ *track , FILE *script ) 
{ 
  int mode ;
  int order ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 320
  if (rip_enc_ordered) {
#line 321
    order = 1;
  } else {
#line 323
    order = 0;
  }
#line 326
  if (def_on_fly) {
#line 327
    mode = 4;
  } else {
#line 329
    mode = 3;
  }
  {
#line 332
  fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"#!/bin/sh\n# Batchfile for encoding CD %08lX to MP3\n# Album \"%s\"\n\n# Generated by WSPse\'s MP3c V0.29 (Batch V1.1b)\n\ndev1=/dev/stdout\t# show STDOUT messages\ndev2=/dev/null\t\t# ignore STDERR stream\nunset verbose\t\t# reduce output by this script\nmode=%d\t\t\t# rip and encode\norder=%d\t\t\t# rip tracks before encode\n\nwhile [ \"$1\" != \"\" ]; do\n  case $1 in\n    -1) mode=1;;\n    -2) mode=2;;\n    -3) mode=4;;\n    -a) mode=3\n        if [ \"$2\" = \"0\" ]; then order=0; shift;\n        elif [ \"$2\" = \"1\" ]; then order=1; shift;\n        fi;;\n    -v) verbose=1;;\n    -O) dev1=/dev/null;;\n    -o) dev1=/dev/stdout;;\n    -E) dev2=/dev/null;;\n    -e) dev2=/dev/stderr;;\n    -V) cat <<EOF\n\nScript for %08lX, V1.1b\nGenerated by WSPse\'s MP3c V0.29\nEOF\n        exit 0;;\n    -h) cat <<EOF\n\nAvailable options for this script:\n-1: rip tracks only and exit\n-2: only encode (tracks must be already ripped for this)\n-3: create mp3\'s on the fly",
          track->cddb_id, track->album, mode, order, track->cddb_id);
  }
#line 364
  if (def_on_fly) {
    {
#line 365
    fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)" (default)");
    }
  }
  {
#line 368
  fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"\n-a <order>: rip and encode by <order>");
  }
#line 369
  if (! def_on_fly) {
    {
#line 370
    fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)" (default)");
    }
  }
  {
#line 373
  fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"\n  order = 0: encode track directly after ripping");
  }
#line 374
  if (! rip_enc_ordered) {
    {
#line 375
    fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)" (default)");
    }
  }
  {
#line 378
  fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"\n  order = 1: first rip all tracks and then start encoding");
  }
#line 379
  if (rip_enc_ordered) {
    {
#line 380
    fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)" (default)");
    }
  }
  {
#line 383
  fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"\n-v: activate verbose mode\n-O: disable STDOUT from external programs\n-o: enable STDOUT (default)\n-E: disable STDERR (default)\n-e: enable STDERR\n-V: show script-version information\n-h: this help\nEOF\n        exit 0;;\n    *) echo \"unkown option \'$1\' (try -h for help)\"\n       exit 1;;\n  esac\n  shift\ndone\n\n");
  }
#line 398
  return (0);
}
}
#line 404 "/home/wslee/benchmarks/sound/mp3c-0.29/src/batch.c"
int output_batch(song_typ *anchor , char *filenm , unsigned char ask_overwrite ) 
{ 
  FILE *script ;
  song_typ *curr ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned char tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 409
  tmp___3 = access((char const   *)filenm, 0);
  }
#line 409
  if (tmp___3 == 0) {
    {
#line 411
    tmp___0 = access((char const   *)filenm, 2);
    }
#line 411
    if (tmp___0 != 0) {
#line 412
      if (ask_overwrite) {
        {
#line 412
        tmp = gettext("script already exists, and isn\'t writeable");
#line 412
        popup_error_win(tmp);
        }
      }
#line 413
      return (1);
    }
#line 417
    if (ask_overwrite) {
      {
#line 418
      tmp___1 = gettext("overwrite existing script?");
#line 418
      tmp___2 = select_yesno_box(tmp___1);
      }
#line 418
      if (! tmp___2) {
#line 418
        return (1);
      }
    }
  }
  {
#line 422
  script = fopen((char const   */* __restrict  */)filenm, (char const   */* __restrict  */)"wb");
  }
#line 423
  if ((unsigned long )script == (unsigned long )((void *)0)) {
#line 424
    if (ask_overwrite) {
      {
#line 424
      tmp___4 = gettext("couldn\'t open file for writing!");
#line 424
      popup_error_win(tmp___4);
      }
    }
#line 425
    return (1);
  }
  {
#line 428
  batch_task_output_header(anchor, script);
#line 434
  fputs((char const   */* __restrict  */)"##########\n# PASS 1 #\n##########\n\nif [ $verbose ]; then echo \"* * * * * PASS 1 * * * * *\"; fi;\n\nif [ \"$mode\" != \"2\" ]; then\t# encoding only is part of pass 2\n",
        (FILE */* __restrict  */)script);
#line 439
  curr = anchor;
  }
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (! curr) {
#line 440
      goto while_break;
    }
#line 441
    if (curr->convert) {
      {
#line 442
      fputs((char const   */* __restrict  */)"#-{\nif [ \"$mode\" = \"4\" ]; then\t# on-the-fly encode\n",
            (FILE */* __restrict  */)script);
#line 443
      batch_task_rip_and_enc(curr, script);
#line 444
      fputs((char const   */* __restrict  */)"else\t\t\t# rip following track\n",
            (FILE */* __restrict  */)script);
#line 445
      batch_task_single_rip(curr, script);
#line 446
      fputs((char const   */* __restrict  */)"  if [ \"$mode\" = \"3\" -a \"$order\" = \"0\" ]; then\t# encoding should be also done\n",
            (FILE */* __restrict  */)script);
#line 447
      batch_task_single_enc(curr, script);
#line 448
      fputs((char const   */* __restrict  */)"  fi\nfi\nif [ \"$mode\" = \"3\" -a \"$order\" = \"0\" -o \"$mode\" = \"4\" ]; then\t# was encoded\n",
            (FILE */* __restrict  */)script);
#line 449
      batch_task_set_tag(curr, script);
#line 450
      batch_task_update_m3u(curr, script);
#line 451
      fputs((char const   */* __restrict  */)"fi\n#-}\n\n", (FILE */* __restrict  */)script);
      }
    }
#line 453
    curr = curr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 455
  fputs((char const   */* __restrict  */)"if [ \"$mode\" = \"3\" -a \"$order\" = \"0\" -o \"$mode\" = \"4\" ]; then\n  echo \"ENCODING FINISHED!\"\n  exit 0\nfi\nif [ \"$mode\" = \"1\" ]; then\n  echo \"RIPPING FINISHED!\"\n  exit 0\nfi\nfi\n\n",
        (FILE */* __restrict  */)script);
#line 468
  fputs((char const   */* __restrict  */)"##########\n# PASS 2 #\n##########\n\nif [ $verbose ]; then echo \"* * * * * PASS 2 * * * * *\"; fi;\n\n",
        (FILE */* __restrict  */)script);
#line 472
  curr = anchor;
  }
  {
#line 473
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 473
    if (! curr) {
#line 473
      goto while_break___0;
    }
#line 474
    if (curr->convert) {
      {
#line 475
      tmp___5 = return_track_tmpname(curr);
#line 475
      fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"if [ -f \"%s\" ]; then\n",
              tmp___5);
#line 476
      batch_task_single_enc(curr, script);
#line 477
      batch_task_set_tag(curr, script);
#line 478
      batch_task_update_m3u(curr, script);
#line 479
      fprintf((FILE */* __restrict  */)script, (char const   */* __restrict  */)"else\n echo Skipping %d\nfi\n",
              (int )curr->toc + 1);
      }
    }
#line 483
    curr = curr->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 487
  fputs((char const   */* __restrict  */)"echo \"ENCODING FINISHED!\"\nexit 0\n\n# End of script. Thanks for using MP3c\n# MP3c is available here: http://www.wspse.de/WSPse/Linux-MP3c.php3\n# WSPse, Matthias Hensler 1999/2000\n",
        (FILE */* __restrict  */)script);
#line 493
  fclose(script);
#line 494
  chmod((char const   *)filenm, (__mode_t )511);
  }
#line 495
  return (0);
}
}
#line 501 "/home/wslee/benchmarks/sound/mp3c-0.29/src/batch.c"
int start_non_interact(char *batchfile ) 
{ 
  song_typ *anchor ;
  char *tmp_file ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 506
  tmp = gettext("WSPse MP3c - Batchmode, noninteractive\nreading config\n");
#line 506
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 507
  careful_batch = (unsigned char)1;
#line 508
  anchor = (song_typ *)((void *)0);
#line 509
  init_config();
#line 510
  get_config(external_config_file);
#line 512
  tmp___1 = open_cdrom();
  }
#line 512
  if (tmp___1 < 1) {
    {
#line 513
    tmp___0 = gettext("opening cdrom device \"%s\" failed!\n");
#line 513
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            def_cdrom_dev);
    }
#line 514
    return (1);
  }
  {
#line 517
  tmp___2 = gettext("reading TOC of cd\n");
#line 517
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2);
#line 518
  tmp___4 = init_cd();
  }
#line 518
  if (tmp___4 != 0) {
    {
#line 519
    tmp___3 = gettext("no cd in cdrom-drive\n");
#line 519
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3);
    }
#line 520
    return (1);
  }
  {
#line 523
  close_cdrom();
#line 525
  tmp___5 = gettext("building up data tree\n");
#line 525
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5);
#line 526
  build_data_tree(def_cddb_server, def_cddb_bank, & anchor, (unsigned char)0);
#line 528
  tmp___6 = gettext("building shellscript\n");
#line 528
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6);
#line 530
  tmp_file = (char *)((void *)0);
  }
#line 531
  if (batch_alt_tmp_file) {
    {
#line 532
    tmp___9 = strlen((char const   *)batch_alt_tmp_file);
    }
#line 532
    if ((int )*((batch_alt_tmp_file + tmp___9) - 1) == 47) {
      {
#line 533
      tmp___7 = strlen((char const   *)batch_alt_tmp_file);
#line 533
      tmp___8 = malloc((size_t )(sizeof(char ) * (unsigned long )(tmp___7 + 17U)));
#line 533
      tmp_file = (char *)tmp___8;
      }
#line 534
      if (! tmp_file) {
        {
#line 535
        perror("malloc");
#line 536
        wuuush(1);
        }
      }
      {
#line 538
      strcpy((char */* __restrict  */)tmp_file, (char const   */* __restrict  */)batch_alt_tmp_file);
#line 539
      strcat((char */* __restrict  */)tmp_file, (char const   */* __restrict  */)"mp3c-tmp-.wav");
#line 540
      batch_alt_tmp_file = tmp_file;
      }
    }
    {
#line 542
    tmp___10 = gettext("using alternate tmp-file \"%s\"\n");
#line 542
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___10,
            batch_alt_tmp_file);
#line 543
    def_tmp_file = batch_alt_tmp_file;
    }
  }
  {
#line 546
  output_batch(anchor, batchfile, (unsigned char)0);
#line 547
  free_song_typ(& anchor);
  }
#line 548
  if (tmp_file) {
    {
#line 548
    free((void *)tmp_file);
    }
  }
  {
#line 550
  tmp___11 = gettext("ready...\n\n");
#line 550
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___11);
  }
#line 551
  return (0);
}
}
