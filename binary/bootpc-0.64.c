/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_7 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_7 fd_set;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_34 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_35 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_34 ifr_ifrn ;
   union __anonunion_ifr_ifru_35 ifr_ifru ;
};
#line 42 "/home/june/collector/temp/bootpc-0.64/bootp.h"
struct bootp {
   unsigned char bp_op ;
   unsigned char bp_htype ;
   unsigned char bp_hlen ;
   unsigned char bp_hops ;
   unsigned int bp_xid ;
   unsigned short bp_secs ;
   unsigned short bp_flags ;
   struct in_addr bp_ciaddr ;
   struct in_addr bp_yiaddr ;
   struct in_addr bp_siaddr ;
   struct in_addr bp_giaddr ;
   unsigned char bp_chaddr[16] ;
   char bp_sname[64] ;
   char bp_file[128] ;
   unsigned char bp_vend[64] ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 163
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 137 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 53
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 14 "/home/june/collector/temp/bootpc-0.64/log.h"
void doLogMessage(char *s  , ...) ;
#line 43 "/home/june/collector/temp/bootpc-0.64/bootpc.h"
int BootpFatal(void) ;
#line 45
void ParsePacket(struct bootp *bootp_recv , int cookielength , unsigned char *match ) ;
#line 49
void OutList(char *name , unsigned char *cookie , int len ) ;
#line 53
void OutString(char *name , unsigned char *cookie , int len ) ;
#line 57
void OutSearch(char *name , unsigned char *cookie , int len ) ;
#line 61
void safecopy(unsigned char *out , unsigned char *string , int len ) ;
#line 65
void doOut(char *name , char *lenv ) ;
#line 68
int in2host(char *address , int bp_pr ) ;
#line 71
int performBootp(char *device , char *server , char *bootfile , int timeout_wait ,
                 int givenhwaddr , struct ifreq *their_ifr , int waitformore , int bp_rif ,
                 int bp_pr , int broadcast ) ;
#line 83
int bootp_verbose ;
#line 84
int bootp_debug ;
#line 39 "/home/june/collector/temp/bootpc-0.64/bootpc.c"
int bootp_verbose  =    0;
#line 40 "/home/june/collector/temp/bootpc-0.64/bootpc.c"
int bootp_debug  =    0;
#line 42 "/home/june/collector/temp/bootpc-0.64/bootpc.c"
static int returniffail  ;
#line 43 "/home/june/collector/temp/bootpc-0.64/bootpc.c"
static int printflag  ;
#line 44 "/home/june/collector/temp/bootpc-0.64/bootpc.c"
static int sockfd  ;
#line 46 "/home/june/collector/temp/bootpc-0.64/bootpc.c"
int performBootp(char *device , char *server , char *bootfile , int timeout_wait ,
                 int givenhwaddr , struct ifreq *their_ifr , int waitformore , int bp_rif ,
                 int bp_pr , int broadcast ) 
{ 
  struct ifreq ifr ;
  struct sockaddr_in cli_addr ;
  struct sockaddr_in serv_addr ;
  struct bootp *bootp_xmit ;
  struct bootp *bootp_recv ;
  fd_set rfds ;
  fd_set wfds ;
  fd_set xfds ;
  struct timeval timeout ;
  int rancopy ;
  int cookielength ;
  long plen ;
  int retry_wait ;
  int waited ;
  int one ;
  int i ;
  struct timeval tp ;
  int received_packet ;
  unsigned char mincookie[5] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  uint16_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  ssize_t tmp___13 ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int __d0___1 ;
  int __d1___1 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  {
#line 65
  waited = 0;
#line 66
  one = 1;
#line 68
  received_packet = 0;
#line 70
  mincookie[0] = (unsigned char)99;
#line 70
  mincookie[1] = (unsigned char)130;
#line 70
  mincookie[2] = (unsigned char)83;
#line 70
  mincookie[3] = (unsigned char)99;
#line 70
  mincookie[4] = (unsigned char)255;
#line 72
  returniffail = bp_rif;
#line 73
  printflag = bp_pr;
#line 76
  memset((void *)((char *)(& serv_addr)), 0, sizeof(serv_addr));
#line 78
  serv_addr.sin_family = (sa_family_t )2;
#line 79
  serv_addr.sin_addr.s_addr = inet_addr((char const   *)server);
#line 80
  serv_addr.sin_port = htons((uint16_t )67);
#line 82
  sockfd = socket(2, 2, 0);
  }
#line 82
  if (sockfd < 0) {
    {
#line 83
    perror("bootpc: socket failed");
#line 84
    tmp = BootpFatal();
    }
#line 84
    return (tmp);
  }
  {
#line 87
  tmp___1 = setsockopt(sockfd, 1, 6, (void const   *)(& one), (socklen_t )sizeof(one));
  }
#line 87
  if (tmp___1 == -1) {
    {
#line 88
    perror("bootpc: setsockopt failed");
#line 89
    tmp___0 = BootpFatal();
    }
#line 89
    return (tmp___0);
  }
  {
#line 92
  memset((void *)((char *)(& cli_addr)), 0, sizeof(cli_addr));
#line 93
  cli_addr.sin_family = (sa_family_t )2;
#line 94
  cli_addr.sin_addr.s_addr = htonl((in_addr_t )0);
#line 95
  cli_addr.sin_port = htons((uint16_t )68);
#line 97
  tmp___3 = bind(sockfd, (struct sockaddr  const  *)((struct sockaddr *)(& cli_addr)),
                 (socklen_t )sizeof(cli_addr));
  }
#line 97
  if (tmp___3 < 0) {
    {
#line 98
    perror("bootpc: bind failed");
#line 99
    tmp___2 = BootpFatal();
    }
#line 99
    return (tmp___2);
  }
  {
#line 103
  tmp___4 = malloc((size_t )8192);
#line 103
  bootp_xmit = (struct bootp *)tmp___4;
#line 104
  memset((void *)((char *)bootp_xmit), 0, (size_t )8192);
#line 106
  tmp___5 = malloc((size_t )8192);
#line 106
  bootp_recv = (struct bootp *)tmp___5;
#line 107
  memset((void *)((char *)bootp_recv), 0, (size_t )8192);
  }
#line 110
  if (broadcast) {
    {
#line 111
    tmp___6 = htons((uint16_t )(1 << 15));
#line 111
    bootp_xmit->bp_flags = (unsigned short )((int )bootp_xmit->bp_flags | (int )tmp___6);
    }
  } else
#line 110
  if (givenhwaddr) {
    {
#line 111
    tmp___6 = htons((uint16_t )(1 << 15));
#line 111
    bootp_xmit->bp_flags = (unsigned short )((int )bootp_xmit->bp_flags | (int )tmp___6);
    }
  }
#line 114
  if (givenhwaddr) {
#line 116
    ifr.ifr_ifru.ifru_hwaddr.sa_family = (sa_family_t )1;
#line 117
    ifr.ifr_ifru.ifru_hwaddr = their_ifr->ifr_ifru.ifru_hwaddr;
  } else {
    {
#line 120
    tmp___7 = strlen((char const   *)device);
#line 120
    memcpy((void */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (void const   */* __restrict  */)device,
           tmp___7 + 1UL);
#line 121
    tmp___9 = ioctl(sockfd, 35111UL, & ifr);
    }
#line 121
    if (tmp___9 < 0) {
      {
#line 122
      perror("bootpc: ioctl failed");
#line 123
      tmp___8 = BootpFatal();
      }
#line 123
      return (tmp___8);
    }
  }
#line 133
  bootp_xmit->bp_htype = (unsigned char )ifr.ifr_ifru.ifru_hwaddr.sa_family;
#line 134
  bootp_xmit->bp_hlen = (unsigned char)6;
#line 136
  if (bootp_debug) {
    {
#line 137
    doLogMessage((char *)"Got family=%d (Ether=%d)", (int )bootp_xmit->bp_htype, 1);
    }
  }
  {
#line 142
  tmp___10 = gettimeofday((struct timeval */* __restrict  */)(& tp), (__timezone_ptr_t )((void *)0));
  }
#line 142
  if (tmp___10 == -1) {
#line 143
    rancopy = 0;
  } else {
#line 145
    rancopy = (int )(tp.tv_sec + tp.tv_usec);
  }
#line 148
  i = 0;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (i < 6)) {
#line 148
      goto while_break;
    }
#line 149
    *((unsigned char *)(& rancopy) + (unsigned long )i % sizeof(rancopy)) = (unsigned char )((int )*((unsigned char *)(& rancopy) + (unsigned long )i % sizeof(rancopy)) ^ (int )*((unsigned char *)(ifr.ifr_ifru.ifru_hwaddr.sa_data) + i));
#line 148
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 153
  srand((unsigned int )rancopy);
  }
#line 155
  if (bootp_debug) {
    {
#line 156
    doLogMessage((char *)"hardware addr is :");
#line 157
    i = 0;
    }
    {
#line 157
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 157
      if (! (i < (int )bootp_xmit->bp_hlen)) {
#line 157
        goto while_break___0;
      }
      {
#line 158
      doLogMessage((char *)"%2.2X ", (int )*((unsigned char *)(ifr.ifr_ifru.ifru_hwaddr.sa_data) + i));
#line 157
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 162
  bootp_xmit->bp_op = (unsigned char)1;
  {
#line 174
  if ((int )bootp_xmit->bp_htype == 7) {
#line 174
    goto case_7;
  }
#line 183
  goto switch_default;
  case_7: /* CIL Label */ 
  {
#line 175
  memcpy((void */* __restrict  */)((bootp_xmit->bp_chaddr + 6) - 1), (void const   */* __restrict  */)(ifr.ifr_ifru.ifru_hwaddr.sa_data),
         (size_t )1);
#line 176
  bootp_xmit->bp_htype = (unsigned char)1;
#line 177
  bootp_xmit->bp_hlen = (unsigned char)6;
  }
#line 178
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 184
  memcpy((void */* __restrict  */)(bootp_xmit->bp_chaddr), (void const   */* __restrict  */)(ifr.ifr_ifru.ifru_hwaddr.sa_data),
         (size_t )bootp_xmit->bp_hlen);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 190
  bootp_xmit->bp_secs = (unsigned short)0;
#line 193
  memcpy((void */* __restrict  */)(bootp_xmit->bp_vend), (void const   */* __restrict  */)(mincookie),
         sizeof(mincookie));
#line 196
  tmp___11 = strlen((char const   *)bootfile);
#line 196
  memcpy((void */* __restrict  */)(bootp_xmit->bp_file), (void const   */* __restrict  */)bootfile,
         tmp___11 + 1UL);
#line 199
  rancopy = rand();
#line 199
  bootp_xmit->bp_xid = (unsigned int )rancopy;
#line 201
  retry_wait = 2;
  }
#line 202
  if (bootp_verbose) {
    {
#line 203
    doLogMessage((char *)"BOOTPclient broadcast...");
    }
  }
  {
#line 205
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 205
    if (waited <= timeout_wait) {
#line 205
      if (! (! received_packet)) {
#line 205
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 205
    if (waited <= waitformore) {
#line 205
      if (! received_packet) {
#line 205
        goto while_break___1;
      }
    } else {
#line 205
      goto while_break___1;
    }
#line 208
    if (! received_packet) {
#line 210
      bootp_xmit->bp_secs = (unsigned short )waited;
#line 211
      if (bootp_verbose) {
        {
#line 212
        doLogMessage((char *)".");
#line 212
        fflush(stderr);
        }
      }
#line 214
      if (bootp_debug) {
        {
#line 215
        doLogMessage((char *)"Size = %ld", (long )sizeof(struct bootp ));
        }
      }
      {
#line 218
      tmp___13 = sendto(sockfd, (void const   *)bootp_xmit, sizeof(struct bootp ),
                        0, (struct sockaddr  const  *)((struct sockaddr *)(& serv_addr)),
                        (socklen_t )sizeof(serv_addr));
      }
#line 218
      if (tmp___13 < 0L) {
        {
#line 220
        perror("bootpc: sendto");
#line 221
        tmp___12 = BootpFatal();
        }
#line 221
        return (tmp___12);
      }
    }
    {
#line 226
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 226
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rfds.__fds_bits[0]): "memory");
#line 226
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 229
    rfds.__fds_bits[sockfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sockfd % (8 * (int )sizeof(__fd_mask ));
    {
#line 230
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 230
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& wfds.__fds_bits[0]): "memory");
#line 230
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 231
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 231
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___1), "=D" (__d1___1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& xfds.__fds_bits[0]): "memory");
#line 231
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 234
    tmp___14 = rand();
#line 234
    timeout.tv_sec = (__time_t )(retry_wait + (1 + (tmp___14 & (retry_wait - 1))));
#line 235
    timeout.tv_usec = (__suseconds_t )0;
#line 236
    waited = (int )((__time_t )waited + timeout.tv_sec);
#line 238
    tmp___16 = select(sockfd + 1, (fd_set */* __restrict  */)(& rfds), (fd_set */* __restrict  */)(& wfds),
                      (fd_set */* __restrict  */)(& xfds), (struct timeval */* __restrict  */)(& timeout));
    }
#line 238
    if (tmp___16 < 0) {
      {
#line 239
      perror("bootpc: select");
#line 240
      tmp___15 = BootpFatal();
      }
#line 240
      return (tmp___15);
    }
#line 243
    if (! ((rfds.__fds_bits[sockfd / (8 * (int )sizeof(__fd_mask ))] & (1L << sockfd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 244
      retry_wait *= 2;
    } else {
      {
#line 246
      plen = recvfrom(sockfd, (void */* __restrict  */)bootp_recv, (size_t )8192,
                      0, (struct sockaddr */* __restrict  */)((struct sockaddr *)((void *)0)),
                      (socklen_t */* __restrict  */)((int *)((void *)0)));
      }
#line 246
      if (plen < 0L) {
        {
#line 248
        perror("bootpc: recvfrom");
#line 249
        tmp___17 = BootpFatal();
        }
#line 249
        return (tmp___17);
      }
#line 252
      if (bootp_debug) {
        {
#line 253
        doLogMessage((char *)"plen = %ld  plen - sizeof(struct bootp) = %ld", plen,
                     (long )((unsigned long )plen - sizeof(struct bootp )));
        }
      }
#line 256
      cookielength = (int )((unsigned long )(64L + plen) - sizeof(struct bootp ));
#line 258
      if (bootp_recv->bp_xid == (unsigned int )rancopy) {
#line 259
        if (! received_packet) {
#line 262
          waitformore += waited;
#line 263
          received_packet = 1;
        } else
#line 266
        if (printflag & 1) {
          {
#line 267
          printf((char const   */* __restrict  */)"\n");
          }
        }
        {
#line 273
        ParsePacket(bootp_recv, cookielength, mincookie);
        }
      } else
#line 278
      if (bootp_verbose) {
        {
#line 279
        doLogMessage((char *)"WARNING bp_xid mismatch got 0x%lx sent 0x%lx", (long )bootp_recv->bp_xid,
                     (long )rancopy);
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 285
  if (! received_packet) {
    {
#line 286
    doLogMessage((char *)"No response from BOOTP server");
#line 287
    tmp___18 = BootpFatal();
    }
#line 287
    return (tmp___18);
  }
#line 290
  if (sockfd) {
    {
#line 291
    close(sockfd);
    }
  }
#line 292
  return (0);
}
}
#line 295 "/home/june/collector/temp/bootpc-0.64/bootpc.c"
int BootpFatal(void) 
{ 
  int *tmp ;

  {
#line 297
  if (sockfd) {
    {
#line 298
    close(sockfd);
    }
  }
#line 300
  if (bootp_debug) {
    {
#line 301
    tmp = __errno_location();
#line 301
    doLogMessage((char *)"In BootpFatal(), errno was %d", *tmp);
    }
  }
#line 303
  if (returniffail) {
    {
#line 304
    doLogMessage((char *)"bootpc failed to locate a network address");
    }
#line 305
    return (1);
  }
  {
#line 308
  doLogMessage((char *)" Unable to locate an IP address for this host.\n     ***Please report this problem**\n\n          [Unable to continue]\n");
  }
#line 312
  if (bootp_debug) {
    {
#line 313
    doLogMessage((char *)"Will now loop forerver, break out of this to fix");
    }
  }
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 317
    sleep(1000U);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 324 "/home/june/collector/temp/bootpc-0.64/bootpc.c"
void ParsePacket(struct bootp *bootp_recv , int cookielength , unsigned char *match ) 
{ 
  int i ;
  int len ;
  int tag ;
  int subnet ;
  struct in_addr temp ;
  unsigned char *cookie ;
  struct in_addr temp_addr ;
  struct in_addr my_addr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char name[30] ;
  struct in_addr netmask ;
  int type ;
  uint32_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 328
  i = 0;
#line 329
  subnet = 0;
#line 331
  cookie = bootp_recv->bp_vend;
#line 334
  temp_addr.s_addr = bootp_recv->bp_giaddr.s_addr;
#line 335
  tmp = inet_ntoa(temp_addr);
#line 335
  OutString((char *)"GATEWAY", (unsigned char *)tmp, -1);
#line 336
  temp_addr.s_addr = bootp_recv->bp_siaddr.s_addr;
#line 337
  tmp___0 = inet_ntoa(temp_addr);
#line 337
  OutString((char *)"SERVER", (unsigned char *)tmp___0, -1);
#line 338
  my_addr.s_addr = bootp_recv->bp_yiaddr.s_addr;
#line 339
  tmp___1 = inet_ntoa(my_addr);
#line 339
  OutString((char *)"IPADDR", (unsigned char *)tmp___1, -1);
  }
#line 340
  if (bootp_verbose) {
    {
#line 341
    tmp___2 = strlen((char const   *)(bootp_recv->bp_file));
#line 341
    doLogMessage((char *)"bp_file len is %d", tmp___2);
    }
  }
  {
#line 343
  OutString((char *)"BOOTFILE", (unsigned char *)(bootp_recv->bp_file), -1);
  }
#line 346
  if (bootp_debug) {
#line 347
    i = 0;
    {
#line 347
    while (1) {
      while_continue: /* CIL Label */ ;
#line 347
      if (! (i < cookielength)) {
#line 347
        goto while_break;
      }
#line 348
      if (i % 8 == 0) {
        {
#line 349
        doLogMessage((char *)"\n %2.2d :", i);
        }
      }
      {
#line 350
      doLogMessage((char *)" 0x%2.2X", (int )*(cookie + i));
#line 347
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 352
    doLogMessage((char *)"");
    }
  }
#line 356
  i = 0;
  {
#line 356
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 356
    if (! (i < 4)) {
#line 356
      goto while_break___0;
    }
#line 357
    if ((int )*(cookie + i) != (int )*(match + i)) {
#line 358
      if (bootp_verbose) {
        {
#line 359
        doLogMessage((char *)"RFC1497 Cookie mismatch at offset %d", i);
        }
      }
#line 360
      return;
    }
#line 356
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 364
  if (bootp_verbose) {
    {
#line 365
    doLogMessage((char *)"found valid RFC1497 cookie, parsing...");
    }
  }
  {
#line 368
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 368
    if (! (i < cookielength)) {
#line 368
      goto while_break___1;
    }
#line 369
    tag = (int )*(cookie + i);
#line 371
    if (bootp_verbose) {
      {
#line 372
      doLogMessage((char *)"cookie position %d is %d", i, tag);
      }
    }
#line 375
    if (i < cookielength - 1) {
#line 375
      if (tag != 0) {
#line 375
        if (tag != 255) {
#line 376
          len = (int )*(cookie + (i + 1));
        } else {
#line 378
          len = 0;
        }
      } else {
#line 378
        len = 0;
      }
    } else {
#line 378
      len = 0;
    }
#line 381
    if (len + i > cookielength) {
#line 382
      if (bootp_verbose) {
        {
#line 383
        doLogMessage((char *)"TAG %d at %d.  len %d, overrun %d", (int )*(cookie + i),
                     i, len, (i + len) - cookielength);
        }
      }
#line 386
      len = cookielength - i;
    }
    {
#line 391
    if ((int )*(cookie + i) == 0) {
#line 391
      goto case_0;
    }
#line 396
    if ((int )*(cookie + i) == 1) {
#line 396
      goto case_1;
    }
#line 415
    if ((int )*(cookie + i) == 2) {
#line 415
      goto case_2;
    }
#line 421
    if ((int )*(cookie + i) == 3) {
#line 421
      goto case_3;
    }
#line 427
    if ((int )*(cookie + i) == 4) {
#line 427
      goto case_4;
    }
#line 433
    if ((int )*(cookie + i) == 5) {
#line 433
      goto case_5;
    }
#line 439
    if ((int )*(cookie + i) == 6) {
#line 439
      goto case_6;
    }
#line 445
    if ((int )*(cookie + i) == 7) {
#line 445
      goto case_7;
    }
#line 451
    if ((int )*(cookie + i) == 8) {
#line 451
      goto case_8;
    }
#line 457
    if ((int )*(cookie + i) == 9) {
#line 457
      goto case_9;
    }
#line 463
    if ((int )*(cookie + i) == 10) {
#line 463
      goto case_10;
    }
#line 469
    if ((int )*(cookie + i) == 11) {
#line 469
      goto case_11;
    }
#line 475
    if ((int )*(cookie + i) == 12) {
#line 475
      goto case_12;
    }
#line 481
    if ((int )*(cookie + i) == 13) {
#line 481
      goto case_13;
    }
#line 486
    if ((int )*(cookie + i) == 14) {
#line 486
      goto case_14;
    }
#line 491
    if ((int )*(cookie + i) == 15) {
#line 491
      goto case_15;
    }
#line 498
    if ((int )*(cookie + i) == 16) {
#line 498
      goto case_16;
    }
#line 504
    if ((int )*(cookie + i) == 17) {
#line 504
      goto case_17;
    }
#line 510
    if ((int )*(cookie + i) == 18) {
#line 510
      goto case_18;
    }
#line 516
    if ((int )*(cookie + i) == 40) {
#line 516
      goto case_40;
    }
#line 522
    if ((int )*(cookie + i) == 41) {
#line 522
      goto case_41;
    }
#line 528
    if ((int )*(cookie + i) == 42) {
#line 528
      goto case_42;
    }
#line 534
    if ((int )*(cookie + i) == 255) {
#line 534
      goto case_255;
    }
#line 539
    goto switch_default;
    case_0: /* CIL Label */ 
#line 392
    i ++;
#line 393
    goto switch_break;
    case_1: /* CIL Label */ 
#line 397
    if (bootp_verbose) {
#line 397
      if (len != 4) {
        {
#line 398
        doLogMessage((char *)"WARNING len of tag 1 is %d not 4", len);
        }
      }
    }
    {
#line 399
    memcpy((void */* __restrict  */)((char *)(& temp)), (void const   */* __restrict  */)((cookie + i) + 2),
           (size_t )4);
#line 400
    tmp___3 = inet_ntoa(temp);
#line 400
    OutString((char *)"NETMASK", (unsigned char *)tmp___3, -1);
#line 404
    my_addr.s_addr &= temp.s_addr;
#line 405
    tmp___4 = inet_ntoa(my_addr);
#line 405
    OutString((char *)"NETWORK", (unsigned char *)tmp___4, -1);
#line 406
    my_addr.s_addr |= ~ temp.s_addr;
#line 407
    tmp___5 = inet_ntoa(my_addr);
#line 407
    OutString((char *)"BROADCAST", (unsigned char *)tmp___5, -1);
#line 410
    subnet = 1;
#line 411
    i += len + 2;
    }
#line 412
    goto switch_break;
    case_2: /* CIL Label */ 
#line 417
    i += len + 2;
#line 418
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 422
    OutList((char *)"GATEWAYS", (cookie + i) + 2, len);
#line 423
    i += len + 2;
    }
#line 424
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 428
    OutList((char *)"TIMESRVS", (cookie + i) + 2, len);
#line 429
    i += len + 2;
    }
#line 430
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 434
    OutList((char *)"IEN116SRVS", (cookie + i) + 2, len);
#line 435
    i += len + 2;
    }
#line 436
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 440
    OutList((char *)"DNSSRVS", (cookie + i) + 2, len);
#line 441
    i += len + 2;
    }
#line 442
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 446
    OutList((char *)"LOGSRVS", (cookie + i) + 2, len);
#line 447
    i += len + 2;
    }
#line 448
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 452
    OutList((char *)"QODSRVS", (cookie + i) + 2, len);
#line 453
    i += len + 2;
    }
#line 454
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 458
    OutList((char *)"LPRSRVS", (cookie + i) + 2, len);
#line 459
    i += len + 2;
    }
#line 460
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 464
    OutList((char *)"IMPRESSSRVS", (cookie + i) + 2, len);
#line 465
    i += len + 2;
    }
#line 466
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 470
    OutList((char *)"RLPSRVS", (cookie + i) + 2, len);
#line 471
    i += len + 2;
    }
#line 472
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 476
    OutString((char *)"HOSTNAME", (cookie + i) + 2, len);
#line 477
    i += len + 2;
    }
#line 478
    goto switch_break;
    case_13: /* CIL Label */ 
#line 482
    i += len + 2;
#line 483
    goto switch_break;
    case_14: /* CIL Label */ 
#line 487
    i += len + 2;
#line 488
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 492
    OutString((char *)"DOMAIN", (cookie + i) + 2, len);
#line 493
    OutSearch((char *)"SEARCH", (cookie + i) + 2, len);
#line 494
    i += len + 2;
    }
#line 495
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 499
    OutList((char *)"SWAPSRVR", (cookie + i) + 2, len);
#line 500
    i += len + 2;
    }
#line 501
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 505
    OutString((char *)"ROOT_PATH", (cookie + i) + 2, len);
#line 506
    i += len + 2;
    }
#line 507
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 511
    OutString((char *)"EXTEN_FILE", (cookie + i) + 2, len);
#line 512
    i += len + 2;
    }
#line 513
    goto switch_break;
    case_40: /* CIL Label */ 
    {
#line 517
    OutString((char *)"YPDOMAIN", (cookie + i) + 2, len);
#line 518
    i += len + 2;
    }
#line 519
    goto switch_break;
    case_41: /* CIL Label */ 
    {
#line 523
    OutList((char *)"YPSRVR", (cookie + i) + 2, len);
#line 524
    i += len + 2;
    }
#line 525
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 529
    OutList((char *)"NTPSRVS", (cookie + i) + 2, len);
#line 530
    i += len + 2;
    }
#line 531
    goto switch_break;
    case_255: /* CIL Label */ 
#line 535
    if (bootp_verbose) {
      {
#line 536
      doLogMessage((char *)"end of cookie parsing, END tag found");
      }
    }
#line 537
    return;
    switch_default: /* CIL Label */ 
#line 541
    if (bootp_verbose) {
#line 542
      if (tag >= 128) {
#line 542
        if (tag <= 254) {
          {
#line 543
          doLogMessage((char *)"Reserved TAG %d at %d (len %d)", tag, i, len);
          }
        } else {
          {
#line 545
          doLogMessage((char *)"Unknown TAG %d at %d (len %d)", tag, i, len);
          }
        }
      } else {
        {
#line 545
        doLogMessage((char *)"Unknown TAG %d at %d (len %d)", tag, i, len);
        }
      }
    }
    {
#line 547
    sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"T%3.3d",
            tag);
#line 548
    OutString(name, (cookie + i) + 2, len);
#line 549
    i += 2 + len;
    }
#line 551
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 559
  if (! subnet) {
#line 563
    if (bootp_verbose) {
      {
#line 564
      doLogMessage((char *)"Guessing netmask from IP address range");
      }
    }
    {
#line 566
    tmp___6 = ntohl(temp_addr.s_addr);
#line 566
    type = (int )tmp___6;
    }
#line 567
    if (((unsigned int )type & 2147483648U) == 0U) {
      {
#line 569
      netmask.s_addr = htonl(4278190080U);
      }
    } else
#line 570
    if ((type & 1073741824) == 0) {
      {
#line 572
      netmask.s_addr = htonl(4294901760U);
      }
    } else
#line 573
    if ((type & 536870912) == 0) {
      {
#line 575
      netmask.s_addr = htonl(4294967040U);
      }
    } else {
#line 577
      if (bootp_verbose) {
        {
#line 578
        doLogMessage((char *)"IP number not Class A,B or C. Setting NETMASK to zero");
        }
      }
      {
#line 579
      netmask.s_addr = htonl((uint32_t )0);
      }
    }
    {
#line 581
    tmp___7 = inet_ntoa(netmask);
#line 581
    OutString((char *)"NETMASK", (unsigned char *)tmp___7, -1);
#line 582
    temp_addr.s_addr &= netmask.s_addr;
#line 583
    tmp___8 = inet_ntoa(temp_addr);
#line 583
    OutString((char *)"NETWORK", (unsigned char *)tmp___8, -1);
#line 584
    temp_addr.s_addr |= ~ netmask.s_addr;
#line 585
    tmp___9 = inet_ntoa(temp_addr);
#line 585
    OutString((char *)"BROADCAST", (unsigned char *)tmp___9, -1);
    }
  }
#line 587
  return;
}
}
#line 591 "/home/june/collector/temp/bootpc-0.64/bootpc.c"
void OutList(char *name , unsigned char *cookie , int len ) 
{ 
  struct in_addr temp ;
  char lenv[8192] ;
  char *ptr ;
  int n ;
  int c ;
  int i ;
  char lbuf[8192] ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 599
  if (bootp_verbose) {
    {
#line 600
    doLogMessage((char *)"%s found len=%d", name, len);
    }
  }
#line 602
  if (len % 4 != 0) {
#line 603
    if (bootp_verbose) {
      {
#line 604
      doLogMessage((char *)"ERROR %s length (%d) not 4 div", name, len);
      }
    }
#line 605
    return;
  }
#line 607
  if (len == 0) {
#line 608
    return;
  }
#line 610
  n = 0;
#line 610
  i = 1;
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 610
    if (! len) {
#line 610
      goto while_break;
    }
    {
#line 612
    memcpy((void */* __restrict  */)((char *)(& temp)), (void const   */* __restrict  */)cookie,
           (size_t )4);
#line 613
    ptr = inet_ntoa(temp);
#line 614
    tmp = strlen((char const   *)ptr);
#line 614
    c = (int )tmp;
#line 615
    sprintf((char */* __restrict  */)(lbuf), (char const   */* __restrict  */)"%s_%d",
            name, i);
#line 616
    OutString(lbuf, (unsigned char *)ptr, c);
#line 617
    strncpy((char */* __restrict  */)(lenv + n), (char const   */* __restrict  */)ptr,
            (size_t )c);
#line 618
    n += c;
    }
#line 619
    if (len > 4) {
#line 620
      tmp___0 = n;
#line 620
      n ++;
#line 620
      lenv[tmp___0] = (char )' ';
    }
#line 610
    len -= 4;
#line 610
    cookie += 4;
#line 610
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 622
  lenv[n] = (char)0;
#line 624
  doOut(name, lenv);
  }
#line 625
  return;
}
}
#line 628 "/home/june/collector/temp/bootpc-0.64/bootpc.c"
void OutString(char *name , unsigned char *cookie , int len ) 
{ 
  char lenv[8192] ;
  size_t tmp ;

  {
#line 633
  if (len == -1) {
    {
#line 634
    tmp = strlen((char const   *)((char *)cookie));
#line 634
    len = (int )tmp;
    }
  }
  {
#line 636
  safecopy((unsigned char *)(lenv), cookie, len);
#line 637
  doOut(name, lenv);
  }
#line 638
  return;
}
}
#line 644 "/home/june/collector/temp/bootpc-0.64/bootpc.c"
void OutSearch(char *name , unsigned char *cookie , int len ) 
{ 
  unsigned char *ptr ;
  unsigned char *nptr ;
  unsigned char buf[258] ;
  char lenv[8192] ;
  int n ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 651
  n = 0;
#line 653
  strncpy((char */* __restrict  */)((char *)(buf)), (char const   */* __restrict  */)((char *)cookie),
          (size_t )len);
#line 654
  buf[len + 1] = (unsigned char)0;
#line 655
  ptr = buf;
  }
  {
#line 657
  while (1) {
    while_continue: /* CIL Label */ ;
#line 657
    if (! len) {
#line 657
      goto while_break;
    }
    {
#line 658
    safecopy((unsigned char *)(lenv + n), ptr, len);
#line 659
    n += len;
#line 661
    tmp = strchr((char const   *)((char *)ptr), '.');
#line 661
    nptr = (unsigned char *)tmp;
    }
#line 662
    if ((unsigned long )nptr == (unsigned long )((void *)0)) {
#line 663
      len = 0;
    } else {
      {
#line 665
      tmp___1 = strchr((char const   *)((char *)nptr + 1), '.');
      }
#line 665
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 667
        len = 0;
      } else {
#line 669
        len = (int )((long )len - ((nptr - ptr) + 1L));
#line 670
        ptr = nptr + 1;
#line 671
        tmp___0 = n;
#line 671
        n ++;
#line 671
        lenv[tmp___0] = (char )' ';
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 675
  lenv[n] = (char)0;
#line 677
  doOut(name, lenv);
  }
#line 678
  return;
}
}
#line 684 "/home/june/collector/temp/bootpc-0.64/bootpc.c"
int in2host(char *address , int bp_pr ) 
{ 
  struct in_addr sin_addr ;
  struct hostent *hp ;
  char *c ;
  size_t tmp ;

  {
  {
#line 691
  printflag = bp_pr;
#line 694
  sin_addr.s_addr = inet_addr((char const   *)address);
#line 699
  hp = gethostbyaddr((void const   *)((char *)(& sin_addr)), (__socklen_t )sizeof(sin_addr),
                     2);
  }
#line 701
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
    {
#line 702
    perror("bootpc: gethostbyaddr");
    }
#line 703
    return (-1);
  }
  {
#line 707
  OutString((char *)"DONEIN2HOST", (unsigned char *)"1", -1);
#line 710
  OutString((char *)"HOSTFULL", (unsigned char *)hp->h_name, -1);
#line 712
  c = hp->h_name;
  }
  {
#line 712
  while (1) {
    while_continue: /* CIL Label */ ;
#line 712
    if (! *c) {
#line 712
      goto while_break;
    }
#line 713
    if ((int )*c == 46) {
      {
#line 715
      OutString((char *)"HOSTDOMAIN", (unsigned char *)(c + 1), -1);
#line 716
      tmp = strlen((char const   *)(c + 1));
#line 716
      OutSearch((char *)"HOSTSEARCH", (unsigned char *)(c + 1), (int )tmp);
#line 717
      *c = (char)0;
#line 718
      OutString((char *)"HOSTLEAF", (unsigned char *)hp->h_name, -1);
      }
#line 719
      return (0);
    }
#line 712
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 721
  return (0);
}
}
#line 726 "/home/june/collector/temp/bootpc-0.64/bootpc.c"
void safecopy(unsigned char *out , unsigned char *string , int len ) 
{ 
  char safe[21] ;
  int i ;
  int c ;
  char *tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 730
  safe[0] = (char )'.';
#line 730
  safe[1] = (char )'/';
#line 730
  safe[2] = (char )':';
#line 730
  safe[3] = (char )'-';
#line 730
  safe[4] = (char )'_';
#line 730
  safe[5] = (char )'=';
#line 730
  safe[6] = (char )'+';
#line 730
  safe[7] = (char )'[';
#line 730
  safe[8] = (char )']';
#line 730
  safe[9] = (char )'~';
#line 730
  safe[10] = (char )'(';
#line 730
  safe[11] = (char )')';
#line 730
  safe[12] = (char )'%';
#line 730
  safe[13] = (char )'&';
#line 730
  safe[14] = (char )'*';
#line 730
  safe[15] = (char )'^';
#line 730
  safe[16] = (char )'#';
#line 730
  safe[17] = (char )'@';
#line 730
  safe[18] = (char )'!';
#line 730
  safe[19] = (char )' ';
#line 730
  safe[20] = (char )'\000';
#line 733
  i = 0;
  {
#line 733
  while (1) {
    while_continue: /* CIL Label */ ;
#line 733
    if (! (i < len)) {
#line 733
      goto while_break;
    }
    {
#line 734
    c = (int )*(string + i);
#line 735
    tmp___0 = __ctype_b_loc();
    }
#line 735
    if ((int const   )*(*tmp___0 + c) & 8) {
#line 736
      *(out + i) = (unsigned char )c;
    } else {
      {
#line 738
      tmp = strchr((char const   *)(safe), c);
      }
#line 738
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 739
        *(out + i) = (unsigned char )c;
      } else {
#line 741
        *(out + i) = (unsigned char )'?';
#line 742
        if (bootp_verbose) {
          {
#line 743
          doLogMessage((char *)"Illegal char 0x%2.2X", c);
          }
        }
      }
    }
#line 733
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 747
  *(out + i) = (unsigned char)0;
#line 748
  return;
}
}
#line 750 "/home/june/collector/temp/bootpc-0.64/bootpc.c"
void doOut(char *name , char *lenv ) 
{ 
  char envb[8192] ;
  char *envp ;

  {
#line 753
  if (printflag & 1) {
    {
#line 754
    printf((char const   */* __restrict  */)"%s=\'%s\'\n", name, lenv);
    }
  }
#line 756
  if (printflag & 2) {
    {
#line 758
    sprintf((char */* __restrict  */)(envb), (char const   */* __restrict  */)"BOOTP_%s=%s",
            name, lenv);
#line 759
    envp = strdup((char const   *)(envb));
    }
#line 760
    if (bootp_debug) {
      {
#line 761
      doLogMessage((char *)"ENV setting :%s:", envp);
      }
    }
    {
#line 762
    putenv(envp);
    }
  }
#line 764
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 356 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 24 "/home/june/collector/temp/bootpc-0.64/main.c"
FILE *logfile  ;
#line 46
int main(int argc , char **argv ) ;
#line 46 "/home/june/collector/temp/bootpc-0.64/main.c"
static struct option long_options[13]  = 
#line 46
  {      {"bootfile", 1, (int *)0, 1}, 
        {"dev", 1, (int *)0, 2}, 
        {"verbose", 0, (int *)0, 3}, 
        {"debug", 0, (int *)0, 4}, 
        {"server", 1, (int *)0, 5}, 
        {"hwaddr", 1, (int *)0, 6}, 
        {"returniffail", 0, (int *)0, 7}, 
        {"timeoutwait", 1, (int *)0, 8}, 
        {"waitformore", 1, (int *)0, 9}, 
        {"in2host", 1, (int *)0, 10}, 
        {"serverbcast", 0, (int *)0, 11}, 
        {"help", 0, (int *)0, 100}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 26 "/home/june/collector/temp/bootpc-0.64/main.c"
int main(int argc , char **argv ) 
{ 
  struct ifreq ifr ;
  int timeout_wait ;
  int waitformore ;
  int givenhwaddr ;
  int i ;
  int serverbcast ;
  char *device ;
  char *bootfile ;
  char *server ;
  int returniffail___0 ;
  int printflag___0 ;
  int option_index ;
  int option ;
  int tmp ;
  int tmp___0 ;
  int error ;
  int count ;
  unsigned int value ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 30
  timeout_wait = 70;
#line 31
  waitformore = -1;
#line 32
  serverbcast = 0;
#line 34
  returniffail___0 = 0;
#line 34
  printflag___0 = 1;
#line 36
  logfile = stderr;
#line 39
  device = (char *)"eth0";
#line 40
  bootfile = (char *)"";
#line 41
  server = (char *)"255.255.255.255";
#line 42
  givenhwaddr = 0;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 45
    option_index = 0;
#line 62
    option = getopt_long(argc, (char * const  *)argv, "", (struct option  const  *)(long_options),
                         & option_index);
    }
#line 64
    if (option == -1) {
#line 65
      goto while_break;
    }
    {
#line 68
    if (option == 1) {
#line 68
      goto case_1;
    }
#line 76
    if (option == 2) {
#line 76
      goto case_2;
    }
#line 84
    if (option == 3) {
#line 84
      goto case_3;
    }
#line 87
    if (option == 4) {
#line 87
      goto case_4;
    }
#line 90
    if (option == 5) {
#line 90
      goto case_5;
    }
#line 93
    if (option == 6) {
#line 93
      goto case_6;
    }
#line 115
    if (option == 7) {
#line 115
      goto case_7;
    }
#line 118
    if (option == 8) {
#line 118
      goto case_8;
    }
#line 121
    if (option == 9) {
#line 121
      goto case_9;
    }
#line 124
    if (option == 10) {
#line 124
      goto case_10;
    }
#line 128
    if (option == 11) {
#line 128
      goto case_11;
    }
#line 131
    if (option == 100) {
#line 131
      goto case_100;
    }
#line 134
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 69
    bootfile = optarg;
#line 70
    tmp = (int )strlen(bootfile);
    }
#line 70
    if (tmp > 127) {
#line 71
      if (bootp_verbose) {
        {
#line 72
        doLogMessage((char *)"Bootfile %s too long, truncating", bootfile);
        }
      }
#line 73
      *(bootfile + 127) = (char)0;
    }
#line 75
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 77
    device = optarg;
#line 78
    tmp___0 = (int )strlen(device);
    }
#line 78
    if (tmp___0 > 15) {
#line 79
      if (bootp_verbose) {
        {
#line 80
        doLogMessage((char *)"device name %s too long, truncating", device);
        }
      }
#line 81
      *(device + 15) = (char)0;
    }
#line 83
    goto switch_break;
    case_3: /* CIL Label */ 
#line 85
    bootp_verbose = 1;
#line 86
    goto switch_break;
    case_4: /* CIL Label */ 
#line 88
    bootp_debug = 1;
#line 89
    goto switch_break;
    case_5: /* CIL Label */ 
#line 91
    server = optarg;
#line 92
    goto switch_break;
    case_6: /* CIL Label */ 
#line 102
    i = 0;
    {
#line 102
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 102
      if (! (i < 6)) {
#line 102
        goto while_break___0;
      }
      {
#line 103
      error = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%2x%n%*[ :.]%n",
                     & value, & count, & count);
#line 104
      ifr.ifr_ifru.ifru_hwaddr.sa_data[i] = (char )value;
      }
#line 105
      if (error <= 0) {
#line 106
        if (bootp_debug) {
          {
#line 107
          doLogMessage((char *)"Ran out of numbers in hwaddr, ignoring");
          }
        }
#line 108
        goto while_break___0;
      }
#line 110
      optarg += count;
#line 102
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 112
    givenhwaddr = 1;
#line 114
    goto switch_break;
    case_7: /* CIL Label */ 
#line 116
    returniffail___0 = 1;
#line 117
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 119
    timeout_wait = atoi((char const   *)optarg);
    }
#line 120
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 122
    waitformore = atoi((char const   *)optarg);
    }
#line 123
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 126
    tmp___1 = in2host(optarg, printflag___0);
    }
#line 126
    return (tmp___1);
#line 127
    goto switch_break;
    case_11: /* CIL Label */ 
#line 129
    serverbcast = 1;
#line 130
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 132
    doLogMessage((char *)"%s is used to find the IP number and other setup\ninformation for a machine",
                 *(argv + 0));
    }
    switch_default: /* CIL Label */ 
    {
#line 135
    doLogMessage((char *)"\t%s", "BOOTPclient V0.64");
#line 136
    doLogMessage((char *)"Usage: %s\t[--dev device] [--bootfile file] [--bootp_verbose]\n\t\t[--server address] [--hwaddr mac-address]\n\t\t[--timeoutwait seconds] [--serverbcast]\n\t\t[--waitformore seconds]\n\t\t[--in2host address]\n\t\t[--help] [--returniffail]",
                 *(argv + 0));
#line 143
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  if (bootp_verbose) {
    {
#line 148
    doLogMessage((char *)"\t%s\n\tdevice=%s  bootfile=%s timeout=%d\n", "BOOTPclient V0.64",
                 device, bootfile, timeout_wait);
    }
  }
  {
#line 153
  tmp___2 = performBootp(device, server, bootfile, timeout_wait, givenhwaddr, & ifr,
                         waitformore, returniffail___0, printflag___0, serverbcast);
  }
#line 153
  return (tmp___2);
}
}
#line 160 "/home/june/collector/temp/bootpc-0.64/main.c"
void doLogMessage(char *s  , ...) 
{ 
  va_list args ;

  {
  {
#line 163
  __builtin_va_start(args, s);
#line 164
  fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"* ");
#line 165
  vfprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)s, args);
#line 166
  fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"\n");
#line 167
  __builtin_va_end(args);
  }
#line 168
  return;
}
}
