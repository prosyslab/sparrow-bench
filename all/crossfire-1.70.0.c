/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 671 "../include/define.h"
typedef unsigned char MoveType;
#line 37 "../include/logger.h"
enum LogLevel {
    llevError = 0,
    llevInfo = 1,
    llevDebug = 2,
    llevMonster = 3
} ;
#line 37 "../include/logger.h"
typedef enum LogLevel LogLevel;
#line 681 "../include/shared/newclient.h"
struct SockList {
   size_t len ;
   unsigned char buf[65538] ;
};
#line 681 "../include/shared/newclient.h"
typedef struct SockList SockList;
#line 58 "../include/global.h"
typedef unsigned int uint32;
#line 64 "../include/global.h"
typedef int sint32;
#line 67 "../include/global.h"
typedef unsigned short uint16;
#line 72 "../include/global.h"
typedef short sint16;
#line 75 "../include/global.h"
typedef unsigned char uint8;
#line 80 "../include/global.h"
typedef signed char sint8;
#line 84 "../include/global.h"
typedef char const   *sstring;
#line 105 "../include/global.h"
typedef unsigned long uint64;
#line 106 "../include/global.h"
typedef long sint64;
#line 42 "../include/face.h"
struct new_face_struct {
   uint16 number ;
   uint8 visibility ;
   uint8 magicmap ;
   uint16 smoothface ;
   char const   *name ;
};
#line 42 "../include/face.h"
typedef struct new_face_struct New_Face;
#line 64 "../include/living.h"
struct liv {
   sint8 Str ;
   sint8 Dex ;
   sint8 Con ;
   sint8 Wis ;
   sint8 Cha ;
   sint8 Int ;
   sint8 Pow ;
   sint8 wc ;
   sint8 ac ;
   sint8 luck ;
   sint16 hp ;
   sint16 maxhp ;
   sint16 sp ;
   sint16 maxsp ;
   sint16 grace ;
   sint16 maxgrace ;
   sint16 dam ;
   sint64 exp ;
   sint32 food ;
};
#line 64 "../include/living.h"
typedef struct liv living;
#line 9 "../include/dialog.h"
enum __anonenum_reply_type_58 {
    rt_say = 0,
    rt_reply = 1,
    rt_question = 2
} ;
#line 9 "../include/dialog.h"
typedef enum __anonenum_reply_type_58 reply_type;
#line 18 "../include/dialog.h"
struct struct_dialog_reply {
   char *reply ;
   char *message ;
   reply_type type ;
   struct struct_dialog_reply *next ;
};
#line 28 "../include/dialog.h"
struct struct_dialog_message {
   char *match ;
   char *message ;
   struct struct_dialog_reply *replies ;
   struct struct_dialog_message *next ;
};
#line 38 "../include/dialog.h"
struct struct_dialog_information {
   struct struct_dialog_reply *all_replies ;
   struct struct_dialog_message *all_messages ;
};
#line 51
struct obj;
#line 40 "../include/object.h"
typedef uint32 tag_t;
#line 66 "../include/object.h"
struct _key_value {
   char const   *key ;
   char const   *value ;
   struct _key_value *next ;
};
#line 66 "../include/object.h"
typedef struct _key_value key_value;
#line 132
struct pl;
#line 132
struct mapdef;
#line 132
struct treasureliststruct;
#line 132
struct archt;
#line 132 "../include/object.h"
struct obj {
   struct pl *contr ;
   struct obj *next ;
   struct obj *prev ;
   struct obj *active_next ;
   struct obj *active_prev ;
   struct obj *below ;
   struct obj *above ;
   struct obj *inv ;
   struct obj *container ;
   struct obj *env ;
   struct obj *more ;
   struct obj *head ;
   struct mapdef *map ;
   tag_t count ;
   struct struct_dialog_information *dialog_information ;
   sstring artifact ;
   char const   *name ;
   char const   *name_pl ;
   char const   *anim_suffix ;
   char const   *title ;
   char const   *race ;
   char const   *slaying ;
   char const   *skill ;
   char const   *msg ;
   char const   *lore ;
   sint16 x ;
   sint16 y ;
   sint16 ox ;
   sint16 oy ;
   float speed ;
   float speed_left ;
   float weapon_speed ;
   float weapon_speed_left ;
   New_Face const   *face ;
   uint32 nrof ;
   sint8 direction ;
   sint8 facing ;
   uint8 type ;
   uint8 subtype ;
   uint16 client_type ;
   sint16 resist[26] ;
   uint32 attacktype ;
   uint32 path_attuned ;
   uint32 path_repelled ;
   uint32 path_denied ;
   char const   *materialname ;
   uint16 material ;
   sint8 magic ;
   uint8 state ;
   sint32 value ;
   sint16 level ;
   sint32 last_eat ;
   sint32 last_heal ;
   sint32 last_sp ;
   sint16 last_grace ;
   sint16 invisible ;
   uint8 pick_up ;
   sint8 item_power ;
   sint8 gen_sp_armour ;
   sint8 glow_radius ;
   sint32 weight ;
   sint32 weight_limit ;
   sint32 carrying ;
   living stats ;
   sint64 perm_exp ;
   struct obj *current_weapon ;
   uint32 weapontype ;
   sint8 body_info[13] ;
   sint8 body_used[13] ;
   struct obj *owner ;
   tag_t ownercount ;
   struct obj *enemy ;
   struct obj *attacked_by ;
   tag_t attacked_by_count ;
   uint16 run_away ;
   struct treasureliststruct *randomitems ;
   struct obj *chosen_skill ;
   uint32 hide ;
   sint32 move_status ;
   uint16 attack_movement ;
   uint8 will_apply ;
   sint8 sound_chance ;
   struct obj *spellitem ;
   double expmul ;
   sint16 casting_time ;
   sint16 duration ;
   uint8 duration_modifier ;
   sint8 range ;
   uint8 range_modifier ;
   uint8 dam_modifier ;
   struct obj *spell ;
   char *spellarg ;
   struct archt *arch ;
   struct archt *other_arch ;
   uint32 flags[4] ;
   uint16 animation_id ;
   uint8 anim_speed ;
   uint8 last_anim ;
   uint16 temp_animation_id ;
   uint8 temp_anim_speed ;
   sint32 elevation ;
   uint8 smoothlevel ;
   uint8 map_layer ;
   MoveType move_type ;
   MoveType move_block ;
   MoveType move_allow ;
   MoveType move_on ;
   MoveType move_off ;
   MoveType move_slow ;
   float move_slow_penalty ;
   char const   *custom_name ;
   key_value *key_values ;
   sint16 *discrete_damage ;
   tag_t *spell_tags ;
};
#line 132 "../include/object.h"
typedef struct obj object;
#line 297 "../include/object.h"
struct oblnk {
   object *ob ;
   struct oblnk *next ;
   tag_t id ;
};
#line 306 "../include/object.h"
struct oblinkpt {
   struct oblnk *link ;
   long value ;
   struct oblinkpt *next ;
};
#line 306 "../include/object.h"
typedef struct oblinkpt oblinkpt;
#line 320 "../include/object.h"
struct archt {
   char const   *name ;
   struct archt *next ;
   struct archt *head ;
   struct archt *more ;
   object clone ;
   sint8 tail_x ;
   sint8 tail_y ;
   int reference_count ;
};
#line 286 "../include/map.h"
struct MapSpace {
   object *bottom ;
   object *top ;
   object *faces_obj[10] ;
   uint8 flags ;
   sint8 light ;
   MoveType move_block ;
   MoveType move_slow ;
   MoveType move_on ;
   MoveType move_off ;
   object *pl ;
};
#line 286 "../include/map.h"
typedef struct MapSpace MapSpace;
#line 304 "../include/map.h"
struct regiondef {
   struct regiondef *next ;
   char *name ;
   char *parent_name ;
   struct regiondef *parent ;
   char *longname ;
   char *msg ;
   uint32 counter ;
   sint8 fallback ;
   char *jailmap ;
   sint16 jailx ;
   sint16 jaily ;
};
#line 333 "../include/map.h"
struct shopitem {
   char const   *name ;
   char const   *name_pl ;
   int typenum ;
   sint8 strength ;
   int index ;
};
#line 353 "../include/map.h"
struct mapdef {
   struct mapdef *next ;
   char *tmpname ;
   char *name ;
   struct regiondef *region ;
   uint32 reset_time ;
   uint32 reset_timeout ;
   uint32 fixed_resettime : 1 ;
   uint32 unique : 1 ;
   uint32 is_template : 1 ;
   uint32 nosmooth : 1 ;
   uint32 outdoor : 1 ;
   sint32 timeout ;
   sint32 swap_time ;
   uint16 difficulty ;
   sint16 players ;
   uint32 in_memory ;
   uint8 darkness ;
   uint16 width ;
   uint16 height ;
   sint16 enter_x ;
   sint16 enter_y ;
   oblinkpt *buttons ;
   MapSpace *spaces ;
   struct shopitem *shopitems ;
   char *shoprace ;
   double shopgreed ;
   uint64 shopmin ;
   uint64 shopmax ;
   char *msg ;
   char *maplore ;
   char *tile_path[4] ;
   struct mapdef *tile_map[4] ;
   char path[4096] ;
   struct timeval last_reset_time ;
   char *background_music ;
};
#line 54 "../include/account_char.h"
struct account_char_struct {
   char const   *name ;
   char const   *character_class ;
   char const   *race ;
   uint8 level ;
   char const   *face ;
   char const   *party ;
   char const   *map ;
   struct account_char_struct *next ;
};
#line 54 "../include/account_char.h"
typedef struct account_char_struct Account_Char;
#line 59 "../include/newserver.h"
struct map_cell_struct {
   uint16 faces[10] ;
   uint16 smooth[10] ;
   int darkness ;
};
#line 77 "../include/newserver.h"
struct Map {
   struct map_cell_struct cells[33][33] ;
};
#line 85 "../include/newserver.h"
struct statsinfo {
   char *range ;
   char *title ;
};
#line 93
enum Sock_Status {
    Ns_Avail = 0,
    Ns_Add = 1,
    Ns_Dead = 2
} ;
#line 104 "../include/newserver.h"
struct listen_info {
   int family ;
   int socktype ;
   int protocol ;
   socklen_t addrlen ;
   struct sockaddr *addr ;
};
#line 116 "../include/newserver.h"
struct buffer_struct {
   char data[262144] ;
   int start ;
   int len ;
};
#line 116 "../include/newserver.h"
typedef struct buffer_struct buffer_struct;
#line 128 "../include/newserver.h"
struct socket_struct {
   enum Sock_Status status ;
   int fd ;
   struct listen_info *listen ;
   struct Map lastmap ;
   sint8 map_scroll_x ;
   sint8 map_scroll_y ;
   size_t faces_sent_len ;
   uint8 *faces_sent ;
   uint8 anims_sent[2000] ;
   struct statsinfo stats ;
   SockList inbuf ;
   char *host ;
   buffer_struct outputbuffer ;
   uint8 password_fails ;
   uint32 facecache : 1 ;
   uint32 darkness : 1 ;
   uint32 update_look : 1 ;
   uint32 update_inventory : 1 ;
   uint32 can_write : 1 ;
   uint32 tick : 1 ;
   uint32 is_bot : 1 ;
   uint32 want_pickup : 1 ;
   uint32 extended_stats : 1 ;
   uint32 monitor_spells ;
   uint32 sound ;
   uint32 cs_version ;
   uint32 sc_version ;
   uint16 look_position ;
   uint16 container_position ;
   uint8 mapx ;
   uint8 mapy ;
   uint8 faceset ;
   sint8 sounds_this_tick ;
   uint8 num_look_objects ;
   char *account_name ;
   Account_Char *account_chars ;
   uint8 login_method ;
   uint16 notifications ;
};
#line 128 "../include/newserver.h"
typedef struct socket_struct socket_struct;
#line 180 "../include/newserver.h"
struct Socket_Info {
   struct timeval timeout ;
   int max_filedescriptor ;
   int allocated_sockets ;
};
#line 180 "../include/newserver.h"
typedef struct Socket_Info Socket_Info;
#line 38 "../include/party.h"
struct party_struct {
   char *partyleader ;
   char passwd[9] ;
   struct party_struct *next ;
   char *partyname ;
};
#line 38 "../include/party.h"
typedef struct party_struct partylist;
#line 43 "../include/player.h"
enum rangetype {
    range_bottom = -1,
    range_none = 0,
    range_bow = 1,
    range_magic = 2,
    range_misc = 3,
    range_golem = 4,
    range_skill = 5,
    range_builder = 6,
    range_size = 7
} ;
#line 43 "../include/player.h"
typedef enum rangetype rangetype;
#line 56
enum _bowtype {
    bow_normal = 0,
    bow_threewide = 1,
    bow_spreadshot = 2,
    bow_n = 3,
    bow_ne = 4,
    bow_e = 5,
    bow_se = 6,
    bow_s = 7,
    bow_sw = 8,
    bow_w = 9,
    bow_nw = 10,
    bow_bestarrow = 11
} ;
#line 56 "../include/player.h"
typedef enum _bowtype bowtype_t;
#line 72
enum _petmode {
    pet_normal = 0,
    pet_sad = 1,
    pet_defend = 2,
    pet_arena = 3
} ;
#line 72 "../include/player.h"
typedef enum _petmode petmode_t;
#line 80
enum usekeytype {
    key_inventory = 0,
    keyrings = 1,
    containers = 2
} ;
#line 80 "../include/player.h"
typedef enum usekeytype usekeytype;
#line 90
enum unapplymode {
    unapply_nochoice = 0,
    unapply_never = 1,
    unapply_always = 2
} ;
#line 90 "../include/player.h"
typedef enum unapplymode unapplymode;
#line 102 "../include/player.h"
struct client_spell {
   object *spell ;
   sint16 last_sp ;
   sint16 last_grace ;
   sint16 last_dam ;
   struct client_spell *next ;
};
#line 102 "../include/player.h"
typedef struct client_spell client_spell;
#line 113
enum party_rejoin_mode {
    party_rejoin_no = 0,
    party_rejoin_if_exists = 1,
    party_rejoin_always = 2
} ;
#line 113 "../include/player.h"
typedef enum party_rejoin_mode party_rejoin_mode;
#line 120 "../include/player.h"
struct pl {
   struct pl *next ;
   socket_struct socket ;
   char maplevel[256] ;
   char savebed_map[256] ;
   sint16 bed_x ;
   sint16 bed_y ;
   rangetype shoottype ;
   char spellparam[256] ;
   bowtype_t bowtype ;
   petmode_t petmode ;
   object *ranges[7] ;
   uint32 golem_count ;
   usekeytype usekeys ;
   unapplymode unapply ;
   uint32 count ;
   uint32 mode ;
   sint16 digestion ;
   sint16 gen_hp ;
   sint16 gen_sp ;
   sint16 gen_sp_armour ;
   sint16 gen_grace ;
   sint16 item_power ;
   uint8 state ;
   uint8 listening ;
   sint8 last_level ;
   uint32 braced : 1 ;
   uint32 tmp_invis : 1 ;
   uint32 do_los : 1 ;
   uint32 fire_on : 1 ;
   uint32 run_on : 1 ;
   uint32 has_hit : 1 ;
   uint32 name_changed : 1 ;
   uint32 peaceful : 1 ;
   uint32 hidden : 1 ;
   uint32 no_shout : 1 ;
   uint32 has_directory : 1 ;
   char const   *invis_race ;
   object *last_skill_ob[44] ;
   sint64 last_skill_exp[44] ;
   float last_weapon_sp ;
   uint16 last_flags ;
   sint32 last_weight ;
   sint32 last_weight_limit ;
   uint32 last_path_attuned ;
   uint32 last_path_repelled ;
   uint32 last_path_denied ;
   int swap_first ;
   living orig_stats ;
   living last_stats ;
   living last_orig_stats ;
   living last_race_stats ;
   living applied_stats ;
   living last_applied_stats ;
   float last_speed ;
   sint16 last_resist[26] ;
   sint16 last_golem_hp ;
   sint16 last_golem_maxhp ;
   object *ob ;
   object *last_used ;
   uint32 last_used_id ;
   sint8 blocked_los[25][25] ;
   char own_title[48] ;
   char title[32] ;
   sint8 levhp[11] ;
   sint8 levsp[11] ;
   sint8 levgrace[11] ;
   char killer[32] ;
   char last_tell[48] ;
   char write_buf[256] ;
   char input_buf[256] ;
   char password[16] ;
   char new_password[16] ;
   sint16 encumbrance ;
   uint32 last_save_tick ;
   partylist *party ;
   partylist *party_to_join ;
   party_rejoin_mode rejoin_party ;
   char search_str[256] ;
   uint32 mark_count ;
   object *mark ;
   object *transport ;
   client_spell *spell_state ;
   tag_t *stack_items ;
   sstring followed_player ;
   int stack_position ;
   int language ;
   char const   *unarmed_skill ;
   uint32 ticks_played ;
};
#line 120 "../include/player.h"
typedef struct pl player;
#line 79 "../include/treasure.h"
struct _change_arch {
   char const   *name ;
   char const   *title ;
   char const   *slaying ;
};
#line 91 "../include/treasure.h"
struct treasurestruct {
   struct archt *item ;
   char const   *name ;
   struct treasurestruct *next ;
   struct treasurestruct *next_yes ;
   struct treasurestruct *next_no ;
   struct _change_arch change_arch ;
   uint8 chance ;
   uint8 magic ;
   uint16 nrof ;
};
#line 110 "../include/treasure.h"
struct treasureliststruct {
   char const   *name ;
   sint16 total_chance ;
   struct treasureliststruct *next ;
   struct treasurestruct *items ;
};
#line 162 "../include/global.h"
struct linked_char {
   char const   *name ;
   struct linked_char *next ;
};
#line 162 "../include/global.h"
typedef struct linked_char linked_char;
#line 333 "../include/global.h"
struct Settings {
   char const   *logfilename ;
   uint16 csport ;
   LogLevel debug ;
   uint8 dumpvalues ;
   char const   *dumparg ;
   uint8 daemonmode ;
   int argc ;
   char **argv ;
   char const   *confdir ;
   char const   *datadir ;
   char const   *localdir ;
   char const   *playerdir ;
   char const   *mapdir ;
   char const   *archetypes ;
   char const   *regions ;
   char const   *treasures ;
   char const   *uniquedir ;
   char const   *templatedir ;
   char const   *tmpdir ;
   uint8 stat_loss_on_death ;
   sint16 pk_luck_penalty ;
   uint8 permanent_exp_ratio ;
   uint8 death_penalty_ratio ;
   uint8 death_penalty_level ;
   uint8 balanced_stat_loss ;
   uint8 not_permadeth ;
   uint8 simple_exp ;
   int reset_loc_time ;
   uint8 set_title ;
   uint8 resurrection ;
   uint8 search_items ;
   uint8 spell_encumbrance ;
   uint8 spell_failure_effects ;
   uint8 casting_time ;
   uint8 real_wiz ;
   uint8 recycle_tmp_maps ;
   uint8 spellpoint_level_depend ;
   uint16 set_friendly_fire ;
   char who_format[256] ;
   char who_wiz_format[256] ;
   char motd[256] ;
   char const   *rules ;
   char const   *news ;
   char dm_mail[256] ;
   unsigned int meta_on : 1 ;
   char meta_server[256] ;
   char meta_host[256] ;
   uint16 meta_port ;
   char meta_comment[256] ;
   uint32 worldmapstartx ;
   uint32 worldmapstarty ;
   uint32 worldmaptilesx ;
   uint32 worldmaptilesy ;
   uint32 worldmaptilesizex ;
   uint32 worldmaptilesizey ;
   uint8 fastclock ;
   char *emergency_mapname ;
   uint16 emergency_x ;
   uint16 emergency_y ;
   sint16 max_level ;
   float item_power_factor ;
   int armor_max_enchant ;
   int armor_weight_reduction ;
   uint8 armor_weight_linear ;
   int armor_speed_improvement ;
   uint8 armor_speed_linear ;
   uint8 no_player_stealing ;
   uint8 create_home_portals ;
   uint8 personalized_blessings ;
   sint64 pk_max_experience ;
   int pk_max_experience_percent ;
   int allow_denied_spells_writing ;
   int allow_broken_converters ;
   int log_timestamp ;
   char *log_timestamp_format ;
   uint8 starting_stat_min ;
   uint8 starting_stat_max ;
   uint8 starting_stat_points ;
   uint8 roll_stat_points ;
   uint8 max_stat ;
   uint8 special_break_map ;
   linked_char *disabled_plugins ;
   uint8 ignore_plugin_compatibility ;
};
#line 333 "../include/global.h"
typedef struct Settings Settings;
#line 84 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account.c"
struct account_struct {
   char *name ;
   char *password ;
   time_t last_login ;
   int num_characters ;
   char *character_names[18] ;
   time_t created ;
   struct account_struct *next ;
};
#line 84 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account.c"
typedef struct account_struct account_struct;
#line 304 "../include/map.h"
typedef struct regiondef region;
#line 353 "../include/map.h"
typedef struct mapdef mapstruct;
#line 48 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/los.c"
struct blstr {
   int x[4] ;
   int y[4] ;
   int index ;
};
#line 48 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/los.c"
typedef struct blstr blocks;
#line 320 "../include/object.h"
typedef struct archt archetype;
#line 37 "../include/artifact.h"
struct artifactstruct {
   object *item ;
   uint16 chance ;
   uint8 difficulty ;
   struct artifactstruct *next ;
   linked_char *allowed ;
   int allowed_size ;
};
#line 37 "../include/artifact.h"
typedef struct artifactstruct artifact;
#line 49 "../include/artifact.h"
struct artifactliststruct {
   uint8 type ;
   uint16 total_chance ;
   struct artifactliststruct *next ;
   struct artifactstruct *items ;
};
#line 49 "../include/artifact.h"
typedef struct artifactliststruct artifactlist;
#line 65 "../include/commands.h"
struct __anonstruct_command_array_struct_60 {
   char const   *name ;
   void (*func)(object *op , char const   *params ) ;
   float time ;
};
#line 65 "../include/commands.h"
typedef struct __anonstruct_command_array_struct_60 command_array_struct;
#line 41 "../include/ob_methods.h"
typedef char method_ret;
#line 65
struct ob_methods;
#line 65 "../include/ob_methods.h"
typedef struct ob_methods ob_methods;
#line 72 "../include/ob_methods.h"
struct ob_methods {
   method_ret (*apply)(ob_methods * , object * , object * , int  ) ;
   method_ret (*process)(ob_methods * , object * ) ;
   void (*describe)(ob_methods const   * , object const   * , object const   * , char *buf ,
                    size_t size ) ;
   method_ret (*move_on)(ob_methods * , object * , object * , object * ) ;
   method_ret (*trigger)(ob_methods * , object * , object * , int  ) ;
   struct ob_methods *fallback ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 110 "../include/treasure.h"
typedef struct treasureliststruct treasurelist;
#line 53 "../include/stringbuffer.h"
struct StringBuffer;
#line 53 "../include/stringbuffer.h"
typedef struct StringBuffer StringBuffer;
#line 10 "../include/recipe.h"
struct recipestruct {
   sstring title ;
   size_t arch_names ;
   char **arch_name ;
   int chance ;
   int diff ;
   int exp ;
   int index ;
   int transmute ;
   int yield ;
   linked_char *ingred ;
   int ingred_count ;
   struct recipestruct *next ;
   sstring keycode ;
   sstring skill ;
   sstring cauldron ;
   sstring failure_arch ;
   sstring failure_message ;
   int min_level ;
   int is_combination ;
   char **tool ;
   size_t tool_size ;
};
#line 10 "../include/recipe.h"
typedef struct recipestruct recipe;
#line 37 "../include/recipe.h"
struct recipeliststruct {
   int total_chance ;
   int number ;
   struct recipestruct *items ;
   struct recipeliststruct *next ;
};
#line 37 "../include/recipe.h"
typedef struct recipeliststruct recipelist;
#line 54 "../include/face.h"
struct animations_struct {
   char const   *name ;
   uint8 num_animations ;
   uint8 facings ;
   uint16 num ;
   New_Face const   **faces ;
};
#line 54 "../include/face.h"
typedef struct animations_struct Animations;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 48 "../include/object.h"
struct body_locations_struct {
   char const   *save_name ;
   char const   *use_name ;
   char const   *nonuse_name ;
};
#line 48 "../include/object.h"
typedef struct body_locations_struct body_locations_struct;
#line 297 "../include/object.h"
typedef struct oblnk objectlink;
#line 91 "../include/treasure.h"
typedef struct treasurestruct treasure;
#line 467 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
struct __anonstruct_chars_names_64 {
   char namebuf[256] ;
   int login_order ;
};
#line 467 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
typedef struct __anonstruct_chars_names_64 chars_names;
#line 146 "../include/attack.h"
struct attackmess {
   int level ;
   char *buf1 ;
   char *buf2 ;
   char *buf3 ;
};
#line 146 "../include/attack.h"
typedef struct attackmess attackmess_t;
#line 153 "../include/attack.h"
struct __anonstruct_Chaos_Attacks_57 {
   int attacktype ;
   int face ;
};
#line 153 "../include/attack.h"
typedef struct __anonstruct_Chaos_Attacks_57 Chaos_Attacks;
#line 62 "../include/material.h"
struct _materialtype {
   char const   *name ;
   char const   *description ;
   int material ;
   sint8 save[26] ;
   sint8 mod[26] ;
   struct _materialtype *next ;
};
#line 62 "../include/material.h"
typedef struct _materialtype materialtype_t;
#line 49 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
struct quest_state {
   sstring code ;
   int state ;
   int was_completed ;
   int is_complete ;
   int sent_to_client ;
   struct quest_state *next ;
};
#line 49 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
typedef struct quest_state quest_state;
#line 59 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
struct quest_player {
   sstring player_name ;
   struct quest_state *quests ;
   struct quest_player *next ;
};
#line 59 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
typedef struct quest_player quest_player;
#line 68 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
struct quest_condition {
   sstring quest_code ;
   int minstep ;
   int maxstep ;
   struct quest_condition *next ;
};
#line 68 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
typedef struct quest_condition quest_condition;
#line 78 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
struct quest_step_definition {
   int step ;
   sstring step_description ;
   int is_completion_step : 1 ;
   struct quest_step_definition *next ;
   quest_condition *conditions ;
};
#line 78 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
typedef struct quest_step_definition quest_step_definition;
#line 87 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
struct quest_definition {
   sstring quest_code ;
   sstring quest_title ;
   sstring quest_description ;
   int quest_restart ;
   int face ;
   uint32 client_code ;
   quest_step_definition *steps ;
   struct quest_definition *parent ;
   struct quest_definition *next ;
};
#line 87 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
typedef struct quest_definition quest_definition;
#line 337 "../include/define.h"
struct typedata {
   int number ;
   char const   *name ;
   char const   *name_pl ;
   int identifyskill ;
   int identifyskill2 ;
};
#line 337 "../include/define.h"
typedef struct typedata typedata;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 61 "../../include/tod.h"
struct _timeofday {
   int year ;
   int month ;
   int day ;
   int dayofweek ;
   int hour ;
   int minute ;
   int weekofmonth ;
   int season ;
   int periodofday ;
};
#line 61 "../../include/tod.h"
typedef struct _timeofday timeofday_t;
#line 42 "../../include/../random_maps/random_map.h"
struct RMParms {
   char wallstyle[512] ;
   char wall_name[512] ;
   char floorstyle[512] ;
   char monsterstyle[512] ;
   char treasurestyle[512] ;
   char layoutstyle[512] ;
   char doorstyle[512] ;
   char decorstyle[512] ;
   char origin_map[512] ;
   char final_map[512] ;
   char final_exit_archetype[512] ;
   char exitstyle[512] ;
   char this_map[512] ;
   char exit_on_final_map[512] ;
   char dungeon_name[512] ;
   int Xsize ;
   int Ysize ;
   int expand2x ;
   int layoutoptions1 ;
   int layoutoptions2 ;
   int symmetry ;
   int difficulty ;
   int difficulty_given ;
   float difficulty_increase ;
   int dungeon_level ;
   int dungeon_depth ;
   int decoroptions ;
   int orientation ;
   int origin_y ;
   int origin_x ;
   int random_seed ;
   int map_layout_style ;
   unsigned long total_map_hp ;
   int treasureoptions ;
   int symmetry_used ;
   struct regiondef *region ;
   int multiple_floors ;
};
#line 42 "../../include/../random_maps/random_map.h"
typedef struct RMParms RMParms;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 42 "./include/cfanim.h"
enum time_enum {
    time_second = 0,
    time_tick = 1
} ;
#line 48
enum anim_move_result {
    mr_finished = 0,
    mr_again = 1
} ;
#line 48 "./include/cfanim.h"
typedef enum anim_move_result anim_move_result;
#line 53
struct CFanimation_struct;
#line 54
struct CFmovement_struct;
#line 61 "./include/cfanim.h"
struct CFmovement_struct {
   struct CFanimation_struct *parent ;
   anim_move_result (*func)(struct CFanimation_struct *animation , long id , void *parameters ) ;
   void *parameters ;
   long id ;
   int tick ;
   struct CFmovement_struct *next ;
};
#line 61 "./include/cfanim.h"
typedef struct CFmovement_struct CFmovement;
#line 71 "./include/cfanim.h"
struct CFanimation_struct {
   char *name ;
   object *victim ;
   object *event ;
   int paralyze ;
   int invisible ;
   int wizard ;
   int unique ;
   int verbose ;
   int ghosted ;
   int errors_allowed ;
   int delete_end ;
   object *corpse ;
   long tick_left ;
   enum time_enum time_representation ;
   struct CFmovement_struct *nextmovement ;
   struct CFanimation_struct *nextanimation ;
};
#line 71 "./include/cfanim.h"
typedef struct CFanimation_struct CFanimation;
#line 91 "./include/cfanim.h"
struct __anonstruct_CFanimationHook_63 {
   char const   *name ;
   long (*funcinit)(char const   *name , char *parameters , struct CFmovement_struct * ) ;
   anim_move_result (*funcrun)(struct CFanimation_struct *animation , long id , void *parameters ) ;
};
#line 91 "./include/cfanim.h"
typedef struct __anonstruct_CFanimationHook_63 CFanimationHook;
#line 324 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
struct __anonstruct_teleport_params_64 {
   char *mapname ;
   int mapx ;
   int mapy ;
};
#line 324 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
typedef struct __anonstruct_teleport_params_64 teleport_params;
#line 407 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
struct __anonstruct_param_moveto_65 {
   int x ;
   int y ;
};
#line 407 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
typedef struct __anonstruct_param_moveto_65 param_moveto;
#line 51 "../../include/dialog.h"
struct talk_info {
   struct obj *who ;
   char const   *text ;
   sstring message ;
   int message_type ;
   int replies_count ;
   sstring replies_words[10] ;
   sstring replies[10] ;
   int npc_msg_count ;
   sstring npc_msgs[5] ;
};
#line 51 "../../include/dialog.h"
typedef struct talk_info talk_info;
#line 114 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
struct __anonstruct_spawn_point_63 {
   int x ;
   int y ;
};
#line 114 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
typedef struct __anonstruct_spawn_point_63 spawn_point;
#line 123 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
struct __anonstruct_spawn_zone_64 {
   int sx ;
   int sy ;
   int ex ;
   int ey ;
};
#line 123 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
typedef struct __anonstruct_spawn_zone_64 spawn_zone;
#line 130 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
struct __anonstruct_mapzone_65 {
   spawn_point const   *points ;
   int count_points ;
   spawn_zone const   *zones ;
   int count_zones ;
   int population ;
   char const   *mapname ;
   char const   * const  *available_archetypes ;
   int archetypes_count ;
};
#line 130 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
typedef struct __anonstruct_mapzone_65 mapzone;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 183 "/usr/include/python2.7/pyport.h"
typedef ssize_t Py_ssize_t;
#line 106 "/usr/include/python2.7/object.h"
struct _typeobject;
#line 106 "/usr/include/python2.7/object.h"
struct _object {
   Py_ssize_t ob_refcnt ;
   struct _typeobject *ob_type ;
};
#line 106 "/usr/include/python2.7/object.h"
typedef struct _object PyObject;
#line 164 "/usr/include/python2.7/object.h"
struct bufferinfo {
   void *buf ;
   PyObject *obj ;
   Py_ssize_t len ;
   Py_ssize_t itemsize ;
   int readonly ;
   int ndim ;
   char *format ;
   Py_ssize_t *shape ;
   Py_ssize_t *strides ;
   Py_ssize_t *suboffsets ;
   Py_ssize_t smalltable[2] ;
   void *internal ;
};
#line 164 "/usr/include/python2.7/object.h"
typedef struct bufferinfo Py_buffer;
#line 219 "/usr/include/python2.7/object.h"
struct __anonstruct_PyNumberMethods_33 {
   PyObject *(*nb_add)(PyObject * , PyObject * ) ;
   PyObject *(*nb_subtract)(PyObject * , PyObject * ) ;
   PyObject *(*nb_multiply)(PyObject * , PyObject * ) ;
   PyObject *(*nb_divide)(PyObject * , PyObject * ) ;
   PyObject *(*nb_remainder)(PyObject * , PyObject * ) ;
   PyObject *(*nb_divmod)(PyObject * , PyObject * ) ;
   PyObject *(*nb_power)(PyObject * , PyObject * , PyObject * ) ;
   PyObject *(*nb_negative)(PyObject * ) ;
   PyObject *(*nb_positive)(PyObject * ) ;
   PyObject *(*nb_absolute)(PyObject * ) ;
   int (*nb_nonzero)(PyObject * ) ;
   PyObject *(*nb_invert)(PyObject * ) ;
   PyObject *(*nb_lshift)(PyObject * , PyObject * ) ;
   PyObject *(*nb_rshift)(PyObject * , PyObject * ) ;
   PyObject *(*nb_and)(PyObject * , PyObject * ) ;
   PyObject *(*nb_xor)(PyObject * , PyObject * ) ;
   PyObject *(*nb_or)(PyObject * , PyObject * ) ;
   int (*nb_coerce)(PyObject ** , PyObject ** ) ;
   PyObject *(*nb_int)(PyObject * ) ;
   PyObject *(*nb_long)(PyObject * ) ;
   PyObject *(*nb_float)(PyObject * ) ;
   PyObject *(*nb_oct)(PyObject * ) ;
   PyObject *(*nb_hex)(PyObject * ) ;
   PyObject *(*nb_inplace_add)(PyObject * , PyObject * ) ;
   PyObject *(*nb_inplace_subtract)(PyObject * , PyObject * ) ;
   PyObject *(*nb_inplace_multiply)(PyObject * , PyObject * ) ;
   PyObject *(*nb_inplace_divide)(PyObject * , PyObject * ) ;
   PyObject *(*nb_inplace_remainder)(PyObject * , PyObject * ) ;
   PyObject *(*nb_inplace_power)(PyObject * , PyObject * , PyObject * ) ;
   PyObject *(*nb_inplace_lshift)(PyObject * , PyObject * ) ;
   PyObject *(*nb_inplace_rshift)(PyObject * , PyObject * ) ;
   PyObject *(*nb_inplace_and)(PyObject * , PyObject * ) ;
   PyObject *(*nb_inplace_xor)(PyObject * , PyObject * ) ;
   PyObject *(*nb_inplace_or)(PyObject * , PyObject * ) ;
   PyObject *(*nb_floor_divide)(PyObject * , PyObject * ) ;
   PyObject *(*nb_true_divide)(PyObject * , PyObject * ) ;
   PyObject *(*nb_inplace_floor_divide)(PyObject * , PyObject * ) ;
   PyObject *(*nb_inplace_true_divide)(PyObject * , PyObject * ) ;
   PyObject *(*nb_index)(PyObject * ) ;
};
#line 219 "/usr/include/python2.7/object.h"
typedef struct __anonstruct_PyNumberMethods_33 PyNumberMethods;
#line 275 "/usr/include/python2.7/object.h"
struct __anonstruct_PySequenceMethods_34 {
   Py_ssize_t (*sq_length)(PyObject * ) ;
   PyObject *(*sq_concat)(PyObject * , PyObject * ) ;
   PyObject *(*sq_repeat)(PyObject * , Py_ssize_t  ) ;
   PyObject *(*sq_item)(PyObject * , Py_ssize_t  ) ;
   PyObject *(*sq_slice)(PyObject * , Py_ssize_t  , Py_ssize_t  ) ;
   int (*sq_ass_item)(PyObject * , Py_ssize_t  , PyObject * ) ;
   int (*sq_ass_slice)(PyObject * , Py_ssize_t  , Py_ssize_t  , PyObject * ) ;
   int (*sq_contains)(PyObject * , PyObject * ) ;
   PyObject *(*sq_inplace_concat)(PyObject * , PyObject * ) ;
   PyObject *(*sq_inplace_repeat)(PyObject * , Py_ssize_t  ) ;
};
#line 275 "/usr/include/python2.7/object.h"
typedef struct __anonstruct_PySequenceMethods_34 PySequenceMethods;
#line 289 "/usr/include/python2.7/object.h"
struct __anonstruct_PyMappingMethods_35 {
   Py_ssize_t (*mp_length)(PyObject * ) ;
   PyObject *(*mp_subscript)(PyObject * , PyObject * ) ;
   int (*mp_ass_subscript)(PyObject * , PyObject * , PyObject * ) ;
};
#line 289 "/usr/include/python2.7/object.h"
typedef struct __anonstruct_PyMappingMethods_35 PyMappingMethods;
#line 295 "/usr/include/python2.7/object.h"
struct __anonstruct_PyBufferProcs_36 {
   Py_ssize_t (*bf_getreadbuffer)(PyObject * , Py_ssize_t  , void ** ) ;
   Py_ssize_t (*bf_getwritebuffer)(PyObject * , Py_ssize_t  , void ** ) ;
   Py_ssize_t (*bf_getsegcount)(PyObject * , Py_ssize_t * ) ;
   Py_ssize_t (*bf_getcharbuffer)(PyObject * , Py_ssize_t  , char ** ) ;
   int (*bf_getbuffer)(PyObject * , Py_buffer * , int  ) ;
   void (*bf_releasebuffer)(PyObject * , Py_buffer * ) ;
};
#line 295 "/usr/include/python2.7/object.h"
typedef struct __anonstruct_PyBufferProcs_36 PyBufferProcs;
#line 324
struct PyMethodDef;
#line 324
struct PyMemberDef;
#line 324
struct PyGetSetDef;
#line 324 "/usr/include/python2.7/object.h"
struct _typeobject {
   Py_ssize_t ob_refcnt ;
   struct _typeobject *ob_type ;
   Py_ssize_t ob_size ;
   char const   *tp_name ;
   Py_ssize_t tp_basicsize ;
   Py_ssize_t tp_itemsize ;
   void (*tp_dealloc)(PyObject * ) ;
   int (*tp_print)(PyObject * , FILE * , int  ) ;
   PyObject *(*tp_getattr)(PyObject * , char * ) ;
   int (*tp_setattr)(PyObject * , char * , PyObject * ) ;
   int (*tp_compare)(PyObject * , PyObject * ) ;
   PyObject *(*tp_repr)(PyObject * ) ;
   PyNumberMethods *tp_as_number ;
   PySequenceMethods *tp_as_sequence ;
   PyMappingMethods *tp_as_mapping ;
   long (*tp_hash)(PyObject * ) ;
   PyObject *(*tp_call)(PyObject * , PyObject * , PyObject * ) ;
   PyObject *(*tp_str)(PyObject * ) ;
   PyObject *(*tp_getattro)(PyObject * , PyObject * ) ;
   int (*tp_setattro)(PyObject * , PyObject * , PyObject * ) ;
   PyBufferProcs *tp_as_buffer ;
   long tp_flags ;
   char const   *tp_doc ;
   int (*tp_traverse)(PyObject * , int (*)(PyObject * , void * ) , void * ) ;
   int (*tp_clear)(PyObject * ) ;
   PyObject *(*tp_richcompare)(PyObject * , PyObject * , int  ) ;
   Py_ssize_t tp_weaklistoffset ;
   PyObject *(*tp_iter)(PyObject * ) ;
   PyObject *(*tp_iternext)(PyObject * ) ;
   struct PyMethodDef *tp_methods ;
   struct PyMemberDef *tp_members ;
   struct PyGetSetDef *tp_getset ;
   struct _typeobject *tp_base ;
   PyObject *tp_dict ;
   PyObject *(*tp_descr_get)(PyObject * , PyObject * , PyObject * ) ;
   int (*tp_descr_set)(PyObject * , PyObject * , PyObject * ) ;
   Py_ssize_t tp_dictoffset ;
   int (*tp_init)(PyObject * , PyObject * , PyObject * ) ;
   PyObject *(*tp_alloc)(struct _typeobject * , Py_ssize_t  ) ;
   PyObject *(*tp_new)(struct _typeobject * , PyObject * , PyObject * ) ;
   void (*tp_free)(void * ) ;
   int (*tp_is_gc)(PyObject * ) ;
   PyObject *tp_bases ;
   PyObject *tp_mro ;
   PyObject *tp_cache ;
   PyObject *tp_subclasses ;
   PyObject *tp_weaklist ;
   void (*tp_del)(PyObject * ) ;
   unsigned int tp_version_tag ;
};
#line 324 "/usr/include/python2.7/object.h"
typedef struct _typeobject PyTypeObject;
#line 37 "/usr/include/python2.7/methodobject.h"
struct PyMethodDef {
   char const   *ml_name ;
   PyObject *(*ml_meth)(PyObject * , PyObject * ) ;
   int ml_flags ;
   char const   *ml_doc ;
};
#line 44 "/usr/include/python2.7/methodobject.h"
typedef struct PyMethodDef PyMethodDef;
#line 11 "/usr/include/python2.7/descrobject.h"
struct PyGetSetDef {
   char *name ;
   PyObject *(*get)(PyObject * , void * ) ;
   int (*set)(PyObject * , PyObject * , void * ) ;
   char *doc ;
   void *closure ;
};
#line 11 "/usr/include/python2.7/descrobject.h"
typedef struct PyGetSetDef PyGetSetDef;
#line 33 "./include/cfpython_region.h"
struct __anonstruct_Crossfire_Region_123 {
   Py_ssize_t ob_refcnt ;
   struct _typeobject *ob_type ;
   region *reg ;
};
#line 33 "./include/cfpython_region.h"
typedef struct __anonstruct_Crossfire_Region_123 Crossfire_Region;
#line 122 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 7 "../../plugins/common/include/hashtable.h"
struct _ptr_assoc {
   struct _ptr_assoc **array ;
   struct _ptr_assoc *previous ;
   struct _ptr_assoc *next ;
   void *key ;
   void *value ;
};
#line 7 "../../plugins/common/include/hashtable.h"
typedef struct _ptr_assoc ptr_assoc;
#line 33 "./include/cfpython_archetype.h"
struct __anonstruct_Crossfire_Archetype_121 {
   Py_ssize_t ob_refcnt ;
   struct _typeobject *ob_type ;
   archetype *arch ;
};
#line 33 "./include/cfpython_archetype.h"
typedef struct __anonstruct_Crossfire_Archetype_121 Crossfire_Archetype;
#line 23 "/usr/include/python2.7/intobject.h"
struct __anonstruct_PyIntObject_41 {
   Py_ssize_t ob_refcnt ;
   struct _typeobject *ob_type ;
   long ob_ival ;
};
#line 23 "/usr/include/python2.7/intobject.h"
typedef struct __anonstruct_PyIntObject_41 PyIntObject;
#line 32 "./include/cfpython_object.h"
struct __anonstruct_Crossfire_Object_118 {
   Py_ssize_t ob_refcnt ;
   struct _typeobject *ob_type ;
   object *obj ;
   tag_t count ;
};
#line 32 "./include/cfpython_object.h"
typedef struct __anonstruct_Crossfire_Object_118 Crossfire_Object;
#line 40 "./include/cfpython_object.h"
struct __anonstruct_Crossfire_Player_119 {
   Py_ssize_t ob_refcnt ;
   struct _typeobject *ob_type ;
   object *obj ;
   tag_t count ;
};
#line 40 "./include/cfpython_object.h"
typedef struct __anonstruct_Crossfire_Player_119 Crossfire_Player;
#line 32 "./include/cfpython_map.h"
struct __anonstruct_Crossfire_Map_120 {
   Py_ssize_t ob_refcnt ;
   struct _typeobject *ob_type ;
   mapstruct *map ;
   int valid ;
};
#line 32 "./include/cfpython_map.h"
typedef struct __anonstruct_Crossfire_Map_120 Crossfire_Map;
#line 33 "./include/cfpython_party.h"
struct __anonstruct_Crossfire_Party_122 {
   Py_ssize_t ob_refcnt ;
   struct _typeobject *ob_type ;
   partylist *party ;
};
#line 33 "./include/cfpython_party.h"
typedef struct __anonstruct_Crossfire_Party_122 Crossfire_Party;
#line 119 "./include/cfpython.h"
struct _cfpcontext {
   struct _cfpcontext *down ;
   PyObject *who ;
   PyObject *activator ;
   PyObject *third ;
   PyObject *event ;
   char message[1024] ;
   int fix ;
   int event_code ;
   char script[1024] ;
   char options[1024] ;
   int returnvalue ;
   int parms[5] ;
   struct talk_info *talk ;
};
#line 119 "./include/cfpython.h"
typedef struct _cfpcontext CFPContext;
#line 15 "../../plugins/common/include/hashtable.h"
typedef ptr_assoc *ptr_assoc_table[251];
#line 110 "/usr/include/python2.7/object.h"
struct __anonstruct_PyVarObject_32 {
   Py_ssize_t ob_refcnt ;
   struct _typeobject *ob_type ;
   Py_ssize_t ob_size ;
};
#line 110 "/usr/include/python2.7/object.h"
typedef struct __anonstruct_PyVarObject_32 PyVarObject;
#line 128 "/usr/include/python2.7/unicodeobject.h"
typedef unsigned int Py_UCS4;
#line 137 "/usr/include/python2.7/unicodeobject.h"
typedef Py_UCS4 Py_UNICODE;
#line 415 "/usr/include/python2.7/unicodeobject.h"
struct __anonstruct_PyUnicodeObject_40 {
   Py_ssize_t ob_refcnt ;
   struct _typeobject *ob_type ;
   Py_ssize_t length ;
   Py_UNICODE *str ;
   long hash ;
   PyObject *defenc ;
};
#line 415 "/usr/include/python2.7/unicodeobject.h"
typedef struct __anonstruct_PyUnicodeObject_40 PyUnicodeObject;
#line 14 "/usr/include/python2.7/floatobject.h"
struct __anonstruct_PyFloatObject_42 {
   Py_ssize_t ob_refcnt ;
   struct _typeobject *ob_type ;
   double ob_fval ;
};
#line 14 "/usr/include/python2.7/floatobject.h"
typedef struct __anonstruct_PyFloatObject_42 PyFloatObject;
#line 35 "/usr/include/python2.7/stringobject.h"
struct __anonstruct_PyStringObject_45 {
   Py_ssize_t ob_refcnt ;
   struct _typeobject *ob_type ;
   Py_ssize_t ob_size ;
   long ob_shash ;
   int ob_sstate ;
   char ob_sval[1] ;
};
#line 35 "/usr/include/python2.7/stringobject.h"
typedef struct __anonstruct_PyStringObject_45 PyStringObject;
#line 22 "/usr/include/python2.7/bytearrayobject.h"
struct __anonstruct_PyByteArrayObject_47 {
   Py_ssize_t ob_refcnt ;
   struct _typeobject *ob_type ;
   Py_ssize_t ob_size ;
   int ob_exports ;
   Py_ssize_t ob_alloc ;
   char *ob_bytes ;
};
#line 22 "/usr/include/python2.7/bytearrayobject.h"
typedef struct __anonstruct_PyByteArrayObject_47 PyByteArrayObject;
#line 24 "/usr/include/python2.7/tupleobject.h"
struct __anonstruct_PyTupleObject_48 {
   Py_ssize_t ob_refcnt ;
   struct _typeobject *ob_type ;
   Py_ssize_t ob_size ;
   PyObject *ob_item[1] ;
};
#line 24 "/usr/include/python2.7/tupleobject.h"
typedef struct __anonstruct_PyTupleObject_48 PyTupleObject;
#line 22 "/usr/include/python2.7/listobject.h"
struct __anonstruct_PyListObject_49 {
   Py_ssize_t ob_refcnt ;
   struct _typeobject *ob_type ;
   Py_ssize_t ob_size ;
   PyObject **ob_item ;
   Py_ssize_t allocated ;
};
#line 22 "/usr/include/python2.7/listobject.h"
typedef struct __anonstruct_PyListObject_49 PyListObject;
#line 50 "/usr/include/python2.7/dictobject.h"
struct __anonstruct_PyDictEntry_50 {
   Py_ssize_t me_hash ;
   PyObject *me_key ;
   PyObject *me_value ;
};
#line 50 "/usr/include/python2.7/dictobject.h"
typedef struct __anonstruct_PyDictEntry_50 PyDictEntry;
#line 69
struct _dictobject;
#line 69 "/usr/include/python2.7/dictobject.h"
typedef struct _dictobject PyDictObject;
#line 70 "/usr/include/python2.7/dictobject.h"
struct _dictobject {
   Py_ssize_t ob_refcnt ;
   struct _typeobject *ob_type ;
   Py_ssize_t ma_fill ;
   Py_ssize_t ma_used ;
   Py_ssize_t ma_mask ;
   PyDictEntry *ma_table ;
   PyDictEntry *(*ma_lookup)(PyDictObject *mp , PyObject *key , long hash ) ;
   PyDictEntry ma_smalltable[8] ;
};
#line 147 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef long ptrdiff_t;
#line 38 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
struct JSONData {
   char *str ;
   char *end ;
   char *ptr ;
   int all_unicode ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
typedef struct JSONData JSONData;
#line 18 "/usr/include/python2.7/pythonrun.h"
struct __anonstruct_PyCompilerFlags_73 {
   int cf_flags ;
};
#line 18 "/usr/include/python2.7/pythonrun.h"
typedef struct __anonstruct_PyCompilerFlags_73 PyCompilerFlags;
#line 53
struct _node;
#line 10 "/usr/include/python2.7/code.h"
struct __anonstruct_PyCodeObject_74 {
   Py_ssize_t ob_refcnt ;
   struct _typeobject *ob_type ;
   int co_argcount ;
   int co_nlocals ;
   int co_stacksize ;
   int co_flags ;
   PyObject *co_code ;
   PyObject *co_consts ;
   PyObject *co_names ;
   PyObject *co_varnames ;
   PyObject *co_freevars ;
   PyObject *co_cellvars ;
   PyObject *co_filename ;
   PyObject *co_name ;
   int co_firstlineno ;
   PyObject *co_lnotab ;
   void *co_zombieframe ;
   PyObject *co_weakreflist ;
};
#line 10 "/usr/include/python2.7/code.h"
typedef struct __anonstruct_PyCodeObject_74 PyCodeObject;
#line 10 "/usr/include/python2.7/node.h"
struct _node {
   short n_type ;
   char *n_str ;
   int n_lineno ;
   int n_col_offset ;
   int n_nchildren ;
   struct _node *n_child ;
};
#line 10 "/usr/include/python2.7/node.h"
typedef struct _node node;
#line 73 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
struct __anonstruct_pycode_cache_entry_124 {
   sstring file ;
   PyCodeObject *code ;
   time_t cached_time ;
   time_t used_time ;
};
#line 73 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
typedef struct __anonstruct_pycode_cache_entry_124 pycode_cache_entry;
#line 81 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
struct PythonCmdStruct {
   sstring name ;
   sstring script ;
   double speed ;
};
#line 81 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
typedef struct PythonCmdStruct PythonCmd;
#line 993 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
struct __anonstruct_CFConstant_125 {
   char const   *name ;
   int const   value ;
};
#line 993 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
typedef struct __anonstruct_CFConstant_125 CFConstant;
#line 36 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/languages.c"
struct i18n_message {
   sstring code ;
   sstring message ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/languages.c"
typedef struct i18n_message i18n_message;
#line 44 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/languages.c"
struct i18n_file {
   sstring code ;
   sstring name ;
   int count ;
   struct i18n_message *messages ;
};
#line 44 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/languages.c"
typedef struct i18n_file i18n_file;
#line 12 "../include/god.h"
struct glnk {
   char const   *name ;
   struct archt *arch ;
   int id ;
   struct glnk *next ;
};
#line 12 "../include/god.h"
typedef struct glnk godlink;
#line 33 "../include/image.h"
struct face_info {
   uint8 *data ;
   uint16 datalen ;
   uint32 checksum ;
};
#line 33 "../include/image.h"
typedef struct face_info face_info;
#line 40 "../include/image.h"
struct __anonstruct_face_sets_63 {
   char *prefix ;
   char *fullname ;
   uint8 fallback ;
   char *size ;
   char *extension ;
   char *comment ;
   face_info *faces ;
};
#line 40 "../include/image.h"
typedef struct __anonstruct_face_sets_63 face_sets;
#line 12 "../include/race.h"
struct ralnk {
   char const   *name ;
   int nrof ;
   struct oblnk *member ;
   struct ralnk *next ;
};
#line 12 "../include/race.h"
typedef struct ralnk racelink;
#line 442 "../include/global.h"
struct Statistics {
   uint64 spell_merges ;
   uint64 spell_hash_full ;
   uint64 spell_suppressions ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/stringbuffer.c"
struct StringBuffer {
   char *buf ;
   size_t pos ;
   size_t size ;
};
#line 18 "../include/dialog.h"
typedef struct struct_dialog_reply struct_dialog_reply;
#line 28 "../include/dialog.h"
typedef struct struct_dialog_message struct_dialog_message;
#line 38 "../include/dialog.h"
typedef struct struct_dialog_information struct_dialog_information;
#line 35 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/devel/devel.c"
struct __anonstruct_cf_parameter_25 {
   char const   *name ;
   char const   *value ;
};
#line 35 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/devel/devel.c"
typedef struct __anonstruct_cf_parameter_25 cf_parameter;
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 186 "../include/newserver.h"
extern Socket_Info socket_info ;
#line 193 "../include/global.h"
player *first_player ;
#line 267
extern socket_struct *init_sockets ;
#line 169 "../include/libproto.h"
extern void LOG(LogLevel logLevel , char const   *format  , ...) ;
#line 320
extern char *strdup_local(char const   *str ) ;
#line 322
extern char *strerror_local(int errnum , char *buf , size_t size ) ;
#line 434
size_t split_string(char *str , char **array , size_t array_size , char sep ) ;
#line 430 "../include/global.h"
struct Settings settings ;
#line 2 "../include/sproto.h"
void clear_accounts(void) ;
#line 3
void account_load_entries(void) ;
#line 4
void accounts_save(void) ;
#line 5
char const   *account_exists(char const   *account_name ) ;
#line 6
int account_check_name_password(char const   *account_name , char const   *account_password___0 ) ;
#line 7
int account_check_string(char const   *str ) ;
#line 8
int account_add_account(char const   *account_name , char const   *account_password___0 ) ;
#line 9
int account_add_player_to_account(char const   *account_name , char const   *player_name ) ;
#line 10
int account_remove_player_from_account(char const   *account_name , char const   *player_name ) ;
#line 11
char **account_get_players_for_account(char const   *account_name ) ;
#line 12
char const   *account_get_account_for_char(char const   *charname ) ;
#line 13
player *account_get_logged_in_player(char const   *name ) ;
#line 14
socket_struct *account_get_logged_in_init_socket(char const   *name ) ;
#line 15
int account_is_logged_in(char const   *name ) ;
#line 16
int account_change_password(char const   *account_name , char const   *current_password ,
                            char const   *new_password ) ;
#line 628
extern char *crypt_string(char const   *str , char const   *salt ) ;
#line 99 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account.c"
static account_struct *accounts  =    (account_struct *)((void *)0);
#line 112 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account.c"
void clear_accounts(void) 
{ 


  {
#line 113
  accounts = (account_struct *)((void *)0);
#line 114
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account.c"
void account_load_entries(void) 
{ 
  char fname[256] ;
  char buf[1024] ;
  FILE *fp ;
  account_struct *ac ;
  account_struct *last ;
  int fields ;
  char err[256] ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1[6] ;
  char *cp ;
  int result ;
  int i ;
  size_t tmp___2 ;
  void *tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;

  {
#line 124
  last = (account_struct *)((void *)0);
#line 125
  fields = 0;
#line 127
  if ((unsigned long )accounts != (unsigned long )((void *)0)) {
    {
#line 128
    LOG((LogLevel )0, "account_load_entries(): Called when accounts has been set.\n");
    }
#line 129
    return;
  }
  {
#line 131
  snprintf((char */* __restrict  */)(fname), (size_t )256, (char const   */* __restrict  */)"%s/%s",
           settings.localdir, "accounts");
#line 132
  fp = fopen((char const   */* __restrict  */)(fname), (char const   */* __restrict  */)"r");
  }
#line 133
  if (! fp) {
    {
#line 138
    tmp = __errno_location();
#line 138
    tmp___0 = strerror_local(*tmp, err, sizeof(err));
#line 138
    LOG((LogLevel )1, "Warning: Unable to open %s [%s]\n", fname, tmp___0);
    }
#line 139
    return;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 141
    tmp___7 = fgets((char */* __restrict  */)(buf), 1024, (FILE */* __restrict  */)fp);
    }
#line 141
    if (! tmp___7) {
#line 141
      goto while_break;
    }
#line 146
    if ((int )buf[0] == 35) {
#line 146
      goto while_continue;
    }
    {
#line 149
    cp = strchr((char const   *)(buf), '\n');
    }
#line 150
    if (cp) {
#line 150
      *cp = (char )'\000';
    }
    {
#line 152
    tmp___2 = split_string(buf, tmp___1, (size_t )6, (char )':');
#line 152
    fields = (int )tmp___2;
#line 154
    tmp___3 = malloc(sizeof(account_struct ));
#line 154
    ac = (account_struct *)tmp___3;
#line 155
    ac->name = strdup_local((char const   *)tmp___1[0]);
#line 156
    ac->password = strdup_local((char const   *)tmp___1[1]);
#line 157
    tmp___4 = strtoul((char const   */* __restrict  */)tmp___1[2], (char **/* __restrict  */)((char **)((void *)0)),
                      10);
#line 157
    ac->last_login = (time_t )tmp___4;
    }
#line 163
    if (fields > 4) {
      {
#line 163
      tmp___5 = strtoul((char const   */* __restrict  */)tmp___1[4], (char **/* __restrict  */)((char **)((void *)0)),
                        10);
#line 163
      ac->created = (time_t )tmp___5;
      }
    } else {
#line 165
      ac->created = ac->last_login;
    }
#line 167
    ac->next = (struct account_struct *)((void *)0);
#line 170
    if ((int )*(tmp___1[3] + 0) == 0) {
#line 171
      ac->num_characters = 0;
#line 172
      i = 0;
      {
#line 172
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 172
        if (! (i <= 17)) {
#line 172
          goto while_break___0;
        }
#line 173
        ac->character_names[i] = (char *)((void *)0);
#line 172
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 179
      ac->num_characters = 1;
#line 180
      cp = tmp___1[3];
      {
#line 180
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 180
        if (! ((int )*cp != 0)) {
#line 180
          goto while_break___1;
        }
#line 181
        if ((int )*cp == 59) {
#line 181
          (ac->num_characters) ++;
        }
#line 180
        cp ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 184
      tmp___6 = split_string(tmp___1[3], ac->character_names, (size_t )ac->num_characters,
                             (char )';');
#line 184
      result = (int )tmp___6;
      }
#line 188
      if (result != ac->num_characters) {
        {
#line 189
        LOG((LogLevel )0, "account_load_entries: split_string found different number of characters: %d != %d\n",
            result, ac->num_characters);
        }
      }
#line 193
      if (ac->num_characters > 17) {
        {
#line 194
        LOG((LogLevel )0, "account_load_entries: Too many characters set for account %s - truncating to %d\n",
            ac->name, 17);
#line 196
        ac->num_characters = 17;
        }
      }
#line 205
      i = 0;
      {
#line 205
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 205
        if (! (i < ac->num_characters)) {
#line 205
          goto while_break___2;
        }
#line 206
        if ((unsigned long )ac->character_names[i] != (unsigned long )((void *)0)) {
          {
#line 207
          ac->character_names[i] = strdup_local((char const   *)ac->character_names[i]);
          }
        } else {
#line 209
          ac->num_characters = i;
#line 210
          goto while_break___2;
        }
#line 205
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 218
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 218
        if (! (i <= 17)) {
#line 218
          goto while_break___3;
        }
#line 219
        ac->character_names[i] = (char *)((void *)0);
#line 220
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 227
    if (last) {
#line 228
      last->next = ac;
    } else {
#line 230
      accounts = ac;
    }
#line 231
    last = ac;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 234
  fclose(fp);
  }
#line 235
  return;
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account.c"
static void account_write_entry(FILE *fp , account_struct *ac ) 
{ 
  int i ;

  {
  {
#line 250
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s:%s:%u:",
          ac->name, ac->password, (uint32 )ac->last_login);
#line 251
  i = 0;
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! (i < ac->num_characters)) {
#line 251
      goto while_break;
    }
#line 252
    if (i != 0) {
      {
#line 253
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)";%s",
              ac->character_names[i]);
      }
    } else {
      {
#line 255
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s",
              ac->character_names[i]);
      }
    }
#line 251
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 257
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)":%u:\n",
          (uint32 )ac->created);
  }
#line 258
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account.c"
void accounts_save(void) 
{ 
  char fname[256] ;
  char fname1[256] ;
  FILE *fp ;
  account_struct *ac ;
  char err[256] ;
  int *tmp ;
  char *tmp___0 ;
  time_t tmp___1 ;

  {
  {
#line 273
  snprintf((char */* __restrict  */)(fname), (size_t )256, (char const   */* __restrict  */)"%s/%s.new",
           settings.localdir, "accounts");
#line 275
  fp = fopen((char const   */* __restrict  */)(fname), (char const   */* __restrict  */)"w");
  }
#line 276
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 279
    tmp = __errno_location();
#line 279
    tmp___0 = strerror_local(*tmp, err, sizeof(err));
#line 279
    LOG((LogLevel )0, "Cannot open accounts file %s: %s\n", fname, tmp___0);
    }
#line 281
    return;
  }
  {
#line 284
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# This file should not be edited while the server is running.\n");
#line 285
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# Otherwise, any changes made may be overwritten by the server\n");
#line 286
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# Format:\n");
#line 287
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# Account name:Password:Account last used:Characters (semicolon separated):created:expansion\n");
#line 288
  ac = accounts;
  }
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if (! ac) {
#line 288
      goto while_break;
    }
#line 292
    if (ac->num_characters) {
      {
#line 293
      account_write_entry(fp, ac);
      }
    } else {
      {
#line 292
      tmp___1 = time((time_t *)((void *)0));
      }
#line 292
      if (ac->created > tmp___1 - 86400L) {
        {
#line 293
        account_write_entry(fp, ac);
        }
      }
    }
#line 288
    ac = ac->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 295
  fclose(fp);
#line 301
  snprintf((char */* __restrict  */)(fname1), (size_t )256, (char const   */* __restrict  */)"%s/%s",
           settings.localdir, "accounts");
#line 302
  unlink((char const   *)(fname1));
#line 303
  rename((char const   *)(fname), (char const   *)(fname1));
  }
#line 304
  return;
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account.c"
char const   *account_exists(char const   *account_name ) 
{ 
  account_struct *ac ;
  int tmp ;

  {
#line 319
  ac = accounts;
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (! ac) {
#line 319
      goto while_break;
    }
    {
#line 320
    tmp = strcasecmp((char const   *)ac->name, account_name);
    }
#line 320
    if (! tmp) {
#line 320
      return ((char const   *)ac->name);
    }
#line 319
    ac = ac->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  return ((char const   *)((void *)0));
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account.c"
int account_check_name_password(char const   *account_name , char const   *account_password___0 ) 
{ 
  account_struct *ac ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 344
  ac = accounts;
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    if (! ac) {
#line 344
      goto while_break;
    }
    {
#line 351
    tmp___1 = strcasecmp((char const   *)ac->name, account_name);
    }
#line 351
    if (! tmp___1) {
      {
#line 352
      tmp = crypt_string(account_password___0, (char const   *)ac->password);
#line 352
      tmp___0 = strcmp((char const   *)ac->password, (char const   *)tmp);
      }
#line 352
      if (tmp___0) {
#line 356
        return (0);
      } else {
        {
#line 353
        ac->last_login = time((time_t *)((void *)0));
        }
#line 354
        return (1);
      }
    }
#line 344
    ac = ac->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 359
  return (0);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account.c"
int account_check_string(char const   *str ) 
{ 
  char const   *cp ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 383
  cp = str;
#line 386
  tmp = __ctype_b_loc();
  }
#line 386
  if (! ((int const   )*(*tmp + (int )*str) & 8)) {
#line 386
    return (1);
  }
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (! ((int const   )*str != 0)) {
#line 387
      goto while_break;
    }
    {
#line 388
    tmp___0 = __ctype_b_loc();
    }
#line 388
    if (! ((int const   )*(*tmp___0 + (int )*str) & 16384)) {
#line 388
      return (1);
    }
#line 389
    if ((int const   )*str == 58) {
#line 389
      return (1);
    } else
#line 389
    if ((int const   )*str == 59) {
#line 389
      return (1);
    } else
#line 389
    if ((int const   )*str == 47) {
#line 389
      return (1);
    } else
#line 389
    if ((int const   )*str == 39) {
#line 389
      return (1);
    }
#line 387
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 392
  tmp___1 = __ctype_b_loc();
  }
#line 392
  if ((int const   )*(*tmp___1 + (int )*(str - 1)) & 8192) {
#line 392
    return (1);
  }
#line 393
  if (str - cp > 48L) {
#line 393
    return (2);
  }
#line 394
  return (0);
}
}
#line 412 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account.c"
int account_add_account(char const   *account_name , char const   *account_password___0 ) 
{ 
  account_struct *ac ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 422
  tmp = account_check_string(account_name);
  }
#line 422
  if (tmp) {
#line 423
    return (1);
  } else {
    {
#line 422
    tmp___0 = account_check_string(account_password___0);
    }
#line 422
    if (tmp___0) {
#line 423
      return (1);
    }
  }
  {
#line 425
  tmp___1 = account_exists(account_name);
  }
#line 425
  if (tmp___1) {
#line 425
    return (2);
  }
  {
#line 427
  tmp___2 = malloc(sizeof(account_struct ));
#line 427
  ac = (account_struct *)tmp___2;
#line 428
  ac->name = strdup_local(account_name);
#line 429
  tmp___3 = crypt_string(account_password___0, (char const   *)((void *)0));
#line 429
  ac->password = strdup_local((char const   *)tmp___3);
#line 430
  ac->last_login = time((time_t *)((void *)0));
#line 431
  ac->created = ac->last_login;
#line 432
  ac->num_characters = 0;
#line 434
  memset((void *)(ac->character_names), 0, 17UL + sizeof(char *));
#line 443
  ac->next = accounts;
#line 444
  accounts = ac;
  }
#line 446
  return (0);
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account.c"
int account_add_player_to_account(char const   *account_name , char const   *player_name ) 
{ 
  account_struct *ac ;
  int tmp ;

  {
#line 471
  ac = accounts;
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (! ac) {
#line 471
      goto while_break;
    }
    {
#line 472
    tmp = strcasecmp((char const   *)ac->name, account_name);
    }
#line 472
    if (! tmp) {
#line 472
      goto while_break;
    }
#line 471
    ac = ac->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 474
  if ((unsigned long )ac == (unsigned long )((void *)0)) {
#line 474
    return (1);
  }
#line 476
  if (ac->num_characters >= 17) {
#line 476
    return (2);
  }
  {
#line 478
  ac->character_names[ac->num_characters] = strdup_local(player_name);
#line 479
  (ac->num_characters) ++;
#line 482
  ac->character_names[ac->num_characters] = (char *)((void *)0);
  }
#line 483
  return (0);
}
}
#line 504 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account.c"
int account_remove_player_from_account(char const   *account_name , char const   *player_name ) 
{ 
  account_struct *ac ;
  int i ;
  int match ;
  int tmp ;
  int tmp___0 ;

  {
#line 507
  match = 0;
#line 509
  ac = accounts;
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 509
    if (! ac) {
#line 509
      goto while_break;
    }
    {
#line 510
    tmp = strcasecmp((char const   *)ac->name, account_name);
    }
#line 510
    if (! tmp) {
#line 510
      goto while_break;
    }
#line 509
    ac = ac->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 512
  if ((unsigned long )ac == (unsigned long )((void *)0)) {
#line 512
    return (1);
  }
#line 518
  i = 0;
  {
#line 518
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 518
    if (! (i < ac->num_characters)) {
#line 518
      goto while_break___0;
    }
    {
#line 519
    tmp___0 = strcasecmp((char const   *)ac->character_names[i], player_name);
    }
#line 519
    if (! tmp___0) {
      {
#line 520
      free((void *)ac->character_names[i]);
#line 521
      match = 1;
      }
    }
#line 523
    if (match == 1) {
#line 524
      ac->character_names[i] = ac->character_names[i + 1];
    }
#line 518
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 528
  if (match) {
#line 529
    (ac->num_characters) --;
#line 530
    return (0);
  }
#line 533
  return (2);
}
}
#line 548 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account.c"
char **account_get_players_for_account(char const   *account_name ) 
{ 
  account_struct *ac ;
  int tmp ;

  {
#line 552
  ac = accounts;
  {
#line 552
  while (1) {
    while_continue: /* CIL Label */ ;
#line 552
    if (! ac) {
#line 552
      goto while_break;
    }
    {
#line 553
    tmp = strcasecmp((char const   *)ac->name, account_name);
    }
#line 553
    if (! tmp) {
#line 553
      return (ac->character_names);
    }
#line 552
    ac = ac->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 555
  return ((char **)((void *)0));
}
}
#line 567 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account.c"
char const   *account_get_account_for_char(char const   *charname ) 
{ 
  account_struct *ac ;
  int i ;
  int tmp ;

  {
#line 572
  ac = accounts;
  {
#line 572
  while (1) {
    while_continue: /* CIL Label */ ;
#line 572
    if (! ac) {
#line 572
      goto while_break;
    }
#line 573
    i = 0;
    {
#line 573
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 573
      if (! (i < ac->num_characters)) {
#line 573
        goto while_break___0;
      }
      {
#line 574
      tmp = strcasecmp((char const   *)ac->character_names[i], charname);
      }
#line 574
      if (! tmp) {
#line 575
        return ((char const   *)ac->name);
      }
#line 573
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 572
    ac = ac->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 579
  return ((char const   *)((void *)0));
}
}
#line 592 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account.c"
player *account_get_logged_in_player(char const   *name ) 
{ 
  player *pl ;
  int tmp ;

  {
#line 596
  pl = first_player;
  {
#line 596
  while (1) {
    while_continue: /* CIL Label */ ;
#line 596
    if (! pl) {
#line 596
      goto while_break;
    }
#line 597
    if (pl->socket.account_name) {
      {
#line 597
      tmp = strcasecmp((char const   *)pl->socket.account_name, name);
      }
#line 597
      if (! tmp) {
#line 598
        return (pl);
      }
    }
#line 596
    pl = pl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 600
  return ((player *)((void *)0));
}
}
#line 613 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account.c"
socket_struct *account_get_logged_in_init_socket(char const   *name ) 
{ 
  int i ;
  int tmp ;

  {
#line 617
  i = 0;
  {
#line 617
  while (1) {
    while_continue: /* CIL Label */ ;
#line 617
    if (! (i < socket_info.allocated_sockets)) {
#line 617
      goto while_break;
    }
#line 618
    if ((unsigned int )(init_sockets + i)->status == 1U) {
#line 618
      if ((init_sockets + i)->account_name) {
        {
#line 618
        tmp = strcasecmp((char const   *)(init_sockets + i)->account_name, name);
        }
#line 618
        if (! tmp) {
#line 620
          return (init_sockets + i);
        }
      }
    }
#line 617
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 622
  return ((socket_struct *)((void *)0));
}
}
#line 635 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account.c"
int account_is_logged_in(char const   *name ) 
{ 
  player *tmp ;
  socket_struct *tmp___0 ;

  {
  {
#line 637
  tmp = account_get_logged_in_player(name);
  }
#line 637
  if (tmp) {
#line 637
    return (1);
  }
  {
#line 639
  tmp___0 = account_get_logged_in_init_socket(name);
  }
#line 639
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 639
    return (1);
  }
#line 641
  return (0);
}
}
#line 663 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account.c"
int account_change_password(char const   *account_name , char const   *current_password ,
                            char const   *new_password ) 
{ 
  account_struct *ac ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 673
  tmp = account_check_string(account_name);
  }
#line 673
  if (tmp) {
#line 674
    return (1);
  } else {
    {
#line 673
    tmp___0 = account_check_string(current_password);
    }
#line 673
    if (tmp___0) {
#line 674
      return (1);
    } else {
      {
#line 673
      tmp___1 = account_check_string(new_password);
      }
#line 673
      if (tmp___1) {
#line 674
        return (1);
      }
    }
  }
#line 676
  ac = accounts;
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    if (! ac) {
#line 676
      goto while_break;
    }
    {
#line 677
    tmp___2 = strcasecmp((char const   *)ac->name, account_name);
    }
#line 677
    if (! tmp___2) {
#line 677
      goto while_break;
    }
#line 676
    ac = ac->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 679
  if ((unsigned long )ac == (unsigned long )((void *)0)) {
#line 679
    return (2);
  }
  {
#line 681
  tmp___3 = crypt_string(current_password, (char const   *)ac->password);
#line 681
  tmp___4 = strcmp((char const   *)tmp___3, (char const   *)ac->password);
  }
#line 681
  if (tmp___4) {
#line 682
    return (3);
  }
  {
#line 684
  free((void *)ac->password);
#line 685
  tmp___5 = crypt_string(new_password, (char const   *)((void *)0));
#line 685
  ac->password = strdup_local((char const   *)tmp___5);
  }
#line 687
  return (0);
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 10 "../include/sockproto.h"
void draw_ext_info(int flags , int pri , object const   *pl , uint8 type , uint8 subtype ,
                   char const   *message ) ;
#line 11
void draw_ext_info_format(int flags , int pri , object const   *pl , uint8 type ,
                          uint8 subtype , char const   *format  , ...) ;
#line 134 "../include/sproto.h"
void list_players(object *op , region *reg , partylist *party ) ;
#line 227
int confirm_party_password(object *op ) ;
#line 228
void receive_party_password(object *op ) ;
#line 229
void command_gsay(object *op , char const   *params ) ;
#line 230
void command_party(object *op , char const   *params ) ;
#line 231
void command_party_rejoin(object *op , char const   *params ) ;
#line 365
extern partylist *party_form(object *op , char const   *partyname ) ;
#line 366
extern void party_join(object *op , partylist *party ) ;
#line 367
extern void party_leave(object *op ) ;
#line 368
extern partylist *party_find(char const   *partyname ) ;
#line 370
extern partylist *party_get_first(void) ;
#line 371
extern partylist *party_get_next(partylist const   *party ) ;
#line 373
extern char const   *party_get_password(partylist const   *party ) ;
#line 374
extern void party_set_password(partylist *party , char const   *password ) ;
#line 375
extern int party_confirm_password(partylist const   *party , char const   *password ) ;
#line 376
extern void party_send_message(object *op , char const   *message ) ;
#line 377
extern char const   *party_get_leader(partylist const   *party ) ;
#line 409
extern int get_party_password(object *op , partylist *party ) ;
#line 440
extern void player_set_state(player *pl , uint8 state ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_party.c"
int confirm_party_password(object *op ) 
{ 
  partylist const   *party ;
  partylist *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 53
  tmp = party_find((char const   *)((op->contr)->party_to_join)->partyname);
#line 53
  party = (partylist const   *)tmp;
  }
#line 54
  if ((unsigned long )party == (unsigned long )((void *)0)) {
#line 54
    tmp___1 = 1;
  } else {
    {
#line 54
    tmp___0 = party_confirm_password(party, (char const   *)((op->contr)->write_buf + 1));
    }
#line 54
    if (tmp___0) {
#line 54
      tmp___1 = 0;
    } else {
#line 54
      tmp___1 = 1;
    }
  }
#line 54
  return (tmp___1);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_party.c"
void receive_party_password(object *op ) 
{ 
  int tmp ;

  {
  {
#line 64
  tmp = confirm_party_password(op);
  }
#line 64
  if (tmp == 0) {
    {
#line 65
    party_join(op, (op->contr)->party_to_join);
#line 66
    (op->contr)->party_to_join = (partylist *)((void *)0);
#line 67
    player_set_state(op->contr, (uint8 )0);
    }
#line 68
    return;
  }
  {
#line 71
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You entered the wrong password");
#line 73
  (op->contr)->party_to_join = (partylist *)((void *)0);
#line 74
  player_set_state(op->contr, (uint8 )0);
  }
#line 75
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_party.c"
void command_gsay(object *op , char const   *params ) 
{ 
  char party_params[256] ;

  {
#line 88
  if ((int const   )*params == 0) {
    {
#line 89
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Say what?");
    }
#line 90
    return;
  }
  {
#line 92
  strcpy((char */* __restrict  */)(party_params), (char const   */* __restrict  */)"say ");
#line 93
  strcat((char */* __restrict  */)(party_params), (char const   */* __restrict  */)params);
#line 94
  command_party(op, (char const   *)(party_params));
  }
#line 95
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_party.c"
static void party_help(object *op ) 
{ 


  {
  {
#line 104
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )16, "To form a party type: party form <partyname>. To join a party type: party join <partyname> If the party has a passwd, it will you prompt you for it. For a list of current parties type: party list. To leave a party type: party leave To change a passwd for a party type: party passwd <password> There is an 8 character maximum password length. To talk to party members type: party say <msg> To see who is in your party: party who ");
  }
#line 118
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_party.c"
void command_party(object *op , char const   *params ) 
{ 
  char buf[256] ;
  int tmp ;
  int tmp___0 ;
  partylist *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  partylist *party ;
  partylist *tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  partylist *party___0 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 133
  if ((int const   )*params == 0) {
#line 134
    if ((unsigned long )(op->contr)->party == (unsigned long )((void *)0)) {
      {
#line 135
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You are not a member of any party. For help try: party help");
      }
    } else {
      {
#line 139
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "You are a member of party %s.",
                           ((op->contr)->party)->partyname);
      }
    }
#line 143
    return;
  }
  {
#line 145
  tmp = strcmp(params, "help");
  }
#line 145
  if (tmp == 0) {
    {
#line 146
    party_help(op);
    }
#line 147
    return;
  }
  {
#line 209
  tmp___0 = strncmp(params, "say ", (size_t )4);
  }
#line 209
  if (tmp___0 == 0) {
#line 210
    if ((unsigned long )(op->contr)->party == (unsigned long )((void *)0)) {
      {
#line 211
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You are not a member of any party.");
      }
#line 213
      return;
    }
    {
#line 215
    params += 4;
#line 216
    snprintf((char */* __restrict  */)(buf), (size_t )255, (char const   */* __restrict  */)"<%s> %s says: %s",
             ((op->contr)->party)->partyname, op->name, params);
#line 217
    party_send_message(op, (char const   *)(buf));
#line 218
    draw_ext_info_format(1, 0, (object const   *)op, (uint8 )15, (uint8 )6, "<%s> You say: %s",
                         ((op->contr)->party)->partyname, params);
    }
#line 221
    return;
  }
  {
#line 224
  tmp___2 = strncmp(params, "form ", (size_t )5);
  }
#line 224
  if (tmp___2 == 0) {
    {
#line 225
    params += 5;
#line 227
    tmp___1 = party_form(op, params);
    }
#line 227
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
#line 228
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "The party %s already exists, pick another name",
                           params);
      }
#line 231
      return;
    }
#line 233
    return;
  }
  {
#line 236
  tmp___3 = strcmp(params, "leave");
  }
#line 236
  if (tmp___3 == 0) {
#line 237
    if ((unsigned long )(op->contr)->party == (unsigned long )((void *)0)) {
      {
#line 238
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You are not a member of any party.");
      }
#line 240
      return;
    }
    {
#line 242
    party_leave(op);
    }
#line 243
    return;
  }
  {
#line 245
  tmp___4 = strcmp(params, "who");
  }
#line 245
  if (tmp___4 == 0) {
#line 246
    if ((unsigned long )(op->contr)->party == (unsigned long )((void *)0)) {
      {
#line 247
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You are not a member of any party.");
      }
#line 249
      return;
    }
    {
#line 251
    list_players(op, (region *)((void *)0), (op->contr)->party);
    }
#line 252
    return;
  }
  {
#line 255
  tmp___8 = strncmp(params, "passwd ", (size_t )7);
  }
#line 255
  if (tmp___8 == 0) {
#line 256
    params += 7;
#line 258
    if ((unsigned long )(op->contr)->party == (unsigned long )((void *)0)) {
      {
#line 259
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You are not a member of a party");
      }
#line 261
      return;
    }
    {
#line 264
    tmp___5 = strlen(params);
    }
#line 264
    if (tmp___5 > 8UL) {
      {
#line 265
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "The password must not exceed 8 characters");
      }
#line 267
      return;
    }
    {
#line 270
    party_set_password((op->contr)->party, params);
#line 271
    tmp___6 = party_get_password((partylist const   *)(op->contr)->party);
#line 271
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "The password for party %s is %s",
                         ((op->contr)->party)->partyname, tmp___6);
#line 275
    tmp___7 = party_get_password((partylist const   *)(op->contr)->party);
#line 275
    snprintf((char */* __restrict  */)(buf), (size_t )256, (char const   */* __restrict  */)"Password for party %s is now %s, changed by %s",
             ((op->contr)->party)->partyname, tmp___7, op->name);
#line 277
    party_send_message(op, (char const   *)(buf));
    }
#line 278
    return;
  }
  {
#line 281
  tmp___11 = strcmp(params, "list");
  }
#line 281
  if (tmp___11 == 0) {
    {
#line 284
    tmp___9 = party_get_first();
    }
#line 284
    if ((unsigned long )tmp___9 == (unsigned long )((void *)0)) {
      {
#line 285
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "There are no parties active right now");
      }
#line 287
      return;
    }
    {
#line 290
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "[fixed]Party name                       Leader\n----------                       ------");
#line 292
    party = party_get_first();
    }
    {
#line 292
    while (1) {
      while_continue: /* CIL Label */ ;
#line 292
      if (! ((unsigned long )party != (unsigned long )((void *)0))) {
#line 292
        goto while_break;
      }
      {
#line 293
      tmp___10 = party_get_leader((partylist const   *)party);
#line 293
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "[fixed]%-32s %s",
                           party->partyname, tmp___10);
#line 292
      party = party_get_next((partylist const   *)party);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 298
    return;
  }
  {
#line 301
  tmp___13 = strncmp(params, "join ", (size_t )5);
  }
#line 301
  if (tmp___13 == 0) {
    {
#line 304
    params += 5;
#line 306
    party___0 = party_find(params);
    }
#line 307
    if ((unsigned long )party___0 == (unsigned long )((void *)0)) {
      {
#line 308
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Party %s does not exist.  You must form it first.",
                           params);
      }
#line 311
      return;
    }
#line 314
    if ((unsigned long )(op->contr)->party == (unsigned long )party___0) {
      {
#line 315
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You are already a member of party: %s",
                           party___0->partyname);
      }
#line 318
      return;
    }
    {
#line 321
    tmp___12 = get_party_password(op, party___0);
    }
#line 321
    if (tmp___12) {
#line 322
      return;
    }
    {
#line 325
    party_join(op, party___0);
    }
#line 326
    return;
  }
  {
#line 329
  party_help(op);
  }
#line 330
  return;
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_party.c"
static char const   *rejoin_modes[4]  = {      "no",      "if_exists",      "always",      (char const   *)((void *)0)};
#line 347 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_party.c"
void command_party_rejoin(object *op , char const   *params ) 
{ 
  int mode ;
  int tmp ;

  {
#line 350
  if ((int const   )*params == 0) {
    {
#line 351
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "party rejoin: %s",
                         rejoin_modes[(op->contr)->rejoin_party]);
    }
#line 353
    return;
  }
#line 355
  mode = 0;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    if (! ((unsigned long )rejoin_modes[mode] != (unsigned long )((void *)0))) {
#line 355
      goto while_break;
    }
    {
#line 356
    tmp = strcmp(rejoin_modes[mode], params);
    }
#line 356
    if (tmp == 0) {
      {
#line 357
      (op->contr)->rejoin_party = (party_rejoin_mode )mode;
#line 358
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "party rejoin is now: %s",
                           rejoin_modes[(op->contr)->rejoin_party]);
      }
#line 360
      return;
    }
#line 355
    mode ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 363
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "invalid mode: %50s",
                       params);
  }
#line 365
  return;
}
}
#line 377 "../include/libproto.h"
extern sstring add_string(char const   *str ) ;
#line 381
extern void free_string(sstring str ) ;
#line 18 "../include/sproto.h"
Account_Char *account_char_load(char const   *account_name ) ;
#line 19
void account_char_save(char const   *account , Account_Char *chars ) ;
#line 20
Account_Char *account_char_add(Account_Char *chars , player *pl ) ;
#line 21
Account_Char *account_char_remove(Account_Char *chars , char const   *pl_name ) ;
#line 22
void account_char_free(Account_Char *chars ) ;
#line 89 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account_char.c"
Account_Char *account_char_load(char const   *account_name ) 
{ 
  char fname[256] ;
  char buf[1024] ;
  FILE *fp ;
  Account_Char *first ;
  Account_Char *ac ;
  Account_Char *last ;
  char *tmp[7] ;
  char *cp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  unsigned long tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 93
  first = (Account_Char *)((void *)0);
#line 93
  last = (Account_Char *)((void *)0);
#line 95
  snprintf((char */* __restrict  */)(fname), (size_t )256, (char const   */* __restrict  */)"%s/%s/%s",
           settings.localdir, "account", account_name);
#line 96
  fp = fopen((char const   */* __restrict  */)(fname), (char const   */* __restrict  */)"r");
  }
#line 97
  if (! fp) {
    {
#line 101
    LOG((LogLevel )1, "Warning: Unable to open %s\n", fname);
    }
#line 102
    return ((Account_Char *)((void *)0));
  }
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 104
    tmp___3 = fgets((char */* __restrict  */)(buf), 1024, (FILE */* __restrict  */)fp);
    }
#line 104
    if (! tmp___3) {
#line 104
      goto while_break;
    }
#line 108
    if ((int )buf[0] == 35) {
#line 108
      goto while_continue;
    }
    {
#line 111
    cp = strchr((char const   *)(buf), '\n');
    }
#line 112
    if (cp) {
#line 112
      *cp = (char )'\000';
    }
    {
#line 114
    tmp___0 = split_string(buf, tmp, (size_t )7, (char )':');
    }
#line 114
    if (tmp___0 != 7UL) {
      {
#line 115
      LOG((LogLevel )0, "Corrupt entry in %s: %s\n", fname, buf);
      }
#line 116
      goto while_continue;
    }
    {
#line 118
    tmp___1 = malloc(sizeof(Account_Char ));
#line 118
    ac = (Account_Char *)tmp___1;
#line 119
    ac->name = add_string((char const   *)tmp[0]);
#line 120
    ac->character_class = add_string((char const   *)tmp[1]);
#line 121
    ac->race = add_string((char const   *)tmp[2]);
#line 122
    tmp___2 = strtoul((char const   */* __restrict  */)tmp[3], (char **/* __restrict  */)((char **)((void *)0)),
                      10);
#line 122
    ac->level = (uint8 )tmp___2;
#line 123
    ac->face = add_string((char const   *)tmp[4]);
#line 124
    ac->party = add_string((char const   *)tmp[5]);
#line 125
    ac->map = add_string((char const   *)tmp[6]);
#line 127
    ac->next = (struct account_char_struct *)((void *)0);
    }
#line 132
    if (last) {
#line 133
      last->next = ac;
    } else {
#line 135
      first = ac;
    }
#line 136
    last = ac;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 139
  fclose(fp);
  }
#line 140
  return (first);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account_char.c"
void account_char_save(char const   *account , Account_Char *chars ) 
{ 
  char fname[256] ;
  char fname1[256] ;
  FILE *fp ;
  Account_Char *ac ;
  char err[256] ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 160
  if ((unsigned long )chars == (unsigned long )((void *)0)) {
    {
#line 161
    snprintf((char */* __restrict  */)(fname), (size_t )256, (char const   */* __restrict  */)"%s/%s/%s",
             settings.localdir, "account", account);
#line 162
    unlink((char const   *)(fname));
    }
#line 163
    return;
  }
  {
#line 166
  snprintf((char */* __restrict  */)(fname), (size_t )256, (char const   */* __restrict  */)"%s/%s/%s.new",
           settings.localdir, "account", account);
#line 167
  fp = fopen((char const   */* __restrict  */)(fname), (char const   */* __restrict  */)"w");
  }
#line 168
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 171
    tmp = __errno_location();
#line 171
    tmp___0 = strerror_local(*tmp, err, sizeof(err));
#line 171
    LOG((LogLevel )0, "Cannot open accounts file %s: %s\n", fname, tmp___0);
    }
#line 173
    return;
  }
  {
#line 176
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# This file should not be edited while the server is running.\n");
#line 177
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# Otherwise, any changes made may be overwritten by the server\n");
#line 178
  ac = chars;
  }
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! ac) {
#line 178
      goto while_break;
    }
    {
#line 179
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s:%s:%s:%d:%s:%s:%s\n",
            ac->name, ac->character_class, ac->race, (int )ac->level, ac->face, ac->party,
            ac->map);
#line 178
    ac = ac->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  fclose(fp);
#line 189
  snprintf((char */* __restrict  */)(fname1), (size_t )256, (char const   */* __restrict  */)"%s/%s/%s",
           settings.localdir, "account", account);
#line 190
  unlink((char const   *)(fname1));
#line 191
  rename((char const   *)(fname), (char const   *)(fname1));
  }
#line 192
  return;
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account_char.c"
Account_Char *account_char_add(Account_Char *chars , player *pl ) 
{ 
  Account_Char *ap ;
  Account_Char *last ;
  int tmp ;
  void *tmp___0 ;

  {
#line 213
  last = (Account_Char *)((void *)0);
#line 215
  ap = chars;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! ap) {
#line 215
      goto while_break;
    }
    {
#line 216
    tmp = strcasecmp(ap->name, (pl->ob)->name);
    }
#line 216
    if (! tmp) {
#line 216
      goto while_break;
    }
#line 217
    last = ap;
#line 215
    ap = ap->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  if (ap) {
    {
#line 236
    ap->character_class = add_string("");
#line 239
    free_string(ap->race);
#line 245
    ap->race = add_string(((pl->ob)->arch)->clone.name);
#line 247
    ap->level = (uint8 )(pl->ob)->level;
#line 255
    free_string(ap->face);
#line 256
    ap->face = add_string((char const   *)((pl->ob)->face)->name);
#line 258
    free_string(ap->party);
    }
#line 259
    if (pl->party) {
      {
#line 260
      ap->party = add_string((char const   *)(pl->party)->partyname);
      }
    } else {
      {
#line 262
      ap->party = add_string("");
      }
    }
    {
#line 264
    free_string(ap->map);
    }
#line 270
    if ((pl->ob)->map) {
#line 270
      if (((pl->ob)->map)->name) {
        {
#line 271
        ap->map = add_string((char const   *)((pl->ob)->map)->name);
        }
      } else {
        {
#line 277
        ap->map = add_string((char const   *)(pl->maplevel));
        }
      }
    } else {
      {
#line 277
      ap->map = add_string((char const   *)(pl->maplevel));
      }
    }
  } else {
    {
#line 281
    tmp___0 = malloc(sizeof(Account_Char ));
#line 281
    ap = (Account_Char *)tmp___0;
#line 282
    ap->name = add_string((pl->ob)->name);
#line 283
    ap->character_class = add_string("");
#line 284
    ap->race = add_string(((pl->ob)->arch)->clone.name);
#line 285
    ap->level = (uint8 )(pl->ob)->level;
#line 286
    ap->face = add_string((char const   *)((pl->ob)->face)->name);
    }
#line 287
    if (pl->party) {
      {
#line 288
      ap->party = add_string((char const   *)(pl->party)->partyname);
      }
    } else {
      {
#line 290
      ap->party = add_string("");
      }
    }
    {
#line 291
    ap->map = add_string((char const   *)(pl->maplevel));
#line 293
    ap->next = (struct account_char_struct *)((void *)0);
    }
#line 294
    if (last) {
#line 295
      last->next = ap;
    } else {
#line 297
      chars = ap;
    }
  }
#line 299
  return (chars);
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account_char.c"
Account_Char *account_char_remove(Account_Char *chars , char const   *pl_name ) 
{ 
  Account_Char *ap ;
  Account_Char *last ;
  int tmp ;

  {
#line 315
  last = (Account_Char *)((void *)0);
#line 317
  ap = chars;
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if (! ap) {
#line 317
      goto while_break;
    }
    {
#line 318
    tmp = strcasecmp(ap->name, pl_name);
    }
#line 318
    if (! tmp) {
#line 318
      goto while_break;
    }
#line 319
    last = ap;
#line 317
    ap = ap->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  if (! ap) {
#line 322
    return (chars);
  }
  {
#line 325
  free_string(ap->name);
#line 326
  free_string(ap->character_class);
#line 327
  free_string(ap->race);
#line 328
  free_string(ap->face);
#line 329
  free_string(ap->party);
#line 330
  free_string(ap->map);
  }
#line 333
  if (last) {
#line 334
    last->next = ap->next;
  } else {
#line 336
    chars = ap->next;
  }
  {
#line 338
  free((void *)ap);
  }
#line 339
  return (chars);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/account_char.c"
void account_char_free(Account_Char *chars ) 
{ 
  Account_Char *ap ;
  Account_Char *next ;

  {
#line 354
  ap = chars;
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 354
    if (! ap) {
#line 354
      goto while_break;
    }
    {
#line 355
    next = ap->next;
#line 357
    free_string(ap->name);
#line 358
    free_string(ap->character_class);
#line 359
    free_string(ap->race);
#line 360
    free_string(ap->face);
#line 361
    free_string(ap->party);
#line 362
    free_string(ap->map);
#line 363
    free((void *)ap);
#line 354
    ap = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  return;
}
}
#line 140 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 775 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 258 "../include/global.h"
extern short freearr_x[49] ;
#line 258
extern short freearr_y[49] ;
#line 171 "../include/libproto.h"
void init_block(void) ;
#line 172
void clear_los(object *op ) ;
#line 173
int has_carried_lights(object const   *op ) ;
#line 174
void update_los(object *op ) ;
#line 175
void update_all_map_los(mapstruct *map ) ;
#line 176
void update_all_los(mapstruct const   *map , int x , int y ) ;
#line 177
void print_los(object *op ) ;
#line 178
void make_sure_seen(object const   *op ) ;
#line 179
void make_sure_not_seen(object const   *op ) ;
#line 188
extern int get_map_flags(mapstruct *oldmap , mapstruct **newmap , sint16 x , sint16 y ,
                         sint16 *nx , sint16 *ny ) ;
#line 323
extern int isqrt(int n ) ;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/los.c"
static blocks block[25][25]  ;
#line 55
static void expand_lighted_sight(object *op ) ;
#line 75 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/los.c"
static void set_block(int x , int y , int bx , int by ) 
{ 
  int index___0 ;
  int i ;

  {
#line 76
  index___0 = block[x][y].index;
#line 80
  i = 0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! (i < index___0)) {
#line 80
      goto while_break;
    }
#line 81
    if (block[x][y].x[i] == bx) {
#line 81
      if (block[x][y].y[i] == by) {
#line 83
        return;
      }
    }
#line 80
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  block[x][y].x[index___0] = bx;
#line 87
  block[x][y].y[index___0] = by;
#line 88
  (block[x][y].index) ++;
#line 92
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/los.c"
static int const   block_x[3]  = {      (int const   )-1,      (int const   )-1,      (int const   )0};
#line 104 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/los.c"
static int const   block_y[3]  = {      (int const   )-1,      (int const   )0,      (int const   )-1};
#line 102 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/los.c"
void init_block(void) 
{ 
  int x ;
  int y ;
  int dx ;
  int dy ;
  int i ;
  float d1 ;
  float s ;
  float l ;
  double tmp ;
  double tmp___0 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 110
  x = 0;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! (x < 25)) {
#line 110
      goto while_break;
    }
#line 111
    y = 0;
    {
#line 111
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 111
      if (! (y < 25)) {
#line 111
        goto while_break___0;
      }
#line 112
      block[x][y].index = 0;
#line 111
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 110
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  x = 1;
  {
#line 118
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 118
    if (! (x <= 12)) {
#line 118
      goto while_break___1;
    }
#line 119
    y = 1;
    {
#line 119
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 119
      if (! (y <= 12)) {
#line 119
        goto while_break___2;
      }
#line 120
      i = 0;
      {
#line 120
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 120
        if (! (i < 3)) {
#line 120
          goto while_break___3;
        }
#line 121
        dx = x + (int )block_x[i];
#line 122
        dy = y + (int )block_y[i];
#line 125
        if (x == 12) {
#line 125
          if (y == 12) {
#line 126
            goto __Cont;
          }
        }
#line 129
        if (dx == x) {
#line 129
          if (x == 12) {
#line 129
            goto _L;
          } else {
#line 129
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 129
        if (dy == y) {
#line 129
          if (y == 12) {
            _L: /* CIL Label */ 
            {
#line 134
            set_block(x, y, dx, dy);
            }
#line 135
            if (x == 12) {
              {
#line 136
              set_block(x, (25 - y) - 1, dx, (25 - dy) - 1);
              }
            } else
#line 137
            if (y == 12) {
              {
#line 138
              set_block((25 - x) - 1, y, (25 - dx) - 1, dy);
              }
            }
          } else {
#line 129
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 150
          tmp = pow((double )(12 - dx), (double )2);
#line 150
          tmp___0 = pow((double )(12 - dy), (double )2);
#line 150
          d1 = (float )(tmp + tmp___0);
#line 151
          s = (float )((dy - y) * (12 - dx) - (dx - x) * (12 - dy)) / d1;
#line 152
          tmp___4 = sqrt((double )d1);
          }
#line 152
          if (tmp___4 * (double )s < (double )0) {
            {
#line 152
            tmp___2 = sqrt((double )d1);
#line 152
            l = (float )(- (tmp___2 * (double )s));
            }
          } else {
            {
#line 152
            tmp___3 = sqrt((double )d1);
#line 152
            l = (float )(tmp___3 * (double )s);
            }
          }
#line 154
          if ((double )l <= 0.5) {
            {
#line 158
            set_block(x, y, dx, dy);
#line 159
            set_block((25 - x) - 1, y, (25 - dx) - 1, dy);
#line 160
            set_block(x, (25 - y) - 1, dx, (25 - dy) - 1);
#line 161
            set_block((25 - x) - 1, (25 - y) - 1, (25 - dx) - 1, (25 - dy) - 1);
            }
          }
        }
        __Cont: /* CIL Label */ 
#line 120
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 119
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 118
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 167
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/los.c"
static void set_wall(object *op , int x , int y ) 
{ 
  int i ;
  int dx ;
  int dy ;
  int ax ;
  int ay ;

  {
#line 187
  i = 0;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! (i < block[x][y].index)) {
#line 187
      goto while_break;
    }
#line 188
    dx = block[x][y].x[i];
#line 188
    dy = block[x][y].y[i];
#line 193
    ax = dx - (25 - (int )(op->contr)->socket.mapx) / 2;
#line 194
    ay = dy - (25 - (int )(op->contr)->socket.mapy) / 2;
#line 196
    if (ax < 0) {
#line 198
      goto __Cont;
    } else
#line 196
    if (ax >= (int )(op->contr)->socket.mapx) {
#line 198
      goto __Cont;
    } else
#line 196
    if (ay < 0) {
#line 198
      goto __Cont;
    } else
#line 196
    if (ay >= (int )(op->contr)->socket.mapy) {
#line 198
      goto __Cont;
    }
    {
#line 203
    (op->contr)->blocked_los[ax][ay] = (sint8 )100;
#line 204
    set_wall(op, dx, dy);
    }
    __Cont: /* CIL Label */ 
#line 187
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/los.c"
static void check_wall(object *op , int x , int y ) 
{ 
  int ax ;
  int ay ;
  int tmp ;

  {
#line 222
  if (! block[x][y].index) {
#line 223
    return;
  }
#line 226
  ax = x - (25 - (int )(op->contr)->socket.mapx) / 2;
#line 227
  ay = y - (25 - (int )(op->contr)->socket.mapy) / 2;
#line 232
  if (ax < 0) {
#line 233
    return;
  } else
#line 232
  if (ay < 0) {
#line 233
    return;
  } else
#line 232
  if (ax >= (int )(op->contr)->socket.mapx) {
#line 233
    return;
  } else
#line 232
  if (ay >= (int )(op->contr)->socket.mapy) {
#line 233
    return;
  }
#line 239
  if ((int )(op->contr)->blocked_los[ax][ay] == 100) {
#line 240
    return;
  }
  {
#line 243
  tmp = get_map_flags(op->map, (mapstruct **)((void *)0), (sint16 )(((int )op->x + x) - 12),
                      (sint16 )(((int )op->y + y) - 12), (sint16 *)((void *)0), (sint16 *)((void *)0));
  }
#line 243
  if (tmp & 257) {
    {
#line 244
    set_wall(op, x, y);
    }
  }
#line 245
  return;
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/los.c"
void clear_los(object *op ) 
{ 


  {
  {
#line 263
  memset((void *)((op->contr)->blocked_los), 0, (size_t )625);
  }
#line 264
  return;
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/los.c"
static void expand_sight(object *op ) 
{ 
  int i ;
  int x ;
  int y ;
  int dx ;
  int dy ;
  int tmp ;

  {
#line 280
  x = 1;
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! (x < (int )(op->contr)->socket.mapx - 1)) {
#line 280
      goto while_break;
    }
#line 281
    y = 1;
    {
#line 281
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 281
      if (! (y < (int )(op->contr)->socket.mapy - 1)) {
#line 281
        goto while_break___0;
      }
#line 282
      if (! (op->contr)->blocked_los[x][y]) {
        {
#line 282
        tmp = get_map_flags(op->map, (mapstruct **)((void *)0), (sint16 )(((int )op->x - (int )(op->contr)->socket.mapx / 2) + x),
                            (sint16 )(((int )op->y - (int )(op->contr)->socket.mapy / 2) + y),
                            (sint16 *)((void *)0), (sint16 *)((void *)0));
        }
#line 282
        if (! (tmp & 257)) {
#line 287
          i = 1;
          {
#line 287
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 287
            if (! (i <= 8)) {
#line 287
              goto while_break___1;
            }
#line 288
            dx = x + (int )freearr_x[i];
#line 289
            dy = y + (int )freearr_y[i];
#line 290
            if ((int )(op->contr)->blocked_los[dx][dy] > 0) {
#line 291
              (op->contr)->blocked_los[dx][dy] = (sint8 )-1;
            }
#line 287
            i ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
#line 281
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 280
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  if ((int )(op->map)->darkness > 0) {
    {
#line 297
    expand_lighted_sight(op);
    }
  }
#line 301
  x = 0;
  {
#line 301
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 301
    if (! (x < (int )(op->contr)->socket.mapx)) {
#line 301
      goto while_break___2;
    }
#line 302
    y = 0;
    {
#line 302
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 302
      if (! (y < (int )(op->contr)->socket.mapy)) {
#line 302
        goto while_break___3;
      }
#line 303
      if ((int )(op->contr)->blocked_los[x][y] < 0) {
#line 304
        (op->contr)->blocked_los[x][y] = (sint8 )0;
      }
#line 302
      y ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 301
    x ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 305
  return;
}
}
#line 320 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/los.c"
int has_carried_lights(object const   *op ) 
{ 


  {
#line 322
  if ((int const   )op->glow_radius > 0) {
#line 323
    return (1);
  }
#line 325
  return (0);
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/los.c"
static void expand_lighted_sight(object *op ) 
{ 
  int x ;
  int y ;
  int darklevel ;
  int ax ;
  int ay ;
  int basex ;
  int basey ;
  int mflags ;
  int light ;
  int x1 ;
  int y1___0 ;
  mapstruct *m ;
  sint16 nx ;
  sint16 ny ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;

  {
#line 336
  m = op->map;
#line 339
  darklevel = (int )m->darkness;
#line 342
  if (op->flags[2] & (1U << 29)) {
#line 343
    darklevel -= 2;
  }
#line 349
  if (darklevel < 1) {
#line 350
    return;
  }
#line 355
  if (darklevel > 5) {
    {
#line 356
    LOG((LogLevel )0, "Map darkness for %s on %s is too high (%d)\n", op->name, (op->map)->path,
        darklevel);
#line 357
    darklevel = 5;
    }
  }
#line 361
  x = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! (x < (int )(op->contr)->socket.mapx)) {
#line 361
      goto while_break;
    }
#line 362
    y = 0;
    {
#line 362
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 362
      if (! (y < (int )(op->contr)->socket.mapy)) {
#line 362
        goto while_break___0;
      }
#line 363
      if ((int )(op->contr)->blocked_los[x][y] != 100) {
#line 364
        (op->contr)->blocked_los[x][y] = (sint8 )4;
      }
#line 362
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 361
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  x = ((int )op->x - (int )(op->contr)->socket.mapx / 2) - 4;
#line 372
  basex = -4;
  {
#line 372
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 372
    if (! (x <= ((int )op->x + (int )(op->contr)->socket.mapx / 2) + 4)) {
#line 372
      goto while_break___1;
    }
#line 374
    y = ((int )op->y - (int )(op->contr)->socket.mapy / 2) - 4;
#line 374
    basey = -4;
    {
#line 374
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 374
      if (! (y <= ((int )op->y + (int )(op->contr)->socket.mapy / 2) + 4)) {
#line 374
        goto while_break___2;
      }
      {
#line 376
      m = op->map;
#line 377
      nx = (sint16 )x;
#line 378
      ny = (sint16 )y;
#line 380
      mflags = get_map_flags(m, & m, nx, ny, & nx, & ny);
      }
#line 382
      if (mflags & 256) {
#line 383
        goto __Cont;
      }
#line 388
      light = (int )(m->spaces + ((int )nx + (int )m->width * (int )ny))->light;
#line 389
      if (light != 0) {
#line 390
        ax = basex - light;
        {
#line 390
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 390
          if (! (ax <= basex + light)) {
#line 390
            goto while_break___3;
          }
#line 391
          if (ax < 0) {
#line 392
            goto __Cont___0;
          } else
#line 391
          if (ax >= (int )(op->contr)->socket.mapx) {
#line 392
            goto __Cont___0;
          }
#line 393
          ay = basey - light;
          {
#line 393
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 393
            if (! (ay <= basey + light)) {
#line 393
              goto while_break___4;
            }
#line 394
            if (ay < 0) {
#line 395
              goto __Cont___1;
            } else
#line 394
            if (ay >= (int )(op->contr)->socket.mapy) {
#line 395
              goto __Cont___1;
            }
#line 404
            if ((int )(op->contr)->blocked_los[ax][ay] != 100) {
              {
#line 405
              tmp = abs(basex - ax);
#line 405
              tmp___0 = abs(basex - ax);
#line 405
              x1 = tmp * tmp___0;
#line 406
              tmp___1 = abs(basey - ay);
#line 406
              tmp___2 = abs(basey - ay);
#line 406
              y1___0 = tmp___1 * tmp___2;
              }
#line 407
              if (light > 0) {
                {
#line 408
                tmp___6 = isqrt(x1 + y1___0);
                }
#line 408
                if (light - tmp___6 > 0) {
                  {
#line 408
                  tmp___4 = isqrt(x1 + y1___0);
#line 408
                  tmp___5 = light - tmp___4;
                  }
                } else {
#line 408
                  tmp___5 = 0;
                }
#line 408
                (op->contr)->blocked_los[ax][ay] = (sint8 )((int )(op->contr)->blocked_los[ax][ay] - tmp___5);
              }
#line 409
              if (light < 0) {
                {
#line 410
                tmp___10 = isqrt(x1 + y1___0);
                }
#line 410
                if (light + tmp___10 < 0) {
                  {
#line 410
                  tmp___8 = isqrt(x1 + y1___0);
#line 410
                  tmp___9 = light + tmp___8;
                  }
                } else {
#line 410
                  tmp___9 = 0;
                }
#line 410
                (op->contr)->blocked_los[ax][ay] = (sint8 )((int )(op->contr)->blocked_los[ax][ay] - tmp___9);
              }
            }
            __Cont___1: /* CIL Label */ 
#line 393
            ay ++;
          }
          while_break___4: /* CIL Label */ ;
          }
          __Cont___0: /* CIL Label */ 
#line 390
          ax ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      __Cont: /* CIL Label */ 
#line 374
      y ++;
#line 374
      basey ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 372
    x ++;
#line 372
    basex ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 421
  if ((op->map)->outdoor) {
#line 421
    if (darklevel > 2) {
#line 422
      if ((int )(op->contr)->blocked_los[(int )(op->contr)->socket.mapx / 2][(int )(op->contr)->socket.mapy / 2] > 2) {
#line 423
        (op->contr)->blocked_los[(int )(op->contr)->socket.mapx / 2][(int )(op->contr)->socket.mapy / 2] = (sint8 )2;
      }
#line 425
      x = -1;
      {
#line 425
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 425
        if (! (x <= 1)) {
#line 425
          goto while_break___5;
        }
#line 426
        y = -1;
        {
#line 426
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 426
          if (! (y <= 1)) {
#line 426
            goto while_break___6;
          }
#line 427
          if ((int )(op->contr)->blocked_los[x + (int )(op->contr)->socket.mapx / 2][y + (int )(op->contr)->socket.mapy / 2] > 3) {
#line 428
            (op->contr)->blocked_los[x + (int )(op->contr)->socket.mapx / 2][y + (int )(op->contr)->socket.mapy / 2] = (sint8 )3;
          }
#line 426
          y ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 425
        x ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  }
#line 432
  x = darklevel - 5;
  {
#line 432
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 432
    if (! (x < 6 - darklevel)) {
#line 432
      goto while_break___7;
    }
#line 433
    y = darklevel - 5;
    {
#line 433
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 433
      if (! (y < 6 - darklevel)) {
#line 433
        goto while_break___8;
      }
#line 434
      if (! ((int )(op->contr)->blocked_los[x + (int )(op->contr)->socket.mapx / 2][y + (int )(op->contr)->socket.mapy / 2] == 100)) {
        {
#line 435
        tmp___31 = abs(x);
#line 435
        tmp___32 = abs(y);
        }
#line 435
        if (tmp___31 > tmp___32) {
          {
#line 435
          tmp___28 = abs(x);
#line 435
          tmp___30 = tmp___28;
          }
        } else {
          {
#line 435
          tmp___29 = abs(y);
#line 435
          tmp___30 = tmp___29;
          }
        }
#line 435
        if (0 > (6 - darklevel) - tmp___30) {
#line 435
          tmp___25 = 0;
        } else {
          {
#line 435
          tmp___23 = abs(x);
#line 435
          tmp___24 = abs(y);
          }
#line 435
          if (tmp___23 > tmp___24) {
            {
#line 435
            tmp___20 = abs(x);
#line 435
            tmp___22 = tmp___20;
            }
          } else {
            {
#line 435
            tmp___21 = abs(y);
#line 435
            tmp___22 = tmp___21;
            }
          }
#line 435
          tmp___25 = (6 - darklevel) - tmp___22;
        }
#line 435
        (op->contr)->blocked_los[x + (int )(op->contr)->socket.mapx / 2][y + (int )(op->contr)->socket.mapy / 2] = (sint8 )((int )(op->contr)->blocked_los[x + (int )(op->contr)->socket.mapx / 2][y + (int )(op->contr)->socket.mapy / 2] - tmp___25);
      }
#line 433
      y ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 432
    x ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 436
  return;
}
}
#line 447 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/los.c"
static void blinded_sight(object *op ) 
{ 
  int x ;
  int y ;

  {
#line 450
  x = 0;
  {
#line 450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 450
    if (! (x < (int )(op->contr)->socket.mapx)) {
#line 450
      goto while_break;
    }
#line 451
    y = 0;
    {
#line 451
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 451
      if (! (y < (int )(op->contr)->socket.mapy)) {
#line 451
        goto while_break___0;
      }
#line 452
      (op->contr)->blocked_los[x][y] = (sint8 )100;
#line 451
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 450
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 454
  (op->contr)->blocked_los[(int )(op->contr)->socket.mapx / 2][(int )(op->contr)->socket.mapy / 2] = (sint8 )0;
#line 455
  return;
}
}
#line 464 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/los.c"
void update_los(object *op ) 
{ 
  int dx ;
  int dy ;
  int x ;
  int y ;
  int x___0 ;
  int y___0 ;

  {
#line 465
  dx = (int )(op->contr)->socket.mapx / 2;
#line 465
  dy = (int )(op->contr)->socket.mapy / 2;
#line 467
  if (op->flags[0] & (1U << 2)) {
#line 468
    return;
  }
  {
#line 470
  clear_los(op);
  }
#line 471
  if (op->flags[0] & (1U << 1)) {
#line 472
    return;
  }
#line 479
  x = (25 - (int )(op->contr)->socket.mapx) / 2 + 1;
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 479
    if (! (x < (25 + (int )(op->contr)->socket.mapx) / 2 - 1)) {
#line 479
      goto while_break;
    }
#line 480
    y = (25 - (int )(op->contr)->socket.mapy) / 2 + 1;
    {
#line 480
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 480
      if (! (y < (25 + (int )(op->contr)->socket.mapy) / 2 - 1)) {
#line 480
        goto while_break___0;
      }
      {
#line 481
      check_wall(op, x, y);
#line 480
      y ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 479
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 485
  if (op->flags[2] & (1U << 28)) {
    {
#line 486
    blinded_sight(op);
    }
  } else {
    {
#line 488
    expand_sight(op);
    }
  }
#line 490
  if (op->flags[1] & (1U << 29)) {
#line 492
    x___0 = -2;
    {
#line 492
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 492
      if (! (x___0 <= 2)) {
#line 492
        goto while_break___1;
      }
#line 493
      y___0 = -2;
      {
#line 493
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 493
        if (! (y___0 <= 2)) {
#line 493
          goto while_break___2;
        }
#line 494
        (op->contr)->blocked_los[dx + x___0][dy + y___0] = (sint8 )0;
#line 493
        y___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 492
      x___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 496
  return;
}
}
#line 513 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/los.c"
void update_all_map_los(mapstruct *map ) 
{ 
  player *pl ;

  {
#line 516
  pl = first_player;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! ((unsigned long )pl != (unsigned long )((void *)0))) {
#line 516
      goto while_break;
    }
#line 517
    if ((unsigned long )(pl->ob)->map == (unsigned long )map) {
#line 518
      pl->do_los = (uint32 )1;
    }
#line 516
    pl = pl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 520
  return;
}
}
#line 541 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/los.c"
void update_all_los(mapstruct const   *map , int x , int y ) 
{ 
  player *pl ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 544
  pl = first_player;
  {
#line 544
  while (1) {
    while_continue: /* CIL Label */ ;
#line 544
    if (! ((unsigned long )pl != (unsigned long )((void *)0))) {
#line 544
      goto while_break;
    }
#line 548
    if (! (pl->ob)->map) {
#line 549
      goto __Cont;
    }
#line 560
    if ((unsigned long )(pl->ob)->map == (unsigned long )map) {
      {
#line 561
      tmp = abs((int )(pl->ob)->x - x);
      }
#line 561
      if (tmp <= (int )pl->socket.mapx / 2) {
        {
#line 561
        tmp___0 = abs((int )(pl->ob)->y - y);
        }
#line 561
        if (tmp___0 <= (int )pl->socket.mapy / 2) {
#line 563
          pl->do_los = (uint32 )1;
        }
      }
    } else
#line 581
    if ((unsigned long )(pl->ob)->map == (unsigned long )map->tile_map[0]) {
      {
#line 582
      tmp___1 = abs((int )(pl->ob)->x - x);
      }
#line 582
      if (tmp___1 <= (int )pl->socket.mapx / 2) {
        {
#line 582
        tmp___2 = abs((y + (int )(map->tile_map[0])->height) - (int )(pl->ob)->y);
        }
#line 582
        if (tmp___2 <= (int )pl->socket.mapy / 2) {
#line 584
          pl->do_los = (uint32 )1;
        }
      }
    } else
#line 585
    if ((unsigned long )(pl->ob)->map == (unsigned long )map->tile_map[2]) {
      {
#line 586
      tmp___3 = abs((int )(pl->ob)->x - x);
      }
#line 586
      if (tmp___3 <= (int )pl->socket.mapx / 2) {
        {
#line 586
        tmp___4 = abs(((int )(pl->ob)->y + (int )map->height) - y);
        }
#line 586
        if (tmp___4 <= (int )pl->socket.mapy / 2) {
#line 588
          pl->do_los = (uint32 )1;
        }
      }
    } else
#line 589
    if ((unsigned long )(pl->ob)->map == (unsigned long )map->tile_map[1]) {
      {
#line 590
      tmp___5 = abs(((int )(pl->ob)->x + (int )map->width) - x);
      }
#line 590
      if (tmp___5 <= (int )pl->socket.mapx / 2) {
        {
#line 590
        tmp___6 = abs((int )(pl->ob)->y - y);
        }
#line 590
        if (tmp___6 <= (int )pl->socket.mapy / 2) {
#line 592
          pl->do_los = (uint32 )1;
        }
      }
    } else
#line 593
    if ((unsigned long )(pl->ob)->map == (unsigned long )map->tile_map[3]) {
      {
#line 594
      tmp___7 = abs((x + (int )(map->tile_map[3])->width) - (int )(pl->ob)->x);
      }
#line 594
      if (tmp___7 <= (int )pl->socket.mapx / 2) {
        {
#line 594
        tmp___8 = abs((int )(pl->ob)->y - y);
        }
#line 594
        if (tmp___8 <= (int )pl->socket.mapy / 2) {
#line 596
          pl->do_los = (uint32 )1;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 544
    pl = pl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 599
  return;
}
}
#line 611 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/los.c"
void print_los(object *op ) 
{ 
  int x ;
  int y ;
  char buf[70] ;
  char buf2[10] ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 615
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"[fixed]   ");
#line 616
  x = 0;
  }
  {
#line 616
  while (1) {
    while_continue: /* CIL Label */ ;
#line 616
    if (! (x < (int )(op->contr)->socket.mapx)) {
#line 616
      goto while_break;
    }
    {
#line 617
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%2d",
             x);
#line 618
    tmp = strlen((char const   *)(buf));
#line 618
    strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)(buf2),
            (sizeof(buf) - tmp) - 1UL);
#line 616
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 620
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )10, (char const   *)(buf));
#line 621
  y = 0;
  }
  {
#line 621
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 621
    if (! (y < (int )(op->contr)->socket.mapy)) {
#line 621
      goto while_break___0;
    }
    {
#line 622
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"[fixed]%2d:",
             y);
#line 623
    x = 0;
    }
    {
#line 623
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 623
      if (! (x < (int )(op->contr)->socket.mapx)) {
#line 623
        goto while_break___1;
      }
#line 624
      if ((int )(op->contr)->blocked_los[x][y] == 100) {
#line 624
        tmp___0 = 1;
      } else {
#line 624
        tmp___0 = 0;
      }
      {
#line 624
      snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)" %1d",
               tmp___0);
#line 625
      tmp___1 = strlen((char const   *)(buf));
#line 625
      strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)(buf2),
              (sizeof(buf) - tmp___1) - 1UL);
#line 623
      x ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 627
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )10, (char const   *)(buf));
#line 621
    y ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 629
  return;
}
}
#line 641 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/los.c"
void make_sure_seen(object const   *op ) 
{ 
  player *pl ;

  {
#line 644
  pl = first_player;
  {
#line 644
  while (1) {
    while_continue: /* CIL Label */ ;
#line 644
    if (! pl) {
#line 644
      goto while_break;
    }
#line 645
    if ((unsigned long )(pl->ob)->map == (unsigned long )op->map) {
#line 645
      if ((int )(pl->ob)->y - (int )pl->socket.mapy / 2 <= (int )op->y) {
#line 645
        if ((int )(pl->ob)->y + (int )pl->socket.mapy / 2 >= (int )op->y) {
#line 645
          if ((int )(pl->ob)->x - (int )pl->socket.mapx / 2 <= (int )op->x) {
#line 645
            if ((int )(pl->ob)->x + (int )pl->socket.mapx / 2 >= (int )op->x) {
#line 650
              pl->blocked_los[((int )pl->socket.mapx / 2 + (int )op->x) - (int )(pl->ob)->x][((int )pl->socket.mapy / 2 + (int )op->y) - (int )(pl->ob)->y] = (sint8 )0;
            }
          }
        }
      }
    }
#line 644
    pl = pl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 651
  return;
}
}
#line 664 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/los.c"
void make_sure_not_seen(object const   *op ) 
{ 
  player *pl ;

  {
#line 667
  pl = first_player;
  {
#line 667
  while (1) {
    while_continue: /* CIL Label */ ;
#line 667
    if (! pl) {
#line 667
      goto while_break;
    }
#line 668
    if ((unsigned long )(pl->ob)->map == (unsigned long )op->map) {
#line 668
      if ((int )(pl->ob)->y - (int )pl->socket.mapy / 2 <= (int )op->y) {
#line 668
        if ((int )(pl->ob)->y + (int )pl->socket.mapy / 2 >= (int )op->y) {
#line 668
          if ((int )(pl->ob)->x - (int )pl->socket.mapx / 2 <= (int )op->x) {
#line 668
            if ((int )(pl->ob)->x + (int )pl->socket.mapx / 2 >= (int )op->x) {
#line 673
              pl->do_los = (uint32 )1;
            }
          }
        }
      }
    }
#line 667
    pl = pl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 674
  return;
}
}
#line 184 "../include/sproto.h"
void command_east(object *op , char const   *params ) ;
#line 185
void command_north(object *op , char const   *params ) ;
#line 186
void command_northeast(object *op , char const   *params ) ;
#line 187
void command_northwest(object *op , char const   *params ) ;
#line 188
void command_south(object *op , char const   *params ) ;
#line 189
void command_southeast(object *op , char const   *params ) ;
#line 190
void command_southwest(object *op , char const   *params ) ;
#line 191
void command_west(object *op , char const   *params ) ;
#line 192
void command_stay(object *op , char const   *params ) ;
#line 420
extern void fire(object *op , int dir ) ;
#line 423
extern int move_player(object *op , int dir ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_move.c"
static void move_internal(object *op , char const   *params , int dir ) 
{ 


  {
#line 51
  if ((int const   )*params != 0) {
#line 52
    if ((int const   )*(params + 0) == 102) {
#line 53
      if (! (op->contr)->fire_on) {
        {
#line 54
        (op->contr)->fire_on = (uint32 )1;
#line 55
        move_player(op, dir);
#line 56
        (op->contr)->fire_on = (uint32 )0;
        }
#line 57
        return;
      }
    } else
#line 59
    if ((int const   )*(params + 0) == 114) {
#line 59
      if (! (op->contr)->run_on) {
#line 60
        (op->contr)->run_on = (uint32 )1;
      }
    }
  }
  {
#line 62
  move_player(op, dir);
  }
#line 63
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_move.c"
void command_east(object *op , char const   *params ) 
{ 


  {
  {
#line 73
  move_internal(op, params, 3);
  }
#line 74
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_move.c"
void command_north(object *op , char const   *params ) 
{ 


  {
  {
#line 84
  move_internal(op, params, 1);
  }
#line 85
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_move.c"
void command_northeast(object *op , char const   *params ) 
{ 


  {
  {
#line 95
  move_internal(op, params, 2);
  }
#line 96
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_move.c"
void command_northwest(object *op , char const   *params ) 
{ 


  {
  {
#line 106
  move_internal(op, params, 8);
  }
#line 107
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_move.c"
void command_south(object *op , char const   *params ) 
{ 


  {
  {
#line 117
  move_internal(op, params, 5);
  }
#line 118
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_move.c"
void command_southeast(object *op , char const   *params ) 
{ 


  {
  {
#line 128
  move_internal(op, params, 4);
  }
#line 129
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_move.c"
void command_southwest(object *op , char const   *params ) 
{ 


  {
  {
#line 139
  move_internal(op, params, 6);
  }
#line 140
  return;
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_move.c"
void command_west(object *op , char const   *params ) 
{ 


  {
  {
#line 150
  move_internal(op, params, 7);
  }
#line 151
  return;
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_move.c"
void command_stay(object *op , char const   *params ) 
{ 


  {
#line 161
  if (! (op->contr)->fire_on) {
#line 161
    if ((int const   )*(params + 0) != 102) {
#line 162
      return;
    }
  }
  {
#line 163
  fire(op, 0);
  }
#line 164
  return;
}
}
#line 321 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 197 "../include/global.h"
artifactlist *first_artifactlist ;
#line 198
archetype *first_archetype ;
#line 220
FILE *logfile ;
#line 224
long nrofartifacts ;
#line 225
long nrofallowedstr ;
#line 263
New_Face *blank_face ;
#line 24 "../include/libproto.h"
object *arch_to_object(archetype *at ) ;
#line 28
archetype *find_archetype(char const   *name ) ;
#line 32
void free_all_artifacts(void) ;
#line 33
void generate_artifact(object *op , int difficulty ) ;
#line 34
void give_artifact_abilities(object *op , object const   *artifact___0 ) ;
#line 35
int legal_artifact_combination(object const   *op , artifact const   *art ) ;
#line 36
void add_abilities(object *op , object const   *change ) ;
#line 37
void init_artifacts(void) ;
#line 38
artifactlist const   *find_artifactlist(int type ) ;
#line 39
artifact const   *find_artifact(object const   *op , char const   *name ) ;
#line 40
void dump_artifacts(void) ;
#line 41
unsigned int artifact_get_face(artifact const   *art ) ;
#line 74
void fatal(int err ) ;
#line 134
void change_attr_value(living *stats , int attr , sint8 value ) ;
#line 135
sint8 get_attr_value(living const   *stats , int attr ) ;
#line 242
extern void object_reset(object *op ) ;
#line 243
extern void object_free_key_values(object *op ) ;
#line 245
extern void object_copy(object const   *src_ob , object *dest_ob ) ;
#line 247
extern object *object_new(void) ;
#line 249
extern void object_update_speed(object *op ) ;
#line 252
extern void object_free_drop_inventory(object *ob ) ;
#line 258
extern void object_remove(object *op ) ;
#line 267
extern object *object_insert_in_ob(object *op , object *where ) ;
#line 306
extern int object_set_value(object *op , char const   *key , char const   *value ,
                            int add_key ) ;
#line 311
extern void object_set_msg(object *op , char const   *msg ) ;
#line 378
extern sstring add_refcount(sstring str ) ;
#line 380
extern sstring find_string(char const   *str ) ;
#line 412
extern void set_abs_magic(object *op , int magic ) ;
#line 453
extern int load_object(FILE *fp , object *op , int bufstate , int map_flags ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
int artifact_init  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
static artifactlist *get_empty_artifactlist(void) 
{ 
  artifactlist *tl ;
  void *tmp ;

  {
  {
#line 51
  tmp = malloc(sizeof(artifactlist ));
#line 51
  tl = (artifactlist *)tmp;
  }
#line 52
  if ((unsigned long )tl == (unsigned long )((void *)0)) {
    {
#line 53
    fatal(0);
    }
  }
#line 54
  tl->next = (struct artifactliststruct *)((void *)0);
#line 55
  tl->items = (struct artifactstruct *)((void *)0);
#line 56
  tl->total_chance = (uint16 )0;
#line 57
  return (tl);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
static artifact *get_empty_artifact(void) 
{ 
  artifact *t ;
  void *tmp ;

  {
  {
#line 70
  tmp = malloc(sizeof(artifact ));
#line 70
  t = (artifact *)tmp;
  }
#line 71
  if ((unsigned long )t == (unsigned long )((void *)0)) {
    {
#line 72
    fatal(0);
    }
  }
#line 73
  t->item = (object *)((void *)0);
#line 74
  t->next = (struct artifactstruct *)((void *)0);
#line 75
  t->chance = (uint16 )0;
#line 76
  t->difficulty = (uint8 )0;
#line 77
  t->allowed = (linked_char *)((void *)0);
#line 78
  t->allowed_size = 0;
#line 79
  return (t);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
static void free_charlinks(linked_char *lc ) 
{ 


  {
#line 89
  if (lc->next) {
    {
#line 90
    free_charlinks(lc->next);
    }
  }
  {
#line 91
  free((void *)lc);
  }
#line 92
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
static void free_artifact(artifact *at ) 
{ 
  object *next ;

  {
#line 109
  if (at->next) {
    {
#line 110
    free_artifact(at->next);
    }
  }
#line 111
  if (at->allowed) {
    {
#line 112
    free_charlinks(at->allowed);
    }
  }
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! at->item) {
#line 113
      goto while_break;
    }
#line 114
    next = (at->item)->next;
#line 115
    if ((at->item)->name) {
      {
#line 116
      free_string((at->item)->name);
      }
    }
#line 117
    if ((at->item)->name_pl) {
      {
#line 118
      free_string((at->item)->name_pl);
      }
    }
#line 119
    if ((at->item)->msg) {
      {
#line 120
      free_string((at->item)->msg);
      }
    }
#line 121
    if ((at->item)->title) {
      {
#line 122
      free_string((at->item)->title);
      }
    }
    {
#line 123
    object_free_key_values(at->item);
#line 124
    free((void *)at->item);
#line 125
    at->item = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  free((void *)at);
  }
#line 128
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
static void free_artifactlist(artifactlist *al ) 
{ 
  artifactlist *nextal ;

  {
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! ((unsigned long )al != (unsigned long )((void *)0))) {
#line 139
      goto while_break;
    }
#line 140
    nextal = al->next;
#line 141
    if (al->items) {
      {
#line 142
      free_artifact(al->items);
      }
    }
    {
#line 144
    free((void *)al);
#line 139
    al = nextal;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
void free_all_artifacts(void) 
{ 


  {
  {
#line 152
  free_artifactlist(first_artifactlist);
#line 153
  first_artifactlist = (artifactlist *)((void *)0);
  }
#line 154
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
void generate_artifact(object *op , int difficulty ) 
{ 
  artifactlist const   *al ;
  artifact const   *art ;
  int i ;
  int roll ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 171
  al = find_artifactlist((int )op->type);
  }
#line 173
  if ((unsigned long )al == (unsigned long )((void *)0)) {
#line 174
    return;
  }
#line 177
  i = 0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < 2)) {
#line 177
      goto while_break;
    }
    {
#line 178
    tmp = random();
#line 178
    roll = (int )(tmp % (long )al->total_chance);
#line 180
    art = (artifact const   *)al->items;
    }
    {
#line 180
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 180
      if (! ((unsigned long )art != (unsigned long )((void *)0))) {
#line 180
        goto while_break___0;
      }
#line 181
      roll -= (int )art->chance;
#line 182
      if (roll < 0) {
#line 183
        goto while_break___0;
      }
#line 180
      art = (artifact const   *)art->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 186
    if ((unsigned long )art == (unsigned long )((void *)0)) {
      {
#line 187
      LOG((LogLevel )0, "Got null entry and non zero roll in generate_artifact, type %d\n",
          (int )op->type);
      }
#line 188
      return;
    } else
#line 186
    if (roll >= 0) {
      {
#line 187
      LOG((LogLevel )0, "Got null entry and non zero roll in generate_artifact, type %d\n",
          (int )op->type);
      }
#line 188
      return;
    }
    {
#line 190
    tmp___0 = strcmp((art->item)->name, "NONE");
    }
#line 190
    if (! tmp___0) {
#line 191
      return;
    }
#line 192
    if ((int )op->magic < 0) {
#line 192
      tmp___1 = - ((int )op->magic);
    } else {
#line 192
      tmp___1 = (int )op->magic;
    }
#line 192
    if (tmp___1 < (int )(art->item)->magic) {
#line 193
      goto __Cont;
    }
#line 196
    if (difficulty < (int )art->difficulty) {
#line 197
      goto __Cont;
    }
    {
#line 199
    tmp___2 = legal_artifact_combination((object const   *)op, art);
    }
#line 199
    if (! tmp___2) {
#line 203
      goto __Cont;
    }
    {
#line 205
    give_artifact_abilities(op, (object const   *)art->item);
    }
#line 206
    return;
    __Cont: /* CIL Label */ 
#line 177
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
void give_artifact_abilities(object *op , object const   *artifact___0 ) 
{ 
  char new_name[256] ;

  {
  {
#line 217
  snprintf((char */* __restrict  */)(new_name), sizeof(new_name), (char const   */* __restrict  */)"of %s",
           artifact___0->name);
  }
#line 218
  if (op->title) {
    {
#line 219
    free_string(op->title);
    }
  }
  {
#line 220
  op->title = add_string((char const   *)(new_name));
  }
#line 221
  if (op->artifact) {
    {
#line 222
    free_string(op->artifact);
    }
  }
  {
#line 223
  op->artifact = add_refcount((sstring )artifact___0->name);
#line 224
  add_abilities(op, artifact___0);
  }
#line 226
  return;
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
int legal_artifact_combination(object const   *op , artifact const   *art ) 
{ 
  int neg ;
  int success ;
  linked_char *tmp ;
  char const   *name ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 233
  success = 0;
#line 237
  if ((unsigned long )art->allowed == (unsigned long )((linked_char *)((void *)0))) {
#line 238
    return (1);
  }
#line 239
  tmp = (linked_char *)art->allowed;
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 239
    if (! tmp) {
#line 239
      goto while_break;
    }
#line 243
    if ((int const   )*(tmp->name) == 33) {
#line 244
      name = tmp->name + 1;
#line 245
      neg = 1;
    } else {
#line 247
      name = tmp->name;
#line 248
      neg = 0;
    }
    {
#line 252
    tmp___0 = strcmp(name, (char const   *)op->name);
    }
#line 252
    if (tmp___0) {
#line 252
      if (op->arch) {
        {
#line 252
        tmp___1 = strcmp(name, (op->arch)->name);
        }
#line 252
        if (tmp___1) {
#line 252
          goto _L;
        } else {
#line 253
          return (! neg);
        }
      } else
      _L: /* CIL Label */ 
#line 258
      if (neg) {
#line 259
        success = 1;
      }
    } else {
#line 253
      return (! neg);
    }
#line 239
    tmp = tmp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 261
  return (success);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
void add_abilities(object *op , object const   *change ) 
{ 
  int i ;
  int tmp ;
  char buf[256] ;
  sint8 tmp___0 ;
  long tmp___1 ;
  object *tmp_obj ;
  object *copy ;
  object *inv ;
  object *next455 ;
  tag_t next_tag455 ;
  tag_t tmp___2 ;

  {
#line 272
  if ((unsigned long )change->face != (unsigned long )blank_face) {
    {
#line 277
    object_set_value(op, "identified_face", (char const   *)(change->face)->name,
                     1);
    }
  }
#line 279
  if (change->flags[0] & (1U << 10)) {
    {
#line 280
    object_set_value(op, "identified_anim_random", "1", 1);
    }
  }
#line 282
  if ((int const   )change->anim_speed > 0) {
    {
#line 283
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%d",
             (int const   )change->anim_speed);
#line 284
    object_set_value(op, "identified_anim_speed", (char const   *)(buf), 1);
    }
  }
#line 286
  if ((int const   )change->animation_id != 0) {
#line 286
    if ((unsigned long )op->arch != (unsigned long )((void *)0)) {
      {
#line 288
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%d",
               (int const   )change->animation_id);
#line 289
      object_set_value(op, "identified_animation", (char const   *)(buf), 1);
      }
    }
  }
#line 292
  i = 0;
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (! (i < 7)) {
#line 292
      goto while_break;
    }
    {
#line 293
    tmp___0 = get_attr_value(& change->stats, i);
#line 293
    change_attr_value(& op->stats, i, tmp___0);
#line 292
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 295
  op->attacktype |= (unsigned int )change->attacktype;
#line 296
  op->path_attuned |= (unsigned int )change->path_attuned;
#line 297
  op->path_repelled |= (unsigned int )change->path_repelled;
#line 298
  op->path_denied |= (unsigned int )change->path_denied;
#line 299
  op->move_type = (MoveType )((int )op->move_type | (int )change->move_type);
#line 300
  op->stats.luck = (sint8 )((int )op->stats.luck + (int )change->stats.luck);
#line 302
  if (change->flags[2] & (1U << 10)) {
#line 303
    op->flags[2] |= 1U << 10;
  }
#line 304
  if (change->flags[2] & (1U << 11)) {
#line 305
    op->flags[2] |= 1U << 11;
  }
#line 306
  if (change->flags[2] & (1U << 10)) {
#line 306
    goto _L;
  } else
#line 306
  if (change->flags[2] & (1U << 11)) {
    _L: /* CIL Label */ 
#line 306
    if ((int )op->magic > 0) {
      {
#line 308
      set_abs_magic(op, - ((int )op->magic));
      }
    }
  }
#line 310
  if (change->flags[2] & 1U) {
#line 311
    op->flags[2] |= 1U;
  }
#line 312
  if (change->flags[1] & (1U << 8)) {
#line 313
    op->flags[1] |= 1U << 8;
  }
#line 314
  if (change->flags[2] & (1U << 7)) {
#line 315
    op->flags[2] |= 1U << 7;
  }
#line 316
  if (change->flags[1] & (1U << 29)) {
#line 317
    op->flags[1] |= 1U << 29;
  }
#line 318
  if (change->flags[2] & (1U << 28)) {
#line 319
    op->flags[2] |= 1U << 28;
  }
#line 320
  if (change->flags[2] & (1U << 29)) {
#line 321
    op->flags[2] |= 1U << 29;
  }
#line 322
  if (change->flags[1] & (1U << 7)) {
#line 323
    op->flags[1] |= 1U << 7;
  }
#line 324
  if (change->flags[2] & (1U << 21)) {
#line 325
    op->flags[2] |= 1U << 21;
  }
#line 327
  if (change->flags[2] & (1U << 3)) {
#line 328
    op->flags[0] &= ~ (1U << 11);
#line 330
    if (! (op->flags[0] & 1U)) {
#line 331
      op->speed = (float )0.0;
    }
    {
#line 332
    object_update_speed(op);
    }
  }
#line 334
  if (change->nrof) {
    {
#line 335
    tmp___1 = random();
#line 335
    op->nrof = (uint32 )(tmp___1 % (long )((int )change->nrof) + 1L);
    }
  }
#line 336
  op->stats.exp += (sint64 )change->stats.exp;
#line 337
  op->stats.wc = (sint8 )((int )op->stats.wc + (int )change->stats.wc);
#line 338
  op->stats.ac = (sint8 )((int )op->stats.ac + (int )change->stats.ac);
#line 340
  if (change->other_arch) {
#line 345
    if ((int )op->type == 3) {
#line 345
      goto _L___0;
    } else
#line 345
    if ((int )op->type == 5) {
      _L___0: /* CIL Label */ 
      {
#line 349
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 349
        if (! op->inv) {
#line 349
          goto while_break___0;
        }
        {
#line 350
        tmp_obj = op->inv;
#line 351
        object_remove(tmp_obj);
#line 352
        object_free_drop_inventory(tmp_obj);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 354
      tmp_obj = arch_to_object((archetype *)change->other_arch);
#line 357
      tmp_obj->flags[0] |= 1U << 13;
#line 358
      object_insert_in_ob(tmp_obj, op);
      }
    }
#line 361
    op->other_arch = (struct archt *)change->other_arch;
  }
#line 364
  if ((int const   )change->stats.hp < 0) {
#line 365
    op->stats.hp = (sint16 )(- ((int const   )change->stats.hp));
  } else {
#line 367
    op->stats.hp = (sint16 )((int )op->stats.hp + (int )change->stats.hp);
  }
#line 368
  if ((int const   )change->stats.maxhp < 0) {
#line 369
    op->stats.maxhp = (sint16 )(- ((int const   )change->stats.maxhp));
  } else {
#line 371
    op->stats.maxhp = (sint16 )((int )op->stats.maxhp + (int )change->stats.maxhp);
  }
#line 372
  if ((int const   )change->stats.sp < 0) {
#line 373
    op->stats.sp = (sint16 )(- ((int const   )change->stats.sp));
  } else {
#line 375
    op->stats.sp = (sint16 )((int )op->stats.sp + (int )change->stats.sp);
  }
#line 376
  if ((int const   )change->stats.maxsp < 0) {
#line 377
    op->stats.maxsp = (sint16 )(- ((int const   )change->stats.maxsp));
  } else {
#line 379
    op->stats.maxsp = (sint16 )((int )op->stats.maxsp + (int )change->stats.maxsp);
  }
#line 380
  if (change->stats.food < 0) {
#line 381
    op->stats.food = (sint32 )(- change->stats.food);
  } else {
#line 383
    op->stats.food += (sint32 )change->stats.food;
  }
#line 384
  if ((int const   )change->level < 0) {
#line 385
    op->level = (sint16 )(- ((int const   )change->level));
  } else {
#line 387
    op->level = (sint16 )((int )op->level + (int )change->level);
  }
#line 389
  op->item_power = (sint8 )change->item_power;
#line 391
  i = 0;
  {
#line 391
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 391
    if (! (i < 26)) {
#line 391
      goto while_break___1;
    }
#line 392
    if (change->resist[i]) {
#line 393
      op->resist[i] = (sint16 )((int )op->resist[i] + (int )change->resist[i]);
    }
#line 391
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 396
  if (change->stats.dam) {
#line 397
    if ((int const   )change->stats.dam < 0) {
#line 398
      op->stats.dam = (sint16 )(- ((int const   )change->stats.dam));
    } else
#line 399
    if (op->stats.dam) {
#line 400
      tmp = ((int )op->stats.dam * (int )change->stats.dam) / 10;
#line 401
      if (tmp == (int )op->stats.dam) {
#line 402
        if ((int const   )change->stats.dam < 10) {
#line 403
          op->stats.dam = (sint16 )((int )op->stats.dam - 1);
        } else {
#line 405
          op->stats.dam = (sint16 )((int )op->stats.dam + 1);
        }
      } else {
#line 407
        op->stats.dam = (sint16 )tmp;
      }
    }
  }
#line 410
  if (change->weight) {
#line 411
    if (change->weight < 0) {
#line 412
      op->weight = (sint32 )(- change->weight);
    } else {
#line 414
      op->weight = (op->weight * (sint32 )change->weight) / 100;
    }
  }
#line 416
  if (change->last_sp) {
#line 417
    if (change->last_sp < 0) {
#line 418
      op->last_sp = (sint32 )(- change->last_sp);
    } else {
#line 420
      op->last_sp = (sint32 )((signed char )((op->last_sp * (int )change->last_sp) / 100));
    }
  }
#line 422
  if (change->gen_sp_armour) {
#line 423
    if ((int const   )change->gen_sp_armour < 0) {
#line 424
      op->gen_sp_armour = (sint8 )(- ((int const   )change->gen_sp_armour));
    } else {
#line 426
      op->gen_sp_armour = (signed char )(((int )op->gen_sp_armour * (int )change->gen_sp_armour) / 100);
    }
  }
#line 428
  op->value *= (sint32 )change->value;
#line 430
  if (change->material) {
#line 431
    op->material = (uint16 )change->material;
  }
#line 433
  if (change->materialname) {
#line 434
    if (op->materialname) {
      {
#line 435
      free_string(op->materialname);
      }
    }
    {
#line 436
    op->materialname = add_refcount((sstring )change->materialname);
    }
  }
#line 439
  if (change->slaying) {
#line 440
    if (op->slaying) {
      {
#line 441
      free_string(op->slaying);
      }
    }
    {
#line 442
    op->slaying = add_refcount((sstring )change->slaying);
    }
  }
#line 444
  if (change->race) {
#line 445
    if (op->race) {
      {
#line 446
      free_string(op->race);
      }
    }
    {
#line 447
    op->race = add_refcount((sstring )change->race);
    }
  }
#line 449
  if (change->msg) {
    {
#line 450
    object_set_msg(op, (char const   *)change->msg);
    }
  }
#line 452
  if (change->inv) {
    {
#line 455
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 455
      inv = (object *)change->inv;
      {
#line 455
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 455
        next455 = inv;
#line 455
        if ((unsigned long )next455 == (unsigned long )((void *)0)) {
#line 455
          tmp___2 = (tag_t )0;
        } else {
#line 455
          tmp___2 = next455->count;
        }
#line 455
        next_tag455 = tmp___2;
        {
#line 455
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 455
          inv = next455;
#line 455
          if (! ((unsigned long )inv != (unsigned long )((void *)0))) {
#line 455
            goto while_break___4;
          }
#line 455
          if (next455->count != next_tag455) {
#line 455
            goto while_break___4;
          } else
#line 455
          if (next455->flags[0] & (1U << 3)) {
#line 455
            goto while_break___4;
          }
#line 455
          next455 = next455->below;
#line 455
          if ((unsigned long )next455 == (unsigned long )((void *)0)) {
#line 455
            next_tag455 = (tag_t )0;
          } else {
#line 455
            next_tag455 = next455->count;
          }
          {
#line 456
          copy = object_new();
#line 457
          object_copy((object const   *)inv, copy);
#line 458
          object_insert_in_ob(copy, op);
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 455
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 455
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 461
  return;
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
static artifactlist *find_artifactlist_internal(int type ) 
{ 
  artifactlist *al ;

  {
#line 474
  al = first_artifactlist;
  {
#line 474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 474
    if (! ((unsigned long )al != (unsigned long )((void *)0))) {
#line 474
      goto while_break;
    }
#line 475
    if ((int )al->type == type) {
#line 476
      return (al);
    }
#line 474
    al = al->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  return ((artifactlist *)((void *)0));
}
}
#line 485 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
static int has_been_inited  =    0;
#line 484 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
void init_artifacts(void) 
{ 
  FILE *fp ;
  char filename[256] ;
  char buf[4096] ;
  char *cp ;
  char *next ;
  artifact *art ;
  linked_char *tmp ;
  int value ;
  artifactlist *al ;
  archetype dummy_archetype ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 488
  art = (artifact *)((void *)0);
#line 494
  memset((void *)(& dummy_archetype), 0, sizeof(archetype ));
  }
#line 496
  if (has_been_inited) {
#line 497
    return;
  } else {
#line 499
    has_been_inited = 1;
  }
  {
#line 501
  artifact_init = 1;
#line 503
  snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s/artifacts",
           settings.datadir);
#line 504
  LOG((LogLevel )2, "Reading artifacts from %s...\n", filename);
#line 505
  fp = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"r");
  }
#line 505
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 506
    LOG((LogLevel )0, "Can\'t open %s.\n", filename);
    }
#line 507
    return;
  }
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 510
    tmp___13 = fgets((char */* __restrict  */)(buf), 4096, (FILE */* __restrict  */)fp);
    }
#line 510
    if (! ((unsigned long )tmp___13 != (unsigned long )((void *)0))) {
#line 510
      goto while_break;
    }
#line 511
    if ((int )buf[0] == 35) {
#line 512
      goto while_continue;
    }
    {
#line 513
    cp = strchr((char const   *)(buf), '\n');
    }
#line 513
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 514
      *cp = (char )'\000';
    }
#line 515
    cp = buf;
    {
#line 516
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 516
      if (! ((int )*cp == 32)) {
#line 516
        goto while_break___0;
      }
#line 517
      cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 518
    if ((int )*cp == 0) {
#line 519
      goto while_continue;
    }
    {
#line 521
    tmp___12 = strncmp((char const   *)cp, "Allowed", (size_t )7);
    }
#line 521
    if (tmp___12) {
      {
#line 546
      tmp___11 = sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"chance %d",
                        & value);
      }
#line 546
      if (tmp___11) {
#line 547
        art->chance = (uint16 )value;
      } else {
        {
#line 548
        tmp___10 = sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"difficulty %d",
                          & value);
        }
#line 548
        if (tmp___10) {
#line 549
          art->difficulty = (uint8 )value;
        } else {
          {
#line 550
          tmp___9 = strncmp((char const   *)cp, "Object", (size_t )6);
          }
#line 550
          if (tmp___9) {
            {
#line 573
            LOG((LogLevel )0, "Unknown input in artifact file: %s\n", buf);
            }
          } else {
            {
#line 551
            tmp___6 = calloc((size_t )1, sizeof(object ));
#line 551
            art->item = (object *)tmp___6;
            }
#line 552
            if ((unsigned long )art->item == (unsigned long )((void *)0)) {
              {
#line 553
              LOG((LogLevel )0, "init_artifacts: memory allocation failure.\n");
#line 554
              abort();
              }
            }
            {
#line 556
            object_reset(art->item);
#line 557
            (art->item)->arch = & dummy_archetype;
#line 558
            tmp___7 = load_object(fp, art->item, 1, 8);
            }
#line 558
            if (! tmp___7) {
              {
#line 559
              LOG((LogLevel )0, "Init_Artifacts: Could not load object.\n");
              }
            }
            {
#line 560
            (art->item)->arch = (struct archt *)((void *)0);
#line 561
            tmp___8 = strchr((char const   *)cp, ' ');
#line 561
            (art->item)->name = add_string((char const   *)(tmp___8 + 1));
#line 562
            al = find_artifactlist_internal((int )(art->item)->type);
            }
#line 563
            if ((unsigned long )al == (unsigned long )((void *)0)) {
              {
#line 564
              al = get_empty_artifactlist();
#line 565
              al->type = (art->item)->type;
#line 566
              al->next = first_artifactlist;
#line 567
              first_artifactlist = al;
              }
            }
#line 569
            art->next = al->items;
#line 570
            al->items = art;
#line 571
            art = (artifact *)((void *)0);
          }
        }
      }
    } else {
#line 522
      if ((unsigned long )art == (unsigned long )((void *)0)) {
        {
#line 523
        art = get_empty_artifact();
#line 524
        nrofartifacts ++;
        }
      }
      {
#line 527
      tmp___0 = strchr((char const   *)cp, ' ');
#line 527
      cp = tmp___0 + 1;
      }
      {
#line 528
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 528
        tmp___2 = strlen((char const   *)cp);
        }
#line 528
        if (! ((int )*((cp + tmp___2) - 1) == 32)) {
#line 528
          goto while_break___1;
        }
        {
#line 529
        tmp___1 = strlen((char const   *)cp);
#line 529
        *(cp + (tmp___1 - 1UL)) = (char )'\000';
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 531
      tmp___3 = strcmp((char const   *)cp, "all");
      }
#line 531
      if (! tmp___3) {
#line 532
        goto while_continue;
      }
      {
#line 534
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 535
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 535
          if (! ((int )*cp == 32)) {
#line 535
            goto while_break___3;
          }
#line 536
          cp ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 537
        nrofallowedstr ++;
#line 538
        next = strchr((char const   *)cp, ',');
        }
#line 538
        if ((unsigned long )next != (unsigned long )((void *)0)) {
#line 539
          tmp___4 = next;
#line 539
          next ++;
#line 539
          *tmp___4 = (char )'\000';
        }
        {
#line 540
        tmp___5 = malloc(sizeof(linked_char ));
#line 540
        tmp = (linked_char *)tmp___5;
#line 541
        tmp->name = add_string((char const   *)cp);
#line 542
        tmp->next = art->allowed;
#line 543
        art->allowed = tmp;
#line 544
        (art->allowed_size) ++;
#line 534
        cp = next;
        }
#line 534
        if (! ((unsigned long )cp != (unsigned long )((void *)0))) {
#line 534
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 576
  fclose(fp);
#line 578
  al = first_artifactlist;
  }
  {
#line 578
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 578
    if (! ((unsigned long )al != (unsigned long )((void *)0))) {
#line 578
      goto while_break___4;
    }
#line 579
    art = al->items;
    {
#line 579
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 579
      if (! ((unsigned long )art != (unsigned long )((void *)0))) {
#line 579
        goto while_break___5;
      }
#line 580
      if (! art->chance) {
        {
#line 581
        LOG((LogLevel )0, "Warning: artifact with no chance: %s\n", (art->item)->name);
        }
      } else {
#line 583
        al->total_chance = (uint16 )((int )al->total_chance + (int )art->chance);
      }
#line 579
      art = art->next;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 578
    al = al->next;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 590
  LOG((LogLevel )2, "done artifacts.\n");
#line 591
  artifact_init = 0;
  }
#line 592
  return;
}
}
#line 601 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
artifactlist const   *find_artifactlist(int type ) 
{ 
  artifactlist *tmp ;

  {
  {
#line 602
  tmp = find_artifactlist_internal(type);
  }
#line 602
  return ((artifactlist const   *)tmp);
}
}
#line 611 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
artifact const   *find_artifact(object const   *op , char const   *name ) 
{ 
  artifactlist *list ;
  artifact *at ;
  sstring sname ;
  sstring tmp ;
  int tmp___0 ;

  {
  {
#line 614
  tmp = find_string(name);
#line 614
  sname = tmp;
  }
#line 616
  if ((unsigned long )sname == (unsigned long )((void *)0)) {
#line 617
    return ((artifact const   *)((void *)0));
  }
  {
#line 619
  list = find_artifactlist_internal((int )op->type);
  }
#line 620
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 621
    return ((artifact const   *)((void *)0));
  }
#line 623
  at = list->items;
  {
#line 623
  while (1) {
    while_continue: /* CIL Label */ ;
#line 623
    if (! ((unsigned long )at != (unsigned long )((void *)0))) {
#line 623
      goto while_break;
    }
#line 624
    if ((unsigned long )(at->item)->name == (unsigned long )sname) {
      {
#line 624
      tmp___0 = legal_artifact_combination(op, (artifact const   *)at);
      }
#line 624
      if (tmp___0) {
#line 625
        return ((artifact const   *)at);
      }
    }
#line 623
    at = at->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 628
  return ((artifact const   *)((void *)0));
}
}
#line 637 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
void dump_artifacts(void) 
{ 
  artifactlist *al ;
  artifact *art ;
  linked_char *next ;

  {
  {
#line 642
  fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"\n");
#line 643
  al = first_artifactlist;
  }
  {
#line 643
  while (1) {
    while_continue: /* CIL Label */ ;
#line 643
    if (! ((unsigned long )al != (unsigned long )((void *)0))) {
#line 643
      goto while_break;
    }
    {
#line 644
    fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"Artifact has type %d, total_chance=%d\n",
            (int )al->type, (int )al->total_chance);
#line 645
    art = al->items;
    }
    {
#line 645
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 645
      if (! ((unsigned long )art != (unsigned long )((void *)0))) {
#line 645
        goto while_break___0;
      }
      {
#line 646
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"Artifact %-30s Difficulty %3d Chance %5d\n",
              (art->item)->name, (int )art->difficulty, (int )art->chance);
      }
#line 647
      if ((unsigned long )art->allowed != (unsigned long )((void *)0)) {
        {
#line 648
        fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"\tAllowed combinations:");
#line 649
        next = art->allowed;
        }
        {
#line 649
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 649
          if (! ((unsigned long )next != (unsigned long )((void *)0))) {
#line 649
            goto while_break___1;
          }
          {
#line 650
          fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s,",
                  next->name);
#line 649
          next = next->next;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 651
        fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"\n");
        }
      }
#line 645
      art = art->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 643
    al = al->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 655
  fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"\n");
  }
#line 656
  return;
}
}
#line 663 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
unsigned int artifact_get_face(artifact const   *art ) 
{ 
  archetype const   *arch ;
  linked_char *allowed ;
  int tmp ;
  archetype const   *arch___0 ;
  archetype *tmp___0 ;

  {
#line 664
  arch = (archetype const   *)first_archetype;
#line 666
  if ((unsigned long )(art->item)->face != (unsigned long )blank_face) {
#line 666
    if ((unsigned long )(art->item)->face != (unsigned long )((void *)0)) {
#line 667
      return ((unsigned int )((art->item)->face)->number);
    }
  }
#line 669
  if (art->allowed_size > 0) {
#line 670
    if ((int const   )*((art->allowed)->name + 0) == 33) {
      {
#line 672
      while (1) {
        while_continue: /* CIL Label */ ;
#line 672
        if (! arch) {
#line 672
          goto while_break;
        }
#line 673
        if ((int const   )arch->clone.type != (int const   )(art->item)->type) {
#line 674
          arch = (archetype const   *)arch->next;
        }
#line 676
        allowed = (linked_char *)art->allowed;
        {
#line 676
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 676
          if (! ((unsigned long )allowed != (unsigned long )((void *)0))) {
#line 676
            goto while_break___0;
          }
          {
#line 677
          tmp = strcmp((char const   *)arch->name, allowed->name + 1);
          }
#line 677
          if (tmp == 0) {
#line 678
            goto while_break___0;
          }
#line 676
          allowed = allowed->next;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 681
        if ((unsigned long )allowed != (unsigned long )((void *)0)) {
#line 682
          goto while_continue;
        }
#line 684
        if ((unsigned long )arch->clone.face == (unsigned long )((void *)0)) {
#line 685
          goto while_continue;
        }
#line 686
        return ((unsigned int )(arch->clone.face)->number);
      }
      while_break: /* CIL Label */ ;
      }
#line 688
      return (4294967295U);
    } else {
      {
#line 690
      tmp___0 = find_archetype((art->allowed)->name);
#line 690
      arch___0 = (archetype const   *)tmp___0;
      }
#line 691
      if ((unsigned long )arch___0 != (unsigned long )((void *)0)) {
#line 692
        return ((unsigned int )(arch___0->clone.face)->number);
      }
#line 693
      return (4294967295U);
    }
  }
  {
#line 697
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 697
    if (! ((unsigned long )arch != (unsigned long )((void *)0))) {
#line 697
      goto while_break___1;
    }
#line 698
    if ((int const   )arch->clone.type == (int const   )(art->item)->type) {
#line 698
      if ((unsigned long )arch->clone.face != (unsigned long )((void *)0)) {
#line 699
        return ((unsigned int )(arch->clone.face)->number);
      }
    }
#line 701
    arch = (archetype const   *)arch->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 703
  return (4294967295U);
}
}
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 71 "../include/commands.h"
command_array_struct Commands[78] ;
#line 71
command_array_struct WizCommands[59] ;
#line 71
command_array_struct CommunicationCommands[63] ;
#line 73
int const   CommandsSize ;
#line 73
int const   WizCommandsSize ;
#line 73
int const   CommunicationCommandSize ;
#line 61 "../include/sproto.h"
void command_say(object *op , char const   *params ) ;
#line 62
void command_me(object *op , char const   *params ) ;
#line 63
void command_cointoss(object *op , char const   *params ) ;
#line 64
void command_orcknuckle(object *op , char const   *params ) ;
#line 65
void command_shout(object *op , char const   *params ) ;
#line 66
void command_chat(object *op , char const   *params ) ;
#line 67
void command_tell(object *op , char const   *params ) ;
#line 68
void command_dmtell(object *op , char const   *params ) ;
#line 69
void command_reply(object *op , char const   *params ) ;
#line 70
void command_nod(object *op , char const   *params ) ;
#line 71
void command_dance(object *op , char const   *params ) ;
#line 72
void command_kiss(object *op , char const   *params ) ;
#line 73
void command_bounce(object *op , char const   *params ) ;
#line 74
void command_smile(object *op , char const   *params ) ;
#line 75
void command_cackle(object *op , char const   *params ) ;
#line 76
void command_laugh(object *op , char const   *params ) ;
#line 77
void command_giggle(object *op , char const   *params ) ;
#line 78
void command_shake(object *op , char const   *params ) ;
#line 79
void command_puke(object *op , char const   *params ) ;
#line 80
void command_growl(object *op , char const   *params ) ;
#line 81
void command_scream(object *op , char const   *params ) ;
#line 82
void command_sigh(object *op , char const   *params ) ;
#line 83
void command_sulk(object *op , char const   *params ) ;
#line 84
void command_hug(object *op , char const   *params ) ;
#line 85
void command_cry(object *op , char const   *params ) ;
#line 86
void command_poke(object *op , char const   *params ) ;
#line 87
void command_accuse(object *op , char const   *params ) ;
#line 88
void command_grin(object *op , char const   *params ) ;
#line 89
void command_bow(object *op , char const   *params ) ;
#line 90
void command_clap(object *op , char const   *params ) ;
#line 91
void command_blush(object *op , char const   *params ) ;
#line 92
void command_burp(object *op , char const   *params ) ;
#line 93
void command_chuckle(object *op , char const   *params ) ;
#line 94
void command_cough(object *op , char const   *params ) ;
#line 95
void command_flip(object *op , char const   *params ) ;
#line 96
void command_frown(object *op , char const   *params ) ;
#line 97
void command_gasp(object *op , char const   *params ) ;
#line 98
void command_glare(object *op , char const   *params ) ;
#line 99
void command_groan(object *op , char const   *params ) ;
#line 100
void command_hiccup(object *op , char const   *params ) ;
#line 101
void command_lick(object *op , char const   *params ) ;
#line 102
void command_pout(object *op , char const   *params ) ;
#line 103
void command_shiver(object *op , char const   *params ) ;
#line 104
void command_shrug(object *op , char const   *params ) ;
#line 105
void command_slap(object *op , char const   *params ) ;
#line 106
void command_smirk(object *op , char const   *params ) ;
#line 107
void command_snap(object *op , char const   *params ) ;
#line 108
void command_sneeze(object *op , char const   *params ) ;
#line 109
void command_snicker(object *op , char const   *params ) ;
#line 110
void command_sniff(object *op , char const   *params ) ;
#line 111
void command_snore(object *op , char const   *params ) ;
#line 112
void command_spit(object *op , char const   *params ) ;
#line 113
void command_strut(object *op , char const   *params ) ;
#line 114
void command_thank(object *op , char const   *params ) ;
#line 115
void command_twiddle(object *op , char const   *params ) ;
#line 116
void command_wave(object *op , char const   *params ) ;
#line 117
void command_whistle(object *op , char const   *params ) ;
#line 118
void command_wink(object *op , char const   *params ) ;
#line 119
void command_yawn(object *op , char const   *params ) ;
#line 120
void command_beg(object *op , char const   *params ) ;
#line 121
void command_bleed(object *op , char const   *params ) ;
#line 122
void command_cringe(object *op , char const   *params ) ;
#line 123
void command_think(object *op , char const   *params ) ;
#line 126
void command_language(object *op , char const   *params ) ;
#line 127
void command_body(object *op , char const   *params ) ;
#line 128
void command_motd(object *op , char const   *params ) ;
#line 129
void command_rules(object *op , char const   *params ) ;
#line 130
void command_news(object *op , char const   *params ) ;
#line 133
void command_whereabouts(object *op , char const   *params ) ;
#line 135
void command_who(object *op , char const   *params ) ;
#line 138
void command_afk(object *op , char const   *params ) ;
#line 139
void command_malloc(object *op , char const   *params ) ;
#line 140
void command_mapinfo(object *op , char const   *params ) ;
#line 141
void command_whereami(object *op , char const   *params ) ;
#line 142
void command_maps(object *op , char const   *params ) ;
#line 143
void command_strings(object *op , char const   *params ) ;
#line 144
void command_time(object *op , char const   *params ) ;
#line 145
void command_archs(object *op , char const   *params ) ;
#line 146
void command_hiscore(object *op , char const   *params ) ;
#line 147
void command_debug(object *op , char const   *params ) ;
#line 148
void command_wizpass(object *op , char const   *params ) ;
#line 149
void command_wizcast(object *op , char const   *params ) ;
#line 150
void command_dumpallobjects(object *op , char const   *params ) ;
#line 151
void command_dumpfriendlyobjects(object *op , char const   *params ) ;
#line 152
void command_dumpallarchetypes(object *op , char const   *params ) ;
#line 153
void command_ssdumptable(object *op , char const   *params ) ;
#line 154
void command_dumpmap(object *op , char const   *params ) ;
#line 155
void command_dumpallmaps(object *op , char const   *params ) ;
#line 156
void command_printlos(object *op , char const   *params ) ;
#line 157
void command_version(object *op , char const   *params ) ;
#line 158
void command_listen(object *op , char const   *params ) ;
#line 159
void command_statistics(object *pl , char const   *params ) ;
#line 160
void command_fix_me(object *op , char const   *params ) ;
#line 161
void command_players(object *op , char const   *params ) ;
#line 162
void command_applymode(object *op , char const   *params ) ;
#line 163
void command_bowmode(object *op , char const   *params ) ;
#line 164
void command_unarmed_skill(object *op , char const   *params ) ;
#line 165
void command_petmode(object *op , char const   *params ) ;
#line 166
void command_showpets(object *op , char const   *params ) ;
#line 167
void command_usekeys(object *op , char const   *params ) ;
#line 168
void command_resistances(object *op , char const   *params ) ;
#line 169
void command_help(object *op , char const   *params ) ;
#line 171
void command_quit(object *op , char const   *params ) ;
#line 172
void command_sound(object *op , char const   *params ) ;
#line 175
void command_title(object *op , char const   *params ) ;
#line 176
void command_save(object *op , char const   *params ) ;
#line 177
void command_peaceful(object *op , char const   *params ) ;
#line 178
void command_wimpy(object *op , char const   *params ) ;
#line 179
void command_brace(object *op , char const   *params ) ;
#line 180
void command_kill_pets(object *op , char const   *params ) ;
#line 181
void command_passwd(object *pl , char const   *params ) ;
#line 195
void command_run(object *op , char const   *params ) ;
#line 196
void command_run_stop(object *op , char const   *params ) ;
#line 197
void command_fire(object *op , char const   *params ) ;
#line 198
void command_fire_stop(object *op , char const   *params ) ;
#line 200
void command_uskill(object *pl , char const   *params ) ;
#line 201
void command_rskill(object *pl , char const   *params ) ;
#line 202
void command_search(object *op , char const   *params ) ;
#line 203
void command_disarm(object *op , char const   *params ) ;
#line 204
void command_throw(object *op , char const   *params ) ;
#line 205
void command_apply(object *op , char const   *params ) ;
#line 208
void command_take(object *op , char const   *params ) ;
#line 212
void command_dropall(object *op , char const   *params ) ;
#line 213
void command_drop(object *op , char const   *params ) ;
#line 214
void command_empty(object *op , char const   *params ) ;
#line 215
void command_examine(object *op , char const   *params ) ;
#line 217
void command_mark(object *op , char const   *params ) ;
#line 221
void command_pickup(object *op , char const   *params ) ;
#line 222
void command_search_items(object *op , char const   *params ) ;
#line 223
void command_rename_item(object *op , char const   *params ) ;
#line 224
void command_lock_item(object *op , char const   *params ) ;
#line 225
void command_use(object *op , char const   *params ) ;
#line 233
void command_invoke(object *op , char const   *params ) ;
#line 234
void command_cast(object *op , char const   *params ) ;
#line 235
void command_prepare(object *op , char const   *params ) ;
#line 239
void command_rotateshoottype(object *op , char const   *params ) ;
#line 241
void command_loadtest(object *op , char const   *params ) ;
#line 242
void command_hide(object *op , char const   *params ) ;
#line 243
void command_setgod(object *op , char const   *params ) ;
#line 244
void command_banish(object *op , char const   *params ) ;
#line 245
void command_kick(object *op , char const   *params ) ;
#line 246
void command_overlay_save(object *op , char const   *params ) ;
#line 247
void command_overlay_reset(object *op , char const   *params ) ;
#line 248
void command_toggle_shout(object *op , char const   *params ) ;
#line 249
void command_shutdown(object *op , char const   *params ) ;
#line 250
void command_goto(object *op , char const   *params ) ;
#line 251
void command_freeze(object *op , char const   *params ) ;
#line 253
void command_arrest(object *op , char const   *params ) ;
#line 254
void command_summon(object *op , char const   *params ) ;
#line 255
void command_teleport(object *op , char const   *params ) ;
#line 256
void command_create(object *op , char const   *params ) ;
#line 257
void command_inventory(object *op , char const   *params ) ;
#line 258
void command_skills(object *op , char const   *params ) ;
#line 259
void command_dump(object *op , char const   *params ) ;
#line 260
void command_mon_aggr(object *op , char const   *params ) ;
#line 262
void command_patch(object *op , char const   *params ) ;
#line 263
void command_remove(object *op , char const   *params ) ;
#line 264
void command_free(object *op , char const   *params ) ;
#line 265
void command_addexp(object *op , char const   *params ) ;
#line 266
void command_speed(object *op , char const   *params ) ;
#line 267
void command_stats(object *op , char const   *params ) ;
#line 268
void command_abil(object *op , char const   *params ) ;
#line 269
void command_reset(object *op , char const   *params ) ;
#line 270
void command_nowiz(object *op , char const   *params ) ;
#line 271
void command_dm(object *op , char const   *params ) ;
#line 272
void command_invisible(object *op , char const   *params ) ;
#line 273
void command_learn_spell(object *op , char const   *params ) ;
#line 274
void command_learn_special_prayer(object *op , char const   *params ) ;
#line 275
void command_forget_spell(object *op , char const   *params ) ;
#line 276
void command_listplugins(object *op , char const   *params ) ;
#line 277
void command_loadplugin(object *op , char const   *params ) ;
#line 278
void command_unloadplugin(object *op , char const   *params ) ;
#line 279
void command_dmhide(object *op , char const   *params ) ;
#line 280
void command_stack_pop(object *op , char const   *params ) ;
#line 281
void command_stack_push(object *op , char const   *params ) ;
#line 282
void command_stack_list(object *op , char const   *params ) ;
#line 283
void command_stack_clear(object *op , char const   *params ) ;
#line 284
void command_diff(object *op , char const   *params ) ;
#line 285
void command_insert_into(object *op , char const   *params ) ;
#line 286
void command_style_map_info(object *op , char const   *params ) ;
#line 287
void command_follow(object *op , char const   *params ) ;
#line 288
void command_purge_quest(object *op , char const   *param ) ;
#line 289
void command_purge_quest_definitions(object *op , char const   *param ) ;
#line 290
void command_dumpbelow(object *op , char const   *params ) ;
#line 292
void init_commands(void) ;
#line 318
extern void command_knowledge(object *pl , char const   *params ) ;
#line 457
void command_quest(object *op , char const   *params ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/commands.c"
command_array_struct Commands[78]  = 
#line 49 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/commands.c"
  {      {"afk", & command_afk, (float )0.0}, 
        {"apply", & command_apply, (float )1.0}, 
        {"applymode", & command_applymode, (float )1.0}, 
        {"body", & command_body, (float )0.0}, 
        {"bowmode", & command_bowmode, (float )0.0}, 
        {"brace", & command_brace, (float )0.0}, 
        {"cast", & command_cast, (float )0.2}, 
        {"disarm", & command_disarm, (float )1.0}, 
        {"dm", & command_dm, (float )0.0}, 
        {"dmhide", & command_dmhide, (float )0.0}, 
        {"drop", & command_drop, (float )1.0}, 
        {"dropall", & command_dropall, (float )1.0}, 
        {"empty", & command_empty, (float )1.0}, 
        {"examine", & command_examine, (float )0.5}, 
        {"fix_me", & command_fix_me, (float )0.0}, 
        {"get", & command_take, (float )1.0}, 
        {"help", & command_help, (float )0.0}, 
        {"hiscore", & command_hiscore, (float )0.0}, 
        {"inventory", & command_inventory, (float )0.0}, 
        {"invoke", & command_invoke, (float )1.0}, 
        {"killpets", & command_kill_pets, (float )0.0}, 
        {"language", & command_language, (float )0.0}, 
        {"listen", & command_listen, (float )0.0}, 
        {"lock", & command_lock_item, (float )0.0}, 
        {"maps", & command_maps, (float )0.0}, 
        {"mapinfo", & command_mapinfo, (float )0.0}, 
        {"mark", & command_mark, (float )0.0}, 
        {"motd", & command_motd, (float )0.0}, 
        {"news", & command_news, (float )0.0}, 
        {"party", & command_party, (float )0.0}, 
        {"party_rejoin", & command_party_rejoin, (float )0.0}, 
        {"passwd", & command_passwd, (float )0.0}, 
        {"peaceful", & command_peaceful, (float )0.0}, 
        {"petmode", & command_petmode, (float )0.0}, 
        {"pickup", & command_pickup, (float )1.0}, 
        {"prepare", & command_prepare, (float )1.0}, 
        {"printlos", & command_printlos, (float )0.0}, 
        {"quit", & command_quit, (float )0.0}, 
        {"ready_skill", & command_rskill, (float )1.0}, 
        {"rename", & command_rename_item, (float )0.0}, 
        {"resistances", & command_resistances, (float )0.0}, 
        {"rotateshoottype", & command_rotateshoottype, (float )0.0}, 
        {"rules", & command_rules, (float )0.0}, 
        {"save", & command_save, (float )0.0}, 
        {"skills", & command_skills, (float )0.0}, 
        {"use_skill", & command_uskill, (float )1.0}, 
        {"search", & command_search, (float )1.0}, 
        {"search-items", & command_search_items, (float )0.0}, 
        {"showpets", & command_showpets, (float )1.0}, 
        {"sound", & command_sound, (float )0.0}, 
        {"statistics", & command_statistics, (float )0.0}, 
        {"take", & command_take, (float )1.0}, 
        {"throw", & command_throw, (float )1.0}, 
        {"time", & command_time, (float )0.0}, 
        {"title", & command_title, (float )0.0}, 
        {"use", & command_use, (float )1.0}, 
        {"usekeys", & command_usekeys, (float )0.0}, 
        {"whereabouts", & command_whereabouts, (float )0.0}, 
        {"whereami", & command_whereami, (float )0.0}, 
        {"unarmed_skill", & command_unarmed_skill, (float )0.0}, 
        {"version", & command_version, (float )0.0}, 
        {"wimpy", & command_wimpy, (float )0.0}, 
        {"who", & command_who, (float )0.0}, 
        {"stay", & command_stay, (float )1.0}, 
        {"north", & command_north, (float )1.0}, 
        {"east", & command_east, (float )1.0}, 
        {"south", & command_south, (float )1.0}, 
        {"west", & command_west, (float )1.0}, 
        {"northeast", & command_northeast, (float )1.0}, 
        {"southeast", & command_southeast, (float )1.0}, 
        {"southwest", & command_southwest, (float )1.0}, 
        {"northwest", & command_northwest, (float )1.0}, 
        {"run", & command_run, (float )1.0}, 
        {"run_stop", & command_run_stop, (float )0.0}, 
        {"fire", & command_fire, (float )1.0}, 
        {"fire_stop", & command_fire_stop, (float )0.0}, 
        {"quest", & command_quest, (float )0.0}, 
        {"knowledge", & command_knowledge, (float )0.0}};
#line 138 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/commands.c"
int const   CommandsSize  =    (int const   )(sizeof(Commands) / sizeof(command_array_struct ));
#line 141 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/commands.c"
command_array_struct CommunicationCommands[63]  = 
#line 141
  {      {"tell", & command_tell, (float )0.1}, 
        {"reply", & command_reply, (float )0.0}, 
        {"say", & command_say, (float )0.1}, 
        {"gsay", & command_gsay, (float )1.0}, 
        {"shout", & command_shout, (float )0.1}, 
        {"chat", & command_chat, (float )0.1}, 
        {"me", & command_me, (float )0.1}, 
        {"cointoss", & command_cointoss, (float )0.0}, 
        {"orcknuckle", & command_orcknuckle, (float )0.0}, 
        {"nod", & command_nod, (float )0.0}, 
        {"dance", & command_dance, (float )0.0}, 
        {"kiss", & command_kiss, (float )0.0}, 
        {"bounce", & command_bounce, (float )0.0}, 
        {"smile", & command_smile, (float )0.0}, 
        {"cackle", & command_cackle, (float )0.0}, 
        {"laugh", & command_laugh, (float )0.0}, 
        {"giggle", & command_giggle, (float )0.0}, 
        {"shake", & command_shake, (float )0.0}, 
        {"puke", & command_puke, (float )0.0}, 
        {"growl", & command_growl, (float )0.0}, 
        {"scream", & command_scream, (float )0.0}, 
        {"sigh", & command_sigh, (float )0.0}, 
        {"sulk", & command_sulk, (float )0.0}, 
        {"hug", & command_hug, (float )0.0}, 
        {"cry", & command_cry, (float )0.0}, 
        {"poke", & command_poke, (float )0.0}, 
        {"accuse", & command_accuse, (float )0.0}, 
        {"grin", & command_grin, (float )0.0}, 
        {"bow", & command_bow, (float )0.0}, 
        {"clap", & command_clap, (float )0.0}, 
        {"blush", & command_blush, (float )0.0}, 
        {"burp", & command_burp, (float )0.0}, 
        {"chuckle", & command_chuckle, (float )0.0}, 
        {"cough", & command_cough, (float )0.0}, 
        {"flip", & command_flip, (float )0.0}, 
        {"frown", & command_frown, (float )0.0}, 
        {"gasp", & command_gasp, (float )0.0}, 
        {"glare", & command_glare, (float )0.0}, 
        {"groan", & command_groan, (float )0.0}, 
        {"hiccup", & command_hiccup, (float )0.0}, 
        {"lick", & command_lick, (float )0.0}, 
        {"pout", & command_pout, (float )0.0}, 
        {"shiver", & command_shiver, (float )0.0}, 
        {"shrug", & command_shrug, (float )0.0}, 
        {"slap", & command_slap, (float )0.0}, 
        {"smirk", & command_smirk, (float )0.0}, 
        {"snap", & command_snap, (float )0.0}, 
        {"sneeze", & command_sneeze, (float )0.0}, 
        {"snicker", & command_snicker, (float )0.0}, 
        {"sniff", & command_sniff, (float )0.0}, 
        {"snore", & command_snore, (float )0.0}, 
        {"spit", & command_spit, (float )0.0}, 
        {"strut", & command_strut, (float )0.0}, 
        {"thank", & command_thank, (float )0.0}, 
        {"twiddle", & command_twiddle, (float )0.0}, 
        {"wave", & command_wave, (float )0.0}, 
        {"whistle", & command_whistle, (float )0.0}, 
        {"wink", & command_wink, (float )0.0}, 
        {"yawn", & command_yawn, (float )0.0}, 
        {"beg", & command_beg, (float )0.0}, 
        {"bleed", & command_bleed, (float )0.0}, 
        {"cringe", & command_cringe, (float )0.0}, 
        {"think", & command_think, (float )0.0}};
#line 211 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/commands.c"
int const   CommunicationCommandSize  =    (int const   )(sizeof(CommunicationCommands) / sizeof(command_array_struct ));
#line 214 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/commands.c"
command_array_struct WizCommands[59]  = 
#line 214
  {      {"abil", & command_abil, (float )0.0}, 
        {"addexp", & command_addexp, (float )0.0}, 
        {"archs", & command_archs, (float )0.0}, 
        {"arrest", & command_arrest, (float )0.0}, 
        {"banish", & command_banish, (float )0.0}, 
        {"create", & command_create, (float )0.0}, 
        {"debug", & command_debug, (float )0.0}, 
        {"diff", & command_diff, (float )0.0}, 
        {"dmtell", & command_dmtell, (float )0.0}, 
        {"dump", & command_dump, (float )0.0}, 
        {"dumpbelow", & command_dumpbelow, (float )0.0}, 
        {"dumpfriendlyobjects", & command_dumpfriendlyobjects, (float )0.0}, 
        {"dumpallarchetypes", & command_dumpallarchetypes, (float )0.0}, 
        {"dumpallmaps", & command_dumpallmaps, (float )0.0}, 
        {"dumpallobjects", & command_dumpallobjects, (float )0.0}, 
        {"dumpmap", & command_dumpmap, (float )0.0}, 
        {"follow", & command_follow, (float )0.0}, 
        {"forget_spell", & command_forget_spell, (float )0.0}, 
        {"free", & command_free, (float )0.0}, 
        {"freeze", & command_freeze, (float )0.0}, 
        {"goto", & command_goto, (float )0.0}, 
        {"hide", & command_hide, (float )0.0}, 
        {"insert_into", & command_insert_into, (float )0.0}, 
        {"invisible", & command_invisible, (float )0.0}, 
        {"kick", & command_kick, (float )0.0}, 
        {"learn_special_prayer", & command_learn_special_prayer, (float )0.0}, 
        {"learn_spell", & command_learn_spell, (float )0.0}, 
        {"malloc", & command_malloc, (float )0.0}, 
        {"nodm", & command_nowiz, (float )0.0}, 
        {"nowiz", & command_nowiz, (float )0.0}, 
        {"patch", & command_patch, (float )0.0}, 
        {"players", & command_players, (float )0.0}, 
        {"plugin", & command_loadplugin, (float )0.0}, 
        {"pluglist", & command_listplugins, (float )0.0}, 
        {"plugout", & command_unloadplugin, (float )0.0}, 
        {"purge_quest_state", & command_purge_quest, (float )0.0}, 
        {"purge_quests", & command_purge_quest_definitions, (float )0.0}, 
        {"remove", & command_remove, (float )0.0}, 
        {"reset", & command_reset, (float )0.0}, 
        {"set_god", & command_setgod, (float )0.0}, 
        {"server_speed", & command_speed, (float )0.0}, 
        {"shutdown", & command_shutdown, (float )0.0}, 
        {"ssdumptable", & command_ssdumptable, (float )0.0}, 
        {"stack_clear", & command_stack_clear, (float )0.0}, 
        {"stack_list", & command_stack_list, (float )0.0}, 
        {"stack_pop", & command_stack_pop, (float )0.0}, 
        {"stack_push", & command_stack_push, (float )0.0}, 
        {"stats", & command_stats, (float )0.0}, 
        {"strings", & command_strings, (float )0.0}, 
        {"style_info", & command_style_map_info, (float )0.0}, 
        {"summon", & command_summon, (float )0.0}, 
        {"teleport", & command_teleport, (float )0.0}, 
        {"toggle_shout", & command_toggle_shout, (float )0.0}, 
        {"wizpass", & command_wizpass, (float )0.0}, 
        {"wizcast", & command_wizcast, (float )0.0}, 
        {"overlay_save", & command_overlay_save, (float )0.0}, 
        {"overlay_reset", & command_overlay_reset, (float )0.0}, 
        {"mon_aggr", & command_mon_aggr, (float )0.0}, 
        {"loadtest", & command_loadtest, (float )0.0}};
#line 277 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/commands.c"
int const   WizCommandsSize  =    (int const   )(sizeof(WizCommands) / sizeof(command_array_struct ));
#line 291 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/commands.c"
static int compare_A(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 292
  tmp = strcmp((char const   *)((command_array_struct const   *)a)->name, (char const   *)((command_array_struct const   *)b)->name);
  }
#line 292
  return (tmp);
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/commands.c"
void init_commands(void) 
{ 


  {
  {
#line 299
  qsort((void *)(Commands), (size_t )CommandsSize, sizeof(command_array_struct ),
        & compare_A);
#line 300
  qsort((void *)(CommunicationCommands), (size_t )CommunicationCommandSize, sizeof(command_array_struct ),
        & compare_A);
#line 301
  qsort((void *)(WizCommands), (size_t )WizCommandsSize, sizeof(command_array_struct ),
        & compare_A);
  }
#line 302
  return;
}
}
#line 222 "../include/libproto.h"
extern void register_apply(int ob_type , method_ret (*method)(ob_methods * , object * ,
                                                              object * , int  ) ) ;
#line 302
extern object *object_find_by_type_and_arch_name(object const   *who , int type ,
                                                 char const   *name ) ;
#line 329
extern int is_dragon_pl(object const   *op ) ;
#line 32 "../include/typesproto.h"
void init_type_dragon_focus(void) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/types/dragon_focus/dragon_focus.c"
static method_ret dragon_focus_type_apply(ob_methods *context , object *focus , object *applier ,
                                          int aflags ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/types/dragon_focus/dragon_focus.c"
void init_type_dragon_focus(void) 
{ 


  {
  {
#line 40
  register_apply(10, & dragon_focus_type_apply);
  }
#line 41
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/types/dragon_focus/dragon_focus.c"
static method_ret dragon_focus_type_apply(ob_methods *context , object *focus , object *applier ,
                                          int aflags ) 
{ 
  object *abil ;
  int tmp ;

  {
#line 54
  abil = (object *)((void *)0);
#line 56
  if ((int )applier->type != 1) {
#line 57
    return ((method_ret )2);
  }
  {
#line 59
  tmp = is_dragon_pl((object const   *)applier);
  }
#line 59
  if (! tmp) {
#line 60
    return ((method_ret )2);
  }
  {
#line 62
  abil = object_find_by_type_and_arch_name((object const   *)applier, 114, "dragon_ability_force");
  }
#line 64
  if ((unsigned long )abil == (unsigned long )((void *)0)) {
#line 65
    return ((method_ret )2);
  }
#line 67
  abil->stats.exp = focus->stats.exp;
#line 69
  if (focus->face) {
#line 70
    applier->face = focus->face;
#line 75
    if (focus->animation_id) {
#line 76
      applier->animation_id = focus->animation_id;
    }
  }
#line 78
  if (focus->title) {
#line 79
    if (applier->title) {
      {
#line 79
      free_string(applier->title);
      }
    }
    {
#line 80
    applier->title = add_refcount(focus->title);
    }
  }
#line 82
  return ((method_ret )0);
}
}
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 194 "../include/global.h"
mapstruct *first_map ;
#line 194 "../include/libproto.h"
extern mapstruct *load_original_map(char const   *filename , int flags ) ;
#line 198
extern void delete_map(mapstruct *m ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 69 "./../random_maps/rproto.h"
int load_dir(char const   *dir , char ***namelist , int skip_dirs ) ;
#line 70
mapstruct *load_style_map(char *style_name ) ;
#line 71
mapstruct *find_style(char const   *dirname , char const   *stylename , int difficulty ) ;
#line 72
object *pick_random_object(mapstruct *style ) ;
#line 73
void free_style_maps(void) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/style.c"
static int pointer_strcmp(void const   *p1 , void const   *p2 ) 
{ 
  char const   *s1 ;
  char const   *s2 ;
  int tmp ;

  {
  {
#line 54
  s1 = (char const   *)*((char const   * const  *)p1);
#line 55
  s2 = (char const   *)*((char const   * const  *)p2);
#line 57
  tmp = strcmp(s1, s2);
  }
#line 57
  return (tmp);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/style.c"
int load_dir(char const   *dir , char ***namelist , int skip_dirs ) 
{ 
  DIR *dp ;
  struct dirent *d ;
  int entries ;
  int entry_size ;
  char name[256] ;
  char **rn ;
  struct stat sb ;
  void *tmp ;

  {
  {
#line 86
  entries = 0;
#line 86
  entry_size = 0;
#line 87
  rn = (char **)((void *)0);
#line 90
  dp = opendir(dir);
  }
#line 91
  if ((unsigned long )dp == (unsigned long )((void *)0)) {
#line 92
    return (-1);
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 94
    d = readdir(dp);
    }
#line 94
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 94
      goto while_break;
    }
#line 95
    if (skip_dirs) {
      {
#line 96
      snprintf((char */* __restrict  */)(name), sizeof(name), (char const   */* __restrict  */)"%s/%s",
               dir, d->d_name);
#line 97
      stat((char const   */* __restrict  */)(name), (struct stat */* __restrict  */)(& sb));
      }
#line 98
      if ((sb.st_mode & 61440U) == 16384U) {
#line 99
        goto while_continue;
      }
    }
#line 103
    if (entries == entry_size) {
      {
#line 104
      entry_size += 10;
#line 105
      tmp = realloc((void *)rn, sizeof(char *) * (unsigned long )entry_size);
#line 105
      rn = (char **)tmp;
      }
    }
    {
#line 107
    *(rn + entries) = strdup_local((char const   *)(d->d_name));
#line 108
    entries ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 110
  closedir(dp);
  }
#line 116
  if ((unsigned long )rn == (unsigned long )((void *)0)) {
#line 117
    return (0);
  }
  {
#line 119
  qsort((void *)rn, (size_t )entries, sizeof(char *), & pointer_strcmp);
#line 121
  *namelist = rn;
  }
#line 122
  return (entries);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/style.c"
mapstruct *styles  =    (mapstruct *)((void *)0);
#line 137 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/style.c"
mapstruct *load_style_map(char *style_name ) 
{ 
  mapstruct *style_map ;
  int tmp ;
  mapstruct *tmp___0 ;

  {
#line 141
  style_map = styles;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! ((unsigned long )style_map != (unsigned long )((void *)0))) {
#line 141
      goto while_break;
    }
    {
#line 142
    tmp = strcmp((char const   *)style_name, (char const   *)(style_map->path));
    }
#line 142
    if (! tmp) {
#line 143
      return (style_map);
    }
#line 141
    style_map = style_map->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 145
  style_map = load_original_map((char const   *)style_name, 8);
  }
#line 147
  if (style_map) {
#line 150
    if ((unsigned long )style_map == (unsigned long )first_map) {
#line 151
      first_map = style_map->next;
    } else {
#line 153
      tmp___0 = first_map;
      {
#line 153
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 153
        if (tmp___0) {
#line 153
          if (! ((unsigned long )tmp___0->next != (unsigned long )style_map)) {
#line 153
            goto while_break___0;
          }
        } else {
#line 153
          goto while_break___0;
        }
#line 153
        tmp___0 = tmp___0->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 155
      if (tmp___0) {
#line 156
        tmp___0->next = style_map->next;
      }
    }
#line 158
    style_map->next = styles;
#line 159
    styles = style_map;
  }
#line 161
  return (style_map);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/style.c"
mapstruct *find_style(char const   *dirname , char const   *stylename , int difficulty ) 
{ 
  char style_file_path[256] ;
  char style_file_full_path[256] ;
  mapstruct *style_map ;
  struct stat file_stat ;
  int i ;
  int only_subdirs ;
  size_t tmp ;
  int tmp___0 ;
  char **namelist ;
  int n ;
  char style_dir_full_path[256] ;
  char *p ;
  long tmp___1 ;
  int min_dist ;
  int min_index ;
  char *p___0 ;
  int dist ;
  char *mfile_name ;
  char *tmp___2 ;
  int q ;
  long tmp___3 ;
  int tmp___4 ;

  {
#line 186
  style_map = (mapstruct *)((void *)0);
#line 188
  only_subdirs = 0;
#line 191
  if (stylename) {
    {
#line 191
    tmp = strlen(stylename);
    }
#line 191
    if (tmp > 0UL) {
      {
#line 192
      snprintf((char */* __restrict  */)(style_file_path), sizeof(style_file_path),
               (char const   */* __restrict  */)"%s/%s", dirname, stylename);
      }
    } else {
      {
#line 194
      snprintf((char */* __restrict  */)(style_file_path), sizeof(style_file_path),
               (char const   */* __restrict  */)"%s", dirname);
      }
    }
  } else {
    {
#line 194
    snprintf((char */* __restrict  */)(style_file_path), sizeof(style_file_path),
             (char const   */* __restrict  */)"%s", dirname);
    }
  }
  {
#line 197
  snprintf((char */* __restrict  */)(style_file_full_path), sizeof(style_file_full_path),
           (char const   */* __restrict  */)"%s/maps%s", settings.datadir, style_file_path);
#line 198
  tmp___0 = stat((char const   */* __restrict  */)(style_file_full_path), (struct stat */* __restrict  */)(& file_stat));
  }
#line 198
  if (tmp___0 == 0) {
#line 198
    if (! ((file_stat.st_mode & 61440U) == 16384U)) {
      {
#line 200
      style_map = load_style_map(style_file_path);
      }
    }
  }
#line 202
  if ((unsigned long )style_map == (unsigned long )((void *)0)) {
    {
#line 208
    snprintf((char */* __restrict  */)(style_dir_full_path), sizeof(style_dir_full_path),
             (char const   */* __restrict  */)"%s/maps%s", settings.datadir, style_file_path);
#line 213
    n = load_dir((char const   *)(style_dir_full_path), & namelist, 1);
    }
#line 214
    if (n <= 0) {
      {
#line 215
      n = load_dir((char const   *)(style_dir_full_path), & namelist, 0);
#line 216
      only_subdirs = 1;
      }
    }
#line 219
    if (n <= 0) {
#line 220
      return ((mapstruct *)((void *)0));
    }
#line 227
    if (difficulty == -1) {
#line 228
      if (only_subdirs) {
#line 229
        style_map = (mapstruct *)((void *)0);
      } else {
        {
#line 233
        p = strchr((char const   *)(style_file_path), '\000');
#line 234
        tmp___1 = random();
#line 234
        snprintf((char */* __restrict  */)p, (size_t )((style_file_path + sizeof(style_file_path)) - p),
                 (char const   */* __restrict  */)"/%s", *(namelist + tmp___1 % (long )n));
#line 235
        style_map = load_style_map(style_file_path);
        }
      }
    } else {
#line 238
      min_dist = 32000;
#line 238
      min_index = -1;
#line 241
      i = 0;
      {
#line 241
      while (1) {
        while_continue: /* CIL Label */ ;
#line 241
        if (! (i < n)) {
#line 241
          goto while_break;
        }
        {
#line 243
        tmp___2 = strrchr((char const   *)*(namelist + i), '_');
#line 243
        mfile_name = tmp___2 + 1;
        }
#line 245
        if ((unsigned long )(mfile_name - 1) == (unsigned long )((void *)0)) {
          {
#line 249
          tmp___3 = random();
#line 249
          style_map = find_style((char const   *)(style_file_path), (char const   *)*(namelist + tmp___3 % (long )n),
                                 difficulty);
#line 250
          q = 0;
          }
          {
#line 250
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 250
            if (! (q < n)) {
#line 250
              goto while_break___0;
            }
            {
#line 251
            free((void *)*(namelist + q));
#line 250
            q ++;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 252
          free((void *)namelist);
          }
#line 253
          return (style_map);
        } else {
          {
#line 255
          tmp___4 = atoi((char const   *)mfile_name);
#line 255
          dist = abs(difficulty - tmp___4);
          }
#line 256
          if (dist < min_dist) {
#line 257
            min_dist = dist;
#line 258
            min_index = i;
          }
        }
#line 241
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 264
      p___0 = strchr((char const   *)(style_file_path), '\000');
#line 265
      snprintf((char */* __restrict  */)p___0, (size_t )((style_file_path + sizeof(style_file_path)) - p___0),
               (char const   */* __restrict  */)"/%s", *(namelist + min_index));
#line 266
      style_map = load_style_map(style_file_path);
      }
    }
#line 268
    i = 0;
    {
#line 268
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 268
      if (! (i < n)) {
#line 268
        goto while_break___1;
      }
      {
#line 269
      free((void *)*(namelist + i));
#line 268
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 270
    free((void *)namelist);
    }
  }
#line 272
  return (style_map);
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/style.c"
object *pick_random_object(mapstruct *style ) 
{ 
  int x ;
  int y ;
  int limit ;
  object *new_obj ;
  long tmp ;
  long tmp___0 ;
  struct obj *tmp___1 ;

  {
#line 285
  limit = 0;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 295
    limit ++;
#line 296
    tmp = random();
#line 296
    x = (int )(tmp % (long )style->width);
#line 297
    tmp___0 = random();
#line 297
    y = (int )(tmp___0 % (long )style->height);
#line 298
    new_obj = (style->spaces + (x + (int )style->width * y))->bottom;
    }
#line 294
    if ((unsigned long )new_obj == (unsigned long )((void *)0)) {
#line 294
      if (! (limit < 1000)) {
#line 294
        goto while_break;
      }
    } else {
#line 294
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 300
  if ((unsigned long )new_obj->head != (unsigned long )((void *)0)) {
#line 300
    tmp___1 = new_obj->head;
  } else {
#line 300
    tmp___1 = new_obj;
  }
#line 300
  return (tmp___1);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/style.c"
void free_style_maps(void) 
{ 
  mapstruct *next ;
  int style_maps ;

  {
#line 308
  style_maps = 0;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! styles) {
#line 313
      goto while_break;
    }
    {
#line 314
    next = styles->next;
#line 315
    delete_map(styles);
#line 316
    styles = next;
#line 317
    style_maps ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 319
  LOG((LogLevel )2, "free_style_maps: Freed %d maps\n", style_maps);
  }
#line 320
  return;
}
}
#line 265 "../include/libproto.h"
extern object *object_decrease_nrof(object *op , uint32 i ) ;
#line 118 "../include/sockproto.h"
extern void play_sound_player_only(player *pl , sint8 sound_type , object *emitter ,
                                   int dir , char const   *action ) ;
#line 64 "../include/typesproto.h"
void init_type_poison(void) ;
#line 29 "../include/sproto.h"
void apply_handle_yield(object *tmp ) ;
#line 51
int hit_player(object *op , int dam , object *hitter , uint32 type , int full_hit ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/types/poison/poison.c"
static method_ret poison_type_apply(ob_methods *context , object *op , object *applier ,
                                    int aflags ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/types/poison/poison.c"
void init_type_poison(void) 
{ 


  {
  {
#line 39
  register_apply(7, & poison_type_apply);
  }
#line 40
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/types/poison/poison.c"
static method_ret poison_type_apply(ob_methods *context , object *op , object *applier ,
                                    int aflags ) 
{ 


  {
#line 52
  if ((int )applier->type == 1) {
    {
#line 53
    play_sound_player_only(applier->contr, (sint8 )3, op, 0, "poison");
#line 54
    draw_ext_info(256, 0, (object const   *)applier, (uint8 )13, (uint8 )5, "Yech!  That tasted poisonous!");
#line 56
    snprintf((char */* __restrict  */)((applier->contr)->killer), (size_t )32, (char const   */* __restrict  */)"poisonous %s",
             op->name);
    }
  }
#line 59
  if ((int )op->stats.hp > 0) {
    {
#line 60
    LOG((LogLevel )2, "Trying to poison player/monster for %d hp\n", (int )op->stats.hp);
#line 61
    hit_player(applier, (int )op->stats.hp, op, (uint32 )1024, 1);
    }
  }
  {
#line 64
  applier->stats.food -= applier->stats.food / 4;
#line 65
  apply_handle_yield(op);
#line 66
  object_decrease_nrof(op, (uint32 )1);
  }
#line 67
  return ((method_ret )0);
}
}
#line 755 "/usr/include/stdlib.h"
extern void *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                            void const   *__base ,
                                                            size_t __nmemb , size_t __size ,
                                                            int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 194 "../include/sproto.h"
void execute_newserver_command(object *pl , char *command ) ;
#line 449
extern command_array_struct *find_plugin_command(char const   *cmd , command_array_struct *command ) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_new.c"
static int compare_A___0(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 59
  tmp = strcmp((char const   *)((command_array_struct const   *)a)->name, (char const   *)((command_array_struct const   *)b)->name);
  }
#line 59
  return (tmp);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_new.c"
static command_array_struct *find_command_element(char const   *cmd , command_array_struct *commarray ,
                                                  int commsize ) 
{ 
  command_array_struct *asp ;
  command_array_struct dummy ;
  void *tmp ;

  {
  {
#line 78
  dummy.name = cmd;
#line 79
  tmp = bsearch((void const   *)((void *)(& dummy)), (void const   *)((void *)commarray),
                (size_t )commsize, sizeof(command_array_struct ), & compare_A___0);
#line 79
  asp = (command_array_struct *)tmp;
  }
#line 83
  return (asp);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_new.c"
void execute_newserver_command(object *pl , char *command ) 
{ 
  command_array_struct *csp ;
  command_array_struct sent ;
  char *cp ;
  char *low ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 100
  (pl->contr)->has_hit = (uint32 )0;
#line 105
  tmp = strlen((char const   *)command);
#line 105
  cp = (command + tmp) - 1;
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if ((unsigned long )cp >= (unsigned long )command) {
#line 106
      if (! ((int )*cp == 32)) {
#line 106
        goto while_break;
      }
    } else {
#line 106
      goto while_break;
    }
#line 107
    *cp = (char )'\000';
#line 108
    cp --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 110
  cp = strchr((char const   *)command, ' ');
  }
#line 111
  if (cp) {
#line 112
    tmp___0 = cp;
#line 112
    cp ++;
#line 112
    *tmp___0 = (char )'\000';
    {
#line 113
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 113
      if (! ((int )*cp == 32)) {
#line 113
        goto while_break___0;
      }
#line 114
      cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 116
    cp = strchr((char const   *)command, '\000');
    }
  }
#line 119
  low = command;
  {
#line 119
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 119
    if (! *low) {
#line 119
      goto while_break___1;
    }
#line 120
    if ((int )*low >= 65) {
#line 120
      if ((int )*low <= 90) {
#line 120
        *low = (char )(((int )*low - 65) + 97);
      } else {
#line 120
        *low = *low;
      }
    } else {
#line 120
      *low = *low;
    }
#line 119
    low ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 122
  csp = find_plugin_command((char const   *)command, & sent);
  }
#line 123
  if (! csp) {
    {
#line 124
    csp = find_command_element((char const   *)command, Commands, (int )CommandsSize);
    }
  }
#line 125
  if (! csp) {
    {
#line 126
    csp = find_command_element((char const   *)command, CommunicationCommands, (int )CommunicationCommandSize);
    }
  }
#line 128
  if (! csp) {
#line 128
    if (pl->flags[0] & (1U << 1)) {
      {
#line 129
      csp = find_command_element((char const   *)command, WizCommands, (int )WizCommandsSize);
      }
    }
  }
#line 131
  if ((unsigned long )csp == (unsigned long )((void *)0)) {
    {
#line 132
    draw_ext_info_format(256, 0, (object const   *)pl, (uint8 )10, (uint8 )11, "\'%s\' is not a valid command.",
                         command);
    }
#line 136
    return;
  }
#line 139
  pl->speed_left -= csp->time;
#line 151
  if (csp->time) {
#line 151
    if ((double )pl->speed_left < - 2.0) {
      {
#line 152
      LOG((LogLevel )2, "execute_newclient_command: Player issued command that takes more time than he has left.\n");
      }
    }
  }
  {
#line 154
  (*(csp->func))(pl, (char const   *)cp);
  }
#line 155
  return;
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_new.c"
void command_run(object *op , char const   *params ) 
{ 
  int dir ;

  {
  {
#line 168
  dir = atoi(params);
  }
#line 169
  if (dir < 0) {
    {
#line 170
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Can\'t run into a non adjacent square.");
    }
#line 172
    return;
  } else
#line 169
  if (dir >= 9) {
    {
#line 170
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Can\'t run into a non adjacent square.");
    }
#line 172
    return;
  }
  {
#line 174
  (op->contr)->run_on = (uint32 )1;
#line 175
  move_player(op, dir);
  }
#line 176
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_new.c"
void command_run_stop(object *op , char const   *params ) 
{ 


  {
#line 189
  (op->contr)->run_on = (uint32 )0;
#line 190
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_new.c"
void command_fire(object *op , char const   *params ) 
{ 
  int dir ;

  {
  {
#line 203
  dir = atoi(params);
  }
#line 204
  if (dir < 0) {
    {
#line 205
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Can\'t fire to a non adjacent square.");
    }
#line 207
    return;
  } else
#line 204
  if (dir >= 9) {
    {
#line 205
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Can\'t fire to a non adjacent square.");
    }
#line 207
    return;
  }
  {
#line 209
  (op->contr)->fire_on = (uint32 )1;
#line 210
  move_player(op, dir);
  }
#line 211
  return;
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_new.c"
void command_fire_stop(object *op , char const   *params ) 
{ 


  {
#line 222
  (op->contr)->fire_on = (uint32 )0;
#line 223
  return;
}
}
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 150 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 264 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 266 "../include/global.h"
extern uint32 max_time ;
#line 61 "../include/stringbuffer.h"
StringBuffer *stringbuffer_new(void) ;
#line 78
char *stringbuffer_finish(StringBuffer *sb ) ;
#line 9 "../include/libproto.h"
archetype *find_archetype_by_object_name(char const   *name ) ;
#line 27
archetype *try_find_archetype(char const   *name ) ;
#line 29
object *object_create_arch(archetype *at ) ;
#line 110
void query_name(object const   *op , char *buf , size_t size ) ;
#line 115
int need_identify(object const   *op ) ;
#line 116
void object_give_identified_properties(object *op ) ;
#line 144
void fix_object(object *op ) ;
#line 148
void player_lvl_adj(object *who , object *op ) ;
#line 150
void calc_perm_exp(object *op ) ;
#line 152
sint64 check_exp_adjust(object const   *op , sint64 exp ) ;
#line 181
extern mapstruct *has_been_loaded(char const   *name ) ;
#line 183
extern void create_overlay_pathname(char const   *name , char *buf , size_t size ) ;
#line 195
extern int save_map(mapstruct *m , int flag ) ;
#line 206
extern int out_of_map(mapstruct *m , int x , int y ) ;
#line 212
extern void map_remove_unique_files(mapstruct const   *map ) ;
#line 232
extern void object_dump(object const   *op , StringBuffer *sb ) ;
#line 234
extern object *object_find_by_tag_global(tag_t i ) ;
#line 235
extern object *object_find_by_name_global(char const   *str ) ;
#line 241
extern void object_set_enemy(object *op , object *enemy ) ;
#line 251
extern void object_update(object *op , int action ) ;
#line 253
extern void object_free2(object *ob , int flags ) ;
#line 260
extern object *object_insert_in_map_at(object *op , mapstruct *m , object *originator ,
                                       int flag , int x , int y ) ;
#line 279
extern int object_find_free_spot(object const   *ob , mapstruct *m , int x , int y ,
                                 int start , int stop ) ;
#line 315
extern char *path_combine_and_normalize(char const   *src , char const   *dst , char *path ,
                                        size_t size ) ;
#line 372
extern object *get_jail_exit(object *op ) ;
#line 399
extern void reset_sleep(void) ;
#line 402
extern void set_max_time(long t ) ;
#line 410
extern void create_treasure(treasurelist *t , object *op , int flag , int difficulty ,
                            int tries ) ;
#line 454
extern int set_variable(object *op , char const   *buf ) ;
#line 457
extern void get_ob_diff(StringBuffer *sb , object const   *op , object const   *op2 ) ;
#line 28 "../include/sockproto.h"
extern void esrv_send_inventory(object *pl , object *op ) ;
#line 29
void esrv_update_item(int flags , object *pl , object *op ) ;
#line 88
extern void esrv_new_player(player *pl , uint32 weight ) ;
#line 32 "../include/sproto.h"
void do_learn_spell(object *op , object *spell , int special_prayer ) ;
#line 33
void do_forget_spell(object *op , char const   *spell ) ;
#line 220
void inventory(object *op , object *inv ) ;
#line 252
int player_arrest(object *who ) ;
#line 261
void command_possess(object *op , char const   *params ) ;
#line 303
extern void hiscore_check(object *op , int quiet ) ;
#line 306
extern object const   *find_god(char const   *name ) ;
#line 309
extern int become_follower(object *op , object const   *new_god ) ;
#line 332
extern int save_player(object *op , int flag ) ;
#line 340
extern void monster_check_apply_all(object *monster ) ;
#line 392
extern player *find_player_partial_name(char const   *plname ) ;
#line 406
extern void play_again(object *op ) ;
#line 426
extern void do_some_living(object *op ) ;
#line 445
int execute_global_event(int eventcode  , ...) ;
#line 446
extern int plugins_init_plugin(char const   *libfile ) ;
#line 447
extern int plugins_remove_plugin(char const   *id ) ;
#line 448
extern void plugins_display_list(object *op ) ;
#line 459
void free_quest(void) ;
#line 460
void free_quest_definitions(void) ;
#line 507
extern object *find_skill_by_name(object *who , char const   *name ) ;
#line 514
extern void show_skills(object *op , char const   *search ) ;
#line 576
extern object *check_spell_known(object *op , char const   *name ) ;
#line 577
extern object *lookup_spell_by_name(object *op , char const   *spname ) ;
#line 596
extern int swap_map(mapstruct *map ) ;
#line 600
extern void flush_old_maps(void) ;
#line 632
extern void enter_exit(object *op , object *exit_ob ) ;
#line 635
extern void cleanup(void) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
static player *get_other_player_from_name(object *op , char const   *name ) 
{ 
  player *pl ;
  int tmp ;

  {
#line 70
  if (! name) {
#line 71
    return ((player *)((void *)0));
  }
#line 73
  pl = first_player;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! ((unsigned long )pl != (unsigned long )((void *)0))) {
#line 73
      goto while_break;
    }
    {
#line 74
    tmp = strncmp((pl->ob)->name, name, (size_t )48);
    }
#line 74
    if (! tmp) {
#line 75
      goto while_break;
    }
#line 73
    pl = pl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  if ((unsigned long )pl == (unsigned long )((void *)0)) {
    {
#line 78
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "No such player.");
    }
#line 80
    return ((player *)((void *)0));
  }
#line 83
  if ((unsigned long )pl->ob == (unsigned long )op) {
    {
#line 84
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You can\'t do that to yourself.");
    }
#line 86
    return ((player *)((void *)0));
  }
#line 88
  if ((int )pl->state != 0) {
    {
#line 89
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "That player is in no state for that right now.");
    }
#line 91
    return ((player *)((void *)0));
  }
#line 93
  return (pl);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
static void dm_stack_pop(player *pl ) 
{ 


  {
#line 103
  if (! pl->stack_items) {
    {
#line 104
    draw_ext_info(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )11, "Empty stack!");
    }
#line 106
    return;
  } else
#line 103
  if (! pl->stack_position) {
    {
#line 104
    draw_ext_info(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )11, "Empty stack!");
    }
#line 106
    return;
  }
  {
#line 109
  (pl->stack_position) --;
#line 110
  draw_ext_info_format(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )17, "Popped item from stack, %d left.",
                       pl->stack_position);
  }
#line 113
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
static object *dm_stack_peek(player *pl ) 
{ 
  object *ob ;

  {
#line 130
  if (! pl->stack_position) {
    {
#line 131
    draw_ext_info(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )11, "Empty stack!");
    }
#line 133
    return ((object *)((void *)0));
  }
  {
#line 136
  ob = object_find_by_tag_global(*(pl->stack_items + (pl->stack_position - 1)));
  }
#line 137
  if (! ob) {
    {
#line 138
    draw_ext_info(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )17, "Stacked item was removed!");
#line 140
    dm_stack_pop(pl);
    }
#line 141
    return ((object *)((void *)0));
  }
#line 144
  return (ob);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
static void dm_stack_push(player *pl , tag_t item ) 
{ 
  void *tmp ;

  {
#line 158
  if (! pl->stack_items) {
    {
#line 159
    tmp = malloc(sizeof(tag_t ) * 50UL);
#line 159
    pl->stack_items = (tag_t *)tmp;
#line 160
    memset((void *)pl->stack_items, 0, sizeof(tag_t ) * 50UL);
    }
  }
#line 163
  if (pl->stack_position == 50) {
    {
#line 164
    draw_ext_info(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )11, "Item stack full!");
    }
#line 166
    return;
  }
  {
#line 169
  *(pl->stack_items + pl->stack_position) = item;
#line 170
  draw_ext_info_format(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )17, "Item stacked as %d.",
                       pl->stack_position);
#line 173
  (pl->stack_position) ++;
  }
#line 174
  return;
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
static object *get_dm_object(player *pl , char const   **params , int *from ) 
{ 
  int item_tag ;
  int item_position ;
  object *ob ;
  object *tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  object *tmp___5 ;

  {
#line 207
  if (! pl) {
#line 208
    return ((object *)((void *)0));
  }
#line 210
  if ((int const   )*(*params) == 0) {
#line 211
    if (from) {
#line 212
      *from = 1;
    }
    {
#line 214
    tmp = dm_stack_peek(pl);
    }
#line 214
    return (tmp);
  }
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! ((int const   )*(*params) == 32)) {
#line 218
      goto while_break;
    }
#line 219
    (*params) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 222
  tmp___1 = sscanf((char const   */* __restrict  */)*params, (char const   */* __restrict  */)"%d",
                   & item_tag);
  }
#line 222
  if (tmp___1) {
    {
#line 224
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 224
      tmp___0 = __ctype_b_loc();
      }
#line 224
      if (! ((int const   )*(*tmp___0 + (int )*(*params)) & 2048)) {
#line 224
        goto while_break___0;
      }
#line 225
      (*params) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 228
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 228
      if (! ((int const   )*(*params) == 32)) {
#line 228
        goto while_break___1;
      }
#line 229
      (*params) ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 232
    ob = object_find_by_tag_global((tag_t )item_tag);
    }
#line 233
    if (! ob) {
#line 234
      if (from) {
#line 235
        *from = 0;
      }
      {
#line 236
      draw_ext_info_format(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )11,
                           "No such item %d!", item_tag);
      }
#line 239
      return ((object *)((void *)0));
    }
    {
#line 243
    dm_stack_push(pl, (tag_t )item_tag);
    }
#line 244
    if (from) {
#line 245
      *from = 3;
    }
#line 246
    return (ob);
  }
  {
#line 250
  tmp___3 = sscanf((char const   */* __restrict  */)*params, (char const   */* __restrict  */)"$%d",
                   & item_position);
  }
#line 250
  if (tmp___3) {
#line 252
    (*params) ++;
    {
#line 254
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 254
      tmp___2 = __ctype_b_loc();
      }
#line 254
      if (! ((int const   )*(*tmp___2 + (int )*(*params)) & 2048)) {
#line 254
        goto while_break___2;
      }
#line 255
      (*params) ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 256
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 256
      if (! ((int const   )*(*params) == 32)) {
#line 256
        goto while_break___3;
      }
#line 257
      (*params) ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 259
    if (item_position >= pl->stack_position) {
#line 260
      if (from) {
#line 261
        *from = 0;
      }
      {
#line 262
      draw_ext_info_format(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )11,
                           "No such stack item %d!", item_position);
      }
#line 265
      return ((object *)((void *)0));
    }
    {
#line 268
    ob = object_find_by_tag_global(*(pl->stack_items + item_position));
    }
#line 269
    if (! ob) {
#line 270
      if (from) {
#line 271
        *from = 0;
      }
      {
#line 272
      draw_ext_info_format(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )17,
                           "Stack item %d was removed.", item_position);
      }
#line 275
      return ((object *)((void *)0));
    }
#line 278
    if (from) {
#line 279
      if (item_position < pl->stack_position - 1) {
#line 279
        *from = 2;
      } else {
#line 279
        *from = 1;
      }
    }
#line 280
    return (ob);
  }
  {
#line 284
  tmp___4 = strncmp(*params, "me", (size_t )2);
  }
#line 284
  if (! tmp___4) {
#line 285
    if (from) {
#line 286
      *from = 3;
    }
    {
#line 287
    dm_stack_push(pl, (pl->ob)->count);
#line 290
    *params += 2;
    }
    {
#line 291
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 291
      if (! ((int const   )*(*params) == 32)) {
#line 291
        goto while_break___4;
      }
#line 292
      (*params) ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 294
    return (pl->ob);
  }
#line 298
  if (from) {
#line 299
    *from = 1;
  }
  {
#line 300
  tmp___5 = dm_stack_peek(pl);
  }
#line 300
  return (tmp___5);
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_loadtest(object *op , char const   *params ) 
{ 
  uint32 x ;
  uint32 y ;
  char buf[1024] ;
  int tmp ;

  {
  {
#line 317
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )10, "loadtest will stress server through teleporting at different map places. Use at your own risk.  Very long loop used so server may have to be reset. type loadtest TRUE to run");
#line 321
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )10, "{%s}",
                       params);
  }
#line 324
  if ((int const   )*params == 0) {
#line 325
    return;
  }
  {
#line 326
  tmp = strncmp(params, "TRUE", (size_t )4);
  }
#line 326
  if (tmp) {
#line 327
    return;
  }
  {
#line 329
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )10, "gogogo");
#line 332
  x = (uint32 )0;
  }
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    if (! (x < settings.worldmaptilesx)) {
#line 332
      goto while_break;
    }
#line 333
    y = (uint32 )0;
    {
#line 333
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 333
      if (! (y < settings.worldmaptilesy)) {
#line 333
        goto while_break___0;
      }
      {
#line 334
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"/world/world_%u_%u",
               x + settings.worldmapstartx, y + settings.worldmapstarty);
#line 335
      command_goto(op, (char const   *)(buf));
#line 333
      y ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 332
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 338
  return;
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
static void do_wizard_hide(object *op , int silent_dm ) 
{ 


  {
#line 349
  if ((op->contr)->hidden) {
    {
#line 350
    (op->contr)->hidden = (uint32 )0;
#line 351
    op->invisible = (sint16 )1;
#line 352
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "You are no longer hidden from other players");
#line 354
    (op->map)->players = (sint16 )((int )(op->map)->players + 1);
#line 355
    draw_ext_info_format(774, 5, (object const   *)((void *)0), (uint8 )8, (uint8 )3,
                         "%s has entered the game.", op->name);
    }
#line 359
    if (! silent_dm) {
      {
#line 360
      draw_ext_info(776, 1, (object const   *)((void *)0), (uint8 )8, (uint8 )4, "The Dungeon Master has arrived!");
      }
    }
  } else {
    {
#line 365
    (op->contr)->hidden = (uint32 )1;
#line 366
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "Other players will no longer see you.");
#line 368
    (op->map)->players = (sint16 )((int )(op->map)->players - 1);
    }
#line 369
    if (! silent_dm) {
      {
#line 370
      draw_ext_info(776, 1, (object const   *)((void *)0), (uint8 )8, (uint8 )4, "The Dungeon Master is gone..");
      }
    }
    {
#line 374
    draw_ext_info_format(774, 5, (object const   *)((void *)0), (uint8 )8, (uint8 )3,
                         "%s leaves the game.", op->name);
#line 378
    draw_ext_info_format(774, 5, (object const   *)((void *)0), (uint8 )8, (uint8 )3,
                         "%s left the game.", op->name);
    }
  }
#line 383
  return;
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_hide(object *op , char const   *params ) 
{ 


  {
  {
#line 394
  do_wizard_hide(op, 0);
  }
#line 395
  return;
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
static object *find_object_both(char const   *params ) 
{ 
  long tmp ;
  object *tmp___0 ;
  object *tmp___1 ;

  {
#line 407
  if ((int const   )*(params + 0) == 35) {
    {
#line 408
    tmp = atol(params + 1);
#line 408
    tmp___0 = object_find_by_tag_global((tag_t )tmp);
    }
#line 408
    return (tmp___0);
  } else {
    {
#line 410
    tmp___1 = object_find_by_name_global(params);
    }
#line 410
    return (tmp___1);
  }
}
}
#line 421 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_setgod(object *op , char const   *params ) 
{ 
  object *ob ;
  object const   *god ;
  char *str ;
  char *tmp ;

  {
#line 426
  if ((int const   )*params == 0) {
    {
#line 427
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Usage: setgod object god");
    }
#line 429
    return;
  } else {
    {
#line 426
    str = strchr(params, ' ');
    }
#line 426
    if (! str) {
      {
#line 427
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Usage: setgod object god");
      }
#line 429
      return;
    }
  }
  {
#line 433
  tmp = str;
#line 433
  str ++;
#line 433
  *tmp = (char )'\000';
#line 434
  ob = find_object_both(params);
  }
#line 434
  if (! ob) {
    {
#line 435
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Set whose god - can not find object %s?",
                         params);
    }
#line 438
    return;
  }
#line 445
  if ((int )ob->type != 1) {
    {
#line 446
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "%s is not a player - can not change its god",
                         ob->name);
    }
#line 449
    return;
  }
  {
#line 452
  god = find_god((char const   *)str);
  }
#line 453
  if ((unsigned long )god == (unsigned long )((void *)0)) {
    {
#line 454
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "No such god %s.",
                         str);
    }
#line 457
    return;
  }
  {
#line 460
  become_follower(ob, god);
  }
#line 461
  return;
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
static void command_kick2(object *op , char const   *params ) 
{ 
  struct pl *pl ;
  object *op___0 ;
  int removed ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 474
  pl = first_player;
  {
#line 474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 474
    if (! ((unsigned long )pl != (unsigned long )((void *)0))) {
#line 474
      goto while_break;
    }
#line 475
    if ((int const   )*params == 0) {
#line 475
      goto _L;
    } else {
      {
#line 475
      tmp___0 = strcmp((pl->ob)->name, params);
      }
#line 475
      if (! tmp___0) {
        _L: /* CIL Label */ 
#line 475
        if ((unsigned long )pl->ob != (unsigned long )op) {
#line 477
          removed = 0;
#line 479
          op___0 = pl->ob;
#line 480
          if (! (op___0->flags[0] & (1U << 2))) {
#line 482
            if ((int const   )*params == 0) {
#line 482
              tmp = (char const   *)((void *)0);
            } else {
#line 482
              tmp = params;
            }
            {
#line 482
            execute_global_event(28, op___0, tmp);
#line 483
            object_remove(op___0);
#line 484
            removed = 1;
            }
          }
          {
#line 486
          op___0->direction = (sint8 )0;
#line 487
          draw_ext_info_format(771, 5, (object const   *)op___0, (uint8 )8, (uint8 )4,
                               "%s is kicked out of the game.", op___0->name);
#line 490
          strcpy((char */* __restrict  */)((op___0->contr)->killer), (char const   */* __restrict  */)"left");
#line 491
          hiscore_check(op___0, 0);
          }
#line 498
          if (! removed) {
#line 498
            if (! (op___0->flags[0] & (1U << 3))) {
              {
#line 499
              save_player(op___0, 0);
              }
#line 500
              if (op___0->map) {
#line 501
                (op___0->map)->players = (sint16 )((int )(op___0->map)->players - 1);
              }
            }
          }
#line 504
          if (op___0->map) {
#line 505
            (op___0->map)->timeout = (op___0->map)->timeout;
          }
#line 507
          pl->socket.status = (enum Sock_Status )2;
        }
      }
    }
#line 474
    pl = pl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 510
  return;
}
}
#line 527 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_banish(object *op , char const   *params ) 
{ 
  player *pl ;
  FILE *banishfile ;
  char buf[256] ;
  time_t now ;
  char *tmp ;

  {
#line 533
  if ((int const   )*params == 0) {
    {
#line 534
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Usage: banish <player>.");
    }
#line 536
    return;
  }
  {
#line 539
  pl = get_other_player_from_name(op, params);
  }
#line 540
  if (! pl) {
#line 541
    return;
  }
  {
#line 543
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s/%s",
           settings.localdir, "banish_file");
#line 545
  banishfile = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"a");
  }
#line 545
  if ((unsigned long )banishfile == (unsigned long )((void *)0)) {
    {
#line 546
    LOG((LogLevel )2, "Could not find file banish_file.\n");
#line 547
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Could not find banish_file.");
    }
#line 549
    return;
  }
  {
#line 552
  now = time((time_t *)((void *)0));
#line 557
  tmp = ctime((time_t const   *)(& now));
#line 557
  fprintf((FILE */* __restrict  */)banishfile, (char const   */* __restrict  */)"# %s (%s) banned by %s at %s\n",
          (pl->ob)->name, pl->socket.host, op->name, tmp);
#line 558
  fprintf((FILE */* __restrict  */)banishfile, (char const   */* __restrict  */)"*@%s\n",
          pl->socket.host);
#line 559
  fclose(banishfile);
#line 561
  LOG((LogLevel )2, "! %s banned %s from IP: %s.\n", op->name, (pl->ob)->name, pl->socket.host);
#line 563
  draw_ext_info_format(259, 0, (object const   *)op, (uint8 )10, (uint8 )17, "You banish %s",
                       (pl->ob)->name);
#line 567
  draw_ext_info_format(771, 5, (object const   *)op, (uint8 )8, (uint8 )4, "%s banishes %s from the land!",
                       op->name, (pl->ob)->name);
#line 570
  command_kick2(op, (pl->ob)->name);
  }
#line 571
  return;
}
}
#line 581 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_kick(object *op , char const   *params ) 
{ 


  {
  {
#line 582
  command_kick2(op, params);
  }
#line 583
  return;
}
}
#line 593 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_overlay_save(object *op , char const   *params ) 
{ 
  int tmp ;

  {
#line 594
  if (! op) {
#line 595
    return;
  }
  {
#line 597
  tmp = save_map(op->map, 2);
  }
#line 597
  if (tmp < 0) {
    {
#line 598
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "Overlay save error!");
    }
  } else {
    {
#line 601
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "Current map has been saved as an overlay.");
    }
  }
#line 603
  return;
}
}
#line 613 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_overlay_reset(object *op , char const   *params ) 
{ 
  char filename[256] ;
  struct stat stats ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 617
  create_overlay_pathname((char const   *)((op->map)->path), filename, (size_t )256);
#line 618
  tmp___0 = stat((char const   */* __restrict  */)(filename), (struct stat */* __restrict  */)(& stats));
  }
#line 618
  if (tmp___0) {
    {
#line 626
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "No overlay for current map.");
    }
  } else {
    {
#line 619
    tmp = unlink((char const   *)(filename));
    }
#line 619
    if (tmp) {
      {
#line 623
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "Overlay couldn\'t be removed.");
      }
    } else {
      {
#line 620
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "Overlay successfully removed.");
      }
    }
  }
#line 628
  return;
}
}
#line 638 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_toggle_shout(object *op , char const   *params ) 
{ 
  player *pl ;

  {
#line 641
  if ((int const   )*params == 0) {
    {
#line 642
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Usage: toggle_shout <player>.");
    }
#line 644
    return;
  }
  {
#line 647
  pl = get_other_player_from_name(op, params);
  }
#line 648
  if (! pl) {
#line 649
    return;
  }
#line 651
  if (((pl->ob)->contr)->no_shout == 0U) {
    {
#line 652
    ((pl->ob)->contr)->no_shout = (uint32 )1;
#line 654
    draw_ext_info(259, 0, (object const   *)pl->ob, (uint8 )8, (uint8 )4, "You have been muzzled by the DM!");
#line 656
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "You muzzle %s.",
                         (pl->ob)->name);
#line 661
    execute_global_event(27, pl->ob, params);
    }
#line 663
    return;
  }
  {
#line 666
  ((pl->ob)->contr)->no_shout = (uint32 )0;
#line 667
  draw_ext_info(260, 0, (object const   *)pl->ob, (uint8 )8, (uint8 )4, "You are allowed to shout and chat again.");
#line 669
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "You remove %s\'s muzzle.",
                       (pl->ob)->name);
  }
#line 672
  return;
}
}
#line 682 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_shutdown(object *op , char const   *params ) 
{ 


  {
  {
#line 687
  command_kick2(op, "");
#line 688
  hiscore_check(op, 0);
#line 689
  save_player(op, 0);
#line 690
  play_again(op);
#line 691
  cleanup();
  }
#line 693
  return;
}
}
#line 703 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_goto(object *op , char const   *params ) 
{ 
  char const   *name ;
  object *dummy ;

  {
#line 707
  if (! op) {
#line 708
    return;
  }
#line 710
  if ((int const   )*params == 0) {
    {
#line 711
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Go to what level?");
    }
#line 713
    return;
  }
  {
#line 716
  name = params;
#line 717
  dummy = object_new();
#line 718
  dummy->map = op->map;
#line 719
  dummy->slaying = add_string(name);
#line 720
  dummy->stats.hp = (sint16 )-1;
#line 721
  dummy->stats.sp = (sint16 )-1;
#line 722
  dummy->name = add_string(name);
#line 724
  enter_exit(op, dummy);
#line 725
  object_free2(dummy, 2);
#line 726
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "Difficulty: %d.",
                       (int )(op->map)->difficulty);
  }
#line 729
  return;
}
}
#line 739 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_freeze(object *op , char const   *params ) 
{ 
  int ticks ;
  player *pl ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 743
  if ((int const   )*params == 0) {
    {
#line 744
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Usage: freeze [ticks] <player>.");
    }
#line 746
    return;
  }
  {
#line 749
  ticks = atoi(params);
  }
#line 750
  if (ticks) {
    {
#line 751
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 751
      tmp = __ctype_b_loc();
      }
#line 751
      if ((int const   )*(*tmp + (int )*params) & 2048) {
#line 751
        goto _L;
      } else {
        {
#line 751
        tmp___0 = __ctype_b_loc();
        }
#line 751
        if ((int const   )*(*tmp___0 + (int )*params) & 8192) {
          _L: /* CIL Label */ 
#line 751
          if (! ((int const   )*params != 0)) {
#line 751
            goto while_break;
          }
        } else {
#line 751
          goto while_break;
        }
      }
#line 752
      params ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 753
    if ((int const   )*params == 0) {
      {
#line 754
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Usage: freeze [ticks] <player>.");
      }
#line 756
      return;
    }
  } else {
#line 759
    ticks = 100;
  }
  {
#line 761
  pl = get_other_player_from_name(op, params);
  }
#line 762
  if (! pl) {
#line 763
    return;
  }
  {
#line 765
  draw_ext_info(259, 0, (object const   *)pl->ob, (uint8 )8, (uint8 )4, "You have been frozen by the DM!");
#line 768
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "You freeze %s for %d ticks",
                       (pl->ob)->name, ticks);
#line 772
  (pl->ob)->speed_left = - ((pl->ob)->speed * (float )ticks);
  }
#line 773
  return;
}
}
#line 783 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
int player_arrest(object *who ) 
{ 
  object *dummy ;
  mapstruct *cur ;
  int x ;
  int y ;

  {
#line 788
  if ((int )who->type != 1) {
#line 789
    return (-3);
  }
  {
#line 791
  dummy = get_jail_exit(who);
  }
#line 792
  if (! dummy) {
#line 793
    return (-1);
  }
  {
#line 795
  cur = who->map;
#line 796
  x = (int )who->x;
#line 797
  y = (int )who->y;
#line 798
  enter_exit(who, dummy);
#line 799
  object_free2(dummy, 2);
  }
#line 801
  if ((unsigned long )cur == (unsigned long )who->map) {
#line 801
    if (x == (int )who->x) {
#line 801
      if (y == (int )who->y) {
#line 802
        return (-2);
      }
    }
  }
#line 804
  return (0);
}
}
#line 815 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_arrest(object *op , char const   *params ) 
{ 
  player *pl ;
  int ret ;

  {
#line 819
  if (! op) {
#line 820
    return;
  }
#line 821
  if ((int const   )*params == 0) {
    {
#line 822
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Usage: arrest <player>.");
    }
#line 824
    return;
  }
  {
#line 826
  pl = get_other_player_from_name(op, params);
  }
#line 827
  if (! pl) {
#line 828
    return;
  }
  {
#line 830
  ret = player_arrest(pl->ob);
  }
#line 831
  if (ret == -1) {
    {
#line 833
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Can\'t jail player, there is no map to hold them");
    }
#line 835
    return;
  }
#line 837
  if (ret == -2) {
    {
#line 839
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Can\'t jail player, map loading issue or already in jail\'s position");
    }
#line 841
    return;
  }
  {
#line 845
  draw_ext_info(256, 0, (object const   *)pl->ob, (uint8 )8, (uint8 )4, "You have been arrested.");
#line 847
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "Jailed %s",
                       (pl->ob)->name);
#line 850
  LOG((LogLevel )1, "Player %s arrested by %s\n", (pl->ob)->name, op->name);
  }
#line 851
  return;
}
}
#line 860 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_summon(object *op , char const   *params ) 
{ 
  int i ;
  object *dummy ;
  player *pl ;

  {
#line 865
  if (! op) {
#line 866
    return;
  }
#line 868
  if ((int const   )*params == 0) {
    {
#line 869
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Usage: summon <player>.");
    }
#line 871
    return;
  }
  {
#line 874
  pl = get_other_player_from_name(op, params);
  }
#line 875
  if (! pl) {
#line 876
    return;
  }
  {
#line 878
  i = object_find_free_spot((object const   *)op, op->map, (int )op->x, (int )op->y,
                            1, 9);
  }
#line 879
  if (i == -1) {
    {
#line 880
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Can not find a free spot to place summoned player.");
    }
#line 882
    return;
  }
  {
#line 885
  dummy = object_new();
#line 886
  dummy->slaying = add_string((char const   *)((op->map)->path));
#line 887
  dummy->stats.hp = (sint16 )((int )op->x + (int )freearr_x[i]);
#line 888
  dummy->stats.sp = (sint16 )((int )op->y + (int )freearr_y[i]);
#line 889
  enter_exit(pl->ob, dummy);
#line 890
  object_free2(dummy, 2);
#line 891
  draw_ext_info(256, 0, (object const   *)pl->ob, (uint8 )8, (uint8 )4, "You are summoned.");
#line 893
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "You summon %s",
                       (pl->ob)->name);
  }
#line 896
  return;
}
}
#line 907 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_teleport(object *op , char const   *params ) 
{ 
  int i ;
  object *dummy ;
  player *pl ;

  {
#line 912
  if (! op) {
#line 913
    return;
  }
#line 915
  if ((int const   )*params == 0) {
    {
#line 916
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Usage: teleport <player>.");
    }
#line 918
    return;
  }
  {
#line 921
  pl = find_player_partial_name(params);
  }
#line 922
  if (! pl) {
    {
#line 923
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "No such player or ambiguous name.");
    }
#line 925
    return;
  }
  {
#line 928
  i = object_find_free_spot((object const   *)pl->ob, (pl->ob)->map, (int )(pl->ob)->x,
                            (int )(pl->ob)->y, 1, 9);
  }
#line 929
  if (i == -1) {
    {
#line 930
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Can not find a free spot to teleport to.");
    }
#line 932
    return;
  }
  {
#line 935
  dummy = object_new();
#line 936
  dummy->slaying = add_string((char const   *)(((pl->ob)->map)->path));
#line 937
  dummy->stats.hp = (sint16 )((int )(pl->ob)->x + (int )freearr_x[i]);
#line 938
  dummy->stats.sp = (sint16 )((int )(pl->ob)->y + (int )freearr_y[i]);
#line 939
  enter_exit(op, dummy);
#line 940
  object_free2(dummy, 2);
  }
#line 941
  if (! (op->contr)->hidden) {
    {
#line 942
    draw_ext_info(256, 0, (object const   *)pl->ob, (uint8 )8, (uint8 )4, "You see a portal open.");
    }
  }
  {
#line 944
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "You teleport to %s",
                       (pl->ob)->name);
  }
#line 947
  return;
}
}
#line 973 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_create(object *op , char const   *params ) 
{ 
  object *tmp ;
  uint32 i ;
  int magic ;
  int set_magic ;
  int set_nrof ;
  int gotquote ;
  int gotspace ;
  uint32 nrof ;
  char *cp ;
  char *bp ;
  char *bp2 ;
  char *bp3 ;
  char *endline ;
  char cpy[256] ;
  archetype *at ;
  archetype *at_spell ;
  artifact const   *art ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char spell_name[256] ;
  char *fsp ;
  size_t tmp___3 ;
  artifactlist const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  artifactlist const   *tmp___7 ;
  int tmp___8 ;
  uint32 tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  object *tmp___12 ;
  archetype *atmp ;
  object *prev ;
  object *head ;
  object *dup___0 ;
  object *tmp___13 ;
  object *check ;
  int size_x ;
  int size_y ;
  int tmp___14 ;
  uint32 tmp___15 ;

  {
#line 974
  tmp = (object *)((void *)0);
#line 976
  set_magic = 0;
#line 976
  set_nrof = 0;
#line 979
  at_spell = (archetype *)((void *)0);
#line 980
  art = (artifact const   *)((void *)0);
#line 982
  if (! op) {
#line 983
    return;
  }
#line 985
  if ((int const   )*params == 0) {
    {
#line 986
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Usage: create [nr] [magic] <archetype> [ of <artifact>] [variable_to_patch setting]");
    }
#line 988
    return;
  }
  {
#line 990
  strncpy((char */* __restrict  */)(cpy), (char const   */* __restrict  */)params,
          sizeof(cpy));
#line 991
  bp = cpy;
#line 994
  tmp___0 = strlen((char const   *)bp);
#line 994
  endline = bp + tmp___0;
#line 996
  tmp___1 = sscanf((char const   */* __restrict  */)bp, (char const   */* __restrict  */)"%u ",
                   & nrof);
  }
#line 996
  if (tmp___1) {
    {
#line 997
    bp = strchr((char const   *)(cpy), ' ');
    }
#line 997
    if ((unsigned long )bp == (unsigned long )((void *)0)) {
      {
#line 998
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Usage: create [nr] [magic] <archetype> [ of <artifact>] [variable_to_patch setting]");
      }
#line 1000
      return;
    }
    {
#line 1002
    bp ++;
#line 1003
    set_nrof = 1;
#line 1004
    LOG((LogLevel )2, "%s creates: (%u) %s\n", op->name, nrof, bp);
    }
  }
  {
#line 1006
  tmp___2 = sscanf((char const   */* __restrict  */)bp, (char const   */* __restrict  */)"%d ",
                   & magic);
  }
#line 1006
  if (tmp___2) {
    {
#line 1007
    bp = strchr((char const   *)bp, ' ');
    }
#line 1007
    if ((unsigned long )bp == (unsigned long )((void *)0)) {
      {
#line 1008
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Usage: create [nr] [magic] <archetype> [ of <artifact>] [variable_to_patch setting]");
      }
#line 1010
      return;
    }
    {
#line 1012
    bp ++;
#line 1013
    set_magic = 1;
#line 1014
    LOG((LogLevel )2, "%s creates: (%d) (%d) %s\n", op->name, nrof, magic, bp);
    }
  }
  {
#line 1016
  cp = strstr((char const   *)bp, " of ");
  }
#line 1016
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 1017
    *cp = (char )'\000';
#line 1018
    cp += 4;
  }
#line 1020
  bp2 = bp;
  {
#line 1020
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1020
    if (! *bp2) {
#line 1020
      goto while_break;
    }
#line 1021
    if ((int )*bp2 == 32) {
#line 1022
      *bp2 = (char )'\000';
#line 1023
      bp2 ++;
#line 1024
      goto while_break;
    }
#line 1020
    bp2 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1028
  at = try_find_archetype((char const   *)bp);
  }
#line 1028
  if ((unsigned long )at == (unsigned long )((void *)0)) {
    {
#line 1029
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "No such archetype.");
    }
#line 1031
    return;
  }
#line 1034
  if (cp) {
    {
#line 1035
    fsp = (char *)((void *)0);
#line 1043
    at_spell = try_find_archetype((char const   *)cp);
    }
#line 1044
    if (! at_spell) {
      {
#line 1045
      at_spell = find_archetype_by_object_name((char const   *)cp);
      }
    } else
#line 1044
    if ((int )at_spell->clone.type != 101) {
      {
#line 1045
      at_spell = find_archetype_by_object_name((char const   *)cp);
      }
    }
#line 1046
    if (! at_spell) {
#line 1046
      goto _L;
    } else
#line 1046
    if ((int )at_spell->clone.type != 101) {
      _L: /* CIL Label */ 
      {
#line 1047
      strcpy((char */* __restrict  */)(spell_name), (char const   */* __restrict  */)cp);
#line 1048
      fsp = strchr((char const   *)(spell_name), ' ');
      }
#line 1049
      if (fsp) {
        {
#line 1050
        *fsp = (char)0;
#line 1051
        fsp ++;
#line 1052
        at_spell = try_find_archetype((char const   *)(spell_name));
        }
#line 1055
        if (at_spell) {
#line 1055
          if ((int )at_spell->clone.type == 101) {
            {
#line 1056
            tmp___3 = strlen((char const   *)(spell_name));
#line 1056
            bp2 = (cp + tmp___3) + 1;
            }
          } else {
#line 1058
            at_spell = (archetype *)((void *)0);
          }
        } else {
#line 1058
          at_spell = (archetype *)((void *)0);
        }
      } else {
#line 1060
        at_spell = (archetype *)((void *)0);
      }
    }
#line 1066
    if (! at_spell) {
      {
#line 1067
      tmp___7 = find_artifactlist((int )at->clone.type);
      }
#line 1067
      if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
        {
#line 1068
        draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11,
                             "No artifact list for type %d\n", (int )at->clone.type);
        }
      } else {
        {
#line 1072
        tmp___4 = find_artifactlist((int )at->clone.type);
#line 1072
        art = (artifact const   *)tmp___4->items;
        }
        {
#line 1074
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 1075
          tmp___5 = strcmp((art->item)->name, (char const   *)cp);
          }
#line 1075
          if (! tmp___5) {
            {
#line 1075
            tmp___6 = legal_artifact_combination((object const   *)(& at->clone),
                                                 art);
            }
#line 1075
            if (tmp___6) {
#line 1076
              goto while_break___0;
            }
          }
#line 1077
          art = (artifact const   *)art->next;
#line 1074
          if (! ((unsigned long )art != (unsigned long )((void *)0))) {
#line 1074
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1079
        if (! art) {
          {
#line 1080
          draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11,
                               "No such artifact ([%d] of %s)", (int )at->clone.type,
                               cp);
          }
        }
      }
#line 1085
      if (set_magic) {
#line 1085
        tmp___8 = magic;
      } else {
#line 1085
        tmp___8 = 0;
      }
#line 1085
      if (set_nrof) {
#line 1085
        tmp___9 = nrof;
      } else {
#line 1085
        tmp___9 = (uint32 )0;
      }
      {
#line 1085
      LOG((LogLevel )2, "%s creates: (%d) (%d) (%s) of (%s)\n", op->name, tmp___9,
          tmp___8, bp, cp);
      }
    }
  }
#line 1089
  if ((int )at->clone.type == 3) {
#line 1089
    goto _L___0;
  } else
#line 1089
  if ((int )at->clone.type == 109) {
#line 1089
    goto _L___0;
  } else
#line 1089
  if ((int )at->clone.type == 111) {
#line 1089
    goto _L___0;
  } else
#line 1089
  if ((int )at->clone.type == 85) {
    _L___0: /* CIL Label */ 
#line 1089
    if (! at_spell) {
      {
#line 1091
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Unable to find spell %s for object that needs it, or it is of wrong type",
                           cp);
      }
#line 1094
      return;
    }
  }
  {
#line 1102
  tmp = object_create_arch(at);
  }
#line 1103
  if ((int )settings.real_wiz == 0) {
#line 1104
    tmp->flags[0] |= 1U << 4;
  }
#line 1105
  if (set_magic) {
    {
#line 1106
    set_abs_magic(tmp, magic);
    }
  }
#line 1107
  if (art) {
    {
#line 1108
    give_artifact_abilities(tmp, (object const   *)art->item);
    }
  }
  {
#line 1109
  tmp___10 = need_identify((object const   *)tmp);
  }
#line 1109
  if (tmp___10) {
    {
#line 1110
    tmp->flags[0] |= 1U << 29;
#line 1111
    tmp->flags[2] &= ~ (1U << 13);
#line 1112
    object_give_identified_properties(tmp);
    }
  }
  {
#line 1122
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1122
    if (*bp2) {
#line 1122
      if (! ((unsigned long )bp2 <= (unsigned long )endline)) {
#line 1122
        goto while_break___1;
      }
    } else {
#line 1122
      goto while_break___1;
    }
#line 1123
    gotspace = 0;
#line 1124
    gotquote = 0;
#line 1126
    bp3 = bp2;
    {
#line 1126
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1126
      if (*bp3) {
#line 1126
        if (gotspace < 2) {
#line 1126
          if (! (gotquote < 2)) {
#line 1126
            goto while_break___2;
          }
        } else {
#line 1126
          goto while_break___2;
        }
      } else {
#line 1126
        goto while_break___2;
      }
#line 1128
      if ((int )*bp3 == 34) {
#line 1129
        *bp3 = (char )' ';
#line 1130
        bp2 = bp3 + 1;
#line 1131
        bp3 ++;
#line 1132
        gotquote ++;
        {
#line 1133
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1133
          if (! *bp3) {
#line 1133
            goto while_break___3;
          }
#line 1134
          if ((int )*bp3 == 34) {
#line 1135
            *bp3 = (char )'\000';
#line 1136
            gotquote ++;
          } else {
#line 1138
            bp3 ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      } else
#line 1140
      if ((int )*bp3 == 32) {
#line 1141
        gotspace ++;
      }
#line 1126
      bp3 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1150
    if (gotspace == 2) {
#line 1151
      bp3 --;
#line 1152
      *bp3 = (char )'\000';
    } else
#line 1150
    if (gotquote == 2) {
#line 1151
      bp3 --;
#line 1152
      *bp3 = (char )'\000';
    } else
#line 1153
    if ((int )*bp3 == 0) {
#line 1154
      gotspace ++;
    }
#line 1156
    if (gotquote) {
#line 1156
      if (gotquote != 2) {
        {
#line 1165
        draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11,
                             "Malformed create line: %s", bp2);
        }
#line 1168
        goto while_break___1;
      } else {
#line 1156
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1156
    if (gotspace != 2) {
#line 1156
      if (gotquote != 2) {
        {
#line 1165
        draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11,
                             "Malformed create line: %s", bp2);
        }
#line 1168
        goto while_break___1;
      }
    }
    {
#line 1173
    tmp___11 = set_variable(tmp, (char const   *)bp2);
    }
#line 1173
    if (tmp___11 == -1) {
      {
#line 1174
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Unknown variable %s",
                           bp2);
      }
    } else {
      {
#line 1178
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "(%s#%d)->%s",
                           tmp->name, tmp->count, bp2);
      }
    }
#line 1181
    bp2 = bp3 + 1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1184
  if (at->clone.nrof) {
#line 1185
    if (at_spell) {
      {
#line 1186
      tmp___12 = arch_to_object(at_spell);
#line 1186
      object_insert_in_ob(tmp___12, tmp);
      }
    }
#line 1188
    if (set_nrof) {
#line 1189
      tmp->nrof = nrof;
    }
#line 1191
    if ((unsigned long )at->clone.randomitems != (unsigned long )((void *)0)) {
#line 1191
      if (! at_spell) {
        {
#line 1192
        create_treasure(at->clone.randomitems, tmp, 0, (int )(op->map)->difficulty,
                        0);
        }
#line 1193
        if (tmp->flags[0] & (1U << 14)) {
          {
#line 1194
          monster_check_apply_all(tmp);
          }
        }
      }
    }
#line 1199
    if (! tmp->more) {
      {
#line 1200
      tmp = object_insert_in_ob(tmp, op);
      }
    } else {
      {
#line 1202
      object_insert_in_map_at(tmp, op->map, op, 0, (int )op->x, (int )op->y);
      }
    }
    {
#line 1206
    dm_stack_push(op->contr, tmp->count);
    }
#line 1208
    return;
  }
#line 1211
  i = (uint32 )0;
  {
#line 1211
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1211
    if (set_nrof) {
#line 1211
      tmp___15 = nrof;
    } else {
#line 1211
      tmp___15 = (uint32 )1;
    }
#line 1211
    if (! (i < tmp___15)) {
#line 1211
      goto while_break___4;
    }
#line 1213
    prev = (object *)((void *)0);
#line 1213
    head = (object *)((void *)0);
#line 1215
    atmp = at;
    {
#line 1215
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1215
      if (! ((unsigned long )atmp != (unsigned long )((void *)0))) {
#line 1215
        goto while_break___5;
      }
      {
#line 1216
      dup___0 = arch_to_object(atmp);
      }
#line 1218
      if (at_spell) {
        {
#line 1219
        tmp___13 = arch_to_object(at_spell);
#line 1219
        object_insert_in_ob(tmp___13, dup___0);
        }
      }
#line 1225
      if ((unsigned long )head == (unsigned long )((void *)0)) {
        {
#line 1226
        head = dup___0;
#line 1227
        object_copy((object const   *)tmp, dup___0);
        }
      }
#line 1229
      if ((int )settings.real_wiz == 0) {
#line 1230
        dup___0->flags[0] |= 1U << 4;
      }
#line 1231
      dup___0->x = (sint16 )((int )op->x + (int )(dup___0->arch)->clone.x);
#line 1232
      dup___0->y = (sint16 )((int )op->y + (int )(dup___0->arch)->clone.y);
#line 1233
      dup___0->map = op->map;
#line 1235
      if ((unsigned long )head != (unsigned long )dup___0) {
#line 1236
        dup___0->head = head;
#line 1237
        prev->more = dup___0;
      }
#line 1239
      prev = dup___0;
#line 1215
      atmp = atmp->more;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1242
    if (head->flags[0] & 1U) {
#line 1243
      check = head;
#line 1244
      size_x = 0;
#line 1245
      size_y = 0;
      {
#line 1247
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1247
        if (! check) {
#line 1247
          goto while_break___6;
        }
#line 1248
        if (size_x > (int )(check->arch)->clone.x) {
#line 1248
          size_x = size_x;
        } else {
#line 1248
          size_x = (int )(check->arch)->clone.x;
        }
#line 1249
        if (size_y > (int )(check->arch)->clone.y) {
#line 1249
          size_y = size_y;
        } else {
#line 1249
          size_y = (int )(check->arch)->clone.y;
        }
#line 1250
        check = check->more;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 1253
      tmp___14 = out_of_map(op->map, (int )head->x + size_x, (int )head->y + size_y);
      }
#line 1253
      if (tmp___14) {
#line 1254
        if ((int )head->x < size_x) {
          {
#line 1255
          dm_stack_pop(op->contr);
#line 1256
          object_free2(head, 2);
#line 1257
          draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Object too big to insert in map, or wrong position.");
#line 1259
          object_free2(tmp, 2);
          }
#line 1260
          return;
        } else
#line 1254
        if ((int )head->y < size_y) {
          {
#line 1255
          dm_stack_pop(op->contr);
#line 1256
          object_free2(head, 2);
#line 1257
          draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Object too big to insert in map, or wrong position.");
#line 1259
          object_free2(tmp, 2);
          }
#line 1260
          return;
        }
#line 1263
        check = head;
        {
#line 1264
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1264
          if (! check) {
#line 1264
            goto while_break___7;
          }
#line 1265
          check->x = (sint16 )((int )check->x - size_x);
#line 1266
          check->y = (sint16 )((int )check->y - size_y);
#line 1267
          check = check->more;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
      {
#line 1271
      object_insert_in_map_at(head, op->map, op, 0, (int )head->x, (int )head->y);
      }
    } else {
      {
#line 1273
      head = object_insert_in_ob(head, op);
      }
    }
    {
#line 1279
    dm_stack_push(op->contr, head->count);
    }
#line 1281
    if ((unsigned long )at->clone.randomitems != (unsigned long )((void *)0)) {
#line 1281
      if (! at_spell) {
        {
#line 1282
        create_treasure(at->clone.randomitems, head, 0, (int )(op->map)->difficulty,
                        0);
        }
#line 1283
        if (head->flags[0] & (1U << 14)) {
          {
#line 1284
          monster_check_apply_all(head);
          }
        }
      }
    }
#line 1211
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1290
  object_free2(tmp, 2);
  }
#line 1291
  return;
}
}
#line 1305 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_inventory(object *op , char const   *params ) 
{ 
  object *tmp ;
  int i ;
  int tmp___0 ;

  {
#line 1309
  if ((int const   )*params == 0) {
    {
#line 1310
    inventory(op, (object *)((void *)0));
    }
#line 1311
    return;
  }
  {
#line 1314
  tmp___0 = sscanf((char const   */* __restrict  */)params, (char const   */* __restrict  */)"%d",
                   & i);
  }
#line 1314
  if (tmp___0) {
    {
#line 1314
    tmp = object_find_by_tag_global((tag_t )i);
    }
#line 1314
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 1315
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Inventory of what object (nr)?");
      }
#line 1317
      return;
    }
  } else {
    {
#line 1315
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Inventory of what object (nr)?");
    }
#line 1317
    return;
  }
  {
#line 1320
  inventory(op, tmp);
  }
#line 1321
  return;
}
}
#line 1335 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_skills(object *op , char const   *params ) 
{ 
  char const   *tmp ;

  {
#line 1336
  if ((int const   )*params == 0) {
#line 1336
    tmp = (char const   *)((void *)0);
  } else {
#line 1336
    tmp = params;
  }
  {
#line 1336
  show_skills(op, tmp);
  }
#line 1337
  return;
}
}
#line 1347 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_dump(object *op , char const   *params ) 
{ 
  object *tmp ;
  StringBuffer *sb ;
  char *diff ;

  {
  {
#line 1352
  tmp = get_dm_object(op->contr, & params, (int *)((void *)0));
  }
#line 1353
  if (! tmp) {
#line 1354
    return;
  }
  {
#line 1356
  sb = stringbuffer_new();
#line 1357
  object_dump((object const   *)tmp, sb);
#line 1358
  diff = stringbuffer_finish(sb);
#line 1359
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, (char const   *)diff);
#line 1360
  free((void *)diff);
  }
#line 1361
  if (tmp->flags[3] & (1U << 7)) {
    {
#line 1362
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "Object is marked original");
    }
  }
#line 1364
  return;
}
}
#line 1375 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_mon_aggr(object *op , char const   *params ) 
{ 


  {
#line 1376
  if (op->enemy) {
    {
#line 1377
    object_set_enemy(op, (object *)((void *)0));
#line 1378
    op->flags[1] |= 1U << 6;
#line 1379
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "Aggression turned OFF");
    }
  } else
#line 1376
  if (! (op->flags[1] & (1U << 6))) {
    {
#line 1377
    object_set_enemy(op, (object *)((void *)0));
#line 1378
    op->flags[1] |= 1U << 6;
#line 1379
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "Aggression turned OFF");
    }
  } else {
    {
#line 1382
    op->flags[0] &= ~ (1U << 15);
#line 1383
    op->flags[1] &= ~ (1U << 6);
#line 1384
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "Aggression turned ON");
    }
  }
#line 1387
  return;
}
}
#line 1401 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_possess(object *op , char const   *params ) 
{ 
  object *victim ;
  player *pl ;
  int i ;
  char buf[256] ;
  int tmp ;
  int tmp___0 ;

  {
#line 1407
  victim = (object *)((void *)0);
#line 1408
  if ((int const   )*params != 0) {
    {
#line 1409
    tmp___0 = sscanf((char const   */* __restrict  */)params, (char const   */* __restrict  */)"%d",
                     & i);
    }
#line 1409
    if (tmp___0) {
      {
#line 1410
      victim = object_find_by_tag_global((tag_t )i);
      }
    } else {
      {
#line 1411
      tmp = sscanf((char const   */* __restrict  */)params, (char const   */* __restrict  */)"%s",
                   buf);
      }
#line 1411
      if (tmp) {
        {
#line 1412
        victim = object_find_by_name_global((char const   *)(buf));
        }
      }
    }
  }
#line 1414
  if ((unsigned long )victim == (unsigned long )((void *)0)) {
    {
#line 1415
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Patch what object (nr)?");
    }
#line 1417
    return;
  }
#line 1420
  if ((unsigned long )victim == (unsigned long )op) {
    {
#line 1421
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "As insane as you are, I cannot allow you to possess yourself.");
    }
#line 1423
    return;
  }
#line 1427
  pl = op->contr;
#line 1428
  victim->contr = pl;
#line 1429
  pl->ob = victim;
#line 1430
  victim->type = (uint8 )1;
#line 1431
  victim->flags[0] |= 1U << 1;
#line 1441
  i = 0;
  {
#line 1441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1441
    if (! (i < 13)) {
#line 1441
      goto while_break;
    }
#line 1442
    if (i == 1) {
#line 1443
      victim->body_info[i] = (sint8 )2;
    } else
#line 1442
    if (i == 6) {
#line 1443
      victim->body_info[i] = (sint8 )2;
    } else
#line 1442
    if (i == 8) {
#line 1443
      victim->body_info[i] = (sint8 )2;
    } else
#line 1442
    if (i == 9) {
#line 1443
      victim->body_info[i] = (sint8 )2;
    } else {
#line 1445
      victim->body_info[i] = (sint8 )1;
    }
#line 1441
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1447
  esrv_new_player(pl, (uint32 )80);
#line 1448
  esrv_send_inventory(victim, victim);
#line 1450
  fix_object(victim);
#line 1452
  do_some_living(victim);
  }
#line 1453
  return;
}
}
#line 1462 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_patch(object *op , char const   *params ) 
{ 
  char const   *arg ;
  char const   *arg2 ;
  object *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1466
  tmp = get_dm_object(op->contr, & params, (int *)((void *)0));
  }
#line 1467
  if (! tmp) {
#line 1469
    return;
  }
#line 1472
  arg = params;
#line 1473
  if ((int const   )*arg == 0) {
    {
#line 1474
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Patch what values?");
    }
#line 1476
    return;
  }
  {
#line 1479
  tmp___0 = strchr(arg, ' ');
#line 1479
  arg2 = (char const   *)tmp___0;
  }
#line 1479
  if (arg2) {
#line 1480
    arg2 ++;
  }
#line 1481
  if ((int )settings.real_wiz == 0) {
#line 1482
    tmp->flags[0] |= 1U << 4;
  }
  {
#line 1483
  tmp___1 = set_variable(tmp, arg);
  }
#line 1483
  if (tmp___1 == -1) {
    {
#line 1484
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Unknown variable %s",
                         arg);
    }
  } else {
    {
#line 1488
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "(%s#%d)->%s=%s",
                         tmp->name, tmp->count, arg, arg2);
    }
  }
#line 1492
  return;
}
}
#line 1502 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_remove(object *op , char const   *params ) 
{ 
  object *tmp ;
  int from ;
  char name[256] ;

  {
  {
#line 1506
  tmp = get_dm_object(op->contr, & params, & from);
  }
#line 1507
  if (! tmp) {
    {
#line 1508
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Remove what object (nr)?");
    }
#line 1510
    return;
  }
#line 1513
  if ((int )tmp->type == 1) {
    {
#line 1514
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Unable to remove a player!");
    }
#line 1516
    return;
  }
#line 1519
  if (tmp->flags[0] & (1U << 2)) {
    {
#line 1522
    query_name((object const   *)tmp, name, (size_t )256);
#line 1523
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "%s is already removed!",
                         name);
    }
#line 1526
    return;
  }
#line 1529
  if (from != 2) {
    {
#line 1531
    dm_stack_pop(op->contr);
    }
  }
#line 1534
  if ((unsigned long )tmp->head != (unsigned long )((void *)0)) {
#line 1534
    tmp = tmp->head;
  } else {
#line 1534
    tmp = tmp;
  }
#line 1535
  if (tmp->speed != (float )0) {
    {
#line 1536
    tmp->speed = (float )0;
#line 1537
    object_update_speed(tmp);
    }
  }
  {
#line 1539
  object_remove(tmp);
  }
#line 1540
  return;
}
}
#line 1549 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_free(object *op , char const   *params ) 
{ 
  object *tmp ;
  int from ;

  {
  {
#line 1553
  tmp = get_dm_object(op->contr, & params, & from);
  }
#line 1555
  if (! tmp) {
    {
#line 1556
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Free what object (nr)?");
    }
#line 1558
    return;
  }
#line 1561
  if (from != 2) {
    {
#line 1563
    dm_stack_pop(op->contr);
    }
  }
#line 1565
  if ((unsigned long )tmp->head != (unsigned long )((void *)0)) {
#line 1565
    tmp = tmp->head;
  } else {
#line 1565
    tmp = tmp;
  }
#line 1566
  if (! (tmp->flags[0] & (1U << 2))) {
    {
#line 1567
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "Warning: item was not removed, will do so now.");
#line 1569
    object_remove(tmp);
    }
  }
  {
#line 1572
  object_free_drop_inventory(tmp);
  }
#line 1573
  return;
}
}
#line 1583 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_addexp(object *op , char const   *params ) 
{ 
  char buf[256] ;
  char skill[256] ;
  int i ;
  int q ;
  object *skillob ;
  player *pl ;
  size_t tmp ;
  int tmp___0 ;
  sint64 tmp___1 ;

  {
#line 1586
  skillob = (object *)((void *)0);
#line 1589
  skill[0] = (char )'\000';
#line 1590
  if ((int const   )*params == 0) {
    {
#line 1593
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Usage: addexp player quantity [skill].");
    }
#line 1595
    return;
  } else {
    {
#line 1590
    tmp = strlen(params);
    }
#line 1590
    if (tmp > 256UL) {
      {
#line 1593
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Usage: addexp player quantity [skill].");
      }
#line 1595
      return;
    } else {
      {
#line 1590
      q = sscanf((char const   */* __restrict  */)params, (char const   */* __restrict  */)"%s %d %[^\r\n]",
                 buf, & i, skill);
      }
#line 1590
      if (q < 2) {
        {
#line 1593
        draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Usage: addexp player quantity [skill].");
        }
#line 1595
        return;
      }
    }
  }
#line 1598
  pl = first_player;
  {
#line 1598
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1598
    if (! ((unsigned long )pl != (unsigned long )((void *)0))) {
#line 1598
      goto while_break;
    }
    {
#line 1599
    tmp___0 = strncmp((pl->ob)->name, (char const   *)(buf), (size_t )48);
    }
#line 1599
    if (! tmp___0) {
#line 1600
      goto while_break;
    }
#line 1598
    pl = pl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1602
  if ((unsigned long )pl == (unsigned long )((void *)0)) {
    {
#line 1603
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "No such player.");
    }
#line 1605
    return;
  }
#line 1608
  if (q >= 3) {
    {
#line 1609
    skillob = find_skill_by_name(pl->ob, (char const   *)(skill));
    }
#line 1610
    if (! skillob) {
      {
#line 1611
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Unable to find skill %s in %s",
                           skill, buf);
      }
#line 1614
      return;
    }
    {
#line 1617
    tmp___1 = check_exp_adjust((object const   *)skillob, (sint64 )i);
#line 1617
    i = (int )tmp___1;
#line 1618
    skillob->stats.exp += (sint64 )i;
#line 1619
    calc_perm_exp(skillob);
#line 1620
    player_lvl_adj(pl->ob, skillob);
    }
  }
  {
#line 1623
  (pl->ob)->stats.exp += (sint64 )i;
#line 1624
  calc_perm_exp(pl->ob);
#line 1625
  player_lvl_adj(pl->ob, (object *)((void *)0));
  }
#line 1627
  if ((int )settings.real_wiz == 0) {
#line 1628
    (pl->ob)->flags[0] |= 1U << 4;
  }
#line 1629
  return;
}
}
#line 1639 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_speed(object *op , char const   *params ) 
{ 
  int i ;
  int tmp ;

  {
#line 1642
  if ((int const   )*params == 0) {
    {
#line 1643
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "Current speed is %d",
                         max_time);
    }
#line 1646
    return;
  } else {
    {
#line 1642
    tmp = sscanf((char const   */* __restrict  */)params, (char const   */* __restrict  */)"%d",
                 & i);
    }
#line 1642
    if (! tmp) {
      {
#line 1643
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "Current speed is %d",
                           max_time);
      }
#line 1646
      return;
    }
  }
  {
#line 1649
  set_max_time((long )i);
#line 1650
  reset_sleep();
#line 1651
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "The speed is changed to %d.",
                       i);
  }
#line 1654
  return;
}
}
#line 1669 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_stats(object *op , char const   *params ) 
{ 
  player *pl ;

  {
#line 1672
  if ((int const   )*params == 0) {
    {
#line 1673
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Who?");
    }
#line 1675
    return;
  }
  {
#line 1678
  pl = find_player_partial_name(params);
  }
#line 1679
  if ((unsigned long )pl == (unsigned long )((void *)0)) {
    {
#line 1680
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "No such player.");
    }
#line 1682
    return;
  }
  {
#line 1685
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "[Fixed]Statistics for %s:",
                       (pl->ob)->name);
#line 1688
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "[fixed]Str : %-2d      H.P. : %-4d  MAX : %d",
                       (int )(pl->ob)->stats.Str, (int )(pl->ob)->stats.hp, (int )(pl->ob)->stats.maxhp);
#line 1692
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "[fixed]Dex : %-2d      S.P. : %-4d  MAX : %d",
                       (int )(pl->ob)->stats.Dex, (int )(pl->ob)->stats.sp, (int )(pl->ob)->stats.maxsp);
#line 1696
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "[fixed]Con : %-2d        AC : %-4d  WC  : %d",
                       (int )(pl->ob)->stats.Con, (int )(pl->ob)->stats.ac, (int )(pl->ob)->stats.wc);
#line 1700
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "[fixed]Int : %-2d    Damage : %d",
                       (int )(pl->ob)->stats.Int, (int )(pl->ob)->stats.dam);
#line 1704
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "[fixed]Wis : %-2d       EXP : %ld",
                       (int )(pl->ob)->stats.Wis, (pl->ob)->stats.exp);
#line 1708
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "[fixed]Pow : %-2d    Grace : %d",
                       (int )(pl->ob)->stats.Pow, (int )(pl->ob)->stats.grace);
#line 1712
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "[fixed]Cha : %-2d      Food : %d",
                       (int )(pl->ob)->stats.Cha, (pl->ob)->stats.food);
  }
#line 1715
  return;
}
}
#line 1726 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_abil(object *op , char const   *params ) 
{ 
  char thing[20] ;
  char thing2[20] ;
  int iii ;
  player *pl ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1731
  iii = 0;
#line 1732
  thing[0] = (char )'\000';
#line 1733
  thing2[0] = (char )'\000';
#line 1734
  if ((int const   )*params == 0) {
    {
#line 1737
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Who?");
    }
#line 1739
    return;
  } else {
    {
#line 1734
    tmp = sscanf((char const   */* __restrict  */)params, (char const   */* __restrict  */)"%s %s %d",
                 thing, thing2, & iii);
    }
#line 1734
    if (tmp != 3) {
      {
#line 1737
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Who?");
      }
#line 1739
      return;
    } else
#line 1734
    if ((int )thing[0] == 0) {
      {
#line 1737
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Who?");
      }
#line 1739
      return;
    }
  }
#line 1742
  if ((int )thing2[0] == 0) {
    {
#line 1743
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You can\'t change that.");
    }
#line 1745
    return;
  }
#line 1748
  if (iii < 1) {
    {
#line 1749
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Illegal range of stat.\n");
    }
#line 1751
    return;
  } else
#line 1748
  if (iii > (int )settings.max_stat) {
    {
#line 1749
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Illegal range of stat.\n");
    }
#line 1751
    return;
  }
#line 1754
  pl = first_player;
  {
#line 1754
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1754
    if (! ((unsigned long )pl != (unsigned long )((void *)0))) {
#line 1754
      goto while_break;
    }
    {
#line 1755
    tmp___7 = strcmp((pl->ob)->name, (char const   *)(thing));
    }
#line 1755
    if (! tmp___7) {
#line 1756
      if ((int )settings.real_wiz == 0) {
#line 1757
        (pl->ob)->flags[0] |= 1U << 4;
      }
      {
#line 1758
      tmp___0 = strcmp("str", (char const   *)(thing2));
      }
#line 1758
      if (! tmp___0) {
#line 1759
        (pl->ob)->stats.Str = (sint8 )iii;
#line 1759
        pl->orig_stats.Str = (sint8 )iii;
      }
      {
#line 1760
      tmp___1 = strcmp("dex", (char const   *)(thing2));
      }
#line 1760
      if (! tmp___1) {
#line 1761
        (pl->ob)->stats.Dex = (sint8 )iii;
#line 1761
        pl->orig_stats.Dex = (sint8 )iii;
      }
      {
#line 1762
      tmp___2 = strcmp("con", (char const   *)(thing2));
      }
#line 1762
      if (! tmp___2) {
#line 1763
        (pl->ob)->stats.Con = (sint8 )iii;
#line 1763
        pl->orig_stats.Con = (sint8 )iii;
      }
      {
#line 1764
      tmp___3 = strcmp("wis", (char const   *)(thing2));
      }
#line 1764
      if (! tmp___3) {
#line 1765
        (pl->ob)->stats.Wis = (sint8 )iii;
#line 1765
        pl->orig_stats.Wis = (sint8 )iii;
      }
      {
#line 1766
      tmp___4 = strcmp("cha", (char const   *)(thing2));
      }
#line 1766
      if (! tmp___4) {
#line 1767
        (pl->ob)->stats.Cha = (sint8 )iii;
#line 1767
        pl->orig_stats.Cha = (sint8 )iii;
      }
      {
#line 1768
      tmp___5 = strcmp("int", (char const   *)(thing2));
      }
#line 1768
      if (! tmp___5) {
#line 1769
        (pl->ob)->stats.Int = (sint8 )iii;
#line 1769
        pl->orig_stats.Int = (sint8 )iii;
      }
      {
#line 1770
      tmp___6 = strcmp("pow", (char const   *)(thing2));
      }
#line 1770
      if (! tmp___6) {
#line 1771
        (pl->ob)->stats.Pow = (sint8 )iii;
#line 1771
        pl->orig_stats.Pow = (sint8 )iii;
      }
      {
#line 1772
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "%s has been altered.",
                           (pl->ob)->name);
#line 1775
      fix_object(pl->ob);
      }
#line 1776
      return;
    }
#line 1754
    pl = pl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1780
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "No such player.");
  }
#line 1782
  return;
}
}
#line 1792 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_reset(object *op , char const   *params ) 
{ 
  mapstruct *m ;
  object *dummy ;
  object *tmp ;
  char path[4096] ;
  char const   *space ;
  char const   *confirmation ;
  int res ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  player *pl ;
  int playercount ;

  {
#line 1794
  dummy = (object *)((void *)0);
#line 1794
  tmp = (object *)((void *)0);
#line 1796
  confirmation = (char const   *)((void *)0);
#line 1797
  res = 0;
#line 1799
  if ((int const   )*params == 0) {
    {
#line 1800
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Reset what map [name]?");
    }
#line 1802
    return;
  }
  {
#line 1805
  tmp___0 = strchr(params, ' ');
#line 1805
  space = (char const   *)tmp___0;
  }
#line 1806
  if ((unsigned long )space != (unsigned long )((void *)0)) {
#line 1807
    confirmation = params;
#line 1808
    params = space + 1;
  }
  {
#line 1811
  tmp___1 = strcmp(params, ".");
  }
#line 1811
  if (tmp___1 == 0) {
    {
#line 1812
    snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"%s",
             (op->map)->path);
    }
  } else {
    {
#line 1814
    path_combine_and_normalize((char const   *)((op->map)->path), params, path, sizeof(path));
    }
  }
  {
#line 1815
  m = has_been_loaded((char const   *)(path));
  }
#line 1816
  if ((unsigned long )m == (unsigned long )((void *)0)) {
    {
#line 1817
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "No such map.");
    }
#line 1819
    return;
  }
#line 1822
  if (confirmation) {
    {
#line 1823
    tmp___2 = strcmp(params, ".");
    }
#line 1823
    if (tmp___2 == 0) {
#line 1823
      if (m->unique) {
        {
#line 1824
        draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11,
                             "Can\'t reset a player unique map while on it, use \'reset full-reset %s\' while not on it.",
                             m->path);
        }
#line 1827
        return;
      }
    }
    {
#line 1830
    tmp___3 = strlen("full-reset");
#line 1830
    tmp___4 = strncmp("full-reset", confirmation, tmp___3);
    }
#line 1830
    if (tmp___4) {
      {
#line 1831
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Invalid confirmation, must be \'full-reset\'.");
      }
#line 1833
      return;
    }
  }
#line 1840
  if (op->contr) {
#line 1840
    if ((op->contr)->transport) {
#line 1840
      if ((unsigned long )op->map == (unsigned long )m) {
        {
#line 1841
        draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You need to disembark first.");
        }
#line 1843
        return;
      }
    }
  }
  {
#line 1846
  snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"%s",
           m->path);
  }
#line 1848
  if (m->in_memory != 2U) {
#line 1849
    if (m->in_memory != 1U) {
      {
#line 1850
      LOG((LogLevel )0, "Tried to swap out map which was not in memory.\n");
      }
#line 1851
      return;
    }
#line 1858
    if ((unsigned long )op->map == (unsigned long )m) {
      {
#line 1859
      tmp___5 = strncmp((char const   *)(m->path), "/random/", (size_t )8);
      }
#line 1859
      if (tmp___5 == 0) {
        {
#line 1868
        draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You cannot reset a random map when inside it.");
        }
#line 1870
        return;
      }
      {
#line 1873
      dummy = object_new();
#line 1874
      dummy->map = (struct mapdef *)((void *)0);
#line 1875
      dummy->stats.hp = op->x;
#line 1876
      dummy->stats.sp = op->y;
#line 1877
      dummy->slaying = add_string((char const   *)((op->map)->path));
#line 1878
      object_remove(op);
#line 1879
      op->map = (struct mapdef *)((void *)0);
#line 1880
      tmp = op;
      }
    }
    {
#line 1882
    res = swap_map(m);
    }
  }
#line 1885
  if (res < 0) {
#line 1885
    goto _L___0;
  } else
#line 1885
  if (m->in_memory != 2U) {
    _L___0: /* CIL Label */ 
#line 1887
    playercount = 0;
#line 1890
    if (tmp) {
      {
#line 1891
      object_insert_in_map_at(op, m, (object *)((void *)0), 0, (int )op->x, (int )op->y);
#line 1892
      object_free2(dummy, 2);
      }
    }
#line 1895
    if (res < 0) {
#line 1895
      if (res != -11) {
        {
#line 1897
        draw_ext_info_format(259, 0, (object const   *)op, (uint8 )10, (uint8 )11,
                             "Reset failed, error code: %d.", res);
        }
      } else {
#line 1895
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1900
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Reset failed, couldn\'t swap map, the following players are on it:");
#line 1902
      pl = first_player;
      }
      {
#line 1902
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1902
        if (! ((unsigned long )pl != (unsigned long )((void *)0))) {
#line 1902
          goto while_break;
        }
#line 1903
        if ((unsigned long )(pl->ob)->map == (unsigned long )m) {
#line 1903
          if ((unsigned long )pl->ob != (unsigned long )op) {
            {
#line 1904
            draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, (pl->ob)->name);
#line 1906
            playercount ++;
            }
          }
        }
#line 1902
        pl = pl->next;
      }
      while_break: /* CIL Label */ ;
      }
#line 1909
      if (! playercount) {
        {
#line 1910
        draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "hmm, I don\'t see any other players on this map, something else is the problem.");
        }
      }
#line 1912
      return;
    }
  }
#line 1918
  if (m) {
#line 1918
    if (m->in_memory == 2U) {
#line 1920
      if (confirmation) {
        {
#line 1921
        map_remove_unique_files((mapstruct const   *)m);
#line 1922
        LOG((LogLevel )2, "DM %s fully resetting map %s.\n", op->name, m->path);
        }
      } else {
        {
#line 1924
        LOG((LogLevel )2, "DM %s resetting map %s.\n", op->name, m->path);
        }
      }
      {
#line 1927
      m->reset_time = (uint32 )1;
#line 1928
      flush_old_maps();
      }
    }
  }
#line 1931
  if (confirmation) {
    {
#line 1932
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "Fully resetting map %s.",
                         path);
    }
  } else {
    {
#line 1936
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "Resetting map %s.",
                         path);
    }
  }
#line 1940
  if (tmp) {
    {
#line 1941
    enter_exit(tmp, dummy);
#line 1942
    object_free2(dummy, 2);
    }
  }
#line 1945
  if ((unsigned long )confirmation == (unsigned long )((void *)0)) {
    {
#line 1946
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "Use \'reset full-reset %s\' to fully reset the map.",
                         params);
    }
  }
#line 1949
  return;
}
}
#line 1959 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_nowiz(object *op , char const   *params ) 
{ 


  {
#line 1960
  op->flags[0] &= ~ (1U << 1);
#line 1961
  op->flags[2] &= ~ (1U << 8);
#line 1962
  op->flags[1] &= ~ (1U << 19);
#line 1963
  if ((op->contr)->followed_player) {
    {
#line 1964
    free_string((op->contr)->followed_player);
#line 1964
    (op->contr)->followed_player = (sstring )((void *)0);
    }
  }
#line 1966
  if ((int )settings.real_wiz == 1) {
#line 1967
    op->flags[0] &= ~ (1U << 4);
  }
#line 1968
  if ((op->contr)->hidden) {
    {
#line 1969
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "You are no longer hidden from other players");
#line 1971
    (op->map)->players = (sint16 )((int )(op->map)->players + 1);
#line 1972
    draw_ext_info_format(774, 5, (object const   *)((void *)0), (uint8 )8, (uint8 )3,
                         "%s has entered the game.", op->name);
#line 1975
    (op->contr)->hidden = (uint32 )0;
#line 1976
    op->invisible = (sint16 )1;
    }
  } else {
    {
#line 1978
    draw_ext_info(776, 1, (object const   *)((void *)0), (uint8 )8, (uint8 )4, "The Dungeon Master is gone..");
    }
  }
  {
#line 1981
  update_los(op);
  }
#line 1982
  return;
}
}
#line 2004 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
static int checkdm(object *op , char const   *pl_name , char const   *pl_passwd ,
                   char const   *pl_host ) 
{ 
  FILE *dmfile ;
  char buf[256] ;
  char line_buf[160] ;
  char name[160] ;
  char passwd[160] ;
  char host[160] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 2013
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s/%s",
           settings.confdir, "dm_file");
#line 2014
  dmfile = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"r");
  }
#line 2014
  if ((unsigned long )dmfile == (unsigned long )((void *)0)) {
    {
#line 2015
    LOG((LogLevel )2, "Could not find DM file.\n");
    }
#line 2016
    return (0);
  }
  {
#line 2019
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2019
    tmp___6 = fgets((char */* __restrict  */)(line_buf), 160, (FILE */* __restrict  */)dmfile);
    }
#line 2019
    if (! ((unsigned long )tmp___6 != (unsigned long )((void *)0))) {
#line 2019
      goto while_break;
    }
#line 2020
    if ((int )line_buf[0] == 35) {
#line 2021
      goto while_continue;
    }
    {
#line 2022
    tmp___5 = sscanf((char const   */* __restrict  */)(line_buf), (char const   */* __restrict  */)"%[^:]:%[^:]:%s\n",
                     name, passwd, host);
    }
#line 2022
    if (tmp___5 != 3) {
      {
#line 2023
      LOG((LogLevel )0, "Warning - malformed dm file entry: %s\n", line_buf);
      }
    } else {
      {
#line 2024
      tmp = strcmp((char const   *)(name), "*");
      }
#line 2024
      if (tmp) {
#line 2024
        if (pl_name) {
          {
#line 2024
          tmp___0 = strcmp(pl_name, (char const   *)(name));
          }
#line 2024
          if (! tmp___0) {
            _L___0: /* CIL Label */ 
            {
#line 2024
            tmp___1 = strcmp((char const   *)(passwd), "*");
            }
#line 2024
            if (tmp___1) {
              {
#line 2024
              tmp___2 = strcmp((char const   *)(passwd), pl_passwd);
              }
#line 2024
              if (! tmp___2) {
                _L: /* CIL Label */ 
                {
#line 2024
                tmp___3 = strcmp((char const   *)(host), "*");
                }
#line 2024
                if (tmp___3) {
                  {
#line 2024
                  tmp___4 = strcmp((char const   *)(host), pl_host);
                  }
#line 2024
                  if (! tmp___4) {
                    {
#line 2027
                    fclose(dmfile);
                    }
#line 2028
                    return (1);
                  }
                } else {
                  {
#line 2027
                  fclose(dmfile);
                  }
#line 2028
                  return (1);
                }
              }
            } else {
#line 2024
              goto _L;
            }
          }
        }
      } else {
#line 2024
        goto _L___0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2031
  fclose(dmfile);
  }
#line 2032
  return (0);
}
}
#line 2049 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
static int do_wizard_dm(object *op , char const   *params , int silent ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
#line 2050
  if (! op->contr) {
#line 2051
    return (0);
  }
#line 2053
  if (op->flags[0] & (1U << 1)) {
    {
#line 2054
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You are already the Dungeon Master!");
    }
#line 2056
    return (0);
  }
#line 2059
  if ((int const   )*params != 0) {
#line 2059
    tmp = params;
  } else {
#line 2059
    tmp = "*";
  }
  {
#line 2059
  tmp___0 = checkdm(op, op->name, tmp, (char const   *)(op->contr)->socket.host);
  }
#line 2059
  if (tmp___0) {
    {
#line 2060
    op->flags[0] |= 1U << 1;
#line 2061
    op->flags[0] |= 1U << 4;
#line 2062
    op->flags[2] |= 1U << 8;
#line 2063
    op->flags[1] |= 1U << 19;
#line 2064
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "Ok, you are the Dungeon Master!");
#line 2072
    clear_los(op);
#line 2073
    (op->contr)->write_buf[0] = (char )'\000';
    }
#line 2075
    if (! silent) {
      {
#line 2076
      draw_ext_info(776, 1, (object const   *)((void *)0), (uint8 )8, (uint8 )4, "The Dungeon Master has arrived!");
      }
    }
#line 2080
    return (1);
  }
  {
#line 2083
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Sorry Pal, I don\'t think so.");
#line 2085
  (op->contr)->write_buf[0] = (char )'\000';
  }
#line 2086
  return (0);
}
}
#line 2100 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_dm(object *op , char const   *params ) 
{ 


  {
  {
#line 2101
  do_wizard_dm(op, params, 0);
  }
#line 2102
  return;
}
}
#line 2112 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_invisible(object *op , char const   *params ) 
{ 


  {
#line 2113
  if (op) {
    {
#line 2114
    op->invisible = (sint16 )((int )op->invisible + 100);
#line 2115
    object_update(op, 4);
#line 2116
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "You turn invisible.");
    }
  }
#line 2119
  return;
}
}
#line 2138 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
static object *get_spell_by_name(object *op , char const   *spell_name ) 
{ 
  archetype *ar ;
  archetype *found ;
  int conflict_found ;
  size_t spell_name_length ;
  int tmp ;
  int tmp___0 ;
  object *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  object *tmp___4 ;

  {
#line 2145
  conflict_found = 0;
#line 2146
  found = (archetype *)((void *)0);
#line 2147
  ar = first_archetype;
  {
#line 2147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2147
    if (! ((unsigned long )ar != (unsigned long )((void *)0))) {
#line 2147
      goto while_break;
    }
#line 2148
    if ((int )ar->clone.type != 101) {
#line 2149
      goto __Cont;
    }
    {
#line 2151
    tmp = strncmp(ar->name, "spelldirect_", (size_t )12);
    }
#line 2151
    if (tmp == 0) {
#line 2152
      goto __Cont;
    }
    {
#line 2154
    tmp___0 = strcmp(ar->clone.name, spell_name);
    }
#line 2154
    if (tmp___0 != 0) {
#line 2155
      goto __Cont;
    }
#line 2157
    if ((unsigned long )found != (unsigned long )((void *)0)) {
#line 2158
      if (! conflict_found) {
        {
#line 2159
        conflict_found = 1;
#line 2160
        draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11,
                             "More than one archetype matches the spell name %s:",
                             spell_name);
#line 2163
        draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11,
                             "- %s", found->name);
        }
      }
      {
#line 2167
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "- %s",
                           ar->name);
      }
#line 2170
      goto __Cont;
    }
#line 2173
    found = ar;
    __Cont: /* CIL Label */ 
#line 2147
    ar = ar->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2177
  if (conflict_found) {
#line 2178
    return ((object *)((void *)0));
  }
#line 2181
  if ((unsigned long )found != (unsigned long )((void *)0)) {
    {
#line 2182
    tmp___1 = arch_to_object(found);
    }
#line 2182
    return (tmp___1);
  }
  {
#line 2185
  spell_name_length = strlen(spell_name);
#line 2186
  conflict_found = 0;
#line 2187
  found = (archetype *)((void *)0);
#line 2188
  ar = first_archetype;
  }
  {
#line 2188
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2188
    if (! ((unsigned long )ar != (unsigned long )((void *)0))) {
#line 2188
      goto while_break___0;
    }
#line 2189
    if ((int )ar->clone.type != 101) {
#line 2190
      goto __Cont___0;
    }
    {
#line 2192
    tmp___2 = strncmp(ar->name, "spelldirect_", (size_t )12);
    }
#line 2192
    if (tmp___2 == 0) {
#line 2193
      goto __Cont___0;
    }
    {
#line 2195
    tmp___3 = strncmp(ar->clone.name, spell_name, spell_name_length);
    }
#line 2195
    if (tmp___3 != 0) {
#line 2196
      goto __Cont___0;
    }
#line 2198
    if ((unsigned long )found != (unsigned long )((void *)0)) {
#line 2199
      if (! conflict_found) {
        {
#line 2200
        conflict_found = 1;
#line 2201
        draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11,
                             "More than one spell matches %s:", spell_name);
#line 2204
        draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11,
                             "- %s", found->clone.name);
        }
      }
      {
#line 2208
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "- %s",
                           ar->clone.name);
      }
#line 2211
      goto __Cont___0;
    }
#line 2214
    found = ar;
    __Cont___0: /* CIL Label */ 
#line 2188
    ar = ar->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2218
  if (conflict_found) {
#line 2219
    return ((object *)((void *)0));
  }
#line 2222
  if ((unsigned long )found != (unsigned long )((void *)0)) {
    {
#line 2223
    tmp___4 = arch_to_object(found);
    }
#line 2223
    return (tmp___4);
  }
  {
#line 2226
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "The spell %s does not exist.",
                       spell_name);
  }
#line 2229
  return ((object *)((void *)0));
}
}
#line 2242 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
static void command_learn_spell_or_prayer(object *op , char const   *params , int special_prayer ) 
{ 
  object *tmp ;
  object *tmp___0 ;

  {
#line 2245
  if ((unsigned long )op->contr == (unsigned long )((void *)0)) {
    {
#line 2246
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Which spell do you want to learn?");
    }
#line 2248
    return;
  } else
#line 2245
  if ((int const   )*params == 0) {
    {
#line 2246
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Which spell do you want to learn?");
    }
#line 2248
    return;
  }
  {
#line 2251
  tmp = get_spell_by_name(op, params);
  }
#line 2252
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 2253
    return;
  }
  {
#line 2256
  tmp___0 = check_spell_known(op, tmp->name);
  }
#line 2256
  if (tmp___0) {
    {
#line 2257
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You already know the spell %s.",
                         tmp->name);
    }
#line 2260
    return;
  }
  {
#line 2263
  do_learn_spell(op, tmp, special_prayer);
#line 2264
  object_free2(tmp, 2);
  }
#line 2265
  return;
}
}
#line 2275 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_learn_spell(object *op , char const   *params ) 
{ 


  {
  {
#line 2276
  command_learn_spell_or_prayer(op, params, 0);
  }
#line 2277
  return;
}
}
#line 2287 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_learn_special_prayer(object *op , char const   *params ) 
{ 


  {
  {
#line 2288
  command_learn_spell_or_prayer(op, params, 1);
  }
#line 2289
  return;
}
}
#line 2299 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_forget_spell(object *op , char const   *params ) 
{ 
  object *spell ;

  {
#line 2302
  if ((unsigned long )op->contr == (unsigned long )((void *)0)) {
    {
#line 2303
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Which spell do you want to forget?");
    }
#line 2305
    return;
  } else
#line 2302
  if ((int const   )*params == 0) {
    {
#line 2303
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Which spell do you want to forget?");
    }
#line 2305
    return;
  }
  {
#line 2308
  spell = lookup_spell_by_name(op, params);
  }
#line 2309
  if ((unsigned long )spell == (unsigned long )((void *)0)) {
    {
#line 2310
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You do not know the spell %s.",
                         params);
    }
#line 2313
    return;
  }
  {
#line 2316
  do_forget_spell(op, spell->name);
  }
#line 2317
  return;
}
}
#line 2327 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_listplugins(object *op , char const   *params ) 
{ 


  {
  {
#line 2328
  plugins_display_list(op);
  }
#line 2329
  return;
}
}
#line 2341 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_loadplugin(object *op , char const   *params ) 
{ 
  char buf[256] ;
  int tmp ;

  {
#line 2344
  if ((int const   )*params == 0) {
    {
#line 2345
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Load which plugin?");
    }
#line 2347
    return;
  }
  {
#line 2350
  strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"/usr/games/crossfire/lib/crossfire");
#line 2351
  strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"/plugins/");
#line 2352
  strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)params);
#line 2353
  LOG((LogLevel )2, "Requested plugin file is %s\n", buf);
#line 2354
  tmp = plugins_init_plugin((char const   *)(buf));
  }
#line 2354
  if (tmp == 0) {
    {
#line 2355
    LOG((LogLevel )1, "DM %s loaded plugin %s\n", op->name, params);
#line 2356
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "Plugin %s successfully loaded.",
                         params);
    }
  } else {
    {
#line 2360
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Could not load plugin %s.",
                         params);
    }
  }
#line 2363
  return;
}
}
#line 2375 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_unloadplugin(object *op , char const   *params ) 
{ 
  int tmp ;

  {
#line 2376
  if ((int const   )*params == 0) {
    {
#line 2377
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Remove which plugin?");
    }
#line 2379
    return;
  }
  {
#line 2382
  tmp = plugins_remove_plugin(params);
  }
#line 2382
  if (tmp == 0) {
    {
#line 2383
    LOG((LogLevel )1, "DM %s unloaded plugin %s\n", op->name, params);
#line 2384
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "Plugin %s successfully removed.",
                         params);
    }
  } else {
    {
#line 2388
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Could not remove plugin %s.",
                         params);
    }
  }
#line 2391
  return;
}
}
#line 2403 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_dmhide(object *op , char const   *params ) 
{ 
  int tmp ;

  {
  {
#line 2404
  tmp = do_wizard_dm(op, params, 1);
  }
#line 2404
  if (! tmp) {
#line 2405
    return;
  }
  {
#line 2407
  do_wizard_hide(op, 1);
  }
#line 2408
  return;
}
}
#line 2418 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_stack_pop(object *op , char const   *params ) 
{ 


  {
  {
#line 2419
  dm_stack_pop(op->contr);
  }
#line 2420
  return;
}
}
#line 2430 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_stack_push(object *op , char const   *params ) 
{ 
  object *ob ;
  int from ;

  {
  {
#line 2433
  ob = get_dm_object(op->contr, & params, & from);
  }
#line 2435
  if (ob) {
#line 2435
    if (from != 3) {
      {
#line 2437
      dm_stack_push(op->contr, ob->count);
      }
    }
  }
#line 2438
  return;
}
}
#line 2448 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_stack_list(object *op , char const   *params ) 
{ 
  int item ;
  object *display ;
  player *pl ;

  {
  {
#line 2451
  pl = op->contr;
#line 2453
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "Item stack contents:");
#line 2456
  item = 0;
  }
  {
#line 2456
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2456
    if (! (item < pl->stack_position)) {
#line 2456
      goto while_break;
    }
    {
#line 2457
    display = object_find_by_tag_global(*(pl->stack_items + item));
    }
#line 2458
    if (display) {
      {
#line 2459
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, " %d : %s [%d]",
                           item, display->name, display->count);
      }
    } else {
      {
#line 2464
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, " %d : (lost item: %d)",
                           item, *(pl->stack_items + item));
      }
    }
#line 2456
    item ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2468
  return;
}
}
#line 2478 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_stack_clear(object *op , char const   *params ) 
{ 


  {
  {
#line 2479
  (op->contr)->stack_position = 0;
#line 2480
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "Item stack cleared.");
  }
#line 2482
  return;
}
}
#line 2503 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_diff(object *op , char const   *params ) 
{ 
  object *left ;
  object *right ;
  char *diff ;
  StringBuffer *sb ;
  int left_from ;
  int right_from ;

  {
  {
#line 2509
  left = get_dm_object(op->contr, & params, & left_from);
  }
#line 2510
  if (! left) {
    {
#line 2511
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Compare to what item?");
    }
#line 2513
    return;
  }
#line 2516
  if (left_from == 3) {
    {
#line 2518
    dm_stack_pop(op->contr);
    }
  }
  {
#line 2520
  right = get_dm_object(op->contr, & params, & right_from);
  }
#line 2522
  if (! right) {
    {
#line 2523
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Compare what item?");
    }
#line 2525
    return;
  }
  {
#line 2528
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "Item difference:");
  }
#line 2531
  if (left_from == 1) {
#line 2531
    if (right_from == 1) {
#line 2538
      if ((op->contr)->stack_position > 1) {
        {
#line 2539
        left = object_find_by_tag_global(*((op->contr)->stack_items + ((op->contr)->stack_position - 2)));
        }
#line 2540
        if (left) {
          {
#line 2541
          draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "(Note: first item taken from undertop)");
          }
        } else {
#line 2545
          left = right;
        }
      }
    }
  }
  {
#line 2549
  sb = stringbuffer_new();
#line 2550
  get_ob_diff(sb, (object const   *)left, (object const   *)right);
#line 2551
  diff = stringbuffer_finish(sb);
  }
#line 2552
  if ((int )*diff == 0) {
    {
#line 2553
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "Objects are the same.");
    }
  } else {
    {
#line 2555
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, (char const   *)diff);
    }
  }
  {
#line 2557
  free((void *)diff);
  }
#line 2558
  return;
}
}
#line 2567 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_insert_into(object *op , char const   *params ) 
{ 
  object *left ;
  object *right ;
  object *inserted ;
  int left_from ;
  int right_from ;
  char what[256] ;
  char where[256] ;

  {
  {
#line 2572
  left = get_dm_object(op->contr, & params, & left_from);
  }
#line 2573
  if (! left) {
    {
#line 2574
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Insert into what object?");
    }
#line 2576
    return;
  }
#line 2579
  if (left_from == 3) {
    {
#line 2581
    dm_stack_pop(op->contr);
    }
  }
  {
#line 2583
  right = get_dm_object(op->contr, & params, & right_from);
  }
#line 2585
  if (! right) {
    {
#line 2586
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Insert what item?");
    }
#line 2588
    return;
  }
#line 2591
  if (left_from == 1) {
#line 2591
    if (right_from == 1) {
#line 2598
      if ((op->contr)->stack_position > 1) {
        {
#line 2599
        left = object_find_by_tag_global(*((op->contr)->stack_items + ((op->contr)->stack_position - 2)));
        }
#line 2600
        if (left) {
          {
#line 2601
          draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "(Note: item to insert into taken from undertop)");
          }
        } else {
#line 2605
          left = right;
        }
      }
    }
  }
#line 2609
  if ((unsigned long )left == (unsigned long )right) {
    {
#line 2610
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Can\'t insert an object into itself!");
    }
#line 2612
    return;
  }
#line 2615
  if ((int )right->type == 1) {
    {
#line 2616
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Can\'t insert a player into something!");
    }
#line 2618
    return;
  }
#line 2621
  if (! (right->flags[0] & (1U << 2))) {
    {
#line 2622
    object_remove(right);
    }
  }
  {
#line 2623
  inserted = object_insert_in_ob(right, left);
  }
#line 2624
  if ((int )left->type == 1) {
#line 2625
    if ((unsigned long )inserted != (unsigned long )right) {
      {
#line 2627
      esrv_update_item(148, left, inserted);
      }
    }
  }
  {
#line 2629
  query_name((object const   *)inserted, what, (size_t )256);
#line 2630
  query_name((object const   *)left, where, (size_t )256);
#line 2631
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "Inserted %s in %s",
                       what, where);
  }
#line 2634
  return;
}
}
#line 2644 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_style_map_info(object *op , char const   *params ) 
{ 
  mapstruct *mp ;
  int maps_used ;
  int mapmem ;
  int objects_used ;
  int x ;
  int y ;
  object *tmp ;
  object *next2654 ;
  tag_t next_tag2654 ;
  tag_t tmp___0 ;

  {
#line 2647
  maps_used = 0;
#line 2647
  mapmem = 0;
#line 2647
  objects_used = 0;
#line 2649
  mp = styles;
  {
#line 2649
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2649
    if (! ((unsigned long )mp != (unsigned long )((void *)0))) {
#line 2649
      goto while_break;
    }
#line 2650
    maps_used ++;
#line 2651
    mapmem = (int )((unsigned long )mapmem + ((unsigned long )((int )mp->width * (int )mp->height) * (sizeof(object *) + sizeof(MapSpace )) + sizeof(mapstruct )));
#line 2652
    x = 0;
    {
#line 2652
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2652
      if (! (x < (int )mp->width)) {
#line 2652
        goto while_break___0;
      }
#line 2653
      y = 0;
      {
#line 2653
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2653
        if (! (y < (int )mp->height)) {
#line 2653
          goto while_break___1;
        }
        {
#line 2654
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2654
          tmp = (mp->spaces + (x + (int )mp->width * y))->bottom;
          {
#line 2654
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 2654
            next2654 = tmp;
#line 2654
            if ((unsigned long )next2654 == (unsigned long )((void *)0)) {
#line 2654
              tmp___0 = (tag_t )0;
            } else {
#line 2654
              tmp___0 = next2654->count;
            }
#line 2654
            next_tag2654 = tmp___0;
            {
#line 2654
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 2654
              tmp = next2654;
#line 2654
              if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 2654
                goto while_break___4;
              }
#line 2654
              if (next2654->count != next_tag2654) {
#line 2654
                goto while_break___4;
              } else
#line 2654
              if (next2654->flags[0] & (1U << 3)) {
#line 2654
                goto while_break___4;
              }
#line 2654
              next2654 = next2654->above;
#line 2654
              if ((unsigned long )next2654 == (unsigned long )((void *)0)) {
#line 2654
                next_tag2654 = (tag_t )0;
              } else {
#line 2654
                next_tag2654 = next2654->count;
              }
#line 2655
              objects_used ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 2654
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 2654
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2653
        y ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2652
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2649
    mp = mp->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2660
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )2, "[fixed]Style maps loaded:    %d",
                       maps_used);
#line 2663
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )2, "[fixed]Memory used, not");
#line 2665
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )2, "[fixed]including objects:    %d",
                       mapmem);
#line 2668
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )2, "[fixed]Style objects:        %d",
                       objects_used);
#line 2671
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )2, "[fixed]Mem for objects:      %lu",
                       (unsigned long )objects_used * sizeof(object ));
  }
#line 2674
  return;
}
}
#line 2684 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_follow(object *op , char const   *params ) 
{ 
  player *other ;

  {
#line 2687
  if ((int const   )*params == 0) {
#line 2688
    if ((unsigned long )(op->contr)->followed_player != (unsigned long )((void *)0)) {
      {
#line 2689
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )8, (uint8 )4, "You stop following %s.",
                           (op->contr)->followed_player);
#line 2690
      free_string((op->contr)->followed_player);
#line 2690
      (op->contr)->followed_player = (sstring )((void *)0);
      }
    }
#line 2692
    return;
  }
  {
#line 2695
  other = find_player_partial_name(params);
  }
#line 2696
  if (! other) {
    {
#line 2697
    draw_ext_info(256, 0, (object const   *)op, (uint8 )8, (uint8 )4, "No such player or ambiguous name.");
    }
#line 2698
    return;
  }
#line 2700
  if ((unsigned long )other == (unsigned long )op->contr) {
    {
#line 2701
    draw_ext_info(256, 0, (object const   *)op, (uint8 )8, (uint8 )4, "You can\'t follow yourself.");
    }
#line 2702
    return;
  }
#line 2705
  if ((op->contr)->followed_player) {
    {
#line 2706
    free_string((op->contr)->followed_player);
#line 2706
    (op->contr)->followed_player = (sstring )((void *)0);
    }
  }
  {
#line 2708
  (op->contr)->followed_player = add_string((other->ob)->name);
#line 2709
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )8, (uint8 )4, "Following %s.",
                       (op->contr)->followed_player);
  }
#line 2710
  return;
}
}
#line 2712 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_purge_quest(object *op , char const   *param ) 
{ 


  {
  {
#line 2713
  free_quest();
#line 2714
  draw_ext_info(256, 0, (object const   *)op, (uint8 )8, (uint8 )4, "Purged quest state.");
  }
#line 2715
  return;
}
}
#line 2717 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_purge_quest_definitions(object *op , char const   *param ) 
{ 


  {
  {
#line 2718
  free_quest_definitions();
#line 2719
  draw_ext_info(256, 0, (object const   *)op, (uint8 )8, (uint8 )4, "Purged quests definitions.");
  }
#line 2720
  return;
}
}
#line 2730 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_wiz.c"
void command_dumpbelow(object *op , char const   *params ) 
{ 
  StringBuffer *sb ;
  char *diff ;

  {
#line 2731
  if (op) {
#line 2731
    if (op->below) {
      {
#line 2735
      sb = stringbuffer_new();
#line 2736
      object_dump((object const   *)op->below, sb);
#line 2737
      diff = stringbuffer_finish(sb);
#line 2738
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, (char const   *)diff);
#line 2739
      free((void *)diff);
#line 2742
      dm_stack_push(op->contr, (op->below)->count);
      }
    }
  }
#line 2744
  return;
}
}
#line 26 "../include/libproto.h"
object *create_archetype(char const   *name ) ;
#line 111
void query_base_name(object const   *op , int plural , char *buf , size_t size ) ;
#line 153
void change_exp(object *op , sint64 exp , char const   *skill_name , int flag ) ;
#line 257
extern void object_sub_weight(object *op , long weight ) ;
#line 266
extern void object_add_weight(object *op , long weight ) ;
#line 297
extern object *object_find_by_type_and_slaying(object const   *who , int type , char const   *slaying ) ;
#line 299
extern object *object_find_by_flag(object const   *who , int flag ) ;
#line 345
extern object *get_random_mon(int level ) ;
#line 354
extern recipelist *get_formulalist(int i ) ;
#line 359
extern int strtoint(char const   *buf ) ;
#line 360
extern artifact const   *locate_recipe_artifact(recipe const   *rp , size_t idx ) ;
#line 361
extern recipe *get_random_recipe(recipelist *rpl ) ;
#line 418
int random_roll(int min , int max , object const   *op , int goodbad ) ;
#line 421
int rndm(int min , int max ) ;
#line 424
void transmute_materialname(object *op , object const   *change ) ;
#line 25 "../include/sproto.h"
int use_alchemy(object *op ) ;
#line 342
extern void monster_npc_call_help(object *op ) ;
#line 474
extern uint64 query_cost(object const   *tmp , object *who , int flag ) ;
#line 532
extern void cast_magic_storm(object *op , object *tmp , int lvl ) ;
#line 581
extern int fire_arch_from_position(object *op , object *caster , sint16 x , sint16 y ,
                                   int dir , object *spell ) ;
#line 587
extern int summon_hostile_monsters(object *op , int n , char const   *monstername ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/alchemy.c"
static char const   * const  cauldron_effect[14]  = 
#line 56 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/alchemy.c"
  {      (char const   */* const  */)"vibrates briefly",      (char const   */* const  */)"produces a cloud of steam",      (char const   */* const  */)"emits bright flames",      (char const   */* const  */)"pours forth heavy black smoke", 
        (char const   */* const  */)"emits sparks",      (char const   */* const  */)"shoots out small flames",      (char const   */* const  */)"whines painfully",      (char const   */* const  */)"hiccups loudly", 
        (char const   */* const  */)"wheezes",      (char const   */* const  */)"burps",      (char const   */* const  */)"shakes",      (char const   */* const  */)"rattles", 
        (char const   */* const  */)"makes chugging sounds",      (char const   */* const  */)"smokes heavily for a while"};
#line 74
static int is_defined_recipe(recipe const   *rp , object const   *cauldron , object *caster ) ;
#line 75
static recipe const   *find_recipe(recipelist const   *fl , int formula , object *ingredients ) ;
#line 76
static int content_recipe_value(object *op ) ;
#line 77
static int numb_ob_inside(object const   *op ) ;
#line 78
static void alchemy_failure_effect(object *op , object *cauldron , recipe const   *rp ,
                                   int danger ) ;
#line 79
static object *attempt_recipe(object *caster , object *cauldron , int ability , recipe const   *rp ,
                              int nbatches , int ignore_cauldron ) ;
#line 80
static int calc_alch_danger(object *caster , object *cauldron , recipe const   *rp ) ;
#line 81
static object *make_item_from_recipe(object *cauldron , recipe const   *rp ) ;
#line 82
static void remove_contents(object *first_ob , object *save_item ) ;
#line 83
static void adjust_product(object *item , int adjust , int yield ) ;
#line 84
static object *find_transmution_ob(object *first_ingred , recipe const   *rp , size_t *rp_arch_index ,
                                   int create_item ) ;
#line 85
static void attempt_do_alchemy(object *caster , object *cauldron ) ;
#line 88 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/alchemy.c"
static char const   *cauldron_sound(void) 
{ 
  int size ;
  int tmp ;

  {
  {
#line 89
  size = (int )(sizeof(cauldron_effect) / sizeof(char *));
#line 91
  tmp = rndm(0, size - 1);
  }
#line 91
  return ((char const   *)cauldron_effect[tmp]);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/alchemy.c"
static float recipe_chance(recipe const   *rp , object const   *skill , object const   *cauldron ) 
{ 
  int cauldron_add_skill ;
  double tmp ;
  double tmp___0 ;

  {
#line 107
  if (! rp) {
    {
#line 107
    __assert_fail("rp", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/alchemy.c",
                  107U, "recipe_chance");
    }
  }
#line 108
  if (! skill) {
    {
#line 108
    __assert_fail("skill", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/alchemy.c",
                  108U, "recipe_chance");
    }
  }
#line 109
  if (! cauldron) {
    {
#line 109
    __assert_fail("cauldron", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/alchemy.c",
                  109U, "recipe_chance");
    }
  }
#line 111
  cauldron_add_skill = (int )(((int const   )cauldron->magic + 1) / 2);
#line 113
  if ((int const   )skill->level + (int const   )cauldron_add_skill < rp->diff - 10) {
#line 114
    if (.01 > .3 - (double )(((rp->diff - 10) - (int const   )skill->level) - (int const   )cauldron_add_skill) * .03) {
#line 114
      tmp = .01;
    } else {
#line 114
      tmp = .3 - (double )(((rp->diff - 10) - (int const   )skill->level) - (int const   )cauldron_add_skill) * .03;
    }
#line 114
    return ((float )tmp);
  }
#line 116
  if ((int const   )skill->level + (int const   )cauldron_add_skill <= rp->diff + 10) {
#line 117
    return ((float )(.5 + .02 * (double )((float )(((int const   )skill->level + (int const   )cauldron_add_skill) - rp->diff))));
  }
#line 119
  if (.95 < .70 + (double )((((int const   )skill->level + (int const   )cauldron_add_skill) - rp->diff) - 10) * .01) {
#line 119
    tmp___0 = .95;
  } else {
#line 119
    tmp___0 = .70 + (double )((((int const   )skill->level + (int const   )cauldron_add_skill) - rp->diff) - 10) * .01;
  }
#line 119
  return ((float )tmp___0);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/alchemy.c"
static void attempt_do_alchemy(object *caster , object *cauldron ) 
{ 
  recipelist const   *fl ;
  recipe const   *rp ;
  float success_chance ;
  int numb ;
  int ability ;
  int formula ;
  object *item ;
  object *skop ;
  int tmp ;
  int tmp___0 ;
  uint64 value_ingredients ;
  uint64 value_item ;
  int attempt_shadow_alchemy ;
  object *tmp___1 ;
  object *next220 ;
  tag_t next_tag220 ;
  tag_t tmp___2 ;
  uint64 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  recipelist *tmp___7 ;
  int tmp___8 ;

  {
#line 152
  rp = (recipe const   *)((void *)0);
#line 154
  ability = 1;
#line 155
  formula = 0;
#line 158
  if ((int )caster->type != 1) {
#line 159
    return;
  }
  {
#line 162
  formula = content_recipe_value(cauldron);
  }
#line 162
  if (! formula) {
    {
#line 163
    draw_ext_info_format(256, 0, (object const   *)caster, (uint8 )12, (uint8 )4,
                         "The %s is empty.", cauldron->name);
    }
#line 166
    return;
  }
  {
#line 169
  numb = numb_ob_inside((object const   *)cauldron);
#line 170
  tmp___7 = get_formulalist(numb);
#line 170
  fl = (recipelist const   *)tmp___7;
  }
#line 170
  if (fl) {
#line 171
    if (caster->flags[0] & (1U << 1)) {
      {
#line 172
      rp = find_recipe(fl, formula, cauldron->inv);
      }
#line 173
      if ((unsigned long )rp != (unsigned long )((void *)0)) {
        {
#line 180
        tmp = is_defined_recipe(rp, (object const   *)cauldron, caster);
        }
#line 180
        if (tmp) {
#line 180
          tmp___0 = 0;
        } else {
#line 180
          tmp___0 = 1;
        }
        {
#line 180
        attempt_recipe(caster, cauldron, ability, rp, formula / (int )rp->index, tmp___0);
        }
      } else {
        {
#line 182
        LOG((LogLevel )2, "WIZ couldn\'t find formula for ingredients.\n");
        }
      }
#line 183
      return;
    }
    {
#line 187
    rp = find_recipe(fl, formula, cauldron->inv);
    }
#line 188
    if ((unsigned long )rp != (unsigned long )((void *)0)) {
#line 194
      if ((unsigned long )rp->skill != (unsigned long )((void *)0)) {
        {
#line 195
        skop = find_skill_by_name(caster, (char const   *)rp->skill);
        }
#line 196
        if (! skop) {
          {
#line 197
          draw_ext_info(256, 0, (object const   *)caster, (uint8 )12, (uint8 )1, "You do not have the proper skill for this recipe");
          }
        } else {
#line 200
          ability = (int )((double )ability + (double )skop->level * ((4.0 + (double )cauldron->magic) / 4.0));
        }
      } else {
        {
#line 203
        LOG((LogLevel )2, "Recipe %s has NULL skill!\n", rp->title);
        }
#line 204
        return;
      }
#line 207
      if ((unsigned long )rp->cauldron == (unsigned long )((void *)0)) {
        {
#line 208
        LOG((LogLevel )2, "Recipe %s has NULL cauldron!\n", rp->title);
        }
#line 209
        return;
      }
#line 212
      if (rp->min_level != 0) {
#line 212
        if ((int )skop->level < (int )rp->min_level) {
          {
#line 213
          draw_ext_info(256, 0, (object const   *)caster, (uint8 )12, (uint8 )4, "You aren\'t skilled enough to try this recipe.");
          }
#line 215
          return;
        }
      }
#line 219
      value_ingredients = (uint64 )0;
      {
#line 220
      while (1) {
        while_continue: /* CIL Label */ ;
#line 220
        tmp___1 = cauldron->inv;
        {
#line 220
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 220
          next220 = tmp___1;
#line 220
          if ((unsigned long )next220 == (unsigned long )((void *)0)) {
#line 220
            tmp___2 = (tag_t )0;
          } else {
#line 220
            tmp___2 = next220->count;
          }
#line 220
          next_tag220 = tmp___2;
          {
#line 220
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 220
            tmp___1 = next220;
#line 220
            if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 220
              goto while_break___1;
            }
#line 220
            if (next220->count != next_tag220) {
#line 220
              goto while_break___1;
            } else
#line 220
            if (next220->flags[0] & (1U << 3)) {
#line 220
              goto while_break___1;
            }
#line 220
            next220 = next220->below;
#line 220
            if ((unsigned long )next220 == (unsigned long )((void *)0)) {
#line 220
              next_tag220 = (tag_t )0;
            } else {
#line 220
              next_tag220 = next220->count;
            }
            {
#line 221
            tmp___3 = query_cost((object const   *)tmp___1, (object *)((void *)0),
                                 2);
#line 221
            value_ingredients += tmp___3;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 220
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 220
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 224
      tmp___4 = is_defined_recipe(rp, (object const   *)cauldron, caster);
      }
#line 224
      if (tmp___4) {
#line 224
        tmp___5 = 0;
      } else {
#line 224
        tmp___5 = 1;
      }
      {
#line 224
      attempt_shadow_alchemy = tmp___5;
#line 227
      item = attempt_recipe(caster, cauldron, ability, rp, formula / (int )rp->index,
                            attempt_shadow_alchemy);
      }
#line 227
      if ((unsigned long )item != (unsigned long )((void *)0)) {
        {
#line 229
        success_chance = recipe_chance(rp, (object const   *)skop, (object const   *)cauldron);
#line 235
        value_item = query_cost((object const   *)item, (object *)((void *)0), 26);
        }
#line 236
        if (attempt_shadow_alchemy) {
#line 236
          if (! (value_item > value_ingredients)) {
#line 236
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 245
          tmp___6 = random_roll(0, 101, (object const   *)caster, 0);
          }
#line 245
          if ((double )tmp___6 <= 100.0 * (double )success_chance) {
            {
#line 246
            change_exp(caster, (sint64 )rp->exp, (char const   *)rp->skill, 2);
            }
#line 247
            return;
          }
        }
      }
    }
  }
  {
#line 253
  tmp___8 = calc_alch_danger(caster, cauldron, rp);
#line 253
  alchemy_failure_effect(caster, cauldron, rp, tmp___8);
  }
#line 254
  return;
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/alchemy.c"
static int content_recipe_value(object *op ) 
{ 
  char name[256] ;
  int tval ;
  int formula ;
  object *tmp ;
  object *next270 ;
  tag_t next_tag270 ;
  tag_t tmp___0 ;
  int tmp___1 ;
  uint32 tmp___2 ;

  {
#line 268
  tval = 0;
#line 268
  formula = 0;
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 270
    tmp = op->inv;
    {
#line 270
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 270
      next270 = tmp;
#line 270
      if ((unsigned long )next270 == (unsigned long )((void *)0)) {
#line 270
        tmp___0 = (tag_t )0;
      } else {
#line 270
        tmp___0 = next270->count;
      }
#line 270
      next_tag270 = tmp___0;
      {
#line 270
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 270
        tmp = next270;
#line 270
        if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 270
          goto while_break___1;
        }
#line 270
        if (next270->count != next_tag270) {
#line 270
          goto while_break___1;
        } else
#line 270
        if (next270->flags[0] & (1U << 3)) {
#line 270
          goto while_break___1;
        }
#line 270
        next270 = next270->below;
#line 270
        if ((unsigned long )next270 == (unsigned long )((void *)0)) {
#line 270
          next_tag270 = (tag_t )0;
        } else {
#line 270
          next_tag270 = next270->count;
        }
        {
#line 271
        tval = 0;
#line 272
        strcpy((char */* __restrict  */)(name), (char const   */* __restrict  */)tmp->name);
        }
#line 273
        if (tmp->title) {
          {
#line 274
          snprintf((char */* __restrict  */)(name), sizeof(name), (char const   */* __restrict  */)"%s %s",
                   tmp->name, tmp->title);
          }
        }
        {
#line 275
        tmp___1 = strtoint((char const   *)(name));
        }
#line 275
        if (tmp->nrof) {
#line 275
          tmp___2 = tmp->nrof;
        } else {
#line 275
          tmp___2 = (uint32 )1;
        }
#line 275
        tval = (int )((uint32 )tmp___1 * tmp___2);
#line 279
        formula += tval;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 270
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 270
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  return (formula);
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/alchemy.c"
static int numb_ob_inside(object const   *op ) 
{ 
  int o_number ;
  object *tmp ;
  object *next297 ;
  tag_t next_tag297 ;
  tag_t tmp___0 ;

  {
#line 295
  o_number = 0;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    tmp = (object *)op->inv;
    {
#line 297
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 297
      next297 = tmp;
#line 297
      if ((unsigned long )next297 == (unsigned long )((void *)0)) {
#line 297
        tmp___0 = (tag_t )0;
      } else {
#line 297
        tmp___0 = next297->count;
      }
#line 297
      next_tag297 = tmp___0;
      {
#line 297
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 297
        tmp = next297;
#line 297
        if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 297
          goto while_break___1;
        }
#line 297
        if (next297->count != next_tag297) {
#line 297
          goto while_break___1;
        } else
#line 297
        if (next297->flags[0] & (1U << 3)) {
#line 297
          goto while_break___1;
        }
#line 297
        next297 = next297->below;
#line 297
        if ((unsigned long )next297 == (unsigned long )((void *)0)) {
#line 297
          next_tag297 = (tag_t )0;
        } else {
#line 297
          next_tag297 = next297->count;
        }
#line 298
        o_number ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 297
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 297
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 303
  return (o_number);
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/alchemy.c"
static object *attempt_recipe(object *caster , object *cauldron , int ability , recipe const   *rp ,
                              int nbatches , int ignore_cauldron ) 
{ 
  object *item ;
  object *skop ;
  int batches ;
  int tmp ;
  int tmp___0 ;
  object *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 332
  item = (object *)((void *)0);
#line 334
  tmp = abs(nbatches);
#line 334
  batches = tmp;
  }
#line 337
  if (! ignore_cauldron) {
    {
#line 337
    tmp___0 = strcmp((char const   *)rp->cauldron, (cauldron->arch)->name);
    }
#line 337
    if (tmp___0 != 0) {
      {
#line 338
      draw_ext_info(256, 0, (object const   *)caster, (uint8 )12, (uint8 )2, "You are not using the proper facilities for this formula.");
      }
#line 340
      return ((object *)((void *)0));
    }
  }
  {
#line 343
  skop = find_skill_by_name(caster, (char const   *)rp->skill);
  }
#line 345
  if (! skop) {
#line 346
    return ((object *)((void *)0));
  }
#line 349
  if (rp->keycode) {
    {
#line 352
    tmp___1 = object_find_by_type_and_slaying((object const   *)caster, 114, (char const   *)rp->keycode);
    }
#line 353
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
#line 354
      draw_ext_info(256, 0, (object const   *)caster, (uint8 )12, (uint8 )2, "You know the ingredients, but not the technique.  Go learn how to do this recipe.");
      }
#line 356
      return ((object *)((void *)0));
    }
  }
  {
#line 365
  item = make_item_from_recipe(cauldron, rp);
  }
#line 365
  if ((unsigned long )item != (unsigned long )((void *)0)) {
    {
#line 366
    remove_contents(cauldron->inv, item);
    }
#line 368
    if (rp->yield) {
#line 368
      tmp___2 = rp->yield * (int const   )batches;
    } else {
#line 368
      tmp___2 = (int const   )batches;
    }
    {
#line 368
    adjust_product(item, ability, (int )tmp___2);
    }
#line 370
    if ((int )item->type == 5) {
#line 371
      if ((int )item->level > (int )skop->level) {
#line 371
        item->level = item->level;
      } else {
#line 371
        item->level = skop->level;
      }
    }
#line 374
    if (! item->env) {
      {
#line 374
      item = object_insert_in_ob(item, cauldron);
      }
#line 374
      if ((unsigned long )item == (unsigned long )((void *)0)) {
        {
#line 375
        draw_ext_info(256, 0, (object const   *)caster, (uint8 )12, (uint8 )4, "Nothing happened.");
        }
      } else {
        {
#line 378
        tmp___3 = cauldron_sound();
#line 378
        draw_ext_info_format(256, 0, (object const   *)caster, (uint8 )12, (uint8 )3,
                             "The %s %s.", cauldron->name, tmp___3);
        }
      }
    } else {
      {
#line 378
      tmp___3 = cauldron_sound();
#line 378
      draw_ext_info_format(256, 0, (object const   *)caster, (uint8 )12, (uint8 )3,
                           "The %s %s.", cauldron->name, tmp___3);
      }
    }
  }
#line 384
  return (item);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/alchemy.c"
static void adjust_product(object *item , int adjust , int yield ) 
{ 
  int nrof ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 398
  nrof = 1;
#line 400
  if (! yield) {
#line 401
    yield = 1;
  }
#line 402
  if (adjust <= 0) {
#line 403
    adjust = 1;
  }
#line 404
  if (item->nrof) {
    {
#line 405
    tmp = rndm(0, yield - 1);
#line 405
    tmp___0 = rndm(0, yield - 1);
#line 405
    tmp___1 = rndm(0, yield - 1);
#line 405
    nrof = (int )((1.0 - 1.0 / ((double )adjust / 10.0 + 1.0)) * (double )((tmp + tmp___0) + tmp___1) + (double )1);
    }
#line 406
    if (nrof > yield) {
#line 407
      nrof = yield;
    }
#line 408
    item->nrof = (uint32 )nrof;
  }
#line 410
  return;
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/alchemy.c"
static object *make_item_from_recipe(object *cauldron , recipe const   *rp ) 
{ 
  artifact const   *art ;
  object *item ;
  size_t rp_arch_index ;
  uint32 tmp ;
  int tmp___0 ;
  uint32 tmp___1 ;

  {
#line 423
  art = (artifact const   *)((void *)0);
#line 424
  item = (object *)((void *)0);
#line 427
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
#line 428
    return ((object *)((void *)0));
  }
  {
#line 431
  item = find_transmution_ob(cauldron->inv, rp, & rp_arch_index, 1);
  }
#line 431
  if ((unsigned long )item == (unsigned long )((void *)0)) {
    {
#line 432
    LOG((LogLevel )2, "make_alchemy_item(): failed to create alchemical object.\n");
    }
#line 433
    return ((object *)((void *)0));
  }
#line 437
  if ((unsigned long )item->env != (unsigned long )((void *)0)) {
#line 438
    if (item->nrof != 0U) {
#line 438
      tmp = item->nrof;
    } else {
#line 438
      tmp = (uint32 )1;
    }
    {
#line 438
    object_sub_weight(cauldron, (long )((uint32 )item->weight * tmp));
    }
  }
  {
#line 441
  tmp___0 = strcmp((char const   *)rp->title, "NONE");
  }
#line 441
  if (tmp___0) {
    {
#line 442
    art = locate_recipe_artifact(rp, rp_arch_index);
    }
#line 442
    if ((unsigned long )art == (unsigned long )((void *)0)) {
      {
#line 443
      LOG((LogLevel )0, "make_alchemy_item(): failed to locate recipe artifact.\n");
#line 444
      LOG((LogLevel )2, "  --requested recipe: %s of %s.\n", *(rp->arch_name + 0),
          rp->title);
      }
#line 445
      return ((object *)((void *)0));
    }
    {
#line 447
    transmute_materialname(item, (object const   *)art->item);
#line 448
    give_artifact_abilities(item, (object const   *)art->item);
    }
  }
#line 450
  if ((unsigned long )item->env != (unsigned long )((void *)0)) {
#line 451
    if (item->nrof != 0U) {
#line 451
      tmp___1 = item->nrof;
    } else {
#line 451
      tmp___1 = (uint32 )1;
    }
    {
#line 451
    object_add_weight(cauldron, (long )((uint32 )item->weight * tmp___1));
    }
  }
#line 453
  if (cauldron->flags[2] & (1U << 10)) {
#line 454
    item->flags[2] |= 1U << 10;
  }
#line 455
  if (cauldron->flags[2] & (1U << 11)) {
#line 456
    item->flags[2] |= 1U << 11;
  }
#line 458
  return (item);
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/alchemy.c"
static object *find_transmution_ob(object *first_ingred , recipe const   *rp , size_t *rp_arch_index ,
                                   int create_item ) 
{ 
  object *item ;
  object *next481 ;
  tag_t next_tag481 ;
  tag_t tmp ;
  size_t i ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 475
  item = (object *)((void *)0);
#line 477
  *rp_arch_index = (size_t )0;
#line 479
  if (rp->transmute) {
#line 480
    item = first_ingred;
    {
#line 481
    while (1) {
      while_continue: /* CIL Label */ ;
#line 481
      next481 = item;
#line 481
      if ((unsigned long )next481 == (unsigned long )((void *)0)) {
#line 481
        tmp = (tag_t )0;
      } else {
#line 481
        tmp = next481->count;
      }
#line 481
      next_tag481 = tmp;
      {
#line 481
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 481
        item = next481;
#line 481
        if (! ((unsigned long )item != (unsigned long )((void *)0))) {
#line 481
          goto while_break___0;
        }
#line 481
        if (next481->count != next_tag481) {
#line 481
          goto while_break___0;
        } else
#line 481
        if (next481->flags[0] & (1U << 3)) {
#line 481
          goto while_break___0;
        }
#line 481
        next481 = next481->below;
#line 481
        if ((unsigned long )next481 == (unsigned long )((void *)0)) {
#line 481
          next_tag481 = (tag_t )0;
        } else {
#line 481
          next_tag481 = next481->count;
        }
#line 484
        i = (size_t )0;
        {
#line 484
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 484
          if (! (i < (size_t )rp->arch_names)) {
#line 484
            goto while_break___1;
          }
          {
#line 485
          tmp___0 = strcmp((item->arch)->name, (char const   *)*(rp->arch_name + i));
          }
#line 485
          if (tmp___0 == 0) {
#line 486
            *rp_arch_index = i;
#line 487
            goto while_break___1;
          }
#line 484
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 490
        if (i < (size_t )rp->arch_names) {
#line 491
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 481
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 497
  if (create_item) {
#line 497
    if (! item) {
      {
#line 498
      tmp___1 = random();
#line 498
      *rp_arch_index = (size_t )((unsigned long const   )tmp___1 % rp->arch_names);
#line 499
      item = create_archetype((char const   *)*(rp->arch_name + *rp_arch_index));
      }
    } else
#line 497
    if (item->nrof > 1U) {
      {
#line 498
      tmp___1 = random();
#line 498
      *rp_arch_index = (size_t )((unsigned long const   )tmp___1 % rp->arch_names);
#line 499
      item = create_archetype((char const   *)*(rp->arch_name + *rp_arch_index));
      }
    }
  }
#line 509
  return (item);
}
}
#line 528 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/alchemy.c"
static void alchemy_failure_effect(object *op , object *cauldron , recipe const   *rp ,
                                   int danger ) 
{ 
  int level ;
  object *failure ;
  object *tmp ;
  object *item ;
  object *tmp___0 ;
  int weight ;
  uint16 material ;
  object *tmp___1 ;
  object *next567 ;
  tag_t next_tag567 ;
  tag_t tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  object *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  object *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  object *fb ;
  object *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  object *tmp___20 ;
  object *tmp___21 ;
  char const   *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int roll ;
  int tmp___25 ;
  object *tmp___26 ;
  recipe *tmp___27 ;
  int tmp___28 ;
  char const   *tmp___29 ;
  long tmp___30 ;
  object *tmp___31 ;
  object *tmp___32 ;

  {
#line 529
  level = 0;
#line 531
  if (! op) {
#line 532
    return;
  } else
#line 531
  if (! cauldron) {
#line 532
    return;
  }
#line 535
  if (rp) {
#line 535
    if (rp->failure_arch) {
      {
#line 536
      tmp = create_archetype((char const   *)rp->failure_arch);
#line 536
      failure = tmp;
      }
#line 537
      if (! failure) {
        {
#line 538
        LOG((LogLevel )0, "invalid failure_arch %s for recipe %s\n", rp->failure_arch,
            rp->title);
        }
#line 539
        return;
      }
      {
#line 542
      remove_contents(cauldron->inv, (object *)((void *)0));
#line 544
      object_insert_in_ob(failure, cauldron);
      }
#line 545
      if (rp->failure_message) {
        {
#line 546
        draw_ext_info(256, 0, (object const   *)op, (uint8 )12, (uint8 )4, (char const   *)rp->failure_message);
        }
      }
#line 548
      return;
    }
  }
#line 551
  if (danger > 1) {
    {
#line 552
    level = random_roll(1, danger, (object const   *)op, 0);
    }
  }
#line 559
  if (level < 25) {
    {
#line 560
    item = (object *)((void *)0);
#line 562
    tmp___3 = rndm(0, 2);
    }
#line 562
    if (tmp___3) {
#line 564
      weight = 0;
#line 565
      material = (uint16 )64;
      {
#line 567
      while (1) {
        while_continue: /* CIL Label */ ;
#line 567
        tmp___1 = cauldron->inv;
        {
#line 567
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 567
          next567 = tmp___1;
#line 567
          if ((unsigned long )next567 == (unsigned long )((void *)0)) {
#line 567
            tmp___2 = (tag_t )0;
          } else {
#line 567
            tmp___2 = next567->count;
          }
#line 567
          next_tag567 = tmp___2;
          {
#line 567
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 567
            tmp___1 = next567;
#line 567
            if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 567
              goto while_break___1;
            }
#line 567
            if (next567->count != next_tag567) {
#line 567
              goto while_break___1;
            } else
#line 567
            if (next567->flags[0] & (1U << 3)) {
#line 567
              goto while_break___1;
            }
#line 567
            next567 = next567->below;
#line 567
            if ((unsigned long )next567 == (unsigned long )((void *)0)) {
#line 567
              next_tag567 = (tag_t )0;
            } else {
#line 567
              next_tag567 = next567->count;
            }
#line 568
            weight += tmp___1->weight;
#line 569
            if (! ((int )material & (int )tmp___1->material)) {
#line 570
              material = (uint16 )((int )material | (int )tmp___1->material);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 567
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 567
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 572
      tmp___0 = create_archetype("rock");
#line 573
      tmp___0->weight = weight;
#line 574
      tmp___0->value = 0;
#line 575
      tmp___0->material = material;
#line 576
      tmp___0->materialname = add_string("stone");
#line 577
      free_string(tmp___0->name);
#line 578
      tmp___0->name = add_string("slag");
      }
#line 579
      if (tmp___0->name_pl) {
        {
#line 580
        free_string(tmp___0->name_pl);
        }
      }
      {
#line 581
      tmp___0->name_pl = add_string("slags");
#line 582
      item = object_insert_in_ob(tmp___0, cauldron);
#line 583
      tmp___0->flags[0] &= ~ (1U << 22);
#line 584
      tmp___0->flags[0] &= ~ (1U << 8);
#line 585
      tmp___0->move_block = (MoveType )0;
      }
    }
    {
#line 587
    remove_contents(cauldron->inv, item);
#line 588
    tmp___4 = cauldron_sound();
#line 588
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )12, (uint8 )4, "The %s %s.",
                         cauldron->name, tmp___4);
    }
#line 591
    return;
  } else
#line 592
  if (level < 40) {
#line 593
    tmp___5 = (object *)((void *)0);
#line 609
    tmp___5 = cauldron->inv;
#line 609
    if (tmp___5) {
#line 610
      if (! (tmp___5->flags[2] & (1U << 10))) {
#line 611
        tmp___5->flags[2] |= 1U << 10;
#line 612
        tmp___5->flags[2] &= ~ (1U << 14);
#line 613
        tmp___5->flags[0] &= ~ (1U << 29);
      }
#line 619
      if ((int )tmp___5->type == 6) {
        {
#line 620
        tmp___6 = random_roll(0, 149, (object const   *)op, 0);
#line 620
        tmp___5->stats.hp = (sint16 )tmp___6;
        }
      }
#line 622
      tmp___5->value = 0;
      {
#line 625
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 626
        tmp___7 = rndm(1, 3);
#line 626
        tmp___8 = rndm(0, 6);
#line 626
        change_attr_value(& tmp___5->stats, tmp___8, (sint8 )(-1 * tmp___7));
#line 625
        tmp___9 = rndm(0, 2);
        }
#line 625
        if (! tmp___9) {
#line 625
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 629
    return;
  }
#line 653
  if (level < 45) {
    {
#line 655
    object_set_enemy(cauldron, op);
#line 656
    monster_npc_call_help(cauldron);
#line 657
    object_set_enemy(cauldron, (object *)((void *)0));
#line 659
    alchemy_failure_effect(op, cauldron, rp, level - 5);
    }
#line 660
    return;
  } else
#line 661
  if (level < 50) {
    {
#line 664
    remove_contents(cauldron->inv, (object *)((void *)0));
#line 665
    tmp___11 = rndm(0, 2);
    }
    {
#line 666
    if (tmp___11 == 0) {
#line 666
      goto case_0;
    }
#line 675
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 667
    tmp___10 = create_archetype("bomb");
#line 668
    tmp___12 = random_roll(1, level, (object const   *)op, 0);
#line 668
    tmp___10->stats.dam = (sint16 )tmp___12;
#line 669
    tmp___13 = random_roll(1, level, (object const   *)op, 0);
#line 669
    tmp___10->stats.hp = (sint16 )tmp___13;
#line 670
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )12, (uint8 )4, "The %s creates a bomb!",
                         cauldron->name);
    }
#line 673
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 676
    tmp___10 = create_archetype("fireball");
#line 677
    tmp___14 = random_roll(1, level, (object const   *)op, 0);
#line 677
    tmp___10->stats.dam = (sint16 )(tmp___14 / 5 + 1);
#line 678
    tmp___15 = random_roll(1, level, (object const   *)op, 0);
#line 678
    tmp___10->stats.hp = (sint16 )(tmp___15 / 10 + 2);
#line 679
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )12, (uint8 )4, "The %s erupts in flame!",
                         cauldron->name);
    }
#line 682
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 684
    object_insert_in_map_at(tmp___10, op->map, (object *)((void *)0), 0, (int )cauldron->x,
                            (int )cauldron->y);
    }
#line 685
    return;
  } else
#line 686
  if (level < 60) {
    {
#line 687
    tmp___16 = cauldron_sound();
#line 687
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )12, (uint8 )4, "The %s %s.",
                         cauldron->name, tmp___16);
#line 689
    remove_contents(cauldron->inv, (object *)((void *)0));
    }
#line 690
    return;
  } else
#line 691
  if (level < 80) {
    {
#line 692
    tmp___17 = create_archetype("spell_medium_fireball");
#line 692
    fb = tmp___17;
#line 694
    remove_contents(cauldron->inv, (object *)((void *)0));
#line 695
    fire_arch_from_position(cauldron, cauldron, cauldron->x, cauldron->y, 0, fb);
#line 696
    object_free_drop_inventory(fb);
#line 697
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )12, (uint8 )4, "The %s erupts in flame!",
                         cauldron->name);
    }
#line 700
    return;
  } else
#line 701
  if (level < 100) {
#line 702
    if (! (cauldron->flags[2] & (1U << 10))) {
#line 703
      cauldron->flags[2] |= 1U << 10;
#line 704
      cauldron->flags[2] &= ~ (1U << 14);
#line 705
      cauldron->flags[0] &= ~ (1U << 29);
    } else {
#line 707
      cauldron->magic = (sint8 )((int )cauldron->magic - 1);
    }
    {
#line 708
    tmp___18 = random_roll(0, 4, (object const   *)op, 0);
#line 708
    cauldron->magic = (sint8 )((int )cauldron->magic - tmp___18);
#line 709
    tmp___19 = rndm(0, 1);
    }
#line 709
    if (tmp___19) {
      {
#line 710
      remove_contents(cauldron->inv, (object *)((void *)0));
#line 711
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )12, (uint8 )4, "Your %s turns darker then makes a gulping sound!",
                           cauldron->name);
      }
    } else {
      {
#line 715
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )12, (uint8 )4, "Your %s becomes darker.",
                           cauldron->name);
      }
    }
#line 718
    return;
  } else
#line 719
  if (level < 110) {
    {
#line 720
    tmp___21 = get_random_mon(level / 5);
#line 720
    tmp___20 = tmp___21;
#line 722
    remove_contents(cauldron->inv, (object *)((void *)0));
    }
#line 723
    if (! tmp___20) {
      {
#line 724
      alchemy_failure_effect(op, cauldron, rp, level);
      }
    } else {
      {
#line 725
      tmp___23 = random_roll(1, 10, (object const   *)op, 0);
#line 725
      tmp___24 = summon_hostile_monsters(cauldron, tmp___23, (tmp___20->arch)->name);
      }
#line 725
      if (tmp___24) {
        {
#line 726
        tmp___22 = cauldron_sound();
#line 726
        draw_ext_info_format(256, 0, (object const   *)op, (uint8 )12, (uint8 )4,
                             "The %s %s and then pours forth monsters!", cauldron->name,
                             tmp___22);
        }
      }
    }
#line 729
    return;
  } else
#line 730
  if (level < 150) {
    {
#line 731
    tmp___25 = rndm(1, 3);
#line 731
    roll = tmp___25;
    }
    {
#line 732
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 732
      if (! roll) {
#line 732
        goto while_break___3;
      }
      {
#line 733
      alchemy_failure_effect(op, cauldron, rp, level - 39);
#line 734
      roll --;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 736
    return;
  } else
#line 737
  if (level == 151) {
#line 744
    if (! rp) {
      {
#line 745
      tmp___27 = get_random_recipe((recipelist *)((void *)0));
#line 745
      rp = (recipe const   *)tmp___27;
      }
    }
#line 746
    if (rp) {
      {
#line 746
      tmp___30 = random();
#line 746
      tmp___26 = create_archetype((char const   *)*(rp->arch_name + (unsigned long const   )tmp___30 % rp->arch_names));
      }
#line 746
      if (tmp___26) {
        {
#line 747
        tmp___28 = random_roll(1, (int )op->level / 2 + 1, (object const   *)op, 1);
#line 747
        generate_artifact(tmp___26, tmp___28 + 1);
#line 748
        tmp___26 = object_insert_in_ob(tmp___26, cauldron);
        }
#line 748
        if (tmp___26) {
          {
#line 749
          remove_contents(cauldron->inv, tmp___26);
#line 750
          tmp___29 = cauldron_sound();
#line 750
          draw_ext_info_format(256, 0, (object const   *)op, (uint8 )12, (uint8 )3,
                               "The %s %s.", cauldron->name, tmp___29);
          }
        }
      }
    }
#line 756
    return;
  } else {
    {
#line 758
    tmp___32 = create_archetype("loose_magic");
#line 758
    tmp___31 = tmp___32;
#line 759
    draw_ext_info(256, 0, (object const   *)op, (uint8 )12, (uint8 )4, "You unwisely release potent forces!");
#line 761
    remove_contents(cauldron->inv, (object *)((void *)0));
#line 762
    cast_magic_storm(op, tmp___31, level);
    }
#line 763
    return;
  }
}
}
#line 776 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/alchemy.c"
static void remove_contents(object *first_ob , object *save_item ) 
{ 
  object *tmp ;
  object *next780 ;
  tag_t next_tag780 ;
  tag_t tmp___0 ;

  {
#line 779
  tmp = first_ob;
  {
#line 780
  while (1) {
    while_continue: /* CIL Label */ ;
#line 780
    next780 = tmp;
#line 780
    if ((unsigned long )next780 == (unsigned long )((void *)0)) {
#line 780
      tmp___0 = (tag_t )0;
    } else {
#line 780
      tmp___0 = next780->count;
    }
#line 780
    next_tag780 = tmp___0;
    {
#line 780
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 780
      tmp = next780;
#line 780
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 780
        goto while_break___0;
      }
#line 780
      if (next780->count != next_tag780) {
#line 780
        goto while_break___0;
      } else
#line 780
      if (next780->flags[0] & (1U << 3)) {
#line 780
        goto while_break___0;
      }
#line 780
      next780 = next780->below;
#line 780
      if ((unsigned long )next780 == (unsigned long )((void *)0)) {
#line 780
        next_tag780 = (tag_t )0;
      } else {
#line 780
        next_tag780 = next780->count;
      }
#line 781
      if ((unsigned long )tmp != (unsigned long )save_item) {
#line 782
        if (tmp->inv) {
          {
#line 783
          remove_contents(tmp->inv, (object *)((void *)0));
          }
        }
        {
#line 784
        object_remove(tmp);
#line 785
        object_free_drop_inventory(tmp);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 780
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 788
  return;
}
}
#line 809 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/alchemy.c"
static int calc_alch_danger(object *caster , object *cauldron , recipe const   *rp ) 
{ 
  int danger ;
  int tmp ;
  object *item ;
  object *next822 ;
  tag_t next_tag822 ;
  tag_t tmp___0 ;

  {
#line 810
  danger = 0;
#line 813
  if (caster->chosen_skill) {
#line 813
    tmp = (int )(caster->chosen_skill)->level;
  } else {
#line 813
    tmp = (int )caster->level;
  }
#line 813
  danger -= tmp;
#line 816
  danger -= (int )cauldron->magic;
#line 819
  danger -= 3 * ((int )caster->stats.Int - 15);
  {
#line 822
  while (1) {
    while_continue: /* CIL Label */ ;
#line 822
    item = cauldron->inv;
    {
#line 822
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 822
      next822 = item;
#line 822
      if ((unsigned long )next822 == (unsigned long )((void *)0)) {
#line 822
        tmp___0 = (tag_t )0;
      } else {
#line 822
        tmp___0 = next822->count;
      }
#line 822
      next_tag822 = tmp___0;
      {
#line 822
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 822
        item = next822;
#line 822
        if (! ((unsigned long )item != (unsigned long )((void *)0))) {
#line 822
          goto while_break___1;
        }
#line 822
        if (next822->count != next_tag822) {
#line 822
          goto while_break___1;
        } else
#line 822
        if (next822->flags[0] & (1U << 3)) {
#line 822
          goto while_break___1;
        }
#line 822
        next822 = next822->below;
#line 822
        if ((unsigned long )next822 == (unsigned long )((void *)0)) {
#line 822
          next_tag822 = (tag_t )0;
        } else {
#line 822
          next_tag822 = next822->count;
        }
#line 823
        danger += item->weight / 100;
#line 824
        danger ++;
#line 825
        if (item->flags[2] & (1U << 10)) {
#line 826
          danger += 5;
        } else
#line 825
        if (item->flags[2] & (1U << 11)) {
#line 826
          danger += 5;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 822
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 822
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 829
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
#line 830
    danger += 110;
  } else {
#line 832
    danger += (int )(rp->diff * 3);
  }
#line 835
  if (cauldron->flags[2] & (1U << 10)) {
#line 836
    danger += 80;
  }
#line 837
  if (cauldron->flags[2] & (1U << 11)) {
#line 838
    danger += 200;
  }
#line 844
  return (danger);
}
}
#line 866 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/alchemy.c"
static int is_defined_recipe(recipe const   *rp , object const   *cauldron , object *caster ) 
{ 
  uint32 batches_in_cauldron ;
  linked_char const   *ingredient ;
  int number ;
  object *ob ;
  object *next875 ;
  tag_t next_tag875 ;
  tag_t tmp ;
  uint32 nrof ;
  char const   *name ;
  int ok ;
  unsigned short const   **tmp___0 ;
  object *ob___0 ;
  object *next902 ;
  tag_t next_tag902 ;
  tag_t tmp___1 ;
  char name_ob[256] ;
  char const   *name2 ;
  uint32 batches ;
  int tmp___2 ;

  {
#line 872
  number = 0;
#line 873
  ingredient = (linked_char const   *)rp->ingred;
  {
#line 873
  while (1) {
    while_continue: /* CIL Label */ ;
#line 873
    if (! ((unsigned long )ingredient != (unsigned long )((void *)0))) {
#line 873
      goto while_break;
    }
#line 874
    number ++;
#line 873
    ingredient = (linked_char const   *)ingredient->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 875
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 875
    ob = (object *)cauldron->inv;
    {
#line 875
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 875
      next875 = ob;
#line 875
      if ((unsigned long )next875 == (unsigned long )((void *)0)) {
#line 875
        tmp = (tag_t )0;
      } else {
#line 875
        tmp = next875->count;
      }
#line 875
      next_tag875 = tmp;
      {
#line 875
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 875
        ob = next875;
#line 875
        if (! ((unsigned long )ob != (unsigned long )((void *)0))) {
#line 875
          goto while_break___2;
        }
#line 875
        if (next875->count != next_tag875) {
#line 875
          goto while_break___2;
        } else
#line 875
        if (next875->flags[0] & (1U << 3)) {
#line 875
          goto while_break___2;
        }
#line 875
        next875 = next875->below;
#line 875
        if ((unsigned long )next875 == (unsigned long )((void *)0)) {
#line 875
          next_tag875 = (tag_t )0;
        } else {
#line 875
          next_tag875 = next875->count;
        }
#line 876
        number --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 875
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 875
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 878
  if (number != 0) {
#line 879
    return (0);
  }
#line 882
  batches_in_cauldron = (uint32 )0;
#line 883
  ingredient = (linked_char const   *)rp->ingred;
  {
#line 883
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 883
    if (! ((unsigned long )ingredient != (unsigned long )((void *)0))) {
#line 883
      goto while_break___3;
    }
#line 889
    name = (char const   *)ingredient->name;
#line 890
    nrof = (uint32 )0;
    {
#line 891
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 891
      tmp___0 = __ctype_b_loc();
      }
#line 891
      if (! ((int const   )*(*tmp___0 + (int )*name) & 2048)) {
#line 891
        goto while_break___4;
      }
#line 892
      nrof = 10U * nrof + (uint32 )((int const   )*name - 48);
#line 893
      name ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 895
    if (nrof == 0U) {
#line 896
      nrof = (uint32 )1;
    }
    {
#line 897
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 897
      if (! ((int const   )*name == 32)) {
#line 897
        goto while_break___5;
      }
#line 898
      name ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 901
    ok = 0;
    {
#line 902
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 902
      ob___0 = (object *)cauldron->inv;
      {
#line 902
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 902
        next902 = ob___0;
#line 902
        if ((unsigned long )next902 == (unsigned long )((void *)0)) {
#line 902
          tmp___1 = (tag_t )0;
        } else {
#line 902
          tmp___1 = next902->count;
        }
#line 902
        next_tag902 = tmp___1;
        {
#line 902
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 902
          ob___0 = next902;
#line 902
          if (! ((unsigned long )ob___0 != (unsigned long )((void *)0))) {
#line 902
            goto while_break___8;
          }
#line 902
          if (next902->count != next_tag902) {
#line 902
            goto while_break___8;
          } else
#line 902
          if (next902->flags[0] & (1U << 3)) {
#line 902
            goto while_break___8;
          }
#line 902
          next902 = next902->below;
#line 902
          if ((unsigned long )next902 == (unsigned long )((void *)0)) {
#line 902
            next_tag902 = (tag_t )0;
          } else {
#line 902
            next_tag902 = next902->count;
          }
#line 906
          if ((unsigned long )ob___0->title == (unsigned long )((void *)0)) {
#line 907
            name2 = ob___0->name;
          } else {
            {
#line 909
            snprintf((char */* __restrict  */)(name_ob), sizeof(name_ob), (char const   */* __restrict  */)"%s %s",
                     ob___0->name, ob___0->title);
#line 910
            name2 = (char const   *)(name_ob);
            }
          }
          {
#line 913
          tmp___2 = strcmp(name2, name);
          }
#line 913
          if (tmp___2 == 0) {
#line 914
            if (ob___0->nrof % nrof == 0U) {
#line 917
              batches = ob___0->nrof / nrof;
#line 918
              if (batches_in_cauldron == 0U) {
#line 919
                batches_in_cauldron = batches;
#line 920
                ok = 1;
              } else
#line 921
              if (batches_in_cauldron == batches) {
#line 922
                ok = 1;
              }
            }
#line 924
            goto while_break___8;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
#line 902
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 902
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 927
    if (! ok) {
#line 928
      return (0);
    }
#line 883
    ingredient = (linked_char const   *)ingredient->next;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 931
  return (1);
}
}
#line 948 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/alchemy.c"
static recipe const   *find_recipe(recipelist const   *fl , int formula , object *ingredients ) 
{ 
  recipe const   *rp ;
  recipe const   *result ;
  int recipes_matching ;
  int transmute_found ;
  size_t rp_arch_index ;
  object *tmp ;
  int tmp___0 ;

  {
#line 958
  result = (recipe const   *)((void *)0);
#line 959
  recipes_matching = 0;
#line 960
  transmute_found = 0;
#line 961
  rp = (recipe const   *)fl->items;
  {
#line 961
  while (1) {
    while_continue: /* CIL Label */ ;
#line 961
    if (! ((unsigned long )rp != (unsigned long )((void *)0))) {
#line 961
      goto while_break;
    }
#line 963
    if (formula % (int )rp->index != 0) {
#line 967
      goto __Cont;
    }
#line 970
    if (rp->transmute) {
      {
#line 970
      tmp = find_transmution_ob(ingredients, rp, & rp_arch_index, 0);
      }
#line 970
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 975
        if (! transmute_found) {
#line 976
          transmute_found = 1;
#line 977
          recipes_matching = 0;
        }
      } else {
#line 970
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 979
    if (transmute_found) {
#line 984
      goto __Cont;
    }
    {
#line 992
    tmp___0 = rndm(0, recipes_matching);
    }
#line 992
    if (tmp___0 == 0) {
#line 993
      result = rp;
    }
#line 995
    recipes_matching ++;
    __Cont: /* CIL Label */ 
#line 961
    rp = (recipe const   *)rp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 998
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 1002
    return ((recipe const   *)((void *)0));
  }
#line 1011
  return (result);
}
}
#line 1025 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/alchemy.c"
int use_alchemy(object *op ) 
{ 
  object *unpaid_cauldron ;
  object *unpaid_item ;
  int did_alchemy ;
  char name[256] ;
  object *tmp ;
  object *next1034 ;
  tag_t next_tag1034 ;
  tag_t tmp___0 ;

  {
#line 1026
  unpaid_cauldron = (object *)((void *)0);
#line 1027
  unpaid_item = (object *)((void *)0);
#line 1028
  did_alchemy = 0;
#line 1031
  if (op->flags[0] & (1U << 1)) {
    {
#line 1032
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )17, "Note: alchemy in wizard-mode.\n");
    }
  }
  {
#line 1034
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1034
    tmp = ((op->map)->spaces + ((int )op->x + (int )(op->map)->width * (int )op->y))->bottom;
    {
#line 1034
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1034
      next1034 = tmp;
#line 1034
      if ((unsigned long )next1034 == (unsigned long )((void *)0)) {
#line 1034
        tmp___0 = (tag_t )0;
      } else {
#line 1034
        tmp___0 = next1034->count;
      }
#line 1034
      next_tag1034 = tmp___0;
      {
#line 1034
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1034
        tmp = next1034;
#line 1034
        if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 1034
          goto while_break___1;
        }
#line 1034
        if (next1034->count != next_tag1034) {
#line 1034
          goto while_break___1;
        } else
#line 1034
        if (next1034->flags[0] & (1U << 3)) {
#line 1034
          goto while_break___1;
        }
#line 1034
        next1034 = next1034->above;
#line 1034
        if ((unsigned long )next1034 == (unsigned long )((void *)0)) {
#line 1034
          next_tag1034 = (tag_t )0;
        } else {
#line 1034
          next_tag1034 = next1034->count;
        }
#line 1035
        if (tmp->flags[2] & (1U << 30)) {
#line 1036
          if (tmp->flags[0] & (1U << 6)) {
#line 1037
            unpaid_cauldron = tmp;
#line 1038
            goto while_continue___1;
          }
          {
#line 1040
          unpaid_item = object_find_by_flag((object const   *)tmp, 6);
          }
#line 1041
          if ((unsigned long )unpaid_item != (unsigned long )((void *)0)) {
#line 1042
            goto while_continue___1;
          }
          {
#line 1044
          attempt_do_alchemy(op, tmp);
          }
#line 1045
          if (tmp->flags[0] & (1U << 5)) {
            {
#line 1046
            esrv_send_inventory(op, tmp);
            }
          }
#line 1047
          did_alchemy = 1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1034
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1034
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1050
  if (unpaid_cauldron) {
    {
#line 1051
    query_base_name((object const   *)unpaid_cauldron, 0, name, (size_t )256);
#line 1052
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )12, (uint8 )2, "You must pay for your %s first!",
                         name);
    }
  } else
#line 1055
  if (unpaid_item) {
    {
#line 1056
    query_base_name((object const   *)unpaid_item, 0, name, (size_t )256);
#line 1057
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )12, (uint8 )2, "You must pay for your %s first!",
                         name);
    }
  }
#line 1062
  return (did_alchemy);
}
}
#line 187 "../include/global.h"
New_Face *new_faces ;
#line 241
Animations *animations ;
#line 5 "../include/libproto.h"
int try_find_animation(char const   *name ) ;
#line 6
void animate_object(object *op , int dir ) ;
#line 7
void apply_anim_suffix(object *who , sstring suffix ) ;
#line 51
int check_trigger(object *op , object *cause ) ;
#line 87
unsigned int find_face(char const   *name , unsigned int error ) ;
#line 117
object *identify(object *op ) ;
#line 133
void set_attr_value(living *stats , int attr , sint8 value ) ;
#line 137
int change_abil(object *op , object *tmp ) ;
#line 214
extern method_ret ob_apply(object *op , object *applier , int aflags ) ;
#line 259
extern object *object_merge(object *op , object *top ) ;
#line 264
extern object *object_split(object *orig_ob , uint32 nr , char *err , size_t size ) ;
#line 272
extern object *object_present_in_ob_by_name(int type , char const   *str , object const   *op ) ;
#line 290
extern object *object_find_by_name(object const   *who , char const   *name ) ;
#line 294
extern object *object_find_by_type_applied(object const   *who , int type ) ;
#line 305
extern char const   *object_get_value(object const   *op , char const   * const  key ) ;
#line 411
extern object *generate_treasure(treasurelist *t , int difficulty ) ;
#line 30 "../include/sockproto.h"
void esrv_send_item(object *ob , object *obx ) ;
#line 102
extern void esrv_remove_spell(player *pl , object *spell ) ;
#line 104
extern void esrv_add_spells(player *pl , object *spell ) ;
#line 119
extern void play_sound_map(sint8 sound_type , object *emitter , int dir , char const   *action ) ;
#line 27 "../include/sproto.h"
int transport_can_hold(object const   *transport , object const   *op , int nrof ) ;
#line 28
int should_director_abort(object const   *op , object const   *victim ) ;
#line 30
int set_object_face_main(object *op ) ;
#line 31
int apply_container(object *op , object *sack ) ;
#line 34
int apply_manual(object *op , object *tmp , int aflag ) ;
#line 35
int apply_by_living(object *pl , object *op , int aflag , int quiet ) ;
#line 36
void apply_by_living_below(object *pl ) ;
#line 37
int apply_can_apply_object(object const   *who , object const   *op ) ;
#line 38
int apply_check_weapon_power(object const   *who , int improves ) ;
#line 39
int apply_special(object *who , object *op , int aflags ) ;
#line 40
int apply_auto(object *op ) ;
#line 41
void apply_auto_fix(mapstruct *m ) ;
#line 42
void scroll_failure(object *op , int failure , int power ) ;
#line 43
void apply_changes_to_player(object *pl , object *change , int limit_stats ) ;
#line 44
void legacy_apply_container(object *op , object *sack ) ;
#line 52
void confuse_living(object *op , object *hitter , int dam ) ;
#line 53
void blind_living(object *op , object *hitter , int dam ) ;
#line 54
void paralyze_living(object *op , int dam ) ;
#line 403
extern void give_initial_items(object *pl , treasurelist *items ) ;
#line 421
extern object *find_key(object *pl , object *container , object *door ) ;
#line 439
extern void player_unready_range_ob(player *pl , object *ob ) ;
#line 443
int execute_event(object *op , int eventcode , object *activator , object *third ,
                  char const   *message , int fix ) ;
#line 509
extern int change_skill(object *who , object *new_skill , int flag ) ;
#line 510
extern void clear_skill(object *who ) ;
#line 543
extern int cast_wonder(object *op , object *caster , int dir , object *spell_ob ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
static int apply_check_apply_restrictions(object *who , object *op , int aflags ) ;
#line 50
static int apply_check_personalized_blessings(object *who , object const   *op ) ;
#line 51
static int apply_check_item_power(object const   *who , object const   *op , int aflags ) ;
#line 52
static int apply_check_owner(object const   *who , object const   *op , int aflags ) ;
#line 53
static void apply_update_ranged_skill(object const   *who , object *op , int aflags ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
int transport_can_hold(object const   *transport , object const   *op , int nrof ) 
{ 


  {
#line 71
  return (op->weight * (sint32 const   )nrof + transport->carrying <= transport->weight_limit);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
int should_director_abort(object const   *op , object const   *victim ) 
{ 
  int arch_flag ;
  int name_flag ;
  int race_flag ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 88
  if ((int const   )victim->type == 23) {
#line 89
    return (1);
  }
#line 101
  if (op->subtype) {
#line 102
    arch_flag = (int )((int const   )op->subtype & 1);
#line 103
    name_flag = (int )((int const   )op->subtype & 2);
#line 104
    race_flag = (int )((int const   )op->subtype & 4);
  } else {
#line 106
    arch_flag = 1;
#line 107
    name_flag = 1;
#line 108
    race_flag = 1;
  }
#line 113
  if (op->race) {
#line 113
    if (victim->arch) {
#line 113
      if (arch_flag) {
#line 113
        if ((victim->arch)->name) {
          {
#line 113
          tmp = strcmp((char const   *)op->race, (victim->arch)->name);
          }
#line 113
          if (tmp) {
            _L___0: /* CIL Label */ 
#line 113
            if (victim->name) {
#line 113
              if (name_flag) {
                {
#line 113
                tmp___0 = strcmp((char const   *)op->race, (char const   *)victim->name);
                }
#line 113
                if (tmp___0) {
                  _L: /* CIL Label */ 
#line 113
                  if (victim->race) {
#line 113
                    if (race_flag) {
                      {
#line 113
                      tmp___1 = strcmp((char const   *)op->race, (char const   *)victim->race);
                      }
#line 113
                      if (tmp___1) {
#line 117
                        return (1);
                      }
                    } else {
#line 117
                      return (1);
                    }
                  } else {
#line 117
                    return (1);
                  }
                }
              } else {
#line 113
                goto _L;
              }
            } else {
#line 113
              goto _L;
            }
          }
        } else {
#line 113
          goto _L___0;
        }
      } else {
#line 113
        goto _L___0;
      }
    } else {
#line 113
      goto _L___0;
    }
  }
#line 122
  if (op->slaying) {
#line 122
    if (victim->arch) {
#line 122
      if (arch_flag) {
#line 122
        if ((victim->arch)->name) {
          {
#line 122
          tmp___2 = strcmp((char const   *)op->slaying, (victim->arch)->name);
          }
#line 122
          if (tmp___2) {
#line 122
            goto _L___5;
          } else {
#line 126
            return (1);
          }
        } else {
#line 122
          goto _L___5;
        }
      } else {
#line 122
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 122
    if (victim->name) {
#line 122
      if (name_flag) {
        {
#line 122
        tmp___3 = strcmp((char const   *)op->slaying, (char const   *)victim->name);
        }
#line 122
        if (tmp___3) {
#line 122
          goto _L___2;
        } else {
#line 126
          return (1);
        }
      } else {
#line 122
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 122
    if (victim->race) {
#line 122
      if (race_flag) {
        {
#line 122
        tmp___4 = strcmp((char const   *)op->slaying, (char const   *)victim->race);
        }
#line 122
        if (! tmp___4) {
#line 126
          return (1);
        }
      }
    }
  }
#line 128
  return (0);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
void apply_handle_yield(object *tmp ) 
{ 
  char const   *yield ;
  object *drop___0 ;
  object *tmp___0 ;

  {
  {
#line 144
  yield = object_get_value((object const   *)tmp, (char const   */* const  */)"on_use_yield");
  }
#line 145
  if ((unsigned long )yield != (unsigned long )((void *)0)) {
    {
#line 146
    tmp___0 = create_archetype(yield);
#line 146
    drop___0 = tmp___0;
    }
#line 147
    if (tmp->env) {
      {
#line 148
      drop___0 = object_insert_in_ob(drop___0, tmp->env);
      }
    } else {
      {
#line 150
      object_insert_in_map_at(drop___0, tmp->map, tmp, 16, (int )tmp->x, (int )tmp->y);
      }
    }
  }
#line 152
  return;
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
int set_object_face_main(object *op ) 
{ 
  int newface ;
  sstring saved ;
  char const   *tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 166
  newface = (int )((op->arch)->clone.face)->number;
#line 167
  tmp = object_get_value((object const   *)op, (char const   */* const  */)"face_closed");
#line 167
  saved = tmp;
  }
#line 169
  if (saved) {
    {
#line 170
    tmp___0 = find_face(saved, (unsigned int )newface);
#line 170
    newface = (int )tmp___0;
    }
  }
#line 171
  if (newface) {
#line 171
    if ((unsigned long )op->face != (unsigned long )(new_faces + newface)) {
#line 172
      op->face = (New_Face const   *)(new_faces + newface);
#line 173
      return (1);
    }
  }
#line 175
  return (0);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
static int set_object_face_other(object *op ) 
{ 
  sstring custom ;
  int newface ;
  unsigned int tmp ;

  {
#line 191
  newface = 0;
#line 193
  if (op->face) {
#line 193
    if (op->other_arch) {
#line 193
      if ((op->other_arch)->clone.face) {
#line 194
        newface = (int )((op->other_arch)->clone.face)->number;
      }
    }
  }
#line 196
  if ((unsigned long )op->face != (unsigned long )(op->arch)->clone.face) {
    {
#line 198
    object_set_value(op, "face_closed", (char const   *)(op->face)->name, 1);
    }
  }
  {
#line 201
  custom = object_get_value((object const   *)op, (char const   */* const  */)"face_opened");
  }
#line 202
  if (custom) {
    {
#line 203
    tmp = find_face(custom, (unsigned int )newface);
#line 203
    newface = (int )tmp;
    }
  }
#line 204
  if (newface) {
#line 204
    if ((int const   )(op->face)->number != (int const   )newface) {
#line 205
      op->face = (New_Face const   *)(new_faces + newface);
#line 206
      return (1);
    }
  }
#line 208
  return (0);
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
int apply_container(object *op , object *sack ) 
{ 
  char name_sack[256] ;
  char name_tmp[256] ;
  object *tmp ;
  char const   *tmp___0 ;
  tag_t tmp_tag ;
  int tmp___1 ;
  int tmp___2 ;
  object *left ;
  object *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  object *left___0 ;

  {
#line 234
  tmp = op->container;
#line 236
  if ((int )op->type != 1) {
#line 237
    return (0);
  }
#line 239
  if ((unsigned long )sack == (unsigned long )((void *)0)) {
#line 239
    goto _L;
  } else
#line 239
  if ((int )sack->type != 122) {
    _L: /* CIL Label */ 
#line 240
    if (sack) {
#line 240
      tmp___0 = sack->name;
    } else {
#line 240
      tmp___0 = "NULL";
    }
    {
#line 240
    LOG((LogLevel )0, "apply_container: %s is not container!\n", tmp___0);
    }
#line 241
    return (0);
  }
#line 249
  if (op->container) {
#line 249
    if (sack->flags[0] & (1U << 5)) {
#line 250
      tmp_tag = (op->container)->count;
#line 252
      if ((unsigned long )(op->container)->env != (unsigned long )op) {
#line 253
        (op->container)->move_off = (MoveType )0;
      }
      {
#line 257
      query_name((object const   *)op->container, name_tmp, (size_t )256);
#line 260
      tmp___1 = execute_event(tmp, 11, op, (object *)((void *)0), (char const   *)((void *)0),
                              1);
      }
#line 260
      if (tmp___1 != 0) {
#line 261
        return (1);
      }
      {
#line 263
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )13, (uint8 )2, "You close %s.",
                           name_tmp);
#line 268
      op->container = (struct obj *)((void *)0);
      }
#line 269
      if ((unsigned long )op->contr != (unsigned long )((void *)0)) {
#line 270
        (op->contr)->socket.container_position = (uint16 )0;
      }
#line 273
      if (! (tmp->count != tmp_tag)) {
#line 273
        if (! (tmp->flags[0] & (1U << 3))) {
          {
#line 274
          tmp->flags[0] &= ~ (1U << 5);
#line 275
          tmp___2 = set_object_face_main(tmp);
          }
#line 275
          if (tmp___2) {
            {
#line 276
            esrv_update_item(10, op, tmp);
            }
          } else {
            {
#line 278
            esrv_update_item(2, op, tmp);
            }
          }
        }
      }
#line 280
      if ((unsigned long )tmp == (unsigned long )sack) {
#line 281
        return (1);
      }
    }
  }
  {
#line 284
  query_name((object const   *)sack, name_sack, (size_t )256);
  }
#line 291
  if (sack->slaying) {
    {
#line 292
    tmp = find_key(op, op, sack);
    }
#line 293
    if (tmp) {
      {
#line 294
      query_name((object const   *)tmp, name_tmp, (size_t )256);
#line 295
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )13, (uint8 )3, "You unlock %s with %s.",
                           name_sack, name_tmp);
      }
    } else {
      {
#line 300
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )13, (uint8 )1, "You don\'t have the key to unlock %s.",
                           name_sack);
      }
#line 304
      return (0);
    }
  }
#line 320
  if ((unsigned long )sack->env != (unsigned long )op) {
#line 326
    if (sack->env) {
      {
#line 327
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )13, (uint8 )1, "You can\'t open %s",
                           name_sack);
      }
#line 330
      return (0);
    }
#line 333
    if (sack->nrof > 1U) {
      {
#line 334
      tmp___3 = object_split(sack, sack->nrof - 1U, (char *)((void *)0), (size_t )0);
#line 334
      left = tmp___3;
#line 336
      object_insert_in_map_at(left, sack->map, (object *)((void *)0), 1, (int )sack->x,
                              (int )sack->y);
#line 338
      query_name((object const   *)sack, name_sack, (size_t )256);
      }
    }
    {
#line 342
    sack->move_off = (MoveType )31;
#line 344
    sack->flags[0] &= ~ (1U << 5);
#line 345
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )13, (uint8 )3, "You open %s.",
                         name_sack);
#line 348
    sack->flags[0] |= 1U << 5;
#line 349
    op->container = sack;
    }
#line 350
    if ((unsigned long )op->contr != (unsigned long )((void *)0)) {
#line 351
      (op->contr)->socket.container_position = (uint16 )0;
    }
    {
#line 353
    tmp___4 = set_object_face_other(sack);
    }
#line 353
    if (tmp___4) {
      {
#line 354
      esrv_update_item(10, op, sack);
      }
    } else {
      {
#line 356
      esrv_update_item(2, op, sack);
      }
    }
    {
#line 357
    esrv_send_inventory(op, sack);
    }
  } else
#line 359
  if (sack->flags[0] & (1U << 5)) {
    {
#line 360
    sack->flags[0] &= ~ (1U << 5);
#line 361
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )13, (uint8 )3, "You open %s.",
                         name_sack);
#line 364
    sack->flags[0] |= 1U << 5;
#line 365
    op->container = sack;
    }
#line 366
    if ((unsigned long )op->contr != (unsigned long )((void *)0)) {
#line 367
      (op->contr)->socket.container_position = (uint16 )0;
    }
    {
#line 369
    tmp___5 = set_object_face_other(sack);
    }
#line 369
    if (tmp___5) {
      {
#line 370
      esrv_update_item(10, op, sack);
      }
    } else {
      {
#line 372
      esrv_update_item(2, op, sack);
      }
    }
    {
#line 373
    esrv_send_inventory(op, sack);
    }
  } else {
#line 375
    left___0 = (object *)((void *)0);
#line 377
    if (sack->nrof > 1U) {
      {
#line 378
      left___0 = object_split(sack, sack->nrof - 1U, (char *)((void *)0), (size_t )1);
      }
    }
    {
#line 380
    sack->flags[0] &= ~ (1U << 5);
#line 381
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )13, (uint8 )3, "You readied %s.",
                         name_sack);
#line 384
    sack->flags[0] |= 1U << 5;
#line 385
    esrv_update_item(2, op, sack);
    }
#line 387
    if (left___0) {
      {
#line 388
      object_insert_in_ob(left___0, sack->env);
#line 389
      esrv_send_item(op, left___0);
      }
    }
  }
#line 393
  return (1);
}
}
#line 407 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
void do_learn_spell(object *op , object *spell , int special_prayer ) 
{ 
  object *tmp ;

  {
#line 410
  if ((int )op->type != 1) {
    {
#line 411
    LOG((LogLevel )0, "BUG: do_learn_spell(): not a player\n");
    }
#line 412
    return;
  }
  {
#line 416
  tmp = check_spell_known(op, spell->name);
  }
#line 417
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 418
    if (special_prayer) {
#line 418
      if (! (tmp->flags[1] & (1U << 2))) {
        {
#line 419
        LOG((LogLevel )0, "BUG: do_learn_spell(): spell already known, but not marked as startequip\n");
        }
#line 420
        return;
      }
    }
#line 422
    return;
  }
  {
#line 425
  play_sound_player_only(op->contr, (sint8 )2, spell, 0, "learn");
#line 426
  tmp = object_new();
#line 427
  object_copy((object const   *)spell, tmp);
#line 428
  object_insert_in_ob(tmp, op);
  }
#line 430
  if (special_prayer) {
#line 431
    tmp->flags[1] |= 1U << 2;
  }
  {
#line 433
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )13, (uint8 )3, "Type \'bind cast %s to store the spell in a key.",
                       spell->name);
#line 437
  esrv_add_spells(op->contr, tmp);
  }
#line 438
  return;
}
}
#line 448 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
void do_forget_spell(object *op , char const   *spell ) 
{ 
  object *spob ;

  {
#line 451
  if ((int )op->type != 1) {
    {
#line 452
    LOG((LogLevel )0, "BUG: do_forget_spell(): not a player\n");
    }
#line 453
    return;
  }
  {
#line 455
  spob = check_spell_known(op, spell);
  }
#line 456
  if ((unsigned long )spob == (unsigned long )((void *)0)) {
    {
#line 457
    LOG((LogLevel )0, "BUG: do_forget_spell(): spell not known\n");
    }
#line 458
    return;
  }
  {
#line 461
  draw_ext_info_format(258, 0, (object const   *)op, (uint8 )13, (uint8 )5, "You lose knowledge of %s.",
                       spell);
#line 464
  player_unready_range_ob(op->contr, spob);
#line 465
  esrv_remove_spell(op->contr, spob);
#line 466
  object_remove(spob);
#line 467
  object_free2(spob, 0);
  }
#line 468
  return;
}
}
#line 483 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
static int apply_check_race_restrictions(object *who , object *item ) 
{ 
  char buf[256] ;
  sstring restriction ;
  char *tmp ;

  {
#line 487
  if ((int )who->type != 1) {
#line 488
    return (1);
  } else
#line 487
  if (who->flags[0] & (1U << 1)) {
#line 488
    return (1);
  }
  {
#line 490
  restriction = object_get_value((object const   *)item, (char const   */* const  */)"race_restriction");
  }
#line 491
  if (! restriction) {
#line 492
    return (1);
  }
  {
#line 494
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)":%s:",
           who->race);
#line 495
  buf[sizeof(buf) - 1UL] = (char )'\000';
#line 497
  tmp = strstr(restriction, (char const   *)(buf));
  }
#line 497
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 498
    return (1);
  }
  {
#line 500
  query_name((object const   *)item, buf, sizeof(buf));
#line 501
  draw_ext_info_format(256, 0, (object const   *)who, (uint8 )13, (uint8 )8, "Somehow you can\'t seem to use the %s.",
                       buf);
  }
#line 503
  return (0);
}
}
#line 526 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
int apply_manual(object *op , object *tmp , int aflag ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  method_ret tmp___2 ;

  {
#line 527
  if ((unsigned long )tmp->head != (unsigned long )((void *)0)) {
#line 527
    tmp = tmp->head;
  } else {
#line 527
    tmp = tmp;
  }
#line 529
  if (tmp->flags[0] & (1U << 6)) {
#line 529
    if (! (tmp->flags[0] & (1U << 5))) {
#line 530
      if ((int )op->type == 1) {
        {
#line 531
        draw_ext_info(256, 0, (object const   *)op, (uint8 )13, (uint8 )1, "You should pay for it first.");
        }
#line 533
        return (3);
      }
#line 535
      return (0);
    }
  }
  {
#line 538
  tmp___0 = apply_check_race_restrictions(op, tmp);
  }
#line 538
  if (! tmp___0) {
#line 539
    return (3);
  }
  {
#line 542
  tmp___1 = execute_event(tmp, 1, op, (object *)((void *)0), (char const   *)((void *)0),
                          1);
  }
#line 542
  if (tmp___1 != 0) {
#line 543
    return (0);
  }
#line 545
  if (op->contr) {
    {
#line 546
    play_sound_player_only(op->contr, (sint8 )3, tmp, 0, "apply");
    }
  }
  {
#line 548
  tmp___2 = ob_apply(tmp, op, aflag);
  }
#line 548
  return ((int )tmp___2);
}
}
#line 573 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
int apply_by_living(object *pl , object *op , int aflag , int quiet ) 
{ 
  int tmp ;
  char name[256] ;

  {
#line 576
  if ((unsigned long )op->env == (unsigned long )((void *)0)) {
#line 576
    if ((int )pl->move_type & 6) {
#line 578
      if (! (pl->flags[0] & (1U << 1))) {
#line 578
        if (! ((int )op->move_type & 6)) {
          {
#line 579
          draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )1, "But you are floating high above the ground!");
          }
#line 581
          return (0);
        }
      }
    }
  }
#line 588
  if ((int )op->type != 1) {
#line 588
    if (op->flags[0] & (1U << 4)) {
#line 588
      if (! (pl->flags[0] & (1U << 4))) {
        {
#line 591
        play_sound_map((sint8 )3, op, 0, "evaporate");
#line 592
        draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )1, "The object disappears in a puff of smoke!");
#line 594
        draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )1, "It must have been an illusion.");
#line 596
        object_remove(op);
#line 597
        object_free2(op, 0);
        }
#line 598
        return (1);
      }
    }
  }
  {
#line 601
  (pl->contr)->last_used = op;
#line 602
  (pl->contr)->last_used_id = op->count;
#line 604
  tmp = apply_manual(pl, op, aflag);
  }
#line 605
  if (! quiet) {
#line 606
    if (tmp == 1) {
      {
#line 609
      query_name((object const   *)op, name, (size_t )256);
#line 610
      draw_ext_info_format(256, 0, (object const   *)pl, (uint8 )13, (uint8 )1, "I don\'t know how to apply the %s.",
                           name);
      }
    } else
#line 613
    if (tmp == 2) {
      {
#line 614
      draw_ext_info_format(256, 0, (object const   *)pl, (uint8 )13, (uint8 )1, "You must get it first!\n");
      }
    } else
#line 616
    if (tmp == 3) {
#line 617
      return (tmp);
    }
  }
#line 619
  if (tmp == 0) {
#line 620
    if ((unsigned long )op->anim_suffix != (unsigned long )((void *)0)) {
      {
#line 621
      apply_anim_suffix(pl, op->anim_suffix);
      }
    }
  }
#line 623
  return (tmp);
}
}
#line 637 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
void apply_by_living_below(object *pl ) 
{ 
  object *tmp ;
  int floors ;
  object *next658 ;
  tag_t next_tag658 ;
  tag_t tmp___0 ;
  int tmp___1 ;

  {
#line 641
  if ((pl->contr)->transport) {
#line 641
    if ((int )((pl->contr)->transport)->type == 2) {
      {
#line 642
      ob_apply((pl->contr)->transport, pl, 0);
      }
#line 643
      return;
    }
  }
#line 649
  if ((unsigned long )pl->container != (unsigned long )((void *)0)) {
#line 649
    tmp = (pl->container)->inv;
  } else {
#line 649
    tmp = pl->below;
  }
#line 657
  floors = 0;
  {
#line 658
  while (1) {
    while_continue: /* CIL Label */ ;
#line 658
    next658 = tmp;
#line 658
    if ((unsigned long )next658 == (unsigned long )((void *)0)) {
#line 658
      tmp___0 = (tag_t )0;
    } else {
#line 658
      tmp___0 = next658->count;
    }
#line 658
    next_tag658 = tmp___0;
    {
#line 658
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 658
      tmp = next658;
#line 658
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 658
        goto while_break___0;
      }
#line 658
      if (next658->count != next_tag658) {
#line 658
        goto while_break___0;
      } else
#line 658
      if (next658->flags[0] & (1U << 3)) {
#line 658
        goto while_break___0;
      }
#line 658
      next658 = next658->below;
#line 658
      if ((unsigned long )next658 == (unsigned long )((void *)0)) {
#line 658
        next_tag658 = (tag_t )0;
      } else {
#line 658
        next_tag658 = next658->count;
      }
#line 659
      if (tmp->flags[1] & (1U << 31)) {
#line 660
        floors ++;
      } else
#line 661
      if (floors > 0) {
#line 662
        return;
      }
#line 669
      if (! tmp->invisible) {
#line 669
        goto _L;
      } else
#line 669
      if ((int )tmp->move_on & (int )pl->move_type) {
        _L: /* CIL Label */ 
        {
#line 670
        tmp___1 = apply_by_living(pl, tmp, 0, 1);
        }
#line 670
        if (tmp___1 == 0) {
#line 671
          return;
        }
      }
#line 673
      if (floors >= 2) {
#line 674
        return;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 658
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 676
  return;
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
static int unapply_special(object *who , object *op , int aflags ) 
{ 
  char name[256] ;
  object *tmp ;

  {
#line 696
  if ((int )op->type != 82) {
#line 697
    op->flags[0] &= ~ (1U << 5);
  }
  {
#line 698
  query_name((object const   *)op, name, (size_t )256);
  }
  {
#line 700
  if ((int )op->type == 15) {
#line 700
    goto case_15;
  }
#line 712
  if ((int )op->type == 74) {
#line 712
    goto case_74;
  }
#line 712
  if ((int )op->type == 43) {
#line 712
    goto case_74;
  }
#line 744
  if ((int )op->type == 87) {
#line 744
    goto case_87;
  }
#line 744
  if ((int )op->type == 104) {
#line 744
    goto case_87;
  }
#line 744
  if ((int )op->type == 113) {
#line 744
    goto case_87;
  }
#line 744
  if ((int )op->type == 39) {
#line 744
    goto case_87;
  }
#line 744
  if ((int )op->type == 100) {
#line 744
    goto case_87;
  }
#line 744
  if ((int )op->type == 99) {
#line 744
    goto case_87;
  }
#line 744
  if ((int )op->type == 70) {
#line 744
    goto case_87;
  }
#line 744
  if ((int )op->type == 33) {
#line 744
    goto case_87;
  }
#line 744
  if ((int )op->type == 34) {
#line 744
    goto case_87;
  }
#line 744
  if ((int )op->type == 16) {
#line 744
    goto case_87;
  }
#line 754
  if ((int )op->type == 3) {
#line 754
    goto case_3;
  }
#line 754
  if ((int )op->type == 109) {
#line 754
    goto case_3;
  }
#line 754
  if ((int )op->type == 14) {
#line 754
    goto case_3;
  }
#line 768
  if ((int )op->type == 160) {
#line 768
    goto case_160;
  }
#line 777
  goto switch_default;
  case_15: /* CIL Label */ 
#line 701
  if (! (aflags & 128)) {
    {
#line 702
    draw_ext_info_format(256, 0, (object const   *)who, (uint8 )13, (uint8 )2, "You unwield %s.",
                         name);
    }
  }
  {
#line 705
  change_abil(who, op);
#line 706
  who->flags[2] &= ~ (1U << 26);
#line 707
  who->current_weapon = (struct obj *)((void *)0);
#line 708
  clear_skill(who);
  }
#line 709
  goto switch_break;
  case_74: /* CIL Label */ 
  case_43: /* CIL Label */ 
#line 713
  if ((unsigned long )op != (unsigned long )who->chosen_skill) {
    {
#line 714
    LOG((LogLevel )0, "BUG: unapply_special(): applied skill is not a chosen skill\n");
    }
  }
#line 715
  if ((int )who->type == 1) {
#line 716
    if ((int )(who->contr)->shoottype == 5) {
#line 717
      (who->contr)->shoottype = (rangetype )0;
    }
#line 718
    if (! op->invisible) {
#line 719
      if (! (aflags & 128)) {
        {
#line 720
        draw_ext_info_format(256, 0, (object const   *)who, (uint8 )13, (uint8 )2,
                             "You stop using the %s.", name);
        }
      }
    } else
#line 724
    if (! (aflags & 128)) {
      {
#line 725
      draw_ext_info_format(256, 0, (object const   *)who, (uint8 )13, (uint8 )2, "You can no longer use the skill: %s.",
                           op->skill);
      }
    }
  }
  {
#line 730
  change_abil(who, op);
#line 731
  who->chosen_skill = (struct obj *)((void *)0);
#line 732
  who->flags[2] &= ~ (1U << 25);
  }
#line 733
  goto switch_break;
  case_87: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_16: /* CIL Label */ 
#line 745
  if (! (aflags & 128)) {
    {
#line 746
    draw_ext_info_format(256, 0, (object const   *)who, (uint8 )13, (uint8 )2, "You unwear %s.",
                         name);
    }
  }
  {
#line 749
  change_abil(who, op);
  }
#line 750
  goto switch_break;
  case_3: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_14: /* CIL Label */ 
  {
#line 755
  clear_skill(who);
  }
#line 756
  if (! (aflags & 128)) {
    {
#line 757
    draw_ext_info_format(256, 0, (object const   *)who, (uint8 )13, (uint8 )2, "You unready %s.",
                         name);
    }
  }
#line 760
  if ((int )who->type == 1) {
#line 761
    (who->contr)->shoottype = (rangetype )0;
  } else
#line 762
  if ((int )op->type == 14) {
#line 763
    who->flags[1] &= ~ (1U << 28);
  } else {
#line 765
    who->flags[1] &= ~ (1U << 27);
  }
#line 766
  goto switch_break;
  case_160: /* CIL Label */ 
#line 769
  if (! (aflags & 128)) {
    {
#line 770
    draw_ext_info_format(256, 0, (object const   *)who, (uint8 )13, (uint8 )2, "You unready %s.",
                         name);
    }
  }
#line 773
  (who->contr)->shoottype = (rangetype )0;
#line 774
  (who->contr)->ranges[6] = (object *)((void *)0);
#line 775
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 778
  if (! (aflags & 128)) {
    {
#line 779
    draw_ext_info_format(256, 0, (object const   *)who, (uint8 )13, (uint8 )2, "You unapply %s.",
                         name);
    }
  }
#line 782
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 785
  fix_object(who);
  }
#line 787
  if (! (aflags & 16)) {
    {
#line 790
    tmp = object_merge(op, (object *)((void *)0));
    }
#line 791
    if ((int )who->type == 1) {
#line 792
      if (tmp) {
#line 793
        op = tmp;
      }
      {
#line 795
      esrv_update_item(2, who, op);
      }
    }
  }
#line 798
  return (0);
}
}
#line 820 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
static object *get_item_from_body_location(object *start , int loc ) 
{ 
  object *tmp ;
  object *next827 ;
  tag_t next_tag827 ;
  tag_t tmp___0 ;

  {
#line 823
  if (! start) {
#line 824
    return ((object *)((void *)0));
  }
#line 826
  tmp = start;
  {
#line 827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 827
    next827 = tmp;
#line 827
    if ((unsigned long )next827 == (unsigned long )((void *)0)) {
#line 827
      tmp___0 = (tag_t )0;
    } else {
#line 827
      tmp___0 = next827->count;
    }
#line 827
    next_tag827 = tmp___0;
    {
#line 827
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 827
      tmp = next827;
#line 827
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 827
        goto while_break___0;
      }
#line 827
      if (next827->count != next_tag827) {
#line 827
        goto while_break___0;
      } else
#line 827
      if (next827->flags[0] & (1U << 3)) {
#line 827
        goto while_break___0;
      }
#line 827
      next827 = next827->below;
#line 827
      if ((unsigned long )next827 == (unsigned long )((void *)0)) {
#line 827
        next_tag827 = (tag_t )0;
      } else {
#line 827
        next_tag827 = next827->count;
      }
#line 828
      if (tmp->flags[0] & (1U << 5)) {
#line 828
        if (tmp->body_info[loc]) {
#line 828
          if (! tmp->invisible) {
#line 831
            return (tmp);
          } else
#line 828
          if ((int )tmp->type == 43) {
#line 831
            return (tmp);
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 827
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 833
  return ((object *)((void *)0));
}
}
#line 857 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
static int unapply_for_ob(object *who , object *op , int aflags ) 
{ 
  int i ;
  object *tmp ;
  object *last ;
  char name[256] ;
  object *tmp___0 ;
  object *next866 ;
  tag_t next_tag866 ;
  tag_t tmp___1 ;

  {
#line 859
  tmp = (object *)((void *)0);
#line 865
  if ((int )op->type == 15) {
#line 865
    goto _L___0;
  } else
#line 865
  if ((int )op->type == 33) {
    _L___0: /* CIL Label */ 
    {
#line 866
    while (1) {
      while_continue: /* CIL Label */ ;
#line 866
      tmp___0 = who->inv;
      {
#line 866
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 866
        next866 = tmp___0;
#line 866
        if ((unsigned long )next866 == (unsigned long )((void *)0)) {
#line 866
          tmp___1 = (tag_t )0;
        } else {
#line 866
          tmp___1 = next866->count;
        }
#line 866
        next_tag866 = tmp___1;
        {
#line 866
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 866
          tmp___0 = next866;
#line 866
          if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 866
            goto while_break___1;
          }
#line 866
          if (next866->count != next_tag866) {
#line 866
            goto while_break___1;
          } else
#line 866
          if (next866->flags[0] & (1U << 3)) {
#line 866
            goto while_break___1;
          }
#line 866
          next866 = next866->below;
#line 866
          if ((unsigned long )next866 == (unsigned long )((void *)0)) {
#line 866
            next_tag866 = (tag_t )0;
          } else {
#line 866
            next_tag866 = next866->count;
          }
#line 867
          if (tmp___0->flags[0] & (1U << 5)) {
#line 867
            if ((int )tmp___0->type == (int )op->type) {
#line 868
              if (! (aflags & 32)) {
#line 868
                if (! (aflags & 64)) {
#line 868
                  if (tmp___0->flags[2] & (1U << 10)) {
#line 868
                    goto _L;
                  } else
#line 868
                  if (tmp___0->flags[2] & (1U << 11)) {
                    _L: /* CIL Label */ 
#line 876
                    if (! (aflags & 128)) {
                      {
#line 877
                      query_name((object const   *)tmp___0, name, (size_t )256);
#line 878
                      draw_ext_info_format(256, 0, (object const   *)who, (uint8 )13,
                                           (uint8 )2, "No matter how hard you try, you just can\'t remove %s.",
                                           name);
                      }
                    }
#line 882
                    return (1);
                  }
                }
              }
#line 885
              if (aflags & 64) {
                {
#line 886
                query_name((object const   *)tmp___0, name, (size_t )256);
#line 887
                draw_ext_info(256, 0, (object const   *)who, (uint8 )13, (uint8 )2,
                              (char const   *)(name));
                }
              } else {
                {
#line 890
                unapply_special(who, tmp___0, aflags);
                }
              }
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 866
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 866
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 895
  i = 0;
  {
#line 895
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 895
    if (! (i < 13)) {
#line 895
      goto while_break___2;
    }
#line 897
    if (op->body_info[i]) {
#line 898
      last = who->inv;
      {
#line 903
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 903
        if (! ((int )who->body_used[i] + (int )op->body_info[i] < 0)) {
#line 903
          goto while_break___3;
        }
        {
#line 904
        tmp = get_item_from_body_location(last, i);
        }
#line 905
        if (! tmp) {
#line 906
          return (1);
        }
#line 909
        if (aflags & 32) {
#line 909
          goto _L___1;
        } else
#line 909
        if (aflags & 64) {
#line 909
          goto _L___1;
        } else
#line 909
        if (tmp->flags[2] & (1U << 10)) {
#line 909
          goto _L___2;
        } else
#line 909
        if (tmp->flags[2] & (1U << 11)) {
          _L___2: /* CIL Label */ 
#line 924
          if (! (aflags & 128)) {
            {
#line 925
            query_name((object const   *)tmp, name, (size_t )256);
#line 926
            draw_ext_info_format(256, 0, (object const   *)who, (uint8 )13, (uint8 )2,
                                 "The %s just won\'t come off", name);
            }
          }
        } else
        _L___1: /* CIL Label */ 
#line 912
        if (aflags & 64) {
          {
#line 913
          query_name((object const   *)tmp, name, (size_t )256);
#line 914
          draw_ext_info(256, 0, (object const   *)who, (uint8 )13, (uint8 )2, (char const   *)(name));
          }
        } else {
          {
#line 917
          unapply_special(who, tmp, aflags);
          }
        }
#line 931
        last = tmp->below;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 895
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 939
  return (0);
}
}
#line 961 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
int apply_can_apply_object(object const   *who , object const   *op ) 
{ 
  int i ;
  int retval ;
  object *tmp ;
  object *ws ;
  object *tmp1 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 962
  retval = 0;
#line 963
  tmp = (object *)((void *)0);
#line 963
  ws = (object *)((void *)0);
#line 970
  if ((int const   )op->type == 15) {
#line 970
    goto _L;
  } else
#line 970
  if ((int const   )op->type == 33) {
    _L: /* CIL Label */ 
    {
#line 971
    tmp = object_find_by_type_applied(who, (int )op->type);
    }
#line 972
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 973
      retval = 16;
#line 974
      ws = tmp;
    }
  }
#line 978
  i = 0;
  {
#line 978
  while (1) {
    while_continue: /* CIL Label */ ;
#line 978
    if (! (i < 13)) {
#line 978
      goto while_break;
    }
#line 979
    if (op->body_info[i]) {
#line 981
      if ((int )op->body_info[i] < 0) {
#line 981
        tmp___1 = - ((int )op->body_info[i]);
      } else {
#line 981
        tmp___1 = (int )op->body_info[i];
      }
#line 981
      if (tmp___1 > (int )who->body_info[i]) {
#line 985
        retval |= 1;
      } else
#line 986
      if ((int )who->body_used[i] + (int )op->body_info[i] < 0) {
#line 1001
        if (ws) {
#line 1002
          if (((int )who->body_used[i] - (int )ws->body_info[i]) + (int )op->body_info[i] >= 0) {
#line 1003
            retval |= 16;
#line 1004
            goto __Cont;
          }
        }
        {
#line 1008
        tmp1 = get_item_from_body_location((object *)who->inv, i);
        }
#line 1009
        if (! tmp1) {
#line 1010
          retval |= 1;
        } else {
#line 1016
          retval |= 16;
#line 1017
          if (! tmp) {
#line 1018
            tmp = tmp1;
          } else
#line 1019
          if ((unsigned long )tmp != (unsigned long )tmp1) {
#line 1020
            retval |= 32;
          }
#line 1026
          if ((int )who->body_used[i] - (int )tmp1->body_info[i] != (int )who->body_info[i]) {
#line 1026
            if ((int )op->body_info[i] < 0) {
#line 1026
              tmp___0 = - ((int )op->body_info[i]);
            } else {
#line 1026
              tmp___0 = (int )op->body_info[i];
            }
#line 1026
            if (tmp___0 < (int )who->body_info[i]) {
#line 1028
              retval |= 64;
            }
          }
#line 1034
          if (((int )who->body_used[i] + (int )op->body_info[i]) - (int )tmp1->body_info[i] < 0) {
#line 1035
            retval |= 32;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 978
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1042
  if ((int const   )op->type == 13) {
#line 1042
    goto _L___0;
  } else
#line 1042
  if ((int const   )op->type == 14) {
#line 1042
    goto _L___0;
  } else
#line 1042
  if ((int const   )op->type == 15) {
    _L___0: /* CIL Label */ 
#line 1042
    if (! (who->flags[1] & (1U << 25))) {
#line 1043
      retval |= 2;
    }
  }
#line 1044
  if ((int const   )op->type == 33) {
#line 1044
    if (! (who->flags[0] & (1U << 7))) {
#line 1045
      retval |= 2;
    }
  }
#line 1046
  if ((int const   )op->type == 16) {
#line 1046
    goto _L___1;
  } else
#line 1046
  if ((int const   )op->type == 34) {
#line 1046
    goto _L___1;
  } else
#line 1046
  if ((int const   )op->type == 99) {
#line 1046
    goto _L___1;
  } else
#line 1046
  if ((int const   )op->type == 100) {
    _L___1: /* CIL Label */ 
#line 1046
    if (! (who->flags[1] & (1U << 24))) {
#line 1047
      retval |= 2;
    }
  }
#line 1049
  if ((int const   )who->type != 1) {
#line 1050
    if ((int const   )op->type == 109) {
#line 1050
      goto _L___2;
    } else
#line 1050
    if ((int const   )op->type == 3) {
      _L___2: /* CIL Label */ 
#line 1050
      if (! (who->flags[1] & (1U << 22))) {
#line 1052
        retval |= 2;
      }
    }
#line 1053
    if ((int const   )op->type == 14) {
#line 1053
      if (! (who->flags[1] & (1U << 23))) {
#line 1054
        retval |= 2;
      }
    }
#line 1055
    if ((int const   )op->type == 70) {
#line 1055
      if (! (who->flags[1] & (1U << 26))) {
#line 1056
        retval |= 2;
      }
    }
  }
#line 1058
  return (retval);
}
}
#line 1076 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
int apply_check_weapon_power(object const   *who , int improves ) 
{ 


  {
#line 1077
  return ((int const   )who->level / 5 + 5 >= (int const   )improves);
}
}
#line 1101 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
int apply_special(object *who , object *op , int aflags ) 
{ 
  int basic_flag ;
  object *tmp ;
  object *skop ;
  char name_op[256] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  object *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
#line 1102
  basic_flag = aflags & 15;
#line 1106
  if ((unsigned long )who == (unsigned long )((void *)0)) {
    {
#line 1107
    LOG((LogLevel )0, "apply_special() from object without environment.\n");
    }
#line 1108
    return (1);
  }
#line 1111
  if ((unsigned long )op->env != (unsigned long )who) {
#line 1112
    return (1);
  }
#line 1115
  if (op->flags[0] & (1U << 5)) {
#line 1117
    if (basic_flag == 1) {
#line 1118
      return (0);
    }
#line 1120
    if (! (aflags & 32)) {
#line 1120
      if (op->flags[2] & (1U << 10)) {
#line 1120
        goto _L;
      } else
#line 1120
      if (op->flags[2] & (1U << 11)) {
        _L: /* CIL Label */ 
#line 1122
        if (! (aflags & 128)) {
          {
#line 1123
          query_name((object const   *)op, name_op, (size_t )256);
#line 1124
          draw_ext_info_format(256, 0, (object const   *)who, (uint8 )13, (uint8 )2,
                               "No matter how hard you try, you just can\'t remove %s.",
                               name_op);
          }
        }
#line 1128
        return (1);
      }
    }
    {
#line 1130
    tmp___0 = unapply_special(who, op, aflags);
    }
#line 1130
    return (tmp___0);
  }
#line 1133
  if (basic_flag == 2) {
#line 1134
    return (0);
  }
  {
#line 1136
  tmp___1 = apply_check_apply_restrictions(who, op, aflags);
  }
#line 1136
  if (! tmp___1) {
#line 1137
    return (1);
  }
#line 1139
  if (op->skill) {
#line 1139
    if ((int )op->type != 43) {
#line 1139
      if ((int )op->type != 74) {
        {
#line 1140
        skop = find_skill_by_name(who, op->skill);
        }
#line 1141
        if (! skop) {
#line 1142
          if (! (aflags & 128)) {
            {
#line 1143
            draw_ext_info_format(256, 0, (object const   *)who, (uint8 )13, (uint8 )1,
                                 "You need the %s skill to use this item!", op->skill);
            }
          }
#line 1146
          if ((int )who->type == 1) {
#line 1147
            return (1);
          }
        } else {
          {
#line 1154
          change_skill(who, skop, aflags & 128);
          }
        }
      } else {
#line 1156
        skop = (object *)((void *)0);
      }
    } else {
#line 1156
      skop = (object *)((void *)0);
    }
  } else {
#line 1156
    skop = (object *)((void *)0);
  }
  {
#line 1158
  tmp___2 = apply_check_item_power((object const   *)who, (object const   *)op, aflags);
  }
#line 1158
  if (! tmp___2) {
#line 1159
    return (1);
  }
  {
#line 1161
  tmp___3 = apply_check_personalized_blessings(who, (object const   *)op);
  }
#line 1161
  if (! tmp___3) {
#line 1162
    return (1);
  }
#line 1169
  if (op->nrof <= 1U) {
#line 1169
    tmp = (object *)((void *)0);
  } else {
    {
#line 1169
    tmp___4 = object_split(op, op->nrof - 1U, (char *)((void *)0), (size_t )0);
#line 1169
    tmp = tmp___4;
    }
  }
  {
#line 1172
  if ((int )op->type == 15) {
#line 1172
    goto case_15;
  }
#line 1213
  if ((int )op->type == 39) {
#line 1213
    goto case_39;
  }
#line 1213
  if ((int )op->type == 70) {
#line 1213
    goto case_39;
  }
#line 1213
  if ((int )op->type == 87) {
#line 1213
    goto case_39;
  }
#line 1213
  if ((int )op->type == 104) {
#line 1213
    goto case_39;
  }
#line 1213
  if ((int )op->type == 113) {
#line 1213
    goto case_39;
  }
#line 1213
  if ((int )op->type == 100) {
#line 1213
    goto case_39;
  }
#line 1213
  if ((int )op->type == 99) {
#line 1213
    goto case_39;
  }
#line 1213
  if ((int )op->type == 33) {
#line 1213
    goto case_39;
  }
#line 1213
  if ((int )op->type == 34) {
#line 1213
    goto case_39;
  }
#line 1213
  if ((int )op->type == 16) {
#line 1213
    goto case_39;
  }
#line 1226
  if ((int )op->type == 74) {
#line 1226
    goto case_74;
  }
#line 1226
  if ((int )op->type == 43) {
#line 1226
    goto case_74;
  }
#line 1239
  if ((int )op->type == 14) {
#line 1239
    goto case_14;
  }
#line 1256
  if ((int )op->type == 3) {
#line 1256
    goto case_3;
  }
#line 1256
  if ((int )op->type == 109) {
#line 1256
    goto case_3;
  }
#line 1288
  if ((int )op->type == 160) {
#line 1288
    goto case_160;
  }
#line 1301
  goto switch_default;
  case_15: /* CIL Label */ 
  {
#line 1173
  tmp___5 = apply_check_weapon_power((object const   *)who, op->last_eat);
  }
#line 1173
  if (! tmp___5) {
#line 1174
    if (! (aflags & 128)) {
      {
#line 1175
      draw_ext_info(256, 0, (object const   *)who, (uint8 )13, (uint8 )1, "That weapon is too powerful for you to use.  It would consume your soul!");
      }
    }
#line 1177
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      {
#line 1178
      object_insert_in_ob(tmp, who);
      }
    }
#line 1179
    return (1);
  }
  {
#line 1182
  tmp___6 = apply_check_owner((object const   *)who, (object const   *)op, aflags);
  }
#line 1182
  if (! tmp___6) {
#line 1183
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      {
#line 1184
      object_insert_in_ob(tmp, who);
      }
    }
#line 1185
    return (1);
  }
#line 1188
  op->flags[0] |= 1U << 5;
#line 1190
  if (skop) {
    {
#line 1191
    change_skill(who, skop, 1);
    }
  }
#line 1192
  who->flags[2] |= 1U << 26;
#line 1194
  if (! (aflags & 128)) {
    {
#line 1195
    query_name((object const   *)op, name_op, (size_t )256);
#line 1196
    draw_ext_info_format(256, 0, (object const   *)who, (uint8 )13, (uint8 )3, "You wield %s.",
                         name_op);
    }
  }
  {
#line 1201
  change_abil(who, op);
  }
#line 1202
  goto switch_break;
  case_39: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_16: /* CIL Label */ 
#line 1214
  op->flags[0] |= 1U << 5;
#line 1215
  if (! (aflags & 128)) {
    {
#line 1216
    query_name((object const   *)op, name_op, (size_t )256);
#line 1217
    draw_ext_info_format(256, 0, (object const   *)who, (uint8 )13, (uint8 )3, "You wear %s.",
                         name_op);
    }
  }
  {
#line 1221
  change_abil(who, op);
  }
#line 1222
  goto switch_break;
  case_74: /* CIL Label */ 
  case_43: /* CIL Label */ 
#line 1227
  if (who->chosen_skill) {
    {
#line 1228
    LOG((LogLevel )0, "BUG: apply_special(): can\'t apply two skills\n");
    }
#line 1229
    return (1);
  }
  {
#line 1232
  apply_update_ranged_skill((object const   *)who, op, aflags);
#line 1233
  op->flags[0] |= 1U << 5;
#line 1234
  change_abil(who, op);
#line 1235
  who->chosen_skill = op;
#line 1236
  who->flags[2] |= 1U << 25;
  }
#line 1237
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 1240
  tmp___7 = apply_check_weapon_power((object const   *)who, op->last_eat);
  }
#line 1240
  if (! tmp___7) {
#line 1241
    if (! (aflags & 128)) {
      {
#line 1242
      draw_ext_info(256, 0, (object const   *)who, (uint8 )13, (uint8 )1, "That weapon is too powerful for you to use.  It would consume your soul!");
      }
    }
#line 1244
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      {
#line 1245
      object_insert_in_ob(tmp, who);
      }
    }
#line 1246
    return (1);
  }
  {
#line 1249
  tmp___8 = apply_check_owner((object const   *)who, (object const   *)op, aflags);
  }
#line 1249
  if (! tmp___8) {
#line 1250
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      {
#line 1251
      object_insert_in_ob(tmp, who);
      }
    }
#line 1252
    return (1);
  }
  case_3: /* CIL Label */ 
  case_109: /* CIL Label */ 
#line 1258
  op->flags[0] |= 1U << 5;
#line 1259
  if (skop) {
    {
#line 1260
    change_skill(who, skop, 0);
    }
  }
#line 1261
  if (! (aflags & 128)) {
    {
#line 1262
    query_name((object const   *)op, name_op, (size_t )256);
#line 1263
    draw_ext_info_format(256, 0, (object const   *)who, (uint8 )13, (uint8 )3, "You ready %s.",
                         name_op);
    }
  }
#line 1267
  if ((int )who->type == 1) {
#line 1268
    if ((int )op->type == 14) {
      {
#line 1269
      change_abil(who, op);
      }
#line 1270
      if (! (aflags & 128)) {
        {
#line 1271
        query_name((object const   *)op, name_op, (size_t )256);
        }
#line 1272
        if (op->race) {
#line 1272
          tmp___9 = op->race;
        } else {
#line 1272
          tmp___9 = "nothing";
        }
        {
#line 1272
        draw_ext_info_format(256, 0, (object const   *)who, (uint8 )13, (uint8 )3,
                             "You will now fire %s with %s.", tmp___9, name_op);
        }
      }
#line 1277
      (who->contr)->shoottype = (rangetype )1;
    } else {
#line 1279
      (who->contr)->shoottype = (rangetype )3;
    }
  } else
#line 1281
  if ((int )op->type == 14) {
#line 1282
    who->flags[1] |= 1U << 28;
  } else {
#line 1284
    who->flags[1] |= 1U << 27;
  }
#line 1286
  goto switch_break;
  case_160: /* CIL Label */ 
#line 1289
  if ((who->contr)->ranges[6]) {
    {
#line 1290
    unapply_special(who, (who->contr)->ranges[6], 0);
    }
  }
#line 1291
  (who->contr)->shoottype = (rangetype )6;
#line 1292
  (who->contr)->ranges[6] = op;
#line 1293
  if (! (aflags & 128)) {
    {
#line 1294
    query_name((object const   *)op, name_op, (size_t )256);
#line 1295
    draw_ext_info_format(256, 0, (object const   *)who, (uint8 )13, (uint8 )3, "You ready your %s.",
                         name_op);
    }
  }
#line 1299
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1302
  query_name((object const   *)op, name_op, (size_t )256);
#line 1303
  draw_ext_info_format(256, 0, (object const   *)who, (uint8 )13, (uint8 )3, "You apply %s.",
                       name_op);
  }
#line 1306
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1309
  op->flags[0] |= 1U << 5;
#line 1311
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
    {
#line 1312
    tmp = object_insert_in_ob(tmp, who);
    }
  }
  {
#line 1314
  fix_object(who);
  }
#line 1320
  if ((int )who->type == 1) {
#line 1320
    if ((int )op->type != 109) {
#line 1320
      if ((int )op->type != 3) {
#line 1321
        op->flags[2] |= 1U << 16;
      }
    }
  }
#line 1323
  if (op->flags[2] & (1U << 10)) {
#line 1323
    goto _L___0;
  } else
#line 1323
  if (op->flags[2] & (1U << 11)) {
    _L___0: /* CIL Label */ 
#line 1324
    if ((int )who->type == 1) {
      {
#line 1325
      draw_ext_info(256, 0, (object const   *)who, (uint8 )13, (uint8 )5, "Oops, it feels deadly cold!");
#line 1327
      op->flags[2] |= 1U << 14;
      }
    }
  }
#line 1330
  if ((int )who->type == 1) {
    {
#line 1331
    esrv_update_item(134, who, op);
    }
  }
#line 1332
  return (0);
}
}
#line 1348 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
int apply_auto(object *op ) 
{ 
  object *tmp ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  sint16 tmp___6 ;
  object *tmp___7 ;
  object *next1387 ;
  tag_t next_tag1387 ;
  tag_t tmp___8 ;

  {
  {
#line 1352
  if ((int )op->type == 68) {
#line 1352
    goto case_68;
  }
#line 1376
  if ((int )op->type == 4) {
#line 1376
    goto case_4;
  }
#line 1351
  goto switch_break;
  case_68: /* CIL Label */ 
#line 1353
  if (op->randomitems) {
#line 1353
    if (! (! (op->flags[3] & (1U << 13)))) {
#line 1354
      return (0);
    }
  } else {
#line 1354
    return (0);
  }
  {
#line 1355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1358
    i = 10;
    {
#line 1359
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1359
      if (op->stats.exp) {
#line 1359
        tmp___1 = (int )op->stats.exp;
      } else {
#line 1359
        if ((int )(op->map)->difficulty > 5) {
#line 1359
          tmp___0 = (int )(op->map)->difficulty;
        } else {
#line 1359
          tmp___0 = 5;
        }
#line 1359
        tmp___1 = tmp___0;
      }
      {
#line 1359
      tmp = generate_treasure(op->randomitems, tmp___1);
      }
#line 1359
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1359
        i --;
#line 1359
        if (! i) {
#line 1359
          goto while_break___0;
        }
      } else {
#line 1359
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1362
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1363
      return (0);
    }
#line 1364
    if (tmp->flags[2] & (1U << 10)) {
      {
#line 1365
      object_free2(tmp, 2);
#line 1366
      tmp = (object *)((void *)0);
      }
    } else
#line 1364
    if (tmp->flags[2] & (1U << 11)) {
      {
#line 1365
      object_free2(tmp, 2);
#line 1366
      tmp = (object *)((void *)0);
      }
    }
#line 1355
    if (! (! tmp)) {
#line 1355
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1369
  tmp->flags[0] |= 1U << 6;
#line 1370
  object_insert_in_map_at(tmp, op->map, (object *)((void *)0), 0, (int )op->x, (int )op->y);
#line 1371
  op->flags[0] &= ~ (1U << 18);
#line 1372
  identify(tmp);
  }
#line 1373
  return (1);
#line 1374
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1377
  if (op->flags[3] & (1U << 13)) {
#line 1378
    return (0);
  }
  {
#line 1379
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1379
    tmp___6 = op->stats.hp;
#line 1379
    op->stats.hp = (sint16 )((int )op->stats.hp - 1);
#line 1379
    if (! ((int )tmp___6 > 0)) {
#line 1379
      goto while_break___1;
    }
#line 1380
    if (op->stats.exp) {
#line 1380
      tmp___3 = (int )op->stats.exp;
    } else {
#line 1380
      if ((unsigned long )op->map == (unsigned long )((void *)0)) {
#line 1380
        tmp___2 = 14;
      } else {
#line 1380
        tmp___2 = (int )(op->map)->difficulty;
      }
#line 1380
      tmp___3 = tmp___2;
    }
#line 1380
    if (op->map) {
#line 1380
      tmp___4 = 1;
    } else {
#line 1380
      tmp___4 = 0;
    }
#line 1380
    if (op->flags[3] & (1U << 16)) {
#line 1380
      tmp___5 = 8;
    } else {
#line 1380
      tmp___5 = 0;
    }
    {
#line 1380
    create_treasure(op->randomitems, op, tmp___4 | tmp___5, tmp___3, 0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1387
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1387
    tmp___7 = op->inv;
    {
#line 1387
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1387
      next1387 = tmp___7;
#line 1387
      if ((unsigned long )next1387 == (unsigned long )((void *)0)) {
#line 1387
        tmp___8 = (tag_t )0;
      } else {
#line 1387
        tmp___8 = next1387->count;
      }
#line 1387
      next_tag1387 = tmp___8;
      {
#line 1387
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1387
        tmp___7 = next1387;
#line 1387
        if (! ((unsigned long )tmp___7 != (unsigned long )((void *)0))) {
#line 1387
          goto while_break___4;
        }
#line 1387
        if (next1387->count != next_tag1387) {
#line 1387
          goto while_break___4;
        } else
#line 1387
        if (next1387->flags[0] & (1U << 3)) {
#line 1387
          goto while_break___4;
        }
#line 1387
        next1387 = next1387->below;
#line 1387
        if ((unsigned long )next1387 == (unsigned long )((void *)0)) {
#line 1387
          next_tag1387 = (tag_t )0;
        } else {
#line 1387
          next_tag1387 = next1387->count;
        }
        {
#line 1388
        object_remove(tmp___7);
        }
#line 1389
        if (op->env) {
          {
#line 1390
          object_insert_in_ob(tmp___7, op->env);
          }
        } else {
          {
#line 1392
          object_free_drop_inventory(tmp___7);
          }
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1387
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1387
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1394
  object_remove(op);
#line 1395
  object_free2(op, 2);
  }
#line 1396
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1398
  return (0);
}
}
#line 1414 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
void apply_auto_fix(mapstruct *m ) 
{ 
  int x ;
  int y ;
  object *tmp ;
  object *next1422 ;
  tag_t next_tag1422 ;
  tag_t tmp___0 ;
  object *invtmp ;
  object *next1424 ;
  tag_t next_tag1424 ;
  tag_t tmp___1 ;
  sint16 tmp___2 ;
  sint16 tmp___3 ;
  object *head ;
  struct obj *tmp___4 ;
  object *tmp___5 ;
  object *next1507 ;
  tag_t next_tag1507 ;
  tag_t tmp___6 ;

  {
#line 1417
  if ((unsigned long )m == (unsigned long )((void *)0)) {
#line 1418
    return;
  }
#line 1420
  x = 0;
  {
#line 1420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1420
    if (! (x < (int )m->width)) {
#line 1420
      goto while_break;
    }
#line 1421
    y = 0;
    {
#line 1421
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1421
      if (! (y < (int )m->height)) {
#line 1421
        goto while_break___0;
      }
      {
#line 1422
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1422
        tmp = (m->spaces + (x + (int )m->width * y))->bottom;
        {
#line 1422
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1422
          next1422 = tmp;
#line 1422
          if ((unsigned long )next1422 == (unsigned long )((void *)0)) {
#line 1422
            tmp___0 = (tag_t )0;
          } else {
#line 1422
            tmp___0 = next1422->count;
          }
#line 1422
          next_tag1422 = tmp___0;
          {
#line 1422
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1422
            tmp = next1422;
#line 1422
            if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 1422
              goto while_break___3;
            }
#line 1422
            if (next1422->count != next_tag1422) {
#line 1422
              goto while_break___3;
            } else
#line 1422
            if (next1422->flags[0] & (1U << 3)) {
#line 1422
              goto while_break___3;
            }
#line 1422
            next1422 = next1422->above;
#line 1422
            if ((unsigned long )next1422 == (unsigned long )((void *)0)) {
#line 1422
              next_tag1422 = (tag_t )0;
            } else {
#line 1422
              next_tag1422 = next1422->count;
            }
#line 1423
            if (tmp->inv) {
              {
#line 1424
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 1424
                invtmp = tmp->inv;
                {
#line 1424
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 1424
                  next1424 = invtmp;
#line 1424
                  if ((unsigned long )next1424 == (unsigned long )((void *)0)) {
#line 1424
                    tmp___1 = (tag_t )0;
                  } else {
#line 1424
                    tmp___1 = next1424->count;
                  }
#line 1424
                  next_tag1424 = tmp___1;
                  {
#line 1424
                  while (1) {
                    while_continue___6: /* CIL Label */ ;
#line 1424
                    invtmp = next1424;
#line 1424
                    if (! ((unsigned long )invtmp != (unsigned long )((void *)0))) {
#line 1424
                      goto while_break___6;
                    }
#line 1424
                    if (next1424->count != next_tag1424) {
#line 1424
                      goto while_break___6;
                    } else
#line 1424
                    if (next1424->flags[0] & (1U << 3)) {
#line 1424
                      goto while_break___6;
                    }
#line 1424
                    next1424 = next1424->below;
#line 1424
                    if ((unsigned long )next1424 == (unsigned long )((void *)0)) {
#line 1424
                      next_tag1424 = (tag_t )0;
                    } else {
#line 1424
                      next_tag1424 = next1424->count;
                    }
#line 1425
                    if (invtmp->flags[0] & (1U << 18)) {
                      {
#line 1426
                      apply_auto(invtmp);
                      }
                    } else
#line 1427
                    if ((int )invtmp->type == 4) {
#line 1427
                      if (invtmp->randomitems) {
#line 1427
                        if (! (invtmp->flags[3] & (1U << 13))) {
                          {
#line 1428
                          while (1) {
                            while_continue___7: /* CIL Label */ ;
#line 1428
                            tmp___2 = invtmp->stats.hp;
#line 1428
                            invtmp->stats.hp = (sint16 )((int )invtmp->stats.hp - 1);
#line 1428
                            if (! ((int )tmp___2 > 0)) {
#line 1428
                              goto while_break___7;
                            }
                            {
#line 1429
                            create_treasure(invtmp->randomitems, invtmp, 0, (int )m->difficulty,
                                            0);
                            }
                          }
                          while_break___7: /* CIL Label */ ;
                          }
#line 1430
                          invtmp->randomitems = (struct treasureliststruct *)((void *)0);
                        } else {
#line 1427
                          goto _L;
                        }
                      } else {
#line 1427
                        goto _L;
                      }
                    } else
                    _L: /* CIL Label */ 
#line 1431
                    if (invtmp) {
#line 1431
                      if (invtmp->arch) {
#line 1431
                        if ((int )invtmp->type != 4) {
#line 1431
                          if ((int )invtmp->type != 101) {
#line 1431
                            if ((int )invtmp->type != 37) {
#line 1431
                              if (invtmp->randomitems) {
#line 1431
                                if (! (invtmp->flags[3] & (1U << 13))) {
                                  {
#line 1436
                                  create_treasure(invtmp->randomitems, invtmp, 0,
                                                  (int )m->difficulty, 0);
#line 1440
                                  invtmp->randomitems = (struct treasureliststruct *)((void *)0);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  while_break___6: /* CIL Label */ ;
                  }
#line 1424
                  goto while_break___5;
                }
                while_break___5: /* CIL Label */ ;
                }
#line 1424
                goto while_break___4;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 1456
              if ((int )tmp->type == 109) {
#line 1463
                tmp->randomitems = (struct treasureliststruct *)((void *)0);
              } else
#line 1456
              if ((int )tmp->type == 3) {
#line 1463
                tmp->randomitems = (struct treasureliststruct *)((void *)0);
              } else
#line 1456
              if ((int )tmp->type == 111) {
#line 1463
                tmp->randomitems = (struct treasureliststruct *)((void *)0);
              } else
#line 1456
              if ((int )tmp->type == 62) {
#line 1463
                tmp->randomitems = (struct treasureliststruct *)((void *)0);
              } else
#line 1456
              if ((int )tmp->type == 5) {
#line 1463
                tmp->randomitems = (struct treasureliststruct *)((void *)0);
              } else
#line 1456
              if ((int )tmp->type == 18) {
#line 1463
                tmp->randomitems = (struct treasureliststruct *)((void *)0);
              } else
#line 1456
              if ((int )tmp->type == 85) {
#line 1463
                tmp->randomitems = (struct treasureliststruct *)((void *)0);
              }
            }
#line 1466
            if (tmp->flags[0] & (1U << 18)) {
              {
#line 1467
              apply_auto(tmp);
              }
            } else
#line 1468
            if ((int )tmp->type == 4) {
#line 1468
              goto _L___1;
            } else
#line 1468
            if ((int )tmp->type == 122) {
              _L___1: /* CIL Label */ 
#line 1468
              if (tmp->randomitems) {
#line 1468
                if (! (tmp->flags[3] & (1U << 13))) {
                  {
#line 1470
                  while (1) {
                    while_continue___8: /* CIL Label */ ;
#line 1470
                    tmp___3 = tmp->stats.hp;
#line 1470
                    tmp->stats.hp = (sint16 )((int )tmp->stats.hp - 1);
#line 1470
                    if (! ((int )tmp___3 > 0)) {
#line 1470
                      goto while_break___8;
                    }
                    {
#line 1471
                    create_treasure(tmp->randomitems, tmp, 0, (int )m->difficulty,
                                    0);
                    }
                  }
                  while_break___8: /* CIL Label */ ;
                  }
#line 1472
                  tmp->randomitems = (struct treasureliststruct *)((void *)0);
                } else {
#line 1468
                  goto _L___0;
                }
              } else {
#line 1468
                goto _L___0;
              }
            } else
            _L___0: /* CIL Label */ 
#line 1473
            if ((int )tmp->type == 26) {
#line 1474
              if ((unsigned long )tmp->head != (unsigned long )((void *)0)) {
#line 1474
                tmp___4 = tmp->head;
              } else {
#line 1474
                tmp___4 = tmp;
              }
#line 1474
              head = tmp___4;
#line 1476
              if (head->flags[2] & (1U << 9)) {
                {
#line 1477
                tmp->speed = (float )0;
#line 1478
                object_update_speed(tmp);
                }
              }
            } else
#line 1489
            if (tmp) {
#line 1489
              if (tmp->arch) {
#line 1489
                if ((int )tmp->type != 1) {
#line 1489
                  if ((int )tmp->type != 4) {
#line 1489
                    if ((int )tmp->type != 101) {
#line 1489
                      if ((int )tmp->type != 57) {
#line 1489
                        if ((int )tmp->type != 37) {
#line 1489
                          if (tmp->randomitems) {
#line 1489
                            if (! (tmp->flags[3] & (1U << 13))) {
                              {
#line 1497
                              create_treasure(tmp->randomitems, tmp, 0, (int )m->difficulty,
                                              0);
#line 1498
                              tmp->randomitems = (struct treasureliststruct *)((void *)0);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
#line 1501
            if (tmp->flags[0] & (1U << 14)) {
              {
#line 1502
              monster_check_apply_all(tmp);
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1422
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1422
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1421
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1420
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1505
  x = 0;
  {
#line 1505
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1505
    if (! (x < (int )m->width)) {
#line 1505
      goto while_break___9;
    }
#line 1506
    y = 0;
    {
#line 1506
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 1506
      if (! (y < (int )m->height)) {
#line 1506
        goto while_break___10;
      }
      {
#line 1507
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 1507
        tmp___5 = (m->spaces + (x + (int )m->width * y))->bottom;
        {
#line 1507
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 1507
          next1507 = tmp___5;
#line 1507
          if ((unsigned long )next1507 == (unsigned long )((void *)0)) {
#line 1507
            tmp___6 = (tag_t )0;
          } else {
#line 1507
            tmp___6 = next1507->count;
          }
#line 1507
          next_tag1507 = tmp___6;
          {
#line 1507
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 1507
            tmp___5 = next1507;
#line 1507
            if (! ((unsigned long )tmp___5 != (unsigned long )((void *)0))) {
#line 1507
              goto while_break___13;
            }
#line 1507
            if (next1507->count != next_tag1507) {
#line 1507
              goto while_break___13;
            } else
#line 1507
            if (next1507->flags[0] & (1U << 3)) {
#line 1507
              goto while_break___13;
            }
#line 1507
            next1507 = next1507->above;
#line 1507
            if ((unsigned long )next1507 == (unsigned long )((void *)0)) {
#line 1507
              next_tag1507 = (tag_t )0;
            } else {
#line 1507
              next_tag1507 = next1507->count;
            }
#line 1508
            if (tmp___5->above) {
#line 1508
              if ((int )tmp___5->type == 30) {
                {
#line 1510
                check_trigger(tmp___5, tmp___5->above);
                }
              } else
#line 1508
              if ((int )tmp___5->type == 32) {
                {
#line 1510
                check_trigger(tmp___5, tmp___5->above);
                }
              }
            }
          }
          while_break___13: /* CIL Label */ ;
          }
#line 1507
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 1507
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 1506
      y ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 1505
    x ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 1512
  return;
}
}
#line 1528 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
void scroll_failure(object *op , int failure , int power ) 
{ 
  int tmp ;
  object *tmp___0 ;
  object *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1529
  tmp = abs(failure / 4);
  }
#line 1529
  if (tmp > power) {
    {
#line 1530
    power = abs(failure / 4);
    }
  }
#line 1532
  if (failure <= -1) {
#line 1532
    if (failure > -15) {
      {
#line 1535
      draw_ext_info(256, 0, (object const   *)op, (uint8 )13, (uint8 )4, "Your spell warps!");
#line 1537
      tmp___0 = create_archetype("spell_wonder");
#line 1538
      cast_wonder(op, op, 0, tmp___0);
      }
#line 1539
      if ((int )op->stats.sp < 0) {
#line 1541
        op->stats.sp = (sint16 )0;
      }
      {
#line 1542
      object_free2(tmp___0, 2);
      }
#line 1543
      return;
    }
  }
#line 1546
  if ((int )settings.spell_failure_effects == 1) {
#line 1547
    if (failure <= -35) {
#line 1547
      if (failure > -60) {
        {
#line 1548
        draw_ext_info(256, 0, (object const   *)op, (uint8 )13, (uint8 )4, "The magic recoils on you!");
#line 1550
        confuse_living(op, op, power);
        }
#line 1551
        return;
      }
    }
#line 1554
    if (failure <= -60) {
#line 1554
      if (failure > -70) {
        {
#line 1555
        draw_ext_info(256, 0, (object const   *)op, (uint8 )13, (uint8 )4, "The magic recoils and paralyzes you!");
#line 1557
        paralyze_living(op, power);
        }
#line 1558
        return;
      }
    }
#line 1561
    if (failure <= -70) {
#line 1561
      if (failure > -80) {
        {
#line 1562
        draw_ext_info(256, 0, (object const   *)op, (uint8 )13, (uint8 )4, "The magic recoils on you!");
#line 1564
        blind_living(op, op, power);
        }
#line 1565
        return;
      }
    }
#line 1568
    if (failure <= -80) {
      {
#line 1571
      tmp___1 = create_archetype("loose_magic");
#line 1572
      cast_magic_storm(op, tmp___1, power);
#line 1573
      draw_ext_info(256, 0, (object const   *)op, (uint8 )13, (uint8 )4, "You unlease uncontrolled mana!");
#line 1575
      object_free2(tmp___1, 2);
      }
#line 1576
      return;
    }
  }
  {
#line 1582
  draw_ext_info(256, 0, (object const   *)op, (uint8 )13, (uint8 )4, "Your mana is drained!");
#line 1584
  tmp___2 = random_roll(0, power - 1, (object const   *)op, 0);
#line 1584
  op->stats.sp = (sint16 )((int )op->stats.sp - tmp___2);
  }
#line 1585
  if ((int )op->stats.sp < 0) {
#line 1586
    op->stats.sp = (sint16 )0;
  }
#line 1587
  return;
}
}
#line 1600 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
void apply_changes_to_player(object *pl , object *change , int limit_stats ) 
{ 
  int i ;
  int j ;
  int excess_stat ;
  sint8 stat___0 ;
  sint8 tmp ;
  int race_bonus ;
  sint8 tmp___0 ;
  sint8 tmp___1 ;
  int i___0 ;
  int tmp___2 ;
  int stat___1 ;
  sint8 tmp___3 ;
  int race_bonus___0 ;
  sint8 tmp___4 ;
  object *tmp___5 ;
  char buf[256] ;
  int anim ;
  object *tmp___6 ;

  {
#line 1602
  excess_stat = 0;
#line 1607
  if ((int )change->type != 37) {
#line 1607
    return;
  }
#line 1613
  if (! (limit_stats & 2)) {
#line 1614
    i = 0;
    {
#line 1614
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1614
      if (! (i < 7)) {
#line 1614
        goto while_break;
      }
      {
#line 1615
      tmp = get_attr_value((living const   *)(& (pl->contr)->orig_stats), i);
#line 1615
      stat___0 = tmp;
#line 1616
      tmp___0 = get_attr_value((living const   *)(& (pl->arch)->clone.stats), i);
#line 1616
      race_bonus = (int )tmp___0;
#line 1618
      tmp___1 = get_attr_value((living const   *)(& change->stats), i);
#line 1618
      stat___0 = (sint8 )((int )stat___0 + (int )tmp___1);
      }
#line 1619
      if (limit_stats & 1) {
#line 1620
        if ((int )stat___0 > 20 + race_bonus) {
#line 1621
          excess_stat ++;
#line 1622
          stat___0 = (sint8 )(20 + race_bonus);
        } else
#line 1623
        if ((int )stat___0 < 1) {
#line 1631
          excess_stat += (int )stat___0;
#line 1632
          stat___0 = (sint8 )1;
        }
      }
      {
#line 1635
      set_attr_value(& (pl->contr)->orig_stats, i, stat___0);
#line 1614
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1641
    if (excess_stat < 0) {
#line 1641
      excess_stat = 0;
    }
#line 1647
    j = 0;
    {
#line 1647
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1647
      if (excess_stat > 0) {
#line 1647
        if (! (j < 100)) {
#line 1647
          goto while_break___0;
        }
      } else {
#line 1647
        goto while_break___0;
      }
      {
#line 1649
      tmp___2 = rndm(0, 6);
#line 1649
      i___0 = tmp___2;
#line 1650
      tmp___3 = get_attr_value((living const   *)(& (pl->contr)->orig_stats), i___0);
#line 1650
      stat___1 = (int )tmp___3;
#line 1651
      tmp___4 = get_attr_value((living const   *)(& (pl->arch)->clone.stats), i___0);
#line 1651
      race_bonus___0 = (int )tmp___4;
      }
#line 1653
      if (i___0 == 4) {
#line 1654
        goto __Cont;
      }
#line 1655
      if (stat___1 < 20 + race_bonus___0) {
        {
#line 1656
        change_attr_value(& (pl->contr)->orig_stats, i___0, (sint8 )1);
#line 1657
        excess_stat --;
        }
      }
      __Cont: /* CIL Label */ 
#line 1647
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1666
  if ((unsigned long )change->randomitems != (unsigned long )((void *)0)) {
    {
#line 1667
    give_initial_items(pl, change->randomitems);
    }
  }
  {
#line 1675
  tmp___5 = object_find_by_name((object const   *)pl, "NOCLASSFACECHANGE");
  }
#line 1675
  if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
#line 1676
    if (change->temp_animation_id) {
#line 1676
      pl->animation_id = change->temp_animation_id;
    } else {
#line 1676
      pl->animation_id = change->animation_id;
    }
#line 1677
    pl->face = change->face;
#line 1679
    if (change->flags[0] & (1U << 11)) {
#line 1680
      pl->flags[0] |= 1U << 11;
    } else {
#line 1682
      pl->flags[0] &= ~ (1U << 11);
    }
  }
#line 1685
  if (change->anim_suffix) {
    {
#line 1689
    snprintf((char */* __restrict  */)(buf), (size_t )256, (char const   */* __restrict  */)"%s_%s",
             (animations + pl->animation_id)->name, change->anim_suffix);
#line 1690
    anim = try_find_animation((char const   *)(buf));
    }
#line 1691
    if (anim) {
      {
#line 1692
      pl->animation_id = (uint16 )anim;
#line 1693
      pl->anim_speed = (uint8 )-1;
#line 1694
      pl->flags[0] &= ~ (1U << 11);
#line 1695
      animate_object(pl, (int )pl->facing);
      }
    }
  }
  {
#line 1701
  tmp___6 = object_present_in_ob_by_name(114, "no weapon force", (object const   *)pl);
  }
#line 1701
  if (tmp___6) {
#line 1702
    pl->flags[1] &= ~ (1U << 25);
  }
#line 1704
  return;
}
}
#line 1706 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
void legacy_apply_container(object *op , object *sack ) 
{ 


  {
  {
#line 1707
  apply_container(op, sack);
  }
#line 1708
  return;
}
}
#line 1723 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
static int apply_check_apply_restrictions(object *who , object *op , int aflags ) 
{ 
  int i ;
  char name_op[256] ;
  char name_op___0[256] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1726
  i = apply_can_apply_object((object const   *)who, (object const   *)op);
  }
#line 1727
  if (i == 0) {
#line 1728
    return (1);
  }
#line 1732
  if (i & 1) {
#line 1733
    if (! (aflags & 128)) {
      {
#line 1736
      query_name((object const   *)op, name_op, (size_t )256);
#line 1737
      draw_ext_info_format(256, 0, (object const   *)who, (uint8 )13, (uint8 )7, "You don\'t have the body to use a %s",
                           name_op);
      }
    }
#line 1741
    return (0);
  }
#line 1744
  if (i & 2) {
#line 1745
    if (! (aflags & 128)) {
      {
#line 1748
      query_name((object const   *)op, name_op___0, (size_t )256);
#line 1749
      draw_ext_info_format(256, 0, (object const   *)who, (uint8 )13, (uint8 )8, "You have a prohibition against using a %s",
                           name_op___0);
      }
    }
#line 1753
    return (0);
  }
#line 1756
  if ((int )who->type != 1) {
    {
#line 1758
    tmp = unapply_for_ob(who, op, aflags);
    }
#line 1758
    if (tmp) {
#line 1758
      tmp___0 = 0;
    } else {
#line 1758
      tmp___0 = 1;
    }
#line 1758
    return (tmp___0);
  }
#line 1761
  if ((unsigned int )(who->contr)->unapply == 1U) {
#line 1761
    goto _L;
  } else
#line 1761
  if (i & 64) {
#line 1761
    if ((unsigned int )(who->contr)->unapply == 0U) {
      _L: /* CIL Label */ 
#line 1763
      if (! (aflags & 128)) {
        {
#line 1764
        draw_ext_info(256, 0, (object const   *)who, (uint8 )13, (uint8 )2, "You need to unapply some item(s):");
        }
      }
      {
#line 1766
      unapply_for_ob(who, op, 64);
      }
#line 1767
      return (0);
    }
  }
#line 1770
  if ((unsigned int )(who->contr)->unapply == 2U) {
#line 1770
    goto _L___0;
  } else
#line 1770
  if (! (i & 64)) {
    _L___0: /* CIL Label */ 
    {
#line 1772
    tmp___1 = unapply_for_ob(who, op, aflags);
    }
#line 1772
    if (tmp___1) {
#line 1772
      tmp___2 = 0;
    } else {
#line 1772
      tmp___2 = 1;
    }
#line 1772
    return (tmp___2);
  }
#line 1775
  return (1);
}
}
#line 1790 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
static int apply_check_item_power(object const   *who , object const   *op , int aflags ) 
{ 


  {
#line 1791
  if ((int const   )who->type != 1) {
#line 1792
    return (1);
  }
#line 1794
  if ((int const   )op->item_power == 0) {
#line 1796
    return (1);
  } else
#line 1794
  if ((float )((int const   )op->item_power + (int const   )(who->contr)->item_power) <= settings.item_power_factor * (float )who->level) {
#line 1796
    return (1);
  }
#line 1798
  if (! (aflags & 128)) {
    {
#line 1799
    draw_ext_info(256, 0, who, (uint8 )13, (uint8 )1, "Equipping that combined with other items would consume your soul!");
    }
  }
#line 1801
  return (0);
}
}
#line 1818 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
static int apply_check_personalized_blessings(object *who , object const   *op ) 
{ 
  char const   *owner ;
  char const   *will ;
  long item_will ;
  long margin ;
  char const   *msg ;
  int random_effect ;
  int damage_percentile ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int weapon_bite ;

  {
#line 1827
  if (! settings.personalized_blessings) {
#line 1828
    return (1);
  }
  {
#line 1831
  owner = object_get_value(op, (char const   */* const  */)"item_owner");
  }
#line 1832
  if ((unsigned long )owner == (unsigned long )((void *)0)) {
#line 1833
    return (1);
  } else {
    {
#line 1832
    tmp = strcmp(owner, who->name);
    }
#line 1832
    if (tmp == 0) {
#line 1833
      return (1);
    }
  }
  {
#line 1835
  will = object_get_value(op, (char const   */* const  */)"item_willpower");
  }
#line 1836
  if ((unsigned long )will != (unsigned long )((void *)0)) {
    {
#line 1836
    tmp___0 = atol(will);
#line 1836
    item_will = tmp___0;
    }
  } else {
#line 1836
    item_will = 0L;
  }
#line 1837
  if (item_will > who->stats.exp) {
    {
#line 1838
    draw_ext_info_format(256, 0, (object const   *)who, (uint8 )13, (uint8 )1, "This %s refuses to serve you - it keeps evading your hand !",
                         op->name);
    }
#line 1841
    return (0);
  }
#line 1844
  if (item_will != 0L) {
#line 1844
    margin = who->stats.exp / item_will;
  } else {
#line 1844
    margin = who->stats.exp;
  }
  {
#line 1845
  tmp___1 = random_roll(0, 100, (object const   *)who, 1);
#line 1845
  random_effect = (int )((long )tmp___1 - margin * 20L);
  }
#line 1846
  if (random_effect > 80) {
#line 1847
    msg = "You don\'t know why, but you have the feeling that the %s is angry at you !";
#line 1848
    damage_percentile = 60;
  } else
#line 1849
  if (random_effect > 60) {
#line 1850
    msg = "The %s seems to look at you nastily !";
#line 1851
    damage_percentile = 45;
  } else
#line 1852
  if (random_effect > 40) {
#line 1853
    msg = "You have the strange feeling that the %s is annoyed...";
#line 1854
    damage_percentile = 30;
  } else
#line 1855
  if (random_effect > 20) {
#line 1856
    msg = "The %s seems tired, or bored, in a way. Very strange !";
#line 1857
    damage_percentile = 15;
  } else
#line 1858
  if (random_effect > 0) {
#line 1859
    msg = "You hear the %s sighing !";
#line 1860
    damage_percentile = 0;
  } else {
#line 1862
    msg = (char const   *)((void *)0);
#line 1863
    damage_percentile = 0;
  }
#line 1865
  if ((unsigned long )msg != (unsigned long )((void *)0)) {
    {
#line 1866
    draw_ext_info_format(256, 0, (object const   *)who, (uint8 )13, (uint8 )3, msg,
                         op->name);
    }
  }
#line 1868
  if (damage_percentile > 0) {
#line 1869
    weapon_bite = ((int )who->stats.hp * damage_percentile) / 100;
#line 1870
    if (weapon_bite < 1) {
#line 1871
      weapon_bite = 1;
    }
    {
#line 1872
    who->stats.hp = (sint16 )((int )who->stats.hp - weapon_bite);
#line 1873
    draw_ext_info_format(256, 0, (object const   *)who, (uint8 )19, (uint8 )2, "You get a nasty bite in the hand !");
    }
  }
#line 1877
  return (1);
}
}
#line 1894 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
static int apply_check_owner(object const   *who , object const   *op , int aflags ) 
{ 
  char const   *quotepos ;
  char *tmp ;
  int tmp___0 ;

  {
#line 1897
  if ((int const   )op->level == 0) {
#line 1898
    return (1);
  }
  {
#line 1900
  tmp = strstr((char const   *)op->name, "\'");
#line 1900
  quotepos = (char const   *)tmp;
  }
#line 1901
  if ((unsigned long )quotepos == (unsigned long )((void *)0)) {
#line 1902
    return (1);
  } else {
    {
#line 1901
    tmp___0 = strncmp((char const   *)op->name, (char const   *)who->name, (size_t )(quotepos - (char const   *)op->name));
    }
#line 1901
    if (tmp___0 == 0) {
#line 1902
      return (1);
    }
  }
#line 1904
  if (! (aflags & 128)) {
    {
#line 1905
    draw_ext_info(256, 0, who, (uint8 )13, (uint8 )1, "The weapon does not recognize you as its owner.");
    }
  }
#line 1907
  return (0);
}
}
#line 1920 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/apply.c"
static void apply_update_ranged_skill(object const   *who , object *op , int aflags ) 
{ 
  char const   *tmp ;
  char name_op[256] ;

  {
#line 1921
  if ((int const   )who->type != 1) {
#line 1922
    return;
  }
#line 1925
  (who->contr)->shoottype = (rangetype )5;
#line 1926
  (who->contr)->ranges[5] = op;
#line 1927
  if (op->invisible) {
#line 1928
    if (! (aflags & 128)) {
#line 1929
      if (op->skill) {
#line 1929
        tmp = op->skill;
      } else {
#line 1929
        tmp = op->name;
      }
      {
#line 1929
      draw_ext_info_format(256, 0, who, (uint8 )13, (uint8 )3, "Readied skill: %s.",
                           tmp);
      }
    }
  } else
#line 1933
  if (! (aflags & 128)) {
    {
#line 1936
    query_name((object const   *)op, name_op, (size_t )256);
#line 1937
    draw_ext_info_format(256, 0, who, (uint8 )13, (uint8 )3, "You ready %s.", name_op);
#line 1940
    draw_ext_info_format(256, 0, who, (uint8 )13, (uint8 )3, "You can now use the skill: %s.",
                         op->skill);
    }
  }
#line 1945
  return;
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 348 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 243 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 163 "../include/attack.h"
char const   * const  change_resist_msg[26] ;
#line 165
char const   * const  attacktype_desc[26] ;
#line 83 "../include/living.h"
uint32 get_weight_limit(int stat___0 ) ;
#line 54 "../include/object.h"
body_locations_struct body_locations[13] ;
#line 169 "../include/skills.h"
static uint8 unarmed_skills[6]  = {      (uint8 )19,      (uint8 )31,      (uint8 )18,      (uint8 )17, 
        (uint8 )38,      (uint8 )0};
#line 195 "../include/global.h"
region *first_region ;
#line 196
treasurelist *first_treasurelist ;
#line 199
objectlink *first_friendly_object ;
#line 223
long nroftreasures ;
#line 242
int num_animations ;
#line 15 "../include/libproto.h"
void arch_info(object *op ) ;
#line 18
void dump_all_archetypes(void) ;
#line 69
void remove_friendly_object(object *op ) ;
#line 70
void dump_friendly_objects(void) ;
#line 119
char const   *i18n(object const   *who , char const   *code ) ;
#line 121
int i18n_find_language_by_code(char const   *code ) ;
#line 122
sstring i18n_get_language_code(int language ) ;
#line 123
void i18n_list_languages(object *who ) ;
#line 149
sint64 level_exp(int level , double expmul ) ;
#line 186
extern void dump_map(mapstruct const   *m ) ;
#line 187
extern void dump_all_maps(void) ;
#line 229
extern long object_sum_weight(object *op ) ;
#line 233
extern void object_dump_all(void) ;
#line 237
extern object *object_get_owner(object *op ) ;
#line 246
extern void object_copy_with_inv(object const   *src_ob , object *dest_ob ) ;
#line 254
extern int object_count_free(void) ;
#line 255
extern int object_count_used(void) ;
#line 256
extern int object_count_active(void) ;
#line 328
extern int atnr_is_dragon_enabled(int attacknr ) ;
#line 334
extern void player_get_title(struct pl  const  *pl , char *buf , size_t bufsize ) ;
#line 335
extern int player_has_own_title(struct pl  const  *pl ) ;
#line 337
extern void player_set_own_title(struct pl *pl , char const   *title ) ;
#line 365
extern region *get_region_by_name(char const   *region_name ) ;
#line 366
extern region *get_region_by_map(mapstruct *m ) ;
#line 367
extern char const   *get_name_of_region_for_map(mapstruct const   *m ) ;
#line 368
extern region *get_region_from_string(char const   *name ) ;
#line 369
extern int region_is_child_of_region(region const   *child , region const   *r ) ;
#line 370
extern char const   *get_region_longname(region const   *r ) ;
#line 371
extern char const   *get_region_msg(region const   *r ) ;
#line 382
extern void ss_dump_statistics(char *buf , size_t size ) ;
#line 383
extern char *ss_dump_table(int what , char *buf , size_t size ) ;
#line 404
extern void time_info(object *op ) ;
#line 405
extern long seconds(void) ;
#line 86 "../include/sockproto.h"
extern void send_query(socket_struct *ns , uint8 flags , char const   *text ) ;
#line 56 "../include/sproto.h"
int checkbanned(char const   *login , char const   *host ) ;
#line 125
void map_info(object *op , char const   *search ) ;
#line 131
void current_region_info(object *op ) ;
#line 132
void current_map_info(object *op ) ;
#line 136
void display_who_entry(object *op , player *pl , char const   *format ) ;
#line 137
void get_who_escape_code_value(char *return_val , int size , char const   letter ,
                               player *pl ) ;
#line 170
int onoff_value(char const   *line ) ;
#line 173
void receive_player_name(object *op ) ;
#line 174
void receive_player_password(object *op ) ;
#line 182
void do_harvest(object *pl , int dir , object *skill ) ;
#line 304
extern void hiscore_display(object *op , int max , char const   *match ) ;
#line 330
extern int check_name(player *me , char const   *name ) ;
#line 333
extern void check_login(object *op , int check_pass ) ;
#line 380
extern void pets_terminate_all(object *owner ) ;
#line 390
extern player *find_player(char const   *plname ) ;
#line 394
extern void display_motd(object const   *op ) ;
#line 395
extern void send_rules(object const   *op ) ;
#line 396
extern void send_news(object const   *op ) ;
#line 404
extern void get_name(object *op ) ;
#line 405
extern void get_password(object *op ) ;
#line 412
extern void roll_again(object *op ) ;
#line 599
extern int players_on_map(mapstruct *m , int show_all ) ;
#line 626
extern void version(object *op ) ;
#line 629
extern int check_password(char const   *typed , char const   *crypted ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void map_info(object *op , char const   *search ) 
{ 
  mapstruct *m ;
  char map_path[256] ;
  long sec ;
  long tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;

  {
  {
#line 60
  tmp = seconds();
#line 60
  sec = tmp;
#line 62
  tmp___0 = i18n((object const   *)op, "Current time is: %02ld:%02ld:%02ld.");
#line 62
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )2, tmp___0,
                       (sec % 86400L) / 3600L, (sec % 3600L) / 60L, sec % 60L);
#line 66
  tmp___1 = i18n((object const   *)op, "[fixed]Path               Pl PlM IM   TO Dif Reset");
#line 66
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )2, tmp___1);
#line 69
  m = first_map;
  }
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! ((unsigned long )m != (unsigned long )((void *)0))) {
#line 69
      goto while_break;
    }
#line 70
    if ((int const   )*search != 0) {
      {
#line 70
      tmp___2 = strstr((char const   *)(m->path), search);
      }
#line 70
      if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 71
        goto __Cont;
      }
    }
    {
#line 74
    tmp___4 = strlen((char const   *)(m->path));
    }
#line 74
    if (tmp___4 <= 18UL) {
      {
#line 75
      strcpy((char */* __restrict  */)(map_path), (char const   */* __restrict  */)(m->path));
      }
    } else {
      {
#line 77
      tmp___3 = strlen((char const   *)(m->path));
#line 77
      strcpy((char */* __restrict  */)(map_path), (char const   */* __restrict  */)((m->path + tmp___3) - 18));
      }
    }
    {
#line 79
    tmp___5 = players_on_map(m, 0);
#line 79
    tmp___6 = i18n((object const   *)op, "[fixed]%-18.18s %2d %2d   %1d %4d %2d  %02d:%02d:%02d");
#line 79
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )2, tmp___6,
                         map_path, (int )m->players, tmp___5, m->in_memory, m->timeout,
                         (int )m->difficulty, (m->reset_time % 86400U) / 3600U, (m->reset_time % 3600U) / 60U,
                         m->reset_time % 60U);
    }
    __Cont: /* CIL Label */ 
#line 69
    m = m->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_language(object *op , char const   *params ) 
{ 
  int language ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 97
  language = -1;
#line 99
  if (! op->contr) {
#line 100
    return;
  }
#line 102
  if ((int const   )*params == 0) {
#line 102
    goto _L;
  } else {
    {
#line 102
    tmp___1 = strcmp(params, "");
    }
#line 102
    if (! tmp___1) {
      _L: /* CIL Label */ 
      {
#line 103
      tmp = i18n((object const   *)op, "Your current language is set to: English.");
#line 103
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp);
#line 105
      tmp___0 = i18n((object const   *)op, "Available languages:");
#line 105
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___0);
#line 107
      i18n_list_languages(op);
      }
#line 108
      return;
    }
  }
  {
#line 111
  language = i18n_find_language_by_code(params);
  }
#line 114
  if (language == -1) {
    {
#line 115
    tmp___2 = i18n((object const   *)op, "Unknown language.");
#line 115
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___2);
    }
#line 117
    return;
  }
  {
#line 120
  (op->contr)->language = language;
#line 122
  tmp___3 = i18n((object const   *)op, "Your current language is set to English.");
#line 122
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___3);
  }
#line 124
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_body(object *op , char const   *params ) 
{ 
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 145
  tmp = i18n((object const   *)op, "The first column is the name of the body location.");
#line 145
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )3, tmp);
#line 148
  tmp___0 = i18n((object const   *)op, "The second column is how many of those locations your body has.");
#line 148
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )3, tmp___0);
#line 151
  tmp___1 = i18n((object const   *)op, "The third column is how many slots in that location are available.");
#line 151
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )3, tmp___1);
#line 154
  i = 0;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (i < 13)) {
#line 154
      goto while_break;
    }
#line 158
    if (op->body_info[i]) {
      {
#line 159
      tmp___2 = i18n((object const   *)op, body_locations[i].use_name);
#line 159
      tmp___3 = i18n((object const   *)op, "[fixed]%-30s %5d %5d");
#line 159
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )3, tmp___3,
                           tmp___2, (int )op->body_info[i], (int )op->body_used[i]);
      }
    } else
#line 158
    if (op->body_used[i]) {
      {
#line 159
      tmp___2 = i18n((object const   *)op, body_locations[i].use_name);
#line 159
      tmp___3 = i18n((object const   *)op, "[fixed]%-30s %5d %5d");
#line 159
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )3, tmp___3,
                           tmp___2, (int )op->body_info[i], (int )op->body_used[i]);
      }
    }
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  if (! (op->flags[1] & (1U << 24))) {
    {
#line 165
    tmp___4 = i18n((object const   *)op, "You are not allowed to wear armor.");
#line 165
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )3, tmp___4);
    }
  }
#line 167
  if (! (op->flags[1] & (1U << 25))) {
    {
#line 168
    tmp___5 = i18n((object const   *)op, "You are not allowed to use weapons.");
#line 168
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )3, tmp___5);
    }
  }
#line 170
  return;
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_motd(object *op , char const   *params ) 
{ 


  {
  {
#line 181
  display_motd((object const   *)op);
  }
#line 182
  return;
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_rules(object *op , char const   *params ) 
{ 


  {
  {
#line 193
  send_rules((object const   *)op);
  }
#line 194
  return;
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_news(object *op , char const   *params ) 
{ 


  {
  {
#line 205
  send_news((object const   *)op);
  }
#line 206
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
static void malloc_info(object *op ) 
{ 
  int ob_used ;
  int tmp ;
  int ob_free ;
  int tmp___0 ;
  int players ;
  int nrofmaps ;
  int nrm ;
  int mapmem ;
  int anr ;
  int anims ;
  int sum_alloc ;
  int sum_used ;
  int i ;
  int tlnr ;
  int alnr ;
  treasurelist *tl ;
  player *pl ;
  mapstruct *m ;
  archetype *at ;
  artifactlist *al ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;

  {
  {
#line 215
  tmp = object_count_used();
#line 215
  ob_used = tmp;
#line 215
  tmp___0 = object_count_free();
#line 215
  ob_free = tmp___0;
#line 216
  nrm = 0;
#line 216
  mapmem = 0;
#line 216
  sum_alloc = 0;
#line 216
  sum_used = 0;
#line 223
  tl = first_treasurelist;
#line 223
  tlnr = 0;
  }
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! ((unsigned long )tl != (unsigned long )((void *)0))) {
#line 223
      goto while_break;
    }
#line 223
    tl = tl->next;
#line 223
    tlnr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  al = first_artifactlist;
#line 225
  alnr = 0;
  {
#line 225
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 225
    if (! ((unsigned long )al != (unsigned long )((void *)0))) {
#line 225
      goto while_break___0;
    }
#line 225
    al = al->next;
#line 225
    alnr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 228
  at = first_archetype;
#line 228
  anr = 0;
#line 228
  anims = 0;
  {
#line 228
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 228
    if (! ((unsigned long )at != (unsigned long )((void *)0))) {
#line 228
      goto while_break___1;
    }
#line 228
    if ((unsigned long )at->more == (unsigned long )((void *)0)) {
#line 228
      at = at->next;
    } else {
#line 228
      at = at->more;
    }
#line 228
    anr ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 231
  i = 1;
  {
#line 231
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 231
    if (! (i < num_animations)) {
#line 231
      goto while_break___2;
    }
#line 232
    anims += (int )(animations + i)->num_animations;
#line 231
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 234
  pl = first_player;
#line 234
  players = 0;
  {
#line 234
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 234
    if (! ((unsigned long )pl != (unsigned long )((void *)0))) {
#line 234
      goto while_break___3;
    }
#line 234
    pl = pl->next;
#line 234
    players ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 237
  m = first_map;
#line 237
  nrofmaps = 0;
  {
#line 237
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 237
    if (! ((unsigned long )m != (unsigned long )((void *)0))) {
#line 237
      goto while_break___4;
    }
#line 238
    if (m->in_memory == 1U) {
#line 239
      mapmem = (int )((unsigned long )mapmem + (unsigned long )((int )m->width * (int )m->height) * (sizeof(object *) + sizeof(MapSpace )));
#line 240
      nrm ++;
    }
#line 237
    m = m->next;
#line 237
    nrofmaps ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 243
  tmp___1 = i18n((object const   *)op, "Sizeof: object=%d  player=%d  map=%d");
#line 243
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )4, tmp___1,
                       sizeof(object ), sizeof(player ), sizeof(mapstruct ));
#line 247
  i = (int )((unsigned long )ob_used * sizeof(object ));
#line 247
  tmp___2 = i18n((object const   *)op, "[fixed]%4d used objects:    %8d");
#line 247
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )4, tmp___2,
                       ob_used, i);
#line 251
  sum_used += i;
#line 252
  sum_alloc += i;
#line 253
  i = (int )((unsigned long )ob_free * sizeof(object ));
#line 253
  tmp___3 = i18n((object const   *)op, "[fixed]%4d free objects:    %8d");
#line 253
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )4, tmp___3,
                       ob_free, i);
#line 257
  tmp___4 = object_count_active();
#line 257
  tmp___5 = i18n((object const   *)op, "[fixed]%4d active objects:  %8d");
#line 257
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )4, tmp___5,
                       tmp___4, 0);
#line 261
  sum_alloc += i;
#line 262
  i = (int )((unsigned long )players * sizeof(player ));
#line 262
  tmp___6 = i18n((object const   *)op, "[fixed]%4d players:         %8d");
#line 262
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )4, tmp___6,
                       players, i);
#line 266
  sum_alloc += i;
#line 267
  sum_used += i;
#line 269
  i = (int )((unsigned long )nrofmaps * sizeof(mapstruct ));
#line 269
  tmp___7 = i18n((object const   *)op, "[fixed]%4d maps allocated:  %8d");
#line 269
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )4, tmp___7,
                       nrofmaps, i);
#line 273
  sum_alloc += i;
#line 274
  sum_used = (int )((unsigned long )sum_used + (unsigned long )nrm * sizeof(mapstruct ));
#line 276
  tmp___8 = i18n((object const   *)op, "[fixed]%4d maps in memory:  %8d");
#line 276
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )4, tmp___8,
                       nrm, mapmem);
#line 280
  sum_alloc += mapmem;
#line 281
  sum_used += mapmem;
#line 283
  i = (int )((unsigned long )anr * sizeof(archetype ));
#line 283
  tmp___9 = i18n((object const   *)op, "[fixed]%4d archetypes:      %8d");
#line 283
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )4, tmp___9,
                       anr, i);
#line 287
  sum_alloc += i;
#line 288
  sum_used += i;
#line 290
  i = (int )((unsigned long )anims * sizeof(uint16 ));
#line 290
  tmp___10 = i18n((object const   *)op, "[fixed]%4d animations:      %8d");
#line 290
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )4, tmp___10,
                       anims, i);
#line 294
  sum_alloc += i;
#line 295
  sum_used += i;
#line 297
  i = (int )((unsigned long )tlnr * sizeof(treasurelist ));
#line 297
  tmp___11 = i18n((object const   *)op, "[fixed]%4d treasurelists    %8d");
#line 297
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )4, tmp___11,
                       tlnr, i);
#line 301
  sum_alloc += i;
#line 302
  sum_used += i;
#line 304
  i = (int )((unsigned long )nroftreasures * sizeof(treasure ));
#line 304
  tmp___12 = i18n((object const   *)op, "[fixed]%4ld treasures        %8d");
#line 304
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )4, tmp___12,
                       nroftreasures, i);
#line 308
  sum_alloc += i;
#line 309
  sum_used += i;
#line 311
  i = (int )((unsigned long )nrofartifacts * sizeof(artifact ));
#line 311
  tmp___13 = i18n((object const   *)op, "[fixed]%4ld artifacts        %8d");
#line 311
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )4, tmp___13,
                       nrofartifacts, i);
#line 315
  sum_alloc += i;
#line 316
  sum_used += i;
#line 318
  i = (int )((unsigned long )nrofallowedstr * sizeof(linked_char ));
#line 318
  tmp___14 = i18n((object const   *)op, "[fixed]%4ld artifacts strngs %8d");
#line 318
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )4, tmp___14,
                       nrofallowedstr, i);
#line 322
  sum_alloc += i;
#line 323
  sum_used += i;
#line 325
  i = (int )((unsigned long )alnr * sizeof(artifactlist ));
#line 325
  tmp___15 = i18n((object const   *)op, "[fixed]%4d artifactlists    %8d");
#line 325
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )4, tmp___15,
                       alnr, i);
#line 329
  sum_alloc += i;
#line 330
  sum_used += i;
#line 332
  tmp___16 = i18n((object const   *)op, "[fixed]Total space allocated:%8d");
#line 332
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )4, tmp___16,
                       sum_alloc);
#line 336
  tmp___17 = i18n((object const   *)op, "[fixed]Total space used:     %8d");
#line 336
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )4, tmp___17,
                       sum_used);
  }
#line 339
  return;
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void current_region_info(object *op ) 
{ 
  region *r ;
  char const   *tmp ;
  region *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 357
  tmp = get_name_of_region_for_map((mapstruct const   *)op->map);
#line 357
  tmp___0 = get_region_by_name(tmp);
#line 357
  r = tmp___0;
  }
#line 360
  if (! r) {
#line 361
    return;
  }
  {
#line 363
  tmp___1 = get_region_msg((region const   *)r);
#line 363
  tmp___2 = get_region_longname((region const   *)r);
#line 363
  tmp___3 = i18n((object const   *)op, "You are in %s. \n %s");
#line 363
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___3,
                       tmp___2, tmp___1);
  }
#line 366
  return;
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void current_map_info(object *op ) 
{ 
  mapstruct *m ;
  region *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 375
  m = op->map;
#line 377
  if (! m) {
#line 378
    return;
  }
  {
#line 380
  tmp = get_region_by_map(m);
#line 380
  tmp___0 = get_region_longname((region const   *)tmp);
#line 380
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, "%s (%s) in %s",
                       m->name, m->path, tmp___0);
  }
#line 384
  if (op->flags[0] & (1U << 1)) {
    {
#line 385
    tmp___1 = i18n((object const   *)op, "players:%d difficulty:%d size:%dx%d start:%dx%d timeout %d");
#line 385
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___1,
                         (int )m->players, (int )m->difficulty, (int )m->width, (int )m->height,
                         (int )m->enter_x, (int )m->enter_y, m->timeout);
    }
  }
#line 392
  if (m->msg) {
    {
#line 393
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, (char const   *)m->msg);
    }
  }
#line 394
  return;
}
}
#line 429 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_whereabouts(object *op , char const   *params ) 
{ 
  region *reg ;
  player *pl ;
  region *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 438
  reg = first_region;
  {
#line 438
  while (1) {
    while_continue: /* CIL Label */ ;
#line 438
    if (! ((unsigned long )reg != (unsigned long )((void *)0))) {
#line 438
      goto while_break;
    }
#line 439
    reg->counter = (uint32 )0;
#line 438
    reg = reg->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  pl = first_player;
  {
#line 441
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 441
    if (! ((unsigned long )pl != (unsigned long )((void *)0))) {
#line 441
      goto while_break___0;
    }
#line 442
    if ((unsigned long )(pl->ob)->map != (unsigned long )((void *)0)) {
      {
#line 443
      tmp = get_region_by_map((pl->ob)->map);
#line 443
      (tmp->counter) ++;
      }
    }
#line 441
    pl = pl->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 446
  reg = first_region;
  {
#line 446
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 446
    if (! ((unsigned long )reg != (unsigned long )((void *)0))) {
#line 446
      goto while_break___1;
    }
#line 447
    if ((unsigned long )reg->longname == (unsigned long )((void *)0)) {
#line 447
      if (reg->counter > 0U) {
#line 448
        if ((unsigned long )reg->parent != (unsigned long )((void *)0)) {
#line 449
          (reg->parent)->counter += reg->counter;
#line 450
          reg->counter = (uint32 )0;
        } else {
          {
#line 452
          LOG((LogLevel )0, "command_whereabouts() Region %s with no longname has no parent\n",
              reg->name);
          }
        }
      }
    }
#line 446
    reg = reg->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 455
  tmp___0 = i18n((object const   *)op, "In the world currently there are:");
#line 455
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___0);
#line 458
  reg = first_region;
  }
  {
#line 458
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 458
    if (! ((unsigned long )reg != (unsigned long )((void *)0))) {
#line 458
      goto while_break___2;
    }
#line 459
    if (reg->counter > 0U) {
      {
#line 460
      tmp___1 = get_region_longname((region const   *)reg);
#line 460
      tmp___2 = i18n((object const   *)op, "%u players in %s");
#line 460
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___2,
                           reg->counter, tmp___1);
      }
    }
#line 458
    reg = reg->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 464
  return;
}
}
#line 481 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
static int name_cmp(chars_names const   *c1 , chars_names const   *c2 ) 
{ 
  int tmp ;

  {
  {
#line 482
  tmp = strcasecmp((char const   *)(c1->namebuf), (char const   *)(c2->namebuf));
  }
#line 482
  return (tmp);
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void list_players(object *op , region *reg , partylist *party ) 
{ 
  player *pl ;
  uint16 i ;
  char *format ;
  int num_players ;
  int num_wiz ;
  int num_afk ;
  int num_bot ;
  chars_names *chars ;
  region *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  player *tmp___7 ;

  {
#line 499
  num_players = 0;
#line 499
  num_wiz = 0;
#line 499
  num_afk = 0;
#line 499
  num_bot = 0;
#line 500
  chars = (chars_names *)((void *)0);
#line 502
  if ((unsigned long )op == (unsigned long )((void *)0)) {
#line 503
    format = settings.who_wiz_format;
  } else
#line 502
  if (op->flags[0] & (1U << 1)) {
#line 503
    format = settings.who_wiz_format;
  } else {
#line 505
    format = settings.who_format;
  }
#line 507
  pl = first_player;
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 507
    if (! ((unsigned long )pl != (unsigned long )((void *)0))) {
#line 507
      goto while_break;
    }
#line 508
    if ((unsigned long )(pl->ob)->map == (unsigned long )((void *)0)) {
#line 509
      goto __Cont;
    }
#line 510
    if (pl->hidden) {
#line 510
      if (! (op->flags[0] & (1U << 1))) {
#line 511
        goto __Cont;
      }
    }
#line 513
    if (reg) {
      {
#line 513
      tmp = get_region_by_map((pl->ob)->map);
#line 513
      tmp___0 = region_is_child_of_region((region const   *)tmp, (region const   *)reg);
      }
#line 513
      if (! tmp___0) {
#line 514
        goto __Cont;
      }
    }
#line 515
    if (party) {
#line 515
      if ((unsigned long )pl->party != (unsigned long )party) {
#line 516
        goto __Cont;
      }
    }
#line 518
    if ((int )pl->state == 0) {
#line 518
      goto _L;
    } else
#line 518
    if ((int )pl->state == 10) {
      _L: /* CIL Label */ 
      {
#line 519
      num_players ++;
#line 520
      tmp___1 = realloc((void *)chars, (unsigned long )num_players * sizeof(chars_names ));
#line 520
      chars = (chars_names *)tmp___1;
      }
#line 521
      if ((unsigned long )chars == (unsigned long )((void *)0)) {
        {
#line 522
        tmp___2 = i18n((object const   *)op, "who failed - out of memory!");
#line 522
        draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )1, tmp___2);
        }
#line 524
        return;
      }
      {
#line 526
      sprintf((char */* __restrict  */)((chars + (num_players - 1))->namebuf), (char const   */* __restrict  */)"%s",
              (pl->ob)->name);
#line 527
      (chars + (num_players - 1))->login_order = num_players;
      }
#line 530
      if ((pl->ob)->flags[0] & (1U << 1)) {
#line 531
        num_wiz ++;
      }
#line 533
      if ((pl->ob)->flags[3] & (1U << 15)) {
#line 534
        num_afk ++;
      }
#line 536
      if (pl->socket.is_bot) {
#line 537
        num_bot ++;
      }
    }
    __Cont: /* CIL Label */ 
#line 507
    pl = pl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 540
  if ((unsigned long )first_player != (unsigned long )((player *)((void *)0))) {
#line 541
    if ((unsigned long )reg == (unsigned long )((void *)0)) {
#line 541
      if ((unsigned long )party == (unsigned long )((void *)0)) {
        {
#line 542
        tmp___3 = i18n((object const   *)op, "Total Players (%d) -- WIZ(%d) AFK(%d) BOT(%d)");
#line 542
        draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )1,
                             tmp___3, num_players, num_wiz, num_afk, num_bot);
        }
      } else {
#line 541
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 545
    if ((unsigned long )party == (unsigned long )((void *)0)) {
#line 546
      if (reg->longname) {
#line 546
        tmp___4 = reg->longname;
      } else {
#line 546
        tmp___4 = reg->name;
      }
      {
#line 546
      tmp___5 = i18n((object const   *)op, "Total Players in %s (%d) -- WIZ(%d) AFK(%d) BOT(%d)");
#line 546
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )1, tmp___5,
                           tmp___4, num_players, num_wiz, num_afk, num_bot);
      }
    } else {
      {
#line 550
      tmp___6 = i18n((object const   *)op, "Total Players in party %s (%d) -- WIZ(%d) AFK(%d) BOT(%d)");
#line 550
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )1, tmp___6,
                           party->partyname, num_players, num_wiz, num_afk, num_bot);
      }
    }
  }
  {
#line 554
  qsort((void *)chars, (size_t )num_players, sizeof(chars_names ), (int (*)(void const   * ,
                                                                            void const   * ))(& name_cmp));
#line 555
  i = (uint16 )0;
  }
  {
#line 555
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 555
    if (! ((int )i < num_players)) {
#line 555
      goto while_break___0;
    }
    {
#line 556
    tmp___7 = find_player((char const   *)((chars + i)->namebuf));
#line 556
    display_who_entry(op, tmp___7, (char const   *)format);
#line 555
    i = (uint16 )((int )i + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 557
  free((void *)chars);
  }
#line 558
  return;
}
}
#line 568 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_who(object *op , char const   *params ) 
{ 
  region *reg ;

  {
  {
#line 571
  reg = get_region_from_string(params);
#line 572
  list_players(op, reg, (partylist *)((void *)0));
  }
#line 573
  return;
}
}
#line 585 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void display_who_entry(object *op , player *pl , char const   *format ) 
{ 
  char tmpbuf[256] ;
  char outbuf[256] ;
  size_t i ;
  size_t tmp ;

  {
  {
#line 590
  strcpy((char */* __restrict  */)(outbuf), (char const   */* __restrict  */)"[fixed]");
  }
#line 592
  if ((unsigned long )pl == (unsigned long )((void *)0)) {
    {
#line 593
    LOG((LogLevel )0, "display_who_entry(): I was passed a null player\n");
    }
#line 594
    return;
  }
#line 596
  i = (size_t )0;
  {
#line 596
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 596
    tmp = strlen(format);
    }
#line 596
    if (! (i <= tmp)) {
#line 596
      goto while_break;
    }
#line 597
    if ((int const   )*(format + i) == 37) {
      {
#line 598
      i ++;
#line 599
      get_who_escape_code_value(tmpbuf, (int )sizeof(tmpbuf), *(format + i), pl);
#line 600
      strcat((char */* __restrict  */)(outbuf), (char const   */* __restrict  */)(tmpbuf));
      }
    } else
#line 601
    if ((int const   )*(format + i) == 95) {
      {
#line 602
      strcat((char */* __restrict  */)(outbuf), (char const   */* __restrict  */)" ");
      }
    } else {
      {
#line 604
      snprintf((char */* __restrict  */)(tmpbuf), sizeof(tmpbuf), (char const   */* __restrict  */)"%c",
               (int const   )*(format + i));
#line 605
      strcat((char */* __restrict  */)(outbuf), (char const   */* __restrict  */)(tmpbuf));
      }
    }
#line 596
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 608
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )1, (char const   *)(outbuf));
  }
#line 609
  return;
}
}
#line 641 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void get_who_escape_code_value(char *return_val , int size , char const   letter ,
                               player *pl ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  region *tmp___5 ;
  char const   *tmp___6 ;

  {
  {
#line 643
  if ((int const   )letter == 78) {
#line 643
    goto case_78;
  }
#line 647
  if ((int const   )letter == 116) {
#line 647
    goto case_116;
  }
#line 651
  if ((int const   )letter == 99) {
#line 651
    goto case_99;
  }
#line 655
  if ((int const   )letter == 110) {
#line 655
    goto case_110;
  }
#line 659
  if ((int const   )letter == 104) {
#line 659
    goto case_104;
  }
#line 663
  if ((int const   )letter == 108) {
#line 663
    goto case_108;
  }
#line 667
  if ((int const   )letter == 100) {
#line 667
    goto case_100;
  }
#line 671
  if ((int const   )letter == 97) {
#line 671
    goto case_97;
  }
#line 675
  if ((int const   )letter == 98) {
#line 675
    goto case_98;
  }
#line 679
  if ((int const   )letter == 109) {
#line 679
    goto case_109;
  }
#line 683
  if ((int const   )letter == 77) {
#line 683
    goto case_77;
  }
#line 687
  if ((int const   )letter == 114) {
#line 687
    goto case_114;
  }
#line 691
  if ((int const   )letter == 82) {
#line 691
    goto case_82;
  }
#line 695
  if ((int const   )letter == 105) {
#line 695
    goto case_105;
  }
#line 699
  if ((int const   )letter == 37) {
#line 699
    goto case_37;
  }
#line 703
  if ((int const   )letter == 95) {
#line 703
    goto case_95;
  }
#line 642
  goto switch_break;
  case_78: /* CIL Label */ 
  {
#line 644
  snprintf((char */* __restrict  */)return_val, (size_t )size, (char const   */* __restrict  */)"%s",
           (pl->ob)->name);
  }
#line 645
  goto switch_break;
  case_116: /* CIL Label */ 
  {
#line 648
  player_get_title((struct pl  const  *)pl, return_val, (size_t )size);
  }
#line 649
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 652
  snprintf((char */* __restrict  */)return_val, (size_t )size, (char const   */* __restrict  */)"%u",
           (pl->ob)->count);
  }
#line 653
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 656
  snprintf((char */* __restrict  */)return_val, (size_t )size, (char const   */* __restrict  */)"\n");
  }
#line 657
  goto switch_break;
  case_104: /* CIL Label */ 
#line 660
  if (pl->peaceful) {
#line 660
    tmp = "";
  } else {
#line 660
    tmp = " <Hostile>";
  }
  {
#line 660
  snprintf((char */* __restrict  */)return_val, (size_t )size, (char const   */* __restrict  */)"%s",
           tmp);
  }
#line 661
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 664
  snprintf((char */* __restrict  */)return_val, (size_t )size, (char const   */* __restrict  */)"%d",
           (int )(pl->ob)->level);
  }
#line 665
  goto switch_break;
  case_100: /* CIL Label */ 
#line 668
  if ((pl->ob)->flags[0] & (1U << 1)) {
#line 668
    tmp___0 = " <WIZ>";
  } else {
#line 668
    tmp___0 = "";
  }
  {
#line 668
  snprintf((char */* __restrict  */)return_val, (size_t )size, (char const   */* __restrict  */)"%s",
           tmp___0);
  }
#line 669
  goto switch_break;
  case_97: /* CIL Label */ 
#line 672
  if ((pl->ob)->flags[3] & (1U << 15)) {
#line 672
    tmp___1 = " <AFK>";
  } else {
#line 672
    tmp___1 = "";
  }
  {
#line 672
  snprintf((char */* __restrict  */)return_val, (size_t )size, (char const   */* __restrict  */)"%s",
           tmp___1);
  }
#line 673
  goto switch_break;
  case_98: /* CIL Label */ 
#line 676
  if (pl->socket.is_bot == 1U) {
#line 676
    tmp___2 = " <BOT>";
  } else {
#line 676
    tmp___2 = "";
  }
  {
#line 676
  snprintf((char */* __restrict  */)return_val, (size_t )size, (char const   */* __restrict  */)"%s",
           tmp___2);
  }
#line 677
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 680
  snprintf((char */* __restrict  */)return_val, (size_t )size, (char const   */* __restrict  */)"%s",
           ((pl->ob)->map)->path);
  }
#line 681
  goto switch_break;
  case_77: /* CIL Label */ 
#line 684
  if (((pl->ob)->map)->name) {
#line 684
    tmp___3 = (char const   *)((pl->ob)->map)->name;
  } else {
#line 684
    tmp___3 = "Untitled";
  }
  {
#line 684
  snprintf((char */* __restrict  */)return_val, (size_t )size, (char const   */* __restrict  */)"%s",
           tmp___3);
  }
#line 685
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 688
  tmp___4 = get_name_of_region_for_map((mapstruct const   *)(pl->ob)->map);
#line 688
  snprintf((char */* __restrict  */)return_val, (size_t )size, (char const   */* __restrict  */)"%s",
           tmp___4);
  }
#line 689
  goto switch_break;
  case_82: /* CIL Label */ 
  {
#line 692
  tmp___5 = get_region_by_map((pl->ob)->map);
#line 692
  tmp___6 = get_region_longname((region const   *)tmp___5);
#line 692
  snprintf((char */* __restrict  */)return_val, (size_t )size, (char const   */* __restrict  */)"%s",
           tmp___6);
  }
#line 693
  goto switch_break;
  case_105: /* CIL Label */ 
  {
#line 696
  snprintf((char */* __restrict  */)return_val, (size_t )size, (char const   */* __restrict  */)"%s",
           pl->socket.host);
  }
#line 697
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 700
  snprintf((char */* __restrict  */)return_val, (size_t )size, (char const   */* __restrict  */)"%%");
  }
#line 701
  goto switch_break;
  case_95: /* CIL Label */ 
  {
#line 704
  snprintf((char */* __restrict  */)return_val, (size_t )size, (char const   */* __restrict  */)"_");
  }
#line 705
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 707
  return;
}
}
#line 717 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_afk(object *op , char const   *params ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 718
  if (op->flags[3] & (1U << 15)) {
    {
#line 719
    op->flags[3] &= ~ (1U << 15);
#line 720
    tmp = i18n((object const   *)op, "You are no longer AFK");
#line 720
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp);
    }
  } else {
    {
#line 723
    op->flags[3] |= 1U << 15;
#line 724
    tmp___0 = i18n((object const   *)op, "You are now AFK");
#line 724
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___0);
    }
  }
#line 727
  return;
}
}
#line 737 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_malloc(object *op , char const   *params ) 
{ 


  {
  {
#line 738
  malloc_info(op);
  }
#line 739
  return;
}
}
#line 749 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_mapinfo(object *op , char const   *params ) 
{ 


  {
  {
#line 750
  current_map_info(op);
  }
#line 751
  return;
}
}
#line 761 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_whereami(object *op , char const   *params ) 
{ 


  {
  {
#line 762
  current_region_info(op);
  }
#line 763
  return;
}
}
#line 773 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_maps(object *op , char const   *params ) 
{ 


  {
  {
#line 774
  map_info(op, params);
  }
#line 775
  return;
}
}
#line 785 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_strings(object *op , char const   *params ) 
{ 
  char stats[4096] ;
  char *tmp ;

  {
  {
#line 788
  ss_dump_statistics(stats, sizeof(stats));
#line 789
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )21, "[fixed]%s\n",
                       stats);
#line 793
  tmp = ss_dump_table(2, stats, sizeof(stats));
#line 793
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )21, (char const   *)tmp);
  }
#line 795
  return;
}
}
#line 805 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_time(object *op , char const   *params ) 
{ 


  {
  {
#line 806
  time_info(op);
  }
#line 807
  return;
}
}
#line 817 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_archs(object *op , char const   *params ) 
{ 


  {
  {
#line 818
  arch_info(op);
  }
#line 819
  return;
}
}
#line 829 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_hiscore(object *op , char const   *params ) 
{ 
  int tmp ;

  {
#line 830
  if ((unsigned long )op == (unsigned long )((void *)0)) {
#line 830
    tmp = 9999;
  } else {
#line 830
    tmp = 50;
  }
  {
#line 830
  hiscore_display(op, tmp, params);
  }
#line 831
  return;
}
}
#line 841 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_debug(object *op , char const   *params ) 
{ 
  int i ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
#line 844
  if ((int const   )*params == 0) {
    {
#line 845
    tmp = i18n((object const   *)op, "Global debug level is %d.");
#line 845
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp,
                         (unsigned int )settings.debug);
    }
#line 848
    return;
  } else {
    {
#line 844
    tmp___0 = sscanf((char const   */* __restrict  */)params, (char const   */* __restrict  */)"%d",
                     & i);
    }
#line 844
    if (! tmp___0) {
      {
#line 845
      tmp = i18n((object const   *)op, "Global debug level is %d.");
#line 845
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp,
                           (unsigned int )settings.debug);
      }
#line 848
      return;
    }
  }
#line 850
  if (i < 0) {
#line 850
    tmp___1 = - i;
  } else {
#line 850
    tmp___1 = i;
  }
  {
#line 850
  settings.debug = (enum LogLevel )tmp___1;
#line 851
  tmp___2 = i18n((object const   *)op, "Debug level set to %d.");
#line 851
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___2,
                       i);
  }
#line 854
  return;
}
}
#line 865 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_wizpass(object *op , char const   *params ) 
{ 
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 868
  if (! op) {
#line 869
    return;
  }
#line 871
  if ((int const   )*params == 0) {
#line 872
    if (op->flags[2] & (1U << 8)) {
#line 872
      i = 0;
    } else {
#line 872
      i = 1;
    }
  } else {
    {
#line 874
    i = onoff_value(params);
    }
  }
#line 876
  if (i) {
    {
#line 877
    tmp = i18n((object const   *)op, "You will now walk through walls.");
#line 877
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp);
#line 879
    op->flags[2] |= 1U << 8;
    }
  } else {
    {
#line 881
    tmp___0 = i18n((object const   *)op, "You will now be stopped by walls.");
#line 881
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___0);
#line 883
    op->flags[2] &= ~ (1U << 8);
    }
  }
#line 885
  return;
}
}
#line 895 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_wizcast(object *op , char const   *params ) 
{ 
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 898
  if (! op) {
#line 899
    return;
  }
#line 901
  if ((int const   )*params == 0) {
#line 902
    if (op->flags[1] & (1U << 19)) {
#line 902
      i = 0;
    } else {
#line 902
      i = 1;
    }
  } else {
    {
#line 904
    i = onoff_value(params);
    }
  }
#line 906
  if (i) {
    {
#line 907
    tmp = i18n((object const   *)op, "You can now cast spells anywhere.");
#line 907
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp);
#line 909
    op->flags[1] |= 1U << 19;
    }
  } else {
    {
#line 911
    tmp___0 = i18n((object const   *)op, "You now cannot cast spells in no-magic areas.");
#line 911
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___0);
#line 913
    op->flags[1] &= ~ (1U << 19);
    }
  }
#line 915
  return;
}
}
#line 925 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_dumpallobjects(object *op , char const   *params ) 
{ 


  {
  {
#line 926
  object_dump_all();
  }
#line 927
  return;
}
}
#line 937 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_dumpfriendlyobjects(object *op , char const   *params ) 
{ 


  {
  {
#line 938
  dump_friendly_objects();
  }
#line 939
  return;
}
}
#line 949 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_dumpallarchetypes(object *op , char const   *params ) 
{ 


  {
  {
#line 950
  dump_all_archetypes();
  }
#line 951
  return;
}
}
#line 961 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_ssdumptable(object *op , char const   *params ) 
{ 


  {
  {
#line 962
  ss_dump_table(1, (char *)((void *)0), (size_t )0);
  }
#line 963
  return;
}
}
#line 973 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_dumpmap(object *op , char const   *params ) 
{ 


  {
#line 974
  if (op) {
    {
#line 975
    dump_map((mapstruct const   *)op->map);
    }
  }
#line 976
  return;
}
}
#line 986 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_dumpallmaps(object *op , char const   *params ) 
{ 


  {
  {
#line 987
  dump_all_maps();
  }
#line 988
  return;
}
}
#line 998 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_printlos(object *op , char const   *params ) 
{ 


  {
#line 999
  if (op) {
    {
#line 1000
    print_los(op);
    }
  }
#line 1001
  return;
}
}
#line 1012 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_version(object *op , char const   *params ) 
{ 


  {
  {
#line 1013
  version(op);
  }
#line 1014
  return;
}
}
#line 1024 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_listen(object *op , char const   *params ) 
{ 
  int i ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 1027
  if ((int const   )*params == 0) {
    {
#line 1028
    tmp = i18n((object const   *)op, "Set listen to what (presently %d)?");
#line 1028
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp,
                         (int )(op->contr)->listening);
    }
#line 1031
    return;
  } else {
    {
#line 1027
    tmp___0 = sscanf((char const   */* __restrict  */)params, (char const   */* __restrict  */)"%d",
                     & i);
    }
#line 1027
    if (! tmp___0) {
      {
#line 1028
      tmp = i18n((object const   *)op, "Set listen to what (presently %d)?");
#line 1028
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp,
                           (int )(op->contr)->listening);
      }
#line 1031
      return;
    }
  }
#line 1033
  if (i < 0) {
    {
#line 1034
    tmp___1 = i18n((object const   *)op, "Verbose level should be positive.");
#line 1034
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___1);
    }
#line 1036
    return;
  }
  {
#line 1038
  (op->contr)->listening = (uint8 )((char )i);
#line 1039
  tmp___2 = i18n((object const   *)op, "Your verbose level is now %d.");
#line 1039
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___2,
                       i);
  }
#line 1042
  return;
}
}
#line 1055 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_statistics(object *pl , char const   *params ) 
{ 
  char buf[256] ;
  uint32 hours ;
  uint32 minutes ;
  uint64 seconds___0 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  sint64 tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;

  {
#line 1060
  if (! pl->contr) {
#line 1061
    return;
  }
  {
#line 1062
  tmp = i18n((object const   *)pl, "[fixed]  Experience: %");
#line 1062
  strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp);
#line 1063
  strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"ld");
#line 1064
  draw_ext_info_format(256, 0, (object const   *)pl, (uint8 )10, (uint8 )6, (char const   *)(buf),
                       pl->stats.exp);
#line 1067
  tmp___0 = i18n((object const   *)pl, "[fixed]  Next Level: %");
#line 1067
  strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp___0);
#line 1068
  strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"ld");
#line 1069
  tmp___1 = level_exp((int )pl->level + 1, pl->expmul);
#line 1069
  draw_ext_info_format(256, 0, (object const   *)pl, (uint8 )10, (uint8 )6, (char const   *)(buf),
                       tmp___1);
#line 1073
  tmp___2 = i18n((object const   *)pl, "[fixed]\nStat       Nat/Real/Max");
#line 1073
  draw_ext_info(256, 0, (object const   *)pl, (uint8 )10, (uint8 )6, tmp___2);
#line 1076
  tmp___3 = i18n((object const   *)pl, "[fixed]Str         %2d/ %3d/%3d");
#line 1076
  draw_ext_info_format(256, 0, (object const   *)pl, (uint8 )10, (uint8 )6, tmp___3,
                       (int )(pl->contr)->orig_stats.Str, (int )pl->stats.Str, 20 + (int )(pl->arch)->clone.stats.Str);
#line 1079
  tmp___4 = i18n((object const   *)pl, "[fixed]Dex         %2d/ %3d/%3d");
#line 1079
  draw_ext_info_format(256, 0, (object const   *)pl, (uint8 )10, (uint8 )6, tmp___4,
                       (int )(pl->contr)->orig_stats.Dex, (int )pl->stats.Dex, 20 + (int )(pl->arch)->clone.stats.Dex);
#line 1082
  tmp___5 = i18n((object const   *)pl, "[fixed]Con         %2d/ %3d/%3d");
#line 1082
  draw_ext_info_format(256, 0, (object const   *)pl, (uint8 )10, (uint8 )6, tmp___5,
                       (int )(pl->contr)->orig_stats.Con, (int )pl->stats.Con, 20 + (int )(pl->arch)->clone.stats.Con);
#line 1085
  tmp___6 = i18n((object const   *)pl, "[fixed]Int         %2d/ %3d/%3d");
#line 1085
  draw_ext_info_format(256, 0, (object const   *)pl, (uint8 )10, (uint8 )6, tmp___6,
                       (int )(pl->contr)->orig_stats.Int, (int )pl->stats.Int, 20 + (int )(pl->arch)->clone.stats.Int);
#line 1088
  tmp___7 = i18n((object const   *)pl, "[fixed]Wis         %2d/ %3d/%3d");
#line 1088
  draw_ext_info_format(256, 0, (object const   *)pl, (uint8 )10, (uint8 )6, tmp___7,
                       (int )(pl->contr)->orig_stats.Wis, (int )pl->stats.Wis, 20 + (int )(pl->arch)->clone.stats.Wis);
#line 1091
  tmp___8 = i18n((object const   *)pl, "[fixed]Pow         %2d/ %3d/%3d");
#line 1091
  draw_ext_info_format(256, 0, (object const   *)pl, (uint8 )10, (uint8 )6, tmp___8,
                       (int )(pl->contr)->orig_stats.Pow, (int )pl->stats.Pow, 20 + (int )(pl->arch)->clone.stats.Pow);
#line 1094
  tmp___9 = i18n((object const   *)pl, "[fixed]Cha         %2d/ %3d/%3d");
#line 1094
  draw_ext_info_format(256, 0, (object const   *)pl, (uint8 )10, (uint8 )6, tmp___9,
                       (int )(pl->contr)->orig_stats.Cha, (int )pl->stats.Cha, 20 + (int )(pl->arch)->clone.stats.Cha);
  }
#line 1097
  if ((pl->contr)->peaceful) {
#line 1097
    tmp___10 = "Peaceful";
  } else {
#line 1097
    tmp___10 = "Hostile";
  }
  {
#line 1097
  tmp___11 = i18n((object const   *)pl, tmp___10);
#line 1097
  tmp___12 = i18n((object const   *)pl, "\nAttack Mode: %s");
#line 1097
  draw_ext_info_format(256, 0, (object const   *)pl, (uint8 )10, (uint8 )6, tmp___12,
                       tmp___11);
#line 1109
  seconds___0 = ((uint64 )(pl->contr)->ticks_played * (uint64 )max_time) / 1000000UL;
#line 1110
  minutes = (uint32 )seconds___0 / 60U;
#line 1111
  hours = minutes / 60U;
#line 1112
  minutes %= 60U;
#line 1114
  draw_ext_info_format(256, 0, (object const   *)pl, (uint8 )10, (uint8 )6, "You have played this character for %u ticks, which amounts to %d hours and %d minutes.",
                       (pl->contr)->ticks_played, hours, minutes);
  }
#line 1121
  return;
}
}
#line 1131 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_fix_me(object *op , char const   *params ) 
{ 


  {
  {
#line 1132
  object_sum_weight(op);
#line 1133
  fix_object(op);
  }
#line 1134
  return;
}
}
#line 1144 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_players(object *op , char const   *params ) 
{ 
  char buf[256] ;
  char *t ;
  DIR *dir ;
  size_t tmp ;
  struct dirent  const  *entry ;
  struct stat st ;
  struct tm *tm ;
  struct tm *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  struct dirent *tmp___3 ;

  {
  {
#line 1149
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s/%s/",
           settings.localdir, settings.playerdir);
#line 1150
  tmp = strlen((char const   *)(buf));
#line 1150
  t = buf + tmp;
#line 1151
  dir = opendir((char const   *)(buf));
  }
#line 1151
  if ((unsigned long )dir != (unsigned long )((void *)0)) {
    {
#line 1154
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1154
      tmp___3 = readdir(dir);
#line 1154
      entry = (struct dirent  const  *)tmp___3;
      }
#line 1154
      if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 1154
        goto while_break;
      }
#line 1156
      if ((int )entry->d_name[0] == 46) {
#line 1156
        if (! ((int )entry->d_name[1] == 0)) {
#line 1156
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1156
      if ((int )entry->d_name[0] == 46) {
#line 1156
        if ((int )entry->d_name[1] == 46) {
#line 1156
          if (! ((int )entry->d_name[2] == 0)) {
#line 1156
            goto _L___0;
          }
        } else {
#line 1156
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 1160
        strcpy((char */* __restrict  */)t, (char const   */* __restrict  */)(entry->d_name));
#line 1161
        tmp___2 = stat((char const   */* __restrict  */)(buf), (struct stat */* __restrict  */)(& st));
        }
#line 1161
        if (tmp___2 == 0) {
#line 1165
          if ((st.st_mode & 61440U) == 16384U) {
            {
#line 1166
            tmp___0 = localtime((time_t const   *)(& st.st_mtim.tv_sec));
#line 1166
            tm = tmp___0;
#line 1168
            tmp___1 = i18n((object const   *)op, "[fixed]%s\t%04d %02d %02d %02d %02d %02d");
#line 1168
            draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0,
                                 tmp___1, entry->d_name, 1900 + tm->tm_year, 1 + tm->tm_mon,
                                 tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
            }
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1182
  closedir(dir);
  }
#line 1183
  return;
}
}
#line 1195 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
static char const   * const  types[3]  = {      (char const   */* const  */)"nochoice",      (char const   */* const  */)"never",      (char const   */* const  */)"always"};
#line 1193 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_applymode(object *op , char const   *params ) 
{ 
  unapplymode unapply ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
#line 1194
  unapply = (op->contr)->unapply;
#line 1201
  if ((int const   )*params == 0) {
    {
#line 1202
    tmp = i18n((object const   *)op, "applymode is set to %s");
#line 1202
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )7, tmp,
                         types[(op->contr)->unapply]);
    }
#line 1205
    return;
  }
  {
#line 1208
  tmp___3 = strcmp(params, "nochoice");
  }
#line 1208
  if (tmp___3) {
    {
#line 1210
    tmp___2 = strcmp(params, "never");
    }
#line 1210
    if (tmp___2) {
      {
#line 1212
      tmp___1 = strcmp(params, "always");
      }
#line 1212
      if (tmp___1) {
        {
#line 1215
        tmp___0 = i18n((object const   *)op, "applymode: Unknown options %s, valid options are nochoice, never, always");
#line 1215
        draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )7,
                             tmp___0, params);
        }
#line 1218
        return;
      } else {
#line 1213
        (op->contr)->unapply = (unapplymode )2;
      }
    } else {
#line 1211
      (op->contr)->unapply = (unapplymode )1;
    }
  } else {
#line 1209
    (op->contr)->unapply = (unapplymode )0;
  }
#line 1220
  if ((unsigned int )unapply == (unsigned int )(op->contr)->unapply) {
#line 1220
    tmp___4 = "";
  } else {
#line 1220
    tmp___4 = " now";
  }
  {
#line 1220
  tmp___5 = i18n((object const   *)op, "applymode%s set to %s");
#line 1220
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )7, tmp___5,
                       tmp___4, types[(op->contr)->unapply]);
  }
#line 1224
  return;
}
}
#line 1236 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
static char const   * const  types___0[12]  = 
#line 1236
  {      (char const   */* const  */)"normal",      (char const   */* const  */)"threewide",      (char const   */* const  */)"spreadshot",      (char const   */* const  */)"firenorth", 
        (char const   */* const  */)"firene",      (char const   */* const  */)"fireeast",      (char const   */* const  */)"firese",      (char const   */* const  */)"firesouth", 
        (char const   */* const  */)"firesw",      (char const   */* const  */)"firewest",      (char const   */* const  */)"firenw",      (char const   */* const  */)"bestarrow"};
#line 1234 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_bowmode(object *op , char const   *params ) 
{ 
  bowtype_t oldtype ;
  char buf[256] ;
  int i ;
  int found ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 1235
  oldtype = (op->contr)->bowtype;
#line 1253
  if ((int const   )*params == 0) {
    {
#line 1254
    tmp = i18n((object const   *)op, "bowmode is set to %s");
#line 1254
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )7, tmp,
                         types___0[(op->contr)->bowtype]);
    }
#line 1257
    return;
  }
#line 1260
  i = 0;
#line 1260
  found = 0;
  {
#line 1260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1260
    if (! (i <= 11)) {
#line 1260
      goto while_break;
    }
    {
#line 1261
    tmp___0 = strcmp(params, (char const   *)types___0[i]);
    }
#line 1261
    if (! tmp___0) {
#line 1262
      found ++;
#line 1263
      (op->contr)->bowtype = (bowtype_t )i;
#line 1264
      goto while_break;
    }
#line 1260
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1267
  if (! found) {
    {
#line 1268
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"bowmode: Unknown options %s, valid options are:",
             params);
#line 1269
    i = 0;
    }
    {
#line 1269
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1269
      if (! (i <= 11)) {
#line 1269
        goto while_break___0;
      }
      {
#line 1270
      strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)" ");
#line 1271
      strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)types___0[i]);
      }
#line 1272
      if (i < 10) {
        {
#line 1273
        strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)",");
        }
      } else {
        {
#line 1275
        strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)".");
        }
      }
#line 1269
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1277
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )7, (char const   *)(buf));
    }
#line 1278
    return;
  }
#line 1280
  if ((unsigned int )oldtype == (unsigned int )(op->contr)->bowtype) {
#line 1280
    tmp___1 = "";
  } else {
#line 1280
    tmp___1 = " now";
  }
  {
#line 1280
  tmp___2 = i18n((object const   *)op, "bowmode%s set to %s");
#line 1280
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )7, tmp___2,
                       tmp___1, types___0[(op->contr)->bowtype]);
  }
#line 1284
  return;
}
}
#line 1295 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_unarmed_skill(object *op , char const   *params ) 
{ 
  object *skill ;
  size_t i ;
  char const   *tmp ;

  {
#line 1299
  if ((int const   )*params == 0) {
#line 1300
    if ((op->contr)->unarmed_skill) {
#line 1300
      tmp = (op->contr)->unarmed_skill;
    } else {
#line 1300
      tmp = "nothing";
    }
    {
#line 1300
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )7, "unarmed skill is set to %s",
                         tmp);
    }
#line 1303
    return;
  }
  {
#line 1310
  skill = find_skill_by_name(op, params);
  }
#line 1312
  if (! skill) {
    {
#line 1313
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You do not know any such skill called %s",
                         params);
    }
#line 1316
    return;
  }
#line 1318
  i = (size_t )0;
  {
#line 1318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1318
    if (! (i < sizeof(unarmed_skills))) {
#line 1318
      goto while_break;
    }
#line 1319
    if ((int )skill->subtype == (int )unarmed_skills[i]) {
#line 1320
      goto while_break;
    }
#line 1318
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1321
  if (i == sizeof(unarmed_skills)) {
    {
#line 1322
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "%s is not an unarmed skill!",
                         skill->name);
    }
#line 1325
    return;
  }
#line 1329
  if ((op->contr)->unarmed_skill) {
    {
#line 1330
    free_string((op->contr)->unarmed_skill);
    }
  }
  {
#line 1335
  (op->contr)->unarmed_skill = add_string(skill->name);
#line 1337
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )7, "unarmed skill is now set to %s",
                       (op->contr)->unarmed_skill);
  }
#line 1340
  return;
}
}
#line 1353 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
static char const   * const  types___1[4]  = {      (char const   */* const  */)"normal",      (char const   */* const  */)"sad",      (char const   */* const  */)"defend",      (char const   */* const  */)"arena"};
#line 1351 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_petmode(object *op , char const   *params ) 
{ 
  petmode_t oldtype ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;

  {
#line 1352
  oldtype = (op->contr)->petmode;
#line 1360
  if ((int const   )*params == 0) {
    {
#line 1361
    tmp = i18n((object const   *)op, "petmode is set to %s");
#line 1361
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )7, tmp,
                         types___1[(op->contr)->petmode]);
    }
#line 1364
    return;
  }
  {
#line 1367
  tmp___4 = strcmp(params, "normal");
  }
#line 1367
  if (tmp___4) {
    {
#line 1369
    tmp___3 = strcmp(params, "sad");
    }
#line 1369
    if (tmp___3) {
      {
#line 1371
      tmp___2 = strcmp(params, "defend");
      }
#line 1371
      if (tmp___2) {
        {
#line 1373
        tmp___1 = strcmp(params, "arena");
        }
#line 1373
        if (tmp___1) {
          {
#line 1376
          tmp___0 = i18n((object const   *)op, "petmode: Unknown options %s, valid options are normal, sad (seek and destroy), defend, arena");
#line 1376
          draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )7,
                               tmp___0, params);
          }
#line 1379
          return;
        } else {
#line 1374
          (op->contr)->petmode = (petmode_t )3;
        }
      } else {
#line 1372
        (op->contr)->petmode = (petmode_t )2;
      }
    } else {
#line 1370
      (op->contr)->petmode = (petmode_t )1;
    }
  } else {
#line 1368
    (op->contr)->petmode = (petmode_t )0;
  }
#line 1381
  if ((unsigned int )oldtype == (unsigned int )(op->contr)->petmode) {
#line 1381
    tmp___5 = "";
  } else {
#line 1381
    tmp___5 = " now";
  }
  {
#line 1381
  tmp___6 = i18n((object const   *)op, "petmode%s set to %s");
#line 1381
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )7, tmp___6,
                       tmp___5, types___1[(op->contr)->petmode]);
  }
#line 1385
  return;
}
}
#line 1395 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_showpets(object *op , char const   *params ) 
{ 
  objectlink *obl ;
  objectlink *next ;
  int counter ;
  int target ;
  int have_shown_pet ;
  object *ob ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  object *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;

  {
#line 1397
  counter = 0;
#line 1397
  target = 0;
#line 1398
  have_shown_pet = 0;
#line 1399
  if ((int const   )*params != 0) {
    {
#line 1400
    target = atoi(params);
    }
  }
#line 1402
  obl = first_friendly_object;
  {
#line 1402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1402
    if (! ((unsigned long )obl != (unsigned long )((void *)0))) {
#line 1402
      goto while_break;
    }
    {
#line 1403
    ob = obl->ob;
#line 1405
    next = obl->next;
#line 1406
    tmp___11 = object_get_owner(ob);
    }
#line 1406
    if ((unsigned long )tmp___11 == (unsigned long )op) {
#line 1407
      if (target == 0) {
#line 1408
        if (counter == 0) {
          {
#line 1409
          tmp = i18n((object const   *)op, "Pets:");
#line 1409
          draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp);
          }
        }
        {
#line 1411
        counter ++;
#line 1411
        tmp___0 = i18n((object const   *)op, "%d  %s - level %d");
#line 1411
        draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0,
                             tmp___0, counter, ob->name, (int )ob->level);
        }
      } else
#line 1414
      if (! have_shown_pet) {
#line 1414
        counter ++;
#line 1414
        if (counter == target) {
          {
#line 1415
          tmp___1 = i18n((object const   *)op, "[fixed]level %d %s");
#line 1415
          draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0,
                               tmp___1, (int )ob->level, ob->name);
#line 1418
          tmp___2 = i18n((object const   *)op, "[fixed]%d/%d HP, %d/%d SP");
#line 1418
          draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0,
                               tmp___2, (int )ob->stats.hp, (int )ob->stats.maxhp,
                               (int )ob->stats.sp, (int )ob->stats.maxsp);
#line 1423
          tmp___3 = i18n((object const   *)op, "[fixed]Str %d");
#line 1423
          draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0,
                               tmp___3, (int )ob->stats.Str);
#line 1426
          tmp___4 = i18n((object const   *)op, "[fixed]Dex %d");
#line 1426
          draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0,
                               tmp___4, (int )ob->stats.Dex);
#line 1429
          tmp___5 = i18n((object const   *)op, "[fixed]Con %d");
#line 1429
          draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0,
                               tmp___5, (int )ob->stats.Con);
#line 1432
          tmp___6 = i18n((object const   *)op, "[fixed]Int %d");
#line 1432
          draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0,
                               tmp___6, (int )ob->stats.Int);
#line 1435
          tmp___7 = i18n((object const   *)op, "[fixed]Wis %d");
#line 1435
          draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0,
                               tmp___7, (int )ob->stats.Wis);
#line 1438
          tmp___8 = i18n((object const   *)op, "[fixed]Cha %d");
#line 1438
          draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0,
                               tmp___8, (int )ob->stats.Cha);
#line 1441
          tmp___9 = i18n((object const   *)op, "[fixed]Pow %d");
#line 1441
          draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0,
                               tmp___9, (int )ob->stats.Pow);
#line 1444
          tmp___10 = i18n((object const   *)op, "[fixed]wc %d  damage %d ac %d");
#line 1444
          draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0,
                               tmp___10, (int )ob->stats.wc, (int )ob->stats.dam,
                               (int )ob->stats.ac);
#line 1447
          have_shown_pet = 1;
          }
        }
      }
    }
#line 1402
    obl = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1451
  if (counter == 0) {
    {
#line 1452
    tmp___12 = i18n((object const   *)op, "You have no pets.");
#line 1452
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___12);
    }
  } else
#line 1454
  if (target != 0) {
#line 1454
    if (have_shown_pet == 0) {
      {
#line 1455
      tmp___13 = i18n((object const   *)op, "No such pet.");
#line 1455
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___13);
      }
    }
  }
#line 1457
  return;
}
}
#line 1469 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
static char const   * const  types___2[3]  = {      (char const   */* const  */)"inventory",      (char const   */* const  */)"keyrings",      (char const   */* const  */)"containers"};
#line 1467 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_usekeys(object *op , char const   *params ) 
{ 
  usekeytype oldtype ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
#line 1468
  oldtype = (op->contr)->usekeys;
#line 1475
  if ((int const   )*params == 0) {
    {
#line 1476
    tmp = i18n((object const   *)op, "usekeys is set to %s");
#line 1476
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )7, tmp,
                         types___2[(op->contr)->usekeys]);
    }
#line 1479
    return;
  }
  {
#line 1482
  tmp___3 = strcmp(params, "inventory");
  }
#line 1482
  if (tmp___3) {
    {
#line 1484
    tmp___2 = strcmp(params, "keyrings");
    }
#line 1484
    if (tmp___2) {
      {
#line 1486
      tmp___1 = strcmp(params, "containers");
      }
#line 1486
      if (tmp___1) {
        {
#line 1489
        tmp___0 = i18n((object const   *)op, "usekeys: Unknown option %s, valid options are inventory, keyrings, containers");
#line 1489
        draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )7,
                             tmp___0, params);
        }
#line 1492
        return;
      } else {
#line 1487
        (op->contr)->usekeys = (usekeytype )2;
      }
    } else {
#line 1485
      (op->contr)->usekeys = (usekeytype )1;
    }
  } else {
#line 1483
    (op->contr)->usekeys = (usekeytype )0;
  }
#line 1494
  if ((unsigned int )oldtype == (unsigned int )(op->contr)->usekeys) {
#line 1494
    tmp___4 = "";
  } else {
#line 1494
    tmp___4 = " now";
  }
  {
#line 1494
  tmp___5 = i18n((object const   *)op, "usekeys%s set to %s");
#line 1494
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )7, tmp___5,
                       tmp___4, types___2[(op->contr)->usekeys]);
  }
#line 1498
  return;
}
}
#line 1508 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_resistances(object *op , char const   *params ) 
{ 
  int i ;
  char const   *tmp ;
  int attack ;
  object *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1510
  if (! op) {
#line 1511
    return;
  }
#line 1513
  i = 0;
  {
#line 1513
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1513
    if (! (i < 26)) {
#line 1513
      goto while_break;
    }
#line 1514
    if (i == 23) {
#line 1515
      goto __Cont;
    }
    {
#line 1517
    tmp = i18n((object const   *)op, "[fixed]%-20s %+5d");
#line 1517
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )8, tmp,
                         attacktype_desc[i], (int )op->resist[i]);
    }
    __Cont: /* CIL Label */ 
#line 1513
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1523
  tmp___4 = is_dragon_pl((object const   *)op);
  }
#line 1523
  if (tmp___4) {
    {
#line 1527
    tmp___0 = object_find_by_type_and_arch_name((object const   *)op, 114, "dragon_skin_force");
    }
#line 1528
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      {
#line 1529
      tmp___1 = i18n((object const   *)op, "\nNatural skin resistances:");
#line 1529
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )8, tmp___1);
#line 1532
      attack = 0;
      }
      {
#line 1532
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1532
        if (! (attack < 26)) {
#line 1532
          goto while_break___0;
        }
        {
#line 1533
        tmp___3 = atnr_is_dragon_enabled(attack);
        }
#line 1533
        if (tmp___3) {
          {
#line 1534
          tmp___2 = i18n((object const   *)op, "%s: %d");
#line 1534
          draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )8,
                               tmp___2, change_resist_msg[attack], (int )tmp___0->resist[attack]);
          }
        }
#line 1532
        attack ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 1541
  return;
}
}
#line 1553 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
static void help_topics(object *op , int what ) 
{ 
  DIR *dirp ;
  struct dirent *de ;
  char filename[256] ;
  char line[4096] ;
  char suffix[256] ;
  int namelen ;
  char const   *language ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 1561
  language = i18n_get_language_code((op->contr)->language);
#line 1562
  snprintf((char */* __restrict  */)(suffix), sizeof(suffix), (char const   */* __restrict  */)".%s",
           language);
  }
  {
#line 1565
  if (what == 1) {
#line 1565
    goto case_1;
  }
#line 1571
  if (what == 3) {
#line 1571
    goto case_3;
  }
#line 1577
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1566
  snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s/wizhelp",
           settings.datadir);
#line 1567
  tmp = i18n((object const   *)op, "      Wiz commands:");
#line 1567
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )8, tmp);
  }
#line 1569
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1572
  snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s/mischelp",
           settings.datadir);
#line 1573
  tmp___0 = i18n((object const   *)op, "      Misc help:");
#line 1573
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )8, tmp___0);
  }
#line 1575
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1578
  snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s/help",
           settings.datadir);
#line 1579
  tmp___1 = i18n((object const   *)op, "      Commands:");
#line 1579
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )8, tmp___1);
  }
#line 1581
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1583
  dirp = opendir((char const   *)(filename));
  }
#line 1583
  if (! dirp) {
#line 1584
    return;
  }
  {
#line 1586
  line[0] = (char )'\000';
#line 1587
  de = readdir(dirp);
  }
  {
#line 1587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1587
    if (! de) {
#line 1587
      goto while_break;
    }
    {
#line 1588
    tmp___2 = strlen((char const   *)(de->d_name));
#line 1588
    namelen = (int )tmp___2;
    }
#line 1590
    if (namelen <= 2) {
#line 1590
      if ((int )de->d_name[0] == 46) {
#line 1590
        if (namelen == 1) {
#line 1593
          goto __Cont;
        } else
#line 1590
        if ((int )de->d_name[1] == 46) {
#line 1593
          goto __Cont;
        }
      }
    }
    {
#line 1594
    tmp___4 = strstr((char const   *)(de->d_name), (char const   *)(suffix));
    }
#line 1594
    if (tmp___4) {
      {
#line 1595
      tmp___3 = strtok((char */* __restrict  */)(de->d_name), (char const   */* __restrict  */)".");
#line 1595
      strcat((char */* __restrict  */)(line), (char const   */* __restrict  */)tmp___3);
#line 1596
      strcat((char */* __restrict  */)(line), (char const   */* __restrict  */)" ");
      }
    }
    __Cont: /* CIL Label */ 
    {
#line 1587
    de = readdir(dirp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1599
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )8, (char const   *)(line));
#line 1601
  closedir(dirp);
  }
#line 1602
  return;
}
}
#line 1614 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
static void show_commands(object *op , int what ) 
{ 
  char line[4096] ;
  int i ;
  int size ;
  command_array_struct *ap ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 1620
  if (what == 1) {
#line 1620
    goto case_1;
  }
#line 1627
  if (what == 2) {
#line 1627
    goto case_2;
  }
#line 1634
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1621
  ap = WizCommands;
#line 1622
  size = (int )WizCommandsSize;
#line 1623
  tmp = i18n((object const   *)op, "      Wiz commands:");
#line 1623
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )8, tmp);
  }
#line 1625
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1628
  ap = CommunicationCommands;
#line 1629
  size = (int )CommunicationCommandSize;
#line 1630
  tmp___0 = i18n((object const   *)op, "      Communication commands:");
#line 1630
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )8, tmp___0);
  }
#line 1632
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1635
  ap = Commands;
#line 1636
  size = (int )CommandsSize;
#line 1637
  tmp___1 = i18n((object const   *)op, "      Commands:");
#line 1637
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )8, tmp___1);
  }
#line 1639
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1642
  line[0] = (char )'\000';
#line 1643
  i = 0;
  {
#line 1643
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1643
    if (! (i < size)) {
#line 1643
      goto while_break;
    }
    {
#line 1644
    strcat((char */* __restrict  */)(line), (char const   */* __restrict  */)(ap + i)->name);
#line 1645
    strcat((char */* __restrict  */)(line), (char const   */* __restrict  */)" ");
#line 1643
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1647
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )8, (char const   *)(line));
  }
#line 1648
  return;
}
}
#line 1658 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_help(object *op , char const   *params ) 
{ 
  struct stat st ;
  FILE *fp ;
  char filename[256] ;
  char line[256] ;
  int len ;
  char const   *language ;
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  char const   *tmp___14 ;
  size_t tmp___15 ;
  char *tmp___16 ;
  char const   *tmp___17 ;

  {
  {
#line 1665
  language = i18n_get_language_code((op->contr)->language);
  }
#line 1670
  if ((int const   )*params == 0) {
    {
#line 1671
    snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s/def_help",
             settings.datadir);
#line 1672
    fp = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"r");
    }
#line 1672
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 1673
      tmp = __errno_location();
#line 1673
      tmp___0 = strerror_local(*tmp, line, sizeof(line));
#line 1673
      LOG((LogLevel )0, "Cannot open help file %s: %s\n", filename, tmp___0);
      }
#line 1674
      return;
    }
    {
#line 1676
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1676
      tmp___2 = fgets((char */* __restrict  */)(line), 256, (FILE */* __restrict  */)fp);
      }
#line 1676
      if (! tmp___2) {
#line 1676
        goto while_break;
      }
      {
#line 1677
      line[255] = (char )'\000';
#line 1678
      tmp___1 = strlen((char const   *)(line));
#line 1678
      len = (int )(tmp___1 - 1UL);
      }
#line 1679
      if ((int )line[len] == 10) {
#line 1680
        line[len] = (char )'\000';
      }
      {
#line 1681
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )8, (char const   *)(line));
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1683
    fclose(fp);
    }
#line 1684
    return;
  }
  {
#line 1690
  tmp___3 = strcmp(params, "topics");
  }
#line 1690
  if (! tmp___3) {
    {
#line 1691
    help_topics(op, 3);
#line 1692
    help_topics(op, 0);
    }
#line 1693
    if (op->flags[0] & (1U << 1)) {
      {
#line 1694
      help_topics(op, 1);
      }
    }
#line 1695
    return;
  }
  {
#line 1701
  tmp___4 = strcmp(params, "commands");
  }
#line 1701
  if (! tmp___4) {
    {
#line 1702
    show_commands(op, 0);
#line 1703
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )8, "\n");
#line 1704
    show_commands(op, 2);
    }
#line 1705
    if (op->flags[0] & (1U << 1)) {
      {
#line 1706
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )8, "\n");
#line 1707
      show_commands(op, 1);
      }
    }
#line 1709
    return;
  }
  {
#line 1715
  tmp___6 = strchr(params, '.');
  }
#line 1715
  if (tmp___6) {
    {
#line 1716
    tmp___5 = i18n((object const   *)op, "Illegal characters in \'%s\'");
#line 1716
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )8, tmp___5,
                         params);
    }
#line 1719
    return;
  } else {
    {
#line 1715
    tmp___7 = strchr(params, ' ');
    }
#line 1715
    if (tmp___7) {
      {
#line 1716
      tmp___5 = i18n((object const   *)op, "Illegal characters in \'%s\'");
#line 1716
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )8, tmp___5,
                           params);
      }
#line 1719
      return;
    } else {
      {
#line 1715
      tmp___8 = strchr(params, '/');
      }
#line 1715
      if (tmp___8) {
        {
#line 1716
        tmp___5 = i18n((object const   *)op, "Illegal characters in \'%s\'");
#line 1716
        draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )8,
                             tmp___5, params);
        }
#line 1719
        return;
      }
    }
  }
  {
#line 1722
  snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s/mischelp/%s.%s",
           settings.datadir, params, language);
#line 1723
  tmp___11 = stat((char const   */* __restrict  */)(filename), (struct stat */* __restrict  */)(& st));
  }
#line 1723
  if (tmp___11) {
#line 1723
    goto _L___0;
  } else
#line 1723
  if (! ((st.st_mode & 61440U) == 32768U)) {
    _L___0: /* CIL Label */ 
#line 1724
    if (op) {
      {
#line 1725
      snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s/help/%s.%s",
               settings.datadir, params, language);
#line 1726
      tmp___10 = stat((char const   */* __restrict  */)(filename), (struct stat */* __restrict  */)(& st));
      }
#line 1726
      if (tmp___10) {
#line 1726
        goto _L;
      } else
#line 1726
      if (! ((st.st_mode & 61440U) == 32768U)) {
        _L: /* CIL Label */ 
#line 1727
        if (op->flags[0] & (1U << 1)) {
          {
#line 1728
          snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s/wizhelp/%s.%s",
                   settings.datadir, params, language);
#line 1729
          tmp___9 = stat((char const   */* __restrict  */)(filename), (struct stat */* __restrict  */)(& st));
          }
#line 1729
          if (tmp___9) {
#line 1730
            goto nohelp;
          } else
#line 1729
          if (! ((st.st_mode & 61440U) == 32768U)) {
#line 1730
            goto nohelp;
          }
        } else {
#line 1732
          goto nohelp;
        }
      }
    }
  }
  {
#line 1740
  fp = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"r");
  }
#line 1740
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 1741
    tmp___12 = __errno_location();
#line 1741
    tmp___13 = strerror_local(*tmp___12, line, sizeof(line));
#line 1741
    LOG((LogLevel )0, "Cannot open help file %s: %s\n", filename, tmp___13);
    }
#line 1742
    return;
  }
  {
#line 1745
  tmp___14 = i18n((object const   *)op, "Help about \'%s\'");
#line 1745
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )8, tmp___14,
                       params);
  }
  {
#line 1749
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1749
    tmp___16 = fgets((char */* __restrict  */)(line), 256, (FILE */* __restrict  */)fp);
    }
#line 1749
    if (! tmp___16) {
#line 1749
      goto while_break___0;
    }
    {
#line 1750
    line[255] = (char )'\000';
#line 1751
    tmp___15 = strlen((char const   *)(line));
#line 1751
    len = (int )(tmp___15 - 1UL);
    }
#line 1752
    if ((int )line[len] == 10) {
#line 1753
      line[len] = (char )'\000';
    }
    {
#line 1754
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )8, (char const   *)(line));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1756
  fclose(fp);
  }
#line 1757
  return;
  nohelp: 
  {
#line 1764
  tmp___17 = i18n((object const   *)op, "No help available on \'%s\'");
#line 1764
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )8, tmp___17,
                       params);
  }
#line 1767
  return;
}
}
#line 1779 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
int onoff_value(char const   *line ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 1782
  tmp = sscanf((char const   */* __restrict  */)line, (char const   */* __restrict  */)"%d",
               & i);
  }
#line 1782
  if (tmp) {
#line 1783
    return (i != 0);
  }
  {
#line 1786
  if ((int const   )*(line + 0) == 111) {
#line 1786
    goto case_111;
  }
#line 1797
  if ((int const   )*(line + 0) == 100) {
#line 1797
    goto case_100;
  }
#line 1797
  if ((int const   )*(line + 0) == 115) {
#line 1797
    goto case_100;
  }
#line 1797
  if ((int const   )*(line + 0) == 107) {
#line 1797
    goto case_100;
  }
#line 1797
  if ((int const   )*(line + 0) == 121) {
#line 1797
    goto case_100;
  }
#line 1803
  goto switch_default___0;
  case_111: /* CIL Label */ 
  {
#line 1788
  if ((int const   )*(line + 1) == 110) {
#line 1788
    goto case_110;
  }
#line 1790
  goto switch_default;
  case_110: /* CIL Label */ 
#line 1789
  return (1);
  switch_default: /* CIL Label */ 
#line 1791
  return (0);
  switch_break___0: /* CIL Label */ ;
  }
  case_100: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_121: /* CIL Label */ 
#line 1798
  return (1);
  switch_default___0: /* CIL Label */ 
#line 1804
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1816 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_quit(object *op , char const   *params ) 
{ 
  char const   *tmp ;

  {
#line 1817
  if (op->flags[0] & (1U << 4)) {
    {
#line 1818
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )4, "Can\'t quit when in DM mode.");
    }
#line 1819
    return;
  }
  {
#line 1822
  tmp = i18n((object const   *)op, "Quitting will delete your character.\nAre you sure you want to delete your character (y/n):");
#line 1822
  send_query(& (op->contr)->socket, (uint8 )2, tmp);
#line 1825
  player_set_state(op->contr, (uint8 )4);
  }
#line 1826
  return;
}
}
#line 1836 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_sound(object *op , char const   *params ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 1837
  if (! ((op->contr)->socket.sound & 64U)) {
    {
#line 1838
    (op->contr)->socket.sound |= 64U;
#line 1839
    tmp = i18n((object const   *)op, "Sounds are turned off.");
#line 1839
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp);
    }
  } else {
    {
#line 1842
    (op->contr)->socket.sound &= 4294967231U;
#line 1843
    tmp___0 = i18n((object const   *)op, "The sounds are enabled.");
#line 1843
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___0);
    }
  }
#line 1846
  return;
}
}
#line 1858 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void receive_player_name(object *op ) 
{ 
  int tmp ;

  {
  {
#line 1859
  tmp = check_name(op->contr, (char const   *)((op->contr)->write_buf + 1));
  }
#line 1859
  if (! tmp) {
    {
#line 1860
    get_name(op);
    }
#line 1861
    return;
  }
#line 1863
  if (op->name) {
    {
#line 1863
    free_string(op->name);
    }
  }
  {
#line 1863
  op->name = add_string((char const   *)((op->contr)->write_buf + 1));
  }
#line 1864
  if (op->name_pl) {
    {
#line 1864
    free_string(op->name_pl);
    }
  }
  {
#line 1864
  op->name_pl = add_string((char const   *)((op->contr)->write_buf + 1));
#line 1865
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, (char const   *)((op->contr)->write_buf));
#line 1866
  (op->contr)->name_changed = (uint32 )1;
#line 1867
  get_password(op);
  }
#line 1868
  return;
}
}
#line 1876 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void receive_player_password(object *op ) 
{ 
  unsigned int pwd_len ;
  size_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;

  {
  {
#line 1877
  tmp = strlen((char const   *)((op->contr)->write_buf));
#line 1877
  pwd_len = (unsigned int )tmp;
  }
#line 1879
  if (pwd_len <= 1U) {
#line 1879
    goto _L;
  } else
#line 1879
  if (pwd_len > 17U) {
    _L: /* CIL Label */ 
#line 1880
    if ((int )(op->contr)->state == 11) {
      {
#line 1883
      tmp___0 = i18n((object const   *)op, "Password changed cancelled.");
#line 1883
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___0);
#line 1885
      player_set_state(op->contr, (uint8 )0);
      }
    } else
#line 1880
    if ((int )(op->contr)->state == 12) {
      {
#line 1883
      tmp___0 = i18n((object const   *)op, "Password changed cancelled.");
#line 1883
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___0);
#line 1885
      player_set_state(op->contr, (uint8 )0);
      }
    } else
#line 1880
    if ((int )(op->contr)->state == 13) {
      {
#line 1883
      tmp___0 = i18n((object const   *)op, "Password changed cancelled.");
#line 1883
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___0);
#line 1885
      player_set_state(op->contr, (uint8 )0);
      }
    } else {
      {
#line 1887
      get_name(op);
      }
    }
#line 1888
    return;
  }
  {
#line 1892
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, "          ");
#line 1894
  tmp___2 = checkbanned(op->name, (char const   *)(op->contr)->socket.host);
  }
#line 1894
  if (tmp___2) {
    {
#line 1895
    LOG((LogLevel )1, "Banned player tried to add: [%s@%s]\n", op->name, (op->contr)->socket.host);
#line 1896
    tmp___1 = i18n((object const   *)op, "You are not allowed to play.");
#line 1896
    draw_ext_info(259, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___1);
#line 1898
    get_name(op);
    }
#line 1899
    return;
  }
#line 1902
  if ((int )(op->contr)->state == 8) {
    {
#line 1903
    tmp___4 = check_password((char const   *)((op->contr)->write_buf + 1), (char const   *)((op->contr)->password));
    }
#line 1903
    if (! tmp___4) {
      {
#line 1904
      tmp___3 = i18n((object const   *)op, "The passwords did not match.");
#line 1904
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___3);
#line 1906
      get_name(op);
      }
#line 1907
      return;
    }
    {
#line 1909
    LOG((LogLevel )1, "LOGIN: New player named %s from ip %s\n", op->name, (op->contr)->socket.host);
#line 1910
    display_motd((object const   *)op);
#line 1911
    tmp___5 = i18n((object const   *)op, "\nWelcome, Brave New Warrior!\n");
#line 1911
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___5);
#line 1913
    roll_again(op);
#line 1914
    player_set_state(op->contr, (uint8 )2);
    }
#line 1915
    return;
  }
#line 1918
  if ((int )(op->contr)->state == 11) {
    {
#line 1919
    tmp___8 = check_password((char const   *)((op->contr)->write_buf + 1), (char const   *)((op->contr)->password));
    }
#line 1919
    if (tmp___8) {
      {
#line 1924
      tmp___7 = i18n((object const   *)op, "Please enter your new password, or blank to cancel:");
#line 1924
      send_query(& (op->contr)->socket, (uint8 )4, tmp___7);
#line 1925
      player_set_state(op->contr, (uint8 )12);
      }
    } else {
      {
#line 1920
      tmp___6 = i18n((object const   *)op, "You entered the wrong current password.");
#line 1920
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___6);
#line 1922
      player_set_state(op->contr, (uint8 )0);
      }
    }
#line 1927
    return;
  }
#line 1930
  if ((int )(op->contr)->state == 12) {
    {
#line 1931
    tmp___9 = crypt_string((char const   *)((op->contr)->write_buf + 1), (char const   *)((void *)0));
#line 1931
    strcpy((char */* __restrict  */)((op->contr)->new_password), (char const   */* __restrict  */)tmp___9);
#line 1932
    tmp___10 = i18n((object const   *)op, "Please confirm your new password, or blank to cancel:");
#line 1932
    send_query(& (op->contr)->socket, (uint8 )4, tmp___10);
#line 1933
    player_set_state(op->contr, (uint8 )13);
    }
#line 1934
    return;
  }
#line 1937
  if ((int )(op->contr)->state == 13) {
    {
#line 1938
    tmp___13 = crypt_string((char const   *)((op->contr)->write_buf + 1), (char const   *)((op->contr)->new_password));
#line 1938
    tmp___14 = strcmp((char const   *)tmp___13, (char const   *)((op->contr)->new_password));
    }
#line 1938
    if (tmp___14) {
      {
#line 1939
      tmp___11 = i18n((object const   *)op, "The new passwords don\'t match!");
#line 1939
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___11);
      }
    } else {
      {
#line 1942
      tmp___12 = i18n((object const   *)op, "Password changed.");
#line 1942
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___12);
#line 1944
      strncpy((char */* __restrict  */)((op->contr)->password), (char const   */* __restrict  */)((op->contr)->new_password),
              (size_t )13);
      }
    }
    {
#line 1946
    player_set_state(op->contr, (uint8 )0);
    }
#line 1947
    return;
  }
  {
#line 1950
  tmp___15 = crypt_string((char const   *)((op->contr)->write_buf + 1), (char const   *)((void *)0));
#line 1950
  strcpy((char */* __restrict  */)((op->contr)->password), (char const   */* __restrict  */)tmp___15);
#line 1951
  player_set_state(op->contr, (uint8 )2);
#line 1952
  check_login(op, 1);
  }
#line 1953
  return;
}
}
#line 1965 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_title(object *op , char const   *params ) 
{ 
  char buf[256] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char tmp___2[256] ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  size_t tmp___10 ;

  {
#line 1968
  if ((int )settings.set_title == 0) {
    {
#line 1969
    tmp = i18n((object const   *)op, "You cannot change your title.");
#line 1969
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )7, tmp);
    }
#line 1971
    return;
  }
  {
#line 1975
  tmp___1 = is_dragon_pl((object const   *)op);
  }
#line 1975
  if (tmp___1) {
    {
#line 1976
    tmp___0 = i18n((object const   *)op, "Dragons cannot change titles.");
#line 1976
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )7, tmp___0);
    }
#line 1978
    return;
  }
#line 1981
  if ((int const   )*params == 0) {
    {
#line 1984
    player_get_title((struct pl  const  *)op->contr, tmp___2, sizeof(tmp___2));
#line 1985
    tmp___3 = i18n((object const   *)op, "Your title is \'%s\'.");
#line 1985
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)tmp___3,
             tmp___2);
#line 1986
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )7, (char const   *)(buf));
    }
#line 1987
    return;
  }
  {
#line 1989
  tmp___7 = strcmp(params, "clear");
  }
#line 1989
  if (tmp___7 == 0) {
#line 1989
    goto _L;
  } else {
    {
#line 1989
    tmp___8 = strcmp(params, "default");
    }
#line 1989
    if (tmp___8 == 0) {
      _L: /* CIL Label */ 
      {
#line 1990
      tmp___6 = player_has_own_title((struct pl  const  *)op->contr);
      }
#line 1990
      if (tmp___6) {
        {
#line 1994
        tmp___5 = i18n((object const   *)op, "Title set to default.");
#line 1994
        draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )7, tmp___5);
        }
      } else {
        {
#line 1991
        tmp___4 = i18n((object const   *)op, "Your title is the default title.");
#line 1991
        draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )7, tmp___4);
        }
      }
      {
#line 1996
      player_set_own_title(op->contr, "");
      }
#line 1997
      return;
    }
  }
  {
#line 2000
  tmp___10 = strlen(params);
  }
#line 2000
  if ((int )tmp___10 >= 48) {
    {
#line 2001
    tmp___9 = i18n((object const   *)op, "Title too long.");
#line 2001
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )7, tmp___9);
    }
#line 2003
    return;
  }
  {
#line 2005
  player_set_own_title(op->contr, params);
  }
#line 2006
  return;
}
}
#line 2016 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_save(object *op , char const   *params ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 2017
  tmp___4 = get_map_flags(op->map, (mapstruct **)((void *)0), op->x, op->y, (sint16 *)((void *)0),
                          (sint16 *)((void *)0));
  }
#line 2017
  if (tmp___4 & 32) {
    {
#line 2018
    tmp = i18n((object const   *)op, "You can not save on unholy ground.");
#line 2018
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp);
    }
  } else
#line 2020
  if (! op->stats.exp) {
    {
#line 2021
    tmp___0 = i18n((object const   *)op, "You don\'t deserve to save yet.");
#line 2021
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___0);
    }
  } else {
    {
#line 2024
    tmp___3 = save_player(op, 1);
    }
#line 2024
    if (tmp___3) {
      {
#line 2025
      tmp___1 = i18n((object const   *)op, "You have been saved.");
#line 2025
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___1);
      }
    } else {
      {
#line 2028
      tmp___2 = i18n((object const   *)op, "SAVE FAILED!");
#line 2028
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___2);
      }
    }
  }
#line 2031
  return;
}
}
#line 2041 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_peaceful(object *op , char const   *params ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  uint32 tmp___1 ;

  {
#line 2042
  tmp___1 = (uint32 )(! (op->contr)->peaceful);
#line 2042
  (op->contr)->peaceful = tmp___1;
#line 2042
  if (tmp___1) {
    {
#line 2043
    tmp = i18n((object const   *)op, "You will not attack other players.");
#line 2043
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )7, tmp);
    }
  } else {
    {
#line 2046
    tmp___0 = i18n((object const   *)op, "You will attack other players.");
#line 2046
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )7, tmp___0);
    }
  }
#line 2048
  return;
}
}
#line 2058 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_wimpy(object *op , char const   *params ) 
{ 
  int i ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 2061
  if ((int const   )*params == 0) {
    {
#line 2062
    tmp = i18n((object const   *)op, "Your current wimpy level is %d.");
#line 2062
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )7, tmp,
                         (int )op->run_away);
    }
#line 2065
    return;
  } else {
    {
#line 2061
    tmp___0 = sscanf((char const   */* __restrict  */)params, (char const   */* __restrict  */)"%d",
                     & i);
    }
#line 2061
    if (! tmp___0) {
      {
#line 2062
      tmp = i18n((object const   *)op, "Your current wimpy level is %d.");
#line 2062
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )7, tmp,
                           (int )op->run_away);
      }
#line 2065
      return;
    }
  }
  {
#line 2068
  tmp___1 = i18n((object const   *)op, "Your new wimpy level is %d.");
#line 2068
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )7, tmp___1,
                       i);
#line 2071
  op->run_away = (uint16 )i;
  }
#line 2072
  return;
}
}
#line 2082 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_brace(object *op , char const   *params ) 
{ 
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 2083
  if ((int const   )*params == 0) {
#line 2084
    (op->contr)->braced = (uint32 )(! (op->contr)->braced);
  } else {
    {
#line 2086
    tmp = onoff_value(params);
#line 2086
    (op->contr)->braced = (uint32 )tmp;
    }
  }
#line 2088
  if ((op->contr)->braced) {
    {
#line 2089
    tmp___0 = i18n((object const   *)op, "You are braced.");
#line 2089
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___0);
    }
  } else {
    {
#line 2092
    tmp___1 = i18n((object const   *)op, "Not braced.");
#line 2092
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___1);
    }
  }
  {
#line 2095
  fix_object(op);
  }
#line 2096
  return;
}
}
#line 2106 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_kill_pets(object *op , char const   *params ) 
{ 
  objectlink *obl ;
  objectlink *next ;
  int counter ;
  int removecount ;
  char const   *tmp ;
  int target ;
  int tmp___0 ;
  object *ob ;
  int tmp___1 ;
  object *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 2108
  counter = 0;
#line 2108
  removecount = 0;
#line 2110
  if ((int const   )*params == 0) {
    {
#line 2111
    pets_terminate_all(op);
#line 2112
    tmp = i18n((object const   *)op, "Your pets have been killed.");
#line 2112
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp);
    }
  } else {
    {
#line 2115
    tmp___0 = atoi(params);
#line 2115
    target = tmp___0;
#line 2116
    obl = first_friendly_object;
    }
    {
#line 2116
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2116
      if (! ((unsigned long )obl != (unsigned long )((void *)0))) {
#line 2116
        goto while_break;
      }
      {
#line 2117
      ob = obl->ob;
#line 2118
      next = obl->next;
#line 2119
      tmp___2 = object_get_owner(ob);
      }
#line 2119
      if ((unsigned long )tmp___2 == (unsigned long )op) {
#line 2120
        counter ++;
#line 2120
        if (counter == target) {
#line 2120
          goto _L;
        } else
#line 2120
        if (target == 0) {
          {
#line 2120
          tmp___1 = strcasecmp(ob->name, params);
          }
#line 2120
          if (! tmp___1) {
            _L: /* CIL Label */ 
#line 2121
            if (! (ob->flags[0] & (1U << 2))) {
              {
#line 2122
              object_remove(ob);
              }
            }
            {
#line 2123
            remove_friendly_object(ob);
#line 2124
            object_free_drop_inventory(ob);
#line 2125
            removecount ++;
            }
          }
        }
      }
#line 2116
      obl = next;
    }
    while_break: /* CIL Label */ ;
    }
#line 2128
    if (removecount != 0) {
      {
#line 2129
      tmp___3 = i18n((object const   *)op, "Killed %d pets.");
#line 2129
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___3,
                           removecount);
      }
    } else {
      {
#line 2133
      tmp___4 = i18n((object const   *)op, "Couldn\'t find any suitable pets to kill.");
#line 2133
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )0, tmp___4);
      }
    }
  }
#line 2136
  return;
}
}
#line 2146 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void command_passwd(object *pl , char const   *params ) 
{ 
  char const   *tmp ;

  {
  {
#line 2147
  tmp = i18n((object const   *)pl, "Password change.\nPlease enter your current password, or empty string to cancel.");
#line 2147
  send_query(& (pl->contr)->socket, (uint8 )4, tmp);
#line 2149
  player_set_state(pl->contr, (uint8 )11);
  }
#line 2150
  return;
}
}
#line 2161 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c"
void do_harvest(object *pl , int dir , object *skill ) 
{ 
  sint16 x ;
  sint16 y ;
  int count ;
  int proba ;
  int level ;
  int exp ;
  object *found[10] ;
  mapstruct *map ;
  object *item ;
  object *inv ;
  sstring trace ;
  sstring ttool ;
  sstring tspeed ;
  sstring race ;
  sstring tool ;
  sstring slevel ;
  sstring sexp ;
  float speed ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  object *inv___0 ;
  object *next2200 ;
  tag_t next_tag2200 ;
  tag_t tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  double tmp___7 ;
  int tmp___8 ;
  uint32 tmp___9 ;
  int spot ;
  int tmp___10 ;

  {
#line 2163
  count = 0;
#line 2171
  x = (sint16 )((int )pl->x + (int )freearr_x[dir]);
#line 2172
  y = (sint16 )((int )pl->y + (int )freearr_y[dir]);
#line 2173
  map = pl->map;
#line 2175
  if (! pl->type == 1) {
#line 2176
    return;
  }
#line 2178
  if (! map) {
#line 2179
    return;
  }
  {
#line 2181
  tmp = get_map_flags(map, & map, x, y, & x, & y);
  }
#line 2181
  if (tmp & 256) {
    {
#line 2182
    draw_ext_info_format(1, 0, (object const   *)pl, (uint8 )12, (uint8 )4, "You can\'t %s anything here.",
                         skill->slaying);
    }
#line 2183
    return;
  }
#line 2186
  if (! pl->chosen_skill) {
#line 2187
    return;
  } else
#line 2186
  if ((unsigned long )(pl->chosen_skill)->skill != (unsigned long )skill->skill) {
#line 2187
    return;
  }
  {
#line 2189
  trace = object_get_value((object const   *)pl->chosen_skill, (char const   */* const  */)"harvest_race");
#line 2190
  ttool = object_get_value((object const   *)pl->chosen_skill, (char const   */* const  */)"harvest_tool");
#line 2191
  tspeed = object_get_value((object const   *)pl->chosen_skill, (char const   */* const  */)"harvest_speed");
  }
#line 2192
  if (! trace) {
    {
#line 2193
    draw_ext_info_format(1, 0, (object const   *)pl, (uint8 )12, (uint8 )4, "You can\'t %s anything here.",
                         skill->slaying);
#line 2194
    LOG((LogLevel )0, "do_harvest: tool %s without harvest_[race|tool|speed]\n", (pl->chosen_skill)->name);
    }
#line 2195
    return;
  } else {
    {
#line 2192
    tmp___0 = strcmp(trace, "");
    }
#line 2192
    if (tmp___0 == 0) {
      {
#line 2193
      draw_ext_info_format(1, 0, (object const   *)pl, (uint8 )12, (uint8 )4, "You can\'t %s anything here.",
                           skill->slaying);
#line 2194
      LOG((LogLevel )0, "do_harvest: tool %s without harvest_[race|tool|speed]\n",
          (pl->chosen_skill)->name);
      }
#line 2195
      return;
    } else
#line 2192
    if (! ttool) {
      {
#line 2193
      draw_ext_info_format(1, 0, (object const   *)pl, (uint8 )12, (uint8 )4, "You can\'t %s anything here.",
                           skill->slaying);
#line 2194
      LOG((LogLevel )0, "do_harvest: tool %s without harvest_[race|tool|speed]\n",
          (pl->chosen_skill)->name);
      }
#line 2195
      return;
    } else {
      {
#line 2192
      tmp___1 = strcmp(ttool, "");
      }
#line 2192
      if (tmp___1 == 0) {
        {
#line 2193
        draw_ext_info_format(1, 0, (object const   *)pl, (uint8 )12, (uint8 )4, "You can\'t %s anything here.",
                             skill->slaying);
#line 2194
        LOG((LogLevel )0, "do_harvest: tool %s without harvest_[race|tool|speed]\n",
            (pl->chosen_skill)->name);
        }
#line 2195
        return;
      } else
#line 2192
      if (! tspeed) {
        {
#line 2193
        draw_ext_info_format(1, 0, (object const   *)pl, (uint8 )12, (uint8 )4, "You can\'t %s anything here.",
                             skill->slaying);
#line 2194
        LOG((LogLevel )0, "do_harvest: tool %s without harvest_[race|tool|speed]\n",
            (pl->chosen_skill)->name);
        }
#line 2195
        return;
      } else {
        {
#line 2192
        tmp___2 = strcmp(tspeed, "");
        }
#line 2192
        if (tmp___2 == 0) {
          {
#line 2193
          draw_ext_info_format(1, 0, (object const   *)pl, (uint8 )12, (uint8 )4,
                               "You can\'t %s anything here.", skill->slaying);
#line 2194
          LOG((LogLevel )0, "do_harvest: tool %s without harvest_[race|tool|speed]\n",
              (pl->chosen_skill)->name);
          }
#line 2195
          return;
        }
      }
    }
  }
#line 2198
  item = (map->spaces + ((int )x + (int )map->width * (int )y))->bottom;
  {
#line 2199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2199
    if (item) {
#line 2199
      if (! (count < 10)) {
#line 2199
        goto while_break;
      }
    } else {
#line 2199
      goto while_break;
    }
    {
#line 2200
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2200
      inv___0 = item->inv;
      {
#line 2200
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2200
        next2200 = inv___0;
#line 2200
        if ((unsigned long )next2200 == (unsigned long )((void *)0)) {
#line 2200
          tmp___3 = (tag_t )0;
        } else {
#line 2200
          tmp___3 = next2200->count;
        }
#line 2200
        next_tag2200 = tmp___3;
        {
#line 2200
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2200
          inv___0 = next2200;
#line 2200
          if (! ((unsigned long )inv___0 != (unsigned long )((void *)0))) {
#line 2200
            goto while_break___2;
          }
#line 2200
          if (next2200->count != next_tag2200) {
#line 2200
            goto while_break___2;
          } else
#line 2200
          if (next2200->flags[0] & (1U << 3)) {
#line 2200
            goto while_break___2;
          }
#line 2200
          next2200 = next2200->below;
#line 2200
          if ((unsigned long )next2200 == (unsigned long )((void *)0)) {
#line 2200
            next_tag2200 = (tag_t )0;
          } else {
#line 2200
            next_tag2200 = next2200->count;
          }
          {
#line 2201
          tmp___4 = object_get_value((object const   *)inv___0, (char const   */* const  */)"harvestable");
          }
#line 2201
          if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 2202
            goto while_continue___2;
          }
          {
#line 2203
          race = object_get_value((object const   *)inv___0, (char const   */* const  */)"harvest_race");
#line 2204
          tool = object_get_value((object const   *)inv___0, (char const   */* const  */)"harvest_tool");
#line 2205
          slevel = object_get_value((object const   *)inv___0, (char const   */* const  */)"harvest_level");
#line 2206
          sexp = object_get_value((object const   *)inv___0, (char const   */* const  */)"harvest_exp");
          }
#line 2207
          if (race) {
#line 2207
            if (! slevel) {
              {
#line 2208
              LOG((LogLevel )0, "do_harvest: item %s without harvest_[level|exp]\n",
                  inv___0->name);
              }
#line 2209
              goto while_continue___2;
            } else
#line 2207
            if (! sexp) {
              {
#line 2208
              LOG((LogLevel )0, "do_harvest: item %s without harvest_[level|exp]\n",
                  inv___0->name);
              }
#line 2209
              goto while_continue___2;
            }
          }
#line 2211
          if ((unsigned long )race == (unsigned long )trace) {
#line 2211
            if (! tool) {
#line 2212
              tmp___5 = count;
#line 2212
              count ++;
#line 2212
              found[tmp___5] = inv___0;
            } else
#line 2211
            if ((unsigned long )tool == (unsigned long )ttool) {
#line 2212
              tmp___5 = count;
#line 2212
              count ++;
#line 2212
              found[tmp___5] = inv___0;
            }
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2200
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2200
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2214
    item = item->above;
  }
  while_break: /* CIL Label */ ;
  }
#line 2216
  if (count == 0) {
    {
#line 2217
    draw_ext_info_format(1, 0, (object const   *)pl, (uint8 )12, (uint8 )4, "You can\'t %s anything here.",
                         skill->slaying);
    }
#line 2218
    return;
  }
  {
#line 2221
  tmp___6 = rndm(0, count - 1);
#line 2221
  inv = found[tmp___6];
  }
#line 2222
  if (! inv) {
    {
#line 2222
    __assert_fail("inv", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_misc.c",
                  2222U, "do_harvest");
    }
  }
  {
#line 2224
  slevel = object_get_value((object const   *)inv, (char const   */* const  */)"harvest_level");
#line 2225
  sexp = object_get_value((object const   *)inv, (char const   */* const  */)"harvest_exp");
#line 2226
  level = atoi(slevel);
#line 2227
  exp = atoi(sexp);
#line 2229
  tmp___7 = atof(tspeed);
#line 2229
  speed = (float )tmp___7;
  }
#line 2230
  if (speed < (float )0) {
#line 2231
    speed = - speed * pl->speed;
  }
#line 2232
  pl->speed_left -= speed;
#line 2236
  if (level > (int )skill->level + 10) {
    {
#line 2237
    draw_ext_info_format(1, 0, (object const   *)pl, (uint8 )12, (uint8 )4, "You fail to %s anything.",
                         skill->slaying);
    }
#line 2238
    return;
  }
#line 2241
  if (level >= (int )skill->level) {
#line 2243
    proba = (10 + (int )skill->level) - level;
  } else
#line 2244
  if ((int )skill->level <= level + 10) {
#line 2245
    proba = 10 + ((int )skill->level - level) * 2;
  } else {
#line 2247
    proba = 30;
  }
  {
#line 2249
  tmp___8 = random_roll(0, 100, (object const   *)pl, 1);
  }
#line 2249
  if (proba <= tmp___8) {
    {
#line 2250
    draw_ext_info_format(1, 0, (object const   *)pl, (uint8 )12, (uint8 )4, "You fail to %s anything.",
                         skill->slaying);
    }
#line 2251
    return;
  }
  {
#line 2256
  tmp___9 = get_weight_limit((int )pl->stats.Str);
  }
#line 2256
  if ((uint32 )((pl->weight + pl->carrying) + inv->weight) > tmp___9) {
    {
#line 2257
    draw_ext_info_format(1, 0, (object const   *)pl, (uint8 )12, (uint8 )4, "You are carrying too much to %s a %s.",
                         skill->slaying, inv->name);
    }
#line 2258
    return;
  }
  {
#line 2262
  item = object_new();
#line 2263
  object_copy_with_inv((object const   *)inv, item);
#line 2264
  object_set_value(item, "harvestable", (char const   *)((void *)0), 0);
  }
#line 2265
  if (item->flags[0] & (1U << 14)) {
    {
#line 2266
    tmp___10 = object_find_free_spot((object const   *)item, pl->map, (int )pl->x,
                                     (int )pl->y, 0, 49);
#line 2266
    spot = tmp___10;
    }
#line 2267
    if (spot == -1) {
      {
#line 2269
      object_remove(item);
#line 2270
      draw_ext_info_format(1, 0, (object const   *)pl, (uint8 )12, (uint8 )4, "You fail to %s anything.",
                           skill->slaying);
      }
#line 2271
      return;
    }
    {
#line 2273
    object_insert_in_map_at(item, pl->map, (object *)((void *)0), 0, (int )pl->x + (int )freearr_x[spot],
                            (int )pl->y + (int )freearr_y[spot]);
#line 2274
    draw_ext_info_format(1, 0, (object const   *)pl, (uint8 )12, (uint8 )4, "You %s a %s!",
                         skill->slaying, item->name);
    }
  } else {
    {
#line 2276
    item = object_insert_in_ob(item, pl);
#line 2277
    draw_ext_info_format(1, 0, (object const   *)pl, (uint8 )12, (uint8 )4, "You %s some %s",
                         skill->slaying, item->name);
    }
  }
  {
#line 2281
  change_exp(pl, (sint64 )exp, skill->name, 0);
  }
#line 2283
  return;
}
}
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 159 "../include/attack.h"
attackmess_t attack_mess[21][21] ;
#line 162
Chaos_Attacks ATTACKS[22] ;
#line 72 "../include/material.h"
materialtype_t *materialt ;
#line 86 "../include/living.h"
int get_turn_bonus(int stat___0 ) ;
#line 239 "../include/global.h"
char const   *undead_name ;
#line 138 "../include/libproto.h"
void drain_stat(object *op ) ;
#line 141
void change_luck(object *op , int value ) ;
#line 151
sint64 check_exp_loss(object const   *op , sint64 exp ) ;
#line 155
int did_make_save(object const   *op , int level , int bonus ) ;
#line 156
void share_exp(object *op , sint64 exp , char const   *skill , int flag ) ;
#line 210
extern int on_same_map(object const   *op1 , object const   *op2 ) ;
#line 240
extern void object_copy_owner(object *op , object *clone ) ;
#line 263
extern void object_replace_insert_in_map(char const   *arch_string , object *op ) ;
#line 269
extern object *map_find_by_archetype(mapstruct *m , int x , int y , archetype const   *at ) ;
#line 271
extern object *object_present_in_ob(uint8 type , object const   *op ) ;
#line 273
extern object *arch_present_in_ob(archetype const   *at , object const   *op ) ;
#line 292
extern object *object_find_by_type2(object const   *who , int type1 , int type2 ) ;
#line 331
extern int is_wraith_pl(object *op ) ;
#line 423
materialtype_t *name_to_material(char const   *name ) ;
#line 46 "../include/sproto.h"
void save_throw_object(object *op , uint32 type , object *originator ) ;
#line 47
int hit_map(object *op , int dir , uint32 type , int full_hit ) ;
#line 48
int attack_ob(object *op , object *hitter ) ;
#line 49
object *hit_with_arrow(object *op , object *victim ) ;
#line 50
int friendly_fire(object *op , object *hitter ) ;
#line 299
extern void check_physically_infect(object *victim , object *hitter ) ;
#line 307
extern char const   *determine_god(object *op ) ;
#line 350
extern int monster_stand_in_light(object *op ) ;
#line 351
extern int monster_can_see_enemy(object *op , object *enemy ) ;
#line 427
extern void kill_player(object *op , object const   *killer ) ;
#line 431
extern void make_visible(object *op ) ;
#line 436
extern int player_can_view(object *pl , object *op ) ;
#line 437
extern int op_on_battleground(object *op , int *x , int *y , archetype **trophy ) ;
#line 468
extern void spring_trap(object *trap , object *victim ) ;
#line 512
extern sint64 calc_skill_exp(object const   *who , object const   *op , object const   *skill ) ;
#line 557
extern void counterspell(object *op , int dir ) ;
#line 588
extern void shuffle_attack(object *op , int change_face ) ;
#line 604
extern object *stop_item(object *op ) ;
#line 605
extern void fix_stopped_item(object *op , mapstruct *map , object *originator ) ;
#line 606
extern object *fix_stopped_arrow(object *op ) ;
#line 607
extern int free_no_drop(object *op ) ;
#line 608
extern void change_object(object *op ) ;
#line 611
extern int process_object(object *op ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
static void slow_living(object *op , object *hitter , int dam ) ;
#line 50
static void deathstrike_living(object *op , object *hitter , int *dam ) ;
#line 51
static int adj_attackroll(object *hitter , object *target ) ;
#line 52
static int is_aimed_missile(object *op ) ;
#line 53
static int did_make_save_item(object *op , int type , object *originator ) ;
#line 54
static void poison_living(object *op , object *hitter , int dam ) ;
#line 63 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
static void cancellation(object *op ) 
{ 
  object *inv ;
  object *next69 ;
  tag_t next_tag69 ;
  tag_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 64
  if (op->invisible) {
#line 65
    return;
  }
#line 67
  if (op->flags[0] & 1U) {
#line 67
    goto _L;
  } else
#line 67
  if ((int )op->type == 122) {
#line 67
    goto _L;
  } else
#line 67
  if ((int )op->type == 48) {
    _L: /* CIL Label */ 
    {
#line 69
    while (1) {
      while_continue: /* CIL Label */ ;
#line 69
      inv = op->inv;
      {
#line 69
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 69
        next69 = inv;
#line 69
        if ((unsigned long )next69 == (unsigned long )((void *)0)) {
#line 69
          tmp = (tag_t )0;
        } else {
#line 69
          tmp = next69->count;
        }
#line 69
        next_tag69 = tmp;
        {
#line 69
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 69
          inv = next69;
#line 69
          if (! ((unsigned long )inv != (unsigned long )((void *)0))) {
#line 69
            goto while_break___1;
          }
#line 69
          if (next69->count != next_tag69) {
#line 69
            goto while_break___1;
          } else
#line 69
          if (next69->flags[0] & (1U << 3)) {
#line 69
            goto while_break___1;
          }
#line 69
          next69 = next69->below;
#line 69
          if ((unsigned long )next69 == (unsigned long )((void *)0)) {
#line 69
            next_tag69 = (tag_t )0;
          } else {
#line 69
            next_tag69 = next69->count;
          }
          {
#line 70
          tmp___0 = did_make_save_item(inv, 32768, op);
          }
#line 70
          if (! tmp___0) {
            {
#line 71
            cancellation(inv);
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 69
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 69
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 73
    if ((int )op->magic < 0) {
#line 73
      tmp___1 = - ((int )op->magic);
    } else {
#line 73
      tmp___1 = (int )op->magic;
    }
    {
#line 73
    tmp___2 = rndm(0, 5);
    }
#line 73
    if (tmp___1 <= tmp___2) {
#line 76
      op->magic = (sint8 )0;
#line 77
      op->flags[2] &= ~ (1U << 11);
#line 78
      op->flags[2] &= ~ (1U << 10);
#line 79
      op->flags[2] &= ~ (1U << 13);
#line 80
      op->flags[2] &= ~ (1U << 14);
#line 81
      if (op->env) {
#line 81
        if ((int )(op->env)->type == 1) {
          {
#line 82
          esrv_update_item(2, op->env, op);
          }
        }
      }
    }
  }
#line 85
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
static int did_make_save_item(object *op , int type , object *originator ) 
{ 
  int i ;
  int roll ;
  int saves ;
  int attacks___0 ;
  int number ;
  materialtype_t *mt ;
  int tmp ;

  {
#line 103
  saves = 0;
#line 103
  attacks___0 = 0;
#line 106
  if ((unsigned long )op->materialname == (unsigned long )((void *)0)) {
#line 107
    mt = materialt;
    {
#line 107
    while (1) {
      while_continue: /* CIL Label */ ;
#line 107
      if ((unsigned long )mt != (unsigned long )((void *)0)) {
#line 107
        if (! ((unsigned long )mt->next != (unsigned long )((void *)0))) {
#line 107
          goto while_break;
        }
      } else {
#line 107
        goto while_break;
      }
#line 108
      if ((int )op->material & mt->material) {
#line 109
        goto while_break;
      }
#line 107
      mt = mt->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 112
    mt = name_to_material(op->materialname);
    }
  }
#line 113
  if ((unsigned long )mt == (unsigned long )((void *)0)) {
#line 114
    return (1);
  }
  {
#line 115
  roll = rndm(1, 20);
  }
#line 125
  if (type != 2) {
#line 126
    type &= -23821987;
  }
#line 131
  if (type == 0) {
#line 132
    return (1);
  }
#line 133
  if (roll == 20) {
#line 134
    return (1);
  }
#line 135
  if (roll == 1) {
#line 136
    return (0);
  }
#line 138
  number = 0;
  {
#line 138
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 138
    if (! (number < 26)) {
#line 138
      goto while_break___0;
    }
#line 139
    i = 1 << number;
#line 140
    if (! (i & type)) {
#line 141
      goto __Cont;
    }
#line 142
    attacks___0 ++;
#line 143
    if ((int )op->resist[number] == 100) {
#line 144
      saves ++;
    } else
#line 145
    if (roll >= ((int )mt->save[number] - (int )op->magic) - (int )op->resist[number] / 100) {
#line 146
      saves ++;
    } else
#line 147
    if ((20 - (int )mt->save[number]) / 3 > (int )originator->stats.dam) {
#line 148
      saves ++;
    }
    __Cont: /* CIL Label */ 
#line 138
    number ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 151
  if (saves == attacks___0) {
#line 152
    return (1);
  } else
#line 151
  if (attacks___0 == 0) {
#line 152
    return (1);
  }
#line 153
  if (saves == 0) {
#line 154
    return (0);
  } else {
    {
#line 153
    tmp = rndm(1, attacks___0);
    }
#line 153
    if (tmp > saves) {
#line 154
      return (0);
    }
  }
#line 155
  return (1);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
void save_throw_object(object *op , uint32 type , object *originator ) 
{ 
  object *env ;
  int x ;
  int y ;
  mapstruct *m ;
  object *inv ;
  object *next181 ;
  tag_t next_tag181 ;
  tag_t tmp ;
  char const   *arch ;
  int tmp___0 ;
  int tmp___1 ;
  object *tmp___2 ;
  archetype *at ;
  archetype *tmp___3 ;
  long tmp___4 ;

  {
  {
#line 171
  tmp___1 = did_make_save_item(op, (int )type, originator);
  }
#line 171
  if (! tmp___1) {
    {
#line 172
    env = op->env;
#line 173
    x = (int )op->x;
#line 173
    y = (int )op->y;
#line 174
    m = op->map;
#line 176
    op = stop_item(op);
    }
#line 177
    if ((unsigned long )op == (unsigned long )((void *)0)) {
#line 178
      return;
    }
    {
#line 181
    while (1) {
      while_continue: /* CIL Label */ ;
#line 181
      inv = op->inv;
      {
#line 181
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 181
        next181 = inv;
#line 181
        if ((unsigned long )next181 == (unsigned long )((void *)0)) {
#line 181
          tmp = (tag_t )0;
        } else {
#line 181
          tmp = next181->count;
        }
#line 181
        next_tag181 = tmp;
        {
#line 181
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 181
          inv = next181;
#line 181
          if (! ((unsigned long )inv != (unsigned long )((void *)0))) {
#line 181
            goto while_break___1;
          }
#line 181
          if (next181->count != next_tag181) {
#line 181
            goto while_break___1;
          } else
#line 181
          if (next181->flags[0] & (1U << 3)) {
#line 181
            goto while_break___1;
          }
#line 181
          next181 = next181->below;
#line 181
          if ((unsigned long )next181 == (unsigned long )((void *)0)) {
#line 181
            next_tag181 = (tag_t )0;
          } else {
#line 181
            next_tag181 = next181->count;
          }
#line 182
          if ((int )inv->type == 154) {
            {
#line 183
            spring_trap(inv, originator);
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 181
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 181
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 194
    if (type & 12U) {
#line 194
      if (op->other_arch) {
#line 194
        if (op->flags[1] & (1U << 11)) {
          {
#line 197
          arch = (op->other_arch)->name;
#line 199
          op = object_decrease_nrof(op, (uint32 )1);
          }
#line 200
          if (op) {
            {
#line 201
            fix_stopped_item(op, m, originator);
            }
          }
          {
#line 202
          op = create_archetype(arch);
          }
#line 203
          if ((unsigned long )op != (unsigned long )((void *)0)) {
#line 204
            if (env) {
              {
#line 205
              op->x = env->x;
#line 205
              op->y = env->y;
#line 207
              object_insert_in_ob(op, env);
              }
            } else {
              {
#line 209
              object_insert_in_map_at(op, m, originator, 0, x, y);
              }
            }
          }
#line 211
          return;
        }
      }
    }
#line 213
    if (type & 32768U) {
      {
#line 214
      cancellation(op);
#line 215
      fix_stopped_item(op, m, originator);
      }
#line 216
      return;
    }
#line 218
    if (op->nrof > 1U) {
      {
#line 219
      tmp___0 = rndm(0, (int )(op->nrof - 1U));
#line 219
      op = object_decrease_nrof(op, (uint32 )tmp___0);
      }
#line 220
      if (op) {
        {
#line 221
        fix_stopped_item(op, m, originator);
        }
      }
    } else {
#line 223
      if (! (op->flags[0] & (1U << 2))) {
        {
#line 224
        object_remove(op);
        }
      }
      {
#line 225
      object_free_drop_inventory(op);
      }
    }
#line 227
    if (type & 12U) {
#line 228
      if (env) {
        {
#line 229
        op = create_archetype("burnout");
#line 230
        op->x = env->x;
#line 230
        op->y = env->y;
#line 232
        object_insert_in_ob(op, env);
        }
      } else {
        {
#line 234
        object_replace_insert_in_map("burnout", originator);
        }
      }
    }
#line 237
    return;
  }
#line 240
  if (type & 16U) {
#line 240
    if ((int )op->resist[4] < 50) {
#line 240
      if (! (op->flags[0] & (1U << 8))) {
        {
#line 240
        tmp___4 = random();
        }
#line 240
        if (tmp___4 & 2L) {
          {
#line 245
          tmp___3 = find_archetype("icecube");
#line 245
          at = tmp___3;
          }
#line 247
          if ((unsigned long )at == (unsigned long )((void *)0)) {
#line 248
            return;
          }
          {
#line 249
          op = stop_item(op);
          }
#line 250
          if ((unsigned long )op == (unsigned long )((void *)0)) {
#line 251
            return;
          }
          {
#line 252
          tmp___2 = map_find_by_archetype(op->map, (int )op->x, (int )op->y, (archetype const   *)at);
          }
#line 253
          if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
            {
#line 254
            tmp___2 = arch_to_object(at);
#line 259
            tmp___2->move_slow_penalty = (float )0;
#line 260
            tmp___2->move_slow = (MoveType )0;
#line 261
            object_insert_in_map_at(tmp___2, op->map, originator, 0, (int )op->x,
                                    (int )op->y);
            }
          }
#line 263
          if (! (op->flags[0] & (1U << 2))) {
            {
#line 264
            object_remove(op);
            }
          }
          {
#line 265
          object_insert_in_ob(op, tmp___2);
          }
#line 266
          return;
        }
      }
    }
  }
#line 268
  return;
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
int hit_map(object *op , int dir , uint32 type , int full_hit ) 
{ 
  mapstruct *map ;
  sint16 x ;
  sint16 y ;
  int retflag ;
  tag_t op_tag ;
  int tmp ;
  object *tmp___0 ;
  object *next337 ;
  tag_t next_tag337 ;
  tag_t tmp___1 ;
  object *pl ;
  object *next354 ;
  tag_t next_tag354 ;
  tag_t tmp___2 ;

  {
#line 288
  retflag = 0;
#line 291
  if (op->flags[0] & (1U << 3)) {
    {
#line 292
    LOG((LogLevel )0, "BUG: hit_map(): free object\n");
    }
#line 293
    return (0);
  }
#line 296
  if (op->flags[0] & (1U << 2)) {
    {
#line 297
    LOG((LogLevel )0, "BUG: hit_map(): hitter (arch %s, name %s) not on a map\n",
        (op->arch)->name, op->name);
    }
#line 298
    return (0);
  } else
#line 296
  if ((unsigned long )op->env != (unsigned long )((void *)0)) {
    {
#line 297
    LOG((LogLevel )0, "BUG: hit_map(): hitter (arch %s, name %s) not on a map\n",
        (op->arch)->name, op->name);
    }
#line 298
    return (0);
  }
#line 301
  if (! op->map) {
    {
#line 302
    LOG((LogLevel )0, "BUG: hit_map(): %s has no map\n", op->name);
    }
#line 303
    return (0);
  }
#line 306
  if ((unsigned long )op->head != (unsigned long )((void *)0)) {
#line 306
    op = op->head;
  } else {
#line 306
    op = op;
  }
  {
#line 307
  op_tag = op->count;
#line 309
  map = op->map;
#line 310
  x = (sint16 )((int )op->x + (int )freearr_x[dir]);
#line 311
  y = (sint16 )((int )op->y + (int )freearr_y[dir]);
#line 312
  tmp = get_map_flags(map, & map, x, y, & x, & y);
  }
#line 312
  if (tmp & 256) {
#line 313
    return (0);
  }
#line 319
  if (type & 524288U) {
    {
#line 320
    counterspell(op, dir);
    }
#line 325
    if (! (type & 4294443005U)) {
#line 326
      return (0);
    }
#line 328
    type &= 4294443007U;
  }
#line 331
  if (type & 262144U) {
    {
#line 332
    shuffle_attack(op, 1);
#line 333
    object_update(op, 4);
#line 334
    type &= 4294705151U;
    }
  }
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    tmp___0 = (map->spaces + ((int )x + (int )map->width * (int )y))->bottom;
    {
#line 337
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 337
      next337 = tmp___0;
#line 337
      if ((unsigned long )next337 == (unsigned long )((void *)0)) {
#line 337
        tmp___1 = (tag_t )0;
      } else {
#line 337
        tmp___1 = next337->count;
      }
#line 337
      next_tag337 = tmp___1;
      {
#line 337
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 337
        tmp___0 = next337;
#line 337
        if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 337
          goto while_break___1;
        }
#line 337
        if (next337->count != next_tag337) {
#line 337
          goto while_break___1;
        } else
#line 337
        if (next337->flags[0] & (1U << 3)) {
#line 337
          goto while_break___1;
        }
#line 337
        next337 = next337->above;
#line 337
        if ((unsigned long )next337 == (unsigned long )((void *)0)) {
#line 337
          next_tag337 = (tag_t )0;
        } else {
#line 337
          next_tag337 = next337->count;
        }
#line 338
        if (tmp___0->flags[0] & (1U << 3)) {
          {
#line 339
          LOG((LogLevel )0, "BUG: hit_map(): found freed object\n");
          }
#line 340
          goto while_break___1;
        }
#line 347
        if ((unsigned long )tmp___0->map != (unsigned long )map) {
#line 348
          goto while_continue___1;
        } else
#line 347
        if ((int )tmp___0->x != (int )x) {
#line 348
          goto while_continue___1;
        } else
#line 347
        if ((int )tmp___0->y != (int )y) {
#line 348
          goto while_continue___1;
        }
#line 350
        if ((unsigned long )tmp___0->head != (unsigned long )((void *)0)) {
#line 350
          tmp___0 = tmp___0->head;
        } else {
#line 350
          tmp___0 = tmp___0;
        }
#line 353
        if ((int )tmp___0->type == 2) {
          {
#line 354
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 354
            pl = tmp___0->inv;
            {
#line 354
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 354
              next354 = pl;
#line 354
              if ((unsigned long )next354 == (unsigned long )((void *)0)) {
#line 354
                tmp___2 = (tag_t )0;
              } else {
#line 354
                tmp___2 = next354->count;
              }
#line 354
              next_tag354 = tmp___2;
              {
#line 354
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 354
                pl = next354;
#line 354
                if (! ((unsigned long )pl != (unsigned long )((void *)0))) {
#line 354
                  goto while_break___4;
                }
#line 354
                if (next354->count != next_tag354) {
#line 354
                  goto while_break___4;
                } else
#line 354
                if (next354->flags[0] & (1U << 3)) {
#line 354
                  goto while_break___4;
                }
#line 354
                next354 = next354->below;
#line 354
                if ((unsigned long )next354 == (unsigned long )((void *)0)) {
#line 354
                  next_tag354 = (tag_t )0;
                } else {
#line 354
                  next_tag354 = next354->count;
                }
#line 355
                if ((int )pl->type == 1) {
                  {
#line 356
                  hit_player(pl, (int )op->stats.dam, op, type, full_hit);
                  }
                }
              }
              while_break___4: /* CIL Label */ ;
              }
#line 354
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 354
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 360
        if (tmp___0->flags[0] & 1U) {
          {
#line 361
          hit_player(tmp___0, (int )op->stats.dam, op, type, full_hit);
#line 362
          retflag |= 1;
          }
#line 363
          if (op->count != op_tag) {
#line 364
            goto while_break___1;
          } else
#line 363
          if (op->flags[0] & (1U << 3)) {
#line 364
            goto while_break___1;
          }
        } else
#line 373
        if (tmp___0->material) {
#line 373
          goto _L;
        } else
#line 373
        if (tmp___0->materialname) {
          _L: /* CIL Label */ 
#line 373
          if ((int )op->stats.dam > 0) {
#line 373
            if (! tmp___0->move_block) {
              {
#line 374
              save_throw_object(tmp___0, type, op);
              }
#line 375
              if (op->count != op_tag) {
#line 376
                goto while_break___1;
              } else
#line 375
              if (op->flags[0] & (1U << 3)) {
#line 376
                goto while_break___1;
              }
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 337
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 337
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 379
  return (0);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
static void attack_message(int dam , int type , object *op , object *hitter ) 
{ 
  char buf[256] ;
  char buf1[256] ;
  char buf2[256] ;
  int i ;
  int found ;
  mapstruct *map ;
  object *owner ;
  int mtype ;
  int tmp ;
  int tmp___0 ;
  object *tmp___1 ;
  int tmp___2 ;
  object *next ;
  object *next623 ;
  tag_t next_tag623 ;
  tag_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 399
  found = 0;
#line 408
  if (dam == 9998) {
#line 408
    if ((int )op->type == 23) {
      {
#line 409
      snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"unlock %s",
               op->name);
#line 410
      snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)" unlocks");
#line 411
      found ++;
      }
    }
  }
#line 413
  if (dam < 0) {
    {
#line 414
    snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"hit %s",
             op->name);
#line 415
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)" hits");
#line 416
    found ++;
    }
  } else
#line 417
  if (dam == 0) {
    {
#line 418
    snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"missed %s",
             op->name);
#line 419
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)" misses");
#line 420
    found ++;
    }
  } else
#line 421
  if ((int )hitter->type == 158) {
#line 421
    goto _L___5;
  } else
#line 421
  if ((int )hitter->type == 159) {
#line 421
    goto _L___5;
  } else
#line 421
  if ((int )hitter->type == 105) {
#line 421
    goto _L___5;
  } else
#line 421
  if (type & 1024) {
#line 421
    if ((int )op->type == 1) {
#line 421
      goto _L___7;
    } else
#line 421
    if (op->flags[0] & (1U << 14)) {
#line 421
      goto _L___7;
    } else
#line 421
    if (op->flags[0] & 1U) {
#line 421
      if (! (op->flags[0] & (1U << 16))) {
#line 421
        if (! op->type == 23) {
          _L___7: /* CIL Label */ 
#line 421
          if (! (op->flags[3] & (1U << 13))) {
            _L___5: /* CIL Label */ 
#line 421
            if (! found) {
#line 425
              i = 0;
              {
#line 425
              while (1) {
                while_continue: /* CIL Label */ ;
#line 425
                if (i < 21) {
#line 425
                  if (! (attack_mess[18][i].level != -1)) {
#line 425
                    goto while_break;
                  }
                } else {
#line 425
                  goto while_break;
                }
#line 426
                if (dam < attack_mess[18][i].level) {
                  {
#line 428
                  snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"%s %s%s",
                           attack_mess[18][i].buf1, op->name, attack_mess[18][i].buf2);
#line 429
                  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                           attack_mess[18][i].buf3);
#line 430
                  found ++;
                  }
#line 431
                  goto while_break;
                } else
#line 426
                if (attack_mess[18][i + 1].level == -1) {
                  {
#line 428
                  snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"%s %s%s",
                           attack_mess[18][i].buf1, op->name, attack_mess[18][i].buf2);
#line 429
                  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                           attack_mess[18][i].buf3);
#line 430
                  found ++;
                  }
#line 431
                  goto while_break;
                }
#line 425
                i ++;
              }
              while_break: /* CIL Label */ ;
              }
            } else {
#line 421
              goto _L___6;
            }
          } else {
#line 421
            goto _L___6;
          }
        } else {
#line 421
          goto _L___6;
        }
      } else {
#line 421
        goto _L___6;
      }
    } else {
#line 421
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 433
  if ((int )op->type == 23) {
#line 433
    if (! found) {
#line 434
      i = 0;
      {
#line 434
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 434
        if (i < 21) {
#line 434
          if (! (attack_mess[17][i].level != -1)) {
#line 434
            goto while_break___0;
          }
        } else {
#line 434
          goto while_break___0;
        }
#line 435
        if (dam < attack_mess[17][i].level) {
          {
#line 437
          snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"%s %s%s",
                   attack_mess[17][i].buf1, op->name, attack_mess[17][i].buf2);
#line 438
          snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                   attack_mess[17][i].buf3);
#line 439
          found ++;
          }
#line 440
          goto while_break___0;
        } else
#line 435
        if (attack_mess[17][i + 1].level == -1) {
          {
#line 437
          snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"%s %s%s",
                   attack_mess[17][i].buf1, op->name, attack_mess[17][i].buf2);
#line 438
          snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                   attack_mess[17][i].buf3);
#line 439
          found ++;
          }
#line 440
          goto while_break___0;
        }
#line 434
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 433
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 442
  if ((int )hitter->type == 1) {
#line 442
    if ((int )op->type == 1) {
#line 442
      goto _L___2;
    } else
#line 442
    if (op->flags[0] & (1U << 14)) {
#line 442
      goto _L___2;
    } else
#line 442
    if (op->flags[0] & 1U) {
#line 442
      if (! (op->flags[0] & (1U << 16))) {
#line 442
        if (! op->type == 23) {
          _L___2: /* CIL Label */ 
#line 442
          if (! (op->flags[3] & (1U << 13))) {
#line 443
            if (hitter->chosen_skill) {
#line 443
              if ((int )(hitter->chosen_skill)->subtype == 19) {
#line 444
                i = 0;
                {
#line 444
                while (1) {
                  while_continue___1: /* CIL Label */ ;
#line 444
                  if (i < 21) {
#line 444
                    if (! (attack_mess[6][i].level != -1)) {
#line 444
                      goto while_break___1;
                    }
                  } else {
#line 444
                    goto while_break___1;
                  }
#line 445
                  if (dam < attack_mess[6][i].level) {
                    {
#line 447
                    snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"%s %s%s",
                             attack_mess[6][i].buf1, op->name, attack_mess[6][i].buf2);
#line 448
                    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                             attack_mess[6][i].buf3);
#line 449
                    found ++;
                    }
#line 450
                    goto while_break___1;
                  } else
#line 445
                  if (attack_mess[6][i + 1].level == -1) {
                    {
#line 447
                    snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"%s %s%s",
                             attack_mess[6][i].buf1, op->name, attack_mess[6][i].buf2);
#line 448
                    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                             attack_mess[6][i].buf3);
#line 449
                    found ++;
                    }
#line 450
                    goto while_break___1;
                  }
#line 444
                  i ++;
                }
                while_break___1: /* CIL Label */ ;
                }
              } else {
#line 443
                goto _L___1;
              }
            } else
            _L___1: /* CIL Label */ 
#line 452
            if (hitter->chosen_skill) {
#line 452
              if ((int )(hitter->chosen_skill)->subtype == 31) {
#line 453
                i = 0;
                {
#line 453
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 453
                  if (i < 21) {
#line 453
                    if (! (attack_mess[7][i].level != -1)) {
#line 453
                      goto while_break___2;
                    }
                  } else {
#line 453
                    goto while_break___2;
                  }
#line 454
                  if (dam < attack_mess[7][i].level) {
                    {
#line 456
                    snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"%s %s%s",
                             attack_mess[7][i].buf1, op->name, attack_mess[7][i].buf2);
#line 457
                    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                             attack_mess[7][i].buf3);
#line 458
                    found ++;
                    }
#line 459
                    goto while_break___2;
                  } else
#line 454
                  if (attack_mess[7][i + 1].level == -1) {
                    {
#line 456
                    snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"%s %s%s",
                             attack_mess[7][i].buf1, op->name, attack_mess[7][i].buf2);
#line 457
                    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                             attack_mess[7][i].buf3);
#line 458
                    found ++;
                    }
#line 459
                    goto while_break___2;
                  }
#line 453
                  i ++;
                }
                while_break___2: /* CIL Label */ ;
                }
              } else {
#line 452
                goto _L___0;
              }
            } else
            _L___0: /* CIL Label */ 
#line 461
            if (hitter->chosen_skill) {
#line 461
              if ((int )(hitter->chosen_skill)->subtype == 17) {
#line 462
                i = 0;
                {
#line 462
                while (1) {
                  while_continue___3: /* CIL Label */ ;
#line 462
                  if (i < 21) {
#line 462
                    if (! (attack_mess[8][i].level != -1)) {
#line 462
                      goto while_break___3;
                    }
                  } else {
#line 462
                    goto while_break___3;
                  }
#line 463
                  if (dam < attack_mess[8][i].level) {
                    {
#line 465
                    snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"%s %s%s",
                             attack_mess[8][i].buf1, op->name, attack_mess[8][i].buf2);
#line 466
                    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                             attack_mess[8][i].buf3);
#line 467
                    found ++;
                    }
#line 468
                    goto while_break___3;
                  } else
#line 463
                  if (attack_mess[8][i + 1].level == -1) {
                    {
#line 465
                    snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"%s %s%s",
                             attack_mess[8][i].buf1, op->name, attack_mess[8][i].buf2);
#line 466
                    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                             attack_mess[8][i].buf3);
#line 467
                    found ++;
                    }
#line 468
                    goto while_break___3;
                  }
#line 462
                  i ++;
                }
                while_break___3: /* CIL Label */ ;
                }
              } else {
#line 461
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
#line 470
            if (hitter->chosen_skill) {
#line 470
              if ((int )(hitter->chosen_skill)->subtype == 38) {
#line 471
                i = 0;
                {
#line 471
                while (1) {
                  while_continue___4: /* CIL Label */ ;
#line 471
                  if (i < 21) {
#line 471
                    if (! (attack_mess[19][i].level != -1)) {
#line 471
                      goto while_break___4;
                    }
                  } else {
#line 471
                    goto while_break___4;
                  }
#line 472
                  if (dam < attack_mess[19][i].level) {
                    {
#line 473
                    snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"%s %s%s",
                             attack_mess[19][i].buf1, op->name, attack_mess[19][i].buf2);
#line 474
                    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                             attack_mess[19][i].buf3);
#line 475
                    found ++;
                    }
#line 476
                    goto while_break___4;
                  }
#line 471
                  i ++;
                }
                while_break___4: /* CIL Label */ ;
                }
              }
            }
          }
        }
      }
    }
  }
#line 480
  if (! found) {
#line 482
    if ((int )hitter->type == 13) {
#line 482
      goto _L___18;
    } else
#line 482
    if ((int )hitter->type == 102) {
#line 482
      if ((int )hitter->subtype == 5) {
#line 482
        goto _L___18;
      } else
#line 482
      if ((int )hitter->subtype == 11) {
        _L___18: /* CIL Label */ 
#line 482
        if (type == 1) {
#line 482
          goto _L___15;
        } else
#line 482
        if (type == 2) {
          _L___15: /* CIL Label */ 
          {
#line 483
          snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"hit");
#line 484
          i = 0;
          }
          {
#line 484
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 484
            if (! (i < 21)) {
#line 484
              goto while_break___5;
            }
#line 485
            if (dam < attack_mess[0][i].level) {
              {
#line 487
              snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                       attack_mess[0][i].buf3);
#line 488
              found ++;
              }
#line 489
              goto while_break___5;
            } else
#line 485
            if (attack_mess[0][i + 1].level == -1) {
              {
#line 487
              snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                       attack_mess[0][i].buf3);
#line 488
              found ++;
              }
#line 489
              goto while_break___5;
            }
#line 484
            i ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        } else {
#line 482
          goto _L___17;
        }
      } else {
#line 482
        goto _L___17;
      }
    } else
    _L___17: /* CIL Label */ 
#line 491
    if (type & 128) {
#line 491
      if ((int )op->type == 1) {
#line 491
        goto _L___13;
      } else
#line 491
      if (op->flags[0] & (1U << 14)) {
#line 491
        goto _L___13;
      } else
#line 491
      if (op->flags[0] & 1U) {
#line 491
        if (! (op->flags[0] & (1U << 16))) {
#line 491
          if (! op->type == 23) {
            _L___13: /* CIL Label */ 
#line 491
            if (! (op->flags[3] & (1U << 13))) {
#line 493
              i = 0;
              {
#line 493
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 493
                if (i < 21) {
#line 493
                  if (! (attack_mess[1][i].level != -1)) {
#line 493
                    goto while_break___6;
                  }
                } else {
#line 493
                  goto while_break___6;
                }
#line 494
                if (dam < attack_mess[1][i].level) {
                  {
#line 496
                  snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"%s %s%s",
                           attack_mess[1][i].buf1, op->name, attack_mess[1][i].buf2);
#line 497
                  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                           attack_mess[1][i].buf3);
#line 498
                  found ++;
                  }
#line 499
                  goto while_break___6;
                } else
#line 494
                if (attack_mess[1][i + 1].level == -1) {
                  {
#line 496
                  snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"%s %s%s",
                           attack_mess[1][i].buf1, op->name, attack_mess[1][i].buf2);
#line 497
                  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                           attack_mess[1][i].buf3);
#line 498
                  found ++;
                  }
#line 499
                  goto while_break___6;
                }
#line 493
                i ++;
              }
              while_break___6: /* CIL Label */ ;
              }
            } else {
#line 491
              goto _L___12;
            }
          } else {
#line 491
            goto _L___12;
          }
        } else {
#line 491
          goto _L___12;
        }
      } else {
#line 491
        goto _L___12;
      }
    } else
    _L___12: /* CIL Label */ 
#line 501
    if (type & 8) {
#line 501
      if ((int )op->type == 1) {
#line 501
        goto _L___11;
      } else
#line 501
      if (op->flags[0] & (1U << 14)) {
#line 501
        goto _L___11;
      } else
#line 501
      if (op->flags[0] & 1U) {
#line 501
        if (! (op->flags[0] & (1U << 16))) {
#line 501
          if (! op->type == 23) {
            _L___11: /* CIL Label */ 
#line 501
            if (! (op->flags[3] & (1U << 13))) {
#line 502
              i = 0;
              {
#line 502
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 502
                if (i < 21) {
#line 502
                  if (! (attack_mess[2][i].level != -1)) {
#line 502
                    goto while_break___7;
                  }
                } else {
#line 502
                  goto while_break___7;
                }
#line 503
                if (dam < attack_mess[2][i].level) {
                  {
#line 505
                  snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"%s %s%s",
                           attack_mess[2][i].buf1, op->name, attack_mess[2][i].buf2);
#line 506
                  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                           attack_mess[2][i].buf3);
#line 507
                  found ++;
                  }
#line 508
                  goto while_break___7;
                } else
#line 503
                if (attack_mess[2][i + 1].level == -1) {
                  {
#line 505
                  snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"%s %s%s",
                           attack_mess[2][i].buf1, op->name, attack_mess[2][i].buf2);
#line 506
                  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                           attack_mess[2][i].buf3);
#line 507
                  found ++;
                  }
#line 508
                  goto while_break___7;
                }
#line 502
                i ++;
              }
              while_break___7: /* CIL Label */ ;
              }
            } else {
#line 501
              goto _L___10;
            }
          } else {
#line 501
            goto _L___10;
          }
        } else {
#line 501
          goto _L___10;
        }
      } else {
#line 501
        goto _L___10;
      }
    } else
    _L___10: /* CIL Label */ 
#line 510
    if (type & 16) {
#line 510
      if ((int )op->type == 1) {
#line 510
        goto _L___9;
      } else
#line 510
      if (op->flags[0] & (1U << 14)) {
#line 510
        goto _L___9;
      } else
#line 510
      if (op->flags[0] & 1U) {
#line 510
        if (! (op->flags[0] & (1U << 16))) {
#line 510
          if (! op->type == 23) {
            _L___9: /* CIL Label */ 
#line 510
            if (! (op->flags[3] & (1U << 13))) {
#line 511
              i = 0;
              {
#line 511
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 511
                if (i < 21) {
#line 511
                  if (! (attack_mess[3][i].level != -1)) {
#line 511
                    goto while_break___8;
                  }
                } else {
#line 511
                  goto while_break___8;
                }
#line 512
                if (dam < attack_mess[3][i].level) {
                  {
#line 514
                  snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"%s %s%s",
                           attack_mess[3][i].buf1, op->name, attack_mess[3][i].buf2);
#line 515
                  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                           attack_mess[3][i].buf3);
#line 516
                  found ++;
                  }
#line 517
                  goto while_break___8;
                } else
#line 512
                if (attack_mess[3][i + 1].level == -1) {
                  {
#line 514
                  snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"%s %s%s",
                           attack_mess[3][i].buf1, op->name, attack_mess[3][i].buf2);
#line 515
                  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                           attack_mess[3][i].buf3);
#line 516
                  found ++;
                  }
#line 517
                  goto while_break___8;
                }
#line 511
                i ++;
              }
              while_break___8: /* CIL Label */ ;
              }
            } else {
#line 510
              goto _L___8;
            }
          } else {
#line 510
            goto _L___8;
          }
        } else {
#line 510
          goto _L___8;
        }
      } else {
#line 510
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
#line 519
    if (type & 4) {
#line 520
      i = 0;
      {
#line 520
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 520
        if (i < 21) {
#line 520
          if (! (attack_mess[4][i].level != -1)) {
#line 520
            goto while_break___9;
          }
        } else {
#line 520
          goto while_break___9;
        }
#line 521
        if (dam < attack_mess[4][i].level) {
          {
#line 523
          snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"%s %s%s",
                   attack_mess[4][i].buf1, op->name, attack_mess[4][i].buf2);
#line 524
          snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                   attack_mess[4][i].buf3);
#line 525
          found ++;
          }
#line 526
          goto while_break___9;
        } else
#line 521
        if (attack_mess[4][i + 1].level == -1) {
          {
#line 523
          snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"%s %s%s",
                   attack_mess[4][i].buf1, op->name, attack_mess[4][i].buf2);
#line 524
          snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                   attack_mess[4][i].buf3);
#line 525
          found ++;
          }
#line 526
          goto while_break___9;
        }
#line 520
        i ++;
      }
      while_break___9: /* CIL Label */ ;
      }
    } else
#line 528
    if ((unsigned long )hitter->current_weapon != (unsigned long )((void *)0)) {
      {
#line 532
      if ((hitter->current_weapon)->weapontype == 0U) {
#line 532
        goto case_0;
      }
#line 533
      if ((hitter->current_weapon)->weapontype == 1U) {
#line 533
        goto case_1;
      }
#line 534
      if ((hitter->current_weapon)->weapontype == 2U) {
#line 534
        goto case_2;
      }
#line 535
      if ((hitter->current_weapon)->weapontype == 3U) {
#line 535
        goto case_3;
      }
#line 536
      if ((hitter->current_weapon)->weapontype == 4U) {
#line 536
        goto case_4;
      }
#line 537
      if ((hitter->current_weapon)->weapontype == 5U) {
#line 537
        goto case_5;
      }
#line 538
      if ((hitter->current_weapon)->weapontype == 6U) {
#line 538
        goto case_6;
      }
#line 539
      if ((hitter->current_weapon)->weapontype == 7U) {
#line 539
        goto case_7;
      }
#line 540
      if ((hitter->current_weapon)->weapontype == 8U) {
#line 540
        goto case_8;
      }
#line 541
      goto switch_default;
      case_0: /* CIL Label */ 
#line 532
      mtype = 5;
#line 532
      goto switch_break;
      case_1: /* CIL Label */ 
#line 533
      mtype = 9;
#line 533
      goto switch_break;
      case_2: /* CIL Label */ 
#line 534
      mtype = 10;
#line 534
      goto switch_break;
      case_3: /* CIL Label */ 
#line 535
      mtype = 11;
#line 535
      goto switch_break;
      case_4: /* CIL Label */ 
#line 536
      mtype = 12;
#line 536
      goto switch_break;
      case_5: /* CIL Label */ 
#line 537
      mtype = 13;
#line 537
      goto switch_break;
      case_6: /* CIL Label */ 
#line 538
      mtype = 14;
#line 538
      goto switch_break;
      case_7: /* CIL Label */ 
#line 539
      mtype = 15;
#line 539
      goto switch_break;
      case_8: /* CIL Label */ 
#line 540
      mtype = 16;
#line 540
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 541
      mtype = 5;
#line 541
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 543
      i = 0;
      {
#line 543
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 543
        if (i < 21) {
#line 543
          if (! (attack_mess[mtype][i].level != -1)) {
#line 543
            goto while_break___10;
          }
        } else {
#line 543
          goto while_break___10;
        }
#line 544
        if (dam < attack_mess[mtype][i].level) {
          {
#line 546
          snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"%s %s%s",
                   attack_mess[mtype][i].buf1, op->name, attack_mess[mtype][i].buf2);
#line 547
          snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                   attack_mess[mtype][i].buf3);
#line 548
          found ++;
          }
#line 549
          goto while_break___10;
        } else
#line 544
        if (attack_mess[mtype][i + 1].level == -1) {
          {
#line 546
          snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"%s %s%s",
                   attack_mess[mtype][i].buf1, op->name, attack_mess[mtype][i].buf2);
#line 547
          snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                   attack_mess[mtype][i].buf3);
#line 548
          found ++;
          }
#line 549
          goto while_break___10;
        }
#line 543
        i ++;
      }
      while_break___10: /* CIL Label */ ;
      }
    } else {
#line 552
      i = 0;
      {
#line 552
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 552
        if (i < 21) {
#line 552
          if (! (attack_mess[5][i].level != -1)) {
#line 552
            goto while_break___11;
          }
        } else {
#line 552
          goto while_break___11;
        }
#line 553
        if (dam < attack_mess[5][i].level) {
          {
#line 555
          snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"%s %s%s",
                   attack_mess[5][i].buf1, op->name, attack_mess[5][i].buf2);
#line 556
          snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                   attack_mess[5][i].buf3);
#line 557
          found ++;
          }
#line 558
          goto while_break___11;
        } else
#line 553
        if (attack_mess[5][i + 1].level == -1) {
          {
#line 555
          snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"%s %s%s",
                   attack_mess[5][i].buf1, op->name, attack_mess[5][i].buf2);
#line 556
          snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s",
                   attack_mess[5][i].buf3);
#line 557
          found ++;
          }
#line 558
          goto while_break___11;
        }
#line 552
        i ++;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
  }
#line 562
  if (! found) {
    {
#line 563
    snprintf((char */* __restrict  */)(buf1), sizeof(buf1), (char const   */* __restrict  */)"hit");
#line 564
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"hits");
    }
  }
  {
#line 568
  owner = object_get_owner(hitter);
  }
#line 569
  if ((int )hitter->type != 1) {
#line 569
    if ((unsigned long )owner == (unsigned long )((void *)0)) {
#line 570
      return;
    } else
#line 569
    if ((int )owner->type != 1) {
#line 570
      return;
    }
  }
#line 573
  if (type & 2) {
    {
#line 573
    tmp = rndm(0, 5);
    }
#line 573
    if (tmp) {
#line 574
      return;
    }
  }
#line 578
  if ((int )op->type == 1) {
    {
#line 578
    tmp___0 = rndm(0, 1);
    }
#line 578
    if (tmp___0) {
#line 578
      if ((unsigned long )owner != (unsigned long )((void *)0)) {
#line 578
        tmp___1 = owner;
      } else {
#line 578
        tmp___1 = hitter;
      }
#line 578
      if ((int )tmp___1->type == 1) {
#line 581
        if ((unsigned long )owner != (unsigned long )((void *)0)) {
          {
#line 582
          snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s\'s %s %s you.",
                   owner->name, hitter->name, buf2);
          }
        } else {
          {
#line 584
          snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s%s you.",
                   hitter->name, buf2);
          }
#line 585
          if (dam != 0) {
#line 586
            if (hitter->chosen_skill) {
              {
#line 587
              play_sound_player_only(op->contr, (sint8 )6, op, 0, (hitter->chosen_skill)->name);
              }
            } else
#line 588
            if (dam < 10) {
              {
#line 589
              play_sound_player_only(op->contr, (sint8 )6, op, 0, "low");
              }
            } else
#line 590
            if (dam < 20) {
              {
#line 591
              play_sound_player_only(op->contr, (sint8 )6, op, 0, "medium");
              }
            } else {
              {
#line 593
              play_sound_player_only(op->contr, (sint8 )6, op, 0, "high");
              }
            }
          }
        }
        {
#line 596
        draw_ext_info(0, 0, (object const   *)op, (uint8 )19, (uint8 )2, (char const   *)(buf));
        }
      }
    }
  }
#line 601
  if ((int )hitter->type == 1) {
    {
#line 602
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You %s.",
             buf1);
    }
#line 603
    if (dam != 0) {
#line 604
      if (hitter->chosen_skill) {
        {
#line 605
        play_sound_player_only(hitter->contr, (sint8 )5, hitter, 0, (hitter->chosen_skill)->name);
        }
      } else
#line 606
      if (dam < 10) {
        {
#line 607
        play_sound_player_only(hitter->contr, (sint8 )5, hitter, 0, "low");
        }
      } else
#line 608
      if (dam < 20) {
        {
#line 609
        play_sound_player_only(hitter->contr, (sint8 )5, hitter, 0, "medium");
        }
      } else {
        {
#line 611
        play_sound_player_only(hitter->contr, (sint8 )5, hitter, 0, "high");
        }
      }
    }
    {
#line 613
    draw_ext_info(0, 0, (object const   *)hitter, (uint8 )14, (uint8 )1, (char const   *)(buf));
    }
  } else
#line 615
  if ((unsigned long )owner != (unsigned long )((void *)0)) {
#line 615
    if ((int )owner->type == 1) {
#line 617
      if ((int )hitter->type == 102) {
#line 617
        if ((int )hitter->subtype == 6) {
#line 617
          goto _L___20;
        } else
#line 617
        if ((int )hitter->subtype == 5) {
#line 617
          goto _L___20;
        } else
#line 617
        if ((int )hitter->subtype == 7) {
          _L___20: /* CIL Label */ 
          {
#line 619
          i = 4;
#line 620
          map = hitter->map;
#line 621
          tmp___2 = out_of_map(map, (int )hitter->x, (int )hitter->y);
          }
#line 621
          if (tmp___2) {
#line 622
            return;
          }
          {
#line 623
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 623
            next = (map->spaces + ((int )hitter->x + (int )map->width * (int )hitter->y))->bottom;
            {
#line 623
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 623
              next623 = next;
#line 623
              if ((unsigned long )next623 == (unsigned long )((void *)0)) {
#line 623
                tmp___3 = (tag_t )0;
              } else {
#line 623
                tmp___3 = next623->count;
              }
#line 623
              next_tag623 = tmp___3;
              {
#line 623
              while (1) {
                while_continue___14: /* CIL Label */ ;
#line 623
                next = next623;
#line 623
                if (! ((unsigned long )next != (unsigned long )((void *)0))) {
#line 623
                  goto while_break___14;
                }
#line 623
                if (next623->count != next_tag623) {
#line 623
                  goto while_break___14;
                } else
#line 623
                if (next623->flags[0] & (1U << 3)) {
#line 623
                  goto while_break___14;
                }
#line 623
                next623 = next623->above;
#line 623
                if ((unsigned long )next623 == (unsigned long )((void *)0)) {
#line 623
                  next_tag623 = (tag_t )0;
                } else {
#line 623
                  next_tag623 = next623->count;
                }
#line 624
                if ((int )next->type == 102) {
#line 624
                  if ((int )next->subtype == 6) {
#line 626
                    i *= 3;
                  } else
#line 624
                  if ((int )next->subtype == 5) {
#line 626
                    i *= 3;
                  } else
#line 624
                  if ((int )next->subtype == 7) {
#line 626
                    i *= 3;
                  }
                }
              }
              while_break___14: /* CIL Label */ ;
              }
#line 623
              goto while_break___13;
            }
            while_break___13: /* CIL Label */ ;
            }
#line 623
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
#line 628
          if (i < 0) {
#line 629
            return;
          }
          {
#line 630
          tmp___4 = rndm(0, i);
          }
#line 630
          if (tmp___4 != 0) {
#line 631
            return;
          }
        } else {
#line 617
          goto _L___19;
        }
      } else {
        _L___19: /* CIL Label */ 
        {
#line 632
        tmp___5 = rndm(0, 5);
        }
#line 632
        if (tmp___5 != 0) {
#line 633
          return;
        }
      }
      {
#line 634
      play_sound_map((sint8 )5, owner, 0, "hit");
#line 635
      draw_ext_info_format(0, 0, (object const   *)owner, (uint8 )14, (uint8 )2, "Your %s%s %s.",
                           hitter->name, buf2, op->name);
      }
    }
  }
#line 639
  return;
}
}
#line 652 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
static int get_attack_mode(object **target , object **hitter , int *simple_attack ) 
{ 
  int tmp ;

  {
#line 654
  if ((*target)->flags[0] & (1U << 3)) {
    {
#line 655
    LOG((LogLevel )0, "BUG: get_attack_mode(): freed object\n");
    }
#line 656
    return (1);
  } else
#line 654
  if ((*hitter)->flags[0] & (1U << 3)) {
    {
#line 655
    LOG((LogLevel )0, "BUG: get_attack_mode(): freed object\n");
    }
#line 656
    return (1);
  }
#line 658
  if ((unsigned long )(*target)->head != (unsigned long )((void *)0)) {
#line 658
    *target = (*target)->head;
  } else {
#line 658
    *target = *target;
  }
#line 659
  if ((unsigned long )(*hitter)->head != (unsigned long )((void *)0)) {
#line 659
    *hitter = (*hitter)->head;
  } else {
#line 659
    *hitter = *hitter;
  }
#line 660
  if ((unsigned long )(*hitter)->env != (unsigned long )((void *)0)) {
#line 661
    *simple_attack = 1;
#line 662
    return (0);
  } else
#line 660
  if ((unsigned long )(*target)->env != (unsigned long )((void *)0)) {
#line 661
    *simple_attack = 1;
#line 662
    return (0);
  }
#line 664
  if ((*target)->flags[0] & (1U << 2)) {
    {
#line 668
    LOG((LogLevel )0, "BUG: hitter (arch %s, name %s) with no relation to target\n",
        ((*hitter)->arch)->name, (*hitter)->name);
    }
#line 669
    return (1);
  } else
#line 664
  if ((*hitter)->flags[0] & (1U << 2)) {
    {
#line 668
    LOG((LogLevel )0, "BUG: hitter (arch %s, name %s) with no relation to target\n",
        ((*hitter)->arch)->name, (*hitter)->name);
    }
#line 669
    return (1);
  } else
#line 664
  if ((unsigned long )(*hitter)->map == (unsigned long )((void *)0)) {
    {
#line 668
    LOG((LogLevel )0, "BUG: hitter (arch %s, name %s) with no relation to target\n",
        ((*hitter)->arch)->name, (*hitter)->name);
    }
#line 669
    return (1);
  } else {
    {
#line 664
    tmp = on_same_map((object const   *)*hitter, (object const   *)*target);
    }
#line 664
    if (! tmp) {
      {
#line 668
      LOG((LogLevel )0, "BUG: hitter (arch %s, name %s) with no relation to target\n",
          ((*hitter)->arch)->name, (*hitter)->name);
      }
#line 669
      return (1);
    }
  }
#line 671
  *simple_attack = 0;
#line 672
  return (0);
}
}
#line 688 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
static int abort_attack(object *target , object *hitter , int simple_attack ) 
{ 
  int new_mode ;
  int tmp ;

  {
#line 691
  if ((unsigned long )hitter->env == (unsigned long )target) {
#line 692
    new_mode = 1;
  } else
#line 691
  if ((unsigned long )target->env == (unsigned long )hitter) {
#line 692
    new_mode = 1;
  } else
#line 693
  if (hitter->flags[0] & (1U << 2)) {
#line 696
    return (1);
  } else
#line 693
  if (target->flags[0] & (1U << 2)) {
#line 696
    return (1);
  } else
#line 693
  if ((unsigned long )hitter->map == (unsigned long )((void *)0)) {
#line 696
    return (1);
  } else {
    {
#line 693
    tmp = on_same_map((object const   *)hitter, (object const   *)target);
    }
#line 693
    if (tmp) {
#line 698
      new_mode = 0;
    } else {
#line 696
      return (1);
    }
  }
#line 699
  return (new_mode != simple_attack);
}
}
#line 702
static void thrown_item_effect(object *hitter , object *victim ) ;
#line 719 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
static int attack_ob_simple(object *op , object *hitter , int base_dam , int base_wc ) 
{ 
  int simple_attack ;
  int roll ;
  int dam ;
  uint32 type ;
  tag_t op_tag ;
  tag_t hitter_tag ;
  int tmp ;
  struct obj *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  float tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  object *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 724
  tmp = get_attack_mode(& op, & hitter, & simple_attack);
  }
#line 724
  if (tmp) {
#line 725
    return (1);
  }
#line 728
  if (hitter->current_weapon) {
#line 728
    tmp___0 = hitter->current_weapon;
  } else {
#line 728
    tmp___0 = hitter;
  }
  {
#line 728
  tmp___1 = execute_event(op, 2, hitter, tmp___0, (char const   *)((void *)0), 1);
  }
#line 728
  if (tmp___1 != 0) {
#line 729
    return (0);
  }
#line 734
  if ((int )hitter->type == 1) {
#line 735
    if ((unsigned long )hitter->current_weapon != (unsigned long )((void *)0)) {
      {
#line 737
      tmp___2 = execute_event(hitter->current_weapon, 2, hitter, op, (char const   *)((void *)0),
                              1);
      }
#line 737
      if (tmp___2 != 0) {
#line 739
        return (0);
      }
#line 740
      if ((hitter->current_weapon)->anim_suffix) {
        {
#line 741
        apply_anim_suffix(hitter, (hitter->current_weapon)->anim_suffix);
        }
      }
    } else
#line 742
    if (hitter->chosen_skill) {
#line 742
      if ((hitter->chosen_skill)->anim_suffix) {
        {
#line 744
        apply_anim_suffix(hitter, (hitter->chosen_skill)->anim_suffix);
        }
      }
    }
  }
#line 746
  op_tag = op->count;
#line 747
  hitter_tag = hitter->count;
#line 752
  if (! simple_attack) {
#line 752
    if (op->flags[0] & (1U << 14)) {
#line 752
      if (op->speed < (float )0) {
#line 752
        tmp___4 = - op->speed;
      } else {
#line 752
        tmp___4 = op->speed;
      }
#line 752
      if ((double )op->speed_left > (double )(- tmp___4) * 0.3) {
        {
#line 759
        op->speed_left -= (float )1;
#line 760
        process_object(op);
        }
#line 761
        if (op->count != op_tag) {
#line 764
          return (1);
        } else
#line 761
        if (op->flags[0] & (1U << 3)) {
#line 764
          return (1);
        } else
#line 761
        if (hitter->count != hitter_tag) {
#line 764
          return (1);
        } else
#line 761
        if (hitter->flags[0] & (1U << 3)) {
#line 764
          return (1);
        } else {
          {
#line 761
          tmp___3 = abort_attack(op, hitter, simple_attack);
          }
#line 761
          if (tmp___3) {
#line 764
            return (1);
          }
        }
      }
    }
  }
  {
#line 767
  roll = random_roll(1, 20, (object const   *)hitter, 1);
  }
#line 770
  if (! simple_attack) {
    {
#line 771
    tmp___5 = adj_attackroll(hitter, op);
#line 771
    roll += tmp___5;
    }
  }
#line 774
  if (roll >= 20) {
#line 774
    goto _L;
  } else
#line 774
  if ((int )op->stats.ac >= base_wc - roll) {
    _L: /* CIL Label */ 
#line 775
    if ((int )settings.casting_time == 1) {
#line 776
      if ((int )hitter->type == 1) {
#line 776
        if ((int )hitter->casting_time > -1) {
          {
#line 777
          hitter->casting_time = (sint16 )-1;
#line 778
          draw_ext_info(256, 0, (object const   *)hitter, (uint8 )14, (uint8 )3, "You attacked and lost your spell!");
          }
        }
      }
#line 781
      if ((int )op->casting_time > -1) {
#line 781
        if (base_dam > 0) {
#line 782
          op->casting_time = (sint16 )-1;
#line 783
          if ((int )op->type == 1) {
            {
#line 784
            draw_ext_info(256, 0, (object const   *)op, (uint8 )14, (uint8 )3, "You were hit and lost your spell!");
#line 786
            draw_ext_info_format(768, 5, (object const   *)((void *)0), (uint8 )14,
                                 (uint8 )3, "%s was hit by %s and lost a spell.",
                                 op->name, hitter->name);
            }
          }
        }
      }
    }
#line 793
    if (! simple_attack) {
#line 797
      if (op->flags[2] & (1U << 2)) {
#line 798
        op->flags[2] &= ~ (1U << 2);
      }
#line 802
      if ((int )op->type != 1) {
        {
#line 802
        tmp___6 = monster_can_see_enemy(op, hitter);
        }
#line 802
        if (! tmp___6) {
          {
#line 802
          tmp___7 = object_get_owner(op);
          }
#line 802
          if (! tmp___7) {
            {
#line 802
            tmp___8 = rndm(0, (int )op->stats.Int);
            }
#line 802
            if (tmp___8) {
              {
#line 804
              monster_npc_call_help(op);
              }
            }
          }
        }
      }
#line 807
      if (op->hide) {
#line 807
        if (hitter->flags[0] & 1U) {
          {
#line 808
          make_visible(op);
          }
#line 809
          if ((int )op->type == 1) {
            {
#line 810
            draw_ext_info(256, 0, (object const   *)op, (uint8 )19, (uint8 )2, "You were hit by a wild attack. You are no longer hidden!");
            }
          }
        }
      }
      {
#line 819
      thrown_item_effect(hitter, op);
      }
#line 820
      if (hitter->count != hitter_tag) {
#line 823
        return (0);
      } else
#line 820
      if (hitter->flags[0] & (1U << 3)) {
#line 823
        return (0);
      } else
#line 820
      if (op->count != op_tag) {
#line 823
        return (0);
      } else
#line 820
      if (op->flags[0] & (1U << 3)) {
#line 823
        return (0);
      } else {
        {
#line 820
        tmp___9 = abort_attack(op, hitter, simple_attack);
        }
#line 820
        if (tmp___9) {
#line 823
          return (0);
        }
      }
    }
#line 830
    if (base_dam <= 0) {
#line 831
      base_dam = 1;
    }
#line 833
    type = hitter->attacktype;
#line 834
    if (! type) {
#line 835
      type = (uint32 )1;
    }
#line 837
    if (! simple_attack) {
#line 837
      if (op->flags[1] & (1U << 1)) {
#line 837
        if (hitter->flags[0] & 1U) {
#line 839
          if (op->attacktype & 64U) {
#line 839
            if ((int )hitter->type == 1) {
              {
#line 840
              draw_ext_info(256, 0, (object const   *)hitter, (uint8 )19, (uint8 )2,
                            "You are splashed by acid!\n");
              }
            }
          }
          {
#line 842
          tmp___10 = random_roll(0, (int )op->stats.dam, (object const   *)hitter,
                                 0);
#line 842
          hit_player(hitter, tmp___10, op, op->attacktype, 1);
          }
#line 843
          if (op->count != op_tag) {
#line 846
            return (0);
          } else
#line 843
          if (op->flags[0] & (1U << 3)) {
#line 846
            return (0);
          } else
#line 843
          if (hitter->count != hitter_tag) {
#line 846
            return (0);
          } else
#line 843
          if (hitter->flags[0] & (1U << 3)) {
#line 846
            return (0);
          } else {
            {
#line 843
            tmp___11 = abort_attack(op, hitter, simple_attack);
            }
#line 843
            if (tmp___11) {
#line 846
              return (0);
            }
          }
        }
      }
    }
    {
#line 853
    tmp___12 = random_roll(1, base_dam, (object const   *)hitter, 1);
#line 853
    dam = hit_player(op, tmp___12, hitter, type, 1);
    }
#line 854
    if (op->count != op_tag) {
#line 857
      return (0);
    } else
#line 854
    if (op->flags[0] & (1U << 3)) {
#line 857
      return (0);
    } else
#line 854
    if (hitter->count != hitter_tag) {
#line 857
      return (0);
    } else
#line 854
    if (hitter->flags[0] & (1U << 3)) {
#line 857
      return (0);
    } else {
      {
#line 854
      tmp___13 = abort_attack(op, hitter, simple_attack);
      }
#line 854
      if (tmp___13) {
#line 857
        return (0);
      }
    }
  } else {
#line 860
    dam = 0;
  }
#line 865
  return (dam);
}
}
#line 877 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
int attack_ob(object *op , object *hitter ) 
{ 
  int tmp ;

  {
#line 878
  if ((unsigned long )hitter->head != (unsigned long )((void *)0)) {
#line 878
    hitter = hitter->head;
  } else {
#line 878
    hitter = hitter;
  }
  {
#line 879
  tmp = attack_ob_simple(op, hitter, (int )hitter->stats.dam, (int )hitter->stats.wc);
  }
#line 879
  return (tmp);
}
}
#line 892 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
static int stick_arrow(object *op , object *tmp ) 
{ 
  struct obj *tmp___0 ;

  {
#line 899
  if (op->weight <= 5000) {
#line 899
    if ((int )tmp->stats.hp >= 0) {
      {
#line 900
      object_remove(op);
      }
#line 901
      if ((unsigned long )tmp->head != (unsigned long )((void *)0)) {
#line 901
        tmp___0 = tmp->head;
      } else {
#line 901
        tmp___0 = tmp;
      }
      {
#line 901
      op = object_insert_in_ob(op, tmp___0);
      }
#line 902
      return (1);
    } else {
#line 904
      return (0);
    }
  } else {
#line 904
    return (0);
  }
}
}
#line 919 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
object *hit_with_arrow(object *op , object *victim ) 
{ 
  object *container ;
  object *hitter ;
  int hit_something ;
  tag_t victim_tag ;
  tag_t hitter_tag ;
  sint16 victim_x ;
  sint16 victim_y ;
  mapstruct *victim_map ;
  char const   *old_skill ;
  object *next929 ;
  tag_t next_tag929 ;
  tag_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 921
  hit_something = 0;
#line 925
  old_skill = (char const   *)((void *)0);
#line 928
  hitter = op->inv;
  {
#line 929
  while (1) {
    while_continue: /* CIL Label */ ;
#line 929
    next929 = hitter;
#line 929
    if ((unsigned long )next929 == (unsigned long )((void *)0)) {
#line 929
      tmp = (tag_t )0;
    } else {
#line 929
      tmp = next929->count;
    }
#line 929
    next_tag929 = tmp;
    {
#line 929
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 929
      hitter = next929;
#line 929
      if (! ((unsigned long )hitter != (unsigned long )((void *)0))) {
#line 929
        goto while_break___0;
      }
#line 929
      if (next929->count != next_tag929) {
#line 929
        goto while_break___0;
      } else
#line 929
      if (next929->flags[0] & (1U << 3)) {
#line 929
        goto while_break___0;
      }
#line 929
      next929 = next929->below;
#line 929
      if ((unsigned long )next929 == (unsigned long )((void *)0)) {
#line 929
        next_tag929 = (tag_t )0;
      } else {
#line 929
        next_tag929 = next929->count;
      }
#line 930
      if ((int )hitter->type != 116) {
#line 931
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 929
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 934
  if (! hitter) {
    {
#line 935
    container = (object *)((void *)0);
#line 936
    hitter = op;
#line 937
    tmp___0 = free_no_drop(hitter);
    }
#line 937
    if (tmp___0) {
#line 938
      return ((object *)((void *)0));
    }
  } else {
    {
#line 940
    container = op;
#line 941
    object_remove(hitter);
#line 942
    tmp___1 = free_no_drop(hitter);
    }
#line 942
    if (tmp___1) {
#line 943
      return ((object *)((void *)0));
    }
    {
#line 945
    object_insert_in_map_at(hitter, container->map, hitter, 5, (int )container->x,
                            (int )container->y);
    }
  }
  {
#line 953
  victim_x = victim->x;
#line 954
  victim_y = victim->y;
#line 955
  victim_map = victim->map;
#line 956
  victim_tag = victim->count;
#line 957
  hitter_tag = hitter->count;
#line 963
  tmp___2 = execute_event(op, 2, hitter, victim, (char const   *)((void *)0), 1);
  }
#line 963
  if (tmp___2 == 0) {
#line 970
    if ((unsigned long )container != (unsigned long )((void *)0)) {
      {
#line 971
      old_skill = hitter->skill;
#line 972
      hitter->skill = add_refcount(container->skill);
      }
    }
    {
#line 974
    hit_something = attack_ob_simple(victim, hitter, (int )op->stats.dam, (int )op->stats.wc);
    }
  }
#line 982
  if (hitter->count != hitter_tag) {
#line 982
    goto _L;
  } else
#line 982
  if (hitter->flags[0] & (1U << 3)) {
#line 982
    goto _L;
  } else
#line 982
  if ((unsigned long )hitter->env != (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 983
    if (container) {
      {
#line 984
      object_remove(container);
#line 985
      object_free_drop_inventory(container);
      }
    }
#line 987
    return ((object *)((void *)0));
  }
#line 989
  if ((unsigned long )container != (unsigned long )((void *)0)) {
    {
#line 990
    free_string(hitter->skill);
#line 991
    hitter->skill = old_skill;
    }
  }
#line 997
  if (hit_something) {
#line 997
    if ((double )op->speed <= 10.0) {
#line 999
      if ((unsigned long )container == (unsigned long )((void *)0)) {
        {
#line 1000
        hitter = fix_stopped_arrow(hitter);
        }
#line 1001
        if ((unsigned long )hitter == (unsigned long )((void *)0)) {
#line 1002
          return ((object *)((void *)0));
        }
      } else {
        {
#line 1004
        object_remove(container);
#line 1005
        object_free_drop_inventory(container);
        }
      }
#line 1009
      if (! (victim->count != victim_tag)) {
#line 1009
        if (! (victim->flags[0] & (1U << 3))) {
          {
#line 1009
          tmp___3 = stick_arrow(hitter, victim);
          }
#line 1009
          if (tmp___3) {
#line 1011
            return ((object *)((void *)0));
          }
        }
      }
#line 1020
      if ((int )victim_x != (int )hitter->x) {
        {
#line 1021
        object_remove(hitter);
#line 1022
        object_insert_in_map_at(hitter, victim_map, hitter, 0, (int )victim_x, (int )victim_y);
        }
      } else
#line 1020
      if ((int )victim_y != (int )hitter->y) {
        {
#line 1021
        object_remove(hitter);
#line 1022
        object_insert_in_map_at(hitter, victim_map, hitter, 0, (int )victim_x, (int )victim_y);
        }
      } else {
        {
#line 1025
        object_merge(hitter, (object *)((void *)0));
        }
      }
#line 1027
      return ((object *)((void *)0));
    }
  }
#line 1030
  if (hit_something) {
#line 1030
    if ((double )op->speed >= 10.0) {
#line 1031
      op->speed = (float )((double )op->speed - 1.0);
    }
  }
#line 1034
  if (container) {
    {
#line 1035
    object_remove(hitter);
#line 1036
    object_insert_in_ob(hitter, container);
    }
  }
#line 1038
  return (op);
}
}
#line 1047 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
static void tear_down_wall(object *op ) 
{ 
  int perc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1048
  perc = 0;
#line 1050
  if (! op->stats.maxhp) {
    {
#line 1051
    LOG((LogLevel )0, "TEAR_DOWN wall %s had no maxhp.\n", op->name);
#line 1052
    perc = 1;
    }
  } else {
#line 1053
    if (op->temp_animation_id) {
#line 1053
      tmp = (int )op->temp_animation_id;
    } else {
#line 1053
      tmp = (int )op->animation_id;
    }
#line 1053
    if (! tmp) {
#line 1055
      if ((int )op->stats.hp < 0) {
        {
#line 1056
        object_remove(op);
#line 1057
        object_free_drop_inventory(op);
        }
      }
#line 1061
      return;
    }
  }
#line 1063
  if (op->temp_animation_id) {
#line 1063
    tmp___0 = (int )(animations + op->temp_animation_id)->num_animations;
  } else {
#line 1063
    tmp___0 = (int )(animations + op->animation_id)->num_animations;
  }
#line 1063
  if (op->temp_animation_id) {
#line 1063
    tmp___1 = (int )(animations + op->temp_animation_id)->num_animations;
  } else {
#line 1063
    tmp___1 = (int )(animations + op->animation_id)->num_animations;
  }
#line 1063
  perc = tmp___0 - (tmp___1 * (int )op->stats.hp) / (int )op->stats.maxhp;
#line 1064
  if (op->temp_animation_id) {
#line 1064
    tmp___3 = (int )(animations + op->temp_animation_id)->num_animations;
  } else {
#line 1064
    tmp___3 = (int )(animations + op->animation_id)->num_animations;
  }
#line 1064
  if (perc >= tmp___3) {
#line 1065
    if (op->temp_animation_id) {
#line 1065
      tmp___2 = (int )(animations + op->temp_animation_id)->num_animations;
    } else {
#line 1065
      tmp___2 = (int )(animations + op->animation_id)->num_animations;
    }
#line 1065
    perc = tmp___2 - 1;
  } else
#line 1066
  if (perc < 1) {
#line 1067
    perc = 1;
  }
#line 1068
  if (op->temp_animation_id) {
#line 1068
    op->face = *((animations + op->temp_animation_id)->faces + perc);
  } else {
#line 1068
    op->face = *((animations + op->animation_id)->faces + perc);
  }
  {
#line 1069
  object_update(op, 4);
  }
#line 1070
  if (op->temp_animation_id) {
#line 1070
    tmp___4 = (int )(animations + op->temp_animation_id)->num_animations;
  } else {
#line 1070
    tmp___4 = (int )(animations + op->animation_id)->num_animations;
  }
#line 1070
  if (perc == tmp___4 - 1) {
#line 1071
    if ((unsigned long )op->face == (unsigned long )blank_face) {
      {
#line 1073
      object_remove(op);
#line 1074
      object_free_drop_inventory(op);
      }
    } else {
      {
#line 1079
      op->flags[1] &= ~ (1U << 3);
#line 1080
      update_all_los((mapstruct const   *)op->map, (int )op->x, (int )op->y);
#line 1081
      op->move_block = (MoveType )0;
#line 1082
      op->flags[0] &= 4294967294U;
      }
    }
  }
#line 1085
  return;
}
}
#line 1094 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
static void scare_creature(object *target , object *hitter ) 
{ 
  object *owner ;
  object *tmp ;

  {
  {
#line 1095
  tmp = object_get_owner(hitter);
#line 1095
  owner = tmp;
  }
#line 1097
  if (! owner) {
#line 1098
    owner = hitter;
  }
#line 1100
  target->flags[1] |= 1U << 5;
#line 1101
  if (! target->enemy) {
    {
#line 1102
    object_set_enemy(target, owner);
    }
  }
#line 1103
  return;
}
}
#line 1121 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
static int hit_with_one_attacktype(object *op , object *hitter , int dam , uint32 attacknum ) 
{ 
  int doesnt_slay ;
  char name_hitter[256] ;
  char name_op[256] ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___2 ;
  int level_diff ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int flag ;
  object *tmp___10 ;
  object *next1242 ;
  tag_t next_tag1242 ;
  tag_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int rate ;
  int tmp___15 ;
  object *owner ;
  object *tmp___16 ;
  sint64 orig_exp ;
  char const   *tmp___17 ;
  sint64 tmp___18 ;
  char const   *tmp___19 ;
  sint64 tmp___20 ;
  int tmp___21 ;
  object *owner___0 ;
  object *tmp___23 ;
  object *tmp___24 ;
  object *tmp___25 ;
  object const   *god ;
  char const   *tmp___26 ;
  object const   *tmp___27 ;
  int div___0 ;
  char *tmp___28 ;
  int tmp___29 ;
  object *owner___1 ;
  object *tmp___31 ;
  object *tmp___32 ;
  object *tmp___33 ;
  int tmp___34 ;
  int new_hp ;
  int dam_modifier ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;

  {
#line 1122
  doesnt_slay = 1;
#line 1126
  if (attacknum >= 26U) {
    {
#line 1127
    LOG((LogLevel )0, "hit_with_one_attacktype: Invalid attacknumber passed: %u\n",
        attacknum);
    }
#line 1128
    return (0);
  }
#line 1131
  if (dam < 0) {
    {
#line 1132
    LOG((LogLevel )0, "hit_with_one_attacktype called with negative damage: %d\n",
        dam);
    }
#line 1133
    return (0);
  }
#line 1136
  if (hitter->current_weapon) {
#line 1136
    if ((unsigned long )(hitter->current_weapon)->discrete_damage != (unsigned long )((void *)0)) {
#line 1137
      dam = (int )*((hitter->current_weapon)->discrete_damage + attacknum);
    } else {
#line 1136
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1138
  if ((unsigned long )hitter->discrete_damage != (unsigned long )((void *)0)) {
#line 1139
    dam = (int )*(hitter->discrete_damage + attacknum);
  }
#line 1143
  if (attacknum == 23U) {
#line 1144
    return (dam);
  }
#line 1146
  if (hitter->slaying) {
#line 1147
    if ((unsigned long )op->race != (unsigned long )((void *)0)) {
      {
#line 1147
      tmp = strstr(hitter->slaying, op->race);
      }
#line 1147
      if (tmp) {
#line 1149
        doesnt_slay = 0;
#line 1150
        dam *= 3;
      } else {
#line 1147
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1147
    if (op->arch) {
#line 1147
      if ((unsigned long )(op->arch)->name != (unsigned long )((void *)0)) {
        {
#line 1147
        tmp___0 = strstr((op->arch)->name, hitter->slaying);
        }
#line 1147
        if (tmp___0) {
#line 1149
          doesnt_slay = 0;
#line 1150
          dam *= 3;
        }
      }
    }
  }
#line 1155
  if (op->resist[attacknum]) {
#line 1158
    dam *= 100 - (int )op->resist[attacknum];
#line 1159
    if (dam >= 100) {
#line 1160
      dam /= 100;
    } else {
      {
#line 1162
      tmp___2 = random_roll(0, 99, (object const   *)op, 0);
      }
#line 1162
      if (dam > tmp___2) {
#line 1162
        dam = 1;
      } else {
#line 1162
        dam = 0;
      }
    }
  }
#line 1170
  if ((int )op->resist[attacknum] >= 100) {
#line 1170
    if (doesnt_slay) {
#line 1170
      if (attacknum != 6U) {
#line 1173
        return (0);
      }
    }
  }
  {
#line 1178
  if (attacknum == 0U) {
#line 1178
    goto case_0;
  }
#line 1196
  if (attacknum == 22U) {
#line 1196
    goto case_22;
  }
#line 1196
  if (attacknum == 16U) {
#line 1196
    goto case_22;
  }
#line 1196
  if (attacknum == 15U) {
#line 1196
    goto case_22;
  }
#line 1196
  if (attacknum == 14U) {
#line 1196
    goto case_22;
  }
#line 1196
  if (attacknum == 12U) {
#line 1196
    goto case_22;
  }
#line 1196
  if (attacknum == 11U) {
#line 1196
    goto case_22;
  }
#line 1196
  if (attacknum == 10U) {
#line 1196
    goto case_22;
  }
#line 1196
  if (attacknum == 5U) {
#line 1196
    goto case_22;
  }
#line 1235
  if (attacknum == 6U) {
#line 1235
    goto case_6;
  }
#line 1284
  if (attacknum == 7U) {
#line 1284
    goto case_7;
  }
#line 1343
  if (attacknum == 13U) {
#line 1343
    goto case_13;
  }
#line 1369
  if (attacknum == 17U) {
#line 1369
    goto case_17;
  }
#line 1373
  if (attacknum == 18U) {
#line 1373
    goto case_18;
  }
#line 1380
  if (attacknum == 19U) {
#line 1380
    goto case_19;
  }
#line 1391
  if (attacknum == 21U) {
#line 1391
    goto case_21;
  }
#line 1403
  if (attacknum == 24U) {
#line 1403
    goto case_24;
  }
#line 1177
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1180
  check_physically_infect(op, hitter);
  }
#line 1181
  goto switch_break;
  case_22: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 1200
  if (0 > (int )op->level - (int )hitter->level) {
#line 1200
    tmp___6 = 0;
  } else {
#line 1200
    tmp___6 = (int )op->level - (int )hitter->level;
  }
#line 1200
  if (110 < tmp___6) {
#line 1200
    tmp___5 = 110;
  } else {
#line 1200
    if (0 > (int )op->level - (int )hitter->level) {
#line 1200
      tmp___4 = 0;
    } else {
#line 1200
      tmp___4 = (int )op->level - (int )hitter->level;
    }
#line 1200
    tmp___5 = tmp___4;
  }
#line 1200
  level_diff = tmp___5;
#line 1207
  if (op->speed) {
#line 1207
    if (op->flags[0] & (1U << 14)) {
#line 1207
      goto _L___1;
    } else
#line 1207
    if ((int )op->type == 1) {
      _L___1: /* CIL Label */ 
#line 1207
      if (attacknum == 11U) {
#line 1207
        tmp___7 = 6;
      } else {
#line 1207
        tmp___7 = 3;
      }
      {
#line 1207
      tmp___8 = rndm(0, tmp___7 - 1);
      }
#line 1207
      if (! tmp___8) {
        {
#line 1207
        tmp___9 = did_make_save((object const   *)op, level_diff, (int )op->resist[attacknum] / 10);
        }
#line 1207
        if (! tmp___9) {
#line 1212
          if (attacknum == 5U) {
            {
#line 1213
            confuse_living(op, hitter, dam);
            }
          } else
#line 1214
          if (attacknum == 10U) {
            {
#line 1215
            poison_living(op, hitter, dam);
            }
          } else
#line 1216
          if (attacknum == 11U) {
            {
#line 1217
            slow_living(op, hitter, dam);
            }
          } else
#line 1218
          if (attacknum == 12U) {
            {
#line 1219
            paralyze_living(op, dam);
            }
          } else
#line 1220
          if (attacknum == 14U) {
            {
#line 1221
            scare_creature(op, hitter);
            }
          } else
#line 1222
          if (attacknum == 15U) {
            {
#line 1223
            cancellation(op);
            }
          } else
#line 1224
          if (attacknum == 16U) {
            {
#line 1225
            drain_stat(op);
            }
          } else
#line 1226
          if (attacknum == 22U) {
#line 1226
            if (! (op->flags[1] & (1U << 4))) {
#line 1226
              if (! (op->flags[0] & (1U << 16))) {
                {
#line 1229
                blind_living(op, hitter, dam);
                }
              }
            }
          }
        }
      }
    }
  }
#line 1231
  dam = 0;
#line 1233
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1236
  flag = 0;
#line 1240
  tmp___14 = op_on_battleground(op, (int *)((void *)0), (int *)((void *)0), (archetype **)((void *)0));
  }
#line 1240
  if (! tmp___14) {
#line 1240
    if ((int )op->resist[6] < 50) {
      {
#line 1242
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1242
        tmp___10 = op->inv;
        {
#line 1242
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1242
          next1242 = tmp___10;
#line 1242
          if ((unsigned long )next1242 == (unsigned long )((void *)0)) {
#line 1242
            tmp___11 = (tag_t )0;
          } else {
#line 1242
            tmp___11 = next1242->count;
          }
#line 1242
          next_tag1242 = tmp___11;
          {
#line 1242
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1242
            tmp___10 = next1242;
#line 1242
            if (! ((unsigned long )tmp___10 != (unsigned long )((void *)0))) {
#line 1242
              goto while_break___1;
            }
#line 1242
            if (next1242->count != next_tag1242) {
#line 1242
              goto while_break___1;
            } else
#line 1242
            if (next1242->flags[0] & (1U << 3)) {
#line 1242
              goto while_break___1;
            }
#line 1242
            next1242 = next1242->below;
#line 1242
            if ((unsigned long )next1242 == (unsigned long )((void *)0)) {
#line 1242
              next_tag1242 = (tag_t )0;
            } else {
#line 1242
              next_tag1242 = next1242->count;
            }
#line 1243
            if (tmp___10->invisible) {
#line 1244
              goto while_continue___1;
            }
#line 1245
            if (! (tmp___10->flags[0] & (1U << 5))) {
#line 1248
              goto while_continue___1;
            } else
#line 1245
            if ((int )tmp___10->resist[6] >= 10) {
#line 1248
              goto while_continue___1;
            }
#line 1249
            if (! ((int )tmp___10->material & 2)) {
#line 1250
              goto while_continue___1;
            }
#line 1251
            if ((int )tmp___10->magic < -4) {
#line 1252
              goto while_continue___1;
            }
#line 1253
            if ((int )tmp___10->type == 70) {
#line 1259
              goto while_continue___1;
            } else
#line 1253
            if ((int )tmp___10->type == 113) {
#line 1259
              goto while_continue___1;
            } else
#line 1253
            if ((int )tmp___10->type == 39) {
#line 1259
              goto while_continue___1;
            } else
#line 1253
            if ((int )tmp___10->type == 109) {
#line 1259
              goto while_continue___1;
            } else
#line 1253
            if ((int )tmp___10->type == 3) {
#line 1259
              goto while_continue___1;
            }
            {
#line 1262
            tmp___12 = rndm(0, dam + 4);
#line 1262
            tmp___13 = random_roll(0, 39, (object const   *)op, 1);
            }
#line 1262
            if (tmp___12 > tmp___13 + 2 * (int )tmp___10->magic) {
#line 1263
              if ((int )op->type == 1) {
                {
#line 1265
                query_name((object const   *)hitter, name_hitter, (size_t )256);
#line 1266
                query_name((object const   *)tmp___10, name_op, (size_t )256);
#line 1267
                draw_ext_info_format(259, 0, (object const   *)op, (uint8 )19, (uint8 )2,
                                     "The %s\'s acid corrodes your %s!", name_hitter,
                                     name_op);
                }
              }
#line 1272
              flag = 1;
#line 1273
              tmp___10->magic = (sint8 )((int )tmp___10->magic - 1);
#line 1274
              if ((int )op->type == 1) {
                {
#line 1275
                esrv_update_item(16, op, tmp___10);
                }
              }
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 1242
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1242
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 1278
      if (flag) {
        {
#line 1279
        fix_object(op);
        }
      }
    }
  }
#line 1282
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1290
  if ((int )op->resist[7] >= 0) {
#line 1291
    rate = 50 + (int )op->resist[7] / 2;
  } else {
#line 1293
    rate = 5000 / (100 - (int )op->resist[7]);
  }
#line 1297
  if (! rate) {
#line 1298
    return (0);
  }
#line 1300
  if (op->stats.exp <= (sint64 )rate) {
#line 1301
    if ((int )op->type == 46) {
#line 1302
      dam = 999;
    } else {
      {
#line 1305
      dam = hit_with_one_attacktype(op, hitter, dam, (uint32 )0);
      }
    }
  } else {
#line 1308
    if ((int )hitter->stats.hp < (int )hitter->stats.maxhp) {
#line 1308
      if ((int )op->level > (int )hitter->level) {
        {
#line 1308
        tmp___15 = random_roll(0, ((int )op->level - (int )hitter->level) + 2, (object const   *)hitter,
                               1);
        }
#line 1308
        if (tmp___15 > 3) {
#line 1311
          hitter->stats.hp = (sint16 )((int )hitter->stats.hp + 1);
        }
      }
    }
    {
#line 1320
    tmp___21 = op_on_battleground(hitter, (int *)((void *)0), (int *)((void *)0),
                                  (archetype **)((void *)0));
    }
#line 1320
    if (! tmp___21) {
#line 1320
      if (! (op->flags[0] & (1U << 4))) {
        {
#line 1321
        tmp___16 = object_get_owner(hitter);
#line 1321
        owner = tmp___16;
#line 1322
        orig_exp = op->stats.exp;
#line 1324
        change_exp(op, - op->stats.exp / (sint64 )rate, (char const   *)((void *)0),
                   0);
        }
#line 1326
        if (owner) {
#line 1326
          if ((unsigned long )owner != (unsigned long )hitter) {
#line 1327
            if ((int )op->type != 1) {
#line 1327
              goto _L___2;
            } else
#line 1327
            if ((int )owner->type != 1) {
              _L___2: /* CIL Label */ 
#line 1328
              if (hitter->chosen_skill) {
#line 1328
                tmp___17 = (hitter->chosen_skill)->skill;
              } else {
#line 1328
                tmp___17 = (char const   *)((void *)0);
              }
#line 1328
              if (op->stats.exp / (sint64 )(rate * 2) < orig_exp - op->stats.exp) {
#line 1328
                tmp___18 = op->stats.exp / (sint64 )(rate * 2);
              } else {
#line 1328
                tmp___18 = orig_exp - op->stats.exp;
              }
              {
#line 1328
              change_exp(owner, tmp___18, tmp___17, 1);
              }
            }
          } else {
#line 1326
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 1330
        if ((int )op->type != 1) {
#line 1330
          goto _L___3;
        } else
#line 1330
        if ((int )hitter->type != 1) {
          _L___3: /* CIL Label */ 
#line 1331
          if (hitter->chosen_skill) {
#line 1331
            tmp___19 = (hitter->chosen_skill)->skill;
          } else {
#line 1331
            tmp___19 = (char const   *)((void *)0);
          }
#line 1331
          if (op->stats.exp / (sint64 )(rate * 2) < orig_exp - op->stats.exp) {
#line 1331
            tmp___20 = op->stats.exp / (sint64 )(rate * 2);
          } else {
#line 1331
            tmp___20 = orig_exp - op->stats.exp;
          }
          {
#line 1331
          change_exp(hitter, tmp___20, tmp___19, 0);
          }
        }
      }
    }
#line 1335
    dam = 1;
  }
#line 1341
  goto switch_break;
  case_13: /* CIL Label */ 
#line 1344
  if (op->flags[1] & (1U << 4)) {
    {
#line 1345
    tmp___25 = object_get_owner(hitter);
    }
#line 1345
    if ((unsigned long )tmp___25 == (unsigned long )((void *)0)) {
#line 1345
      tmp___24 = hitter;
    } else {
      {
#line 1345
      tmp___23 = object_get_owner(hitter);
#line 1345
      tmp___24 = tmp___23;
      }
    }
    {
#line 1345
    owner___0 = tmp___24;
#line 1346
    tmp___26 = determine_god(owner___0);
#line 1346
    tmp___27 = find_god(tmp___26);
#line 1346
    god = tmp___27;
#line 1347
    div___0 = 1;
    }
#line 1351
    if (! god) {
#line 1354
      div___0 = 2;
    } else
#line 1351
    if (! god->slaying) {
#line 1354
      div___0 = 2;
    } else {
      {
#line 1351
      tmp___28 = strstr((char const   *)god->slaying, undead_name);
      }
#line 1351
      if ((unsigned long )tmp___28 == (unsigned long )((void *)0)) {
#line 1354
        div___0 = 2;
      }
    }
    {
#line 1362
    tmp___29 = get_turn_bonus((int )owner___0->stats.Wis);
    }
#line 1362
    if ((int )op->level * div___0 + (int )op->resist[13] / 20 < tmp___29 + (int )owner___0->level) {
      {
#line 1363
      scare_creature(op, owner___0);
      }
    }
  } else {
#line 1365
    dam = 0;
  }
#line 1367
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 1370
  deathstrike_living(op, hitter, & dam);
  }
#line 1371
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 1374
  query_name((object const   *)op, name_op, (size_t )256);
#line 1375
  query_name((object const   *)hitter, name_hitter, (size_t )256);
#line 1376
  LOG((LogLevel )0, "%s was hit by %s with non-specific chaos.\n", name_op, name_hitter);
#line 1377
  dam = 0;
  }
#line 1378
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 1381
  query_name((object const   *)op, name_op, (size_t )256);
#line 1382
  query_name((object const   *)hitter, name_hitter, (size_t )256);
#line 1383
  LOG((LogLevel )0, "%s was hit by %s with counterspell attack.\n", name_op, name_hitter);
#line 1384
  dam = 0;
  }
#line 1389
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 1395
  tmp___33 = object_get_owner(hitter);
  }
#line 1395
  if ((unsigned long )tmp___33 == (unsigned long )((void *)0)) {
#line 1395
    tmp___32 = hitter;
  } else {
    {
#line 1395
    tmp___31 = object_get_owner(hitter);
#line 1395
    tmp___32 = tmp___31;
    }
  }
  {
#line 1395
  owner___1 = tmp___32;
#line 1398
  tmp___34 = get_turn_bonus((int )owner___1->stats.Wis);
  }
#line 1398
  if ((int )op->level + (int )op->resist[21] / 100 < (int )owner___1->level + tmp___34) {
    {
#line 1399
    scare_creature(op, owner___1);
    }
  }
#line 1401
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 1416
  tmp___37 = is_wraith_pl(hitter);
  }
#line 1416
  if (tmp___37) {
#line 1416
    tmp___36 = 200;
  } else {
#line 1416
    tmp___36 = 3000;
  }
#line 1416
  dam_modifier = tmp___36;
#line 1419
  if ((int )op->type == 46) {
#line 1423
    return (0);
  } else
#line 1419
  if (op->flags[1] & (1U << 4)) {
#line 1423
    return (0);
  } else
#line 1419
  if (! (op->flags[0] & 1U)) {
#line 1423
    return (0);
  } else
#line 1419
  if ((int )op->type == 23) {
#line 1423
    return (0);
  }
#line 1425
  if ((int )op->resist[7] >= (int )op->resist[24]) {
#line 1426
    dam = (dam * (100 - (int )op->resist[7])) / dam_modifier;
  } else {
#line 1428
    dam = (dam * (100 - (int )op->resist[24])) / dam_modifier;
  }
#line 1430
  if (dam > (int )op->stats.hp + 1) {
#line 1431
    dam = (int )op->stats.hp + 1;
  }
#line 1432
  new_hp = (int )hitter->stats.hp + dam;
#line 1433
  if (new_hp > (int )hitter->stats.maxhp) {
#line 1434
    new_hp = (int )hitter->stats.maxhp;
  }
#line 1435
  if (new_hp > (int )hitter->stats.hp) {
#line 1436
    hitter->stats.hp = (sint16 )new_hp;
  }
  {
#line 1439
  tmp___38 = is_wraith_pl(hitter);
  }
#line 1439
  if (tmp___38) {
#line 1440
    if (hitter->stats.food + dam >= 999) {
#line 1441
      hitter->stats.food = 999;
    } else {
#line 1443
      hitter->stats.food += dam;
    }
    {
#line 1444
    fix_object(hitter);
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 1448
  return (dam);
}
}
#line 1486 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
static int kill_object(object *op , int dam , object *hitter ) 
{ 
  char kill_message[256] ;
  char const   *skill ;
  int maxdam ;
  int battleg ;
  int pk ;
  object *owner ;
  object const   *skop ;
  sstring death_animation ;
  int tmp ;
  object *death ;
  object *tmp___0 ;
  object *owner___0 ;
  int tmp___1 ;
  time_t t ;
  time_t tmp___2 ;
  struct tm *tmv ;
  char buf[256] ;
  char name[256] ;
  char killed[256] ;
  char with[256] ;
  char killed___0[256] ;
  int i ;
  int tmp___3 ;
  char name_op[256] ;
  char name_hitter[256] ;
  char const   *owner_prefix ;
  char const   *op_prefix ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *hitter_prefix ;
  char const   *op_prefix___0 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  sint64 exp ;
  object *tmp___10 ;

  {
#line 1489
  maxdam = 0;
#line 1490
  battleg = 0;
#line 1491
  pk = 0;
#line 1492
  owner = (object *)((void *)0);
#line 1493
  skop = (object const   *)((void *)0);
#line 1496
  if ((int )op->stats.hp >= 0) {
#line 1497
    return (-1);
  }
  {
#line 1500
  tmp = execute_event(op, 3, hitter, (object *)((void *)0), (char const   *)((void *)0),
                      1);
  }
#line 1500
  if (tmp != 0) {
#line 1501
    return (0);
  }
  {
#line 1503
  execute_global_event(18, op, hitter);
  }
#line 1505
  if (op->map) {
    {
#line 1506
    death_animation = object_get_value((object const   *)op, (char const   */* const  */)"death_animation");
    }
#line 1507
    if ((unsigned long )death_animation != (unsigned long )((void *)0)) {
      {
#line 1508
      tmp___0 = create_archetype(death_animation);
#line 1508
      death = tmp___0;
      }
#line 1510
      if (death) {
        {
#line 1511
        object_insert_in_map_at(death, op->map, op, 0, (int )op->x, (int )op->y);
        }
      }
    }
  }
#line 1519
  maxdam = (dam + (int )op->stats.hp) + 1;
#line 1521
  if (op->flags[1] & (1U << 3)) {
    {
#line 1522
    update_all_los((mapstruct const   *)op->map, (int )op->x, (int )op->y);
    }
  }
#line 1524
  if ((int )op->type == 23) {
    {
#line 1525
    op->speed = (float )0.1;
#line 1526
    object_update_speed(op);
#line 1527
    op->speed_left = (float )(- 0.05);
    }
#line 1528
    return (maxdam);
  }
#line 1530
  if (op->flags[0] & (1U << 15)) {
#line 1530
    if ((int )op->type != 1) {
      {
#line 1533
      remove_friendly_object(op);
#line 1534
      owner___0 = object_get_owner(op);
      }
#line 1535
      if ((unsigned long )owner___0 != (unsigned long )((void *)0)) {
#line 1535
        if ((int )owner___0->type == 1) {
#line 1537
          if ((unsigned long )(owner___0->contr)->ranges[4] == (unsigned long )op) {
#line 1538
            (owner___0->contr)->ranges[4] = (object *)((void *)0);
#line 1539
            (owner___0->contr)->golem_count = (uint32 )0;
          }
          {
#line 1544
          draw_ext_info_format(256, 0, (object const   *)owner___0, (uint8 )14, (uint8 )5,
                               "Your pet, the %s, is killed by %s.", op->name, hitter->name);
          }
        } else {
          {
#line 1548
          LOG((LogLevel )0, "BUG: hit_player(): Encountered golem without owner.\n");
          }
        }
      } else {
        {
#line 1548
        LOG((LogLevel )0, "BUG: hit_player(): Encountered golem without owner.\n");
        }
      }
      {
#line 1550
      object_remove(op);
#line 1551
      object_free_drop_inventory(op);
      }
#line 1552
      return (maxdam);
    }
  }
  {
#line 1557
  owner = object_get_owner(hitter);
  }
#line 1558
  if ((unsigned long )owner == (unsigned long )((void *)0)) {
#line 1559
    owner = hitter;
  }
  {
#line 1562
  tmp___1 = op_on_battleground(op, (int *)((void *)0), (int *)((void *)0), (archetype **)((void *)0));
  }
#line 1562
  if (tmp___1) {
#line 1563
    battleg = 1;
  }
#line 1566
  if ((int )op->type == 1) {
#line 1566
    if ((int )owner->type == 1) {
#line 1567
      pk = 1;
    }
  }
#line 1570
  if ((int )owner->type == 1) {
#line 1576
    if ((int )op->type == 1) {
#line 1576
      if (! battleg) {
        {
#line 1577
        tmp___2 = time((time_t *)((void *)0));
#line 1577
        t = tmp___2;
#line 1582
        tmv = localtime((time_t const   *)(& t));
#line 1583
        strftime((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%a %b %d %H:%M:%S %Y",
                 (struct tm  const  */* __restrict  */)tmv);
#line 1584
        query_name((object const   *)op, name, (size_t )256);
#line 1586
        LOG((LogLevel )1, "%s PLAYER_KILL_PLAYER: %s (%s) killed %s\n", buf, owner->name,
            (owner->contr)->socket.host, name);
        }
      }
    }
#line 1593
    if ((int )owner->level < (int )op->level * 2) {
#line 1593
      goto _L;
    } else
#line 1593
    if (op->stats.exp > 1000L) {
      _L: /* CIL Label */ 
#line 1594
      if ((unsigned long )owner != (unsigned long )hitter) {
        {
#line 1597
        query_name((object const   *)op, killed, (size_t )256);
#line 1598
        query_name((object const   *)hitter, with, (size_t )256);
#line 1599
        draw_ext_info_format(0, 0, (object const   *)owner, (uint8 )14, (uint8 )4,
                             "You killed %s with %s.", killed, with);
        }
      } else {
        {
#line 1605
        query_name((object const   *)op, killed___0, (size_t )256);
#line 1606
        draw_ext_info_format(0, 0, (object const   *)owner, (uint8 )14, (uint8 )4,
                             "You killed %s.", killed___0);
        }
      }
#line 1611
      if ((int )hitter->type == 1) {
        {
#line 1612
        play_sound_map((sint8 )5, owner, 0, "kill");
        }
      }
    }
#line 1623
    if ((int )op->type == 1) {
#line 1623
      if ((unsigned long )owner != (unsigned long )op) {
#line 1623
        if (! battleg) {
          {
#line 1624
          change_luck(owner, - ((int )settings.pk_luck_penalty));
          }
        }
      }
    }
#line 1630
    skill = (char const   *)((void *)0);
#line 1631
    if (hitter->skill) {
#line 1631
      if ((int )hitter->type != 1) {
#line 1632
        skill = hitter->skill;
      } else {
#line 1631
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1633
    if (owner->chosen_skill) {
#line 1634
      skill = (owner->chosen_skill)->skill;
#line 1635
      skop = (object const   *)owner->chosen_skill;
    } else
#line 1636
    if (owner->flags[2] & (1U << 26)) {
#line 1637
      skill = (owner->current_weapon)->skill;
    } else {
      {
#line 1639
      LOG((LogLevel )0, "kill_object - unable to find skill that killed monster\n");
      }
    }
#line 1644
    if (! skop) {
#line 1644
      goto _L___1;
    } else
#line 1644
    if ((int const   )skop->type != 43) {
      _L___1: /* CIL Label */ 
#line 1644
      if (skill) {
#line 1647
        i = 0;
        {
#line 1647
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1647
          if (! (i < 44)) {
#line 1647
            goto while_break;
          }
#line 1648
          if ((owner->contr)->last_skill_ob[i]) {
            {
#line 1648
            tmp___3 = strcmp(((owner->contr)->last_skill_ob[i])->skill, skill);
            }
#line 1648
            if (! tmp___3) {
#line 1650
              skop = (object const   *)(owner->contr)->last_skill_ob[i];
#line 1651
              goto while_break;
            }
          }
#line 1647
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  } else {
#line 1656
    skill = (char const   *)((void *)0);
  }
#line 1660
  if ((unsigned long )owner != (unsigned long )hitter) {
#line 1665
    if (! battleg) {
#line 1665
      if (pk) {
#line 1665
        if ((unsigned long )owner->contr != (unsigned long )((void *)0)) {
#line 1665
          if (! (owner->contr)->peaceful) {
#line 1665
            owner_prefix = "hostile ";
          } else {
#line 1665
            owner_prefix = "";
          }
        } else {
#line 1665
          owner_prefix = "";
        }
      } else {
#line 1665
        owner_prefix = "";
      }
    } else {
#line 1665
      owner_prefix = "";
    }
#line 1666
    if (! battleg) {
#line 1666
      if (pk) {
#line 1666
        if ((unsigned long )op->contr != (unsigned long )((void *)0)) {
#line 1666
          if (! (op->contr)->peaceful) {
#line 1666
            op_prefix = "hostile ";
          } else {
#line 1666
            op_prefix = "";
          }
        } else {
#line 1666
          op_prefix = "";
        }
      } else {
#line 1666
        op_prefix = "";
      }
    } else {
#line 1666
      op_prefix = "";
    }
    {
#line 1668
    query_name((object const   *)op, name_op, (size_t )256);
#line 1669
    query_name((object const   *)hitter, name_hitter, (size_t )256);
    }
#line 1670
    if (battleg) {
#line 1670
      tmp___5 = " (duel)";
    } else {
#line 1670
      if (pk) {
#line 1670
        tmp___4 = " (pk)";
      } else {
#line 1670
        tmp___4 = "";
      }
#line 1670
      tmp___5 = tmp___4;
    }
    {
#line 1670
    snprintf((char */* __restrict  */)(kill_message), sizeof(kill_message), (char const   */* __restrict  */)"%s%s killed %s%s with %s%s.",
             owner_prefix, owner->name, op_prefix, name_op, name_hitter, tmp___5);
    }
  } else {
#line 1675
    if (! battleg) {
#line 1675
      if (pk) {
#line 1675
        if ((unsigned long )hitter->contr != (unsigned long )((void *)0)) {
#line 1675
          if (! (hitter->contr)->peaceful) {
#line 1675
            hitter_prefix = "hostile ";
          } else {
#line 1675
            hitter_prefix = "";
          }
        } else {
#line 1675
          hitter_prefix = "";
        }
      } else {
#line 1675
        hitter_prefix = "";
      }
    } else {
#line 1675
      hitter_prefix = "";
    }
#line 1676
    if (! battleg) {
#line 1676
      if (pk) {
#line 1676
        if ((unsigned long )op->contr != (unsigned long )((void *)0)) {
#line 1676
          if (! (op->contr)->peaceful) {
#line 1676
            op_prefix___0 = "hostile ";
          } else {
#line 1676
            op_prefix___0 = "";
          }
        } else {
#line 1676
          op_prefix___0 = "";
        }
      } else {
#line 1676
        op_prefix___0 = "";
      }
    } else {
#line 1676
      op_prefix___0 = "";
    }
#line 1678
    if (battleg) {
#line 1678
      tmp___7 = " (duel)";
    } else {
#line 1678
      if (pk) {
#line 1678
        tmp___6 = " (pk)";
      } else {
#line 1678
        tmp___6 = "";
      }
#line 1678
      tmp___7 = tmp___6;
    }
#line 1678
    if (hitter->flags[0] & (1U << 14)) {
#line 1678
      tmp___8 = " in hand to hand combat";
    } else
#line 1678
    if ((int )hitter->type == 1) {
#line 1678
      tmp___8 = " in hand to hand combat";
    } else {
#line 1678
      tmp___8 = "";
    }
    {
#line 1678
    snprintf((char */* __restrict  */)(kill_message), sizeof(kill_message), (char const   */* __restrict  */)"%s%s killed %s%s%s%s.",
             hitter_prefix, hitter->name, op_prefix___0, op->name, tmp___8, tmp___7);
    }
  }
#line 1683
  if (! skop) {
#line 1684
    skop = (object const   *)hitter->chosen_skill;
  }
#line 1685
  if (! skill) {
#line 1685
    if (skop) {
#line 1686
      skill = (char const   *)skop->skill;
    }
  }
#line 1688
  if ((int )op->type == 1) {
#line 1688
    tmp___9 = 1;
  } else {
#line 1688
    tmp___9 = 10;
  }
  {
#line 1688
  draw_ext_info(512, tmp___9, (object const   *)((void *)0), (uint8 )8, (uint8 )3,
                (char const   *)(kill_message));
  }
#line 1693
  if ((unsigned long )owner != (unsigned long )op) {
#line 1693
    if (! (op->flags[0] & (1U << 4))) {
      {
#line 1696
      exp = calc_skill_exp((object const   *)owner, (object const   *)op, skop);
      }
#line 1699
      if ((int )op->type == 1) {
#line 1700
        if (battleg) {
          {
#line 1701
          draw_ext_info(256, 0, (object const   *)owner, (uint8 )14, (uint8 )4, "Your foe has fallen!\nVICTORY!!!");
          }
        } else {
#line 1704
          exp = ((sint64 )settings.pk_max_experience_percent * exp) / 100L;
#line 1705
          if (settings.pk_max_experience >= 0L) {
#line 1706
            if (settings.pk_max_experience < exp) {
#line 1706
              exp = settings.pk_max_experience;
            } else {
#line 1706
              exp = exp;
            }
          }
          {
#line 1708
          exp = check_exp_loss((object const   *)op, exp);
          }
        }
      }
#line 1716
      if (! settings.simple_exp) {
#line 1717
        exp /= 2L;
      }
#line 1722
      if (battleg) {
#line 1723
        exp = (sint64 )0;
      }
      {
#line 1735
      share_exp(owner, exp, skill, 1);
      }
    }
  }
#line 1738
  if ((int )op->type != 1) {
    {
#line 1739
    object_remove(op);
#line 1740
    object_free_drop_inventory(op);
    }
  } else {
#line 1743
    if ((int )owner->type == 1) {
      {
#line 1744
      snprintf((char */* __restrict  */)((op->contr)->killer), (size_t )32, (char const   */* __restrict  */)"%s the %s",
               owner->name, (owner->contr)->title);
      }
    } else {
      {
#line 1746
      strncpy((char */* __restrict  */)((op->contr)->killer), (char const   */* __restrict  */)hitter->name,
              (size_t )32);
#line 1747
      (op->contr)->killer[31] = (char )'\000';
      }
    }
#line 1750
    if (! (op->flags[0] & (1U << 1))) {
#line 1751
      if ((int )owner->type == 1) {
#line 1751
        tmp___10 = owner;
      } else {
#line 1751
        tmp___10 = hitter;
      }
      {
#line 1751
      kill_player(op, (object const   *)tmp___10);
      }
    }
  }
#line 1756
  return (maxdam);
}
}
#line 1769 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
int friendly_fire(object *op , object *hitter ) 
{ 
  object *owner ;
  int friendlyfire ;

  {
#line 1773
  if ((unsigned long )hitter->head != (unsigned long )((void *)0)) {
#line 1773
    hitter = hitter->head;
  } else {
#line 1773
    hitter = hitter;
  }
#line 1774
  friendlyfire = 0;
#line 1776
  if ((int )op->type == 1) {
#line 1777
    if ((int )hitter->type == 1) {
#line 1777
      if ((hitter->contr)->peaceful == 1U) {
#line 1778
        return (1);
      }
    }
    {
#line 1780
    owner = object_get_owner(hitter);
    }
#line 1781
    if ((unsigned long )owner != (unsigned long )((void *)0)) {
#line 1782
      if ((int )owner->type == 1) {
#line 1782
        if ((owner->contr)->peaceful == 1U) {
#line 1783
          friendlyfire = 2;
        }
      }
    }
#line 1786
    if ((int )hitter->type == 101) {
#line 1790
      friendlyfire = 0;
    } else
#line 1786
    if ((int )hitter->type == 105) {
#line 1790
      friendlyfire = 0;
    } else
#line 1786
    if ((int )hitter->type == 158) {
#line 1790
      friendlyfire = 0;
    } else
#line 1786
    if ((int )hitter->type == 154) {
#line 1790
      friendlyfire = 0;
    }
  }
#line 1792
  return (friendlyfire);
}
}
#line 1818 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
int hit_player(object *op , int dam , object *hitter , uint32 type , int full_hit ) 
{ 
  int maxdam ;
  int ndam ;
  int magic ;
  int maxattacktype ;
  int attacknum ;
  int body_attack ;
  int simple_attack ;
  tag_t op_tag ;
  tag_t hitter_tag ;
  int rtn_kill ;
  int friendlyfire ;
  object *owner ;
  int tmp ;
  object *tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  long tmp___4 ;
  object const   *god ;
  char *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  int attacktype ;
  int tmp___9 ;
  archetype *at ;
  int area ;
  int remainder ;
  long tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  sint32 tmp___13 ;

  {
  {
#line 1819
  maxdam = 0;
#line 1819
  ndam = 0;
#line 1819
  magic = (int )(type & 2U);
#line 1821
  body_attack = (unsigned long )op->head != (unsigned long )((void *)0);
#line 1824
  rtn_kill = 0;
#line 1828
  tmp = get_attack_mode(& op, & hitter, & simple_attack);
  }
#line 1828
  if (tmp) {
#line 1829
    return (0);
  }
#line 1832
  if (op->flags[0] & (1U << 1)) {
#line 1833
    return (0);
  } else
#line 1832
  if (op->flags[3] & (1U << 6)) {
#line 1833
    return (0);
  }
#line 1835
  op_tag = op->count;
#line 1836
  hitter_tag = hitter->count;
#line 1838
  if (body_attack) {
#line 1848
    if (type & 6144U) {
#line 1849
      type &= 4294961151U;
#line 1850
      if (! type) {
#line 1851
        return (0);
      } else
#line 1850
      if (type == 2U) {
#line 1851
        return (0);
      }
    }
  }
#line 1855
  if (! simple_attack) {
#line 1855
    if ((int )op->type == 23) {
      {
#line 1858
      tmp___0 = object_find_by_type2((object const   *)op, 154, 155);
      }
#line 1859
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
        {
#line 1860
        spring_trap(tmp___0, hitter);
        }
#line 1861
        if (hitter->count != hitter_tag) {
#line 1864
          return (0);
        } else
#line 1861
        if (hitter->flags[0] & (1U << 3)) {
#line 1864
          return (0);
        } else
#line 1861
        if (op->count != op_tag) {
#line 1864
          return (0);
        } else
#line 1861
        if (op->flags[0] & (1U << 3)) {
#line 1864
          return (0);
        } else {
          {
#line 1861
          tmp___1 = abort_attack(op, hitter, simple_attack);
          }
#line 1861
          if (tmp___1) {
#line 1864
            return (0);
          }
        }
      }
    }
  }
#line 1868
  if (! (op->flags[0] & 1U)) {
    {
#line 1872
    LOG((LogLevel )2, "victim (arch %s, name %s) already dead in hit_player()\n",
        (op->arch)->name, op->name);
    }
#line 1873
    return (0);
  } else
#line 1868
  if ((int )op->stats.hp < 0) {
    {
#line 1872
    LOG((LogLevel )2, "victim (arch %s, name %s) already dead in hit_player()\n",
        (op->arch)->name, op->name);
    }
#line 1873
    return (0);
  }
#line 1880
  if (magic) {
#line 1883
    dam *= 100 - (int )op->resist[1];
#line 1884
    if (dam >= 100) {
#line 1885
      dam /= 100;
    } else {
      {
#line 1887
      tmp___3 = rndm(0, 99);
      }
#line 1887
      if (dam > tmp___3) {
#line 1887
        dam = 1;
      } else {
#line 1887
        dam = 0;
      }
    }
  }
#line 1895
  if (type & 262144U) {
    {
#line 1896
    tmp___4 = random();
#line 1896
    type = (uint32 )(ATTACKS[(unsigned long )tmp___4 % (sizeof(ATTACKS) / sizeof(ATTACKS[0]))].attacktype | 2);
    }
  }
#line 1903
  if (type & 2097152U) {
#line 1906
    if (! hitter->slaying) {
#line 1906
      goto _L___0;
    } else
#line 1906
    if (op->race) {
      {
#line 1906
      tmp___5 = strstr(hitter->slaying, op->race);
      }
#line 1906
      if (! tmp___5) {
#line 1906
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1906
    if (op->name) {
      {
#line 1906
      tmp___6 = strstr(hitter->slaying, op->name);
      }
#line 1906
      if (! tmp___6) {
#line 1906
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1906
    if (! (op->flags[1] & (1U << 4))) {
#line 1912
      return (0);
    } else
#line 1906
    if ((unsigned long )hitter->title != (unsigned long )((void *)0)) {
      {
#line 1906
      tmp___7 = determine_god(hitter);
#line 1906
      god = find_god(tmp___7);
      }
#line 1906
      if ((unsigned long )god != (unsigned long )((void *)0)) {
#line 1906
        if ((unsigned long )god->race != (unsigned long )((void *)0)) {
          {
#line 1906
          tmp___8 = strstr((char const   *)god->race, undead_name);
          }
#line 1906
          if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
#line 1912
            return (0);
          }
        }
      }
    }
  }
#line 1915
  maxattacktype = (int )type;
#line 1916
  attacknum = 0;
  {
#line 1916
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1916
    if (! (attacknum < 26)) {
#line 1916
      goto while_break;
    }
#line 1919
    attacktype = 1 << attacknum;
#line 1925
    if (attacktype == 2) {
#line 1925
      if (type & 4294967293U) {
#line 1926
        goto __Cont;
      }
    }
#line 1933
    if (type & (unsigned int )attacktype) {
      {
#line 1934
      ndam = hit_with_one_attacktype(op, hitter, dam, (uint32 )attacknum);
      }
#line 1938
      if (ndam >= maxdam) {
#line 1939
        maxdam = ndam;
#line 1940
        maxattacktype = 1 << attacknum;
      }
#line 1944
      if (attacktype == 131072) {
#line 1944
        if (ndam > 0) {
#line 1945
          full_hit = 1;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1916
    attacknum ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1961
  friendlyfire = friendly_fire(op, hitter);
  }
#line 1962
  if (friendlyfire) {
#line 1962
    if (maxdam) {
      {
#line 1963
      tmp___9 = op_on_battleground(op, (int *)((void *)0), (int *)((void *)0), (archetype **)((void *)0));
      }
#line 1963
      if (! tmp___9) {
#line 1964
        maxdam = (dam * (int )settings.set_friendly_fire) / 100 + 1;
      }
    }
  }
#line 1971
  if (! full_hit) {
#line 1976
    area = 0;
#line 1977
    at = op->arch;
    {
#line 1977
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1977
      if (! ((unsigned long )at != (unsigned long )((void *)0))) {
#line 1977
        goto while_break___0;
      }
#line 1978
      area ++;
#line 1977
      at = at->more;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1979
    if (! (area > 0)) {
      {
#line 1979
      __assert_fail("area > 0", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c",
                    1979U, "hit_player");
      }
    }
    {
#line 1983
    remainder = (100 * (maxdam % area)) / area;
#line 1984
    maxdam /= area;
#line 1985
    tmp___10 = random();
    }
#line 1985
    if (tmp___10 % 100L < (long )remainder) {
#line 1986
      maxdam ++;
    }
  }
  {
#line 1993
  owner = object_get_owner(hitter);
  }
#line 1994
  if ((unsigned long )owner != (unsigned long )((void *)0)) {
#line 1995
    if ((unsigned long )op->enemy != (unsigned long )hitter) {
      {
#line 1996
      object_set_enemy(op, owner);
      }
    }
  } else
#line 1997
  if (hitter->flags[0] & 1U) {
#line 1998
    if ((unsigned long )op->enemy == (unsigned long )((void *)0)) {
      {
#line 1999
      object_set_enemy(op, hitter);
      }
    } else {
      {
#line 1998
      tmp___11 = rndm(1, 20);
      }
#line 1998
      if (tmp___11 == 0) {
        {
#line 1999
        object_set_enemy(op, hitter);
        }
      }
    }
  }
#line 2001
  if (op->flags[1] & (1U << 6)) {
#line 2001
    if ((int )op->type != 1) {
      {
#line 2003
      op->flags[1] &= ~ (1U << 6);
#line 2004
      monster_npc_call_help(op);
      }
    }
  }
#line 2007
  if (magic) {
    {
#line 2007
    tmp___12 = did_make_save((object const   *)op, (int )op->level, 0);
    }
#line 2007
    if (tmp___12) {
#line 2008
      maxdam /= 2;
    }
  }
  {
#line 2010
  attack_message(maxdam, maxattacktype, op, hitter);
#line 2012
  op->stats.hp = (sint16 )((int )op->stats.hp - maxdam);
  }
#line 2015
  if ((int )op->stats.hp >= 0) {
#line 2015
    if (op->flags[0] & (1U << 14)) {
#line 2015
      goto _L___2;
    } else
#line 2015
    if ((int )op->type == 1) {
      _L___2: /* CIL Label */ 
#line 2015
      if ((int )op->stats.hp < (int )((short )(((float )op->run_away / (float )100) * (float )op->stats.maxhp))) {
#line 2018
        if (op->flags[0] & (1U << 14)) {
#line 2019
          op->flags[1] |= 1U << 13;
        } else {
          {
#line 2021
          scare_creature(op, hitter);
          }
        }
      }
    }
  }
#line 2024
  if (op->flags[1] & (1U << 12)) {
#line 2025
    if (maxdam) {
      {
#line 2026
      tear_down_wall(op);
      }
    }
#line 2027
    return (maxdam);
  }
  {
#line 2031
  rtn_kill = kill_object(op, maxdam, hitter);
  }
#line 2032
  if (rtn_kill != -1) {
#line 2033
    return (rtn_kill);
  }
#line 2039
  if (hitter->flags[3] & (1U << 1)) {
#line 2040
    if (hitter->flags[0] & (1U << 15)) {
      {
#line 2041
      remove_friendly_object(hitter);
      }
    }
    {
#line 2042
    object_remove(hitter);
#line 2043
    object_free_drop_inventory(hitter);
    }
  } else
#line 2045
  if (type & 1U) {
#line 2045
    if (! (op->flags[0] & (1U << 3))) {
#line 2045
      if (op->flags[1] & 1U) {
        {
#line 2046
        change_object(op);
        }
      } else {
#line 2045
        goto _L___4;
      }
    } else {
#line 2045
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 2047
  if (type & 128U) {
#line 2047
    if ((int )hitter->type == 28) {
#line 2047
      tmp___13 = hitter->value;
#line 2047
      (hitter->value) ++;
#line 2047
      if (tmp___13 > 10) {
        {
#line 2048
        object_remove(hitter);
#line 2049
        object_free_drop_inventory(hitter);
        }
      }
    }
  }
#line 2051
  return (maxdam);
}
}
#line 2064 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
static void poison_living(object *op , object *hitter , int dam ) 
{ 
  archetype *at ;
  archetype *tmp ;
  object *tmp___0 ;
  object *tmp___1 ;
  char const   *skill ;
  object *owner ;

  {
  {
#line 2065
  tmp = find_archetype("poisoning");
#line 2065
  at = tmp;
#line 2066
  tmp___1 = arch_present_in_ob((archetype const   *)at, (object const   *)op);
#line 2066
  tmp___0 = tmp___1;
  }
#line 2069
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 2070
    tmp___0 = arch_to_object(at);
    }
#line 2071
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 2072
      LOG((LogLevel )0, "Failed to clone arch poisoning.\n");
      }
    } else {
      {
#line 2074
      tmp___0 = object_insert_in_ob(tmp___0, op);
      }
#line 2083
      if (hitter->flags[0] & 1U) {
#line 2084
        tmp___0->stats.dam = (sint16 )((int )tmp___0->stats.dam + (int )hitter->level / 2);
      } else {
#line 2086
        tmp___0->stats.dam = (sint16 )dam;
      }
      {
#line 2088
      object_copy_owner(tmp___0, hitter);
#line 2089
      skill = hitter->skill;
      }
#line 2090
      if (! skill) {
#line 2090
        if (hitter->chosen_skill) {
#line 2091
          skill = (hitter->chosen_skill)->name;
        }
      }
#line 2093
      if (skill) {
#line 2093
        if ((unsigned long )skill != (unsigned long )tmp___0->skill) {
#line 2094
          if (tmp___0->skill) {
            {
#line 2095
            free_string(tmp___0->skill);
            }
          }
          {
#line 2096
          tmp___0->skill = add_refcount(skill);
          }
        }
      }
#line 2099
      tmp___0->stats.food += dam;
#line 2101
      if ((int )op->type == 1) {
#line 2103
        if (- (dam / 4 + 1) > -10) {
#line 2103
          tmp___0->stats.Con = (sint8 )(- (dam / 4 + 1));
        } else {
#line 2103
          tmp___0->stats.Con = (sint8 )-10;
        }
#line 2104
        if (- (dam / 3 + 2) > -10) {
#line 2104
          tmp___0->stats.Str = (sint8 )(- (dam / 3 + 2));
        } else {
#line 2104
          tmp___0->stats.Str = (sint8 )-10;
        }
#line 2105
        if (- (dam / 6 + 1) > -10) {
#line 2105
          tmp___0->stats.Dex = (sint8 )(- (dam / 6 + 1));
        } else {
#line 2105
          tmp___0->stats.Dex = (sint8 )-10;
        }
#line 2106
        if (- dam / 7 > -10) {
#line 2106
          tmp___0->stats.Int = (sint8 )(- dam / 7);
        } else {
#line 2106
          tmp___0->stats.Int = (sint8 )-10;
        }
        {
#line 2107
        tmp___0->flags[0] |= 1U << 5;
#line 2108
        fix_object(op);
#line 2109
        draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )7, "You suddenly feel very ill.");
        }
      }
#line 2113
      if ((int )hitter->type == 1) {
        {
#line 2114
        draw_ext_info_format(256, 0, (object const   *)hitter, (uint8 )14, (uint8 )1,
                             "You poison %s.", op->name);
        }
      } else {
        {
#line 2121
        owner = object_get_owner(hitter);
        }
#line 2122
        if ((unsigned long )owner != (unsigned long )((void *)0)) {
#line 2122
          if ((int )owner->type == 1) {
            {
#line 2123
            draw_ext_info_format(256, 0, (object const   *)owner, (uint8 )14, (uint8 )2,
                                 "Your %s poisons %s.", hitter->name, op->name);
            }
          }
        }
      }
#line 2128
      tmp___0->speed_left = (float )0;
    }
  } else {
#line 2131
    (tmp___0->stats.food) ++;
  }
#line 2132
  return;
}
}
#line 2144 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
static void slow_living(object *op , object *hitter , int dam ) 
{ 
  archetype *at ;
  archetype *tmp ;
  object *tmp___0 ;

  {
  {
#line 2145
  tmp = find_archetype("slowness");
#line 2145
  at = tmp;
  }
#line 2148
  if ((unsigned long )at == (unsigned long )((void *)0)) {
    {
#line 2149
    LOG((LogLevel )0, "Can\'t find slowness archetype.\n");
    }
  }
  {
#line 2151
  tmp___0 = arch_present_in_ob((archetype const   *)at, (object const   *)op);
  }
#line 2152
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 2153
    tmp___0 = arch_to_object(at);
#line 2154
    tmp___0 = object_insert_in_ob(tmp___0, op);
#line 2155
    draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )7, "The world suddenly moves very fast!");
    }
  } else {
#line 2158
    (tmp___0->stats.food) ++;
  }
  {
#line 2159
  tmp___0->flags[0] |= 1U << 5;
#line 2160
  tmp___0->speed_left = (float )0;
#line 2161
  fix_object(op);
  }
#line 2162
  return;
}
}
#line 2174 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
void confuse_living(object *op , object *hitter , int dam ) 
{ 
  object *tmp ;
  int maxduration ;
  int tmp___0 ;

  {
  {
#line 2178
  tmp = object_present_in_ob_by_name(114, "confusion", (object const   *)op);
  }
#line 2179
  if (! tmp) {
    {
#line 2180
    tmp = create_archetype("force");
#line 2181
    tmp = object_insert_in_ob(tmp, op);
    }
  }
#line 2187
  tmp->speed = (float )0.05;
#line 2188
  tmp->subtype = (uint8 )1;
#line 2189
  if (1 > (5 * (100 - (int )op->resist[5])) / 100) {
#line 2189
    tmp___0 = 1;
  } else {
#line 2189
    tmp___0 = (5 * (100 - (int )op->resist[5])) / 100;
  }
#line 2189
  tmp->duration = (sint16 )(8 + tmp___0);
#line 2190
  if (tmp->name) {
    {
#line 2191
    free_string(tmp->name);
    }
  }
  {
#line 2192
  tmp->name = add_string("confusion");
  }
#line 2193
  if (2 > (30 * (100 - (int )op->resist[5])) / 100) {
#line 2193
    maxduration = 2;
  } else {
#line 2193
    maxduration = (30 * (100 - (int )op->resist[5])) / 100;
  }
#line 2194
  if ((int )tmp->duration > maxduration) {
#line 2195
    tmp->duration = (sint16 )maxduration;
  }
#line 2197
  if ((int )op->type == 1) {
#line 2197
    if (! (op->flags[2] & (1U << 6))) {
      {
#line 2198
      draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )7, "You suddenly feel very confused!");
      }
    }
  }
#line 2200
  op->flags[2] |= 1U << 6;
#line 2201
  return;
}
}
#line 2213 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
void blind_living(object *op , object *hitter , int dam ) 
{ 
  object *tmp ;
  object *owner ;
  char victim[256] ;

  {
#line 2218
  if ((int )op->resist[22] == 100) {
#line 2219
    return;
  }
  {
#line 2221
  tmp = object_present_in_ob((uint8 )49, (object const   *)op);
  }
#line 2222
  if (! tmp) {
    {
#line 2223
    tmp = create_archetype("blindness");
#line 2224
    tmp->flags[2] |= 1U << 28;
#line 2225
    tmp->flags[0] |= 1U << 5;
#line 2229
    tmp->speed = (float )(((double )tmp->speed * (100.0 - (double )((float )op->resist[22]))) / (double )100);
#line 2231
    tmp = object_insert_in_ob(tmp, op);
#line 2232
    change_abil(op, tmp);
#line 2233
    fix_object(op);
#line 2235
    owner = object_get_owner(hitter);
    }
#line 2236
    if ((unsigned long )owner == (unsigned long )((void *)0)) {
#line 2237
      owner = hitter;
    }
    {
#line 2239
    query_name((object const   *)op, victim, (size_t )256);
#line 2240
    draw_ext_info_format(256, 0, (object const   *)owner, (uint8 )14, (uint8 )1, "Your attack blinds %s!",
                         victim);
    }
  }
#line 2244
  tmp->stats.food += dam;
#line 2245
  if (tmp->stats.food > 10) {
#line 2246
    tmp->stats.food = 10;
  }
#line 2247
  return;
}
}
#line 2257 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
void paralyze_living(object *op , int dam ) 
{ 
  float effect ;
  float max ;
  float tmp ;
  float tmp___0 ;
  float tmp___1 ;

  {
#line 2261
  effect = (float )((((double )((float )dam) * 3.0) * (100.0 - (double )op->resist[12])) / (double )100);
#line 2263
  if (effect == (float )0) {
#line 2264
    return;
  }
#line 2266
  if (op->speed < (float )0) {
#line 2266
    tmp = - op->speed;
  } else {
#line 2266
    tmp = op->speed;
  }
#line 2266
  op->speed_left -= tmp * effect;
#line 2269
  max = (float )((100 - (int )op->resist[12]) / 2);
#line 2270
  if (op->speed < (float )0) {
#line 2270
    tmp___1 = - op->speed;
  } else {
#line 2270
    tmp___1 = op->speed;
  }
#line 2270
  if (op->speed_left < - (tmp___1 * max)) {
#line 2271
    if (op->speed < (float )0) {
#line 2271
      tmp___0 = - op->speed;
    } else {
#line 2271
      tmp___0 = op->speed;
    }
#line 2271
    op->speed_left = - (tmp___0 * max);
  }
#line 2272
  return;
}
}
#line 2294 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
static void deathstrike_living(object *op , object *hitter , int *dam ) 
{ 
  int atk_lev ;
  int def_lev ;
  int kill_lev ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 2297
  if (hitter->slaying) {
#line 2298
    if (op->flags[1] & (1U << 4)) {
      {
#line 2298
      tmp = strstr(hitter->slaying, undead_name);
      }
#line 2298
      if (! tmp) {
#line 2298
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2298
    if (op->race) {
      {
#line 2298
      tmp___0 = strstr(hitter->slaying, op->race);
      }
#line 2298
      if (! tmp___0) {
#line 2300
        return;
      }
    } else {
#line 2300
      return;
    }
  } else
#line 2302
  if (op->flags[1] & (1U << 4)) {
#line 2303
    return;
  }
#line 2305
  def_lev = (int )op->level;
#line 2306
  if (def_lev < 1) {
    {
#line 2307
    LOG((LogLevel )0, "BUG: arch %s, name %s with level < 1\n", (op->arch)->name,
        op->name);
#line 2308
    def_lev = 1;
    }
  }
#line 2310
  if (hitter->chosen_skill) {
#line 2310
    tmp___1 = (int )(hitter->chosen_skill)->level;
  } else {
#line 2310
    tmp___1 = (int )hitter->level;
  }
#line 2310
  atk_lev = tmp___1 / 2;
#line 2313
  if (atk_lev >= def_lev) {
    {
#line 2314
    kill_lev = random_roll(0, atk_lev - 1, (object const   *)hitter, 1);
    }
#line 2321
    if (kill_lev >= def_lev) {
#line 2322
      *dam = (int )op->stats.hp + 10;
#line 2327
      *dam *= kill_lev / def_lev;
    }
  } else {
#line 2330
    *dam = 0;
  }
#line 2332
  return;
}
}
#line 2346 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
static void thrown_item_effect(object *hitter , object *victim ) 
{ 


  {
#line 2347
  if (! (hitter->flags[0] & 1U)) {
    {
#line 2352
    if ((int )hitter->type == 5) {
#line 2352
      goto case_5;
    }
#line 2360
    if ((int )hitter->type == 7) {
#line 2360
      goto case_7;
    }
#line 2351
    goto switch_break;
    case_5: /* CIL Label */ 
#line 2354
    if (victim->flags[0] & 1U) {
#line 2354
      if (! (victim->flags[1] & (1U << 4))) {
#line 2354
        if ((int )victim->resist[1] < 60) {
          {
#line 2357
          ob_apply(hitter, victim, 0);
          }
        }
      }
    }
#line 2358
    goto switch_break;
    case_7: /* CIL Label */ 
#line 2362
    if (victim->flags[0] & 1U) {
#line 2362
      if (! (victim->flags[1] & (1U << 4))) {
#line 2362
        if ((int )victim->resist[10] < 60) {
          {
#line 2365
          ob_apply(victim, hitter, 0);
          }
        }
      }
    }
#line 2366
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 2375
  return;
}
}
#line 2386 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
static int adj_attackroll(object *hitter , object *target ) 
{ 
  object *attacker ;
  int adjust ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2387
  attacker = hitter;
#line 2388
  adjust = 0;
#line 2391
  if (! target) {
    {
#line 2392
    LOG((LogLevel )0, "BUG: adj_attackroll(): hitter and target not on same map\n");
    }
#line 2393
    return (0);
  } else
#line 2391
  if (! hitter) {
    {
#line 2392
    LOG((LogLevel )0, "BUG: adj_attackroll(): hitter and target not on same map\n");
    }
#line 2393
    return (0);
  } else
#line 2391
  if (! hitter->map) {
    {
#line 2392
    LOG((LogLevel )0, "BUG: adj_attackroll(): hitter and target not on same map\n");
    }
#line 2393
    return (0);
  } else
#line 2391
  if (! target->map) {
    {
#line 2392
    LOG((LogLevel )0, "BUG: adj_attackroll(): hitter and target not on same map\n");
    }
#line 2393
    return (0);
  } else {
    {
#line 2391
    tmp = on_same_map((object const   *)hitter, (object const   *)target);
    }
#line 2391
    if (! tmp) {
      {
#line 2392
      LOG((LogLevel )0, "BUG: adj_attackroll(): hitter and target not on same map\n");
      }
#line 2393
      return (0);
    }
  }
  {
#line 2397
  tmp___0 = is_aimed_missile(hitter);
  }
#line 2397
  if (tmp___0) {
    {
#line 2398
    attacker = object_get_owner(hitter);
    }
#line 2399
    if ((unsigned long )attacker == (unsigned long )((void *)0)) {
#line 2400
      attacker = hitter;
    }
#line 2404
    if (attacker->flags[0] & (1U << 2)) {
#line 2405
      attacker = hitter;
    }
  } else
#line 2406
  if (! (hitter->flags[0] & 1U)) {
#line 2407
    return (0);
  }
  {
#line 2412
  tmp___3 = monster_can_see_enemy(attacker, target);
  }
#line 2412
  if (! tmp___3) {
#line 2414
    if (target->invisible) {
#line 2415
      adjust -= 10;
    } else
#line 2414
    if (attacker->flags[2] & (1U << 28)) {
#line 2415
      adjust -= 10;
    } else
#line 2417
    if (target->map) {
#line 2417
      if ((int )(target->map)->darkness > 0) {
        {
#line 2417
        tmp___1 = monster_stand_in_light(target);
        }
#line 2417
        if (! tmp___1) {
#line 2417
          if ((int )hitter->type != 1) {
#line 2418
            adjust -= (int )(target->map)->darkness;
          } else {
            {
#line 2417
            tmp___2 = player_can_view(hitter, target);
            }
#line 2417
            if (! tmp___2) {
#line 2418
              adjust -= (int )(target->map)->darkness;
            }
          }
        }
      }
    }
  }
#line 2421
  if (attacker->flags[1] & (1U << 5)) {
#line 2422
    adjust -= 3;
  }
#line 2424
  if (target->flags[1] & (1U << 6)) {
#line 2425
    adjust ++;
  }
#line 2427
  if (target->flags[1] & (1U << 5)) {
#line 2428
    adjust ++;
  }
#line 2430
  if (attacker->flags[2] & (1U << 6)) {
#line 2431
    adjust -= 3;
  }
#line 2439
  if (target->move_type) {
#line 2439
    if (((int )attacker->move_type & (int )target->move_type) == 0) {
#line 2440
      adjust -= 2;
    }
  }
#line 2442
  return (adjust);
}
}
#line 2453 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/attack.c"
static int is_aimed_missile(object *op ) 
{ 


  {
#line 2457
  if (op) {
#line 2457
    if ((int )op->move_type & 6) {
#line 2458
      if ((int )op->type == 13) {
#line 2459
        return (1);
      } else
#line 2458
      if ((int )op->type == 48) {
#line 2459
        return (1);
      } else
#line 2460
      if ((int )op->type == 102) {
#line 2460
        if ((int )op->subtype == 5) {
#line 2462
          return (1);
        } else
#line 2460
        if ((int )op->subtype == 6) {
#line 2462
          return (1);
        }
      }
    }
  }
#line 2464
  return (0);
}
}
#line 420 "../include/libproto.h"
int die_roll(int num , int size , object const   *op , int goodbad ) ;
#line 12 "../include/sockproto.h"
void ext_info_map(int color , mapstruct const   *map , uint8 type , uint8 subtype ,
                  char const   *str1 ) ;
#line 13
extern void ext_info_map_except(int color , mapstruct const   *map , object const   *op ,
                                uint8 type , uint8 subtype , char const   *str1 ) ;
#line 14
extern void ext_info_map_except2(int color , mapstruct const   *map , object const   *op1 ,
                                 object const   *op2 , int type , int subtype , char const   *str1 ) ;
#line 346 "../include/sproto.h"
extern void monster_communicate(object *op , char const   *txt ) ;
#line 391
extern player *find_player_options(char const   *plname , int options , mapstruct const   *map ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_say(object *op , char const   *params ) 
{ 


  {
#line 46
  if ((int const   )*params == 0) {
#line 47
    return;
  }
  {
#line 48
  monster_communicate(op, params);
  }
#line 49
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_me(object *op , char const   *params ) 
{ 
  char buf[256] ;

  {
#line 61
  if ((int const   )*params == 0) {
#line 62
    return;
  }
  {
#line 63
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s %s",
           op->name, params);
#line 64
  ext_info_map(261, (mapstruct const   *)op->map, (uint8 )15, (uint8 )3, (char const   *)(buf));
  }
#line 66
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_cointoss(object *op , char const   *params ) 
{ 
  char buf[256] ;
  char const   *result ;
  int tmp___0 ;

  {
  {
#line 79
  tmp___0 = rndm(1, 2);
  }
#line 79
  if (tmp___0 == 1) {
#line 79
    result = "Heads";
  } else {
#line 79
    result = "Tails";
  }
  {
#line 81
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )15, (uint8 )1, "You flip a coin.... %s!",
                       result);
#line 85
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s flips a coin.... %s!",
           op->name, result);
#line 86
  ext_info_map_except(1, (mapstruct const   *)op->map, (object const   *)op, (uint8 )15,
                      (uint8 )1, (char const   *)(buf));
  }
#line 88
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
static char const   * const  orcknuckle[7]  = {      (char const   */* const  */)"none",      (char const   */* const  */)"beholder",      (char const   */* const  */)"ghost",      (char const   */* const  */)"knight", 
        (char const   */* const  */)"princess",      (char const   */* const  */)"dragon",      (char const   */* const  */)"orc"};
#line 118 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_orcknuckle(object *op , char const   *params ) 
{ 
  char buf[256] ;
  char buf2[256] ;
  object *dice[4] ;
  int i ;
  int j ;
  int k ;
  int l ;
  int dice_count ;
  int number_dice ;
  char const   *name ;
  object *ob ;
  object *next133 ;
  tag_t next_tag133 ;
  tag_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 126
  name = find_string("dice");
  }
#line 127
  if (name) {
#line 128
    dice_count = 0;
    {
#line 128
    while (1) {
      while_continue: /* CIL Label */ ;
#line 128
      if (! (dice_count < 4)) {
#line 128
        goto while_break;
      }
#line 129
      dice[dice_count] = (object *)((void *)0);
#line 128
      dice_count ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 130
    dice_count = 0;
#line 131
    number_dice = 0;
    {
#line 133
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 133
      ob = op->inv;
      {
#line 133
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 133
        next133 = ob;
#line 133
        if ((unsigned long )next133 == (unsigned long )((void *)0)) {
#line 133
          tmp = (tag_t )0;
        } else {
#line 133
          tmp = next133->count;
        }
#line 133
        next_tag133 = tmp;
        {
#line 133
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 133
          ob = next133;
#line 133
          if (! ((unsigned long )ob != (unsigned long )((void *)0))) {
#line 133
            goto while_break___2;
          }
#line 133
          if (next133->count != next_tag133) {
#line 133
            goto while_break___2;
          } else
#line 133
          if (next133->flags[0] & (1U << 3)) {
#line 133
            goto while_break___2;
          }
#line 133
          next133 = next133->below;
#line 133
          if ((unsigned long )next133 == (unsigned long )((void *)0)) {
#line 133
            next_tag133 = (tag_t )0;
          } else {
#line 133
            next_tag133 = next133->count;
          }
#line 134
          if (dice_count >= 4) {
#line 135
            goto while_break___2;
          } else
#line 134
          if (number_dice >= 4) {
#line 135
            goto while_break___2;
          }
#line 136
          if ((unsigned long )ob->name == (unsigned long )name) {
#line 137
            number_dice = (int )((uint32 )number_dice + ob->nrof);
#line 138
            tmp___0 = dice_count;
#line 138
            dice_count ++;
#line 138
            dice[tmp___0] = ob;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 133
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 133
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 142
    if (number_dice < 4) {
      {
#line 143
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )15, (uint8 )1, "You need at least %d dice to play orcknuckle!",
                           4);
      }
#line 145
      return;
    }
  } else {
#line 148
    dice_count = 0;
  }
  {
#line 151
  i = rndm(1, 5);
#line 152
  j = rndm(1, 5);
#line 153
  k = rndm(1, 5);
#line 154
  l = rndm(1, 6);
#line 156
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s rolls %s, %s, %s, %s!",
           op->name, orcknuckle[i], orcknuckle[j], orcknuckle[k], orcknuckle[l]);
#line 157
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You roll %s, %s, %s, %s!",
           orcknuckle[i], orcknuckle[j], orcknuckle[k], orcknuckle[l]);
#line 159
  draw_ext_info(256, 0, (object const   *)op, (uint8 )15, (uint8 )1, (char const   *)(buf));
#line 161
  ext_info_map_except(256, (mapstruct const   *)op->map, (object const   *)op, (uint8 )15,
                      (uint8 )1, (char const   *)(buf2));
  }
#line 164
  if (name) {
    {
#line 166
    tmp___2 = die_roll(1, 100, (object const   *)op, 1);
    }
#line 166
    if (tmp___2 < 5) {
      {
#line 168
      tmp___1 = rndm(1, dice_count);
#line 168
      object_decrease_nrof(dice[tmp___1 - 1], (uint32 )1);
#line 169
      draw_ext_info(256, 0, (object const   *)op, (uint8 )15, (uint8 )1, "Oops, you lost a die!");
      }
    }
  }
#line 174
  return;
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
static void command_tell_all(object *op , char const   *params , int pri , int color ,
                             int subtype , char const   *desc ) 
{ 


  {
#line 193
  if ((op->contr)->no_shout == 1U) {
    {
#line 194
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You are no longer allowed to shout or chat.");
    }
#line 196
    return;
  }
#line 199
  if ((int const   )*params == 0) {
    {
#line 200
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Shout/Chat what?");
    }
#line 202
    return;
  }
  {
#line 205
  draw_ext_info_format(768 | color, pri, (object const   *)((void *)0), (uint8 )15,
                       (uint8 )subtype, "%s %s: %s", op->name, desc, params);
#line 210
  execute_global_event(25, op, params, pri);
  }
#line 211
  return;
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_shout(object *op , char const   *params ) 
{ 


  {
  {
#line 221
  command_tell_all(op, params, 1, 3, 7, "shouts");
  }
#line 222
  return;
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_chat(object *op , char const   *params ) 
{ 


  {
  {
#line 232
  command_tell_all(op, params, 9, 5, 8, "chats");
  }
#line 233
  return;
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
static void do_tell(object *op , char const   *params , int adjust_listen ) 
{ 
  char buf[256] ;
  char name[256] ;
  char *msg ;
  player *pl ;
  uint8 original_listen ;
  size_t tmp ;

  {
  {
#line 247
  msg = (char *)((void *)0);
#line 251
  strncpy((char */* __restrict  */)(name), (char const   */* __restrict  */)params,
          sizeof(name));
#line 253
  msg = strchr((char const   *)(name), ' ');
  }
#line 254
  if (msg) {
#line 255
    *msg = (char )'\000';
#line 256
    msg ++;
#line 257
    if ((int )*msg == 0) {
#line 258
      msg = (char *)((void *)0);
    }
  }
  {
#line 261
  tmp = strlen((char const   *)(name));
  }
#line 261
  if (tmp == 0UL) {
    {
#line 262
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Tell whom what?");
    }
#line 264
    return;
  }
#line 267
  if ((unsigned long )msg == (unsigned long )((void *)0)) {
    {
#line 268
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Tell %s what?",
                         name);
    }
#line 271
    return;
  }
  {
#line 274
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s tells you: %s",
           op->name, msg);
#line 276
  pl = find_player_partial_name((char const   *)(name));
  }
#line 277
  if (pl) {
#line 278
    if (adjust_listen) {
#line 279
      original_listen = pl->listening;
#line 280
      pl->listening = (uint8 )10;
    } else {
#line 282
      original_listen = (uint8 )0;
    }
    {
#line 285
    execute_global_event(26, op, msg, pl->ob);
#line 287
    draw_ext_info(260, 0, (object const   *)pl->ob, (uint8 )15, (uint8 )4, (char const   *)(buf));
    }
#line 290
    if (adjust_listen) {
#line 291
      pl->listening = original_listen;
    }
    {
#line 294
    snprintf((char */* __restrict  */)(pl->last_tell), sizeof(pl->last_tell), (char const   */* __restrict  */)"%s",
             op->name);
    }
#line 297
    if (! pl->hidden) {
      {
#line 298
      draw_ext_info_format(260, 0, (object const   *)op, (uint8 )15, (uint8 )4, "You tell %s: %s",
                           (pl->ob)->name, msg);
      }
#line 302
      return;
    } else
#line 297
    if (op->flags[0] & (1U << 1)) {
      {
#line 298
      draw_ext_info_format(260, 0, (object const   *)op, (uint8 )15, (uint8 )4, "You tell %s: %s",
                           (pl->ob)->name, msg);
      }
#line 302
      return;
    }
  }
  {
#line 306
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "No such player or ambiguous name.");
  }
#line 308
  return;
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_tell(object *op , char const   *params ) 
{ 


  {
  {
#line 319
  do_tell(op, params, 0);
  }
#line 320
  return;
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_dmtell(object *op , char const   *params ) 
{ 


  {
  {
#line 331
  do_tell(op, params, 1);
  }
#line 332
  return;
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_reply(object *op , char const   *params ) 
{ 
  player *pl ;

  {
#line 349
  if ((int const   )*params == 0) {
    {
#line 350
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Reply what?");
    }
#line 352
    return;
  }
#line 355
  if ((int )(op->contr)->last_tell[0] == 0) {
    {
#line 356
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You can\'t reply to nobody.");
    }
#line 358
    return;
  }
  {
#line 362
  pl = find_player((char const   *)((op->contr)->last_tell));
  }
#line 363
  if ((unsigned long )pl == (unsigned long )((void *)0)) {
    {
#line 364
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You can\'t reply, this player left.");
    }
#line 366
    return;
  }
  {
#line 370
  strcpy((char */* __restrict  */)(pl->last_tell), (char const   */* __restrict  */)op->name);
#line 372
  draw_ext_info_format(260, 0, (object const   *)pl->ob, (uint8 )15, (uint8 )4, "%s tells you: %s",
                       op->name, params);
  }
#line 376
  if (pl->hidden) {
#line 376
    if (! (op->flags[0] & (1U << 1))) {
      {
#line 377
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You can\'t reply, this player left.");
      }
#line 379
      return;
    }
  }
  {
#line 382
  draw_ext_info_format(260, 0, (object const   *)op, (uint8 )15, (uint8 )4, "You tell to %s: %s",
                       (pl->ob)->name, params);
  }
#line 385
  return;
}
}
#line 408 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
static void basic_emote(object *op , char const   *params , int emotion ) 
{ 
  char buf[256] ;
  char buf2[256] ;
  char buf3[256] ;
  player *pl ;

  {
#line 412
  if ((int const   )*params == 0) {
    {
#line 414
    if (emotion == 1) {
#line 414
      goto case_1;
    }
#line 419
    if (emotion == 2) {
#line 419
      goto case_2;
    }
#line 424
    if (emotion == 3) {
#line 424
      goto case_3;
    }
#line 429
    if (emotion == 4) {
#line 429
      goto case_4;
    }
#line 434
    if (emotion == 5) {
#line 434
      goto case_5;
    }
#line 439
    if (emotion == 6) {
#line 439
      goto case_6;
    }
#line 444
    if (emotion == 7) {
#line 444
      goto case_7;
    }
#line 449
    if (emotion == 8) {
#line 449
      goto case_8;
    }
#line 454
    if (emotion == 9) {
#line 454
      goto case_9;
    }
#line 459
    if (emotion == 10) {
#line 459
      goto case_10;
    }
#line 464
    if (emotion == 11) {
#line 464
      goto case_11;
    }
#line 469
    if (emotion == 12) {
#line 469
      goto case_12;
    }
#line 474
    if (emotion == 13) {
#line 474
      goto case_13;
    }
#line 479
    if (emotion == 14) {
#line 479
      goto case_14;
    }
#line 484
    if (emotion == 16) {
#line 484
      goto case_16;
    }
#line 489
    if (emotion == 19) {
#line 489
      goto case_19;
    }
#line 494
    if (emotion == 20) {
#line 494
      goto case_20;
    }
#line 499
    if (emotion == 21) {
#line 499
      goto case_21;
    }
#line 504
    if (emotion == 22) {
#line 504
      goto case_22;
    }
#line 509
    if (emotion == 23) {
#line 509
      goto case_23;
    }
#line 514
    if (emotion == 24) {
#line 514
      goto case_24;
    }
#line 519
    if (emotion == 25) {
#line 519
      goto case_25;
    }
#line 524
    if (emotion == 26) {
#line 524
      goto case_26;
    }
#line 529
    if (emotion == 27) {
#line 529
      goto case_27;
    }
#line 534
    if (emotion == 28) {
#line 534
      goto case_28;
    }
#line 539
    if (emotion == 29) {
#line 539
      goto case_29;
    }
#line 544
    if (emotion == 30) {
#line 544
      goto case_30;
    }
#line 549
    if (emotion == 31) {
#line 549
      goto case_31;
    }
#line 554
    if (emotion == 32) {
#line 554
      goto case_32;
    }
#line 559
    if (emotion == 33) {
#line 559
      goto case_33;
    }
#line 564
    if (emotion == 34) {
#line 564
      goto case_34;
    }
#line 569
    if (emotion == 35) {
#line 569
      goto case_35;
    }
#line 574
    if (emotion == 37) {
#line 574
      goto case_37;
    }
#line 579
    if (emotion == 38) {
#line 579
      goto case_38;
    }
#line 584
    if (emotion == 39) {
#line 584
      goto case_39;
    }
#line 589
    if (emotion == 40) {
#line 589
      goto case_40;
    }
#line 594
    if (emotion == 41) {
#line 594
      goto case_41;
    }
#line 599
    if (emotion == 42) {
#line 599
      goto case_42;
    }
#line 604
    if (emotion == 43) {
#line 604
      goto case_43;
    }
#line 609
    if (emotion == 44) {
#line 609
      goto case_44;
    }
#line 614
    if (emotion == 46) {
#line 614
      goto case_46;
    }
#line 619
    if (emotion == 47) {
#line 619
      goto case_47;
    }
#line 624
    if (emotion == 48) {
#line 624
      goto case_48;
    }
#line 629
    if (emotion == 49) {
#line 629
      goto case_49;
    }
#line 634
    if (emotion == 50) {
#line 634
      goto case_50;
    }
#line 639
    if (emotion == 53) {
#line 639
      goto case_53;
    }
#line 644
    if (emotion == 52) {
#line 644
      goto case_52;
    }
#line 649
    if (emotion == 54) {
#line 649
      goto case_54;
    }
#line 654
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 415
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s nods solemnly.",
             op->name);
#line 416
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You nod solemnly.");
    }
#line 417
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 420
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s expresses himself through interpretive dance.",
             op->name);
#line 421
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You dance with glee.");
    }
#line 422
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 425
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s makes a weird facial contortion",
             op->name);
#line 426
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"All the lonely people..");
    }
#line 427
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 430
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s bounces around.",
             op->name);
#line 431
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"BOIINNNNNNGG!");
    }
#line 432
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 435
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s smiles happily.",
             op->name);
#line 436
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You smile happily.");
    }
#line 437
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 440
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s throws back his head and cackles with insane glee!",
             op->name);
#line 441
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You cackle gleefully.");
    }
#line 442
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 445
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s falls down laughing.",
             op->name);
#line 446
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You fall down laughing.");
    }
#line 447
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 450
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s giggles.",
             op->name);
#line 451
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You giggle.");
    }
#line 452
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 455
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s shakes his head.",
             op->name);
#line 456
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You shake your head.");
    }
#line 457
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 460
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s pukes.",
             op->name);
#line 461
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"Bleaaaaaghhhhhhh!");
    }
#line 462
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 465
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s growls.",
             op->name);
#line 466
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"Grrrrrrrrr....");
    }
#line 467
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 470
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s screams at the top of his lungs!",
             op->name);
#line 471
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"ARRRRRRRRRRGH!!!!!");
    }
#line 472
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 475
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s sighs loudly.",
             op->name);
#line 476
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You sigh.");
    }
#line 477
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 480
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s sulks in the corner.",
             op->name);
#line 481
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You sulk.");
    }
#line 482
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 485
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s bursts into tears.",
             op->name);
#line 486
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"Waaaaaaahhh..");
    }
#line 487
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 490
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s grins evilly.",
             op->name);
#line 491
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You grin evilly.");
    }
#line 492
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 495
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s bows deeply.",
             op->name);
#line 496
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You bow deeply.");
    }
#line 497
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 500
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s gives a round of applause.",
             op->name);
#line 501
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"Clap, clap, clap.");
    }
#line 502
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 505
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s blushes.",
             op->name);
#line 506
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"Your cheeks are burning.");
    }
#line 507
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 510
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s burps loudly.",
             op->name);
#line 511
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You burp loudly.");
    }
#line 512
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 515
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s chuckles politely.",
             op->name);
#line 516
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You chuckle politely");
    }
#line 517
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 520
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s coughs loudly.",
             op->name);
#line 521
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"Yuck, try to cover your mouth next time!");
    }
#line 522
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 525
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s flips head over heels.",
             op->name);
#line 526
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You flip head over heels.");
    }
#line 527
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 530
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s frowns.",
             op->name);
#line 531
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"What\'s bothering you?");
    }
#line 532
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 535
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s gasps in astonishment.",
             op->name);
#line 536
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You gasp in astonishment.");
    }
#line 537
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 540
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s glares around him.",
             op->name);
#line 541
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You glare at nothing in particular.");
    }
#line 542
    goto switch_break;
    case_30: /* CIL Label */ 
    {
#line 545
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s groans loudly.",
             op->name);
#line 546
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You groan loudly.");
    }
#line 547
    goto switch_break;
    case_31: /* CIL Label */ 
    {
#line 550
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s hiccups.",
             op->name);
#line 551
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"*HIC*");
    }
#line 552
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 555
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s licks his mouth and smiles.",
             op->name);
#line 556
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You lick your mouth and smile.");
    }
#line 557
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 560
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s pouts.",
             op->name);
#line 561
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"Aww, don\'t take it so hard.");
    }
#line 562
    goto switch_break;
    case_34: /* CIL Label */ 
    {
#line 565
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s shivers uncomfortably.",
             op->name);
#line 566
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"Brrrrrrrrr.");
    }
#line 567
    goto switch_break;
    case_35: /* CIL Label */ 
    {
#line 570
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s shrugs helplessly.",
             op->name);
#line 571
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You shrug.");
    }
#line 572
    goto switch_break;
    case_37: /* CIL Label */ 
    {
#line 575
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s smirks.",
             op->name);
#line 576
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You smirk.");
    }
#line 577
    goto switch_break;
    case_38: /* CIL Label */ 
    {
#line 580
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s snaps his fingers.",
             op->name);
#line 581
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"PRONTO! You snap your fingers.");
    }
#line 582
    goto switch_break;
    case_39: /* CIL Label */ 
    {
#line 585
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s sneezes.",
             op->name);
#line 586
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"Gesundheit!");
    }
#line 587
    goto switch_break;
    case_40: /* CIL Label */ 
    {
#line 590
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s snickers softly.",
             op->name);
#line 591
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You snicker softly.");
    }
#line 592
    goto switch_break;
    case_41: /* CIL Label */ 
    {
#line 595
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s sniffs sadly.",
             op->name);
#line 596
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You sniff sadly. *SNIFF*");
    }
#line 597
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 600
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s snores loudly.",
             op->name);
#line 601
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"Zzzzzzzzzzzzzzz.");
    }
#line 602
    goto switch_break;
    case_43: /* CIL Label */ 
    {
#line 605
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s spits over his left shoulder.",
             op->name);
#line 606
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You spit over your left shoulder.");
    }
#line 607
    goto switch_break;
    case_44: /* CIL Label */ 
    {
#line 610
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s struts proudly.",
             op->name);
#line 611
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"Strut your stuff.");
    }
#line 612
    goto switch_break;
    case_46: /* CIL Label */ 
    {
#line 615
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s patiently twiddles his thumbs.",
             op->name);
#line 616
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You patiently twiddle your thumbs.");
    }
#line 617
    goto switch_break;
    case_47: /* CIL Label */ 
    {
#line 620
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s waves happily.",
             op->name);
#line 621
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You wave.");
    }
#line 622
    goto switch_break;
    case_48: /* CIL Label */ 
    {
#line 625
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s whistles appreciatively.",
             op->name);
#line 626
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You whistle appreciatively.");
    }
#line 627
    goto switch_break;
    case_49: /* CIL Label */ 
    {
#line 630
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s winks suggestively.",
             op->name);
#line 631
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"Have you got something in your eye?");
    }
#line 632
    goto switch_break;
    case_50: /* CIL Label */ 
    {
#line 635
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s yawns sleepily.",
             op->name);
#line 636
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You open up your yap and let out a big breeze of stale air.");
    }
#line 637
    goto switch_break;
    case_53: /* CIL Label */ 
    {
#line 640
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s cringes in terror!",
             op->name);
#line 641
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You cringe in terror.");
    }
#line 642
    goto switch_break;
    case_52: /* CIL Label */ 
    {
#line 645
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s is bleeding all over the carpet - got a spare tourniquet?",
             op->name);
#line 646
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You bleed all over your nice new armour.");
    }
#line 647
    goto switch_break;
    case_54: /* CIL Label */ 
    {
#line 650
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s closes his eyes and thinks really hard.",
             op->name);
#line 651
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"Anything in particular that you\'d care to think about?");
    }
#line 652
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 655
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s dances with glee.",
             op->name);
#line 656
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You are a nut.");
    }
#line 657
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 659
    ext_info_map_except(1, (mapstruct const   *)op->map, (object const   *)op, (uint8 )15,
                        (uint8 )5, (char const   *)(buf));
#line 661
    draw_ext_info(257, 0, (object const   *)op, (uint8 )15, (uint8 )5, (char const   *)(buf2));
    }
#line 663
    return;
  }
  {
#line 667
  pl = find_player_options(params, 3, (mapstruct const   *)op->map);
  }
#line 669
  if ((unsigned long )pl == (unsigned long )((void *)0)) {
    {
#line 670
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "%s is not around.",
                         params);
    }
#line 673
    return;
  }
#line 676
  if ((unsigned long )pl->ob == (unsigned long )op) {
    {
#line 679
    if (emotion == 2) {
#line 679
      goto case_2___0;
    }
#line 684
    if (emotion == 7) {
#line 684
      goto case_7___0;
    }
#line 689
    if (emotion == 9) {
#line 689
      goto case_9___0;
    }
#line 694
    if (emotion == 10) {
#line 694
      goto case_10___0;
    }
#line 699
    if (emotion == 15) {
#line 699
      goto case_15;
    }
#line 704
    if (emotion == 16) {
#line 704
      goto case_16___0;
    }
#line 709
    if (emotion == 17) {
#line 709
      goto case_17;
    }
#line 714
    if (emotion == 18) {
#line 714
      goto case_18;
    }
#line 719
    if (emotion == 20) {
#line 719
      goto case_20___0;
    }
#line 724
    if (emotion == 27) {
#line 724
      goto case_27___0;
    }
#line 729
    if (emotion == 29) {
#line 729
      goto case_29___0;
    }
#line 734
    if (emotion == 32) {
#line 734
      goto case_32___0;
    }
#line 739
    if (emotion == 36) {
#line 739
      goto case_36;
    }
#line 744
    if (emotion == 39) {
#line 744
      goto case_39___0;
    }
#line 749
    if (emotion == 41) {
#line 749
      goto case_41___0;
    }
#line 754
    if (emotion == 43) {
#line 754
      goto case_43___0;
    }
#line 759
    if (emotion == 45) {
#line 759
      goto case_45;
    }
#line 764
    if (emotion == 47) {
#line 764
      goto case_47___0;
    }
#line 769
    if (emotion == 48) {
#line 769
      goto case_48___0;
    }
#line 774
    if (emotion == 49) {
#line 774
      goto case_49___0;
    }
#line 779
    if (emotion == 52) {
#line 779
      goto case_52___0;
    }
#line 784
    goto switch_default___0;
    case_2___0: /* CIL Label */ 
    {
#line 680
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You skip and dance around by yourself.");
#line 681
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s embraces himself and begins to dance!",
             op->name);
    }
#line 682
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
    {
#line 685
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"Laugh at yourself all you want, the others won\'t understand.");
#line 686
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s is laughing at something.",
             op->name);
    }
#line 687
    goto switch_break___0;
    case_9___0: /* CIL Label */ 
    {
#line 690
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You are shaken by yourself.");
#line 691
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s shakes and quivers like a bowlful of jelly.",
             op->name);
    }
#line 692
    goto switch_break___0;
    case_10___0: /* CIL Label */ 
    {
#line 695
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You puke on yourself.");
#line 696
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s pukes on his clothes.",
             op->name);
    }
#line 697
    goto switch_break___0;
    case_15: /* CIL Label */ 
    {
#line 700
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You hug yourself.");
#line 701
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s hugs himself.",
             op->name);
    }
#line 702
    goto switch_break___0;
    case_16___0: /* CIL Label */ 
    {
#line 705
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You cry to yourself.");
#line 706
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s sobs quietly to himself.",
             op->name);
    }
#line 707
    goto switch_break___0;
    case_17: /* CIL Label */ 
    {
#line 710
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You poke yourself in the ribs, feeling very silly.");
#line 711
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s pokes himself in the ribs, looking very sheepish.",
             op->name);
    }
#line 712
    goto switch_break___0;
    case_18: /* CIL Label */ 
    {
#line 715
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You accuse yourself.");
#line 716
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s seems to have a bad conscience.",
             op->name);
    }
#line 717
    goto switch_break___0;
    case_20___0: /* CIL Label */ 
    {
#line 720
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You kiss your toes.");
#line 721
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s folds up like a jackknife and kisses his own toes.",
             op->name);
    }
#line 722
    goto switch_break___0;
    case_27___0: /* CIL Label */ 
    {
#line 725
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You frown at yourself.");
#line 726
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s frowns at himself.",
             op->name);
    }
#line 727
    goto switch_break___0;
    case_29___0: /* CIL Label */ 
    {
#line 730
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You glare icily at your feet, they are suddenly very cold.");
#line 731
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s glares at his feet, what is bothering him?",
             op->name);
    }
#line 732
    goto switch_break___0;
    case_32___0: /* CIL Label */ 
    {
#line 735
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You lick yourself.");
#line 736
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s licks himself - YUCK.",
             op->name);
    }
#line 737
    goto switch_break___0;
    case_36: /* CIL Label */ 
    {
#line 740
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You slap yourself, silly you.");
#line 741
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s slaps himself, really strange...",
             op->name);
    }
#line 742
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
    {
#line 745
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You sneeze on yourself, what a mess!");
#line 746
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s sneezes, and covers himself in a slimy substance.",
             op->name);
    }
#line 747
    goto switch_break___0;
    case_41___0: /* CIL Label */ 
    {
#line 750
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You sniff yourself.");
#line 751
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s sniffs himself.",
             op->name);
    }
#line 752
    goto switch_break___0;
    case_43___0: /* CIL Label */ 
    {
#line 755
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You drool all over yourself.");
#line 756
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s drools all over himself.",
             op->name);
    }
#line 757
    goto switch_break___0;
    case_45: /* CIL Label */ 
    {
#line 760
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You thank yourself since nobody else wants to!");
#line 761
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s thanks himself since you won\'t.",
             op->name);
    }
#line 762
    goto switch_break___0;
    case_47___0: /* CIL Label */ 
    {
#line 765
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"Are you going on adventures as well??");
#line 766
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s waves goodbye to himself.",
             op->name);
    }
#line 767
    goto switch_break___0;
    case_48___0: /* CIL Label */ 
    {
#line 770
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You whistle while you work.");
#line 771
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s whistles to himself in boredom.",
             op->name);
    }
#line 772
    goto switch_break___0;
    case_49___0: /* CIL Label */ 
    {
#line 775
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You wink at yourself?? What are you up to?");
#line 776
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s winks at himself - something strange is going on...",
             op->name);
    }
#line 777
    goto switch_break___0;
    case_52___0: /* CIL Label */ 
    {
#line 780
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"Very impressive! You wipe your blood all over yourself.");
#line 781
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s performs some satanic ritual while wiping his blood on himself.",
             op->name);
    }
#line 782
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 785
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"My god! is that LEGAL?");
#line 786
    snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You look away from %s.",
             op->name);
    }
#line 787
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 790
    draw_ext_info(257, 0, (object const   *)op, (uint8 )15, (uint8 )5, (char const   *)(buf));
#line 792
    ext_info_map_except(1, (mapstruct const   *)op->map, (object const   *)op, (uint8 )15,
                        (uint8 )5, (char const   *)(buf2));
    }
#line 794
    return;
  }
  {
#line 799
  if (emotion == 1) {
#line 799
    goto case_1___0;
  }
#line 805
  if (emotion == 2) {
#line 805
    goto case_2___1;
  }
#line 811
  if (emotion == 3) {
#line 811
    goto case_3___0;
  }
#line 817
  if (emotion == 4) {
#line 817
    goto case_4___0;
  }
#line 823
  if (emotion == 5) {
#line 823
    goto case_5___0;
  }
#line 829
  if (emotion == 7) {
#line 829
    goto case_7___1;
  }
#line 835
  if (emotion == 9) {
#line 835
    goto case_9___1;
  }
#line 841
  if (emotion == 10) {
#line 841
    goto case_10___1;
  }
#line 847
  if (emotion == 15) {
#line 847
    goto case_15___0;
  }
#line 853
  if (emotion == 16) {
#line 853
    goto case_16___1;
  }
#line 859
  if (emotion == 17) {
#line 859
    goto case_17___0;
  }
#line 865
  if (emotion == 18) {
#line 865
    goto case_18___0;
  }
#line 871
  if (emotion == 19) {
#line 871
    goto case_19___0;
  }
#line 877
  if (emotion == 20) {
#line 877
    goto case_20___1;
  }
#line 883
  if (emotion == 27) {
#line 883
    goto case_27___1;
  }
#line 889
  if (emotion == 29) {
#line 889
    goto case_29___1;
  }
#line 895
  if (emotion == 32) {
#line 895
    goto case_32___1;
  }
#line 901
  if (emotion == 35) {
#line 901
    goto case_35___0;
  }
#line 907
  if (emotion == 36) {
#line 907
    goto case_36___0;
  }
#line 913
  if (emotion == 39) {
#line 913
    goto case_39___1;
  }
#line 919
  if (emotion == 41) {
#line 919
    goto case_41___1;
  }
#line 925
  if (emotion == 43) {
#line 925
    goto case_43___1;
  }
#line 931
  if (emotion == 45) {
#line 931
    goto case_45___0;
  }
#line 937
  if (emotion == 47) {
#line 937
    goto case_47___1;
  }
#line 943
  if (emotion == 48) {
#line 943
    goto case_48___1;
  }
#line 949
  if (emotion == 49) {
#line 949
    goto case_49___1;
  }
#line 955
  if (emotion == 51) {
#line 955
    goto case_51;
  }
#line 961
  if (emotion == 52) {
#line 961
    goto case_52___1;
  }
#line 967
  if (emotion == 53) {
#line 967
    goto case_53___0;
  }
#line 973
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
  {
#line 800
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You nod solemnly to %s.",
           (pl->ob)->name);
#line 801
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s nods solemnly to you.",
           op->name);
#line 802
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s nods solemnly to %s.",
           op->name, (pl->ob)->name);
  }
#line 803
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
  {
#line 806
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You grab %s and begin doing the Cha-Cha!",
           (pl->ob)->name);
#line 807
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s grabs you, and begins dancing!",
           op->name);
#line 808
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"Yipe! %s and %s are doing the Macarena!",
           op->name, (pl->ob)->name);
  }
#line 809
  goto switch_break___1;
  case_3___0: /* CIL Label */ 
  {
#line 812
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You kiss %s.",
           (pl->ob)->name);
#line 813
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s kisses you.",
           op->name);
#line 814
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s kisses %s.",
           op->name, (pl->ob)->name);
  }
#line 815
  goto switch_break___1;
  case_4___0: /* CIL Label */ 
  {
#line 818
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You bounce around the room with %s.",
           (pl->ob)->name);
#line 819
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s bounces around the room with you.",
           op->name);
#line 820
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s bounces around the room with %s.",
           op->name, (pl->ob)->name);
  }
#line 821
  goto switch_break___1;
  case_5___0: /* CIL Label */ 
  {
#line 824
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You smile at %s.",
           (pl->ob)->name);
#line 825
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s smiles at you.",
           op->name);
#line 826
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s beams a smile at %s.",
           op->name, (pl->ob)->name);
  }
#line 827
  goto switch_break___1;
  case_7___1: /* CIL Label */ 
  {
#line 830
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You take one look at %s and fall down laughing.",
           (pl->ob)->name);
#line 831
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s looks at you and falls down on the ground laughing.",
           op->name);
#line 832
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s looks at %s and falls down on the ground laughing.",
           op->name, (pl->ob)->name);
  }
#line 833
  goto switch_break___1;
  case_9___1: /* CIL Label */ 
  {
#line 836
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You shake %s\'s hand.",
           (pl->ob)->name);
#line 837
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s shakes your hand.",
           op->name);
#line 838
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s shakes %s\'s hand.",
           op->name, (pl->ob)->name);
  }
#line 839
  goto switch_break___1;
  case_10___1: /* CIL Label */ 
  {
#line 842
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You puke on %s.",
           (pl->ob)->name);
#line 843
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s pukes on your clothes!",
           op->name);
#line 844
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s pukes on %s.",
           op->name, (pl->ob)->name);
  }
#line 845
  goto switch_break___1;
  case_15___0: /* CIL Label */ 
  {
#line 848
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You hug %s.",
           (pl->ob)->name);
#line 849
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s hugs you.",
           op->name);
#line 850
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s hugs %s.",
           op->name, (pl->ob)->name);
  }
#line 851
  goto switch_break___1;
  case_16___1: /* CIL Label */ 
  {
#line 854
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You cry on %s\'s shoulder.",
           (pl->ob)->name);
#line 855
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s cries on your shoulder.",
           op->name);
#line 856
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s cries on %s\'s shoulder.",
           op->name, (pl->ob)->name);
  }
#line 857
  goto switch_break___1;
  case_17___0: /* CIL Label */ 
  {
#line 860
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You poke %s in the ribs.",
           (pl->ob)->name);
#line 861
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s pokes you in the ribs.",
           op->name);
#line 862
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s pokes %s in the ribs.",
           op->name, (pl->ob)->name);
  }
#line 863
  goto switch_break___1;
  case_18___0: /* CIL Label */ 
  {
#line 866
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You look accusingly at %s.",
           (pl->ob)->name);
#line 867
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s looks accusingly at you.",
           op->name);
#line 868
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s looks accusingly at %s.",
           op->name, (pl->ob)->name);
  }
#line 869
  goto switch_break___1;
  case_19___0: /* CIL Label */ 
  {
#line 872
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You grin at %s.",
           (pl->ob)->name);
#line 873
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s grins evilly at you.",
           op->name);
#line 874
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s grins evilly at %s.",
           op->name, (pl->ob)->name);
  }
#line 875
  goto switch_break___1;
  case_20___1: /* CIL Label */ 
  {
#line 878
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You bow before %s.",
           (pl->ob)->name);
#line 879
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s bows before you.",
           op->name);
#line 880
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s bows before %s.",
           op->name, (pl->ob)->name);
  }
#line 881
  goto switch_break___1;
  case_27___1: /* CIL Label */ 
  {
#line 884
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You frown darkly at %s.",
           (pl->ob)->name);
#line 885
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s frowns darkly at you.",
           op->name);
#line 886
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s frowns darkly at %s.",
           op->name, (pl->ob)->name);
  }
#line 887
  goto switch_break___1;
  case_29___1: /* CIL Label */ 
  {
#line 890
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You glare icily at %s.",
           (pl->ob)->name);
#line 891
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s glares icily at you, you feel cold to your bones.",
           op->name);
#line 892
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s glares at %s.",
           op->name, (pl->ob)->name);
  }
#line 893
  goto switch_break___1;
  case_32___1: /* CIL Label */ 
  {
#line 896
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You lick %s.",
           (pl->ob)->name);
#line 897
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s licks you.",
           op->name);
#line 898
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s licks %s.",
           op->name, (pl->ob)->name);
  }
#line 899
  goto switch_break___1;
  case_35___0: /* CIL Label */ 
  {
#line 902
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You shrug at %s.",
           (pl->ob)->name);
#line 903
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s shrugs at you.",
           op->name);
#line 904
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s shrugs at %s.",
           op->name, (pl->ob)->name);
  }
#line 905
  goto switch_break___1;
  case_36___0: /* CIL Label */ 
  {
#line 908
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You slap %s.",
           (pl->ob)->name);
#line 909
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You are slapped by %s.",
           op->name);
#line 910
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s slaps %s.",
           op->name, (pl->ob)->name);
  }
#line 911
  goto switch_break___1;
  case_39___1: /* CIL Label */ 
  {
#line 914
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You sneeze at %s and a film of snot shoots onto him.",
           (pl->ob)->name);
#line 915
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s sneezes on you, you feel the snot cover you. EEEEEEW.",
           op->name);
#line 916
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s sneezes on %s and a film of snot covers him.",
           op->name, (pl->ob)->name);
  }
#line 917
  goto switch_break___1;
  case_41___1: /* CIL Label */ 
  {
#line 920
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You sniff %s.",
           (pl->ob)->name);
#line 921
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s sniffs you.",
           op->name);
#line 922
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s sniffs %s",
           op->name, (pl->ob)->name);
  }
#line 923
  goto switch_break___1;
  case_43___1: /* CIL Label */ 
  {
#line 926
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You spit on %s.",
           (pl->ob)->name);
#line 927
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s spits in your face!",
           op->name);
#line 928
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s spits in %s\'s face.",
           op->name, (pl->ob)->name);
  }
#line 929
  goto switch_break___1;
  case_45___0: /* CIL Label */ 
  {
#line 932
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You thank %s heartily.",
           (pl->ob)->name);
#line 933
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s thanks you heartily.",
           op->name);
#line 934
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s thanks %s heartily.",
           op->name, (pl->ob)->name);
  }
#line 935
  goto switch_break___1;
  case_47___1: /* CIL Label */ 
  {
#line 938
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You wave goodbye to %s.",
           (pl->ob)->name);
#line 939
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s waves goodbye to you. Have a good journey.",
           op->name);
#line 940
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s waves goodbye to %s.",
           op->name, (pl->ob)->name);
  }
#line 941
  goto switch_break___1;
  case_48___1: /* CIL Label */ 
  {
#line 944
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You whistle at %s.",
           (pl->ob)->name);
#line 945
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s whistles at you.",
           op->name);
#line 946
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s whistles at %s.",
           op->name, (pl->ob)->name);
  }
#line 947
  goto switch_break___1;
  case_49___1: /* CIL Label */ 
  {
#line 950
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You wink suggestively at %s.",
           (pl->ob)->name);
#line 951
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s winks suggestively at you.",
           op->name);
#line 952
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s winks at %s.",
           op->name, (pl->ob)->name);
  }
#line 953
  goto switch_break___1;
  case_51: /* CIL Label */ 
  {
#line 956
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You beg %s for mercy.",
           (pl->ob)->name);
#line 957
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s begs you for mercy! Show no quarter!",
           op->name);
#line 958
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s begs %s for mercy!",
           op->name, (pl->ob)->name);
  }
#line 959
  goto switch_break___1;
  case_52___1: /* CIL Label */ 
  {
#line 962
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You slash your wrist and bleed all over %s",
           (pl->ob)->name);
#line 963
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s slashes his wrist and bleeds all over you.",
           op->name);
#line 964
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s slashes his wrist and bleeds all over %s.",
           op->name, (pl->ob)->name);
  }
#line 965
  goto switch_break___1;
  case_53___0: /* CIL Label */ 
  {
#line 968
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You cringe away from %s.",
           (pl->ob)->name);
#line 969
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s cringes away from you.",
           op->name);
#line 970
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"%s cringes away from %s in mortal terror.",
           op->name, (pl->ob)->name);
  }
#line 971
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
  {
#line 974
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You are still nuts.");
#line 975
  snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"You get the distinct feeling that %s is nuts.",
           op->name);
#line 976
  snprintf((char */* __restrict  */)(buf3), sizeof(buf3), (char const   */* __restrict  */)"%s is eyeing %s quizzically.",
           (pl->ob)->name, op->name);
  }
#line 977
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 980
  draw_ext_info(257, 0, (object const   *)op, (uint8 )15, (uint8 )5, (char const   *)(buf));
#line 982
  draw_ext_info(257, 0, (object const   *)pl->ob, (uint8 )15, (uint8 )5, (char const   *)(buf2));
#line 984
  ext_info_map_except2(1, (mapstruct const   *)op->map, (object const   *)op, (object const   *)pl->ob,
                       15, 5, (char const   *)(buf3));
  }
#line 986
  return;
}
}
#line 999 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_nod(object *op , char const   *params ) 
{ 


  {
  {
#line 1000
  basic_emote(op, params, 1);
  }
#line 1001
  return;
}
}
#line 1010 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_dance(object *op , char const   *params ) 
{ 


  {
  {
#line 1011
  basic_emote(op, params, 2);
  }
#line 1012
  return;
}
}
#line 1021 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_kiss(object *op , char const   *params ) 
{ 


  {
  {
#line 1022
  basic_emote(op, params, 3);
  }
#line 1023
  return;
}
}
#line 1032 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_bounce(object *op , char const   *params ) 
{ 


  {
  {
#line 1033
  basic_emote(op, params, 4);
  }
#line 1034
  return;
}
}
#line 1043 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_smile(object *op , char const   *params ) 
{ 


  {
  {
#line 1044
  basic_emote(op, params, 5);
  }
#line 1045
  return;
}
}
#line 1054 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_cackle(object *op , char const   *params ) 
{ 


  {
  {
#line 1055
  basic_emote(op, params, 6);
  }
#line 1056
  return;
}
}
#line 1065 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_laugh(object *op , char const   *params ) 
{ 


  {
  {
#line 1066
  basic_emote(op, params, 7);
  }
#line 1067
  return;
}
}
#line 1076 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_giggle(object *op , char const   *params ) 
{ 


  {
  {
#line 1077
  basic_emote(op, params, 8);
  }
#line 1078
  return;
}
}
#line 1087 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_shake(object *op , char const   *params ) 
{ 


  {
  {
#line 1088
  basic_emote(op, params, 9);
  }
#line 1089
  return;
}
}
#line 1098 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_puke(object *op , char const   *params ) 
{ 


  {
  {
#line 1099
  basic_emote(op, params, 10);
  }
#line 1100
  return;
}
}
#line 1109 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_growl(object *op , char const   *params ) 
{ 


  {
  {
#line 1110
  basic_emote(op, params, 11);
  }
#line 1111
  return;
}
}
#line 1120 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_scream(object *op , char const   *params ) 
{ 


  {
  {
#line 1121
  basic_emote(op, params, 12);
  }
#line 1122
  return;
}
}
#line 1131 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_sigh(object *op , char const   *params ) 
{ 


  {
  {
#line 1132
  basic_emote(op, params, 13);
  }
#line 1133
  return;
}
}
#line 1142 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_sulk(object *op , char const   *params ) 
{ 


  {
  {
#line 1143
  basic_emote(op, params, 14);
  }
#line 1144
  return;
}
}
#line 1153 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_hug(object *op , char const   *params ) 
{ 


  {
  {
#line 1154
  basic_emote(op, params, 15);
  }
#line 1155
  return;
}
}
#line 1164 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_cry(object *op , char const   *params ) 
{ 


  {
  {
#line 1165
  basic_emote(op, params, 16);
  }
#line 1166
  return;
}
}
#line 1175 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_poke(object *op , char const   *params ) 
{ 


  {
  {
#line 1176
  basic_emote(op, params, 17);
  }
#line 1177
  return;
}
}
#line 1186 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_accuse(object *op , char const   *params ) 
{ 


  {
  {
#line 1187
  basic_emote(op, params, 18);
  }
#line 1188
  return;
}
}
#line 1197 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_grin(object *op , char const   *params ) 
{ 


  {
  {
#line 1198
  basic_emote(op, params, 19);
  }
#line 1199
  return;
}
}
#line 1208 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_bow(object *op , char const   *params ) 
{ 


  {
  {
#line 1209
  basic_emote(op, params, 20);
  }
#line 1210
  return;
}
}
#line 1219 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_clap(object *op , char const   *params ) 
{ 


  {
  {
#line 1220
  basic_emote(op, params, 21);
  }
#line 1221
  return;
}
}
#line 1230 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_blush(object *op , char const   *params ) 
{ 


  {
  {
#line 1231
  basic_emote(op, params, 22);
  }
#line 1232
  return;
}
}
#line 1241 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_burp(object *op , char const   *params ) 
{ 


  {
  {
#line 1242
  basic_emote(op, params, 23);
  }
#line 1243
  return;
}
}
#line 1252 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_chuckle(object *op , char const   *params ) 
{ 


  {
  {
#line 1253
  basic_emote(op, params, 24);
  }
#line 1254
  return;
}
}
#line 1263 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_cough(object *op , char const   *params ) 
{ 


  {
  {
#line 1264
  basic_emote(op, params, 25);
  }
#line 1265
  return;
}
}
#line 1274 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_flip(object *op , char const   *params ) 
{ 


  {
  {
#line 1275
  basic_emote(op, params, 26);
  }
#line 1276
  return;
}
}
#line 1285 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_frown(object *op , char const   *params ) 
{ 


  {
  {
#line 1286
  basic_emote(op, params, 27);
  }
#line 1287
  return;
}
}
#line 1296 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_gasp(object *op , char const   *params ) 
{ 


  {
  {
#line 1297
  basic_emote(op, params, 28);
  }
#line 1298
  return;
}
}
#line 1307 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_glare(object *op , char const   *params ) 
{ 


  {
  {
#line 1308
  basic_emote(op, params, 29);
  }
#line 1309
  return;
}
}
#line 1318 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_groan(object *op , char const   *params ) 
{ 


  {
  {
#line 1319
  basic_emote(op, params, 30);
  }
#line 1320
  return;
}
}
#line 1329 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_hiccup(object *op , char const   *params ) 
{ 


  {
  {
#line 1330
  basic_emote(op, params, 31);
  }
#line 1331
  return;
}
}
#line 1340 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_lick(object *op , char const   *params ) 
{ 


  {
  {
#line 1341
  basic_emote(op, params, 32);
  }
#line 1342
  return;
}
}
#line 1351 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_pout(object *op , char const   *params ) 
{ 


  {
  {
#line 1352
  basic_emote(op, params, 33);
  }
#line 1353
  return;
}
}
#line 1362 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_shiver(object *op , char const   *params ) 
{ 


  {
  {
#line 1363
  basic_emote(op, params, 34);
  }
#line 1364
  return;
}
}
#line 1373 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_shrug(object *op , char const   *params ) 
{ 


  {
  {
#line 1374
  basic_emote(op, params, 35);
  }
#line 1375
  return;
}
}
#line 1384 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_slap(object *op , char const   *params ) 
{ 


  {
  {
#line 1385
  basic_emote(op, params, 36);
  }
#line 1386
  return;
}
}
#line 1395 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_smirk(object *op , char const   *params ) 
{ 


  {
  {
#line 1396
  basic_emote(op, params, 37);
  }
#line 1397
  return;
}
}
#line 1406 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_snap(object *op , char const   *params ) 
{ 


  {
  {
#line 1407
  basic_emote(op, params, 38);
  }
#line 1408
  return;
}
}
#line 1417 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_sneeze(object *op , char const   *params ) 
{ 


  {
  {
#line 1418
  basic_emote(op, params, 39);
  }
#line 1419
  return;
}
}
#line 1428 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_snicker(object *op , char const   *params ) 
{ 


  {
  {
#line 1429
  basic_emote(op, params, 40);
  }
#line 1430
  return;
}
}
#line 1439 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_sniff(object *op , char const   *params ) 
{ 


  {
  {
#line 1440
  basic_emote(op, params, 41);
  }
#line 1441
  return;
}
}
#line 1450 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_snore(object *op , char const   *params ) 
{ 


  {
  {
#line 1451
  basic_emote(op, params, 42);
  }
#line 1452
  return;
}
}
#line 1461 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_spit(object *op , char const   *params ) 
{ 


  {
  {
#line 1462
  basic_emote(op, params, 43);
  }
#line 1463
  return;
}
}
#line 1472 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_strut(object *op , char const   *params ) 
{ 


  {
  {
#line 1473
  basic_emote(op, params, 44);
  }
#line 1474
  return;
}
}
#line 1483 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_thank(object *op , char const   *params ) 
{ 


  {
  {
#line 1484
  basic_emote(op, params, 45);
  }
#line 1485
  return;
}
}
#line 1494 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_twiddle(object *op , char const   *params ) 
{ 


  {
  {
#line 1495
  basic_emote(op, params, 46);
  }
#line 1496
  return;
}
}
#line 1505 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_wave(object *op , char const   *params ) 
{ 


  {
  {
#line 1506
  basic_emote(op, params, 47);
  }
#line 1507
  return;
}
}
#line 1516 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_whistle(object *op , char const   *params ) 
{ 


  {
  {
#line 1517
  basic_emote(op, params, 48);
  }
#line 1518
  return;
}
}
#line 1527 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_wink(object *op , char const   *params ) 
{ 


  {
  {
#line 1528
  basic_emote(op, params, 49);
  }
#line 1529
  return;
}
}
#line 1538 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_yawn(object *op , char const   *params ) 
{ 


  {
  {
#line 1539
  basic_emote(op, params, 50);
  }
#line 1540
  return;
}
}
#line 1549 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_beg(object *op , char const   *params ) 
{ 


  {
  {
#line 1550
  basic_emote(op, params, 51);
  }
#line 1551
  return;
}
}
#line 1560 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_bleed(object *op , char const   *params ) 
{ 


  {
  {
#line 1561
  basic_emote(op, params, 52);
  }
#line 1562
  return;
}
}
#line 1571 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_cringe(object *op , char const   *params ) 
{ 


  {
  {
#line 1572
  basic_emote(op, params, 53);
  }
#line 1573
  return;
}
}
#line 1582 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_chat.c"
void command_think(object *op , char const   *params ) 
{ 


  {
  {
#line 1583
  basic_emote(op, params, 54);
  }
#line 1584
  return;
}
}
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 52 "../include/libproto.h"
void add_button_link(object *button , mapstruct *map , int connected ) ;
#line 53
void remove_button_link(object *op ) ;
#line 58 "../include/sproto.h"
void apply_builder_remove(object *pl , int dir ) ;
#line 59
void apply_map_builder(object *pl , int dir ) ;
#line 216
object *find_marked_object(object *op ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/build_map.c"
static int can_build_over(struct mapdef *map , object *new_item , short x , short y ) 
{ 
  object *tmp ;
  object *next58 ;
  tag_t next_tag58 ;
  tag_t tmp___0 ;
  object *ob ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    tmp = (map->spaces + ((int )x + (int )map->width * (int )y))->bottom;
    {
#line 58
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 58
      next58 = tmp;
#line 58
      if ((unsigned long )next58 == (unsigned long )((void *)0)) {
#line 58
        tmp___0 = (tag_t )0;
      } else {
#line 58
        tmp___0 = next58->count;
      }
#line 58
      next_tag58 = tmp___0;
      {
#line 58
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 58
        tmp = next58;
#line 58
        if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 58
          goto while_break___1;
        }
#line 58
        if (next58->count != next_tag58) {
#line 58
          goto while_break___1;
        } else
#line 58
        if (next58->flags[0] & (1U << 3)) {
#line 58
          goto while_break___1;
        }
#line 58
        next58 = next58->above;
#line 58
        if ((unsigned long )next58 == (unsigned long )((void *)0)) {
#line 58
          next_tag58 = (tag_t )0;
        } else {
#line 58
          next_tag58 = next58->count;
        }
#line 61
        if ((unsigned long )tmp->head != (unsigned long )((void *)0)) {
#line 61
          ob = tmp->head;
        } else {
#line 61
          ob = tmp;
        }
        {
#line 62
        tmp___1 = strcmp((ob->arch)->name, "rune_mark");
        }
#line 62
        if (tmp___1 == 0) {
#line 64
          goto while_continue___1;
        }
#line 66
        if (ob->flags[3] & (1U << 14)) {
#line 70
          goto while_continue___1;
        }
        {
#line 74
        if ((int )new_item->type == 29) {
#line 74
          goto case_29;
        }
#line 74
        if ((int )new_item->type == 98) {
#line 74
          goto case_29;
        }
#line 83
        if ((int )new_item->type == 93) {
#line 83
          goto case_93;
        }
#line 83
        if ((int )new_item->type == 17) {
#line 83
          goto case_93;
        }
#line 83
        if ((int )new_item->type == 51) {
#line 83
          goto case_93;
        }
#line 83
        if ((int )new_item->type == 92) {
#line 83
          goto case_93;
        }
#line 89
        goto switch_default;
        case_29: /* CIL Label */ 
        case_98: /* CIL Label */ 
#line 76
        if ((int )ob->type != 8) {
#line 77
          return (0);
        }
#line 78
        goto switch_break;
        case_93: /* CIL Label */ 
        case_17: /* CIL Label */ 
        case_51: /* CIL Label */ 
        case_92: /* CIL Label */ 
#line 85
        if ((int )ob->type != 91) {
#line 85
          if ((int )ob->type != 23) {
#line 86
            return (0);
          }
        }
#line 87
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 90
        return (0);
        switch_break: /* CIL Label */ ;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 58
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 58
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  if (new_item->more) {
    {
#line 96
    tmp___2 = can_build_over(map, new_item->more, (short )(((int )x + (int )((new_item->more)->arch)->clone.x) - (int )(new_item->arch)->clone.x),
                             (short )(((int )y + (int )((new_item->more)->arch)->clone.y) - (int )(new_item->arch)->clone.y));
    }
#line 96
    return (tmp___2);
  }
#line 98
  return (1);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/build_map.c"
static object *get_connection_rune(object *pl , short x , short y ) 
{ 
  object *rune ;
  object *next113 ;
  tag_t next_tag113 ;
  tag_t tmp ;
  int tmp___0 ;

  {
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    rune = ((pl->map)->spaces + ((int )x + (int )(pl->map)->width * (int )y))->bottom;
    {
#line 113
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 113
      next113 = rune;
#line 113
      if ((unsigned long )next113 == (unsigned long )((void *)0)) {
#line 113
        tmp = (tag_t )0;
      } else {
#line 113
        tmp = next113->count;
      }
#line 113
      next_tag113 = tmp;
      {
#line 113
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 113
        rune = next113;
#line 113
        if (! ((unsigned long )rune != (unsigned long )((void *)0))) {
#line 113
          goto while_break___1;
        }
#line 113
        if (next113->count != next_tag113) {
#line 113
          goto while_break___1;
        } else
#line 113
        if (next113->flags[0] & (1U << 3)) {
#line 113
          goto while_break___1;
        }
#line 113
        next113 = next113->above;
#line 113
        if ((unsigned long )next113 == (unsigned long )((void *)0)) {
#line 113
          next_tag113 = (tag_t )0;
        } else {
#line 113
          next_tag113 = next113->count;
        }
#line 114
        if ((int )rune->type == 98) {
          {
#line 114
          tmp___0 = strcmp((rune->arch)->name, "rune_mark");
          }
#line 114
          if (tmp___0 == 0) {
#line 115
            return (rune);
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 113
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 113
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  return ((object *)((void *)0));
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/build_map.c"
static object *get_msg_book(object *pl , short x , short y ) 
{ 
  object *book ;
  object *next132 ;
  tag_t next_tag132 ;
  tag_t tmp ;

  {
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    book = ((pl->map)->spaces + ((int )x + (int )(pl->map)->width * (int )y))->bottom;
    {
#line 132
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 132
      next132 = book;
#line 132
      if ((unsigned long )next132 == (unsigned long )((void *)0)) {
#line 132
        tmp = (tag_t )0;
      } else {
#line 132
        tmp = next132->count;
      }
#line 132
      next_tag132 = tmp;
      {
#line 132
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 132
        book = next132;
#line 132
        if (! ((unsigned long )book != (unsigned long )((void *)0))) {
#line 132
          goto while_break___1;
        }
#line 132
        if (next132->count != next_tag132) {
#line 132
          goto while_break___1;
        } else
#line 132
        if (next132->flags[0] & (1U << 3)) {
#line 132
          goto while_break___1;
        }
#line 132
        next132 = next132->above;
#line 132
        if ((unsigned long )next132 == (unsigned long )((void *)0)) {
#line 132
          next_tag132 = (tag_t )0;
        } else {
#line 132
          next_tag132 = next132->count;
        }
#line 133
        if ((int )book->type == 8) {
#line 134
          return (book);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 132
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 132
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  return ((object *)((void *)0));
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/build_map.c"
static object *get_wall(struct mapdef *map , int x , int y ) 
{ 
  object *wall ;
  object *next152 ;
  tag_t next_tag152 ;
  tag_t tmp ;

  {
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    wall = (map->spaces + (x + (int )map->width * y))->bottom;
    {
#line 152
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 152
      next152 = wall;
#line 152
      if ((unsigned long )next152 == (unsigned long )((void *)0)) {
#line 152
        tmp = (tag_t )0;
      } else {
#line 152
        tmp = next152->count;
      }
#line 152
      next_tag152 = tmp;
      {
#line 152
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 152
        wall = next152;
#line 152
        if (! ((unsigned long )wall != (unsigned long )((void *)0))) {
#line 152
          goto while_break___1;
        }
#line 152
        if (next152->count != next_tag152) {
#line 152
          goto while_break___1;
        } else
#line 152
        if (next152->flags[0] & (1U << 3)) {
#line 152
          goto while_break___1;
        }
#line 152
        next152 = next152->above;
#line 152
        if ((unsigned long )next152 == (unsigned long )((void *)0)) {
#line 152
          next_tag152 = (tag_t )0;
        } else {
#line 152
          next_tag152 = next152->count;
        }
#line 153
        if ((int )wall->type == 77) {
#line 154
          return (wall);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 152
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 152
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return ((object *)((void *)0));
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/build_map.c"
static void remove_marking_runes(struct mapdef *map , short x , short y ) 
{ 
  object *rune ;
  object *next168 ;
  tag_t next_tag168 ;
  tag_t tmp ;
  int tmp___0 ;

  {
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    rune = (map->spaces + ((int )x + (int )map->width * (int )y))->bottom;
    {
#line 168
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 168
      next168 = rune;
#line 168
      if ((unsigned long )next168 == (unsigned long )((void *)0)) {
#line 168
        tmp = (tag_t )0;
      } else {
#line 168
        tmp = next168->count;
      }
#line 168
      next_tag168 = tmp;
      {
#line 168
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 168
        rune = next168;
#line 168
        if (! ((unsigned long )rune != (unsigned long )((void *)0))) {
#line 168
          goto while_break___1;
        }
#line 168
        if (next168->count != next_tag168) {
#line 168
          goto while_break___1;
        } else
#line 168
        if (next168->flags[0] & (1U << 3)) {
#line 168
          goto while_break___1;
        }
#line 168
        next168 = next168->above;
#line 168
        if ((unsigned long )next168 == (unsigned long )((void *)0)) {
#line 168
          next_tag168 = (tag_t )0;
        } else {
#line 168
          next_tag168 = next168->count;
        }
#line 169
        if ((int )rune->type == 98) {
          {
#line 169
          tmp___0 = strcmp((rune->arch)->name, "rune_mark");
          }
#line 169
          if (! tmp___0) {
            {
#line 170
            object_remove(rune);
#line 171
            object_free_drop_inventory(rune);
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 168
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 168
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/build_map.c"
static int adjust_sign_msg(object *pl , short x , short y , object *tmp ) 
{ 
  object *book ;
  char buf[256] ;
  char buf2[256] ;

  {
  {
#line 198
  book = get_msg_book(pl, x, y);
  }
#line 199
  if (! book) {
    {
#line 200
    draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "You need to put a book or scroll with the message.");
    }
#line 202
    return (-1);
  }
  {
#line 205
  object_set_msg(tmp, book->msg);
  }
#line 207
  if (tmp->invisible) {
#line 208
    if ((unsigned long )book->custom_name != (unsigned long )((void *)0)) {
      {
#line 209
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"talking %s",
               book->custom_name);
      }
    } else {
      {
#line 211
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"talking %s",
               book->name);
      }
    }
#line 213
    if (tmp->name) {
      {
#line 214
      free_string(tmp->name);
      }
    }
    {
#line 215
    tmp->name = add_string((char const   *)(buf));
    }
#line 217
    if ((unsigned long )book->name_pl != (unsigned long )((void *)0)) {
      {
#line 218
      snprintf((char */* __restrict  */)(buf2), sizeof(buf2), (char const   */* __restrict  */)"talking %s",
               book->name_pl);
      }
#line 219
      if (tmp->name_pl) {
        {
#line 220
        free_string(tmp->name_pl);
        }
      }
      {
#line 221
      tmp->name_pl = add_string((char const   *)(buf2));
      }
    }
#line 224
    tmp->face = book->face;
#line 225
    tmp->invisible = (sint16 )0;
  }
  {
#line 227
  object_remove(book);
#line 228
  object_free_drop_inventory(book);
  }
#line 229
  return (0);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/build_map.c"
static int find_unused_connected_value(struct mapdef *map ) 
{ 
  int connected ;
  int itest ;
  oblinkpt *obp ;
  int tmp ;
  int tmp___0 ;

  {
#line 243
  connected = 0;
#line 244
  itest = 0;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    tmp___0 = itest;
#line 247
    itest ++;
#line 247
    if (! (tmp___0 < 1000)) {
#line 247
      goto while_break;
    }
    {
#line 248
    tmp = rand();
#line 248
    connected = 1 + tmp % 20000;
#line 249
    obp = map->buttons;
    }
    {
#line 249
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 249
      if (obp) {
#line 249
        if (! (obp->value != (long )connected)) {
#line 249
          goto while_break___0;
        }
      } else {
#line 249
        goto while_break___0;
      }
#line 249
      obp = obp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 252
    if (! obp) {
#line 253
      return (connected);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  return (-1);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/build_map.c"
static int find_or_create_connection_for_map(object *pl , short x , short y , object *rune ) 
{ 
  object *force ;
  int connected ;
  object *tmp ;
  object *next295 ;
  tag_t next_tag295 ;
  tag_t tmp___0 ;
  int tmp___1 ;

  {
#line 284
  if (! rune) {
    {
#line 285
    rune = get_connection_rune(pl, x, y);
    }
  }
#line 287
  if (! rune) {
    {
#line 288
    draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "You need to put a marking rune with the group name.");
    }
#line 290
    return (-1);
  } else
#line 287
  if (! rune->msg) {
    {
#line 288
    draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "You need to put a marking rune with the group name.");
    }
#line 290
    return (-1);
  }
#line 294
  force = (object *)((void *)0);
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    tmp = pl->inv;
    {
#line 295
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 295
      next295 = tmp;
#line 295
      if ((unsigned long )next295 == (unsigned long )((void *)0)) {
#line 295
        tmp___0 = (tag_t )0;
      } else {
#line 295
        tmp___0 = next295->count;
      }
#line 295
      next_tag295 = tmp___0;
      {
#line 295
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 295
        tmp = next295;
#line 295
        if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 295
          goto while_break___1;
        }
#line 295
        if (next295->count != next_tag295) {
#line 295
          goto while_break___1;
        } else
#line 295
        if (next295->flags[0] & (1U << 3)) {
#line 295
          goto while_break___1;
        }
#line 295
        next295 = next295->below;
#line 295
        if ((unsigned long )next295 == (unsigned long )((void *)0)) {
#line 295
          next_tag295 = (tag_t )0;
        } else {
#line 295
          next_tag295 = next295->count;
        }
#line 296
        if ((int )tmp->type == 114) {
#line 296
          if ((unsigned long )tmp->slaying != (unsigned long )((void *)0)) {
            {
#line 296
            tmp___1 = strcmp(tmp->slaying, (char const   *)((pl->map)->path));
            }
#line 296
            if (tmp___1 == 0) {
#line 296
              if ((unsigned long )tmp->msg != (unsigned long )((void *)0)) {
#line 296
                if ((unsigned long )tmp->msg == (unsigned long )rune->msg) {
#line 299
                  force = tmp;
#line 300
                  goto while_break___1;
                }
              }
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 295
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 295
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  if (! force) {
    {
#line 307
    connected = find_unused_connected_value(pl->map);
    }
#line 308
    if (connected == -1) {
      {
#line 309
      draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "Could not create more groups.");
      }
#line 311
      return (-1);
    }
    {
#line 314
    force = create_archetype("force");
#line 315
    force->speed = (float )0;
#line 316
    object_update_speed(force);
#line 317
    force->slaying = add_string((char const   *)((pl->map)->path));
#line 318
    object_set_msg(force, rune->msg);
#line 319
    force->path_attuned = (uint32 )connected;
#line 320
    object_insert_in_ob(force, pl);
    }
#line 322
    return (connected);
  }
#line 326
  return ((int )force->path_attuned);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/build_map.c"
static void fix_walls(struct mapdef *map , int x , int y ) 
{ 
  int connect___0 ;
  object *wall ;
  char archetype___0[256] ;
  char *underscore ;
  uint32 old_flags[4] ;
  struct archt *new_arch ;
  int flag ;
  int len ;
  int has_window ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  object *tmp___3 ;
  object *tmp___4 ;
  object *tmp___5 ;
  object *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 356
  wall = get_wall(map, x, y);
  }
#line 357
  if (! wall) {
#line 359
    return;
  }
  {
#line 362
  strncpy((char */* __restrict  */)(archetype___0), (char const   */* __restrict  */)(wall->arch)->name,
          sizeof(archetype___0));
#line 363
  archetype___0[sizeof(archetype___0) - 1UL] = (char )'\000';
#line 364
  underscore = strchr((char const   *)(archetype___0), '_');
  }
#line 365
  if (! underscore) {
#line 367
    return;
  }
  {
#line 368
  has_window = 0;
#line 369
  tmp___1 = strcmp((char const   *)(underscore + 1), "win1");
  }
#line 369
  if (tmp___1) {
    {
#line 371
    tmp___0 = strcmp((char const   *)(underscore + 1), "win2");
    }
#line 371
    if (tmp___0) {
      {
#line 373
      tmp = __ctype_b_loc();
      }
#line 373
      if (! ((int const   )*(*tmp + (int )*(underscore + 1)) & 2048)) {
#line 374
        return;
      }
    } else {
#line 372
      has_window = 1;
    }
  } else {
#line 370
    has_window = 1;
  }
  {
#line 376
  underscore ++;
#line 377
  *underscore = (char )'\000';
#line 378
  tmp___2 = strlen((char const   *)(archetype___0));
#line 378
  len = (int )((sizeof(archetype___0) - tmp___2) - 2UL);
#line 380
  connect___0 = 0;
  }
#line 382
  if (x > 0) {
    {
#line 382
    tmp___3 = get_wall(map, x - 1, y);
    }
#line 382
    if (tmp___3) {
#line 383
      connect___0 |= 1;
    }
  }
#line 384
  if (x < (int )map->width - 1) {
    {
#line 384
    tmp___4 = get_wall(map, x + 1, y);
    }
#line 384
    if (tmp___4) {
#line 385
      connect___0 |= 2;
    }
  }
#line 386
  if (y > 0) {
    {
#line 386
    tmp___5 = get_wall(map, x, y - 1);
    }
#line 386
    if (tmp___5) {
#line 387
      connect___0 |= 4;
    }
  }
#line 388
  if (y < (int )map->height - 1) {
    {
#line 388
    tmp___6 = get_wall(map, x, y + 1);
    }
#line 388
    if (tmp___6) {
#line 389
      connect___0 |= 8;
    }
  }
  {
#line 392
  if (connect___0 == 0) {
#line 392
    goto case_0;
  }
#line 396
  if (connect___0 == 1) {
#line 396
    goto case_1;
  }
#line 400
  if (connect___0 == 2) {
#line 400
    goto case_2;
  }
#line 404
  if (connect___0 == 3) {
#line 404
    goto case_3;
  }
#line 412
  if (connect___0 == 4) {
#line 412
    goto case_4;
  }
#line 416
  if (connect___0 == 5) {
#line 416
    goto case_5;
  }
#line 420
  if (connect___0 == 6) {
#line 420
    goto case_6;
  }
#line 424
  if (connect___0 == 7) {
#line 424
    goto case_7;
  }
#line 428
  if (connect___0 == 8) {
#line 428
    goto case_8;
  }
#line 432
  if (connect___0 == 9) {
#line 432
    goto case_9;
  }
#line 436
  if (connect___0 == 10) {
#line 436
    goto case_10;
  }
#line 440
  if (connect___0 == 11) {
#line 440
    goto case_11;
  }
#line 444
  if (connect___0 == 12) {
#line 444
    goto case_12;
  }
#line 452
  if (connect___0 == 13) {
#line 452
    goto case_13;
  }
#line 456
  if (connect___0 == 14) {
#line 456
    goto case_14;
  }
#line 460
  if (connect___0 == 15) {
#line 460
    goto case_15;
  }
#line 391
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 393
  strncat((char */* __restrict  */)(archetype___0), (char const   */* __restrict  */)"0",
          (size_t )len);
  }
#line 394
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 397
  strncat((char */* __restrict  */)(archetype___0), (char const   */* __restrict  */)"1_3",
          (size_t )len);
  }
#line 398
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 401
  strncat((char */* __restrict  */)(archetype___0), (char const   */* __restrict  */)"1_4",
          (size_t )len);
  }
#line 402
  goto switch_break;
  case_3: /* CIL Label */ 
#line 405
  if (has_window) {
    {
#line 406
    strncat((char */* __restrict  */)(archetype___0), (char const   */* __restrict  */)"win2",
            (size_t )len);
    }
  } else {
    {
#line 408
    strncat((char */* __restrict  */)(archetype___0), (char const   */* __restrict  */)"2_1_2",
            (size_t )len);
    }
  }
#line 410
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 413
  strncat((char */* __restrict  */)(archetype___0), (char const   */* __restrict  */)"1_2",
          (size_t )len);
  }
#line 414
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 417
  strncat((char */* __restrict  */)(archetype___0), (char const   */* __restrict  */)"2_2_4",
          (size_t )len);
  }
#line 418
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 421
  strncat((char */* __restrict  */)(archetype___0), (char const   */* __restrict  */)"2_2_1",
          (size_t )len);
  }
#line 422
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 425
  strncat((char */* __restrict  */)(archetype___0), (char const   */* __restrict  */)"3_1",
          (size_t )len);
  }
#line 426
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 429
  strncat((char */* __restrict  */)(archetype___0), (char const   */* __restrict  */)"1_1",
          (size_t )len);
  }
#line 430
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 433
  strncat((char */* __restrict  */)(archetype___0), (char const   */* __restrict  */)"2_2_3",
          (size_t )len);
  }
#line 434
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 437
  strncat((char */* __restrict  */)(archetype___0), (char const   */* __restrict  */)"2_2_2",
          (size_t )len);
  }
#line 438
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 441
  strncat((char */* __restrict  */)(archetype___0), (char const   */* __restrict  */)"3_3",
          (size_t )len);
  }
#line 442
  goto switch_break;
  case_12: /* CIL Label */ 
#line 445
  if (has_window) {
    {
#line 446
    strncat((char */* __restrict  */)(archetype___0), (char const   */* __restrict  */)"win1",
            (size_t )len);
    }
  } else {
    {
#line 448
    strncat((char */* __restrict  */)(archetype___0), (char const   */* __restrict  */)"2_1_1",
            (size_t )len);
    }
  }
#line 450
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 453
  strncat((char */* __restrict  */)(archetype___0), (char const   */* __restrict  */)"3_4",
          (size_t )len);
  }
#line 454
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 457
  strncat((char */* __restrict  */)(archetype___0), (char const   */* __restrict  */)"3_2",
          (size_t )len);
  }
#line 458
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 461
  strncat((char */* __restrict  */)(archetype___0), (char const   */* __restrict  */)"4",
          (size_t )len);
  }
#line 462
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 468
  tmp___7 = strncmp((char const   *)(archetype___0), (wall->arch)->name, sizeof(archetype___0));
  }
#line 468
  if (! tmp___7) {
#line 469
    return;
  }
  {
#line 475
  new_arch = find_archetype((char const   *)(archetype___0));
  }
#line 476
  if (! new_arch) {
#line 477
    return;
  }
#line 482
  flag = 0;
  {
#line 482
  while (1) {
    while_continue: /* CIL Label */ ;
#line 482
    if (! (flag < 4)) {
#line 482
      goto while_break;
    }
#line 483
    old_flags[flag] = wall->flags[flag];
#line 482
    flag ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 484
  object_remove(wall);
#line 485
  object_free_drop_inventory(wall);
#line 487
  wall = arch_to_object(new_arch);
#line 488
  wall->type = (uint8 )77;
#line 489
  object_insert_in_map_at(wall, map, (object *)((void *)0), 2, x, y);
#line 490
  flag = 0;
  }
  {
#line 490
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 490
    if (! (flag < 4)) {
#line 490
      goto while_break___0;
    }
#line 491
    wall->flags[flag] = old_flags[flag];
#line 490
    flag ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 492
  return;
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/build_map.c"
static int apply_builder_floor(object *pl , object *new_floor , short x , short y ) 
{ 
  object *above_floor ;
  object *floor ;
  struct archt *new_wall ;
  int i ;
  int xt ;
  int yt ;
  int wall_removed ;
  char message[256] ;
  object *tmp ;
  object *next532 ;
  tag_t next_tag532 ;
  tag_t tmp___0 ;
  int tmp___1 ;
  object *tmp___2 ;

  {
  {
#line 522
  snprintf((char */* __restrict  */)(message), sizeof(message), (char const   */* __restrict  */)"You change the floor to better suit your tastes.");
#line 528
  above_floor = (object *)((void *)0);
#line 529
  floor = (object *)((void *)0);
#line 530
  new_wall = (struct archt *)((void *)0);
#line 531
  wall_removed = 0;
  }
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    tmp = ((pl->map)->spaces + ((int )x + (int )(pl->map)->width * (int )y))->bottom;
    {
#line 532
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 532
      next532 = tmp;
#line 532
      if ((unsigned long )next532 == (unsigned long )((void *)0)) {
#line 532
        tmp___0 = (tag_t )0;
      } else {
#line 532
        tmp___0 = next532->count;
      }
#line 532
      next_tag532 = tmp___0;
      {
#line 532
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 532
        tmp = next532;
#line 532
        if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 532
          goto while_break___1;
        }
#line 532
        if (next532->count != next_tag532) {
#line 532
          goto while_break___1;
        } else
#line 532
        if (next532->flags[0] & (1U << 3)) {
#line 532
          goto while_break___1;
        }
#line 532
        next532 = next532->above;
#line 532
        if ((unsigned long )next532 == (unsigned long )((void *)0)) {
#line 532
          next_tag532 = (tag_t )0;
        } else {
#line 532
          next_tag532 = next532->count;
        }
#line 533
        if (77 == (int )tmp->type) {
          {
#line 535
          new_wall = tmp->arch;
#line 536
          object_remove(tmp);
#line 537
          object_free_drop_inventory(tmp);
#line 538
          snprintf((char */* __restrict  */)(message), sizeof(message), (char const   */* __restrict  */)"You destroy the wall and redo the floor.");
#line 539
          wall_removed = 1;
          }
#line 540
          if ((unsigned long )floor != (unsigned long )((void *)0)) {
            {
#line 541
            object_remove(floor);
#line 542
            object_free_drop_inventory(floor);
#line 543
            floor = (object *)((void *)0);
            }
          }
        } else
#line 545
        if (71 == (int )tmp->type) {
#line 546
          floor = tmp;
        } else
#line 545
        if (tmp->flags[1] & (1U << 31)) {
#line 546
          floor = tmp;
        } else
#line 548
        if ((unsigned long )floor != (unsigned long )((void *)0)) {
#line 549
          above_floor = tmp;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 532
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 532
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 553
  if (wall_removed == 0) {
#line 553
    if ((unsigned long )floor != (unsigned long )((void *)0)) {
#line 554
      if ((unsigned long )floor->arch == (unsigned long )new_floor->arch) {
        {
#line 555
        draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "You feel too lazy to redo the exact same floor.");
#line 556
        object_free_drop_inventory(new_floor);
        }
#line 557
        return (0);
      }
    }
  }
#line 561
  new_floor->flags[1] |= 1U << 17;
#line 562
  new_floor->flags[1] |= 1U << 31;
#line 563
  new_floor->type = (uint8 )71;
#line 564
  if (above_floor) {
#line 564
    tmp___1 = 16;
  } else {
#line 564
    tmp___1 = 8;
  }
  {
#line 564
  object_insert_in_map_at(new_floor, pl->map, above_floor, tmp___1, (int )x, (int )y);
  }
#line 567
  if (floor) {
    {
#line 568
    object_remove(floor);
#line 569
    object_free_drop_inventory(floor);
#line 570
    floor = (object *)((void *)0);
    }
  }
#line 577
  i = 1;
  {
#line 577
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 577
    if (! (i <= 8)) {
#line 577
      goto while_break___2;
    }
#line 580
    xt = (int )x + (int )freearr_x[i];
#line 581
    yt = (int )y + (int )freearr_y[i];
#line 582
    tmp___2 = ((pl->map)->spaces + (xt + (int )(pl->map)->width * yt))->bottom;
#line 583
    if (! tmp___2) {
      {
#line 586
      tmp___2 = arch_to_object(new_floor->arch);
#line 588
      tmp___2->flags[1] |= 1U << 17;
#line 589
      tmp___2->flags[3] |= 1U << 14;
#line 590
      tmp___2->type = (uint8 )71;
#line 591
      object_insert_in_map_at(tmp___2, pl->map, (object *)((void *)0), 0, xt, yt);
      }
#line 593
      if (new_wall) {
        {
#line 594
        tmp___2 = arch_to_object(new_wall);
#line 595
        tmp___2->flags[3] |= 1U << 14;
#line 596
        tmp___2->type = (uint8 )77;
#line 597
        object_insert_in_map_at(tmp___2, pl->map, (object *)((void *)0), 0, xt, yt);
        }
      }
    }
#line 577
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 607
  xt = (int )x - 2;
  {
#line 607
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 607
    if (! (xt <= (int )x + 2)) {
#line 607
      goto while_break___3;
    }
#line 608
    yt = (int )y - 2;
    {
#line 608
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 608
      if (! (yt <= (int )y + 2)) {
#line 608
        goto while_break___4;
      }
#line 609
      if (! (xt < 0)) {
#line 609
        if (! (yt < 0)) {
#line 609
          if (! (xt >= (int )(pl->map)->width)) {
#line 609
            if (! (yt >= (int )(pl->map)->height)) {
              {
#line 610
              fix_walls(pl->map, xt, yt);
              }
            }
          }
        }
      }
#line 608
      yt ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 607
    xt ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 614
  draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, (char const   *)(message));
  }
#line 615
  return (1);
}
}
#line 635 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/build_map.c"
static int apply_builder_wall(object *pl , object *new_wall , short x , short y ) 
{ 
  object *current_wall ;
  char message[256] ;
  char current_basename[256] ;
  char new_basename[256] ;
  char *underscore ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int xt ;
  int yt ;

  {
  {
#line 639
  remove_marking_runes(pl->map, x, y);
#line 641
  current_wall = get_wall(pl->map, (int )x, (int )y);
  }
#line 643
  if (current_wall) {
    {
#line 649
    strncpy((char */* __restrict  */)(current_basename), (char const   */* __restrict  */)(current_wall->arch)->name,
            sizeof(current_basename));
#line 650
    current_basename[sizeof(current_basename) - 1UL] = (char )'\000';
#line 651
    underscore = strchr((char const   *)(current_basename), '_');
    }
#line 652
    if (underscore) {
      {
#line 652
      tmp = __ctype_b_loc();
      }
#line 652
      if ((int const   )*(*tmp + (int )*(underscore + 1)) & 2048) {
#line 653
        underscore ++;
#line 654
        *underscore = (char )'\000';
      }
    }
    {
#line 656
    strncpy((char */* __restrict  */)(new_basename), (char const   */* __restrict  */)(new_wall->arch)->name,
            sizeof(new_basename));
#line 657
    new_basename[sizeof(new_basename) - 1UL] = (char )'\000';
#line 658
    underscore = strchr((char const   *)(new_basename), '_');
    }
#line 659
    if (underscore) {
      {
#line 659
      tmp___0 = __ctype_b_loc();
      }
#line 659
      if ((int const   )*(*tmp___0 + (int )*(underscore + 1)) & 2048) {
#line 660
        underscore ++;
#line 661
        *underscore = (char )'\000';
      }
    }
    {
#line 663
    tmp___1 = strncmp((char const   *)(current_basename), (char const   *)(new_basename),
                      sizeof(new_basename));
    }
#line 663
    if (! tmp___1) {
      {
#line 664
      draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "You feel too lazy to redo the exact same wall.");
#line 665
      object_free_drop_inventory(new_wall);
      }
#line 666
      return (0);
    }
  }
  {
#line 670
  snprintf((char */* __restrict  */)(message), sizeof(message), (char const   */* __restrict  */)"You build a wall.");
#line 671
  new_wall->type = (uint8 )77;
  }
#line 673
  if (current_wall) {
    {
#line 675
    object_remove(current_wall);
#line 676
    object_free_drop_inventory(current_wall);
#line 677
    object_insert_in_map_at(new_wall, pl->map, (object *)((void *)0), 2, (int )x,
                            (int )y);
#line 678
    fix_walls(pl->map, (int )x, (int )y);
#line 679
    snprintf((char */* __restrict  */)(message), sizeof(message), (char const   */* __restrict  */)"You redecorate the wall to better suit your tastes.");
    }
  } else {
    {
#line 684
    object_insert_in_map_at(new_wall, pl->map, (object *)((void *)0), 2, (int )x,
                            (int )y);
#line 685
    xt = (int )x - 1;
    }
    {
#line 685
    while (1) {
      while_continue: /* CIL Label */ ;
#line 685
      if (! (xt <= (int )x + 1)) {
#line 685
        goto while_break;
      }
#line 686
      yt = (int )y - 1;
      {
#line 686
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 686
        if (! (yt <= (int )y + 1)) {
#line 686
          goto while_break___0;
        }
#line 687
        if (xt < 0) {
#line 688
          goto __Cont;
        } else
#line 687
        if (yt < 0) {
#line 688
          goto __Cont;
        } else
#line 687
        if (xt >= (int )(pl->map)->width) {
#line 688
          goto __Cont;
        } else
#line 687
        if (yt >= (int )(pl->map)->height) {
#line 688
          goto __Cont;
        }
        {
#line 690
        fix_walls(pl->map, xt, yt);
        }
        __Cont: /* CIL Label */ 
#line 686
        yt ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 685
      xt ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 695
  draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, (char const   *)(message));
  }
#line 696
  return (1);
}
}
#line 715 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/build_map.c"
static int apply_builder_window(object *pl , object *new_wall_win , short x , short y ) 
{ 
  object *current_wall ;
  char archetype___0[256] ;
  struct archt *new_arch ;
  object *window ;
  uint32 old_flags[4] ;
  int flag ;
  char *underscore ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 724
  object_free_drop_inventory(new_wall_win);
#line 726
  current_wall = get_wall(pl->map, (int )x, (int )y);
  }
#line 728
  if (current_wall) {
    {
#line 731
    strncpy((char */* __restrict  */)(archetype___0), (char const   */* __restrict  */)(current_wall->arch)->name,
            sizeof(archetype___0));
#line 732
    archetype___0[sizeof(archetype___0) - 1UL] = (char )'\000';
#line 733
    underscore = strchr((char const   *)(archetype___0), '_');
    }
#line 734
    if (underscore) {
      {
#line 735
      underscore ++;
#line 737
      tmp = strcmp((char const   *)underscore, "win1");
      }
#line 737
      if (tmp) {
        {
#line 737
        tmp___0 = strcmp((char const   *)underscore, "win2");
        }
#line 737
        if (! tmp___0) {
          {
#line 739
          draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "You feel too lazy to redo the window.");
          }
#line 740
          return (0);
        }
      } else {
        {
#line 739
        draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "You feel too lazy to redo the window.");
        }
#line 740
        return (0);
      }
      {
#line 742
      tmp___2 = strcmp((char const   *)underscore, "2_1_1");
      }
#line 742
      if (tmp___2) {
        {
#line 744
        tmp___1 = strcmp((char const   *)underscore, "2_1_2");
        }
#line 744
        if (tmp___1) {
          {
#line 748
          draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "You cannot build a window in that wall.");
          }
#line 749
          return (0);
        } else {
          {
#line 745
          strcpy((char */* __restrict  */)underscore, (char const   */* __restrict  */)"win2");
          }
        }
      } else {
        {
#line 743
        strcpy((char */* __restrict  */)underscore, (char const   */* __restrict  */)"win1");
        }
      }
    }
  } else {
    {
#line 753
    draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "There is no wall there.");
    }
#line 755
    return (0);
  }
  {
#line 758
  new_arch = find_archetype((char const   *)(archetype___0));
  }
#line 759
  if (! new_arch) {
    {
#line 761
    draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "You cannot build a window in that wall.");
    }
#line 762
    return (0);
  }
#line 768
  flag = 0;
  {
#line 768
  while (1) {
    while_continue: /* CIL Label */ ;
#line 768
    if (! (flag < 4)) {
#line 768
      goto while_break;
    }
#line 769
    old_flags[flag] = current_wall->flags[flag];
#line 768
    flag ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 770
  object_remove(current_wall);
#line 771
  object_free_drop_inventory(current_wall);
#line 773
  window = arch_to_object(new_arch);
#line 774
  window->type = (uint8 )77;
#line 775
  object_insert_in_map_at(window, pl->map, (object *)((void *)0), 2, (int )x, (int )y);
#line 776
  flag = 0;
  }
  {
#line 776
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 776
    if (! (flag < 4)) {
#line 776
      goto while_break___0;
    }
#line 777
    window->flags[flag] = old_flags[flag];
#line 776
    flag ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 780
  draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "You build a window in the wall.");
  }
#line 781
  return (1);
}
}
#line 805 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/build_map.c"
static int apply_builder_item(object *pl , object *new_item , short x , short y ) 
{ 
  int insert_flag ;
  object *floor ;
  object *con_rune ;
  int connected ;
  char name[256] ;
  object *next820 ;
  tag_t next_tag820 ;
  tag_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 813
  floor = ((pl->map)->spaces + ((int )x + (int )(pl->map)->width * (int )y))->bottom;
#line 814
  if (! floor) {
    {
#line 815
    draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "Invalid square.");
#line 816
    object_free_drop_inventory(new_item);
    }
#line 817
    return (0);
  }
  {
#line 820
  while (1) {
    while_continue: /* CIL Label */ ;
#line 820
    next820 = floor;
#line 820
    if ((unsigned long )next820 == (unsigned long )((void *)0)) {
#line 820
      tmp = (tag_t )0;
    } else {
#line 820
      tmp = next820->count;
    }
#line 820
    next_tag820 = tmp;
    {
#line 820
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 820
      floor = next820;
#line 820
      if (! ((unsigned long )floor != (unsigned long )((void *)0))) {
#line 820
        goto while_break___0;
      }
#line 820
      if (next820->count != next_tag820) {
#line 820
        goto while_break___0;
      } else
#line 820
      if (next820->flags[0] & (1U << 3)) {
#line 820
        goto while_break___0;
      }
#line 820
      next820 = next820->above;
#line 820
      if ((unsigned long )next820 == (unsigned long )((void *)0)) {
#line 820
        next_tag820 = (tag_t )0;
      } else {
#line 820
        next_tag820 = next820->count;
      }
#line 821
      if ((int )floor->type == 71) {
#line 822
        goto while_break___0;
      } else
#line 821
      if (floor->flags[1] & (1U << 31)) {
#line 822
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 820
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 824
  if (! floor) {
    {
#line 825
    draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "This square has no floor, you can\'t build here.");
#line 827
    object_free_drop_inventory(new_item);
    }
#line 828
    return (0);
  }
#line 831
  new_item->flags[0] |= 1U << 8;
#line 837
  insert_flag = 2;
#line 839
  connected = 0;
#line 840
  con_rune = (object *)((void *)0);
  {
#line 850
  if ((int )new_item->type == 98) {
#line 850
    goto case_98;
  }
#line 850
  if ((int )new_item->type == 29) {
#line 850
    goto case_98;
  }
#line 850
  if ((int )new_item->type == 93) {
#line 850
    goto case_98;
  }
#line 850
  if ((int )new_item->type == 17) {
#line 850
    goto case_98;
  }
#line 850
  if ((int )new_item->type == 26) {
#line 850
    goto case_98;
  }
#line 850
  if ((int )new_item->type == 51) {
#line 850
    goto case_98;
  }
#line 850
  if ((int )new_item->type == 92) {
#line 850
    goto case_98;
  }
#line 850
  if ((int )new_item->type == 91) {
#line 850
    goto case_98;
  }
#line 850
  if ((int )new_item->type == 23) {
#line 850
    goto case_98;
  }
#line 841
  goto switch_break;
  case_98: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_23: /* CIL Label */ 
#line 852
  if ((int )new_item->type == 98) {
    {
#line 852
    tmp___0 = strcmp((new_item->arch)->name, "magic_mouth");
    }
#line 852
    if (tmp___0) {
#line 853
      goto switch_break;
    }
  }
  {
#line 854
  con_rune = get_connection_rune(pl, x, y);
#line 855
  connected = find_or_create_connection_for_map(pl, x, y, con_rune);
  }
#line 856
  if (connected == -1) {
    {
#line 858
    object_free_drop_inventory(new_item);
    }
#line 859
    return (0);
  }
  switch_break: /* CIL Label */ ;
  }
#line 864
  if ((int )new_item->type == 98) {
#line 864
    goto _L;
  } else
#line 864
  if ((int )new_item->type == 29) {
    _L: /* CIL Label */ 
    {
#line 865
    tmp___1 = adjust_sign_msg(pl, x, y, new_item);
    }
#line 865
    if (tmp___1 == -1) {
      {
#line 866
      object_free_drop_inventory(new_item);
      }
#line 867
      return (0);
    }
  }
#line 871
  if ((unsigned long )con_rune != (unsigned long )((void *)0)) {
    {
#line 873
    object_remove(con_rune);
#line 874
    object_free_drop_inventory(con_rune);
    }
  }
  {
#line 877
  object_insert_in_map_at(new_item, pl->map, floor, insert_flag, (int )x, (int )y);
  }
#line 878
  if (connected != 0) {
    {
#line 879
    add_button_link(new_item, pl->map, connected);
    }
  }
  {
#line 881
  query_name((object const   *)new_item, name, (size_t )256);
#line 882
  draw_ext_info_format(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "You build the %s",
                       name);
  }
#line 885
  return (1);
}
}
#line 898 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/build_map.c"
void apply_builder_remove(object *pl , int dir ) 
{ 
  object *item ;
  short x ;
  short y ;
  char name[256] ;

  {
#line 903
  x = (short )((int )pl->x + (int )freearr_x[dir]);
#line 904
  y = (short )((int )pl->y + (int )freearr_y[dir]);
#line 907
  item = ((pl->map)->spaces + ((int )x + (int )(pl->map)->width * (int )y))->bottom;
#line 908
  if (! item) {
    {
#line 910
    draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "Invalid square.");
#line 912
    LOG((LogLevel )0, "apply_builder_remove: (null) square at (%d, %d, %s)\n", (int )x,
        (int )y, (pl->map)->path);
    }
#line 913
    return;
  }
#line 916
  if ((int )item->type == 71) {
#line 917
    item = item->above;
  } else
#line 916
  if (item->flags[1] & (1U << 31)) {
#line 917
    item = item->above;
  }
#line 919
  if (! item) {
    {
#line 920
    draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "Nothing to remove.");
    }
#line 922
    return;
  }
  {
#line 927
  if ((int )item->type == 77) {
#line 927
    goto case_77;
  }
#line 940
  if ((int )item->type == 98) {
#line 940
    goto case_98;
  }
#line 940
  if ((int )item->type == 29) {
#line 940
    goto case_98;
  }
#line 940
  if ((int )item->type == 93) {
#line 940
    goto case_98;
  }
#line 940
  if ((int )item->type == 17) {
#line 940
    goto case_98;
  }
#line 940
  if ((int )item->type == 51) {
#line 940
    goto case_98;
  }
#line 940
  if ((int )item->type == 26) {
#line 940
    goto case_98;
  }
#line 940
  if ((int )item->type == 91) {
#line 940
    goto case_98;
  }
#line 940
  if ((int )item->type == 92) {
#line 940
    goto case_98;
  }
#line 940
  if ((int )item->type == 23) {
#line 940
    goto case_98;
  }
#line 946
  goto switch_default;
  case_77: /* CIL Label */ 
  {
#line 928
  draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "Can\'t remove a wall with that, build a floor.");
  }
#line 930
  return;
  case_98: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_23: /* CIL Label */ 
#line 942
  if (item->flags[2] & (1U << 9)) {
    {
#line 943
    remove_button_link(item);
    }
  }
  switch_default: /* CIL Label */ 
  {
#line 948
  query_name((object const   *)item, name, (size_t )256);
#line 949
  draw_ext_info_format(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "You remove the %s",
                       name);
#line 952
  object_remove(item);
#line 953
  object_free_drop_inventory(item);
  }
  switch_break: /* CIL Label */ ;
  }
#line 955
  return;
}
}
#line 968 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/build_map.c"
void apply_map_builder(object *pl , int dir ) 
{ 
  object *builder ;
  object *tmp ;
  short x ;
  short y ;
  object *next1011 ;
  tag_t next_tag1011 ;
  tag_t tmp___0 ;
  int tmp___1 ;
  object *material ;
  struct archt *new_arch ;
  object *new_item ;
  int built ;
  int tmp___2 ;

  {
#line 973
  if (! pl->type == 1) {
#line 974
    return;
  }
#line 976
  if (dir == 0) {
    {
#line 977
    draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "You can\'t build or destroy under yourself.");
    }
#line 979
    return;
  }
#line 982
  x = (short )((int )pl->x + (int )freearr_x[dir]);
#line 983
  y = (short )((int )pl->y + (int )freearr_y[dir]);
#line 985
  if (1 > (int )x) {
    {
#line 987
    draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "Can\'t build on map edge.");
    }
#line 989
    return;
  } else
#line 985
  if (1 > (int )y) {
    {
#line 987
    draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "Can\'t build on map edge.");
    }
#line 989
    return;
  } else
#line 985
  if ((int )(pl->map)->width - 2 < (int )x) {
    {
#line 987
    draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "Can\'t build on map edge.");
    }
#line 989
    return;
  } else
#line 985
  if ((int )(pl->map)->height - 2 < (int )y) {
    {
#line 987
    draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "Can\'t build on map edge.");
    }
#line 989
    return;
  }
#line 999
  tmp = ((pl->map)->spaces + ((int )x + (int )(pl->map)->width * (int )y))->bottom;
#line 1000
  if (! tmp) {
    {
#line 1002
    LOG((LogLevel )0, "apply_map_builder: undefined square at (%d, %d, %s)\n", (int )x,
        (int )y, (pl->map)->path);
#line 1003
    draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "You\'d better not build here, it looks weird.");
    }
#line 1005
    return;
  }
#line 1008
  builder = (pl->contr)->ranges[6];
#line 1010
  if ((int )builder->subtype != 1) {
    {
#line 1011
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1011
      next1011 = tmp;
#line 1011
      if ((unsigned long )next1011 == (unsigned long )((void *)0)) {
#line 1011
        tmp___0 = (tag_t )0;
      } else {
#line 1011
        tmp___0 = next1011->count;
      }
#line 1011
      next_tag1011 = tmp___0;
      {
#line 1011
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1011
        tmp = next1011;
#line 1011
        if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 1011
          goto while_break___0;
        }
#line 1011
        if (next1011->count != next_tag1011) {
#line 1011
          goto while_break___0;
        } else
#line 1011
        if (next1011->flags[0] & (1U << 3)) {
#line 1011
          goto while_break___0;
        }
#line 1011
        next1011 = next1011->above;
#line 1011
        if ((unsigned long )next1011 == (unsigned long )((void *)0)) {
#line 1011
          next_tag1011 = (tag_t )0;
        } else {
#line 1011
          next_tag1011 = next1011->count;
        }
#line 1012
        if (! (tmp->flags[3] & (1U << 14))) {
#line 1012
          if ((int )tmp->type != 98) {
            {
#line 1014
            draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "You can\'t build here.");
            }
#line 1016
            return;
          } else {
            {
#line 1012
            tmp___1 = strcmp((tmp->arch)->name, "rune_mark");
            }
#line 1012
            if (tmp___1) {
              {
#line 1014
              draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "You can\'t build here.");
              }
#line 1016
              return;
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1011
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1023
  if ((int )builder->subtype == 2) {
    {
#line 1025
    apply_builder_remove(pl, dir);
    }
#line 1026
    return;
  }
#line 1029
  if ((int )builder->subtype == 1) {
    {
#line 1033
    built = 0;
#line 1037
    material = find_marked_object(pl);
    }
#line 1038
    if (! material) {
      {
#line 1039
      draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "You need to mark raw materials to use.");
      }
#line 1041
      return;
    }
#line 1044
    if ((int )material->type != 161) {
      {
#line 1045
      draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "You can\'t use the marked item to build.");
      }
#line 1047
      return;
    }
    {
#line 1051
    new_arch = find_archetype(material->slaying);
    }
#line 1052
    if (! new_arch) {
      {
#line 1053
      draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "You can\'t use this strange material.");
#line 1055
      LOG((LogLevel )0, "apply_map_builder: unable to find archetype %s\n", material->slaying);
      }
#line 1056
      return;
    }
    {
#line 1058
    new_item = object_create_arch(new_arch);
#line 1059
    new_item->flags[3] |= 1U << 14;
#line 1061
    tmp___2 = can_build_over(pl->map, new_item, x, y);
    }
#line 1061
    if (! tmp___2) {
      {
#line 1062
      draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "You can\'t build here.");
      }
#line 1064
      return;
    }
    {
#line 1069
    if ((int )material->subtype == 1) {
#line 1069
      goto case_1;
    }
#line 1073
    if ((int )material->subtype == 2) {
#line 1073
      goto case_2;
    }
#line 1077
    if ((int )material->subtype == 3) {
#line 1077
      goto case_3;
    }
#line 1081
    if ((int )material->subtype == 4) {
#line 1081
      goto case_4;
    }
#line 1085
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 1070
    built = apply_builder_floor(pl, new_item, x, y);
    }
#line 1071
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1074
    built = apply_builder_wall(pl, new_item, x, y);
    }
#line 1075
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1078
    built = apply_builder_item(pl, new_item, x, y);
    }
#line 1079
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1082
    built = apply_builder_window(pl, new_item, x, y);
    }
#line 1083
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1086
    draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "Don\'t know how to apply this material, sorry.");
#line 1088
    LOG((LogLevel )0, "apply_map_builder: invalid material subtype %d\n", (int )material->subtype);
    }
#line 1089
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1091
    if (built) {
      {
#line 1092
      object_decrease_nrof(material, (uint32 )1);
      }
    }
#line 1093
    return;
  }
  {
#line 1097
  draw_ext_info(256, 0, (object const   *)pl, (uint8 )13, (uint8 )9, "Don\'t know how to apply this tool, sorry.");
#line 1099
  LOG((LogLevel )0, "apply_map_builder: invalid builder subtype %d\n", (int )builder->subtype);
  }
#line 1100
  return;
}
}
#line 293 "../include/libproto.h"
extern object *object_find_by_tag(object const   *who , tag_t tag ) ;
#line 236 "../include/sproto.h"
void command_cast_spell(object *op , char const   *params , char command ) ;
#line 237
int legal_range(object *op , int r ) ;
#line 238
void change_spell(object *op , char k ) ;
#line 571
extern sint16 SP_level_spellpoint_cost(object *caster , object *spell , int flags ) ;
#line 590
extern int cast_spell(object *op , object *caster , int dir , object *spell_ob , char *stringarg ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_range.c"
void command_invoke(object *op , char const   *params ) 
{ 


  {
  {
#line 52
  command_cast_spell(op, params, (char )'i');
  }
#line 53
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_range.c"
void command_cast(object *op , char const   *params ) 
{ 


  {
  {
#line 64
  command_cast_spell(op, params, (char )'c');
  }
#line 65
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_range.c"
void command_prepare(object *op , char const   *params ) 
{ 


  {
  {
#line 77
  command_cast_spell(op, params, (char )'p');
  }
#line 78
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_range.c"
static void show_matching_spells(object *op , char const   *params ) 
{ 
  char spell_sort[1024][256] ;
  char tmp[256] ;
  char *cp ;
  int num_found ;
  int i ;
  object *spell ;
  object *next100 ;
  tag_t next_tag100 ;
  tag_t tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  sint16 tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;

  {
#line 93
  num_found = 0;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    spell = op->inv;
    {
#line 100
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 100
      next100 = spell;
#line 100
      if ((unsigned long )next100 == (unsigned long )((void *)0)) {
#line 100
        tmp___0 = (tag_t )0;
      } else {
#line 100
        tmp___0 = next100->count;
      }
#line 100
      next_tag100 = tmp___0;
      {
#line 100
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 100
        spell = next100;
#line 100
        if (! ((unsigned long )spell != (unsigned long )((void *)0))) {
#line 100
          goto while_break___1;
        }
#line 100
        if (next100->count != next_tag100) {
#line 100
          goto while_break___1;
        } else
#line 100
        if (next100->flags[0] & (1U << 3)) {
#line 100
          goto while_break___1;
        }
#line 100
        next100 = next100->below;
#line 100
        if ((unsigned long )next100 == (unsigned long )((void *)0)) {
#line 100
          next_tag100 = (tag_t )0;
        } else {
#line 100
          next_tag100 = next100->count;
        }
#line 104
        if ((int )spell->type == 101) {
#line 104
          if ((int const   )*params == 0) {
#line 104
            goto _L;
          } else {
            {
#line 104
            tmp___6 = strlen(params);
#line 104
            tmp___7 = strncmp(params, spell->name, tmp___6);
            }
#line 104
            if (! tmp___7) {
              _L: /* CIL Label */ 
#line 106
              if (spell->path_attuned & op->path_denied) {
#line 107
                if (spell->skill) {
#line 107
                  tmp___1 = spell->skill;
                } else {
#line 107
                  tmp___1 = "generic";
                }
                {
#line 107
                tmp___2 = num_found;
#line 107
                num_found ++;
#line 107
                snprintf((char */* __restrict  */)(spell_sort[tmp___2]), sizeof(spell_sort[0]),
                         (char const   */* __restrict  */)"%s:%-22s %3s %3s", tmp___1,
                         spell->name, "den", "den");
                }
              } else {
                {
#line 111
                tmp___3 = SP_level_spellpoint_cost(op, spell, 3);
                }
#line 111
                if (spell->skill) {
#line 111
                  tmp___4 = spell->skill;
                } else {
#line 111
                  tmp___4 = "generic";
                }
                {
#line 111
                tmp___5 = num_found;
#line 111
                num_found ++;
#line 111
                snprintf((char */* __restrict  */)(spell_sort[tmp___5]), sizeof(spell_sort[0]),
                         (char const   */* __restrict  */)"%s:%-22s %3d %3d", tmp___4,
                         spell->name, (int )spell->level, (int )tmp___3);
                }
              }
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 100
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 100
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  if (! num_found) {
#line 119
    if ((int const   )*params != 0) {
      {
#line 120
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You know no spells like \'%s\'.",
                           params);
      }
    } else {
      {
#line 123
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You know no spells.");
      }
    }
#line 126
    return;
  }
#line 129
  if ((int const   )*params != 0) {
    {
#line 130
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "You know the following \'%s\' spells:",
                         params);
    }
  } else {
    {
#line 133
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "You know the following spells:");
    }
  }
  {
#line 141
  qsort((void *)(spell_sort), (size_t )num_found, (size_t )256, (int (*)(void const   * ,
                                                                         void const   * ))(& strcmp));
#line 142
  strcpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)"asdfg");
#line 143
  i = 0;
  }
  {
#line 143
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 143
    if (! (i < num_found)) {
#line 143
      goto while_break___2;
    }
    {
#line 145
    tmp___9 = strlen((char const   *)(tmp));
#line 145
    tmp___10 = strncmp((char const   *)(tmp), (char const   *)(spell_sort[i]), tmp___9);
    }
#line 145
    if (tmp___10) {
      {
#line 146
      strcpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)(spell_sort[i]));
#line 147
      cp = strchr((char const   *)(tmp), ':');
#line 148
      *cp = (char )'\000';
#line 150
      tmp___8 = strlen((char const   *)(tmp));
#line 150
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "\n[fixed]%s spells %.*s <lvl> <sp>",
                           tmp, (int )(12UL - tmp___8), "              ");
      }
    }
    {
#line 154
    tmp___11 = strchr((char const   *)(spell_sort[i]), ':');
#line 154
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "[fixed]%s",
                         tmp___11 + 1);
#line 143
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 158
  return;
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_range.c"
void command_cast_spell(object *op , char const   *params , char command ) 
{ 
  int castnow ;
  char *cp ;
  char cpy[256] ;
  object *spob ;
  tag_t spellnumber ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  object *tmp___5 ;
  sstring required ;
  char const   *tmp___6 ;
  sstring tmp___7 ;
  char const   *tmp___8 ;

  {
  {
#line 173
  castnow = 0;
#line 177
  strncpy((char */* __restrict  */)(cpy), (char const   */* __restrict  */)params,
          sizeof(cpy));
  }
#line 179
  if ((int )command == 105) {
#line 180
    castnow = 1;
  }
#line 182
  if ((int )cpy[0] != 0) {
    {
#line 183
    spellnumber = (tag_t )0;
#line 184
    tmp = atoi((char const   *)(cpy));
#line 184
    spellnumber = (tag_t )tmp;
    }
#line 184
    if (spellnumber != 0U) {
      {
#line 185
      spob = object_find_by_tag((object const   *)op, spellnumber);
      }
    } else {
      {
#line 187
      spob = lookup_spell_by_name(op, (char const   *)(cpy));
      }
    }
#line 189
    if (spob) {
#line 189
      if ((int )spob->type == 101) {
#line 193
        if (spellnumber) {
          {
#line 195
          cp = strchr((char const   *)(cpy), ' ');
          }
#line 196
          if (cp) {
            {
#line 197
            cp ++;
#line 198
            tmp___0 = strncmp((char const   *)cp, "of ", (size_t )3);
            }
#line 198
            if (! tmp___0) {
#line 199
              cp += 3;
            }
          }
        } else {
          {
#line 201
          tmp___3 = strlen((char const   *)(cpy));
#line 201
          tmp___4 = strlen(spob->name);
          }
#line 201
          if (tmp___3 > tmp___4) {
            {
#line 202
            tmp___1 = strlen(spob->name);
#line 202
            cp = cpy + tmp___1;
#line 203
            *cp = (char)0;
#line 204
            cp ++;
#line 205
            tmp___2 = strncmp((char const   *)cp, "of ", (size_t )3);
            }
#line 205
            if (! tmp___2) {
#line 206
              cp += 3;
            }
          } else {
#line 208
            cp = (char *)((void *)0);
          }
        }
#line 210
        if (spob->skill) {
          {
#line 210
          tmp___5 = find_skill_by_name(op, spob->skill);
          }
#line 210
          if (! tmp___5) {
            {
#line 211
            draw_ext_info_format(256, 0, (object const   *)op, (uint8 )12, (uint8 )1,
                                 "You need the skill %s to cast %s!", spob->skill,
                                 spob->name);
            }
#line 214
            return;
          }
        }
#line 218
        if ((unsigned long )(op->contr)->ranges[4] != (unsigned long )((void *)0)) {
#line 219
          if ((op->contr)->golem_count == ((op->contr)->ranges[4])->count) {
            {
#line 220
            remove_friendly_object((op->contr)->ranges[4]);
#line 221
            object_remove((op->contr)->ranges[4]);
#line 222
            object_free_drop_inventory((op->contr)->ranges[4]);
            }
          }
#line 224
          (op->contr)->ranges[4] = (object *)((void *)0);
#line 225
          (op->contr)->golem_count = (uint32 )0;
        }
#line 229
        op->spell = spob;
#line 230
        if (castnow) {
          {
#line 231
          cast_spell(op, op, (int )op->facing, spob, cp);
          }
        } else {
          {
#line 234
          tmp___6 = object_get_value((object const   *)spob, (char const   */* const  */)"casting_requirements");
#line 234
          required = tmp___6;
#line 235
          (op->contr)->ranges[2] = spob;
#line 236
          (op->contr)->shoottype = (rangetype )2;
          }
#line 238
          if ((unsigned long )cp != (unsigned long )((void *)0)) {
            {
#line 239
            strncpy((char */* __restrict  */)((op->contr)->spellparam), (char const   */* __restrict  */)cp,
                    (size_t )256);
#line 240
            (op->contr)->spellparam[255] = (char )'\000';
            }
          } else {
#line 242
            (op->contr)->spellparam[0] = (char )'\000';
          }
#line 244
          if (required) {
#line 244
            tmp___7 = required;
          } else {
#line 244
            tmp___7 = "";
          }
#line 244
          if (required) {
#line 244
            tmp___8 = " which consumes for each invocation ";
          } else {
#line 244
            tmp___8 = "";
          }
          {
#line 244
          draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )12,
                               "You ready the spell %s%s%s", spob->name, tmp___8,
                               tmp___7);
          }
        }
#line 248
        return;
      }
    }
  }
  {
#line 255
  show_matching_spells(op, (char const   *)(cpy));
  }
#line 256
  return;
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_range.c"
int legal_range(object *op , int r ) 
{ 


  {
  {
#line 279
  if (r == 0) {
#line 279
    goto case_0;
  }
#line 284
  if (r == 2) {
#line 284
    goto case_2;
  }
#line 284
  if (r == 3) {
#line 284
    goto case_2;
  }
#line 284
  if (r == 1) {
#line 284
    goto case_2;
  }
#line 290
  if (r == 4) {
#line 290
    goto case_4;
  }
#line 297
  if (r == 5) {
#line 297
    goto case_5;
  }
#line 278
  goto switch_break;
  case_0: /* CIL Label */ 
#line 280
  return (1);
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 285
  if ((op->contr)->ranges[r]) {
#line 286
    return (1);
  } else {
#line 288
    return (0);
  }
  case_4: /* CIL Label */ 
#line 291
  if ((op->contr)->ranges[4]) {
#line 291
    if (((op->contr)->ranges[4])->count == (op->contr)->golem_count) {
#line 293
      return (1);
    } else {
#line 295
      return (0);
    }
  } else {
#line 295
    return (0);
  }
  case_5: /* CIL Label */ 
#line 298
  if (op->chosen_skill) {
#line 299
    return (1);
  } else {
#line 301
    return (0);
  }
  switch_break: /* CIL Label */ ;
  }
#line 304
  return (0);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_range.c"
void change_spell(object *op , char k ) 
{ 
  char name[256] ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if ((int )k == 43) {
#line 319
      tmp = 1;
    } else {
#line 319
      tmp = -1;
    }
#line 319
    (op->contr)->shoottype = (rangetype )((int )(op->contr)->shoottype + tmp);
#line 320
    if ((int )(op->contr)->shoottype >= 7) {
#line 321
      (op->contr)->shoottype = (rangetype )0;
    } else
#line 322
    if ((int )(op->contr)->shoottype <= -1) {
#line 323
      (op->contr)->shoottype = (rangetype )6;
    }
    {
#line 318
    tmp___0 = legal_range(op, (int )(op->contr)->shoottype);
    }
#line 318
    if (tmp___0) {
#line 318
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 331
  if ((int )(op->contr)->shoottype == 0) {
#line 331
    goto case_0;
  }
#line 336
  if ((int )(op->contr)->shoottype == 4) {
#line 336
    goto case_4;
  }
#line 341
  if ((int )(op->contr)->shoottype == 1) {
#line 341
    goto case_1;
  }
#line 349
  if ((int )(op->contr)->shoottype == 2) {
#line 349
    goto case_2;
  }
#line 355
  if ((int )(op->contr)->shoottype == 3) {
#line 355
    goto case_3;
  }
#line 362
  if ((int )(op->contr)->shoottype == 5) {
#line 362
    goto case_5;
  }
#line 368
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 332
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "No ranged attack chosen.");
  }
#line 334
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 337
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "You regain control of your golem.");
  }
#line 339
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 342
  query_name((object const   *)(op->contr)->ranges[1], name, (size_t )256);
  }
#line 343
  if (((op->contr)->ranges[1])->race) {
#line 343
    tmp___1 = ((op->contr)->ranges[1])->race;
  } else {
#line 343
    tmp___1 = "nothing";
  }
  {
#line 343
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "Switched to %s and %s.",
                       name, tmp___1);
  }
#line 347
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 350
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "Switched to spells (%s).",
                       ((op->contr)->ranges[2])->name);
  }
#line 353
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 356
  query_base_name((object const   *)(op->contr)->ranges[3], 0, name, (size_t )256);
#line 357
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "Switched to %s.",
                       name);
  }
#line 360
  goto switch_break;
  case_5: /* CIL Label */ 
#line 363
  if (op->chosen_skill) {
#line 363
    tmp___2 = (op->chosen_skill)->name;
  } else {
#line 363
    tmp___2 = "none";
  }
  {
#line 363
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "Switched to skill: %s",
                       tmp___2);
  }
#line 366
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 369
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 371
  return;
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_range.c"
void command_rotateshoottype(object *op , char const   *params ) 
{ 


  {
#line 382
  if ((int const   )*params == 0) {
    {
#line 383
    change_spell(op, (char )'+');
    }
  } else {
    {
#line 385
    change_spell(op, (char )*(params + 0));
    }
  }
#line 386
  return;
}
}
#line 54 "../include/living.h"
char const   * const  attacks[26] ;
#line 69 "../include/spells.h"
char const   * const  spellpathnames[20] ;
#line 100 "../include/stringbuffer.h"
void stringbuffer_append_string(StringBuffer *sb , char const   *str ) ;
#line 109
void stringbuffer_append_printf(StringBuffer *sb , char const   *format  , ...) ;
#line 285 "../include/libproto.h"
extern int absdir(int d ) ;
#line 419
sint64 random_roll64(sint64 min , sint64 max , object const   *op , int goodbad ) ;
#line 422
void decay_objects(mapstruct *m ) ;
#line 425
void set_materialname(object *op ) ;
#line 426
char const   *strrstr(char const   *haystack , char const   *needle ) ;
#line 427
void strip_endline(char *buf ) ;
#line 428
void replace(char const   *src , char const   *key , char const   *replacement , char *result ,
             size_t resultsize ) ;
#line 429
void make_list_like(char *input ) ;
#line 430
int get_random_dir(void) ;
#line 431
int get_randomized_dir(int dir ) ;
#line 432
int adjust_dir(int dir , int destination_dir ) ;
#line 433
void replace_unprintable_chars(char *buf ) ;
#line 435
StringBuffer *describe_spellpath_attenuation(char const   *attenuation , int value ,
                                             StringBuffer *buf ) ;
#line 436
StringBuffer *describe_attacktype(char const   *attack , int value , StringBuffer *buf ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/utils.c"
int random_roll(int min , int max , object const   *op , int goodbad ) 
{ 
  int omin ;
  int diff ;
  int luck ;
  int base ;
  int ran ;
  long tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 54
  omin = min;
#line 55
  diff = (max - min) + 1;
#line 56
  if (diff > 2) {
#line 56
    base = 20;
  } else {
#line 56
    base = 50;
  }
#line 58
  if (max < 1) {
    {
#line 59
    LOG((LogLevel )0, "Calling random_roll with min=%d max=%d\n", min, max);
    }
#line 60
    return (min);
  } else
#line 58
  if (diff < 1) {
    {
#line 59
    LOG((LogLevel )0, "Calling random_roll with min=%d max=%d\n", min, max);
    }
#line 60
    return (min);
  }
  {
#line 63
  tmp = random();
#line 63
  ran = (int )tmp;
  }
#line 65
  if ((int const   )op->type != 1) {
#line 66
    return (ran % diff + min);
  }
  {
#line 68
  luck = (int )op->stats.luck;
#line 69
  tmp___4 = random();
#line 69
  tmp___8 = abs(luck);
  }
#line 69
  if (10 < tmp___8) {
#line 69
    tmp___7 = 10;
  } else {
    {
#line 69
    tmp___6 = abs(luck);
#line 69
    tmp___7 = tmp___6;
    }
  }
#line 69
  if (tmp___4 % (long )base < (long )tmp___7) {
#line 71
    if (luck > 0) {
#line 71
      luck = 1;
    } else {
#line 71
      luck = -1;
    }
#line 72
    diff -= luck;
#line 73
    if (diff < 1) {
#line 74
      return (omin);
    }
#line 75
    if (goodbad) {
#line 75
      min += luck;
    }
#line 77
    if (max < ran % diff + min) {
#line 77
      tmp___3 = max;
    } else {
#line 77
      tmp___3 = ran % diff + min;
    }
#line 77
    if (omin > tmp___3) {
#line 77
      tmp___2 = omin;
    } else {
#line 77
      if (max < ran % diff + min) {
#line 77
        tmp___1 = max;
      } else {
#line 77
        tmp___1 = ran % diff + min;
      }
#line 77
      tmp___2 = tmp___1;
    }
#line 77
    return (tmp___2);
  }
#line 79
  return (ran % diff + min);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/utils.c"
sint64 random_roll64(sint64 min , sint64 max , object const   *op , int goodbad ) 
{ 
  sint64 omin ;
  sint64 diff ;
  sint64 luck ;
  sint64 ran ;
  int base ;
  long tmp ;
  long tmp___0 ;
  sint64 tmp___2 ;
  sint64 tmp___3 ;
  sint64 tmp___4 ;
  long tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 90
  omin = min;
#line 91
  diff = (max - min) + 1L;
#line 92
  if (diff > 2L) {
#line 92
    base = 20;
  } else {
#line 92
    base = 50;
  }
#line 94
  if (max < 1L) {
    {
#line 95
    LOG((LogLevel )0, "Calling random_roll with min=%ld max=%ld\n", min, max);
    }
#line 96
    return (min);
  } else
#line 94
  if (diff < 1L) {
    {
#line 95
    LOG((LogLevel )0, "Calling random_roll with min=%ld max=%ld\n", min, max);
    }
#line 96
    return (min);
  }
  {
#line 104
  tmp = random();
#line 104
  tmp___0 = random();
#line 104
  ran = (tmp & 4294967295L) | (tmp___0 << 32);
  }
#line 106
  if ((int const   )op->type != 1) {
#line 107
    return (ran % diff + min);
  }
  {
#line 109
  luck = (sint64 )op->stats.luck;
#line 110
  tmp___5 = random();
#line 110
  tmp___9 = abs((int )luck);
  }
#line 110
  if (10 < tmp___9) {
#line 110
    tmp___8 = 10;
  } else {
    {
#line 110
    tmp___7 = abs((int )luck);
#line 110
    tmp___8 = tmp___7;
    }
  }
#line 110
  if (tmp___5 % (long )base < (long )tmp___8) {
#line 112
    if (luck > 0L) {
#line 112
      luck = (sint64 )1;
    } else {
#line 112
      luck = (sint64 )-1;
    }
#line 113
    diff -= luck;
#line 114
    if (diff < 1L) {
#line 115
      return (omin);
    }
#line 116
    if (goodbad) {
#line 116
      min += luck;
    }
#line 118
    if (max < ran % diff + min) {
#line 118
      tmp___4 = max;
    } else {
#line 118
      tmp___4 = ran % diff + min;
    }
#line 118
    if (omin > tmp___4) {
#line 118
      tmp___3 = omin;
    } else {
#line 118
      if (max < ran % diff + min) {
#line 118
        tmp___2 = max;
      } else {
#line 118
        tmp___2 = ran % diff + min;
      }
#line 118
      tmp___3 = tmp___2;
    }
#line 118
    return (tmp___3);
  }
#line 120
  return (ran % diff + min);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/utils.c"
int die_roll(int num , int size , object const   *op , int goodbad ) 
{ 
  int min ;
  int diff ;
  int luck ;
  int total ;
  int i ;
  int gotlucky ;
  int base ;
  int ran ;
  long tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 133
  diff = size;
#line 134
  min = 1;
#line 135
  gotlucky = 0;
#line 135
  total = gotlucky;
#line 135
  luck = total;
#line 136
  if (diff > 2) {
#line 136
    base = 20;
  } else {
#line 136
    base = 50;
  }
#line 137
  if (size < 2) {
    {
#line 138
    LOG((LogLevel )0, "Calling die_roll with num=%d size=%d\n", num, size);
    }
#line 139
    return (num);
  } else
#line 137
  if (diff < 1) {
    {
#line 138
    LOG((LogLevel )0, "Calling die_roll with num=%d size=%d\n", num, size);
    }
#line 139
    return (num);
  }
#line 142
  if ((int const   )op->type == 1) {
#line 143
    luck = (int )op->stats.luck;
  }
#line 145
  i = 0;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! (i < num)) {
#line 145
      goto while_break;
    }
    {
#line 146
    tmp___5 = random();
#line 146
    tmp___9 = abs(luck);
    }
#line 146
    if (10 < tmp___9) {
#line 146
      tmp___8 = 10;
    } else {
      {
#line 146
      tmp___7 = abs(luck);
#line 146
      tmp___8 = tmp___7;
      }
    }
#line 146
    if (tmp___5 % (long )base < (long )tmp___8) {
#line 146
      if (! gotlucky) {
#line 148
        gotlucky ++;
#line 149
        if (luck > 0) {
#line 149
          luck = 1;
        } else {
#line 149
          luck = -1;
        }
#line 150
        diff -= luck;
#line 151
        if (diff < 1) {
#line 152
          return (num);
        }
#line 153
        if (goodbad) {
#line 153
          min += luck;
        }
        {
#line 154
        tmp = random();
#line 154
        ran = (int )tmp;
        }
#line 155
        if (size < ran % diff + min) {
#line 155
          tmp___3 = size;
        } else {
#line 155
          tmp___3 = ran % diff + min;
        }
#line 155
        if (1 > tmp___3) {
#line 155
          tmp___2 = 1;
        } else {
#line 155
          if (size < ran % diff + min) {
#line 155
            tmp___1 = size;
          } else {
#line 155
            tmp___1 = ran % diff + min;
          }
#line 155
          tmp___2 = tmp___1;
        }
#line 155
        total += tmp___2;
      } else {
        {
#line 157
        tmp___4 = random();
#line 157
        total = (int )((long )total + (tmp___4 % (long )size + 1L));
        }
      }
    } else {
      {
#line 157
      tmp___4 = random();
#line 157
      total = (int )((long )total + (tmp___4 % (long )size + 1L));
      }
    }
#line 145
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  return (total);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/utils.c"
int rndm(int min , int max ) 
{ 
  int diff ;
  long tmp ;

  {
#line 173
  diff = (max - min) + 1;
#line 174
  if (max < 1) {
#line 175
    return (min);
  } else
#line 174
  if (diff < 1) {
#line 175
    return (min);
  }
  {
#line 177
  tmp = random();
  }
#line 177
  return ((int )(tmp % (long )diff + (long )min));
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/utils.c"
void decay_objects(mapstruct *m ) 
{ 
  int x ;
  int y ;
  int destroy ;
  object *op ;
  object *next191 ;
  tag_t next_tag191 ;
  tag_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 186
  if (m->unique) {
#line 187
    return;
  }
#line 189
  x = 0;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! (x < (int )m->width)) {
#line 189
      goto while_break;
    }
#line 190
    y = 0;
    {
#line 190
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 190
      if (! (y < (int )m->height)) {
#line 190
        goto while_break___0;
      }
      {
#line 191
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 191
        op = (m->spaces + (x + (int )m->width * y))->bottom;
        {
#line 191
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 191
          next191 = op;
#line 191
          if ((unsigned long )next191 == (unsigned long )((void *)0)) {
#line 191
            tmp = (tag_t )0;
          } else {
#line 191
            tmp = next191->count;
          }
#line 191
          next_tag191 = tmp;
          {
#line 191
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 191
            op = next191;
#line 191
            if (! ((unsigned long )op != (unsigned long )((void *)0))) {
#line 191
              goto while_break___3;
            }
#line 191
            if (next191->count != next_tag191) {
#line 191
              goto while_break___3;
            } else
#line 191
            if (next191->flags[0] & (1U << 3)) {
#line 191
              goto while_break___3;
            }
#line 191
            next191 = next191->above;
#line 191
            if ((unsigned long )next191 == (unsigned long )((void *)0)) {
#line 191
              next_tag191 = (tag_t )0;
            } else {
#line 191
              next_tag191 = next191->count;
            }
#line 192
            destroy = 0;
#line 193
            if (op->flags[1] & (1U << 31)) {
#line 193
              if (op->flags[1] & (1U << 17)) {
#line 194
                goto while_break___3;
              }
            }
#line 195
            if (op->flags[1] & (1U << 31)) {
#line 201
              goto while_continue___3;
            } else
#line 195
            if (op->flags[3] & (1U << 7)) {
#line 201
              goto while_continue___3;
            } else
#line 195
            if (op->flags[1] & (1U << 17)) {
#line 201
              goto while_continue___3;
            } else
#line 195
            if (op->flags[0] & (1U << 23)) {
#line 201
              goto while_continue___3;
            } else
#line 195
            if (op->flags[0] & (1U << 6)) {
#line 201
              goto while_continue___3;
            } else
#line 195
            if ((int )op->type == 1) {
#line 195
              goto _L;
            } else
#line 195
            if (op->flags[0] & (1U << 14)) {
#line 195
              goto _L;
            } else
#line 195
            if (op->flags[0] & 1U) {
#line 195
              if (! (op->flags[0] & (1U << 16))) {
#line 195
                if (! op->type == 23) {
                  _L: /* CIL Label */ 
#line 195
                  if (! (op->flags[3] & (1U << 13))) {
#line 201
                    goto while_continue___3;
                  }
                }
              }
            }
#line 202
            if (op->head) {
#line 204
              goto while_continue___3;
            }
#line 206
            if ((int )op->type == 13) {
#line 206
              goto _L___3;
            } else
#line 206
            if ((int )op->type == 14) {
#line 206
              goto _L___3;
            } else
#line 206
            if ((int )op->type == 15) {
              _L___3: /* CIL Label */ 
#line 207
              op->stats.dam = (sint16 )((int )op->stats.dam - 1);
#line 208
              if ((int )op->stats.dam < 0) {
#line 209
                destroy = 1;
              }
            } else
#line 210
            if ((int )op->type == 16) {
#line 210
              goto _L___2;
            } else
#line 210
            if ((int )op->type == 34) {
#line 210
              goto _L___2;
            } else
#line 210
            if ((int )op->type == 99) {
#line 210
              goto _L___2;
            } else
#line 210
            if ((int )op->type == 100) {
#line 210
              goto _L___2;
            } else
#line 210
            if ((int )op->type == 33) {
#line 210
              goto _L___2;
            } else
#line 210
            if ((int )op->type == 113) {
#line 210
              goto _L___2;
            } else
#line 210
            if ((int )op->type == 100) {
#line 210
              goto _L___2;
            } else
#line 210
            if ((int )op->type == 87) {
              _L___2: /* CIL Label */ 
#line 215
              op->stats.ac = (sint8 )((int )op->stats.ac - 1);
#line 216
              if ((int )op->stats.ac < 0) {
#line 217
                destroy = 1;
              }
            } else
#line 218
            if ((int )op->type == 6) {
              {
#line 219
              tmp___0 = rndm(5, 20);
#line 219
              op->stats.food -= tmp___0;
              }
#line 220
              if (op->stats.food < 0) {
#line 221
                destroy = 1;
              }
            } else {
#line 223
              if ((int )op->material & 1) {
#line 229
                destroy = 1;
              } else
#line 223
              if ((int )op->material & 8) {
#line 229
                destroy = 1;
              } else
#line 223
              if ((int )op->material & 16) {
#line 229
                destroy = 1;
              } else
#line 223
              if ((int )op->material & 32) {
#line 229
                destroy = 1;
              } else
#line 223
              if ((int )op->material & 128) {
#line 229
                destroy = 1;
              } else
#line 223
              if ((int )op->material & 512) {
#line 229
                destroy = 1;
              }
#line 230
              if ((int )op->material & 2) {
                {
#line 230
                tmp___1 = rndm(1, 5);
                }
#line 230
                if (tmp___1 == 1) {
#line 231
                  destroy = 1;
                }
              }
#line 232
              if ((int )op->material & 4) {
                {
#line 232
                tmp___2 = rndm(1, 2);
                }
#line 232
                if (tmp___2 == 1) {
#line 233
                  destroy = 1;
                }
              }
#line 234
              if ((int )op->material & 64) {
#line 234
                goto _L___0;
              } else
#line 234
              if ((int )op->material & 256) {
                _L___0: /* CIL Label */ 
                {
#line 234
                tmp___3 = rndm(1, 10);
                }
#line 234
                if (tmp___3 == 1) {
#line 235
                  destroy = 1;
                }
              }
#line 236
              if ((int )op->material & 1024) {
#line 236
                goto _L___1;
              } else
#line 236
              if ((int )op->material & 2048) {
                _L___1: /* CIL Label */ 
                {
#line 236
                tmp___4 = rndm(1, 3);
                }
#line 236
                if (tmp___4 == 1) {
#line 238
                  destroy = 1;
                }
              }
#line 239
              if ((int )op->material & 4096) {
                {
#line 239
                tmp___5 = rndm(0, 100);
                }
#line 239
                if (tmp___5 > 70) {
#line 240
                  destroy = 1;
                }
              }
            }
#line 243
            if (destroy) {
              {
#line 243
              tmp___6 = rndm(0, 1);
              }
#line 243
              if (tmp___6) {
                {
#line 244
                object_remove(op);
#line 245
                object_free_drop_inventory(op);
                }
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
#line 191
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 191
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 190
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 189
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 248
  return;
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/utils.c"
materialtype_t *name_to_material(char const   *name ) 
{ 
  materialtype_t *mt ;
  materialtype_t *nmt ;
  int tmp ;

  {
#line 259
  mt = (materialtype_t *)((void *)0);
#line 260
  nmt = materialt;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if ((unsigned long )nmt != (unsigned long )((void *)0)) {
#line 260
      if (! ((unsigned long )nmt->next != (unsigned long )((void *)0))) {
#line 260
        goto while_break;
      }
    } else {
#line 260
      goto while_break;
    }
    {
#line 261
    tmp = strcmp(name, nmt->name);
    }
#line 261
    if (tmp == 0) {
#line 262
      mt = nmt;
#line 263
      goto while_break;
    }
#line 260
    nmt = nmt->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 266
  return (mt);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/utils.c"
void transmute_materialname(object *op , object const   *change ) 
{ 
  materialtype_t *mt ;
  int j ;
  int tmp ;

  {
#line 279
  if ((unsigned long )op->materialname == (unsigned long )((void *)0)) {
#line 280
    return;
  }
#line 282
  if ((unsigned long )change->materialname != (unsigned long )((void *)0)) {
    {
#line 282
    tmp = strcmp(op->materialname, (char const   *)change->materialname);
    }
#line 282
    if (tmp) {
#line 284
      return;
    }
  }
#line 286
  if (! ((int )op->type == 16)) {
#line 286
    if (! ((int )op->type == 34)) {
#line 286
      if (! ((int )op->type == 99)) {
#line 286
        if (! ((int )op->type == 100)) {
#line 286
          if (! ((int )op->type == 33)) {
#line 286
            if (! ((int )op->type == 113)) {
#line 286
              if (! ((int )op->type == 100)) {
#line 286
                if (! ((int )op->type == 87)) {
#line 287
                  return;
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 289
  mt = name_to_material(op->materialname);
  }
#line 290
  if (! mt) {
    {
#line 291
    LOG((LogLevel )0, "archetype \'%s>%s\' uses nonexistent material \'%s\'\n", (op->arch)->name,
        op->name, op->materialname);
    }
#line 292
    return;
  }
#line 295
  j = 0;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    if (! (j < 26)) {
#line 295
      goto while_break;
    }
#line 296
    if ((int )op->resist[j] == 0) {
#line 296
      if ((int )change->resist[j] != 0) {
#line 297
        op->resist[j] = (sint16 )((int )op->resist[j] + (int )mt->mod[j]);
#line 298
        if ((int )op->resist[j] > 100) {
#line 299
          op->resist[j] = (sint16 )100;
        }
#line 300
        if ((int )op->resist[j] < -100) {
#line 301
          op->resist[j] = (sint16 )-100;
        }
      }
    }
#line 295
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 303
  return;
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/utils.c"
void set_materialname(object *op ) 
{ 
  materialtype_t *mt ;

  {
#line 312
  if ((unsigned long )op->materialname != (unsigned long )((void *)0)) {
#line 313
    return;
  }
#line 315
  mt = materialt;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if ((unsigned long )mt != (unsigned long )((void *)0)) {
#line 315
      if (! ((unsigned long )mt->next != (unsigned long )((void *)0))) {
#line 315
        goto while_break;
      }
    } else {
#line 315
      goto while_break;
    }
#line 316
    if ((int )op->material & mt->material) {
#line 317
      goto while_break;
    }
#line 315
    mt = mt->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  if ((unsigned long )mt != (unsigned long )((void *)0)) {
    {
#line 322
    op->materialname = add_string(mt->name);
    }
#line 323
    return;
  }
#line 325
  return;
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/utils.c"
char const   *strrstr(char const   *haystack , char const   *needle ) 
{ 
  char const   *lastneedle ;
  char *tmp ;

  {
#line 336
  lastneedle = (char const   *)((void *)0);
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 337
    tmp = strstr(haystack, needle);
#line 337
    haystack = (char const   *)tmp;
    }
#line 337
    if (! ((unsigned long )haystack != (unsigned long )((void *)0))) {
#line 337
      goto while_break;
    }
#line 338
    lastneedle = haystack;
#line 339
    haystack ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 341
  return (lastneedle);
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/utils.c"
void strip_endline(char *buf ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 350
  tmp = strlen((char const   *)buf);
  }
#line 350
  if (tmp < sizeof("\n")) {
#line 351
    return;
  }
  {
#line 353
  tmp___1 = strlen((char const   *)buf);
#line 353
  tmp___2 = strcmp((char const   *)((buf + tmp___1) - (sizeof("\n") - 1UL)), "\n");
  }
#line 353
  if (! tmp___2) {
    {
#line 354
    tmp___0 = strlen((char const   *)buf);
#line 354
    *(buf + (tmp___0 - (sizeof("\n") - 1UL))) = (char )'\000';
    }
  }
#line 355
  return;
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/utils.c"
void replace(char const   *src , char const   *key , char const   *replacement , char *result ,
             size_t resultsize ) 
{ 
  size_t resultlen ;
  size_t keylen ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 367
  tmp = strcmp(key, replacement);
  }
#line 367
  if (tmp == 0) {
    {
#line 368
    snprintf((char */* __restrict  */)result, resultsize, (char const   */* __restrict  */)"%s",
             src);
    }
#line 369
    return;
  }
  {
#line 372
  keylen = strlen(key);
#line 374
  resultlen = (size_t )0;
  }
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if ((int const   )*src != 0) {
#line 375
      if (! (resultlen + 1UL < resultsize)) {
#line 375
        goto while_break;
      }
    } else {
#line 375
      goto while_break;
    }
    {
#line 376
    tmp___3 = strncmp(src, key, keylen);
    }
#line 376
    if (tmp___3 == 0) {
      {
#line 377
      snprintf((char */* __restrict  */)(result + resultlen), resultsize - resultlen,
               (char const   */* __restrict  */)"%s", replacement);
#line 378
      tmp___0 = strlen((char const   *)(result + resultlen));
#line 378
      resultlen += tmp___0;
#line 379
      src += keylen;
      }
    } else {
#line 381
      tmp___1 = resultlen;
#line 381
      resultlen ++;
#line 381
      tmp___2 = src;
#line 381
      src ++;
#line 381
      *(result + tmp___1) = (char )*tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  *(result + resultlen) = (char )'\000';
#line 385
  return;
}
}
#line 403 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/utils.c"
void make_list_like(char *input ) 
{ 
  char *p ;
  char tmp[256] ;
  int i ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 406
  if (! input) {
#line 407
    return;
  } else {
    {
#line 406
    tmp___0 = strlen((char const   *)input);
    }
#line 406
    if (tmp___0 > 251UL) {
#line 407
      return;
    }
  }
  {
#line 410
  strncpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)input,
          (size_t )251);
#line 412
  tmp___1 = strlen((char const   *)(tmp));
#line 412
  i = (int )tmp___1;
  }
  {
#line 412
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 412
    tmp___2 = __ctype_b_loc();
    }
#line 412
    if ((int const   )*(*tmp___2 + (int )tmp[i]) & 8) {
#line 412
      goto while_break;
    } else
#line 412
    if (! (i >= 0)) {
#line 412
      goto while_break;
    }
#line 413
    tmp[i] = (char )'\000';
#line 412
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 414
  strcat((char */* __restrict  */)(tmp), (char const   */* __restrict  */)".");
#line 416
  p = strrchr((char const   *)(tmp), ',');
  }
#line 417
  if (p) {
    {
#line 418
    *p = (char )'\000';
#line 419
    strcpy((char */* __restrict  */)input, (char const   */* __restrict  */)(tmp));
#line 420
    p ++;
#line 421
    strcat((char */* __restrict  */)input, (char const   */* __restrict  */)" and");
#line 422
    strcat((char */* __restrict  */)input, (char const   */* __restrict  */)p);
    }
  } else {
    {
#line 424
    strcpy((char */* __restrict  */)input, (char const   */* __restrict  */)(tmp));
    }
  }
#line 425
  return;
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/utils.c"
int get_random_dir(void) 
{ 
  int tmp ;

  {
  {
#line 435
  tmp = rndm(1, 8);
  }
#line 435
  return (tmp);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/utils.c"
int get_randomized_dir(int dir ) 
{ 
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 447
  tmp = random();
#line 447
  tmp___0 = random();
#line 447
  tmp___1 = absdir((int )((((long )dir + tmp % 3L) + tmp___0 % 3L) - 2L));
  }
#line 447
  return (tmp___1);
}
}
#line 460 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/utils.c"
int adjust_dir(int dir , int destination_dir ) 
{ 
  int diff ;
  int tmp ;
  int tmp___0 ;

  {
#line 463
  diff = (destination_dir - dir) & 7;
#line 464
  if (1 <= diff) {
#line 464
    if (diff <= 3) {
#line 465
      dir ++;
    } else {
#line 464
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 466
  if (5 <= diff) {
#line 466
    if (diff <= 7) {
#line 467
      dir --;
    } else {
#line 466
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 468
    tmp = rndm(0, 1);
    }
#line 468
    if (tmp == 0) {
#line 469
      dir ++;
    } else {
#line 471
      dir --;
    }
  }
  {
#line 472
  tmp___0 = absdir(dir);
  }
#line 472
  return (tmp___0);
}
}
#line 481 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/utils.c"
void replace_unprintable_chars(char *buf ) 
{ 
  char *p ;

  {
#line 484
  p = buf;
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;
#line 484
    if (! ((int )*p != 0)) {
#line 484
      goto while_break;
    }
#line 485
    if ((int )*p < 32) {
#line 486
      *p = (char )' ';
    }
#line 484
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 489
  return;
}
}
#line 507 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/utils.c"
size_t split_string(char *str , char **array , size_t array_size , char sep ) 
{ 
  char *p ;
  size_t pos ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 511
  if (array_size <= 0UL) {
#line 512
    return ((size_t )0);
  }
#line 514
  if ((int )*str == 0) {
#line 515
    *(array + 0) = str;
#line 516
    return ((size_t )1);
  }
#line 519
  pos = (size_t )0;
#line 520
  p = str;
  {
#line 521
  while (1) {
    while_continue: /* CIL Label */ ;
#line 521
    if (! (pos < array_size)) {
#line 521
      goto while_break;
    }
#line 522
    tmp = pos;
#line 522
    pos ++;
#line 522
    *(array + tmp) = p;
    {
#line 523
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 523
      if ((int )*p != 0) {
#line 523
        if (! ((int )*p != (int )sep)) {
#line 523
          goto while_break___0;
        }
      } else {
#line 523
        goto while_break___0;
      }
#line 524
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 525
    if (pos >= array_size) {
#line 526
      goto while_break;
    }
#line 527
    if ((int )*p != (int )sep) {
#line 528
      goto while_break;
    }
#line 529
    tmp___0 = p;
#line 529
    p ++;
#line 529
    *tmp___0 = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
#line 531
  return (pos);
}
}
#line 541 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/utils.c"
StringBuffer *describe_spellpath_attenuation(char const   *attenuation , int value ,
                                             StringBuffer *buf ) 
{ 
  int i ;
  int j ;

  {
#line 542
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 543
    buf = stringbuffer_new();
    }
  }
#line 545
  if (value) {
    {
#line 546
    j = 0;
#line 547
    stringbuffer_append_printf(buf, "(%s: ", attenuation);
#line 548
    i = 0;
    }
    {
#line 548
    while (1) {
      while_continue: /* CIL Label */ ;
#line 548
      if (! (i < 20)) {
#line 548
        goto while_break;
      }
#line 549
      if (value & (1 << i)) {
#line 550
        if (j) {
          {
#line 551
          stringbuffer_append_string(buf, ", ");
          }
        } else {
#line 553
          j = 1;
        }
        {
#line 554
        stringbuffer_append_string(buf, (char const   *)spellpathnames[i]);
        }
      }
#line 548
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 556
    stringbuffer_append_string(buf, ")");
    }
  }
#line 559
  return (buf);
}
}
#line 569 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/utils.c"
StringBuffer *describe_attacktype(char const   *attack , int value , StringBuffer *buf ) 
{ 
  int i ;
  int j ;

  {
#line 570
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 571
    buf = stringbuffer_new();
    }
  }
#line 573
  if (value) {
    {
#line 574
    j = 0;
#line 575
    stringbuffer_append_printf(buf, "(%s: ", attack);
#line 576
    i = 0;
    }
    {
#line 576
    while (1) {
      while_continue: /* CIL Label */ ;
#line 576
      if (! (i < 26)) {
#line 576
        goto while_break;
      }
#line 577
      if (value & (1 << i)) {
#line 578
        if (j) {
          {
#line 579
          stringbuffer_append_string(buf, ", ");
          }
        } else {
#line 581
          j = 1;
        }
        {
#line 582
        stringbuffer_append_string(buf, (char const   *)attacks[i]);
        }
      }
#line 576
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 584
    stringbuffer_append_string(buf, ")");
    }
  }
#line 587
  return (buf);
}
}
#line 223 "../include/libproto.h"
extern void register_process(int ob_type , method_ret (*method)(ob_methods * , object * ) ) ;
#line 225
extern void register_move_on(int ob_type , method_ret (*method)(ob_methods * , object * ,
                                                                object * , object * ) ) ;
#line 6 "../include/typesproto.h"
void init_type_arrow(void) ;
#line 123
extern void stop_projectile(object *op ) ;
#line 124
extern method_ret common_process_projectile(ob_methods *context , object *op ) ;
#line 125
extern method_ret common_projectile_move_on(ob_methods *context , object *trap , object *victim ,
                                            object *originator ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/types/arrow/arrow.c"
static method_ret arrow_type_process(ob_methods *context , object *op ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/types/arrow/arrow.c"
void init_type_arrow(void) 
{ 


  {
  {
#line 39
  register_move_on(13, & common_projectile_move_on);
#line 40
  register_process(13, & arrow_type_process);
  }
#line 41
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/types/arrow/arrow.c"
static method_ret arrow_type_process(ob_methods *context , object *op ) 
{ 
  method_ret tmp ;

  {
#line 50
  if ((unsigned long )op->map == (unsigned long )((void *)0)) {
    {
#line 51
    LOG((LogLevel )0, "BUG: Arrow had no map.\n");
#line 52
    object_remove(op);
#line 53
    object_free_drop_inventory(op);
    }
#line 54
    return ((method_ret )2);
  }
#line 59
  if ((double )op->speed < 0.5) {
#line 59
    if ((int )op->type == 13) {
      {
#line 60
      stop_projectile(op);
      }
#line 61
      return ((method_ret )0);
    }
  }
  {
#line 64
  tmp = common_process_projectile(context, op);
  }
#line 64
  return (tmp);
}
}
#line 226 "../include/libproto.h"
extern void register_trigger(int ob_type , method_ret (*method)(ob_methods * , object * ,
                                                                object * , int  ) ) ;
#line 90 "../include/typesproto.h"
void init_type_teleporter(void) ;
#line 355 "../include/sproto.h"
extern int transfer_ob(object *op , int x , int y , int randomly , object *originator ) ;
#line 356
extern int teleport(object *teleporter , uint8 tele_type , object *user ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/types/teleporter/teleporter.c"
static method_ret teleporter_type_process(ob_methods *context , object *op ) ;
#line 35
static method_ret teleporter_type_trigger(ob_methods *context , object *op , object *cause ,
                                          int state ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/types/teleporter/teleporter.c"
void init_type_teleporter(void) 
{ 


  {
  {
#line 41
  register_process(41, & teleporter_type_process);
#line 42
  register_trigger(41, & teleporter_type_trigger);
  }
#line 43
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/types/teleporter/teleporter.c"
static void move_teleporter(object *op ) 
{ 
  object *tmp ;
  object *head ;
  float tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 61
  if (op->more) {
#line 61
    if ((op->more)->speed < (float )0) {
#line 61
      tmp___0 = - (op->more)->speed;
    } else {
#line 61
      tmp___0 = (op->more)->speed;
    }
#line 61
    if ((double )tmp___0 < 0.00001) {
      {
#line 62
      move_teleporter(op->more);
      }
    }
  }
#line 64
  if ((unsigned long )op->head != (unsigned long )((void *)0)) {
#line 64
    head = op->head;
  } else {
#line 64
    head = op;
  }
#line 65
  tmp = op->above;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 65
      goto while_break;
    }
#line 66
    if (! (tmp->flags[1] & (1U << 31))) {
#line 67
      goto while_break;
    }
#line 65
    tmp = tmp->above;
  }
  while_break: /* CIL Label */ ;
  }
#line 70
  if (! tmp) {
#line 71
    return;
  } else
#line 70
  if (tmp->flags[2] & (1U << 8)) {
#line 71
    return;
  }
#line 73
  if (head->slaying) {
#line 74
    if ((int )tmp->type == 1) {
      {
#line 76
      tmp___1 = execute_event(op, 10, tmp, (object *)((void *)0), (char const   *)((void *)0),
                              1);
      }
#line 76
      if (tmp___1 != 0) {
#line 77
        return;
      }
      {
#line 78
      enter_exit(tmp, head);
      }
    } else {
#line 82
      return;
    }
  } else
#line 83
  if (head->stats.hp) {
#line 83
    goto _L;
  } else
#line 83
  if (head->stats.sp) {
    _L: /* CIL Label */ 
    {
#line 84
    tmp___2 = out_of_map(head->map, (int )head->stats.hp, (int )head->stats.sp);
    }
#line 84
    if (tmp___2) {
      {
#line 85
      LOG((LogLevel )0, "Removed illegal teleporter.\n");
#line 86
      object_remove(head);
#line 87
      object_free_drop_inventory(head);
      }
#line 88
      return;
    }
    {
#line 91
    tmp___3 = execute_event(op, 10, tmp, (object *)((void *)0), (char const   *)((void *)0),
                            1);
    }
#line 91
    if (tmp___3 != 0) {
#line 92
      return;
    }
    {
#line 93
    transfer_ob(tmp, (int )head->stats.hp, (int )head->stats.sp, 0, head);
    }
  } else {
    {
#line 97
    tmp___4 = execute_event(op, 10, tmp, (object *)((void *)0), (char const   *)((void *)0),
                            1);
    }
#line 97
    if (tmp___4 != 0) {
#line 98
      return;
    }
    {
#line 99
    teleport(head, (uint8 )41, tmp);
    }
  }
#line 101
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/types/teleporter/teleporter.c"
static method_ret teleporter_type_process(ob_methods *context , object *op ) 
{ 


  {
  {
#line 110
  move_teleporter(op);
  }
#line 111
  return ((method_ret )0);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/types/teleporter/teleporter.c"
static method_ret teleporter_type_trigger(ob_methods *context , object *op , object *cause ,
                                          int state ) 
{ 


  {
  {
#line 123
  move_teleporter(op);
  }
#line 124
  return ((method_ret )0);
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 5 "../include/sockproto.h"
extern void esrv_send_face(socket_struct *ns , short face_num , int nocache ) ;
#line 46
extern void SockList_Init(SockList *sl ) ;
#line 47
extern void SockList_Term(SockList *sl ) ;
#line 48
extern void SockList_Reset(SockList *sl ) ;
#line 50
extern void SockList_AddChar(SockList *sl , char c ) ;
#line 51
extern void SockList_AddShort(SockList *sl , uint16 data ) ;
#line 52
extern void SockList_AddInt(SockList *sl , uint32 data ) ;
#line 54
extern size_t SockList_Avail(SockList const   *sl ) ;
#line 55
extern void SockList_AddString(SockList *sl , char const   *data ) ;
#line 58
extern void SockList_AddLen16Data(SockList *sl , void const   *data , size_t len ) ;
#line 66
extern void Send_With_Handling(socket_struct *ns , SockList *sl ) ;
#line 453 "../include/sproto.h"
int quest_get_player_state(player *pl , sstring quest_code ) ;
#line 454
void quest_start(player *pl , sstring quest_code , int state ) ;
#line 455
void quest_set_player_state(player *pl , sstring quest_code , int state ) ;
#line 456
int quest_was_completed(player *pl , sstring quest_code ) ;
#line 458
void dump_quests(void) ;
#line 461
void quest_send_initial_states(player *pl ) ;
#line 462
void quest_first_player_save(player *pl ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static quest_player *player_states  =    (quest_player *)((void *)0);
#line 99 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static int quests_loaded  =    0;
#line 100 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static quest_definition *quests  =    (quest_definition *)((void *)0);
#line 106 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static quest_step_definition *quest_create_step(void) 
{ 
  quest_step_definition *step ;
  void *tmp ;

  {
  {
#line 107
  tmp = calloc((size_t )1, sizeof(quest_step_definition ));
#line 107
  step = (quest_step_definition *)tmp;
  }
#line 108
  if (! step) {
    {
#line 109
    fatal(0);
    }
  }
#line 110
  return (step);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static quest_condition *quest_create_condition(void) 
{ 
  quest_condition *cond ;
  void *tmp ;

  {
  {
#line 118
  tmp = calloc((size_t )1, sizeof(quest_condition ));
#line 118
  cond = (quest_condition *)tmp;
  }
#line 119
  if (! cond) {
    {
#line 120
    fatal(0);
    }
  }
#line 121
  return (cond);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static quest_definition *quest_create_definition(void) 
{ 
  quest_definition *quest ;
  void *tmp ;

  {
  {
#line 130
  tmp = calloc((size_t )1, sizeof(quest_definition ));
#line 130
  quest = (quest_definition *)tmp;
  }
#line 131
  if (! quest) {
    {
#line 132
    fatal(0);
    }
  }
#line 133
  return (quest);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static quest_definition *quest_get_by_code(sstring code ) 
{ 
  quest_definition *quest ;

  {
#line 145
  quest = quests;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! quest) {
#line 146
      goto while_break;
    }
#line 147
    if ((unsigned long )quest->quest_code == (unsigned long )code) {
#line 148
      return (quest);
    }
#line 150
    quest = quest->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  return ((quest_definition *)((void *)0));
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static int load_quests_from_file(char const   *filename ) 
{ 
  int i ;
  int in ;
  int condition_parsed ;
  int minstep ;
  int maxstep ;
  char namedquest[256] ;
  quest_definition *quest ;
  quest_condition *cond ;
  char includefile[256] ;
  sstring questname ;
  quest_step_definition *step ;
  char final[256] ;
  char read___0[256] ;
  FILE *file ;
  StringBuffer *buf ;
  int loaded_quests ;
  int found ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *message ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *message___0 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  quest_definition *tmp___18 ;
  int tmp___19 ;
  int face ;
  size_t tmp___20 ;
  unsigned int tmp___21 ;
  int tmp___22 ;
  size_t tmp___23 ;
  quest_definition *tmp___24 ;
  unsigned int tmp___25 ;
  int tmp___26 ;
  char inc_path[4096] ;
  int tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;

  {
  {
#line 169
  in = 0;
#line 172
  quest = (quest_definition *)((void *)0);
#line 173
  cond = (quest_condition *)((void *)0);
#line 176
  step = (quest_step_definition *)((void *)0);
#line 181
  loaded_quests = 0;
#line 181
  found = 0;
#line 182
  snprintf((char */* __restrict  */)(final), sizeof(final), (char const   */* __restrict  */)"%s/%s/%s",
           settings.datadir, settings.mapdir, filename);
#line 183
  file = fopen((char const   */* __restrict  */)(final), (char const   */* __restrict  */)"r");
  }
#line 184
  if (! file) {
    {
#line 185
    LOG((LogLevel )0, "Can\'t open %s for reading quests", filename);
    }
#line 186
    return (-1);
  }
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 189
    tmp___29 = fgets((char */* __restrict  */)(read___0), (int )sizeof(read___0),
                     (FILE */* __restrict  */)file);
    }
#line 189
    if (! ((unsigned long )tmp___29 != (unsigned long )((void *)0))) {
#line 189
      goto while_break;
    }
#line 190
    if (in == 5) {
      {
#line 191
      tmp = strcmp((char const   *)(read___0), "end_setwhen\n");
      }
#line 191
      if (tmp == 0) {
#line 192
        in = 3;
#line 193
        goto while_continue;
      }
      {
#line 204
      minstep = 0;
#line 205
      maxstep = 0;
#line 206
      condition_parsed = 0;
#line 207
      namedquest[0] = (char )'\000';
#line 208
      tmp___4 = sscanf((char const   */* __restrict  */)(read___0), (char const   */* __restrict  */)"%s %d-%d\n",
                       namedquest, & minstep, & maxstep);
      }
#line 208
      if (tmp___4 != 3) {
        {
#line 209
        tmp___3 = sscanf((char const   */* __restrict  */)(read___0), (char const   */* __restrict  */)"%s <=%d\n",
                         namedquest, & maxstep);
        }
#line 209
        if (tmp___3 == 2) {
#line 210
          minstep = 0;
#line 211
          condition_parsed = 1;
        } else {
          {
#line 212
          tmp___2 = sscanf((char const   */* __restrict  */)(read___0), (char const   */* __restrict  */)"%s %d\n",
                           namedquest, & minstep);
          }
#line 212
          if (tmp___2 == 2) {
#line 213
            maxstep = minstep;
#line 214
            condition_parsed = 1;
          } else {
            {
#line 215
            tmp___1 = strstr((char const   *)(read___0), "finished");
            }
#line 215
            if (tmp___1) {
              {
#line 216
              tmp___0 = sscanf((char const   */* __restrict  */)(read___0), (char const   */* __restrict  */)"%s finished\n",
                               namedquest);
              }
#line 216
              if (tmp___0 == 1) {
#line 217
                maxstep = -1;
#line 217
                minstep = maxstep;
#line 218
                condition_parsed = 1;
              }
            }
          }
        }
      } else {
#line 222
        condition_parsed = 1;
      }
#line 223
      if (! condition_parsed) {
        {
#line 224
        LOG((LogLevel )0, "Invalid line \'%s\' in setwhen block for quest %s", read___0,
            quest->quest_code);
        }
#line 225
        goto while_continue;
      }
      {
#line 228
      cond = quest_create_condition();
#line 229
      cond->minstep = minstep;
#line 230
      cond->maxstep = maxstep;
#line 231
      cond->quest_code = add_string((char const   *)(namedquest));
#line 232
      cond->next = step->conditions;
#line 233
      step->conditions = cond;
#line 234
      LOG((LogLevel )2, "condition added for step %d of quest %s, looking for quest %s between steps %d and %d\n",
          step->step, quest->quest_code, cond->quest_code, cond->minstep, cond->maxstep);
      }
#line 236
      goto while_continue;
    }
#line 238
    if (in == 4) {
      {
#line 239
      tmp___5 = strcmp((char const   *)(read___0), "end_description\n");
      }
#line 239
      if (tmp___5 == 0) {
        {
#line 242
        in = 3;
#line 244
        message = stringbuffer_finish(buf);
#line 245
        buf = (StringBuffer *)((void *)0);
#line 247
        step->step_description = add_string((char const   *)message);
#line 248
        free((void *)message);
        }
#line 250
        goto while_continue;
      }
      {
#line 253
      stringbuffer_append_string(buf, (char const   *)(read___0));
      }
#line 254
      goto while_continue;
    }
#line 257
    if (in == 3) {
      {
#line 258
      tmp___6 = strcmp((char const   *)(read___0), "end_step\n");
      }
#line 258
      if (tmp___6 == 0) {
#line 259
        step = (quest_step_definition *)((void *)0);
#line 260
        in = 1;
#line 261
        goto while_continue;
      }
      {
#line 263
      tmp___7 = strcmp((char const   *)(read___0), "finishes_quest\n");
      }
#line 263
      if (tmp___7 == 0) {
#line 264
        step->is_completion_step = 1;
#line 265
        goto while_continue;
      }
      {
#line 267
      tmp___8 = strcmp((char const   *)(read___0), "description\n");
      }
#line 267
      if (tmp___8 == 0) {
        {
#line 268
        buf = stringbuffer_new();
#line 269
        in = 4;
        }
#line 270
        goto while_continue;
      }
      {
#line 272
      tmp___9 = strcmp((char const   *)(read___0), "setwhen\n");
      }
#line 272
      if (tmp___9 == 0) {
#line 273
        in = 5;
#line 274
        goto while_continue;
      }
      {
#line 276
      LOG((LogLevel )0, "quests: invalid line %s in definition of quest %s in file %s!\n",
          read___0, quest->quest_code, filename);
      }
#line 278
      goto while_continue;
    }
#line 281
    if (in == 2) {
      {
#line 282
      tmp___10 = strcmp((char const   *)(read___0), "end_description\n");
      }
#line 282
      if (tmp___10 == 0) {
        {
#line 285
        in = 1;
#line 287
        message___0 = stringbuffer_finish(buf);
#line 288
        buf = (StringBuffer *)((void *)0);
#line 290
        quest->quest_description = add_string((char const   *)message___0);
#line 291
        free((void *)message___0);
        }
#line 293
        goto while_continue;
      }
      {
#line 295
      stringbuffer_append_string(buf, (char const   *)(read___0));
      }
#line 296
      goto while_continue;
    }
#line 299
    if (in == 1) {
      {
#line 300
      tmp___11 = strcmp((char const   *)(read___0), "end_quest\n");
      }
#line 300
      if (tmp___11 == 0) {
#line 301
        quest = (quest_definition *)((void *)0);
#line 302
        in = 0;
#line 303
        goto while_continue;
      }
      {
#line 306
      tmp___12 = strcmp((char const   *)(read___0), "description\n");
      }
#line 306
      if (tmp___12 == 0) {
        {
#line 307
        in = 2;
#line 308
        buf = stringbuffer_new();
        }
#line 309
        goto while_continue;
      }
      {
#line 312
      tmp___14 = strncmp((char const   *)(read___0), "title ", (size_t )6);
      }
#line 312
      if (tmp___14 == 0) {
        {
#line 313
        tmp___13 = strlen((char const   *)(read___0));
#line 313
        read___0[tmp___13 - 1UL] = (char )'\000';
#line 314
        quest->quest_title = add_string((char const   *)(read___0 + 6));
        }
#line 315
        goto while_continue;
      }
      {
#line 318
      tmp___15 = sscanf((char const   */* __restrict  */)(read___0), (char const   */* __restrict  */)"step %d\n",
                        & i);
      }
#line 318
      if (tmp___15) {
        {
#line 319
        step = quest_create_step();
#line 320
        step->step = i;
#line 321
        step->next = quest->steps;
#line 322
        quest->steps = step;
#line 323
        in = 3;
        }
#line 324
        goto while_continue;
      }
      {
#line 327
      tmp___16 = sscanf((char const   */* __restrict  */)(read___0), (char const   */* __restrict  */)"restart %d\n",
                        & i);
      }
#line 327
      if (tmp___16) {
#line 328
        quest->quest_restart = i;
#line 329
        goto while_continue;
      }
      {
#line 331
      tmp___19 = strncmp((char const   *)(read___0), "parent ", (size_t )7);
      }
#line 331
      if (tmp___19 == 0) {
        {
#line 332
        tmp___17 = strlen((char const   *)(read___0));
#line 332
        read___0[tmp___17 - 1UL] = (char )'\000';
#line 333
        questname = add_string((char const   *)(read___0 + 7));
#line 334
        tmp___18 = quest_get_by_code(questname);
        }
#line 334
        if (tmp___18) {
          {
#line 337
          quest->parent = quest_get_by_code(questname);
          }
        } else {
          {
#line 335
          LOG((LogLevel )0, "Quest %s lists %s, as a parent, but this hasn\'t been defined\n",
              quest->quest_code, questname);
          }
        }
        {
#line 339
        free_string(questname);
        }
#line 340
        goto while_continue;
      }
      {
#line 343
      tmp___22 = strncmp((char const   *)(read___0), "face ", (size_t )5);
      }
#line 343
      if (tmp___22 == 0) {
        {
#line 345
        tmp___20 = strlen((char const   *)(read___0));
#line 345
        read___0[tmp___20 - 1UL] = (char )'\000';
#line 346
        tmp___21 = find_face((char const   *)(read___0 + 5), 0U);
#line 346
        face = (int )tmp___21;
        }
#line 347
        if (face == 0) {
          {
#line 348
          LOG((LogLevel )0, "Quest %s has invalid face %s.\n", quest->quest_code,
              read___0 + 5);
          }
        } else {
#line 350
          quest->face = face;
        }
#line 352
        goto while_continue;
      }
    }
#line 356
    if ((int )read___0[0] == 35) {
#line 357
      goto while_continue;
    }
    {
#line 359
    tmp___26 = strncmp((char const   *)(read___0), "quest ", (size_t )6);
    }
#line 359
    if (tmp___26 == 0) {
      {
#line 360
      quest = quest_create_definition();
#line 361
      tmp___23 = strlen((char const   *)(read___0));
#line 361
      read___0[tmp___23 - 1UL] = (char )'\000';
#line 362
      quest->quest_code = add_string((char const   *)(read___0 + 6));
#line 363
      tmp___24 = quest_get_by_code(quest->quest_code);
      }
#line 363
      if (tmp___24) {
        {
#line 364
        LOG((LogLevel )0, "Quest %s is listed in file %s, but this quest has already been defined\n",
            quest->quest_code, filename);
        }
      }
      {
#line 367
      tmp___25 = find_face("quest_generic.111", 0U);
#line 367
      quest->face = (int )tmp___25;
#line 368
      quest->next = quests;
      }
#line 369
      if ((unsigned long )quests != (unsigned long )((void *)0)) {
#line 370
        quest->client_code = quests->client_code + 1U;
      } else {
#line 372
        quest->client_code = (uint32 )1;
      }
#line 373
      quests = quest;
#line 374
      in = 1;
#line 375
      loaded_quests ++;
#line 376
      goto while_continue;
    }
    {
#line 378
    tmp___27 = sscanf((char const   */* __restrict  */)(read___0), (char const   */* __restrict  */)"include %s\n",
                      includefile);
    }
#line 378
    if (tmp___27) {
      {
#line 380
      path_combine_and_normalize(filename, (char const   *)(includefile), inc_path,
                                 sizeof(inc_path));
#line 381
      found = load_quests_from_file((char const   *)(inc_path));
      }
#line 382
      if (found >= 0) {
        {
#line 383
        LOG((LogLevel )2, "loaded %d quests from file %s\n", found, inc_path);
#line 384
        loaded_quests += found;
        }
      } else {
        {
#line 386
        LOG((LogLevel )0, "Failed to load quests from file %s\n", inc_path);
        }
      }
#line 388
      goto while_continue;
    }
    {
#line 391
    tmp___28 = strcmp((char const   *)(read___0), "\n");
    }
#line 391
    if (tmp___28 == 0) {
#line 392
      goto while_continue;
    }
    {
#line 394
    LOG((LogLevel )0, "quest: invalid file format for %s, I don\'t know what to do with the line %s\n",
        final, read___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 397
  fclose(file);
  }
#line 399
  if (in != 0) {
    {
#line 400
    LOG((LogLevel )0, "quest: quest definition file %s read in, ends with state %d\n",
        final, in);
    }
  }
#line 402
  return (loaded_quests);
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static void quest_load_definitions(void) 
{ 
  int found ;

  {
#line 407
  found = 0;
#line 408
  if (quests_loaded) {
#line 409
    return;
  }
  {
#line 410
  quests_loaded = 1;
#line 411
  found = load_quests_from_file("world.quests");
  }
#line 412
  if (found >= 0) {
    {
#line 413
    LOG((LogLevel )1, "%d quests found.\n", found);
    }
  } else {
    {
#line 415
    LOG((LogLevel )0, "Quest Loading Failed");
    }
  }
#line 417
  return;
}
}
#line 425 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static quest_step_definition *quest_get_step(quest_definition *quest , int step ) 
{ 
  quest_step_definition *qsd ;

  {
#line 426
  qsd = quest->steps;
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if (! qsd) {
#line 428
      goto while_break;
    }
#line 429
    if (qsd->step == step) {
#line 430
      return (qsd);
    }
#line 432
    qsd = qsd->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 435
  LOG((LogLevel )0, "quest %s has no required step %d\n", quest->quest_code, step);
  }
#line 436
  return ((quest_step_definition *)((void *)0));
}
}
#line 444 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static quest_definition *quest_get(sstring code ) 
{ 
  quest_definition *quest ;

  {
  {
#line 447
  quest_load_definitions();
#line 449
  quest = quest_get_by_code(code);
  }
#line 450
  if (! quest) {
    {
#line 451
    LOG((LogLevel )0, "quest %s required but not found!\n", code);
    }
#line 452
    return ((quest_definition *)((void *)0));
  }
#line 454
  return (quest);
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static quest_state *get_new_quest_state(void) 
{ 
  quest_state *qs ;
  void *tmp ;

  {
  {
#line 462
  tmp = calloc((size_t )1, sizeof(quest_state ));
#line 462
  qs = (quest_state *)tmp;
  }
#line 463
  if ((unsigned long )qs == (unsigned long )((void *)0)) {
    {
#line 464
    fatal(0);
    }
  }
#line 465
  return (qs);
}
}
#line 472 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static void quest_read_player_data(quest_player *pq ) 
{ 
  FILE *file ;
  char final[256] ;
  char read___0[256] ;
  char data[256] ;
  StringBuffer *buf ;
  quest_state *qs ;
  quest_state *prev ;
  int warned ;
  int state ;
  quest_definition *quest ;
  int tmp ;
  quest_step_definition *step ;
  quest_step_definition *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 475
  buf = (StringBuffer *)((void *)0);
#line 476
  qs = (quest_state *)((void *)0);
#line 476
  prev = (quest_state *)((void *)0);
#line 477
  warned = 0;
#line 478
  quest = (quest_definition *)((void *)0);
#line 481
  quest_load_definitions();
#line 483
  snprintf((char */* __restrict  */)(final), sizeof(final), (char const   */* __restrict  */)"%s/%s/%s/%s.quest",
           settings.localdir, settings.playerdir, pq->player_name, pq->player_name);
#line 485
  file = fopen((char const   */* __restrict  */)(final), (char const   */* __restrict  */)"r");
  }
#line 486
  if (! file) {
#line 488
    return;
  }
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 491
    tmp___4 = fgets((char */* __restrict  */)(read___0), (int )sizeof(read___0), (FILE */* __restrict  */)file);
    }
#line 491
    if (! ((unsigned long )tmp___4 != (unsigned long )((void *)0))) {
#line 491
      goto while_break;
    }
    {
#line 492
    tmp = sscanf((char const   */* __restrict  */)(read___0), (char const   */* __restrict  */)"quest %s\n",
                 data);
    }
#line 492
    if (tmp) {
      {
#line 493
      qs = get_new_quest_state();
#line 494
      qs->code = add_string((char const   *)(data));
      }
#line 495
      if ((unsigned long )prev == (unsigned long )((void *)0)) {
#line 496
        pq->quests = qs;
      } else {
#line 498
        prev->next = qs;
      }
      {
#line 500
      prev = qs;
#line 501
      quest = quest_get_by_code(qs->code);
      }
#line 502
      if ((unsigned long )quest == (unsigned long )((void *)0)) {
        {
#line 503
        LOG((LogLevel )2, "Unknown quest %s in quest file %s", qs->code, final);
        }
      }
#line 505
      goto while_continue;
    }
#line 508
    if (! qs) {
#line 509
      if (! warned) {
        {
#line 510
        LOG((LogLevel )0, "quest: invalid file format for %s\n", final);
        }
      }
#line 511
      warned = 1;
#line 512
      goto while_continue;
    }
    {
#line 515
    tmp___1 = sscanf((char const   */* __restrict  */)(read___0), (char const   */* __restrict  */)"state %d\n",
                     & state);
    }
#line 515
    if (tmp___1) {
#line 516
      qs->state = state;
#line 517
      if ((unsigned long )quest != (unsigned long )((void *)0)) {
#line 517
        if (state != -1) {
          {
#line 518
          tmp___0 = quest_get_step(quest, state);
#line 518
          step = tmp___0;
          }
#line 519
          if ((unsigned long )step == (unsigned long )((void *)0)) {
            {
#line 520
            LOG((LogLevel )0, "invalid quest step %d for %s in %s", state, quest->quest_code,
                final);
            }
          } else
#line 522
          if (step->is_completion_step) {
#line 523
            qs->is_complete = 1;
          }
        }
      }
#line 525
      goto while_continue;
    }
    {
#line 527
    tmp___2 = strcmp((char const   *)(read___0), "end_quest\n");
    }
#line 527
    if (tmp___2 == 0) {
#line 528
      qs = (quest_state *)((void *)0);
#line 529
      goto while_continue;
    }
    {
#line 531
    tmp___3 = sscanf((char const   */* __restrict  */)(read___0), (char const   */* __restrict  */)"completed %d\n",
                     & state);
    }
#line 531
    if (tmp___3) {
#line 532
      if (state) {
#line 532
        qs->was_completed = 1;
      } else {
#line 532
        qs->was_completed = 0;
      }
#line 533
      goto while_continue;
    }
    {
#line 536
    LOG((LogLevel )0, "quest: invalid line in %s: %s\n", final, read___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 539
  if (qs) {
    {
#line 540
    LOG((LogLevel )0, "quest: missing end_quest in %s\n", final);
    }
  }
#line 541
  if (buf) {
    {
#line 542
    tmp___5 = stringbuffer_finish(buf);
#line 542
    free((void *)tmp___5);
    }
  }
  {
#line 544
  fclose(file);
  }
#line 545
  return;
}
}
#line 551 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static void quest_write_player_data(quest_player const   *pq ) 
{ 
  FILE *file ;
  char write___0[256] ;
  char final[256] ;
  quest_state const   *state ;

  {
  {
#line 556
  snprintf((char */* __restrict  */)(final), sizeof(final), (char const   */* __restrict  */)"%s/%s/%s/%s.quest",
           settings.localdir, settings.playerdir, pq->player_name, pq->player_name);
#line 557
  snprintf((char */* __restrict  */)(write___0), sizeof(write___0), (char const   */* __restrict  */)"%s.new",
           final);
#line 559
  file = fopen((char const   */* __restrict  */)(write___0), (char const   */* __restrict  */)"w+");
  }
#line 560
  if (! file) {
    {
#line 561
    LOG((LogLevel )0, "quest: couldn\'t open player quest file %s!", write___0);
#line 562
    draw_ext_info(1280, 0, (object const   *)((void *)0), (uint8 )8, (uint8 )6, "File write error on server!");
    }
#line 563
    return;
  }
#line 566
  state = (quest_state const   *)pq->quests;
  {
#line 568
  while (1) {
    while_continue: /* CIL Label */ ;
#line 568
    if (! state) {
#line 568
      goto while_break;
    }
    {
#line 569
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"quest %s\n",
            state->code);
#line 570
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"state %d\n",
            state->state);
#line 571
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"completed %d\n",
            state->was_completed);
#line 572
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"end_quest\n");
#line 573
    state = (quest_state const   *)state->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 576
  fclose(file);
#line 578
  unlink((char const   *)(final));
#line 579
  rename((char const   *)(write___0), (char const   *)(final));
  }
#line 580
  return;
}
}
#line 588 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static quest_state *get_state(quest_player *pq , sstring name ) 
{ 
  quest_state *qs ;

  {
#line 589
  qs = pq->quests;
  {
#line 591
  while (1) {
    while_continue: /* CIL Label */ ;
#line 591
    if (! qs) {
#line 591
      goto while_break;
    }
#line 592
    if ((unsigned long )qs->code == (unsigned long )name) {
#line 593
      return (qs);
    }
#line 594
    qs = qs->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 597
  return ((quest_state *)((void *)0));
}
}
#line 606 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static quest_state *get_or_create_state(quest_player *pq , sstring name ) 
{ 
  quest_state *qs ;
  quest_state *tmp ;
  void *tmp___0 ;
  quest_state *last ;

  {
  {
#line 607
  tmp = get_state(pq, name);
#line 607
  qs = tmp;
  }
#line 609
  if (! qs) {
    {
#line 610
    tmp___0 = calloc((size_t )1, sizeof(quest_state ));
#line 610
    qs = (quest_state *)tmp___0;
    }
#line 611
    if (! qs) {
      {
#line 612
      fatal(0);
      }
    }
    {
#line 613
    qs->code = add_refcount(name);
    }
#line 614
    if ((unsigned long )pq->quests != (unsigned long )((void *)0)) {
#line 616
      last = pq->quests;
      {
#line 616
      while (1) {
        while_continue: /* CIL Label */ ;
#line 616
        if (! ((unsigned long )last->next != (unsigned long )((void *)0))) {
#line 616
          goto while_break;
        }
#line 616
        last = last->next;
      }
      while_break: /* CIL Label */ ;
      }
#line 618
      last->next = qs;
    } else {
#line 620
      pq->quests = qs;
    }
  }
#line 624
  return (qs);
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static quest_player *get_quest(player *pl ) 
{ 
  quest_player *pq ;

  {
#line 633
  pq = player_states;
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 635
    if (! pq) {
#line 635
      goto while_break;
    }
#line 636
    if ((unsigned long )pq->player_name == (unsigned long )(pl->ob)->name) {
#line 637
      return (pq);
    }
#line 638
    pq = pq->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 641
  return ((quest_player *)((void *)0));
}
}
#line 650 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static quest_player *get_or_create_quest(player *pl ) 
{ 
  quest_player *pq ;
  quest_player *tmp ;
  void *tmp___0 ;

  {
  {
#line 651
  tmp = get_quest(pl);
#line 651
  pq = tmp;
  }
#line 653
  if (! pq) {
    {
#line 654
    tmp___0 = calloc((size_t )1, sizeof(quest_player ));
#line 654
    pq = (quest_player *)tmp___0;
    }
#line 655
    if (! pq) {
      {
#line 656
      fatal(0);
      }
    }
    {
#line 657
    pq->player_name = add_refcount((pl->ob)->name);
#line 658
    pq->next = player_states;
#line 659
    player_states = pq;
#line 660
    quest_read_player_data(pq);
    }
  }
#line 663
  return (pq);
}
}
#line 667
static void quest_set_state(player *pl , sstring quest_code , int state , int started ) ;
#line 675 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static int evaluate_quest_conditions(quest_condition const   *condition , player *pl ) 
{ 
  quest_condition const   *cond ;
  int current_step ;
  int tmp ;

  {
#line 679
  if (! condition) {
#line 680
    return (0);
  }
#line 681
  cond = condition;
  {
#line 682
  while (1) {
    while_continue: /* CIL Label */ ;
#line 682
    if (! cond) {
#line 682
      goto while_break;
    }
    {
#line 683
    current_step = quest_get_player_state(pl, (sstring )cond->quest_code);
    }
#line 684
    if (cond->minstep < 0) {
#line 684
      if (cond->maxstep < 0) {
        {
#line 686
        tmp = quest_was_completed(pl, (sstring )cond->quest_code);
        }
#line 686
        if (! tmp) {
#line 687
          return (0);
        }
      } else {
#line 684
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 689
    if (current_step < (int )cond->minstep) {
#line 690
      return (0);
    } else
#line 689
    if (current_step > (int )cond->maxstep) {
#line 690
      return (0);
    }
#line 692
    cond = (quest_condition const   *)cond->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 694
  return (1);
}
}
#line 701 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static void update_quests(player *pl ) 
{ 
  quest_definition const   *quest ;
  quest_step_definition const   *step ;
  int new_step ;
  int current_step ;
  int tmp ;

  {
#line 710
  quest = (quest_definition const   *)quests;
  {
#line 711
  while (1) {
    while_continue: /* CIL Label */ ;
#line 711
    if (! quest) {
#line 711
      goto while_break;
    }
#line 712
    new_step = 0;
#line 713
    step = (quest_step_definition const   *)quest->steps;
    {
#line 714
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 714
      if (! step) {
#line 714
        goto while_break___0;
      }
#line 715
      if (step->conditions) {
        {
#line 716
        tmp = evaluate_quest_conditions((quest_condition const   *)step->conditions,
                                        pl);
        }
#line 716
        if (tmp) {
#line 717
          if (new_step < (int )step->step) {
#line 717
            new_step = (int )step->step;
          } else {
#line 717
            new_step = new_step;
          }
        }
      }
#line 719
      step = (quest_step_definition const   *)step->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 721
    if (new_step > 0) {
      {
#line 722
      current_step = quest_get_player_state(pl, (sstring )quest->quest_code);
      }
#line 723
      if (new_step > current_step) {
        {
#line 724
        quest_set_state(pl, (sstring )quest->quest_code, new_step, 0);
        }
      }
    }
#line 727
    quest = (quest_definition const   *)quest->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 729
  return;
}
}
#line 738 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static void quest_set_state(player *pl , sstring quest_code , int state , int started ) 
{ 
  quest_player *pq ;
  quest_player *tmp ;
  quest_state *qs ;
  quest_state *tmp___0 ;
  quest_definition *quest ;
  quest_definition *tmp___1 ;
  quest_step_definition *step ;
  SockList sl ;
  size_t tmp___2 ;
  int tmp___3 ;
  uint32 tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 739
  tmp = get_or_create_quest(pl);
#line 739
  pq = tmp;
#line 740
  tmp___0 = get_or_create_state(pq, quest_code);
#line 740
  qs = tmp___0;
#line 741
  tmp___1 = quest_get(quest_code);
#line 741
  quest = tmp___1;
  }
#line 744
  if (! quest) {
    {
#line 745
    LOG((LogLevel )0, "quest: asking for set_state of unknown quest %s!\n", quest_code);
    }
#line 746
    return;
  }
#line 749
  if (state <= 0) {
    {
#line 750
    LOG((LogLevel )2, "quest_set_player_state: warning: called with invalid state %d for quest %s, player %s",
        state, (pl->ob)->name, quest_code);
#line 751
    state = 100;
    }
  }
  {
#line 754
  step = quest_get_step(quest, state);
  }
#line 755
  if (! step) {
    {
#line 756
    LOG((LogLevel )0, "quest_set_player_state: couldn\'t find state definition %d for quest %s, player %s",
        state, quest_code, (pl->ob)->name);
    }
#line 757
    return;
  }
#line 760
  if (started) {
#line 760
    if (qs->state == 0) {
      {
#line 761
      LOG((LogLevel )2, "quest_set_player_state: warning: called for player %s not having started quest %s\n",
          (pl->ob)->name, quest_code);
      }
    }
  }
#line 764
  qs->state = state;
#line 765
  if (step->is_completion_step) {
#line 767
    if (! qs->is_complete) {
      {
#line 768
      draw_ext_info_format(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )8,
                           "Quest %s completed.", quest->quest_title);
      }
    }
#line 769
    qs->was_completed = 1;
#line 770
    if (quest->quest_restart) {
#line 771
      qs->state = -1;
    } else {
#line 773
      qs->is_complete = 1;
    }
  } else {
    {
#line 776
    draw_ext_info_format(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )8,
                         "New objective for the quest \'%s\':", quest->quest_title);
#line 777
    draw_ext_info(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )8, step->step_description);
    }
  }
#line 780
  if ((int )pl->socket.notifications > 0) {
    {
#line 782
    SockList_Init(& sl);
    }
#line 784
    if (qs->sent_to_client) {
      {
#line 785
      SockList_AddString(& sl, "updquest ");
      }
    } else {
      {
#line 787
      SockList_AddString(& sl, "addquest ");
      }
    }
    {
#line 790
    SockList_AddInt(& sl, quest->client_code);
    }
#line 791
    if (qs->sent_to_client == 0) {
      {
#line 792
      tmp___2 = strlen(quest->quest_title);
#line 792
      SockList_AddLen16Data(& sl, (void const   *)quest->quest_title, tmp___2);
      }
#line 793
      if (quest->face) {
#line 793
        if (! ((int )*(pl->socket.faces_sent + quest->face) & 1)) {
          {
#line 794
          esrv_send_face(& pl->socket, (short )quest->face, 0);
          }
        }
      }
      {
#line 795
      SockList_AddInt(& sl, (uint32 )quest->face);
      }
#line 796
      if (quest->quest_restart) {
#line 796
        tmp___3 = 1;
      } else {
#line 796
        tmp___3 = 0;
      }
      {
#line 796
      SockList_AddChar(& sl, (char )tmp___3);
      }
#line 797
      if (quest->parent) {
#line 797
        tmp___4 = (quest->parent)->client_code;
      } else {
#line 797
        tmp___4 = (uint32 )0;
      }
      {
#line 797
      SockList_AddInt(& sl, tmp___4);
      }
    }
#line 800
    if ((unsigned long )step == (unsigned long )((void *)0)) {
#line 800
      tmp___5 = 1;
    } else
#line 800
    if (step->is_completion_step) {
#line 800
      tmp___5 = 1;
    } else {
#line 800
      tmp___5 = 0;
    }
    {
#line 800
    SockList_AddChar(& sl, (char )tmp___5);
    }
#line 801
    if ((unsigned long )step != (unsigned long )((void *)0)) {
      {
#line 802
      tmp___6 = strlen(step->step_description);
#line 802
      SockList_AddLen16Data(& sl, (void const   *)step->step_description, tmp___6);
      }
    } else {
      {
#line 804
      SockList_AddShort(& sl, (uint16 )0);
      }
    }
    {
#line 806
    Send_With_Handling(& pl->socket, & sl);
#line 807
    SockList_Term(& sl);
#line 809
    qs->sent_to_client = 1;
    }
  }
#line 812
  if (pl->has_directory) {
    {
#line 813
    quest_write_player_data((quest_player const   *)pq);
    }
  }
  {
#line 814
  update_quests(pl);
#line 815
  LOG((LogLevel )2, "quest_set_player_state %s %s %d\n", (pl->ob)->name, quest_code,
      state);
  }
#line 817
  return;
}
}
#line 825 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static void quest_display(player *pl , quest_player *pq , int showall ) 
{ 
  quest_state *state ;
  quest_definition *quest ;
  char const   *restart ;
  int completed_count ;
  int restart_count ;
  int total_count ;
  int current_count ;

  {
#line 829
  completed_count = 0;
#line 829
  restart_count = 0;
#line 829
  total_count = 0;
#line 829
  current_count = 0;
#line 831
  state = pq->quests;
  {
#line 832
  while (1) {
    while_continue: /* CIL Label */ ;
#line 832
    if (! state) {
#line 832
      goto while_break;
    }
    {
#line 833
    quest = quest_get(state->code);
    }
#line 834
    if ((unsigned long )quest->parent == (unsigned long )((void *)0)) {
#line 835
      total_count ++;
#line 837
      if (state->state == -1) {
#line 838
        restart_count ++;
#line 839
        completed_count ++;
      } else
#line 840
      if (state->is_complete) {
#line 841
        completed_count ++;
      }
    }
#line 844
    state = state->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 846
  if (completed_count > 0) {
#line 847
    if (! showall) {
#line 848
      if (restart_count > 0) {
        {
#line 849
        draw_ext_info_format(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )8,
                             "You have completed %d quests, of which %d may be restarted",
                             completed_count, restart_count);
        }
      } else {
        {
#line 852
        draw_ext_info_format(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )8,
                             "You have completed %d quests", completed_count);
        }
      }
#line 854
      current_count = completed_count;
    } else {
      {
#line 856
      draw_ext_info_format(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )8,
                           "You have completed the following quests:");
#line 858
      state = pq->quests;
      }
      {
#line 859
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 859
        if (! state) {
#line 859
          goto while_break___0;
        }
        {
#line 860
        quest = quest_get(state->code);
        }
#line 861
        if ((unsigned long )quest->parent == (unsigned long )((void *)0)) {
#line 862
          if (state->state == -1) {
#line 862
            goto _L;
          } else
#line 862
          if (state->is_complete) {
            _L: /* CIL Label */ 
#line 864
            if (state->state == -1) {
#line 864
              restart = " (can be replayed)";
            } else {
#line 864
              restart = "";
            }
            {
#line 865
            current_count ++;
#line 865
            draw_ext_info_format(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )8,
                                 "(%3d) %s%s", current_count, quest->quest_title,
                                 restart);
            }
          }
        }
#line 869
        state = state->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 873
  if (total_count > completed_count) {
    {
#line 874
    draw_ext_info(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )8, "You have started the following quests:");
#line 876
    state = pq->quests;
    }
    {
#line 877
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 877
      if (! state) {
#line 877
        goto while_break___1;
      }
      {
#line 878
      quest = quest_get(state->code);
      }
#line 879
      if ((unsigned long )quest->parent == (unsigned long )((void *)0)) {
#line 880
        if (state->state != -1) {
#line 880
          if (state->is_complete == 0) {
            {
#line 881
            quest = quest_get(state->code);
#line 882
            current_count ++;
#line 882
            draw_ext_info_format(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )8,
                                 "(%3d) %s", current_count, quest->quest_title);
            }
          }
        }
      }
#line 886
      state = state->next;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 889
  return;
}
}
#line 896 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static void quest_list(player *pl , int showall ) 
{ 
  quest_player *pq ;

  {
  {
#line 900
  pq = get_or_create_quest(pl);
  }
#line 901
  if (! pq->quests) {
    {
#line 902
    draw_ext_info(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )8, "You didn\'t start any quest.");
    }
#line 903
    return;
  }
  {
#line 906
  quest_display(pl, pq, showall);
  }
#line 907
  return;
}
}
#line 913 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static void quest_help(player *pl ) 
{ 


  {
  {
#line 914
  draw_ext_info(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )8, "Quest commands:");
#line 915
  draw_ext_info(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )8, " - list: displays quests you are currently attempting add \'all\' to show completed quests also");
#line 916
  draw_ext_info(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )8, " - info: displays information about the specified (by number) quest");
  }
#line 917
  return;
}
}
#line 926 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static quest_state *get_quest_by_number(player *pl , int number ) 
{ 
  quest_state *state ;
  quest_player *pq ;
  quest_player *tmp ;
  int questnum ;
  quest_definition *tmp___0 ;
  quest_definition *tmp___1 ;

  {
  {
#line 928
  tmp = get_or_create_quest(pl);
#line 928
  pq = tmp;
#line 929
  questnum = 0;
  }
#line 931
  if (number <= 0) {
#line 932
    return ((quest_state *)((void *)0));
  } else
#line 931
  if (! pq) {
#line 932
    return ((quest_state *)((void *)0));
  }
#line 935
  state = pq->quests;
  {
#line 936
  while (1) {
    while_continue: /* CIL Label */ ;
#line 936
    if (! state) {
#line 936
      goto while_break;
    }
    {
#line 938
    tmp___0 = quest_get(state->code);
    }
#line 938
    if (! tmp___0->parent) {
#line 938
      if (state->state == -1) {
#line 938
        goto _L;
      } else
#line 938
      if (state->is_complete) {
        _L: /* CIL Label */ 
#line 939
        questnum ++;
#line 939
        if (questnum == number) {
#line 939
          return (state);
        }
      }
    }
#line 940
    state = state->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 943
  state = pq->quests;
  {
#line 944
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 944
    if (! state) {
#line 944
      goto while_break___0;
    }
    {
#line 946
    tmp___1 = quest_get(state->code);
    }
#line 946
    if (! tmp___1->parent) {
#line 946
      if (state->state != -1) {
#line 946
        if (state->is_complete == 0) {
#line 947
          questnum ++;
#line 947
          if (questnum == number) {
#line 947
            return (state);
          }
        }
      }
    }
#line 948
    state = state->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 951
  return ((quest_state *)((void *)0));
}
}
#line 960 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static void quest_info(player *pl , quest_state *qs , int level ) 
{ 
  quest_definition *quest ;
  quest_definition *child ;
  quest_state *state ;
  quest_player *pq ;
  quest_player *tmp ;
  quest_step_definition *step ;
  char const   *prefix ;
  char const   *restart ;

  {
  {
#line 963
  tmp = get_or_create_quest(pl);
#line 963
  pq = tmp;
  }
#line 967
  if (! qs) {
    {
#line 968
    draw_ext_info(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )8, "Invalid quest number");
    }
#line 969
    return;
  }
  {
#line 971
  quest = quest_get(qs->code);
  }
#line 972
  if (! quest) {
    {
#line 974
    draw_ext_info(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )8, "Quest: (internal error)");
    }
#line 975
    return;
  }
  {
#line 978
  draw_ext_info_format(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )8, "Quest: %s",
                       quest->quest_title);
#line 979
  draw_ext_info_format(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )8, "Description: %s",
                       quest->quest_description);
#line 981
  step = quest_get_step(quest, qs->state);
  }
#line 982
  if (qs->state == -1) {
#line 982
    goto _L;
  } else
#line 982
  if (qs->is_complete) {
    _L: /* CIL Label */ 
#line 983
    restart = "";
#line 984
    if (quest->quest_restart) {
#line 985
      restart = " (can be replayed)";
    }
    {
#line 986
    draw_ext_info_format(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )8,
                         "This quest has been completed%s.", restart);
    }
  }
#line 988
  prefix = "";
#line 989
  if (qs->state != -1) {
#line 991
    if (! step) {
      {
#line 993
      draw_ext_info_format(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )8,
                           " \nOutcome: (invalid quest)");
      }
#line 994
      return;
    }
#line 996
    if (level > 0) {
#line 997
      prefix = " * ";
    } else
#line 998
    if (qs->is_complete) {
#line 999
      prefix = "Outcome";
    } else {
#line 1001
      prefix = "Current Status";
    }
    {
#line 1002
    draw_ext_info_format(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )8,
                         " \n%s: %s", prefix, step->step_description);
    }
  }
#line 1006
  state = pq->quests;
  {
#line 1007
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1007
    if (! state) {
#line 1007
      goto while_break;
    }
    {
#line 1008
    child = quest_get(state->code);
    }
#line 1009
    if ((unsigned long )child->parent == (unsigned long )quest) {
      {
#line 1010
      quest_info(pl, state, level + 1);
      }
    }
#line 1011
    state = state->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1013
  return;
}
}
#line 1020 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static void free_state(quest_player *pq ) 
{ 
  quest_state *qs ;
  quest_state *next ;

  {
#line 1021
  qs = pq->quests;
  {
#line 1023
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1023
    if (! qs) {
#line 1023
      goto while_break;
    }
    {
#line 1024
    next = qs->next;
#line 1025
    free_string(qs->code);
#line 1026
    free((void *)qs);
#line 1027
    qs = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1029
  pq->quests = (struct quest_state *)((void *)0);
#line 1030
  return;
}
}
#line 1041 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
int quest_get_player_state(player *pl , sstring quest_code ) 
{ 
  quest_player *q ;
  quest_player *tmp ;
  quest_state *s ;
  quest_state *tmp___0 ;
  quest_definition *quest ;
  quest_definition *tmp___1 ;

  {
  {
#line 1042
  tmp = get_or_create_quest(pl);
#line 1042
  q = tmp;
#line 1043
  tmp___0 = get_state(q, quest_code);
#line 1043
  s = tmp___0;
#line 1044
  tmp___1 = quest_get(quest_code);
#line 1044
  quest = tmp___1;
  }
#line 1046
  if (! s) {
#line 1047
    return (0);
  }
#line 1049
  if (s->state == -1) {
#line 1049
    if (quest) {
#line 1049
      if (quest->quest_restart) {
#line 1050
        return (0);
      }
    }
  }
#line 1052
  return (s->state);
}
}
#line 1061 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
void quest_start(player *pl , sstring quest_code , int state ) 
{ 
  quest_player *pq ;
  quest_state *q ;
  quest_definition *quest ;

  {
  {
#line 1066
  quest = quest_get(quest_code);
  }
#line 1067
  if (! quest) {
    {
#line 1068
    LOG((LogLevel )0, "quest_start: requested unknown quest %s\n", quest_code);
    }
#line 1069
    return;
  }
  {
#line 1071
  pq = get_or_create_quest(pl);
#line 1072
  q = get_or_create_state(pq, quest_code);
  }
#line 1074
  if (state <= 0) {
    {
#line 1075
    state = 100;
#line 1076
    LOG((LogLevel )2, "quest_start: negative state %d for %s quest %s\n", state, (pl->ob)->name,
        quest_code);
    }
  }
#line 1080
  if (q->state > 0) {
    {
#line 1081
    LOG((LogLevel )2, "quest_start: warning: player %s has already started quest %s\n",
        (pl->ob)->name, quest_code);
    }
  }
  {
#line 1084
  draw_ext_info_format(256, 0, (object const   *)pl->ob, (uint8 )10, (uint8 )8, "New quest started: %s",
                       quest->quest_title);
#line 1086
  quest_set_state(pl, quest_code, state, 0);
  }
#line 1089
  return;
}
}
#line 1097 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
void quest_set_player_state(player *pl , sstring quest_code , int state ) 
{ 


  {
  {
#line 1098
  quest_set_state(pl, quest_code, state, 1);
  }
#line 1099
  return;
}
}
#line 1107 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
int quest_was_completed(player *pl , sstring quest_code ) 
{ 
  quest_player *qp ;
  quest_player *tmp ;
  quest_state *state ;
  quest_state *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1108
  tmp = get_or_create_quest(pl);
#line 1108
  qp = tmp;
#line 1109
  tmp___0 = get_state(qp, quest_code);
#line 1109
  state = tmp___0;
  }
#line 1111
  if (state) {
#line 1111
    if (state->was_completed) {
#line 1111
      tmp___1 = 1;
    } else {
#line 1111
      tmp___1 = 0;
    }
  } else {
#line 1111
    tmp___1 = 0;
  }
#line 1111
  return (tmp___1);
}
}
#line 1119 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
void command_quest(object *op , char const   *params ) 
{ 
  int tmp ;
  int tmp___0 ;
  int number ;
  int tmp___1 ;
  quest_state *tmp___2 ;
  int tmp___3 ;

  {
#line 1120
  if (! op->contr) {
    {
#line 1121
    LOG((LogLevel )0, "command_quest called for a non player!\n");
    }
#line 1122
    return;
  }
#line 1125
  if (! params) {
    {
#line 1126
    quest_help(op->contr);
    }
#line 1127
    return;
  } else
#line 1125
  if ((int const   )*params == 0) {
    {
#line 1126
    quest_help(op->contr);
    }
#line 1127
    return;
  }
  {
#line 1129
  tmp = strcmp(params, "list all");
  }
#line 1129
  if (tmp == 0) {
    {
#line 1130
    quest_list(op->contr, 1);
    }
#line 1131
    return;
  }
  {
#line 1134
  tmp___0 = strcmp(params, "list");
  }
#line 1134
  if (tmp___0 == 0) {
    {
#line 1135
    quest_list(op->contr, 0);
    }
#line 1136
    return;
  }
  {
#line 1139
  tmp___3 = strncmp(params, "info ", (size_t )5);
  }
#line 1139
  if (tmp___3 == 0) {
    {
#line 1140
    tmp___1 = atoi(params + 5);
#line 1140
    number = tmp___1;
#line 1141
    tmp___2 = get_quest_by_number(op->contr, number);
#line 1141
    quest_info(op->contr, tmp___2, 0);
    }
#line 1142
    return;
  }
  {
#line 1145
  quest_help(op->contr);
  }
#line 1146
  return;
}
}
#line 1148 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
static void output_quests(quest_definition *parent , int level ) 
{ 
  quest_definition *quest ;
  quest_step_definition *step ;
  char prefix[256] ;
  int questcount ;
  int stepcount ;
  int i ;
  char const   *tmp ;

  {
#line 1152
  questcount = 0;
#line 1156
  prefix[0] = (char )'\000';
#line 1157
  i = 0;
  {
#line 1157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1157
    if (! (i < level)) {
#line 1157
      goto while_break;
    }
    {
#line 1158
    strncat((char */* __restrict  */)(prefix), (char const   */* __restrict  */)"-",
            (size_t )255);
#line 1157
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1160
  prefix[255] = (char )'\000';
#line 1162
  quest = quests;
  {
#line 1163
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1163
    if (! quest) {
#line 1163
      goto while_break___0;
    }
#line 1164
    if ((unsigned long )quest->parent == (unsigned long )parent) {
#line 1165
      questcount ++;
#line 1166
      stepcount = 0;
#line 1167
      step = quest->steps;
      {
#line 1168
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1168
        if (! step) {
#line 1168
          goto while_break___1;
        }
#line 1169
        stepcount ++;
#line 1170
        step = step->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1172
      if (quest->quest_restart) {
#line 1172
        tmp = "";
      } else {
#line 1172
        tmp = "not ";
      }
      {
#line 1172
      fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s%s - %s - %d steps (%srestartable)\n",
              prefix, quest->quest_code, quest->quest_title, stepcount, tmp);
#line 1173
      output_quests(quest, level + 1);
      }
    }
#line 1175
    quest = quest->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1177
  return;
}
}
#line 1183 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
void dump_quests(void) 
{ 


  {
  {
#line 1184
  quest_load_definitions();
#line 1185
  output_quests((quest_definition *)((void *)0), 0);
#line 1186
  exit(0);
  }
}
}
#line 1192 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
void free_quest(void) 
{ 
  quest_player *pq ;
  quest_player *next ;

  {
#line 1193
  pq = player_states;
  {
#line 1195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1195
    if (! pq) {
#line 1195
      goto while_break;
    }
    {
#line 1196
    next = pq->next;
#line 1197
    free_state(pq);
#line 1198
    free_string(pq->player_name);
#line 1199
    free((void *)pq);
#line 1200
    pq = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1202
  player_states = (quest_player *)((void *)0);
#line 1203
  return;
}
}
#line 1210 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
void free_quest_definitions(void) 
{ 
  quest_definition *quest ;
  quest_definition *next_quest ;
  quest_step_definition *step ;
  quest_step_definition *next_step ;
  quest_condition *condition ;
  quest_condition *next_condition ;

  {
#line 1211
  quest = quests;
  {
#line 1215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1215
    if (! ((unsigned long )quest != (unsigned long )((void *)0))) {
#line 1215
      goto while_break;
    }
    {
#line 1216
    next_quest = quest->next;
#line 1217
    free_string(quest->quest_code);
    }
#line 1218
    if ((unsigned long )quest->quest_description != (unsigned long )((void *)0)) {
      {
#line 1219
      free_string(quest->quest_description);
      }
    }
#line 1220
    if ((unsigned long )quest->quest_title != (unsigned long )((void *)0)) {
      {
#line 1221
      free_string(quest->quest_title);
      }
    }
#line 1222
    step = quest->steps;
    {
#line 1223
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1223
      if (! ((unsigned long )step != (unsigned long )((void *)0))) {
#line 1223
        goto while_break___0;
      }
      {
#line 1224
      next_step = step->next;
#line 1225
      free_string(step->step_description);
#line 1226
      condition = step->conditions;
      }
      {
#line 1227
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1227
        if (! ((unsigned long )condition != (unsigned long )((void *)0))) {
#line 1227
          goto while_break___1;
        }
        {
#line 1228
        next_condition = condition->next;
#line 1229
        free_string(condition->quest_code);
#line 1230
        free((void *)condition);
#line 1231
        condition = next_condition;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1233
      free((void *)step);
#line 1234
      step = next_step;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1236
    free((void *)quest);
#line 1237
    quest = next_quest;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1240
  quests = (quest_definition *)((void *)0);
#line 1241
  quests_loaded = 0;
#line 1242
  return;
}
}
#line 1249 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
void quest_send_initial_states(player *pl ) 
{ 
  quest_player *states ;
  quest_state *state ;
  SockList sl ;
  size_t size ;
  quest_definition *quest ;
  quest_step_definition *step ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  uint32 tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;

  {
#line 1250
  states = (quest_player *)((void *)0);
#line 1251
  state = (quest_state *)((void *)0);
#line 1257
  if ((int )pl->socket.notifications < 1) {
#line 1258
    return;
  }
  {
#line 1261
  quest_load_definitions();
#line 1263
  states = get_or_create_quest(pl);
#line 1265
  SockList_Init(& sl);
#line 1266
  SockList_AddString(& sl, "addquest ");
#line 1267
  state = states->quests;
  }
  {
#line 1267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1267
    if (! ((unsigned long )state != (unsigned long )((void *)0))) {
#line 1267
      goto while_break;
    }
    {
#line 1269
    quest = quest_get_by_code(state->code);
    }
#line 1270
    if (state->state == -1) {
#line 1271
      step = (quest_step_definition *)((void *)0);
    } else {
      {
#line 1273
      step = quest_get_step(quest, state->state);
      }
    }
    {
#line 1275
    tmp = strlen(quest->quest_title);
    }
#line 1275
    if ((unsigned long )step != (unsigned long )((void *)0)) {
      {
#line 1275
      tmp___0 = strlen(step->step_description);
#line 1275
      tmp___1 = tmp___0;
      }
    } else {
#line 1275
      tmp___1 = (size_t )0;
    }
    {
#line 1275
    size = (((2UL + (2UL + tmp)) + 4UL) + 1UL) + (2UL + tmp___1);
#line 1277
    tmp___2 = SockList_Avail((SockList const   *)(& sl));
    }
#line 1277
    if (tmp___2 < size) {
      {
#line 1278
      Send_With_Handling(& pl->socket, & sl);
#line 1279
      SockList_Reset(& sl);
#line 1280
      SockList_AddString(& sl, "addquest ");
      }
    }
    {
#line 1283
    SockList_AddInt(& sl, quest->client_code);
#line 1284
    tmp___3 = strlen(quest->quest_title);
#line 1284
    SockList_AddLen16Data(& sl, (void const   *)quest->quest_title, tmp___3);
    }
#line 1285
    if (quest->face) {
#line 1285
      if (! ((int )*(pl->socket.faces_sent + quest->face) & 1)) {
        {
#line 1286
        esrv_send_face(& pl->socket, (short )quest->face, 0);
        }
      }
    }
    {
#line 1287
    SockList_AddInt(& sl, (uint32 )quest->face);
    }
#line 1288
    if (quest->quest_restart) {
#line 1288
      tmp___4 = 1;
    } else {
#line 1288
      tmp___4 = 0;
    }
    {
#line 1288
    SockList_AddChar(& sl, (char )tmp___4);
    }
#line 1289
    if (quest->parent) {
#line 1289
      tmp___5 = (quest->parent)->client_code;
    } else {
#line 1289
      tmp___5 = (uint32 )0;
    }
    {
#line 1289
    SockList_AddInt(& sl, tmp___5);
    }
#line 1290
    if ((unsigned long )step == (unsigned long )((void *)0)) {
#line 1290
      tmp___6 = 1;
    } else
#line 1290
    if (step->is_completion_step) {
#line 1290
      tmp___6 = 1;
    } else {
#line 1290
      tmp___6 = 0;
    }
    {
#line 1290
    SockList_AddChar(& sl, (char )tmp___6);
    }
#line 1291
    if ((unsigned long )step != (unsigned long )((void *)0)) {
      {
#line 1292
      tmp___7 = strlen(step->step_description);
#line 1292
      SockList_AddLen16Data(& sl, (void const   *)step->step_description, tmp___7);
      }
    } else {
      {
#line 1294
      SockList_AddShort(& sl, (uint16 )0);
      }
    }
#line 1296
    state->sent_to_client = 1;
#line 1267
    state = state->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1299
  Send_With_Handling(& pl->socket, & sl);
#line 1300
  SockList_Term(& sl);
  }
#line 1301
  return;
}
}
#line 1310 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/quest.c"
void quest_first_player_save(player *pl ) 
{ 
  quest_player *qp ;
  quest_player *tmp ;

  {
  {
#line 1311
  tmp = get_quest(pl);
#line 1311
  qp = tmp;
  }
#line 1312
  if ((unsigned long )qp != (unsigned long )((void *)0)) {
#line 1312
    if ((unsigned long )qp->quests != (unsigned long )((void *)0)) {
      {
#line 1313
      quest_write_player_data((quest_player const   *)qp);
      }
    }
  }
#line 1315
  return;
}
}
#line 538 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 153 "../include/skills.h"
extern char const   *skill_names[44] ;
#line 104 "../include/libproto.h"
typedata const   *get_typedata(int itemtype ) ;
#line 107
void query_weight(object const   *op , char *buf , size_t size ) ;
#line 108
void get_levelnumber(int i , char *buf , size_t size ) ;
#line 109
void query_short_name(object const   *op , char *buf , size_t size ) ;
#line 216
extern char *ob_describe(object const   *op , object const   *observer , char *buf ,
                         size_t size ) ;
#line 231
extern object *object_get_player_container(object *op ) ;
#line 262
extern object *object_insert_in_map(object *op , mapstruct *m , object *originator ,
                                    int flag ) ;
#line 288
extern int object_can_pick(object const   *who , object const   *item ) ;
#line 295
extern object *object_find_by_type_and_name(object const   *who , int type , char const   *name ) ;
#line 307
extern int object_matches_string(object *pl , object *op , char const   *name ) ;
#line 363
extern recipe *find_recipe_for_tool(char const   *tool , recipe *from ) ;
#line 103 "../include/sockproto.h"
extern void esrv_send_pickup(player *pl ) ;
#line 206 "../include/sproto.h"
int sack_can_hold(object const   *pl , object const   *sack , object const   *op ,
                  uint32 nrof ) ;
#line 207
void pick_up(object *op , object *alt ) ;
#line 209
void put_object_in_sack(object *op , object *sack , object *tmp , uint32 nrof ) ;
#line 210
object *drop_object(object *op , object *tmp , uint32 nrof ) ;
#line 211
void drop(object *op , object *tmp ) ;
#line 218
void examine_monster(object *op , object *tmp , int level ) ;
#line 219
void examine(object *op , object *tmp ) ;
#line 321
extern void knowledge_item_can_be_used_alchemy(object *op , object const   *item ) ;
#line 475
extern StringBuffer *query_cost_string(object const   *tmp , object *who , int flag ,
                                       StringBuffer *buf ) ;
#line 482
extern void sell_item(object *op , object *pl ) ;
#line 485
extern int is_in_shop(object *ob ) ;
#line 492
extern int detect_curse_on_item(object *pl , object *tmp , object *skill ) ;
#line 493
extern int detect_magic_on_item(object *pl , object *tmp , object *skill ) ;
#line 494
extern int identify_object_with_skill(object *tmp , object *pl , object *skill , int print_on_success ) ;
#line 508
object *find_skill_by_number(object *who , int skillno ) ;
#line 511
extern int do_skill(object *op , object *part , object *skill , int dir , char const   *string ) ;
#line 515
extern int use_skill(object *op , char const   *string ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
static void set_pickup_mode(object const   *op , int i ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
static object *find_best_apply_object_match(object *start , object *pl , char const   *params ,
                                            int aflag ) 
{ 
  object *tmp ;
  object *best ;
  int match_val ;
  int tmpmatch ;
  object *next75 ;
  tag_t next_tag75 ;
  tag_t tmp___0 ;

  {
#line 71
  best = (object *)((void *)0);
#line 72
  match_val = 0;
#line 74
  tmp = start;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    next75 = tmp;
#line 75
    if ((unsigned long )next75 == (unsigned long )((void *)0)) {
#line 75
      tmp___0 = (tag_t )0;
    } else {
#line 75
      tmp___0 = next75->count;
    }
#line 75
    next_tag75 = tmp___0;
    {
#line 75
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 75
      tmp = next75;
#line 75
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 75
        goto while_break___0;
      }
#line 75
      if (next75->count != next_tag75) {
#line 75
        goto while_break___0;
      } else
#line 75
      if (next75->flags[0] & (1U << 3)) {
#line 75
        goto while_break___0;
      }
#line 75
      next75 = next75->below;
#line 75
      if ((unsigned long )next75 == (unsigned long )((void *)0)) {
#line 75
        next_tag75 = (tag_t )0;
      } else {
#line 75
        next_tag75 = next75->count;
      }
#line 76
      if (tmp->invisible) {
#line 77
        goto while_continue___0;
      }
#line 78
      if (aflag == 1) {
#line 78
        if (tmp->flags[0] & (1U << 5)) {
#line 79
          goto while_continue___0;
        }
      }
#line 80
      if (aflag == 2) {
#line 80
        if (! (tmp->flags[0] & (1U << 5))) {
#line 81
          goto while_continue___0;
        }
      }
      {
#line 82
      tmpmatch = object_matches_string(pl, tmp, params);
      }
#line 83
      if (tmpmatch > match_val) {
#line 84
        match_val = tmpmatch;
#line 85
        best = tmp;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 75
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return (best);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
static object *find_best_object_match(object *pl , char const   *params ) 
{ 
  object *tmp ;

  {
  {
#line 102
  tmp = find_best_apply_object_match(pl->inv, pl, params, 0);
  }
#line 102
  return (tmp);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
void command_uskill(object *pl , char const   *params ) 
{ 


  {
#line 114
  if ((int const   )*params == 0) {
    {
#line 115
    draw_ext_info(256, 0, (object const   *)pl, (uint8 )10, (uint8 )11, "Usage: use_skill <skill name>");
    }
#line 117
    return;
  }
  {
#line 119
  use_skill(pl, params);
  }
#line 120
  return;
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
void command_rskill(object *pl , char const   *params ) 
{ 
  object *skill ;

  {
#line 133
  if ((int const   )*params == 0) {
    {
#line 134
    draw_ext_info(256, 0, (object const   *)pl, (uint8 )10, (uint8 )11, "Usage: ready_skill <skill name>");
    }
#line 136
    return;
  }
  {
#line 138
  skill = find_skill_by_name(pl, params);
  }
#line 140
  if (! skill) {
    {
#line 141
    draw_ext_info_format(256, 0, (object const   *)pl, (uint8 )12, (uint8 )1, "You have no knowledge of the skill %s",
                         params);
    }
#line 144
    return;
  }
  {
#line 146
  change_skill(pl, skill, 0);
  }
#line 147
  return;
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
void command_search(object *op , char const   *params ) 
{ 


  {
  {
#line 163
  use_skill(op, skill_names[15]);
  }
#line 164
  return;
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
void command_disarm(object *op , char const   *params ) 
{ 


  {
  {
#line 175
  use_skill(op, skill_names[27]);
  }
#line 176
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
void command_throw(object *op , char const   *params ) 
{ 
  object *skop ;
  char const   *tmp ;

  {
  {
#line 192
  skop = find_skill_by_name(op, skill_names[25]);
  }
#line 193
  if (skop) {
#line 194
    if ((int const   )*params == 0) {
#line 194
      tmp = (char const   *)((void *)0);
    } else {
#line 194
      tmp = params;
    }
    {
#line 194
    do_skill(op, op, skop, (int )op->facing, tmp);
    }
#line 195
    return;
  }
  {
#line 198
  draw_ext_info(256, 0, (object const   *)op, (uint8 )12, (uint8 )1, "You have no knowledge of the skill throwing.");
  }
#line 200
  return;
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
void command_apply(object *op , char const   *params ) 
{ 
  int aflag ;
  object *inv ;
  object *item ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 211
  aflag = 0;
#line 212
  inv = op->inv;
#line 215
  if ((int const   )*params == 0) {
    {
#line 216
    apply_by_living_below(op);
    }
#line 217
    return;
  }
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! ((int const   )*params == 32)) {
#line 220
      goto while_break;
    }
#line 221
    params ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 222
  tmp = strncmp(params, "-a ", (size_t )3);
  }
#line 222
  if (! tmp) {
#line 223
    aflag = 1;
#line 224
    params += 3;
  }
  {
#line 226
  tmp___0 = strncmp(params, "-u ", (size_t )3);
  }
#line 226
  if (! tmp___0) {
#line 227
    aflag = 2;
#line 228
    params += 3;
  }
  {
#line 230
  tmp___1 = strncmp(params, "-b ", (size_t )3);
  }
#line 230
  if (! tmp___1) {
#line 231
    params += 3;
#line 232
    if (op->container) {
#line 233
      inv = (op->container)->inv;
    } else {
#line 235
      inv = op;
      {
#line 236
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 236
        if (! inv->above) {
#line 236
          goto while_break___0;
        }
#line 237
        inv = inv->above;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 240
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 240
    if (! ((int const   )*params == 32)) {
#line 240
      goto while_break___1;
    }
#line 241
    params ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 243
  item = find_best_apply_object_match(inv, op, params, aflag);
  }
#line 244
  if ((unsigned long )item == (unsigned long )((void *)0)) {
    {
#line 245
    item = find_best_apply_object_match(inv, op, params, 0);
    }
  }
#line 246
  if (item) {
    {
#line 247
    apply_by_living(op, item, aflag, 0);
    }
  } else {
    {
#line 249
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Could not find any match to the %s.",
                         params);
    }
  }
#line 252
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
int sack_can_hold(object const   *pl , object const   *sack , object const   *op ,
                  uint32 nrof ) 
{ 
  char name[256] ;
  sint32 new_weight ;
  uint32 tmp ;
  sint32 tmp___0 ;

  {
  {
#line 274
  query_name(sack, name, (size_t )256);
  }
#line 276
  if (! (sack->flags[0] & (1U << 5))) {
    {
#line 277
    draw_ext_info_format(256, 0, pl, (uint8 )10, (uint8 )11, "The %s is not active.",
                         name);
    }
#line 280
    return (0);
  }
#line 282
  if ((unsigned long )sack == (unsigned long )op) {
    {
#line 283
    draw_ext_info_format(256, 0, pl, (uint8 )10, (uint8 )11, "You can\'t put the %s into itself.",
                         name);
    }
#line 286
    return (0);
  }
#line 288
  if (sack->race) {
#line 288
    if ((unsigned long )sack->race != (unsigned long )op->race) {
      {
#line 290
      draw_ext_info_format(256, 0, pl, (uint8 )10, (uint8 )11, "You can put only %s into the %s.",
                           sack->race, name);
      }
#line 293
      return (0);
    } else
#line 288
    if ((int const   )op->type == 122) {
      {
#line 290
      draw_ext_info_format(256, 0, pl, (uint8 )10, (uint8 )11, "You can put only %s into the %s.",
                           sack->race, name);
      }
#line 293
      return (0);
    } else
#line 288
    if (sack->stats.food) {
#line 288
      if (sack->stats.food != (sint32 const   )op->type) {
        {
#line 290
        draw_ext_info_format(256, 0, pl, (uint8 )10, (uint8 )11, "You can put only %s into the %s.",
                             sack->race, name);
        }
#line 293
        return (0);
      }
    }
  }
#line 295
  if ((int const   )op->type == 21) {
#line 295
    if (sack->slaying) {
#line 295
      if (op->slaying) {
        {
#line 296
        draw_ext_info_format(256, 0, pl, (uint8 )10, (uint8 )11, "You can\'t want put the key into %s.",
                             name);
        }
#line 299
        return (0);
      }
    }
  }
#line 301
  if (sack->weight_limit) {
#line 304
    if (nrof) {
#line 304
      tmp = nrof;
    } else {
#line 304
      tmp = (uint32 )1;
    }
#line 304
    if ((int const   )op->type == 122) {
#line 304
      tmp___0 = op->carrying * (sint32 const   )op->stats.Str;
    } else {
#line 304
      tmp___0 = (sint32 const   )0;
    }
#line 304
    new_weight = (sint32 )((uint32 )sack->carrying + ((tmp * (uint32 )(op->weight + tmp___0)) * (uint32 )(100 - (int )sack->stats.Str)) / 100U);
#line 307
    if (new_weight > (sint32 )sack->weight_limit) {
      {
#line 308
      draw_ext_info_format(256, 0, pl, (uint8 )10, (uint8 )11, "That won\'t fit in the %s!",
                           name);
      }
#line 311
      return (0);
    }
  }
#line 315
  return (1);
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
static void pick_up_object(object *pl , object *op , object *tmp , int nrof ) 
{ 
  char buf[4096] ;
  char name[256] ;
  object *env ;
  uint32 weight ;
  uint32 effective_weight_limit ;
  int tmp_nrof ;
  uint32 tmp___0 ;
  object *tmp___1 ;
  int tmp___2 ;
  char failure[256] ;
  char *value ;
  StringBuffer *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 335
  env = tmp->env;
#line 337
  if (tmp->nrof) {
#line 337
    tmp___0 = tmp->nrof;
  } else {
#line 337
    tmp___0 = (uint32 )1;
  }
#line 337
  tmp_nrof = (int )tmp___0;
#line 344
  if ((int )pl->move_type & 6) {
#line 344
    if (! (pl->flags[0] & (1U << 1))) {
      {
#line 344
      tmp___1 = object_get_player_container(tmp);
      }
#line 344
      if ((unsigned long )tmp___1 != (unsigned long )pl) {
        {
#line 347
        draw_ext_info(256, 0, (object const   *)pl, (uint8 )10, (uint8 )11, "You are levitating, you can\'t reach the ground!");
        }
#line 349
        return;
      }
    }
  }
#line 351
  if (tmp->flags[1] & (1U << 18)) {
#line 352
    return;
  }
#line 354
  if (tmp->flags[0] & (1U << 4)) {
#line 354
    if (! (pl->flags[0] & (1U << 4))) {
      {
#line 355
      draw_ext_info(256, 0, (object const   *)pl, (uint8 )10, (uint8 )13, "The object disappears in a puff of smoke! It must have been an illusion.");
      }
#line 357
      if (! (tmp->flags[0] & (1U << 2))) {
        {
#line 358
        object_remove(tmp);
        }
      }
      {
#line 359
      object_free_drop_inventory(tmp);
      }
#line 360
      return;
    }
  }
#line 363
  if (nrof > tmp_nrof) {
#line 364
    nrof = tmp_nrof;
  } else
#line 363
  if (nrof == 0) {
#line 364
    nrof = tmp_nrof;
  }
#line 367
  weight = (uint32 )(tmp->weight * nrof);
#line 368
  if (tmp->inv) {
#line 369
    weight += (uint32 )((tmp->carrying * (100 - (int )tmp->stats.Str)) / 100);
  }
#line 371
  if ((int )pl->stats.Str < (int )settings.max_stat) {
#line 371
    tmp___2 = (int )pl->stats.Str;
  } else {
#line 371
    tmp___2 = (int )settings.max_stat;
  }
  {
#line 371
  effective_weight_limit = get_weight_limit(tmp___2);
  }
#line 373
  if ((uint32 )(pl->weight + pl->carrying) + weight > effective_weight_limit) {
    {
#line 374
    draw_ext_info(0, 0, (object const   *)pl, (uint8 )10, (uint8 )13, "That item is too heavy for you to pick up.");
    }
#line 376
    return;
  }
#line 379
  if ((int )settings.real_wiz == 0) {
#line 379
    if (pl->flags[0] & (1U << 4)) {
#line 380
      tmp->flags[0] |= 1U << 4;
    }
  }
#line 382
  if (nrof != tmp_nrof) {
    {
#line 385
    tmp = object_split(tmp, (uint32 )nrof, failure, sizeof(failure));
    }
#line 386
    if (! tmp) {
      {
#line 387
      draw_ext_info(256, 0, (object const   *)pl, (uint8 )10, (uint8 )11, (char const   *)(failure));
      }
#line 389
      return;
    }
  } else
#line 396
  if (! (tmp->flags[0] & (1U << 2))) {
    {
#line 397
    object_remove(tmp);
    }
  }
  {
#line 400
  query_name((object const   *)tmp, name, (size_t )256);
  }
#line 402
  if (tmp->flags[0] & (1U << 6)) {
    {
#line 403
    tmp___3 = query_cost_string((object const   *)tmp, pl, 64, (StringBuffer *)((void *)0));
#line 403
    tmp___4 = stringbuffer_finish(tmp___3);
#line 403
    value = tmp___4;
#line 404
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s will cost you %s.",
             name, value);
#line 405
    free((void *)value);
    }
  } else {
    {
#line 407
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You pick up the %s.",
             name);
    }
  }
  {
#line 410
  tmp___5 = execute_event(tmp, 5, pl, op, (char const   *)((void *)0), 1);
  }
#line 410
  if (tmp___5 != 0) {
#line 411
    return;
  }
  {
#line 413
  draw_ext_info(256, 0, (object const   *)pl, (uint8 )10, (uint8 )12, (char const   *)(buf));
#line 416
  tmp = object_insert_in_ob(tmp, op);
  }
#line 421
  if ((int )pl->type != 1) {
#line 422
    return;
  }
  {
#line 425
  fix_object(pl);
  }
#line 430
  if ((unsigned long )op != (unsigned long )pl) {
    {
#line 431
    esrv_update_item(4, pl, op);
#line 432
    esrv_update_item(4, pl, pl);
    }
  }
#line 436
  if (env) {
#line 436
    if ((unsigned long )env != (unsigned long )pl) {
#line 436
      if ((unsigned long )env != (unsigned long )op) {
        {
#line 437
        esrv_update_item(4, pl, env);
        }
      }
    }
  }
#line 438
  return;
}
}
#line 448 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
void pick_up(object *op , object *alt ) 
{ 
  object *tmp ;
  object *tmp1 ;
  mapstruct *tmp_map ;
  int count ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  object *container ;
  object *next528 ;
  tag_t next_tag528 ;
  tag_t tmp___4 ;
  int tmp___5 ;

  {
#line 450
  tmp = (object *)((void *)0);
#line 451
  tmp_map = (mapstruct *)((void *)0);
#line 455
  if (alt) {
    {
#line 456
    tmp___0 = object_can_pick((object const   *)op, (object const   *)alt);
    }
#line 456
    if (! tmp___0) {
      {
#line 457
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You can\'t pick up the %s.",
                           alt->name);
      }
#line 460
      return;
    }
#line 462
    tmp = alt;
  } else {
#line 464
    if ((unsigned long )op->below == (unsigned long )((void *)0)) {
      {
#line 465
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "There is nothing to pick up here.");
      }
#line 467
      return;
    } else {
      {
#line 464
      tmp___1 = object_can_pick((object const   *)op, (object const   *)op->below);
      }
#line 464
      if (! tmp___1) {
        {
#line 465
        draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "There is nothing to pick up here.");
        }
#line 467
        return;
      }
    }
#line 469
    tmp = op->below;
  }
  {
#line 483
  tmp_map = tmp->map;
#line 484
  tmp1 = stop_item(tmp);
  }
#line 485
  if ((unsigned long )tmp1 == (unsigned long )((void *)0)) {
#line 486
    return;
  }
#line 492
  if ((unsigned long )tmp1 != (unsigned long )tmp) {
    {
#line 493
    tmp = object_insert_in_map(tmp1, tmp_map, op, 1);
    }
  }
#line 496
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 497
    return;
  }
  {
#line 499
  tmp___2 = object_can_pick((object const   *)op, (object const   *)tmp);
  }
#line 499
  if (! tmp___2) {
#line 500
    return;
  }
#line 503
  if ((int )op->type == 1) {
#line 504
    count = (int )(op->contr)->count;
#line 505
    if (count == 0) {
#line 506
      count = (int )tmp->nrof;
    }
  } else {
#line 508
    count = (int )tmp->nrof;
  }
#line 511
  if (op->container) {
#line 512
    alt = op->container;
#line 513
    if ((unsigned long )alt != (unsigned long )tmp->env) {
      {
#line 513
      tmp___3 = sack_can_hold((object const   *)op, (object const   *)alt, (object const   *)tmp,
                              (uint32 )count);
      }
#line 513
      if (! tmp___3) {
#line 514
        return;
      }
    }
  } else {
#line 519
    container = (object *)((void *)0);
#line 527
    alt = op->inv;
    {
#line 528
    while (1) {
      while_continue: /* CIL Label */ ;
#line 528
      next528 = alt;
#line 528
      if ((unsigned long )next528 == (unsigned long )((void *)0)) {
#line 528
        tmp___4 = (tag_t )0;
      } else {
#line 528
        tmp___4 = next528->count;
      }
#line 528
      next_tag528 = tmp___4;
      {
#line 528
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 528
        alt = next528;
#line 528
        if (! ((unsigned long )alt != (unsigned long )((void *)0))) {
#line 528
          goto while_break___0;
        }
#line 528
        if (next528->count != next_tag528) {
#line 528
          goto while_break___0;
        } else
#line 528
        if (next528->flags[0] & (1U << 3)) {
#line 528
          goto while_break___0;
        }
#line 528
        next528 = next528->below;
#line 528
        if ((unsigned long )next528 == (unsigned long )((void *)0)) {
#line 528
          next_tag528 = (tag_t )0;
        } else {
#line 528
          next_tag528 = next528->count;
        }
#line 529
        if ((int )alt->type == 122) {
#line 529
          if (alt->flags[0] & (1U << 5)) {
            {
#line 529
            tmp___5 = sack_can_hold((object const   *)((void *)0), (object const   *)alt,
                                    (object const   *)tmp, (uint32 )count);
            }
#line 529
            if (tmp___5) {
#line 532
              if (alt->race) {
#line 532
                if ((unsigned long )alt->race == (unsigned long )tmp->race) {
#line 533
                  goto while_break___0;
                } else {
#line 532
                  goto _L;
                }
              } else
              _L: /* CIL Label */ 
#line 534
              if (! container) {
#line 535
                container = alt;
              }
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 528
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 540
    if (! alt) {
#line 541
      alt = container;
    }
#line 543
    if (! alt) {
#line 544
      alt = op;
    }
  }
#line 549
  if ((unsigned long )tmp->env == (unsigned long )alt) {
#line 550
    alt = op;
  }
#line 556
  if ((int )tmp->type == 122) {
#line 556
    if ((int )alt->type == 122) {
#line 557
      alt = op;
    }
  }
#line 566
  if ((int )op->type == 1) {
#line 566
    if ((int )alt->type == 122) {
#line 566
      if (tmp->flags[1] & (1U << 2)) {
        {
#line 569
        draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "This object cannot be put into containers!");
        }
#line 571
        return;
      }
    }
  }
  {
#line 574
  pick_up_object(op, alt, tmp, count);
  }
#line 575
  if ((int )op->type == 1) {
#line 576
    (op->contr)->count = (uint32 )0;
  }
#line 577
  return;
}
}
#line 587 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
void command_take(object *op , char const   *params ) 
{ 
  object *tmp ;
  int ival ;
  int missed ;
  object *next614 ;
  tag_t next_tag614 ;
  tag_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int found ;
  object *tmp___3 ;
  object *next640 ;
  tag_t next_tag640 ;
  tag_t tmp___4 ;
  char const   *tmp___5 ;

  {
#line 590
  missed = 0;
#line 592
  if (op->container) {
#line 593
    tmp = (op->container)->inv;
  } else {
#line 595
    tmp = op->above;
#line 596
    if (tmp) {
      {
#line 597
      while (1) {
        while_continue: /* CIL Label */ ;
#line 597
        if (! tmp->above) {
#line 597
          goto while_break;
        }
#line 598
        tmp = tmp->above;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 600
    if (! tmp) {
#line 601
      tmp = op->below;
    }
  }
#line 604
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 605
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Nothing to take!");
    }
#line 607
    return;
  }
#line 611
  if ((int const   )*params == 0) {
#line 612
    params = (char const   *)((void *)0);
  }
  {
#line 614
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 614
    next614 = tmp;
#line 614
    if ((unsigned long )next614 == (unsigned long )((void *)0)) {
#line 614
      tmp___0 = (tag_t )0;
    } else {
#line 614
      tmp___0 = next614->count;
    }
#line 614
    next_tag614 = tmp___0;
    {
#line 614
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 614
      tmp = next614;
#line 614
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 614
        goto while_break___1;
      }
#line 614
      if (next614->count != next_tag614) {
#line 614
        goto while_break___1;
      } else
#line 614
      if (next614->flags[0] & (1U << 3)) {
#line 614
        goto while_break___1;
      }
#line 614
      next614 = next614->below;
#line 614
      if ((unsigned long )next614 == (unsigned long )((void *)0)) {
#line 614
        next_tag614 = (tag_t )0;
      } else {
#line 614
        next_tag614 = next614->count;
      }
#line 615
      if (tmp->invisible) {
#line 616
        goto while_continue___1;
      }
#line 622
      if (params) {
        {
#line 623
        ival = object_matches_string(op, tmp, params);
        }
#line 624
        if (ival > 0) {
#line 625
          if (ival <= 2) {
            {
#line 625
            tmp___1 = object_can_pick((object const   *)op, (object const   *)tmp);
            }
#line 625
            if (tmp___1) {
              {
#line 629
              pick_up(op, tmp);
              }
            } else
#line 626
            if (! (tmp->flags[1] & (1U << 31))) {
#line 627
              missed ++;
            }
          } else {
            {
#line 629
            pick_up(op, tmp);
            }
          }
        }
      } else {
        {
#line 632
        tmp___2 = object_can_pick((object const   *)op, (object const   *)tmp);
        }
#line 632
        if (tmp___2) {
          {
#line 633
          pick_up(op, tmp);
          }
#line 634
          goto while_break___1;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 614
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 638
  if (! params) {
#line 638
    if (! tmp) {
#line 639
      found = 0;
      {
#line 640
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 640
        tmp___3 = op->below;
        {
#line 640
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 640
          next640 = tmp___3;
#line 640
          if ((unsigned long )next640 == (unsigned long )((void *)0)) {
#line 640
            tmp___4 = (tag_t )0;
          } else {
#line 640
            tmp___4 = next640->count;
          }
#line 640
          next_tag640 = tmp___4;
          {
#line 640
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 640
            tmp___3 = next640;
#line 640
            if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
#line 640
              goto while_break___4;
            }
#line 640
            if (next640->count != next_tag640) {
#line 640
              goto while_break___4;
            } else
#line 640
            if (next640->flags[0] & (1U << 3)) {
#line 640
              goto while_break___4;
            }
#line 640
            next640 = next640->below;
#line 640
            if ((unsigned long )next640 == (unsigned long )((void *)0)) {
#line 640
              next_tag640 = (tag_t )0;
            } else {
#line 640
              next_tag640 = next640->count;
            }
#line 641
            if (! tmp___3->invisible) {
#line 642
              if (tmp___3->name) {
#line 642
                tmp___5 = tmp___3->name;
              } else {
#line 642
                tmp___5 = "null";
              }
              {
#line 642
              draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11,
                                   "You can\'t pick up a %s.", tmp___5);
#line 645
              found = 1;
              }
#line 646
              goto while_break___4;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
#line 640
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 640
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 649
      if (! found) {
        {
#line 650
        draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "There is nothing to pick up.");
        }
      }
    }
  }
#line 653
  if (missed == 1) {
    {
#line 654
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You were unable to take one of the items.");
    }
  } else
#line 656
  if (missed > 1) {
    {
#line 657
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )13, "You were unable to take %d of the items.",
                         missed);
    }
  }
#line 660
  return;
}
}
#line 680 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
void put_object_in_sack(object *op , object *sack , object *tmp , uint32 nrof ) 
{ 
  object *sack2 ;
  object *orig ;
  char name_sack[256] ;
  char name_tmp[256] ;
  object *tmp2 ;
  object *next716 ;
  tag_t next_tag716 ;
  tag_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint32 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char failure[256] ;
  object *tmp___6 ;
  object *next791 ;
  tag_t next_tag791 ;
  tag_t tmp___7 ;

  {
#line 681
  orig = sack;
#line 684
  if ((unsigned long )sack == (unsigned long )tmp) {
#line 685
    return;
  }
  {
#line 686
  query_name((object const   *)sack, name_sack, (size_t )256);
  }
#line 687
  if ((int )sack->type != 122) {
#line 687
    if ((int )sack->type != 2) {
      {
#line 688
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "The %s is not a container.",
                           name_sack);
      }
#line 691
      return;
    }
  }
#line 693
  if (tmp->flags[1] & (1U << 2)) {
    {
#line 694
    query_name((object const   *)tmp, name_tmp, (size_t )256);
#line 695
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You cannot put the %s in the %s.",
                         name_tmp, name_sack);
    }
#line 698
    return;
  }
#line 700
  if ((int )tmp->type == 122) {
#line 701
    if (tmp->inv) {
#line 702
      if (tmp->slaying) {
#line 703
        return;
      }
      {
#line 710
      sack2 = tmp;
#line 711
      query_name((object const   *)tmp, name_tmp, (size_t )256);
#line 712
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "You move the items from %s into %s.",
                           name_tmp, name_sack);
      }
      {
#line 716
      while (1) {
        while_continue: /* CIL Label */ ;
#line 716
        tmp2 = tmp->inv;
        {
#line 716
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 716
          next716 = tmp2;
#line 716
          if ((unsigned long )next716 == (unsigned long )((void *)0)) {
#line 716
            tmp___0 = (tag_t )0;
          } else {
#line 716
            tmp___0 = next716->count;
          }
#line 716
          next_tag716 = tmp___0;
          {
#line 716
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 716
            tmp2 = next716;
#line 716
            if (! ((unsigned long )tmp2 != (unsigned long )((void *)0))) {
#line 716
              goto while_break___1;
            }
#line 716
            if (next716->count != next_tag716) {
#line 716
              goto while_break___1;
            } else
#line 716
            if (next716->flags[0] & (1U << 3)) {
#line 716
              goto while_break___1;
            }
#line 716
            next716 = next716->below;
#line 716
            if ((unsigned long )next716 == (unsigned long )((void *)0)) {
#line 716
              next_tag716 = (tag_t )0;
            } else {
#line 716
              next_tag716 = next716->count;
            }
#line 717
            if ((int )sack->type == 122) {
              {
#line 717
              tmp___1 = sack_can_hold((object const   *)op, (object const   *)op->container,
                                      (object const   *)tmp2, tmp2->nrof);
              }
#line 717
              if (tmp___1) {
                {
#line 719
                put_object_in_sack(op, sack, tmp2, (uint32 )0);
                }
              } else {
#line 717
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
#line 717
            if ((int )sack->type == 2) {
              {
#line 717
              tmp___2 = transport_can_hold((object const   *)sack, (object const   *)tmp2,
                                           (int )tmp2->nrof);
              }
#line 717
              if (tmp___2) {
                {
#line 719
                put_object_in_sack(op, sack, tmp2, (uint32 )0);
                }
              } else {
                {
#line 721
                draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )13,
                                     "Your %s fills up.", name_sack);
                }
#line 725
                goto while_break___1;
              }
            } else {
              {
#line 721
              draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )13,
                                   "Your %s fills up.", name_sack);
              }
#line 725
              goto while_break___1;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 716
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 716
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 728
      esrv_update_item(4, op, sack2);
      }
#line 729
      return;
    } else {
      {
#line 731
      query_name((object const   *)tmp, name_tmp, (size_t )256);
#line 732
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You can not put a %s into a %s",
                           name_tmp, name_sack);
      }
#line 736
      return;
    }
  }
#line 743
  if ((int )sack->type == 122) {
#line 743
    if (nrof) {
#line 743
      tmp___3 = nrof;
    } else {
#line 743
      tmp___3 = tmp->nrof;
    }
    {
#line 743
    tmp___4 = sack_can_hold((object const   *)op, (object const   *)sack, (object const   *)tmp,
                            tmp___3);
    }
#line 743
    if (! tmp___4) {
#line 744
      return;
    }
  }
#line 746
  if (tmp->flags[0] & (1U << 5)) {
    {
#line 747
    tmp___5 = apply_special(op, tmp, 18);
    }
#line 747
    if (tmp___5) {
#line 748
      return;
    }
  }
#line 752
  if (nrof) {
#line 752
    if (tmp->nrof != nrof) {
      {
#line 755
      tmp = object_split(tmp, nrof, failure, sizeof(failure));
      }
#line 757
      if (! tmp) {
        {
#line 758
        draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, (char const   *)(failure));
        }
#line 760
        return;
      }
    } else {
      {
#line 763
      object_remove(tmp);
      }
    }
  } else {
    {
#line 763
    object_remove(tmp);
    }
  }
#line 765
  if (sack->nrof > 1U) {
    {
#line 766
    orig = object_split(sack, sack->nrof - 1U, (char *)((void *)0), (size_t )0);
#line 767
    set_object_face_main(orig);
#line 768
    orig->flags[0] &= ~ (1U << 5);
    }
#line 769
    if (sack->env) {
      {
#line 770
      object_insert_in_ob(orig, sack->env);
      }
    } else {
      {
#line 772
      object_insert_in_map_at(orig, sack->map, (object *)((void *)0), 0, (int )sack->x,
                              (int )sack->y);
#line 773
      orig->move_off = (MoveType )0;
      }
    }
  }
  {
#line 777
  query_name((object const   *)tmp, name_tmp, (size_t )256);
#line 778
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "You put the %s in %s.",
                       name_tmp, name_sack);
#line 782
  object_insert_in_ob(tmp, sack);
  }
#line 783
  if (! (op->flags[1] & (1U << 10))) {
    {
#line 784
    fix_object(op);
    }
  }
#line 790
  if ((int )sack->type == 2) {
    {
#line 791
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 791
      tmp___6 = sack->inv;
      {
#line 791
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 791
        next791 = tmp___6;
#line 791
        if ((unsigned long )next791 == (unsigned long )((void *)0)) {
#line 791
          tmp___7 = (tag_t )0;
        } else {
#line 791
          tmp___7 = next791->count;
        }
#line 791
        next_tag791 = tmp___7;
        {
#line 791
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 791
          tmp___6 = next791;
#line 791
          if (! ((unsigned long )tmp___6 != (unsigned long )((void *)0))) {
#line 791
            goto while_break___4;
          }
#line 791
          if (next791->count != next_tag791) {
#line 791
            goto while_break___4;
          } else
#line 791
          if (next791->flags[0] & (1U << 3)) {
#line 791
            goto while_break___4;
          }
#line 791
          next791 = next791->below;
#line 791
          if ((unsigned long )next791 == (unsigned long )((void *)0)) {
#line 791
            next_tag791 = (tag_t )0;
          } else {
#line 791
            next_tag791 = next791->count;
          }
#line 792
          if ((int )tmp___6->type == 1) {
#line 793
            (tmp___6->contr)->socket.update_look = (uint32 )1;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 791
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 791
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 797
    esrv_update_item(4, op, sack);
    }
  }
#line 799
  return;
}
}
#line 816 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
object *drop_object(object *op , object *tmp , uint32 nrof ) 
{ 
  tag_t tmp_tag ;
  int tmp___0 ;
  int tmp___1 ;
  char failure[256] ;
  char name[256] ;
  int tmp___2 ;

  {
#line 819
  if (tmp->flags[1] & (1U << 18)) {
#line 820
    return ((object *)((void *)0));
  }
#line 823
  if (tmp->flags[0] & (1U << 5)) {
    {
#line 824
    tmp___0 = apply_special(op, tmp, 18);
    }
#line 824
    if (tmp___0) {
#line 825
      return ((object *)((void *)0));
    }
  }
  {
#line 829
  tmp___1 = execute_event(tmp, 4, op, (object *)((void *)0), (char const   *)((void *)0),
                          1);
  }
#line 829
  if (tmp___1 != 0) {
#line 830
    return ((object *)((void *)0));
  }
#line 833
  if (tmp->flags[0] & (1U << 2)) {
#line 834
    return ((object *)((void *)0));
  }
#line 839
  if (nrof) {
#line 839
    if (tmp->nrof != nrof) {
      {
#line 842
      tmp = object_split(tmp, nrof, failure, sizeof(failure));
      }
#line 843
      if (! tmp) {
        {
#line 844
        draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, (char const   *)(failure));
        }
#line 846
        return ((object *)((void *)0));
      }
    } else {
      {
#line 849
      object_remove(tmp);
      }
    }
  } else {
    {
#line 849
    object_remove(tmp);
    }
  }
#line 851
  if (tmp->flags[1] & (1U << 2)) {
    {
#line 854
    query_name((object const   *)tmp, name, (size_t )256);
#line 855
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "You drop the %s. The gods who lent it to you retrieves it.",
                         name);
#line 858
    object_free_drop_inventory(tmp);
    }
#line 860
    if (! (op->flags[1] & (1U << 10))) {
      {
#line 861
      fix_object(op);
      }
    }
#line 863
    return ((object *)((void *)0));
  }
  {
#line 884
  tmp_tag = tmp->count;
#line 885
  object_insert_in_map_at(tmp, op->map, op, 16, (int )op->x, (int )op->y);
  }
#line 886
  if (! (tmp->count != tmp_tag)) {
#line 886
    if (! (tmp->flags[0] & (1U << 3))) {
#line 886
      if (! (tmp->flags[0] & (1U << 6))) {
#line 886
        if ((int )tmp->type != 36) {
          {
#line 886
          tmp___2 = is_in_shop(op);
          }
#line 886
          if (tmp___2) {
            {
#line 887
            sell_item(tmp, op);
            }
          }
        }
      }
    }
  }
#line 893
  if (! (op->flags[1] & (1U << 10))) {
    {
#line 894
    fix_object(op);
    }
#line 898
    if ((int )op->type == 1) {
      {
#line 899
      esrv_update_item(4, op, op);
      }
    }
  }
#line 901
  return (tmp);
}
}
#line 912 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
void drop(object *op , object *tmp ) 
{ 
  object *next928 ;
  tag_t next_tag928 ;
  tag_t tmp___0 ;
  object *n ;

  {
#line 918
  if (tmp->invisible) {
#line 920
    if (tmp->env) {
#line 920
      if ((int )(tmp->env)->type != 1) {
        {
#line 924
        object_remove(tmp);
#line 925
        object_free_drop_inventory(tmp);
        }
#line 926
        return;
      } else {
#line 920
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 928
      while (1) {
        while_continue: /* CIL Label */ ;
#line 928
        next928 = tmp;
#line 928
        if ((unsigned long )next928 == (unsigned long )((void *)0)) {
#line 928
          tmp___0 = (tag_t )0;
        } else {
#line 928
          tmp___0 = next928->count;
        }
#line 928
        next_tag928 = tmp___0;
        {
#line 928
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 928
          tmp = next928;
#line 928
          if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 928
            goto while_break___0;
          }
#line 928
          if (next928->count != next_tag928) {
#line 928
            goto while_break___0;
          } else
#line 928
          if (next928->flags[0] & (1U << 3)) {
#line 928
            goto while_break___0;
          }
#line 928
          next928 = next928->below;
#line 928
          if ((unsigned long )next928 == (unsigned long )((void *)0)) {
#line 928
            next_tag928 = (tag_t )0;
          } else {
#line 928
            next_tag928 = next928->count;
          }
#line 929
          if (! tmp->invisible) {
#line 930
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 928
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 935
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 936
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You don\'t have anything to drop.");
    }
#line 938
    return;
  }
#line 940
  if (tmp->flags[2] & (1U << 22)) {
    {
#line 941
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "This item is locked");
    }
#line 943
    return;
  }
#line 945
  if (tmp->flags[1] & (1U << 18)) {
#line 946
    return;
  }
#line 949
  if ((int )op->type == 1) {
#line 950
    if ((unsigned long )(op->contr)->last_used == (unsigned long )tmp) {
#line 950
      if ((op->contr)->last_used_id == tmp->count) {
#line 951
        n = (object *)((void *)0);
#line 953
        if ((unsigned long )tmp->below != (unsigned long )((void *)0)) {
#line 954
          n = tmp->below;
        } else
#line 955
        if ((unsigned long )tmp->above != (unsigned long )((void *)0)) {
#line 956
          n = tmp->above;
        }
#line 957
        (op->contr)->last_used = n;
#line 958
        if ((unsigned long )n != (unsigned long )((void *)0)) {
#line 959
          (op->contr)->last_used_id = n->count;
        } else {
#line 961
          (op->contr)->last_used_id = (uint32 )0;
        }
      }
    }
  }
#line 965
  if (op->container) {
#line 966
    if ((int )op->type == 1) {
      {
#line 967
      put_object_in_sack(op, op->container, tmp, (op->contr)->count);
      }
    } else {
      {
#line 969
      put_object_in_sack(op, op->container, tmp, (uint32 )0);
      }
    }
  } else
#line 972
  if ((int )op->type == 1) {
    {
#line 973
    drop_object(op, tmp, (op->contr)->count);
    }
  } else {
    {
#line 975
    drop_object(op, tmp, (uint32 )0);
    }
  }
#line 978
  if ((int )op->type == 1) {
#line 979
    (op->contr)->count = (uint32 )0;
  }
#line 980
  return;
}
}
#line 990 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
void command_dropall(object *op , char const   *params ) 
{ 
  int count ;
  object *curinv ;
  object *next1016 ;
  tag_t next_tag1016 ;
  tag_t tmp ;
  object *curinv___0 ;
  object *next1031 ;
  tag_t next_tag1031 ;
  tag_t tmp___0 ;
  object *curinv___1 ;
  object *next1040 ;
  tag_t next_tag1040 ;
  tag_t tmp___1 ;
  object *curinv___2 ;
  object *next1049 ;
  tag_t next_tag1049 ;
  tag_t tmp___2 ;
  object *curinv___3 ;
  object *next1058 ;
  tag_t next_tag1058 ;
  tag_t tmp___3 ;
  object *curinv___4 ;
  object *next1067 ;
  tag_t next_tag1067 ;
  tag_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 991
  count = 0;
#line 993
  if ((unsigned long )op->inv == (unsigned long )((void *)0)) {
    {
#line 994
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Nothing to drop!");
    }
#line 997
    return;
  }
#line 1000
  if (op->contr) {
#line 1001
    count = (int )(op->contr)->count;
  }
#line 1006
  op->flags[1] |= 1U << 10;
#line 1015
  if ((int const   )*params == 0) {
    {
#line 1016
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1016
      curinv = op->inv;
      {
#line 1016
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1016
        next1016 = curinv;
#line 1016
        if ((unsigned long )next1016 == (unsigned long )((void *)0)) {
#line 1016
          tmp = (tag_t )0;
        } else {
#line 1016
          tmp = next1016->count;
        }
#line 1016
        next_tag1016 = tmp;
        {
#line 1016
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1016
          curinv = next1016;
#line 1016
          if (! ((unsigned long )curinv != (unsigned long )((void *)0))) {
#line 1016
            goto while_break___1;
          }
#line 1016
          if (next1016->count != next_tag1016) {
#line 1016
            goto while_break___1;
          } else
#line 1016
          if (next1016->flags[0] & (1U << 3)) {
#line 1016
            goto while_break___1;
          }
#line 1016
          next1016 = next1016->below;
#line 1016
          if ((unsigned long )next1016 == (unsigned long )((void *)0)) {
#line 1016
            next_tag1016 = (tag_t )0;
          } else {
#line 1016
            next_tag1016 = next1016->count;
          }
#line 1017
          if (! (curinv->flags[2] & (1U << 22))) {
#line 1017
            if ((int )curinv->type != 36) {
#line 1017
              if ((int )curinv->type != 6) {
#line 1017
                if ((int )curinv->type != 24) {
#line 1017
                  if ((int )curinv->type != 21) {
#line 1017
                    if ((int )curinv->type != 60) {
#line 1017
                      if (! curinv->invisible) {
#line 1017
                        if ((int )curinv->type != 122) {
#line 1017
                          goto _L;
                        } else
#line 1017
                        if ((unsigned long )op->container != (unsigned long )curinv) {
                          _L: /* CIL Label */ 
                          {
#line 1025
                          drop(op, curinv);
                          }
#line 1026
                          if (op->contr) {
#line 1027
                            (op->contr)->count = (uint32 )count;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1016
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1016
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1030
    tmp___10 = strcmp(params, "weapons");
    }
#line 1030
    if (tmp___10 == 0) {
      {
#line 1031
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1031
        curinv___0 = op->inv;
        {
#line 1031
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1031
          next1031 = curinv___0;
#line 1031
          if ((unsigned long )next1031 == (unsigned long )((void *)0)) {
#line 1031
            tmp___0 = (tag_t )0;
          } else {
#line 1031
            tmp___0 = next1031->count;
          }
#line 1031
          next_tag1031 = tmp___0;
          {
#line 1031
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1031
            curinv___0 = next1031;
#line 1031
            if (! ((unsigned long )curinv___0 != (unsigned long )((void *)0))) {
#line 1031
              goto while_break___4;
            }
#line 1031
            if (next1031->count != next_tag1031) {
#line 1031
              goto while_break___4;
            } else
#line 1031
            if (next1031->flags[0] & (1U << 3)) {
#line 1031
              goto while_break___4;
            }
#line 1031
            next1031 = next1031->below;
#line 1031
            if ((unsigned long )next1031 == (unsigned long )((void *)0)) {
#line 1031
              next_tag1031 = (tag_t )0;
            } else {
#line 1031
              next_tag1031 = next1031->count;
            }
#line 1032
            if (! (curinv___0->flags[2] & (1U << 22))) {
#line 1032
              if ((int )curinv___0->type == 15) {
#line 1032
                goto _L___0;
              } else
#line 1032
              if ((int )curinv___0->type == 14) {
#line 1032
                goto _L___0;
              } else
#line 1032
              if ((int )curinv___0->type == 13) {
                _L___0: /* CIL Label */ 
                {
#line 1034
                drop(op, curinv___0);
                }
#line 1035
                if (op->contr) {
#line 1036
                  (op->contr)->count = (uint32 )count;
                }
              }
            }
          }
          while_break___4: /* CIL Label */ ;
          }
#line 1031
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1031
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 1039
      tmp___8 = strcmp(params, "armor");
      }
#line 1039
      if (tmp___8 == 0) {
#line 1039
        goto _L___3;
      } else {
        {
#line 1039
        tmp___9 = strcmp(params, "armour");
        }
#line 1039
        if (tmp___9 == 0) {
          _L___3: /* CIL Label */ 
          {
#line 1040
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1040
            curinv___1 = op->inv;
            {
#line 1040
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 1040
              next1040 = curinv___1;
#line 1040
              if ((unsigned long )next1040 == (unsigned long )((void *)0)) {
#line 1040
                tmp___1 = (tag_t )0;
              } else {
#line 1040
                tmp___1 = next1040->count;
              }
#line 1040
              next_tag1040 = tmp___1;
              {
#line 1040
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 1040
                curinv___1 = next1040;
#line 1040
                if (! ((unsigned long )curinv___1 != (unsigned long )((void *)0))) {
#line 1040
                  goto while_break___7;
                }
#line 1040
                if (next1040->count != next_tag1040) {
#line 1040
                  goto while_break___7;
                } else
#line 1040
                if (next1040->flags[0] & (1U << 3)) {
#line 1040
                  goto while_break___7;
                }
#line 1040
                next1040 = next1040->below;
#line 1040
                if ((unsigned long )next1040 == (unsigned long )((void *)0)) {
#line 1040
                  next_tag1040 = (tag_t )0;
                } else {
#line 1040
                  next_tag1040 = next1040->count;
                }
#line 1041
                if (! (curinv___1->flags[2] & (1U << 22))) {
#line 1041
                  if ((int )curinv___1->type == 16) {
#line 1041
                    goto _L___1;
                  } else
#line 1041
                  if ((int )curinv___1->type == 33) {
#line 1041
                    goto _L___1;
                  } else
#line 1041
                  if ((int )curinv___1->type == 34) {
                    _L___1: /* CIL Label */ 
                    {
#line 1043
                    drop(op, curinv___1);
                    }
#line 1044
                    if (op->contr) {
#line 1045
                      (op->contr)->count = (uint32 )count;
                    }
                  }
                }
              }
              while_break___7: /* CIL Label */ ;
              }
#line 1040
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 1040
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
        } else {
          {
#line 1048
          tmp___7 = strcmp(params, "food");
          }
#line 1048
          if (tmp___7 == 0) {
            {
#line 1049
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 1049
              curinv___2 = op->inv;
              {
#line 1049
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 1049
                next1049 = curinv___2;
#line 1049
                if ((unsigned long )next1049 == (unsigned long )((void *)0)) {
#line 1049
                  tmp___2 = (tag_t )0;
                } else {
#line 1049
                  tmp___2 = next1049->count;
                }
#line 1049
                next_tag1049 = tmp___2;
                {
#line 1049
                while (1) {
                  while_continue___10: /* CIL Label */ ;
#line 1049
                  curinv___2 = next1049;
#line 1049
                  if (! ((unsigned long )curinv___2 != (unsigned long )((void *)0))) {
#line 1049
                    goto while_break___10;
                  }
#line 1049
                  if (next1049->count != next_tag1049) {
#line 1049
                    goto while_break___10;
                  } else
#line 1049
                  if (next1049->flags[0] & (1U << 3)) {
#line 1049
                    goto while_break___10;
                  }
#line 1049
                  next1049 = next1049->below;
#line 1049
                  if ((unsigned long )next1049 == (unsigned long )((void *)0)) {
#line 1049
                    next_tag1049 = (tag_t )0;
                  } else {
#line 1049
                    next_tag1049 = next1049->count;
                  }
#line 1050
                  if (! (curinv___2->flags[2] & (1U << 22))) {
#line 1050
                    if ((int )curinv___2->type == 6) {
#line 1050
                      goto _L___2;
                    } else
#line 1050
                    if ((int )curinv___2->type == 54) {
                      _L___2: /* CIL Label */ 
                      {
#line 1052
                      drop(op, curinv___2);
                      }
#line 1053
                      if (op->contr) {
#line 1054
                        (op->contr)->count = (uint32 )count;
                      }
                    }
                  }
                }
                while_break___10: /* CIL Label */ ;
                }
#line 1049
                goto while_break___9;
              }
              while_break___9: /* CIL Label */ ;
              }
#line 1049
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
          } else {
            {
#line 1057
            tmp___6 = strcmp(params, "flesh");
            }
#line 1057
            if (tmp___6 == 0) {
              {
#line 1058
              while (1) {
                while_continue___11: /* CIL Label */ ;
#line 1058
                curinv___3 = op->inv;
                {
#line 1058
                while (1) {
                  while_continue___12: /* CIL Label */ ;
#line 1058
                  next1058 = curinv___3;
#line 1058
                  if ((unsigned long )next1058 == (unsigned long )((void *)0)) {
#line 1058
                    tmp___3 = (tag_t )0;
                  } else {
#line 1058
                    tmp___3 = next1058->count;
                  }
#line 1058
                  next_tag1058 = tmp___3;
                  {
#line 1058
                  while (1) {
                    while_continue___13: /* CIL Label */ ;
#line 1058
                    curinv___3 = next1058;
#line 1058
                    if (! ((unsigned long )curinv___3 != (unsigned long )((void *)0))) {
#line 1058
                      goto while_break___13;
                    }
#line 1058
                    if (next1058->count != next_tag1058) {
#line 1058
                      goto while_break___13;
                    } else
#line 1058
                    if (next1058->flags[0] & (1U << 3)) {
#line 1058
                      goto while_break___13;
                    }
#line 1058
                    next1058 = next1058->below;
#line 1058
                    if ((unsigned long )next1058 == (unsigned long )((void *)0)) {
#line 1058
                      next_tag1058 = (tag_t )0;
                    } else {
#line 1058
                      next_tag1058 = next1058->count;
                    }
#line 1059
                    if (! (curinv___3->flags[2] & (1U << 22))) {
#line 1059
                      if ((int )curinv___3->type == 72) {
                        {
#line 1061
                        drop(op, curinv___3);
                        }
#line 1062
                        if (op->contr) {
#line 1063
                          (op->contr)->count = (uint32 )count;
                        }
                      }
                    }
                  }
                  while_break___13: /* CIL Label */ ;
                  }
#line 1058
                  goto while_break___12;
                }
                while_break___12: /* CIL Label */ ;
                }
#line 1058
                goto while_break___11;
              }
              while_break___11: /* CIL Label */ ;
              }
            } else {
              {
#line 1066
              tmp___5 = strcmp(params, "misc");
              }
#line 1066
              if (tmp___5 == 0) {
                {
#line 1067
                while (1) {
                  while_continue___14: /* CIL Label */ ;
#line 1067
                  curinv___4 = op->inv;
                  {
#line 1067
                  while (1) {
                    while_continue___15: /* CIL Label */ ;
#line 1067
                    next1067 = curinv___4;
#line 1067
                    if ((unsigned long )next1067 == (unsigned long )((void *)0)) {
#line 1067
                      tmp___4 = (tag_t )0;
                    } else {
#line 1067
                      tmp___4 = next1067->count;
                    }
#line 1067
                    next_tag1067 = tmp___4;
                    {
#line 1067
                    while (1) {
                      while_continue___16: /* CIL Label */ ;
#line 1067
                      curinv___4 = next1067;
#line 1067
                      if (! ((unsigned long )curinv___4 != (unsigned long )((void *)0))) {
#line 1067
                        goto while_break___16;
                      }
#line 1067
                      if (next1067->count != next_tag1067) {
#line 1067
                        goto while_break___16;
                      } else
#line 1067
                      if (next1067->flags[0] & (1U << 3)) {
#line 1067
                        goto while_break___16;
                      }
#line 1067
                      next1067 = next1067->below;
#line 1067
                      if ((unsigned long )next1067 == (unsigned long )((void *)0)) {
#line 1067
                        next_tag1067 = (tag_t )0;
                      } else {
#line 1067
                        next_tag1067 = next1067->count;
                      }
#line 1068
                      if (! (curinv___4->flags[2] & (1U << 22))) {
#line 1068
                        if (! (curinv___4->flags[0] & (1U << 5))) {
                          {
#line 1085
                          if ((int )curinv___4->type == 5) {
#line 1085
                            goto case_5;
                          }
#line 1085
                          if ((int )curinv___4->type == 3) {
#line 1085
                            goto case_5;
                          }
#line 1085
                          if ((int )curinv___4->type == 109) {
#line 1085
                            goto case_5;
                          }
#line 1085
                          if ((int )curinv___4->type == 124) {
#line 1085
                            goto case_5;
                          }
#line 1085
                          if ((int )curinv___4->type == 123) {
#line 1085
                            goto case_5;
                          }
#line 1085
                          if ((int )curinv___4->type == 111) {
#line 1085
                            goto case_5;
                          }
#line 1085
                          if ((int )curinv___4->type == 104) {
#line 1085
                            goto case_5;
                          }
#line 1085
                          if ((int )curinv___4->type == 100) {
#line 1085
                            goto case_5;
                          }
#line 1085
                          if ((int )curinv___4->type == 99) {
#line 1085
                            goto case_5;
                          }
#line 1085
                          if ((int )curinv___4->type == 87) {
#line 1085
                            goto case_5;
                          }
#line 1085
                          if ((int )curinv___4->type == 70) {
#line 1085
                            goto case_5;
                          }
#line 1085
                          if ((int )curinv___4->type == 39) {
#line 1085
                            goto case_5;
                          }
#line 1085
                          if ((int )curinv___4->type == 113) {
#line 1085
                            goto case_5;
                          }
#line 1085
                          if ((int )curinv___4->type == 85) {
#line 1085
                            goto case_5;
                          }
#line 1085
                          if ((int )curinv___4->type == 8) {
#line 1085
                            goto case_5;
                          }
#line 1091
                          goto switch_default;
                          case_5: /* CIL Label */ 
                          case_3: /* CIL Label */ 
                          case_109: /* CIL Label */ 
                          case_124: /* CIL Label */ 
                          case_123: /* CIL Label */ 
                          case_111: /* CIL Label */ 
                          case_104: /* CIL Label */ 
                          case_100: /* CIL Label */ 
                          case_99: /* CIL Label */ 
                          case_87: /* CIL Label */ 
                          case_70: /* CIL Label */ 
                          case_39: /* CIL Label */ 
                          case_113: /* CIL Label */ 
                          case_85: /* CIL Label */ 
                          case_8: /* CIL Label */ 
                          {
#line 1086
                          drop(op, curinv___4);
                          }
#line 1087
                          if (op->contr) {
#line 1088
                            (op->contr)->count = (uint32 )count;
                          }
#line 1089
                          goto switch_break;
                          switch_default: /* CIL Label */ 
#line 1092
                          goto switch_break;
                          switch_break: /* CIL Label */ ;
                          }
                        }
                      }
                    }
                    while_break___16: /* CIL Label */ ;
                    }
#line 1067
                    goto while_break___15;
                  }
                  while_break___15: /* CIL Label */ ;
                  }
#line 1067
                  goto while_break___14;
                }
                while_break___14: /* CIL Label */ ;
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 1097
  (op->contr)->socket.update_look = (uint32 )1;
#line 1098
  op->flags[1] &= ~ (1U << 10);
#line 1100
  fix_object(op);
  }
#line 1102
  if ((int )op->type == 1) {
    {
#line 1103
    esrv_update_item(4, op, op);
    }
  }
#line 1104
  return;
}
}
#line 1114 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
void command_drop(object *op , char const   *params ) 
{ 
  int did_one ;
  int ival ;
  int missed ;
  object *tmp ;
  object *next1124 ;
  tag_t next_tag1124 ;
  tag_t tmp___0 ;

  {
#line 1115
  did_one = 0;
#line 1116
  ival = 0;
#line 1117
  missed = 0;
#line 1119
  if ((int const   )*params == 0) {
    {
#line 1120
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Drop what?");
    }
#line 1122
    return;
  } else {
    {
#line 1124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1124
      tmp = op->inv;
      {
#line 1124
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1124
        next1124 = tmp;
#line 1124
        if ((unsigned long )next1124 == (unsigned long )((void *)0)) {
#line 1124
          tmp___0 = (tag_t )0;
        } else {
#line 1124
          tmp___0 = next1124->count;
        }
#line 1124
        next_tag1124 = tmp___0;
        {
#line 1124
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1124
          tmp = next1124;
#line 1124
          if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 1124
            goto while_break___1;
          }
#line 1124
          if (next1124->count != next_tag1124) {
#line 1124
            goto while_break___1;
          } else
#line 1124
          if (next1124->flags[0] & (1U << 3)) {
#line 1124
            goto while_break___1;
          }
#line 1124
          next1124 = next1124->below;
#line 1124
          if ((unsigned long )next1124 == (unsigned long )((void *)0)) {
#line 1124
            next_tag1124 = (tag_t )0;
          } else {
#line 1124
            next_tag1124 = next1124->count;
          }
#line 1125
          if (tmp->flags[1] & (1U << 18)) {
#line 1126
            goto while_continue___1;
          } else
#line 1125
          if (tmp->invisible) {
#line 1126
            goto while_continue___1;
          }
          {
#line 1127
          ival = object_matches_string(op, tmp, params);
          }
#line 1128
          if (ival > 0) {
#line 1129
            if (tmp->flags[2] & (1U << 22)) {
#line 1129
              if (ival == 1) {
#line 1130
                missed ++;
              } else
#line 1129
              if (ival == 2) {
#line 1130
                missed ++;
              } else {
                {
#line 1132
                drop(op, tmp);
                }
              }
            } else {
              {
#line 1132
              drop(op, tmp);
              }
            }
#line 1133
            did_one = 1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1124
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1124
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1136
    if (! did_one) {
      {
#line 1137
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Nothing to drop.");
      }
    }
#line 1139
    if (missed == 1) {
      {
#line 1140
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "One item couldn\'t be dropped because it was locked.");
      }
    } else
#line 1142
    if (missed > 1) {
      {
#line 1143
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "%d items couldn\'t be dropped because they were locked.",
                           missed);
      }
    }
  }
#line 1147
  if ((int )op->type == 1) {
#line 1148
    (op->contr)->count = (uint32 )0;
  }
#line 1156
  return;
}
}
#line 1166 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
static void empty_container(object *container , object *pl ) 
{ 
  int left ;
  char name[256] ;
  object *inv ;
  object *next1173 ;
  tag_t next_tag1173 ;
  tag_t tmp ;
  object *next ;

  {
#line 1167
  left = 0;
#line 1170
  if (! container->inv) {
#line 1171
    return;
  }
  {
#line 1173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1173
    inv = container->inv;
    {
#line 1173
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1173
      next1173 = inv;
#line 1173
      if ((unsigned long )next1173 == (unsigned long )((void *)0)) {
#line 1173
        tmp = (tag_t )0;
      } else {
#line 1173
        tmp = next1173->count;
      }
#line 1173
      next_tag1173 = tmp;
      {
#line 1173
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1173
        inv = next1173;
#line 1173
        if (! ((unsigned long )inv != (unsigned long )((void *)0))) {
#line 1173
          goto while_break___1;
        }
#line 1173
        if (next1173->count != next_tag1173) {
#line 1173
          goto while_break___1;
        } else
#line 1173
        if (next1173->flags[0] & (1U << 3)) {
#line 1173
          goto while_break___1;
        }
#line 1173
        next1173 = next1173->below;
#line 1173
        if ((unsigned long )next1173 == (unsigned long )((void *)0)) {
#line 1173
          next_tag1173 = (tag_t )0;
        } else {
#line 1173
          next_tag1173 = next1173->count;
        }
#line 1176
        if (inv->flags[2] & (1U << 22)) {
#line 1178
          left ++;
#line 1179
          goto while_continue___1;
        }
        {
#line 1181
        next = inv->below;
#line 1182
        drop(pl, inv);
        }
#line 1183
        if ((unsigned long )inv->below == (unsigned long )next) {
#line 1185
          left ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1173
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1173
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1187
  esrv_update_item(4, pl, container);
#line 1189
  query_name((object const   *)container, name, sizeof(name));
  }
#line 1190
  if (left) {
    {
#line 1191
    draw_ext_info_format(256, 0, (object const   *)pl, (uint8 )10, (uint8 )12, "You empty the %s except %d items.",
                         name, left);
    }
  } else {
    {
#line 1193
    draw_ext_info_format(256, 0, (object const   *)pl, (uint8 )10, (uint8 )12, "You empty the %s.",
                         name);
    }
  }
#line 1194
  return;
}
}
#line 1204 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
void command_empty(object *op , char const   *params ) 
{ 
  object *container ;
  object *inv ;
  object *next1214 ;
  tag_t next_tag1214 ;
  tag_t tmp ;
  int tmp___0 ;

  {
#line 1207
  if ((int const   )*params == 0) {
    {
#line 1208
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Empty what?");
    }
#line 1210
    return;
  }
  {
#line 1213
  tmp___0 = strcmp(params, "all");
  }
#line 1213
  if (tmp___0 == 0) {
    {
#line 1214
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1214
      inv = op->inv;
      {
#line 1214
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1214
        next1214 = inv;
#line 1214
        if ((unsigned long )next1214 == (unsigned long )((void *)0)) {
#line 1214
          tmp = (tag_t )0;
        } else {
#line 1214
          tmp = next1214->count;
        }
#line 1214
        next_tag1214 = tmp;
        {
#line 1214
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1214
          inv = next1214;
#line 1214
          if (! ((unsigned long )inv != (unsigned long )((void *)0))) {
#line 1214
            goto while_break___1;
          }
#line 1214
          if (next1214->count != next_tag1214) {
#line 1214
            goto while_break___1;
          } else
#line 1214
          if (next1214->flags[0] & (1U << 3)) {
#line 1214
            goto while_break___1;
          }
#line 1214
          next1214 = next1214->below;
#line 1214
          if ((unsigned long )next1214 == (unsigned long )((void *)0)) {
#line 1214
            next_tag1214 = (tag_t )0;
          } else {
#line 1214
            next_tag1214 = next1214->count;
          }
#line 1215
          if ((int )inv->type == 122) {
            {
#line 1216
            empty_container(inv, op);
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1214
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1214
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1218
    return;
  }
  {
#line 1221
  container = find_best_object_match(op, params);
  }
#line 1222
  if (! container) {
    {
#line 1223
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "No such item.");
    }
#line 1225
    return;
  }
#line 1227
  if ((int )container->type != 122) {
    {
#line 1228
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "This is not a container!");
    }
#line 1230
    return;
  }
  {
#line 1232
  empty_container(container, op);
  }
#line 1233
  return;
}
}
#line 1243 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
void command_examine(object *op , char const   *params ) 
{ 
  object *tmp ;
  object *next1245 ;
  tag_t next_tag1245 ;
  tag_t tmp___0 ;
  object *tmp___1 ;
  object *tmp___2 ;

  {
#line 1244
  if ((int const   )*params == 0) {
    {
#line 1245
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1245
      tmp = op->below;
      {
#line 1245
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1245
        next1245 = tmp;
#line 1245
        if ((unsigned long )next1245 == (unsigned long )((void *)0)) {
#line 1245
          tmp___0 = (tag_t )0;
        } else {
#line 1245
          tmp___0 = next1245->count;
        }
#line 1245
        next_tag1245 = tmp___0;
        {
#line 1245
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1245
          tmp = next1245;
#line 1245
          if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 1245
            goto while_break___1;
          }
#line 1245
          if (next1245->count != next_tag1245) {
#line 1245
            goto while_break___1;
          } else
#line 1245
          if (next1245->flags[0] & (1U << 3)) {
#line 1245
            goto while_break___1;
          }
#line 1245
          next1245 = next1245->below;
#line 1245
          if ((unsigned long )next1245 == (unsigned long )((void *)0)) {
#line 1245
            next_tag1245 = (tag_t )0;
          } else {
#line 1245
            next_tag1245 = next1245->count;
          }
#line 1246
          if (! tmp->invisible) {
#line 1246
            if ((int )tmp->type != 1) {
#line 1246
              if ((int )tmp->type != 116) {
                {
#line 1247
                examine(op, tmp);
                }
#line 1248
                goto while_break___1;
              }
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1245
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1245
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1252
    tmp___2 = find_best_object_match(op, params);
#line 1252
    tmp___1 = tmp___2;
    }
#line 1254
    if (tmp___1) {
      {
#line 1255
      examine(op, tmp___1);
      }
    } else {
      {
#line 1257
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Could not find an object that matches %s",
                           params);
      }
    }
  }
#line 1261
  return;
}
}
#line 1274 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
object *find_marked_object(object *op ) 
{ 
  object *tmp ;
  object *next1282 ;
  tag_t next_tag1282 ;
  tag_t tmp___0 ;

  {
#line 1275
  if (! op) {
#line 1276
    return ((object *)((void *)0));
  } else
#line 1275
  if (! op->contr) {
#line 1276
    return ((object *)((void *)0));
  } else
#line 1275
  if (! (op->contr)->mark) {
#line 1276
    return ((object *)((void *)0));
  }
  {
#line 1282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1282
    tmp = op->inv;
    {
#line 1282
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1282
      next1282 = tmp;
#line 1282
      if ((unsigned long )next1282 == (unsigned long )((void *)0)) {
#line 1282
        tmp___0 = (tag_t )0;
      } else {
#line 1282
        tmp___0 = next1282->count;
      }
#line 1282
      next_tag1282 = tmp___0;
      {
#line 1282
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1282
        tmp = next1282;
#line 1282
        if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 1282
          goto while_break___1;
        }
#line 1282
        if (next1282->count != next_tag1282) {
#line 1282
          goto while_break___1;
        } else
#line 1282
        if (next1282->flags[0] & (1U << 3)) {
#line 1282
          goto while_break___1;
        }
#line 1282
        next1282 = next1282->below;
#line 1282
        if ((unsigned long )next1282 == (unsigned long )((void *)0)) {
#line 1282
          next_tag1282 = (tag_t )0;
        } else {
#line 1282
          next_tag1282 = next1282->count;
        }
#line 1283
        if (tmp->invisible) {
#line 1284
          goto while_continue___1;
        }
#line 1285
        if ((unsigned long )tmp == (unsigned long )(op->contr)->mark) {
#line 1286
          if (tmp->count == (op->contr)->mark_count) {
#line 1287
            return (tmp);
          } else {
#line 1289
            (op->contr)->mark = (object *)((void *)0);
#line 1290
            (op->contr)->mark_count = (uint32 )0;
#line 1291
            return ((object *)((void *)0));
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1282
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1282
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1295
  return ((object *)((void *)0));
}
}
#line 1307 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
void command_mark(object *op , char const   *params ) 
{ 
  char name[256] ;
  object *mark ;
  object *tmp ;
  object *mark1 ;
  object *tmp___0 ;

  {
#line 1310
  if (! op->contr) {
#line 1311
    return;
  }
#line 1312
  if ((int const   )*params == 0) {
    {
#line 1313
    tmp = find_marked_object(op);
#line 1313
    mark = tmp;
    }
#line 1314
    if (! mark) {
      {
#line 1315
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You have no marked object.");
      }
    } else {
      {
#line 1318
      query_name((object const   *)mark, name, (size_t )256);
#line 1319
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "%s is marked.",
                           name);
      }
    }
  } else {
    {
#line 1324
    tmp___0 = find_best_object_match(op, params);
#line 1324
    mark1 = tmp___0;
    }
#line 1326
    if (! mark1) {
      {
#line 1327
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Could not find an object that matches %s",
                           params);
      }
#line 1330
      return;
    } else {
      {
#line 1332
      (op->contr)->mark = mark1;
#line 1333
      (op->contr)->mark_count = mark1->count;
#line 1334
      query_name((object const   *)mark1, name, (size_t )256);
#line 1335
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "Marked item %s",
                           name);
      }
#line 1338
      return;
    }
  }
#line 1342
  return;
}
}
#line 1354 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
void examine_monster(object *op , object *tmp , int level ) 
{ 
  object *mon ;
  struct obj *tmp___0 ;
  object *probe___0 ;
  object *tmp___1 ;

  {
#line 1355
  if ((unsigned long )tmp->head != (unsigned long )((void *)0)) {
#line 1355
    tmp___0 = tmp->head;
  } else {
#line 1355
    tmp___0 = tmp;
  }
#line 1355
  mon = tmp___0;
#line 1357
  if (mon->flags[1] & (1U << 4)) {
    {
#line 1358
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )14, "It is an undead force.");
    }
  }
#line 1360
  if ((int )mon->level > (int )op->level) {
    {
#line 1361
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )14, "It is likely more powerful than you.");
    }
  } else
#line 1363
  if ((int )mon->level < (int )op->level) {
    {
#line 1364
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )14, "It is likely less powerful than you.");
    }
  } else {
    {
#line 1367
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )14, "It is probably as powerful as you.");
    }
  }
#line 1370
  if (mon->attacktype & 64U) {
    {
#line 1371
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )14, "You smell an acrid odor.");
    }
  }
  {
#line 1379
  if ((((int )mon->stats.hp + 1) * 4) / ((int )mon->stats.maxhp + 1) == 0) {
#line 1379
    goto case_0;
  }
#line 1384
  if ((((int )mon->stats.hp + 1) * 4) / ((int )mon->stats.maxhp + 1) == 1) {
#line 1384
    goto case_1;
  }
#line 1389
  if ((((int )mon->stats.hp + 1) * 4) / ((int )mon->stats.maxhp + 1) == 2) {
#line 1389
    goto case_2;
  }
#line 1394
  if ((((int )mon->stats.hp + 1) * 4) / ((int )mon->stats.maxhp + 1) == 3) {
#line 1394
    goto case_3;
  }
#line 1399
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1380
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )14, "It is critically wounded.");
  }
#line 1382
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1385
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )14, "It is in a bad shape.");
  }
#line 1387
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1390
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )14, "It is hurt.");
  }
#line 1392
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1395
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )14, "It is somewhat hurt.");
  }
#line 1397
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1400
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )14, "It is in excellent shape.");
  }
#line 1402
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1404
  tmp___1 = object_present_in_ob((uint8 )105, (object const   *)mon);
  }
#line 1404
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
    {
#line 1405
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )14, "It looks very ill.");
    }
  }
#line 1408
  if (level < 15) {
#line 1409
    return;
  }
  {
#line 1411
  probe___0 = object_find_by_type_and_name((object const   *)mon, 114, "probe_force");
  }
#line 1412
  if ((unsigned long )probe___0 != (unsigned long )((void *)0)) {
#line 1412
    if ((int )probe___0->level > level) {
#line 1413
      return;
    }
  }
#line 1415
  if ((unsigned long )probe___0 == (unsigned long )((void *)0)) {
    {
#line 1416
    probe___0 = create_archetype("force");
#line 1417
    free_string(probe___0->name);
#line 1418
    probe___0->name = add_string("probe_force");
#line 1419
    probe___0->flags[0] |= 1U << 5;
#line 1420
    probe___0->flags[0] |= 1U << 25;
#line 1421
    object_insert_in_ob(probe___0, mon);
#line 1422
    fix_object(mon);
    }
  }
#line 1424
  probe___0->level = (sint16 )level;
#line 1425
  if (level / 10 > (int )probe___0->duration) {
#line 1426
    probe___0->duration = (sint16 )(level / 10);
  }
#line 1427
  return;
}
}
#line 1438 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
void examine(object *op , object *tmp ) 
{ 
  char buf[1024] ;
  int in_shop ;
  int i ;
  int exp___0 ;
  int id_attempted ;
  char prefix[256] ;
  unsigned int tmp___0 ;
  typedata const   *tmptype ;
  object *skill ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char level[100] ;
  uint32 tmp___9 ;
  char const   *tmp___10 ;
  char *value ;
  StringBuffer *tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  StringBuffer *tmp___14 ;
  char const   *tmp___15 ;
  StringBuffer *tmp___16 ;
  char const   *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 1441
  exp___0 = 0;
#line 1445
  id_attempted = 0;
#line 1446
  prefix[0] = (char )'T';
#line 1446
  prefix[1] = (char )'h';
#line 1446
  prefix[2] = (char )'a';
#line 1446
  prefix[3] = (char )'t';
#line 1446
  prefix[4] = (char )' ';
#line 1446
  prefix[5] = (char )'i';
#line 1446
  prefix[6] = (char )'s';
#line 1446
  prefix[7] = (char )'\000';
#line 1446
  tmp___0 = 8U;
  {
#line 1446
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1446
    if (tmp___0 >= 256U) {
#line 1446
      goto while_break;
    }
#line 1446
    prefix[tmp___0] = (char)0;
#line 1446
    tmp___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1450
  buf[0] = (char )'\000';
#line 1452
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1453
    return;
  } else
#line 1452
  if ((int )tmp->type == 121) {
#line 1453
    return;
  }
  {
#line 1454
  tmptype = get_typedata((int )tmp->type);
  }
#line 1455
  if (! tmptype) {
    {
#line 1456
    LOG((LogLevel )0, "Attempted to examine item %d with type %d, which is invalid",
        tmp->count, (int )tmp->type);
    }
#line 1457
    return;
  }
#line 1460
  if (! (tmp->flags[0] & (1U << 29))) {
    {
#line 1462
    skill = find_skill_by_number(op, 11);
    }
#line 1463
    if (skill) {
      {
#line 1463
      tmp___2 = object_can_pick((object const   *)op, (object const   *)tmp);
      }
#line 1463
      if (tmp___2) {
        {
#line 1464
        exp___0 = detect_magic_on_item(op, tmp, skill);
        }
#line 1465
        if (exp___0) {
          {
#line 1466
          change_exp(op, (sint64 )exp___0, skill->skill, 3);
          }
#line 1467
          if (tmp->nrof <= 1U) {
#line 1467
            tmp___1 = "that item";
          } else {
#line 1467
            tmp___1 = "those items";
          }
          {
#line 1467
          draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )14,
                               "You discover mystic forces on %s", tmp___1);
          }
        }
      }
    }
    {
#line 1471
    skill = find_skill_by_number(op, 14);
    }
#line 1473
    if (skill) {
      {
#line 1473
      tmp___4 = object_can_pick((object const   *)op, (object const   *)tmp);
      }
#line 1473
      if (tmp___4) {
#line 1473
        goto _L;
      } else
#line 1473
      if (tmp->flags[2] & (1U << 30)) {
        _L: /* CIL Label */ 
        {
#line 1474
        exp___0 = detect_curse_on_item(op, tmp, skill);
        }
#line 1475
        if (exp___0) {
          {
#line 1476
          change_exp(op, (sint64 )exp___0, skill->skill, 3);
          }
#line 1477
          if (tmp->nrof <= 1U) {
#line 1477
            tmp___3 = "that item";
          } else {
#line 1477
            tmp___3 = "those items";
          }
          {
#line 1477
          draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )14,
                               "You have a bad feeling about %s", tmp___3);
          }
        }
      }
    }
#line 1481
    if (! (tmp->flags[2] & (1U << 27))) {
      {
#line 1483
      id_attempted = 1;
#line 1484
      skill = find_skill_by_number(op, (int )tmptype->identifyskill);
      }
#line 1485
      if (skill) {
        {
#line 1486
        id_attempted = 2;
#line 1497
        exp___0 = identify_object_with_skill(tmp, op, skill, 1);
        }
#line 1498
        if (exp___0) {
          {
#line 1499
          change_exp(op, (sint64 )exp___0, skill->skill, 3);
          }
#line 1500
          return;
        }
      }
#line 1503
      if (! exp___0) {
        {
#line 1505
        skill = find_skill_by_number(op, (int )tmptype->identifyskill2);
        }
#line 1506
        if (skill) {
          {
#line 1511
          tmp->flags[2] &= ~ (1U << 27);
#line 1512
          id_attempted = 2;
#line 1513
          exp___0 = identify_object_with_skill(tmp, op, skill, 1);
          }
#line 1514
          if (exp___0) {
            {
#line 1515
            change_exp(op, (sint64 )exp___0, skill->skill, 3);
            }
#line 1516
            return;
          }
        }
      }
    }
  }
#line 1522
  if (! exp___0) {
#line 1524
    if (tmptype->identifyskill) {
#line 1524
      goto _L___0;
    } else
#line 1524
    if (tmptype->identifyskill2) {
      _L___0: /* CIL Label */ 
      {
#line 1526
      if (id_attempted == 1) {
#line 1526
        goto case_1;
      }
#line 1529
      if (id_attempted == 2) {
#line 1529
        goto case_2;
      }
#line 1532
      goto switch_default;
      case_1: /* CIL Label */ 
#line 1527
      if (tmp->nrof <= 1U) {
#line 1527
        tmp___5 = "that fully; it is";
      } else {
#line 1527
        tmp___5 = "those fully, they are";
      }
      {
#line 1527
      snprintf((char */* __restrict  */)(prefix), (size_t )256, (char const   */* __restrict  */)"You lack the skill to understand %s:",
               tmp___5);
      }
#line 1528
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1530
      if (tmp->nrof <= 1U) {
#line 1530
        tmp___6 = "that fully; it is";
      } else {
#line 1530
        tmp___6 = "those fully, they are";
      }
      {
#line 1530
      snprintf((char */* __restrict  */)(prefix), (size_t )256, (char const   */* __restrict  */)"You fail to understand %s:",
               tmp___6);
      }
#line 1531
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1533
      if (tmp->nrof <= 1U) {
#line 1533
        tmp___7 = "That is";
      } else {
#line 1533
        tmp___7 = "Those are";
      }
      {
#line 1533
      snprintf((char */* __restrict  */)(prefix), (size_t )256, (char const   */* __restrict  */)"%s:",
               tmp___7);
      }
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 1535
      if (tmp->nrof <= 1U) {
#line 1535
        tmp___8 = "That is";
      } else {
#line 1535
        tmp___8 = "Those are";
      }
      {
#line 1535
      snprintf((char */* __restrict  */)(prefix), (size_t )256, (char const   */* __restrict  */)"%s:",
               tmp___8);
      }
    }
  }
  {
#line 1538
  ob_describe((object const   *)tmp, (object const   *)op, buf, sizeof(buf));
#line 1540
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )14, "%s %s",
                       prefix, buf);
#line 1542
  buf[0] = (char )'\000';
  }
#line 1543
  if (tmp->custom_name) {
    {
#line 1544
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )14, "You name it %s",
                         tmp->custom_name);
    }
  }
  {
#line 1550
  if ((int )tmp->type == 85) {
#line 1550
    goto case_85;
  }
#line 1559
  if ((int )tmp->type == 8) {
#line 1559
    goto case_8;
  }
#line 1564
  if ((int )tmp->type == 122) {
#line 1564
    goto case_122;
  }
#line 1575
  if ((int )tmp->type == 109) {
#line 1575
    goto case_109;
  }
#line 1549
  goto switch_break___0;
  case_85: /* CIL Label */ 
#line 1551
  if (tmp->flags[0] & (1U << 29)) {
#line 1551
    if (tmp->inv) {
      {
#line 1554
      get_levelnumber((int )(tmp->inv)->level, level, (size_t )100);
#line 1555
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s is a %s level %s spell",
               (tmp->inv)->name, level, (tmp->inv)->skill);
      }
    }
  }
#line 1557
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 1560
  if ((unsigned long )tmp->msg != (unsigned long )((void *)0)) {
    {
#line 1561
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"Something is written in it.");
    }
  }
#line 1562
  goto switch_break___0;
  case_122: /* CIL Label */ 
#line 1565
  if ((unsigned long )tmp->race != (unsigned long )((void *)0)) {
#line 1566
    if (tmp->weight_limit) {
#line 1566
      if ((int )tmp->stats.Str < 100) {
        {
#line 1567
        snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"It can hold only %s and its weight limit is %.1f kg.",
                 tmp->race, (double )tmp->weight_limit / (10.0 * (double )(100 - (int )tmp->stats.Str)));
        }
      } else {
        {
#line 1569
        snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"It can hold only %s.",
                 tmp->race);
        }
      }
    } else {
      {
#line 1569
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"It can hold only %s.",
               tmp->race);
      }
    }
  } else
#line 1571
  if (tmp->weight_limit) {
#line 1571
    if ((int )tmp->stats.Str < 100) {
      {
#line 1572
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"Its weight limit is %.1f kg.",
               (double )tmp->weight_limit / (10.0 * (double )(100 - (int )tmp->stats.Str)));
      }
    }
  }
#line 1573
  goto switch_break___0;
  case_109: /* CIL Label */ 
#line 1576
  if (tmp->flags[0] & (1U << 29)) {
    {
#line 1577
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"It has %d charges left.",
             tmp->stats.food);
    }
  }
#line 1578
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1581
  if ((int )buf[0] != 0) {
    {
#line 1582
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )14, (char const   *)(buf));
    }
  }
#line 1585
  if ((unsigned long )tmp->materialname != (unsigned long )((void *)0)) {
#line 1585
    if (! tmp->msg) {
      {
#line 1586
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )14, "It is made of: %s.",
                           tmp->materialname);
      }
    }
  }
#line 1591
  i = 0;
  {
#line 1591
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1591
    if (! (i < 13)) {
#line 1591
      goto while_break___0;
    }
#line 1592
    if ((int )tmp->body_info[i] < -1) {
#line 1593
      if (op->body_info[i]) {
        {
#line 1594
        draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )14,
                             "It goes %s (%d)", body_locations[i].use_name, - ((int )tmp->body_info[i]));
        }
      } else {
        {
#line 1598
        draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )14,
                             "It goes %s", body_locations[i].nonuse_name);
        }
      }
    } else
#line 1601
    if (tmp->body_info[i]) {
#line 1602
      if (op->body_info[i]) {
        {
#line 1603
        draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )14,
                             "It goes %s", body_locations[i].use_name);
        }
      } else {
        {
#line 1607
        draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )14,
                             "It goes %s", body_locations[i].nonuse_name);
        }
      }
    }
#line 1591
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1613
  if (tmp->weight) {
#line 1614
    if (tmp->nrof) {
#line 1614
      tmp___9 = tmp->nrof;
    } else {
#line 1614
      tmp___9 = (uint32 )1;
    }
#line 1614
    if (tmp->nrof > 1U) {
#line 1614
      tmp___10 = "They weigh %3.3f kg.";
    } else {
#line 1614
      tmp___10 = "It weighs %3.3f kg.";
    }
    {
#line 1614
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)tmp___10,
             (double )tmp->weight * ((double )((float )tmp___9) / 1000.0));
#line 1615
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )14, (char const   *)(buf));
    }
  }
  {
#line 1619
  in_shop = is_in_shop(op);
  }
#line 1621
  if (tmp->value) {
#line 1621
    if (! (tmp->flags[1] & (1U << 2))) {
#line 1621
      if (! (tmp->flags[0] & (1U << 8))) {
        {
#line 1622
        tmp___11 = query_cost_string((object const   *)tmp, op, 33, (StringBuffer *)((void *)0));
#line 1622
        tmp___12 = stringbuffer_finish(tmp___11);
#line 1622
        value = tmp___12;
        }
#line 1623
        if (tmp->nrof > 1U) {
#line 1623
          tmp___13 = "they are";
        } else {
#line 1623
          tmp___13 = "it is";
        }
        {
#line 1623
        snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You reckon %s worth %s.",
                 tmp___13, value);
#line 1624
        free((void *)value);
#line 1625
        draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )14, (char const   *)(buf));
        }
#line 1627
        if (in_shop) {
#line 1628
          if (tmp->flags[0] & (1U << 6)) {
            {
#line 1629
            tmp___14 = query_cost_string((object const   *)tmp, op, 64, (StringBuffer *)((void *)0));
#line 1629
            value = stringbuffer_finish(tmp___14);
            }
#line 1630
            if (tmp->nrof > 1U) {
#line 1630
              tmp___15 = "They";
            } else {
#line 1630
              tmp___15 = "It";
            }
            {
#line 1630
            snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s would cost you %s.",
                     tmp___15, value);
#line 1631
            free((void *)value);
            }
          } else {
            {
#line 1633
            tmp___16 = query_cost_string((object const   *)tmp, op, 65, (StringBuffer *)((void *)0));
#line 1633
            value = stringbuffer_finish(tmp___16);
            }
#line 1634
            if (tmp->nrof > 1U) {
#line 1634
              tmp___17 = "them";
            } else {
#line 1634
              tmp___17 = "it";
            }
            {
#line 1634
            snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You are offered %s for %s.",
                     value, tmp___17);
#line 1635
            free((void *)value);
            }
          }
          {
#line 1637
          draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )14, (char const   *)(buf));
          }
        }
      }
    }
  }
#line 1642
  if (tmp->flags[0] & (1U << 14)) {
    {
#line 1643
    examine_monster(op, tmp, 0);
    }
  }
#line 1646
  if (tmp->flags[3] & (1U << 14)) {
    {
#line 1647
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )14, "This is a buildable item.");
    }
  }
#line 1653
  if (tmp->msg) {
#line 1653
    if ((int )tmp->type != 66) {
#line 1653
      if ((int )tmp->type != 8) {
#line 1653
        if ((int )tmp->type != 157) {
#line 1653
          if (! tmp->move_on) {
            {
#line 1653
            tmp___19 = strncasecmp(tmp->msg, "@match", (size_t )6);
            }
#line 1653
            if (tmp___19) {
              {
#line 1662
              tmp___18 = need_identify((object const   *)tmp);
              }
#line 1662
              if (tmp___18) {
#line 1662
                if (tmp->flags[0] & (1U << 29)) {
                  {
#line 1663
                  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )14,
                                "The object has a story:");
                  }
                }
              }
              {
#line 1666
              draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )14,
                            tmp->msg);
              }
            }
          }
        }
      }
    }
  }
  {
#line 1669
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )14, " ");
#line 1672
  knowledge_item_can_be_used_alchemy(op, (object const   *)tmp);
  }
#line 1673
  return;
}
}
#line 1683 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
void inventory(object *op , object *inv ) 
{ 
  char const   *in ;
  int items ;
  int length ;
  char weight[256] ;
  char name[256] ;
  object *tmp ;
  object *tmp___0 ;
  object *next1693 ;
  tag_t next_tag1693 ;
  tag_t tmp___1 ;
  object *tmp___2 ;
  object *tmp___3 ;
  object *next1717 ;
  tag_t next_tag1717 ;
  tag_t tmp___4 ;

  {
#line 1685
  items = 0;
#line 1688
  if ((unsigned long )inv == (unsigned long )((void *)0)) {
#line 1688
    if ((unsigned long )op == (unsigned long )((void *)0)) {
      {
#line 1689
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Inventory of what object?");
      }
#line 1691
      return;
    }
  }
  {
#line 1693
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1693
    if (inv) {
#line 1693
      tmp___0 = inv;
    } else {
#line 1693
      tmp___0 = op;
    }
#line 1693
    tmp = tmp___0->inv;
    {
#line 1693
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1693
      next1693 = tmp;
#line 1693
      if ((unsigned long )next1693 == (unsigned long )((void *)0)) {
#line 1693
        tmp___1 = (tag_t )0;
      } else {
#line 1693
        tmp___1 = next1693->count;
      }
#line 1693
      next_tag1693 = tmp___1;
      {
#line 1693
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1693
        tmp = next1693;
#line 1693
        if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 1693
          goto while_break___1;
        }
#line 1693
        if (next1693->count != next_tag1693) {
#line 1693
          goto while_break___1;
        } else
#line 1693
        if (next1693->flags[0] & (1U << 3)) {
#line 1693
          goto while_break___1;
        }
#line 1693
        next1693 = next1693->below;
#line 1693
        if ((unsigned long )next1693 == (unsigned long )((void *)0)) {
#line 1693
          next_tag1693 = (tag_t )0;
        } else {
#line 1693
          next_tag1693 = next1693->count;
        }
#line 1694
        if (! tmp->invisible) {
#line 1694
          if ((unsigned long )inv == (unsigned long )((void *)0)) {
#line 1696
            items ++;
          } else
#line 1694
          if ((int )inv->type == 122) {
#line 1696
            items ++;
          } else
#line 1694
          if (tmp->flags[0] & (1U << 5)) {
#line 1696
            items ++;
          } else {
#line 1694
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 1694
        if (! op) {
#line 1696
          items ++;
        } else
#line 1694
        if (op->flags[0] & (1U << 1)) {
#line 1696
          items ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1693
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1693
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1698
  if ((unsigned long )inv == (unsigned long )((void *)0)) {
#line 1699
    if (items == 0) {
      {
#line 1700
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "You carry nothing.");
      }
#line 1702
      return;
    } else {
      {
#line 1704
      length = 28;
#line 1705
      in = "";
#line 1706
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )15, "Inventory:");
      }
    }
  } else
#line 1710
  if (items == 0) {
#line 1711
    return;
  } else {
#line 1713
    length = 28;
#line 1714
    in = "  ";
  }
  {
#line 1717
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1717
    if (inv) {
#line 1717
      tmp___3 = inv;
    } else {
#line 1717
      tmp___3 = op;
    }
#line 1717
    tmp___2 = tmp___3->inv;
    {
#line 1717
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1717
      next1717 = tmp___2;
#line 1717
      if ((unsigned long )next1717 == (unsigned long )((void *)0)) {
#line 1717
        tmp___4 = (tag_t )0;
      } else {
#line 1717
        tmp___4 = next1717->count;
      }
#line 1717
      next_tag1717 = tmp___4;
      {
#line 1717
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1717
        tmp___2 = next1717;
#line 1717
        if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 1717
          goto while_break___4;
        }
#line 1717
        if (next1717->count != next_tag1717) {
#line 1717
          goto while_break___4;
        } else
#line 1717
        if (next1717->flags[0] & (1U << 3)) {
#line 1717
          goto while_break___4;
        }
#line 1717
        next1717 = next1717->below;
#line 1717
        if ((unsigned long )next1717 == (unsigned long )((void *)0)) {
#line 1717
          next_tag1717 = (tag_t )0;
        } else {
#line 1717
          next_tag1717 = next1717->count;
        }
#line 1718
        if (! op) {
#line 1718
          goto _L___0;
        } else
#line 1718
        if (! (op->flags[0] & (1U << 1))) {
          _L___0: /* CIL Label */ 
#line 1718
          if (tmp___2->invisible) {
#line 1720
            goto while_continue___4;
          } else
#line 1718
          if (inv) {
#line 1718
            if ((int )inv->type != 122) {
#line 1718
              if (! (tmp___2->flags[0] & (1U << 5))) {
#line 1720
                goto while_continue___4;
              }
            }
          }
        }
        {
#line 1721
        query_weight((object const   *)tmp___2, weight, (size_t )256);
#line 1722
        query_name((object const   *)tmp___2, name, (size_t )256);
        }
#line 1723
        if (! op) {
          {
#line 1724
          draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )15,
                               "[fixed]%s- %-*.*s (%5d) %-8s", in, length, length,
                               name, tmp___2->count, weight);
          }
        } else
#line 1723
        if (op->flags[0] & (1U << 1)) {
          {
#line 1724
          draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )15,
                               "[fixed]%s- %-*.*s (%5d) %-8s", in, length, length,
                               name, tmp___2->count, weight);
          }
        } else {
          {
#line 1728
          draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )15,
                               "[fixed]%s- %-*.*s %-8s", in, length + 8, length + 8,
                               name, weight);
          }
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1717
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1717
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1732
  if (! inv) {
#line 1732
    if (op) {
      {
#line 1733
      query_weight((object const   *)op, weight, (size_t )256);
#line 1734
      draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )15, "[fixed]%-*s %-8s",
                           41, "Total weight :", weight);
      }
    }
  }
#line 1738
  return;
}
}
#line 1746 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
static void display_new_pickup(object const   *op ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;

  {
  {
#line 1747
  i = (int )(op->contr)->mode;
#line 1749
  esrv_send_pickup((player *)op->contr);
  }
#line 1751
  if (! ((unsigned int )i & 2147483648U)) {
#line 1752
    return;
  } else
#line 1751
  if (! (i & 268435456)) {
#line 1752
    return;
  }
#line 1754
  if ((unsigned int )i & 2147483648U) {
#line 1754
    tmp = 1;
  } else {
#line 1754
    tmp = 0;
  }
  {
#line 1754
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d NEWMODE", tmp);
  }
#line 1757
  if (i & 268435456) {
#line 1757
    tmp___0 = 1;
  } else {
#line 1757
    tmp___0 = 0;
  }
  {
#line 1757
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d DEBUG", tmp___0);
  }
#line 1760
  if (i & 536870912) {
#line 1760
    tmp___1 = 1;
  } else {
#line 1760
    tmp___1 = 0;
  }
  {
#line 1760
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d INHIBIT", tmp___1);
  }
#line 1763
  if (i & 1073741824) {
#line 1763
    tmp___2 = 1;
  } else {
#line 1763
    tmp___2 = 0;
  }
  {
#line 1763
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d STOP", tmp___2);
#line 1767
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d <= x pickup weight/value RATIO (0==off)",
                       (i & 15) * 5);
  }
#line 1771
  if (i & 16) {
#line 1771
    tmp___3 = 1;
  } else {
#line 1771
    tmp___3 = 0;
  }
  {
#line 1771
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d FOOD", tmp___3);
  }
#line 1774
  if (i & 32) {
#line 1774
    tmp___4 = 1;
  } else {
#line 1774
    tmp___4 = 0;
  }
  {
#line 1774
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d DRINK", tmp___4);
  }
#line 1777
  if (i & 64) {
#line 1777
    tmp___5 = 1;
  } else {
#line 1777
    tmp___5 = 0;
  }
  {
#line 1777
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d VALUABLES", tmp___5);
  }
#line 1781
  if (i & 128) {
#line 1781
    tmp___6 = 1;
  } else {
#line 1781
    tmp___6 = 0;
  }
  {
#line 1781
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d BOW", tmp___6);
  }
#line 1784
  if (i & 256) {
#line 1784
    tmp___7 = 1;
  } else {
#line 1784
    tmp___7 = 0;
  }
  {
#line 1784
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d ARROW", tmp___7);
  }
#line 1788
  if (i & 512) {
#line 1788
    tmp___8 = 1;
  } else {
#line 1788
    tmp___8 = 0;
  }
  {
#line 1788
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d HELMET", tmp___8);
  }
#line 1791
  if (i & 1024) {
#line 1791
    tmp___9 = 1;
  } else {
#line 1791
    tmp___9 = 0;
  }
  {
#line 1791
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d SHIELD", tmp___9);
  }
#line 1794
  if (i & 2048) {
#line 1794
    tmp___10 = 1;
  } else {
#line 1794
    tmp___10 = 0;
  }
  {
#line 1794
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d ARMOUR", tmp___10);
  }
#line 1798
  if (i & 4096) {
#line 1798
    tmp___11 = 1;
  } else {
#line 1798
    tmp___11 = 0;
  }
  {
#line 1798
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d BOOTS", tmp___11);
  }
#line 1801
  if (i & 8192) {
#line 1801
    tmp___12 = 1;
  } else {
#line 1801
    tmp___12 = 0;
  }
  {
#line 1801
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d GLOVES", tmp___12);
  }
#line 1804
  if (i & 16384) {
#line 1804
    tmp___13 = 1;
  } else {
#line 1804
    tmp___13 = 0;
  }
  {
#line 1804
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d CLOAK", tmp___13);
  }
#line 1807
  if (i & 32768) {
#line 1807
    tmp___14 = 1;
  } else {
#line 1807
    tmp___14 = 0;
  }
  {
#line 1807
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d KEY", tmp___14);
  }
#line 1811
  if (i & 65536) {
#line 1811
    tmp___15 = 1;
  } else {
#line 1811
    tmp___15 = 0;
  }
  {
#line 1811
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d MISSILEWEAPON", tmp___15);
  }
#line 1814
  if (i & 131072) {
#line 1814
    tmp___16 = 1;
  } else {
#line 1814
    tmp___16 = 0;
  }
  {
#line 1814
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d MELEEWEAPON", tmp___16);
  }
#line 1817
  if (i & 262144) {
#line 1817
    tmp___17 = 1;
  } else {
#line 1817
    tmp___17 = 0;
  }
  {
#line 1817
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d MAGICAL", tmp___17);
  }
#line 1820
  if (i & 524288) {
#line 1820
    tmp___18 = 1;
  } else {
#line 1820
    tmp___18 = 0;
  }
  {
#line 1820
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d POTION", tmp___18);
  }
#line 1824
  if (i & 1048576) {
#line 1824
    tmp___19 = 1;
  } else {
#line 1824
    tmp___19 = 0;
  }
  {
#line 1824
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d SPELLBOOK", tmp___19);
  }
#line 1827
  if (i & 2097152) {
#line 1827
    tmp___20 = 1;
  } else {
#line 1827
    tmp___20 = 0;
  }
  {
#line 1827
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d SKILLSCROLL", tmp___20);
  }
#line 1830
  if (i & 4194304) {
#line 1830
    tmp___21 = 1;
  } else {
#line 1830
    tmp___21 = 0;
  }
  {
#line 1830
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d READABLES", tmp___21);
  }
#line 1833
  if (i & 8388608) {
#line 1833
    tmp___22 = 1;
  } else {
#line 1833
    tmp___22 = 0;
  }
  {
#line 1833
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d MAGICDEVICE", tmp___22);
  }
#line 1837
  if (i & 16777216) {
#line 1837
    tmp___23 = 1;
  } else {
#line 1837
    tmp___23 = 0;
  }
  {
#line 1837
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d NOT CURSED", tmp___23);
  }
#line 1841
  if (i & 33554432) {
#line 1841
    tmp___24 = 1;
  } else {
#line 1841
    tmp___24 = 0;
  }
  {
#line 1841
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d JEWELS", tmp___24);
  }
#line 1845
  if (i & 67108864) {
#line 1845
    tmp___25 = 1;
  } else {
#line 1845
    tmp___25 = 0;
  }
  {
#line 1845
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d FLESH", tmp___25);
  }
#line 1849
  if (i & 134217728) {
#line 1849
    tmp___26 = 1;
  } else {
#line 1849
    tmp___26 = 0;
  }
  {
#line 1849
  draw_ext_info_format(256, 0, op, (uint8 )10, (uint8 )8, "%d CONTAINER", tmp___26);
#line 1853
  draw_ext_info(256, 0, op, (uint8 )10, (uint8 )8, "");
  }
#line 1855
  return;
}
}
#line 1868 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
static char const   *names[28]  = 
#line 1868
  {      "debug",      "inhibit",      "stop",      "food", 
        "drink",      "valuables",      "bow",      "arrow", 
        "helmet",      "shield",      "armour",      "boots", 
        "gloves",      "cloak",      "key",      "missile", 
        "melee",      "magical",      "potion",      "spellbook", 
        "skillscroll",      "readables",      "magicdevice",      "notcursed", 
        "jewels",      "flesh",      "container",      (char const   *)((void *)0)};
#line 1876 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
static uint32 const   modes[28]  = 
#line 1876
  {      (uint32 const   )268435456,      (uint32 const   )536870912,      (uint32 const   )1073741824,      (uint32 const   )16, 
        (uint32 const   )32,      (uint32 const   )64,      (uint32 const   )128,      (uint32 const   )256, 
        (uint32 const   )512,      (uint32 const   )1024,      (uint32 const   )2048,      (uint32 const   )4096, 
        (uint32 const   )8192,      (uint32 const   )16384,      (uint32 const   )32768,      (uint32 const   )65536, 
        (uint32 const   )131072,      (uint32 const   )262144,      (uint32 const   )524288,      (uint32 const   )1048576, 
        (uint32 const   )2097152,      (uint32 const   )4194304,      (uint32 const   )8388608,      (uint32 const   )16777216, 
        (uint32 const   )33554432,      (uint32 const   )67108864,      (uint32 const   )134217728,      (uint32 const   )0};
#line 1866 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
void command_pickup(object *op , char const   *params ) 
{ 
  uint32 i ;
  uint32 tmp ;
  int mode ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1883
  if ((int const   )*params == 0) {
#line 1885
    if ((op->contr)->mode & 2147483648U) {
      {
#line 1886
      display_new_pickup((object const   *)op);
      }
#line 1887
      return;
    }
    {
#line 1890
    LOG((LogLevel )2, "command_pickup: !params\n");
    }
#line 1891
    if ((op->contr)->mode > 6U) {
#line 1891
      tmp = (uint32 )0;
    } else {
#line 1891
      tmp = (op->contr)->mode + 1U;
    }
    {
#line 1891
    set_pickup_mode((object const   *)op, (int )tmp);
    }
#line 1892
    return;
  }
  {
#line 1895
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1895
    if (! ((int const   )*params == 32)) {
#line 1895
      goto while_break;
    }
#line 1896
    params ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1898
  if ((int const   )*params == 43) {
#line 1898
    goto _L;
  } else
#line 1898
  if ((int const   )*params == 45) {
#line 1898
    goto _L;
  } else
#line 1898
  if ((int const   )*params == 33) {
    _L: /* CIL Label */ 
#line 1901
    mode = 0;
    {
#line 1901
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1901
      if (! names[mode]) {
#line 1901
        goto while_break___0;
      }
      {
#line 1902
      tmp___0 = strcmp(names[mode], params + 1);
      }
#line 1902
      if (! tmp___0) {
#line 1903
        i = (op->contr)->mode;
#line 1904
        if (! (i & 2147483648U)) {
#line 1905
          i = 2147483648U;
        }
#line 1906
        if ((int const   )*params == 43) {
#line 1907
          i |= (unsigned int )modes[mode];
        } else
#line 1908
        if ((int const   )*params == 45) {
#line 1909
          i &= (unsigned int )(~ modes[mode]);
        } else
#line 1911
        if (i & (unsigned int )modes[mode]) {
#line 1912
          i &= (unsigned int )(~ modes[mode]);
        } else {
#line 1914
          i |= (unsigned int )modes[mode];
        }
        {
#line 1916
        (op->contr)->mode = i;
#line 1917
        display_new_pickup((object const   *)op);
        }
#line 1918
        return;
      }
#line 1901
      mode ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1921
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Pickup: invalid item %s\n",
                         params);
    }
#line 1924
    return;
  }
  {
#line 1927
  tmp___1 = sscanf((char const   */* __restrict  */)params, (char const   */* __restrict  */)"%u",
                   & i);
  }
#line 1927
  if (tmp___1 != 1) {
    {
#line 1929
    LOG((LogLevel )2, "command_pickup: params==NULL\n");
#line 1930
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Usage: pickup <0-7> or <value_density> .");
    }
#line 1932
    return;
  }
  {
#line 1934
  set_pickup_mode((object const   *)op, (int )i);
#line 1935
  display_new_pickup((object const   *)op);
  }
#line 1936
  return;
}
}
#line 1946 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
static void set_pickup_mode(object const   *op , int i ) 
{ 


  {
#line 1947
  (op->contr)->mode = (uint32 )i;
  {
#line 1949
  if ((op->contr)->mode == 0U) {
#line 1949
    goto case_0;
  }
#line 1954
  if ((op->contr)->mode == 1U) {
#line 1954
    goto case_1;
  }
#line 1959
  if ((op->contr)->mode == 2U) {
#line 1959
    goto case_2;
  }
#line 1964
  if ((op->contr)->mode == 3U) {
#line 1964
    goto case_3;
  }
#line 1969
  if ((op->contr)->mode == 4U) {
#line 1969
    goto case_4;
  }
#line 1974
  if ((op->contr)->mode == 5U) {
#line 1974
    goto case_5;
  }
#line 1979
  if ((op->contr)->mode == 6U) {
#line 1979
    goto case_6;
  }
#line 1984
  if ((op->contr)->mode == 7U) {
#line 1984
    goto case_7;
  }
#line 1948
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1950
  draw_ext_info(256, 0, op, (uint8 )10, (uint8 )12, "Mode: Don\'t pick up.");
  }
#line 1952
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1955
  draw_ext_info(256, 0, op, (uint8 )10, (uint8 )12, "Mode: Pick up one item.");
  }
#line 1957
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1960
  draw_ext_info(256, 0, op, (uint8 )10, (uint8 )12, "Mode: Pick up one item and stop.");
  }
#line 1962
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1965
  draw_ext_info(256, 0, op, (uint8 )10, (uint8 )12, "Mode: Stop before picking up.");
  }
#line 1967
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1970
  draw_ext_info(256, 0, op, (uint8 )10, (uint8 )12, "Mode: Pick up all items.");
  }
#line 1972
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1975
  draw_ext_info(256, 0, op, (uint8 )10, (uint8 )12, "Mode: Pick up all items and stop.");
  }
#line 1977
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1980
  draw_ext_info(256, 0, op, (uint8 )10, (uint8 )12, "Mode: Pick up all magic items.");
  }
#line 1982
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1985
  draw_ext_info(256, 0, op, (uint8 )10, (uint8 )12, "Mode: Pick up all coins and gems");
  }
#line 1987
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1989
  return;
}
}
#line 1999 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
void command_search_items(object *op , char const   *params ) 
{ 
  size_t tmp ;

  {
#line 2000
  if ((int )settings.search_items == 0) {
#line 2001
    return;
  }
#line 2003
  if ((int const   )*params == 0) {
#line 2004
    if ((int )(op->contr)->search_str[0] == 0) {
      {
#line 2005
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "Example: search magic+1 Would automatically pick up all items containing the word \'magic+1\'.");
      }
#line 2009
      return;
    }
    {
#line 2011
    (op->contr)->search_str[0] = (char )'\000';
#line 2012
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "Search mode turned off.");
#line 2014
    fix_object(op);
    }
#line 2015
    return;
  }
  {
#line 2017
  tmp = strlen(params);
  }
#line 2017
  if ((int )tmp >= 256) {
    {
#line 2018
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Search string too long.");
    }
#line 2020
    return;
  }
  {
#line 2022
  strcpy((char */* __restrict  */)((op->contr)->search_str), (char const   */* __restrict  */)params);
#line 2023
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "Searching for \'%s\'.",
                       (op->contr)->search_str);
#line 2026
  fix_object(op);
  }
#line 2027
  return;
}
}
#line 2044 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
void command_rename_item(object *op , char const   *params ) 
{ 
  char buf[1024] ;
  char name[256] ;
  tag_t itemnumber ;
  object *item ;
  object *tmp ;
  char *closebrace ;
  size_t counter ;
  int tmp___0 ;
  int found ;
  object *item___0 ;
  object *next2061 ;
  tag_t next_tag2061 ;
  tag_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;

  {
#line 2047
  item = (object *)((void *)0);
#line 2052
  if ((int const   )*params != 0) {
    {
#line 2054
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2054
      if (! (32 == (int )*params)) {
#line 2054
        goto while_break;
      }
#line 2055
      params ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2058
    tmp___0 = atoi(params);
#line 2058
    itemnumber = (tag_t )tmp___0;
    }
#line 2059
    if (itemnumber != 0U) {
#line 2060
      found = 0;
      {
#line 2061
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2061
        item___0 = op->inv;
        {
#line 2061
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2061
          next2061 = item___0;
#line 2061
          if ((unsigned long )next2061 == (unsigned long )((void *)0)) {
#line 2061
            tmp___1 = (tag_t )0;
          } else {
#line 2061
            tmp___1 = next2061->count;
          }
#line 2061
          next_tag2061 = tmp___1;
          {
#line 2061
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2061
            item___0 = next2061;
#line 2061
            if (! ((unsigned long )item___0 != (unsigned long )((void *)0))) {
#line 2061
              goto while_break___2;
            }
#line 2061
            if (next2061->count != next_tag2061) {
#line 2061
              goto while_break___2;
            } else
#line 2061
            if (next2061->flags[0] & (1U << 3)) {
#line 2061
              goto while_break___2;
            }
#line 2061
            next2061 = next2061->below;
#line 2061
            if ((unsigned long )next2061 == (unsigned long )((void *)0)) {
#line 2061
              next_tag2061 = (tag_t )0;
            } else {
#line 2061
              next_tag2061 = next2061->count;
            }
#line 2062
            if (item___0->count == itemnumber) {
#line 2062
              if (! item___0->invisible) {
#line 2063
                found = 1;
#line 2064
                goto while_break___2;
              }
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 2061
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 2061
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2067
      if (! found) {
        {
#line 2068
        draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Tried to rename an invalid item.");
        }
#line 2070
        return;
      }
      {
#line 2072
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 2072
        tmp___2 = __ctype_b_loc();
        }
#line 2072
        if (! ((int const   )*(*tmp___2 + (int )*params) & 2048)) {
#line 2072
          if (! (32 == (int )*params)) {
#line 2072
            goto while_break___3;
          }
        }
#line 2073
        params ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else
#line 2074
    if (60 == (int )*params) {
      {
#line 2076
      closebrace = strchr(params, '>');
      }
#line 2077
      if (! closebrace) {
        {
#line 2078
        draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Syntax error!");
        }
#line 2080
        return;
      }
#line 2083
      if (closebrace - (char *)params > 127L) {
        {
#line 2084
        draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Old name too long (up to 127 characters allowed)!");
        }
#line 2086
        return;
      }
      {
#line 2089
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%.*s",
               (int )(closebrace - (char *)(params + 1)), params + 1);
#line 2092
      item = find_best_object_match(op, (char const   *)(buf));
      }
#line 2093
      if (! item) {
        {
#line 2094
        draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Could not find a matching item to rename.");
        }
#line 2096
        return;
      }
#line 2100
      params = (char const   *)(closebrace + 1);
      {
#line 2101
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2101
        if (! (32 == (int )*params)) {
#line 2101
          goto while_break___4;
        }
#line 2102
        params ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
      {
#line 2105
      item = find_marked_object(op);
      }
#line 2106
      if (! item) {
        {
#line 2107
        draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "No marked item to rename.");
        }
#line 2109
        return;
      }
    }
    {
#line 2114
    tmp___6 = strncmp(params, "to ", (size_t )3);
    }
#line 2114
    if (tmp___6) {
      {
#line 2164
      tmp___5 = strlen(params);
      }
#line 2164
      if (tmp___5) {
        {
#line 2165
        draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Syntax error, expected \'to <\' after old name!");
        }
#line 2167
        return;
      }
#line 2170
      buf[0] = (char )'\000';
    } else {
#line 2115
      params += 3;
      {
#line 2116
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2116
        if (! (32 == (int )*params)) {
#line 2116
          goto while_break___5;
        }
#line 2117
        params ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 2118
      if (60 != (int )*params) {
        {
#line 2119
        draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Syntax error, expecting < at start of new name!");
        }
#line 2121
        return;
      }
      {
#line 2123
      closebrace = strchr(params + 1, '>');
      }
#line 2124
      if (! closebrace) {
        {
#line 2125
        draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Syntax error, expecting > at end of new name!");
        }
#line 2127
        return;
      }
#line 2131
      if (closebrace - (char *)params > 127L) {
        {
#line 2132
        draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "New name too long (up to 127 characters allowed)!");
        }
#line 2134
        return;
      }
      {
#line 2138
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%.*s",
               (int )(closebrace - (char *)(params + 1)), params + 1);
#line 2141
      counter = (size_t )0;
      }
      {
#line 2141
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 2141
        tmp___4 = strlen((char const   *)(buf));
        }
#line 2141
        if (! (counter < tmp___4)) {
#line 2141
          goto while_break___6;
        }
        {
#line 2142
        tmp___3 = __ctype_b_loc();
        }
#line 2142
        if ((int const   )*(*tmp___3 + (int )buf[counter]) & 8) {
#line 2143
          goto __Cont;
        }
#line 2144
        if (32 == (int )buf[counter]) {
#line 2145
          goto __Cont;
        }
#line 2146
        if (39 == (int )buf[counter]) {
#line 2147
          goto __Cont;
        }
#line 2148
        if (43 == (int )buf[counter]) {
#line 2149
          goto __Cont;
        }
#line 2150
        if (95 == (int )buf[counter]) {
#line 2151
          goto __Cont;
        }
#line 2152
        if (45 == (int )buf[counter]) {
#line 2153
          goto __Cont;
        }
        {
#line 2158
        draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "Invalid new name!");
        }
#line 2160
        return;
        __Cont: /* CIL Label */ 
#line 2141
        counter ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 2174
    item = find_marked_object(op);
    }
#line 2175
    if (! item) {
      {
#line 2176
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "No marked item to rename.");
      }
#line 2178
      return;
    }
#line 2180
    buf[0] = (char )'\000';
  }
  {
#line 2184
  tmp___11 = strlen((char const   *)(buf));
  }
#line 2184
  if (tmp___11) {
#line 2198
    if ((unsigned long )item->custom_name != (unsigned long )((void *)0)) {
      {
#line 2198
      tmp___9 = strcmp(item->custom_name, (char const   *)(buf));
      }
#line 2198
      if (tmp___9 == 0) {
#line 2199
        if (item->nrof > 1U) {
#line 2199
          tmp___8 = 1;
        } else {
#line 2199
          tmp___8 = 0;
        }
        {
#line 2199
        query_base_name((object const   *)item, tmp___8, name, (size_t )256);
#line 2200
        draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )12,
                             "You keep calling your %s %s.", name, buf);
        }
#line 2203
        return;
      }
    }
#line 2207
    if (item->custom_name) {
      {
#line 2207
      free_string(item->custom_name);
      }
    }
    {
#line 2207
    item->custom_name = add_string((char const   *)(buf));
    }
#line 2209
    if (item->nrof > 1U) {
#line 2209
      tmp___10 = 1;
    } else {
#line 2209
      tmp___10 = 0;
    }
    {
#line 2209
    query_base_name((object const   *)item, tmp___10, name, (size_t )256);
#line 2210
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "Your %s will now be called %s.",
                         name, buf);
    }
  } else {
#line 2186
    if ((unsigned long )item->custom_name == (unsigned long )((void *)0)) {
      {
#line 2187
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )11, "This item has no custom name.");
      }
#line 2189
      return;
    }
    {
#line 2192
    free_string(item->custom_name);
#line 2192
    item->custom_name = (char const   *)((void *)0);
    }
#line 2193
    if (item->nrof > 1U) {
#line 2193
      tmp___7 = 1;
    } else {
#line 2193
      tmp___7 = 0;
    }
    {
#line 2193
    query_base_name((object const   *)item, tmp___7, name, (size_t )256);
#line 2194
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )12, "You stop calling your %s with weird names.",
                         name);
    }
  }
  {
#line 2215
  tmp = object_merge(item, (object *)((void *)0));
  }
#line 2216
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 2218
    esrv_update_item(16, op, item);
    }
  }
#line 2220
  return;
}
}
#line 2230 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
void command_lock_item(object *op , char const   *params ) 
{ 
  object *item ;
  object *tmp ;
  char name[4096] ;
  size_t tmp___0 ;

  {
#line 2235
  if ((int const   )*params == 0) {
    {
#line 2236
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )13, "Lock what item?");
    }
#line 2238
    return;
  } else {
    {
#line 2235
    tmp___0 = strlen(params);
    }
#line 2235
    if (tmp___0 == 0UL) {
      {
#line 2236
      draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )13, "Lock what item?");
      }
#line 2238
      return;
    }
  }
  {
#line 2241
  item = find_best_object_match(op, params);
  }
#line 2242
  if (! item) {
    {
#line 2243
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )13, "Can\'t find any matching item.");
    }
#line 2245
    return;
  }
  {
#line 2248
  query_short_name((object const   *)item, name, (size_t )4096);
  }
#line 2249
  if (item->flags[2] & (1U << 22)) {
    {
#line 2250
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )13, "Unlocked %s.",
                         name);
#line 2252
    item->flags[2] &= ~ (1U << 22);
    }
  } else {
    {
#line 2254
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )13, "Locked %s.",
                         name);
#line 2256
    item->flags[2] |= 1U << 22;
    }
  }
  {
#line 2259
  tmp = object_merge(item, (object *)((void *)0));
  }
#line 2260
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 2262
    esrv_update_item(2, op, item);
    }
  }
#line 2264
  return;
}
}
#line 2273 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/c_object.c"
void command_use(object *op , char const   *params ) 
{ 
  char *with ;
  char copy[256] ;
  object *first ;
  object *second ;
  recipe *transformation ;
  size_t tmp ;
  object *generated ;
  object *tmp___0 ;
  int tmp___1 ;

  {
#line 2281
  if (! op->type == 1) {
#line 2282
    return;
  }
  {
#line 2284
  snprintf((char */* __restrict  */)(copy), sizeof(copy), (char const   */* __restrict  */)"%s",
           params);
#line 2285
  with = strstr((char const   *)(copy), " with ");
  }
#line 2286
  if (! with) {
    {
#line 2287
    draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )13, "Syntax is use <item> with <item>.");
    }
#line 2288
    return;
  }
  {
#line 2291
  *(with + 0) = (char )'\000';
#line 2292
  tmp = strlen(" with ");
#line 2292
  with += tmp;
#line 2294
  first = find_best_object_match(op, (char const   *)(copy));
  }
#line 2295
  if (! first) {
    {
#line 2296
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )13, "No match for %s.",
                         copy);
    }
#line 2297
    return;
  }
  {
#line 2299
  second = find_best_object_match(op, (char const   *)with);
  }
#line 2300
  if (! second) {
    {
#line 2301
    draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )13, "No match for %s.",
                         with);
    }
#line 2302
    return;
  }
#line 2305
  transformation = (recipe *)((void *)0);
  {
#line 2306
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2306
    transformation = find_recipe_for_tool((first->arch)->name, transformation);
    }
#line 2306
    if (! transformation) {
#line 2306
      goto while_break;
    }
#line 2308
    if (transformation->ingred_count != 1) {
#line 2309
      goto while_continue;
    }
    {
#line 2312
    tmp___1 = strcmp(second->name, (transformation->ingred)->name);
    }
#line 2312
    if (tmp___1 == 0) {
      {
#line 2314
      tmp___0 = create_archetype((char const   *)*(transformation->arch_name + 0));
#line 2314
      generated = tmp___0;
      }
#line 2315
      if (transformation->yield) {
#line 2316
        generated->nrof = (uint32 )transformation->yield;
      }
      {
#line 2317
      object_insert_in_ob(generated, op);
#line 2319
      object_decrease_nrof(second, (uint32 )1);
      }
#line 2320
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2323
  draw_ext_info(256, 0, (object const   *)op, (uint8 )10, (uint8 )13, "Nothing happens.");
  }
#line 2324
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/ban.c"
int checkbanned(char const   *login , char const   *host ) 
{ 
  FILE *bannedfile ;
  char buf[256] ;
  char log_buf0[160] ;
  char host_buf[64] ;
  char line_buf[160] ;
  char *indexpos ;
  int num1 ;
  int hits ;
  int loop ;
  int inverse_ban ;
  char *log_buf ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 44
  hits = 0;
#line 51
  inverse_ban = 0;
#line 53
  loop = 0;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! (loop < 2)) {
#line 53
      goto while_break;
    }
#line 56
    if (loop == 0) {
      {
#line 57
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s/%s",
               settings.confdir, "ban_file");
#line 58
      bannedfile = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"r");
      }
#line 59
      if ((unsigned long )bannedfile == (unsigned long )((void *)0)) {
        {
#line 60
        LOG((LogLevel )2, "Could not find file Banned file\n");
        }
#line 61
        goto __Cont;
      }
    }
#line 67
    if (loop == 1) {
      {
#line 68
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s/%s",
               settings.localdir, "banish_file");
#line 69
      bannedfile = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"r");
      }
#line 70
      if ((unsigned long )bannedfile == (unsigned long )((void *)0)) {
        {
#line 71
        LOG((LogLevel )2, "Could not find file Banish file\n");
        }
#line 72
        return (0);
      }
    }
    {
#line 78
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 78
      tmp___3 = fgets((char */* __restrict  */)(line_buf), 160, (FILE */* __restrict  */)bannedfile);
      }
#line 78
      if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
#line 78
        goto while_break___0;
      }
#line 79
      log_buf = log_buf0;
#line 81
      inverse_ban = 0;
#line 82
      hits = 0;
#line 85
      if ((int )line_buf[0] == 35) {
#line 86
        goto while_continue___0;
      } else
#line 85
      if ((int )line_buf[0] == 10) {
#line 86
        goto while_continue___0;
      }
      {
#line 88
      indexpos = strrchr((char const   *)(line_buf), '@');
      }
#line 89
      if ((unsigned long )indexpos == (unsigned long )((void *)0)) {
        {
#line 90
        LOG((LogLevel )2, "Bad line in banned file\n");
        }
#line 91
        goto while_continue___0;
      }
      {
#line 95
      num1 = (int )(indexpos - line_buf);
#line 96
      strncpy((char */* __restrict  */)log_buf, (char const   */* __restrict  */)(line_buf),
              (size_t )num1);
#line 97
      *(log_buf + num1) = (char )'\000';
#line 100
      strncpy((char */* __restrict  */)(host_buf), (char const   */* __restrict  */)(indexpos + 1),
              sizeof(host_buf) - 1UL);
#line 101
      host_buf[sizeof(host_buf) - 1UL] = (char )'\000';
#line 104
      indexpos = host_buf;
      }
      {
#line 105
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 105
        tmp = __ctype_b_loc();
        }
#line 105
        if ((int const   )*(*tmp + (int )*indexpos) & 8192) {
#line 105
          goto while_break___1;
        }
#line 106
        indexpos ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 108
      *indexpos = (char )'\000';
#line 110
      if ((int )*log_buf == 126) {
#line 111
        log_buf ++;
#line 112
        inverse_ban = 1;
      }
#line 120
      if ((int )*log_buf == 42) {
#line 121
        hits = 1;
      } else
#line 122
      if ((unsigned long )login != (unsigned long )((void *)0)) {
        {
#line 122
        tmp___0 = strcmp(login, (char const   *)log_buf);
        }
#line 122
        if (tmp___0 == 0) {
#line 123
          hits = 1;
        }
      }
#line 125
      if (hits == 1) {
#line 126
        if ((int )host_buf[0] == 42) {
#line 127
          hits ++;
#line 130
          goto while_break___0;
        } else {
          {
#line 131
          tmp___2 = strstr(host, (char const   *)(host_buf));
          }
#line 131
          if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 132
            hits ++;
#line 135
            goto while_break___0;
          } else {
            {
#line 136
            tmp___1 = strcmp(host, (char const   *)(host_buf));
            }
#line 136
            if (tmp___1 == 0) {
#line 137
              hits ++;
#line 140
              goto while_break___0;
            }
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 145
    fclose(bannedfile);
    }
#line 147
    if (hits >= 2) {
#line 148
      return (! inverse_ban);
    }
    __Cont: /* CIL Label */ 
#line 53
    loop ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  return (0);
}
}
#line 638 "../include/sproto.h"
extern int server_main(int argc , char **argv ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/server/main.c"
int main(int argc , char **argv ) 
{ 
  int tmp ;

  {
  {
#line 48
  tmp = server_main(argc, argv);
  }
#line 48
  return (tmp);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 379
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 46 "./../common/include/plugin_common.h"
int cf_init_plugin(void (*getHooks)(int *type  , ...) ) ;
#line 47
void cf_system_register_global_event(int event , char const   *name , int (*hook)(int *type 
                                                                                  , ...) ) ;
#line 48
void cf_system_unregister_global_event(int event , char const   *name ) ;
#line 51
sstring cf_add_string(char const   *str ) ;
#line 52
void cf_free_string(sstring str ) ;
#line 53
sstring cf_find_string(char const   *str ) ;
#line 54
char *cf_strdup_local(char const   *str ) ;
#line 55
char *cf_get_maps_directory(char const   *name , char *buf , int size ) ;
#line 56
int cf_find_animation(char const   *name ) ;
#line 57
int cf_find_face(char const   *name , int error ) ;
#line 58
void cf_log(LogLevel logLevel , char const   *format  , ...) ;
#line 59
void cf_log_plain(LogLevel logLevel , char const   *message ) ;
#line 60
void cf_get_time(timeofday_t *tod ) ;
#line 61
int cf_timer_create(object *ob , long delay , int mode ) ;
#line 62
int cf_timer_destroy(int id ) ;
#line 63
char const   *cf_get_directory(int id ) ;
#line 64
char const   *cf_re_cmp(char const   *str , char const   *regexp ) ;
#line 65
char const   *cf_get_season_name(int index___0 ) ;
#line 66
char const   *cf_get_month_name(int index___0 ) ;
#line 67
char const   *cf_get_weekday_name(int index___0 ) ;
#line 68
char const   *cf_get_periodofday_name(int index___0 ) ;
#line 69
void cf_cost_string_from_value(uint64 cost , int largest_coin , char *buffer , int length ) ;
#line 72
void cf_object_set_int_property(object *op , int propcode , int value ) ;
#line 73
int cf_object_get_int_property(object *op , int propcode ) ;
#line 74
long cf_object_get_long_property(object *op , long propcode ) ;
#line 75
void cf_object_set_movetype_property(object *op , int propcode , MoveType value ) ;
#line 76
MoveType cf_object_get_movetype_property(object *op , int propcode ) ;
#line 77
object *cf_object_get_object_property(object *op , int propcode ) ;
#line 78
void cf_object_set_object_property(object *op , int propcode , object *value ) ;
#line 79
float cf_object_get_float_property(object *op , int propcode ) ;
#line 80
void cf_object_set_float_property(object *op , int propcode , float value ) ;
#line 81
mapstruct *cf_object_get_map_property(object *op , int propcode ) ;
#line 82
archetype *cf_object_get_archetype_property(object *op , int propcode ) ;
#line 83
partylist *cf_object_get_partylist_property(object *op , int propcode ) ;
#line 84
sint64 cf_object_get_int64_property(object *op , int propcode ) ;
#line 85
void cf_object_set_int64_property(object *op , int propcode , sint64 value ) ;
#line 86
double cf_object_get_double_property(object *op , int propcode ) ;
#line 87
sstring cf_object_get_sstring_property(object *op , int propcode ) ;
#line 88
char *cf_object_get_string_property(object *op , int propcode , char *buf , int size ) ;
#line 89
void cf_fix_object(object *op ) ;
#line 90
char *cf_query_name(object *ob , char *name , int size ) ;
#line 91
sstring cf_query_name_pl(object *ob ) ;
#line 92
char *cf_query_base_name(object *ob , int plural , char *name , int size ) ;
#line 93
char const   *cf_object_get_msg(object *ob ) ;
#line 94
void cf_object_set_weight(object *ob , int weight ) ;
#line 95
int cf_object_get_weight(object *ob ) ;
#line 96
void cf_object_set_weight_limit(object *ob , int weight_limit ) ;
#line 97
int cf_object_get_weight_limit(object *ob ) ;
#line 98
int cf_object_set_nrof(object *ob , int nrof ) ;
#line 99
int cf_object_get_nrof(object *ob ) ;
#line 100
int cf_object_get_flag(object *ob , int flag ) ;
#line 101
void cf_object_set_flag(object *ob , int flag , int value ) ;
#line 102
object *cf_object_insert_in_ob(object *op , object *where ) ;
#line 103
void cf_object_set_string_property(object *op , int propcode , char const   *value ) ;
#line 104
void cf_spring_trap(object *trap , object *victim ) ;
#line 105
int cf_object_check_trigger(object *op , object *cause ) ;
#line 106
int cf_object_query_money(object const   *op ) ;
#line 107
int cf_object_query_cost(object const   *tmp , object *who , int flag ) ;
#line 108
void cf_object_query_cost_string(object const   *tmp , object *who , int flag , char *buffer ,
                                 int length ) ;
#line 109
int cf_object_cast_spell(object *op , object *caster , int dir , object *spell_ob ,
                         char *stringarg ) ;
#line 110
void cf_object_learn_spell(object *op , object *spell , int special_prayer ) ;
#line 111
void cf_object_forget_spell(object *op , object *sp ) ;
#line 112
object *cf_object_check_for_spell(object *op , char const   *name ) ;
#line 113
int cf_object_cast_ability(object *caster , object *ctoo , int dir , object *sp ,
                           char *flags ) ;
#line 114
int cf_object_pay_amount(object *pl , uint64 to_pay ) ;
#line 115
int cf_object_pay_item(object *op , object *pl ) ;
#line 116
void cf_object_set_long_property(object *op , int propcode , long value ) ;
#line 117
int cf_object_transfer(object *op , int x , int y , int randomly , object *originator ) ;
#line 118
int cf_object_move_to(object *op , int x , int y ) ;
#line 119
int cf_object_out_of_map(object *op , int x , int y ) ;
#line 120
void cf_object_drop(object *op , object *author ) ;
#line 121
void cf_object_say(object *op , char *msg ) ;
#line 122
object *cf_object_insert_object(object *op , object *container ) ;
#line 123
object *cf_object_present_archname_inside(object *op , char *whatstr ) ;
#line 124
int cf_object_apply(object *op , object *tmp , int aflag ) ;
#line 125
void cf_object_remove(object *op ) ;
#line 126
void cf_object_free_drop_inventory(object *ob ) ;
#line 127
object *cf_create_object(void) ;
#line 128
object *cf_create_object_by_name(char const   *name ) ;
#line 129
object *cf_object_change_map(object *op , mapstruct *m , object *originator , int flag ,
                             int x , int y ) ;
#line 130
int cf_object_teleport(object *op , mapstruct *map , int x , int y ) ;
#line 131
void cf_object_update(object *op , int flags ) ;
#line 132
void cf_object_pickup(object *op , object *what ) ;
#line 133
char const   *cf_object_get_key(object *op , char const   *keyname ) ;
#line 134
int cf_object_set_key(object *op , char const   *keyname , char const   *value , int add_key ) ;
#line 135
sint16 cf_object_get_resistance(object *op , int rtype ) ;
#line 136
void cf_object_set_resistance(object *op , int rtype , sint16 value ) ;
#line 137
int cf_object_move(object *op , int dir , object *originator ) ;
#line 138
void cf_object_apply_below(object *pl ) ;
#line 139
object *cf_object_clone(object *op , int clonetype ) ;
#line 140
void cf_object_change_exp(object *op , sint64 exp , char const   *skill_name , int flag ) ;
#line 141
int cf_object_change_abil(object *op , object *tmp ) ;
#line 142
int cf_object_user_event(object *op , object *activator , object *third , char const   *message ,
                         int fix ) ;
#line 143
int cf_object_remove_depletion(object *op , int level ) ;
#line 144
object *cf_object_find_by_arch_name(object const   *who , char const   *name ) ;
#line 145
object *cf_object_find_by_name(object const   *who , char const   *name ) ;
#line 146
object *cf_object_split(object *orig_ob , uint32 nr , char *err , size_t size ) ;
#line 148
int cf_object_set_face(object *op , char const   *face ) ;
#line 149
int cf_object_set_animation(object *op , char const   *animation ) ;
#line 150
object *cf_identify(object *op ) ;
#line 153
sstring cf_map_get_sstring_property(mapstruct *map , int propcode ) ;
#line 154
mapstruct *cf_map_get_map_property(mapstruct *map , int propcode ) ;
#line 155
region *cf_map_get_region_property(mapstruct *map , int propcode ) ;
#line 156
int cf_map_get_int_property(mapstruct *map , int property ) ;
#line 158
void cf_map_set_int_property(mapstruct *map , int propcode , int value ) ;
#line 159
void cf_map_set_string_property(mapstruct *map , int propcode , char const   *value ) ;
#line 160
mapstruct *cf_map_get_map(char const   *name , int flags ) ;
#line 161
mapstruct *cf_get_empty_map(int sizex , int sizey ) ;
#line 162
mapstruct *cf_map_get_first(void) ;
#line 163
mapstruct *cf_map_has_been_loaded(char const   *name ) ;
#line 164
void cf_map_message(mapstruct *m , char const   *msg , int color ) ;
#line 165
object *cf_map_get_object_at(mapstruct *m , int x , int y ) ;
#line 166
object *cf_map_insert_object(mapstruct *where , object *op , int x , int y ) ;
#line 167
object *cf_map_insert_object_around(mapstruct *where , object *op , int x , int y ) ;
#line 168
object *cf_map_find_by_archetype_name(char const   *str , mapstruct *map , int nx ,
                                      int ny ) ;
#line 169
int cf_map_get_flags(mapstruct *oldmap , mapstruct **newmap , sint16 x , sint16 y ,
                     sint16 *nx , sint16 *ny ) ;
#line 170
object *cf_map_insert_object_there(object *op , mapstruct *m , object *originator ,
                                   int flag ) ;
#line 171
int cf_map_get_difficulty(mapstruct *map ) ;
#line 172
int cf_map_get_reset_time(mapstruct *map ) ;
#line 173
int cf_map_get_reset_timeout(mapstruct *map ) ;
#line 174
int cf_map_get_players(mapstruct *map ) ;
#line 175
int cf_map_get_darkness(mapstruct *map ) ;
#line 177
int cf_map_get_width(mapstruct *map ) ;
#line 178
int cf_map_get_height(mapstruct *map ) ;
#line 179
int cf_map_get_enter_x(mapstruct *map ) ;
#line 180
int cf_map_get_enter_y(mapstruct *map ) ;
#line 181
int cf_map_change_light(mapstruct *m , int change ) ;
#line 182
void cf_map_trigger_connected(objectlink *ol , object *cause , int state ) ;
#line 185
int cf_random_map_set_variable(RMParms *rp , char const   *buf ) ;
#line 186
mapstruct *cf_random_map_generate(char const   *OutFileName , RMParms *RP , char **use_layout ) ;
#line 189
char *cf_player_get_title(object *op , char *title , int size ) ;
#line 190
void cf_player_set_title(object *op , char const   *title ) ;
#line 191
sstring cf_player_get_ip(object *op ) ;
#line 192
object *cf_player_get_marked_item(object *op ) ;
#line 193
void cf_player_set_marked_item(object *op , object *ob ) ;
#line 194
player *cf_player_find(char const   *plname ) ;
#line 195
void cf_player_message(object *op , char *txt , int flags ) ;
#line 196
int cf_player_move(player *pl , int dir ) ;
#line 197
partylist *cf_player_get_party(object *op ) ;
#line 198
void cf_player_set_party(object *op , partylist *party ) ;
#line 199
int cf_player_can_pay(object *pl ) ;
#line 200
int cf_player_knowledge_has(object *op , char const   *knowledge ) ;
#line 201
int cf_player_arrest(object *who ) ;
#line 204
archetype *cf_archetype_get_first(void) ;
#line 205
sstring cf_archetype_get_name(archetype *arch ) ;
#line 206
archetype *cf_archetype_get_next(archetype *arch ) ;
#line 207
archetype *cf_archetype_get_more(archetype *arch ) ;
#line 208
archetype *cf_archetype_get_head(archetype *arch ) ;
#line 209
object *cf_archetype_get_clone(archetype *arch ) ;
#line 212
partylist *cf_party_get_first(void) ;
#line 213
char const   *cf_party_get_name(partylist *party ) ;
#line 214
partylist *cf_party_get_next(partylist *party ) ;
#line 215
char const   *cf_party_get_password(partylist *party ) ;
#line 216
player *cf_party_get_first_player(partylist *party ) ;
#line 217
player *cf_party_get_next_player(partylist *party , player *op ) ;
#line 220
region *cf_region_get_first(void) ;
#line 221
char const   *cf_region_get_name(region *reg ) ;
#line 222
region *cf_region_get_next(region *reg ) ;
#line 223
region *cf_region_get_parent(region *reg ) ;
#line 224
char const   *cf_region_get_longname(region *reg ) ;
#line 225
char const   *cf_region_get_message(region *reg ) ;
#line 226
int cf_region_get_jail_x(region *reg ) ;
#line 227
int cf_region_get_jail_y(region *reg ) ;
#line 228
char const   *cf_region_get_jail_path(region *reg ) ;
#line 231
object *cf_friendlylist_get_first(void) ;
#line 232
object *cf_friendlylist_get_next(object *ob ) ;
#line 235
int cf_quest_get_player_state(object *pl , sstring quest_code ) ;
#line 236
void cf_quest_start(object *pl , sstring quest_code , int state ) ;
#line 237
void cf_quest_set_player_state(object *pl , sstring quest_code , int state ) ;
#line 238
int cf_quest_was_completed(object *pl , sstring quest_code ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiSystem_add_string)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 41 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiSystem_find_string)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 42 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiSystem_register_global_event)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 43 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiSystem_remove_string)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 44 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiSystem_unregister_global_event)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 45 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiSystem_strdup_local)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 46 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiSystem_find_animation)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 47 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiSystem_find_face)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 48 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiSystem_log)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 49 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiSystem_get_time)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 50 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiSystem_timer_create)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 51 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiSystem_timer_destroy)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 52 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiSystem_directory)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 53 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiSystem_re_cmp)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 55 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_get_property)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 56 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_set_property)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 57 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_apply)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 58 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_identify)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 59 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_describe)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 60 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_drain)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 61 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_fix)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 62 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_give_skill)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 63 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_transmute)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 64 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_remove)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 65 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_delete)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 66 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_clone)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 67 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_create)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 68 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_insert)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 69 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_split)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 70 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_merge)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 71 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_distance)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 72 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_update)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 73 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_clear)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 74 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_reset)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 75 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_activate_rune)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 76 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_check_trigger)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 77 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_query_money)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 78 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_query_cost)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 79 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_query_cost_string)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 80 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_cast)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 81 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_learn_spell)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 82 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_forget_spell)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 83 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_check_spell)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 84 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_pay_amount)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 85 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_pay_item)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 86 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_transfer)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 87 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_find_archetype_inside)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 88 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_find_by_arch_name)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 89 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_find_by_name)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 90 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_out_of_map)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 91 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_drop)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 92 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_change_abil)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 93 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_say)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 94 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiMap_get_property)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 95 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiMap_set_property)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 96 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiMap_get_map)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 97 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiMap_message)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 98 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiMap_get_object_at)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 99 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiMap_find_by_archetype_name)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 100 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiMap_create_path)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 101 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiMap_has_been_loaded)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 102 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiMap_change_light)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 103 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiMap_trigger_connected)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 104 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiPlayer_find)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 105 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiPlayer_message)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 106 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_teleport)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 107 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_pickup)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 108 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_get_key)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 109 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_set_key)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 110 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_move)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 111 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_apply_below)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 112 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiArchetype_get_property)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 113 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiParty_get_property)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 114 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiRegion_get_property)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 115 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiPlayer_can_pay)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 116 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiFriendlylist_get_next)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 117 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiSet_random_map_variable)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 118 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiGenerate_random_map)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 119 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_change_exp)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 120 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiSystem_get_month_name)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 121 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiSystem_get_season_name)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 122 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiSystem_get_weekday_name)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 123 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiSystem_get_periodofday_name)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 124 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_user_event)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 125 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiCost_string_from_value)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 126 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiPlayer_quest)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 127 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiObject_remove_depletion)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 128 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
static void (*cfapiPlayer_knowledge)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 138 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_init_plugin(void (*getHooks)(int *type  , ...) ) 
{ 
  int z ;

  {
  {
#line 141
  (*getHooks)(& z, 1, "cfapi_system_strdup_local", & cfapiSystem_strdup_local);
  }
#line 141
  if (z != 10) {
    {
#line 141
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_system_strdup_local");
    }
#line 141
    return (0);
  }
  {
#line 142
  (*getHooks)(& z, 1, "cfapi_system_add_string", & cfapiSystem_add_string);
  }
#line 142
  if (z != 10) {
    {
#line 142
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_system_add_string");
    }
#line 142
    return (0);
  }
  {
#line 143
  (*getHooks)(& z, 1, "cfapi_system_register_global_event", & cfapiSystem_register_global_event);
  }
#line 143
  if (z != 10) {
    {
#line 143
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_system_register_global_event");
    }
#line 143
    return (0);
  }
  {
#line 144
  (*getHooks)(& z, 1, "cfapi_system_remove_string", & cfapiSystem_remove_string);
  }
#line 144
  if (z != 10) {
    {
#line 144
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_system_remove_string");
    }
#line 144
    return (0);
  }
  {
#line 145
  (*getHooks)(& z, 1, "cfapi_system_directory", & cfapiSystem_directory);
  }
#line 145
  if (z != 10) {
    {
#line 145
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_system_directory");
    }
#line 145
    return (0);
  }
  {
#line 146
  (*getHooks)(& z, 1, "cfapi_system_unregister_global_event", & cfapiSystem_unregister_global_event);
  }
#line 146
  if (z != 10) {
    {
#line 146
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_system_unregister_global_event");
    }
#line 146
    return (0);
  }
  {
#line 147
  (*getHooks)(& z, 1, "cfapi_system_find_animation", & cfapiSystem_find_animation);
  }
#line 147
  if (z != 10) {
    {
#line 147
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_system_find_animation");
    }
#line 147
    return (0);
  }
  {
#line 148
  (*getHooks)(& z, 1, "cfapi_system_find_face", & cfapiSystem_find_face);
  }
#line 148
  if (z != 10) {
    {
#line 148
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_system_find_face");
    }
#line 148
    return (0);
  }
  {
#line 149
  (*getHooks)(& z, 1, "cfapi_system_re_cmp", & cfapiSystem_re_cmp);
  }
#line 149
  if (z != 10) {
    {
#line 149
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_system_re_cmp");
    }
#line 149
    return (0);
  }
  {
#line 150
  (*getHooks)(& z, 1, "cfapi_object_get_property", & cfapiObject_get_property);
  }
#line 150
  if (z != 10) {
    {
#line 150
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_get_property");
    }
#line 150
    return (0);
  }
  {
#line 151
  (*getHooks)(& z, 1, "cfapi_object_set_property", & cfapiObject_set_property);
  }
#line 151
  if (z != 10) {
    {
#line 151
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_set_property");
    }
#line 151
    return (0);
  }
  {
#line 152
  (*getHooks)(& z, 1, "cfapi_object_apply", & cfapiObject_apply);
  }
#line 152
  if (z != 10) {
    {
#line 152
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_apply");
    }
#line 152
    return (0);
  }
  {
#line 153
  (*getHooks)(& z, 1, "cfapi_object_identify", & cfapiObject_identify);
  }
#line 153
  if (z != 10) {
    {
#line 153
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_identify");
    }
#line 153
    return (0);
  }
  {
#line 154
  (*getHooks)(& z, 1, "cfapi_object_describe", & cfapiObject_describe);
  }
#line 154
  if (z != 10) {
    {
#line 154
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_describe");
    }
#line 154
    return (0);
  }
  {
#line 155
  (*getHooks)(& z, 1, "cfapi_object_drain", & cfapiObject_drain);
  }
#line 155
  if (z != 10) {
    {
#line 155
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_drain");
    }
#line 155
    return (0);
  }
  {
#line 156
  (*getHooks)(& z, 1, "cfapi_object_fix", & cfapiObject_fix);
  }
#line 156
  if (z != 10) {
    {
#line 156
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_fix");
    }
#line 156
    return (0);
  }
  {
#line 157
  (*getHooks)(& z, 1, "cfapi_object_give_skill", & cfapiObject_give_skill);
  }
#line 157
  if (z != 10) {
    {
#line 157
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_give_skill");
    }
#line 157
    return (0);
  }
  {
#line 158
  (*getHooks)(& z, 1, "cfapi_object_transmute", & cfapiObject_transmute);
  }
#line 158
  if (z != 10) {
    {
#line 158
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_transmute");
    }
#line 158
    return (0);
  }
  {
#line 159
  (*getHooks)(& z, 1, "cfapi_object_remove", & cfapiObject_remove);
  }
#line 159
  if (z != 10) {
    {
#line 159
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_remove");
    }
#line 159
    return (0);
  }
  {
#line 160
  (*getHooks)(& z, 1, "cfapi_object_delete", & cfapiObject_delete);
  }
#line 160
  if (z != 10) {
    {
#line 160
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_delete");
    }
#line 160
    return (0);
  }
  {
#line 161
  (*getHooks)(& z, 1, "cfapi_object_clone", & cfapiObject_clone);
  }
#line 161
  if (z != 10) {
    {
#line 161
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_clone");
    }
#line 161
    return (0);
  }
  {
#line 162
  (*getHooks)(& z, 1, "cfapi_object_create", & cfapiObject_create);
  }
#line 162
  if (z != 10) {
    {
#line 162
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_create");
    }
#line 162
    return (0);
  }
  {
#line 163
  (*getHooks)(& z, 1, "cfapi_object_insert", & cfapiObject_insert);
  }
#line 163
  if (z != 10) {
    {
#line 163
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_insert");
    }
#line 163
    return (0);
  }
  {
#line 164
  (*getHooks)(& z, 1, "cfapi_object_split", & cfapiObject_split);
  }
#line 164
  if (z != 10) {
    {
#line 164
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_split");
    }
#line 164
    return (0);
  }
  {
#line 165
  (*getHooks)(& z, 1, "cfapi_object_merge", & cfapiObject_merge);
  }
#line 165
  if (z != 10) {
    {
#line 165
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_merge");
    }
#line 165
    return (0);
  }
  {
#line 166
  (*getHooks)(& z, 1, "cfapi_object_distance", & cfapiObject_distance);
  }
#line 166
  if (z != 10) {
    {
#line 166
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_distance");
    }
#line 166
    return (0);
  }
  {
#line 167
  (*getHooks)(& z, 1, "cfapi_object_update", & cfapiObject_update);
  }
#line 167
  if (z != 10) {
    {
#line 167
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_update");
    }
#line 167
    return (0);
  }
  {
#line 168
  (*getHooks)(& z, 1, "cfapi_object_clear", & cfapiObject_clear);
  }
#line 168
  if (z != 10) {
    {
#line 168
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_clear");
    }
#line 168
    return (0);
  }
  {
#line 169
  (*getHooks)(& z, 1, "cfapi_object_reset", & cfapiObject_reset);
  }
#line 169
  if (z != 10) {
    {
#line 169
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_reset");
    }
#line 169
    return (0);
  }
  {
#line 170
  (*getHooks)(& z, 1, "cfapi_object_spring_trap", & cfapiObject_activate_rune);
  }
#line 170
  if (z != 10) {
    {
#line 170
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_spring_trap");
    }
#line 170
    return (0);
  }
  {
#line 171
  (*getHooks)(& z, 1, "cfapi_object_check_trigger", & cfapiObject_check_trigger);
  }
#line 171
  if (z != 10) {
    {
#line 171
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_check_trigger");
    }
#line 171
    return (0);
  }
  {
#line 172
  (*getHooks)(& z, 1, "cfapi_object_query_money", & cfapiObject_query_money);
  }
#line 172
  if (z != 10) {
    {
#line 172
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_query_money");
    }
#line 172
    return (0);
  }
  {
#line 173
  (*getHooks)(& z, 1, "cfapi_object_query_cost", & cfapiObject_query_cost);
  }
#line 173
  if (z != 10) {
    {
#line 173
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_query_cost");
    }
#line 173
    return (0);
  }
  {
#line 174
  (*getHooks)(& z, 1, "cfapi_object_query_cost_string", & cfapiObject_query_cost_string);
  }
#line 174
  if (z != 10) {
    {
#line 174
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_query_cost_string");
    }
#line 174
    return (0);
  }
  {
#line 175
  (*getHooks)(& z, 1, "cfapi_object_cast", & cfapiObject_cast);
  }
#line 175
  if (z != 10) {
    {
#line 175
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_cast");
    }
#line 175
    return (0);
  }
  {
#line 176
  (*getHooks)(& z, 1, "cfapi_object_learn_spell", & cfapiObject_learn_spell);
  }
#line 176
  if (z != 10) {
    {
#line 176
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_learn_spell");
    }
#line 176
    return (0);
  }
  {
#line 177
  (*getHooks)(& z, 1, "cfapi_object_forget_spell", & cfapiObject_forget_spell);
  }
#line 177
  if (z != 10) {
    {
#line 177
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_forget_spell");
    }
#line 177
    return (0);
  }
  {
#line 178
  (*getHooks)(& z, 1, "cfapi_object_check_spell", & cfapiObject_check_spell);
  }
#line 178
  if (z != 10) {
    {
#line 178
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_check_spell");
    }
#line 178
    return (0);
  }
  {
#line 179
  (*getHooks)(& z, 1, "cfapi_object_pay_amount", & cfapiObject_pay_amount);
  }
#line 179
  if (z != 10) {
    {
#line 179
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_pay_amount");
    }
#line 179
    return (0);
  }
  {
#line 180
  (*getHooks)(& z, 1, "cfapi_object_pay_item", & cfapiObject_pay_item);
  }
#line 180
  if (z != 10) {
    {
#line 180
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_pay_item");
    }
#line 180
    return (0);
  }
  {
#line 181
  (*getHooks)(& z, 1, "cfapi_object_transfer", & cfapiObject_transfer);
  }
#line 181
  if (z != 10) {
    {
#line 181
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_transfer");
    }
#line 181
    return (0);
  }
  {
#line 182
  (*getHooks)(& z, 1, "cfapi_object_find_archetype_inside", & cfapiObject_find_archetype_inside);
  }
#line 182
  if (z != 10) {
    {
#line 182
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_find_archetype_inside");
    }
#line 182
    return (0);
  }
  {
#line 183
  (*getHooks)(& z, 1, "cfapi_object_remove", & cfapiObject_remove);
  }
#line 183
  if (z != 10) {
    {
#line 183
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_remove");
    }
#line 183
    return (0);
  }
  {
#line 184
  (*getHooks)(& z, 1, "cfapi_object_delete", & cfapiObject_delete);
  }
#line 184
  if (z != 10) {
    {
#line 184
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_delete");
    }
#line 184
    return (0);
  }
  {
#line 185
  (*getHooks)(& z, 1, "cfapi_map_out_of_map", & cfapiObject_out_of_map);
  }
#line 185
  if (z != 10) {
    {
#line 185
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_map_out_of_map");
    }
#line 185
    return (0);
  }
  {
#line 186
  (*getHooks)(& z, 1, "cfapi_object_drop", & cfapiObject_drop);
  }
#line 186
  if (z != 10) {
    {
#line 186
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_drop");
    }
#line 186
    return (0);
  }
  {
#line 187
  (*getHooks)(& z, 1, "cfapi_object_change_abil", & cfapiObject_change_abil);
  }
#line 187
  if (z != 10) {
    {
#line 187
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_change_abil");
    }
#line 187
    return (0);
  }
  {
#line 188
  (*getHooks)(& z, 1, "cfapi_object_say", & cfapiObject_say);
  }
#line 188
  if (z != 10) {
    {
#line 188
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_say");
    }
#line 188
    return (0);
  }
  {
#line 189
  (*getHooks)(& z, 1, "cfapi_map_create_path", & cfapiMap_create_path);
  }
#line 189
  if (z != 10) {
    {
#line 189
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_map_create_path");
    }
#line 189
    return (0);
  }
  {
#line 190
  (*getHooks)(& z, 1, "cfapi_map_get_property", & cfapiMap_get_property);
  }
#line 190
  if (z != 10) {
    {
#line 190
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_map_get_property");
    }
#line 190
    return (0);
  }
  {
#line 191
  (*getHooks)(& z, 1, "cfapi_map_set_property", & cfapiMap_set_property);
  }
#line 191
  if (z != 10) {
    {
#line 191
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_map_set_property");
    }
#line 191
    return (0);
  }
  {
#line 192
  (*getHooks)(& z, 1, "cfapi_map_get_map", & cfapiMap_get_map);
  }
#line 192
  if (z != 10) {
    {
#line 192
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_map_get_map");
    }
#line 192
    return (0);
  }
  {
#line 193
  (*getHooks)(& z, 1, "cfapi_map_message", & cfapiMap_message);
  }
#line 193
  if (z != 10) {
    {
#line 193
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_map_message");
    }
#line 193
    return (0);
  }
  {
#line 194
  (*getHooks)(& z, 1, "cfapi_map_get_object_at", & cfapiMap_get_object_at);
  }
#line 194
  if (z != 10) {
    {
#line 194
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_map_get_object_at");
    }
#line 194
    return (0);
  }
  {
#line 195
  (*getHooks)(& z, 1, "cfapi_map_find_by_archetype_name", & cfapiMap_find_by_archetype_name);
  }
#line 195
  if (z != 10) {
    {
#line 195
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_map_find_by_archetype_name");
    }
#line 195
    return (0);
  }
  {
#line 196
  (*getHooks)(& z, 1, "cfapi_map_change_light", & cfapiMap_change_light);
  }
#line 196
  if (z != 10) {
    {
#line 196
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_map_change_light");
    }
#line 196
    return (0);
  }
  {
#line 197
  (*getHooks)(& z, 1, "cfapi_map_has_been_loaded", & cfapiMap_has_been_loaded);
  }
#line 197
  if (z != 10) {
    {
#line 197
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_map_has_been_loaded");
    }
#line 197
    return (0);
  }
  {
#line 198
  (*getHooks)(& z, 1, "cfapi_map_trigger_connected", & cfapiMap_trigger_connected);
  }
#line 198
  if (z != 10) {
    {
#line 198
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_map_trigger_connected");
    }
#line 198
    return (0);
  }
  {
#line 199
  (*getHooks)(& z, 1, "cfapi_player_find", & cfapiPlayer_find);
  }
#line 199
  if (z != 10) {
    {
#line 199
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_player_find");
    }
#line 199
    return (0);
  }
  {
#line 200
  (*getHooks)(& z, 1, "cfapi_player_message", & cfapiPlayer_message);
  }
#line 200
  if (z != 10) {
    {
#line 200
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_player_message");
    }
#line 200
    return (0);
  }
  {
#line 201
  (*getHooks)(& z, 1, "cfapi_object_teleport", & cfapiObject_teleport);
  }
#line 201
  if (z != 10) {
    {
#line 201
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_teleport");
    }
#line 201
    return (0);
  }
  {
#line 202
  (*getHooks)(& z, 1, "cfapi_object_pickup", & cfapiObject_pickup);
  }
#line 202
  if (z != 10) {
    {
#line 202
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_pickup");
    }
#line 202
    return (0);
  }
  {
#line 203
  (*getHooks)(& z, 1, "cfapi_object_get_key", & cfapiObject_get_key);
  }
#line 203
  if (z != 10) {
    {
#line 203
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_get_key");
    }
#line 203
    return (0);
  }
  {
#line 204
  (*getHooks)(& z, 1, "cfapi_object_set_key", & cfapiObject_set_key);
  }
#line 204
  if (z != 10) {
    {
#line 204
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_set_key");
    }
#line 204
    return (0);
  }
  {
#line 205
  (*getHooks)(& z, 1, "cfapi_object_move", & cfapiObject_move);
  }
#line 205
  if (z != 10) {
    {
#line 205
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_move");
    }
#line 205
    return (0);
  }
  {
#line 206
  (*getHooks)(& z, 1, "cfapi_object_apply_below", & cfapiObject_apply_below);
  }
#line 206
  if (z != 10) {
    {
#line 206
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_apply_below");
    }
#line 206
    return (0);
  }
  {
#line 207
  (*getHooks)(& z, 1, "cfapi_archetype_get_property", & cfapiArchetype_get_property);
  }
#line 207
  if (z != 10) {
    {
#line 207
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_archetype_get_property");
    }
#line 207
    return (0);
  }
  {
#line 208
  (*getHooks)(& z, 1, "cfapi_party_get_property", & cfapiParty_get_property);
  }
#line 208
  if (z != 10) {
    {
#line 208
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_party_get_property");
    }
#line 208
    return (0);
  }
  {
#line 209
  (*getHooks)(& z, 1, "cfapi_region_get_property", & cfapiRegion_get_property);
  }
#line 209
  if (z != 10) {
    {
#line 209
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_region_get_property");
    }
#line 209
    return (0);
  }
  {
#line 210
  (*getHooks)(& z, 1, "cfapi_player_can_pay", & cfapiPlayer_can_pay);
  }
#line 210
  if (z != 10) {
    {
#line 210
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_player_can_pay");
    }
#line 210
    return (0);
  }
  {
#line 211
  (*getHooks)(& z, 1, "cfapi_log", & cfapiSystem_log);
  }
#line 211
  if (z != 10) {
    {
#line 211
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_log");
    }
#line 211
    return (0);
  }
  {
#line 212
  (*getHooks)(& z, 1, "cfapi_system_get_time", & cfapiSystem_get_time);
  }
#line 212
  if (z != 10) {
    {
#line 212
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_system_get_time");
    }
#line 212
    return (0);
  }
  {
#line 213
  (*getHooks)(& z, 1, "cfapi_system_timer_create", & cfapiSystem_timer_create);
  }
#line 213
  if (z != 10) {
    {
#line 213
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_system_timer_create");
    }
#line 213
    return (0);
  }
  {
#line 214
  (*getHooks)(& z, 1, "cfapi_system_timer_destroy", & cfapiSystem_timer_destroy);
  }
#line 214
  if (z != 10) {
    {
#line 214
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_system_timer_destroy");
    }
#line 214
    return (0);
  }
  {
#line 215
  (*getHooks)(& z, 1, "cfapi_friendlylist_get_next", & cfapiFriendlylist_get_next);
  }
#line 215
  if (z != 10) {
    {
#line 215
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_friendlylist_get_next");
    }
#line 215
    return (0);
  }
  {
#line 216
  (*getHooks)(& z, 1, "cfapi_set_random_map_variable", & cfapiSet_random_map_variable);
  }
#line 216
  if (z != 10) {
    {
#line 216
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_set_random_map_variable");
    }
#line 216
    return (0);
  }
  {
#line 217
  (*getHooks)(& z, 1, "cfapi_generate_random_map", & cfapiGenerate_random_map);
  }
#line 217
  if (z != 10) {
    {
#line 217
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_generate_random_map");
    }
#line 217
    return (0);
  }
  {
#line 218
  (*getHooks)(& z, 1, "cfapi_object_change_exp", & cfapiObject_change_exp);
  }
#line 218
  if (z != 10) {
    {
#line 218
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_change_exp");
    }
#line 218
    return (0);
  }
  {
#line 219
  (*getHooks)(& z, 1, "cfapi_system_get_season_name", & cfapiSystem_get_season_name);
  }
#line 219
  if (z != 10) {
    {
#line 219
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_system_get_season_name");
    }
#line 219
    return (0);
  }
  {
#line 220
  (*getHooks)(& z, 1, "cfapi_system_get_month_name", & cfapiSystem_get_month_name);
  }
#line 220
  if (z != 10) {
    {
#line 220
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_system_get_month_name");
    }
#line 220
    return (0);
  }
  {
#line 221
  (*getHooks)(& z, 1, "cfapi_system_get_weekday_name", & cfapiSystem_get_weekday_name);
  }
#line 221
  if (z != 10) {
    {
#line 221
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_system_get_weekday_name");
    }
#line 221
    return (0);
  }
  {
#line 222
  (*getHooks)(& z, 1, "cfapi_system_get_periodofday_name", & cfapiSystem_get_periodofday_name);
  }
#line 222
  if (z != 10) {
    {
#line 222
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_system_get_periodofday_name");
    }
#line 222
    return (0);
  }
  {
#line 223
  (*getHooks)(& z, 1, "cfapi_object_user_event", & cfapiObject_user_event);
  }
#line 223
  if (z != 10) {
    {
#line 223
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_user_event");
    }
#line 223
    return (0);
  }
  {
#line 224
  (*getHooks)(& z, 1, "cfapi_system_find_string", & cfapiSystem_find_string);
  }
#line 224
  if (z != 10) {
    {
#line 224
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_system_find_string");
    }
#line 224
    return (0);
  }
  {
#line 225
  (*getHooks)(& z, 1, "cfapi_cost_string_from_value", & cfapiCost_string_from_value);
  }
#line 225
  if (z != 10) {
    {
#line 225
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_cost_string_from_value");
    }
#line 225
    return (0);
  }
  {
#line 226
  (*getHooks)(& z, 1, "cfapi_player_quest", & cfapiPlayer_quest);
  }
#line 226
  if (z != 10) {
    {
#line 226
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_player_quest");
    }
#line 226
    return (0);
  }
  {
#line 227
  (*getHooks)(& z, 1, "cfapi_object_remove_depletion", & cfapiObject_remove_depletion);
  }
#line 227
  if (z != 10) {
    {
#line 227
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_remove_depletion");
    }
#line 227
    return (0);
  }
  {
#line 228
  (*getHooks)(& z, 1, "cfapi_object_find_by_arch_name", & cfapiObject_find_by_arch_name);
  }
#line 228
  if (z != 10) {
    {
#line 228
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_find_by_arch_name");
    }
#line 228
    return (0);
  }
  {
#line 229
  (*getHooks)(& z, 1, "cfapi_object_find_by_name", & cfapiObject_find_by_name);
  }
#line 229
  if (z != 10) {
    {
#line 229
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_object_find_by_name");
    }
#line 229
    return (0);
  }
  {
#line 230
  (*getHooks)(& z, 1, "cfapi_player_knowledge", & cfapiPlayer_knowledge);
  }
#line 230
  if (z != 10) {
    {
#line 230
    printf((char const   */* __restrict  */)"unable to find hook %s!\n", "cfapi_player_knowledge");
    }
#line 230
    return (0);
  }
#line 231
  return (1);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_map_get_int_property(mapstruct *map , int property ) 
{ 
  int type ;
  int value ;

  {
  {
#line 243
  (*cfapiMap_get_property)(& type, map, property, & value);
  }
#line 244
  if (! (type == 1)) {
    {
#line 244
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  244U, "cf_map_get_int_property");
    }
  }
#line 245
  return (value);
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_user_event(object *op , object *activator , object *third , char const   *message ,
                         int fix ) 
{ 
  int type ;
  int value ;

  {
  {
#line 251
  (*cfapiObject_user_event)(& type, op, activator, third, message, fix, & value);
  }
#line 252
  if (! (type == 1)) {
    {
#line 252
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  252U, "cf_object_user_event");
    }
  }
#line 253
  return (value);
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
sstring cf_map_get_sstring_property(mapstruct *map , int propcode ) 
{ 
  int type ;
  sstring value ;

  {
  {
#line 260
  (*cfapiMap_get_property)(& type, map, propcode, & value);
  }
#line 261
  if (! (type == 17)) {
    {
#line 261
    __assert_fail("type == 17", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  261U, "cf_map_get_sstring_property");
    }
  }
#line 262
  return (value);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
mapstruct *cf_map_get_map_property(mapstruct *map , int propcode ) 
{ 
  int type ;
  mapstruct *value ;

  {
  {
#line 269
  (*cfapiMap_get_property)(& type, map, propcode, & value);
  }
#line 270
  if (! (type == 6)) {
    {
#line 270
    __assert_fail("type == 6", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  270U, "cf_map_get_map_property");
    }
  }
#line 271
  return (value);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
region *cf_map_get_region_property(mapstruct *map , int propcode ) 
{ 
  int type ;
  region *value ;

  {
  {
#line 278
  (*cfapiMap_get_property)(& type, map, propcode, & value);
  }
#line 279
  if (! (type == 13)) {
    {
#line 279
    __assert_fail("type == 13", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  279U, "cf_map_get_region_property");
    }
  }
#line 280
  return (value);
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_map_set_int_property(mapstruct *map , int propcode , int value ) 
{ 
  int type ;

  {
  {
#line 287
  (*cfapiMap_set_property)(& type, map, propcode, value);
  }
#line 288
  if (! (type == 1)) {
    {
#line 288
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  288U, "cf_map_set_int_property");
    }
  }
#line 289
  return;
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_map_set_string_property(mapstruct *map , int propcode , char const   *value ) 
{ 
  int type ;

  {
  {
#line 294
  (*cfapiMap_set_property)(& type, map, propcode, value);
  }
#line 295
  if (! (type == 4)) {
    {
#line 295
    __assert_fail("type == 4", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  295U, "cf_map_set_string_property");
    }
  }
#line 296
  return;
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
sint16 cf_object_get_resistance(object *op , int rtype ) 
{ 
  int type ;
  sint16 resist ;

  {
  {
#line 303
  (*cfapiObject_get_property)(& type, op, 30, rtype, & resist);
  }
#line 304
  if (! (type == 14)) {
    {
#line 304
    __assert_fail("type == 14", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  304U, "cf_object_get_resistance");
    }
  }
#line 305
  return (resist);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_object_set_resistance(object *op , int rtype , sint16 value ) 
{ 
  int type ;

  {
  {
#line 310
  (*cfapiObject_set_property)(& type, op, 30, rtype, (int )value);
  }
#line 311
  if (! (type == 14)) {
    {
#line 311
    __assert_fail("type == 14", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  311U, "cf_object_set_resistance");
    }
  }
#line 312
  return;
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_object_set_int_property(object *op , int propcode , int value ) 
{ 
  int type ;

  {
  {
#line 318
  (*cfapiObject_set_property)(& type, op, propcode, value);
  }
#line 319
  if (! (type == 1)) {
    {
#line 319
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  319U, "cf_object_set_int_property");
    }
  }
#line 320
  return;
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_get_int_property(object *op , int propcode ) 
{ 
  int type ;
  int value ;

  {
  {
#line 324
  (*cfapiObject_get_property)(& type, op, propcode, & value);
  }
#line 325
  if (! (type == 1)) {
    {
#line 325
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  325U, "cf_object_get_int_property");
    }
  }
#line 326
  return (value);
}
}
#line 328 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
long cf_object_get_long_property(object *op , long propcode ) 
{ 
  int type ;
  long value ;

  {
  {
#line 332
  (*cfapiObject_get_property)(& type, op, propcode, & value);
  }
#line 333
  if (! (type == 2)) {
    {
#line 333
    __assert_fail("type == 2", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  333U, "cf_object_get_long_property");
    }
  }
#line 334
  return (value);
}
}
#line 336 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_object_set_movetype_property(object *op , int propcode , MoveType value ) 
{ 
  int type ;

  {
  {
#line 339
  (*cfapiObject_set_property)(& type, op, propcode, (int )value);
  }
#line 340
  if (! (type == 18)) {
    {
#line 340
    __assert_fail("type == 18", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  340U, "cf_object_set_movetype_property");
    }
  }
#line 341
  return;
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
MoveType cf_object_get_movetype_property(object *op , int propcode ) 
{ 
  int type ;
  MoveType value ;

  {
  {
#line 346
  (*cfapiObject_get_property)(& type, op, propcode, & value);
  }
#line 347
  if (! (type == 18)) {
    {
#line 347
    __assert_fail("type == 18", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  347U, "cf_object_get_movetype_property");
    }
  }
#line 348
  return (value);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
object *cf_object_get_object_property(object *op , int propcode ) 
{ 
  int type ;
  object *value ;

  {
  {
#line 354
  (*cfapiObject_get_property)(& type, op, propcode, & value);
  }
#line 355
  if (! (type == 5)) {
    {
#line 355
    __assert_fail("type == 5", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  355U, "cf_object_get_object_property");
    }
  }
#line 356
  return (value);
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
mapstruct *cf_object_get_map_property(object *op , int propcode ) 
{ 
  int type ;
  mapstruct *value ;

  {
  {
#line 362
  (*cfapiObject_get_property)(& type, op, propcode, & value);
  }
#line 363
  if (! (type == 6)) {
    {
#line 363
    __assert_fail("type == 6", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  363U, "cf_object_get_map_property");
    }
  }
#line 364
  return (value);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
sint64 cf_object_get_int64_property(object *op , int propcode ) 
{ 
  int type ;
  sint64 value ;

  {
  {
#line 370
  (*cfapiObject_get_property)(& type, op, propcode, & value);
  }
#line 371
  if (! (type == 16)) {
    {
#line 371
    __assert_fail("type == 16", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  371U, "cf_object_get_int64_property");
    }
  }
#line 372
  return (value);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_object_set_long_property(object *op , int propcode , long value ) 
{ 
  int type ;

  {
  {
#line 378
  (*cfapiObject_set_property)(& type, op, propcode, value);
  }
#line 379
  if (! (type == 2)) {
    {
#line 379
    __assert_fail("type == 2", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  379U, "cf_object_set_long_property");
    }
  }
#line 380
  return;
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_object_set_float_property(object *op , int propcode , float value ) 
{ 
  int type ;

  {
  {
#line 384
  (*cfapiObject_set_property)(& type, op, propcode, (double )value);
  }
#line 385
  if (! (type == 7)) {
    {
#line 385
    __assert_fail("type == 7", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  385U, "cf_object_set_float_property");
    }
  }
#line 386
  return;
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_object_set_int64_property(object *op , int propcode , sint64 value ) 
{ 
  int type ;

  {
  {
#line 390
  (*cfapiObject_set_property)(& type, op, propcode, value);
  }
#line 391
  if (! (type == 16)) {
    {
#line 391
    __assert_fail("type == 16", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  391U, "cf_object_set_int64_property");
    }
  }
#line 392
  return;
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
float cf_object_get_float_property(object *op , int propcode ) 
{ 
  int type ;
  float value ;

  {
  {
#line 397
  (*cfapiObject_get_property)(& type, op, propcode, & value);
  }
#line 398
  if (! (type == 7)) {
    {
#line 398
    __assert_fail("type == 7", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  398U, "cf_object_get_float_property");
    }
  }
#line 399
  return (value);
}
}
#line 401 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
archetype *cf_object_get_archetype_property(object *op , int propcode ) 
{ 
  int type ;
  archetype *value ;

  {
  {
#line 405
  (*cfapiObject_get_property)(& type, op, propcode, & value);
  }
#line 406
  if (! (type == 9)) {
    {
#line 406
    __assert_fail("type == 9", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  406U, "cf_object_get_archetype_property");
    }
  }
#line 407
  return (value);
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
partylist *cf_object_get_partylist_property(object *op , int propcode ) 
{ 
  int type ;
  partylist *value ;

  {
  {
#line 413
  (*cfapiObject_get_property)(& type, op, propcode, & value);
  }
#line 414
  if (! (type == 12)) {
    {
#line 414
    __assert_fail("type == 12", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  414U, "cf_object_get_partylist_property");
    }
  }
#line 415
  return (value);
}
}
#line 417 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
double cf_object_get_double_property(object *op , int propcode ) 
{ 
  int type ;
  double value ;

  {
  {
#line 421
  (*cfapiObject_get_property)(& type, op, propcode, & value);
  }
#line 422
  if (! (type == 8)) {
    {
#line 422
    __assert_fail("type == 8", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  422U, "cf_object_get_double_property");
    }
  }
#line 423
  return (value);
}
}
#line 425 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
sstring cf_object_get_sstring_property(object *op , int propcode ) 
{ 
  int type ;
  sstring value ;

  {
  {
#line 429
  (*cfapiObject_get_property)(& type, op, propcode, & value);
  }
#line 430
  if (! (type == 17)) {
    {
#line 430
    __assert_fail("type == 17", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  430U, "cf_object_get_sstring_property");
    }
  }
#line 431
  return (value);
}
}
#line 433 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
char *cf_object_get_string_property(object *op , int propcode , char *buf , int size ) 
{ 
  int type ;

  {
  {
#line 436
  (*cfapiObject_get_property)(& type, op, propcode, buf, size);
  }
#line 437
  if (! (type == 4)) {
    {
#line 437
    __assert_fail("type == 4", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  437U, "cf_object_get_string_property");
    }
  }
#line 438
  return (buf);
}
}
#line 441 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_object_set_string_property(object *op , int propcode , char const   *value ) 
{ 
  int type ;

  {
#line 445
  if (! (propcode != 99)) {
    {
#line 445
    __assert_fail("propcode != 99", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  445U, "cf_object_set_string_property");
    }
  }
#line 447
  if (! (propcode != 100)) {
    {
#line 447
    __assert_fail("propcode != 100", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  447U, "cf_object_set_string_property");
    }
  }
  {
#line 449
  (*cfapiObject_set_property)(& type, op, propcode, value);
  }
#line 450
  if (! (type == 4)) {
    {
#line 450
    __assert_fail("type == 4", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  450U, "cf_object_set_string_property");
    }
  }
#line 451
  return;
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_set_face(object *op , char const   *face ) 
{ 
  int type ;
  int ret ;

  {
  {
#line 461
  (*cfapiObject_set_property)(& type, op, 99, face, & ret);
  }
#line 462
  if (! (type == 1)) {
    {
#line 462
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  462U, "cf_object_set_face");
    }
  }
#line 463
  return (ret);
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_set_animation(object *op , char const   *animation ) 
{ 
  int type ;
  int ret ;

  {
  {
#line 473
  (*cfapiObject_set_property)(& type, op, 100, animation, & ret);
  }
#line 474
  if (! (type == 1)) {
    {
#line 474
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  474U, "cf_object_set_animation");
    }
  }
#line 475
  return (ret);
}
}
#line 478 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_object_set_object_property(object *op , int propcode , object *value ) 
{ 
  int type ;

  {
  {
#line 481
  (*cfapiObject_set_property)(& type, op, propcode, value);
  }
#line 482
  if (! (type == 5)) {
    {
#line 482
    __assert_fail("type == 5", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  482U, "cf_object_set_object_property");
    }
  }
#line 483
  return;
}
}
#line 489 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_object_change_exp(object *op , sint64 exp , char const   *skill_name , int flag ) 
{ 
  int type ;
  char const   *tmp___0 ;
  size_t tmp___1 ;

  {
#line 492
  if (skill_name) {
    {
#line 492
    tmp___1 = strlen(skill_name);
    }
#line 492
    if (tmp___1 > 0UL) {
#line 492
      tmp___0 = skill_name;
    } else {
#line 492
      tmp___0 = (char const   *)((void *)0);
    }
  } else {
#line 492
    tmp___0 = (char const   *)((void *)0);
  }
  {
#line 492
  (*cfapiObject_change_exp)(& type, op, exp, tmp___0, flag);
  }
#line 493
  if (! (type == 0)) {
    {
#line 493
    __assert_fail("type == 0", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  493U, "cf_object_change_exp");
    }
  }
#line 494
  return;
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_player_move(player *pl , int dir ) 
{ 
  int type ;
  int ret ;

  {
  {
#line 498
  (*cfapiObject_move)(& type, 1, pl, dir, & ret);
  }
#line 499
  if (! (type == 1)) {
    {
#line 499
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  499U, "cf_player_move");
    }
  }
#line 500
  return (ret);
}
}
#line 502 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_move(object *op , int dir , object *originator ) 
{ 
  int type ;
  int ret ;

  {
  {
#line 505
  (*cfapiObject_move)(& type, 0, op, dir, originator, & ret);
  }
#line 506
  if (! (type == 1)) {
    {
#line 506
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  506U, "cf_object_move");
    }
  }
#line 507
  return (ret);
}
}
#line 513 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_apply(object *op , object *tmp , int aflag ) 
{ 
  int type ;
  int ret ;

  {
  {
#line 516
  (*cfapiObject_apply)(& type, op, tmp, aflag, & ret);
  }
#line 517
  return (ret);
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_object_apply_below(object *pl ) 
{ 
  int type ;

  {
  {
#line 527
  (*cfapiObject_apply_below)(& type, pl);
  }
#line 528
  return;
}
}
#line 533 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_object_remove(object *op ) 
{ 
  int type ;

  {
  {
#line 536
  (*cfapiObject_remove)(& type, op);
  }
#line 537
  return;
}
}
#line 542 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_object_free_drop_inventory(object *ob ) 
{ 
  int type ;

  {
  {
#line 545
  (*cfapiObject_delete)(& type, ob);
  }
#line 546
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
object *cf_object_present_archname_inside(object *op , char *whatstr ) 
{ 
  int type ;
  object *value ;

  {
  {
#line 554
  (*cfapiObject_find_archetype_inside)(& type, op, whatstr, & value);
  }
#line 555
  if (! (type == 5)) {
    {
#line 555
    __assert_fail("type == 5", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  555U, "cf_object_present_archname_inside");
    }
  }
#line 556
  return (value);
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
object *cf_object_find_by_arch_name(object const   *who , char const   *name ) 
{ 
  int type ;
  object *result ;

  {
  {
#line 567
  (*cfapiObject_find_by_arch_name)(& type, who, name, & result);
  }
#line 568
  if (! (type == 5)) {
    {
#line 568
    __assert_fail("type == 5", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  568U, "cf_object_find_by_arch_name");
    }
  }
#line 569
  return (result);
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
object *cf_object_find_by_name(object const   *who , char const   *name ) 
{ 
  int type ;
  object *result ;

  {
  {
#line 580
  (*cfapiObject_find_by_name)(& type, who, name, & result);
  }
#line 581
  if (! (type == 5)) {
    {
#line 581
    __assert_fail("type == 5", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  581U, "cf_object_find_by_name");
    }
  }
#line 582
  return (result);
}
}
#line 589 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_transfer(object *op , int x , int y , int randomly , object *originator ) 
{ 
  int type ;
  int value ;

  {
  {
#line 592
  (*cfapiObject_transfer)(& type, op, 0, x, y, randomly, originator, & value);
  }
#line 593
  if (! (type == 1)) {
    {
#line 593
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  593U, "cf_object_transfer");
    }
  }
#line 594
  return (value);
}
}
#line 601 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_move_to(object *op , int x , int y ) 
{ 
  int type ;
  int value ;

  {
  {
#line 604
  (*cfapiObject_transfer)(& type, op, 2, x, y, & value);
  }
#line 605
  if (! (type == 1)) {
    {
#line 605
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  605U, "cf_object_move_to");
    }
  }
#line 606
  return (value);
}
}
#line 613 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
object *cf_object_change_map(object *op , mapstruct *m , object *originator , int flag ,
                             int x , int y ) 
{ 
  int type ;
  object *value ;

  {
  {
#line 617
  (*cfapiObject_transfer)(& type, op, 1, m, originator, flag, x, y, & value);
  }
#line 618
  if (! (type == 5)) {
    {
#line 618
    __assert_fail("type == 5", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  618U, "cf_object_change_map");
    }
  }
#line 619
  return (value);
}
}
#line 626 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
object *cf_map_get_object_at(mapstruct *m , int x , int y ) 
{ 
  int type ;
  object *value ;

  {
  {
#line 630
  (*cfapiMap_get_object_at)(& type, m, x, y, & value);
  }
#line 631
  if (! (type == 5)) {
    {
#line 631
    __assert_fail("type == 5", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  631U, "cf_map_get_object_at");
    }
  }
#line 632
  return (value);
}
}
#line 638 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_map_message(mapstruct *m , char const   *msg , int color ) 
{ 
  int type ;

  {
  {
#line 641
  (*cfapiMap_message)(& type, m, msg, color);
  }
#line 642
  return;
}
}
#line 654 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
object *cf_object_clone(object *op , int clonetype ) 
{ 
  int type ;
  object *value ;

  {
  {
#line 658
  (*cfapiObject_clone)(& type, op, clonetype, & value);
  }
#line 659
  if (! (type == 5)) {
    {
#line 659
    __assert_fail("type == 5", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  659U, "cf_object_clone");
    }
  }
#line 660
  return (value);
}
}
#line 668 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
object *cf_object_split(object *orig_ob , uint32 nr , char *err , size_t size ) 
{ 
  int type ;
  object *value ;

  {
  {
#line 672
  (*cfapiObject_split)(& type, orig_ob, nr, err, size, & value);
  }
#line 674
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 676
    if (! (type == 0)) {
      {
#line 676
      __assert_fail("type == 0", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                    676U, "cf_object_split");
      }
    }
  } else
#line 680
  if (! (type == 5)) {
    {
#line 680
    __assert_fail("type == 5", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  680U, "cf_object_split");
    }
  }
#line 683
  return (value);
}
}
#line 691 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_pay_item(object *op , object *pl ) 
{ 
  int type ;
  int value ;

  {
  {
#line 694
  (*cfapiObject_pay_item)(& type, op, pl, & value);
  }
#line 695
  if (! (type == 1)) {
    {
#line 695
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  695U, "cf_object_pay_item");
    }
  }
#line 696
  return (value);
}
}
#line 703 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_pay_amount(object *pl , uint64 to_pay ) 
{ 
  int type ;
  int value ;

  {
  {
#line 706
  (*cfapiObject_pay_amount)(& type, pl, to_pay, & value);
  }
#line 707
  if (! (type == 1)) {
    {
#line 707
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  707U, "cf_object_pay_amount");
    }
  }
#line 708
  return (value);
}
}
#line 715 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_cast_spell(object *op , object *caster , int dir , object *spell_ob ,
                         char *stringarg ) 
{ 
  int type ;
  int value ;

  {
  {
#line 718
  (*cfapiObject_cast)(& type, op, caster, dir, spell_ob, stringarg, & value);
  }
#line 719
  if (! (type == 1)) {
    {
#line 719
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  719U, "cf_object_cast_spell");
    }
  }
#line 720
  return (value);
}
}
#line 727 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_cast_ability(object *caster , object *ctoo , int dir , object *sp ,
                           char *flags ) 
{ 
  int type ;
  int value ;

  {
  {
#line 730
  (*cfapiObject_cast)(& type, caster, ctoo, dir, sp, flags, & value);
  }
#line 731
  if (! (type == 1)) {
    {
#line 731
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  731U, "cf_object_cast_ability");
    }
  }
#line 732
  return (value);
}
}
#line 739 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_object_learn_spell(object *op , object *spell , int special_prayer ) 
{ 
  int type ;

  {
  {
#line 742
  (*cfapiObject_learn_spell)(& type, op, spell, special_prayer);
  }
#line 743
  if (! (type == 0)) {
    {
#line 743
    __assert_fail("type == 0", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  743U, "cf_object_learn_spell");
    }
  }
#line 744
  return;
}
}
#line 751 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_object_forget_spell(object *op , object *sp ) 
{ 
  int type ;

  {
  {
#line 754
  (*cfapiObject_forget_spell)(& type, op, sp);
  }
#line 755
  return;
}
}
#line 761 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
object *cf_object_check_for_spell(object *op , char const   *name ) 
{ 
  int type ;
  object *value ;

  {
  {
#line 765
  (*cfapiObject_check_spell)(& type, op, name, & value);
  }
#line 766
  if (! (type == 5)) {
    {
#line 766
    __assert_fail("type == 5", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  766U, "cf_object_check_for_spell");
    }
  }
#line 767
  return (value);
}
}
#line 770 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_player_message(object *op , char *txt , int flags ) 
{ 
  int type ;

  {
  {
#line 773
  (*cfapiPlayer_message)(& type, flags, 0, op, txt);
  }
#line 774
  if (! (type == 0)) {
    {
#line 774
    __assert_fail("type == 0", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  774U, "cf_player_message");
    }
  }
#line 775
  return;
}
}
#line 781 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_remove_depletion(object *op , int level ) 
{ 
  int type ;
  int result ;

  {
  {
#line 784
  (*cfapiObject_remove_depletion)(& type, op, level, & result);
  }
#line 785
  if (! (type == 1)) {
    {
#line 785
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  785U, "cf_object_remove_depletion");
    }
  }
#line 786
  return (result);
}
}
#line 795 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
object *cf_identify(object *op ) 
{ 
  int type ;
  object *result ;

  {
  {
#line 799
  (*cfapiObject_identify)(& type, op, & result);
  }
#line 800
  if (! (type == 5)) {
    {
#line 800
    __assert_fail("type == 5", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  800U, "cf_identify");
    }
  }
#line 801
  return (result);
}
}
#line 808 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
player *cf_player_find(char const   *plname ) 
{ 
  int type ;
  player *value ;

  {
  {
#line 812
  (*cfapiPlayer_find)(& type, plname, & value);
  }
#line 813
  if (! (type == 11)) {
    {
#line 813
    __assert_fail("type == 11", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  813U, "cf_player_find");
    }
  }
#line 814
  return (value);
}
}
#line 817 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
char *cf_player_get_title(object *op , char *title , int size ) 
{ 
  int type ;

  {
  {
#line 820
  (*cfapiObject_get_property)(& type, op, 157, title, size);
  }
#line 821
  if (! (type == 4)) {
    {
#line 821
    __assert_fail("type == 4", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  821U, "cf_player_get_title");
    }
  }
#line 822
  return (title);
}
}
#line 825 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_player_set_title(object *op , char const   *title ) 
{ 
  int type ;

  {
  {
#line 828
  (*cfapiObject_set_property)(& type, op, 157, title);
  }
#line 829
  return;
}
}
#line 831 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
sstring cf_player_get_ip(object *op ) 
{ 
  int type ;
  sstring value ;

  {
  {
#line 835
  (*cfapiObject_get_property)(& type, op, 150, & value);
  }
#line 836
  if (! (type == 17)) {
    {
#line 836
    __assert_fail("type == 17", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  836U, "cf_player_get_ip");
    }
  }
#line 837
  return (value);
}
}
#line 840 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
object *cf_player_get_marked_item(object *op ) 
{ 
  int type ;
  object *value ;

  {
  {
#line 844
  (*cfapiObject_get_property)(& type, op, 151, & value);
  }
#line 845
  if (! (type == 5)) {
    {
#line 845
    __assert_fail("type == 5", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  845U, "cf_player_get_marked_item");
    }
  }
#line 846
  return (value);
}
}
#line 849 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_player_set_marked_item(object *op , object *ob ) 
{ 
  int type ;

  {
  {
#line 852
  (*cfapiObject_set_property)(& type, op, 151, ob);
  }
#line 853
  return;
}
}
#line 855 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
partylist *cf_player_get_party(object *op ) 
{ 
  partylist *tmp ;

  {
  {
#line 856
  tmp = cf_object_get_partylist_property(op, 152);
  }
#line 856
  return (tmp);
}
}
#line 859 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_player_set_party(object *op , partylist *party ) 
{ 
  int type ;

  {
  {
#line 862
  (*cfapiObject_set_property)(& type, op, 152, party);
  }
#line 863
  return;
}
}
#line 869 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_player_can_pay(object *pl ) 
{ 
  int type ;
  int value ;

  {
  {
#line 872
  (*cfapiPlayer_can_pay)(& type, pl, & value);
  }
#line 873
  if (! (type == 1)) {
    {
#line 873
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  873U, "cf_player_can_pay");
    }
  }
#line 874
  return (value);
}
}
#line 883 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_player_knowledge_has(object *op , char const   *knowledge ) 
{ 
  int type ;
  int value ;

  {
  {
#line 886
  (*cfapiPlayer_knowledge)(& type, 1, op, knowledge, & value);
  }
#line 887
  if (! (type == 1)) {
    {
#line 887
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  887U, "cf_player_knowledge_has");
    }
  }
#line 888
  return (value);
}
}
#line 895 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_player_arrest(object *who ) 
{ 
  int type ;
  int value ;

  {
  {
#line 897
  (*cfapiObject_move)(& type, 2, who, & value);
  }
#line 898
  if (! (type == 1)) {
    {
#line 898
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  898U, "cf_player_arrest");
    }
  }
#line 899
  return (value);
}
}
#line 906 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
mapstruct *cf_map_get_map(char const   *name , int flags ) 
{ 
  int type ;
  mapstruct *ret ;

  {
  {
#line 910
  (*cfapiMap_get_map)(& type, 1, name, flags, & ret);
  }
#line 911
  if (! (type == 6)) {
    {
#line 911
    __assert_fail("type == 6", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  911U, "cf_map_get_map");
    }
  }
#line 912
  return (ret);
}
}
#line 919 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
mapstruct *cf_get_empty_map(int sizex , int sizey ) 
{ 
  int type ;
  mapstruct *ret ;

  {
  {
#line 923
  (*cfapiMap_get_map)(& type, 0, sizex, sizey, & ret);
  }
#line 924
  if (! (type == 6)) {
    {
#line 924
    __assert_fail("type == 6", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  924U, "cf_get_empty_map");
    }
  }
#line 925
  return (ret);
}
}
#line 932 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
mapstruct *cf_map_has_been_loaded(char const   *name ) 
{ 
  int type ;
  mapstruct *ret ;

  {
  {
#line 936
  (*cfapiMap_has_been_loaded)(& type, name, & ret);
  }
#line 937
  if (! (type == 6)) {
    {
#line 937
    __assert_fail("type == 6", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  937U, "cf_map_has_been_loaded");
    }
  }
#line 938
  return (ret);
}
}
#line 946 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
mapstruct *cf_map_get_first(void) 
{ 
  mapstruct *tmp ;

  {
  {
#line 947
  tmp = cf_map_get_map_property((mapstruct *)((void *)0), 23);
  }
#line 947
  return (tmp);
}
}
#line 954 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_query_money(object const   *op ) 
{ 
  int type ;
  int value ;

  {
  {
#line 957
  (*cfapiObject_query_money)(& type, op, & value);
  }
#line 958
  if (! (type == 1)) {
    {
#line 958
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  958U, "cf_object_query_money");
    }
  }
#line 959
  return (value);
}
}
#line 966 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_query_cost(object const   *tmp , object *who , int flag ) 
{ 
  int type ;
  int value ;

  {
  {
#line 969
  (*cfapiObject_query_cost)(& type, tmp, who, flag, & value);
  }
#line 970
  if (! (type == 1)) {
    {
#line 970
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  970U, "cf_object_query_cost");
    }
  }
#line 971
  return (value);
}
}
#line 977 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_object_query_cost_string(object const   *tmp , object *who , int flag , char *buffer ,
                                 int length ) 
{ 
  int type ;

  {
  {
#line 980
  (*cfapiObject_query_cost_string)(& type, tmp, who, flag, buffer, length);
  }
#line 981
  if (! (type == 0)) {
    {
#line 981
    __assert_fail("type == 0", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  981U, "cf_object_query_cost_string");
    }
  }
#line 982
  return;
}
}
#line 987 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_cost_string_from_value(uint64 cost , int largest_coin , char *buffer , int length ) 
{ 
  int type ;

  {
  {
#line 990
  (*cfapiCost_string_from_value)(& type, cost, largest_coin, buffer, length);
  }
#line 991
  if (! (type == 0)) {
    {
#line 991
    __assert_fail("type == 0", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  991U, "cf_cost_string_from_value");
    }
  }
#line 992
  return;
}
}
#line 998 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_spring_trap(object *trap , object *victim ) 
{ 
  int type ;

  {
#line 1001
  if (trap) {
    {
#line 1002
    (*cfapiObject_activate_rune)(& type, trap, victim);
    }
  }
#line 1003
  return;
}
}
#line 1009 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_check_trigger(object *op , object *cause ) 
{ 
  int type ;
  int value ;

  {
  {
#line 1012
  (*cfapiObject_check_trigger)(& type, op, cause, & value);
  }
#line 1013
  if (! (type == 1)) {
    {
#line 1013
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1013U, "cf_object_check_trigger");
    }
  }
#line 1014
  return (value);
}
}
#line 1021 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_map_trigger_connected(objectlink *ol , object *cause , int state ) 
{ 
  int type ;

  {
  {
#line 1024
  (*cfapiMap_trigger_connected)(& type, ol, cause, state);
  }
#line 1025
  if (! (type == 0)) {
    {
#line 1025
    __assert_fail("type == 0", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1025U, "cf_map_trigger_connected");
    }
  }
#line 1026
  return;
}
}
#line 1028 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_out_of_map(object *op , int x , int y ) 
{ 
  int type ;
  int value ;

  {
  {
#line 1031
  (*cfapiObject_out_of_map)(& type, op->map, x, y, & value);
  }
#line 1032
  if (! (type == 1)) {
    {
#line 1032
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1032U, "cf_object_out_of_map");
    }
  }
#line 1033
  return (value);
}
}
#line 1036 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_object_drop(object *op , object *author ) 
{ 
  int type ;

  {
  {
#line 1039
  (*cfapiObject_drop)(& type, op, author);
  }
#line 1040
  return;
}
}
#line 1042 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_object_say(object *op , char *msg ) 
{ 
  int type ;
  int value ;

  {
  {
#line 1045
  (*cfapiObject_say)(& type, op, msg, & value);
  }
#line 1046
  if (! (type == 1)) {
    {
#line 1046
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1046U, "cf_object_say");
    }
  }
#line 1047
  return;
}
}
#line 1049 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
object *cf_object_insert_object(object *op , object *container ) 
{ 
  int type ;
  object *value ;

  {
  {
#line 1053
  (*cfapiObject_insert)(& type, op, 3, container, & value);
  }
#line 1054
  if (! (type == 5)) {
    {
#line 1054
    __assert_fail("type == 5", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1054U, "cf_object_insert_object");
    }
  }
#line 1055
  return (value);
}
}
#line 1062 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
char *cf_get_maps_directory(char const   *name , char *buf , int size ) 
{ 
  int type ;

  {
  {
#line 1065
  (*cfapiMap_create_path)(& type, 0, name, buf, size);
  }
#line 1066
  if (! (type == 4)) {
    {
#line 1066
    __assert_fail("type == 4", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1066U, "cf_get_maps_directory");
    }
  }
#line 1067
  return (buf);
}
}
#line 1074 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
object *cf_create_object(void) 
{ 
  int type ;
  object *value ;

  {
  {
#line 1078
  (*cfapiObject_create)(& type, 0, & value);
  }
#line 1079
  if (! (type == 5)) {
    {
#line 1079
    __assert_fail("type == 5", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1079U, "cf_create_object");
    }
  }
#line 1080
  return (value);
}
}
#line 1086 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
object *cf_create_object_by_name(char const   *name ) 
{ 
  int type ;
  object *value ;

  {
  {
#line 1090
  (*cfapiObject_create)(& type, 1, name, & value);
  }
#line 1091
  if (! (type == 5)) {
    {
#line 1091
    __assert_fail("type == 5", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1091U, "cf_create_object_by_name");
    }
  }
#line 1092
  return (value);
}
}
#line 1095 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_system_register_global_event(int event , char const   *name , int (*hook)(int *type 
                                                                                  , ...) ) 
{ 
  int type ;

  {
  {
#line 1098
  (*cfapiSystem_register_global_event)(& type, event, name, hook);
  }
#line 1099
  if (! (type == 0)) {
    {
#line 1099
    __assert_fail("type == 0", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1099U, "cf_system_register_global_event");
    }
  }
#line 1100
  return;
}
}
#line 1102 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_system_unregister_global_event(int event , char const   *name ) 
{ 
  int type ;

  {
  {
#line 1105
  (*cfapiSystem_unregister_global_event)(& type, event, name);
  }
#line 1106
  if (! (type == 0)) {
    {
#line 1106
    __assert_fail("type == 0", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1106U, "cf_system_unregister_global_event");
    }
  }
#line 1107
  return;
}
}
#line 1123 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
char const   *cf_get_directory(int id ) 
{ 
  int type ;
  char const   *ret ;

  {
  {
#line 1127
  (*cfapiSystem_directory)(& type, id, & ret);
  }
#line 1128
  if (! (type == 4)) {
    {
#line 1128
    __assert_fail("type == 4", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1128U, "cf_get_directory");
    }
  }
#line 1129
  return (ret);
}
}
#line 1136 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
char const   *cf_re_cmp(char const   *str , char const   *regexp ) 
{ 
  int type ;
  char const   *result ;

  {
  {
#line 1140
  (*cfapiSystem_re_cmp)(& type, str, regexp, & result);
  }
#line 1141
  if (! (type == 4)) {
    {
#line 1141
    __assert_fail("type == 4", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1141U, "cf_re_cmp");
    }
  }
#line 1142
  return (result);
}
}
#line 1149 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_fix_object(object *op ) 
{ 
  int type ;

  {
#line 1152
  if (op) {
    {
#line 1153
    (*cfapiObject_fix)(& type, op);
    }
  }
#line 1154
  return;
}
}
#line 1160 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
sstring cf_add_string(char const   *str ) 
{ 
  int type ;
  sstring ret ;

  {
#line 1164
  if (! str) {
#line 1165
    return ((sstring )((void *)0));
  }
  {
#line 1166
  (*cfapiSystem_add_string)(& type, str, & ret);
  }
#line 1167
  if (! (type == 17)) {
    {
#line 1167
    __assert_fail("type == 17", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1167U, "cf_add_string");
    }
  }
#line 1168
  return (ret);
}
}
#line 1175 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_free_string(sstring str ) 
{ 
  int type ;

  {
#line 1178
  if (str) {
    {
#line 1179
    (*cfapiSystem_remove_string)(& type, str);
    }
  }
#line 1180
  return;
}
}
#line 1182 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
sstring cf_find_string(char const   *str ) 
{ 
  int type ;
  sstring ret ;

  {
#line 1186
  if (! str) {
#line 1187
    return ((sstring )((void *)0));
  }
  {
#line 1189
  (*cfapiSystem_find_string)(& type, str, & ret);
  }
#line 1190
  if (! (type == 17)) {
    {
#line 1190
    __assert_fail("type == 17", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1190U, "cf_find_string");
    }
  }
#line 1191
  return (ret);
}
}
#line 1194 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
char *cf_query_name(object *ob , char *name , int size ) 
{ 
  int type ;

  {
  {
#line 1197
  (*cfapiObject_get_property)(& type, ob, 12, name, size);
  }
#line 1198
  if (! (type == 4)) {
    {
#line 1198
    __assert_fail("type == 4", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1198U, "cf_query_name");
    }
  }
#line 1199
  return (name);
}
}
#line 1202 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
sstring cf_query_name_pl(object *ob ) 
{ 
  int type ;
  sstring value ;

  {
  {
#line 1206
  (*cfapiObject_get_property)(& type, ob, 13, & value);
  }
#line 1207
  if (! (type == 17)) {
    {
#line 1207
    __assert_fail("type == 17", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1207U, "cf_query_name_pl");
    }
  }
#line 1208
  return (value);
}
}
#line 1211 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
char *cf_query_base_name(object *ob , int plural , char *name , int size ) 
{ 
  int type ;

  {
  {
#line 1214
  (*cfapiObject_get_property)(& type, ob, 69, name, size);
  }
#line 1215
  if (! (type == 4)) {
    {
#line 1215
    __assert_fail("type == 4", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1215U, "cf_query_base_name");
    }
  }
#line 1216
  return (name);
}
}
#line 1219 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
char const   *cf_object_get_msg(object *ob ) 
{ 
  int type ;
  sstring value ;

  {
  {
#line 1223
  (*cfapiObject_get_property)(& type, ob, 18, & value);
  }
#line 1224
  if (! (type == 17)) {
    {
#line 1224
    __assert_fail("type == 17", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1224U, "cf_object_get_msg");
    }
  }
#line 1225
  return (value);
}
}
#line 1228 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_object_set_weight(object *ob , int weight ) 
{ 
  int type ;

  {
  {
#line 1231
  (*cfapiObject_set_property)(& type, ob, 48, weight);
  }
#line 1232
  if (! (type == 1)) {
    {
#line 1232
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1232U, "cf_object_set_weight");
    }
  }
#line 1233
  return;
}
}
#line 1235 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_object_set_weight_limit(object *ob , int weight_limit ) 
{ 
  int type ;

  {
  {
#line 1238
  (*cfapiObject_set_property)(& type, ob, 49, weight_limit);
  }
#line 1239
  if (! (type == 1)) {
    {
#line 1239
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1239U, "cf_object_set_weight_limit");
    }
  }
#line 1240
  return;
}
}
#line 1242 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_get_weight(object *ob ) 
{ 
  int type ;
  int weight ;

  {
  {
#line 1245
  (*cfapiObject_get_property)(& type, ob, 48, & weight);
  }
#line 1246
  if (! (type == 1)) {
    {
#line 1246
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1246U, "cf_object_get_weight");
    }
  }
#line 1247
  return (weight);
}
}
#line 1250 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_get_weight_limit(object *ob ) 
{ 
  int type ;
  int limit ;

  {
  {
#line 1253
  (*cfapiObject_get_property)(& type, ob, 49, & limit);
  }
#line 1254
  if (! (type == 1)) {
    {
#line 1254
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1254U, "cf_object_get_weight_limit");
    }
  }
#line 1255
  return (limit);
}
}
#line 1261 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_set_nrof(object *ob , int nrof ) 
{ 
  int type ;

  {
#line 1264
  if (nrof < 0) {
#line 1265
    return (-1);
  }
  {
#line 1267
  (*cfapiObject_set_property)(& type, ob, 24, nrof);
  }
#line 1268
  return (0);
}
}
#line 1271 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_get_nrof(object *ob ) 
{ 
  int type ;
  int nrof ;

  {
  {
#line 1274
  (*cfapiObject_get_property)(& type, ob, 24, & nrof);
  }
#line 1275
  return (nrof);
}
}
#line 1278 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_get_flag(object *ob , int flag ) 
{ 
  int type ;
  int rv ;

  {
  {
#line 1282
  (*cfapiObject_get_property)(& type, ob, 78, flag, & rv);
  }
#line 1283
  if (rv != 0) {
#line 1284
    return (1);
  } else {
#line 1286
    return (0);
  }
}
}
#line 1289 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_object_set_flag(object *ob , int flag , int value ) 
{ 
  int type ;
  int tmp ;

  {
#line 1292
  if (value) {
#line 1292
    tmp = 1;
  } else {
#line 1292
    tmp = 0;
  }
  {
#line 1292
  (*cfapiObject_set_property)(& type, ob, 78, flag, tmp);
  }
#line 1293
  return;
}
}
#line 1299 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
object *cf_object_insert_in_ob(object *op , object *where ) 
{ 
  int type ;
  object *value ;
  int tmp ;

  {
  {
#line 1303
  tmp = cf_object_get_flag(op, 2);
  }
#line 1303
  if (! tmp) {
    {
#line 1304
    (*cfapiObject_remove)(& type, op);
    }
  }
  {
#line 1307
  (*cfapiObject_insert)(& type, op, 3, where, & value);
  }
#line 1308
  if (! (type == 5)) {
    {
#line 1308
    __assert_fail("type == 5", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1308U, "cf_object_insert_in_ob");
    }
  }
#line 1309
  return (value);
}
}
#line 1316 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
object *cf_map_insert_object_there(object *op , mapstruct *m , object *originator ,
                                   int flag ) 
{ 
  int type ;
  object *value ;

  {
  {
#line 1320
  (*cfapiObject_insert)(& type, op, 1, m, originator, flag, & value);
  }
#line 1321
  if (! (type == 5)) {
    {
#line 1321
    __assert_fail("type == 5", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1321U, "cf_map_insert_object_there");
    }
  }
#line 1322
  return (value);
}
}
#line 1330 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
object *cf_map_insert_object(mapstruct *where , object *op , int x , int y ) 
{ 
  int type ;
  object *value ;

  {
  {
#line 1334
  (*cfapiObject_insert)(& type, op, 0, where, (void *)0, 0, x, y, & value);
  }
#line 1335
  if (! (type == 5)) {
    {
#line 1335
    __assert_fail("type == 5", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1335U, "cf_map_insert_object");
    }
  }
#line 1336
  return (value);
}
}
#line 1352 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
object *cf_map_insert_object_around(mapstruct *where , object *op , int x , int y ) 
{ 
  int type ;
  object *value ;

  {
  {
#line 1356
  (*cfapiObject_insert)(& type, op, 2, where, (void *)0, 0, x, y, & value);
  }
#line 1357
  if (! (type == 5)) {
    {
#line 1357
    __assert_fail("type == 5", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1357U, "cf_map_insert_object_around");
    }
  }
#line 1358
  return (value);
}
}
#line 1361 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_teleport(object *op , mapstruct *map , int x , int y ) 
{ 
  int type ;
  int value ;

  {
  {
#line 1364
  (*cfapiObject_teleport)(& type, op, map, x, y, & value);
  }
#line 1365
  if (! (type == 1)) {
    {
#line 1365
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1365U, "cf_object_teleport");
    }
  }
#line 1366
  return (value);
}
}
#line 1372 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
object *cf_map_find_by_archetype_name(char const   *str , mapstruct *map , int nx ,
                                      int ny ) 
{ 
  int type ;
  object *value ;

  {
  {
#line 1376
  (*cfapiMap_find_by_archetype_name)(& type, str, map, nx, ny, & value);
  }
#line 1377
  if (! (type == 5)) {
    {
#line 1377
    __assert_fail("type == 5", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1377U, "cf_map_find_by_archetype_name");
    }
  }
#line 1378
  return (value);
}
}
#line 1381 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_map_get_difficulty(mapstruct *map ) 
{ 
  int tmp ;

  {
  {
#line 1382
  tmp = cf_map_get_int_property(map, 1);
  }
#line 1382
  return (tmp);
}
}
#line 1385 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_map_get_reset_time(mapstruct *map ) 
{ 
  int tmp ;

  {
  {
#line 1386
  tmp = cf_map_get_int_property(map, 5);
  }
#line 1386
  return (tmp);
}
}
#line 1389 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_map_get_reset_timeout(mapstruct *map ) 
{ 
  int tmp ;

  {
  {
#line 1390
  tmp = cf_map_get_int_property(map, 6);
  }
#line 1390
  return (tmp);
}
}
#line 1393 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_map_get_players(mapstruct *map ) 
{ 
  int tmp ;

  {
  {
#line 1394
  tmp = cf_map_get_int_property(map, 7);
  }
#line 1394
  return (tmp);
}
}
#line 1397 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_map_get_darkness(mapstruct *map ) 
{ 
  int tmp ;

  {
  {
#line 1398
  tmp = cf_map_get_int_property(map, 9);
  }
#line 1398
  return (tmp);
}
}
#line 1401 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_map_get_width(mapstruct *map ) 
{ 
  int tmp ;

  {
  {
#line 1402
  tmp = cf_map_get_int_property(map, 10);
  }
#line 1402
  return (tmp);
}
}
#line 1405 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_map_get_height(mapstruct *map ) 
{ 
  int tmp ;

  {
  {
#line 1406
  tmp = cf_map_get_int_property(map, 11);
  }
#line 1406
  return (tmp);
}
}
#line 1409 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_map_get_enter_x(mapstruct *map ) 
{ 
  int tmp ;

  {
  {
#line 1410
  tmp = cf_map_get_int_property(map, 12);
  }
#line 1410
  return (tmp);
}
}
#line 1413 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_map_get_enter_y(mapstruct *map ) 
{ 
  int tmp ;

  {
  {
#line 1414
  tmp = cf_map_get_int_property(map, 13);
  }
#line 1414
  return (tmp);
}
}
#line 1421 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_map_change_light(mapstruct *m , int change ) 
{ 
  int type ;
  int value ;

  {
  {
#line 1424
  (*cfapiMap_change_light)(& type, m, change, & value);
  }
#line 1425
  if (! (type == 1)) {
    {
#line 1425
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1425U, "cf_map_change_light");
    }
  }
#line 1426
  return (value);
}
}
#line 1429 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_object_update(object *op , int flags ) 
{ 
  int type ;

  {
  {
#line 1432
  (*cfapiObject_update)(& type, op, flags);
  }
#line 1433
  return;
}
}
#line 1435 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_object_pickup(object *op , object *what ) 
{ 
  int type ;

  {
  {
#line 1438
  (*cfapiObject_pickup)(& type, op, what);
  }
#line 1439
  if (! (type == 0)) {
    {
#line 1439
    __assert_fail("type == 0", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1439U, "cf_object_pickup");
    }
  }
#line 1440
  return;
}
}
#line 1447 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
char *cf_strdup_local(char const   *str ) 
{ 
  int type ;
  char *dup___0 ;

  {
#line 1451
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 1452
    return ((char *)((void *)0));
  }
  {
#line 1453
  (*cfapiSystem_strdup_local)(& type, str, & dup___0);
  }
#line 1454
  if (! (type == 4)) {
    {
#line 1454
    __assert_fail("type == 4", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1454U, "cf_strdup_local");
    }
  }
#line 1455
  return (dup___0);
}
}
#line 1462 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_map_get_flags(mapstruct *oldmap , mapstruct **newmap , sint16 x , sint16 y ,
                     sint16 *nx , sint16 *ny ) 
{ 
  int type ;
  int value ;

  {
  {
#line 1465
  (*cfapiMap_get_property)(& type, oldmap, 0, newmap, (int )x, (int )y, nx, ny, & value);
  }
#line 1466
  if (! (type == 1)) {
    {
#line 1466
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1466U, "cf_map_get_flags");
    }
  }
#line 1467
  return (value);
}
}
#line 1474 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_random_map_set_variable(RMParms *rp , char const   *buf ) 
{ 
  int type ;
  int ret ;

  {
  {
#line 1477
  (*cfapiSet_random_map_variable)(& type, rp, buf, & ret);
  }
#line 1478
  if (! (type == 1)) {
    {
#line 1478
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1478U, "cf_random_map_set_variable");
    }
  }
#line 1479
  return (ret);
}
}
#line 1486 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
mapstruct *cf_random_map_generate(char const   *OutFileName , RMParms *RP , char **use_layout ) 
{ 
  int type ;
  mapstruct *map ;

  {
  {
#line 1490
  (*cfapiGenerate_random_map)(& type, OutFileName, RP, use_layout, & map);
  }
#line 1491
  if (! (type == 6)) {
    {
#line 1491
    __assert_fail("type == 6", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1491U, "cf_random_map_generate");
    }
  }
#line 1492
  return (map);
}
}
#line 1499 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_find_animation(char const   *name ) 
{ 
  int type ;
  int anim ;

  {
  {
#line 1502
  (*cfapiSystem_find_animation)(& type, name, & anim);
  }
#line 1503
  if (! (type == 1)) {
    {
#line 1503
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1503U, "cf_find_animation");
    }
  }
#line 1504
  return (anim);
}
}
#line 1511 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_find_face(char const   *name , int error ) 
{ 
  int type ;
  int anim ;

  {
  {
#line 1514
  (*cfapiSystem_find_face)(& type, name, error, & anim);
  }
#line 1515
  if (! (type == 1)) {
    {
#line 1515
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1515U, "cf_find_face");
    }
  }
#line 1516
  return (anim);
}
}
#line 1523 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_log(LogLevel logLevel , char const   *format  , ...) 
{ 
  int type ;
  char buf[20480] ;
  va_list ap ;

  {
  {
#line 1530
  __builtin_va_start(ap, format);
#line 1531
  buf[0] = (char )'\000';
#line 1532
  vsprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)format,
           ap);
#line 1533
  __builtin_va_end(ap);
#line 1535
  (*cfapiSystem_log)(& type, (unsigned int )logLevel, buf);
  }
#line 1536
  if (! (type == 0)) {
    {
#line 1536
    __assert_fail("type == 0", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1536U, "cf_log");
    }
  }
#line 1537
  return;
}
}
#line 1543 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_log_plain(LogLevel logLevel , char const   *message ) 
{ 
  int type ;

  {
  {
#line 1546
  (*cfapiSystem_log)(& type, (unsigned int )logLevel, message);
  }
#line 1547
  if (! (type == 0)) {
    {
#line 1547
    __assert_fail("type == 0", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1547U, "cf_log_plain");
    }
  }
#line 1548
  return;
}
}
#line 1550 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_get_time(timeofday_t *tod ) 
{ 
  int type ;

  {
  {
#line 1553
  (*cfapiSystem_get_time)(& type, tod);
  }
#line 1554
  if (! (type == 0)) {
    {
#line 1554
    __assert_fail("type == 0", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1554U, "cf_get_time");
    }
  }
#line 1555
  return;
}
}
#line 1557 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
char const   *cf_get_season_name(int index___0 ) 
{ 
  int type ;
  char *result ;

  {
  {
#line 1561
  (*cfapiSystem_get_season_name)(& type, index___0, & result);
  }
#line 1562
  if (! (type == 4)) {
    {
#line 1562
    __assert_fail("type == 4", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1562U, "cf_get_season_name");
    }
  }
#line 1563
  return ((char const   *)result);
}
}
#line 1566 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
char const   *cf_get_month_name(int index___0 ) 
{ 
  int type ;
  char *result ;

  {
  {
#line 1570
  (*cfapiSystem_get_month_name)(& type, index___0, & result);
  }
#line 1571
  if (! (type == 4)) {
    {
#line 1571
    __assert_fail("type == 4", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1571U, "cf_get_month_name");
    }
  }
#line 1572
  return ((char const   *)result);
}
}
#line 1575 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
char const   *cf_get_weekday_name(int index___0 ) 
{ 
  int type ;
  char *result ;

  {
  {
#line 1579
  (*cfapiSystem_get_weekday_name)(& type, index___0, & result);
  }
#line 1580
  if (! (type == 4)) {
    {
#line 1580
    __assert_fail("type == 4", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1580U, "cf_get_weekday_name");
    }
  }
#line 1581
  return ((char const   *)result);
}
}
#line 1584 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
char const   *cf_get_periodofday_name(int index___0 ) 
{ 
  int type ;
  char *result ;

  {
  {
#line 1588
  (*cfapiSystem_get_periodofday_name)(& type, index___0, & result);
  }
#line 1589
  if (! (type == 4)) {
    {
#line 1589
    __assert_fail("type == 4", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1589U, "cf_get_periodofday_name");
    }
  }
#line 1590
  return ((char const   *)result);
}
}
#line 1605 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_timer_create(object *ob , long delay , int mode ) 
{ 
  int type ;
  int timer ;

  {
  {
#line 1608
  (*cfapiSystem_timer_create)(& type, ob, delay, mode, & timer);
  }
#line 1609
  if (! (type == 1)) {
    {
#line 1609
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1609U, "cf_timer_create");
    }
  }
#line 1610
  return (timer);
}
}
#line 1621 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_timer_destroy(int id ) 
{ 
  int type ;
  int code ;

  {
  {
#line 1624
  (*cfapiSystem_timer_destroy)(& type, id, & code);
  }
#line 1625
  if (! (type == 1)) {
    {
#line 1625
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1625U, "cf_timer_destroy");
    }
  }
#line 1626
  return (code);
}
}
#line 1638 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
char const   *cf_object_get_key(object *op , char const   *keyname ) 
{ 
  int type ;
  char const   *value ;

  {
  {
#line 1642
  (*cfapiObject_get_key)(& type, op, keyname, & value);
  }
#line 1643
  if (! (type == 17)) {
    {
#line 1643
    __assert_fail("type == 17", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1643U, "cf_object_get_key");
    }
  }
#line 1644
  return (value);
}
}
#line 1660 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_set_key(object *op , char const   *keyname , char const   *value , int add_key ) 
{ 
  int type ;
  int ret ;

  {
  {
#line 1663
  (*cfapiObject_set_key)(& type, op, keyname, value, add_key, & ret);
  }
#line 1664
  if (! (type == 1)) {
    {
#line 1664
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1664U, "cf_object_set_key");
    }
  }
#line 1665
  return (ret);
}
}
#line 1672 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_object_change_abil(object *op , object *tmp ) 
{ 
  int type ;
  int ret ;

  {
  {
#line 1675
  (*cfapiObject_change_abil)(& type, op, tmp, & ret);
  }
#line 1676
  if (! (type == 1)) {
    {
#line 1676
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1676U, "cf_object_change_abil");
    }
  }
#line 1677
  return (ret);
}
}
#line 1687 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
archetype *cf_archetype_get_first(void) 
{ 
  int type ;
  archetype *value ;

  {
  {
#line 1691
  (*cfapiArchetype_get_property)(& type, (void *)0, 1, & value);
  }
#line 1692
  if (! (type == 9)) {
    {
#line 1692
    __assert_fail("type == 9", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1692U, "cf_archetype_get_first");
    }
  }
#line 1693
  return (value);
}
}
#line 1703 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
sstring cf_archetype_get_name(archetype *arch ) 
{ 
  int type ;
  sstring name ;

  {
  {
#line 1707
  (*cfapiArchetype_get_property)(& type, arch, 0, & name);
  }
#line 1708
  if (! (type == 17)) {
    {
#line 1708
    __assert_fail("type == 17", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1708U, "cf_archetype_get_name");
    }
  }
#line 1709
  return (name);
}
}
#line 1720 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
archetype *cf_archetype_get_next(archetype *arch ) 
{ 
  int type ;
  archetype *value ;

  {
  {
#line 1724
  (*cfapiArchetype_get_property)(& type, arch, 1, & value);
  }
#line 1725
  if (! (type == 9)) {
    {
#line 1725
    __assert_fail("type == 9", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1725U, "cf_archetype_get_next");
    }
  }
#line 1726
  return (value);
}
}
#line 1736 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
archetype *cf_archetype_get_more(archetype *arch ) 
{ 
  int type ;
  archetype *value ;

  {
  {
#line 1740
  (*cfapiArchetype_get_property)(& type, arch, 3, & value);
  }
#line 1741
  if (! (type == 9)) {
    {
#line 1741
    __assert_fail("type == 9", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1741U, "cf_archetype_get_more");
    }
  }
#line 1742
  return (value);
}
}
#line 1752 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
archetype *cf_archetype_get_head(archetype *arch ) 
{ 
  int type ;
  archetype *value ;

  {
  {
#line 1756
  (*cfapiArchetype_get_property)(& type, arch, 2, & value);
  }
#line 1757
  if (! (type == 9)) {
    {
#line 1757
    __assert_fail("type == 9", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1757U, "cf_archetype_get_head");
    }
  }
#line 1758
  return (value);
}
}
#line 1768 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
object *cf_archetype_get_clone(archetype *arch ) 
{ 
  int type ;
  object *value ;

  {
  {
#line 1772
  (*cfapiArchetype_get_property)(& type, arch, 4, & value);
  }
#line 1773
  if (! (type == 5)) {
    {
#line 1773
    __assert_fail("type == 5", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1773U, "cf_archetype_get_clone");
    }
  }
#line 1774
  return (value);
}
}
#line 1784 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
partylist *cf_party_get_first(void) 
{ 
  int type ;
  partylist *value ;

  {
  {
#line 1788
  (*cfapiParty_get_property)(& type, (void *)0, 1, & value);
  }
#line 1789
  if (! (type == 12)) {
    {
#line 1789
    __assert_fail("type == 12", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1789U, "cf_party_get_first");
    }
  }
#line 1790
  return (value);
}
}
#line 1799 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
char const   *cf_party_get_name(partylist *party ) 
{ 
  int type ;
  sstring value ;

  {
  {
#line 1803
  (*cfapiParty_get_property)(& type, party, 0, & value);
  }
#line 1804
  if (! (type == 17)) {
    {
#line 1804
    __assert_fail("type == 17", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1804U, "cf_party_get_name");
    }
  }
#line 1805
  return (value);
}
}
#line 1815 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
partylist *cf_party_get_next(partylist *party ) 
{ 
  int type ;
  partylist *value ;

  {
  {
#line 1819
  (*cfapiParty_get_property)(& type, party, 1, & value);
  }
#line 1820
  if (! (type == 12)) {
    {
#line 1820
    __assert_fail("type == 12", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1820U, "cf_party_get_next");
    }
  }
#line 1821
  return (value);
}
}
#line 1831 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
char const   *cf_party_get_password(partylist *party ) 
{ 
  int type ;
  sstring value ;

  {
  {
#line 1835
  (*cfapiParty_get_property)(& type, party, 2, & value);
  }
#line 1836
  if (! (type == 17)) {
    {
#line 1836
    __assert_fail("type == 17", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1836U, "cf_party_get_password");
    }
  }
#line 1837
  return (value);
}
}
#line 1847 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
player *cf_party_get_first_player(partylist *party ) 
{ 
  int type ;
  player *value ;

  {
  {
#line 1851
  (*cfapiParty_get_property)(& type, party, 3, (void *)0, & value);
  }
#line 1852
  if (! (type == 11)) {
    {
#line 1852
    __assert_fail("type == 11", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1852U, "cf_party_get_first_player");
    }
  }
#line 1853
  return (value);
}
}
#line 1865 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
player *cf_party_get_next_player(partylist *party , player *op ) 
{ 
  int type ;
  player *value ;

  {
  {
#line 1869
  (*cfapiParty_get_property)(& type, party, 3, op, & value);
  }
#line 1870
  if (! (type == 11)) {
    {
#line 1870
    __assert_fail("type == 11", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1870U, "cf_party_get_next_player");
    }
  }
#line 1871
  return (value);
}
}
#line 1879 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
region *cf_region_get_first(void) 
{ 
  int type ;
  region *value ;

  {
  {
#line 1883
  (*cfapiRegion_get_property)(& type, (void *)0, 1, & value);
  }
#line 1884
  if (! (type == 13)) {
    {
#line 1884
    __assert_fail("type == 13", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1884U, "cf_region_get_first");
    }
  }
#line 1885
  return (value);
}
}
#line 1895 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
char const   *cf_region_get_name(region *reg ) 
{ 
  int type ;
  sstring value ;

  {
  {
#line 1899
  (*cfapiRegion_get_property)(& type, reg, 0, & value);
  }
#line 1900
  if (! (type == 17)) {
    {
#line 1900
    __assert_fail("type == 17", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1900U, "cf_region_get_name");
    }
  }
#line 1901
  return (value);
}
}
#line 1911 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
region *cf_region_get_next(region *reg ) 
{ 
  int type ;
  region *value ;

  {
  {
#line 1915
  (*cfapiRegion_get_property)(& type, reg, 1, & value);
  }
#line 1916
  if (! (type == 13)) {
    {
#line 1916
    __assert_fail("type == 13", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1916U, "cf_region_get_next");
    }
  }
#line 1917
  return (value);
}
}
#line 1927 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
region *cf_region_get_parent(region *reg ) 
{ 
  int type ;
  region *value ;

  {
  {
#line 1931
  (*cfapiRegion_get_property)(& type, reg, 2, & value);
  }
#line 1932
  if (! (type == 13)) {
    {
#line 1932
    __assert_fail("type == 13", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1932U, "cf_region_get_parent");
    }
  }
#line 1933
  return (value);
}
}
#line 1943 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
char const   *cf_region_get_longname(region *reg ) 
{ 
  int type ;
  sstring value ;

  {
  {
#line 1947
  (*cfapiRegion_get_property)(& type, reg, 3, & value);
  }
#line 1948
  if (! (type == 17)) {
    {
#line 1948
    __assert_fail("type == 17", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1948U, "cf_region_get_longname");
    }
  }
#line 1949
  return (value);
}
}
#line 1959 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
char const   *cf_region_get_message(region *reg ) 
{ 
  int type ;
  sstring value ;

  {
  {
#line 1963
  (*cfapiRegion_get_property)(& type, reg, 4, & value);
  }
#line 1964
  if (! (type == 17)) {
    {
#line 1964
    __assert_fail("type == 17", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1964U, "cf_region_get_message");
    }
  }
#line 1965
  return (value);
}
}
#line 1975 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_region_get_jail_x(region *reg ) 
{ 
  int type ;
  int value ;

  {
  {
#line 1978
  (*cfapiRegion_get_property)(& type, reg, 5, & value);
  }
#line 1979
  if (! (type == 1)) {
    {
#line 1979
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1979U, "cf_region_get_jail_x");
    }
  }
#line 1980
  return (value);
}
}
#line 1990 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_region_get_jail_y(region *reg ) 
{ 
  int type ;
  int value ;

  {
  {
#line 1993
  (*cfapiRegion_get_property)(& type, reg, 6, & value);
  }
#line 1994
  if (! (type == 1)) {
    {
#line 1994
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  1994U, "cf_region_get_jail_y");
    }
  }
#line 1995
  return (value);
}
}
#line 2005 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
char const   *cf_region_get_jail_path(region *reg ) 
{ 
  int type ;
  sstring value ;

  {
  {
#line 2009
  (*cfapiRegion_get_property)(& type, reg, 7, & value);
  }
#line 2010
  if (! (type == 17)) {
    {
#line 2010
    __assert_fail("type == 17", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  2010U, "cf_region_get_jail_path");
    }
  }
#line 2011
  return (value);
}
}
#line 2021 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
object *cf_friendlylist_get_first(void) 
{ 
  int type ;
  object *value ;

  {
  {
#line 2025
  (*cfapiFriendlylist_get_next)(& type, (void *)0, & value);
  }
#line 2026
  if (! (type == 5)) {
    {
#line 2026
    __assert_fail("type == 5", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  2026U, "cf_friendlylist_get_first");
    }
  }
#line 2027
  return (value);
}
}
#line 2037 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
object *cf_friendlylist_get_next(object *ob ) 
{ 
  int type ;
  object *value ;

  {
  {
#line 2041
  (*cfapiFriendlylist_get_next)(& type, ob, & value);
  }
#line 2042
  if (! (type == 5)) {
    {
#line 2042
    __assert_fail("type == 5", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  2042U, "cf_friendlylist_get_next");
    }
  }
#line 2043
  return (value);
}
}
#line 2052 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_quest_get_player_state(object *pl , sstring quest_code ) 
{ 
  int type ;
  int ret ;

  {
  {
#line 2055
  (*cfapiPlayer_quest)(& type, 1, pl, quest_code, & ret);
  }
#line 2056
  if (! (type == 1)) {
    {
#line 2056
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  2056U, "cf_quest_get_player_state");
    }
  }
#line 2058
  return (ret);
}
}
#line 2065 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_quest_start(object *pl , sstring quest_code , int state ) 
{ 
  int type ;

  {
  {
#line 2068
  (*cfapiPlayer_quest)(& type, 0, pl, quest_code, state);
  }
#line 2069
  if (! (type == 0)) {
    {
#line 2069
    __assert_fail("type == 0", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  2069U, "cf_quest_start");
    }
  }
#line 2070
  return;
}
}
#line 2076 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
void cf_quest_set_player_state(object *pl , sstring quest_code , int state ) 
{ 
  int type ;

  {
  {
#line 2079
  (*cfapiPlayer_quest)(& type, 2, pl, quest_code, state);
  }
#line 2080
  if (! (type == 0)) {
    {
#line 2080
    __assert_fail("type == 0", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  2080U, "cf_quest_set_player_state");
    }
  }
#line 2081
  return;
}
}
#line 2087 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c"
int cf_quest_was_completed(object *pl , sstring quest_code ) 
{ 
  int type ;
  int ret ;

  {
  {
#line 2090
  (*cfapiPlayer_quest)(& type, 3, pl, quest_code, & ret);
  }
#line 2091
  if (! (type == 1)) {
    {
#line 2091
    __assert_fail("type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/../common/plugin_common.c",
                  2091U, "cf_quest_was_completed");
    }
  }
#line 2093
  return (ret);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 828 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 97 "./include/cfanim.h"
CFanimationHook animationbox[46] ;
#line 99
int animationcount ;
#line 2 "./include/cfanim_proto.h"
int __attribute__((__visibility__("default")))  initPlugin(char const   *iversion ,
                                                           void (*gethooksptr)(int *type 
                                                                               , ...) ) ;
#line 3
void __attribute__((__visibility__("default")))  *getPluginProperty(int *type  , ...) ;
#line 4
anim_move_result __attribute__((__visibility__("default")))  cfanim_runPluginCommand(object *op ,
                                                                                     char *params ) ;
#line 5
int __attribute__((__visibility__("default")))  postInitPlugin(void) ;
#line 6
int __attribute__((__visibility__("default")))  cfanim_globalEventListener(int *type 
                                                                           , ...) ;
#line 7
int __attribute__((__visibility__("default")))  eventListener(int *type  , ...) ;
#line 8
int __attribute__((__visibility__("default")))  closePlugin(void) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
char __attribute__((__visibility__("default")))  SvnRevPlugin[8]  = 
#line 37 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
  {      (char __attribute__((__visibility__("default")))  )'u',      (char __attribute__((__visibility__("default")))  )'n',      (char __attribute__((__visibility__("default")))  )'k',      (char __attribute__((__visibility__("default")))  )'n', 
        (char __attribute__((__visibility__("default")))  )'o',      (char __attribute__((__visibility__("default")))  )'w',      (char __attribute__((__visibility__("default")))  )'n',      (char __attribute__((__visibility__("default")))  )'\000'};
#line 39 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static CFanimation *first_animation  =    (CFanimation *)((void *)0);
#line 41
static int get_boolean(char const   *strg , int *bl ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static int get_dir_from_name(char const   *name ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 49
  tmp = strcmp(name, "north");
  }
#line 49
  if (! tmp) {
#line 50
    return (1);
  }
  {
#line 51
  tmp___0 = strcmp(name, "north_east");
  }
#line 51
  if (! tmp___0) {
#line 52
    return (2);
  }
  {
#line 53
  tmp___1 = strcmp(name, "east");
  }
#line 53
  if (! tmp___1) {
#line 54
    return (3);
  }
  {
#line 55
  tmp___2 = strcmp(name, "south_east");
  }
#line 55
  if (! tmp___2) {
#line 56
    return (4);
  }
  {
#line 57
  tmp___3 = strcmp(name, "south");
  }
#line 57
  if (! tmp___3) {
#line 58
    return (5);
  }
  {
#line 59
  tmp___4 = strcmp(name, "south_west");
  }
#line 59
  if (! tmp___4) {
#line 60
    return (6);
  }
  {
#line 61
  tmp___5 = strcmp(name, "west");
  }
#line 61
  if (! tmp___5) {
#line 62
    return (7);
  }
  {
#line 63
  tmp___6 = strcmp(name, "north_west");
  }
#line 63
  if (! tmp___6) {
#line 64
    return (8);
  }
#line 65
  return (-1);
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static long initmovement(char const   *name , char *parameters , struct CFmovement_struct *move_entity ) 
{ 
  int dir ;

  {
  {
#line 71
  dir = get_dir_from_name(name);
#line 72
  move_entity->parameters = (void *)0;
  }
#line 73
  return ((long )dir);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static anim_move_result runmovement(struct CFanimation_struct *animation , long id ,
                                    void *parameters ) 
{ 
  object *op ;
  int dir ;

  {
#line 77
  op = animation->victim;
#line 78
  dir = (int )id;
#line 80
  if (animation->verbose) {
    {
#line 81
    cf_log((LogLevel )2, "CFAnim: Moving in direction %ld\n", id);
    }
  }
#line 82
  if ((int )op->type == 1) {
    {
#line 83
    cf_player_move(op->contr, dir);
    }
  } else {
    {
#line 85
    cf_object_move(op, dir, op);
    }
  }
#line 86
  return ((anim_move_result )0);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static long initfire(char const   *name , char *parameters , struct CFmovement_struct *move_entity ) 
{ 
  int dir ;

  {
  {
#line 92
  dir = get_dir_from_name(name + 5);
#line 93
  move_entity->parameters = (void *)0;
  }
#line 94
  return ((long )dir);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static anim_move_result runfire(struct CFanimation_struct *animation , long id , void *parameters ) 
{ 


  {
#line 99
  if (animation->verbose) {
    {
#line 100
    cf_log((LogLevel )2, "CFAnim: Firing in direction %ld\n", id);
    }
  }
#line 101
  return ((anim_move_result )0);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static long initturn(char const   *name , char *parameters , struct CFmovement_struct *move_entity ) 
{ 
  int dir ;

  {
  {
#line 107
  dir = get_dir_from_name(name + 5);
#line 108
  move_entity->parameters = (void *)0;
  }
#line 109
  return ((long )dir);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static anim_move_result runturn(struct CFanimation_struct *animation , long id , void *parameters ) 
{ 
  object *op ;
  int dir ;

  {
#line 113
  op = animation->victim;
#line 114
  dir = (int )id;
#line 117
  if (animation->verbose) {
    {
#line 118
    cf_log((LogLevel )2, "CFAnim: Turning in direction %ld\n", id);
    }
  }
#line 119
  op->facing = (sint8 )dir;
#line 122
  return ((anim_move_result )0);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static long initcamera(char const   *name , char *parameters , struct CFmovement_struct *move_entity ) 
{ 
  int dir ;

  {
  {
#line 128
  dir = get_dir_from_name(name + 7);
#line 129
  move_entity->parameters = (void *)0;
  }
#line 130
  return ((long )dir);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static anim_move_result runcamera(struct CFanimation_struct *animation , long id ,
                                  void *parameters ) 
{ 


  {
#line 135
  if (animation->verbose) {
    {
#line 136
    cf_log((LogLevel )2, "CFAnim: Moving the camera in direction %ld\n", id);
    }
  }
#line 137
  return ((anim_move_result )0);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static long initvisible(char const   *name , char *parameters , struct CFmovement_struct *move_entity ) 
{ 
  int result ;
  int tmp ;

  {
  {
#line 148
  tmp = get_boolean((char const   *)parameters, & result);
  }
#line 148
  if (tmp) {
#line 149
    return ((long )result);
  }
  {
#line 150
  cf_log((LogLevel )0, "CFAnim: Error in animation - possible values for \'invisible\' are \'yes\' and \'no\'\n");
  }
#line 151
  return (-1L);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static anim_move_result runvisible(struct CFanimation_struct *animation , long id ,
                                   void *parameters ) 
{ 


  {
#line 155
  if (id == -1L) {
#line 156
    return ((anim_move_result )0);
  }
#line 157
  animation->invisible = (int )id;
#line 158
  return ((anim_move_result )0);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static long initwizard(char const   *name , char *parameters , struct CFmovement_struct *move_entity ) 
{ 
  int result ;
  int tmp ;

  {
  {
#line 164
  tmp = get_boolean((char const   *)parameters, & result);
  }
#line 164
  if (tmp) {
#line 165
    return ((long )result);
  }
  {
#line 166
  cf_log((LogLevel )0, "CFAnim: Error in animation - possible values for \'wizard\' are \'yes\' and \'no\'\n");
  }
#line 167
  return (-1L);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static anim_move_result runwizard(struct CFanimation_struct *animation , long id ,
                                  void *parameters ) 
{ 


  {
#line 171
  if (id == -1L) {
#line 172
    return ((anim_move_result )1);
  }
#line 173
  animation->wizard = (int )id;
#line 174
  return ((anim_move_result )0);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static long initsay(char const   *name , char *parameters , struct CFmovement_struct *move_entity ) 
{ 
  char *tmp ;
  char const   *tmp___0 ;

  {
#line 178
  if (parameters) {
    {
#line 179
    tmp = cf_strdup_local((char const   *)parameters);
#line 179
    move_entity->parameters = (void *)tmp;
    }
  } else {
#line 181
    move_entity->parameters = (void *)0;
  }
#line 182
  if ((move_entity->parent)->verbose) {
#line 183
    if (parameters) {
#line 183
      tmp___0 = (char const   *)parameters;
    } else {
#line 183
      tmp___0 = "null";
    }
    {
#line 183
    cf_log((LogLevel )2, "CFAnim: init say: parameters: %s\n", tmp___0);
    }
  }
#line 184
  return (1L);
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static anim_move_result runsay(struct CFanimation_struct *animation , long id , void *parameters ) 
{ 


  {
#line 188
  if (parameters) {
    {
#line 189
    cf_object_say(animation->victim, (char *)parameters);
#line 190
    free(parameters);
    }
  } else {
    {
#line 192
    cf_log((LogLevel )0, "CFAnim: Error in animation: nothing to say with say function\n");
    }
  }
#line 193
  return ((anim_move_result )0);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static long initapply(char const   *name , char *parameters , struct CFmovement_struct *move_entity ) 
{ 


  {
#line 197
  return (1L);
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static anim_move_result runapply(struct CFanimation_struct *animation , long id ,
                                 void *parameters ) 
{ 
  object *current_container ;

  {
#line 203
  if ((int )(animation->victim)->type != 1) {
#line 204
    return ((anim_move_result )0);
  }
  {
#line 205
  current_container = (animation->victim)->container;
#line 206
  (animation->victim)->container = (struct obj *)((void *)0);
#line 207
  cf_object_apply_below(animation->victim);
#line 208
  (animation->victim)->container = current_container;
  }
#line 209
  return ((anim_move_result )0);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static long initapplyobject(char const   *name , char *parameters , struct CFmovement_struct *move_entity ) 
{ 
  sstring tmp ;

  {
#line 213
  if (parameters) {
    {
#line 213
    tmp = cf_add_string((char const   *)parameters);
#line 213
    move_entity->parameters = (void *)tmp;
    }
  } else {
#line 213
    move_entity->parameters = (void *)0;
  }
#line 214
  return (1L);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static anim_move_result runapplyobject(struct CFanimation_struct *animation , long id ,
                                       void *parameters ) 
{ 
  object *current ;
  int aflag ;
  object *next224 ;
  tag_t next_tag224 ;
  tag_t tmp ;

  {
#line 221
  if (! parameters) {
#line 222
    return ((anim_move_result )0);
  }
#line 223
  current = (animation->victim)->below;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    next224 = current;
#line 224
    if ((unsigned long )next224 == (unsigned long )((void *)0)) {
#line 224
      tmp = (tag_t )0;
    } else {
#line 224
      tmp = next224->count;
    }
#line 224
    next_tag224 = tmp;
    {
#line 224
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 224
      current = next224;
#line 224
      if (! ((unsigned long )current != (unsigned long )((void *)0))) {
#line 224
        goto while_break___0;
      }
#line 224
      if (next224->count != next_tag224) {
#line 224
        goto while_break___0;
      } else
#line 224
      if (next224->flags[0] & (1U << 3)) {
#line 224
        goto while_break___0;
      }
#line 224
      next224 = next224->below;
#line 224
      if ((unsigned long )next224 == (unsigned long )((void *)0)) {
#line 224
        next_tag224 = (tag_t )0;
      } else {
#line 224
        next_tag224 = next224->count;
      }
#line 225
      if ((unsigned long )current->name == (unsigned long )parameters) {
#line 226
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 224
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  if (! current) {
    {
#line 229
    current = cf_object_find_by_name((object const   *)animation->victim, (char const   *)parameters);
    }
  }
#line 230
  if (! current) {
    {
#line 231
    cf_free_string((sstring )parameters);
    }
#line 232
    return ((anim_move_result )0);
  }
  {
#line 234
  aflag = 1;
#line 235
  cf_object_apply(animation->victim, current, aflag);
#line 236
  cf_free_string((sstring )parameters);
  }
#line 237
  return ((anim_move_result )0);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static long initdropobject(char const   *name , char *parameters , struct CFmovement_struct *move_entity ) 
{ 
  char *tmp ;

  {
#line 241
  if (parameters) {
    {
#line 241
    tmp = cf_strdup_local((char const   *)parameters);
#line 241
    move_entity->parameters = (void *)tmp;
    }
  } else {
#line 241
    move_entity->parameters = (void *)0;
  }
#line 242
  return (1L);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static anim_move_result rundropobject(struct CFanimation_struct *animation , long id ,
                                      void *parameters ) 
{ 


  {
#line 246
  if (! parameters) {
#line 247
    return ((anim_move_result )0);
  }
  {
#line 248
  cf_object_drop(animation->victim, (object *)parameters);
#line 249
  cf_free_string((sstring )parameters);
  }
#line 250
  return ((anim_move_result )0);
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static long initpickup(char const   *name , char *parameters , struct CFmovement_struct *move_entity ) 
{ 


  {
#line 254
  return (1L);
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static anim_move_result runpickup(struct CFanimation_struct *animation , long id ,
                                  void *parameters ) 
{ 
  object *current ;

  {
#line 260
  current = (animation->victim)->below;
#line 261
  if (! current) {
#line 262
    return ((anim_move_result )0);
  }
  {
#line 263
  cf_object_pickup(animation->victim, current);
  }
#line 264
  return ((anim_move_result )0);
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static long initpickupobject(char const   *name , char *parameters , struct CFmovement_struct *move_entity ) 
{ 
  sstring tmp ;

  {
#line 268
  if (parameters) {
    {
#line 268
    tmp = cf_add_string((char const   *)parameters);
#line 268
    move_entity->parameters = (void *)tmp;
    }
  } else {
#line 268
    move_entity->parameters = (void *)0;
  }
#line 269
  return (1L);
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static anim_move_result runpickupobject(struct CFanimation_struct *animation , long id ,
                                        void *parameters ) 
{ 
  object *current ;
  object *next275 ;
  tag_t next_tag275 ;
  tag_t tmp ;

  {
#line 273
  if (! parameters) {
#line 274
    return ((anim_move_result )0);
  }
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    current = (animation->victim)->below;
    {
#line 275
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 275
      next275 = current;
#line 275
      if ((unsigned long )next275 == (unsigned long )((void *)0)) {
#line 275
        tmp = (tag_t )0;
      } else {
#line 275
        tmp = next275->count;
      }
#line 275
      next_tag275 = tmp;
      {
#line 275
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 275
        current = next275;
#line 275
        if (! ((unsigned long )current != (unsigned long )((void *)0))) {
#line 275
          goto while_break___1;
        }
#line 275
        if (next275->count != next_tag275) {
#line 275
          goto while_break___1;
        } else
#line 275
        if (next275->flags[0] & (1U << 3)) {
#line 275
          goto while_break___1;
        }
#line 275
        next275 = next275->below;
#line 275
        if ((unsigned long )next275 == (unsigned long )((void *)0)) {
#line 275
          next_tag275 = (tag_t )0;
        } else {
#line 275
          next_tag275 = next275->count;
        }
#line 276
        if ((unsigned long )current->name == (unsigned long )parameters) {
          {
#line 277
          cf_object_pickup(animation->victim, current);
          }
#line 278
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 275
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 275
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 281
  cf_free_string((sstring )parameters);
  }
#line 282
  return ((anim_move_result )0);
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static long initghosted(char const   *name , char *parameters , struct CFmovement_struct *move_entity ) 
{ 
  int result ;
  int tmp ;

  {
  {
#line 288
  tmp = get_boolean((char const   *)parameters, & result);
  }
#line 288
  if (tmp) {
#line 289
    return ((long )result);
  }
  {
#line 290
  cf_log((LogLevel )0, "CFAnim: Error in animation: possible values for \'ghosted\' are \'yes\' and \'no\'\n");
  }
#line 291
  return (-1L);
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static anim_move_result runghosted(struct CFanimation_struct *animation , long id ,
                                   void *parameters ) 
{ 
  object *corpse ;

  {
#line 297
  if (id) {
#line 297
    if (animation->ghosted) {
      {
#line 299
      runghosted(animation, (long )(! id), parameters);
      }
    } else {
#line 297
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 297
  if (! id) {
#line 297
    if (! animation->ghosted) {
      {
#line 299
      runghosted(animation, (long )(! id), parameters);
      }
    }
  }
#line 300
  if (id) {
    {
#line 301
    corpse = cf_object_clone(animation->victim, 1);
#line 302
    corpse->x = (animation->victim)->x;
#line 303
    corpse->y = (animation->victim)->y;
#line 304
    corpse->type = (uint8 )0;
#line 305
    corpse->flags[0] &= ~ (1U << 1);
#line 306
    corpse->contr = (struct pl *)((void *)0);
#line 307
    cf_map_insert_object_there(corpse, (animation->victim)->map, (object *)((void *)0),
                               0);
#line 308
    animation->wizard = 1;
#line 309
    animation->invisible = 1;
#line 310
    animation->corpse = corpse;
    }
  } else {
    {
#line 312
    animation->wizard = 0;
#line 313
    animation->invisible = 0;
#line 314
    cf_object_remove(animation->corpse);
#line 315
    cf_object_free_drop_inventory(animation->corpse);
#line 316
    animation->corpse = (object *)((void *)0);
#line 317
    (animation->victim)->invisible = (sint16 )0;
#line 318
    cf_player_move((animation->victim)->contr, 0);
    }
  }
#line 320
  animation->ghosted = (int )id;
#line 321
  return ((anim_move_result )0);
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static long initteleport(char const   *name , char *parameters , struct CFmovement_struct *move_entity ) 
{ 
  char *mapname ;
  int mapx ;
  int mapy ;
  teleport_params *teleport___0 ;
  void *tmp ;

  {
  {
#line 336
  move_entity->parameters = (void *)0;
#line 337
  cf_log((LogLevel )2, ".(%s)\n", parameters);
  }
#line 338
  if (! parameters) {
    {
#line 339
    cf_log((LogLevel )0, "CFAnim: Error - no parameters for teleport\n");
    }
#line 340
    return (0L);
  }
  {
#line 342
  mapname = strstr((char const   *)parameters, " ");
#line 343
  cf_log((LogLevel )2, ".(%s)\n", parameters);
  }
#line 344
  if (! mapname) {
#line 345
    return (0L);
  }
  {
#line 346
  *mapname = (char )'\000';
#line 347
  mapx = atoi((char const   *)parameters);
#line 348
  mapname ++;
#line 349
  parameters = mapname;
  }
#line 350
  if (! parameters) {
    {
#line 351
    cf_log((LogLevel )0, "CFAnim: Error - not enough parameters for teleport\n");
    }
#line 352
    return (0L);
  }
  {
#line 354
  cf_log((LogLevel )2, ".(%s)\n", parameters);
#line 355
  mapname = strstr((char const   *)parameters, " ");
#line 356
  cf_log((LogLevel )2, ".\n");
  }
#line 357
  if (! mapname) {
#line 358
    return (0L);
  }
  {
#line 359
  *mapname = (char )'\000';
#line 360
  mapy = atoi((char const   *)parameters);
#line 361
  mapname ++;
  }
#line 362
  if ((int )*(mapname + 0) == 0) {
#line 363
    return (0L);
  }
  {
#line 364
  tmp = malloc(sizeof(teleport_params ));
#line 364
  teleport___0 = (teleport_params *)tmp;
#line 365
  teleport___0->mapname = cf_strdup_local((char const   *)mapname);
#line 366
  teleport___0->mapx = mapx;
#line 367
  teleport___0->mapy = mapy;
#line 368
  move_entity->parameters = (void *)teleport___0;
  }
#line 369
  return (1L);
}
}
#line 372 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static anim_move_result runteleport(struct CFanimation_struct *animation , long id ,
                                    void *parameters ) 
{ 
  teleport_params *teleport___0 ;
  mapstruct *tmp ;

  {
#line 373
  teleport___0 = (teleport_params *)parameters;
#line 375
  if (! parameters) {
#line 376
    return ((anim_move_result )0);
  }
  {
#line 377
  tmp = cf_map_get_map((char const   *)teleport___0->mapname, 0);
#line 377
  cf_object_teleport(animation->victim, tmp, teleport___0->mapx, teleport___0->mapy);
#line 378
  free(parameters);
  }
#line 379
  return ((anim_move_result )0);
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static long initnotice(char const   *name , char *parameters , struct CFmovement_struct *move_entity ) 
{ 
  char *tmp ;

  {
#line 383
  if (parameters) {
    {
#line 383
    tmp = cf_strdup_local((char const   *)parameters);
#line 383
    move_entity->parameters = (void *)tmp;
    }
  } else {
#line 383
    move_entity->parameters = (void *)0;
  }
#line 384
  return (1L);
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static anim_move_result runnotice(struct CFanimation_struct *animation , long id ,
                                  void *parameters ) 
{ 
  int val ;

  {
  {
#line 389
  val = 258;
#line 391
  cf_player_message(animation->victim, (char *)parameters, val);
  }
#line 392
  return ((anim_move_result )0);
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static long initstop(char const   *name , char *parameters , struct CFmovement_struct *move_entity ) 
{ 


  {
#line 396
  return (1L);
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static anim_move_result runstop(struct CFanimation_struct *animation , long id , void *parameters ) 
{ 


  {
#line 401
  if (animation->verbose) {
    {
#line 402
    cf_log((LogLevel )2, "CFAnim: stop encountered\n");
    }
  }
#line 403
  return ((anim_move_result )0);
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static long initmoveto(char const   *name , char *parameters , struct CFmovement_struct *move_entity ) 
{ 
  param_moveto *moveto ;
  int x ;
  int y ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 415
  tmp = sscanf((char const   */* __restrict  */)parameters, (char const   */* __restrict  */)"%d %d",
               & x, & y);
  }
#line 415
  if (tmp != 2) {
#line 416
    return (0L);
  }
  {
#line 418
  tmp___0 = calloc((size_t )1, sizeof(param_moveto ));
#line 418
  moveto = (param_moveto *)tmp___0;
#line 419
  moveto->x = x;
#line 420
  moveto->y = y;
#line 421
  move_entity->parameters = (void *)moveto;
  }
#line 423
  return (1L);
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static anim_move_result runmoveto(struct CFanimation_struct *animation , long id ,
                                  void *parameters ) 
{ 
  int move ;
  param_moveto *dest ;

  {
#line 428
  dest = (param_moveto *)parameters;
#line 430
  if (! dest) {
#line 431
    return ((anim_move_result )0);
  }
  {
#line 433
  move = cf_object_move_to(animation->victim, dest->x, dest->y);
  }
#line 435
  if ((int )(animation->victim)->x == dest->x) {
#line 435
    if ((int )(animation->victim)->y == dest->y) {
      {
#line 436
      free(parameters);
      }
#line 437
      return ((anim_move_result )0);
    }
  }
#line 440
  if (move == 1) {
#line 441
    return ((anim_move_result )1);
  }
#line 443
  return ((anim_move_result )0);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static long initmessage(char const   *name , char *parameters , struct CFmovement_struct *move_entity ) 
{ 
  char *tmp ;

  {
#line 447
  if (parameters) {
    {
#line 448
    tmp = strdup((char const   *)parameters);
#line 448
    move_entity->parameters = (void *)tmp;
    }
  } else {
#line 450
    move_entity->parameters = (void *)0;
  }
#line 451
  return (1L);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static anim_move_result runmessage(struct CFanimation_struct *animation , long id ,
                                   void *parameters ) 
{ 


  {
#line 455
  if (parameters) {
#line 455
    if ((animation->victim)->map) {
      {
#line 456
      cf_map_message((animation->victim)->map, (char const   *)parameters, 263);
#line 457
      free(parameters);
      }
    }
  }
#line 460
  return ((anim_move_result )0);
}
}
#line 464 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
CFanimationHook animationbox[46]  = 
#line 464
  {      {"north", & initmovement, & runmovement}, 
        {"north_east", & initmovement, & runmovement}, 
        {"east", & initmovement, & runmovement}, 
        {"south_east", & initmovement, & runmovement}, 
        {"south", & initmovement, & runmovement}, 
        {"south_west", & initmovement, & runmovement}, 
        {"west", & initmovement, & runmovement}, 
        {"north_west", & initmovement, & runmovement}, 
        {"fire_north", & initfire, & runfire}, 
        {"fire_north_east", & initfire, & runfire}, 
        {"fire_east", & initfire, & runfire}, 
        {"fire_south_east", & initfire, & runfire}, 
        {"fire_south", & initfire, & runfire}, 
        {"fire_south_west", & initfire, & runfire}, 
        {"fire_west", & initfire, & runfire}, 
        {"fire_north_west", & initfire, & runfire}, 
        {"turn_north", & initturn, & runturn}, 
        {"turn_north_east", & initturn, & runturn}, 
        {"turn_east", & initturn, & runturn}, 
        {"turn_south_east", & initturn, & runturn}, 
        {"turn_south", & initturn, & runturn}, 
        {"turn_south_west", & initturn, & runturn}, 
        {"turn_west", & initturn, & runturn}, 
        {"turn_north_west", & initturn, & runturn}, 
        {"camera_north", & initcamera, & runcamera}, 
        {"camera_north_east", & initcamera, & runcamera}, 
        {"camera_east", & initcamera, & runcamera}, 
        {"camera_south_east", & initcamera, & runcamera}, 
        {"camera_south", & initcamera, & runcamera}, 
        {"camera_south_west", & initcamera, & runcamera}, 
        {"camera_west", & initcamera, & runcamera}, 
        {"camera_north_west", & initcamera, & runcamera}, 
        {"invisible", & initvisible, & runvisible}, 
        {"wizard", & initwizard, & runwizard}, 
        {"say", & initsay, & runsay}, 
        {"apply", & initapply, & runapply}, 
        {"apply_object", & initapplyobject, & runapplyobject}, 
        {"drop_object", & initdropobject, & rundropobject}, 
        {"pickup", & initpickup, & runpickup}, 
        {"pickup_object", & initpickupobject, & runpickupobject}, 
        {"ghosted", & initghosted, & runghosted}, 
        {"teleport", & initteleport, & runteleport}, 
        {"notice", & initnotice, & runnotice}, 
        {"stop", & initstop, & runstop}, 
        {"moveto", & initmoveto, & runmoveto}, 
        {"message", & initmessage, & runmessage}};
#line 513 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
int animationcount  =    (int )(sizeof(animationbox) / sizeof(CFanimationHook ));
#line 515 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static int ordered_commands  =    0;
#line 517 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static int compareAnims(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 518
  tmp = strcmp((char const   *)((CFanimationHook const   *)a)->name, (char const   *)((CFanimationHook const   *)b)->name);
  }
#line 518
  return (tmp);
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static void prepare_commands(void) 
{ 


  {
  {
#line 522
  qsort((void *)(animationbox), (size_t )animationcount, sizeof(CFanimationHook ),
        & compareAnims);
#line 523
  ordered_commands = 1;
  }
#line 524
  return;
}
}
#line 526 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static CFanimationHook *get_command(char *command ) 
{ 
  CFanimationHook dummy ;
  void *tmp ;

  {
#line 529
  dummy.name = (char const   *)command;
#line 530
  if (! ordered_commands) {
    {
#line 531
    prepare_commands();
    }
  }
  {
#line 532
  tmp = bsearch((void const   *)(& dummy), (void const   *)(animationbox), (size_t )animationcount,
                sizeof(CFanimationHook ), & compareAnims);
  }
#line 532
  return ((CFanimationHook *)tmp);
}
}
#line 543 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static CFmovement *parse_animation_block(char *buffer , size_t buffer_size , FILE *fichier ,
                                         CFanimation *parent ) 
{ 
  CFmovement *first ;
  CFmovement *current ;
  CFmovement *next ;
  char *time___0 ;
  char *name ;
  char *parameters ;
  int tick ;
  CFanimationHook *animationhook ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;

  {
#line 544
  first = (CFmovement *)((void *)0);
#line 545
  current = (CFmovement *)((void *)0);
#line 553
  if (parent->verbose) {
    {
#line 554
    cf_log((LogLevel )2, "CFAnim: In parse block for %s\n", buffer);
    }
  }
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 555
    tmp___5 = fgets((char */* __restrict  */)buffer, (int )buffer_size, (FILE */* __restrict  */)fichier);
    }
#line 555
    if (! tmp___5) {
#line 555
      goto while_break;
    }
#line 556
    if ((int )*(buffer + 0) == 91) {
#line 557
      goto while_break;
    }
#line 558
    if ((int )*(buffer + 0) == 35) {
#line 559
      goto while_continue;
    }
    {
#line 560
    tmp = strlen((char const   *)buffer);
#line 560
    tmp___0 = strlen("\n");
#line 560
    *(buffer + (tmp - tmp___0)) = (char )'\000';
    }
    {
#line 561
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 561
      tmp___2 = strlen((char const   *)buffer);
      }
#line 561
      if (! ((int )*(buffer + (tmp___2 - 1UL)) == 32)) {
#line 561
        goto while_break___0;
      }
      {
#line 562
      tmp___1 = strlen((char const   *)buffer);
#line 562
      *(buffer + (tmp___1 - 1UL)) = (char )'\000';
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 563
    tmp___3 = strlen((char const   *)buffer);
    }
#line 563
    if (tmp___3 <= 0UL) {
#line 564
      goto while_continue;
    }
    {
#line 565
    time___0 = buffer;
#line 567
    name = strstr((char const   *)buffer, " ");
    }
#line 568
    if (! name) {
#line 569
      goto while_continue;
    }
#line 570
    *name = (char )'\000';
#line 571
    name ++;
    {
#line 572
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 572
      if (! ((int )*name == 32)) {
#line 572
        goto while_break___1;
      }
#line 573
      name ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 575
    tick = atoi((char const   *)time___0);
    }
#line 576
    if (tick < 0) {
#line 577
      goto while_continue;
    }
    {
#line 579
    parameters = strstr((char const   *)name, " ");
    }
#line 580
    if (parameters) {
#line 581
      *parameters = (char )'\000';
#line 582
      parameters ++;
      {
#line 583
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 583
        if (! ((int )*parameters == 32)) {
#line 583
          goto while_break___2;
        }
#line 584
        parameters ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 585
      if ((int )*parameters == 0) {
#line 586
        parameters = (char *)((void *)0);
      }
    }
    {
#line 588
    animationhook = get_command(name);
    }
#line 589
    if (parent->verbose) {
#line 590
      if (! animationhook) {
        {
#line 591
        cf_log((LogLevel )0, "CFAnim: %s - Unknown animation command\n", name);
        }
      } else {
        {
#line 593
        cf_log((LogLevel )2, "CFAnim: Parsed %s -> %p\n", name, animationhook);
        }
      }
    }
#line 595
    if (! animationhook) {
#line 596
      if (parent->errors_allowed) {
#line 597
        goto while_continue;
      } else {
#line 599
        goto while_break;
      }
    }
    {
#line 601
    tmp___4 = malloc(sizeof(CFmovement ));
#line 601
    next = (CFmovement *)tmp___4;
    }
#line 602
    if (! next) {
#line 603
      goto while_continue;
    }
#line 604
    next->parent = parent;
#line 605
    next->tick = tick;
#line 606
    next->next = (struct CFmovement_struct *)((void *)0);
#line 607
    if (animationhook->funcinit) {
      {
#line 608
      next->id = (*(animationhook->funcinit))((char const   *)name, parameters, next);
      }
    }
#line 609
    next->func = animationhook->funcrun;
#line 610
    if (current) {
#line 611
      current->next = next;
    } else {
#line 613
      first = next;
    }
#line 614
    current = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 616
  return (first);
}
}
#line 629 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static int equality_split(char *buffer , char **variable , char **value ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;

  {
  {
#line 630
  tmp___1 = strlen((char const   *)buffer);
#line 630
  tmp___2 = strlen("\n");
#line 630
  tmp___3 = strcmp((char const   *)(buffer + (tmp___1 - tmp___2)), "\n");
  }
#line 630
  if (! tmp___3) {
    {
#line 631
    tmp = strlen((char const   *)buffer);
#line 631
    tmp___0 = strlen("\n");
#line 631
    *(buffer + (tmp - tmp___0)) = (char )'\000';
    }
  }
  {
#line 632
  *value = strstr((char const   *)buffer, "=");
  }
#line 633
  if (! *value) {
#line 634
    return (0);
  }
#line 635
  *(*value) = (char )'\000';
#line 636
  *variable = buffer;
#line 637
  (*value) ++;
  {
#line 638
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 638
    tmp___5 = strlen((char const   *)*variable);
    }
#line 638
    if (tmp___5 > 0UL) {
      {
#line 638
      tmp___6 = strlen((char const   *)*variable);
      }
#line 638
      if (! ((int )*(*variable + (tmp___6 - 1UL)) == 32)) {
#line 638
        goto while_break;
      }
    } else {
#line 638
      goto while_break;
    }
    {
#line 639
    tmp___4 = strlen((char const   *)*variable);
#line 639
    *(*variable + (tmp___4 - 1UL)) = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 640
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 640
    tmp___8 = strlen((char const   *)*value);
    }
#line 640
    if (tmp___8 > 0UL) {
      {
#line 640
      tmp___9 = strlen((char const   *)*value);
      }
#line 640
      if (! ((int )*(*value + (tmp___9 - 1UL)) == 32)) {
#line 640
        goto while_break___0;
      }
    } else {
#line 640
      goto while_break___0;
    }
    {
#line 641
    tmp___7 = strlen((char const   *)*value);
#line 641
    *(*value + (tmp___7 - 1UL)) = (char )'\000';
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 642
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 642
    if (! ((int )*(*value) == 32)) {
#line 642
      goto while_break___1;
    }
#line 643
    (*value) ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 644
  if ((int )*(*variable) == 0) {
#line 645
    return (0);
  } else
#line 644
  if ((int )*(*value) == 0) {
#line 645
    return (0);
  }
#line 646
  return (1);
}
}
#line 660 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static int get_boolean(char const   *strg , int *bl ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 661
  tmp___4 = strncmp(strg, "y", (size_t )1);
  }
#line 661
  if (tmp___4) {
    {
#line 663
    tmp___3 = strncmp(strg, "n", (size_t )1);
    }
#line 663
    if (tmp___3) {
      {
#line 665
      tmp___2 = strncmp(strg, "Y", (size_t )1);
      }
#line 665
      if (tmp___2) {
        {
#line 667
        tmp___1 = strncmp(strg, "N", (size_t )1);
        }
#line 667
        if (tmp___1) {
          {
#line 669
          tmp___0 = strncmp(strg, "1", (size_t )1);
          }
#line 669
          if (tmp___0) {
            {
#line 671
            tmp = strncmp(strg, "0", (size_t )1);
            }
#line 671
            if (tmp) {
#line 674
              return (0);
            } else {
#line 672
              *bl = 0;
            }
          } else {
#line 670
            *bl = 1;
          }
        } else {
#line 668
          *bl = 0;
        }
      } else {
#line 666
        *bl = 1;
      }
    } else {
#line 664
      *bl = 0;
    }
  } else {
#line 662
    *bl = 1;
  }
#line 675
  return (1);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static int is_animated_object(object const   *ob ) 
{ 
  CFanimation *current ;

  {
#line 686
  current = first_animation;
  {
#line 686
  while (1) {
    while_continue: /* CIL Label */ ;
#line 686
    if (! current) {
#line 686
      goto while_break;
    }
#line 687
    if ((unsigned long )current->victim == (unsigned long )ob) {
#line 688
      return (1);
    }
#line 686
    current = current->nextanimation;
  }
  while_break: /* CIL Label */ ;
  }
#line 690
  return (0);
}
}
#line 697 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static CFanimation *create_animation(void) 
{ 
  CFanimation *new ;
  CFanimation *current ;
  void *tmp ;

  {
  {
#line 701
  tmp = malloc(sizeof(CFanimation ));
#line 701
  new = (CFanimation *)tmp;
  }
#line 702
  if (! new) {
#line 703
    return ((CFanimation *)((void *)0));
  }
#line 704
  new->name = (char *)((void *)0);
#line 705
  new->victim = (object *)((void *)0);
#line 706
  new->event = (object *)((void *)0);
#line 707
  new->nextmovement = (struct CFmovement_struct *)((void *)0);
#line 708
  new->nextanimation = (struct CFanimation_struct *)((void *)0);
#line 709
  new->delete_end = 0;
#line 710
  current = first_animation;
  {
#line 710
  while (1) {
    while_continue: /* CIL Label */ ;
#line 710
    if (current) {
#line 710
      if (! current->nextanimation) {
#line 710
        goto while_break;
      }
    } else {
#line 710
      goto while_break;
    }
#line 710
    current = current->nextanimation;
  }
  while_break: /* CIL Label */ ;
  }
#line 712
  if (! current) {
#line 713
    first_animation = new;
  } else {
#line 715
    current->nextanimation = new;
  }
#line 716
  return (new);
}
}
#line 719 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static object *find_by_name(object *origin , char const   *name ) 
{ 
  int x ;
  int y ;
  int w ;
  int h ;
  mapstruct *map ;
  char const   *sname ;
  object *ob ;
  object *next741 ;
  tag_t next_tag741 ;
  tag_t tmp ;

  {
  {
#line 724
  sname = cf_find_string(name);
  }
#line 725
  if (! sname) {
#line 726
    return ((object *)((void *)0));
  }
  {
#line 728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 728
    if (origin) {
#line 728
      if (! (! origin->map)) {
#line 728
        goto while_break;
      }
    } else {
#line 728
      goto while_break;
    }
#line 729
    origin = origin->env;
  }
  while_break: /* CIL Label */ ;
  }
#line 731
  if (! origin) {
#line 732
    return ((object *)((void *)0));
  } else
#line 731
  if (! origin->map) {
#line 732
    return ((object *)((void *)0));
  }
  {
#line 734
  map = origin->map;
#line 736
  w = cf_map_get_width(map);
#line 737
  h = cf_map_get_height(map);
#line 739
  x = 0;
  }
  {
#line 739
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 739
    if (! (x < w)) {
#line 739
      goto while_break___0;
    }
#line 740
    y = 0;
    {
#line 740
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 740
      if (! (y < h)) {
#line 740
        goto while_break___1;
      }
      {
#line 741
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 741
        ob = (map->spaces + (x + (int )map->width * y))->bottom;
        {
#line 741
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 741
          next741 = ob;
#line 741
          if ((unsigned long )next741 == (unsigned long )((void *)0)) {
#line 741
            tmp = (tag_t )0;
          } else {
#line 741
            tmp = next741->count;
          }
#line 741
          next_tag741 = tmp;
          {
#line 741
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 741
            ob = next741;
#line 741
            if (! ((unsigned long )ob != (unsigned long )((void *)0))) {
#line 741
              goto while_break___4;
            }
#line 741
            if (next741->count != next_tag741) {
#line 741
              goto while_break___4;
            } else
#line 741
            if (next741->flags[0] & (1U << 3)) {
#line 741
              goto while_break___4;
            }
#line 741
            next741 = next741->above;
#line 741
            if ((unsigned long )next741 == (unsigned long )((void *)0)) {
#line 741
              next_tag741 = (tag_t )0;
            } else {
#line 741
              next_tag741 = next741->count;
            }
#line 742
            if ((unsigned long )ob->name == (unsigned long )sname) {
#line 743
              return (ob);
            }
          }
          while_break___4: /* CIL Label */ ;
          }
#line 741
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 741
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 740
      y ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 739
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 748
  return ((object *)((void *)0));
}
}
#line 762 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static int start_animation(object *who , object *activator , object *event , char const   *file ,
                           char const   *message ) 
{ 
  FILE *fichier ;
  char *name ;
  int victimtype ;
  object *victim ;
  int unique ;
  int always_delete ;
  int delete_end ;
  int parallel ;
  int paralyzed ;
  int invisible ;
  int wizard ;
  enum time_enum timetype ;
  int errors_allowed ;
  int verbose ;
  char const   *animationitem ;
  char buffer[4096] ;
  char *variable ;
  char *value ;
  int errors_found ;
  CFanimation *current_anim ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  char *tmp___40 ;
  size_t tmp___41 ;
  int tmp___42 ;

  {
  {
#line 764
  name = (char *)((void *)0);
#line 765
  victimtype = 0;
#line 766
  victim = (object *)((void *)0);
#line 767
  unique = 0;
#line 768
  always_delete = 0;
#line 769
  delete_end = 0;
#line 770
  parallel = 0;
#line 771
  paralyzed = 1;
#line 772
  invisible = 0;
#line 773
  wizard = 0;
#line 775
  errors_allowed = 0;
#line 776
  verbose = 0;
#line 781
  errors_found = 0;
#line 784
  fichier = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 785
  if ((unsigned long )fichier == (unsigned long )((void *)0)) {
    {
#line 786
    cf_log((LogLevel )2, "CFAnim: Unable to open %s\n", file);
    }
#line 787
    return (0);
  }
  {
#line 789
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 789
    tmp___0 = fgets((char */* __restrict  */)(buffer), 4096, (FILE */* __restrict  */)fichier);
    }
#line 789
    if (! tmp___0) {
#line 789
      goto while_break;
    }
#line 790
    if ((int )buffer[0] == 91) {
#line 791
      goto while_break;
    }
#line 792
    if ((int )buffer[0] == 35) {
#line 793
      goto while_continue;
    }
    {
#line 794
    tmp = strcmp((char const   *)(buffer), "\n");
    }
#line 794
    if (! tmp) {
#line 795
      goto while_continue;
    }
    {
#line 796
    errors_found = 1;
#line 797
    cf_log((LogLevel )0, "CFAnim: \'%s\' has an invalid syntax.\n", buffer);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 799
  tmp___1 = feof(fichier);
  }
#line 799
  if (tmp___1) {
#line 800
    return (0);
  }
  {
#line 801
  tmp___2 = strncmp((char const   *)(buffer), "[Config]", (size_t )8);
  }
#line 801
  if (tmp___2) {
    {
#line 802
    cf_log((LogLevel )0, "CFAnim: Fatal error in %s: [Config] must be the first group defined.\n",
           file);
    }
#line 803
    return (0);
  }
  {
#line 805
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 805
    tmp___40 = fgets((char */* __restrict  */)(buffer), 4096, (FILE */* __restrict  */)fichier);
    }
#line 805
    if (! tmp___40) {
#line 805
      goto while_break___0;
    }
#line 806
    if ((int )buffer[0] == 91) {
#line 807
      goto while_break___0;
    }
#line 808
    if ((int )buffer[0] == 35) {
#line 809
      goto while_continue___0;
    }
    {
#line 810
    tmp___3 = strcmp((char const   *)(buffer), "\n");
    }
#line 810
    if (! tmp___3) {
#line 811
      goto while_continue___0;
    }
    {
#line 812
    tmp___39 = equality_split(buffer, & variable, & value);
    }
#line 812
    if (tmp___39) {
      {
#line 815
      tmp___38 = strcmp((char const   *)variable, "name");
      }
#line 815
      if (tmp___38) {
        {
#line 821
        tmp___37 = strcmp((char const   *)variable, "victimtype");
        }
#line 821
        if (tmp___37) {
          {
#line 832
          tmp___36 = strcmp((char const   *)variable, "victim");
          }
#line 832
          if (tmp___36) {
            {
#line 854
            tmp___35 = strcmp((char const   *)variable, "unique");
            }
#line 854
            if (tmp___35) {
              {
#line 857
              tmp___34 = strcmp((char const   *)variable, "always_delete");
              }
#line 857
              if (tmp___34) {
                {
#line 860
                tmp___33 = strcmp((char const   *)variable, "delete_event_end");
                }
#line 860
                if (tmp___33) {
                  {
#line 863
                  tmp___32 = strcmp((char const   *)variable, "parallel");
                  }
#line 863
                  if (tmp___32) {
                    {
#line 866
                    tmp___31 = strcmp((char const   *)variable, "paralyzed");
                    }
#line 866
                    if (tmp___31) {
                      {
#line 869
                      tmp___30 = strcmp((char const   *)variable, "invisible");
                      }
#line 869
                      if (tmp___30) {
                        {
#line 872
                        tmp___29 = strcmp((char const   *)variable, "wizard");
                        }
#line 872
                        if (tmp___29) {
                          {
#line 875
                          tmp___28 = strcmp((char const   *)variable, "errors_allowed");
                          }
#line 875
                          if (tmp___28) {
                            {
#line 878
                            tmp___27 = strcmp((char const   *)variable, "verbose");
                            }
#line 878
                            if (tmp___27) {
                              {
#line 881
                              tmp___26 = strcmp((char const   *)variable, "time_representation");
                              }
#line 881
                              if (tmp___26) {
                                {
#line 888
                                tmp___25 = strcmp((char const   *)variable, "animation");
                                }
#line 888
                                if (tmp___25) {
#line 891
                                  errors_found = 1;
                                } else {
                                  {
#line 889
                                  animationitem = cf_add_string((char const   *)value);
                                  }
                                }
                              } else {
                                {
#line 882
                                tmp___24 = strcmp((char const   *)value, "second");
                                }
#line 882
                                if (tmp___24) {
                                  {
#line 884
                                  tmp___23 = strcmp((char const   *)value, "tick");
                                  }
#line 884
                                  if (tmp___23) {
#line 887
                                    errors_found = 1;
                                  } else {
#line 885
                                    timetype = (enum time_enum )1;
                                  }
                                } else {
#line 883
                                  timetype = (enum time_enum )0;
                                }
                              }
                            } else {
                              {
#line 879
                              tmp___22 = get_boolean((char const   *)value, & verbose);
                              }
#line 879
                              if (! tmp___22) {
#line 880
                                errors_found = 1;
                              }
                            }
                          } else {
                            {
#line 876
                            tmp___21 = get_boolean((char const   *)value, & errors_allowed);
                            }
#line 876
                            if (! tmp___21) {
#line 877
                              errors_found = 1;
                            }
                          }
                        } else {
                          {
#line 873
                          tmp___20 = get_boolean((char const   *)value, & wizard);
                          }
#line 873
                          if (! tmp___20) {
#line 874
                            errors_found = 1;
                          }
                        }
                      } else {
                        {
#line 870
                        tmp___19 = get_boolean((char const   *)value, & invisible);
                        }
#line 870
                        if (! tmp___19) {
#line 871
                          errors_found = 1;
                        }
                      }
                    } else {
                      {
#line 867
                      tmp___18 = get_boolean((char const   *)value, & paralyzed);
                      }
#line 867
                      if (! tmp___18) {
#line 868
                        errors_found = 1;
                      }
                    }
                  } else {
                    {
#line 864
                    tmp___17 = get_boolean((char const   *)value, & parallel);
                    }
#line 864
                    if (! tmp___17) {
#line 865
                      errors_found = 1;
                    }
                  }
                } else {
                  {
#line 861
                  tmp___16 = get_boolean((char const   *)value, & delete_end);
                  }
#line 861
                  if (! tmp___16) {
#line 862
                    errors_found = 1;
                  }
                }
              } else {
                {
#line 858
                tmp___15 = get_boolean((char const   *)value, & always_delete);
                }
#line 858
                if (! tmp___15) {
#line 859
                  errors_found = 1;
                }
              }
            } else {
              {
#line 855
              tmp___14 = get_boolean((char const   *)value, & unique);
              }
#line 855
              if (! tmp___14) {
#line 856
                errors_found = 1;
              }
            }
          } else {
            {
#line 833
            cf_log((LogLevel )2, "CFAnim: Setting victim to %s\n", value);
#line 834
            tmp___13 = strcmp((char const   *)value, "who");
            }
#line 834
            if (tmp___13) {
              {
#line 836
              tmp___12 = strcmp((char const   *)value, "activator");
              }
#line 836
              if (tmp___12) {
                {
#line 838
                tmp___11 = strcmp((char const   *)value, "who_owner");
                }
#line 838
                if (tmp___11) {
                  {
#line 844
                  tmp___10 = strcmp((char const   *)value, "activator_owner");
                  }
#line 844
                  if (tmp___10) {
#line 850
                    if (victimtype == 3) {
                      {
#line 851
                      victim = find_by_name(who, (char const   *)value);
                      }
                    } else {
#line 853
                      errors_found = 1;
                    }
                  } else
#line 845
                  if (! activator) {
                    {
#line 846
                    errors_found = 1;
#line 847
                    cf_log((LogLevel )0, "CFAnim: Warning: object \"activator\" doesn\'t exist and you\'re victimized it\'s owner\n");
                    }
                  } else {
#line 849
                    victim = activator->env;
                  }
                } else
#line 839
                if (! who) {
                  {
#line 840
                  errors_found = 1;
#line 841
                  cf_log((LogLevel )0, "CFAnim: Warning: object \"who\" doesn\'t exist and you\'re victimized it\'s owner\n");
                  }
                } else {
#line 843
                  victim = who->env;
                }
              } else {
#line 837
                victim = activator;
              }
            } else {
#line 835
              victim = who;
            }
          }
        } else {
          {
#line 822
          tmp___9 = strcmp((char const   *)value, "player");
          }
#line 822
          if (tmp___9) {
            {
#line 824
            tmp___8 = strcmp((char const   *)value, "object");
            }
#line 824
            if (tmp___8) {
              {
#line 826
              tmp___7 = strcmp((char const   *)value, "any");
              }
#line 826
              if (tmp___7) {
                {
#line 828
                tmp___6 = strcmp((char const   *)value, "byname");
                }
#line 828
                if (tmp___6) {
#line 831
                  errors_found = 1;
                } else {
#line 829
                  victimtype = 3;
                }
              } else {
#line 827
                victimtype = 2;
              }
            } else {
#line 825
              victimtype = 1;
            }
          } else {
#line 823
            victimtype = 0;
          }
        }
      } else {
#line 816
        if ((int )*value == 34) {
#line 817
          value ++;
        }
        {
#line 818
        tmp___5 = strlen((char const   *)value);
        }
#line 818
        if ((int )*(value + (tmp___5 - 1UL)) == 34) {
          {
#line 819
          tmp___4 = strlen((char const   *)value);
#line 819
          *(value + (tmp___4 - 1UL)) = (char )'\000';
          }
        }
        {
#line 820
        name = cf_strdup_local((char const   *)value);
        }
      }
    } else {
#line 813
      errors_found = 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 895
  if (message) {
#line 895
    if ((int const   )*(message + 0) != 0) {
      {
#line 896
      cf_free_string(animationitem);
#line 897
      animationitem = cf_add_string(message);
      }
    }
  }
#line 900
  if ((int )buffer[0] == 0) {
#line 901
    if (animationitem) {
      {
#line 902
      cf_free_string(animationitem);
      }
    }
    {
#line 903
    cf_log((LogLevel )0, "CFAnim: Errors occurred during the parsing of %s\n", file);
    }
#line 904
    return (0);
  }
#line 906
  if (! victim) {
#line 907
    if (animationitem) {
      {
#line 908
      cf_free_string(animationitem);
      }
    }
    {
#line 909
    cf_log((LogLevel )0, "CFAnim: Fatal error - victim is NULL");
    }
#line 910
    return (0);
  }
  {
#line 912
  current_anim = create_animation();
  }
#line 912
  if (! current_anim) {
#line 913
    if (animationitem) {
      {
#line 914
      cf_free_string(animationitem);
      }
    }
    {
#line 915
    cf_log((LogLevel )0, "CFAnim: Fatal error - Not enough memory.\n");
    }
#line 916
    return (0);
  }
#line 918
  if (always_delete) {
    {
#line 920
    cf_object_remove(event);
#line 921
    event = (object *)((void *)0);
    }
  }
#line 923
  if ((int )victim->type == 1) {
#line 923
    if (victimtype == 1) {
#line 923
      goto _L;
    } else {
#line 923
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 923
  if ((int )victim->type != 1) {
#line 923
    if (victimtype == 0) {
#line 923
      goto _L;
    } else {
#line 923
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 923
  if (errors_found) {
#line 923
    if (! errors_allowed) {
      _L: /* CIL Label */ 
#line 926
      if (verbose) {
        {
#line 927
        cf_log((LogLevel )0, "CFAnim: No correct victim found or errors found, aborting.\n");
        }
      }
#line 928
      if (animationitem) {
        {
#line 929
        cf_free_string(animationitem);
        }
      }
#line 930
      return (0);
    }
  }
#line 932
  if (unique) {
#line 932
    if (! always_delete) {
      {
#line 934
      cf_object_remove(event);
#line 935
      event = (object *)((void *)0);
      }
    }
  }
#line 937
  current_anim->name = name;
#line 938
  current_anim->victim = victim;
#line 939
  current_anim->event = event;
#line 940
  current_anim->paralyze = paralyzed;
#line 941
  current_anim->invisible = invisible;
#line 942
  current_anim->wizard = wizard;
#line 943
  current_anim->unique = unique;
#line 944
  current_anim->delete_end = delete_end;
#line 945
  current_anim->ghosted = 0;
#line 946
  current_anim->corpse = (object *)((void *)0);
#line 947
  current_anim->time_representation = timetype;
#line 948
  current_anim->verbose = verbose;
#line 949
  current_anim->tick_left = 0L;
#line 950
  current_anim->errors_allowed = errors_allowed;
  {
#line 952
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 952
    if (! ((int )buffer[0] == 91)) {
#line 952
      goto while_break___1;
    }
    {
#line 953
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 953
      tmp___41 = strlen(animationitem);
#line 953
      tmp___42 = strncmp((char const   *)(& buffer[1]), animationitem, tmp___41);
      }
#line 953
      if (! tmp___42) {
#line 953
        goto while_break___2;
      }
      {
#line 954
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 954
        value = fgets((char */* __restrict  */)(buffer), 4096, (FILE */* __restrict  */)fichier);
        }
#line 954
        if (! ((unsigned long )value != (unsigned long )((void *)0))) {
#line 954
          goto while_break___3;
        }
#line 955
        if ((int )buffer[0] == 91) {
#line 956
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 957
      if ((unsigned long )value == (unsigned long )((void *)0)) {
        {
#line 958
        cf_log((LogLevel )0, "CFAnim: no matching animation %s in file.\n", animationitem);
#line 959
        cf_free_string(animationitem);
        }
#line 960
        return (0);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 963
    current_anim->nextmovement = parse_animation_block(buffer, (size_t )4096, fichier,
                                                       current_anim);
    }
#line 964
    if (current_anim->nextmovement) {
#line 965
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 967
  fclose(fichier);
  }
#line 968
  return (1);
}
}
#line 976 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static void animate_one(CFanimation *animation , long milliseconds ) 
{ 
  CFmovement *current ;
  int mult ;
  anim_move_result result ;

  {
#line 978
  mult = 1;
#line 981
  if ((unsigned int )animation->time_representation == 0U) {
#line 982
    animation->tick_left += milliseconds;
#line 983
    mult = 1000;
  } else {
#line 985
    (animation->tick_left) ++;
  }
#line 987
  if (animation->verbose) {
    {
#line 988
    cf_log((LogLevel )2, "CFAnim: Ticking %s for %s. Tickleft is %ld\n", animation->name,
           (animation->victim)->name, animation->tick_left);
    }
  }
#line 989
  if (animation->invisible) {
#line 990
    (animation->victim)->invisible = (sint16 )10;
  }
#line 991
  if (animation->wizard) {
#line 991
    if ((int )(animation->victim)->type == 1) {
#line 993
      if (animation->verbose) {
        {
#line 994
        cf_log((LogLevel )2, "CFAnim: Setting wizard flags\n");
        }
      }
      {
#line 995
      cf_object_set_flag(animation->victim, 72, 1);
#line 996
      cf_object_set_flag(animation->victim, 51, 1);
#line 997
      cf_object_set_flag(animation->victim, 1, 1);
      }
#line 998
      if (animation->verbose) {
        {
#line 999
        cf_log((LogLevel )2, "CFAnim: Setting wizard flags done\n");
        }
      }
    }
  }
#line 1002
  if (animation->paralyze) {
#line 1003
    (animation->victim)->speed_left = (float )-99999;
  }
  {
#line 1005
  cf_object_update(animation->victim, 3);
  }
#line 1007
  if (animation->nextmovement) {
    {
#line 1008
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1008
      if (! (animation->tick_left > (long )((animation->nextmovement)->tick * mult))) {
#line 1008
        goto while_break;
      }
      {
#line 1009
      animation->tick_left -= (long )((animation->nextmovement)->tick * mult);
#line 1010
      result = (*((animation->nextmovement)->func))(animation, (animation->nextmovement)->id,
                                                    (animation->nextmovement)->parameters);
      }
#line 1011
      if ((unsigned int )result == 1U) {
#line 1012
        goto while_continue;
      }
      {
#line 1014
      current = animation->nextmovement;
#line 1015
      animation->nextmovement = (animation->nextmovement)->next;
#line 1016
      free((void *)current);
      }
#line 1017
      if (! animation->nextmovement) {
#line 1018
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1020
  cf_object_set_flag(animation->victim, 72, 0);
#line 1021
  cf_object_set_flag(animation->victim, 51, 0);
#line 1022
  cf_object_set_flag(animation->victim, 1, 0);
  }
#line 1023
  return;
}
}
#line 1033 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static struct timeval yesterday  ;
#line 1034
static void animate(void) ;
#line 1034 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static int already_passed  =    0;
#line 1028 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
static void animate(void) 
{ 
  CFanimation *current ;
  CFanimation *next ;
  CFanimation *previous_anim ;
  struct timeval now ;
  long delta_milli ;

  {
  {
#line 1031
  previous_anim = (CFanimation *)((void *)0);
#line 1037
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((struct timezone *)((void *)0)));
  }
#line 1038
  if (! already_passed) {
    {
#line 1039
    already_passed = 1;
#line 1040
    memcpy((void */* __restrict  */)(& yesterday), (void const   */* __restrict  */)(& now),
           sizeof(struct timeval ));
    }
#line 1041
    return;
  }
  {
#line 1043
  delta_milli = (now.tv_sec - yesterday.tv_sec) * 1000L + (now.tv_usec / 1000L - yesterday.tv_usec / 1000L);
#line 1045
  memcpy((void */* __restrict  */)(& yesterday), (void const   */* __restrict  */)(& now),
         sizeof(struct timeval ));
#line 1046
  current = first_animation;
  }
  {
#line 1046
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1046
    if (! current) {
#line 1046
      goto while_break;
    }
    {
#line 1047
    animate_one(current, delta_milli);
#line 1046
    current = current->nextanimation;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1048
  current = first_animation;
  {
#line 1049
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1049
    if (! current) {
#line 1049
      goto while_break___0;
    }
#line 1050
    if (! current->nextmovement) {
#line 1051
      if (current->paralyze) {
#line 1052
        (current->victim)->speed_left = (current->victim)->speed;
      }
#line 1053
      next = current->nextanimation;
#line 1054
      if ((unsigned long )first_animation == (unsigned long )current) {
#line 1055
        first_animation = next;
      } else {
#line 1057
        previous_anim->nextanimation = next;
      }
#line 1059
      if (current->delete_end) {
#line 1059
        if ((unsigned long )current->event != (unsigned long )((void *)0)) {
          {
#line 1060
          cf_object_remove(current->event);
          }
        }
      }
      {
#line 1061
      free((void *)current->name);
#line 1062
      free((void *)current);
#line 1063
      current = next;
      }
    } else {
#line 1065
      previous_anim = current;
#line 1066
      current = current->nextanimation;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1069
  return;
}
}
#line 1077 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
int __attribute__((__visibility__("default")))  initPlugin(char const   *iversion ,
                                                           void (*gethooksptr)(int *type 
                                                                               , ...) ) 
{ 


  {
  {
#line 1078
  cf_init_plugin(gethooksptr);
#line 1079
  cf_log((LogLevel )2, "CFAnim 2.0a init\n");
  }
#line 1082
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 1085 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
void __attribute__((__visibility__("default")))  *getPluginProperty(int *type  , ...) 
{ 
  va_list args ;
  char const   *propname ;
  char *buf ;
  int size ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1091
  __builtin_va_start(args, type);
#line 1092
  tmp = __builtin_va_arg(args, char const   *);
#line 1092
  propname = tmp;
#line 1094
  tmp___5 = strcmp(propname, "Identification");
  }
#line 1094
  if (tmp___5) {
    {
#line 1100
    tmp___4 = strcmp(propname, "FullName");
    }
#line 1100
    if (! tmp___4) {
      {
#line 1101
      tmp___2 = __builtin_va_arg(args, char *);
#line 1101
      buf = tmp___2;
#line 1102
      tmp___3 = __builtin_va_arg(args, int );
#line 1102
      size = tmp___3;
#line 1103
      __builtin_va_end(args);
#line 1104
      snprintf((char */* __restrict  */)buf, (size_t )size, (char const   */* __restrict  */)"CFAnim Plugin 2.0");
      }
#line 1105
      return ((void __attribute__((__visibility__("default")))  *)((void *)0));
    }
  } else {
    {
#line 1095
    tmp___0 = __builtin_va_arg(args, char *);
#line 1095
    buf = tmp___0;
#line 1096
    tmp___1 = __builtin_va_arg(args, int );
#line 1096
    size = tmp___1;
#line 1097
    __builtin_va_end(args);
#line 1098
    snprintf((char */* __restrict  */)buf, (size_t )size, (char const   */* __restrict  */)"Animator");
    }
#line 1099
    return ((void __attribute__((__visibility__("default")))  *)((void *)0));
  }
  {
#line 1107
  __builtin_va_end(args);
  }
#line 1108
  return ((void __attribute__((__visibility__("default")))  *)((void *)0));
}
}
#line 1111 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
anim_move_result __attribute__((__visibility__("default")))  cfanim_runPluginCommand(object *op ,
                                                                                     char *params ) 
{ 


  {
#line 1112
  return ((anim_move_result __attribute__((__visibility__("default")))  )-1);
}
}
#line 1115 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
int __attribute__((__visibility__("default")))  postInitPlugin(void) 
{ 


  {
  {
#line 1116
  cf_log((LogLevel )2, "CFAnim 2.0a post init\n");
#line 1118
  cf_system_register_global_event(15, "Animator", (int (*)(int *type  , ...))(& cfanim_globalEventListener));
  }
#line 1119
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 1122 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
int __attribute__((__visibility__("default")))  cfanim_globalEventListener(int *type 
                                                                           , ...) 
{ 
  va_list args ;
  int rv ;
  int event_code ;
  int tmp ;

  {
  {
#line 1124
  rv = 0;
#line 1127
  __builtin_va_start(args, type);
#line 1128
  tmp = __builtin_va_arg(args, int );
#line 1128
  event_code = tmp;
  }
#line 1129
  if (! (event_code == 15)) {
    {
#line 1129
    __assert_fail("event_code == 15", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c",
                  1129U, "cfanim_globalEventListener");
    }
  }
  {
#line 1131
  animate();
#line 1133
  __builtin_va_end(args);
  }
#line 1135
  return ((int __attribute__((__visibility__("default")))  )rv);
}
}
#line 1138 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
int __attribute__((__visibility__("default")))  eventListener(int *type  , ...) 
{ 
  int rv ;
  va_list args ;
  char *buf ;
  char message[256] ;
  char script[256] ;
  object *who ;
  object *activator ;
  object *event ;
  int query ;
  object *tmp ;
  object *tmp___0 ;
  object *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  object *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1139
  rv = 0;
#line 1145
  __builtin_va_start(args, type);
#line 1147
  tmp = __builtin_va_arg(args, object *);
#line 1147
  who = tmp;
#line 1148
  tmp___0 = __builtin_va_arg(args, object *);
#line 1148
  activator = tmp___0;
#line 1149
  tmp___2 = __builtin_va_arg(args, object *);
#line 1150
  tmp___3 = __builtin_va_arg(args, char *);
#line 1150
  buf = tmp___3;
  }
#line 1152
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
    {
#line 1153
    strcpy((char */* __restrict  */)(message), (char const   */* __restrict  */)buf);
    }
  } else {
#line 1155
    message[0] = (char )'\000';
  }
  {
#line 1157
  tmp___4 = __builtin_va_arg(args, int );
#line 1157
  query = tmp___4;
#line 1158
  tmp___5 = __builtin_va_arg(args, object *);
#line 1158
  event = tmp___5;
  }
#line 1160
  if (query == 1) {
    {
#line 1160
    tmp___6 = strcmp((char const   *)(message), "query_object_is_animated");
    }
#line 1160
    if (tmp___6 == 0) {
      {
#line 1161
      rv = is_animated_object((object const   *)who);
      }
#line 1162
      return ((int __attribute__((__visibility__("default")))  )rv);
    }
  }
  {
#line 1166
  cf_get_maps_directory(event->slaying, script, (int )sizeof(script));
#line 1167
  __builtin_va_end(args);
  }
#line 1170
  if ((unsigned long )activator != (unsigned long )((void *)0)) {
    {
#line 1171
    cf_log((LogLevel )2, "CFAnim: %s called animator script %s\n", activator->name,
           script);
    }
  } else
#line 1172
  if ((unsigned long )who != (unsigned long )((void *)0)) {
    {
#line 1173
    activator = who;
#line 1174
    cf_log((LogLevel )2, "CFAnim: %s called animator script %s\n", who->name, script);
    }
  }
  {
#line 1177
  rv = start_animation(who, activator, event, (char const   *)(script), (char const   *)(message));
  }
#line 1179
  return ((int __attribute__((__visibility__("default")))  )rv);
}
}
#line 1182 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfanim/cfanim.c"
int __attribute__((__visibility__("default")))  closePlugin(void) 
{ 


  {
  {
#line 1183
  cf_log((LogLevel )2, "CFAnim 2.0a closing\n");
  }
#line 1184
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiSystem_add_string___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 41 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiSystem_find_string___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 42 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiSystem_register_global_event___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 43 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiSystem_remove_string___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 44 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiSystem_unregister_global_event___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 45 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiSystem_strdup_local___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 46 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiSystem_find_animation___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 47 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiSystem_find_face___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 48 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiSystem_log___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 49 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiSystem_get_time___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 50 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiSystem_timer_create___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 51 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiSystem_timer_destroy___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 52 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiSystem_directory___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 53 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiSystem_re_cmp___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 55 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_get_property___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 56 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_set_property___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 57 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_apply___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 58 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_identify___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 59 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_describe___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 60 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_drain___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 61 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_fix___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 62 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_give_skill___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 63 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_transmute___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 64 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_remove___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 65 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_delete___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 66 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_clone___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 67 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_create___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 68 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_insert___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 69 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_split___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 70 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_merge___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 71 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_distance___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 72 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_update___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 73 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_clear___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 74 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_reset___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 75 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_activate_rune___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 76 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_check_trigger___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 77 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_query_money___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 78 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_query_cost___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 79 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_query_cost_string___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 80 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_cast___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 81 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_learn_spell___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 82 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_forget_spell___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 83 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_check_spell___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 84 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_pay_amount___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 85 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_pay_item___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 86 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_transfer___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 87 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_find_archetype_inside___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 88 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_find_by_arch_name___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 89 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_find_by_name___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 90 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_out_of_map___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 91 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_drop___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 92 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_change_abil___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 93 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_say___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 94 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiMap_get_property___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 95 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiMap_set_property___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 96 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiMap_get_map___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 97 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiMap_message___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 98 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiMap_get_object_at___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 99 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiMap_find_by_archetype_name___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 100 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiMap_create_path___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 101 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiMap_has_been_loaded___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 102 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiMap_change_light___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 103 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiMap_trigger_connected___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 104 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiPlayer_find___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 105 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiPlayer_message___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 106 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_teleport___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 107 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_pickup___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 108 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_get_key___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 109 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_set_key___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 110 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_move___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 111 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_apply_below___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 112 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiArchetype_get_property___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 113 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiParty_get_property___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 114 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiRegion_get_property___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 115 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiPlayer_can_pay___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 116 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiFriendlylist_get_next___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 117 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiSet_random_map_variable___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 118 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiGenerate_random_map___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 119 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_change_exp___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 120 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiSystem_get_month_name___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 121 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiSystem_get_season_name___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 122 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiSystem_get_weekday_name___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 123 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiSystem_get_periodofday_name___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 124 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_user_event___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 125 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiCost_string_from_value___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 126 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiPlayer_quest___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 127 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiObject_remove_depletion___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 128 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/../common/plugin_common.c"
static void (*cfapiPlayer_knowledge___0)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 4 "./include/citylife_proto.h"
int __attribute__((__visibility__("default")))  citylife_runPluginCommand(object *op ,
                                                                          char *params ) ;
#line 5
int __attribute__((__visibility__("default")))  citylife_globalEventListener(int *type 
                                                                             , ...) ;
#line 104 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
int __attribute__((__visibility__("default")))  citylife_runPluginCommand(object *op ,
                                                                          char *params ) 
{ 


  {
#line 105
  return ((int __attribute__((__visibility__("default")))  )-1);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
static spawn_zone const   scorn_nw_zones[1]  = {      {40, 26, 50, 50}};
#line 155 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
static spawn_point const   scorn_nw_points[5]  = {      {41, 37}, 
        {48, 35}, 
        {49, 40}, 
        {47, 22}, 
        {49, 37}};
#line 164 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
static spawn_zone const   scorn_ne_zones[1]  = {      {0, 26, 22, 50}};
#line 169 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
static spawn_point const   scorn_ne_points[5]  = {      {15, 42}, 
        {9, 35}, 
        {15, 29}, 
        {1, 25}, 
        {1, 29}};
#line 178 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
static spawn_zone const   scorn_sw_zones[1]  = {      {41, 0, 50, 10}};
#line 183 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
static spawn_point const   scorn_sw_points[3]  = {      {41, 2}, 
        {46, 8}, 
        {42, 8}};
#line 190 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
static spawn_zone const   scorn_se_zones[1]  = {      {0, 0, 13, 10}};
#line 195 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
static spawn_point const   scorn_se_points[4]  = {      {2, 8}, 
        {11, 8}, 
        {8, 1}, 
        {5, 8}};
#line 203 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
static char const   * const  scorn_archs[12]  = 
#line 203
  {      (char const   */* const  */)"c_man",      (char const   */* const  */)"c_woman",      (char const   */* const  */)"child",      (char const   */* const  */)"farmer", 
        (char const   */* const  */)"fatman",      (char const   */* const  */)"fatwoman",      (char const   */* const  */)"guard",      (char const   */* const  */)"knight", 
        (char const   */* const  */)"man",      (char const   */* const  */)"nun",      (char const   */* const  */)"sage",      (char const   */* const  */)"woman"};
#line 224 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
static mapzone const   available_zones[5]  = {      {scorn_nw_points, 5, scorn_nw_zones, 1, 2, "/world/world_104_115", scorn_archs,
      12}, 
        {scorn_ne_points, 1, scorn_ne_zones, 1, 5, "/world/world_105_115", scorn_archs,
      12}, 
        {scorn_sw_points, 3, scorn_sw_zones, 1, 5, "/world/world_104_116", scorn_archs,
      12}, 
        {scorn_se_points, 1, scorn_se_zones, 1, 5, "/world/world_105_116", scorn_archs,
      12}, 
        {(spawn_point const   *)((void *)0), -1, (spawn_zone const   *)((void *)0), -1,
      1, "", (char const   * const  *)((void *)0), 0}};
#line 240 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
static mapzone const   *get_zone_for_map(mapstruct *map ) 
{ 
  int test ;
  int tmp ;

  {
#line 243
  test = 0;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! (available_zones[test].count_points != -1)) {
#line 243
      goto while_break;
    }
    {
#line 244
    tmp = strcmp((char const   *)available_zones[test].mapname, (char const   *)(map->path));
    }
#line 244
    if (tmp == 0) {
#line 245
      return (& available_zones[test]);
    }
#line 243
    test ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 247
  return ((mapzone const   *)((void *)0));
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
static object *get_npc(mapzone const   *zone ) 
{ 
  int arch ;
  long tmp ;
  object *npc ;
  object *tmp___0 ;
  object *evt ;

  {
  {
#line 258
  tmp = random();
#line 258
  arch = (int )(tmp % (long )zone->archetypes_count);
#line 259
  tmp___0 = cf_create_object_by_name((char const   *)*(zone->available_archetypes + arch));
#line 259
  npc = tmp___0;
  }
#line 262
  if (! npc) {
    {
#line 263
    cf_log((LogLevel )0, "citylife: get_npc() got NULL object for %s!\n", *(zone->available_archetypes + arch));
    }
#line 264
    return ((object *)((void *)0));
  }
  {
#line 267
  cf_object_set_flag(npc, 68, 1);
#line 269
  cf_object_set_flag(npc, 36, 1);
#line 271
  cf_object_set_key(npc, "citylife_first_move", "1", 1);
#line 273
  evt = cf_create_object_by_name("event_time");
#line 274
  evt->slaying = cf_add_string("citylife");
#line 275
  evt->title = cf_add_string("citylife");
#line 276
  cf_object_insert_object(evt, npc);
  }
#line 278
  return (npc);
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
static void add_npc_to_zone(mapzone const   *zone , mapstruct *map ) 
{ 
  int which ;
  object *npc ;
  object *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
  {
#line 290
  tmp = get_npc(zone);
#line 290
  npc = tmp;
  }
#line 292
  if (! npc) {
#line 293
    return;
  }
  {
#line 294
  tmp___0 = random();
#line 294
  which = (int )(tmp___0 % (long )zone->count_zones);
#line 295
  tmp___1 = random();
#line 295
  tmp___2 = random();
#line 295
  tmp___3 = cf_object_teleport(npc, map, (int )((long )(zone->zones + which)->sx + tmp___2 % (long )((zone->zones + which)->ex - (zone->zones + which)->sx)),
                               (int )((long )(zone->zones + which)->sy + tmp___1 % (long )((zone->zones + which)->ey - (zone->zones + which)->sy)));
  }
#line 295
  if (tmp___3) {
    {
#line 296
    cf_object_free_drop_inventory(npc);
    }
  }
#line 298
  return;
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
static void add_npc_to_point(mapzone const   *zone , mapstruct *map ) 
{ 
  int which ;
  object *npc ;
  object *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 309
  tmp = get_npc(zone);
#line 309
  npc = tmp;
#line 311
  tmp___0 = random();
#line 311
  which = (int )(tmp___0 % (long )zone->count_points);
#line 312
  tmp___1 = cf_object_teleport(npc, map, (int )(zone->points + which)->x, (int )(zone->points + which)->y);
  }
#line 312
  if (tmp___1) {
    {
#line 313
    cf_object_free_drop_inventory(npc);
    }
  }
#line 315
  return;
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
static void add_npcs_to_map(mapstruct *map ) 
{ 
  int add ;
  mapzone const   *zone ;
  mapzone const   *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 324
  tmp = get_zone_for_map(map);
#line 324
  zone = tmp;
  }
#line 326
  if (! zone) {
#line 327
    return;
  }
  {
#line 329
  tmp___0 = random();
#line 329
  add = (int )(1L + tmp___0 % (long )zone->population);
#line 330
  cf_log((LogLevel )2, "citylife: adding %d NPC to map %s.\n", add, map->path);
  }
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    tmp___1 = add;
#line 332
    add --;
#line 332
    if (! (tmp___1 >= 0)) {
#line 332
      goto while_break;
    }
    {
#line 333
    add_npc_to_zone(zone, map);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 335
  return;
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
static void add_npc_to_random_map(void) 
{ 
  int count ;
  int test ;
  mapstruct *list[50] ;
  int zones[50] ;
  mapstruct *tmp ;
  long tmp___0 ;

  {
  {
#line 344
  count = 0;
#line 346
  cf_log((LogLevel )2, "citylife: adding NPC to random map.\n");
#line 348
  test = 0;
  }
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (available_zones[test].count_points != -1) {
#line 348
      if (! (count < 50)) {
#line 348
        goto while_break;
      }
    } else {
#line 348
      goto while_break;
    }
    {
#line 349
    tmp = cf_map_has_been_loaded((char const   *)available_zones[test].mapname);
#line 349
    list[count] = tmp;
    }
#line 349
    if (tmp) {
#line 349
      if ((list[count])->in_memory == 1U) {
#line 350
        zones[count] = test;
#line 351
        count ++;
      }
    }
#line 348
    test ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 354
  if (! count) {
#line 355
    return;
  }
  {
#line 357
  tmp___0 = random();
#line 357
  test = (int )(tmp___0 % (long )count);
#line 358
  add_npc_to_point(& available_zones[zones[test]], list[test]);
  }
#line 359
  return;
}
}
#line 361 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/citylife/citylife.c"
int __attribute__((__visibility__("default")))  citylife_globalEventListener(int *type 
                                                                             , ...) 
{ 
  va_list args ;
  int rv ;
  mapstruct *map ;
  int code ;
  int tmp ;
  mapstruct *tmp___0 ;
  long tmp___1 ;

  {
  {
#line 363
  rv = 0;
#line 367
  __builtin_va_start(args, type);
#line 368
  tmp = __builtin_va_arg(args, int );
#line 368
  code = tmp;
  }
  {
#line 371
  if (code == 30) {
#line 371
    goto case_30;
  }
#line 376
  if (code == 15) {
#line 376
    goto case_15;
  }
#line 370
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 372
  tmp___0 = __builtin_va_arg(args, mapstruct *);
#line 372
  map = tmp___0;
#line 373
  add_npcs_to_map(map);
  }
#line 374
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 377
  tmp___1 = random();
  }
#line 377
  if (tmp___1 % 40L == 0L) {
    {
#line 378
    add_npc_to_random_map();
    }
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 380
  __builtin_va_end(args);
  }
#line 382
  return ((int __attribute__((__visibility__("default")))  )rv);
}
}
#line 437 "/usr/include/python2.7/object.h"
extern int PyType_IsSubtype(PyTypeObject * , PyTypeObject * ) ;
#line 480
extern PyObject *PyObject_GenericGetAttr(PyObject * , PyObject * ) ;
#line 481
extern int PyObject_GenericSetAttr(PyObject * , PyObject * , PyObject * ) ;
#line 484
extern long PyObject_HashNotImplemented(PyObject * ) ;
#line 838
extern PyObject _Py_NoneStruct ;
#line 848
extern PyObject _Py_NotImplementedStruct ;
#line 97 "/usr/include/python2.7/objimpl.h"
extern void *PyObject_Malloc(size_t  ) ;
#line 150
extern PyObject *PyObject_Init(PyObject * , PyTypeObject * ) ;
#line 31 "/usr/include/python2.7/boolobject.h"
extern PyObject *PyBool_FromLong(long  ) ;
#line 31 "/usr/include/python2.7/modsupport.h"
extern PyObject *Py_BuildValue(char const   *  , ...) ;
#line 38 "./include/cfpython_region.h"
PyTypeObject Crossfire_RegionType ;
#line 40
PyObject *Crossfire_Region_wrap(region *what ) ;
#line 1 "./include/cfpython_region_private.h"
static PyObject *Crossfire_Region_GetName(Crossfire_Region *regionptr , void *closure ) ;
#line 2
static PyObject *Crossfire_Region_GetLongname(Crossfire_Region *regionptr , void *closure ) ;
#line 3
static PyObject *Crossfire_Region_GetMessage(Crossfire_Region *regionptr , void *closure ) ;
#line 4
static PyObject *Crossfire_Region_GetNext(Crossfire_Region *party , void *closure ) ;
#line 5
static PyObject *Crossfire_Region_GetParent(Crossfire_Region *party , PyObject *args ) ;
#line 6
static PyObject *Crossfire_Region_GetJailX(Crossfire_Region *regionptr , void *closure ) ;
#line 7
static PyObject *Crossfire_Region_GetJailY(Crossfire_Region *regionptr , void *closure ) ;
#line 8
static PyObject *Crossfire_Region_GetJailPath(Crossfire_Region *regionptr , void *closure ) ;
#line 10
static int Crossfire_Region_InternalCompare(Crossfire_Region *left , Crossfire_Region *right ) ;
#line 11
static PyObject *Crossfire_Region_RichCompare(Crossfire_Region *left , Crossfire_Region *right ,
                                              int op ) ;
#line 13 "./include/cfpython_region_private.h"
static PyGetSetDef Region_getseters[8]  = 
#line 13
  {      {(char *)"Name", (PyObject *(*)(PyObject * , void * ))(& Crossfire_Region_GetName),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Longname", (PyObject *(*)(PyObject * , void * ))(& Crossfire_Region_GetLongname),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Message", (PyObject *(*)(PyObject * , void * ))(& Crossfire_Region_GetMessage),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Next", (PyObject *(*)(PyObject * , void * ))(& Crossfire_Region_GetNext),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"JailX", (PyObject *(*)(PyObject * , void * ))(& Crossfire_Region_GetJailX),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"JailY", (PyObject *(*)(PyObject * , void * ))(& Crossfire_Region_GetJailY),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"JailPath", (PyObject *(*)(PyObject * , void * ))(& Crossfire_Region_GetJailPath),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)((void *)0), (PyObject *(*)(PyObject * , void * ))((void *)0), (int (*)(PyObject * ,
                                                                                      PyObject * ,
                                                                                      void * ))((void *)0),
      (char *)((void *)0), (void *)0}};
#line 24 "./include/cfpython_region_private.h"
static PyMethodDef RegionMethods[2]  = {      {"GetParent", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Region_GetParent),
      4, (char const   *)((void *)0)}, 
        {(char const   *)((void *)0), (PyObject *(*)(PyObject * , PyObject * ))((void *)0),
      0, (char const   *)((void *)0)}};
#line 30 "./include/cfpython_region_private.h"
PyTypeObject Crossfire_RegionType  = 
#line 30
     {(Py_ssize_t )1, (struct _typeobject *)((void *)0), (Py_ssize_t )0, "Crossfire.Region",
    (Py_ssize_t )sizeof(Crossfire_Region ), (Py_ssize_t )0, (void (*)(PyObject * ))((void *)0),
    (int (*)(PyObject * , FILE * , int  ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                      char * ))((void *)0),
    (int (*)(PyObject * , char * , PyObject * ))((void *)0), (int (*)(PyObject * ,
                                                                      PyObject * ))(& Crossfire_Region_InternalCompare),
    (PyObject *(*)(PyObject * ))((void *)0), (PyNumberMethods *)((void *)0), (PySequenceMethods *)((void *)0),
    (PyMappingMethods *)((void *)0), & PyObject_HashNotImplemented, (PyObject *(*)(PyObject * ,
                                                                                   PyObject * ,
                                                                                   PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * ))((void *)0), & PyObject_GenericGetAttr, & PyObject_GenericSetAttr,
    (PyBufferProcs *)((void *)0), (((((((1L | (1L << 1)) | (1L << 3)) | (1L << 5)) | (1L << 6)) | (1L << 7)) | (1L << 8)) | (1L << 17)) | (1L << 10),
    "Crossfire regions", (int (*)(PyObject * , int (*)(PyObject * , void * ) , void * ))((void *)0),
    (int (*)(PyObject * ))((void *)0), (PyObject *(*)(PyObject * , PyObject * , int  ))(& Crossfire_Region_RichCompare),
    (Py_ssize_t )0, (PyObject *(*)(PyObject * ))((void *)0), (PyObject *(*)(PyObject * ))((void *)0),
    RegionMethods, (struct PyMemberDef *)((void *)0), Region_getseters, (struct _typeobject *)((void *)0),
    (PyObject *)((void *)0), (PyObject *(*)(PyObject * , PyObject * , PyObject * ))((void *)0),
    (int (*)(PyObject * , PyObject * , PyObject * ))((void *)0), (Py_ssize_t )0, (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          PyObject * ))((void *)0),
    (PyObject *(*)(struct _typeobject * , Py_ssize_t  ))((void *)0), (PyObject *(*)(struct _typeobject * ,
                                                                                    PyObject * ,
                                                                                    PyObject * ))((void *)0),
    (void (*)(void * ))((void *)0), (int (*)(PyObject * ))((void *)0), (PyObject *)((void *)0),
    (PyObject *)((void *)0), (PyObject *)((void *)0), (PyObject *)((void *)0), (PyObject *)((void *)0),
    (void (*)(PyObject * ))((void *)0), 0U};
#line 33 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_region.c"
static PyObject *Crossfire_Region_GetName(Crossfire_Region *regionptr , void *closure ) 
{ 
  char const   *tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 34
  tmp = cf_region_get_name(regionptr->reg);
#line 34
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 34
  return (tmp___0);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_region.c"
static PyObject *Crossfire_Region_GetLongname(Crossfire_Region *regionptr , void *closure ) 
{ 
  char const   *tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 38
  tmp = cf_region_get_longname(regionptr->reg);
#line 38
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 38
  return (tmp___0);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_region.c"
static PyObject *Crossfire_Region_GetMessage(Crossfire_Region *regionptr , void *closure ) 
{ 
  char const   *tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 42
  tmp = cf_region_get_message(regionptr->reg);
#line 42
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 42
  return (tmp___0);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_region.c"
static PyObject *Crossfire_Region_GetNext(Crossfire_Region *party , void *closure ) 
{ 
  region *tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 46
  tmp = cf_region_get_next(party->reg);
#line 46
  tmp___0 = Crossfire_Region_wrap(tmp);
  }
#line 46
  return (tmp___0);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_region.c"
static PyObject *Crossfire_Region_GetParent(Crossfire_Region *party , PyObject *args ) 
{ 
  region *tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 50
  tmp = cf_region_get_parent(party->reg);
#line 50
  tmp___0 = Crossfire_Region_wrap(tmp);
  }
#line 50
  return (tmp___0);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_region.c"
static PyObject *Crossfire_Region_GetJailX(Crossfire_Region *regionptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 54
  tmp = cf_region_get_jail_x(regionptr->reg);
#line 54
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 54
  return (tmp___0);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_region.c"
static PyObject *Crossfire_Region_GetJailY(Crossfire_Region *regionptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 58
  tmp = cf_region_get_jail_y(regionptr->reg);
#line 58
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 58
  return (tmp___0);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_region.c"
static PyObject *Crossfire_Region_GetJailPath(Crossfire_Region *regionptr , void *closure ) 
{ 
  char const   *tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 62
  tmp = cf_region_get_jail_path(regionptr->reg);
#line 62
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 62
  return (tmp___0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_region.c"
PyObject *Crossfire_Region_wrap(region *what ) 
{ 
  Crossfire_Region *wrapper ;
  void *tmp ;
  PyObject *tmp___0 ;

  {
#line 69
  if ((unsigned long )what == (unsigned long )((void *)0)) {
#line 70
    (_Py_NoneStruct.ob_refcnt) ++;
#line 71
    return (& _Py_NoneStruct);
  }
  {
#line 74
  tmp = PyObject_Malloc((size_t )Crossfire_RegionType.tp_basicsize);
#line 74
  tmp___0 = PyObject_Init((PyObject *)tmp, & Crossfire_RegionType);
#line 74
  wrapper = (Crossfire_Region *)tmp___0;
  }
#line 75
  if ((unsigned long )wrapper != (unsigned long )((void *)0)) {
#line 76
    wrapper->reg = what;
  }
#line 77
  return ((PyObject *)wrapper);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_region.c"
static int Crossfire_Region_InternalCompare(Crossfire_Region *left , Crossfire_Region *right ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 81
  if ((unsigned long )left->reg < (unsigned long )right->reg) {
#line 81
    tmp___0 = -1;
  } else {
#line 81
    if ((unsigned long )left->reg == (unsigned long )right->reg) {
#line 81
      tmp = 0;
    } else {
#line 81
      tmp = 1;
    }
#line 81
    tmp___0 = tmp;
  }
#line 81
  return (tmp___0);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_region.c"
static PyObject *Crossfire_Region_RichCompare(Crossfire_Region *left , Crossfire_Region *right ,
                                              int op ) 
{ 
  int result ;
  int tmp ;
  int tmp___0 ;
  PyObject *tmp___1 ;

  {
#line 86
  if (! left) {
#line 90
    (_Py_NotImplementedStruct.ob_refcnt) ++;
#line 91
    return (& _Py_NotImplementedStruct);
  } else
#line 86
  if (! right) {
#line 90
    (_Py_NotImplementedStruct.ob_refcnt) ++;
#line 91
    return (& _Py_NotImplementedStruct);
  } else
#line 86
  if ((unsigned long )((PyObject *)left)->ob_type == (unsigned long )(& Crossfire_RegionType)) {
#line 86
    goto _L;
  } else {
    {
#line 86
    tmp = PyType_IsSubtype(((PyObject *)left)->ob_type, & Crossfire_RegionType);
    }
#line 86
    if (tmp) {
      _L: /* CIL Label */ 
#line 86
      if (! ((unsigned long )((PyObject *)right)->ob_type == (unsigned long )(& Crossfire_RegionType))) {
        {
#line 86
        tmp___0 = PyType_IsSubtype(((PyObject *)right)->ob_type, & Crossfire_RegionType);
        }
#line 86
        if (! tmp___0) {
#line 90
          (_Py_NotImplementedStruct.ob_refcnt) ++;
#line 91
          return (& _Py_NotImplementedStruct);
        }
      }
    } else {
#line 90
      (_Py_NotImplementedStruct.ob_refcnt) ++;
#line 91
      return (& _Py_NotImplementedStruct);
    }
  }
  {
#line 93
  result = Crossfire_Region_InternalCompare(left, right);
  }
  {
#line 96
  if (op == 2) {
#line 96
    goto case_2;
  }
#line 99
  if (op == 3) {
#line 99
    goto case_3;
  }
#line 102
  if (op == 1) {
#line 102
    goto case_1;
  }
#line 105
  if (op == 5) {
#line 105
    goto case_5;
  }
#line 108
  if (op == 0) {
#line 108
    goto case_0;
  }
#line 111
  if (op == 4) {
#line 111
    goto case_4;
  }
#line 95
  goto switch_break;
  case_2: /* CIL Label */ 
#line 97
  result = result == 0;
#line 98
  goto switch_break;
  case_3: /* CIL Label */ 
#line 100
  result = result != 0;
#line 101
  goto switch_break;
  case_1: /* CIL Label */ 
#line 103
  result = result <= 0;
#line 104
  goto switch_break;
  case_5: /* CIL Label */ 
#line 106
  result = result >= 0;
#line 107
  goto switch_break;
  case_0: /* CIL Label */ 
#line 109
  result = result == -1;
#line 110
  goto switch_break;
  case_4: /* CIL Label */ 
#line 112
  result = result == 1;
#line 113
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 115
  tmp___1 = PyBool_FromLong((long )result);
  }
#line 115
  return (tmp___1);
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiSystem_add_string___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 41 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiSystem_find_string___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 42 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiSystem_register_global_event___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 43 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiSystem_remove_string___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 44 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiSystem_unregister_global_event___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 45 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiSystem_strdup_local___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 46 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiSystem_find_animation___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 47 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiSystem_find_face___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 48 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiSystem_log___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 49 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiSystem_get_time___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 50 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiSystem_timer_create___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 51 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiSystem_timer_destroy___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 52 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiSystem_directory___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 53 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiSystem_re_cmp___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 55 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_get_property___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 56 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_set_property___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 57 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_apply___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 58 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_identify___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 59 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_describe___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 60 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_drain___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 61 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_fix___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 62 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_give_skill___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 63 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_transmute___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 64 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_remove___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 65 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_delete___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 66 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_clone___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 67 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_create___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 68 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_insert___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 69 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_split___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 70 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_merge___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 71 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_distance___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 72 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_update___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 73 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_clear___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 74 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_reset___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 75 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_activate_rune___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 76 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_check_trigger___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 77 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_query_money___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 78 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_query_cost___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 79 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_query_cost_string___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 80 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_cast___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 81 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_learn_spell___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 82 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_forget_spell___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 83 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_check_spell___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 84 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_pay_amount___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 85 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_pay_item___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 86 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_transfer___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 87 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_find_archetype_inside___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 88 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_find_by_arch_name___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 89 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_find_by_name___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 90 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_out_of_map___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 91 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_drop___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 92 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_change_abil___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 93 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_say___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 94 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiMap_get_property___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 95 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiMap_set_property___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 96 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiMap_get_map___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 97 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiMap_message___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 98 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiMap_get_object_at___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 99 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiMap_find_by_archetype_name___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 100 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiMap_create_path___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 101 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiMap_has_been_loaded___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 102 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiMap_change_light___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 103 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiMap_trigger_connected___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 104 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiPlayer_find___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 105 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiPlayer_message___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 106 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_teleport___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 107 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_pickup___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 108 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_get_key___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 109 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_set_key___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 110 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_move___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 111 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_apply_below___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 112 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiArchetype_get_property___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 113 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiParty_get_property___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 114 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiRegion_get_property___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 115 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiPlayer_can_pay___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 116 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiFriendlylist_get_next___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 117 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiSet_random_map_variable___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 118 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiGenerate_random_map___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 119 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_change_exp___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 120 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiSystem_get_month_name___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 121 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiSystem_get_season_name___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 122 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiSystem_get_weekday_name___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 123 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiSystem_get_periodofday_name___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 124 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_user_event___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 125 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiCost_string_from_value___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 126 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiPlayer_quest___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 127 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiObject_remove_depletion___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 128 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/plugin_common.c"
static void (*cfapiPlayer_knowledge___1)(int *type  , ...)  =    (void (*)(int *type  , ...))((void *)0);
#line 17 "../../plugins/common/include/hashtable.h"
void init_ptr_assoc_table(ptr_assoc **hash_table ) ;
#line 18
void add_ptr_assoc(ptr_assoc **hash_table , void *key , void *value ) ;
#line 19
void *find_assoc_value(ptr_assoc **hash_table , void *key ) ;
#line 20
void free_ptr_assoc(ptr_assoc **hash_table , void *key ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/hashtable.c"
void init_ptr_assoc_table(ptr_assoc **hash_table ) 
{ 


  {
  {
#line 58
  memset((void *)hash_table, 0, 251UL * sizeof(ptr_assoc *));
  }
#line 59
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/hashtable.c"
static int hashptr(void *ptr ) 
{ 


  {
#line 73
  return ((int )((uintptr_t )ptr % 251UL));
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/hashtable.c"
static ptr_assoc *new_ptr_assoc(void *key , void *value ) 
{ 
  ptr_assoc *assoc ;
  void *tmp ;

  {
  {
#line 90
  tmp = malloc(sizeof(ptr_assoc ));
#line 90
  assoc = (ptr_assoc *)tmp;
#line 91
  assoc->previous = (struct _ptr_assoc *)((void *)0);
#line 92
  assoc->array = (struct _ptr_assoc **)((void *)0);
#line 93
  assoc->next = (struct _ptr_assoc *)((void *)0);
#line 94
  assoc->key = key;
#line 95
  assoc->value = value;
  }
#line 96
  return (assoc);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/hashtable.c"
void add_ptr_assoc(ptr_assoc **hash_table , void *key , void *value ) 
{ 
  ptr_assoc *assoc ;
  int ind ;
  ptr_assoc *new_assoc ;

  {
  {
#line 113
  ind = hashptr(key);
#line 114
  assoc = *(hash_table + ind);
  }
#line 117
  if (assoc) {
#line 119
    if ((unsigned long )key != (unsigned long )assoc->key) {
      {
#line 124
      while (1) {
        while_continue: /* CIL Label */ ;
#line 124
        if (! assoc->next) {
#line 124
          goto while_break;
        }
#line 125
        assoc = assoc->next;
#line 126
        if ((unsigned long )key != (unsigned long )assoc->key) {
#line 128
          goto while_continue;
        }
#line 133
        assoc->value = value;
#line 134
        return;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 140
      new_assoc = new_ptr_assoc(key, value);
#line 141
      assoc->next = new_assoc;
#line 142
      new_assoc->previous = assoc;
      }
#line 143
      return;
    }
#line 146
    return;
  } else {
    {
#line 149
    *(hash_table + ind) = new_ptr_assoc(key, value);
#line 151
    (*(hash_table + ind))->array = hash_table + ind;
    }
#line 153
    return;
  }
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/hashtable.c"
static ptr_assoc *find_ptr_assoc(ptr_assoc **hash_table , void *key ) 
{ 
  ptr_assoc *assoc ;
  int ind ;

  {
  {
#line 172
  ind = hashptr(key);
#line 173
  assoc = *(hash_table + ind);
  }
#line 176
  if (assoc) {
#line 178
    if ((unsigned long )assoc->key == (unsigned long )key) {
#line 179
      return (assoc);
    } else {
      {
#line 182
      while (1) {
        while_continue: /* CIL Label */ ;
#line 182
        if (! assoc->next) {
#line 182
          goto while_break;
        }
#line 183
        assoc = assoc->next;
#line 184
        if ((unsigned long )assoc->key == (unsigned long )key) {
#line 185
          return (assoc);
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 191
  return ((ptr_assoc *)((void *)0));
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/hashtable.c"
void *find_assoc_value(ptr_assoc **hash_table , void *key ) 
{ 
  ptr_assoc *assoc ;

  {
  {
#line 208
  assoc = find_ptr_assoc(hash_table, key);
  }
#line 209
  if (! assoc) {
#line 210
    return ((void *)0);
  }
#line 211
  return (assoc->value);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/../common/hashtable.c"
void free_ptr_assoc(ptr_assoc **hash_table , void *key ) 
{ 
  ptr_assoc *assoc ;

  {
  {
#line 225
  assoc = find_ptr_assoc(hash_table, key);
  }
#line 226
  if (! assoc) {
#line 227
    return;
  }
#line 229
  if (assoc->array) {
#line 232
    if (assoc->next) {
#line 233
      *(assoc->array) = assoc->next;
#line 234
      (assoc->next)->previous = (struct _ptr_assoc *)((void *)0);
#line 235
      (assoc->next)->array = assoc->array;
    } else {
#line 237
      *(assoc->array) = (struct _ptr_assoc *)((void *)0);
    }
    {
#line 239
    free((void *)assoc);
    }
  } else {
#line 243
    if (assoc->next) {
#line 244
      (assoc->next)->previous = assoc->previous;
    }
    {
#line 245
    (assoc->previous)->next = assoc->next;
#line 246
    free((void *)assoc);
    }
  }
#line 248
  return;
}
}
#line 38 "./include/cfpython_archetype.h"
PyTypeObject Crossfire_ArchetypeType ;
#line 40
PyObject *Crossfire_Archetype_wrap(archetype *what ) ;
#line 13 "./include/cfpython_proto.h"
PyObject *Crossfire_Object_wrap(object *what ) ;
#line 1 "./include/cfpython_archetype_private.h"
static PyObject *Crossfire_Archetype_GetName(Crossfire_Archetype *whoptr , void *closure ) ;
#line 2
static PyObject *Crossfire_Archetype_GetNext(Crossfire_Archetype *who , void *closure ) ;
#line 3
static PyObject *Crossfire_Archetype_GetMore(Crossfire_Archetype *who , void *closure ) ;
#line 4
static PyObject *Crossfire_Archetype_GetHead(Crossfire_Archetype *who , void *closure ) ;
#line 5
static PyObject *Crossfire_Archetype_GetClone(Crossfire_Archetype *who , void *closure ) ;
#line 6
static PyObject *Crossfire_Archetype_GetNewObject(Crossfire_Archetype *who , PyObject *args ) ;
#line 7
static int Crossfire_Archetype_InternalCompare(Crossfire_Archetype *left , Crossfire_Archetype *right ) ;
#line 8
static PyObject *Crossfire_Archetype_RichCompare(Crossfire_Archetype *left , Crossfire_Archetype *right ,
                                                 int op ) ;
#line 10 "./include/cfpython_archetype_private.h"
static PyGetSetDef Archetype_getseters[6]  = {      {(char *)"Name", (PyObject *(*)(PyObject * , void * ))(& Crossfire_Archetype_GetName),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Next", (PyObject *(*)(PyObject * , void * ))(& Crossfire_Archetype_GetNext),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"More", (PyObject *(*)(PyObject * , void * ))(& Crossfire_Archetype_GetMore),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Head", (PyObject *(*)(PyObject * , void * ))(& Crossfire_Archetype_GetHead),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Clone", (PyObject *(*)(PyObject * , void * ))(& Crossfire_Archetype_GetClone),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)((void *)0), (PyObject *(*)(PyObject * , void * ))((void *)0), (int (*)(PyObject * ,
                                                                                      PyObject * ,
                                                                                      void * ))((void *)0),
      (char *)((void *)0), (void *)0}};
#line 19 "./include/cfpython_archetype_private.h"
static PyMethodDef ArchetypeMethods[2]  = {      {"NewObject", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Archetype_GetNewObject),
      4, (char const   *)((void *)0)}, 
        {(char const   *)((void *)0), (PyObject *(*)(PyObject * , PyObject * ))((void *)0),
      0, (char const   *)((void *)0)}};
#line 25 "./include/cfpython_archetype_private.h"
PyTypeObject Crossfire_ArchetypeType  = 
#line 25
     {(Py_ssize_t )1, (struct _typeobject *)((void *)0), (Py_ssize_t )0, "Crossfire.Archetype",
    (Py_ssize_t )sizeof(Crossfire_Archetype ), (Py_ssize_t )0, (void (*)(PyObject * ))((void *)0),
    (int (*)(PyObject * , FILE * , int  ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                      char * ))((void *)0),
    (int (*)(PyObject * , char * , PyObject * ))((void *)0), (int (*)(PyObject * ,
                                                                      PyObject * ))(& Crossfire_Archetype_InternalCompare),
    (PyObject *(*)(PyObject * ))((void *)0), (PyNumberMethods *)((void *)0), (PySequenceMethods *)((void *)0),
    (PyMappingMethods *)((void *)0), & PyObject_HashNotImplemented, (PyObject *(*)(PyObject * ,
                                                                                   PyObject * ,
                                                                                   PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * ))((void *)0), & PyObject_GenericGetAttr, & PyObject_GenericSetAttr,
    (PyBufferProcs *)((void *)0), (((((((1L | (1L << 1)) | (1L << 3)) | (1L << 5)) | (1L << 6)) | (1L << 7)) | (1L << 8)) | (1L << 17)) | (1L << 10),
    "Crossfire archetypes", (int (*)(PyObject * , int (*)(PyObject * , void * ) ,
                                     void * ))((void *)0), (int (*)(PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * , int  ))(& Crossfire_Archetype_RichCompare),
    (Py_ssize_t )0, (PyObject *(*)(PyObject * ))((void *)0), (PyObject *(*)(PyObject * ))((void *)0),
    ArchetypeMethods, (struct PyMemberDef *)((void *)0), Archetype_getseters, (struct _typeobject *)((void *)0),
    (PyObject *)((void *)0), (PyObject *(*)(PyObject * , PyObject * , PyObject * ))((void *)0),
    (int (*)(PyObject * , PyObject * , PyObject * ))((void *)0), (Py_ssize_t )0, (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          PyObject * ))((void *)0),
    (PyObject *(*)(struct _typeobject * , Py_ssize_t  ))((void *)0), (PyObject *(*)(struct _typeobject * ,
                                                                                    PyObject * ,
                                                                                    PyObject * ))((void *)0),
    (void (*)(void * ))((void *)0), (int (*)(PyObject * ))((void *)0), (PyObject *)((void *)0),
    (PyObject *)((void *)0), (PyObject *)((void *)0), (PyObject *)((void *)0), (PyObject *)((void *)0),
    (void (*)(PyObject * ))((void *)0), 0U};
#line 33 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_archetype.c"
static PyObject *Crossfire_Archetype_GetName(Crossfire_Archetype *whoptr , void *closure ) 
{ 
  sstring tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 34
  tmp = cf_archetype_get_name(whoptr->arch);
#line 34
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 34
  return (tmp___0);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_archetype.c"
static PyObject *Crossfire_Archetype_GetNext(Crossfire_Archetype *who , void *closure ) 
{ 
  archetype *tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 38
  tmp = cf_archetype_get_next(who->arch);
#line 38
  tmp___0 = Crossfire_Archetype_wrap(tmp);
  }
#line 38
  return (tmp___0);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_archetype.c"
static PyObject *Crossfire_Archetype_GetMore(Crossfire_Archetype *who , void *closure ) 
{ 
  archetype *tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 42
  tmp = cf_archetype_get_more(who->arch);
#line 42
  tmp___0 = Crossfire_Archetype_wrap(tmp);
  }
#line 42
  return (tmp___0);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_archetype.c"
static PyObject *Crossfire_Archetype_GetHead(Crossfire_Archetype *who , void *closure ) 
{ 
  archetype *tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 46
  tmp = cf_archetype_get_head(who->arch);
#line 46
  tmp___0 = Crossfire_Archetype_wrap(tmp);
  }
#line 46
  return (tmp___0);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_archetype.c"
static PyObject *Crossfire_Archetype_GetClone(Crossfire_Archetype *who , void *closure ) 
{ 
  object *tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 50
  tmp = cf_archetype_get_clone(who->arch);
#line 50
  tmp___0 = Crossfire_Object_wrap(tmp);
  }
#line 50
  return (tmp___0);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_archetype.c"
static PyObject *Crossfire_Archetype_GetNewObject(Crossfire_Archetype *who , PyObject *args ) 
{ 
  sstring tmp ;
  object *tmp___0 ;
  PyObject *tmp___1 ;

  {
  {
#line 54
  tmp = cf_archetype_get_name(who->arch);
#line 54
  tmp___0 = cf_create_object_by_name(tmp);
#line 54
  tmp___1 = Crossfire_Object_wrap(tmp___0);
  }
#line 54
  return (tmp___1);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_archetype.c"
PyObject *Crossfire_Archetype_wrap(archetype *what ) 
{ 
  Crossfire_Archetype *wrapper ;
  void *tmp ;
  PyObject *tmp___0 ;

  {
#line 61
  if ((unsigned long )what == (unsigned long )((void *)0)) {
#line 62
    (_Py_NoneStruct.ob_refcnt) ++;
#line 63
    return (& _Py_NoneStruct);
  }
  {
#line 66
  tmp = PyObject_Malloc((size_t )Crossfire_ArchetypeType.tp_basicsize);
#line 66
  tmp___0 = PyObject_Init((PyObject *)tmp, & Crossfire_ArchetypeType);
#line 66
  wrapper = (Crossfire_Archetype *)tmp___0;
  }
#line 67
  if ((unsigned long )wrapper != (unsigned long )((void *)0)) {
#line 68
    wrapper->arch = what;
  }
#line 69
  return ((PyObject *)wrapper);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_archetype.c"
static int Crossfire_Archetype_InternalCompare(Crossfire_Archetype *left , Crossfire_Archetype *right ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 73
  if ((unsigned long )left->arch < (unsigned long )right->arch) {
#line 73
    tmp___0 = -1;
  } else {
#line 73
    if ((unsigned long )left->arch == (unsigned long )right->arch) {
#line 73
      tmp = 0;
    } else {
#line 73
      tmp = 1;
    }
#line 73
    tmp___0 = tmp;
  }
#line 73
  return (tmp___0);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_archetype.c"
static PyObject *Crossfire_Archetype_RichCompare(Crossfire_Archetype *left , Crossfire_Archetype *right ,
                                                 int op ) 
{ 
  int result ;
  int tmp ;
  int tmp___0 ;
  PyObject *tmp___1 ;

  {
#line 78
  if (! left) {
#line 82
    (_Py_NotImplementedStruct.ob_refcnt) ++;
#line 83
    return (& _Py_NotImplementedStruct);
  } else
#line 78
  if (! right) {
#line 82
    (_Py_NotImplementedStruct.ob_refcnt) ++;
#line 83
    return (& _Py_NotImplementedStruct);
  } else
#line 78
  if ((unsigned long )((PyObject *)left)->ob_type == (unsigned long )(& Crossfire_ArchetypeType)) {
#line 78
    goto _L;
  } else {
    {
#line 78
    tmp = PyType_IsSubtype(((PyObject *)left)->ob_type, & Crossfire_ArchetypeType);
    }
#line 78
    if (tmp) {
      _L: /* CIL Label */ 
#line 78
      if (! ((unsigned long )((PyObject *)right)->ob_type == (unsigned long )(& Crossfire_ArchetypeType))) {
        {
#line 78
        tmp___0 = PyType_IsSubtype(((PyObject *)right)->ob_type, & Crossfire_ArchetypeType);
        }
#line 78
        if (! tmp___0) {
#line 82
          (_Py_NotImplementedStruct.ob_refcnt) ++;
#line 83
          return (& _Py_NotImplementedStruct);
        }
      }
    } else {
#line 82
      (_Py_NotImplementedStruct.ob_refcnt) ++;
#line 83
      return (& _Py_NotImplementedStruct);
    }
  }
  {
#line 85
  result = Crossfire_Archetype_InternalCompare(left, right);
  }
  {
#line 88
  if (op == 2) {
#line 88
    goto case_2;
  }
#line 91
  if (op == 3) {
#line 91
    goto case_3;
  }
#line 94
  if (op == 1) {
#line 94
    goto case_1;
  }
#line 97
  if (op == 5) {
#line 97
    goto case_5;
  }
#line 100
  if (op == 0) {
#line 100
    goto case_0;
  }
#line 103
  if (op == 4) {
#line 103
    goto case_4;
  }
#line 87
  goto switch_break;
  case_2: /* CIL Label */ 
#line 89
  result = result == 0;
#line 90
  goto switch_break;
  case_3: /* CIL Label */ 
#line 92
  result = result != 0;
#line 93
  goto switch_break;
  case_1: /* CIL Label */ 
#line 95
  result = result <= 0;
#line 96
  goto switch_break;
  case_5: /* CIL Label */ 
#line 98
  result = result >= 0;
#line 99
  goto switch_break;
  case_0: /* CIL Label */ 
#line 101
  result = result == -1;
#line 102
  goto switch_break;
  case_4: /* CIL Label */ 
#line 104
  result = result == 1;
#line 105
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 107
  tmp___1 = PyBool_FromLong((long )result);
  }
#line 107
  return (tmp___1);
}
}
#line 20 "/usr/include/python2.7/boolobject.h"
extern PyIntObject _Py_ZeroStruct ;
#line 20
extern PyIntObject _Py_TrueStruct ;
#line 78 "/usr/include/python2.7/pyerrors.h"
extern void PyErr_SetString(PyObject * , char const   * ) ;
#line 79
extern PyObject *PyErr_Occurred(void) ;
#line 140
extern PyObject *PyExc_RuntimeError ;
#line 145
extern PyObject *PyExc_ReferenceError ;
#line 148
extern PyObject *PyExc_TypeError ;
#line 154
extern PyObject *PyExc_ValueError ;
#line 26 "/usr/include/python2.7/modsupport.h"
extern int PyArg_Parse(PyObject * , char const   *  , ...) ;
#line 27
extern int PyArg_ParseTuple(PyObject * , char const   *  , ...) ;
#line 38 "./include/cfpython_object.h"
PyTypeObject Crossfire_ObjectType ;
#line 46
PyTypeObject Crossfire_PlayerType ;
#line 38 "./include/cfpython_map.h"
PyTypeObject Crossfire_MapType ;
#line 54
PyObject *Crossfire_Map_wrap(mapstruct *what ) ;
#line 38 "./include/cfpython_party.h"
PyTypeObject Crossfire_PartyType ;
#line 40
PyObject *Crossfire_Party_wrap(partylist *what ) ;
#line 139 "./include/cfpython.h"
CFPContext *current_context ;
#line 12 "./include/cfpython_proto.h"
void init_object_assoc_table(void) ;
#line 30 "./include/cfpython_object_private.h"
static PyObject *Object_GetName(Crossfire_Object *whoptr , void *closure ) ;
#line 31
static PyObject *Object_GetNamePl(Crossfire_Object *whoptr , void *closure ) ;
#line 32
static PyObject *Object_GetTitle(Crossfire_Object *whoptr , void *closure ) ;
#line 33
static PyObject *Object_GetRace(Crossfire_Object *whoptr , void *closure ) ;
#line 34
static PyObject *Object_GetMap(Crossfire_Object *whoptr , void *closure ) ;
#line 35
static PyObject *Object_GetCha(Crossfire_Object *whoptr , void *closure ) ;
#line 36
static PyObject *Object_GetCon(Crossfire_Object *whoptr , void *closure ) ;
#line 37
static PyObject *Object_GetDex(Crossfire_Object *whoptr , void *closure ) ;
#line 38
static PyObject *Object_GetInt(Crossfire_Object *whoptr , void *closure ) ;
#line 39
static PyObject *Object_GetPow(Crossfire_Object *whoptr , void *closure ) ;
#line 40
static PyObject *Object_GetStr(Crossfire_Object *whoptr , void *closure ) ;
#line 41
static PyObject *Object_GetWis(Crossfire_Object *whoptr , void *closure ) ;
#line 42
static PyObject *Object_GetHP(Crossfire_Object *whoptr , void *closure ) ;
#line 43
static PyObject *Object_GetMaxHP(Crossfire_Object *whoptr , void *closure ) ;
#line 44
static PyObject *Object_GetSP(Crossfire_Object *whoptr , void *closure ) ;
#line 45
static PyObject *Object_GetMaxSP(Crossfire_Object *whoptr , void *closure ) ;
#line 46
static PyObject *Object_GetGrace(Crossfire_Object *whoptr , void *closure ) ;
#line 47
static PyObject *Object_GetMaxGrace(Crossfire_Object *whoptr , void *closure ) ;
#line 48
static PyObject *Object_GetFood(Crossfire_Object *whoptr , void *closure ) ;
#line 49
static PyObject *Object_GetAC(Crossfire_Object *whoptr , void *closure ) ;
#line 50
static PyObject *Object_GetWC(Crossfire_Object *whoptr , void *closure ) ;
#line 51
static PyObject *Object_GetDam(Crossfire_Object *whoptr , void *closure ) ;
#line 52
static PyObject *Object_GetLuck(Crossfire_Object *whoptr , void *closure ) ;
#line 53
static PyObject *Object_GetMessage(Crossfire_Object *whoptr , void *closure ) ;
#line 54
static PyObject *Object_GetSkill(Crossfire_Object *whoptr , void *closure ) ;
#line 55
static PyObject *Object_GetExp(Crossfire_Object *whoptr , void *closure ) ;
#line 56
static PyObject *Object_GetPermExp(Crossfire_Object *whoptr , void *closure ) ;
#line 57
static PyObject *Object_GetExpMul(Crossfire_Object *whoptr , void *closure ) ;
#line 58
static PyObject *Object_GetSlaying(Crossfire_Object *whoptr , void *closure ) ;
#line 59
static PyObject *Object_GetCursed(Crossfire_Object *whoptr , void *closure ) ;
#line 60
static PyObject *Object_GetDamned(Crossfire_Object *whoptr , void *closure ) ;
#line 61
static PyObject *Object_GetWeight(Crossfire_Object *whoptr , void *closure ) ;
#line 62
static PyObject *Object_GetWeightLimit(Crossfire_Object *whoptr , void *closure ) ;
#line 63
static PyObject *Object_GetAbove(Crossfire_Object *whoptr , void *closure ) ;
#line 64
static PyObject *Object_GetBelow(Crossfire_Object *whoptr , void *closure ) ;
#line 65
static PyObject *Object_GetInventory(Crossfire_Object *whoptr , void *closure ) ;
#line 66
static PyObject *Object_GetX(Crossfire_Object *whoptr , void *closure ) ;
#line 67
static PyObject *Object_GetY(Crossfire_Object *whoptr , void *closure ) ;
#line 68
static PyObject *Object_GetDirection(Crossfire_Object *whoptr , void *closure ) ;
#line 69
static PyObject *Object_GetFacing(Crossfire_Object *whoptr , void *closure ) ;
#line 70
static PyObject *Object_GetUnaggressive(Crossfire_Object *whoptr , void *closure ) ;
#line 71
static PyObject *Object_GetGod(Crossfire_Object *whoptr , void *closure ) ;
#line 72
static PyObject *Object_GetPickable(Crossfire_Object *whoptr , void *closure ) ;
#line 73
static PyObject *Object_GetQuantity(Crossfire_Object *whoptr , void *closure ) ;
#line 74
static PyObject *Object_GetInvisible(Crossfire_Object *whoptr , void *closure ) ;
#line 75
static PyObject *Object_GetSpeed(Crossfire_Object *whoptr , void *closure ) ;
#line 76
static PyObject *Object_GetSpeedLeft(Crossfire_Object *whoptr , void *closure ) ;
#line 77
static PyObject *Object_GetLastSP(Crossfire_Object *whoptr , void *closure ) ;
#line 78
static PyObject *Object_GetLastGrace(Crossfire_Object *whoptr , void *closure ) ;
#line 79
static PyObject *Object_GetLastEat(Crossfire_Object *whoptr , void *closure ) ;
#line 80
static PyObject *Object_GetLevel(Crossfire_Object *whoptr , void *closure ) ;
#line 81
static PyObject *Object_GetFace(Crossfire_Object *whoptr , void *closure ) ;
#line 82
static PyObject *Object_GetAnim(Crossfire_Object *whoptr , void *closure ) ;
#line 83
static PyObject *Object_GetAnimSpeed(Crossfire_Object *whoptr , void *closure ) ;
#line 84
static PyObject *Object_GetAttackType(Crossfire_Object *whoptr , void *closure ) ;
#line 85
static PyObject *Object_GetBeenApplied(Crossfire_Object *whoptr , void *closure ) ;
#line 86
static PyObject *Object_GetIdentified(Crossfire_Object *whoptr , void *closure ) ;
#line 87
static PyObject *Object_GetAlive(Crossfire_Object *whoptr , void *closure ) ;
#line 88
static PyObject *Object_GetDM(Crossfire_Object *whoptr , void *closure ) ;
#line 89
static PyObject *Object_GetWasDM(Crossfire_Object *whoptr , void *closure ) ;
#line 90
static PyObject *Object_GetApplied(Crossfire_Object *whoptr , void *closure ) ;
#line 91
static PyObject *Object_GetUnpaid(Crossfire_Object *whoptr , void *closure ) ;
#line 92
static PyObject *Object_GetMonster(Crossfire_Object *whoptr , void *closure ) ;
#line 93
static PyObject *Object_GetFriendly(Crossfire_Object *whoptr , void *closure ) ;
#line 94
static PyObject *Object_GetGenerator(Crossfire_Object *whoptr , void *closure ) ;
#line 95
static PyObject *Object_GetThrown(Crossfire_Object *whoptr , void *closure ) ;
#line 96
static PyObject *Object_GetCanSeeInvisible(Crossfire_Object *whoptr , void *closure ) ;
#line 97
static PyObject *Object_GetRollable(Crossfire_Object *whoptr , void *closure ) ;
#line 98
static PyObject *Object_GetTurnable(Crossfire_Object *whoptr , void *closure ) ;
#line 99
static PyObject *Object_GetUsedUp(Crossfire_Object *whoptr , void *closure ) ;
#line 100
static PyObject *Object_GetSplitting(Crossfire_Object *whoptr , void *closure ) ;
#line 101
static PyObject *Object_GetBlind(Crossfire_Object *whoptr , void *closure ) ;
#line 102
static PyObject *Object_GetCanUseSkill(Crossfire_Object *whoptr , void *closure ) ;
#line 103
static PyObject *Object_GetKnownCursed(Crossfire_Object *whoptr , void *closure ) ;
#line 104
static PyObject *Object_GetStealthy(Crossfire_Object *whoptr , void *closure ) ;
#line 105
static PyObject *Object_GetConfused(Crossfire_Object *whoptr , void *closure ) ;
#line 106
static PyObject *Object_GetSleeping(Crossfire_Object *whoptr , void *closure ) ;
#line 107
static PyObject *Object_GetLifesaver(Crossfire_Object *whoptr , void *closure ) ;
#line 108
static PyObject *Object_GetFloor(Crossfire_Object *whoptr , void *closure ) ;
#line 109
static PyObject *Object_GetHasXRays(Crossfire_Object *whoptr , void *closure ) ;
#line 110
static PyObject *Object_GetCanUseRing(Crossfire_Object *whoptr , void *closure ) ;
#line 111
static PyObject *Object_GetCanUseBow(Crossfire_Object *whoptr , void *closure ) ;
#line 112
static PyObject *Object_GetCanUseWand(Crossfire_Object *whoptr , void *closure ) ;
#line 113
static PyObject *Object_GetCanSeeInDark(Crossfire_Object *whoptr , void *closure ) ;
#line 114
static PyObject *Object_GetKnownMagical(Crossfire_Object *whoptr , void *closure ) ;
#line 115
static PyObject *Object_GetCanUseWeapon(Crossfire_Object *whoptr , void *closure ) ;
#line 116
static PyObject *Object_GetCanUseArmour(Crossfire_Object *whoptr , void *closure ) ;
#line 117
static PyObject *Object_GetCanUseScroll(Crossfire_Object *whoptr , void *closure ) ;
#line 118
static PyObject *Object_GetCanCastSpell(Crossfire_Object *whoptr , void *closure ) ;
#line 119
static PyObject *Object_GetReflectSpells(Crossfire_Object *whoptr , void *closure ) ;
#line 120
static PyObject *Object_GetReflectMissiles(Crossfire_Object *whoptr , void *closure ) ;
#line 121
static PyObject *Object_GetUnique(Crossfire_Object *whoptr , void *closure ) ;
#line 122
static PyObject *Object_GetRunAway(Crossfire_Object *whoptr , void *closure ) ;
#line 123
static PyObject *Object_GetScared(Crossfire_Object *whoptr , void *closure ) ;
#line 124
static PyObject *Object_GetUndead(Crossfire_Object *whoptr , void *closure ) ;
#line 125
static PyObject *Object_GetBlocksView(Crossfire_Object *whoptr , void *closure ) ;
#line 126
static PyObject *Object_GetHitBack(Crossfire_Object *whoptr , void *closure ) ;
#line 127
static PyObject *Object_GetStandStill(Crossfire_Object *whoptr , void *closure ) ;
#line 128
static PyObject *Object_GetOnlyAttack(Crossfire_Object *whoptr , void *closure ) ;
#line 129
static PyObject *Object_GetMakeInvisible(Crossfire_Object *whoptr , void *closure ) ;
#line 130
static PyObject *Object_GetMoney(Crossfire_Object *whoptr , void *closure ) ;
#line 131
static PyObject *Object_GetType(Crossfire_Object *whoptr , void *closure ) ;
#line 132
static PyObject *Object_GetSubtype(Crossfire_Object *whoptr , void *closure ) ;
#line 133
static PyObject *Object_GetValue(Crossfire_Object *whoptr , void *closure ) ;
#line 134
static PyObject *Object_GetArchName(Crossfire_Object *whoptr , void *closure ) ;
#line 135
static PyObject *Object_GetArchetype(Crossfire_Object *whoptr , void *closure ) ;
#line 136
static PyObject *Object_GetNoSave(Crossfire_Object *whoptr , void *closure ) ;
#line 137
static PyObject *Object_GetExists(Crossfire_Object *whoptr , void *closure ) ;
#line 138
static PyObject *Object_GetEnv(Crossfire_Object *whoptr , void *closure ) ;
#line 139
static PyObject *Object_GetMoveType(Crossfire_Object *whoptr , void *closure ) ;
#line 140
static PyObject *Object_GetMoveBlock(Crossfire_Object *whoptr , void *closure ) ;
#line 141
static PyObject *Object_GetMoveAllow(Crossfire_Object *whoptr , void *closure ) ;
#line 142
static PyObject *Object_GetMoveOn(Crossfire_Object *whoptr , void *closure ) ;
#line 143
static PyObject *Object_GetMoveOff(Crossfire_Object *whoptr , void *closure ) ;
#line 144
static PyObject *Object_GetMoveSlow(Crossfire_Object *whoptr , void *closure ) ;
#line 145
static PyObject *Object_GetMoveSlowPenalty(Crossfire_Object *whoptr , void *closure ) ;
#line 146
static PyObject *Object_GetOwner(Crossfire_Object *whoptr , void *closure ) ;
#line 147
static PyObject *Object_GetEnemy(Crossfire_Object *whoptr , void *closure ) ;
#line 148
static PyObject *Object_GetCount(Crossfire_Object *whoptr , void *closure ) ;
#line 149
static PyObject *Object_GetGodGiven(Crossfire_Object *whoptr , void *closure ) ;
#line 150
static PyObject *Object_GetIsPet(Crossfire_Object *whoptr , void *closure ) ;
#line 151
static PyObject *Object_GetAttackMovement(Crossfire_Object *whoptr , void *closure ) ;
#line 152
static PyObject *Object_GetDuration(Crossfire_Object *whoptr , void *closure ) ;
#line 153
static PyObject *Object_GetGlowRadius(Crossfire_Object *whoptr , void *closure ) ;
#line 154
static PyObject *Object_GetAnimated(Crossfire_Object *whoptr , void *closure ) ;
#line 155
static PyObject *Object_GetNoDamage(Crossfire_Object *whoptr , void *closure ) ;
#line 156
static PyObject *Object_GetRandomMovement(Crossfire_Object *whoptr , void *closure ) ;
#line 158
static int Object_SetMessage(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 159
static int Object_SetExp(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 160
static int Object_SetName(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 161
static int Object_SetNamePl(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 162
static int Object_SetTitle(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 163
static int Object_SetRace(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 164
static int Object_SetMap(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 165
static int Object_SetSlaying(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 166
static int Object_SetSkill(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 167
static int Object_SetCursed(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 168
static int Object_SetDamned(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 169
static int Object_SetApplied(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 170
static int Object_SetStr(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 171
static int Object_SetDex(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 172
static int Object_SetCon(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 173
static int Object_SetInt(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 174
static int Object_SetPow(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 175
static int Object_SetWis(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 176
static int Object_SetCha(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 177
static int Object_SetHP(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 178
static int Object_SetMaxHP(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 179
static int Object_SetSP(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 180
static int Object_SetMaxSP(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 181
static int Object_SetGrace(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 182
static int Object_SetMaxGrace(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 183
static int Object_SetDam(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 184
static int Object_SetFood(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 185
static int Object_SetAC(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 186
static int Object_SetWC(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 187
static int Object_SetWeight(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 188
static int Object_SetWeightLimit(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 189
static int Object_SetDirection(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 190
static int Object_SetFacing(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 191
static int Object_SetGod(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 192
static int Object_SetSpeed(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 193
static int Object_SetSpeedLeft(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 194
static int Object_SetQuantity(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 195
static int Object_SetLastSP(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 196
static int Object_SetLastGrace(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 197
static int Object_SetLastEat(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 198
static int Object_SetAttackType(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 199
static int Object_SetIdentified(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 200
static int Object_SetUnaggressive(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 201
static int Object_SetPickable(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 202
static int Object_SetInvisible(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 203
static int Object_SetUnpaid(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 204
static int Object_SetFriendly(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 205
static int Object_SetCanSeeInvisible(Crossfire_Object *whoptr , PyObject *value ,
                                     void *closure ) ;
#line 206
static int Object_SetRollable(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 207
static int Object_SetTurnable(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 208
static int Object_SetUsedUp(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 209
static int Object_SetBlind(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 210
static int Object_SetKnownCursed(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 211
static int Object_SetStealthy(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 212
static int Object_SetConfused(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 213
static int Object_SetSleeping(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 214
static int Object_SetLifesaver(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 215
static int Object_SetHasXRays(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 216
static int Object_SetCanSeeInDark(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 217
static int Object_SetKnownMagical(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 218
static int Object_SetReflectSpells(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 219
static int Object_SetReflectMissiles(Crossfire_Object *whoptr , PyObject *value ,
                                     void *closure ) ;
#line 220
static int Object_SetUnique(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 221
static int Object_SetRunAway(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 222
static int Object_SetScared(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 223
static int Object_SetUndead(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 224
static int Object_SetBlocksView(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 225
static int Object_SetHitBack(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 226
static int Object_SetStandStill(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 227
static int Object_SetOnlyAttack(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 228
static int Object_SetMakeInvisible(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 229
static int Object_SetValue(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 230
static int Object_SetFace(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 231
static int Object_SetAnim(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 232
static int Object_SetAnimSpeed(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 233
static int Object_SetNoSave(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 234
static int Object_SetOwner(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 235
static int Object_SetEnemy(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 236
static int Object_SetGodGiven(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 237
static int Object_SetIsPet(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 238
static int Object_SetAttackMovement(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 239
static int Object_SetDuration(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 240
static int Object_SetGlowRadius(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 241
static int Object_SetAnimated(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 242
static int Object_SetNoDamage(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 243
static int Object_SetRandomMovement(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 245
static PyObject *Crossfire_Object_Remove(Crossfire_Object *who , PyObject *args ) ;
#line 246
static PyObject *Crossfire_Object_Apply(Crossfire_Object *who , PyObject *args ) ;
#line 247
static PyObject *Crossfire_Object_Drop(Crossfire_Object *who , PyObject *args ) ;
#line 248
static PyObject *Crossfire_Object_Clone(Crossfire_Object *who , PyObject *args ) ;
#line 249
static PyObject *Crossfire_Object_Split(Crossfire_Object *who , PyObject *args ) ;
#line 250
static PyObject *Crossfire_Object_Fix(Crossfire_Object *who , PyObject *args ) ;
#line 251
static PyObject *Crossfire_Object_Say(Crossfire_Object *who , PyObject *args ) ;
#line 252
static PyObject *Crossfire_Object_Take(Crossfire_Object *who , PyObject *args ) ;
#line 253
static PyObject *Crossfire_Object_Teleport(Crossfire_Object *who , PyObject *args ) ;
#line 254
static PyObject *Crossfire_Object_Reposition(Crossfire_Object *who , PyObject *args ) ;
#line 256
static PyObject *Crossfire_Object_QueryName(Crossfire_Object *who , PyObject *args ) ;
#line 257
static PyObject *Crossfire_Object_GetResist(Crossfire_Object *who , PyObject *args ) ;
#line 258
static PyObject *Crossfire_Object_SetResist(Crossfire_Object *who , PyObject *args ) ;
#line 259
static PyObject *Crossfire_Object_ActivateRune(Crossfire_Object *who , PyObject *args ) ;
#line 260
static PyObject *Crossfire_Object_CheckTrigger(Crossfire_Object *who , PyObject *args ) ;
#line 261
static PyObject *Crossfire_Object_QueryCost(Crossfire_Object *who , PyObject *args ) ;
#line 262
static PyObject *Crossfire_Object_Cast(Crossfire_Object *who , PyObject *args ) ;
#line 263
static PyObject *Crossfire_Object_LearnSpell(Crossfire_Object *who , PyObject *args ) ;
#line 264
static PyObject *Crossfire_Object_ForgetSpell(Crossfire_Object *who , PyObject *args ) ;
#line 265
static PyObject *Crossfire_Object_KnowSpell(Crossfire_Object *who , PyObject *args ) ;
#line 266
static PyObject *Crossfire_Object_CastAbility(Crossfire_Object *who , PyObject *args ) ;
#line 267
static PyObject *Crossfire_Object_PayAmount(Crossfire_Object *who , PyObject *args ) ;
#line 268
static PyObject *Crossfire_Object_Pay(Crossfire_Object *who , PyObject *args ) ;
#line 269
static PyObject *Crossfire_Object_CheckInventory(Crossfire_Object *who , PyObject *args ) ;
#line 270
static PyObject *Crossfire_Object_CheckArchInventory(Crossfire_Object *who , PyObject *args ) ;
#line 271
static PyObject *Crossfire_Object_GetOutOfMap(Crossfire_Object *who , PyObject *args ) ;
#line 272
static PyObject *Crossfire_Object_CreateInside(Crossfire_Object *who , PyObject *args ) ;
#line 273
static PyObject *Crossfire_Object_InsertInto(Crossfire_Object *who , PyObject *args ) ;
#line 274
static PyObject *Crossfire_Object_ReadKey(Crossfire_Object *who , PyObject *args ) ;
#line 275
static PyObject *Crossfire_Object_WriteKey(Crossfire_Object *who , PyObject *args ) ;
#line 276
static PyObject *Crossfire_Object_CreateTimer(Crossfire_Object *who , PyObject *args ) ;
#line 277
static PyObject *Crossfire_Object_AddExp(Crossfire_Object *who , PyObject *args ) ;
#line 278
static PyObject *Crossfire_Object_Move(Crossfire_Object *who , PyObject *args ) ;
#line 279
static PyObject *Crossfire_Object_ChangeAbil(Crossfire_Object *who , PyObject *args ) ;
#line 280
static PyObject *Crossfire_Object_Event(Crossfire_Object *who , PyObject *args ) ;
#line 281
static PyObject *Crossfire_Object_RemoveDepletion(Crossfire_Object *who , PyObject *args ) ;
#line 282
static PyObject *Crossfire_Object_Arrest(Crossfire_Object *who , PyObject *args ) ;
#line 283
static PyObject *Object_GetMaterial(Crossfire_Object *whoptr , void *closure ) ;
#line 285
static int Crossfire_Object_InternalCompare(Crossfire_Object *left , Crossfire_Object *right ) ;
#line 286
static PyObject *Crossfire_Object_RichCompare(Crossfire_Object *left , Crossfire_Object *right ,
                                              int op ) ;
#line 288
static PyObject *Crossfire_Object_Long(PyObject *obj ) ;
#line 290
static PyObject *Crossfire_Object_Int(PyObject *obj ) ;
#line 292
static PyObject *Crossfire_Object_new(PyTypeObject *type , PyObject *args , PyObject *kwds ) ;
#line 295 "./include/cfpython_object_private.h"
static PyGetSetDef Object_getseters[129]  = 
#line 295
  {      {(char *)"Name", (PyObject *(*)(PyObject * , void * ))(& Object_GetName), (int (*)(PyObject * ,
                                                                                        PyObject * ,
                                                                                        void * ))(& Object_SetName),
      (char *)((void *)0), (void *)0}, 
        {(char *)"NamePl", (PyObject *(*)(PyObject * , void * ))(& Object_GetNamePl),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetNamePl), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Title", (PyObject *(*)(PyObject * , void * ))(& Object_GetTitle), (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          void * ))(& Object_SetTitle),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Race", (PyObject *(*)(PyObject * , void * ))(& Object_GetRace), (int (*)(PyObject * ,
                                                                                        PyObject * ,
                                                                                        void * ))(& Object_SetRace),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Skill", (PyObject *(*)(PyObject * , void * ))(& Object_GetSkill), (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          void * ))(& Object_SetSkill),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Map", (PyObject *(*)(PyObject * , void * ))(& Object_GetMap), (int (*)(PyObject * ,
                                                                                      PyObject * ,
                                                                                      void * ))(& Object_SetMap),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Cha", (PyObject *(*)(PyObject * , void * ))(& Object_GetCha), (int (*)(PyObject * ,
                                                                                      PyObject * ,
                                                                                      void * ))(& Object_SetCha),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Con", (PyObject *(*)(PyObject * , void * ))(& Object_GetCon), (int (*)(PyObject * ,
                                                                                      PyObject * ,
                                                                                      void * ))(& Object_SetCon),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Dex", (PyObject *(*)(PyObject * , void * ))(& Object_GetDex), (int (*)(PyObject * ,
                                                                                      PyObject * ,
                                                                                      void * ))(& Object_SetDex),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Int", (PyObject *(*)(PyObject * , void * ))(& Object_GetInt), (int (*)(PyObject * ,
                                                                                      PyObject * ,
                                                                                      void * ))(& Object_SetInt),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Pow", (PyObject *(*)(PyObject * , void * ))(& Object_GetPow), (int (*)(PyObject * ,
                                                                                      PyObject * ,
                                                                                      void * ))(& Object_SetPow),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Str", (PyObject *(*)(PyObject * , void * ))(& Object_GetStr), (int (*)(PyObject * ,
                                                                                      PyObject * ,
                                                                                      void * ))(& Object_SetStr),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Wis", (PyObject *(*)(PyObject * , void * ))(& Object_GetWis), (int (*)(PyObject * ,
                                                                                      PyObject * ,
                                                                                      void * ))(& Object_SetWis),
      (char *)((void *)0), (void *)0}, 
        {(char *)"HP", (PyObject *(*)(PyObject * , void * ))(& Object_GetHP), (int (*)(PyObject * ,
                                                                                    PyObject * ,
                                                                                    void * ))(& Object_SetHP),
      (char *)((void *)0), (void *)0}, 
        {(char *)"MaxHP", (PyObject *(*)(PyObject * , void * ))(& Object_GetMaxHP), (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          void * ))(& Object_SetMaxHP),
      (char *)((void *)0), (void *)0}, 
        {(char *)"SP", (PyObject *(*)(PyObject * , void * ))(& Object_GetSP), (int (*)(PyObject * ,
                                                                                    PyObject * ,
                                                                                    void * ))(& Object_SetSP),
      (char *)((void *)0), (void *)0}, 
        {(char *)"MaxSP", (PyObject *(*)(PyObject * , void * ))(& Object_GetMaxSP), (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          void * ))(& Object_SetMaxSP),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Grace", (PyObject *(*)(PyObject * , void * ))(& Object_GetGrace), (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          void * ))(& Object_SetGrace),
      (char *)((void *)0), (void *)0}, 
        {(char *)"MaxGrace", (PyObject *(*)(PyObject * , void * ))(& Object_GetMaxGrace),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetMaxGrace), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Food", (PyObject *(*)(PyObject * , void * ))(& Object_GetFood), (int (*)(PyObject * ,
                                                                                        PyObject * ,
                                                                                        void * ))(& Object_SetFood),
      (char *)((void *)0), (void *)0}, 
        {(char *)"AC", (PyObject *(*)(PyObject * , void * ))(& Object_GetAC), (int (*)(PyObject * ,
                                                                                    PyObject * ,
                                                                                    void * ))(& Object_SetAC),
      (char *)((void *)0), (void *)0}, 
        {(char *)"WC", (PyObject *(*)(PyObject * , void * ))(& Object_GetWC), (int (*)(PyObject * ,
                                                                                    PyObject * ,
                                                                                    void * ))(& Object_SetWC),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Dam", (PyObject *(*)(PyObject * , void * ))(& Object_GetDam), (int (*)(PyObject * ,
                                                                                      PyObject * ,
                                                                                      void * ))(& Object_SetDam),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Luck", (PyObject *(*)(PyObject * , void * ))(& Object_GetLuck), (int (*)(PyObject * ,
                                                                                        PyObject * ,
                                                                                        void * ))((void *)0),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Exp", (PyObject *(*)(PyObject * , void * ))(& Object_GetExp), (int (*)(PyObject * ,
                                                                                      PyObject * ,
                                                                                      void * ))(& Object_SetExp),
      (char *)((void *)0), (void *)0}, 
        {(char *)"ExpMul", (PyObject *(*)(PyObject * , void * ))(& Object_GetExpMul),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"PermExp", (PyObject *(*)(PyObject * , void * ))(& Object_GetPermExp),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Message", (PyObject *(*)(PyObject * , void * ))(& Object_GetMessage),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetMessage), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Slaying", (PyObject *(*)(PyObject * , void * ))(& Object_GetSlaying),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetSlaying), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Cursed", (PyObject *(*)(PyObject * , void * ))(& Object_GetCursed),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetCursed), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Damned", (PyObject *(*)(PyObject * , void * ))(& Object_GetDamned),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetDamned), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Weight", (PyObject *(*)(PyObject * , void * ))(& Object_GetWeight),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetWeight), (char *)((void *)0),
      (void *)0}, 
        {(char *)"WeightLimit", (PyObject *(*)(PyObject * , void * ))(& Object_GetWeightLimit),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetWeightLimit), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Above", (PyObject *(*)(PyObject * , void * ))(& Object_GetAbove), (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          void * ))((void *)0),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Below", (PyObject *(*)(PyObject * , void * ))(& Object_GetBelow), (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          void * ))((void *)0),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Inventory", (PyObject *(*)(PyObject * , void * ))(& Object_GetInventory),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"X", (PyObject *(*)(PyObject * , void * ))(& Object_GetX), (int (*)(PyObject * ,
                                                                                  PyObject * ,
                                                                                  void * ))((void *)0),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Y", (PyObject *(*)(PyObject * , void * ))(& Object_GetY), (int (*)(PyObject * ,
                                                                                  PyObject * ,
                                                                                  void * ))((void *)0),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Direction", (PyObject *(*)(PyObject * , void * ))(& Object_GetDirection),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetDirection), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Facing", (PyObject *(*)(PyObject * , void * ))(& Object_GetFacing),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetFacing), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Unaggressive", (PyObject *(*)(PyObject * , void * ))(& Object_GetUnaggressive),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetUnaggressive), (char *)((void *)0),
      (void *)0}, 
        {(char *)"God", (PyObject *(*)(PyObject * , void * ))(& Object_GetGod), (int (*)(PyObject * ,
                                                                                      PyObject * ,
                                                                                      void * ))(& Object_SetGod),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Pickable", (PyObject *(*)(PyObject * , void * ))(& Object_GetPickable),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetPickable), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Quantity", (PyObject *(*)(PyObject * , void * ))(& Object_GetQuantity),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetQuantity), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Invisible", (PyObject *(*)(PyObject * , void * ))(& Object_GetInvisible),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetInvisible), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Speed", (PyObject *(*)(PyObject * , void * ))(& Object_GetSpeed), (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          void * ))(& Object_SetSpeed),
      (char *)((void *)0), (void *)0}, 
        {(char *)"SpeedLeft", (PyObject *(*)(PyObject * , void * ))(& Object_GetSpeedLeft),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetSpeedLeft), (char *)((void *)0),
      (void *)0}, 
        {(char *)"LastSP", (PyObject *(*)(PyObject * , void * ))(& Object_GetLastSP),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetLastSP), (char *)((void *)0),
      (void *)0}, 
        {(char *)"LastGrace", (PyObject *(*)(PyObject * , void * ))(& Object_GetLastGrace),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetLastGrace), (char *)((void *)0),
      (void *)0}, 
        {(char *)"LastEat", (PyObject *(*)(PyObject * , void * ))(& Object_GetLastEat),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetLastEat), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Level", (PyObject *(*)(PyObject * , void * ))(& Object_GetLevel), (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          void * ))((void *)0),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Face", (PyObject *(*)(PyObject * , void * ))(& Object_GetFace), (int (*)(PyObject * ,
                                                                                        PyObject * ,
                                                                                        void * ))(& Object_SetFace),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Anim", (PyObject *(*)(PyObject * , void * ))(& Object_GetAnim), (int (*)(PyObject * ,
                                                                                        PyObject * ,
                                                                                        void * ))(& Object_SetAnim),
      (char *)((void *)0), (void *)0}, 
        {(char *)"AnimSpeed", (PyObject *(*)(PyObject * , void * ))(& Object_GetAnimSpeed),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetAnimSpeed), (char *)((void *)0),
      (void *)0}, 
        {(char *)"AttackType", (PyObject *(*)(PyObject * , void * ))(& Object_GetAttackType),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetAttackType), (char *)((void *)0),
      (void *)0}, 
        {(char *)"BeenApplied", (PyObject *(*)(PyObject * , void * ))(& Object_GetBeenApplied),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Identified", (PyObject *(*)(PyObject * , void * ))(& Object_GetIdentified),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetIdentified), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Alive", (PyObject *(*)(PyObject * , void * ))(& Object_GetAlive), (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          void * ))((void *)0),
      (char *)((void *)0), (void *)0}, 
        {(char *)"DungeonMaster", (PyObject *(*)(PyObject * , void * ))(& Object_GetDM),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"WasDungeonMaster", (PyObject *(*)(PyObject * , void * ))(& Object_GetWasDM),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Applied", (PyObject *(*)(PyObject * , void * ))(& Object_GetApplied),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetApplied), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Unpaid", (PyObject *(*)(PyObject * , void * ))(& Object_GetUnpaid),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetUnpaid), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Monster", (PyObject *(*)(PyObject * , void * ))(& Object_GetMonster),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Friendly", (PyObject *(*)(PyObject * , void * ))(& Object_GetFriendly),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetFriendly), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Generator", (PyObject *(*)(PyObject * , void * ))(& Object_GetGenerator),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Thrown", (PyObject *(*)(PyObject * , void * ))(& Object_GetThrown),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"CanSeeInvisible", (PyObject *(*)(PyObject * , void * ))(& Object_GetCanSeeInvisible),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetCanSeeInvisible), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Rollable", (PyObject *(*)(PyObject * , void * ))(& Object_GetRollable),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetRollable), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Turnable", (PyObject *(*)(PyObject * , void * ))(& Object_GetTurnable),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetTurnable), (char *)((void *)0),
      (void *)0}, 
        {(char *)"UsedUp", (PyObject *(*)(PyObject * , void * ))(& Object_GetUsedUp),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetUsedUp), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Splitting", (PyObject *(*)(PyObject * , void * ))(& Object_GetSplitting),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Blind", (PyObject *(*)(PyObject * , void * ))(& Object_GetBlind), (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          void * ))(& Object_SetBlind),
      (char *)((void *)0), (void *)0}, 
        {(char *)"CanUseSkill", (PyObject *(*)(PyObject * , void * ))(& Object_GetCanUseSkill),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"KnownCursed", (PyObject *(*)(PyObject * , void * ))(& Object_GetKnownCursed),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetKnownCursed), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Stealthy", (PyObject *(*)(PyObject * , void * ))(& Object_GetStealthy),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetStealthy), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Confused", (PyObject *(*)(PyObject * , void * ))(& Object_GetConfused),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetConfused), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Sleeping", (PyObject *(*)(PyObject * , void * ))(& Object_GetSleeping),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetSleeping), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Lifesaver", (PyObject *(*)(PyObject * , void * ))(& Object_GetLifesaver),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetLifesaver), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Floor", (PyObject *(*)(PyObject * , void * ))(& Object_GetFloor), (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          void * ))((void *)0),
      (char *)((void *)0), (void *)0}, 
        {(char *)"HasXRays", (PyObject *(*)(PyObject * , void * ))(& Object_GetHasXRays),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetHasXRays), (char *)((void *)0),
      (void *)0}, 
        {(char *)"CanUseRing", (PyObject *(*)(PyObject * , void * ))(& Object_GetCanUseRing),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"CanUseBow", (PyObject *(*)(PyObject * , void * ))(& Object_GetCanUseBow),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"CanUseWand", (PyObject *(*)(PyObject * , void * ))(& Object_GetCanUseWand),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"CanSeeInDark", (PyObject *(*)(PyObject * , void * ))(& Object_GetCanSeeInDark),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetCanSeeInDark), (char *)((void *)0),
      (void *)0}, 
        {(char *)"KnownMagical", (PyObject *(*)(PyObject * , void * ))(& Object_GetKnownMagical),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetKnownMagical), (char *)((void *)0),
      (void *)0}, 
        {(char *)"CanUseWeapon", (PyObject *(*)(PyObject * , void * ))(& Object_GetCanUseWeapon),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"CanUseArmour", (PyObject *(*)(PyObject * , void * ))(& Object_GetCanUseArmour),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"CanUseScroll", (PyObject *(*)(PyObject * , void * ))(& Object_GetCanUseScroll),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"CanCastSpell", (PyObject *(*)(PyObject * , void * ))(& Object_GetCanCastSpell),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"ReflectSpells", (PyObject *(*)(PyObject * , void * ))(& Object_GetReflectSpells),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetReflectSpells), (char *)((void *)0),
      (void *)0}, 
        {(char *)"ReflectMissiles", (PyObject *(*)(PyObject * , void * ))(& Object_GetReflectMissiles),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetReflectMissiles), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Unique", (PyObject *(*)(PyObject * , void * ))(& Object_GetUnique),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetUnique), (char *)((void *)0),
      (void *)0}, 
        {(char *)"RunAway", (PyObject *(*)(PyObject * , void * ))(& Object_GetRunAway),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetRunAway), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Scared", (PyObject *(*)(PyObject * , void * ))(& Object_GetScared),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetScared), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Undead", (PyObject *(*)(PyObject * , void * ))(& Object_GetUndead),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetUndead), (char *)((void *)0),
      (void *)0}, 
        {(char *)"BlocksView", (PyObject *(*)(PyObject * , void * ))(& Object_GetBlocksView),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetBlocksView), (char *)((void *)0),
      (void *)0}, 
        {(char *)"HitBack", (PyObject *(*)(PyObject * , void * ))(& Object_GetHitBack),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetHitBack), (char *)((void *)0),
      (void *)0}, 
        {(char *)"StandStill", (PyObject *(*)(PyObject * , void * ))(& Object_GetStandStill),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetStandStill), (char *)((void *)0),
      (void *)0}, 
        {(char *)"OnlyAttack", (PyObject *(*)(PyObject * , void * ))(& Object_GetOnlyAttack),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetOnlyAttack), (char *)((void *)0),
      (void *)0}, 
        {(char *)"MakeInvisible", (PyObject *(*)(PyObject * , void * ))(& Object_GetMakeInvisible),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetMakeInvisible), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Money", (PyObject *(*)(PyObject * , void * ))(& Object_GetMoney), (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          void * ))((void *)0),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Type", (PyObject *(*)(PyObject * , void * ))(& Object_GetType), (int (*)(PyObject * ,
                                                                                        PyObject * ,
                                                                                        void * ))((void *)0),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Subtype", (PyObject *(*)(PyObject * , void * ))(& Object_GetSubtype),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Value", (PyObject *(*)(PyObject * , void * ))(& Object_GetValue), (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          void * ))(& Object_SetValue),
      (char *)((void *)0), (void *)0}, 
        {(char *)"ArchName", (PyObject *(*)(PyObject * , void * ))(& Object_GetArchName),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Archetype", (PyObject *(*)(PyObject * , void * ))(& Object_GetArchetype),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Exists", (PyObject *(*)(PyObject * , void * ))(& Object_GetExists),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"NoSave", (PyObject *(*)(PyObject * , void * ))(& Object_GetNoSave),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetNoSave), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Env", (PyObject *(*)(PyObject * , void * ))(& Object_GetEnv), (int (*)(PyObject * ,
                                                                                      PyObject * ,
                                                                                      void * ))((void *)0),
      (char *)((void *)0), (void *)0}, 
        {(char *)"MoveType", (PyObject *(*)(PyObject * , void * ))(& Object_GetMoveType),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"MoveBlock", (PyObject *(*)(PyObject * , void * ))(& Object_GetMoveBlock),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"MoveAllow", (PyObject *(*)(PyObject * , void * ))(& Object_GetMoveAllow),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"MoveOn", (PyObject *(*)(PyObject * , void * ))(& Object_GetMoveOn),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"MoveOff", (PyObject *(*)(PyObject * , void * ))(& Object_GetMoveOff),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"MoveSlow", (PyObject *(*)(PyObject * , void * ))(& Object_GetMoveSlow),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"MoveSlowPenalty", (PyObject *(*)(PyObject * , void * ))(& Object_GetMoveSlowPenalty),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Owner", (PyObject *(*)(PyObject * , void * ))(& Object_GetOwner), (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          void * ))(& Object_SetOwner),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Enemy", (PyObject *(*)(PyObject * , void * ))(& Object_GetEnemy), (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          void * ))(& Object_SetEnemy),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Count", (PyObject *(*)(PyObject * , void * ))(& Object_GetCount), (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          void * ))((void *)0),
      (char *)((void *)0), (void *)0}, 
        {(char *)"GodGiven", (PyObject *(*)(PyObject * , void * ))(& Object_GetGodGiven),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetGodGiven), (char *)((void *)0),
      (void *)0}, 
        {(char *)"IsPet", (PyObject *(*)(PyObject * , void * ))(& Object_GetIsPet), (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          void * ))(& Object_SetIsPet),
      (char *)((void *)0), (void *)0}, 
        {(char *)"AttackMovement", (PyObject *(*)(PyObject * , void * ))(& Object_GetAttackMovement),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetAttackMovement), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Duration", (PyObject *(*)(PyObject * , void * ))(& Object_GetDuration),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetDuration), (char *)((void *)0),
      (void *)0}, 
        {(char *)"GlowRadius", (PyObject *(*)(PyObject * , void * ))(& Object_GetGlowRadius),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetGlowRadius), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Animated", (PyObject *(*)(PyObject * , void * ))(& Object_GetAnimated),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetAnimated), (char *)((void *)0),
      (void *)0}, 
        {(char *)"NoDamage", (PyObject *(*)(PyObject * , void * ))(& Object_GetNoDamage),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetNoDamage), (char *)((void *)0),
      (void *)0}, 
        {(char *)"RandomMovement", (PyObject *(*)(PyObject * , void * ))(& Object_GetRandomMovement),
      (int (*)(PyObject * , PyObject * , void * ))(& Object_SetRandomMovement), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Material", (PyObject *(*)(PyObject * , void * ))(& Object_GetMaterial),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)((void *)0), (PyObject *(*)(PyObject * , void * ))((void *)0), (int (*)(PyObject * ,
                                                                                      PyObject * ,
                                                                                      void * ))((void *)0),
      (char *)((void *)0), (void *)0}};
#line 427 "./include/cfpython_object_private.h"
static PyMethodDef ObjectMethods[39]  = 
#line 427
  {      {"Remove", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_Remove),
      4, (char const   *)((void *)0)}, 
        {"Apply", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_Apply),
      1, (char const   *)((void *)0)}, 
        {"Drop", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_Drop),
      8, (char const   *)((void *)0)}, 
        {"Clone", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_Clone),
      1, (char const   *)((void *)0)}, 
        {"Split", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_Split),
      1, (char const   *)((void *)0)}, 
        {"Fix", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_Fix), 4,
      (char const   *)((void *)0)}, 
        {"Say", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_Say), 1,
      (char const   *)((void *)0)}, 
        {"Speak", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_Say),
      1, (char const   *)((void *)0)}, 
        {"Take", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_Take),
      8, (char const   *)((void *)0)}, 
        {"Teleport", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_Teleport),
      1, (char const   *)((void *)0)}, 
        {"Reposition", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_Reposition),
      1, (char const   *)((void *)0)}, 
        {"QueryName", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_QueryName),
      4, (char const   *)((void *)0)}, 
        {"GetResist", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_GetResist),
      1, (char const   *)((void *)0)}, 
        {"SetResist", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_SetResist),
      1, (char const   *)((void *)0)}, 
        {"ActivateRune", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_ActivateRune),
      8, (char const   *)((void *)0)}, 
        {"CheckTrigger", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_CheckTrigger),
      8, (char const   *)((void *)0)}, 
        {"QueryCost", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_QueryCost),
      1, (char const   *)((void *)0)}, 
        {"Cast", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_Cast),
      1, (char const   *)((void *)0)}, 
        {"LearnSpell", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_LearnSpell),
      8, (char const   *)((void *)0)}, 
        {"ForgetSpell", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_ForgetSpell),
      8, (char const   *)((void *)0)}, 
        {"KnowSpell", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_KnowSpell),
      1, (char const   *)((void *)0)}, 
        {"CastAbility", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_CastAbility),
      1, (char const   *)((void *)0)}, 
        {"PayAmount", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_PayAmount),
      1, (char const   *)((void *)0)}, 
        {"Pay", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_Pay), 8,
      (char const   *)((void *)0)}, 
        {"CheckInventory", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_CheckInventory),
      1, (char const   *)((void *)0)}, 
        {"CheckArchInventory", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_CheckArchInventory),
      1, (char const   *)((void *)0)}, 
        {"OutOfMap", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_GetOutOfMap),
      1, (char const   *)((void *)0)}, 
        {"CreateObject", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_CreateInside),
      1, (char const   *)((void *)0)}, 
        {"InsertInto", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_InsertInto),
      8, (char const   *)((void *)0)}, 
        {"ReadKey", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_ReadKey),
      1, (char const   *)((void *)0)}, 
        {"WriteKey", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_WriteKey),
      1, (char const   *)((void *)0)}, 
        {"CreateTimer", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_CreateTimer),
      1, (char const   *)((void *)0)}, 
        {"AddExp", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_AddExp),
      1, (char const   *)((void *)0)}, 
        {"Move", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_Move),
      1, (char const   *)((void *)0)}, 
        {"ChangeAbil", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_ChangeAbil),
      8, (char const   *)((void *)0)}, 
        {"Event", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_Event),
      1, (char const   *)((void *)0)}, 
        {"RemoveDepletion", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_RemoveDepletion),
      1, (char const   *)((void *)0)}, 
        {"Arrest", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Object_Arrest),
      1, (char const   *)((void *)0)}, 
        {(char const   *)((void *)0), (PyObject *(*)(PyObject * , PyObject * ))((void *)0),
      0, (char const   *)((void *)0)}};
#line 469 "./include/cfpython_object_private.h"
static PyNumberMethods ObjectConvert  = 
#line 469
     {(PyObject *(*)(PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                         PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                         PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                         PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * ))((void *)0), (PyObject *(*)(PyObject * ))((void *)0),
    (int (*)(PyObject * ))((void *)0), (PyObject *(*)(PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                                               PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                         PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                         PyObject * ))((void *)0),
    (int (*)(PyObject ** , PyObject ** ))((void *)0), & Crossfire_Object_Int, & Crossfire_Object_Long,
    (PyObject *(*)(PyObject * ))((void *)0), (PyObject *(*)(PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * ))((void *)0), (PyObject *(*)(PyObject * , PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                         PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                         PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                                      PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                         PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                         PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                         PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                         PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * ))((void *)0)};
#line 534
static void Crossfire_Object_dealloc(PyObject *obj ) ;
#line 539 "./include/cfpython_object_private.h"
PyTypeObject Crossfire_ObjectType  = 
#line 539
     {(Py_ssize_t )1, (struct _typeobject *)((void *)0), (Py_ssize_t )0, "Crossfire.Object",
    (Py_ssize_t )sizeof(Crossfire_Object ), (Py_ssize_t )0, & Crossfire_Object_dealloc,
    (int (*)(PyObject * , FILE * , int  ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                      char * ))((void *)0),
    (int (*)(PyObject * , char * , PyObject * ))((void *)0), (int (*)(PyObject * ,
                                                                      PyObject * ))(& Crossfire_Object_InternalCompare),
    (PyObject *(*)(PyObject * ))((void *)0), & ObjectConvert, (PySequenceMethods *)((void *)0),
    (PyMappingMethods *)((void *)0), & PyObject_HashNotImplemented, (PyObject *(*)(PyObject * ,
                                                                                   PyObject * ,
                                                                                   PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * ))((void *)0), & PyObject_GenericGetAttr, & PyObject_GenericSetAttr,
    (PyBufferProcs *)((void *)0), (((((((1L | (1L << 1)) | (1L << 3)) | (1L << 5)) | (1L << 6)) | (1L << 7)) | (1L << 8)) | (1L << 17)) | (1L << 10),
    "Crossfire objects", (int (*)(PyObject * , int (*)(PyObject * , void * ) , void * ))((void *)0),
    (int (*)(PyObject * ))((void *)0), (PyObject *(*)(PyObject * , PyObject * , int  ))(& Crossfire_Object_RichCompare),
    (Py_ssize_t )0, (PyObject *(*)(PyObject * ))((void *)0), (PyObject *(*)(PyObject * ))((void *)0),
    ObjectMethods, (struct PyMemberDef *)((void *)0), Object_getseters, (struct _typeobject *)((void *)0),
    (PyObject *)((void *)0), (PyObject *(*)(PyObject * , PyObject * , PyObject * ))((void *)0),
    (int (*)(PyObject * , PyObject * , PyObject * ))((void *)0), (Py_ssize_t )0, (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          PyObject * ))((void *)0),
    (PyObject *(*)(struct _typeobject * , Py_ssize_t  ))((void *)0), & Crossfire_Object_new,
    (void (*)(void * ))((void *)0), (int (*)(PyObject * ))((void *)0), (PyObject *)((void *)0),
    (PyObject *)((void *)0), (PyObject *)((void *)0), (PyObject *)((void *)0), (PyObject *)((void *)0),
    (void (*)(PyObject * ))((void *)0), 0U};
#line 598
static PyObject *Player_GetTitle(Crossfire_Object *whoptr , void *closure ) ;
#line 599
static int Player_SetTitle(Crossfire_Object *whoptr , PyObject *value , void *closure ) ;
#line 600
static PyObject *Player_GetIP(Crossfire_Player *whoptr , void *closure ) ;
#line 601
static PyObject *Player_GetMarkedItem(Crossfire_Player *whoptr , void *closure ) ;
#line 602
static int Player_SetMarkedItem(Crossfire_Player *whoptr , PyObject *value , void *closure ) ;
#line 603
static PyObject *Crossfire_Player_Message(Crossfire_Player *who , PyObject *args ) ;
#line 604
static PyObject *Player_GetParty(Crossfire_Player *whoptr , void *closure ) ;
#line 605
static int Player_SetParty(Crossfire_Player *whoptr , PyObject *value , void *closure ) ;
#line 606
static PyObject *Crossfire_Player_CanPay(Crossfire_Player *who , PyObject *args ) ;
#line 607
static PyObject *Player_GetBedMap(Crossfire_Player *whoptr , void *closure ) ;
#line 608
static PyObject *Player_GetBedX(Crossfire_Player *whoptr , void *closure ) ;
#line 609
static PyObject *Player_GetBedY(Crossfire_Player *whoptr , void *closure ) ;
#line 610
static int Player_SetBedMap(Crossfire_Player *whoptr , PyObject *value , void *closure ) ;
#line 611
static int Player_SetBedX(Crossfire_Player *whoptr , PyObject *value , void *closure ) ;
#line 612
static int Player_SetBedY(Crossfire_Player *whoptr , PyObject *value , void *closure ) ;
#line 613
static PyObject *Player_QuestStart(Crossfire_Player *whoptr , PyObject *args ) ;
#line 614
static PyObject *Player_QuestGetState(Crossfire_Player *whoptr , PyObject *args ) ;
#line 615
static PyObject *Player_QuestSetState(Crossfire_Player *whoptr , PyObject *args ) ;
#line 616
static PyObject *Player_QuestWasCompleted(Crossfire_Player *whoptr , PyObject *args ) ;
#line 617
static PyObject *Player_KnowledgeKnown(Crossfire_Player *who , PyObject *args ) ;
#line 619 "./include/cfpython_object_private.h"
static PyGetSetDef Player_getseters[8]  = 
#line 619
  {      {(char *)"Title", (PyObject *(*)(PyObject * , void * ))(& Player_GetTitle), (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          void * ))(& Player_SetTitle),
      (char *)((void *)0), (void *)0}, 
        {(char *)"IP", (PyObject *(*)(PyObject * , void * ))(& Player_GetIP), (int (*)(PyObject * ,
                                                                                    PyObject * ,
                                                                                    void * ))((void *)0),
      (char *)((void *)0), (void *)0}, 
        {(char *)"MarkedItem", (PyObject *(*)(PyObject * , void * ))(& Player_GetMarkedItem),
      (int (*)(PyObject * , PyObject * , void * ))(& Player_SetMarkedItem), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Party", (PyObject *(*)(PyObject * , void * ))(& Player_GetParty), (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          void * ))(& Player_SetParty),
      (char *)((void *)0), (void *)0}, 
        {(char *)"BedMap", (PyObject *(*)(PyObject * , void * ))(& Player_GetBedMap),
      (int (*)(PyObject * , PyObject * , void * ))(& Player_SetBedMap), (char *)((void *)0),
      (void *)0}, 
        {(char *)"BedX", (PyObject *(*)(PyObject * , void * ))(& Player_GetBedX), (int (*)(PyObject * ,
                                                                                        PyObject * ,
                                                                                        void * ))(& Player_SetBedX),
      (char *)((void *)0), (void *)0}, 
        {(char *)"BedY", (PyObject *(*)(PyObject * , void * ))(& Player_GetBedY), (int (*)(PyObject * ,
                                                                                        PyObject * ,
                                                                                        void * ))(& Player_SetBedY),
      (char *)((void *)0), (void *)0}, 
        {(char *)((void *)0), (PyObject *(*)(PyObject * , void * ))((void *)0), (int (*)(PyObject * ,
                                                                                      PyObject * ,
                                                                                      void * ))((void *)0),
      (char *)((void *)0), (void *)0}};
#line 630 "./include/cfpython_object_private.h"
static PyMethodDef PlayerMethods[9]  = 
#line 630
  {      {"Message", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Player_Message),
      1, (char const   *)((void *)0)}, 
        {"Write", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Player_Message),
      1, (char const   *)((void *)0)}, 
        {"CanPay", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Player_CanPay),
      4, (char const   *)((void *)0)}, 
        {"QuestStart", (PyObject *(*)(PyObject * , PyObject * ))(& Player_QuestStart),
      1, (char const   *)((void *)0)}, 
        {"QuestGetState", (PyObject *(*)(PyObject * , PyObject * ))(& Player_QuestGetState),
      1, (char const   *)((void *)0)}, 
        {"QuestSetState", (PyObject *(*)(PyObject * , PyObject * ))(& Player_QuestSetState),
      1, (char const   *)((void *)0)}, 
        {"QuestWasCompleted", (PyObject *(*)(PyObject * , PyObject * ))(& Player_QuestWasCompleted),
      1, (char const   *)((void *)0)}, 
        {"KnowledgeKnown", (PyObject *(*)(PyObject * , PyObject * ))(& Player_KnowledgeKnown),
      1, (char const   *)((void *)0)}, 
        {(char const   *)((void *)0), (PyObject *(*)(PyObject * , PyObject * ))((void *)0),
      0, (char const   *)((void *)0)}};
#line 642
static void Crossfire_Player_dealloc(PyObject *obj ) ;
#line 644
static PyObject *Crossfire_Player_new(PyTypeObject *type , PyObject *args , PyObject *kwds ) ;
#line 647 "./include/cfpython_object_private.h"
PyTypeObject Crossfire_PlayerType  = 
#line 647
     {(Py_ssize_t )1, (struct _typeobject *)((void *)0), (Py_ssize_t )0, "Crossfire.Player",
    (Py_ssize_t )sizeof(Crossfire_Player ), (Py_ssize_t )0, & Crossfire_Player_dealloc,
    (int (*)(PyObject * , FILE * , int  ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                      char * ))((void *)0),
    (int (*)(PyObject * , char * , PyObject * ))((void *)0), (int (*)(PyObject * ,
                                                                      PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * ))((void *)0), (PyNumberMethods *)((void *)0), (PySequenceMethods *)((void *)0),
    (PyMappingMethods *)((void *)0), (long (*)(PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                                        PyObject * ,
                                                                                        PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * ))((void *)0), & PyObject_GenericGetAttr, & PyObject_GenericSetAttr,
    (PyBufferProcs *)((void *)0), ((((((1L | (1L << 1)) | (1L << 3)) | (1L << 5)) | (1L << 6)) | (1L << 7)) | (1L << 8)) | (1L << 17),
    "Crossfire player", (int (*)(PyObject * , int (*)(PyObject * , void * ) , void * ))((void *)0),
    (int (*)(PyObject * ))((void *)0), (PyObject *(*)(PyObject * , PyObject * , int  ))((void *)0),
    (Py_ssize_t )0, (PyObject *(*)(PyObject * ))((void *)0), (PyObject *(*)(PyObject * ))((void *)0),
    PlayerMethods, (struct PyMemberDef *)((void *)0), Player_getseters, & Crossfire_ObjectType,
    (PyObject *)((void *)0), (PyObject *(*)(PyObject * , PyObject * , PyObject * ))((void *)0),
    (int (*)(PyObject * , PyObject * , PyObject * ))((void *)0), (Py_ssize_t )0, (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          PyObject * ))((void *)0),
    (PyObject *(*)(struct _typeobject * , Py_ssize_t  ))((void *)0), & Crossfire_Player_new,
    (void (*)(void * ))((void *)0), (int (*)(PyObject * ))((void *)0), (PyObject *)((void *)0),
    (PyObject *)((void *)0), (PyObject *)((void *)0), (PyObject *)((void *)0), (PyObject *)((void *)0),
    (void (*)(PyObject * ))((void *)0), 0U};
#line 35 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static ptr_assoc_table object_assoc_table  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
void init_object_assoc_table(void) 
{ 


  {
  {
#line 39
  init_ptr_assoc_table(object_assoc_table);
  }
#line 40
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static void add_object_assoc(object *key , PyObject *value ) 
{ 


  {
  {
#line 43
  add_ptr_assoc(object_assoc_table, (void *)key, (void *)value);
  }
#line 44
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *find_assoc_pyobject(object *key ) 
{ 
  void *tmp ;

  {
  {
#line 47
  tmp = find_assoc_value(object_assoc_table, (void *)key);
  }
#line 47
  return ((PyObject *)tmp);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static void free_object_assoc(object *key ) 
{ 


  {
  {
#line 51
  free_ptr_assoc(object_assoc_table, (void *)key);
  }
#line 52
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Player_GetTitle(Crossfire_Object *whoptr , void *closure ) 
{ 
  char title[48] ;
  char *tmp ;
  PyObject *tmp___0 ;

  {
#line 56
  if (! whoptr) {
    {
#line 56
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 56
    return ((PyObject *)((void *)0));
  } else
#line 56
  if (! whoptr->obj) {
    {
#line 56
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 56
    return ((PyObject *)((void *)0));
  } else
#line 56
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 56
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 56
    return ((PyObject *)((void *)0));
  } else
#line 56
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 56
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 56
    return ((PyObject *)((void *)0));
  }
  {
#line 57
  tmp = cf_player_get_title(whoptr->obj, title, 48);
#line 57
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 57
  return (tmp___0);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Player_SetTitle(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  char *val ;
  int tmp ;

  {
#line 63
  if (! whoptr) {
    {
#line 63
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 63
    return (-1);
  } else
#line 63
  if (! whoptr->obj) {
    {
#line 63
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 63
    return (-1);
  } else
#line 63
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 63
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 63
    return (-1);
  } else
#line 63
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 63
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 63
    return (-1);
  }
#line 64
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    {
#line 65
    PyErr_SetString(PyExc_TypeError, "Cannot delete the Title attribute");
    }
#line 66
    return (-1);
  }
#line 68
  if (! (((value->ob_type)->tp_flags & (1L << 27)) != 0L)) {
#line 68
    if (! (((value->ob_type)->tp_flags & (1L << 28)) != 0L)) {
      {
#line 69
      PyErr_SetString(PyExc_TypeError, "The Title attribute must be a string");
      }
#line 70
      return (-1);
    }
  }
  {
#line 72
  tmp = PyArg_Parse(value, "s", & val);
  }
#line 72
  if (! tmp) {
#line 73
    return (-1);
  }
  {
#line 75
  cf_player_set_title(whoptr->obj, (char const   *)val);
  }
#line 76
  return (0);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Player_GetIP(Crossfire_Player *whoptr , void *closure ) 
{ 
  sstring tmp ;
  PyObject *tmp___0 ;

  {
#line 80
  if (! whoptr) {
    {
#line 80
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 80
    return ((PyObject *)((void *)0));
  } else
#line 80
  if (! whoptr->obj) {
    {
#line 80
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 80
    return ((PyObject *)((void *)0));
  } else
#line 80
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 80
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 80
    return ((PyObject *)((void *)0));
  } else
#line 80
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 80
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 80
    return ((PyObject *)((void *)0));
  }
  {
#line 81
  tmp = cf_player_get_ip(whoptr->obj);
#line 81
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 81
  return (tmp___0);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Player_GetMarkedItem(Crossfire_Player *whoptr , void *closure ) 
{ 
  object *tmp ;
  PyObject *tmp___0 ;

  {
#line 85
  if (! whoptr) {
    {
#line 85
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 85
    return ((PyObject *)((void *)0));
  } else
#line 85
  if (! whoptr->obj) {
    {
#line 85
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 85
    return ((PyObject *)((void *)0));
  } else
#line 85
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 85
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 85
    return ((PyObject *)((void *)0));
  } else
#line 85
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 85
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 85
    return ((PyObject *)((void *)0));
  }
  {
#line 86
  tmp = cf_player_get_marked_item(whoptr->obj);
#line 86
  tmp___0 = Crossfire_Object_wrap(tmp);
  }
#line 86
  return (tmp___0);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Player_SetMarkedItem(Crossfire_Player *whoptr , PyObject *value , void *closure ) 
{ 
  Crossfire_Object *ob ;
  int tmp ;

  {
#line 92
  if (! whoptr) {
    {
#line 92
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 92
    return (-1);
  } else
#line 92
  if (! whoptr->obj) {
    {
#line 92
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 92
    return (-1);
  } else
#line 92
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 92
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 92
    return (-1);
  } else
#line 92
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 92
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 92
    return (-1);
  }
  {
#line 93
  tmp = PyArg_Parse(value, "O!", & Crossfire_ObjectType, & ob);
  }
#line 93
  if (! tmp) {
#line 94
    return (-1);
  }
  {
#line 95
  cf_player_set_marked_item(whoptr->obj, ob->obj);
  }
#line 96
  return (0);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Player_Message(Crossfire_Player *who , PyObject *args ) 
{ 
  char *message ;
  int color ;
  int tmp ;

  {
#line 101
  color = 260;
#line 103
  if (! who) {
    {
#line 103
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 103
    return ((PyObject *)((void *)0));
  } else
#line 103
  if (! who->obj) {
    {
#line 103
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 103
    return ((PyObject *)((void *)0));
  } else
#line 103
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 103
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 103
    return ((PyObject *)((void *)0));
  } else
#line 103
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 103
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 103
    return ((PyObject *)((void *)0));
  }
  {
#line 104
  tmp = PyArg_ParseTuple(args, "s|i", & message, & color);
  }
#line 104
  if (! tmp) {
#line 105
    return ((PyObject *)((void *)0));
  }
  {
#line 107
  cf_player_message(who->obj, message, color);
#line 108
  (_Py_NoneStruct.ob_refcnt) ++;
  }
#line 109
  return (& _Py_NoneStruct);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Player_KnowledgeKnown(Crossfire_Player *who , PyObject *args ) 
{ 
  char const   *knowledge ;
  int tmp ;
  int tmp___0 ;
  PyObject *tmp___1 ;

  {
#line 115
  if (! who) {
    {
#line 115
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 115
    return ((PyObject *)((void *)0));
  } else
#line 115
  if (! who->obj) {
    {
#line 115
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 115
    return ((PyObject *)((void *)0));
  } else
#line 115
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 115
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 115
    return ((PyObject *)((void *)0));
  } else
#line 115
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 115
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 115
    return ((PyObject *)((void *)0));
  }
  {
#line 116
  tmp = PyArg_ParseTuple(args, "s", & knowledge);
  }
#line 116
  if (! tmp) {
#line 117
    return ((PyObject *)((void *)0));
  }
  {
#line 119
  tmp___0 = cf_player_knowledge_has(who->obj, knowledge);
#line 119
  tmp___1 = Py_BuildValue("i", tmp___0);
  }
#line 119
  return (tmp___1);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Player_GetParty(Crossfire_Player *whoptr , void *closure ) 
{ 
  partylist *tmp ;
  PyObject *tmp___0 ;

  {
#line 123
  if (! whoptr) {
    {
#line 123
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 123
    return ((PyObject *)((void *)0));
  } else
#line 123
  if (! whoptr->obj) {
    {
#line 123
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 123
    return ((PyObject *)((void *)0));
  } else
#line 123
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 123
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 123
    return ((PyObject *)((void *)0));
  } else
#line 123
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 123
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 123
    return ((PyObject *)((void *)0));
  }
  {
#line 124
  tmp = cf_player_get_party(whoptr->obj);
#line 124
  tmp___0 = Crossfire_Party_wrap(tmp);
  }
#line 124
  return (tmp___0);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Player_SetParty(Crossfire_Player *whoptr , PyObject *value , void *closure ) 
{ 
  Crossfire_Party *ob ;
  int tmp ;

  {
#line 130
  if (! whoptr) {
    {
#line 130
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 130
    return (-1);
  } else
#line 130
  if (! whoptr->obj) {
    {
#line 130
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 130
    return (-1);
  } else
#line 130
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 130
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 130
    return (-1);
  } else
#line 130
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 130
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 130
    return (-1);
  }
  {
#line 131
  tmp = PyArg_Parse(value, "O!", & Crossfire_PartyType, & ob);
  }
#line 131
  if (! tmp) {
#line 132
    return (-1);
  }
  {
#line 133
  cf_player_set_party(whoptr->obj, ob->party);
  }
#line 134
  return (0);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Player_CanPay(Crossfire_Player *who , PyObject *args ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 138
  if (! who) {
    {
#line 138
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 138
    return ((PyObject *)((void *)0));
  } else
#line 138
  if (! who->obj) {
    {
#line 138
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 138
    return ((PyObject *)((void *)0));
  } else
#line 138
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 138
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 138
    return ((PyObject *)((void *)0));
  } else
#line 138
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 138
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 138
    return ((PyObject *)((void *)0));
  }
  {
#line 139
  tmp = cf_player_can_pay(who->obj);
#line 139
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 139
  return (tmp___0);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Player_GetBedMap(Crossfire_Player *whoptr , void *closure ) 
{ 
  char bed[200] ;
  char *tmp ;
  PyObject *tmp___0 ;

  {
#line 145
  if (! whoptr) {
    {
#line 145
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 145
    return ((PyObject *)((void *)0));
  } else
#line 145
  if (! whoptr->obj) {
    {
#line 145
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 145
    return ((PyObject *)((void *)0));
  } else
#line 145
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 145
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 145
    return ((PyObject *)((void *)0));
  } else
#line 145
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 145
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 145
    return ((PyObject *)((void *)0));
  }
  {
#line 146
  tmp = cf_object_get_string_property(whoptr->obj, 153, bed, (int )sizeof(bed));
#line 146
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 146
  return (tmp___0);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Player_SetBedMap(Crossfire_Player *whoptr , PyObject *value , void *closure ) 
{ 
  char *location ;
  int tmp ;

  {
#line 152
  if (! whoptr) {
    {
#line 152
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 152
    return (-1);
  } else
#line 152
  if (! whoptr->obj) {
    {
#line 152
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 152
    return (-1);
  } else
#line 152
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 152
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 152
    return (-1);
  } else
#line 152
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 152
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 152
    return (-1);
  }
  {
#line 153
  tmp = PyArg_Parse(value, "s", & location);
  }
#line 153
  if (! tmp) {
#line 154
    return (-1);
  }
  {
#line 155
  cf_object_set_string_property(whoptr->obj, 153, (char const   *)location);
  }
#line 156
  return (0);
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Player_GetBedX(Crossfire_Player *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 160
  if (! whoptr) {
    {
#line 160
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 160
    return ((PyObject *)((void *)0));
  } else
#line 160
  if (! whoptr->obj) {
    {
#line 160
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 160
    return ((PyObject *)((void *)0));
  } else
#line 160
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 160
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 160
    return ((PyObject *)((void *)0));
  } else
#line 160
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 160
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 160
    return ((PyObject *)((void *)0));
  }
  {
#line 161
  tmp = cf_object_get_int_property(whoptr->obj, 154);
#line 161
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 161
  return (tmp___0);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Player_SetBedX(Crossfire_Player *whoptr , PyObject *value , void *closure ) 
{ 
  int x ;
  int tmp ;

  {
#line 167
  if (! whoptr) {
    {
#line 167
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 167
    return (-1);
  } else
#line 167
  if (! whoptr->obj) {
    {
#line 167
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 167
    return (-1);
  } else
#line 167
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 167
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 167
    return (-1);
  } else
#line 167
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 167
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 167
    return (-1);
  }
  {
#line 168
  tmp = PyArg_Parse(value, "i", & x);
  }
#line 168
  if (! tmp) {
#line 169
    return (-1);
  }
  {
#line 170
  cf_object_set_int_property(whoptr->obj, 154, x);
  }
#line 171
  return (0);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Player_GetBedY(Crossfire_Player *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 175
  if (! whoptr) {
    {
#line 175
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 175
    return ((PyObject *)((void *)0));
  } else
#line 175
  if (! whoptr->obj) {
    {
#line 175
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 175
    return ((PyObject *)((void *)0));
  } else
#line 175
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 175
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 175
    return ((PyObject *)((void *)0));
  } else
#line 175
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 175
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 175
    return ((PyObject *)((void *)0));
  }
  {
#line 176
  tmp = cf_object_get_int_property(whoptr->obj, 155);
#line 176
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 176
  return (tmp___0);
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Player_SetBedY(Crossfire_Player *whoptr , PyObject *value , void *closure ) 
{ 
  int y ;
  int tmp ;

  {
#line 182
  if (! whoptr) {
    {
#line 182
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 182
    return (-1);
  } else
#line 182
  if (! whoptr->obj) {
    {
#line 182
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 182
    return (-1);
  } else
#line 182
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 182
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 182
    return (-1);
  } else
#line 182
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 182
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 182
    return (-1);
  }
  {
#line 183
  tmp = PyArg_Parse(value, "i", & y);
  }
#line 183
  if (! tmp) {
#line 184
    return (-1);
  }
  {
#line 185
  cf_object_set_int_property(whoptr->obj, 155, y);
  }
#line 186
  return (0);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Player_QuestStart(Crossfire_Player *whoptr , PyObject *args ) 
{ 
  char *code ;
  int state ;
  sstring quest_code ;
  int tmp ;

  {
#line 194
  if (! whoptr) {
    {
#line 194
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 194
    return ((PyObject *)((void *)0));
  } else
#line 194
  if (! whoptr->obj) {
    {
#line 194
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 194
    return ((PyObject *)((void *)0));
  } else
#line 194
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 194
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 194
    return ((PyObject *)((void *)0));
  } else
#line 194
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 194
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 194
    return ((PyObject *)((void *)0));
  }
  {
#line 195
  tmp = PyArg_ParseTuple(args, "si", & code, & state);
  }
#line 195
  if (! tmp) {
#line 196
    return ((PyObject *)((void *)0));
  }
  {
#line 198
  quest_code = cf_add_string((char const   *)code);
#line 199
  cf_quest_start(whoptr->obj, quest_code, state);
#line 200
  cf_free_string(quest_code);
#line 202
  (_Py_NoneStruct.ob_refcnt) ++;
  }
#line 203
  return (& _Py_NoneStruct);
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Player_QuestGetState(Crossfire_Player *whoptr , PyObject *args ) 
{ 
  char *code ;
  int state ;
  sstring quest_code ;
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 211
  if (! whoptr) {
    {
#line 211
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 211
    return ((PyObject *)((void *)0));
  } else
#line 211
  if (! whoptr->obj) {
    {
#line 211
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 211
    return ((PyObject *)((void *)0));
  } else
#line 211
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 211
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 211
    return ((PyObject *)((void *)0));
  } else
#line 211
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 211
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 211
    return ((PyObject *)((void *)0));
  }
  {
#line 212
  tmp = PyArg_ParseTuple(args, "s", & code);
  }
#line 212
  if (! tmp) {
#line 213
    return ((PyObject *)((void *)0));
  }
  {
#line 215
  quest_code = cf_add_string((char const   *)code);
#line 216
  state = cf_quest_get_player_state(whoptr->obj, quest_code);
#line 217
  cf_free_string(quest_code);
#line 219
  tmp___0 = Py_BuildValue("i", state);
  }
#line 219
  return (tmp___0);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Player_QuestSetState(Crossfire_Player *whoptr , PyObject *args ) 
{ 
  char *code ;
  int state ;
  sstring quest_code ;
  int tmp ;

  {
#line 227
  if (! whoptr) {
    {
#line 227
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 227
    return ((PyObject *)((void *)0));
  } else
#line 227
  if (! whoptr->obj) {
    {
#line 227
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 227
    return ((PyObject *)((void *)0));
  } else
#line 227
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 227
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 227
    return ((PyObject *)((void *)0));
  } else
#line 227
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 227
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 227
    return ((PyObject *)((void *)0));
  }
  {
#line 228
  tmp = PyArg_ParseTuple(args, "si", & code, & state);
  }
#line 228
  if (! tmp) {
#line 229
    return ((PyObject *)((void *)0));
  }
  {
#line 231
  quest_code = cf_add_string((char const   *)code);
#line 232
  cf_quest_set_player_state(whoptr->obj, quest_code, state);
#line 233
  cf_free_string(quest_code);
#line 235
  (_Py_NoneStruct.ob_refcnt) ++;
  }
#line 236
  return (& _Py_NoneStruct);
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Player_QuestWasCompleted(Crossfire_Player *whoptr , PyObject *args ) 
{ 
  char *code ;
  int completed ;
  sstring quest_code ;
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 244
  if (! whoptr) {
    {
#line 244
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 244
    return ((PyObject *)((void *)0));
  } else
#line 244
  if (! whoptr->obj) {
    {
#line 244
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 244
    return ((PyObject *)((void *)0));
  } else
#line 244
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 244
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 244
    return ((PyObject *)((void *)0));
  } else
#line 244
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 244
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 244
    return ((PyObject *)((void *)0));
  }
  {
#line 245
  tmp = PyArg_ParseTuple(args, "s", & code);
  }
#line 245
  if (! tmp) {
#line 246
    return ((PyObject *)((void *)0));
  }
  {
#line 248
  quest_code = cf_add_string((char const   *)code);
#line 249
  completed = cf_quest_was_completed(whoptr->obj, quest_code);
#line 250
  cf_free_string(quest_code);
#line 252
  tmp___0 = Py_BuildValue("i", completed);
  }
#line 252
  return (tmp___0);
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetName(Crossfire_Object *whoptr , void *closure ) 
{ 
  char name[200] ;
  char *tmp ;
  PyObject *tmp___0 ;

  {
#line 259
  if (! whoptr) {
    {
#line 259
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 259
    return ((PyObject *)((void *)0));
  } else
#line 259
  if (! whoptr->obj) {
    {
#line 259
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 259
    return ((PyObject *)((void *)0));
  } else
#line 259
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 259
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 259
    return ((PyObject *)((void *)0));
  } else
#line 259
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 259
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 259
    return ((PyObject *)((void *)0));
  }
  {
#line 260
  tmp = cf_query_name(whoptr->obj, name, (int )sizeof(name));
#line 260
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 260
  return (tmp___0);
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetNamePl(Crossfire_Object *whoptr , void *closure ) 
{ 
  sstring tmp ;
  PyObject *tmp___0 ;

  {
#line 264
  if (! whoptr) {
    {
#line 264
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 264
    return ((PyObject *)((void *)0));
  } else
#line 264
  if (! whoptr->obj) {
    {
#line 264
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 264
    return ((PyObject *)((void *)0));
  } else
#line 264
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 264
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 264
    return ((PyObject *)((void *)0));
  } else
#line 264
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 264
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 264
    return ((PyObject *)((void *)0));
  }
  {
#line 265
  tmp = cf_query_name_pl(whoptr->obj);
#line 265
  tmp___0 = Py_BuildValue("s", (char *)tmp);
  }
#line 265
  return (tmp___0);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetTitle(Crossfire_Object *whoptr , void *closure ) 
{ 
  sstring tmp ;
  PyObject *tmp___0 ;

  {
#line 269
  if (! whoptr) {
    {
#line 269
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 269
    return ((PyObject *)((void *)0));
  } else
#line 269
  if (! whoptr->obj) {
    {
#line 269
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 269
    return ((PyObject *)((void *)0));
  } else
#line 269
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 269
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 269
    return ((PyObject *)((void *)0));
  } else
#line 269
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 269
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 269
    return ((PyObject *)((void *)0));
  }
  {
#line 270
  tmp = cf_object_get_sstring_property(whoptr->obj, 14);
#line 270
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 270
  return (tmp___0);
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetRace(Crossfire_Object *whoptr , void *closure ) 
{ 
  sstring tmp ;
  PyObject *tmp___0 ;

  {
#line 274
  if (! whoptr) {
    {
#line 274
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 274
    return ((PyObject *)((void *)0));
  } else
#line 274
  if (! whoptr->obj) {
    {
#line 274
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 274
    return ((PyObject *)((void *)0));
  } else
#line 274
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 274
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 274
    return ((PyObject *)((void *)0));
  } else
#line 274
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 274
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 274
    return ((PyObject *)((void *)0));
  }
  {
#line 275
  tmp = cf_object_get_sstring_property(whoptr->obj, 15);
#line 275
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 275
  return (tmp___0);
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetMap(Crossfire_Object *whoptr , void *closure ) 
{ 
  mapstruct *m ;
  PyObject *tmp ;

  {
#line 281
  if (! whoptr) {
    {
#line 281
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 281
    return ((PyObject *)((void *)0));
  } else
#line 281
  if (! whoptr->obj) {
    {
#line 281
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 281
    return ((PyObject *)((void *)0));
  } else
#line 281
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 281
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 281
    return ((PyObject *)((void *)0));
  } else
#line 281
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 281
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 281
    return ((PyObject *)((void *)0));
  }
  {
#line 282
  m = cf_object_get_map_property(whoptr->obj, 9);
#line 283
  tmp = Crossfire_Map_wrap(m);
  }
#line 283
  return (tmp);
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetCha(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 287
  if (! whoptr) {
    {
#line 287
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 287
    return ((PyObject *)((void *)0));
  } else
#line 287
  if (! whoptr->obj) {
    {
#line 287
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 287
    return ((PyObject *)((void *)0));
  } else
#line 287
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 287
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 287
    return ((PyObject *)((void *)0));
  } else
#line 287
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 287
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 287
    return ((PyObject *)((void *)0));
  }
  {
#line 288
  tmp = cf_object_get_int_property(whoptr->obj, 85);
#line 288
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 288
  return (tmp___0);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetCon(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 292
  if (! whoptr) {
    {
#line 292
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 292
    return ((PyObject *)((void *)0));
  } else
#line 292
  if (! whoptr->obj) {
    {
#line 292
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 292
    return ((PyObject *)((void *)0));
  } else
#line 292
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 292
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 292
    return ((PyObject *)((void *)0));
  } else
#line 292
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 292
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 292
    return ((PyObject *)((void *)0));
  }
  {
#line 293
  tmp = cf_object_get_int_property(whoptr->obj, 81);
#line 293
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 293
  return (tmp___0);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetDex(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 297
  if (! whoptr) {
    {
#line 297
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 297
    return ((PyObject *)((void *)0));
  } else
#line 297
  if (! whoptr->obj) {
    {
#line 297
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 297
    return ((PyObject *)((void *)0));
  } else
#line 297
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 297
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 297
    return ((PyObject *)((void *)0));
  } else
#line 297
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 297
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 297
    return ((PyObject *)((void *)0));
  }
  {
#line 298
  tmp = cf_object_get_int_property(whoptr->obj, 80);
#line 298
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 298
  return (tmp___0);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetInt(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 302
  if (! whoptr) {
    {
#line 302
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 302
    return ((PyObject *)((void *)0));
  } else
#line 302
  if (! whoptr->obj) {
    {
#line 302
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 302
    return ((PyObject *)((void *)0));
  } else
#line 302
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 302
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 302
    return ((PyObject *)((void *)0));
  } else
#line 302
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 302
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 302
    return ((PyObject *)((void *)0));
  }
  {
#line 303
  tmp = cf_object_get_int_property(whoptr->obj, 83);
#line 303
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 303
  return (tmp___0);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetPow(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 307
  if (! whoptr) {
    {
#line 307
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 307
    return ((PyObject *)((void *)0));
  } else
#line 307
  if (! whoptr->obj) {
    {
#line 307
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 307
    return ((PyObject *)((void *)0));
  } else
#line 307
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 307
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 307
    return ((PyObject *)((void *)0));
  } else
#line 307
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 307
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 307
    return ((PyObject *)((void *)0));
  }
  {
#line 308
  tmp = cf_object_get_int_property(whoptr->obj, 84);
#line 308
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 308
  return (tmp___0);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetStr(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 312
  if (! whoptr) {
    {
#line 312
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 312
    return ((PyObject *)((void *)0));
  } else
#line 312
  if (! whoptr->obj) {
    {
#line 312
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 312
    return ((PyObject *)((void *)0));
  } else
#line 312
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 312
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 312
    return ((PyObject *)((void *)0));
  } else
#line 312
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 312
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 312
    return ((PyObject *)((void *)0));
  }
  {
#line 313
  tmp = cf_object_get_int_property(whoptr->obj, 79);
#line 313
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 313
  return (tmp___0);
}
}
#line 316 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetWis(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 317
  if (! whoptr) {
    {
#line 317
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 317
    return ((PyObject *)((void *)0));
  } else
#line 317
  if (! whoptr->obj) {
    {
#line 317
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 317
    return ((PyObject *)((void *)0));
  } else
#line 317
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 317
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 317
    return ((PyObject *)((void *)0));
  } else
#line 317
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 317
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 317
    return ((PyObject *)((void *)0));
  }
  {
#line 318
  tmp = cf_object_get_int_property(whoptr->obj, 82);
#line 318
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 318
  return (tmp___0);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetHP(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 322
  if (! whoptr) {
    {
#line 322
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 322
    return ((PyObject *)((void *)0));
  } else
#line 322
  if (! whoptr->obj) {
    {
#line 322
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 322
    return ((PyObject *)((void *)0));
  } else
#line 322
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 322
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 322
    return ((PyObject *)((void *)0));
  } else
#line 322
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 322
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 322
    return ((PyObject *)((void *)0));
  }
  {
#line 323
  tmp = cf_object_get_int_property(whoptr->obj, 88);
#line 323
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 323
  return (tmp___0);
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetMaxHP(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 327
  if (! whoptr) {
    {
#line 327
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 327
    return ((PyObject *)((void *)0));
  } else
#line 327
  if (! whoptr->obj) {
    {
#line 327
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 327
    return ((PyObject *)((void *)0));
  } else
#line 327
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 327
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 327
    return ((PyObject *)((void *)0));
  } else
#line 327
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 327
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 327
    return ((PyObject *)((void *)0));
  }
  {
#line 328
  tmp = cf_object_get_int_property(whoptr->obj, 92);
#line 328
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 328
  return (tmp___0);
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetSP(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 332
  if (! whoptr) {
    {
#line 332
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 332
    return ((PyObject *)((void *)0));
  } else
#line 332
  if (! whoptr->obj) {
    {
#line 332
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 332
    return ((PyObject *)((void *)0));
  } else
#line 332
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 332
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 332
    return ((PyObject *)((void *)0));
  } else
#line 332
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 332
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 332
    return ((PyObject *)((void *)0));
  }
  {
#line 333
  tmp = cf_object_get_int_property(whoptr->obj, 89);
#line 333
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 333
  return (tmp___0);
}
}
#line 336 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetMaxSP(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 337
  if (! whoptr) {
    {
#line 337
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 337
    return ((PyObject *)((void *)0));
  } else
#line 337
  if (! whoptr->obj) {
    {
#line 337
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 337
    return ((PyObject *)((void *)0));
  } else
#line 337
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 337
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 337
    return ((PyObject *)((void *)0));
  } else
#line 337
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 337
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 337
    return ((PyObject *)((void *)0));
  }
  {
#line 338
  tmp = cf_object_get_int_property(whoptr->obj, 93);
#line 338
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 338
  return (tmp___0);
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetGrace(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 342
  if (! whoptr) {
    {
#line 342
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 342
    return ((PyObject *)((void *)0));
  } else
#line 342
  if (! whoptr->obj) {
    {
#line 342
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 342
    return ((PyObject *)((void *)0));
  } else
#line 342
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 342
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 342
    return ((PyObject *)((void *)0));
  } else
#line 342
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 342
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 342
    return ((PyObject *)((void *)0));
  }
  {
#line 343
  tmp = cf_object_get_int_property(whoptr->obj, 90);
#line 343
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 343
  return (tmp___0);
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetMaxGrace(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 347
  if (! whoptr) {
    {
#line 347
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 347
    return ((PyObject *)((void *)0));
  } else
#line 347
  if (! whoptr->obj) {
    {
#line 347
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 347
    return ((PyObject *)((void *)0));
  } else
#line 347
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 347
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 347
    return ((PyObject *)((void *)0));
  } else
#line 347
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 347
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 347
    return ((PyObject *)((void *)0));
  }
  {
#line 348
  tmp = cf_object_get_int_property(whoptr->obj, 94);
#line 348
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 348
  return (tmp___0);
}
}
#line 351 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetFood(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 352
  if (! whoptr) {
    {
#line 352
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 352
    return ((PyObject *)((void *)0));
  } else
#line 352
  if (! whoptr->obj) {
    {
#line 352
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 352
    return ((PyObject *)((void *)0));
  } else
#line 352
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 352
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 352
    return ((PyObject *)((void *)0));
  } else
#line 352
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 352
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 352
    return ((PyObject *)((void *)0));
  }
  {
#line 353
  tmp = cf_object_get_int_property(whoptr->obj, 91);
#line 353
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 353
  return (tmp___0);
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetAC(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 357
  if (! whoptr) {
    {
#line 357
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 357
    return ((PyObject *)((void *)0));
  } else
#line 357
  if (! whoptr->obj) {
    {
#line 357
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 357
    return ((PyObject *)((void *)0));
  } else
#line 357
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 357
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 357
    return ((PyObject *)((void *)0));
  } else
#line 357
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 357
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 357
    return ((PyObject *)((void *)0));
  }
  {
#line 358
  tmp = cf_object_get_int_property(whoptr->obj, 87);
#line 358
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 358
  return (tmp___0);
}
}
#line 361 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetWC(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 362
  tmp = cf_object_get_int_property(whoptr->obj, 86);
#line 362
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 362
  return (tmp___0);
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetDam(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 366
  if (! whoptr) {
    {
#line 366
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 366
    return ((PyObject *)((void *)0));
  } else
#line 366
  if (! whoptr->obj) {
    {
#line 366
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 366
    return ((PyObject *)((void *)0));
  } else
#line 366
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 366
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 366
    return ((PyObject *)((void *)0));
  } else
#line 366
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 366
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 366
    return ((PyObject *)((void *)0));
  }
  {
#line 367
  tmp = cf_object_get_int_property(whoptr->obj, 95);
#line 367
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 367
  return (tmp___0);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetLuck(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 371
  if (! whoptr) {
    {
#line 371
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 371
    return ((PyObject *)((void *)0));
  } else
#line 371
  if (! whoptr->obj) {
    {
#line 371
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 371
    return ((PyObject *)((void *)0));
  } else
#line 371
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 371
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 371
    return ((PyObject *)((void *)0));
  } else
#line 371
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 371
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 371
    return ((PyObject *)((void *)0));
  }
  {
#line 372
  tmp = cf_object_get_int_property(whoptr->obj, 71);
#line 372
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 372
  return (tmp___0);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetMessage(Crossfire_Object *whoptr , void *closure ) 
{ 
  sstring tmp ;
  PyObject *tmp___0 ;

  {
#line 376
  if (! whoptr) {
    {
#line 376
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 376
    return ((PyObject *)((void *)0));
  } else
#line 376
  if (! whoptr->obj) {
    {
#line 376
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 376
    return ((PyObject *)((void *)0));
  } else
#line 376
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 376
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 376
    return ((PyObject *)((void *)0));
  } else
#line 376
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 376
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 376
    return ((PyObject *)((void *)0));
  }
  {
#line 377
  tmp = cf_object_get_sstring_property(whoptr->obj, 18);
#line 377
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 377
  return (tmp___0);
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetSkill(Crossfire_Object *whoptr , void *closure ) 
{ 
  sstring tmp ;
  PyObject *tmp___0 ;

  {
#line 381
  if (! whoptr) {
    {
#line 381
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 381
    return ((PyObject *)((void *)0));
  } else
#line 381
  if (! whoptr->obj) {
    {
#line 381
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 381
    return ((PyObject *)((void *)0));
  } else
#line 381
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 381
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 381
    return ((PyObject *)((void *)0));
  } else
#line 381
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 381
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 381
    return ((PyObject *)((void *)0));
  }
  {
#line 382
  tmp = cf_object_get_sstring_property(whoptr->obj, 17);
#line 382
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 382
  return (tmp___0);
}
}
#line 385 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetExp(Crossfire_Object *whoptr , void *closure ) 
{ 
  sint64 tmp ;
  PyObject *tmp___0 ;

  {
#line 386
  if (! whoptr) {
    {
#line 386
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 386
    return ((PyObject *)((void *)0));
  } else
#line 386
  if (! whoptr->obj) {
    {
#line 386
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 386
    return ((PyObject *)((void *)0));
  } else
#line 386
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 386
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 386
    return ((PyObject *)((void *)0));
  } else
#line 386
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 386
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 386
    return ((PyObject *)((void *)0));
  }
  {
#line 387
  tmp = cf_object_get_int64_property(whoptr->obj, 72);
#line 387
  tmp___0 = Py_BuildValue("L", tmp);
  }
#line 387
  return (tmp___0);
}
}
#line 390 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetPermExp(Crossfire_Object *whoptr , void *closure ) 
{ 
  sint64 tmp ;
  PyObject *tmp___0 ;

  {
#line 391
  if (! whoptr) {
    {
#line 391
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 391
    return ((PyObject *)((void *)0));
  } else
#line 391
  if (! whoptr->obj) {
    {
#line 391
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 391
    return ((PyObject *)((void *)0));
  } else
#line 391
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 391
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 391
    return ((PyObject *)((void *)0));
  } else
#line 391
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 391
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 391
    return ((PyObject *)((void *)0));
  }
  {
#line 392
  tmp = cf_object_get_int64_property(whoptr->obj, 52);
#line 392
  tmp___0 = Py_BuildValue("L", tmp);
  }
#line 392
  return (tmp___0);
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetExpMul(Crossfire_Object *whoptr , void *closure ) 
{ 
  double tmp ;
  PyObject *tmp___0 ;

  {
#line 396
  if (! whoptr) {
    {
#line 396
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 396
    return ((PyObject *)((void *)0));
  } else
#line 396
  if (! whoptr->obj) {
    {
#line 396
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 396
    return ((PyObject *)((void *)0));
  } else
#line 396
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 396
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 396
    return ((PyObject *)((void *)0));
  } else
#line 396
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 396
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 396
    return ((PyObject *)((void *)0));
  }
  {
#line 397
  tmp = cf_object_get_double_property(whoptr->obj, 62);
#line 397
  tmp___0 = Py_BuildValue("d", tmp);
  }
#line 397
  return (tmp___0);
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetSlaying(Crossfire_Object *whoptr , void *closure ) 
{ 
  sstring tmp ;
  PyObject *tmp___0 ;

  {
#line 401
  if (! whoptr) {
    {
#line 401
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 401
    return ((PyObject *)((void *)0));
  } else
#line 401
  if (! whoptr->obj) {
    {
#line 401
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 401
    return ((PyObject *)((void *)0));
  } else
#line 401
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 401
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 401
    return ((PyObject *)((void *)0));
  } else
#line 401
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 401
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 401
    return ((PyObject *)((void *)0));
  }
  {
#line 402
  tmp = cf_object_get_sstring_property(whoptr->obj, 16);
#line 402
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 402
  return (tmp___0);
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetCursed(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 406
  if (! whoptr) {
    {
#line 406
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 406
    return ((PyObject *)((void *)0));
  } else
#line 406
  if (! whoptr->obj) {
    {
#line 406
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 406
    return ((PyObject *)((void *)0));
  } else
#line 406
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 406
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 406
    return ((PyObject *)((void *)0));
  } else
#line 406
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 406
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 406
    return ((PyObject *)((void *)0));
  }
  {
#line 407
  tmp = cf_object_get_flag(whoptr->obj, 74);
#line 407
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 407
  return (tmp___0);
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetDamned(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 411
  if (! whoptr) {
    {
#line 411
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 411
    return ((PyObject *)((void *)0));
  } else
#line 411
  if (! whoptr->obj) {
    {
#line 411
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 411
    return ((PyObject *)((void *)0));
  } else
#line 411
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 411
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 411
    return ((PyObject *)((void *)0));
  } else
#line 411
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 411
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 411
    return ((PyObject *)((void *)0));
  }
  {
#line 412
  tmp = cf_object_get_flag(whoptr->obj, 75);
#line 412
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 412
  return (tmp___0);
}
}
#line 415 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetWeight(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 416
  if (! whoptr) {
    {
#line 416
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 416
    return ((PyObject *)((void *)0));
  } else
#line 416
  if (! whoptr->obj) {
    {
#line 416
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 416
    return ((PyObject *)((void *)0));
  } else
#line 416
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 416
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 416
    return ((PyObject *)((void *)0));
  } else
#line 416
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 416
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 416
    return ((PyObject *)((void *)0));
  }
  {
#line 417
  tmp = cf_object_get_int_property(whoptr->obj, 48);
#line 417
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 417
  return (tmp___0);
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetWeightLimit(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 421
  if (! whoptr) {
    {
#line 421
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 421
    return ((PyObject *)((void *)0));
  } else
#line 421
  if (! whoptr->obj) {
    {
#line 421
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 421
    return ((PyObject *)((void *)0));
  } else
#line 421
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 421
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 421
    return ((PyObject *)((void *)0));
  } else
#line 421
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 421
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 421
    return ((PyObject *)((void *)0));
  }
  {
#line 422
  tmp = cf_object_get_int_property(whoptr->obj, 49);
#line 422
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 422
  return (tmp___0);
}
}
#line 425 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetAbove(Crossfire_Object *whoptr , void *closure ) 
{ 
  object *op ;
  PyObject *tmp ;

  {
#line 428
  if (! whoptr) {
    {
#line 428
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 428
    return ((PyObject *)((void *)0));
  } else
#line 428
  if (! whoptr->obj) {
    {
#line 428
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 428
    return ((PyObject *)((void *)0));
  } else
#line 428
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 428
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 428
    return ((PyObject *)((void *)0));
  } else
#line 428
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 428
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 428
    return ((PyObject *)((void *)0));
  }
  {
#line 429
  op = cf_object_get_object_property(whoptr->obj, 1);
#line 430
  tmp = Crossfire_Object_wrap(op);
  }
#line 430
  return (tmp);
}
}
#line 433 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetBelow(Crossfire_Object *whoptr , void *closure ) 
{ 
  object *op ;
  PyObject *tmp ;

  {
#line 436
  if (! whoptr) {
    {
#line 436
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 436
    return ((PyObject *)((void *)0));
  } else
#line 436
  if (! whoptr->obj) {
    {
#line 436
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 436
    return ((PyObject *)((void *)0));
  } else
#line 436
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 436
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 436
    return ((PyObject *)((void *)0));
  } else
#line 436
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 436
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 436
    return ((PyObject *)((void *)0));
  }
  {
#line 437
  op = cf_object_get_object_property(whoptr->obj, 2);
#line 438
  tmp = Crossfire_Object_wrap(op);
  }
#line 438
  return (tmp);
}
}
#line 441 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetInventory(Crossfire_Object *whoptr , void *closure ) 
{ 
  object *op ;
  PyObject *tmp ;

  {
#line 444
  if (! whoptr) {
    {
#line 444
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 444
    return ((PyObject *)((void *)0));
  } else
#line 444
  if (! whoptr->obj) {
    {
#line 444
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 444
    return ((PyObject *)((void *)0));
  } else
#line 444
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 444
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 444
    return ((PyObject *)((void *)0));
  } else
#line 444
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 444
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 444
    return ((PyObject *)((void *)0));
  }
  {
#line 445
  op = cf_object_get_object_property(whoptr->obj, 5);
#line 446
  tmp = Crossfire_Object_wrap(op);
  }
#line 446
  return (tmp);
}
}
#line 449 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetX(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 450
  if (! whoptr) {
    {
#line 450
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 450
    return ((PyObject *)((void *)0));
  } else
#line 450
  if (! whoptr->obj) {
    {
#line 450
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 450
    return ((PyObject *)((void *)0));
  } else
#line 450
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 450
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 450
    return ((PyObject *)((void *)0));
  } else
#line 450
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 450
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 450
    return ((PyObject *)((void *)0));
  }
  {
#line 451
  tmp = cf_object_get_int_property(whoptr->obj, 20);
#line 451
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 451
  return (tmp___0);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetY(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 455
  if (! whoptr) {
    {
#line 455
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 455
    return ((PyObject *)((void *)0));
  } else
#line 455
  if (! whoptr->obj) {
    {
#line 455
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 455
    return ((PyObject *)((void *)0));
  } else
#line 455
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 455
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 455
    return ((PyObject *)((void *)0));
  } else
#line 455
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 455
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 455
    return ((PyObject *)((void *)0));
  }
  {
#line 456
  tmp = cf_object_get_int_property(whoptr->obj, 21);
#line 456
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 456
  return (tmp___0);
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetDirection(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 460
  if (! whoptr) {
    {
#line 460
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 460
    return ((PyObject *)((void *)0));
  } else
#line 460
  if (! whoptr->obj) {
    {
#line 460
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 460
    return ((PyObject *)((void *)0));
  } else
#line 460
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 460
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 460
    return ((PyObject *)((void *)0));
  } else
#line 460
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 460
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 460
    return ((PyObject *)((void *)0));
  }
  {
#line 461
  tmp = cf_object_get_int_property(whoptr->obj, 25);
#line 461
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 461
  return (tmp___0);
}
}
#line 464 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetFacing(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 465
  if (! whoptr) {
    {
#line 465
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 465
    return ((PyObject *)((void *)0));
  } else
#line 465
  if (! whoptr->obj) {
    {
#line 465
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 465
    return ((PyObject *)((void *)0));
  } else
#line 465
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 465
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 465
    return ((PyObject *)((void *)0));
  } else
#line 465
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 465
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 465
    return ((PyObject *)((void *)0));
  }
  {
#line 466
  tmp = cf_object_get_int_property(whoptr->obj, 26);
#line 466
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 466
  return (tmp___0);
}
}
#line 469 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetUnaggressive(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 470
  if (! whoptr) {
    {
#line 470
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 470
    return ((PyObject *)((void *)0));
  } else
#line 470
  if (! whoptr->obj) {
    {
#line 470
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 470
    return ((PyObject *)((void *)0));
  } else
#line 470
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 470
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 470
    return ((PyObject *)((void *)0));
  } else
#line 470
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 470
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 470
    return ((PyObject *)((void *)0));
  }
  {
#line 471
  tmp = cf_object_get_flag(whoptr->obj, 38);
#line 471
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 471
  return (tmp___0);
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetGod(Crossfire_Object *whoptr , void *closure ) 
{ 
  sstring tmp ;
  PyObject *tmp___0 ;

  {
#line 475
  if (! whoptr) {
    {
#line 475
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 475
    return ((PyObject *)((void *)0));
  } else
#line 475
  if (! whoptr->obj) {
    {
#line 475
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 475
    return ((PyObject *)((void *)0));
  } else
#line 475
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 475
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 475
    return ((PyObject *)((void *)0));
  } else
#line 475
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 475
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 475
    return ((PyObject *)((void *)0));
  }
  {
#line 476
  tmp = cf_object_get_sstring_property(whoptr->obj, 96);
#line 476
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 476
  return (tmp___0);
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetPickable(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  int tmp___0 ;
  PyObject *tmp___1 ;

  {
#line 480
  if (! whoptr) {
    {
#line 480
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 480
    return ((PyObject *)((void *)0));
  } else
#line 480
  if (! whoptr->obj) {
    {
#line 480
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 480
    return ((PyObject *)((void *)0));
  } else
#line 480
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 480
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 480
    return ((PyObject *)((void *)0));
  } else
#line 480
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 480
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 480
    return ((PyObject *)((void *)0));
  }
  {
#line 481
  tmp = cf_object_get_flag(whoptr->obj, 8);
  }
#line 481
  if (tmp) {
#line 481
    tmp___0 = 0;
  } else {
#line 481
    tmp___0 = 1;
  }
  {
#line 481
  tmp___1 = Py_BuildValue("i", tmp___0);
  }
#line 481
  return (tmp___1);
}
}
#line 484 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetQuantity(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 485
  if (! whoptr) {
    {
#line 485
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 485
    return ((PyObject *)((void *)0));
  } else
#line 485
  if (! whoptr->obj) {
    {
#line 485
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 485
    return ((PyObject *)((void *)0));
  } else
#line 485
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 485
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 485
    return ((PyObject *)((void *)0));
  } else
#line 485
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 485
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 485
    return ((PyObject *)((void *)0));
  }
  {
#line 486
  tmp = cf_object_get_int_property(whoptr->obj, 24);
#line 486
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 486
  return (tmp___0);
}
}
#line 489 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetInvisible(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 490
  if (! whoptr) {
    {
#line 490
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 490
    return ((PyObject *)((void *)0));
  } else
#line 490
  if (! whoptr->obj) {
    {
#line 490
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 490
    return ((PyObject *)((void *)0));
  } else
#line 490
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 490
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 490
    return ((PyObject *)((void *)0));
  } else
#line 490
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 490
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 490
    return ((PyObject *)((void *)0));
  }
  {
#line 491
  tmp = cf_object_get_int_property(whoptr->obj, 98);
#line 491
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 491
  return (tmp___0);
}
}
#line 494 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetSpeed(Crossfire_Object *whoptr , void *closure ) 
{ 
  float tmp ;
  PyObject *tmp___0 ;

  {
#line 495
  if (! whoptr) {
    {
#line 495
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 495
    return ((PyObject *)((void *)0));
  } else
#line 495
  if (! whoptr->obj) {
    {
#line 495
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 495
    return ((PyObject *)((void *)0));
  } else
#line 495
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 495
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 495
    return ((PyObject *)((void *)0));
  } else
#line 495
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 495
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 495
    return ((PyObject *)((void *)0));
  }
  {
#line 496
  tmp = cf_object_get_float_property(whoptr->obj, 22);
#line 496
  tmp___0 = Py_BuildValue("f", (double )tmp);
  }
#line 496
  return (tmp___0);
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetSpeedLeft(Crossfire_Object *whoptr , void *closure ) 
{ 
  float tmp ;
  PyObject *tmp___0 ;

  {
#line 500
  if (! whoptr) {
    {
#line 500
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 500
    return ((PyObject *)((void *)0));
  } else
#line 500
  if (! whoptr->obj) {
    {
#line 500
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 500
    return ((PyObject *)((void *)0));
  } else
#line 500
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 500
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 500
    return ((PyObject *)((void *)0));
  } else
#line 500
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 500
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 500
    return ((PyObject *)((void *)0));
  }
  {
#line 501
  tmp = cf_object_get_float_property(whoptr->obj, 23);
#line 501
  tmp___0 = Py_BuildValue("f", (double )tmp);
  }
#line 501
  return (tmp___0);
}
}
#line 504 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetLastSP(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 505
  if (! whoptr) {
    {
#line 505
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 505
    return ((PyObject *)((void *)0));
  } else
#line 505
  if (! whoptr->obj) {
    {
#line 505
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 505
    return ((PyObject *)((void *)0));
  } else
#line 505
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 505
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 505
    return ((PyObject *)((void *)0));
  } else
#line 505
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 505
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 505
    return ((PyObject *)((void *)0));
  }
  {
#line 506
  tmp = cf_object_get_int_property(whoptr->obj, 41);
#line 506
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 506
  return (tmp___0);
}
}
#line 509 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetLastGrace(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 510
  if (! whoptr) {
    {
#line 510
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 510
    return ((PyObject *)((void *)0));
  } else
#line 510
  if (! whoptr->obj) {
    {
#line 510
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 510
    return ((PyObject *)((void *)0));
  } else
#line 510
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 510
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 510
    return ((PyObject *)((void *)0));
  } else
#line 510
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 510
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 510
    return ((PyObject *)((void *)0));
  }
  {
#line 511
  tmp = cf_object_get_int_property(whoptr->obj, 42);
#line 511
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 511
  return (tmp___0);
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetLastEat(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 515
  if (! whoptr) {
    {
#line 515
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 515
    return ((PyObject *)((void *)0));
  } else
#line 515
  if (! whoptr->obj) {
    {
#line 515
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 515
    return ((PyObject *)((void *)0));
  } else
#line 515
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 515
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 515
    return ((PyObject *)((void *)0));
  } else
#line 515
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 515
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 515
    return ((PyObject *)((void *)0));
  }
  {
#line 516
  tmp = cf_object_get_int_property(whoptr->obj, 43);
#line 516
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 516
  return (tmp___0);
}
}
#line 519 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetLevel(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 520
  if (! whoptr) {
    {
#line 520
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 520
    return ((PyObject *)((void *)0));
  } else
#line 520
  if (! whoptr->obj) {
    {
#line 520
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 520
    return ((PyObject *)((void *)0));
  } else
#line 520
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 520
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 520
    return ((PyObject *)((void *)0));
  } else
#line 520
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 520
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 520
    return ((PyObject *)((void *)0));
  }
  {
#line 521
  tmp = cf_object_get_int_property(whoptr->obj, 39);
#line 521
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 521
  return (tmp___0);
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetFace(Crossfire_Object *whoptr , void *closure ) 
{ 
  char buf[200] ;
  char *tmp ;
  PyObject *tmp___0 ;

  {
#line 526
  if (! whoptr) {
    {
#line 526
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 526
    return ((PyObject *)((void *)0));
  } else
#line 526
  if (! whoptr->obj) {
    {
#line 526
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 526
    return ((PyObject *)((void *)0));
  } else
#line 526
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 526
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 526
    return ((PyObject *)((void *)0));
  } else
#line 526
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 526
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 526
    return ((PyObject *)((void *)0));
  }
  {
#line 527
  tmp = cf_object_get_string_property(whoptr->obj, 99, buf, (int )sizeof(buf));
#line 527
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 527
  return (tmp___0);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetAnim(Crossfire_Object *whoptr , void *closure ) 
{ 
  char buf[200] ;
  char *tmp ;
  PyObject *tmp___0 ;

  {
#line 532
  if (! whoptr) {
    {
#line 532
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 532
    return ((PyObject *)((void *)0));
  } else
#line 532
  if (! whoptr->obj) {
    {
#line 532
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 532
    return ((PyObject *)((void *)0));
  } else
#line 532
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 532
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 532
    return ((PyObject *)((void *)0));
  } else
#line 532
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 532
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 532
    return ((PyObject *)((void *)0));
  }
  {
#line 533
  tmp = cf_object_get_string_property(whoptr->obj, 100, buf, (int )sizeof(buf));
#line 533
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 533
  return (tmp___0);
}
}
#line 536 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetAnimSpeed(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 537
  if (! whoptr) {
    {
#line 537
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 537
    return ((PyObject *)((void *)0));
  } else
#line 537
  if (! whoptr->obj) {
    {
#line 537
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 537
    return ((PyObject *)((void *)0));
  } else
#line 537
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 537
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 537
    return ((PyObject *)((void *)0));
  } else
#line 537
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 537
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 537
    return ((PyObject *)((void *)0));
  }
  {
#line 538
  tmp = cf_object_get_int_property(whoptr->obj, 66);
#line 538
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 538
  return (tmp___0);
}
}
#line 541 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetAttackType(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 542
  if (! whoptr) {
    {
#line 542
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 542
    return ((PyObject *)((void *)0));
  } else
#line 542
  if (! whoptr->obj) {
    {
#line 542
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 542
    return ((PyObject *)((void *)0));
  } else
#line 542
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 542
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 542
    return ((PyObject *)((void *)0));
  } else
#line 542
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 542
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 542
    return ((PyObject *)((void *)0));
  }
  {
#line 543
  tmp = cf_object_get_int_property(whoptr->obj, 31);
#line 543
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 543
  return (tmp___0);
}
}
#line 546 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetBeenApplied(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 547
  if (! whoptr) {
    {
#line 547
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 547
    return ((PyObject *)((void *)0));
  } else
#line 547
  if (! whoptr->obj) {
    {
#line 547
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 547
    return ((PyObject *)((void *)0));
  } else
#line 547
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 547
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 547
    return ((PyObject *)((void *)0));
  } else
#line 547
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 547
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 547
    return ((PyObject *)((void *)0));
  }
  {
#line 548
  tmp = cf_object_get_flag(whoptr->obj, 80);
#line 548
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 548
  return (tmp___0);
}
}
#line 551 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetIdentified(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 552
  if (! whoptr) {
    {
#line 552
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 552
    return ((PyObject *)((void *)0));
  } else
#line 552
  if (! whoptr->obj) {
    {
#line 552
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 552
    return ((PyObject *)((void *)0));
  } else
#line 552
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 552
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 552
    return ((PyObject *)((void *)0));
  } else
#line 552
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 552
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 552
    return ((PyObject *)((void *)0));
  }
  {
#line 553
  tmp = cf_object_get_flag(whoptr->obj, 29);
#line 553
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 553
  return (tmp___0);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetAlive(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 557
  if (! whoptr) {
    {
#line 557
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 557
    return ((PyObject *)((void *)0));
  } else
#line 557
  if (! whoptr->obj) {
    {
#line 557
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 557
    return ((PyObject *)((void *)0));
  } else
#line 557
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 557
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 557
    return ((PyObject *)((void *)0));
  } else
#line 557
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 557
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 557
    return ((PyObject *)((void *)0));
  }
  {
#line 558
  tmp = cf_object_get_flag(whoptr->obj, 0);
#line 558
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 558
  return (tmp___0);
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetDM(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 562
  if (! whoptr) {
    {
#line 562
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 562
    return ((PyObject *)((void *)0));
  } else
#line 562
  if (! whoptr->obj) {
    {
#line 562
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 562
    return ((PyObject *)((void *)0));
  } else
#line 562
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 562
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 562
    return ((PyObject *)((void *)0));
  } else
#line 562
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 562
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 562
    return ((PyObject *)((void *)0));
  }
  {
#line 563
  tmp = cf_object_get_flag(whoptr->obj, 1);
#line 563
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 563
  return (tmp___0);
}
}
#line 566 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetWasDM(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 567
  if (! whoptr) {
    {
#line 567
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 567
    return ((PyObject *)((void *)0));
  } else
#line 567
  if (! whoptr->obj) {
    {
#line 567
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 567
    return ((PyObject *)((void *)0));
  } else
#line 567
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 567
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 567
    return ((PyObject *)((void *)0));
  } else
#line 567
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 567
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 567
    return ((PyObject *)((void *)0));
  }
  {
#line 568
  tmp = cf_object_get_flag(whoptr->obj, 4);
#line 568
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 568
  return (tmp___0);
}
}
#line 571 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetApplied(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 572
  if (! whoptr) {
    {
#line 572
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 572
    return ((PyObject *)((void *)0));
  } else
#line 572
  if (! whoptr->obj) {
    {
#line 572
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 572
    return ((PyObject *)((void *)0));
  } else
#line 572
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 572
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 572
    return ((PyObject *)((void *)0));
  } else
#line 572
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 572
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 572
    return ((PyObject *)((void *)0));
  }
  {
#line 573
  tmp = cf_object_get_flag(whoptr->obj, 5);
#line 573
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 573
  return (tmp___0);
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetUnpaid(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 577
  if (! whoptr) {
    {
#line 577
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 577
    return ((PyObject *)((void *)0));
  } else
#line 577
  if (! whoptr->obj) {
    {
#line 577
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 577
    return ((PyObject *)((void *)0));
  } else
#line 577
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 577
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 577
    return ((PyObject *)((void *)0));
  } else
#line 577
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 577
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 577
    return ((PyObject *)((void *)0));
  }
  {
#line 578
  tmp = cf_object_get_flag(whoptr->obj, 6);
#line 578
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 578
  return (tmp___0);
}
}
#line 581 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetMonster(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 582
  if (! whoptr) {
    {
#line 582
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 582
    return ((PyObject *)((void *)0));
  } else
#line 582
  if (! whoptr->obj) {
    {
#line 582
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 582
    return ((PyObject *)((void *)0));
  } else
#line 582
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 582
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 582
    return ((PyObject *)((void *)0));
  } else
#line 582
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 582
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 582
    return ((PyObject *)((void *)0));
  }
  {
#line 583
  tmp = cf_object_get_flag(whoptr->obj, 14);
#line 583
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 583
  return (tmp___0);
}
}
#line 586 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetFriendly(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 587
  if (! whoptr) {
    {
#line 587
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 587
    return ((PyObject *)((void *)0));
  } else
#line 587
  if (! whoptr->obj) {
    {
#line 587
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 587
    return ((PyObject *)((void *)0));
  } else
#line 587
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 587
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 587
    return ((PyObject *)((void *)0));
  } else
#line 587
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 587
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 587
    return ((PyObject *)((void *)0));
  }
  {
#line 588
  tmp = cf_object_get_flag(whoptr->obj, 15);
#line 588
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 588
  return (tmp___0);
}
}
#line 591 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetGenerator(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 592
  if (! whoptr) {
    {
#line 592
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 592
    return ((PyObject *)((void *)0));
  } else
#line 592
  if (! whoptr->obj) {
    {
#line 592
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 592
    return ((PyObject *)((void *)0));
  } else
#line 592
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 592
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 592
    return ((PyObject *)((void *)0));
  } else
#line 592
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 592
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 592
    return ((PyObject *)((void *)0));
  }
  {
#line 593
  tmp = cf_object_get_flag(whoptr->obj, 16);
#line 593
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 593
  return (tmp___0);
}
}
#line 596 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetThrown(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 597
  if (! whoptr) {
    {
#line 597
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 597
    return ((PyObject *)((void *)0));
  } else
#line 597
  if (! whoptr->obj) {
    {
#line 597
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 597
    return ((PyObject *)((void *)0));
  } else
#line 597
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 597
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 597
    return ((PyObject *)((void *)0));
  } else
#line 597
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 597
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 597
    return ((PyObject *)((void *)0));
  }
  {
#line 598
  tmp = cf_object_get_flag(whoptr->obj, 17);
#line 598
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 598
  return (tmp___0);
}
}
#line 601 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetCanSeeInvisible(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 602
  if (! whoptr) {
    {
#line 602
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 602
    return ((PyObject *)((void *)0));
  } else
#line 602
  if (! whoptr->obj) {
    {
#line 602
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 602
    return ((PyObject *)((void *)0));
  } else
#line 602
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 602
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 602
    return ((PyObject *)((void *)0));
  } else
#line 602
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 602
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 602
    return ((PyObject *)((void *)0));
  }
  {
#line 603
  tmp = cf_object_get_flag(whoptr->obj, 21);
#line 603
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 603
  return (tmp___0);
}
}
#line 606 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetRollable(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 607
  if (! whoptr) {
    {
#line 607
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 607
    return ((PyObject *)((void *)0));
  } else
#line 607
  if (! whoptr->obj) {
    {
#line 607
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 607
    return ((PyObject *)((void *)0));
  } else
#line 607
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 607
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 607
    return ((PyObject *)((void *)0));
  } else
#line 607
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 607
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 607
    return ((PyObject *)((void *)0));
  }
  {
#line 608
  tmp = cf_object_get_flag(whoptr->obj, 22);
#line 608
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 608
  return (tmp___0);
}
}
#line 611 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetTurnable(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 612
  if (! whoptr) {
    {
#line 612
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 612
    return ((PyObject *)((void *)0));
  } else
#line 612
  if (! whoptr->obj) {
    {
#line 612
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 612
    return ((PyObject *)((void *)0));
  } else
#line 612
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 612
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 612
    return ((PyObject *)((void *)0));
  } else
#line 612
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 612
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 612
    return ((PyObject *)((void *)0));
  }
  {
#line 613
  tmp = cf_object_get_flag(whoptr->obj, 24);
#line 613
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 613
  return (tmp___0);
}
}
#line 616 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetUsedUp(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 617
  if (! whoptr) {
    {
#line 617
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 617
    return ((PyObject *)((void *)0));
  } else
#line 617
  if (! whoptr->obj) {
    {
#line 617
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 617
    return ((PyObject *)((void *)0));
  } else
#line 617
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 617
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 617
    return ((PyObject *)((void *)0));
  } else
#line 617
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 617
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 617
    return ((PyObject *)((void *)0));
  }
  {
#line 618
  tmp = cf_object_get_flag(whoptr->obj, 28);
#line 618
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 618
  return (tmp___0);
}
}
#line 621 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetSplitting(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 622
  if (! whoptr) {
    {
#line 622
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 622
    return ((PyObject *)((void *)0));
  } else
#line 622
  if (! whoptr->obj) {
    {
#line 622
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 622
    return ((PyObject *)((void *)0));
  } else
#line 622
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 622
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 622
    return ((PyObject *)((void *)0));
  } else
#line 622
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 622
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 622
    return ((PyObject *)((void *)0));
  }
  {
#line 623
  tmp = cf_object_get_flag(whoptr->obj, 32);
#line 623
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 623
  return (tmp___0);
}
}
#line 626 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetBlind(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 627
  if (! whoptr) {
    {
#line 627
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 627
    return ((PyObject *)((void *)0));
  } else
#line 627
  if (! whoptr->obj) {
    {
#line 627
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 627
    return ((PyObject *)((void *)0));
  } else
#line 627
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 627
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 627
    return ((PyObject *)((void *)0));
  } else
#line 627
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 627
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 627
    return ((PyObject *)((void *)0));
  }
  {
#line 628
  tmp = cf_object_get_flag(whoptr->obj, 92);
#line 628
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 628
  return (tmp___0);
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetCanUseSkill(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 632
  if (! whoptr) {
    {
#line 632
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 632
    return ((PyObject *)((void *)0));
  } else
#line 632
  if (! whoptr->obj) {
    {
#line 632
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 632
    return ((PyObject *)((void *)0));
  } else
#line 632
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 632
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 632
    return ((PyObject *)((void *)0));
  } else
#line 632
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 632
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 632
    return ((PyObject *)((void *)0));
  }
  {
#line 633
  tmp = cf_object_get_flag(whoptr->obj, 79);
#line 633
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 633
  return (tmp___0);
}
}
#line 636 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetKnownCursed(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 637
  if (! whoptr) {
    {
#line 637
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 637
    return ((PyObject *)((void *)0));
  } else
#line 637
  if (! whoptr->obj) {
    {
#line 637
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 637
    return ((PyObject *)((void *)0));
  } else
#line 637
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 637
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 637
    return ((PyObject *)((void *)0));
  } else
#line 637
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 637
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 637
    return ((PyObject *)((void *)0));
  }
  {
#line 638
  tmp = cf_object_get_flag(whoptr->obj, 78);
#line 638
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 638
  return (tmp___0);
}
}
#line 641 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetStealthy(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 642
  if (! whoptr) {
    {
#line 642
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 642
    return ((PyObject *)((void *)0));
  } else
#line 642
  if (! whoptr->obj) {
    {
#line 642
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 642
    return ((PyObject *)((void *)0));
  } else
#line 642
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 642
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 642
    return ((PyObject *)((void *)0));
  } else
#line 642
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 642
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 642
    return ((PyObject *)((void *)0));
  }
  {
#line 643
  tmp = cf_object_get_flag(whoptr->obj, 71);
#line 643
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 643
  return (tmp___0);
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetConfused(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 647
  if (! whoptr) {
    {
#line 647
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 647
    return ((PyObject *)((void *)0));
  } else
#line 647
  if (! whoptr->obj) {
    {
#line 647
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 647
    return ((PyObject *)((void *)0));
  } else
#line 647
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 647
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 647
    return ((PyObject *)((void *)0));
  } else
#line 647
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 647
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 647
    return ((PyObject *)((void *)0));
  }
  {
#line 648
  tmp = cf_object_get_flag(whoptr->obj, 70);
#line 648
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 648
  return (tmp___0);
}
}
#line 651 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetSleeping(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 652
  if (! whoptr) {
    {
#line 652
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 652
    return ((PyObject *)((void *)0));
  } else
#line 652
  if (! whoptr->obj) {
    {
#line 652
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 652
    return ((PyObject *)((void *)0));
  } else
#line 652
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 652
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 652
    return ((PyObject *)((void *)0));
  } else
#line 652
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 652
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 652
    return ((PyObject *)((void *)0));
  }
  {
#line 653
  tmp = cf_object_get_flag(whoptr->obj, 66);
#line 653
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 653
  return (tmp___0);
}
}
#line 656 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetLifesaver(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 657
  if (! whoptr) {
    {
#line 657
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 657
    return ((PyObject *)((void *)0));
  } else
#line 657
  if (! whoptr->obj) {
    {
#line 657
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 657
    return ((PyObject *)((void *)0));
  } else
#line 657
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 657
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 657
    return ((PyObject *)((void *)0));
  } else
#line 657
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 657
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 657
    return ((PyObject *)((void *)0));
  }
  {
#line 658
  tmp = cf_object_get_flag(whoptr->obj, 64);
#line 658
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 658
  return (tmp___0);
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetFloor(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 662
  if (! whoptr) {
    {
#line 662
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 662
    return ((PyObject *)((void *)0));
  } else
#line 662
  if (! whoptr->obj) {
    {
#line 662
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 662
    return ((PyObject *)((void *)0));
  } else
#line 662
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 662
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 662
    return ((PyObject *)((void *)0));
  } else
#line 662
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 662
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 662
    return ((PyObject *)((void *)0));
  }
  {
#line 663
  tmp = cf_object_get_flag(whoptr->obj, 63);
#line 663
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 663
  return (tmp___0);
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetHasXRays(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 667
  if (! whoptr) {
    {
#line 667
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 667
    return ((PyObject *)((void *)0));
  } else
#line 667
  if (! whoptr->obj) {
    {
#line 667
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 667
    return ((PyObject *)((void *)0));
  } else
#line 667
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 667
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 667
    return ((PyObject *)((void *)0));
  } else
#line 667
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 667
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 667
    return ((PyObject *)((void *)0));
  }
  {
#line 668
  tmp = cf_object_get_flag(whoptr->obj, 61);
#line 668
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 668
  return (tmp___0);
}
}
#line 671 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetCanUseRing(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 672
  if (! whoptr) {
    {
#line 672
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 672
    return ((PyObject *)((void *)0));
  } else
#line 672
  if (! whoptr->obj) {
    {
#line 672
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 672
    return ((PyObject *)((void *)0));
  } else
#line 672
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 672
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 672
    return ((PyObject *)((void *)0));
  } else
#line 672
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 672
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 672
    return ((PyObject *)((void *)0));
  }
  {
#line 673
  tmp = cf_object_get_flag(whoptr->obj, 58);
#line 673
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 673
  return (tmp___0);
}
}
#line 676 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetCanUseBow(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 677
  if (! whoptr) {
    {
#line 677
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 677
    return ((PyObject *)((void *)0));
  } else
#line 677
  if (! whoptr->obj) {
    {
#line 677
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 677
    return ((PyObject *)((void *)0));
  } else
#line 677
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 677
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 677
    return ((PyObject *)((void *)0));
  } else
#line 677
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 677
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 677
    return ((PyObject *)((void *)0));
  }
  {
#line 678
  tmp = cf_object_get_flag(whoptr->obj, 55);
#line 678
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 678
  return (tmp___0);
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetCanUseWand(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 682
  if (! whoptr) {
    {
#line 682
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 682
    return ((PyObject *)((void *)0));
  } else
#line 682
  if (! whoptr->obj) {
    {
#line 682
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 682
    return ((PyObject *)((void *)0));
  } else
#line 682
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 682
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 682
    return ((PyObject *)((void *)0));
  } else
#line 682
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 682
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 682
    return ((PyObject *)((void *)0));
  }
  {
#line 683
  tmp = cf_object_get_flag(whoptr->obj, 54);
#line 683
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 683
  return (tmp___0);
}
}
#line 686 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetCanSeeInDark(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 687
  if (! whoptr) {
    {
#line 687
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 687
    return ((PyObject *)((void *)0));
  } else
#line 687
  if (! whoptr->obj) {
    {
#line 687
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 687
    return ((PyObject *)((void *)0));
  } else
#line 687
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 687
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 687
    return ((PyObject *)((void *)0));
  } else
#line 687
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 687
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 687
    return ((PyObject *)((void *)0));
  }
  {
#line 688
  tmp = cf_object_get_flag(whoptr->obj, 93);
#line 688
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 688
  return (tmp___0);
}
}
#line 691 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetKnownMagical(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 692
  if (! whoptr) {
    {
#line 692
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 692
    return ((PyObject *)((void *)0));
  } else
#line 692
  if (! whoptr->obj) {
    {
#line 692
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 692
    return ((PyObject *)((void *)0));
  } else
#line 692
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 692
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 692
    return ((PyObject *)((void *)0));
  } else
#line 692
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 692
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 692
    return ((PyObject *)((void *)0));
  }
  {
#line 693
  tmp = cf_object_get_flag(whoptr->obj, 77);
#line 693
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 693
  return (tmp___0);
}
}
#line 696 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetCanUseWeapon(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 697
  if (! whoptr) {
    {
#line 697
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 697
    return ((PyObject *)((void *)0));
  } else
#line 697
  if (! whoptr->obj) {
    {
#line 697
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 697
    return ((PyObject *)((void *)0));
  } else
#line 697
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 697
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 697
    return ((PyObject *)((void *)0));
  } else
#line 697
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 697
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 697
    return ((PyObject *)((void *)0));
  }
  {
#line 698
  tmp = cf_object_get_flag(whoptr->obj, 57);
#line 698
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 698
  return (tmp___0);
}
}
#line 701 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetCanUseArmour(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 702
  if (! whoptr) {
    {
#line 702
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 702
    return ((PyObject *)((void *)0));
  } else
#line 702
  if (! whoptr->obj) {
    {
#line 702
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 702
    return ((PyObject *)((void *)0));
  } else
#line 702
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 702
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 702
    return ((PyObject *)((void *)0));
  } else
#line 702
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 702
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 702
    return ((PyObject *)((void *)0));
  }
  {
#line 703
  tmp = cf_object_get_flag(whoptr->obj, 56);
#line 703
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 703
  return (tmp___0);
}
}
#line 706 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetCanUseScroll(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 707
  if (! whoptr) {
    {
#line 707
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 707
    return ((PyObject *)((void *)0));
  } else
#line 707
  if (! whoptr->obj) {
    {
#line 707
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 707
    return ((PyObject *)((void *)0));
  } else
#line 707
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 707
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 707
    return ((PyObject *)((void *)0));
  } else
#line 707
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 707
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 707
    return ((PyObject *)((void *)0));
  }
  {
#line 708
  tmp = cf_object_get_flag(whoptr->obj, 53);
#line 708
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 708
  return (tmp___0);
}
}
#line 711 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetCanCastSpell(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 712
  if (! whoptr) {
    {
#line 712
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 712
    return ((PyObject *)((void *)0));
  } else
#line 712
  if (! whoptr->obj) {
    {
#line 712
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 712
    return ((PyObject *)((void *)0));
  } else
#line 712
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 712
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 712
    return ((PyObject *)((void *)0));
  } else
#line 712
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 712
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 712
    return ((PyObject *)((void *)0));
  }
  {
#line 713
  tmp = cf_object_get_flag(whoptr->obj, 52);
#line 713
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 713
  return (tmp___0);
}
}
#line 716 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetReflectSpells(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 717
  if (! whoptr) {
    {
#line 717
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 717
    return ((PyObject *)((void *)0));
  } else
#line 717
  if (! whoptr->obj) {
    {
#line 717
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 717
    return ((PyObject *)((void *)0));
  } else
#line 717
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 717
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 717
    return ((PyObject *)((void *)0));
  } else
#line 717
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 717
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 717
    return ((PyObject *)((void *)0));
  }
  {
#line 718
  tmp = cf_object_get_flag(whoptr->obj, 40);
#line 718
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 718
  return (tmp___0);
}
}
#line 721 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetReflectMissiles(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 722
  if (! whoptr) {
    {
#line 722
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 722
    return ((PyObject *)((void *)0));
  } else
#line 722
  if (! whoptr->obj) {
    {
#line 722
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 722
    return ((PyObject *)((void *)0));
  } else
#line 722
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 722
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 722
    return ((PyObject *)((void *)0));
  } else
#line 722
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 722
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 722
    return ((PyObject *)((void *)0));
  }
  {
#line 723
  tmp = cf_object_get_flag(whoptr->obj, 39);
#line 723
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 723
  return (tmp___0);
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetUnique(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 727
  if (! whoptr) {
    {
#line 727
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 727
    return ((PyObject *)((void *)0));
  } else
#line 727
  if (! whoptr->obj) {
    {
#line 727
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 727
    return ((PyObject *)((void *)0));
  } else
#line 727
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 727
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 727
    return ((PyObject *)((void *)0));
  } else
#line 727
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 727
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 727
    return ((PyObject *)((void *)0));
  }
  {
#line 728
  tmp = cf_object_get_flag(whoptr->obj, 49);
#line 728
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 728
  return (tmp___0);
}
}
#line 731 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetRunAway(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 732
  if (! whoptr) {
    {
#line 732
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 732
    return ((PyObject *)((void *)0));
  } else
#line 732
  if (! whoptr->obj) {
    {
#line 732
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 732
    return ((PyObject *)((void *)0));
  } else
#line 732
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 732
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 732
    return ((PyObject *)((void *)0));
  } else
#line 732
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 732
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 732
    return ((PyObject *)((void *)0));
  }
  {
#line 733
  tmp = cf_object_get_flag(whoptr->obj, 45);
#line 733
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 733
  return (tmp___0);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetScared(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 737
  if (! whoptr) {
    {
#line 737
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 737
    return ((PyObject *)((void *)0));
  } else
#line 737
  if (! whoptr->obj) {
    {
#line 737
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 737
    return ((PyObject *)((void *)0));
  } else
#line 737
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 737
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 737
    return ((PyObject *)((void *)0));
  } else
#line 737
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 737
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 737
    return ((PyObject *)((void *)0));
  }
  {
#line 738
  tmp = cf_object_get_flag(whoptr->obj, 37);
#line 738
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 738
  return (tmp___0);
}
}
#line 741 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetUndead(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 742
  if (! whoptr) {
    {
#line 742
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 742
    return ((PyObject *)((void *)0));
  } else
#line 742
  if (! whoptr->obj) {
    {
#line 742
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 742
    return ((PyObject *)((void *)0));
  } else
#line 742
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 742
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 742
    return ((PyObject *)((void *)0));
  } else
#line 742
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 742
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 742
    return ((PyObject *)((void *)0));
  }
  {
#line 743
  tmp = cf_object_get_flag(whoptr->obj, 36);
#line 743
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 743
  return (tmp___0);
}
}
#line 746 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetBlocksView(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 747
  if (! whoptr) {
    {
#line 747
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 747
    return ((PyObject *)((void *)0));
  } else
#line 747
  if (! whoptr->obj) {
    {
#line 747
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 747
    return ((PyObject *)((void *)0));
  } else
#line 747
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 747
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 747
    return ((PyObject *)((void *)0));
  } else
#line 747
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 747
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 747
    return ((PyObject *)((void *)0));
  }
  {
#line 748
  tmp = cf_object_get_flag(whoptr->obj, 35);
#line 748
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 748
  return (tmp___0);
}
}
#line 751 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetHitBack(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 752
  if (! whoptr) {
    {
#line 752
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 752
    return ((PyObject *)((void *)0));
  } else
#line 752
  if (! whoptr->obj) {
    {
#line 752
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 752
    return ((PyObject *)((void *)0));
  } else
#line 752
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 752
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 752
    return ((PyObject *)((void *)0));
  } else
#line 752
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 752
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 752
    return ((PyObject *)((void *)0));
  }
  {
#line 753
  tmp = cf_object_get_flag(whoptr->obj, 33);
#line 753
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 753
  return (tmp___0);
}
}
#line 756 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetStandStill(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 757
  if (! whoptr) {
    {
#line 757
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 757
    return ((PyObject *)((void *)0));
  } else
#line 757
  if (! whoptr->obj) {
    {
#line 757
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 757
    return ((PyObject *)((void *)0));
  } else
#line 757
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 757
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 757
    return ((PyObject *)((void *)0));
  } else
#line 757
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 757
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 757
    return ((PyObject *)((void *)0));
  }
  {
#line 758
  tmp = cf_object_get_flag(whoptr->obj, 67);
#line 758
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 758
  return (tmp___0);
}
}
#line 761 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetOnlyAttack(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 762
  if (! whoptr) {
    {
#line 762
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 762
    return ((PyObject *)((void *)0));
  } else
#line 762
  if (! whoptr->obj) {
    {
#line 762
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 762
    return ((PyObject *)((void *)0));
  } else
#line 762
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 762
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 762
    return ((PyObject *)((void *)0));
  } else
#line 762
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 762
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 762
    return ((PyObject *)((void *)0));
  }
  {
#line 763
  tmp = cf_object_get_flag(whoptr->obj, 69);
#line 763
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 763
  return (tmp___0);
}
}
#line 766 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetMakeInvisible(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 767
  if (! whoptr) {
    {
#line 767
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 767
    return ((PyObject *)((void *)0));
  } else
#line 767
  if (! whoptr->obj) {
    {
#line 767
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 767
    return ((PyObject *)((void *)0));
  } else
#line 767
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 767
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 767
    return ((PyObject *)((void *)0));
  } else
#line 767
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 767
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 767
    return ((PyObject *)((void *)0));
  }
  {
#line 768
  tmp = cf_object_get_flag(whoptr->obj, 85);
#line 768
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 768
  return (tmp___0);
}
}
#line 771 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetMoney(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 772
  if (! whoptr) {
    {
#line 772
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 772
    return ((PyObject *)((void *)0));
  } else
#line 772
  if (! whoptr->obj) {
    {
#line 772
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 772
    return ((PyObject *)((void *)0));
  } else
#line 772
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 772
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 772
    return ((PyObject *)((void *)0));
  } else
#line 772
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 772
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 772
    return ((PyObject *)((void *)0));
  }
  {
#line 773
  tmp = cf_object_query_money((object const   *)whoptr->obj);
#line 773
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 773
  return (tmp___0);
}
}
#line 776 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetType(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 777
  if (! whoptr) {
    {
#line 777
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 777
    return ((PyObject *)((void *)0));
  } else
#line 777
  if (! whoptr->obj) {
    {
#line 777
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 777
    return ((PyObject *)((void *)0));
  } else
#line 777
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 777
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 777
    return ((PyObject *)((void *)0));
  } else
#line 777
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 777
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 777
    return ((PyObject *)((void *)0));
  }
  {
#line 778
  tmp = cf_object_get_int_property(whoptr->obj, 27);
#line 778
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 778
  return (tmp___0);
}
}
#line 781 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetSubtype(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 782
  if (! whoptr) {
    {
#line 782
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 782
    return ((PyObject *)((void *)0));
  } else
#line 782
  if (! whoptr->obj) {
    {
#line 782
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 782
    return ((PyObject *)((void *)0));
  } else
#line 782
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 782
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 782
    return ((PyObject *)((void *)0));
  } else
#line 782
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 782
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 782
    return ((PyObject *)((void *)0));
  }
  {
#line 783
  tmp = cf_object_get_int_property(whoptr->obj, 28);
#line 783
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 783
  return (tmp___0);
}
}
#line 786 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetValue(Crossfire_Object *whoptr , void *closure ) 
{ 
  long tmp ;
  PyObject *tmp___0 ;

  {
#line 787
  if (! whoptr) {
    {
#line 787
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 787
    return ((PyObject *)((void *)0));
  } else
#line 787
  if (! whoptr->obj) {
    {
#line 787
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 787
    return ((PyObject *)((void *)0));
  } else
#line 787
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 787
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 787
    return ((PyObject *)((void *)0));
  } else
#line 787
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 787
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 787
    return ((PyObject *)((void *)0));
  }
  {
#line 788
  tmp = cf_object_get_long_property(whoptr->obj, 38L);
#line 788
  tmp___0 = Py_BuildValue("l", tmp);
  }
#line 788
  return (tmp___0);
}
}
#line 791 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetArchName(Crossfire_Object *whoptr , void *closure ) 
{ 
  sstring tmp ;
  PyObject *tmp___0 ;

  {
#line 792
  if (! whoptr) {
    {
#line 792
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 792
    return ((PyObject *)((void *)0));
  } else
#line 792
  if (! whoptr->obj) {
    {
#line 792
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 792
    return ((PyObject *)((void *)0));
  } else
#line 792
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 792
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 792
    return ((PyObject *)((void *)0));
  } else
#line 792
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 792
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 792
    return ((PyObject *)((void *)0));
  }
  {
#line 793
  tmp = cf_object_get_sstring_property(whoptr->obj, 97);
#line 793
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 793
  return (tmp___0);
}
}
#line 796 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetArchetype(Crossfire_Object *whoptr , void *closure ) 
{ 
  archetype *tmp ;
  PyObject *tmp___0 ;

  {
#line 797
  if (! whoptr) {
    {
#line 797
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 797
    return ((PyObject *)((void *)0));
  } else
#line 797
  if (! whoptr->obj) {
    {
#line 797
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 797
    return ((PyObject *)((void *)0));
  } else
#line 797
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 797
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 797
    return ((PyObject *)((void *)0));
  } else
#line 797
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 797
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 797
    return ((PyObject *)((void *)0));
  }
  {
#line 798
  tmp = cf_object_get_archetype_property(whoptr->obj, 63);
#line 798
  tmp___0 = Crossfire_Archetype_wrap(tmp);
  }
#line 798
  return (tmp___0);
}
}
#line 801 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetNoSave(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 802
  if (! whoptr) {
    {
#line 802
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 802
    return ((PyObject *)((void *)0));
  } else
#line 802
  if (! whoptr->obj) {
    {
#line 802
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 802
    return ((PyObject *)((void *)0));
  } else
#line 802
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 802
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 802
    return ((PyObject *)((void *)0));
  } else
#line 802
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 802
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 802
    return ((PyObject *)((void *)0));
  }
  {
#line 803
  tmp = cf_object_get_flag(whoptr->obj, 13);
#line 803
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 803
  return (tmp___0);
}
}
#line 806 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetExists(Crossfire_Object *whoptr , void *closure ) 
{ 


  {
#line 807
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
#line 811
    (((PyObject *)(& _Py_ZeroStruct))->ob_refcnt) ++;
#line 812
    return ((PyObject *)(& _Py_ZeroStruct));
  } else
#line 807
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
#line 811
    (((PyObject *)(& _Py_ZeroStruct))->ob_refcnt) ++;
#line 812
    return ((PyObject *)(& _Py_ZeroStruct));
  } else {
#line 808
    (((PyObject *)(& _Py_TrueStruct))->ob_refcnt) ++;
#line 809
    return ((PyObject *)(& _Py_TrueStruct));
  }
}
}
#line 816 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetEnv(Crossfire_Object *whoptr , void *closure ) 
{ 
  object *tmp ;
  PyObject *tmp___0 ;

  {
#line 817
  if (! whoptr) {
    {
#line 817
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 817
    return ((PyObject *)((void *)0));
  } else
#line 817
  if (! whoptr->obj) {
    {
#line 817
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 817
    return ((PyObject *)((void *)0));
  } else
#line 817
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 817
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 817
    return ((PyObject *)((void *)0));
  } else
#line 817
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 817
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 817
    return ((PyObject *)((void *)0));
  }
  {
#line 818
  tmp = cf_object_get_object_property(whoptr->obj, 6);
#line 818
  tmp___0 = Crossfire_Object_wrap(tmp);
  }
#line 818
  return (tmp___0);
}
}
#line 821 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetMoveType(Crossfire_Object *whoptr , void *closure ) 
{ 
  MoveType tmp ;
  PyObject *tmp___0 ;

  {
#line 822
  if (! whoptr) {
    {
#line 822
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 822
    return ((PyObject *)((void *)0));
  } else
#line 822
  if (! whoptr->obj) {
    {
#line 822
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 822
    return ((PyObject *)((void *)0));
  } else
#line 822
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 822
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 822
    return ((PyObject *)((void *)0));
  } else
#line 822
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 822
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 822
    return ((PyObject *)((void *)0));
  }
  {
#line 823
  tmp = cf_object_get_movetype_property(whoptr->obj, 102);
#line 823
  tmp___0 = Py_BuildValue("i", (int )tmp);
  }
#line 823
  return (tmp___0);
}
}
#line 826 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetMoveBlock(Crossfire_Object *whoptr , void *closure ) 
{ 
  MoveType tmp ;
  PyObject *tmp___0 ;

  {
#line 827
  if (! whoptr) {
    {
#line 827
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 827
    return ((PyObject *)((void *)0));
  } else
#line 827
  if (! whoptr->obj) {
    {
#line 827
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 827
    return ((PyObject *)((void *)0));
  } else
#line 827
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 827
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 827
    return ((PyObject *)((void *)0));
  } else
#line 827
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 827
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 827
    return ((PyObject *)((void *)0));
  }
  {
#line 828
  tmp = cf_object_get_movetype_property(whoptr->obj, 103);
#line 828
  tmp___0 = Py_BuildValue("i", (int )tmp);
  }
#line 828
  return (tmp___0);
}
}
#line 831 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetMoveAllow(Crossfire_Object *whoptr , void *closure ) 
{ 
  MoveType tmp ;
  PyObject *tmp___0 ;

  {
#line 832
  if (! whoptr) {
    {
#line 832
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 832
    return ((PyObject *)((void *)0));
  } else
#line 832
  if (! whoptr->obj) {
    {
#line 832
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 832
    return ((PyObject *)((void *)0));
  } else
#line 832
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 832
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 832
    return ((PyObject *)((void *)0));
  } else
#line 832
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 832
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 832
    return ((PyObject *)((void *)0));
  }
  {
#line 833
  tmp = cf_object_get_movetype_property(whoptr->obj, 104);
#line 833
  tmp___0 = Py_BuildValue("i", (int )tmp);
  }
#line 833
  return (tmp___0);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetMoveOn(Crossfire_Object *whoptr , void *closure ) 
{ 
  MoveType tmp ;
  PyObject *tmp___0 ;

  {
#line 837
  if (! whoptr) {
    {
#line 837
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 837
    return ((PyObject *)((void *)0));
  } else
#line 837
  if (! whoptr->obj) {
    {
#line 837
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 837
    return ((PyObject *)((void *)0));
  } else
#line 837
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 837
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 837
    return ((PyObject *)((void *)0));
  } else
#line 837
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 837
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 837
    return ((PyObject *)((void *)0));
  }
  {
#line 838
  tmp = cf_object_get_movetype_property(whoptr->obj, 105);
#line 838
  tmp___0 = Py_BuildValue("i", (int )tmp);
  }
#line 838
  return (tmp___0);
}
}
#line 841 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetMoveOff(Crossfire_Object *whoptr , void *closure ) 
{ 
  MoveType tmp ;
  PyObject *tmp___0 ;

  {
#line 842
  if (! whoptr) {
    {
#line 842
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 842
    return ((PyObject *)((void *)0));
  } else
#line 842
  if (! whoptr->obj) {
    {
#line 842
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 842
    return ((PyObject *)((void *)0));
  } else
#line 842
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 842
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 842
    return ((PyObject *)((void *)0));
  } else
#line 842
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 842
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 842
    return ((PyObject *)((void *)0));
  }
  {
#line 843
  tmp = cf_object_get_movetype_property(whoptr->obj, 106);
#line 843
  tmp___0 = Py_BuildValue("i", (int )tmp);
  }
#line 843
  return (tmp___0);
}
}
#line 846 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetMoveSlow(Crossfire_Object *whoptr , void *closure ) 
{ 
  MoveType tmp ;
  PyObject *tmp___0 ;

  {
#line 847
  if (! whoptr) {
    {
#line 847
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 847
    return ((PyObject *)((void *)0));
  } else
#line 847
  if (! whoptr->obj) {
    {
#line 847
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 847
    return ((PyObject *)((void *)0));
  } else
#line 847
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 847
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 847
    return ((PyObject *)((void *)0));
  } else
#line 847
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 847
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 847
    return ((PyObject *)((void *)0));
  }
  {
#line 848
  tmp = cf_object_get_movetype_property(whoptr->obj, 107);
#line 848
  tmp___0 = Py_BuildValue("i", (int )tmp);
  }
#line 848
  return (tmp___0);
}
}
#line 851 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetMoveSlowPenalty(Crossfire_Object *whoptr , void *closure ) 
{ 
  float tmp ;
  PyObject *tmp___0 ;

  {
#line 852
  if (! whoptr) {
    {
#line 852
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 852
    return ((PyObject *)((void *)0));
  } else
#line 852
  if (! whoptr->obj) {
    {
#line 852
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 852
    return ((PyObject *)((void *)0));
  } else
#line 852
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 852
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 852
    return ((PyObject *)((void *)0));
  } else
#line 852
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 852
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 852
    return ((PyObject *)((void *)0));
  }
  {
#line 853
  tmp = cf_object_get_float_property(whoptr->obj, 108);
#line 853
  tmp___0 = Py_BuildValue("f", (double )tmp);
  }
#line 853
  return (tmp___0);
}
}
#line 856 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetOwner(Crossfire_Object *whoptr , void *closure ) 
{ 
  object *tmp ;
  PyObject *tmp___0 ;

  {
#line 857
  if (! whoptr) {
    {
#line 857
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 857
    return ((PyObject *)((void *)0));
  } else
#line 857
  if (! whoptr->obj) {
    {
#line 857
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 857
    return ((PyObject *)((void *)0));
  } else
#line 857
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 857
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 857
    return ((PyObject *)((void *)0));
  } else
#line 857
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 857
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 857
    return ((PyObject *)((void *)0));
  }
  {
#line 858
  tmp = cf_object_get_object_property(whoptr->obj, 73);
#line 858
  tmp___0 = Crossfire_Object_wrap(tmp);
  }
#line 858
  return (tmp___0);
}
}
#line 861 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetEnemy(Crossfire_Object *whoptr , void *closure ) 
{ 
  object *tmp ;
  PyObject *tmp___0 ;

  {
#line 862
  if (! whoptr) {
    {
#line 862
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 862
    return ((PyObject *)((void *)0));
  } else
#line 862
  if (! whoptr->obj) {
    {
#line 862
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 862
    return ((PyObject *)((void *)0));
  } else
#line 862
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 862
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 862
    return ((PyObject *)((void *)0));
  } else
#line 862
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 862
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 862
    return ((PyObject *)((void *)0));
  }
  {
#line 863
  tmp = cf_object_get_object_property(whoptr->obj, 54);
#line 863
  tmp___0 = Crossfire_Object_wrap(tmp);
  }
#line 863
  return (tmp___0);
}
}
#line 866 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetCount(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 867
  if (! whoptr) {
    {
#line 867
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 867
    return ((PyObject *)((void *)0));
  } else
#line 867
  if (! whoptr->obj) {
    {
#line 867
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 867
    return ((PyObject *)((void *)0));
  } else
#line 867
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 867
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 867
    return ((PyObject *)((void *)0));
  } else
#line 867
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 867
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 867
    return ((PyObject *)((void *)0));
  }
  {
#line 868
  tmp = cf_object_get_int_property(whoptr->obj, 10);
#line 868
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 868
  return (tmp___0);
}
}
#line 871 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetGodGiven(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 872
  if (! whoptr) {
    {
#line 872
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 872
    return ((PyObject *)((void *)0));
  } else
#line 872
  if (! whoptr->obj) {
    {
#line 872
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 872
    return ((PyObject *)((void *)0));
  } else
#line 872
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 872
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 872
    return ((PyObject *)((void *)0));
  } else
#line 872
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 872
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 872
    return ((PyObject *)((void *)0));
  }
  {
#line 873
  tmp = cf_object_get_flag(whoptr->obj, 34);
#line 873
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 873
  return (tmp___0);
}
}
#line 876 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetNoDamage(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 877
  if (! whoptr) {
    {
#line 877
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 877
    return ((PyObject *)((void *)0));
  } else
#line 877
  if (! whoptr->obj) {
    {
#line 877
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 877
    return ((PyObject *)((void *)0));
  } else
#line 877
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 877
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 877
    return ((PyObject *)((void *)0));
  } else
#line 877
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 877
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 877
    return ((PyObject *)((void *)0));
  }
  {
#line 878
  tmp = cf_object_get_flag(whoptr->obj, 102);
#line 878
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 878
  return (tmp___0);
}
}
#line 881 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetRandomMovement(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 882
  if (! whoptr) {
    {
#line 882
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 882
    return ((PyObject *)((void *)0));
  } else
#line 882
  if (! whoptr->obj) {
    {
#line 882
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 882
    return ((PyObject *)((void *)0));
  } else
#line 882
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 882
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 882
    return ((PyObject *)((void *)0));
  } else
#line 882
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 882
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 882
    return ((PyObject *)((void *)0));
  }
  {
#line 883
  tmp = cf_object_get_flag(whoptr->obj, 68);
#line 883
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 883
  return (tmp___0);
}
}
#line 886 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetIsPet(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 887
  if (! whoptr) {
    {
#line 887
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 887
    return ((PyObject *)((void *)0));
  } else
#line 887
  if (! whoptr->obj) {
    {
#line 887
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 887
    return ((PyObject *)((void *)0));
  } else
#line 887
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 887
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 887
    return ((PyObject *)((void *)0));
  } else
#line 887
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 887
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 887
    return ((PyObject *)((void *)0));
  }
  {
#line 888
  tmp = cf_object_get_int_property(whoptr->obj, 67);
#line 888
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 888
  return (tmp___0);
}
}
#line 891 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetAttackMovement(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 892
  if (! whoptr) {
    {
#line 892
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 892
    return ((PyObject *)((void *)0));
  } else
#line 892
  if (! whoptr->obj) {
    {
#line 892
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 892
    return ((PyObject *)((void *)0));
  } else
#line 892
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 892
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 892
    return ((PyObject *)((void *)0));
  } else
#line 892
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 892
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 892
    return ((PyObject *)((void *)0));
  }
  {
#line 893
  tmp = cf_object_get_int_property(whoptr->obj, 60);
#line 893
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 893
  return (tmp___0);
}
}
#line 896 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetDuration(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 897
  if (! whoptr) {
    {
#line 897
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 897
    return ((PyObject *)((void *)0));
  } else
#line 897
  if (! whoptr->obj) {
    {
#line 897
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 897
    return ((PyObject *)((void *)0));
  } else
#line 897
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 897
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 897
    return ((PyObject *)((void *)0));
  } else
#line 897
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 897
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 897
    return ((PyObject *)((void *)0));
  }
  {
#line 898
  tmp = cf_object_get_int_property(whoptr->obj, 109);
#line 898
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 898
  return (tmp___0);
}
}
#line 901 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetGlowRadius(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 902
  if (! whoptr) {
    {
#line 902
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 902
    return ((PyObject *)((void *)0));
  } else
#line 902
  if (! whoptr->obj) {
    {
#line 902
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 902
    return ((PyObject *)((void *)0));
  } else
#line 902
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 902
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 902
    return ((PyObject *)((void *)0));
  } else
#line 902
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 902
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 902
    return ((PyObject *)((void *)0));
  }
  {
#line 903
  tmp = cf_object_get_int_property(whoptr->obj, 51);
#line 903
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 903
  return (tmp___0);
}
}
#line 906 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetAnimated(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 907
  if (! whoptr) {
    {
#line 907
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 907
    return ((PyObject *)((void *)0));
  } else
#line 907
  if (! whoptr->obj) {
    {
#line 907
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 907
    return ((PyObject *)((void *)0));
  } else
#line 907
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 907
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 907
    return ((PyObject *)((void *)0));
  } else
#line 907
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 907
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 907
    return ((PyObject *)((void *)0));
  }
  {
#line 908
  tmp = cf_object_get_flag(whoptr->obj, 11);
#line 908
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 908
  return (tmp___0);
}
}
#line 910 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Object_GetMaterial(Crossfire_Object *whoptr , void *closure ) 
{ 
  int tmp ;
  sstring tmp___0 ;
  PyObject *tmp___1 ;

  {
#line 911
  if (! whoptr) {
    {
#line 911
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 911
    return ((PyObject *)((void *)0));
  } else
#line 911
  if (! whoptr->obj) {
    {
#line 911
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 911
    return ((PyObject *)((void *)0));
  } else
#line 911
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 911
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 911
    return ((PyObject *)((void *)0));
  } else
#line 911
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 911
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 911
    return ((PyObject *)((void *)0));
  }
  {
#line 912
  tmp = cf_object_get_int_property(whoptr->obj, 35);
#line 912
  tmp___0 = cf_object_get_sstring_property(whoptr->obj, 36);
#line 912
  tmp___1 = Py_BuildValue("{s:s,s:i}", "Name", tmp___0, "Number", tmp);
  }
#line 912
  return (tmp___1);
}
}
#line 915 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetMessage(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  char *val ;
  int tmp ;

  {
#line 918
  if (! whoptr) {
    {
#line 918
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 918
    return (-1);
  } else
#line 918
  if (! whoptr->obj) {
    {
#line 918
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 918
    return (-1);
  } else
#line 918
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 918
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 918
    return (-1);
  } else
#line 918
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 918
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 918
    return (-1);
  }
#line 919
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    {
#line 920
    PyErr_SetString(PyExc_TypeError, "Cannot delete the Message attribute");
    }
#line 921
    return (-1);
  }
#line 923
  if (! (((value->ob_type)->tp_flags & (1L << 27)) != 0L)) {
#line 923
    if (! (((value->ob_type)->tp_flags & (1L << 28)) != 0L)) {
      {
#line 924
      PyErr_SetString(PyExc_TypeError, "The Message attribute must be a string");
      }
#line 925
      return (-1);
    }
  }
  {
#line 927
  tmp = PyArg_Parse(value, "s", & val);
  }
#line 927
  if (! tmp) {
#line 928
    return (-1);
  }
  {
#line 930
  cf_object_set_string_property(whoptr->obj, 18, (char const   *)val);
  }
#line 931
  return (0);
}
}
#line 934 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetName(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  char *val ;
  int tmp ;

  {
#line 937
  if (! whoptr) {
    {
#line 937
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 937
    return (-1);
  } else
#line 937
  if (! whoptr->obj) {
    {
#line 937
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 937
    return (-1);
  } else
#line 937
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 937
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 937
    return (-1);
  } else
#line 937
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 937
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 937
    return (-1);
  }
#line 938
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    {
#line 939
    PyErr_SetString(PyExc_TypeError, "Cannot delete the Name attribute");
    }
#line 940
    return (-1);
  }
#line 942
  if (! (((value->ob_type)->tp_flags & (1L << 27)) != 0L)) {
#line 942
    if (! (((value->ob_type)->tp_flags & (1L << 28)) != 0L)) {
      {
#line 943
      PyErr_SetString(PyExc_TypeError, "The Name attribute must be a string");
      }
#line 944
      return (-1);
    }
  }
  {
#line 946
  tmp = PyArg_Parse(value, "s", & val);
  }
#line 946
  if (! tmp) {
#line 947
    return (-1);
  }
  {
#line 949
  cf_object_set_string_property(whoptr->obj, 12, (char const   *)val);
#line 950
  cf_object_set_string_property(whoptr->obj, 13, (char const   *)val);
  }
#line 951
  return (0);
}
}
#line 954 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetNamePl(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  char *val ;
  int tmp ;

  {
#line 957
  if (! whoptr) {
    {
#line 957
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 957
    return (-1);
  } else
#line 957
  if (! whoptr->obj) {
    {
#line 957
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 957
    return (-1);
  } else
#line 957
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 957
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 957
    return (-1);
  } else
#line 957
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 957
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 957
    return (-1);
  }
#line 958
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    {
#line 959
    PyErr_SetString(PyExc_TypeError, "Cannot delete the NamePl attribute");
    }
#line 960
    return (-1);
  }
#line 962
  if (! (((value->ob_type)->tp_flags & (1L << 27)) != 0L)) {
#line 962
    if (! (((value->ob_type)->tp_flags & (1L << 28)) != 0L)) {
      {
#line 963
      PyErr_SetString(PyExc_TypeError, "The NamePl attribute must be a string");
      }
#line 964
      return (-1);
    }
  }
  {
#line 966
  tmp = PyArg_Parse(value, "s", & val);
  }
#line 966
  if (! tmp) {
#line 967
    return (-1);
  }
  {
#line 969
  cf_object_set_string_property(whoptr->obj, 13, (char const   *)val);
  }
#line 970
  return (0);
}
}
#line 973 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetTitle(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  char *val ;
  int tmp ;

  {
#line 976
  if (! whoptr) {
    {
#line 976
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 976
    return (-1);
  } else
#line 976
  if (! whoptr->obj) {
    {
#line 976
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 976
    return (-1);
  } else
#line 976
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 976
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 976
    return (-1);
  } else
#line 976
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 976
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 976
    return (-1);
  }
#line 977
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    {
#line 978
    PyErr_SetString(PyExc_TypeError, "Cannot delete the Title attribute");
    }
#line 979
    return (-1);
  }
#line 981
  if (! (((value->ob_type)->tp_flags & (1L << 27)) != 0L)) {
#line 981
    if (! (((value->ob_type)->tp_flags & (1L << 28)) != 0L)) {
      {
#line 982
      PyErr_SetString(PyExc_TypeError, "The Title attribute must be a string");
      }
#line 983
      return (-1);
    }
  }
  {
#line 985
  tmp = PyArg_Parse(value, "s", & val);
  }
#line 985
  if (! tmp) {
#line 986
    return (-1);
  }
  {
#line 988
  cf_object_set_string_property(whoptr->obj, 14, (char const   *)val);
  }
#line 989
  return (0);
}
}
#line 992 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetRace(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  char *val ;
  int tmp ;

  {
#line 995
  if (! whoptr) {
    {
#line 995
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 995
    return (-1);
  } else
#line 995
  if (! whoptr->obj) {
    {
#line 995
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 995
    return (-1);
  } else
#line 995
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 995
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 995
    return (-1);
  } else
#line 995
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 995
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 995
    return (-1);
  }
#line 996
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    {
#line 997
    PyErr_SetString(PyExc_TypeError, "Cannot delete the Race attribute");
    }
#line 998
    return (-1);
  }
#line 1000
  if (! (((value->ob_type)->tp_flags & (1L << 27)) != 0L)) {
#line 1000
    if (! (((value->ob_type)->tp_flags & (1L << 28)) != 0L)) {
      {
#line 1001
      PyErr_SetString(PyExc_TypeError, "The Race attribute must be a string");
      }
#line 1002
      return (-1);
    }
  }
  {
#line 1004
  tmp = PyArg_Parse(value, "s", & val);
  }
#line 1004
  if (! tmp) {
#line 1005
    return (-1);
  }
  {
#line 1007
  cf_object_set_string_property(whoptr->obj, 15, (char const   *)val);
  }
#line 1008
  return (0);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetMap(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  Crossfire_Map *val ;
  int tmp ;

  {
#line 1014
  if (! whoptr) {
    {
#line 1014
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1014
    return (-1);
  } else
#line 1014
  if (! whoptr->obj) {
    {
#line 1014
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1014
    return (-1);
  } else
#line 1014
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1014
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1014
    return (-1);
  } else
#line 1014
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1014
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1014
    return (-1);
  }
  {
#line 1015
  tmp = PyArg_Parse(value, "O!", & Crossfire_MapType, & val);
  }
#line 1015
  if (! tmp) {
#line 1016
    return (-1);
  }
  {
#line 1018
  cf_object_change_map(whoptr->obj, val->map, (object *)((void *)0), 0, -1, -1);
  }
#line 1019
  return (0);
}
}
#line 1022 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetSlaying(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  char *val ;
  int tmp ;

  {
#line 1025
  if (! whoptr) {
    {
#line 1025
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1025
    return (-1);
  } else
#line 1025
  if (! whoptr->obj) {
    {
#line 1025
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1025
    return (-1);
  } else
#line 1025
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1025
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1025
    return (-1);
  } else
#line 1025
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1025
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1025
    return (-1);
  }
#line 1026
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    {
#line 1027
    PyErr_SetString(PyExc_TypeError, "Cannot delete the Slaying attribute");
    }
#line 1028
    return (-1);
  }
#line 1030
  if (! (((value->ob_type)->tp_flags & (1L << 27)) != 0L)) {
#line 1030
    if (! (((value->ob_type)->tp_flags & (1L << 28)) != 0L)) {
      {
#line 1031
      PyErr_SetString(PyExc_TypeError, "The Slaying attribute must be a string");
      }
#line 1032
      return (-1);
    }
  }
  {
#line 1034
  tmp = PyArg_Parse(value, "s", & val);
  }
#line 1034
  if (! tmp) {
#line 1035
    return (-1);
  }
  {
#line 1037
  cf_object_set_string_property(whoptr->obj, 16, (char const   *)val);
  }
#line 1038
  return (0);
}
}
#line 1041 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetSkill(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  char *val ;
  int tmp ;

  {
#line 1044
  if (! whoptr) {
    {
#line 1044
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1044
    return (-1);
  } else
#line 1044
  if (! whoptr->obj) {
    {
#line 1044
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1044
    return (-1);
  } else
#line 1044
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1044
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1044
    return (-1);
  } else
#line 1044
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1044
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1044
    return (-1);
  }
#line 1045
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    {
#line 1046
    PyErr_SetString(PyExc_TypeError, "Cannot delete the Skill attribute");
    }
#line 1047
    return (-1);
  }
#line 1049
  if (! (((value->ob_type)->tp_flags & (1L << 27)) != 0L)) {
#line 1049
    if (! (((value->ob_type)->tp_flags & (1L << 28)) != 0L)) {
      {
#line 1050
      PyErr_SetString(PyExc_TypeError, "The Skill attribute must be a string");
      }
#line 1051
      return (-1);
    }
  }
  {
#line 1053
  tmp = PyArg_Parse(value, "s", & val);
  }
#line 1053
  if (! tmp) {
#line 1054
    return (-1);
  }
  {
#line 1056
  cf_object_set_string_property(whoptr->obj, 17, (char const   *)val);
  }
#line 1057
  return (0);
}
}
#line 1060 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetCursed(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1063
  if (! whoptr) {
    {
#line 1063
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1063
    return (-1);
  } else
#line 1063
  if (! whoptr->obj) {
    {
#line 1063
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1063
    return (-1);
  } else
#line 1063
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1063
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1063
    return (-1);
  } else
#line 1063
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1063
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1063
    return (-1);
  }
  {
#line 1064
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1064
  if (! tmp) {
#line 1065
    return (-1);
  }
  {
#line 1067
  cf_object_set_flag(whoptr->obj, 74, val);
  }
#line 1068
  return (0);
}
}
#line 1071 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetDamned(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1074
  if (! whoptr) {
    {
#line 1074
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1074
    return (-1);
  } else
#line 1074
  if (! whoptr->obj) {
    {
#line 1074
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1074
    return (-1);
  } else
#line 1074
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1074
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1074
    return (-1);
  } else
#line 1074
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1074
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1074
    return (-1);
  }
  {
#line 1075
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1075
  if (! tmp) {
#line 1076
    return (-1);
  }
  {
#line 1078
  cf_object_set_flag(whoptr->obj, 75, val);
  }
#line 1079
  return (0);
}
}
#line 1082 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetApplied(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1085
  if (! whoptr) {
    {
#line 1085
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1085
    return (-1);
  } else
#line 1085
  if (! whoptr->obj) {
    {
#line 1085
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1085
    return (-1);
  } else
#line 1085
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1085
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1085
    return (-1);
  } else
#line 1085
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1085
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1085
    return (-1);
  }
  {
#line 1086
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1086
  if (! tmp) {
#line 1087
    return (-1);
  }
  {
#line 1089
  cf_object_set_flag(whoptr->obj, 5, val);
  }
#line 1090
  return (0);
}
}
#line 1093 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetStr(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1096
  if (! whoptr) {
    {
#line 1096
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1096
    return (-1);
  } else
#line 1096
  if (! whoptr->obj) {
    {
#line 1096
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1096
    return (-1);
  } else
#line 1096
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1096
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1096
    return (-1);
  } else
#line 1096
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1096
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1096
    return (-1);
  }
  {
#line 1097
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1097
  if (! tmp) {
#line 1098
    return (-1);
  }
  {
#line 1100
  cf_object_set_int_property(whoptr->obj, 79, val);
  }
#line 1102
  return (0);
}
}
#line 1105 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetDex(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1108
  if (! whoptr) {
    {
#line 1108
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1108
    return (-1);
  } else
#line 1108
  if (! whoptr->obj) {
    {
#line 1108
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1108
    return (-1);
  } else
#line 1108
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1108
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1108
    return (-1);
  } else
#line 1108
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1108
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1108
    return (-1);
  }
  {
#line 1109
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1109
  if (! tmp) {
#line 1110
    return (-1);
  }
  {
#line 1112
  cf_object_set_int_property(whoptr->obj, 80, val);
  }
#line 1114
  return (0);
}
}
#line 1117 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetCon(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1120
  if (! whoptr) {
    {
#line 1120
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1120
    return (-1);
  } else
#line 1120
  if (! whoptr->obj) {
    {
#line 1120
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1120
    return (-1);
  } else
#line 1120
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1120
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1120
    return (-1);
  } else
#line 1120
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1120
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1120
    return (-1);
  }
  {
#line 1121
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1121
  if (! tmp) {
#line 1122
    return (-1);
  }
  {
#line 1124
  cf_object_set_int_property(whoptr->obj, 81, val);
  }
#line 1126
  return (0);
}
}
#line 1129 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetInt(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1132
  if (! whoptr) {
    {
#line 1132
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1132
    return (-1);
  } else
#line 1132
  if (! whoptr->obj) {
    {
#line 1132
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1132
    return (-1);
  } else
#line 1132
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1132
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1132
    return (-1);
  } else
#line 1132
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1132
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1132
    return (-1);
  }
  {
#line 1133
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1133
  if (! tmp) {
#line 1134
    return (-1);
  }
  {
#line 1136
  cf_object_set_int_property(whoptr->obj, 83, val);
  }
#line 1138
  return (0);
}
}
#line 1141 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetPow(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1144
  if (! whoptr) {
    {
#line 1144
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1144
    return (-1);
  } else
#line 1144
  if (! whoptr->obj) {
    {
#line 1144
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1144
    return (-1);
  } else
#line 1144
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1144
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1144
    return (-1);
  } else
#line 1144
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1144
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1144
    return (-1);
  }
  {
#line 1145
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1145
  if (! tmp) {
#line 1146
    return (-1);
  }
  {
#line 1148
  cf_object_set_int_property(whoptr->obj, 84, val);
  }
#line 1150
  return (0);
}
}
#line 1153 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetWis(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1156
  if (! whoptr) {
    {
#line 1156
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1156
    return (-1);
  } else
#line 1156
  if (! whoptr->obj) {
    {
#line 1156
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1156
    return (-1);
  } else
#line 1156
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1156
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1156
    return (-1);
  } else
#line 1156
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1156
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1156
    return (-1);
  }
  {
#line 1157
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1157
  if (! tmp) {
#line 1158
    return (-1);
  }
  {
#line 1160
  cf_object_set_int_property(whoptr->obj, 82, val);
  }
#line 1162
  return (0);
}
}
#line 1165 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetCha(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1168
  if (! whoptr) {
    {
#line 1168
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1168
    return (-1);
  } else
#line 1168
  if (! whoptr->obj) {
    {
#line 1168
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1168
    return (-1);
  } else
#line 1168
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1168
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1168
    return (-1);
  } else
#line 1168
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1168
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1168
    return (-1);
  }
  {
#line 1169
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1169
  if (! tmp) {
#line 1170
    return (-1);
  }
  {
#line 1172
  cf_object_set_int_property(whoptr->obj, 85, val);
  }
#line 1174
  return (0);
}
}
#line 1177 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetHP(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1180
  if (! whoptr) {
    {
#line 1180
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1180
    return (-1);
  } else
#line 1180
  if (! whoptr->obj) {
    {
#line 1180
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1180
    return (-1);
  } else
#line 1180
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1180
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1180
    return (-1);
  } else
#line 1180
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1180
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1180
    return (-1);
  }
  {
#line 1181
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1181
  if (! tmp) {
#line 1182
    return (-1);
  }
  {
#line 1184
  cf_object_set_int_property(whoptr->obj, 88, val);
  }
#line 1185
  return (0);
}
}
#line 1188 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetMaxHP(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1191
  if (! whoptr) {
    {
#line 1191
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1191
    return (-1);
  } else
#line 1191
  if (! whoptr->obj) {
    {
#line 1191
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1191
    return (-1);
  } else
#line 1191
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1191
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1191
    return (-1);
  } else
#line 1191
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1191
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1191
    return (-1);
  }
  {
#line 1192
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1192
  if (! tmp) {
#line 1193
    return (-1);
  }
  {
#line 1195
  cf_object_set_int_property(whoptr->obj, 92, val);
  }
#line 1196
  return (0);
}
}
#line 1199 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetSP(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1202
  if (! whoptr) {
    {
#line 1202
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1202
    return (-1);
  } else
#line 1202
  if (! whoptr->obj) {
    {
#line 1202
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1202
    return (-1);
  } else
#line 1202
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1202
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1202
    return (-1);
  } else
#line 1202
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1202
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1202
    return (-1);
  }
  {
#line 1203
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1203
  if (! tmp) {
#line 1204
    return (-1);
  }
  {
#line 1206
  cf_object_set_int_property(whoptr->obj, 89, val);
  }
#line 1207
  return (0);
}
}
#line 1210 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetMaxSP(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1213
  if (! whoptr) {
    {
#line 1213
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1213
    return (-1);
  } else
#line 1213
  if (! whoptr->obj) {
    {
#line 1213
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1213
    return (-1);
  } else
#line 1213
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1213
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1213
    return (-1);
  } else
#line 1213
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1213
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1213
    return (-1);
  }
  {
#line 1214
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1214
  if (! tmp) {
#line 1215
    return (-1);
  }
  {
#line 1217
  cf_object_set_int_property(whoptr->obj, 93, val);
  }
#line 1218
  return (0);
}
}
#line 1221 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetGrace(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1224
  if (! whoptr) {
    {
#line 1224
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1224
    return (-1);
  } else
#line 1224
  if (! whoptr->obj) {
    {
#line 1224
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1224
    return (-1);
  } else
#line 1224
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1224
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1224
    return (-1);
  } else
#line 1224
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1224
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1224
    return (-1);
  }
  {
#line 1225
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1225
  if (! tmp) {
#line 1226
    return (-1);
  }
  {
#line 1228
  cf_object_set_int_property(whoptr->obj, 90, val);
  }
#line 1229
  return (0);
}
}
#line 1232 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetMaxGrace(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1235
  if (! whoptr) {
    {
#line 1235
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1235
    return (-1);
  } else
#line 1235
  if (! whoptr->obj) {
    {
#line 1235
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1235
    return (-1);
  } else
#line 1235
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1235
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1235
    return (-1);
  } else
#line 1235
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1235
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1235
    return (-1);
  }
  {
#line 1236
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1236
  if (! tmp) {
#line 1237
    return (-1);
  }
  {
#line 1239
  cf_object_set_int_property(whoptr->obj, 94, val);
  }
#line 1240
  return (0);
}
}
#line 1243 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetAC(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1246
  if (! whoptr) {
    {
#line 1246
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1246
    return (-1);
  } else
#line 1246
  if (! whoptr->obj) {
    {
#line 1246
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1246
    return (-1);
  } else
#line 1246
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1246
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1246
    return (-1);
  } else
#line 1246
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1246
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1246
    return (-1);
  }
  {
#line 1247
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1247
  if (! tmp) {
#line 1248
    return (-1);
  }
  {
#line 1250
  cf_object_set_int_property(whoptr->obj, 87, val);
  }
#line 1251
  return (0);
}
}
#line 1254 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetWC(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1257
  if (! whoptr) {
    {
#line 1257
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1257
    return (-1);
  } else
#line 1257
  if (! whoptr->obj) {
    {
#line 1257
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1257
    return (-1);
  } else
#line 1257
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1257
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1257
    return (-1);
  } else
#line 1257
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1257
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1257
    return (-1);
  }
  {
#line 1258
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1258
  if (! tmp) {
#line 1259
    return (-1);
  }
  {
#line 1261
  cf_object_set_int_property(whoptr->obj, 86, val);
  }
#line 1262
  return (0);
}
}
#line 1265 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetDam(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1268
  if (! whoptr) {
    {
#line 1268
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1268
    return (-1);
  } else
#line 1268
  if (! whoptr->obj) {
    {
#line 1268
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1268
    return (-1);
  } else
#line 1268
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1268
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1268
    return (-1);
  } else
#line 1268
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1268
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1268
    return (-1);
  }
  {
#line 1269
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1269
  if (! tmp) {
#line 1270
    return (-1);
  }
  {
#line 1272
  cf_object_set_int_property(whoptr->obj, 95, val);
  }
#line 1273
  return (0);
}
}
#line 1276 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetFood(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1279
  if (! whoptr) {
    {
#line 1279
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1279
    return (-1);
  } else
#line 1279
  if (! whoptr->obj) {
    {
#line 1279
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1279
    return (-1);
  } else
#line 1279
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1279
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1279
    return (-1);
  } else
#line 1279
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1279
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1279
    return (-1);
  }
  {
#line 1280
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1280
  if (! tmp) {
#line 1281
    return (-1);
  }
  {
#line 1283
  cf_object_set_int_property(whoptr->obj, 91, val);
  }
#line 1284
  return (0);
}
}
#line 1287 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetWeight(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1290
  if (! whoptr) {
    {
#line 1290
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1290
    return (-1);
  } else
#line 1290
  if (! whoptr->obj) {
    {
#line 1290
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1290
    return (-1);
  } else
#line 1290
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1290
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1290
    return (-1);
  } else
#line 1290
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1290
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1290
    return (-1);
  }
  {
#line 1291
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1291
  if (! tmp) {
#line 1292
    return (-1);
  }
  {
#line 1294
  cf_object_set_int_property(whoptr->obj, 48, val);
  }
#line 1295
  return (0);
}
}
#line 1298 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetWeightLimit(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1301
  if (! whoptr) {
    {
#line 1301
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1301
    return (-1);
  } else
#line 1301
  if (! whoptr->obj) {
    {
#line 1301
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1301
    return (-1);
  } else
#line 1301
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1301
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1301
    return (-1);
  } else
#line 1301
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1301
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1301
    return (-1);
  }
  {
#line 1302
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1302
  if (! tmp) {
#line 1303
    return (-1);
  }
  {
#line 1305
  cf_object_set_int_property(whoptr->obj, 49, val);
  }
#line 1306
  return (0);
}
}
#line 1309 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetDirection(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1312
  if (! whoptr) {
    {
#line 1312
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1312
    return (-1);
  } else
#line 1312
  if (! whoptr->obj) {
    {
#line 1312
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1312
    return (-1);
  } else
#line 1312
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1312
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1312
    return (-1);
  } else
#line 1312
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1312
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1312
    return (-1);
  }
  {
#line 1313
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1313
  if (! tmp) {
#line 1314
    return (-1);
  }
  {
#line 1316
  cf_object_set_int_property(whoptr->obj, 25, val);
  }
#line 1317
  return (0);
}
}
#line 1320 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetFacing(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1323
  if (! whoptr) {
    {
#line 1323
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1323
    return (-1);
  } else
#line 1323
  if (! whoptr->obj) {
    {
#line 1323
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1323
    return (-1);
  } else
#line 1323
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1323
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1323
    return (-1);
  } else
#line 1323
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1323
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1323
    return (-1);
  }
  {
#line 1324
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1324
  if (! tmp) {
#line 1325
    return (-1);
  }
  {
#line 1327
  cf_object_set_int_property(whoptr->obj, 26, val);
  }
#line 1328
  return (0);
}
}
#line 1331 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetGod(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  char *val ;
  int tmp ;

  {
#line 1334
  if (! whoptr) {
    {
#line 1334
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1334
    return (-1);
  } else
#line 1334
  if (! whoptr->obj) {
    {
#line 1334
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1334
    return (-1);
  } else
#line 1334
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1334
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1334
    return (-1);
  } else
#line 1334
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1334
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1334
    return (-1);
  }
  {
#line 1335
  tmp = PyArg_Parse(value, "s", & val);
  }
#line 1335
  if (! tmp) {
#line 1336
    return (-1);
  }
  {
#line 1338
  cf_object_set_string_property(whoptr->obj, 96, (char const   *)val);
  }
#line 1339
  return (0);
}
}
#line 1342 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetSpeed(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  float val ;
  int tmp ;

  {
#line 1345
  if (! whoptr) {
    {
#line 1345
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1345
    return (-1);
  } else
#line 1345
  if (! whoptr->obj) {
    {
#line 1345
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1345
    return (-1);
  } else
#line 1345
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1345
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1345
    return (-1);
  } else
#line 1345
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1345
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1345
    return (-1);
  }
  {
#line 1346
  tmp = PyArg_Parse(value, "f", & val);
  }
#line 1346
  if (! tmp) {
#line 1347
    return (-1);
  }
  {
#line 1349
  cf_object_set_float_property(whoptr->obj, 22, val);
  }
#line 1351
  return (0);
}
}
#line 1354 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetSpeedLeft(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  float val ;
  int tmp ;

  {
#line 1357
  if (! whoptr) {
    {
#line 1357
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1357
    return (-1);
  } else
#line 1357
  if (! whoptr->obj) {
    {
#line 1357
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1357
    return (-1);
  } else
#line 1357
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1357
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1357
    return (-1);
  } else
#line 1357
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1357
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1357
    return (-1);
  }
  {
#line 1358
  tmp = PyArg_Parse(value, "f", & val);
  }
#line 1358
  if (! tmp) {
#line 1359
    return (-1);
  }
  {
#line 1361
  cf_object_set_float_property(whoptr->obj, 23, val);
  }
#line 1363
  return (0);
}
}
#line 1366 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetQuantity(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;
  int tmp___0 ;

  {
#line 1369
  if (! whoptr) {
    {
#line 1369
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1369
    return (-1);
  } else
#line 1369
  if (! whoptr->obj) {
    {
#line 1369
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1369
    return (-1);
  } else
#line 1369
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1369
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1369
    return (-1);
  } else
#line 1369
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1369
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1369
    return (-1);
  }
  {
#line 1370
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1370
  if (! tmp) {
#line 1371
    return (-1);
  }
  {
#line 1373
  tmp___0 = cf_object_set_nrof(whoptr->obj, val);
  }
#line 1373
  if (tmp___0 != 0) {
    {
#line 1374
    PyErr_SetString(PyExc_TypeError, "Invalid quantity");
    }
#line 1375
    return (-1);
  }
#line 1379
  return (0);
}
}
#line 1382 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetLastSP(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1385
  if (! whoptr) {
    {
#line 1385
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1385
    return (-1);
  } else
#line 1385
  if (! whoptr->obj) {
    {
#line 1385
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1385
    return (-1);
  } else
#line 1385
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1385
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1385
    return (-1);
  } else
#line 1385
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1385
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1385
    return (-1);
  }
  {
#line 1386
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1386
  if (! tmp) {
#line 1387
    return (-1);
  }
  {
#line 1389
  cf_object_set_int_property(whoptr->obj, 41, val);
  }
#line 1391
  return (0);
}
}
#line 1394 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetLastGrace(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1397
  if (! whoptr) {
    {
#line 1397
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1397
    return (-1);
  } else
#line 1397
  if (! whoptr->obj) {
    {
#line 1397
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1397
    return (-1);
  } else
#line 1397
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1397
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1397
    return (-1);
  } else
#line 1397
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1397
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1397
    return (-1);
  }
  {
#line 1398
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1398
  if (! tmp) {
#line 1399
    return (-1);
  }
  {
#line 1401
  cf_object_set_int_property(whoptr->obj, 42, val);
  }
#line 1403
  return (0);
}
}
#line 1406 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetLastEat(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1409
  if (! whoptr) {
    {
#line 1409
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1409
    return (-1);
  } else
#line 1409
  if (! whoptr->obj) {
    {
#line 1409
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1409
    return (-1);
  } else
#line 1409
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1409
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1409
    return (-1);
  } else
#line 1409
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1409
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1409
    return (-1);
  }
  {
#line 1410
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1410
  if (! tmp) {
#line 1411
    return (-1);
  }
  {
#line 1413
  cf_object_set_int_property(whoptr->obj, 43, val);
  }
#line 1414
  return (0);
}
}
#line 1417 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetFace(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  char *face ;
  int tmp ;
  int tmp___0 ;

  {
#line 1420
  if (! whoptr) {
    {
#line 1420
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1420
    return (-1);
  } else
#line 1420
  if (! whoptr->obj) {
    {
#line 1420
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1420
    return (-1);
  } else
#line 1420
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1420
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1420
    return (-1);
  } else
#line 1420
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1420
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1420
    return (-1);
  }
  {
#line 1421
  tmp = PyArg_Parse(value, "s", & face);
  }
#line 1421
  if (! tmp) {
#line 1422
    return (-1);
  }
  {
#line 1424
  tmp___0 = cf_object_set_face(whoptr->obj, (char const   *)face);
  }
#line 1424
  if (! tmp___0) {
    {
#line 1425
    PyErr_SetString(PyExc_TypeError, "Unknown face.");
    }
#line 1426
    return (-1);
  }
#line 1428
  return (0);
}
}
#line 1431 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetAnim(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  char *anim ;
  int tmp ;
  int tmp___0 ;

  {
#line 1434
  if (! whoptr) {
    {
#line 1434
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1434
    return (-1);
  } else
#line 1434
  if (! whoptr->obj) {
    {
#line 1434
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1434
    return (-1);
  } else
#line 1434
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1434
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1434
    return (-1);
  } else
#line 1434
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1434
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1434
    return (-1);
  }
  {
#line 1435
  tmp = PyArg_Parse(value, "s", & anim);
  }
#line 1435
  if (! tmp) {
#line 1436
    return (-1);
  }
  {
#line 1438
  tmp___0 = cf_object_set_animation(whoptr->obj, (char const   *)anim);
  }
#line 1438
  if (! tmp___0) {
    {
#line 1439
    PyErr_SetString(PyExc_TypeError, "Unknown animation.");
    }
#line 1440
    return (-1);
  }
#line 1443
  return (0);
}
}
#line 1446 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetAnimSpeed(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1449
  if (! whoptr) {
    {
#line 1449
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1449
    return (-1);
  } else
#line 1449
  if (! whoptr->obj) {
    {
#line 1449
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1449
    return (-1);
  } else
#line 1449
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1449
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1449
    return (-1);
  } else
#line 1449
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1449
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1449
    return (-1);
  }
  {
#line 1450
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1450
  if (! tmp) {
#line 1451
    return (-1);
  }
  {
#line 1453
  cf_object_set_int_property(whoptr->obj, 66, val);
  }
#line 1454
  return (0);
}
}
#line 1457 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetAttackType(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1460
  if (! whoptr) {
    {
#line 1460
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1460
    return (-1);
  } else
#line 1460
  if (! whoptr->obj) {
    {
#line 1460
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1460
    return (-1);
  } else
#line 1460
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1460
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1460
    return (-1);
  } else
#line 1460
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1460
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1460
    return (-1);
  }
  {
#line 1461
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1461
  if (! tmp) {
#line 1462
    return (-1);
  }
  {
#line 1464
  cf_object_set_int_property(whoptr->obj, 31, val);
  }
#line 1466
  return (0);
}
}
#line 1469 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetIdentified(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1472
  if (! whoptr) {
    {
#line 1472
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1472
    return (-1);
  } else
#line 1472
  if (! whoptr->obj) {
    {
#line 1472
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1472
    return (-1);
  } else
#line 1472
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1472
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1472
    return (-1);
  } else
#line 1472
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1472
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1472
    return (-1);
  }
  {
#line 1473
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1473
  if (! tmp) {
#line 1474
    return (-1);
  }
  {
#line 1476
  cf_object_set_flag(whoptr->obj, 29, val);
  }
#line 1477
  return (0);
}
}
#line 1480 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetUnaggressive(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1483
  if (! whoptr) {
    {
#line 1483
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1483
    return (-1);
  } else
#line 1483
  if (! whoptr->obj) {
    {
#line 1483
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1483
    return (-1);
  } else
#line 1483
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1483
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1483
    return (-1);
  } else
#line 1483
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1483
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1483
    return (-1);
  }
  {
#line 1484
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1484
  if (! tmp) {
#line 1485
    return (-1);
  }
  {
#line 1487
  cf_object_set_flag(whoptr->obj, 38, val);
  }
#line 1488
  return (0);
}
}
#line 1491 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetPickable(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1494
  if (! whoptr) {
    {
#line 1494
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1494
    return (-1);
  } else
#line 1494
  if (! whoptr->obj) {
    {
#line 1494
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1494
    return (-1);
  } else
#line 1494
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1494
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1494
    return (-1);
  } else
#line 1494
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1494
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1494
    return (-1);
  }
  {
#line 1495
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1495
  if (! tmp) {
#line 1496
    return (-1);
  }
  {
#line 1498
  cf_object_set_flag(whoptr->obj, 8, ! val);
  }
#line 1499
  return (0);
}
}
#line 1502 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetInvisible(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1505
  if (! whoptr) {
    {
#line 1505
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1505
    return (-1);
  } else
#line 1505
  if (! whoptr->obj) {
    {
#line 1505
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1505
    return (-1);
  } else
#line 1505
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1505
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1505
    return (-1);
  } else
#line 1505
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1505
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1505
    return (-1);
  }
  {
#line 1506
  tmp = PyArg_ParseTuple(value, "i", & val);
  }
#line 1506
  if (! tmp) {
#line 1507
    return (-1);
  }
  {
#line 1509
  cf_object_set_int_property(whoptr->obj, 98, val);
  }
#line 1510
  return (0);
}
}
#line 1513 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetUnpaid(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1516
  if (! whoptr) {
    {
#line 1516
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1516
    return (-1);
  } else
#line 1516
  if (! whoptr->obj) {
    {
#line 1516
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1516
    return (-1);
  } else
#line 1516
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1516
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1516
    return (-1);
  } else
#line 1516
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1516
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1516
    return (-1);
  }
  {
#line 1517
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1517
  if (! tmp) {
#line 1518
    return (-1);
  }
  {
#line 1520
  cf_object_set_flag(whoptr->obj, 6, val);
  }
#line 1521
  return (0);
}
}
#line 1524 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetFriendly(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1527
  if (! whoptr) {
    {
#line 1527
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1527
    return (-1);
  } else
#line 1527
  if (! whoptr->obj) {
    {
#line 1527
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1527
    return (-1);
  } else
#line 1527
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1527
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1527
    return (-1);
  } else
#line 1527
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1527
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1527
    return (-1);
  }
  {
#line 1528
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1528
  if (! tmp) {
#line 1529
    return (-1);
  }
  {
#line 1531
  cf_object_set_flag(whoptr->obj, 15, val);
  }
#line 1532
  return (0);
}
}
#line 1535 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetCanSeeInvisible(Crossfire_Object *whoptr , PyObject *value ,
                                     void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1538
  if (! whoptr) {
    {
#line 1538
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1538
    return (-1);
  } else
#line 1538
  if (! whoptr->obj) {
    {
#line 1538
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1538
    return (-1);
  } else
#line 1538
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1538
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1538
    return (-1);
  } else
#line 1538
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1538
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1538
    return (-1);
  }
  {
#line 1539
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1539
  if (! tmp) {
#line 1540
    return (-1);
  }
  {
#line 1542
  cf_object_set_flag(whoptr->obj, 21, val);
  }
#line 1543
  return (0);
}
}
#line 1546 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetRollable(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1549
  if (! whoptr) {
    {
#line 1549
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1549
    return (-1);
  } else
#line 1549
  if (! whoptr->obj) {
    {
#line 1549
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1549
    return (-1);
  } else
#line 1549
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1549
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1549
    return (-1);
  } else
#line 1549
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1549
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1549
    return (-1);
  }
  {
#line 1550
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1550
  if (! tmp) {
#line 1551
    return (-1);
  }
  {
#line 1553
  cf_object_set_flag(whoptr->obj, 22, val);
  }
#line 1554
  return (0);
}
}
#line 1557 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetTurnable(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1560
  if (! whoptr) {
    {
#line 1560
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1560
    return (-1);
  } else
#line 1560
  if (! whoptr->obj) {
    {
#line 1560
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1560
    return (-1);
  } else
#line 1560
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1560
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1560
    return (-1);
  } else
#line 1560
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1560
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1560
    return (-1);
  }
  {
#line 1561
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1561
  if (! tmp) {
#line 1562
    return (-1);
  }
  {
#line 1564
  cf_object_set_flag(whoptr->obj, 24, val);
  }
#line 1565
  return (0);
}
}
#line 1568 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetUsedUp(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1571
  if (! whoptr) {
    {
#line 1571
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1571
    return (-1);
  } else
#line 1571
  if (! whoptr->obj) {
    {
#line 1571
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1571
    return (-1);
  } else
#line 1571
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1571
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1571
    return (-1);
  } else
#line 1571
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1571
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1571
    return (-1);
  }
  {
#line 1572
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1572
  if (! tmp) {
#line 1573
    return (-1);
  }
  {
#line 1575
  cf_object_set_flag(whoptr->obj, 28, val);
  }
#line 1576
  return (0);
}
}
#line 1579 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetBlind(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1582
  if (! whoptr) {
    {
#line 1582
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1582
    return (-1);
  } else
#line 1582
  if (! whoptr->obj) {
    {
#line 1582
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1582
    return (-1);
  } else
#line 1582
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1582
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1582
    return (-1);
  } else
#line 1582
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1582
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1582
    return (-1);
  }
  {
#line 1583
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1583
  if (! tmp) {
#line 1584
    return (-1);
  }
  {
#line 1586
  cf_object_set_flag(whoptr->obj, 92, val);
  }
#line 1587
  return (0);
}
}
#line 1590 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetKnownCursed(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1593
  if (! whoptr) {
    {
#line 1593
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1593
    return (-1);
  } else
#line 1593
  if (! whoptr->obj) {
    {
#line 1593
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1593
    return (-1);
  } else
#line 1593
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1593
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1593
    return (-1);
  } else
#line 1593
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1593
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1593
    return (-1);
  }
  {
#line 1594
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1594
  if (! tmp) {
#line 1595
    return (-1);
  }
  {
#line 1597
  cf_object_set_flag(whoptr->obj, 78, val);
  }
#line 1598
  return (0);
}
}
#line 1601 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetStealthy(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1604
  if (! whoptr) {
    {
#line 1604
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1604
    return (-1);
  } else
#line 1604
  if (! whoptr->obj) {
    {
#line 1604
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1604
    return (-1);
  } else
#line 1604
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1604
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1604
    return (-1);
  } else
#line 1604
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1604
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1604
    return (-1);
  }
  {
#line 1605
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1605
  if (! tmp) {
#line 1606
    return (-1);
  }
  {
#line 1608
  cf_object_set_flag(whoptr->obj, 71, val);
  }
#line 1609
  return (0);
}
}
#line 1612 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetConfused(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1615
  if (! whoptr) {
    {
#line 1615
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1615
    return (-1);
  } else
#line 1615
  if (! whoptr->obj) {
    {
#line 1615
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1615
    return (-1);
  } else
#line 1615
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1615
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1615
    return (-1);
  } else
#line 1615
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1615
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1615
    return (-1);
  }
  {
#line 1616
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1616
  if (! tmp) {
#line 1617
    return (-1);
  }
  {
#line 1619
  cf_object_set_flag(whoptr->obj, 70, val);
  }
#line 1620
  return (0);
}
}
#line 1623 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetSleeping(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1626
  if (! whoptr) {
    {
#line 1626
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1626
    return (-1);
  } else
#line 1626
  if (! whoptr->obj) {
    {
#line 1626
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1626
    return (-1);
  } else
#line 1626
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1626
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1626
    return (-1);
  } else
#line 1626
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1626
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1626
    return (-1);
  }
  {
#line 1627
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1627
  if (! tmp) {
#line 1628
    return (-1);
  }
  {
#line 1630
  cf_object_set_flag(whoptr->obj, 66, val);
  }
#line 1631
  return (0);
}
}
#line 1634 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetLifesaver(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1637
  if (! whoptr) {
    {
#line 1637
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1637
    return (-1);
  } else
#line 1637
  if (! whoptr->obj) {
    {
#line 1637
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1637
    return (-1);
  } else
#line 1637
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1637
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1637
    return (-1);
  } else
#line 1637
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1637
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1637
    return (-1);
  }
  {
#line 1638
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1638
  if (! tmp) {
#line 1639
    return (-1);
  }
  {
#line 1641
  cf_object_set_flag(whoptr->obj, 64, val);
  }
#line 1642
  return (0);
}
}
#line 1645 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetHasXRays(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1648
  if (! whoptr) {
    {
#line 1648
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1648
    return (-1);
  } else
#line 1648
  if (! whoptr->obj) {
    {
#line 1648
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1648
    return (-1);
  } else
#line 1648
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1648
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1648
    return (-1);
  } else
#line 1648
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1648
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1648
    return (-1);
  }
  {
#line 1649
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1649
  if (! tmp) {
#line 1650
    return (-1);
  }
  {
#line 1652
  cf_object_set_flag(whoptr->obj, 61, val);
  }
#line 1653
  return (0);
}
}
#line 1656 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetCanSeeInDark(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1659
  if (! whoptr) {
    {
#line 1659
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1659
    return (-1);
  } else
#line 1659
  if (! whoptr->obj) {
    {
#line 1659
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1659
    return (-1);
  } else
#line 1659
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1659
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1659
    return (-1);
  } else
#line 1659
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1659
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1659
    return (-1);
  }
  {
#line 1660
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1660
  if (! tmp) {
#line 1661
    return (-1);
  }
  {
#line 1663
  cf_object_set_flag(whoptr->obj, 93, val);
  }
#line 1664
  return (0);
}
}
#line 1667 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetKnownMagical(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1670
  if (! whoptr) {
    {
#line 1670
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1670
    return (-1);
  } else
#line 1670
  if (! whoptr->obj) {
    {
#line 1670
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1670
    return (-1);
  } else
#line 1670
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1670
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1670
    return (-1);
  } else
#line 1670
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1670
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1670
    return (-1);
  }
  {
#line 1671
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1671
  if (! tmp) {
#line 1672
    return (-1);
  }
  {
#line 1674
  cf_object_set_flag(whoptr->obj, 77, val);
  }
#line 1675
  return (0);
}
}
#line 1678 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetReflectSpells(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1681
  if (! whoptr) {
    {
#line 1681
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1681
    return (-1);
  } else
#line 1681
  if (! whoptr->obj) {
    {
#line 1681
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1681
    return (-1);
  } else
#line 1681
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1681
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1681
    return (-1);
  } else
#line 1681
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1681
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1681
    return (-1);
  }
  {
#line 1682
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1682
  if (! tmp) {
#line 1683
    return (-1);
  }
  {
#line 1685
  cf_object_set_flag(whoptr->obj, 40, val);
  }
#line 1686
  return (0);
}
}
#line 1689 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetReflectMissiles(Crossfire_Object *whoptr , PyObject *value ,
                                     void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1692
  if (! whoptr) {
    {
#line 1692
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1692
    return (-1);
  } else
#line 1692
  if (! whoptr->obj) {
    {
#line 1692
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1692
    return (-1);
  } else
#line 1692
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1692
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1692
    return (-1);
  } else
#line 1692
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1692
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1692
    return (-1);
  }
  {
#line 1693
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1693
  if (! tmp) {
#line 1694
    return (-1);
  }
  {
#line 1696
  cf_object_set_flag(whoptr->obj, 39, val);
  }
#line 1697
  return (0);
}
}
#line 1700 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetUnique(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1703
  if (! whoptr) {
    {
#line 1703
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1703
    return (-1);
  } else
#line 1703
  if (! whoptr->obj) {
    {
#line 1703
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1703
    return (-1);
  } else
#line 1703
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1703
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1703
    return (-1);
  } else
#line 1703
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1703
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1703
    return (-1);
  }
  {
#line 1704
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1704
  if (! tmp) {
#line 1705
    return (-1);
  }
  {
#line 1707
  cf_object_set_flag(whoptr->obj, 49, val);
  }
#line 1708
  return (0);
}
}
#line 1711 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetRunAway(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1714
  if (! whoptr) {
    {
#line 1714
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1714
    return (-1);
  } else
#line 1714
  if (! whoptr->obj) {
    {
#line 1714
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1714
    return (-1);
  } else
#line 1714
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1714
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1714
    return (-1);
  } else
#line 1714
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1714
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1714
    return (-1);
  }
  {
#line 1715
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1715
  if (! tmp) {
#line 1716
    return (-1);
  }
  {
#line 1718
  cf_object_set_flag(whoptr->obj, 45, val);
  }
#line 1719
  return (0);
}
}
#line 1722 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetScared(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1725
  if (! whoptr) {
    {
#line 1725
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1725
    return (-1);
  } else
#line 1725
  if (! whoptr->obj) {
    {
#line 1725
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1725
    return (-1);
  } else
#line 1725
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1725
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1725
    return (-1);
  } else
#line 1725
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1725
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1725
    return (-1);
  }
  {
#line 1726
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1726
  if (! tmp) {
#line 1727
    return (-1);
  }
  {
#line 1729
  cf_object_set_flag(whoptr->obj, 37, val);
  }
#line 1730
  return (0);
}
}
#line 1733 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetUndead(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1736
  if (! whoptr) {
    {
#line 1736
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1736
    return (-1);
  } else
#line 1736
  if (! whoptr->obj) {
    {
#line 1736
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1736
    return (-1);
  } else
#line 1736
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1736
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1736
    return (-1);
  } else
#line 1736
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1736
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1736
    return (-1);
  }
  {
#line 1737
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1737
  if (! tmp) {
#line 1738
    return (-1);
  }
  {
#line 1740
  cf_object_set_flag(whoptr->obj, 36, val);
  }
#line 1741
  return (0);
}
}
#line 1744 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetBlocksView(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1747
  if (! whoptr) {
    {
#line 1747
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1747
    return (-1);
  } else
#line 1747
  if (! whoptr->obj) {
    {
#line 1747
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1747
    return (-1);
  } else
#line 1747
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1747
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1747
    return (-1);
  } else
#line 1747
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1747
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1747
    return (-1);
  }
  {
#line 1748
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1748
  if (! tmp) {
#line 1749
    return (-1);
  }
  {
#line 1751
  cf_object_set_flag(whoptr->obj, 35, val);
  }
#line 1752
  return (0);
}
}
#line 1755 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetHitBack(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1758
  if (! whoptr) {
    {
#line 1758
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1758
    return (-1);
  } else
#line 1758
  if (! whoptr->obj) {
    {
#line 1758
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1758
    return (-1);
  } else
#line 1758
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1758
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1758
    return (-1);
  } else
#line 1758
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1758
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1758
    return (-1);
  }
  {
#line 1759
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1759
  if (! tmp) {
#line 1760
    return (-1);
  }
  {
#line 1762
  cf_object_set_flag(whoptr->obj, 33, val);
  }
#line 1763
  return (0);
}
}
#line 1766 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetStandStill(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1769
  if (! whoptr) {
    {
#line 1769
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1769
    return (-1);
  } else
#line 1769
  if (! whoptr->obj) {
    {
#line 1769
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1769
    return (-1);
  } else
#line 1769
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1769
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1769
    return (-1);
  } else
#line 1769
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1769
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1769
    return (-1);
  }
  {
#line 1770
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1770
  if (! tmp) {
#line 1771
    return (-1);
  }
  {
#line 1773
  cf_object_set_flag(whoptr->obj, 67, val);
  }
#line 1774
  return (0);
}
}
#line 1777 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetOnlyAttack(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1780
  if (! whoptr) {
    {
#line 1780
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1780
    return (-1);
  } else
#line 1780
  if (! whoptr->obj) {
    {
#line 1780
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1780
    return (-1);
  } else
#line 1780
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1780
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1780
    return (-1);
  } else
#line 1780
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1780
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1780
    return (-1);
  }
  {
#line 1781
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1781
  if (! tmp) {
#line 1782
    return (-1);
  }
  {
#line 1784
  cf_object_set_flag(whoptr->obj, 69, val);
  }
#line 1785
  return (0);
}
}
#line 1788 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetMakeInvisible(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1791
  if (! whoptr) {
    {
#line 1791
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1791
    return (-1);
  } else
#line 1791
  if (! whoptr->obj) {
    {
#line 1791
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1791
    return (-1);
  } else
#line 1791
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1791
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1791
    return (-1);
  } else
#line 1791
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1791
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1791
    return (-1);
  }
  {
#line 1792
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1792
  if (! tmp) {
#line 1793
    return (-1);
  }
  {
#line 1795
  cf_object_set_flag(whoptr->obj, 85, val);
  }
#line 1796
  return (0);
}
}
#line 1799 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetValue(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  long val ;
  int tmp ;

  {
#line 1802
  if (! whoptr) {
    {
#line 1802
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1802
    return (-1);
  } else
#line 1802
  if (! whoptr->obj) {
    {
#line 1802
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1802
    return (-1);
  } else
#line 1802
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1802
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1802
    return (-1);
  } else
#line 1802
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1802
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1802
    return (-1);
  }
  {
#line 1803
  tmp = PyArg_Parse(value, "l", & val);
  }
#line 1803
  if (! tmp) {
#line 1804
    return (-1);
  }
  {
#line 1806
  cf_object_set_long_property(whoptr->obj, 38, val);
  }
#line 1807
  return (0);
}
}
#line 1810 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetNoSave(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  long val ;
  int tmp ;

  {
#line 1813
  if (! whoptr) {
    {
#line 1813
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1813
    return (-1);
  } else
#line 1813
  if (! whoptr->obj) {
    {
#line 1813
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1813
    return (-1);
  } else
#line 1813
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1813
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1813
    return (-1);
  } else
#line 1813
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1813
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1813
    return (-1);
  }
  {
#line 1814
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1814
  if (! tmp) {
#line 1815
    return (-1);
  }
  {
#line 1817
  cf_object_set_flag(whoptr->obj, 13, (int )val);
  }
#line 1818
  return (0);
}
}
#line 1821 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetOwner(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  Crossfire_Object *ob ;
  int tmp ;

  {
#line 1824
  if (! whoptr) {
    {
#line 1824
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1824
    return (-1);
  } else
#line 1824
  if (! whoptr->obj) {
    {
#line 1824
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1824
    return (-1);
  } else
#line 1824
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1824
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1824
    return (-1);
  } else
#line 1824
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1824
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1824
    return (-1);
  }
  {
#line 1825
  tmp = PyArg_Parse(value, "O!", & Crossfire_ObjectType, & ob);
  }
#line 1825
  if (! tmp) {
#line 1826
    return (-1);
  }
  {
#line 1827
  cf_object_set_object_property(whoptr->obj, 73, ob->obj);
  }
#line 1828
  return (0);
}
}
#line 1831 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetEnemy(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  Crossfire_Object *ob ;
  int tmp ;

  {
#line 1834
  if (! whoptr) {
    {
#line 1834
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1834
    return (-1);
  } else
#line 1834
  if (! whoptr->obj) {
    {
#line 1834
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1834
    return (-1);
  } else
#line 1834
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1834
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1834
    return (-1);
  } else
#line 1834
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1834
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1834
    return (-1);
  }
  {
#line 1835
  tmp = PyArg_Parse(value, "O!", & Crossfire_ObjectType, & ob);
  }
#line 1835
  if (! tmp) {
#line 1836
    return (-1);
  }
  {
#line 1837
  cf_object_set_object_property(whoptr->obj, 54, ob->obj);
  }
#line 1838
  return (0);
}
}
#line 1841 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetGodGiven(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1844
  if (! whoptr) {
    {
#line 1844
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1844
    return (-1);
  } else
#line 1844
  if (! whoptr->obj) {
    {
#line 1844
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1844
    return (-1);
  } else
#line 1844
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1844
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1844
    return (-1);
  } else
#line 1844
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1844
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1844
    return (-1);
  }
  {
#line 1845
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1845
  if (! tmp) {
#line 1846
    return (-1);
  }
  {
#line 1848
  cf_object_set_flag(whoptr->obj, 34, val);
  }
#line 1849
  return (0);
}
}
#line 1852 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetNoDamage(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1855
  if (! whoptr) {
    {
#line 1855
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1855
    return (-1);
  } else
#line 1855
  if (! whoptr->obj) {
    {
#line 1855
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1855
    return (-1);
  } else
#line 1855
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1855
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1855
    return (-1);
  } else
#line 1855
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1855
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1855
    return (-1);
  }
  {
#line 1856
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1856
  if (! tmp) {
#line 1857
    return (-1);
  }
  {
#line 1859
  cf_object_set_flag(whoptr->obj, 102, val);
  }
#line 1860
  return (0);
}
}
#line 1863 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetRandomMovement(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1866
  if (! whoptr) {
    {
#line 1866
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1866
    return (-1);
  } else
#line 1866
  if (! whoptr->obj) {
    {
#line 1866
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1866
    return (-1);
  } else
#line 1866
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1866
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1866
    return (-1);
  } else
#line 1866
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1866
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1866
    return (-1);
  }
  {
#line 1867
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1867
  if (! tmp) {
#line 1868
    return (-1);
  }
  {
#line 1870
  cf_object_set_flag(whoptr->obj, 68, val);
  }
#line 1871
  return (0);
}
}
#line 1874 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetIsPet(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1877
  if (! whoptr) {
    {
#line 1877
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1877
    return (-1);
  } else
#line 1877
  if (! whoptr->obj) {
    {
#line 1877
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1877
    return (-1);
  } else
#line 1877
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1877
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1877
    return (-1);
  } else
#line 1877
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1877
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1877
    return (-1);
  }
  {
#line 1878
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1878
  if (! tmp) {
#line 1879
    return (-1);
  }
  {
#line 1881
  cf_object_set_int_property(whoptr->obj, 67, val);
  }
#line 1882
  return (0);
}
}
#line 1885 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetAttackMovement(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1888
  if (! whoptr) {
    {
#line 1888
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1888
    return (-1);
  } else
#line 1888
  if (! whoptr->obj) {
    {
#line 1888
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1888
    return (-1);
  } else
#line 1888
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1888
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1888
    return (-1);
  } else
#line 1888
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1888
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1888
    return (-1);
  }
  {
#line 1889
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1889
  if (! tmp) {
#line 1890
    return (-1);
  }
  {
#line 1892
  cf_object_set_int_property(whoptr->obj, 60, val);
  }
#line 1893
  return (0);
}
}
#line 1896 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetExp(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  sint64 val ;
  int tmp ;

  {
#line 1899
  if (! whoptr) {
    {
#line 1899
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1899
    return (-1);
  } else
#line 1899
  if (! whoptr->obj) {
    {
#line 1899
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1899
    return (-1);
  } else
#line 1899
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1899
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1899
    return (-1);
  } else
#line 1899
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1899
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1899
    return (-1);
  }
  {
#line 1900
  tmp = PyArg_Parse(value, "L", & val);
  }
#line 1900
  if (! tmp) {
#line 1901
    return (-1);
  }
  {
#line 1903
  cf_object_set_int64_property(whoptr->obj, 72, val);
  }
#line 1904
  return (0);
}
}
#line 1907 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetDuration(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1910
  if (! whoptr) {
    {
#line 1910
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1910
    return (-1);
  } else
#line 1910
  if (! whoptr->obj) {
    {
#line 1910
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1910
    return (-1);
  } else
#line 1910
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1910
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1910
    return (-1);
  } else
#line 1910
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1910
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1910
    return (-1);
  }
  {
#line 1911
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1911
  if (! tmp) {
#line 1912
    return (-1);
  }
  {
#line 1914
  cf_object_set_int_property(whoptr->obj, 109, val);
  }
#line 1915
  return (0);
}
}
#line 1918 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetGlowRadius(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1921
  if (! whoptr) {
    {
#line 1921
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1921
    return (-1);
  } else
#line 1921
  if (! whoptr->obj) {
    {
#line 1921
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1921
    return (-1);
  } else
#line 1921
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1921
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1921
    return (-1);
  } else
#line 1921
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1921
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1921
    return (-1);
  }
  {
#line 1922
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1922
  if (! tmp) {
#line 1923
    return (-1);
  }
  {
#line 1925
  cf_object_set_int_property(whoptr->obj, 51, val);
  }
#line 1926
  return (0);
}
}
#line 1929 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Object_SetAnimated(Crossfire_Object *whoptr , PyObject *value , void *closure ) 
{ 
  int val ;
  int tmp ;

  {
#line 1932
  if (! whoptr) {
    {
#line 1932
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1932
    return (-1);
  } else
#line 1932
  if (! whoptr->obj) {
    {
#line 1932
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1932
    return (-1);
  } else
#line 1932
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1932
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1932
    return (-1);
  } else
#line 1932
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1932
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1932
    return (-1);
  }
  {
#line 1933
  tmp = PyArg_Parse(value, "i", & val);
  }
#line 1933
  if (! tmp) {
#line 1934
    return (-1);
  }
  {
#line 1935
  cf_object_set_flag(whoptr->obj, 11, val);
  }
#line 1936
  return (0);
}
}
#line 1941 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_Remove(Crossfire_Object *who , PyObject *args ) 
{ 
  int tmp ;

  {
#line 1942
  if (! who) {
    {
#line 1942
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1942
    return ((PyObject *)((void *)0));
  } else
#line 1942
  if (! who->obj) {
    {
#line 1942
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1942
    return ((PyObject *)((void *)0));
  } else
#line 1942
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 1942
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1942
    return ((PyObject *)((void *)0));
  } else
#line 1942
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 1942
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1942
    return ((PyObject *)((void *)0));
  }
#line 1944
  if ((unsigned long )current_context->who != (unsigned long )((void *)0)) {
#line 1944
    if ((unsigned long )((Crossfire_Object *)current_context->who)->obj == (unsigned long )who->obj) {
#line 1945
      current_context->who = (PyObject *)((void *)0);
    }
  }
  {
#line 1947
  tmp = cf_object_get_flag(who->obj, 2);
  }
#line 1947
  if (! tmp) {
    {
#line 1948
    cf_object_remove(who->obj);
    }
  }
  {
#line 1951
  cf_object_free_drop_inventory(who->obj);
#line 1952
  (_Py_NoneStruct.ob_refcnt) ++;
  }
#line 1953
  return (& _Py_NoneStruct);
}
}
#line 1956 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_Apply(Crossfire_Object *who , PyObject *args ) 
{ 
  Crossfire_Object *whoptr ;
  int flags ;
  int tmp ;
  int tmp___0 ;
  PyObject *tmp___1 ;

  {
  {
#line 1960
  tmp = PyArg_ParseTuple(args, "O!i", & Crossfire_ObjectType, & whoptr, & flags);
  }
#line 1960
  if (! tmp) {
#line 1961
    return ((PyObject *)((void *)0));
  }
#line 1962
  if (! who) {
    {
#line 1962
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1962
    return ((PyObject *)((void *)0));
  } else
#line 1962
  if (! who->obj) {
    {
#line 1962
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1962
    return ((PyObject *)((void *)0));
  } else
#line 1962
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 1962
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1962
    return ((PyObject *)((void *)0));
  } else
#line 1962
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 1962
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1962
    return ((PyObject *)((void *)0));
  }
#line 1963
  if (! whoptr) {
    {
#line 1963
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1963
    return ((PyObject *)((void *)0));
  } else
#line 1963
  if (! whoptr->obj) {
    {
#line 1963
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1963
    return ((PyObject *)((void *)0));
  } else
#line 1963
  if ((whoptr->obj)->count != (whoptr->obj)->count) {
    {
#line 1963
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1963
    return ((PyObject *)((void *)0));
  } else
#line 1963
  if ((whoptr->obj)->flags[0] & (1U << 3)) {
    {
#line 1963
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1963
    return ((PyObject *)((void *)0));
  }
  {
#line 1965
  tmp___0 = cf_object_apply(whoptr->obj, who->obj, flags);
#line 1965
  tmp___1 = Py_BuildValue("i", tmp___0);
  }
#line 1965
  return (tmp___1);
}
}
#line 1968 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_Drop(Crossfire_Object *who , PyObject *args ) 
{ 
  Crossfire_Object *whoptr ;
  int tmp ;

  {
#line 1970
  whoptr = (Crossfire_Object *)args;
#line 1972
  if (! who) {
    {
#line 1972
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1972
    return ((PyObject *)((void *)0));
  } else
#line 1972
  if (! who->obj) {
    {
#line 1972
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1972
    return ((PyObject *)((void *)0));
  } else
#line 1972
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 1972
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1972
    return ((PyObject *)((void *)0));
  } else
#line 1972
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 1972
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 1972
    return ((PyObject *)((void *)0));
  }
#line 1973
  if (! whoptr) {
    {
#line 1973
    PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
    }
#line 1973
    return ((PyObject *)((void *)0));
  } else
#line 1973
  if ((unsigned long )((PyObject *)whoptr)->ob_type == (unsigned long )(& Crossfire_ObjectType)) {
#line 1973
    goto _L;
  } else {
    {
#line 1973
    tmp = PyType_IsSubtype(((PyObject *)whoptr)->ob_type, & Crossfire_ObjectType);
    }
#line 1973
    if (tmp) {
      _L: /* CIL Label */ 
#line 1973
      if (! whoptr->obj) {
        {
#line 1973
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 1973
        return ((PyObject *)((void *)0));
      } else
#line 1973
      if ((whoptr->obj)->count != (whoptr->obj)->count) {
        {
#line 1973
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 1973
        return ((PyObject *)((void *)0));
      } else
#line 1973
      if ((whoptr->obj)->flags[0] & (1U << 3)) {
        {
#line 1973
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 1973
        return ((PyObject *)((void *)0));
      }
    } else {
      {
#line 1973
      PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
      }
#line 1973
      return ((PyObject *)((void *)0));
    }
  }
  {
#line 1975
  cf_object_drop(whoptr->obj, who->obj);
#line 1976
  (_Py_NoneStruct.ob_refcnt) ++;
  }
#line 1977
  return (& _Py_NoneStruct);
}
}
#line 1980 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_Clone(Crossfire_Object *who , PyObject *args ) 
{ 
  int clone_type ;
  object *clone ;
  int tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 1984
  tmp = PyArg_ParseTuple(args, "i", & clone_type);
  }
#line 1984
  if (! tmp) {
#line 1985
    return ((PyObject *)((void *)0));
  }
#line 1987
  if (clone_type != 0) {
#line 1987
    if (clone_type != 1) {
      {
#line 1989
      PyErr_SetString(PyExc_ValueError, "Clone type must be 0 (object_create_clone) or 1 (object_copy).");
      }
#line 1990
      return ((PyObject *)((void *)0));
    }
  }
  {
#line 1993
  clone = cf_object_clone(who->obj, clone_type);
  }
#line 1995
  if ((unsigned long )clone == (unsigned long )((void *)0)) {
    {
#line 1997
    PyErr_SetString(PyExc_RuntimeError, "Clone failed.");
    }
#line 1998
    return ((PyObject *)((void *)0));
  }
  {
#line 2001
  tmp___0 = Crossfire_Object_wrap(clone);
  }
#line 2001
  return (tmp___0);
}
}
#line 2004 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_Split(Crossfire_Object *who , PyObject *args ) 
{ 
  int count ;
  char err[255] ;
  object *split ;
  int tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 2009
  err[0] = (char )'\000';
#line 2011
  tmp = PyArg_ParseTuple(args, "i", & count);
  }
#line 2011
  if (! tmp) {
#line 2012
    return ((PyObject *)((void *)0));
  }
  {
#line 2014
  split = cf_object_split(who->obj, (uint32 )count, err, (size_t )255);
  }
#line 2016
  if ((unsigned long )split == (unsigned long )((void *)0)) {
    {
#line 2018
    PyErr_SetString(PyExc_ValueError, (char const   *)(err));
    }
#line 2019
    return ((PyObject *)((void *)0));
  }
  {
#line 2022
  tmp___0 = Crossfire_Object_wrap(split);
  }
#line 2022
  return (tmp___0);
}
}
#line 2025 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_Fix(Crossfire_Object *who , PyObject *args ) 
{ 


  {
  {
#line 2026
  cf_fix_object(who->obj);
#line 2027
  (_Py_NoneStruct.ob_refcnt) ++;
  }
#line 2028
  return (& _Py_NoneStruct);
}
}
#line 2031 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_Take(Crossfire_Object *who , PyObject *args ) 
{ 
  Crossfire_Object *whoptr ;
  int tmp ;

  {
#line 2033
  whoptr = (Crossfire_Object *)args;
#line 2035
  if (! who) {
    {
#line 2035
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2035
    return ((PyObject *)((void *)0));
  } else
#line 2035
  if (! who->obj) {
    {
#line 2035
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2035
    return ((PyObject *)((void *)0));
  } else
#line 2035
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2035
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2035
    return ((PyObject *)((void *)0));
  } else
#line 2035
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2035
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2035
    return ((PyObject *)((void *)0));
  }
#line 2036
  if (! whoptr) {
    {
#line 2036
    PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
    }
#line 2036
    return ((PyObject *)((void *)0));
  } else
#line 2036
  if ((unsigned long )((PyObject *)whoptr)->ob_type == (unsigned long )(& Crossfire_ObjectType)) {
#line 2036
    goto _L;
  } else {
    {
#line 2036
    tmp = PyType_IsSubtype(((PyObject *)whoptr)->ob_type, & Crossfire_ObjectType);
    }
#line 2036
    if (tmp) {
      _L: /* CIL Label */ 
#line 2036
      if (! whoptr->obj) {
        {
#line 2036
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2036
        return ((PyObject *)((void *)0));
      } else
#line 2036
      if ((whoptr->obj)->count != (whoptr->obj)->count) {
        {
#line 2036
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2036
        return ((PyObject *)((void *)0));
      } else
#line 2036
      if ((whoptr->obj)->flags[0] & (1U << 3)) {
        {
#line 2036
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2036
        return ((PyObject *)((void *)0));
      }
    } else {
      {
#line 2036
      PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
      }
#line 2036
      return ((PyObject *)((void *)0));
    }
  }
  {
#line 2038
  cf_object_pickup(who->obj, whoptr->obj);
#line 2039
  (_Py_NoneStruct.ob_refcnt) ++;
  }
#line 2040
  return (& _Py_NoneStruct);
}
}
#line 2043 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_Teleport(Crossfire_Object *who , PyObject *args ) 
{ 
  Crossfire_Map *where ;
  int x ;
  int y ;
  int val ;
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 2048
  if (! who) {
    {
#line 2048
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2048
    return ((PyObject *)((void *)0));
  } else
#line 2048
  if (! who->obj) {
    {
#line 2048
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2048
    return ((PyObject *)((void *)0));
  } else
#line 2048
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2048
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2048
    return ((PyObject *)((void *)0));
  } else
#line 2048
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2048
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2048
    return ((PyObject *)((void *)0));
  }
  {
#line 2049
  tmp = PyArg_ParseTuple(args, "O!ii", & Crossfire_MapType, & where, & x, & y);
  }
#line 2049
  if (! tmp) {
#line 2050
    return ((PyObject *)((void *)0));
  }
  {
#line 2052
  val = cf_object_teleport(who->obj, where->map, x, y);
#line 2054
  tmp___0 = Py_BuildValue("i", val);
  }
#line 2054
  return (tmp___0);
}
}
#line 2057 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_ActivateRune(Crossfire_Object *who , PyObject *args ) 
{ 
  object *trap ;
  object *victim ;
  Crossfire_Object *pcause ;
  int tmp ;

  {
#line 2061
  pcause = (Crossfire_Object *)args;
#line 2063
  if (! who) {
    {
#line 2063
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2063
    return ((PyObject *)((void *)0));
  } else
#line 2063
  if (! who->obj) {
    {
#line 2063
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2063
    return ((PyObject *)((void *)0));
  } else
#line 2063
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2063
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2063
    return ((PyObject *)((void *)0));
  } else
#line 2063
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2063
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2063
    return ((PyObject *)((void *)0));
  }
#line 2064
  if (! pcause) {
    {
#line 2064
    PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
    }
#line 2064
    return ((PyObject *)((void *)0));
  } else
#line 2064
  if ((unsigned long )((PyObject *)pcause)->ob_type == (unsigned long )(& Crossfire_ObjectType)) {
#line 2064
    goto _L;
  } else {
    {
#line 2064
    tmp = PyType_IsSubtype(((PyObject *)pcause)->ob_type, & Crossfire_ObjectType);
    }
#line 2064
    if (tmp) {
      _L: /* CIL Label */ 
#line 2064
      if (! pcause->obj) {
        {
#line 2064
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2064
        return ((PyObject *)((void *)0));
      } else
#line 2064
      if ((pcause->obj)->count != (pcause->obj)->count) {
        {
#line 2064
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2064
        return ((PyObject *)((void *)0));
      } else
#line 2064
      if ((pcause->obj)->flags[0] & (1U << 3)) {
        {
#line 2064
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2064
        return ((PyObject *)((void *)0));
      }
    } else {
      {
#line 2064
      PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
      }
#line 2064
      return ((PyObject *)((void *)0));
    }
  }
  {
#line 2065
  trap = who->obj;
#line 2066
  victim = pcause->obj;
#line 2067
  cf_spring_trap(trap, victim);
#line 2068
  (_Py_NoneStruct.ob_refcnt) ++;
  }
#line 2069
  return (& _Py_NoneStruct);
}
}
#line 2072 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_CheckTrigger(Crossfire_Object *who , PyObject *args ) 
{ 
  object *trigger ;
  object *cause ;
  int result ;
  Crossfire_Object *pcause ;
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 2077
  pcause = (Crossfire_Object *)args;
#line 2079
  if (! who) {
    {
#line 2079
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2079
    return ((PyObject *)((void *)0));
  } else
#line 2079
  if (! who->obj) {
    {
#line 2079
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2079
    return ((PyObject *)((void *)0));
  } else
#line 2079
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2079
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2079
    return ((PyObject *)((void *)0));
  } else
#line 2079
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2079
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2079
    return ((PyObject *)((void *)0));
  }
#line 2080
  if (! pcause) {
    {
#line 2080
    PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
    }
#line 2080
    return ((PyObject *)((void *)0));
  } else
#line 2080
  if ((unsigned long )((PyObject *)pcause)->ob_type == (unsigned long )(& Crossfire_ObjectType)) {
#line 2080
    goto _L;
  } else {
    {
#line 2080
    tmp = PyType_IsSubtype(((PyObject *)pcause)->ob_type, & Crossfire_ObjectType);
    }
#line 2080
    if (tmp) {
      _L: /* CIL Label */ 
#line 2080
      if (! pcause->obj) {
        {
#line 2080
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2080
        return ((PyObject *)((void *)0));
      } else
#line 2080
      if ((pcause->obj)->count != (pcause->obj)->count) {
        {
#line 2080
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2080
        return ((PyObject *)((void *)0));
      } else
#line 2080
      if ((pcause->obj)->flags[0] & (1U << 3)) {
        {
#line 2080
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2080
        return ((PyObject *)((void *)0));
      }
    } else {
      {
#line 2080
      PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
      }
#line 2080
      return ((PyObject *)((void *)0));
    }
  }
  {
#line 2081
  trigger = who->obj;
#line 2082
  cause = pcause->obj;
#line 2083
  result = cf_object_check_trigger(trigger, cause);
#line 2085
  tmp___0 = Py_BuildValue("i", result);
  }
#line 2085
  return (tmp___0);
}
}
#line 2088 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_Say(Crossfire_Object *who , PyObject *args ) 
{ 
  char *message ;
  char buf[2048] ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 2091
  if (! who) {
    {
#line 2091
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2091
    return ((PyObject *)((void *)0));
  } else
#line 2091
  if (! who->obj) {
    {
#line 2091
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2091
    return ((PyObject *)((void *)0));
  } else
#line 2091
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2091
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2091
    return ((PyObject *)((void *)0));
  } else
#line 2091
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2091
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2091
    return ((PyObject *)((void *)0));
  }
  {
#line 2092
  tmp = PyArg_ParseTuple(args, "s", & message);
  }
#line 2092
  if (! tmp) {
#line 2093
    return ((PyObject *)((void *)0));
  }
#line 2096
  if ((unsigned long )current_context->talk == (unsigned long )((void *)0)) {
    {
#line 2097
    cf_object_say(who->obj, message);
#line 2098
    (_Py_NoneStruct.ob_refcnt) ++;
    }
#line 2099
    return (& _Py_NoneStruct);
  }
#line 2102
  if ((current_context->talk)->npc_msg_count == 5) {
    {
#line 2103
    PyErr_SetString(PyExc_ValueError, "too many NPCs");
    }
#line 2104
    return ((PyObject *)((void *)0));
  }
  {
#line 2107
  tmp___0 = strlen((char const   *)message);
  }
#line 2107
  if (tmp___0 >= sizeof(buf) - 1UL) {
    {
#line 2108
    cf_log((LogLevel )0, "warning, too long message in npcSay, will be truncated");
    }
  }
  {
#line 2110
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s says: %s",
           (who->obj)->name, message);
#line 2112
  (current_context->talk)->npc_msgs[(current_context->talk)->npc_msg_count] = cf_add_string((char const   *)(buf));
#line 2113
  ((current_context->talk)->npc_msg_count) ++;
#line 2115
  (_Py_NoneStruct.ob_refcnt) ++;
  }
#line 2116
  return (& _Py_NoneStruct);
}
}
#line 2120 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_Reposition(Crossfire_Object *who , PyObject *args ) 
{ 
  int x ;
  int y ;
  int tmp ;

  {
#line 2123
  if (! who) {
    {
#line 2123
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2123
    return ((PyObject *)((void *)0));
  } else
#line 2123
  if (! who->obj) {
    {
#line 2123
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2123
    return ((PyObject *)((void *)0));
  } else
#line 2123
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2123
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2123
    return ((PyObject *)((void *)0));
  } else
#line 2123
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2123
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2123
    return ((PyObject *)((void *)0));
  }
  {
#line 2124
  tmp = PyArg_ParseTuple(args, "ii", & x, & y);
  }
#line 2124
  if (! tmp) {
#line 2125
    return ((PyObject *)((void *)0));
  }
  {
#line 2127
  cf_object_transfer(who->obj, x, y, 0, (object *)((void *)0));
#line 2128
  (_Py_NoneStruct.ob_refcnt) ++;
  }
#line 2129
  return (& _Py_NoneStruct);
}
}
#line 2132 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_QueryName(Crossfire_Object *who , PyObject *args ) 
{ 
  char name[200] ;
  char *tmp ;
  PyObject *tmp___0 ;

  {
#line 2135
  if (! who) {
    {
#line 2135
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2135
    return ((PyObject *)((void *)0));
  } else
#line 2135
  if (! who->obj) {
    {
#line 2135
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2135
    return ((PyObject *)((void *)0));
  } else
#line 2135
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2135
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2135
    return ((PyObject *)((void *)0));
  } else
#line 2135
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2135
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2135
    return ((PyObject *)((void *)0));
  }
  {
#line 2136
  tmp = cf_query_name(who->obj, name, (int )sizeof(name));
#line 2136
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 2136
  return (tmp___0);
}
}
#line 2139 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_GetResist(Crossfire_Object *who , PyObject *args ) 
{ 
  int resist ;
  int tmp ;
  PyObject *tmp___0 ;
  sint16 tmp___1 ;
  PyObject *tmp___2 ;

  {
#line 2142
  if (! who) {
    {
#line 2142
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2142
    return ((PyObject *)((void *)0));
  } else
#line 2142
  if (! who->obj) {
    {
#line 2142
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2142
    return ((PyObject *)((void *)0));
  } else
#line 2142
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2142
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2142
    return ((PyObject *)((void *)0));
  } else
#line 2142
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2142
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2142
    return ((PyObject *)((void *)0));
  }
  {
#line 2143
  tmp = PyArg_ParseTuple(args, "i", & resist);
  }
#line 2143
  if (! tmp) {
#line 2144
    return ((PyObject *)((void *)0));
  }
#line 2145
  if (resist < 0) {
    {
#line 2146
    tmp___0 = Py_BuildValue("l", 0);
    }
#line 2146
    return (tmp___0);
  } else
#line 2145
  if (resist >= 26) {
    {
#line 2146
    tmp___0 = Py_BuildValue("l", 0);
    }
#line 2146
    return (tmp___0);
  }
  {
#line 2148
  tmp___1 = cf_object_get_resistance(who->obj, resist);
#line 2148
  tmp___2 = Py_BuildValue("i", (int )tmp___1);
  }
#line 2148
  return (tmp___2);
}
}
#line 2151 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_SetResist(Crossfire_Object *who , PyObject *args ) 
{ 
  int resist ;
  int value ;
  int tmp ;

  {
#line 2154
  if (! who) {
    {
#line 2154
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2154
    return ((PyObject *)((void *)0));
  } else
#line 2154
  if (! who->obj) {
    {
#line 2154
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2154
    return ((PyObject *)((void *)0));
  } else
#line 2154
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2154
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2154
    return ((PyObject *)((void *)0));
  } else
#line 2154
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2154
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2154
    return ((PyObject *)((void *)0));
  }
  {
#line 2155
  tmp = PyArg_ParseTuple(args, "ii", & resist, & value);
  }
#line 2155
  if (! tmp) {
#line 2156
    return ((PyObject *)((void *)0));
  }
#line 2157
  if (resist >= 0) {
#line 2157
    if (resist < 26) {
      {
#line 2158
      cf_object_set_resistance(who->obj, resist, (sint16 )value);
      }
    }
  }
#line 2159
  (_Py_NoneStruct.ob_refcnt) ++;
#line 2160
  return (& _Py_NoneStruct);
}
}
#line 2163 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_QueryCost(Crossfire_Object *who , PyObject *args ) 
{ 
  int flags ;
  Crossfire_Object *pcause ;
  int tmp ;
  int tmp___0 ;
  PyObject *tmp___1 ;

  {
  {
#line 2167
  tmp = PyArg_ParseTuple(args, "O!i", & Crossfire_ObjectType, & pcause, & flags);
  }
#line 2167
  if (! tmp) {
#line 2168
    return ((PyObject *)((void *)0));
  }
#line 2169
  if (! who) {
    {
#line 2169
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2169
    return ((PyObject *)((void *)0));
  } else
#line 2169
  if (! who->obj) {
    {
#line 2169
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2169
    return ((PyObject *)((void *)0));
  } else
#line 2169
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2169
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2169
    return ((PyObject *)((void *)0));
  } else
#line 2169
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2169
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2169
    return ((PyObject *)((void *)0));
  }
#line 2170
  if (! pcause) {
    {
#line 2170
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2170
    return ((PyObject *)((void *)0));
  } else
#line 2170
  if (! pcause->obj) {
    {
#line 2170
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2170
    return ((PyObject *)((void *)0));
  } else
#line 2170
  if ((pcause->obj)->count != (pcause->obj)->count) {
    {
#line 2170
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2170
    return ((PyObject *)((void *)0));
  } else
#line 2170
  if ((pcause->obj)->flags[0] & (1U << 3)) {
    {
#line 2170
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2170
    return ((PyObject *)((void *)0));
  }
  {
#line 2171
  tmp___0 = cf_object_query_cost((object const   *)who->obj, pcause->obj, flags);
#line 2171
  tmp___1 = Py_BuildValue("i", tmp___0);
  }
#line 2171
  return (tmp___1);
}
}
#line 2174 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_Cast(Crossfire_Object *who , PyObject *args ) 
{ 
  int dir ;
  char *op ;
  Crossfire_Object *pspell ;
  int tmp ;

  {
  {
#line 2179
  tmp = PyArg_ParseTuple(args, "O!is", & Crossfire_ObjectType, & pspell, & dir, & op);
  }
#line 2179
  if (! tmp) {
#line 2180
    return ((PyObject *)((void *)0));
  }
#line 2181
  if (! who) {
    {
#line 2181
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2181
    return ((PyObject *)((void *)0));
  } else
#line 2181
  if (! who->obj) {
    {
#line 2181
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2181
    return ((PyObject *)((void *)0));
  } else
#line 2181
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2181
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2181
    return ((PyObject *)((void *)0));
  } else
#line 2181
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2181
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2181
    return ((PyObject *)((void *)0));
  }
#line 2182
  if (! pspell) {
    {
#line 2182
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2182
    return ((PyObject *)((void *)0));
  } else
#line 2182
  if (! pspell->obj) {
    {
#line 2182
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2182
    return ((PyObject *)((void *)0));
  } else
#line 2182
  if ((pspell->obj)->count != (pspell->obj)->count) {
    {
#line 2182
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2182
    return ((PyObject *)((void *)0));
  } else
#line 2182
  if ((pspell->obj)->flags[0] & (1U << 3)) {
    {
#line 2182
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2182
    return ((PyObject *)((void *)0));
  }
  {
#line 2184
  cf_object_cast_spell(who->obj, who->obj, dir, pspell->obj, op);
#line 2186
  (_Py_NoneStruct.ob_refcnt) ++;
  }
#line 2187
  return (& _Py_NoneStruct);
}
}
#line 2190 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_LearnSpell(Crossfire_Object *who , PyObject *args ) 
{ 
  Crossfire_Object *pspell ;
  int tmp ;

  {
#line 2192
  pspell = (Crossfire_Object *)args;
#line 2194
  if (! who) {
    {
#line 2194
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2194
    return ((PyObject *)((void *)0));
  } else
#line 2194
  if (! who->obj) {
    {
#line 2194
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2194
    return ((PyObject *)((void *)0));
  } else
#line 2194
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2194
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2194
    return ((PyObject *)((void *)0));
  } else
#line 2194
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2194
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2194
    return ((PyObject *)((void *)0));
  }
#line 2195
  if (! pspell) {
    {
#line 2195
    PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
    }
#line 2195
    return ((PyObject *)((void *)0));
  } else
#line 2195
  if ((unsigned long )((PyObject *)pspell)->ob_type == (unsigned long )(& Crossfire_ObjectType)) {
#line 2195
    goto _L;
  } else {
    {
#line 2195
    tmp = PyType_IsSubtype(((PyObject *)pspell)->ob_type, & Crossfire_ObjectType);
    }
#line 2195
    if (tmp) {
      _L: /* CIL Label */ 
#line 2195
      if (! pspell->obj) {
        {
#line 2195
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2195
        return ((PyObject *)((void *)0));
      } else
#line 2195
      if ((pspell->obj)->count != (pspell->obj)->count) {
        {
#line 2195
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2195
        return ((PyObject *)((void *)0));
      } else
#line 2195
      if ((pspell->obj)->flags[0] & (1U << 3)) {
        {
#line 2195
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2195
        return ((PyObject *)((void *)0));
      }
    } else {
      {
#line 2195
      PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
      }
#line 2195
      return ((PyObject *)((void *)0));
    }
  }
  {
#line 2197
  cf_object_learn_spell(who->obj, pspell->obj, 0);
#line 2199
  (_Py_NoneStruct.ob_refcnt) ++;
  }
#line 2200
  return (& _Py_NoneStruct);
}
}
#line 2203 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_ForgetSpell(Crossfire_Object *who , PyObject *args ) 
{ 
  Crossfire_Object *pspell ;
  int tmp ;

  {
#line 2205
  pspell = (Crossfire_Object *)args;
#line 2207
  if (! who) {
    {
#line 2207
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2207
    return ((PyObject *)((void *)0));
  } else
#line 2207
  if (! who->obj) {
    {
#line 2207
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2207
    return ((PyObject *)((void *)0));
  } else
#line 2207
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2207
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2207
    return ((PyObject *)((void *)0));
  } else
#line 2207
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2207
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2207
    return ((PyObject *)((void *)0));
  }
#line 2208
  if (! pspell) {
    {
#line 2208
    PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
    }
#line 2208
    return ((PyObject *)((void *)0));
  } else
#line 2208
  if ((unsigned long )((PyObject *)pspell)->ob_type == (unsigned long )(& Crossfire_ObjectType)) {
#line 2208
    goto _L;
  } else {
    {
#line 2208
    tmp = PyType_IsSubtype(((PyObject *)pspell)->ob_type, & Crossfire_ObjectType);
    }
#line 2208
    if (tmp) {
      _L: /* CIL Label */ 
#line 2208
      if (! pspell->obj) {
        {
#line 2208
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2208
        return ((PyObject *)((void *)0));
      } else
#line 2208
      if ((pspell->obj)->count != (pspell->obj)->count) {
        {
#line 2208
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2208
        return ((PyObject *)((void *)0));
      } else
#line 2208
      if ((pspell->obj)->flags[0] & (1U << 3)) {
        {
#line 2208
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2208
        return ((PyObject *)((void *)0));
      }
    } else {
      {
#line 2208
      PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
      }
#line 2208
      return ((PyObject *)((void *)0));
    }
  }
  {
#line 2210
  cf_object_forget_spell(who->obj, pspell->obj);
#line 2211
  (_Py_NoneStruct.ob_refcnt) ++;
  }
#line 2212
  return (& _Py_NoneStruct);
}
}
#line 2215 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_KnowSpell(Crossfire_Object *who , PyObject *args ) 
{ 
  char *spellname ;
  object *op ;
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 2219
  if (! who) {
    {
#line 2219
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2219
    return ((PyObject *)((void *)0));
  } else
#line 2219
  if (! who->obj) {
    {
#line 2219
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2219
    return ((PyObject *)((void *)0));
  } else
#line 2219
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2219
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2219
    return ((PyObject *)((void *)0));
  } else
#line 2219
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2219
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2219
    return ((PyObject *)((void *)0));
  }
  {
#line 2220
  tmp = PyArg_ParseTuple(args, "s", & spellname);
  }
#line 2220
  if (! tmp) {
#line 2221
    return ((PyObject *)((void *)0));
  }
  {
#line 2223
  op = cf_object_check_for_spell(who->obj, (char const   *)spellname);
#line 2225
  tmp___0 = Crossfire_Object_wrap(op);
  }
#line 2225
  return (tmp___0);
}
}
#line 2228 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_CastAbility(Crossfire_Object *who , PyObject *args ) 
{ 
  Crossfire_Object *pspell ;
  int dir ;
  char *str ;
  int tmp ;

  {
  {
#line 2233
  tmp = PyArg_ParseTuple(args, "O!is", & Crossfire_ObjectType, & pspell, & dir, & str);
  }
#line 2233
  if (! tmp) {
#line 2234
    return ((PyObject *)((void *)0));
  }
#line 2235
  if (! who) {
    {
#line 2235
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2235
    return ((PyObject *)((void *)0));
  } else
#line 2235
  if (! who->obj) {
    {
#line 2235
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2235
    return ((PyObject *)((void *)0));
  } else
#line 2235
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2235
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2235
    return ((PyObject *)((void *)0));
  } else
#line 2235
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2235
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2235
    return ((PyObject *)((void *)0));
  }
#line 2236
  if (! pspell) {
    {
#line 2236
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2236
    return ((PyObject *)((void *)0));
  } else
#line 2236
  if (! pspell->obj) {
    {
#line 2236
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2236
    return ((PyObject *)((void *)0));
  } else
#line 2236
  if ((pspell->obj)->count != (pspell->obj)->count) {
    {
#line 2236
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2236
    return ((PyObject *)((void *)0));
  } else
#line 2236
  if ((pspell->obj)->flags[0] & (1U << 3)) {
    {
#line 2236
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2236
    return ((PyObject *)((void *)0));
  }
  {
#line 2238
  cf_object_cast_ability(who->obj, who->obj, dir, pspell->obj, str);
#line 2240
  (_Py_NoneStruct.ob_refcnt) ++;
  }
#line 2241
  return (& _Py_NoneStruct);
}
}
#line 2244 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_PayAmount(Crossfire_Object *who , PyObject *args ) 
{ 
  uint64 to_pay ;
  int val ;
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 2248
  if (! who) {
    {
#line 2248
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2248
    return ((PyObject *)((void *)0));
  } else
#line 2248
  if (! who->obj) {
    {
#line 2248
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2248
    return ((PyObject *)((void *)0));
  } else
#line 2248
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2248
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2248
    return ((PyObject *)((void *)0));
  } else
#line 2248
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2248
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2248
    return ((PyObject *)((void *)0));
  }
  {
#line 2249
  tmp = PyArg_ParseTuple(args, "L", & to_pay);
  }
#line 2249
  if (! tmp) {
#line 2250
    return ((PyObject *)((void *)0));
  }
  {
#line 2252
  val = cf_object_pay_amount(who->obj, to_pay);
#line 2254
  tmp___0 = Py_BuildValue("i", val);
  }
#line 2254
  return (tmp___0);
}
}
#line 2257 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_Pay(Crossfire_Object *who , PyObject *args ) 
{ 
  Crossfire_Object *op ;
  int val ;
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 2259
  op = (Crossfire_Object *)args;
#line 2262
  if (! who) {
    {
#line 2262
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2262
    return ((PyObject *)((void *)0));
  } else
#line 2262
  if (! who->obj) {
    {
#line 2262
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2262
    return ((PyObject *)((void *)0));
  } else
#line 2262
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2262
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2262
    return ((PyObject *)((void *)0));
  } else
#line 2262
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2262
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2262
    return ((PyObject *)((void *)0));
  }
#line 2263
  if (! op) {
    {
#line 2263
    PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
    }
#line 2263
    return ((PyObject *)((void *)0));
  } else
#line 2263
  if ((unsigned long )((PyObject *)op)->ob_type == (unsigned long )(& Crossfire_ObjectType)) {
#line 2263
    goto _L;
  } else {
    {
#line 2263
    tmp = PyType_IsSubtype(((PyObject *)op)->ob_type, & Crossfire_ObjectType);
    }
#line 2263
    if (tmp) {
      _L: /* CIL Label */ 
#line 2263
      if (! op->obj) {
        {
#line 2263
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2263
        return ((PyObject *)((void *)0));
      } else
#line 2263
      if ((op->obj)->count != (op->obj)->count) {
        {
#line 2263
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2263
        return ((PyObject *)((void *)0));
      } else
#line 2263
      if ((op->obj)->flags[0] & (1U << 3)) {
        {
#line 2263
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2263
        return ((PyObject *)((void *)0));
      }
    } else {
      {
#line 2263
      PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
      }
#line 2263
      return ((PyObject *)((void *)0));
    }
  }
  {
#line 2265
  val = cf_object_pay_item(who->obj, op->obj);
#line 2267
  tmp___0 = Py_BuildValue("i", val);
  }
#line 2267
  return (tmp___0);
}
}
#line 2270 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_ReadKey(Crossfire_Object *who , PyObject *args ) 
{ 
  char const   *val ;
  char *keyname ;
  int tmp ;
  char const   *tmp___0 ;
  PyObject *tmp___1 ;

  {
#line 2274
  if (! who) {
    {
#line 2274
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2274
    return ((PyObject *)((void *)0));
  } else
#line 2274
  if (! who->obj) {
    {
#line 2274
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2274
    return ((PyObject *)((void *)0));
  } else
#line 2274
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2274
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2274
    return ((PyObject *)((void *)0));
  } else
#line 2274
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2274
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2274
    return ((PyObject *)((void *)0));
  }
  {
#line 2275
  tmp = PyArg_ParseTuple(args, "s", & keyname);
  }
#line 2275
  if (! tmp) {
#line 2276
    return ((PyObject *)((void *)0));
  }
  {
#line 2278
  val = cf_object_get_key(who->obj, (char const   *)keyname);
  }
#line 2280
  if (val) {
#line 2280
    tmp___0 = val;
  } else {
#line 2280
    tmp___0 = "";
  }
  {
#line 2280
  tmp___1 = Py_BuildValue("s", tmp___0);
  }
#line 2280
  return (tmp___1);
}
}
#line 2283 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_WriteKey(Crossfire_Object *who , PyObject *args ) 
{ 
  char *keyname ;
  char *value ;
  int add_key ;
  int tmp ;
  int tmp___0 ;
  PyObject *tmp___1 ;

  {
#line 2286
  add_key = 0;
#line 2288
  if (! who) {
    {
#line 2288
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2288
    return ((PyObject *)((void *)0));
  } else
#line 2288
  if (! who->obj) {
    {
#line 2288
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2288
    return ((PyObject *)((void *)0));
  } else
#line 2288
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2288
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2288
    return ((PyObject *)((void *)0));
  } else
#line 2288
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2288
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2288
    return ((PyObject *)((void *)0));
  }
  {
#line 2289
  tmp = PyArg_ParseTuple(args, "ss|i", & keyname, & value, & add_key);
  }
#line 2289
  if (! tmp) {
#line 2290
    return ((PyObject *)((void *)0));
  }
  {
#line 2292
  tmp___0 = cf_object_set_key(who->obj, (char const   *)keyname, (char const   *)value,
                              add_key);
#line 2292
  tmp___1 = Py_BuildValue("i", tmp___0);
  }
#line 2292
  return (tmp___1);
}
}
#line 2295 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_CreateTimer(Crossfire_Object *who , PyObject *args ) 
{ 
  int mode ;
  long delay ;
  int tmp ;
  int tmp___0 ;
  PyObject *tmp___1 ;

  {
#line 2299
  if (! who) {
    {
#line 2299
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2299
    return ((PyObject *)((void *)0));
  } else
#line 2299
  if (! who->obj) {
    {
#line 2299
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2299
    return ((PyObject *)((void *)0));
  } else
#line 2299
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2299
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2299
    return ((PyObject *)((void *)0));
  } else
#line 2299
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2299
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2299
    return ((PyObject *)((void *)0));
  }
  {
#line 2300
  tmp = PyArg_ParseTuple(args, "li", & delay, & mode);
  }
#line 2300
  if (! tmp) {
#line 2301
    return ((PyObject *)((void *)0));
  }
  {
#line 2303
  tmp___0 = cf_timer_create(who->obj, delay, mode);
#line 2303
  tmp___1 = Py_BuildValue("i", tmp___0);
  }
#line 2303
  return (tmp___1);
}
}
#line 2306 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_CheckInventory(Crossfire_Object *who , PyObject *args ) 
{ 
  char *whatstr ;
  object *foundob ;
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 2310
  if (! who) {
    {
#line 2310
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2310
    return ((PyObject *)((void *)0));
  } else
#line 2310
  if (! who->obj) {
    {
#line 2310
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2310
    return ((PyObject *)((void *)0));
  } else
#line 2310
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2310
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2310
    return ((PyObject *)((void *)0));
  } else
#line 2310
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2310
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2310
    return ((PyObject *)((void *)0));
  }
  {
#line 2311
  tmp = PyArg_ParseTuple(args, "s", & whatstr);
  }
#line 2311
  if (! tmp) {
#line 2312
    return ((PyObject *)((void *)0));
  }
  {
#line 2314
  foundob = cf_object_present_archname_inside(who->obj, whatstr);
#line 2316
  tmp___0 = Crossfire_Object_wrap(foundob);
  }
#line 2316
  return (tmp___0);
}
}
#line 2329 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_CheckArchInventory(Crossfire_Object *who , PyObject *args ) 
{ 
  char *whatstr ;
  object *tmp ;
  int tmp___0 ;
  PyObject *tmp___1 ;

  {
#line 2333
  if (! who) {
    {
#line 2333
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2333
    return ((PyObject *)((void *)0));
  } else
#line 2333
  if (! who->obj) {
    {
#line 2333
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2333
    return ((PyObject *)((void *)0));
  } else
#line 2333
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2333
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2333
    return ((PyObject *)((void *)0));
  } else
#line 2333
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2333
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2333
    return ((PyObject *)((void *)0));
  }
  {
#line 2334
  tmp___0 = PyArg_ParseTuple(args, "s", & whatstr);
  }
#line 2334
  if (! tmp___0) {
#line 2335
    return ((PyObject *)((void *)0));
  }
  {
#line 2337
  tmp = cf_object_find_by_arch_name((object const   *)who->obj, (char const   *)whatstr);
#line 2338
  tmp___1 = Crossfire_Object_wrap(tmp);
  }
#line 2338
  return (tmp___1);
}
}
#line 2341 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_GetOutOfMap(Crossfire_Object *who , PyObject *args ) 
{ 
  int x ;
  int y ;
  int tmp ;
  int tmp___0 ;
  PyObject *tmp___1 ;

  {
#line 2344
  if (! who) {
    {
#line 2344
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2344
    return ((PyObject *)((void *)0));
  } else
#line 2344
  if (! who->obj) {
    {
#line 2344
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2344
    return ((PyObject *)((void *)0));
  } else
#line 2344
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2344
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2344
    return ((PyObject *)((void *)0));
  } else
#line 2344
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2344
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2344
    return ((PyObject *)((void *)0));
  }
  {
#line 2345
  tmp = PyArg_ParseTuple(args, "ii", & x, & y);
  }
#line 2345
  if (! tmp) {
#line 2346
    return ((PyObject *)((void *)0));
  }
  {
#line 2348
  tmp___0 = cf_object_out_of_map(who->obj, x, y);
#line 2348
  tmp___1 = Py_BuildValue("i", tmp___0);
  }
#line 2348
  return (tmp___1);
}
}
#line 2351 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_CreateInside(Crossfire_Object *who , PyObject *args ) 
{ 
  char *txt ;
  object *myob ;
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 2355
  if (! who) {
    {
#line 2355
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2355
    return ((PyObject *)((void *)0));
  } else
#line 2355
  if (! who->obj) {
    {
#line 2355
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2355
    return ((PyObject *)((void *)0));
  } else
#line 2355
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2355
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2355
    return ((PyObject *)((void *)0));
  } else
#line 2355
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2355
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2355
    return ((PyObject *)((void *)0));
  }
  {
#line 2356
  tmp = PyArg_ParseTuple(args, "s", & txt);
  }
#line 2356
  if (! tmp) {
#line 2357
    return ((PyObject *)((void *)0));
  }
  {
#line 2359
  myob = cf_create_object_by_name((char const   *)txt);
  }
#line 2360
  if (myob) {
    {
#line 2361
    myob = cf_object_insert_object(myob, who->obj);
    }
  }
  {
#line 2363
  tmp___0 = Crossfire_Object_wrap(myob);
  }
#line 2363
  return (tmp___0);
}
}
#line 2366 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_InsertInto(Crossfire_Object *who , PyObject *args ) 
{ 
  Crossfire_Object *op ;
  object *myob ;
  int tmp ;
  int tmp___0 ;
  PyObject *tmp___1 ;

  {
#line 2368
  op = (Crossfire_Object *)args;
#line 2371
  if (! who) {
    {
#line 2371
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2371
    return ((PyObject *)((void *)0));
  } else
#line 2371
  if (! who->obj) {
    {
#line 2371
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2371
    return ((PyObject *)((void *)0));
  } else
#line 2371
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2371
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2371
    return ((PyObject *)((void *)0));
  } else
#line 2371
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2371
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2371
    return ((PyObject *)((void *)0));
  }
#line 2372
  if (! op) {
    {
#line 2372
    PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
    }
#line 2372
    return ((PyObject *)((void *)0));
  } else
#line 2372
  if ((unsigned long )((PyObject *)op)->ob_type == (unsigned long )(& Crossfire_ObjectType)) {
#line 2372
    goto _L;
  } else {
    {
#line 2372
    tmp = PyType_IsSubtype(((PyObject *)op)->ob_type, & Crossfire_ObjectType);
    }
#line 2372
    if (tmp) {
      _L: /* CIL Label */ 
#line 2372
      if (! op->obj) {
        {
#line 2372
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2372
        return ((PyObject *)((void *)0));
      } else
#line 2372
      if ((op->obj)->count != (op->obj)->count) {
        {
#line 2372
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2372
        return ((PyObject *)((void *)0));
      } else
#line 2372
      if ((op->obj)->flags[0] & (1U << 3)) {
        {
#line 2372
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2372
        return ((PyObject *)((void *)0));
      }
    } else {
      {
#line 2372
      PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
      }
#line 2372
      return ((PyObject *)((void *)0));
    }
  }
  {
#line 2377
  tmp___0 = cf_object_get_flag(who->obj, 2);
  }
#line 2377
  if (! tmp___0) {
    {
#line 2378
    cf_object_remove(who->obj);
    }
  }
  {
#line 2380
  myob = cf_object_insert_in_ob(who->obj, op->obj);
#line 2382
  tmp___1 = Crossfire_Object_wrap(myob);
  }
#line 2382
  return (tmp___1);
}
}
#line 2385 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_ChangeAbil(Crossfire_Object *who , PyObject *args ) 
{ 
  Crossfire_Object *op ;
  int tmp ;
  int tmp___0 ;
  PyObject *tmp___1 ;

  {
#line 2387
  op = (Crossfire_Object *)args;
#line 2389
  if (! who) {
    {
#line 2389
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2389
    return ((PyObject *)((void *)0));
  } else
#line 2389
  if (! who->obj) {
    {
#line 2389
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2389
    return ((PyObject *)((void *)0));
  } else
#line 2389
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2389
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2389
    return ((PyObject *)((void *)0));
  } else
#line 2389
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2389
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2389
    return ((PyObject *)((void *)0));
  }
#line 2390
  if (! op) {
    {
#line 2390
    PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
    }
#line 2390
    return ((PyObject *)((void *)0));
  } else
#line 2390
  if ((unsigned long )((PyObject *)op)->ob_type == (unsigned long )(& Crossfire_ObjectType)) {
#line 2390
    goto _L;
  } else {
    {
#line 2390
    tmp = PyType_IsSubtype(((PyObject *)op)->ob_type, & Crossfire_ObjectType);
    }
#line 2390
    if (tmp) {
      _L: /* CIL Label */ 
#line 2390
      if (! op->obj) {
        {
#line 2390
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2390
        return ((PyObject *)((void *)0));
      } else
#line 2390
      if ((op->obj)->count != (op->obj)->count) {
        {
#line 2390
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2390
        return ((PyObject *)((void *)0));
      } else
#line 2390
      if ((op->obj)->flags[0] & (1U << 3)) {
        {
#line 2390
        PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
        }
#line 2390
        return ((PyObject *)((void *)0));
      }
    } else {
      {
#line 2390
      PyErr_SetString(PyExc_ReferenceError, "Not a Crossfire object or Crossfire object no longer exists");
      }
#line 2390
      return ((PyObject *)((void *)0));
    }
  }
  {
#line 2392
  tmp___0 = cf_object_change_abil(who->obj, op->obj);
#line 2392
  tmp___1 = Py_BuildValue("i", tmp___0);
  }
#line 2392
  return (tmp___1);
}
}
#line 2395 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_AddExp(Crossfire_Object *who , PyObject *args ) 
{ 
  sint64 exp___0 ;
  char const   *skill ;
  int arg ;
  int tmp ;

  {
  {
#line 2397
  skill = (char const   *)((void *)0);
#line 2398
  arg = 0;
#line 2400
  tmp = PyArg_ParseTuple(args, "L|si", & exp___0, & skill, & arg);
  }
#line 2400
  if (! tmp) {
#line 2401
    return ((PyObject *)((void *)0));
  }
#line 2402
  if (! who) {
    {
#line 2402
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2402
    return ((PyObject *)((void *)0));
  } else
#line 2402
  if (! who->obj) {
    {
#line 2402
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2402
    return ((PyObject *)((void *)0));
  } else
#line 2402
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2402
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2402
    return ((PyObject *)((void *)0));
  } else
#line 2402
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2402
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2402
    return ((PyObject *)((void *)0));
  }
  {
#line 2403
  cf_object_change_exp(who->obj, exp___0, skill, arg);
#line 2404
  (_Py_NoneStruct.ob_refcnt) ++;
  }
#line 2405
  return (& _Py_NoneStruct);
}
}
#line 2408 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_Move(Crossfire_Object *who , PyObject *args ) 
{ 
  int dir ;
  int tmp ;
  int tmp___0 ;
  PyObject *tmp___1 ;

  {
  {
#line 2411
  tmp = PyArg_ParseTuple(args, "i", & dir);
  }
#line 2411
  if (! tmp) {
#line 2412
    return ((PyObject *)((void *)0));
  }
#line 2413
  if (! who) {
    {
#line 2413
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2413
    return ((PyObject *)((void *)0));
  } else
#line 2413
  if (! who->obj) {
    {
#line 2413
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2413
    return ((PyObject *)((void *)0));
  } else
#line 2413
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2413
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2413
    return ((PyObject *)((void *)0));
  } else
#line 2413
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2413
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2413
    return ((PyObject *)((void *)0));
  }
  {
#line 2414
  tmp___0 = cf_object_move(who->obj, dir, who->obj);
#line 2414
  tmp___1 = Py_BuildValue("i", tmp___0);
  }
#line 2414
  return (tmp___1);
}
}
#line 2417 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_Event(Crossfire_Object *who , PyObject *args ) 
{ 
  int fix ;
  char const   *message ;
  object *op1 ;
  object *op2 ;
  object *op3 ;
  Crossfire_Object *activator ;
  Crossfire_Object *third ;
  int tmp ;
  int tmp___0 ;
  PyObject *tmp___1 ;

  {
  {
#line 2419
  message = (char const   *)((void *)0);
#line 2420
  op1 = (object *)((void *)0);
#line 2421
  op2 = (object *)((void *)0);
#line 2422
  op3 = (object *)((void *)0);
#line 2423
  activator = (Crossfire_Object *)((void *)0);
#line 2424
  third = (Crossfire_Object *)((void *)0);
#line 2426
  tmp = PyArg_ParseTuple(args, "O!O!si", & Crossfire_ObjectType, & activator, & Crossfire_ObjectType,
                         & third, & message, & fix);
  }
#line 2426
  if (! tmp) {
#line 2427
    return ((PyObject *)((void *)0));
  }
#line 2428
  if (! who) {
    {
#line 2428
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2428
    return ((PyObject *)((void *)0));
  } else
#line 2428
  if (! who->obj) {
    {
#line 2428
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2428
    return ((PyObject *)((void *)0));
  } else
#line 2428
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2428
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2428
    return ((PyObject *)((void *)0));
  } else
#line 2428
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2428
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2428
    return ((PyObject *)((void *)0));
  }
#line 2429
  if (! activator) {
    {
#line 2429
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2429
    return ((PyObject *)((void *)0));
  } else
#line 2429
  if (! activator->obj) {
    {
#line 2429
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2429
    return ((PyObject *)((void *)0));
  } else
#line 2429
  if ((activator->obj)->count != (activator->obj)->count) {
    {
#line 2429
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2429
    return ((PyObject *)((void *)0));
  } else
#line 2429
  if ((activator->obj)->flags[0] & (1U << 3)) {
    {
#line 2429
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2429
    return ((PyObject *)((void *)0));
  }
#line 2430
  if (! third) {
    {
#line 2430
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2430
    return ((PyObject *)((void *)0));
  } else
#line 2430
  if (! third->obj) {
    {
#line 2430
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2430
    return ((PyObject *)((void *)0));
  } else
#line 2430
  if ((third->obj)->count != (third->obj)->count) {
    {
#line 2430
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2430
    return ((PyObject *)((void *)0));
  } else
#line 2430
  if ((third->obj)->flags[0] & (1U << 3)) {
    {
#line 2430
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2430
    return ((PyObject *)((void *)0));
  }
  {
#line 2431
  op1 = who->obj;
#line 2432
  op2 = activator->obj;
#line 2433
  op3 = third->obj;
#line 2434
  tmp___0 = cf_object_user_event(op1, op2, op3, message, fix);
#line 2434
  tmp___1 = Py_BuildValue("i", tmp___0);
  }
#line 2434
  return (tmp___1);
}
}
#line 2437 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_RemoveDepletion(Crossfire_Object *who , PyObject *args ) 
{ 
  int level ;
  int tmp ;
  int tmp___0 ;
  PyObject *tmp___1 ;

  {
  {
#line 2440
  tmp = PyArg_ParseTuple(args, "i", & level);
  }
#line 2440
  if (! tmp) {
#line 2441
    return ((PyObject *)((void *)0));
  }
#line 2442
  if (! who) {
    {
#line 2442
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2442
    return ((PyObject *)((void *)0));
  } else
#line 2442
  if (! who->obj) {
    {
#line 2442
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2442
    return ((PyObject *)((void *)0));
  } else
#line 2442
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2442
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2442
    return ((PyObject *)((void *)0));
  } else
#line 2442
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2442
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2442
    return ((PyObject *)((void *)0));
  }
  {
#line 2444
  tmp___0 = cf_object_remove_depletion(who->obj, level);
#line 2444
  tmp___1 = Py_BuildValue("i", tmp___0);
  }
#line 2444
  return (tmp___1);
}
}
#line 2447 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_Arrest(Crossfire_Object *who , PyObject *args ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 2448
  if (! who) {
    {
#line 2448
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2448
    return ((PyObject *)((void *)0));
  } else
#line 2448
  if (! who->obj) {
    {
#line 2448
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2448
    return ((PyObject *)((void *)0));
  } else
#line 2448
  if ((who->obj)->count != (who->obj)->count) {
    {
#line 2448
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2448
    return ((PyObject *)((void *)0));
  } else
#line 2448
  if ((who->obj)->flags[0] & (1U << 3)) {
    {
#line 2448
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2448
    return ((PyObject *)((void *)0));
  }
  {
#line 2449
  tmp = cf_player_arrest(who->obj);
#line 2449
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 2449
  return (tmp___0);
}
}
#line 2452 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static int Crossfire_Object_InternalCompare(Crossfire_Object *left , Crossfire_Object *right ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 2453
  if (! left) {
    {
#line 2453
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2453
    return (-1);
  } else
#line 2453
  if (! left->obj) {
    {
#line 2453
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2453
    return (-1);
  } else
#line 2453
  if ((left->obj)->count != (left->obj)->count) {
    {
#line 2453
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2453
    return (-1);
  } else
#line 2453
  if ((left->obj)->flags[0] & (1U << 3)) {
    {
#line 2453
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2453
    return (-1);
  }
#line 2454
  if (! right) {
    {
#line 2454
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2454
    return (-1);
  } else
#line 2454
  if (! right->obj) {
    {
#line 2454
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2454
    return (-1);
  } else
#line 2454
  if ((right->obj)->count != (right->obj)->count) {
    {
#line 2454
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2454
    return (-1);
  } else
#line 2454
  if ((right->obj)->flags[0] & (1U << 3)) {
    {
#line 2454
    PyErr_SetString(PyExc_ReferenceError, "Crossfire object no longer exists");
    }
#line 2454
    return (-1);
  }
#line 2455
  if ((unsigned long )left->obj < (unsigned long )right->obj) {
#line 2455
    tmp___0 = -1;
  } else {
#line 2455
    if ((unsigned long )left->obj == (unsigned long )right->obj) {
#line 2455
      tmp = 0;
    } else {
#line 2455
      tmp = 1;
    }
#line 2455
    tmp___0 = tmp;
  }
#line 2455
  return (tmp___0);
}
}
#line 2458 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_RichCompare(Crossfire_Object *left , Crossfire_Object *right ,
                                              int op ) 
{ 
  int result ;
  int tmp ;
  int tmp___0 ;
  PyObject *tmp___1 ;
  PyObject *tmp___2 ;

  {
#line 2460
  if (! left) {
#line 2464
    (_Py_NotImplementedStruct.ob_refcnt) ++;
#line 2465
    return (& _Py_NotImplementedStruct);
  } else
#line 2460
  if (! right) {
#line 2464
    (_Py_NotImplementedStruct.ob_refcnt) ++;
#line 2465
    return (& _Py_NotImplementedStruct);
  } else
#line 2460
  if ((unsigned long )((PyObject *)left)->ob_type == (unsigned long )(& Crossfire_ObjectType)) {
#line 2460
    goto _L;
  } else {
    {
#line 2460
    tmp = PyType_IsSubtype(((PyObject *)left)->ob_type, & Crossfire_ObjectType);
    }
#line 2460
    if (tmp) {
      _L: /* CIL Label */ 
#line 2460
      if (! ((unsigned long )((PyObject *)right)->ob_type == (unsigned long )(& Crossfire_ObjectType))) {
        {
#line 2460
        tmp___0 = PyType_IsSubtype(((PyObject *)right)->ob_type, & Crossfire_ObjectType);
        }
#line 2460
        if (! tmp___0) {
#line 2464
          (_Py_NotImplementedStruct.ob_refcnt) ++;
#line 2465
          return (& _Py_NotImplementedStruct);
        }
      }
    } else {
#line 2464
      (_Py_NotImplementedStruct.ob_refcnt) ++;
#line 2465
      return (& _Py_NotImplementedStruct);
    }
  }
  {
#line 2467
  result = Crossfire_Object_InternalCompare(left, right);
  }
#line 2469
  if (result == -1) {
    {
#line 2469
    tmp___1 = PyErr_Occurred();
    }
#line 2469
    if (tmp___1) {
#line 2470
      return ((PyObject *)((void *)0));
    }
  }
  {
#line 2473
  if (op == 2) {
#line 2473
    goto case_2;
  }
#line 2476
  if (op == 3) {
#line 2476
    goto case_3;
  }
#line 2479
  if (op == 1) {
#line 2479
    goto case_1;
  }
#line 2482
  if (op == 5) {
#line 2482
    goto case_5;
  }
#line 2485
  if (op == 0) {
#line 2485
    goto case_0;
  }
#line 2488
  if (op == 4) {
#line 2488
    goto case_4;
  }
#line 2472
  goto switch_break;
  case_2: /* CIL Label */ 
#line 2474
  result = result == 0;
#line 2475
  goto switch_break;
  case_3: /* CIL Label */ 
#line 2477
  result = result != 0;
#line 2478
  goto switch_break;
  case_1: /* CIL Label */ 
#line 2480
  result = result <= 0;
#line 2481
  goto switch_break;
  case_5: /* CIL Label */ 
#line 2483
  result = result >= 0;
#line 2484
  goto switch_break;
  case_0: /* CIL Label */ 
#line 2486
  result = result == -1;
#line 2487
  goto switch_break;
  case_4: /* CIL Label */ 
#line 2489
  result = result == 1;
#line 2490
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 2492
  tmp___2 = PyBool_FromLong((long )result);
  }
#line 2492
  return (tmp___2);
}
}
#line 2496 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_Long(PyObject *obj ) 
{ 
  PyObject *tmp ;

  {
  {
#line 2497
  tmp = Py_BuildValue("l", ((Crossfire_Object *)obj)->obj);
  }
#line 2497
  return (tmp);
}
}
#line 2501 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_Int(PyObject *obj ) 
{ 
  PyObject *tmp ;

  {
  {
#line 2502
  tmp = Py_BuildValue("i", ((Crossfire_Object *)obj)->obj);
  }
#line 2502
  return (tmp);
}
}
#line 2509 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Object_new(PyTypeObject *type , PyObject *args , PyObject *kwds ) 
{ 
  Crossfire_Object *self ;
  PyObject *tmp ;

  {
  {
#line 2512
  tmp = (*(type->tp_alloc))(type, (Py_ssize_t )0);
#line 2512
  self = (Crossfire_Object *)tmp;
  }
#line 2513
  if (self) {
#line 2514
    self->obj = (object *)((void *)0);
#line 2515
    self->count = (tag_t )0;
  }
#line 2518
  return ((PyObject *)self);
}
}
#line 2521 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static PyObject *Crossfire_Player_new(PyTypeObject *type , PyObject *args , PyObject *kwds ) 
{ 
  Crossfire_Player *self ;
  PyObject *tmp ;

  {
  {
#line 2524
  tmp = (*(type->tp_alloc))(type, (Py_ssize_t )0);
#line 2524
  self = (Crossfire_Player *)tmp;
  }
#line 2525
  if (self) {
#line 2526
    self->obj = (object *)((void *)0);
#line 2527
    self->count = (tag_t )0;
  }
#line 2530
  return ((PyObject *)self);
}
}
#line 2533 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static void Crossfire_Object_dealloc(PyObject *obj ) 
{ 
  Crossfire_Object *self ;

  {
#line 2536
  self = (Crossfire_Object *)obj;
#line 2537
  if (self) {
#line 2538
    if (self->obj) {
      {
#line 2539
      free_object_assoc(self->obj);
      }
    }
    {
#line 2541
    (*((((PyObject *)self)->ob_type)->tp_free))((void *)obj);
    }
  }
#line 2543
  return;
}
}
#line 2545 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
static void Crossfire_Player_dealloc(PyObject *obj ) 
{ 
  Crossfire_Player *self ;

  {
#line 2548
  self = (Crossfire_Player *)obj;
#line 2549
  if (self) {
#line 2550
    if (self->obj) {
      {
#line 2551
      free_object_assoc(self->obj);
      }
    }
    {
#line 2553
    (*((((PyObject *)self)->ob_type)->tp_free))((void *)obj);
    }
  }
#line 2555
  return;
}
}
#line 2557 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_object.c"
PyObject *Crossfire_Object_wrap(object *what ) 
{ 
  Crossfire_Object *wrapper ;
  Crossfire_Player *plwrap ;
  PyObject *pyobj ;
  void *tmp ;
  PyObject *tmp___0 ;
  void *tmp___1 ;
  PyObject *tmp___2 ;

  {
#line 2563
  if ((unsigned long )what == (unsigned long )((void *)0)) {
#line 2564
    (_Py_NoneStruct.ob_refcnt) ++;
#line 2565
    return (& _Py_NoneStruct);
  }
  {
#line 2568
  pyobj = find_assoc_pyobject(what);
  }
#line 2569
  if (! pyobj) {
#line 2569
    goto _L___0;
  } else
#line 2569
  if ((((Crossfire_Object *)pyobj)->obj)->count != ((Crossfire_Object *)pyobj)->count) {
#line 2569
    goto _L___0;
  } else
#line 2569
  if ((((Crossfire_Object *)pyobj)->obj)->flags[0] & (1U << 3)) {
    _L___0: /* CIL Label */ 
#line 2570
    if ((int )what->type == 1) {
      {
#line 2571
      tmp = PyObject_Malloc((size_t )Crossfire_PlayerType.tp_basicsize);
#line 2571
      tmp___0 = PyObject_Init((PyObject *)tmp, & Crossfire_PlayerType);
#line 2571
      plwrap = (Crossfire_Player *)tmp___0;
      }
#line 2572
      if ((unsigned long )plwrap != (unsigned long )((void *)0)) {
#line 2573
        plwrap->obj = what;
#line 2574
        plwrap->count = what->count;
      }
#line 2576
      pyobj = (PyObject *)plwrap;
    } else {
      {
#line 2578
      tmp___1 = PyObject_Malloc((size_t )Crossfire_ObjectType.tp_basicsize);
#line 2578
      tmp___2 = PyObject_Init((PyObject *)tmp___1, & Crossfire_ObjectType);
#line 2578
      wrapper = (Crossfire_Object *)tmp___2;
      }
#line 2579
      if ((unsigned long )wrapper != (unsigned long )((void *)0)) {
#line 2580
        wrapper->obj = what;
#line 2581
        wrapper->count = what->count;
      }
#line 2583
      pyobj = (PyObject *)wrapper;
    }
    {
#line 2585
    add_object_assoc(what, pyobj);
    }
  } else {
#line 2587
    (pyobj->ob_refcnt) ++;
  }
#line 2589
  return (pyobj);
}
}
#line 19 "./include/cfpython_proto.h"
void init_map_assoc_table(void) ;
#line 20
void Handle_Map_Unload_Hook(Crossfire_Map *map ) ;
#line 29 "./include/cfpython_map_private.h"
static PyObject *Map_GetDifficulty(Crossfire_Map *whoptr , void *closure ) ;
#line 30
static PyObject *Map_GetPath(Crossfire_Map *whoptr , void *closure ) ;
#line 31
static PyObject *Map_GetTempName(Crossfire_Map *whoptr , void *closure ) ;
#line 32
static PyObject *Map_GetName(Crossfire_Map *whoptr , void *closure ) ;
#line 33
static PyObject *Map_GetResetTime(Crossfire_Map *whoptr , void *closure ) ;
#line 34
static PyObject *Map_GetResetTimeout(Crossfire_Map *whoptr , void *closure ) ;
#line 35
static PyObject *Map_GetPlayers(Crossfire_Map *whoptr , void *closure ) ;
#line 36
static PyObject *Map_GetDarkness(Crossfire_Map *whoptr , void *closure ) ;
#line 37
static PyObject *Map_GetWidth(Crossfire_Map *whoptr , void *closure ) ;
#line 38
static PyObject *Map_GetHeight(Crossfire_Map *whoptr , void *closure ) ;
#line 39
static PyObject *Map_GetEnterX(Crossfire_Map *whoptr , void *closure ) ;
#line 40
static PyObject *Map_GetEnterY(Crossfire_Map *whoptr , void *closure ) ;
#line 41
static PyObject *Map_GetMessage(Crossfire_Map *whoptr , void *closure ) ;
#line 42
static PyObject *Map_GetRegion(Crossfire_Map *whoptr , void *closure ) ;
#line 43
static PyObject *Map_GetUnique(Crossfire_Map *whoptr , void *closure ) ;
#line 45
static int Map_SetPath(Crossfire_Map *whoptr , PyObject *value , void *closure ) ;
#line 47
static PyObject *Map_Message(Crossfire_Map *map , PyObject *args ) ;
#line 48
static PyObject *Map_GetFirstObjectAt(Crossfire_Map *map , PyObject *args ) ;
#line 49
static PyObject *Map_CreateObject(Crossfire_Map *map , PyObject *args ) ;
#line 50
static PyObject *Map_Check(Crossfire_Map *map , PyObject *args ) ;
#line 51
static PyObject *Map_Next(Crossfire_Map *map , PyObject *args ) ;
#line 52
static PyObject *Map_Insert(Crossfire_Map *map , PyObject *args ) ;
#line 53
static PyObject *Map_InsertAround(Crossfire_Map *map , PyObject *args ) ;
#line 54
static PyObject *Map_ChangeLight(Crossfire_Map *map , PyObject *args ) ;
#line 55
static PyObject *Map_TriggerConnected(Crossfire_Map *map , PyObject *args ) ;
#line 57
static int Map_InternalCompare(Crossfire_Map *left , Crossfire_Map *right ) ;
#line 58
static PyObject *Crossfire_Map_RichCompare(Crossfire_Map *left , Crossfire_Map *right ,
                                           int op ) ;
#line 60
static PyObject *Crossfire_Map_Long(PyObject *obj ) ;
#line 62
static PyObject *Crossfire_Map_Int(PyObject *obj ) ;
#line 64
static void Crossfire_Map_dealloc(PyObject *obj ) ;
#line 65
static PyObject *Crossfire_Map_new(PyTypeObject *type , PyObject *args , PyObject *kwds ) ;
#line 68 "./include/cfpython_map_private.h"
static PyGetSetDef Map_getseters[17]  = 
#line 68
  {      {(char *)"Difficulty", (PyObject *(*)(PyObject * , void * ))(& Map_GetDifficulty),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Path", (PyObject *(*)(PyObject * , void * ))(& Map_GetPath), (int (*)(PyObject * ,
                                                                                     PyObject * ,
                                                                                     void * ))(& Map_SetPath),
      (char *)((void *)0), (void *)0}, 
        {(char *)"TempName", (PyObject *(*)(PyObject * , void * ))(& Map_GetTempName),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Name", (PyObject *(*)(PyObject * , void * ))(& Map_GetName), (int (*)(PyObject * ,
                                                                                     PyObject * ,
                                                                                     void * ))((void *)0),
      (char *)((void *)0), (void *)0}, 
        {(char *)"ResetTime", (PyObject *(*)(PyObject * , void * ))(& Map_GetResetTime),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"ResetTimeout", (PyObject *(*)(PyObject * , void * ))(& Map_GetResetTimeout),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Players", (PyObject *(*)(PyObject * , void * ))(& Map_GetPlayers),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Light", (PyObject *(*)(PyObject * , void * ))(& Map_GetDarkness), (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          void * ))((void *)0),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Darkness", (PyObject *(*)(PyObject * , void * ))(& Map_GetDarkness),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Width", (PyObject *(*)(PyObject * , void * ))(& Map_GetWidth), (int (*)(PyObject * ,
                                                                                       PyObject * ,
                                                                                       void * ))((void *)0),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Height", (PyObject *(*)(PyObject * , void * ))(& Map_GetHeight), (int (*)(PyObject * ,
                                                                                         PyObject * ,
                                                                                         void * ))((void *)0),
      (char *)((void *)0), (void *)0}, 
        {(char *)"EnterX", (PyObject *(*)(PyObject * , void * ))(& Map_GetEnterX), (int (*)(PyObject * ,
                                                                                         PyObject * ,
                                                                                         void * ))((void *)0),
      (char *)((void *)0), (void *)0}, 
        {(char *)"EnterY", (PyObject *(*)(PyObject * , void * ))(& Map_GetEnterY), (int (*)(PyObject * ,
                                                                                         PyObject * ,
                                                                                         void * ))((void *)0),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Message", (PyObject *(*)(PyObject * , void * ))(& Map_GetMessage),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Region", (PyObject *(*)(PyObject * , void * ))(& Map_GetRegion), (int (*)(PyObject * ,
                                                                                         PyObject * ,
                                                                                         void * ))((void *)0),
      (char *)((void *)0), (void *)0}, 
        {(char *)"Unique", (PyObject *(*)(PyObject * , void * ))(& Map_GetUnique), (int (*)(PyObject * ,
                                                                                         PyObject * ,
                                                                                         void * ))((void *)0),
      (char *)((void *)0), (void *)0}, 
        {(char *)((void *)0), (PyObject *(*)(PyObject * , void * ))((void *)0), (int (*)(PyObject * ,
                                                                                      PyObject * ,
                                                                                      void * ))((void *)0),
      (char *)((void *)0), (void *)0}};
#line 88 "./include/cfpython_map_private.h"
static PyMethodDef MapMethods[10]  = 
#line 88
  {      {"Print", (PyObject *(*)(PyObject * , PyObject * ))(& Map_Message), 1, (char const   *)((void *)0)}, 
        {"ObjectAt",
      (PyObject *(*)(PyObject * , PyObject * ))(& Map_GetFirstObjectAt), 1, (char const   *)((void *)0)}, 
        {"CreateObject",
      (PyObject *(*)(PyObject * , PyObject * ))(& Map_CreateObject), 1, (char const   *)((void *)0)}, 
        {"Check",
      (PyObject *(*)(PyObject * , PyObject * ))(& Map_Check), 1, (char const   *)((void *)0)}, 
        {"Next",
      (PyObject *(*)(PyObject * , PyObject * ))(& Map_Next), 4, (char const   *)((void *)0)}, 
        {"Insert",
      (PyObject *(*)(PyObject * , PyObject * ))(& Map_Insert), 1, (char const   *)((void *)0)}, 
        {"InsertAround",
      (PyObject *(*)(PyObject * , PyObject * ))(& Map_InsertAround), 1, (char const   *)((void *)0)}, 
        {"ChangeLight",
      (PyObject *(*)(PyObject * , PyObject * ))(& Map_ChangeLight), 1, (char const   *)((void *)0)}, 
        {"TriggerConnected",
      (PyObject *(*)(PyObject * , PyObject * ))(& Map_TriggerConnected), 1, (char const   *)((void *)0)}, 
        {(char const   *)((void *)0),
      (PyObject *(*)(PyObject * , PyObject * ))((void *)0), 0, (char const   *)((void *)0)}};
#line 101 "./include/cfpython_map_private.h"
static PyNumberMethods MapConvert  = 
#line 101
     {(PyObject *(*)(PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                         PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                         PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                         PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * ))((void *)0), (PyObject *(*)(PyObject * ))((void *)0),
    (int (*)(PyObject * ))((void *)0), (PyObject *(*)(PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                                               PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                         PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                         PyObject * ))((void *)0),
    (int (*)(PyObject ** , PyObject ** ))((void *)0), & Crossfire_Map_Int, & Crossfire_Map_Long,
    (PyObject *(*)(PyObject * ))((void *)0), (PyObject *(*)(PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * ))((void *)0), (PyObject *(*)(PyObject * , PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                         PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                         PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                                      PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                         PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                         PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                         PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * , PyObject * ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                         PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * ))((void *)0)};
#line 167 "./include/cfpython_map_private.h"
PyTypeObject Crossfire_MapType  = 
#line 167
     {(Py_ssize_t )1, (struct _typeobject *)((void *)0), (Py_ssize_t )0, "Crossfire.Map",
    (Py_ssize_t )sizeof(Crossfire_Map ), (Py_ssize_t )0, & Crossfire_Map_dealloc,
    (int (*)(PyObject * , FILE * , int  ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                      char * ))((void *)0),
    (int (*)(PyObject * , char * , PyObject * ))((void *)0), (int (*)(PyObject * ,
                                                                      PyObject * ))(& Map_InternalCompare),
    (PyObject *(*)(PyObject * ))((void *)0), & MapConvert, (PySequenceMethods *)((void *)0),
    (PyMappingMethods *)((void *)0), & PyObject_HashNotImplemented, (PyObject *(*)(PyObject * ,
                                                                                   PyObject * ,
                                                                                   PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * ))((void *)0), & PyObject_GenericGetAttr, & PyObject_GenericSetAttr,
    (PyBufferProcs *)((void *)0), (((((((1L | (1L << 1)) | (1L << 3)) | (1L << 5)) | (1L << 6)) | (1L << 7)) | (1L << 8)) | (1L << 17)) | (1L << 10),
    "Crossfire maps", (int (*)(PyObject * , int (*)(PyObject * , void * ) , void * ))((void *)0),
    (int (*)(PyObject * ))((void *)0), (PyObject *(*)(PyObject * , PyObject * , int  ))(& Crossfire_Map_RichCompare),
    (Py_ssize_t )0, (PyObject *(*)(PyObject * ))((void *)0), (PyObject *(*)(PyObject * ))((void *)0),
    MapMethods, (struct PyMemberDef *)((void *)0), Map_getseters, (struct _typeobject *)((void *)0),
    (PyObject *)((void *)0), (PyObject *(*)(PyObject * , PyObject * , PyObject * ))((void *)0),
    (int (*)(PyObject * , PyObject * , PyObject * ))((void *)0), (Py_ssize_t )0, (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          PyObject * ))((void *)0),
    (PyObject *(*)(struct _typeobject * , Py_ssize_t  ))((void *)0), & Crossfire_Map_new,
    (void (*)(void * ))((void *)0), (int (*)(PyObject * ))((void *)0), (PyObject *)((void *)0),
    (PyObject *)((void *)0), (PyObject *)((void *)0), (PyObject *)((void *)0), (PyObject *)((void *)0),
    (void (*)(PyObject * ))((void *)0), 0U};
#line 35 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static ptr_assoc_table map_assoc_table  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
void init_map_assoc_table(void) 
{ 


  {
  {
#line 39
  init_ptr_assoc_table(map_assoc_table);
  }
#line 40
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static void add_map_assoc(mapstruct *key , Crossfire_Map *value ) 
{ 


  {
  {
#line 43
  add_ptr_assoc(map_assoc_table, (void *)key, (void *)value);
  }
#line 44
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *find_assoc_pymap(mapstruct *key ) 
{ 
  void *tmp ;

  {
  {
#line 47
  tmp = find_assoc_value(map_assoc_table, (void *)key);
  }
#line 47
  return ((PyObject *)tmp);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static void free_map_assoc(mapstruct *key ) 
{ 


  {
  {
#line 51
  free_ptr_assoc(map_assoc_table, (void *)key);
  }
#line 52
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static void ensure_map_in_memory(Crossfire_Map *map ) 
{ 
  char *mapname ;
  int is_unique ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 57
  if (! ((unsigned long )map->map != (unsigned long )((void *)0))) {
    {
#line 57
    __assert_fail("map->map != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c",
                  57U, "ensure_map_in_memory");
    }
  }
#line 58
  if ((map->map)->in_memory != 1U) {
    {
#line 59
    mapname = (map->map)->path;
#line 60
    tmp = cf_map_get_int_property(map->map, 25);
#line 60
    is_unique = tmp;
    }
#line 62
    if (is_unique) {
      {
#line 63
      tmp___1 = strdup((char const   *)mapname);
#line 63
      tmp___0 = tmp___1;
      }
#line 64
      if (! tmp___0) {
        {
#line 66
        cf_log((LogLevel )0, "Out of memory in ensure_map_in_memory()!\n");
#line 67
        abort();
        }
      }
#line 69
      mapname = tmp___0;
    }
    {
#line 71
    cf_log((LogLevel )2, "MAP %s AIN\'T READY ! Loading it...\n", mapname);
    }
#line 74
    if (is_unique) {
#line 74
      tmp___2 = 2;
    } else {
#line 74
      tmp___2 = 0;
    }
    {
#line 74
    map->map = cf_map_get_map((char const   *)mapname, tmp___2);
    }
#line 75
    if (is_unique) {
      {
#line 76
      free((void *)mapname);
      }
    }
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_GetDifficulty(Crossfire_Map *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 81
  if (! whoptr) {
    {
#line 81
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 81
    return ((PyObject *)((void *)0));
  } else
#line 81
  if (whoptr->valid == 0) {
    {
#line 81
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 81
    return ((PyObject *)((void *)0));
  }
  {
#line 82
  tmp = cf_map_get_difficulty(whoptr->map);
#line 82
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 82
  return (tmp___0);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_GetPath(Crossfire_Map *whoptr , void *closure ) 
{ 
  sstring tmp ;
  PyObject *tmp___0 ;

  {
#line 86
  if (! whoptr) {
    {
#line 86
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 86
    return ((PyObject *)((void *)0));
  } else
#line 86
  if (whoptr->valid == 0) {
    {
#line 86
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 86
    return ((PyObject *)((void *)0));
  }
  {
#line 87
  tmp = cf_map_get_sstring_property(whoptr->map, 2);
#line 87
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 87
  return (tmp___0);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_GetTempName(Crossfire_Map *whoptr , void *closure ) 
{ 
  sstring tmp ;
  PyObject *tmp___0 ;

  {
#line 91
  if (! whoptr) {
    {
#line 91
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 91
    return ((PyObject *)((void *)0));
  } else
#line 91
  if (whoptr->valid == 0) {
    {
#line 91
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 91
    return ((PyObject *)((void *)0));
  }
  {
#line 92
  tmp = cf_map_get_sstring_property(whoptr->map, 3);
#line 92
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 92
  return (tmp___0);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_GetName(Crossfire_Map *whoptr , void *closure ) 
{ 
  sstring tmp ;
  PyObject *tmp___0 ;

  {
#line 96
  if (! whoptr) {
    {
#line 96
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 96
    return ((PyObject *)((void *)0));
  } else
#line 96
  if (whoptr->valid == 0) {
    {
#line 96
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 96
    return ((PyObject *)((void *)0));
  }
  {
#line 97
  tmp = cf_map_get_sstring_property(whoptr->map, 4);
#line 97
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 97
  return (tmp___0);
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_GetResetTime(Crossfire_Map *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 101
  if (! whoptr) {
    {
#line 101
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 101
    return ((PyObject *)((void *)0));
  } else
#line 101
  if (whoptr->valid == 0) {
    {
#line 101
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 101
    return ((PyObject *)((void *)0));
  }
  {
#line 102
  tmp = cf_map_get_reset_time(whoptr->map);
#line 102
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 102
  return (tmp___0);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_GetResetTimeout(Crossfire_Map *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 106
  if (! whoptr) {
    {
#line 106
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 106
    return ((PyObject *)((void *)0));
  } else
#line 106
  if (whoptr->valid == 0) {
    {
#line 106
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 106
    return ((PyObject *)((void *)0));
  }
  {
#line 107
  tmp = cf_map_get_reset_timeout(whoptr->map);
#line 107
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 107
  return (tmp___0);
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_GetPlayers(Crossfire_Map *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 111
  if (! whoptr) {
    {
#line 111
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 111
    return ((PyObject *)((void *)0));
  } else
#line 111
  if (whoptr->valid == 0) {
    {
#line 111
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 111
    return ((PyObject *)((void *)0));
  }
  {
#line 112
  tmp = cf_map_get_players(whoptr->map);
#line 112
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 112
  return (tmp___0);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_GetDarkness(Crossfire_Map *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 116
  if (! whoptr) {
    {
#line 116
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 116
    return ((PyObject *)((void *)0));
  } else
#line 116
  if (whoptr->valid == 0) {
    {
#line 116
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 116
    return ((PyObject *)((void *)0));
  }
  {
#line 117
  tmp = cf_map_get_darkness(whoptr->map);
#line 117
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 117
  return (tmp___0);
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_GetWidth(Crossfire_Map *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 121
  if (! whoptr) {
    {
#line 121
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 121
    return ((PyObject *)((void *)0));
  } else
#line 121
  if (whoptr->valid == 0) {
    {
#line 121
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 121
    return ((PyObject *)((void *)0));
  }
  {
#line 122
  tmp = cf_map_get_width(whoptr->map);
#line 122
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 122
  return (tmp___0);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_GetHeight(Crossfire_Map *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 126
  if (! whoptr) {
    {
#line 126
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 126
    return ((PyObject *)((void *)0));
  } else
#line 126
  if (whoptr->valid == 0) {
    {
#line 126
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 126
    return ((PyObject *)((void *)0));
  }
  {
#line 127
  tmp = cf_map_get_height(whoptr->map);
#line 127
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 127
  return (tmp___0);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_GetEnterX(Crossfire_Map *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 131
  if (! whoptr) {
    {
#line 131
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 131
    return ((PyObject *)((void *)0));
  } else
#line 131
  if (whoptr->valid == 0) {
    {
#line 131
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 131
    return ((PyObject *)((void *)0));
  }
  {
#line 132
  tmp = cf_map_get_int_property(whoptr->map, 12);
#line 132
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 132
  return (tmp___0);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_GetEnterY(Crossfire_Map *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 136
  if (! whoptr) {
    {
#line 136
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 136
    return ((PyObject *)((void *)0));
  } else
#line 136
  if (whoptr->valid == 0) {
    {
#line 136
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 136
    return ((PyObject *)((void *)0));
  }
  {
#line 137
  tmp = cf_map_get_enter_x(whoptr->map);
#line 137
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 137
  return (tmp___0);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_GetMessage(Crossfire_Map *whoptr , void *closure ) 
{ 
  sstring tmp ;
  PyObject *tmp___0 ;

  {
#line 141
  if (! whoptr) {
    {
#line 141
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 141
    return ((PyObject *)((void *)0));
  } else
#line 141
  if (whoptr->valid == 0) {
    {
#line 141
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 141
    return ((PyObject *)((void *)0));
  }
  {
#line 142
  tmp = cf_map_get_sstring_property(whoptr->map, 22);
#line 142
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 142
  return (tmp___0);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_GetRegion(Crossfire_Map *whoptr , void *closure ) 
{ 
  region *tmp ;
  PyObject *tmp___0 ;

  {
#line 146
  if (! whoptr) {
    {
#line 146
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 146
    return ((PyObject *)((void *)0));
  } else
#line 146
  if (whoptr->valid == 0) {
    {
#line 146
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 146
    return ((PyObject *)((void *)0));
  }
  {
#line 147
  tmp = cf_map_get_region_property(whoptr->map, 24);
#line 147
  tmp___0 = Crossfire_Region_wrap(tmp);
  }
#line 147
  return (tmp___0);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static int Map_SetPath(Crossfire_Map *whoptr , PyObject *value , void *closure ) 
{ 
  char const   *val ;
  int tmp ;

  {
#line 153
  if (! whoptr) {
    {
#line 153
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 153
    return (-1);
  } else
#line 153
  if (whoptr->valid == 0) {
    {
#line 153
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 153
    return (-1);
  }
  {
#line 154
  tmp = PyArg_Parse(value, "s", & val);
  }
#line 154
  if (! tmp) {
#line 155
    return (-1);
  }
  {
#line 157
  cf_map_set_string_property(whoptr->map, 2, val);
  }
#line 158
  return (0);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_GetUnique(Crossfire_Map *whoptr , void *closure ) 
{ 
  int tmp ;
  PyObject *tmp___0 ;

  {
#line 163
  if (! whoptr) {
    {
#line 163
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 163
    return ((PyObject *)((void *)0));
  } else
#line 163
  if (whoptr->valid == 0) {
    {
#line 163
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 163
    return ((PyObject *)((void *)0));
  }
  {
#line 164
  tmp = cf_map_get_int_property(whoptr->map, 25);
#line 164
  tmp___0 = Py_BuildValue("i", tmp);
  }
#line 164
  return (tmp___0);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_Message(Crossfire_Map *map , PyObject *args ) 
{ 
  int color ;
  char *message ;
  int tmp ;

  {
  {
#line 168
  color = 261;
#line 171
  tmp = PyArg_ParseTuple(args, "s|i", & message, & color);
  }
#line 171
  if (! tmp) {
#line 172
    return ((PyObject *)((void *)0));
  }
#line 174
  if (! map) {
    {
#line 174
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 174
    return ((PyObject *)((void *)0));
  } else
#line 174
  if (map->valid == 0) {
    {
#line 174
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 174
    return ((PyObject *)((void *)0));
  }
  {
#line 176
  cf_map_message(map->map, (char const   *)message, color);
#line 178
  (_Py_NoneStruct.ob_refcnt) ++;
  }
#line 179
  return (& _Py_NoneStruct);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_GetFirstObjectAt(Crossfire_Map *map , PyObject *args ) 
{ 
  int x ;
  int y ;
  object *val ;
  int tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 186
  tmp = PyArg_ParseTuple(args, "ii", & x, & y);
  }
#line 186
  if (! tmp) {
#line 187
    return ((PyObject *)((void *)0));
  }
#line 189
  if (! map) {
    {
#line 189
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 189
    return ((PyObject *)((void *)0));
  } else
#line 189
  if (map->valid == 0) {
    {
#line 189
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 189
    return ((PyObject *)((void *)0));
  }
  {
#line 192
  ensure_map_in_memory(map);
#line 194
  val = cf_map_get_object_at(map->map, x, y);
#line 195
  tmp___0 = Crossfire_Object_wrap(val);
  }
#line 195
  return (tmp___0);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_CreateObject(Crossfire_Map *map , PyObject *args ) 
{ 
  char *txt ;
  int x ;
  int y ;
  object *op ;
  int tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 203
  tmp = PyArg_ParseTuple(args, "sii", & txt, & x, & y);
  }
#line 203
  if (! tmp) {
#line 204
    return ((PyObject *)((void *)0));
  }
#line 206
  if (! map) {
    {
#line 206
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 206
    return ((PyObject *)((void *)0));
  } else
#line 206
  if (map->valid == 0) {
    {
#line 206
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 206
    return ((PyObject *)((void *)0));
  }
  {
#line 209
  ensure_map_in_memory(map);
#line 211
  op = cf_create_object_by_name((char const   *)txt);
  }
#line 213
  if (op) {
    {
#line 214
    op = cf_map_insert_object(map->map, op, x, y);
    }
  }
  {
#line 215
  tmp___0 = Crossfire_Object_wrap(op);
  }
#line 215
  return (tmp___0);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_Check(Crossfire_Map *map , PyObject *args ) 
{ 
  char *what ;
  int x ;
  int y ;
  object *foundob ;
  sint16 nx ;
  sint16 ny ;
  int mflags ;
  int tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 225
  tmp = PyArg_ParseTuple(args, "s(ii)", & what, & x, & y);
  }
#line 225
  if (! tmp) {
#line 226
    return ((PyObject *)((void *)0));
  }
#line 228
  if (! map) {
    {
#line 228
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 228
    return ((PyObject *)((void *)0));
  } else
#line 228
  if (map->valid == 0) {
    {
#line 228
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 228
    return ((PyObject *)((void *)0));
  }
  {
#line 231
  ensure_map_in_memory(map);
#line 233
  mflags = cf_map_get_flags(map->map, & map->map, (sint16 )x, (sint16 )y, & nx, & ny);
  }
#line 234
  if (mflags & 256) {
#line 235
    (_Py_NoneStruct.ob_refcnt) ++;
#line 236
    return (& _Py_NoneStruct);
  }
  {
#line 238
  foundob = cf_map_find_by_archetype_name((char const   *)what, map->map, (int )nx,
                                          (int )ny);
#line 239
  tmp___0 = Crossfire_Object_wrap(foundob);
  }
#line 239
  return (tmp___0);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_Next(Crossfire_Map *map , PyObject *args ) 
{ 
  mapstruct *tmp ;
  PyObject *tmp___0 ;

  {
#line 243
  if (! map) {
    {
#line 243
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 243
    return ((PyObject *)((void *)0));
  } else
#line 243
  if (map->valid == 0) {
    {
#line 243
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 243
    return ((PyObject *)((void *)0));
  }
  {
#line 244
  tmp = cf_map_get_map_property(map->map, 23);
#line 244
  tmp___0 = Crossfire_Map_wrap(tmp);
  }
#line 244
  return (tmp___0);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_Insert(Crossfire_Map *map , PyObject *args ) 
{ 
  int x ;
  int y ;
  Crossfire_Object *what ;
  int tmp ;
  object *tmp___0 ;
  PyObject *tmp___1 ;

  {
  {
#line 251
  tmp = PyArg_ParseTuple(args, "O!ii", & Crossfire_ObjectType, & what, & x, & y);
  }
#line 251
  if (! tmp) {
#line 252
    return ((PyObject *)((void *)0));
  }
#line 254
  if (! map) {
    {
#line 254
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 254
    return ((PyObject *)((void *)0));
  } else
#line 254
  if (map->valid == 0) {
    {
#line 254
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 254
    return ((PyObject *)((void *)0));
  }
  {
#line 257
  ensure_map_in_memory(map);
#line 259
  tmp___0 = cf_map_insert_object(map->map, what->obj, x, y);
#line 259
  tmp___1 = Crossfire_Object_wrap(tmp___0);
  }
#line 259
  return (tmp___1);
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_InsertAround(Crossfire_Map *map , PyObject *args ) 
{ 
  int x ;
  int y ;
  Crossfire_Object *what ;
  int tmp ;
  object *tmp___0 ;
  PyObject *tmp___1 ;

  {
  {
#line 266
  tmp = PyArg_ParseTuple(args, "O!ii", & Crossfire_ObjectType, & what, & x, & y);
  }
#line 266
  if (! tmp) {
#line 267
    return ((PyObject *)((void *)0));
  }
#line 269
  if (! map) {
    {
#line 269
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 269
    return ((PyObject *)((void *)0));
  } else
#line 269
  if (map->valid == 0) {
    {
#line 269
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 269
    return ((PyObject *)((void *)0));
  }
  {
#line 272
  ensure_map_in_memory(map);
#line 274
  tmp___0 = cf_map_insert_object_around(map->map, what->obj, x, y);
#line 274
  tmp___1 = Crossfire_Object_wrap(tmp___0);
  }
#line 274
  return (tmp___1);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_ChangeLight(Crossfire_Map *map , PyObject *args ) 
{ 
  int change ;
  int tmp ;
  int tmp___0 ;
  PyObject *tmp___1 ;

  {
  {
#line 280
  tmp = PyArg_ParseTuple(args, "i", & change);
  }
#line 280
  if (! tmp) {
#line 281
    return ((PyObject *)((void *)0));
  }
#line 283
  if (! map) {
    {
#line 283
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 283
    return ((PyObject *)((void *)0));
  } else
#line 283
  if (map->valid == 0) {
    {
#line 283
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 283
    return ((PyObject *)((void *)0));
  }
  {
#line 285
  tmp___0 = cf_map_change_light(map->map, change);
#line 285
  tmp___1 = Py_BuildValue("i", tmp___0);
  }
#line 285
  return (tmp___1);
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Map_TriggerConnected(Crossfire_Map *map , PyObject *args ) 
{ 
  objectlink *ol ;
  int connected ;
  int state ;
  Crossfire_Object *cause ;
  oblinkpt *olp ;
  int tmp ;
  sstring tmp___0 ;
  sstring tmp___1 ;
  object *tmp___2 ;

  {
  {
#line 303
  ol = (objectlink *)((void *)0);
#line 306
  cause = (Crossfire_Object *)((void *)0);
#line 309
  tmp = PyArg_ParseTuple(args, "ii|O!", & connected, & state, & Crossfire_ObjectType,
                         & cause);
  }
#line 309
  if (! tmp) {
#line 310
    return ((PyObject *)((void *)0));
  }
#line 312
  if (! map) {
    {
#line 312
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 312
    return ((PyObject *)((void *)0));
  } else
#line 312
  if (map->valid == 0) {
    {
#line 312
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 312
    return ((PyObject *)((void *)0));
  }
  {
#line 315
  ensure_map_in_memory(map);
  }
#line 318
  if (! (map->map)->buttons) {
    {
#line 319
    tmp___0 = cf_map_get_sstring_property(map->map, 2);
#line 319
    cf_log((LogLevel )0, "Map %s called for trigger on connected %d but there ain\'t any button list for that map!\n",
           tmp___0, connected);
#line 320
    PyErr_SetString(PyExc_ReferenceError, "No objects connected to that ID on this map.");
    }
#line 321
    return ((PyObject *)((void *)0));
  }
#line 323
  olp = (map->map)->buttons;
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (! olp) {
#line 323
      goto while_break;
    }
#line 324
    if (olp->value == (long )connected) {
#line 325
      ol = olp->link;
#line 326
      goto while_break;
    }
#line 323
    olp = olp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 329
  if ((unsigned long )ol == (unsigned long )((void *)0)) {
    {
#line 330
    tmp___1 = cf_map_get_sstring_property(map->map, 2);
#line 330
    cf_log((LogLevel )1, "Map %s called for trigger on connected %d but there ain\'t any button list for that map!\n",
           tmp___1, connected);
#line 332
    PyErr_SetString(PyExc_ReferenceError, "No objects with that connection ID on this map.");
    }
#line 333
    return ((PyObject *)((void *)0));
  }
#line 336
  if (cause) {
#line 336
    tmp___2 = cause->obj;
  } else {
#line 336
    tmp___2 = (object *)((void *)0);
  }
  {
#line 336
  cf_map_trigger_connected(ol, tmp___2, state);
#line 338
  (_Py_NoneStruct.ob_refcnt) ++;
  }
#line 339
  return (& _Py_NoneStruct);
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static int Map_InternalCompare(Crossfire_Map *left , Crossfire_Map *right ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 343
  if (! left) {
    {
#line 343
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 343
    return (-1);
  } else
#line 343
  if (left->valid == 0) {
    {
#line 343
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 343
    return (-1);
  }
#line 344
  if (! right) {
    {
#line 344
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 344
    return (-1);
  } else
#line 344
  if (right->valid == 0) {
    {
#line 344
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 344
    return (-1);
  }
#line 345
  if ((unsigned long )left->map < (unsigned long )right->map) {
#line 345
    tmp___0 = -1;
  } else {
#line 345
    if ((unsigned long )left->map == (unsigned long )right->map) {
#line 345
      tmp = 0;
    } else {
#line 345
      tmp = 1;
    }
#line 345
    tmp___0 = tmp;
  }
#line 345
  return (tmp___0);
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Crossfire_Map_RichCompare(Crossfire_Map *left , Crossfire_Map *right ,
                                           int op ) 
{ 
  int result ;
  int tmp ;
  int tmp___0 ;
  PyObject *tmp___1 ;
  PyObject *tmp___2 ;

  {
#line 350
  if (! left) {
#line 354
    (_Py_NotImplementedStruct.ob_refcnt) ++;
#line 355
    return (& _Py_NotImplementedStruct);
  } else
#line 350
  if (! right) {
#line 354
    (_Py_NotImplementedStruct.ob_refcnt) ++;
#line 355
    return (& _Py_NotImplementedStruct);
  } else
#line 350
  if ((unsigned long )((PyObject *)left)->ob_type == (unsigned long )(& Crossfire_MapType)) {
#line 350
    goto _L;
  } else {
    {
#line 350
    tmp = PyType_IsSubtype(((PyObject *)left)->ob_type, & Crossfire_MapType);
    }
#line 350
    if (tmp) {
      _L: /* CIL Label */ 
#line 350
      if (! ((unsigned long )((PyObject *)right)->ob_type == (unsigned long )(& Crossfire_MapType))) {
        {
#line 350
        tmp___0 = PyType_IsSubtype(((PyObject *)right)->ob_type, & Crossfire_MapType);
        }
#line 350
        if (! tmp___0) {
#line 354
          (_Py_NotImplementedStruct.ob_refcnt) ++;
#line 355
          return (& _Py_NotImplementedStruct);
        }
      }
    } else {
#line 354
      (_Py_NotImplementedStruct.ob_refcnt) ++;
#line 355
      return (& _Py_NotImplementedStruct);
    }
  }
  {
#line 357
  result = Map_InternalCompare(left, right);
  }
#line 359
  if (result == -1) {
    {
#line 359
    tmp___1 = PyErr_Occurred();
    }
#line 359
    if (tmp___1) {
#line 360
      return ((PyObject *)((void *)0));
    }
  }
  {
#line 363
  if (op == 2) {
#line 363
    goto case_2;
  }
#line 366
  if (op == 3) {
#line 366
    goto case_3;
  }
#line 369
  if (op == 1) {
#line 369
    goto case_1;
  }
#line 372
  if (op == 5) {
#line 372
    goto case_5;
  }
#line 375
  if (op == 0) {
#line 375
    goto case_0;
  }
#line 378
  if (op == 4) {
#line 378
    goto case_4;
  }
#line 362
  goto switch_break;
  case_2: /* CIL Label */ 
#line 364
  result = result == 0;
#line 365
  goto switch_break;
  case_3: /* CIL Label */ 
#line 367
  result = result != 0;
#line 368
  goto switch_break;
  case_1: /* CIL Label */ 
#line 370
  result = result <= 0;
#line 371
  goto switch_break;
  case_5: /* CIL Label */ 
#line 373
  result = result >= 0;
#line 374
  goto switch_break;
  case_0: /* CIL Label */ 
#line 376
  result = result == -1;
#line 377
  goto switch_break;
  case_4: /* CIL Label */ 
#line 379
  result = result == 1;
#line 380
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 382
  tmp___2 = PyBool_FromLong((long )result);
  }
#line 382
  return (tmp___2);
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Crossfire_Map_Long(PyObject *obj ) 
{ 
  PyObject *tmp ;

  {
#line 387
  if (! ((Crossfire_Map *)obj)) {
    {
#line 387
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 387
    return ((PyObject *)((void *)0));
  } else
#line 387
  if (((Crossfire_Map *)obj)->valid == 0) {
    {
#line 387
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 387
    return ((PyObject *)((void *)0));
  }
  {
#line 388
  tmp = Py_BuildValue("l", ((Crossfire_Map *)obj)->map);
  }
#line 388
  return (tmp);
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Crossfire_Map_Int(PyObject *obj ) 
{ 
  PyObject *tmp ;

  {
#line 393
  if (! ((Crossfire_Map *)obj)) {
    {
#line 393
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 393
    return ((PyObject *)((void *)0));
  } else
#line 393
  if (((Crossfire_Map *)obj)->valid == 0) {
    {
#line 393
    PyErr_SetString(PyExc_ReferenceError, "Crossfire map no longer exists");
    }
#line 393
    return ((PyObject *)((void *)0));
  }
  {
#line 394
  tmp = Py_BuildValue("i", ((Crossfire_Map *)obj)->map);
  }
#line 394
  return (tmp);
}
}
#line 401 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static PyObject *Crossfire_Map_new(PyTypeObject *type , PyObject *args , PyObject *kwds ) 
{ 
  Crossfire_Map *self ;
  PyObject *tmp ;

  {
  {
#line 404
  tmp = (*(type->tp_alloc))(type, (Py_ssize_t )0);
#line 404
  self = (Crossfire_Map *)tmp;
  }
#line 405
  if (self) {
#line 406
    self->map = (mapstruct *)((void *)0);
  }
#line 408
  return ((PyObject *)self);
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
static void Crossfire_Map_dealloc(PyObject *obj ) 
{ 
  Crossfire_Map *self ;

  {
#line 414
  self = (Crossfire_Map *)obj;
#line 415
  if (self) {
#line 416
    if (self->map) {
#line 416
      if (self->valid) {
        {
#line 417
        free_map_assoc(self->map);
        }
      }
    }
    {
#line 419
    (*((((PyObject *)self)->ob_type)->tp_free))((void *)obj);
    }
  }
#line 421
  return;
}
}
#line 423 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
void Handle_Map_Unload_Hook(Crossfire_Map *map ) 
{ 


  {
  {
#line 424
  map->valid = 0;
#line 425
  free_map_assoc(map->map);
  }
#line 426
  return;
}
}
#line 428 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_map.c"
PyObject *Crossfire_Map_wrap(mapstruct *what ) 
{ 
  Crossfire_Map *wrapper ;
  PyObject *tmp ;
  void *tmp___0 ;
  PyObject *tmp___1 ;

  {
#line 432
  if ((unsigned long )what == (unsigned long )((void *)0)) {
#line 433
    (_Py_NoneStruct.ob_refcnt) ++;
#line 434
    return (& _Py_NoneStruct);
  }
  {
#line 437
  tmp = find_assoc_pymap(what);
#line 437
  wrapper = (Crossfire_Map *)tmp;
  }
#line 438
  if (! wrapper) {
    {
#line 439
    tmp___0 = PyObject_Malloc((size_t )Crossfire_MapType.tp_basicsize);
#line 439
    tmp___1 = PyObject_Init((PyObject *)tmp___0, & Crossfire_MapType);
#line 439
    wrapper = (Crossfire_Map *)tmp___1;
    }
#line 440
    if ((unsigned long )wrapper != (unsigned long )((void *)0)) {
      {
#line 441
      wrapper->map = what;
#line 442
      wrapper->valid = 1;
#line 443
      add_map_assoc(what, wrapper);
      }
    }
  } else {
#line 446
    (((PyObject *)wrapper)->ob_refcnt) ++;
  }
#line 449
  return ((PyObject *)wrapper);
}
}
#line 47 "/usr/include/python2.7/listobject.h"
extern PyObject *PyList_New(Py_ssize_t size ) ;
#line 52
extern int PyList_Append(PyObject * , PyObject * ) ;
#line 1 "./include/cfpython_party_private.h"
static PyObject *Crossfire_Party_GetName(Crossfire_Party *partyptr , void *closure ) ;
#line 2
static PyObject *Crossfire_Party_GetPassword(Crossfire_Party *partyptr , void *closure ) ;
#line 3
static PyObject *Crossfire_Party_GetNext(Crossfire_Party *party , void *closure ) ;
#line 4
static PyObject *Crossfire_Party_GetPlayers(Crossfire_Party *party , PyObject *args ) ;
#line 6
static int Crossfire_Party_InternalCompare(Crossfire_Party *left , Crossfire_Party *right ) ;
#line 7
static PyObject *Crossfire_Party_RichCompare(Crossfire_Party *left , Crossfire_Party *right ,
                                             int op ) ;
#line 9 "./include/cfpython_party_private.h"
static PyGetSetDef Party_getseters[4]  = {      {(char *)"Name", (PyObject *(*)(PyObject * , void * ))(& Crossfire_Party_GetName),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Password", (PyObject *(*)(PyObject * , void * ))(& Crossfire_Party_GetPassword),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)"Next", (PyObject *(*)(PyObject * , void * ))(& Crossfire_Party_GetNext),
      (int (*)(PyObject * , PyObject * , void * ))((void *)0), (char *)((void *)0),
      (void *)0}, 
        {(char *)((void *)0), (PyObject *(*)(PyObject * , void * ))((void *)0), (int (*)(PyObject * ,
                                                                                      PyObject * ,
                                                                                      void * ))((void *)0),
      (char *)((void *)0), (void *)0}};
#line 16 "./include/cfpython_party_private.h"
static PyMethodDef PartyMethods[2]  = {      {"GetPlayers", (PyObject *(*)(PyObject * , PyObject * ))(& Crossfire_Party_GetPlayers),
      4, (char const   *)((void *)0)}, 
        {(char const   *)((void *)0), (PyObject *(*)(PyObject * , PyObject * ))((void *)0),
      0, (char const   *)((void *)0)}};
#line 22 "./include/cfpython_party_private.h"
PyTypeObject Crossfire_PartyType  = 
#line 22
     {(Py_ssize_t )1, (struct _typeobject *)((void *)0), (Py_ssize_t )0, "Crossfire.Party",
    (Py_ssize_t )sizeof(Crossfire_Party ), (Py_ssize_t )0, (void (*)(PyObject * ))((void *)0),
    (int (*)(PyObject * , FILE * , int  ))((void *)0), (PyObject *(*)(PyObject * ,
                                                                      char * ))((void *)0),
    (int (*)(PyObject * , char * , PyObject * ))((void *)0), (int (*)(PyObject * ,
                                                                      PyObject * ))(& Crossfire_Party_InternalCompare),
    (PyObject *(*)(PyObject * ))((void *)0), (PyNumberMethods *)((void *)0), (PySequenceMethods *)((void *)0),
    (PyMappingMethods *)((void *)0), & PyObject_HashNotImplemented, (PyObject *(*)(PyObject * ,
                                                                                   PyObject * ,
                                                                                   PyObject * ))((void *)0),
    (PyObject *(*)(PyObject * ))((void *)0), & PyObject_GenericGetAttr, & PyObject_GenericSetAttr,
    (PyBufferProcs *)((void *)0), (((((((1L | (1L << 1)) | (1L << 3)) | (1L << 5)) | (1L << 6)) | (1L << 7)) | (1L << 8)) | (1L << 17)) | (1L << 10),
    "Crossfire parties", (int (*)(PyObject * , int (*)(PyObject * , void * ) , void * ))((void *)0),
    (int (*)(PyObject * ))((void *)0), (PyObject *(*)(PyObject * , PyObject * , int  ))(& Crossfire_Party_RichCompare),
    (Py_ssize_t )0, (PyObject *(*)(PyObject * ))((void *)0), (PyObject *(*)(PyObject * ))((void *)0),
    PartyMethods, (struct PyMemberDef *)((void *)0), Party_getseters, (struct _typeobject *)((void *)0),
    (PyObject *)((void *)0), (PyObject *(*)(PyObject * , PyObject * , PyObject * ))((void *)0),
    (int (*)(PyObject * , PyObject * , PyObject * ))((void *)0), (Py_ssize_t )0, (int (*)(PyObject * ,
                                                                                          PyObject * ,
                                                                                          PyObject * ))((void *)0),
    (PyObject *(*)(struct _typeobject * , Py_ssize_t  ))((void *)0), (PyObject *(*)(struct _typeobject * ,
                                                                                    PyObject * ,
                                                                                    PyObject * ))((void *)0),
    (void (*)(void * ))((void *)0), (int (*)(PyObject * ))((void *)0), (PyObject *)((void *)0),
    (PyObject *)((void *)0), (PyObject *)((void *)0), (PyObject *)((void *)0), (PyObject *)((void *)0),
    (void (*)(PyObject * ))((void *)0), 0U};
#line 33 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_party.c"
static PyObject *Crossfire_Party_GetName(Crossfire_Party *partyptr , void *closure ) 
{ 
  char const   *tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 34
  tmp = cf_party_get_name(partyptr->party);
#line 34
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 34
  return (tmp___0);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_party.c"
static PyObject *Crossfire_Party_GetPassword(Crossfire_Party *partyptr , void *closure ) 
{ 
  char const   *tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 38
  tmp = cf_party_get_password(partyptr->party);
#line 38
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 38
  return (tmp___0);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_party.c"
static PyObject *Crossfire_Party_GetNext(Crossfire_Party *party , void *closure ) 
{ 
  partylist *tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 42
  tmp = cf_party_get_next(party->party);
#line 42
  tmp___0 = Crossfire_Party_wrap(tmp);
  }
#line 42
  return (tmp___0);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_party.c"
static PyObject *Crossfire_Party_GetPlayers(Crossfire_Party *party , PyObject *args ) 
{ 
  PyObject *list ;
  player *pl ;
  PyObject *tmp ;

  {
  {
#line 49
  list = PyList_New((Py_ssize_t )0);
#line 50
  pl = cf_party_get_first_player(party->party);
  }
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! pl) {
#line 51
      goto while_break;
    }
    {
#line 52
    tmp = Crossfire_Object_wrap(pl->ob);
#line 52
    PyList_Append(list, tmp);
#line 53
    pl = cf_party_get_next_player(party->party, pl);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return (list);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_party.c"
PyObject *Crossfire_Party_wrap(partylist *what ) 
{ 
  Crossfire_Party *wrapper ;
  void *tmp ;
  PyObject *tmp___0 ;

  {
#line 62
  if ((unsigned long )what == (unsigned long )((void *)0)) {
#line 63
    (_Py_NoneStruct.ob_refcnt) ++;
#line 64
    return (& _Py_NoneStruct);
  }
  {
#line 67
  tmp = PyObject_Malloc((size_t )Crossfire_PartyType.tp_basicsize);
#line 67
  tmp___0 = PyObject_Init((PyObject *)tmp, & Crossfire_PartyType);
#line 67
  wrapper = (Crossfire_Party *)tmp___0;
  }
#line 68
  if ((unsigned long )wrapper != (unsigned long )((void *)0)) {
#line 69
    wrapper->party = what;
  }
#line 70
  return ((PyObject *)wrapper);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_party.c"
static int Crossfire_Party_InternalCompare(Crossfire_Party *left , Crossfire_Party *right ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 74
  if ((unsigned long )left->party < (unsigned long )right->party) {
#line 74
    tmp___0 = -1;
  } else {
#line 74
    if ((unsigned long )left->party == (unsigned long )right->party) {
#line 74
      tmp = 0;
    } else {
#line 74
      tmp = 1;
    }
#line 74
    tmp___0 = tmp;
  }
#line 74
  return (tmp___0);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython_party.c"
static PyObject *Crossfire_Party_RichCompare(Crossfire_Party *left , Crossfire_Party *right ,
                                             int op ) 
{ 
  int result ;
  int tmp ;
  int tmp___0 ;
  PyObject *tmp___1 ;

  {
#line 79
  if (! left) {
#line 83
    (_Py_NotImplementedStruct.ob_refcnt) ++;
#line 84
    return (& _Py_NotImplementedStruct);
  } else
#line 79
  if (! right) {
#line 83
    (_Py_NotImplementedStruct.ob_refcnt) ++;
#line 84
    return (& _Py_NotImplementedStruct);
  } else
#line 79
  if ((unsigned long )((PyObject *)left)->ob_type == (unsigned long )(& Crossfire_PartyType)) {
#line 79
    goto _L;
  } else {
    {
#line 79
    tmp = PyType_IsSubtype(((PyObject *)left)->ob_type, & Crossfire_PartyType);
    }
#line 79
    if (tmp) {
      _L: /* CIL Label */ 
#line 79
      if (! ((unsigned long )((PyObject *)right)->ob_type == (unsigned long )(& Crossfire_PartyType))) {
        {
#line 79
        tmp___0 = PyType_IsSubtype(((PyObject *)right)->ob_type, & Crossfire_PartyType);
        }
#line 79
        if (! tmp___0) {
#line 83
          (_Py_NotImplementedStruct.ob_refcnt) ++;
#line 84
          return (& _Py_NotImplementedStruct);
        }
      }
    } else {
#line 83
      (_Py_NotImplementedStruct.ob_refcnt) ++;
#line 84
      return (& _Py_NotImplementedStruct);
    }
  }
  {
#line 86
  result = Crossfire_Party_InternalCompare(left, right);
  }
  {
#line 89
  if (op == 2) {
#line 89
    goto case_2;
  }
#line 92
  if (op == 3) {
#line 92
    goto case_3;
  }
#line 95
  if (op == 1) {
#line 95
    goto case_1;
  }
#line 98
  if (op == 5) {
#line 98
    goto case_5;
  }
#line 101
  if (op == 0) {
#line 101
    goto case_0;
  }
#line 104
  if (op == 4) {
#line 104
    goto case_4;
  }
#line 88
  goto switch_break;
  case_2: /* CIL Label */ 
#line 90
  result = result == 0;
#line 91
  goto switch_break;
  case_3: /* CIL Label */ 
#line 93
  result = result != 0;
#line 94
  goto switch_break;
  case_1: /* CIL Label */ 
#line 96
  result = result <= 0;
#line 97
  goto switch_break;
  case_5: /* CIL Label */ 
#line 99
  result = result >= 0;
#line 100
  goto switch_break;
  case_0: /* CIL Label */ 
#line 102
  result = result == -1;
#line 103
  goto switch_break;
  case_4: /* CIL Label */ 
#line 105
  result = result == 1;
#line 106
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 108
  tmp___1 = PyBool_FromLong((long )result);
  }
#line 108
  return (tmp___1);
}
}
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
/* compiler builtin: 
   float __builtin_inff(void) ;  */
#line 192 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __isinf)(double __value )  __attribute__((__const__)) ;
#line 230
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __isnan)(double __value )  __attribute__((__const__)) ;
#line 192
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __isinff)(float __value )  __attribute__((__const__)) ;
#line 230
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __isnanf)(float __value )  __attribute__((__const__)) ;
#line 192
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __isinfl)(long double __value )  __attribute__((__const__)) ;
#line 230
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __isnanl)(long double __value )  __attribute__((__const__)) ;
#line 463 "/usr/include/python2.7/object.h"
extern PyObject *PyObject_Str(PyObject * ) ;
#line 471
extern PyObject *PyObject_GetAttrString(PyObject * , char const   * ) ;
#line 513
extern int Py_ReprEnter(PyObject * ) ;
#line 514
extern void Py_ReprLeave(PyObject * ) ;
#line 927 "/usr/include/python2.7/unicodeobject.h"
extern PyObject *PyUnicodeUCS4_DecodeUnicodeEscape(char const   *string , Py_ssize_t length ,
                                                   char const   *errors ) ;
#line 950
extern PyObject *PyUnicodeUCS4_AsRawUnicodeEscapeString(PyObject *unicode ) ;
#line 34 "/usr/include/python2.7/intobject.h"
extern PyObject *PyInt_FromString(char * , char ** , int  ) ;
#line 19 "/usr/include/python2.7/floatobject.h"
extern PyTypeObject PyFloat_Type ;
#line 48
extern PyObject *PyFloat_FromString(PyObject * , char **junk ) ;
#line 51
extern PyObject *PyFloat_FromDouble(double  ) ;
#line 62 "/usr/include/python2.7/stringobject.h"
extern PyObject *PyString_FromStringAndSize(char const   * , Py_ssize_t  ) ;
#line 63
extern PyObject *PyString_FromString(char const   * ) ;
#line 69
extern char *PyString_AsString(PyObject * ) ;
#line 71
extern void PyString_Concat(PyObject ** , PyObject * ) ;
#line 72
extern void PyString_ConcatAndDel(PyObject ** , PyObject * ) ;
#line 73
extern int _PyString_Resize(PyObject ** , Py_ssize_t  ) ;
#line 78
extern PyObject *PyString_DecodeEscape(char const   * , Py_ssize_t  , char const   * ,
                                       Py_ssize_t  , char const   * ) ;
#line 96
extern PyObject *_PyString_Join(PyObject *sep , PyObject *x ) ;
#line 172
extern int PyString_AsStringAndSize(PyObject *obj , char **s , Py_ssize_t *len ) ;
#line 31 "/usr/include/python2.7/bytearrayobject.h"
extern PyTypeObject PyByteArray_Type ;
#line 41
extern PyObject *PyByteArray_FromStringAndSize(char const   * , Py_ssize_t  ) ;
#line 52
extern char _PyByteArray_empty_string[] ;
#line 40 "/usr/include/python2.7/tupleobject.h"
extern PyObject *PyTuple_New(Py_ssize_t size ) ;
#line 109 "/usr/include/python2.7/dictobject.h"
extern PyObject *PyDict_New(void) ;
#line 111
extern int PyDict_SetItem(PyObject *mp , PyObject *key , PyObject *item ) ;
#line 114
extern int PyDict_Next(PyObject *mp , Py_ssize_t *pos , PyObject **key , PyObject **value ) ;
#line 81 "/usr/include/python2.7/pyerrors.h"
extern void PyErr_Fetch(PyObject ** , PyObject ** , PyObject ** ) ;
#line 91
extern int PyErr_GivenExceptionMatches(PyObject * , PyObject * ) ;
#line 139
extern PyObject *PyExc_OverflowError ;
#line 152
extern PyObject *PyExc_UnicodeDecodeError ;
#line 195
extern PyObject *( /* format attribute */  PyErr_Format)(PyObject * , char const   * 
                                                         , ...) ;
#line 223
extern PyObject *PyErr_NewException(char *name , PyObject *base , PyObject *dict ) ;
#line 28 "/usr/include/python2.7/modsupport.h"
extern int PyArg_ParseTupleAndKeywords(PyObject * , PyObject * , char const   * ,
                                       char **  , ...) ;
#line 40
extern int PyModule_AddObject(PyObject * , char const   * , PyObject * ) ;
#line 42
extern int PyModule_AddStringConstant(PyObject * , char const   * , char const   * ) ;
#line 117
extern PyObject *Py_InitModule4_64(char const   *name , PyMethodDef *methods , char const   *doc ,
                                   PyObject *self , int apiver ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static PyObject *encode_object(PyObject *object___0 ) ;
#line 46
static PyObject *encode_string(PyObject *string ) ;
#line 47
static PyObject *encode_unicode(PyObject *unicode ) ;
#line 48
static PyObject *encode_tuple(PyObject *tuple ) ;
#line 49
static PyObject *encode_list(PyObject *list ) ;
#line 50
static PyObject *encode_dict(PyObject *dict ) ;
#line 52
static PyObject *decode_json(JSONData *jsondata ) ;
#line 53
static PyObject *decode_null(JSONData *jsondata ) ;
#line 54
static PyObject *decode_bool(JSONData *jsondata ) ;
#line 55
static PyObject *decode_string(JSONData *jsondata ) ;
#line 56
static PyObject *decode_inf(JSONData *jsondata ) ;
#line 57
static PyObject *decode_nan(JSONData *jsondata ) ;
#line 58
static PyObject *decode_number(JSONData *jsondata ) ;
#line 59
static PyObject *decode_array(JSONData *jsondata ) ;
#line 60
static PyObject *decode_object(JSONData *jsondata ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static PyObject *JSON_Error  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static PyObject *JSON_EncodeError  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static PyObject *JSON_DecodeError  ;
#line 113 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static void getRowAndCol(char *begin , char *current , int *row , int *col ) 
{ 


  {
#line 114
  *col = 1;
#line 115
  *row = 1;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! ((unsigned long )current > (unsigned long )begin)) {
#line 116
      goto while_break;
    }
#line 117
    if ((int )*current == 10) {
#line 118
      (*row) ++;
    }
#line 119
    if (*row < 2) {
#line 120
      (*col) ++;
    }
#line 121
    current --;
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static PyObject *decode_null(JSONData *jsondata ) 
{ 
  ptrdiff_t left ;
  int row ;
  int col ;
  int tmp ;

  {
#line 127
  left = jsondata->end - jsondata->ptr;
#line 129
  if (left >= 4L) {
    {
#line 129
    tmp = strncmp((char const   *)jsondata->ptr, "null", (size_t )4);
    }
#line 129
    if (tmp == 0) {
#line 130
      jsondata->ptr += 4;
#line 131
      (_Py_NoneStruct.ob_refcnt) ++;
#line 132
      return (& _Py_NoneStruct);
    } else {
      {
#line 136
      getRowAndCol(jsondata->str, jsondata->ptr, & row, & col);
#line 137
      PyErr_Format(JSON_DecodeError, "cannot parse JSON description: %.20s(row %zd, col %zd)",
                   jsondata->ptr, (Py_ssize_t )row, (Py_ssize_t )col);
      }
#line 138
      return ((PyObject *)((void *)0));
    }
  } else {
    {
#line 136
    getRowAndCol(jsondata->str, jsondata->ptr, & row, & col);
#line 137
    PyErr_Format(JSON_DecodeError, "cannot parse JSON description: %.20s(row %zd, col %zd)",
                 jsondata->ptr, (Py_ssize_t )row, (Py_ssize_t )col);
    }
#line 138
    return ((PyObject *)((void *)0));
  }
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static PyObject *decode_bool(JSONData *jsondata ) 
{ 
  ptrdiff_t left ;
  int row ;
  int col ;
  int tmp ;
  int tmp___0 ;

  {
#line 145
  left = jsondata->end - jsondata->ptr;
#line 147
  if (left >= 4L) {
    {
#line 147
    tmp___0 = strncmp((char const   *)jsondata->ptr, "true", (size_t )4);
    }
#line 147
    if (tmp___0 == 0) {
#line 148
      jsondata->ptr += 4;
#line 149
      (((PyObject *)(& _Py_TrueStruct))->ob_refcnt) ++;
#line 150
      return ((PyObject *)(& _Py_TrueStruct));
    } else {
#line 147
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 151
  if (left >= 5L) {
    {
#line 151
    tmp = strncmp((char const   *)jsondata->ptr, "false", (size_t )5);
    }
#line 151
    if (tmp == 0) {
#line 152
      jsondata->ptr += 5;
#line 153
      (((PyObject *)(& _Py_ZeroStruct))->ob_refcnt) ++;
#line 154
      return ((PyObject *)(& _Py_ZeroStruct));
    } else {
      {
#line 158
      getRowAndCol(jsondata->str, jsondata->ptr, & row, & col);
#line 159
      PyErr_Format(JSON_DecodeError, "cannot parse JSON description: %.20s(row %zd, col %zd)",
                   jsondata->ptr, (Py_ssize_t )row, (Py_ssize_t )col);
      }
#line 160
      return ((PyObject *)((void *)0));
    }
  } else {
    {
#line 158
    getRowAndCol(jsondata->str, jsondata->ptr, & row, & col);
#line 159
    PyErr_Format(JSON_DecodeError, "cannot parse JSON description: %.20s(row %zd, col %zd)",
                 jsondata->ptr, (Py_ssize_t )row, (Py_ssize_t )col);
    }
#line 160
    return ((PyObject *)((void *)0));
  }
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static PyObject *decode_string(JSONData *jsondata ) 
{ 
  PyObject *object___0 ;
  int c ;
  int escaping ;
  int has_unicode ;
  int string_escape ;
  Py_ssize_t len ;
  char *ptr ;
  int row ;
  int col ;
  PyObject *type ;
  PyObject *value ;
  PyObject *tb ;
  PyObject *reason ;
  int row___0 ;
  int col___0 ;
  int row___1 ;
  int col___1 ;
  char *tmp ;
  char const   *tmp___0 ;
  int row___2 ;
  int col___2 ;
  int tmp___1 ;

  {
#line 171
  string_escape = 0;
#line 171
  has_unicode = string_escape;
#line 171
  escaping = has_unicode;
#line 172
  ptr = jsondata->ptr + 1;
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    c = (int )*ptr;
#line 175
    if (c == 0) {
      {
#line 178
      getRowAndCol(jsondata->str, jsondata->ptr, & row, & col);
#line 179
      PyErr_Format(JSON_DecodeError, "unterminated string starting at position %zd(row %zd, col %zd)",
                   jsondata->ptr - jsondata->str, (Py_ssize_t )row, (Py_ssize_t )col);
      }
#line 181
      return ((PyObject *)((void *)0));
    }
#line 183
    if (! escaping) {
#line 184
      if (c == 92) {
#line 185
        escaping = 1;
      } else
#line 186
      if (c == 34) {
#line 187
        goto while_break;
      } else
#line 188
      if (! ((c & -128) == 0)) {
#line 189
        has_unicode = 1;
      }
    } else {
      {
#line 193
      if (c == 117) {
#line 193
        goto case_117;
      }
#line 202
      if (c == 92) {
#line 202
        goto case_92;
      }
#line 202
      if (c == 102) {
#line 202
        goto case_92;
      }
#line 202
      if (c == 98) {
#line 202
        goto case_92;
      }
#line 202
      if (c == 116) {
#line 202
        goto case_92;
      }
#line 202
      if (c == 110) {
#line 202
        goto case_92;
      }
#line 202
      if (c == 114) {
#line 202
        goto case_92;
      }
#line 202
      if (c == 34) {
#line 202
        goto case_92;
      }
#line 192
      goto switch_break;
      case_117: /* CIL Label */ 
#line 194
      has_unicode = 1;
#line 195
      goto switch_break;
      case_92: /* CIL Label */ 
      case_102: /* CIL Label */ 
      case_98: /* CIL Label */ 
      case_116: /* CIL Label */ 
      case_110: /* CIL Label */ 
      case_114: /* CIL Label */ 
      case_34: /* CIL Label */ 
#line 203
      string_escape = 1;
#line 204
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 206
      escaping = 0;
    }
#line 208
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  len = (ptr - jsondata->ptr) - 1L;
#line 213
  if (has_unicode) {
    {
#line 214
    object___0 = PyUnicodeUCS4_DecodeUnicodeEscape((char const   *)(jsondata->ptr + 1),
                                                   len, (char const   *)((void *)0));
    }
  } else
#line 213
  if (jsondata->all_unicode) {
    {
#line 214
    object___0 = PyUnicodeUCS4_DecodeUnicodeEscape((char const   *)(jsondata->ptr + 1),
                                                   len, (char const   *)((void *)0));
    }
  } else
#line 215
  if (string_escape) {
    {
#line 216
    object___0 = PyString_DecodeEscape((char const   *)(jsondata->ptr + 1), len, (char const   *)((void *)0),
                                       (Py_ssize_t )0, (char const   *)((void *)0));
    }
  } else {
    {
#line 218
    object___0 = PyString_FromStringAndSize((char const   *)(jsondata->ptr + 1), len);
    }
  }
#line 220
  if ((unsigned long )object___0 == (unsigned long )((void *)0)) {
    {
#line 223
    PyErr_Fetch(& type, & value, & tb);
    }
#line 224
    if ((unsigned long )type == (unsigned long )((void *)0)) {
      {
#line 227
      getRowAndCol(jsondata->str, jsondata->ptr, & row___0, & col___0);
#line 228
      PyErr_Format(JSON_DecodeError, "invalid string starting at position %zd(row %zd, col %zd)",
                   jsondata->ptr - jsondata->str, (Py_ssize_t )row___0, (Py_ssize_t )col___0);
      }
    } else {
      {
#line 231
      tmp___1 = PyErr_GivenExceptionMatches(type, PyExc_UnicodeDecodeError);
      }
#line 231
      if (tmp___1) {
        {
#line 234
        reason = PyObject_GetAttrString(value, "reason");
#line 243
        getRowAndCol(jsondata->str, jsondata->ptr, & row___1, & col___1);
        }
#line 244
        if (reason) {
          {
#line 244
          tmp = PyString_AsString(reason);
#line 244
          tmp___0 = (char const   *)tmp;
          }
        } else {
#line 244
          tmp___0 = "bad format";
        }
        {
#line 244
        PyErr_Format(JSON_DecodeError, "cannot decode string starting at position %zd(row %zd, col %zd): %s",
                     jsondata->ptr - jsondata->str, (Py_ssize_t )row___1, (Py_ssize_t )col___1,
                     tmp___0);
        }
        {
#line 247
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 247
          if (! ((unsigned long )reason == (unsigned long )((void *)0))) {
            {
#line 247
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 247
              (reason->ob_refcnt) --;
#line 247
              if (! (reason->ob_refcnt != 0L)) {
                {
#line 247
                (*((reason->ob_type)->tp_dealloc))(reason);
                }
              }
#line 247
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
#line 247
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 251
        getRowAndCol(jsondata->str, jsondata->ptr, & row___2, & col___2);
#line 252
        PyErr_Format(JSON_DecodeError, "invalid string starting at position %zd(row %zd, col %zd)",
                     jsondata->ptr - jsondata->str, (Py_ssize_t )row___2, (Py_ssize_t )col___2);
        }
      }
    }
    {
#line 256
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 256
      if (! ((unsigned long )type == (unsigned long )((void *)0))) {
        {
#line 256
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 256
          (type->ob_refcnt) --;
#line 256
          if (! (type->ob_refcnt != 0L)) {
            {
#line 256
            (*((type->ob_type)->tp_dealloc))(type);
            }
          }
#line 256
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 256
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 257
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 257
      if (! ((unsigned long )value == (unsigned long )((void *)0))) {
        {
#line 257
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 257
          (value->ob_refcnt) --;
#line 257
          if (! (value->ob_refcnt != 0L)) {
            {
#line 257
            (*((value->ob_type)->tp_dealloc))(value);
            }
          }
#line 257
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 257
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 258
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 258
      if (! ((unsigned long )tb == (unsigned long )((void *)0))) {
        {
#line 258
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 258
          (tb->ob_refcnt) --;
#line 258
          if (! (tb->ob_refcnt != 0L)) {
            {
#line 258
            (*((tb->ob_type)->tp_dealloc))(tb);
            }
          }
#line 258
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
#line 258
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  } else {
#line 260
    jsondata->ptr = ptr + 1;
  }
#line 263
  return (object___0);
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static PyObject *decode_inf(JSONData *jsondata ) 
{ 
  PyObject *object___0 ;
  ptrdiff_t left ;
  float tmp ;
  float tmp___0 ;
  float tmp___1 ;
  int row ;
  int col ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 270
  left = jsondata->end - jsondata->ptr;
#line 272
  if (left >= 8L) {
    {
#line 272
    tmp___4 = strncmp((char const   *)jsondata->ptr, "Infinity", (size_t )8);
    }
#line 272
    if (tmp___4 == 0) {
      {
#line 273
      jsondata->ptr += 8;
#line 274
      tmp = __builtin_inff();
#line 274
      object___0 = PyFloat_FromDouble((double )tmp);
      }
#line 275
      return (object___0);
    } else {
#line 272
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 276
  if (left >= 9L) {
    {
#line 276
    tmp___3 = strncmp((char const   *)jsondata->ptr, "+Infinity", (size_t )9);
    }
#line 276
    if (tmp___3 == 0) {
      {
#line 277
      jsondata->ptr += 9;
#line 278
      tmp___0 = __builtin_inff();
#line 278
      object___0 = PyFloat_FromDouble((double )tmp___0);
      }
#line 279
      return (object___0);
    } else {
#line 276
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 280
  if (left >= 9L) {
    {
#line 280
    tmp___2 = strncmp((char const   *)jsondata->ptr, "-Infinity", (size_t )9);
    }
#line 280
    if (tmp___2 == 0) {
      {
#line 281
      jsondata->ptr += 9;
#line 282
      tmp___1 = __builtin_inff();
#line 282
      object___0 = PyFloat_FromDouble((double )(- tmp___1));
      }
#line 283
      return (object___0);
    } else {
      {
#line 287
      getRowAndCol(jsondata->str, jsondata->ptr, & row, & col);
#line 288
      PyErr_Format(JSON_DecodeError, "cannot parse JSON description: %.20s (row %zd, col %zd)",
                   jsondata->ptr, (Py_ssize_t )row, (Py_ssize_t )col);
      }
#line 289
      return ((PyObject *)((void *)0));
    }
  } else {
    {
#line 287
    getRowAndCol(jsondata->str, jsondata->ptr, & row, & col);
#line 288
    PyErr_Format(JSON_DecodeError, "cannot parse JSON description: %.20s (row %zd, col %zd)",
                 jsondata->ptr, (Py_ssize_t )row, (Py_ssize_t )col);
    }
#line 289
    return ((PyObject *)((void *)0));
  }
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static PyObject *decode_nan(JSONData *jsondata ) 
{ 
  PyObject *object___0 ;
  ptrdiff_t left ;
  float tmp ;
  int row ;
  int col ;
  int tmp___0 ;

  {
#line 297
  left = jsondata->end - jsondata->ptr;
#line 299
  if (left >= 3L) {
    {
#line 299
    tmp___0 = strncmp((char const   *)jsondata->ptr, "NaN", (size_t )3);
    }
#line 299
    if (tmp___0 == 0) {
      {
#line 300
      jsondata->ptr += 3;
#line 301
      tmp = __builtin_nanf("");
#line 301
      object___0 = PyFloat_FromDouble((double )tmp);
      }
#line 302
      return (object___0);
    } else {
      {
#line 305
      getRowAndCol(jsondata->str, jsondata->ptr, & row, & col);
#line 306
      PyErr_Format(JSON_DecodeError, "cannot parse JSON description: %.20s(row %zd, col %zd)",
                   jsondata->ptr, (Py_ssize_t )row, (Py_ssize_t )col);
      }
#line 307
      return ((PyObject *)((void *)0));
    }
  } else {
    {
#line 305
    getRowAndCol(jsondata->str, jsondata->ptr, & row, & col);
#line 306
    PyErr_Format(JSON_DecodeError, "cannot parse JSON description: %.20s(row %zd, col %zd)",
                 jsondata->ptr, (Py_ssize_t )row, (Py_ssize_t )col);
    }
#line 307
    return ((PyObject *)((void *)0));
  }
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static PyObject *decode_number(JSONData *jsondata ) 
{ 
  PyObject *object___0 ;
  PyObject *str ;
  int c ;
  int is_float ;
  int should_stop ;
  char *ptr ;
  int row ;
  int col ;

  {
#line 317
  ptr = jsondata->ptr;
#line 318
  should_stop = 0;
#line 318
  is_float = should_stop;
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    c = (int )*ptr;
#line 321
    if (c == 0) {
#line 322
      goto while_break;
    }
    {
#line 335
    if (c == 43) {
#line 335
      goto case_43;
    }
#line 335
    if (c == 45) {
#line 335
      goto case_43;
    }
#line 335
    if (c == 57) {
#line 335
      goto case_43;
    }
#line 335
    if (c == 56) {
#line 335
      goto case_43;
    }
#line 335
    if (c == 55) {
#line 335
      goto case_43;
    }
#line 335
    if (c == 54) {
#line 335
      goto case_43;
    }
#line 335
    if (c == 53) {
#line 335
      goto case_43;
    }
#line 335
    if (c == 52) {
#line 335
      goto case_43;
    }
#line 335
    if (c == 51) {
#line 335
      goto case_43;
    }
#line 335
    if (c == 50) {
#line 335
      goto case_43;
    }
#line 335
    if (c == 49) {
#line 335
      goto case_43;
    }
#line 335
    if (c == 48) {
#line 335
      goto case_43;
    }
#line 340
    if (c == 69) {
#line 340
      goto case_69;
    }
#line 340
    if (c == 101) {
#line 340
      goto case_69;
    }
#line 340
    if (c == 46) {
#line 340
      goto case_69;
    }
#line 344
    goto switch_default;
    case_43: /* CIL Label */ 
    case_45: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 336
    goto switch_break;
    case_69: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_46: /* CIL Label */ 
#line 341
    is_float = 1;
#line 342
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 345
    should_stop = 1;
    switch_break: /* CIL Label */ ;
    }
#line 347
    if (should_stop) {
#line 348
      goto while_break;
    }
#line 350
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 353
  str = PyString_FromStringAndSize((char const   *)jsondata->ptr, ptr - jsondata->ptr);
  }
#line 354
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 355
    return ((PyObject *)((void *)0));
  }
#line 357
  if (is_float) {
    {
#line 361
    object___0 = PyFloat_FromString(str, (char **)((void *)0));
    }
  } else {
    {
#line 367
    object___0 = PyInt_FromString(((PyStringObject *)str)->ob_sval, (char **)((void *)0),
                                  10);
    }
  }
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 371
    (str->ob_refcnt) --;
#line 371
    if (! (str->ob_refcnt != 0L)) {
      {
#line 371
      (*((str->ob_type)->tp_dealloc))(str);
      }
    }
#line 371
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 373
  if ((unsigned long )object___0 == (unsigned long )((void *)0)) {
    {
#line 376
    getRowAndCol(jsondata->str, jsondata->ptr, & row, & col);
#line 377
    PyErr_Format(JSON_DecodeError, "invalid number starting at position %zd(row %zd, col %zd)",
                 jsondata->ptr - jsondata->str, (Py_ssize_t )row, (Py_ssize_t )col);
    }
  } else {
#line 379
    jsondata->ptr = ptr;
  }
#line 382
  return (object___0);
}
}
#line 385 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static PyObject *decode_array(JSONData *jsondata ) 
{ 
  PyObject *object___0 ;
  PyObject *item ;
  int c ;
  int expect_item ;
  int items ;
  int result ;
  char *start ;
  unsigned short const   **tmp ;
  int row ;
  int col ;
  int row___0 ;
  int col___0 ;
  int row___1 ;
  int col___1 ;

  {
  {
#line 390
  object___0 = PyList_New((Py_ssize_t )0);
#line 392
  start = jsondata->ptr;
#line 393
  (jsondata->ptr) ++;
#line 394
  expect_item = 1;
#line 395
  items = 0;
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 397
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 397
      if (*(jsondata->ptr)) {
        {
#line 397
        tmp = __ctype_b_loc();
        }
#line 397
        if (! ((int const   )*(*tmp + (int )*(jsondata->ptr)) & 8192)) {
#line 397
          goto while_break___0;
        }
      } else {
#line 397
        goto while_break___0;
      }
#line 397
      (jsondata->ptr) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 398
    c = (int )*(jsondata->ptr);
#line 399
    if (c == 0) {
      {
#line 402
      getRowAndCol(jsondata->str, jsondata->ptr, & row, & col);
#line 403
      PyErr_Format(JSON_DecodeError, "unterminated array starting at position %zd(row %zd, col %zd)",
                   start - jsondata->str, (Py_ssize_t )row, (Py_ssize_t )col);
      }
#line 405
      goto failure;
    } else
#line 406
    if (c == 93) {
#line 407
      if (expect_item) {
#line 407
        if (items > 0) {
          {
#line 410
          getRowAndCol(jsondata->str, jsondata->ptr, & row___0, & col___0);
#line 411
          PyErr_Format(JSON_DecodeError, "expecting array item at position %zd(row %zd, col %zd)",
                       jsondata->ptr - jsondata->str, (Py_ssize_t )row___0, (Py_ssize_t )col___0);
          }
#line 413
          goto failure;
        }
      }
#line 415
      (jsondata->ptr) ++;
#line 416
      goto while_break;
    } else
#line 417
    if (c == 44) {
#line 418
      if (expect_item) {
        {
#line 421
        getRowAndCol(jsondata->str, jsondata->ptr, & row___1, & col___1);
#line 422
        PyErr_Format(JSON_DecodeError, "expecting array item at position %zd(row %zd, col %zd)",
                     jsondata->ptr - jsondata->str, (Py_ssize_t )row___1, (Py_ssize_t )col___1);
        }
#line 424
        goto failure;
      }
#line 426
      expect_item = 1;
#line 427
      (jsondata->ptr) ++;
#line 428
      goto while_continue;
    } else {
      {
#line 430
      item = decode_json(jsondata);
      }
#line 431
      if ((unsigned long )item == (unsigned long )((void *)0)) {
#line 432
        goto failure;
      }
      {
#line 433
      result = PyList_Append(object___0, item);
      }
      {
#line 434
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 434
        (item->ob_refcnt) --;
#line 434
        if (! (item->ob_refcnt != 0L)) {
          {
#line 434
          (*((item->ob_type)->tp_dealloc))(item);
          }
        }
#line 434
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 435
      if (result == -1) {
#line 436
        goto failure;
      }
#line 437
      expect_item = 0;
#line 438
      items ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 442
  return (object___0);
  failure: 
  {
#line 445
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 445
    (object___0->ob_refcnt) --;
#line 445
    if (! (object___0->ob_refcnt != 0L)) {
      {
#line 445
      (*((object___0->ob_type)->tp_dealloc))(object___0);
      }
    }
#line 445
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 446
  return ((PyObject *)((void *)0));
}
}
#line 449 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static PyObject *decode_object(JSONData *jsondata ) 
{ 
  PyObject *object___0 ;
  PyObject *key ;
  PyObject *value ;
  int c ;
  int expect_key ;
  int items ;
  int result ;
  char *start ;
  unsigned short const   **tmp ;
  int row ;
  int col ;
  int row___0 ;
  int col___0 ;
  int row___1 ;
  int col___1 ;
  int row___2 ;
  int col___2 ;
  unsigned short const   **tmp___0 ;
  int row___3 ;
  int col___3 ;

  {
  {
#line 454
  object___0 = PyDict_New();
#line 456
  expect_key = 1;
#line 457
  items = 0;
#line 458
  start = jsondata->ptr;
#line 459
  (jsondata->ptr) ++;
  }
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 462
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 462
      if (*(jsondata->ptr)) {
        {
#line 462
        tmp = __ctype_b_loc();
        }
#line 462
        if (! ((int const   )*(*tmp + (int )*(jsondata->ptr)) & 8192)) {
#line 462
          goto while_break___0;
        }
      } else {
#line 462
        goto while_break___0;
      }
#line 462
      (jsondata->ptr) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 463
    c = (int )*(jsondata->ptr);
#line 464
    if (c == 0) {
      {
#line 467
      getRowAndCol(jsondata->str, jsondata->ptr, & row, & col);
#line 468
      PyErr_Format(JSON_DecodeError, "unterminated object starting at position %zd(row %zd, col %zd)",
                   start - jsondata->str, (Py_ssize_t )row, (Py_ssize_t )col);
      }
#line 470
      goto failure;
    } else
#line 471
    if (c == 125) {
#line 472
      if (expect_key) {
#line 472
        if (items > 0) {
          {
#line 475
          getRowAndCol(jsondata->str, jsondata->ptr, & row___0, & col___0);
#line 476
          PyErr_Format(JSON_DecodeError, "expecting object property name at position %zd(row %zd, col %zd)",
                       jsondata->ptr - jsondata->str, (Py_ssize_t )row___0, (Py_ssize_t )col___0);
          }
#line 478
          goto failure;
        }
      }
#line 480
      (jsondata->ptr) ++;
#line 481
      goto while_break;
    } else
#line 482
    if (c == 44) {
#line 483
      if (expect_key) {
        {
#line 486
        getRowAndCol(jsondata->str, jsondata->ptr, & row___1, & col___1);
#line 487
        PyErr_Format(JSON_DecodeError, "expecting object property name at position %zd(row %zd, col %zd)",
                     jsondata->ptr - jsondata->str, (Py_ssize_t )row___1, (Py_ssize_t )col___1);
        }
#line 489
        goto failure;
      }
#line 491
      expect_key = 1;
#line 492
      (jsondata->ptr) ++;
#line 493
      goto while_continue;
    } else {
#line 495
      if (c != 34) {
        {
#line 498
        getRowAndCol(jsondata->str, jsondata->ptr, & row___2, & col___2);
#line 499
        PyErr_Format(JSON_DecodeError, "expecting property name in object at position %zd(row %zd, col %zd)",
                     jsondata->ptr - jsondata->str, (Py_ssize_t )row___2, (Py_ssize_t )col___2);
        }
#line 501
        goto failure;
      }
      {
#line 504
      key = decode_json(jsondata);
      }
#line 505
      if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 506
        goto failure;
      }
      {
#line 508
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 508
        if (*(jsondata->ptr)) {
          {
#line 508
          tmp___0 = __ctype_b_loc();
          }
#line 508
          if (! ((int const   )*(*tmp___0 + (int )*(jsondata->ptr)) & 8192)) {
#line 508
            goto while_break___1;
          }
        } else {
#line 508
          goto while_break___1;
        }
#line 508
        (jsondata->ptr) ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 509
      if ((int )*(jsondata->ptr) != 58) {
        {
#line 512
        getRowAndCol(jsondata->str, jsondata->ptr, & row___3, & col___3);
#line 513
        PyErr_Format(JSON_DecodeError, "missing colon after object property name at position %zd(row %zd, col %zd)",
                     jsondata->ptr - jsondata->str, (Py_ssize_t )row___3, (Py_ssize_t )col___3);
        }
        {
#line 515
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 515
          (key->ob_refcnt) --;
#line 515
          if (! (key->ob_refcnt != 0L)) {
            {
#line 515
            (*((key->ob_type)->tp_dealloc))(key);
            }
          }
#line 515
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 516
        goto failure;
      } else {
#line 518
        (jsondata->ptr) ++;
      }
      {
#line 521
      value = decode_json(jsondata);
      }
#line 522
      if ((unsigned long )value == (unsigned long )((void *)0)) {
        {
#line 523
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 523
          (key->ob_refcnt) --;
#line 523
          if (! (key->ob_refcnt != 0L)) {
            {
#line 523
            (*((key->ob_type)->tp_dealloc))(key);
            }
          }
#line 523
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 524
        goto failure;
      }
      {
#line 527
      result = PyDict_SetItem(object___0, key, value);
      }
      {
#line 528
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 528
        (key->ob_refcnt) --;
#line 528
        if (! (key->ob_refcnt != 0L)) {
          {
#line 528
          (*((key->ob_type)->tp_dealloc))(key);
          }
        }
#line 528
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 529
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 529
        (value->ob_refcnt) --;
#line 529
        if (! (value->ob_refcnt != 0L)) {
          {
#line 529
          (*((value->ob_type)->tp_dealloc))(value);
          }
        }
#line 529
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 530
      if (result == -1) {
#line 531
        goto failure;
      }
#line 532
      expect_key = 0;
#line 533
      items ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 537
  return (object___0);
  failure: 
  {
#line 540
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 540
    (object___0->ob_refcnt) --;
#line 540
    if (! (object___0->ob_refcnt != 0L)) {
      {
#line 540
      (*((object___0->ob_type)->tp_dealloc))(object___0);
      }
    }
#line 540
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 541
  return ((PyObject *)((void *)0));
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static PyObject *decode_json(JSONData *jsondata ) 
{ 
  PyObject *object___0 ;
  unsigned short const   **tmp ;

  {
  {
#line 547
  while (1) {
    while_continue: /* CIL Label */ ;
#line 547
    if (*(jsondata->ptr)) {
      {
#line 547
      tmp = __ctype_b_loc();
      }
#line 547
      if (! ((int const   )*(*tmp + (int )*(jsondata->ptr)) & 8192)) {
#line 547
        goto while_break;
      }
    } else {
#line 547
      goto while_break;
    }
#line 547
    (jsondata->ptr) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 549
  if ((int )*(jsondata->ptr) == 0) {
#line 549
    goto case_0;
  }
#line 553
  if ((int )*(jsondata->ptr) == 123) {
#line 553
    goto case_123;
  }
#line 557
  if ((int )*(jsondata->ptr) == 91) {
#line 557
    goto case_91;
  }
#line 561
  if ((int )*(jsondata->ptr) == 34) {
#line 561
    goto case_34;
  }
#line 566
  if ((int )*(jsondata->ptr) == 102) {
#line 566
    goto case_102;
  }
#line 566
  if ((int )*(jsondata->ptr) == 116) {
#line 566
    goto case_102;
  }
#line 570
  if ((int )*(jsondata->ptr) == 110) {
#line 570
    goto case_110;
  }
#line 574
  if ((int )*(jsondata->ptr) == 78) {
#line 574
    goto case_78;
  }
#line 578
  if ((int )*(jsondata->ptr) == 73) {
#line 578
    goto case_73;
  }
#line 583
  if ((int )*(jsondata->ptr) == 45) {
#line 583
    goto case_45;
  }
#line 583
  if ((int )*(jsondata->ptr) == 43) {
#line 583
    goto case_45;
  }
#line 600
  if ((int )*(jsondata->ptr) == 57) {
#line 600
    goto case_57;
  }
#line 600
  if ((int )*(jsondata->ptr) == 56) {
#line 600
    goto case_57;
  }
#line 600
  if ((int )*(jsondata->ptr) == 55) {
#line 600
    goto case_57;
  }
#line 600
  if ((int )*(jsondata->ptr) == 54) {
#line 600
    goto case_57;
  }
#line 600
  if ((int )*(jsondata->ptr) == 53) {
#line 600
    goto case_57;
  }
#line 600
  if ((int )*(jsondata->ptr) == 52) {
#line 600
    goto case_57;
  }
#line 600
  if ((int )*(jsondata->ptr) == 51) {
#line 600
    goto case_57;
  }
#line 600
  if ((int )*(jsondata->ptr) == 50) {
#line 600
    goto case_57;
  }
#line 600
  if ((int )*(jsondata->ptr) == 49) {
#line 600
    goto case_57;
  }
#line 600
  if ((int )*(jsondata->ptr) == 48) {
#line 600
    goto case_57;
  }
#line 604
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 550
  PyErr_SetString(JSON_DecodeError, "empty JSON description");
  }
#line 551
  return ((PyObject *)((void *)0));
  case_123: /* CIL Label */ 
  {
#line 554
  object___0 = decode_object(jsondata);
  }
#line 555
  goto switch_break;
  case_91: /* CIL Label */ 
  {
#line 558
  object___0 = decode_array(jsondata);
  }
#line 559
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 562
  object___0 = decode_string(jsondata);
  }
#line 563
  goto switch_break;
  case_102: /* CIL Label */ 
  case_116: /* CIL Label */ 
  {
#line 567
  object___0 = decode_bool(jsondata);
  }
#line 568
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 571
  object___0 = decode_null(jsondata);
  }
#line 572
  goto switch_break;
  case_78: /* CIL Label */ 
  {
#line 575
  object___0 = decode_nan(jsondata);
  }
#line 576
  goto switch_break;
  case_73: /* CIL Label */ 
  {
#line 579
  object___0 = decode_inf(jsondata);
  }
#line 580
  goto switch_break;
  case_45: /* CIL Label */ 
  case_43: /* CIL Label */ 
#line 584
  if ((int )*(jsondata->ptr + 1) == 73) {
    {
#line 585
    object___0 = decode_inf(jsondata);
    }
  } else {
    {
#line 587
    object___0 = decode_number(jsondata);
    }
  }
#line 589
  goto switch_break;
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
  {
#line 601
  object___0 = decode_number(jsondata);
  }
#line 602
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 605
  PyErr_SetString(JSON_DecodeError, "cannot parse JSON description");
  }
#line 606
  return ((PyObject *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 609
  return (object___0);
}
}
#line 622 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static PyObject *encode_string(PyObject *string ) 
{ 
  register PyStringObject *op ;
  size_t newsize ;
  PyObject *v ;
  register Py_ssize_t i ;
  register char c ;
  register char *p ;
  int quote ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
#line 623
  op = (PyStringObject *)string;
#line 624
  newsize = (size_t )(2L + 6L * ((PyVarObject *)op)->ob_size);
#line 627
  if (((PyVarObject *)op)->ob_size > ((Py_ssize_t )(0xffffffffffffffffUL >> 1) - 2L) / 6L) {
    {
#line 628
    PyErr_SetString(PyExc_OverflowError, "string is too large to make repr");
    }
#line 629
    return ((PyObject *)((void *)0));
  }
  {
#line 631
  v = PyString_FromStringAndSize((char const   *)((char *)((void *)0)), (Py_ssize_t )newsize);
  }
#line 632
  if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 633
    return ((PyObject *)((void *)0));
  } else {
#line 640
    quote = '\"';
#line 642
    p = ((PyStringObject *)v)->ob_sval;
#line 643
    tmp = p;
#line 643
    p ++;
#line 643
    *tmp = (char )quote;
#line 644
    i = (Py_ssize_t )0;
    {
#line 644
    while (1) {
      while_continue: /* CIL Label */ ;
#line 644
      if (! (i < ((PyVarObject *)op)->ob_size)) {
#line 644
        goto while_break;
      }
#line 647
      if (! (newsize - (size_t )(p - ((PyStringObject *)v)->ob_sval) >= 7UL)) {
        {
#line 647
        __assert_fail("newsize-(p-(((PyStringObject *)(v))->ob_sval)) >= 7", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c",
                      647U, "encode_string");
        }
      }
#line 648
      c = op->ob_sval[i];
#line 649
      if ((int )c == quote) {
#line 649
        goto _L;
      } else
#line 649
      if ((int )c == 92) {
        _L: /* CIL Label */ 
#line 650
        tmp___0 = p;
#line 650
        p ++;
#line 650
        *tmp___0 = (char )'\\';
#line 650
        tmp___1 = p;
#line 650
        p ++;
#line 650
        *tmp___1 = c;
      } else
#line 651
      if ((int )c == 9) {
#line 652
        tmp___2 = p;
#line 652
        p ++;
#line 652
        *tmp___2 = (char )'\\';
#line 652
        tmp___3 = p;
#line 652
        p ++;
#line 652
        *tmp___3 = (char )'t';
      } else
#line 653
      if ((int )c == 10) {
#line 654
        tmp___4 = p;
#line 654
        p ++;
#line 654
        *tmp___4 = (char )'\\';
#line 654
        tmp___5 = p;
#line 654
        p ++;
#line 654
        *tmp___5 = (char )'n';
      } else
#line 655
      if ((int )c == 13) {
#line 656
        tmp___6 = p;
#line 656
        p ++;
#line 656
        *tmp___6 = (char )'\\';
#line 656
        tmp___7 = p;
#line 656
        p ++;
#line 656
        *tmp___7 = (char )'r';
      } else
#line 657
      if ((int )c == 12) {
#line 658
        tmp___8 = p;
#line 658
        p ++;
#line 658
        *tmp___8 = (char )'\\';
#line 658
        tmp___9 = p;
#line 658
        p ++;
#line 658
        *tmp___9 = (char )'f';
      } else
#line 659
      if ((int )c == 8) {
#line 660
        tmp___10 = p;
#line 660
        p ++;
#line 660
        *tmp___10 = (char )'\\';
#line 660
        tmp___11 = p;
#line 660
        p ++;
#line 660
        *tmp___11 = (char )'b';
      } else
#line 661
      if ((int )c < 32) {
        {
#line 665
        sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"\\u%04x",
                (int )c & 255);
#line 666
        p += 6;
        }
      } else
#line 661
      if ((int )c >= 127) {
        {
#line 665
        sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"\\u%04x",
                (int )c & 255);
#line 666
        p += 6;
        }
      } else {
#line 669
        tmp___12 = p;
#line 669
        p ++;
#line 669
        *tmp___12 = c;
      }
#line 644
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 671
    if (! (newsize - (size_t )(p - ((PyStringObject *)v)->ob_sval) >= 1UL)) {
      {
#line 671
      __assert_fail("newsize-(p-(((PyStringObject *)(v))->ob_sval)) >= 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c",
                    671U, "encode_string");
      }
    }
    {
#line 672
    tmp___13 = p;
#line 672
    p ++;
#line 672
    *tmp___13 = (char )quote;
#line 673
    *p = (char )'\000';
#line 674
    _PyString_Resize(& v, (Py_ssize_t )((int )(p - ((PyStringObject *)v)->ob_sval)));
    }
#line 675
    return (v);
  }
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static char const   *hexdigit  =    "0123456789abcdef";
#line 695 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static long const   expandsize  =    (Py_ssize_t const   )10;
#line 688 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static PyObject *encode_unicode(PyObject *unicode ) 
{ 
  PyObject *repr ;
  Py_UNICODE *s ;
  Py_ssize_t size ;
  char *p ;
  int tmp ;
  char *tmp___0 ;
  Py_UNICODE ch ;
  Py_UNICODE *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  Py_ssize_t tmp___39 ;
  char *tmp___40 ;
  int tmp___41 ;
  char *tmp___42 ;
  PyObject *result ;
  int tmp___43 ;
  char *tmp___44 ;
  int tmp___45 ;
  char *tmp___46 ;
  PyObject *tmp___47 ;

  {
#line 700
  s = ((PyUnicodeObject *)unicode)->str;
#line 701
  size = ((PyUnicodeObject *)unicode)->length;
#line 703
  if (size > (((Py_ssize_t )(0xffffffffffffffffUL >> 1) - 2L) - 1L) / (Py_ssize_t )expandsize) {
    {
#line 704
    PyErr_SetString(PyExc_OverflowError, "unicode object is too large to make repr");
    }
#line 705
    return ((PyObject *)((void *)0));
  }
  {
#line 708
  repr = PyByteArray_FromStringAndSize((char const   *)((void *)0), (Py_ssize_t )((2L + expandsize * (long const   )size) + 1L));
  }
#line 712
  if ((unsigned long )repr == (unsigned long )((void *)0)) {
#line 713
    return ((PyObject *)((void *)0));
  }
#line 715
  if (! ((unsigned long )repr->ob_type == (unsigned long )(& PyByteArray_Type))) {
    {
#line 715
    tmp = PyType_IsSubtype(repr->ob_type, & PyByteArray_Type);
    }
#line 715
    if (! tmp) {
      {
#line 715
      __assert_fail("((((PyObject*)(repr))->ob_type) == (&PyByteArray_Type) || PyType_IsSubtype((((PyObject*)(repr))->ob_type), (&PyByteArray_Type)))",
                    "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c",
                    715U, "encode_unicode");
      }
    }
  }
#line 715
  if (((PyVarObject *)repr)->ob_size) {
#line 715
    p = ((PyByteArrayObject *)repr)->ob_bytes;
  } else {
#line 715
    p = _PyByteArray_empty_string;
  }
#line 717
  tmp___0 = p;
#line 717
  p ++;
#line 717
  *tmp___0 = (char )'\"';
  {
#line 719
  while (1) {
    while_continue: /* CIL Label */ ;
#line 719
    tmp___39 = size;
#line 719
    size --;
#line 719
    if (! (tmp___39 > 0L)) {
#line 719
      goto while_break;
    }
#line 720
    tmp___1 = s;
#line 720
    s ++;
#line 720
    ch = *tmp___1;
#line 723
    if (! ((unsigned long )repr->ob_type == (unsigned long )(& PyByteArray_Type))) {
      {
#line 723
      tmp___14 = PyType_IsSubtype(repr->ob_type, & PyByteArray_Type);
      }
#line 723
      if (! tmp___14) {
        {
#line 723
        __assert_fail("((((PyObject*)(repr))->ob_type) == (&PyByteArray_Type) || PyType_IsSubtype((((PyObject*)(repr))->ob_type), (&PyByteArray_Type)))",
                      "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c",
                      723U, "encode_unicode");
        }
      }
    }
#line 723
    if (((PyVarObject *)repr)->ob_size) {
#line 723
      tmp___15 = ((PyByteArrayObject *)repr)->ob_bytes;
    } else {
#line 723
      tmp___15 = _PyByteArray_empty_string;
    }
#line 723
    if (ch == (Py_UNICODE )*(tmp___15 + 0)) {
#line 723
      goto _L;
    } else
#line 723
    if (ch == 92U) {
      _L: /* CIL Label */ 
#line 724
      tmp___2 = p;
#line 724
      p ++;
#line 724
      *tmp___2 = (char )'\\';
#line 725
      tmp___3 = p;
#line 725
      p ++;
#line 725
      *tmp___3 = (char )ch;
#line 726
      goto while_continue;
    } else
#line 730
    if (ch >= 65536U) {
#line 731
      tmp___4 = p;
#line 731
      p ++;
#line 731
      *tmp___4 = (char )'\\';
#line 732
      tmp___5 = p;
#line 732
      p ++;
#line 732
      *tmp___5 = (char )'U';
#line 733
      tmp___6 = p;
#line 733
      p ++;
#line 733
      *tmp___6 = (char )*(hexdigit + ((ch >> 28) & 15U));
#line 734
      tmp___7 = p;
#line 734
      p ++;
#line 734
      *tmp___7 = (char )*(hexdigit + ((ch >> 24) & 15U));
#line 735
      tmp___8 = p;
#line 735
      p ++;
#line 735
      *tmp___8 = (char )*(hexdigit + ((ch >> 20) & 15U));
#line 736
      tmp___9 = p;
#line 736
      p ++;
#line 736
      *tmp___9 = (char )*(hexdigit + ((ch >> 16) & 15U));
#line 737
      tmp___10 = p;
#line 737
      p ++;
#line 737
      *tmp___10 = (char )*(hexdigit + ((ch >> 12) & 15U));
#line 738
      tmp___11 = p;
#line 738
      p ++;
#line 738
      *tmp___11 = (char )*(hexdigit + ((ch >> 8) & 15U));
#line 739
      tmp___12 = p;
#line 739
      p ++;
#line 739
      *tmp___12 = (char )*(hexdigit + ((ch >> 4) & 15U));
#line 740
      tmp___13 = p;
#line 740
      p ++;
#line 740
      *tmp___13 = (char )*(hexdigit + (ch & 15U));
#line 741
      goto while_continue;
    }
#line 771
    if (ch >= 256U) {
#line 772
      tmp___16 = p;
#line 772
      p ++;
#line 772
      *tmp___16 = (char )'\\';
#line 773
      tmp___17 = p;
#line 773
      p ++;
#line 773
      *tmp___17 = (char )'u';
#line 774
      tmp___18 = p;
#line 774
      p ++;
#line 774
      *tmp___18 = (char )*(hexdigit + ((ch >> 12) & 15U));
#line 775
      tmp___19 = p;
#line 775
      p ++;
#line 775
      *tmp___19 = (char )*(hexdigit + ((ch >> 8) & 15U));
#line 776
      tmp___20 = p;
#line 776
      p ++;
#line 776
      *tmp___20 = (char )*(hexdigit + ((ch >> 4) & 15U));
#line 777
      tmp___21 = p;
#line 777
      p ++;
#line 777
      *tmp___21 = (char )*(hexdigit + (ch & 15U));
    } else
#line 779
    if (ch == 9U) {
#line 780
      tmp___22 = p;
#line 780
      p ++;
#line 780
      *tmp___22 = (char )'\\';
#line 781
      tmp___23 = p;
#line 781
      p ++;
#line 781
      *tmp___23 = (char )'t';
    } else
#line 782
    if (ch == 10U) {
#line 783
      tmp___24 = p;
#line 783
      p ++;
#line 783
      *tmp___24 = (char )'\\';
#line 784
      tmp___25 = p;
#line 784
      p ++;
#line 784
      *tmp___25 = (char )'n';
    } else
#line 785
    if (ch == 13U) {
#line 786
      tmp___26 = p;
#line 786
      p ++;
#line 786
      *tmp___26 = (char )'\\';
#line 787
      tmp___27 = p;
#line 787
      p ++;
#line 787
      *tmp___27 = (char )'r';
    } else
#line 788
    if (ch == 12U) {
#line 789
      tmp___28 = p;
#line 789
      p ++;
#line 789
      *tmp___28 = (char )'\\';
#line 790
      tmp___29 = p;
#line 790
      p ++;
#line 790
      *tmp___29 = (char )'f';
    } else
#line 791
    if (ch == 8U) {
#line 792
      tmp___30 = p;
#line 792
      p ++;
#line 792
      *tmp___30 = (char )'\\';
#line 793
      tmp___31 = p;
#line 793
      p ++;
#line 793
      *tmp___31 = (char )'b';
    } else
#line 797
    if (ch < 32U) {
#line 797
      goto _L___0;
    } else
#line 797
    if (ch >= 127U) {
      _L___0: /* CIL Label */ 
#line 798
      tmp___32 = p;
#line 798
      p ++;
#line 798
      *tmp___32 = (char )'\\';
#line 799
      tmp___33 = p;
#line 799
      p ++;
#line 799
      *tmp___33 = (char )'u';
#line 800
      tmp___34 = p;
#line 800
      p ++;
#line 800
      *tmp___34 = (char )'0';
#line 801
      tmp___35 = p;
#line 801
      p ++;
#line 801
      *tmp___35 = (char )'0';
#line 802
      tmp___36 = p;
#line 802
      p ++;
#line 802
      *tmp___36 = (char )*(hexdigit + ((ch >> 4) & 15U));
#line 803
      tmp___37 = p;
#line 803
      p ++;
#line 803
      *tmp___37 = (char )*(hexdigit + (ch & 15U));
    } else {
#line 808
      tmp___38 = p;
#line 808
      p ++;
#line 808
      *tmp___38 = (char )ch;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 811
  tmp___40 = p;
#line 811
  p ++;
#line 811
  if (! ((unsigned long )repr->ob_type == (unsigned long )(& PyByteArray_Type))) {
    {
#line 811
    tmp___41 = PyType_IsSubtype(repr->ob_type, & PyByteArray_Type);
    }
#line 811
    if (! tmp___41) {
      {
#line 811
      __assert_fail("((((PyObject*)(repr))->ob_type) == (&PyByteArray_Type) || PyType_IsSubtype((((PyObject*)(repr))->ob_type), (&PyByteArray_Type)))",
                    "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c",
                    811U, "encode_unicode");
      }
    }
  }
#line 811
  if (((PyVarObject *)repr)->ob_size) {
#line 811
    tmp___42 = ((PyByteArrayObject *)repr)->ob_bytes;
  } else {
#line 811
    tmp___42 = _PyByteArray_empty_string;
  }
#line 811
  *tmp___40 = *(tmp___42 + 0);
#line 813
  *p = (char )'\000';
#line 815
  if (! ((unsigned long )repr->ob_type == (unsigned long )(& PyByteArray_Type))) {
    {
#line 815
    tmp___43 = PyType_IsSubtype(repr->ob_type, & PyByteArray_Type);
    }
#line 815
    if (! tmp___43) {
      {
#line 815
      __assert_fail("((((PyObject*)(repr))->ob_type) == (&PyByteArray_Type) || PyType_IsSubtype((((PyObject*)(repr))->ob_type), (&PyByteArray_Type)))",
                    "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c",
                    816U, "encode_unicode");
      }
    }
  }
#line 815
  if (((PyVarObject *)repr)->ob_size) {
#line 815
    tmp___44 = ((PyByteArrayObject *)repr)->ob_bytes;
  } else {
#line 815
    tmp___44 = _PyByteArray_empty_string;
  }
#line 815
  if (! ((unsigned long )repr->ob_type == (unsigned long )(& PyByteArray_Type))) {
    {
#line 815
    tmp___45 = PyType_IsSubtype(repr->ob_type, & PyByteArray_Type);
    }
#line 815
    if (! tmp___45) {
      {
#line 815
      __assert_fail("((((PyObject*)(repr))->ob_type) == (&PyByteArray_Type) || PyType_IsSubtype((((PyObject*)(repr))->ob_type), (&PyByteArray_Type)))",
                    "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c",
                    815U, "encode_unicode");
      }
    }
  }
#line 815
  if (((PyVarObject *)repr)->ob_size) {
#line 815
    tmp___46 = ((PyByteArrayObject *)repr)->ob_bytes;
  } else {
#line 815
    tmp___46 = _PyByteArray_empty_string;
  }
  {
#line 815
  tmp___47 = PyString_FromStringAndSize((char const   *)tmp___46, p - tmp___44);
#line 815
  result = tmp___47;
  }
  {
#line 817
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 817
    (repr->ob_refcnt) --;
#line 817
    if (! (repr->ob_refcnt != 0L)) {
      {
#line 817
      (*((repr->ob_type)->tp_dealloc))(repr);
      }
    }
#line 817
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 818
  return (result);
}
}
#line 965 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static PyObject *encode_tuple(PyObject *tuple ) 
{ 
  Py_ssize_t i ;
  Py_ssize_t n ;
  PyObject *s ;
  PyObject *temp ;
  PyObject *pieces ;
  PyObject *result ;
  PyTupleObject *v ;
  PyObject *tmp ;

  {
#line 968
  result = (PyObject *)((void *)0);
#line 969
  v = (PyTupleObject *)tuple;
#line 971
  n = ((PyVarObject *)v)->ob_size;
#line 972
  if (n == 0L) {
    {
#line 973
    tmp = PyString_FromString("[]");
    }
#line 973
    return (tmp);
  }
  {
#line 975
  pieces = PyTuple_New(n);
  }
#line 976
  if ((unsigned long )pieces == (unsigned long )((void *)0)) {
#line 977
    return ((PyObject *)((void *)0));
  }
#line 980
  i = (Py_ssize_t )0;
  {
#line 980
  while (1) {
    while_continue: /* CIL Label */ ;
#line 980
    if (! (i < n)) {
#line 980
      goto while_break;
    }
    {
#line 981
    s = encode_object(v->ob_item[i]);
    }
#line 982
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 983
      goto Done;
    }
#line 984
    ((PyTupleObject *)pieces)->ob_item[i] = s;
#line 980
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 988
  if (! (n > 0L)) {
    {
#line 988
    __assert_fail("n > 0", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c",
                  988U, "encode_tuple");
    }
  }
  {
#line 989
  s = PyString_FromString("[");
  }
#line 990
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 991
    goto Done;
  }
  {
#line 992
  temp = ((PyTupleObject *)pieces)->ob_item[0];
#line 993
  PyString_ConcatAndDel(& s, temp);
#line 994
  ((PyTupleObject *)pieces)->ob_item[0] = s;
  }
#line 995
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 996
    goto Done;
  }
  {
#line 998
  s = PyString_FromString("]");
  }
#line 999
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1000
    goto Done;
  }
  {
#line 1001
  temp = ((PyTupleObject *)pieces)->ob_item[n - 1L];
#line 1002
  PyString_ConcatAndDel(& temp, s);
#line 1003
  ((PyTupleObject *)pieces)->ob_item[n - 1L] = temp;
  }
#line 1004
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 1005
    goto Done;
  }
  {
#line 1008
  s = PyString_FromString(", ");
  }
#line 1009
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1010
    goto Done;
  }
  {
#line 1011
  result = _PyString_Join(s, pieces);
  }
  {
#line 1012
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1012
    (s->ob_refcnt) --;
#line 1012
    if (! (s->ob_refcnt != 0L)) {
      {
#line 1012
      (*((s->ob_type)->tp_dealloc))(s);
      }
    }
#line 1012
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  Done: 
  {
#line 1015
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1015
    (pieces->ob_refcnt) --;
#line 1015
    if (! (pieces->ob_refcnt != 0L)) {
      {
#line 1015
      (*((pieces->ob_type)->tp_dealloc))(pieces);
      }
    }
#line 1015
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1016
  return (result);
}
}
#line 1028 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static PyObject *encode_list(PyObject *list ) 
{ 
  Py_ssize_t i ;
  PyObject *s ;
  PyObject *temp ;
  PyObject *pieces ;
  PyObject *result ;
  PyListObject *v ;
  int tmp ;
  int status ;

  {
  {
#line 1031
  pieces = (PyObject *)((void *)0);
#line 1031
  result = (PyObject *)((void *)0);
#line 1032
  v = (PyListObject *)list;
#line 1034
  tmp = Py_ReprEnter((PyObject *)v);
#line 1034
  i = (Py_ssize_t )tmp;
  }
#line 1035
  if (i != 0L) {
#line 1036
    if (i > 0L) {
      {
#line 1037
      PyErr_SetString(JSON_EncodeError, "a list with references to itself is not JSON encodable");
      }
    }
#line 1039
    return ((PyObject *)((void *)0));
  }
#line 1042
  if (((PyVarObject *)v)->ob_size == 0L) {
    {
#line 1043
    result = PyString_FromString("[]");
    }
#line 1044
    goto Done;
  }
  {
#line 1047
  pieces = PyList_New((Py_ssize_t )0);
  }
#line 1048
  if ((unsigned long )pieces == (unsigned long )((void *)0)) {
#line 1049
    goto Done;
  }
#line 1053
  i = (Py_ssize_t )0;
  {
#line 1053
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1053
    if (! (i < ((PyVarObject *)v)->ob_size)) {
#line 1053
      goto while_break;
    }
    {
#line 1055
    s = encode_object(*(v->ob_item + i));
    }
#line 1056
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1057
      goto Done;
    }
    {
#line 1058
    status = PyList_Append(pieces, s);
    }
    {
#line 1059
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1059
      (s->ob_refcnt) --;
#line 1059
      if (! (s->ob_refcnt != 0L)) {
        {
#line 1059
        (*((s->ob_type)->tp_dealloc))(s);
        }
      }
#line 1059
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1060
    if (status < 0) {
#line 1061
      goto Done;
    }
#line 1053
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1065
  if (! (((PyVarObject *)pieces)->ob_size > 0L)) {
    {
#line 1065
    __assert_fail("(((PyVarObject*)(pieces))->ob_size) > 0", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c",
                  1065U, "encode_list");
    }
  }
  {
#line 1066
  s = PyString_FromString("[");
  }
#line 1067
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1068
    goto Done;
  }
  {
#line 1069
  temp = *(((PyListObject *)pieces)->ob_item + 0);
#line 1070
  PyString_ConcatAndDel(& s, temp);
#line 1071
  *(((PyListObject *)pieces)->ob_item + 0) = s;
  }
#line 1072
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1073
    goto Done;
  }
  {
#line 1075
  s = PyString_FromString("]");
  }
#line 1076
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1077
    goto Done;
  }
  {
#line 1078
  temp = *(((PyListObject *)pieces)->ob_item + (((PyVarObject *)pieces)->ob_size - 1L));
#line 1079
  PyString_ConcatAndDel(& temp, s);
#line 1080
  *(((PyListObject *)pieces)->ob_item + (((PyVarObject *)pieces)->ob_size - 1L)) = temp;
  }
#line 1081
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 1082
    goto Done;
  }
  {
#line 1085
  s = PyString_FromString(", ");
  }
#line 1086
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1087
    goto Done;
  }
  {
#line 1088
  result = _PyString_Join(s, pieces);
  }
  {
#line 1089
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1089
    (s->ob_refcnt) --;
#line 1089
    if (! (s->ob_refcnt != 0L)) {
      {
#line 1089
      (*((s->ob_type)->tp_dealloc))(s);
      }
    }
#line 1089
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  Done: 
  {
#line 1092
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1092
    if (! ((unsigned long )pieces == (unsigned long )((void *)0))) {
      {
#line 1092
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1092
        (pieces->ob_refcnt) --;
#line 1092
        if (! (pieces->ob_refcnt != 0L)) {
          {
#line 1092
          (*((pieces->ob_type)->tp_dealloc))(pieces);
          }
        }
#line 1092
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 1092
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1093
  Py_ReprLeave((PyObject *)v);
  }
#line 1094
  return (result);
}
}
#line 1107 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static PyObject *encode_dict(PyObject *dict ) 
{ 
  Py_ssize_t i ;
  PyObject *s ;
  PyObject *temp ;
  PyObject *colon ;
  PyObject *pieces ;
  PyObject *result ;
  PyObject *key ;
  PyObject *value ;
  PyDictObject *mp ;
  int tmp ;
  int status ;
  PyObject *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1109
  colon = (PyObject *)((void *)0);
#line 1110
  pieces = (PyObject *)((void *)0);
#line 1110
  result = (PyObject *)((void *)0);
#line 1112
  mp = (PyDictObject *)dict;
#line 1114
  tmp = Py_ReprEnter((PyObject *)mp);
#line 1114
  i = (Py_ssize_t )tmp;
  }
#line 1115
  if (i != 0L) {
#line 1116
    if (i > 0L) {
      {
#line 1117
      PyErr_SetString(JSON_EncodeError, "a dict with references to itself is not JSON encodable");
      }
    }
#line 1120
    return ((PyObject *)((void *)0));
  }
#line 1123
  if (mp->ma_used == 0L) {
    {
#line 1124
    result = PyString_FromString("{}");
    }
#line 1125
    goto Done;
  }
  {
#line 1128
  pieces = PyList_New((Py_ssize_t )0);
  }
#line 1129
  if ((unsigned long )pieces == (unsigned long )((void *)0)) {
#line 1130
    goto Done;
  }
  {
#line 1132
  colon = PyString_FromString(": ");
  }
#line 1133
  if ((unsigned long )colon == (unsigned long )((void *)0)) {
#line 1134
    goto Done;
  }
#line 1138
  i = (Py_ssize_t )0;
  {
#line 1139
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1139
    tmp___1 = PyDict_Next((PyObject *)mp, & i, & key, & value);
    }
#line 1139
    if (! tmp___1) {
#line 1139
      goto while_break;
    }
#line 1142
    if (! (((key->ob_type)->tp_flags & (1L << 27)) != 0L)) {
#line 1142
      if (! (((key->ob_type)->tp_flags & (1L << 28)) != 0L)) {
        {
#line 1143
        PyErr_SetString(JSON_EncodeError, "JSON encodable dictionaries must have string/unicode keys");
        }
#line 1144
        goto Done;
      }
    }
    {
#line 1148
    (value->ob_refcnt) ++;
#line 1149
    s = encode_object(key);
#line 1150
    PyString_Concat(& s, colon);
#line 1151
    tmp___0 = encode_object(value);
#line 1151
    PyString_ConcatAndDel(& s, tmp___0);
    }
    {
#line 1152
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1152
      (value->ob_refcnt) --;
#line 1152
      if (! (value->ob_refcnt != 0L)) {
        {
#line 1152
        (*((value->ob_type)->tp_dealloc))(value);
        }
      }
#line 1152
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1153
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1154
      goto Done;
    }
    {
#line 1155
    status = PyList_Append(pieces, s);
    }
    {
#line 1156
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1156
      (s->ob_refcnt) --;
#line 1156
      if (! (s->ob_refcnt != 0L)) {
        {
#line 1156
        (*((s->ob_type)->tp_dealloc))(s);
        }
      }
#line 1156
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1157
    if (status < 0) {
#line 1158
      goto Done;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1162
  if (! (((PyVarObject *)pieces)->ob_size > 0L)) {
    {
#line 1162
    __assert_fail("(((PyVarObject*)(pieces))->ob_size) > 0", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c",
                  1162U, "encode_dict");
    }
  }
  {
#line 1163
  s = PyString_FromString("{");
  }
#line 1164
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1165
    goto Done;
  }
  {
#line 1166
  temp = *(((PyListObject *)pieces)->ob_item + 0);
#line 1167
  PyString_ConcatAndDel(& s, temp);
#line 1168
  *(((PyListObject *)pieces)->ob_item + 0) = s;
  }
#line 1169
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1170
    goto Done;
  }
  {
#line 1172
  s = PyString_FromString("}");
  }
#line 1173
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1174
    goto Done;
  }
  {
#line 1175
  temp = *(((PyListObject *)pieces)->ob_item + (((PyVarObject *)pieces)->ob_size - 1L));
#line 1176
  PyString_ConcatAndDel(& temp, s);
#line 1177
  *(((PyListObject *)pieces)->ob_item + (((PyVarObject *)pieces)->ob_size - 1L)) = temp;
  }
#line 1178
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 1179
    goto Done;
  }
  {
#line 1182
  s = PyString_FromString(", ");
  }
#line 1183
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1184
    goto Done;
  }
  {
#line 1185
  result = _PyString_Join(s, pieces);
  }
  {
#line 1186
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1186
    (s->ob_refcnt) --;
#line 1186
    if (! (s->ob_refcnt != 0L)) {
      {
#line 1186
      (*((s->ob_type)->tp_dealloc))(s);
      }
    }
#line 1186
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  Done: 
  {
#line 1189
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1189
    if (! ((unsigned long )pieces == (unsigned long )((void *)0))) {
      {
#line 1189
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1189
        (pieces->ob_refcnt) --;
#line 1189
        if (! (pieces->ob_refcnt != 0L)) {
          {
#line 1189
          (*((pieces->ob_type)->tp_dealloc))(pieces);
          }
        }
#line 1189
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 1189
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1190
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1190
    if (! ((unsigned long )colon == (unsigned long )((void *)0))) {
      {
#line 1190
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1190
        (colon->ob_refcnt) --;
#line 1190
        if (! (colon->ob_refcnt != 0L)) {
          {
#line 1190
          (*((colon->ob_type)->tp_dealloc))(colon);
          }
        }
#line 1190
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 1190
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1191
  Py_ReprLeave((PyObject *)mp);
  }
#line 1192
  return (result);
}
}
#line 1195 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static PyObject *encode_object(PyObject *object___0 ) 
{ 
  PyObject *tmp ;
  PyObject *tmp___0 ;
  PyObject *tmp___1 ;
  PyObject *tmp___2 ;
  PyObject *tmp___3 ;
  double val ;
  PyObject *tmp___4 ;
  PyObject *tmp___5 ;
  PyObject *tmp___6 ;
  PyObject *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  PyObject *tmp___18 ;
  PyObject *tmp___19 ;
  PyObject *tmp___20 ;
  PyObject *tmp___21 ;
  int tmp___22 ;

  {
#line 1196
  if ((unsigned long )object___0 == (unsigned long )((PyObject *)(& _Py_TrueStruct))) {
    {
#line 1197
    tmp = PyString_FromString("true");
    }
#line 1197
    return (tmp);
  } else
#line 1198
  if ((unsigned long )object___0 == (unsigned long )((PyObject *)(& _Py_ZeroStruct))) {
    {
#line 1199
    tmp___0 = PyString_FromString("false");
    }
#line 1199
    return (tmp___0);
  } else
#line 1200
  if ((unsigned long )object___0 == (unsigned long )(& _Py_NoneStruct)) {
    {
#line 1201
    tmp___1 = PyString_FromString("null");
    }
#line 1201
    return (tmp___1);
  } else
#line 1202
  if (((object___0->ob_type)->tp_flags & (1L << 27)) != 0L) {
    {
#line 1203
    tmp___2 = encode_string(object___0);
    }
#line 1203
    return (tmp___2);
  } else
#line 1204
  if (((object___0->ob_type)->tp_flags & (1L << 28)) != 0L) {
    {
#line 1205
    tmp___3 = encode_unicode(object___0);
    }
#line 1205
    return (tmp___3);
  } else
#line 1206
  if ((unsigned long )object___0->ob_type == (unsigned long )(& PyFloat_Type)) {
#line 1206
    goto _L;
  } else {
    {
#line 1206
    tmp___22 = PyType_IsSubtype(object___0->ob_type, & PyFloat_Type);
    }
#line 1206
    if (tmp___22) {
      _L: /* CIL Label */ 
#line 1207
      val = ((PyFloatObject *)object___0)->ob_fval;
#line 1208
      if (sizeof(val) == sizeof(float )) {
        {
#line 1208
        tmp___13 = __isnanf((float )val);
#line 1208
        tmp___17 = tmp___13;
        }
      } else {
#line 1208
        if (sizeof(val) == sizeof(double )) {
          {
#line 1208
          tmp___14 = __isnan(val);
#line 1208
          tmp___16 = tmp___14;
          }
        } else {
          {
#line 1208
          tmp___15 = __isnanl((long double )val);
#line 1208
          tmp___16 = tmp___15;
          }
        }
#line 1208
        tmp___17 = tmp___16;
      }
#line 1208
      if (tmp___17) {
        {
#line 1209
        tmp___4 = PyString_FromString("NaN");
        }
#line 1209
        return (tmp___4);
      } else {
#line 1210
        if (sizeof(val) == sizeof(float )) {
          {
#line 1210
          tmp___8 = __isinff((float )val);
#line 1210
          tmp___12 = tmp___8;
          }
        } else {
#line 1210
          if (sizeof(val) == sizeof(double )) {
            {
#line 1210
            tmp___9 = __isinf(val);
#line 1210
            tmp___11 = tmp___9;
            }
          } else {
            {
#line 1210
            tmp___10 = __isinfl((long double )val);
#line 1210
            tmp___11 = tmp___10;
            }
          }
#line 1210
          tmp___12 = tmp___11;
        }
#line 1210
        if (tmp___12) {
#line 1211
          if (val > (double )0) {
            {
#line 1212
            tmp___5 = PyString_FromString("Infinity");
            }
#line 1212
            return (tmp___5);
          } else {
            {
#line 1214
            tmp___6 = PyString_FromString("-Infinity");
            }
#line 1214
            return (tmp___6);
          }
        } else {
          {
#line 1217
          tmp___7 = PyObject_Str(object___0);
          }
#line 1217
          return (tmp___7);
        }
      }
    } else
#line 1225
    if (((object___0->ob_type)->tp_flags & (1L << 23)) != 0L) {
      {
#line 1226
      tmp___18 = PyObject_Str(object___0);
      }
#line 1226
      return (tmp___18);
    } else
#line 1225
    if (((object___0->ob_type)->tp_flags & (1L << 24)) != 0L) {
      {
#line 1226
      tmp___18 = PyObject_Str(object___0);
      }
#line 1226
      return (tmp___18);
    } else
#line 1229
    if (((object___0->ob_type)->tp_flags & (1L << 25)) != 0L) {
      {
#line 1230
      tmp___19 = encode_list(object___0);
      }
#line 1230
      return (tmp___19);
    } else
#line 1231
    if (((object___0->ob_type)->tp_flags & (1L << 26)) != 0L) {
      {
#line 1232
      tmp___20 = encode_tuple(object___0);
      }
#line 1232
      return (tmp___20);
    } else
#line 1233
    if (((object___0->ob_type)->tp_flags & (1L << 29)) != 0L) {
      {
#line 1234
      tmp___21 = encode_dict(object___0);
      }
#line 1234
      return (tmp___21);
    } else {
      {
#line 1236
      PyErr_SetString(JSON_EncodeError, "object is not JSON encodable");
      }
#line 1237
      return ((PyObject *)((void *)0));
    }
  }
}
}
#line 1243 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static PyObject *JSON_encode(PyObject *self , PyObject *object___0 ) 
{ 
  PyObject *tmp ;

  {
  {
#line 1244
  tmp = encode_object(object___0);
  }
#line 1244
  return (tmp);
}
}
#line 1250
static PyObject *JSON_decode(PyObject *self , PyObject *args , PyObject *kwargs ) ;
#line 1250 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static char *kwlist[3]  = {      (char *)"json",      (char *)"all_unicode",      (char *)((void *)0)};
#line 1249 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static PyObject *JSON_decode(PyObject *self , PyObject *args , PyObject *kwargs ) 
{ 
  int all_unicode ;
  PyObject *object___0 ;
  PyObject *string ;
  PyObject *str ;
  JSONData jsondata ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 1254
  all_unicode = 0;
#line 1259
  tmp = PyArg_ParseTupleAndKeywords(args, kwargs, "O|i:decode", kwlist, & string,
                                    & all_unicode);
  }
#line 1259
  if (! tmp) {
#line 1260
    return ((PyObject *)((void *)0));
  }
#line 1262
  if (((string->ob_type)->tp_flags & (1L << 28)) != 0L) {
    {
#line 1268
    str = PyUnicodeUCS4_AsRawUnicodeEscapeString(string);
    }
#line 1270
    if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 1271
      return ((PyObject *)((void *)0));
    }
  } else {
#line 1274
    (string->ob_refcnt) ++;
#line 1275
    str = string;
  }
  {
#line 1278
  tmp___0 = PyString_AsStringAndSize(str, & jsondata.str, (Py_ssize_t *)((void *)0));
  }
#line 1278
  if (tmp___0 == -1) {
    {
#line 1279
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1279
      (str->ob_refcnt) --;
#line 1279
      if (! (str->ob_refcnt != 0L)) {
        {
#line 1279
        (*((str->ob_type)->tp_dealloc))(str);
        }
      }
#line 1279
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1280
    return ((PyObject *)((void *)0));
  }
  {
#line 1283
  jsondata.ptr = jsondata.str;
#line 1284
  tmp___1 = strlen((char const   *)jsondata.str);
#line 1284
  jsondata.end = jsondata.str + tmp___1;
#line 1285
  jsondata.all_unicode = all_unicode;
#line 1287
  object___0 = decode_json(& jsondata);
  }
#line 1289
  if ((unsigned long )object___0 != (unsigned long )((void *)0)) {
    {
#line 1290
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1290
      if (*(jsondata.ptr)) {
        {
#line 1290
        tmp___2 = __ctype_b_loc();
        }
#line 1290
        if (! ((int const   )*(*tmp___2 + (int )*(jsondata.ptr)) & 8192)) {
#line 1290
          goto while_break___0;
        }
      } else {
#line 1290
        goto while_break___0;
      }
#line 1290
      (jsondata.ptr) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1291
    if ((unsigned long )jsondata.ptr < (unsigned long )jsondata.end) {
      {
#line 1292
      PyErr_Format(JSON_DecodeError, "extra data after JSON description at position %zd",
                   jsondata.ptr - jsondata.str);
      }
      {
#line 1293
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1293
        (str->ob_refcnt) --;
#line 1293
        if (! (str->ob_refcnt != 0L)) {
          {
#line 1293
          (*((str->ob_type)->tp_dealloc))(str);
          }
        }
#line 1293
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1294
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1294
        (object___0->ob_refcnt) --;
#line 1294
        if (! (object___0->ob_refcnt != 0L)) {
          {
#line 1294
          (*((object___0->ob_type)->tp_dealloc))(object___0);
          }
        }
#line 1294
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1295
      return ((PyObject *)((void *)0));
    }
  }
  {
#line 1299
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1299
    (str->ob_refcnt) --;
#line 1299
    if (! (str->ob_refcnt != 0L)) {
      {
#line 1299
      (*((str->ob_type)->tp_dealloc))(str);
      }
    }
#line 1299
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1301
  return (object___0);
}
}
#line 1306 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static PyMethodDef cjson_methods[3]  = {      {"encode", & JSON_encode, 8, "encode(object) -> generate the JSON representation for object."}, 
        {"decode",
      (PyObject *(*)(PyObject * , PyObject * ))(& JSON_decode), 3, "decode(string, all_unicode=False) -> parse the JSON representation into\npython objects. The optional argument `all_unicode\', specifies how to\nconvert the strings in the JSON representation into python objects.\nIf it is False (default on Python 2.x), it will return strings/bytes\neverywhere possible and unicode objects only where necessary, else\nit will return unicode objects everywhere (this is slower, but default\non Python 3.x)."}, 
        {(char const   *)((void *)0),
      (PyObject *(*)(PyObject * , PyObject * ))((void *)0), 0, (char const   *)((void *)0)}};
#line 1333 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static char module_doc[34]  = 
#line 1333
  {      (char )'F',      (char )'a',      (char )'s',      (char )'t', 
        (char )' ',      (char )'J',      (char )'S',      (char )'O', 
        (char )'N',      (char )' ',      (char )'e',      (char )'n', 
        (char )'c',      (char )'o',      (char )'d',      (char )'e', 
        (char )'r',      (char )'/',      (char )'d',      (char )'e', 
        (char )'c',      (char )'o',      (char )'d',      (char )'e', 
        (char )'r',      (char )' ',      (char )'m',      (char )'o', 
        (char )'d',      (char )'u',      (char )'l',      (char )'e', 
        (char )'.',      (char )'\000'};
#line 1337 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
static void initcjson_shared(PyObject *m ) 
{ 


  {
  {
#line 1338
  JSON_Error = PyErr_NewException((char *)"cjson.Error", (PyObject *)((void *)0),
                                  (PyObject *)((void *)0));
  }
#line 1339
  if ((unsigned long )JSON_Error == (unsigned long )((void *)0)) {
#line 1340
    return;
  }
  {
#line 1341
  (JSON_Error->ob_refcnt) ++;
#line 1342
  PyModule_AddObject(m, "Error", JSON_Error);
#line 1344
  JSON_EncodeError = PyErr_NewException((char *)"cjson.EncodeError", JSON_Error, (PyObject *)((void *)0));
  }
#line 1345
  if ((unsigned long )JSON_EncodeError == (unsigned long )((void *)0)) {
#line 1346
    return;
  }
  {
#line 1347
  (JSON_EncodeError->ob_refcnt) ++;
#line 1348
  PyModule_AddObject(m, "EncodeError", JSON_EncodeError);
#line 1350
  JSON_DecodeError = PyErr_NewException((char *)"cjson.DecodeError", JSON_Error, (PyObject *)((void *)0));
  }
#line 1351
  if ((unsigned long )JSON_DecodeError == (unsigned long )((void *)0)) {
#line 1352
    return;
  }
  {
#line 1353
  (JSON_DecodeError->ob_refcnt) ++;
#line 1354
  PyModule_AddObject(m, "DecodeError", JSON_DecodeError);
#line 1357
  PyModule_AddStringConstant(m, "__version__", "1.0.5");
  }
#line 1358
  return;
}
}
#line 1389 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cjson.c"
void initcjson(void) 
{ 
  PyObject *m ;

  {
  {
#line 1392
  m = Py_InitModule4_64("cjson", cjson_methods, (char const   *)(module_doc), (PyObject *)((void *)0),
                        1013);
  }
#line 1394
  if ((unsigned long )m == (unsigned long )((void *)0)) {
#line 1395
    return;
  }
  {
#line 1397
  initcjson_shared(m);
  }
#line 1398
  return;
}
}
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 449 "/usr/include/python2.7/object.h"
extern int PyType_Ready(PyTypeObject * ) ;
#line 451
extern PyObject *PyType_GenericNew(PyTypeObject * , PyObject * , PyObject * ) ;
#line 472
extern int PyObject_SetAttrString(PyObject * , char const   * , PyObject * ) ;
#line 28 "/usr/include/python2.7/pydebug.h"
extern int Py_Py3kWarningFlag ;
#line 18 "/usr/include/python2.7/longobject.h"
extern PyObject *PyLong_FromLong(long  ) ;
#line 149 "/usr/include/python2.7/dictobject.h"
extern PyObject *PyDict_GetItemString(PyObject *dp , char const   *key ) ;
#line 150
extern int PyDict_SetItemString(PyObject *dp , char const   *key , PyObject *item ) ;
#line 15 "/usr/include/python2.7/moduleobject.h"
extern PyObject *PyModule_New(char const   * ) ;
#line 16
extern PyObject *PyModule_GetDict(PyObject * ) ;
#line 40 "/usr/include/python2.7/fileobject.h"
extern PyObject *PyFile_FromString(char * , char * ) ;
#line 46
extern FILE *PyFile_AsFile(PyObject * ) ;
#line 41 "/usr/include/python2.7/modsupport.h"
extern int PyModule_AddIntConstant(PyObject * , char const   * , long  ) ;
#line 28 "/usr/include/python2.7/pythonrun.h"
extern void Py_Initialize(void) ;
#line 30
extern void Py_Finalize(void) ;
#line 37
extern int PyRun_SimpleStringFlags(char const   * , PyCompilerFlags * ) ;
#line 38
extern int PyRun_SimpleFileExFlags(FILE * , char const   * , int  , PyCompilerFlags * ) ;
#line 55
extern struct _node *PyParser_SimpleParseFileFlags(FILE * , char const   * , int  ,
                                                   int  ) ;
#line 70
extern void PyErr_Print(void) ;
#line 28 "/usr/include/python2.7/ceval.h"
extern PyObject *PyEval_GetBuiltins(void) ;
#line 15 "/usr/include/python2.7/import.h"
extern PyObject *PyImport_AddModule(char const   *name ) ;
#line 13 "/usr/include/python2.7/compile.h"
extern PyCodeObject *PyNode_Compile(struct _node * , char const   * ) ;
#line 10 "/usr/include/python2.7/eval.h"
extern PyObject *PyEval_EvalCode(PyCodeObject * , PyObject * , PyObject * ) ;
#line 137 "./include/cfpython.h"
CFPContext *context_stack  ;
#line 139 "./include/cfpython.h"
CFPContext *current_context  ;
#line 4 "./include/cfpython_proto.h"
void __attribute__((__visibility__("default")))  cfpython_runPluginCommand(object *op ,
                                                                           char const   *params ) ;
#line 6
int __attribute__((__visibility__("default")))  cfpython_globalEventListener(int *type 
                                                                             , ...) ;
#line 22 "/usr/include/python2.7/node.h"
extern void PyNode_Free(node *n ) ;
#line 91 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PythonCmd CustomCommand[1024]  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static pycode_cache_entry pycode_cache[16]  ;
#line 96
static void set_exception(char const   *fmt  , ...) ;
#line 97
static PyObject *createCFObject(PyObject *self , PyObject *args ) ;
#line 98
static PyObject *createCFObjectByName(PyObject *self , PyObject *args ) ;
#line 99
static PyObject *getCFPythonVersion(PyObject *self , PyObject *args ) ;
#line 100
static PyObject *getReturnValue(PyObject *self , PyObject *args ) ;
#line 101
static PyObject *setReturnValue(PyObject *self , PyObject *args ) ;
#line 102
static PyObject *matchString(PyObject *self , PyObject *args ) ;
#line 103
static PyObject *findPlayer(PyObject *self , PyObject *args ) ;
#line 104
static PyObject *readyMap(PyObject *self , PyObject *args ) ;
#line 105
static PyObject *createMap(PyObject *self , PyObject *args ) ;
#line 106
static PyObject *getMapDirectory(PyObject *self , PyObject *args ) ;
#line 107
static PyObject *getUniqueDirectory(PyObject *self , PyObject *args ) ;
#line 108
static PyObject *getTempDirectory(PyObject *self , PyObject *args ) ;
#line 109
static PyObject *getConfigDirectory(PyObject *self , PyObject *args ) ;
#line 110
static PyObject *getLocalDirectory(PyObject *self , PyObject *args ) ;
#line 111
static PyObject *getPlayerDirectory(PyObject *self , PyObject *args ) ;
#line 112
static PyObject *getDataDirectory(PyObject *self , PyObject *args ) ;
#line 113
static PyObject *getWhoAmI(PyObject *self , PyObject *args ) ;
#line 114
static PyObject *getWhoIsActivator(PyObject *self , PyObject *args ) ;
#line 115
static PyObject *getWhoIsThird(PyObject *self , PyObject *args ) ;
#line 116
static PyObject *getWhatIsMessage(PyObject *self , PyObject *args ) ;
#line 117
static PyObject *getScriptName(PyObject *self , PyObject *args ) ;
#line 118
static PyObject *getScriptParameters(PyObject *self , PyObject *args ) ;
#line 119
static PyObject *getEvent(PyObject *self , PyObject *args ) ;
#line 120
static PyObject *getPrivateDictionary(PyObject *self , PyObject *args ) ;
#line 121
static PyObject *getSharedDictionary(PyObject *self , PyObject *args ) ;
#line 122
static PyObject *getArchetypes(PyObject *self , PyObject *args ) ;
#line 123
static PyObject *getPlayers(PyObject *self , PyObject *args ) ;
#line 124
static PyObject *getMaps(PyObject *self , PyObject *args ) ;
#line 125
static PyObject *getParties(PyObject *self , PyObject *args ) ;
#line 126
static PyObject *getRegions(PyObject *self , PyObject *args ) ;
#line 127
static PyObject *getFriendlyList(PyObject *self , PyObject *args ) ;
#line 128
static PyObject *registerCommand(PyObject *self , PyObject *args ) ;
#line 129
static PyObject *registerGEvent(PyObject *self , PyObject *args ) ;
#line 130
static PyObject *unregisterGEvent(PyObject *self , PyObject *args ) ;
#line 131 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *CFPythonError  ;
#line 132
static PyObject *getTime(PyObject *self , PyObject *args ) ;
#line 133
static PyObject *destroyTimer(PyObject *self , PyObject *args ) ;
#line 134
static PyObject *getMapHasBeenLoaded(PyObject *self , PyObject *args ) ;
#line 135
static PyObject *findAnimation(PyObject *self , PyObject *args ) ;
#line 136
static PyObject *log_message(PyObject *self , PyObject *args ) ;
#line 137
static PyObject *findFace(PyObject *self , PyObject *args ) ;
#line 138
static PyObject *getSeasonName(PyObject *self , PyObject *args ) ;
#line 139
static PyObject *getMonthName(PyObject *self , PyObject *args ) ;
#line 140
static PyObject *getWeekdayName(PyObject *self , PyObject *args ) ;
#line 141
static PyObject *getPeriodofdayName(PyObject *self , PyObject *args ) ;
#line 142
static PyObject *addReply(PyObject *self , PyObject *args ) ;
#line 143
static PyObject *setPlayerMessage(PyObject *self , PyObject *args ) ;
#line 144
static PyObject *npcSay(PyObject *self , PyObject *args ) ;
#line 145
static PyObject *costStringFromValue(PyObject *self , PyObject *args ) ;
#line 148 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static void set_exception(char const   *fmt  , ...) 
{ 
  char buf[1024] ;
  va_list arg ;

  {
  {
#line 152
  __builtin_va_start(arg, fmt);
#line 153
  vsnprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)fmt,
            arg);
#line 154
  __builtin_va_end(arg);
#line 156
  PyErr_SetString(PyExc_ValueError, (char const   *)(buf));
  }
#line 157
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyMethodDef CFPythonMethods[49]  = 
#line 159
  {      {"WhoAmI", & getWhoAmI, 4, (char const   *)((void *)0)}, 
        {"WhoIsActivator", & getWhoIsActivator, 4, (char const   *)((void *)0)}, 
        {"WhoIsOther", & getWhoIsThird, 4, (char const   *)((void *)0)}, 
        {"WhatIsMessage", & getWhatIsMessage, 4, (char const   *)((void *)0)}, 
        {"ScriptName", & getScriptName, 4, (char const   *)((void *)0)}, 
        {"ScriptParameters", & getScriptParameters, 4, (char const   *)((void *)0)}, 
        {"WhatIsEvent", & getEvent, 4, (char const   *)((void *)0)}, 
        {"MapDirectory", & getMapDirectory, 4, (char const   *)((void *)0)}, 
        {"UniqueDirectory", & getUniqueDirectory, 4, (char const   *)((void *)0)}, 
        {"TempDirectory", & getTempDirectory, 4, (char const   *)((void *)0)}, 
        {"ConfigDirectory", & getConfigDirectory, 4, (char const   *)((void *)0)}, 
        {"LocalDirectory", & getLocalDirectory, 4, (char const   *)((void *)0)}, 
        {"PlayerDirectory", & getPlayerDirectory, 4, (char const   *)((void *)0)}, 
        {"DataDirectory", & getDataDirectory, 4, (char const   *)((void *)0)}, 
        {"ReadyMap", & readyMap, 1, (char const   *)((void *)0)}, 
        {"CreateMap", & createMap, 1, (char const   *)((void *)0)}, 
        {"FindPlayer", & findPlayer, 1, (char const   *)((void *)0)}, 
        {"MatchString", & matchString, 1, (char const   *)((void *)0)}, 
        {"GetReturnValue", & getReturnValue, 4, (char const   *)((void *)0)}, 
        {"SetReturnValue", & setReturnValue, 1, (char const   *)((void *)0)}, 
        {"PluginVersion", & getCFPythonVersion, 4, (char const   *)((void *)0)}, 
        {"CreateObject", & createCFObject, 4, (char const   *)((void *)0)}, 
        {"CreateObjectByName", & createCFObjectByName, 1, (char const   *)((void *)0)}, 
        {"GetPrivateDictionary",
      & getPrivateDictionary, 4, (char const   *)((void *)0)}, 
        {"GetSharedDictionary", & getSharedDictionary, 4, (char const   *)((void *)0)}, 
        {"GetPlayers",
      & getPlayers, 4, (char const   *)((void *)0)}, 
        {"GetArchetypes", & getArchetypes, 4, (char const   *)((void *)0)}, 
        {"GetMaps", & getMaps, 4, (char const   *)((void *)0)}, 
        {"GetParties", & getParties, 4, (char const   *)((void *)0)}, 
        {"GetRegions", & getRegions, 4, (char const   *)((void *)0)}, 
        {"GetFriendlyList", & getFriendlyList, 4, (char const   *)((void *)0)}, 
        {"RegisterCommand", & registerCommand, 1, (char const   *)((void *)0)}, 
        {"RegisterGlobalEvent", & registerGEvent, 1, (char const   *)((void *)0)}, 
        {"UnregisterGlobalEvent", & unregisterGEvent, 1, (char const   *)((void *)0)}, 
        {"GetTime",
      & getTime, 4, (char const   *)((void *)0)}, 
        {"DestroyTimer", & destroyTimer, 1, (char const   *)((void *)0)}, 
        {"MapHasBeenLoaded", & getMapHasBeenLoaded, 1, (char const   *)((void *)0)}, 
        {"Log", & log_message, 1, (char const   *)((void *)0)}, 
        {"FindFace", & findFace, 1, (char const   *)((void *)0)}, 
        {"FindAnimation", & findAnimation, 1, (char const   *)((void *)0)}, 
        {"GetSeasonName", & getSeasonName, 1, (char const   *)((void *)0)}, 
        {"GetMonthName", & getMonthName, 1, (char const   *)((void *)0)}, 
        {"GetWeekdayName", & getWeekdayName, 1, (char const   *)((void *)0)}, 
        {"GetPeriodofdayName", & getPeriodofdayName, 1, (char const   *)((void *)0)}, 
        {"AddReply",
      & addReply, 1, (char const   *)((void *)0)}, 
        {"SetPlayerMessage", & setPlayerMessage, 1, (char const   *)((void *)0)}, 
        {"NPCSay", & npcSay, 1, (char const   *)((void *)0)}, 
        {"CostStringFromValue", & costStringFromValue, 1, (char const   *)((void *)0)}, 
        {(char const   *)((void *)0),
      (PyObject *(*)(PyObject * , PyObject * ))((void *)0), 0, (char const   *)((void *)0)}};
#line 215 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static int current_command  =    -999;
#line 217 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *shared_data  =    (PyObject *)((void *)0);
#line 219 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *private_data  =    (PyObject *)((void *)0);
#line 221 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *registerGEvent(PyObject *self , PyObject *args ) 
{ 
  int eventcode ;
  int tmp ;

  {
  {
#line 224
  tmp = PyArg_ParseTuple(args, "i", & eventcode);
  }
#line 224
  if (! tmp) {
#line 225
    return ((PyObject *)((void *)0));
  }
  {
#line 227
  cf_system_register_global_event(eventcode, "Python", (int (*)(int *type  , ...))(& cfpython_globalEventListener));
#line 229
  (_Py_NoneStruct.ob_refcnt) ++;
  }
#line 230
  return (& _Py_NoneStruct);
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *unregisterGEvent(PyObject *self , PyObject *args ) 
{ 
  int eventcode ;
  int tmp ;

  {
  {
#line 236
  tmp = PyArg_ParseTuple(args, "i", & eventcode);
  }
#line 236
  if (! tmp) {
#line 237
    return ((PyObject *)((void *)0));
  }
  {
#line 239
  cf_system_unregister_global_event(26, "Python");
#line 241
  (_Py_NoneStruct.ob_refcnt) ++;
  }
#line 242
  return (& _Py_NoneStruct);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *createCFObject(PyObject *self , PyObject *args ) 
{ 
  object *op ;
  PyObject *tmp ;

  {
  {
#line 248
  op = cf_create_object();
#line 250
  tmp = Crossfire_Object_wrap(op);
  }
#line 250
  return (tmp);
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *createCFObjectByName(PyObject *self , PyObject *args ) 
{ 
  char *obname ;
  object *op ;
  int tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 257
  tmp = PyArg_ParseTuple(args, "s", & obname);
  }
#line 257
  if (! tmp) {
#line 258
    return ((PyObject *)((void *)0));
  }
  {
#line 260
  op = cf_create_object_by_name((char const   *)obname);
#line 262
  tmp___0 = Crossfire_Object_wrap(op);
  }
#line 262
  return (tmp___0);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getCFPythonVersion(PyObject *self , PyObject *args ) 
{ 
  int i ;
  PyObject *tmp ;

  {
  {
#line 266
  i = 2044;
#line 268
  tmp = Py_BuildValue("i", i);
  }
#line 268
  return (tmp);
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getReturnValue(PyObject *self , PyObject *args ) 
{ 
  PyObject *tmp ;

  {
  {
#line 272
  tmp = Py_BuildValue("i", current_context->returnvalue);
  }
#line 272
  return (tmp);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *setReturnValue(PyObject *self , PyObject *args ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 278
  tmp = PyArg_ParseTuple(args, "i", & i);
  }
#line 278
  if (! tmp) {
#line 279
    return ((PyObject *)((void *)0));
  }
#line 280
  current_context->returnvalue = i;
#line 281
  (_Py_NoneStruct.ob_refcnt) ++;
#line 282
  return (& _Py_NoneStruct);
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *matchString(PyObject *self , PyObject *args ) 
{ 
  char *premiere ;
  char *seconde ;
  char const   *result ;
  int tmp ;
  PyObject *tmp___0 ;
  PyObject *tmp___1 ;

  {
  {
#line 290
  tmp = PyArg_ParseTuple(args, "ss", & premiere, & seconde);
  }
#line 290
  if (! tmp) {
#line 291
    return ((PyObject *)((void *)0));
  }
  {
#line 293
  result = cf_re_cmp((char const   *)premiere, (char const   *)seconde);
  }
#line 294
  if ((unsigned long )result != (unsigned long )((void *)0)) {
    {
#line 295
    tmp___0 = Py_BuildValue("i", 1);
    }
#line 295
    return (tmp___0);
  } else {
    {
#line 297
    tmp___1 = Py_BuildValue("i", 0);
    }
#line 297
    return (tmp___1);
  }
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *findPlayer(PyObject *self , PyObject *args ) 
{ 
  player *foundpl ;
  char *txt ;
  int tmp ;
  PyObject *tmp___0 ;
  PyObject *tmp___1 ;

  {
  {
#line 304
  tmp = PyArg_ParseTuple(args, "s", & txt);
  }
#line 304
  if (! tmp) {
#line 305
    return ((PyObject *)((void *)0));
  }
  {
#line 307
  foundpl = cf_player_find((char const   *)txt);
  }
#line 309
  if ((unsigned long )foundpl != (unsigned long )((void *)0)) {
    {
#line 310
    tmp___0 = Crossfire_Object_wrap(foundpl->ob);
#line 310
    tmp___1 = Py_BuildValue("O", tmp___0);
    }
#line 310
    return (tmp___1);
  } else {
#line 312
    (_Py_NoneStruct.ob_refcnt) ++;
#line 313
    return (& _Py_NoneStruct);
  }
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *readyMap(PyObject *self , PyObject *args ) 
{ 
  char *mapname ;
  mapstruct *map ;
  int flags ;
  int tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 320
  flags = 0;
#line 322
  tmp = PyArg_ParseTuple(args, "s|i", & mapname, & flags);
  }
#line 322
  if (! tmp) {
#line 323
    return ((PyObject *)((void *)0));
  }
  {
#line 325
  map = cf_map_get_map((char const   *)mapname, flags);
#line 327
  tmp___0 = Crossfire_Map_wrap(map);
  }
#line 327
  return (tmp___0);
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *createMap(PyObject *self , PyObject *args ) 
{ 
  int sizex ;
  int sizey ;
  mapstruct *map ;
  int tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 334
  tmp = PyArg_ParseTuple(args, "ii", & sizex, & sizey);
  }
#line 334
  if (! tmp) {
#line 335
    return ((PyObject *)((void *)0));
  }
  {
#line 337
  map = cf_get_empty_map(sizex, sizey);
#line 339
  tmp___0 = Crossfire_Map_wrap(map);
  }
#line 339
  return (tmp___0);
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getMapDirectory(PyObject *self , PyObject *args ) 
{ 
  char const   *tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 343
  tmp = cf_get_directory(0);
#line 343
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 343
  return (tmp___0);
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getUniqueDirectory(PyObject *self , PyObject *args ) 
{ 
  char const   *tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 347
  tmp = cf_get_directory(1);
#line 347
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 347
  return (tmp___0);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getTempDirectory(PyObject *self , PyObject *args ) 
{ 
  char const   *tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 351
  tmp = cf_get_directory(2);
#line 351
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 351
  return (tmp___0);
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getConfigDirectory(PyObject *self , PyObject *args ) 
{ 
  char const   *tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 355
  tmp = cf_get_directory(3);
#line 355
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 355
  return (tmp___0);
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getLocalDirectory(PyObject *self , PyObject *args ) 
{ 
  char const   *tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 359
  tmp = cf_get_directory(4);
#line 359
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 359
  return (tmp___0);
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getPlayerDirectory(PyObject *self , PyObject *args ) 
{ 
  char const   *tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 363
  tmp = cf_get_directory(5);
#line 363
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 363
  return (tmp___0);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getDataDirectory(PyObject *self , PyObject *args ) 
{ 
  char const   *tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 367
  tmp = cf_get_directory(6);
#line 367
  tmp___0 = Py_BuildValue("s", tmp);
  }
#line 367
  return (tmp___0);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getWhoAmI(PyObject *self , PyObject *args ) 
{ 


  {
#line 371
  if (! current_context->who) {
#line 372
    (_Py_NoneStruct.ob_refcnt) ++;
#line 373
    return (& _Py_NoneStruct);
  }
#line 375
  ((current_context->who)->ob_refcnt) ++;
#line 376
  return (current_context->who);
}
}
#line 379 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getWhoIsActivator(PyObject *self , PyObject *args ) 
{ 


  {
#line 380
  if (! current_context->activator) {
#line 381
    (_Py_NoneStruct.ob_refcnt) ++;
#line 382
    return (& _Py_NoneStruct);
  }
#line 384
  ((current_context->activator)->ob_refcnt) ++;
#line 385
  return (current_context->activator);
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getWhoIsThird(PyObject *self , PyObject *args ) 
{ 


  {
#line 389
  if (! current_context->third) {
#line 390
    (_Py_NoneStruct.ob_refcnt) ++;
#line 391
    return (& _Py_NoneStruct);
  }
#line 393
  ((current_context->third)->ob_refcnt) ++;
#line 394
  return (current_context->third);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getWhatIsMessage(PyObject *self , PyObject *args ) 
{ 
  PyObject *tmp ;
  PyObject *tmp___0 ;

  {
#line 398
  if ((int )current_context->message[0] == 0) {
    {
#line 399
    tmp = Py_BuildValue("");
    }
#line 399
    return (tmp);
  } else {
    {
#line 401
    tmp___0 = Py_BuildValue("s", current_context->message);
    }
#line 401
    return (tmp___0);
  }
}
}
#line 404 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getScriptName(PyObject *self , PyObject *args ) 
{ 
  PyObject *tmp ;

  {
  {
#line 405
  tmp = Py_BuildValue("s", current_context->script);
  }
#line 405
  return (tmp);
}
}
#line 408 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getScriptParameters(PyObject *self , PyObject *args ) 
{ 
  PyObject *tmp ;

  {
#line 409
  if (! current_context->options[0]) {
#line 410
    (_Py_NoneStruct.ob_refcnt) ++;
#line 411
    return (& _Py_NoneStruct);
  }
  {
#line 413
  tmp = Py_BuildValue("s", current_context->options);
  }
#line 413
  return (tmp);
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getEvent(PyObject *self , PyObject *args ) 
{ 


  {
#line 417
  if (! current_context->event) {
#line 418
    (_Py_NoneStruct.ob_refcnt) ++;
#line 419
    return (& _Py_NoneStruct);
  }
#line 421
  ((current_context->event)->ob_refcnt) ++;
#line 422
  return (current_context->event);
}
}
#line 425 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getPrivateDictionary(PyObject *self , PyObject *args ) 
{ 
  PyObject *data ;

  {
  {
#line 428
  data = PyDict_GetItemString(private_data, (char const   *)(current_context->script));
  }
#line 429
  if (! data) {
    {
#line 430
    data = PyDict_New();
#line 431
    PyDict_SetItemString(private_data, (char const   *)(current_context->script),
                         data);
    }
    {
#line 432
    while (1) {
      while_continue: /* CIL Label */ ;
#line 432
      (data->ob_refcnt) --;
#line 432
      if (! (data->ob_refcnt != 0L)) {
        {
#line 432
        (*((data->ob_type)->tp_dealloc))(data);
        }
      }
#line 432
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 434
  (data->ob_refcnt) ++;
#line 435
  return (data);
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getSharedDictionary(PyObject *self , PyObject *args ) 
{ 


  {
#line 439
  (shared_data->ob_refcnt) ++;
#line 440
  return (shared_data);
}
}
#line 443 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getArchetypes(PyObject *self , PyObject *args ) 
{ 
  PyObject *list ;
  archetype *arch ;
  PyObject *tmp ;

  {
  {
#line 447
  list = PyList_New((Py_ssize_t )0);
#line 448
  arch = cf_archetype_get_first();
  }
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (! arch) {
#line 449
      goto while_break;
    }
    {
#line 450
    tmp = Crossfire_Archetype_wrap(arch);
#line 450
    PyList_Append(list, tmp);
#line 451
    arch = cf_archetype_get_next(arch);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 453
  return (list);
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getPlayers(PyObject *self , PyObject *args ) 
{ 
  PyObject *list ;
  object *pl ;
  PyObject *tmp ;

  {
  {
#line 460
  list = PyList_New((Py_ssize_t )0);
#line 461
  pl = cf_object_get_object_property((object *)((void *)0), 156);
  }
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 462
    if (! pl) {
#line 462
      goto while_break;
    }
    {
#line 463
    tmp = Crossfire_Object_wrap(pl);
#line 463
    PyList_Append(list, tmp);
#line 464
    pl = cf_object_get_object_property(pl, 156);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 466
  return (list);
}
}
#line 469 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getMaps(PyObject *self , PyObject *args ) 
{ 
  PyObject *list ;
  mapstruct *map ;
  PyObject *tmp ;

  {
  {
#line 473
  list = PyList_New((Py_ssize_t )0);
#line 474
  map = cf_map_get_first();
  }
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 475
    if (! map) {
#line 475
      goto while_break;
    }
    {
#line 476
    tmp = Crossfire_Map_wrap(map);
#line 476
    PyList_Append(list, tmp);
#line 477
    map = cf_map_get_map_property(map, 23);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 479
  return (list);
}
}
#line 482 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getParties(PyObject *self , PyObject *args ) 
{ 
  PyObject *list ;
  partylist *party ;
  PyObject *tmp ;

  {
  {
#line 486
  list = PyList_New((Py_ssize_t )0);
#line 487
  party = cf_party_get_first();
  }
  {
#line 488
  while (1) {
    while_continue: /* CIL Label */ ;
#line 488
    if (! party) {
#line 488
      goto while_break;
    }
    {
#line 489
    tmp = Crossfire_Party_wrap(party);
#line 489
    PyList_Append(list, tmp);
#line 490
    party = cf_party_get_next(party);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 492
  return (list);
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getRegions(PyObject *self , PyObject *args ) 
{ 
  PyObject *list ;
  region *reg ;
  PyObject *tmp ;

  {
  {
#line 499
  list = PyList_New((Py_ssize_t )0);
#line 500
  reg = cf_region_get_first();
  }
  {
#line 501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 501
    if (! reg) {
#line 501
      goto while_break;
    }
    {
#line 502
    tmp = Crossfire_Region_wrap(reg);
#line 502
    PyList_Append(list, tmp);
#line 503
    reg = cf_region_get_next(reg);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 505
  return (list);
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getFriendlyList(PyObject *self , PyObject *args ) 
{ 
  PyObject *list ;
  object *ob ;
  PyObject *tmp ;

  {
  {
#line 512
  list = PyList_New((Py_ssize_t )0);
#line 513
  ob = cf_friendlylist_get_first();
  }
  {
#line 514
  while (1) {
    while_continue: /* CIL Label */ ;
#line 514
    if (! ob) {
#line 514
      goto while_break;
    }
    {
#line 515
    tmp = Crossfire_Object_wrap(ob);
#line 515
    PyList_Append(list, tmp);
#line 516
    ob = cf_friendlylist_get_next(ob);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 518
  return (list);
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *registerCommand(PyObject *self , PyObject *args ) 
{ 
  char *cmdname ;
  char *scriptname ;
  double cmdspeed ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 527
  tmp = PyArg_ParseTuple(args, "ssd", & cmdname, & scriptname, & cmdspeed);
  }
#line 527
  if (! tmp) {
#line 528
    return ((PyObject *)((void *)0));
  }
#line 530
  if (cmdspeed < (double )0) {
    {
#line 531
    set_exception("speed must not be negative");
    }
#line 532
    return ((PyObject *)((void *)0));
  }
#line 535
  i = 0;
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! (i < 1024)) {
#line 535
      goto while_break;
    }
#line 536
    if ((unsigned long )CustomCommand[i].name != (unsigned long )((void *)0)) {
      {
#line 537
      tmp___0 = strcmp(CustomCommand[i].name, (char const   *)cmdname);
      }
#line 537
      if (! tmp___0) {
        {
#line 538
        set_exception("command \'%s\' is already registered", cmdname);
        }
#line 539
        return ((PyObject *)((void *)0));
      }
    }
#line 535
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 543
  i = 0;
  {
#line 543
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 543
    if (! (i < 1024)) {
#line 543
      goto while_break___0;
    }
#line 544
    if ((unsigned long )CustomCommand[i].name == (unsigned long )((void *)0)) {
      {
#line 545
      CustomCommand[i].name = cf_add_string((char const   *)cmdname);
#line 546
      CustomCommand[i].script = cf_add_string((char const   *)scriptname);
#line 547
      CustomCommand[i].speed = cmdspeed;
      }
#line 548
      goto while_break___0;
    }
#line 543
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 552
  (_Py_NoneStruct.ob_refcnt) ++;
#line 553
  return (& _Py_NoneStruct);
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getTime(PyObject *self , PyObject *args ) 
{ 
  PyObject *list ;
  timeofday_t tod ;
  PyObject *tmp ;
  PyObject *tmp___0 ;
  PyObject *tmp___1 ;
  PyObject *tmp___2 ;
  PyObject *tmp___3 ;
  PyObject *tmp___4 ;
  PyObject *tmp___5 ;
  PyObject *tmp___6 ;
  PyObject *tmp___7 ;

  {
  {
#line 560
  cf_get_time(& tod);
#line 562
  list = PyList_New((Py_ssize_t )0);
#line 563
  tmp = Py_BuildValue("i", tod.year);
#line 563
  PyList_Append(list, tmp);
#line 564
  tmp___0 = Py_BuildValue("i", tod.month);
#line 564
  PyList_Append(list, tmp___0);
#line 565
  tmp___1 = Py_BuildValue("i", tod.day);
#line 565
  PyList_Append(list, tmp___1);
#line 566
  tmp___2 = Py_BuildValue("i", tod.hour);
#line 566
  PyList_Append(list, tmp___2);
#line 567
  tmp___3 = Py_BuildValue("i", tod.minute);
#line 567
  PyList_Append(list, tmp___3);
#line 568
  tmp___4 = Py_BuildValue("i", tod.dayofweek);
#line 568
  PyList_Append(list, tmp___4);
#line 569
  tmp___5 = Py_BuildValue("i", tod.weekofmonth);
#line 569
  PyList_Append(list, tmp___5);
#line 570
  tmp___6 = Py_BuildValue("i", tod.season);
#line 570
  PyList_Append(list, tmp___6);
#line 571
  tmp___7 = Py_BuildValue("i", tod.periodofday);
#line 571
  PyList_Append(list, tmp___7);
  }
#line 573
  return (list);
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *destroyTimer(PyObject *self , PyObject *args ) 
{ 
  int id ;
  int tmp ;
  int tmp___0 ;
  PyObject *tmp___1 ;

  {
  {
#line 579
  tmp = PyArg_ParseTuple(args, "i", & id);
  }
#line 579
  if (! tmp) {
#line 580
    return ((PyObject *)((void *)0));
  }
  {
#line 581
  tmp___0 = cf_timer_destroy(id);
#line 581
  tmp___1 = Py_BuildValue("i", tmp___0);
  }
#line 581
  return (tmp___1);
}
}
#line 584 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getMapHasBeenLoaded(PyObject *self , PyObject *args ) 
{ 
  char *name ;
  int tmp ;
  mapstruct *tmp___0 ;
  PyObject *tmp___1 ;

  {
  {
#line 587
  tmp = PyArg_ParseTuple(args, "s", & name);
  }
#line 587
  if (! tmp) {
#line 588
    return ((PyObject *)((void *)0));
  }
  {
#line 589
  tmp___0 = cf_map_has_been_loaded((char const   *)name);
#line 589
  tmp___1 = Crossfire_Map_wrap(tmp___0);
  }
#line 589
  return (tmp___1);
}
}
#line 592 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *findFace(PyObject *self , PyObject *args ) 
{ 
  char *name ;
  int tmp ;
  int tmp___0 ;
  PyObject *tmp___1 ;

  {
  {
#line 595
  tmp = PyArg_ParseTuple(args, "s", & name);
  }
#line 595
  if (! tmp) {
#line 596
    return ((PyObject *)((void *)0));
  }
  {
#line 597
  tmp___0 = cf_find_face((char const   *)name, 0);
#line 597
  tmp___1 = Py_BuildValue("i", tmp___0);
  }
#line 597
  return (tmp___1);
}
}
#line 600 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *log_message(PyObject *self , PyObject *args ) 
{ 
  LogLevel level ;
  int intLevel ;
  char *message ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 605
  tmp = PyArg_ParseTuple(args, "is", & intLevel, & message);
  }
#line 605
  if (! tmp) {
#line 606
    return ((PyObject *)((void *)0));
  }
  {
#line 609
  if (intLevel == 0) {
#line 609
    goto case_0;
  }
#line 613
  if (intLevel == 1) {
#line 613
    goto case_1;
  }
#line 617
  if (intLevel == 2) {
#line 617
    goto case_2;
  }
#line 621
  if (intLevel == 3) {
#line 621
    goto case_3;
  }
#line 625
  goto switch_default;
  case_0: /* CIL Label */ 
#line 610
  level = (LogLevel )0;
#line 611
  goto switch_break;
  case_1: /* CIL Label */ 
#line 614
  level = (LogLevel )1;
#line 615
  goto switch_break;
  case_2: /* CIL Label */ 
#line 618
  level = (LogLevel )2;
#line 619
  goto switch_break;
  case_3: /* CIL Label */ 
#line 622
  level = (LogLevel )3;
#line 623
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 626
  return ((PyObject *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 628
  if ((unsigned long )message != (unsigned long )((void *)0)) {
    {
#line 628
    tmp___0 = strlen((char const   *)message);
    }
#line 628
    if ((int )*(message + tmp___0) == 10) {
      {
#line 629
      cf_log(level, "CFPython: %s", message);
      }
    } else {
      {
#line 631
      cf_log(level, "CFPython: %s\n", message);
      }
    }
  } else {
    {
#line 631
    cf_log(level, "CFPython: %s\n", message);
    }
  }
#line 632
  (_Py_NoneStruct.ob_refcnt) ++;
#line 633
  return (& _Py_NoneStruct);
}
}
#line 636 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *findAnimation(PyObject *self , PyObject *args ) 
{ 
  char *name ;
  int tmp ;
  int tmp___0 ;
  PyObject *tmp___1 ;

  {
  {
#line 639
  tmp = PyArg_ParseTuple(args, "s", & name);
  }
#line 639
  if (! tmp) {
#line 640
    return ((PyObject *)((void *)0));
  }
  {
#line 641
  tmp___0 = cf_find_animation((char const   *)name);
#line 641
  tmp___1 = Py_BuildValue("i", tmp___0);
  }
#line 641
  return (tmp___1);
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getSeasonName(PyObject *self , PyObject *args ) 
{ 
  int i ;
  int tmp ;
  char const   *tmp___0 ;
  PyObject *tmp___1 ;

  {
  {
#line 647
  tmp = PyArg_ParseTuple(args, "i", & i);
  }
#line 647
  if (! tmp) {
#line 648
    return ((PyObject *)((void *)0));
  }
  {
#line 649
  tmp___0 = cf_get_season_name(i);
#line 649
  tmp___1 = Py_BuildValue("s", tmp___0);
  }
#line 649
  return (tmp___1);
}
}
#line 652 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getMonthName(PyObject *self , PyObject *args ) 
{ 
  int i ;
  int tmp ;
  char const   *tmp___0 ;
  PyObject *tmp___1 ;

  {
  {
#line 655
  tmp = PyArg_ParseTuple(args, "i", & i);
  }
#line 655
  if (! tmp) {
#line 656
    return ((PyObject *)((void *)0));
  }
  {
#line 657
  tmp___0 = cf_get_month_name(i);
#line 657
  tmp___1 = Py_BuildValue("s", tmp___0);
  }
#line 657
  return (tmp___1);
}
}
#line 660 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getWeekdayName(PyObject *self , PyObject *args ) 
{ 
  int i ;
  int tmp ;
  char const   *tmp___0 ;
  PyObject *tmp___1 ;

  {
  {
#line 663
  tmp = PyArg_ParseTuple(args, "i", & i);
  }
#line 663
  if (! tmp) {
#line 664
    return ((PyObject *)((void *)0));
  }
  {
#line 665
  tmp___0 = cf_get_weekday_name(i);
#line 665
  tmp___1 = Py_BuildValue("s", tmp___0);
  }
#line 665
  return (tmp___1);
}
}
#line 668 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *getPeriodofdayName(PyObject *self , PyObject *args ) 
{ 
  int i ;
  int tmp ;
  char const   *tmp___0 ;
  PyObject *tmp___1 ;

  {
  {
#line 671
  tmp = PyArg_ParseTuple(args, "i", & i);
  }
#line 671
  if (! tmp) {
#line 672
    return ((PyObject *)((void *)0));
  }
  {
#line 673
  tmp___0 = cf_get_periodofday_name(i);
#line 673
  tmp___1 = Py_BuildValue("s", tmp___0);
  }
#line 673
  return (tmp___1);
}
}
#line 676 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *addReply(PyObject *self , PyObject *args ) 
{ 
  char *word ;
  char *reply ;
  talk_info *talk ;
  int tmp ;

  {
#line 680
  if ((unsigned long )current_context->talk == (unsigned long )((void *)0)) {
    {
#line 681
    set_exception("not in a dialog context");
    }
#line 682
    return ((PyObject *)((void *)0));
  }
  {
#line 684
  talk = current_context->talk;
#line 686
  tmp = PyArg_ParseTuple(args, "ss", & word, & reply);
  }
#line 686
  if (! tmp) {
#line 687
    return ((PyObject *)((void *)0));
  }
#line 690
  if (talk->replies_count == 10) {
    {
#line 691
    set_exception("too many replies");
    }
#line 692
    return ((PyObject *)((void *)0));
  }
  {
#line 695
  talk->replies_words[talk->replies_count] = cf_add_string((char const   *)word);
#line 696
  talk->replies[talk->replies_count] = cf_add_string((char const   *)reply);
#line 697
  (talk->replies_count) ++;
#line 698
  (_Py_NoneStruct.ob_refcnt) ++;
  }
#line 699
  return (& _Py_NoneStruct);
}
}
#line 703 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *setPlayerMessage(PyObject *self , PyObject *args ) 
{ 
  char *message ;
  int type ;
  int tmp ;

  {
#line 705
  type = 1;
#line 707
  if ((unsigned long )current_context->talk == (unsigned long )((void *)0)) {
    {
#line 708
    set_exception("not in a dialog context");
    }
#line 709
    return ((PyObject *)((void *)0));
  }
  {
#line 712
  tmp = PyArg_ParseTuple(args, "s|i", & message, & type);
  }
#line 712
  if (! tmp) {
#line 713
    return ((PyObject *)((void *)0));
  }
#line 716
  if ((unsigned long )(current_context->talk)->message != (unsigned long )((void *)0)) {
    {
#line 717
    cf_free_string((current_context->talk)->message);
    }
  }
  {
#line 718
  (current_context->talk)->message = cf_add_string((char const   *)message);
#line 719
  (current_context->talk)->message_type = type;
#line 721
  (_Py_NoneStruct.ob_refcnt) ++;
  }
#line 722
  return (& _Py_NoneStruct);
}
}
#line 725 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *npcSay(PyObject *self , PyObject *args ) 
{ 
  Crossfire_Object *npc ;
  char *message ;
  char buf[2048] ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 726
  npc = (Crossfire_Object *)((void *)0);
#line 729
  tmp = PyArg_ParseTuple(args, "O!s", & Crossfire_ObjectType, & npc, & message);
  }
#line 729
  if (! tmp) {
#line 730
    return ((PyObject *)((void *)0));
  }
#line 732
  if ((unsigned long )current_context->talk == (unsigned long )((void *)0)) {
    {
#line 733
    set_exception("not in a dialog context");
    }
#line 734
    return ((PyObject *)((void *)0));
  }
#line 737
  if ((current_context->talk)->npc_msg_count == 5) {
    {
#line 738
    set_exception("too many NPCs");
    }
#line 739
    return ((PyObject *)((void *)0));
  }
  {
#line 742
  tmp___0 = strlen((char const   *)message);
  }
#line 742
  if (tmp___0 >= sizeof(buf) - 1UL) {
    {
#line 743
    cf_log((LogLevel )0, "warning, too long message in npcSay, will be truncated");
    }
  }
  {
#line 745
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s says: %s",
           (npc->obj)->name, message);
#line 747
  (current_context->talk)->npc_msgs[(current_context->talk)->npc_msg_count] = cf_add_string((char const   *)(buf));
#line 748
  ((current_context->talk)->npc_msg_count) ++;
#line 750
  (_Py_NoneStruct.ob_refcnt) ++;
  }
#line 751
  return (& _Py_NoneStruct);
}
}
#line 754 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *costStringFromValue(PyObject *self , PyObject *args ) 
{ 
  uint64 value ;
  char buf[2048] ;
  int largest_coin ;
  int tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 757
  largest_coin = 0;
#line 759
  tmp = PyArg_ParseTuple(args, "L|i", & value, & largest_coin);
  }
#line 759
  if (! tmp) {
#line 760
    return ((PyObject *)((void *)0));
  }
  {
#line 762
  cf_cost_string_from_value(value, largest_coin, buf, (int )sizeof(buf));
#line 763
  tmp___0 = Py_BuildValue("s", buf);
  }
#line 763
  return (tmp___0);
}
}
#line 766 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static void initContextStack(void) 
{ 


  {
#line 767
  current_context = (CFPContext *)((void *)0);
#line 768
  context_stack = (CFPContext *)((void *)0);
#line 769
  return;
}
}
#line 771 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static void pushContext(CFPContext *context ) 
{ 


  {
#line 772
  if ((unsigned long )current_context == (unsigned long )((void *)0)) {
#line 773
    context_stack = context;
#line 774
    context->down = (struct _cfpcontext *)((void *)0);
  } else {
#line 776
    context->down = current_context;
  }
#line 778
  current_context = context;
#line 779
  return;
}
}
#line 781 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static CFPContext *popContext(void) 
{ 
  CFPContext *oldcontext ;

  {
#line 784
  if ((unsigned long )current_context != (unsigned long )((void *)0)) {
#line 785
    oldcontext = current_context;
#line 786
    current_context = current_context->down;
#line 787
    return (oldcontext);
  } else {
#line 790
    return ((CFPContext *)((void *)0));
  }
}
}
#line 793 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static void freeContext(CFPContext *context ) 
{ 


  {
  {
#line 794
  while (1) {
    while_continue: /* CIL Label */ ;
#line 794
    if (! ((unsigned long )context->event == (unsigned long )((void *)0))) {
      {
#line 794
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 794
        ((context->event)->ob_refcnt) --;
#line 794
        if (! ((context->event)->ob_refcnt != 0L)) {
          {
#line 794
          (*(((context->event)->ob_type)->tp_dealloc))(context->event);
          }
        }
#line 794
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 794
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 795
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 795
    if (! ((unsigned long )context->third == (unsigned long )((void *)0))) {
      {
#line 795
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 795
        ((context->third)->ob_refcnt) --;
#line 795
        if (! ((context->third)->ob_refcnt != 0L)) {
          {
#line 795
          (*(((context->third)->ob_type)->tp_dealloc))(context->third);
          }
        }
#line 795
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 795
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 796
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 796
    if (! ((unsigned long )context->who == (unsigned long )((void *)0))) {
      {
#line 796
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 796
        ((context->who)->ob_refcnt) --;
#line 796
        if (! ((context->who)->ob_refcnt != 0L)) {
          {
#line 796
          (*(((context->who)->ob_type)->tp_dealloc))(context->who);
          }
        }
#line 796
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 796
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 797
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 797
    if (! ((unsigned long )context->activator == (unsigned long )((void *)0))) {
      {
#line 797
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 797
        ((context->activator)->ob_refcnt) --;
#line 797
        if (! ((context->activator)->ob_refcnt != 0L)) {
          {
#line 797
          (*(((context->activator)->ob_type)->tp_dealloc))(context->activator);
          }
        }
#line 797
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 797
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 798
  free((void *)context);
  }
#line 799
  return;
}
}
#line 804 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *cfpython_openpyfile(char *filename ) 
{ 
  PyObject *scriptfile ;

  {
  {
#line 815
  scriptfile = PyFile_FromString(filename, (char *)"r");
  }
#line 815
  if (! scriptfile) {
#line 816
    return ((PyObject *)((void *)0));
  }
#line 819
  return (scriptfile);
}
}
#line 826 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static FILE *cfpython_pyfile_asfile(PyObject *obj ) 
{ 
  FILE *tmp ;

  {
  {
#line 830
  tmp = PyFile_AsFile(obj);
  }
#line 830
  return (tmp);
}
}
#line 838 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyObject *catcher  =    (PyObject *)((void *)0);
#line 846 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static void log_python_error(void) 
{ 
  PyObject *output ;
  PyObject *tmp ;
  PyObject *empty ;
  PyObject *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 848
  PyErr_Print();
  }
#line 850
  if ((unsigned long )catcher != (unsigned long )((void *)0)) {
    {
#line 851
    tmp = PyObject_GetAttrString(catcher, "value");
#line 851
    output = tmp;
#line 852
    tmp___0 = PyString_FromString("");
#line 852
    empty = tmp___0;
#line 854
    tmp___1 = PyString_AsString(output);
#line 854
    cf_log_plain((LogLevel )0, (char const   *)tmp___1);
    }
    {
#line 855
    while (1) {
      while_continue: /* CIL Label */ ;
#line 855
      (output->ob_refcnt) --;
#line 855
      if (! (output->ob_refcnt != 0L)) {
        {
#line 855
        (*((output->ob_type)->tp_dealloc))(output);
        }
      }
#line 855
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 857
    PyObject_SetAttrString(catcher, "value", empty);
    }
    {
#line 858
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 858
      (empty->ob_refcnt) --;
#line 858
      if (! (empty->ob_refcnt != 0L)) {
        {
#line 858
        (*((empty->ob_type)->tp_dealloc))(empty);
        }
      }
#line 858
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 861
  return;
}
}
#line 866 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static PyCodeObject *compilePython(char *filename ) 
{ 
  PyObject *scriptfile ;
  sstring sh_path ;
  struct stat stat_buf ;
  struct _node *n ;
  int i ;
  pycode_cache_entry *replace___0 ;
  pycode_cache_entry *run ;
  int tmp ;
  FILE *pyfile ;
  FILE *tmp___0 ;
  PyObject *tmp___1 ;

  {
  {
#line 867
  scriptfile = (PyObject *)((void *)0);
#line 872
  replace___0 = (pycode_cache_entry *)((void *)0);
#line 872
  run = (pycode_cache_entry *)((void *)0);
#line 874
  tmp = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& stat_buf));
  }
#line 874
  if (tmp) {
    {
#line 875
    cf_log((LogLevel )2, "cfpython - The Script file %s can\'t be stat:ed\n", filename);
    }
#line 876
    return ((PyCodeObject *)((void *)0));
  }
  {
#line 879
  sh_path = cf_add_string((char const   *)filename);
#line 887
  i = 0;
  }
  {
#line 887
  while (1) {
    while_continue: /* CIL Label */ ;
#line 887
    if (! (i < 16)) {
#line 887
      goto while_break;
    }
#line 888
    if ((unsigned long )pycode_cache[i].file == (unsigned long )((void *)0)) {
#line 889
      replace___0 = & pycode_cache[i];
#line 890
      goto while_break;
    } else
#line 891
    if ((unsigned long )pycode_cache[i].file == (unsigned long )sh_path) {
#line 893
      if ((unsigned long )pycode_cache[i].code == (unsigned long )((void *)0)) {
#line 895
        replace___0 = & pycode_cache[i];
      } else
#line 893
      if (pycode_cache[i].cached_time < stat_buf.st_mtim.tv_sec) {
#line 895
        replace___0 = & pycode_cache[i];
      } else {
#line 898
        replace___0 = (pycode_cache_entry *)((void *)0);
#line 899
        run = & pycode_cache[i];
      }
#line 901
      goto while_break;
    } else
#line 902
    if ((unsigned long )replace___0 == (unsigned long )((void *)0)) {
#line 904
      replace___0 = & pycode_cache[i];
    } else
#line 902
    if (pycode_cache[i].used_time < replace___0->used_time) {
#line 904
      replace___0 = & pycode_cache[i];
    }
#line 887
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 908
  if (replace___0) {
    {
#line 909
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 909
      if (! ((unsigned long )replace___0->code == (unsigned long )((void *)0))) {
        {
#line 909
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 909
          (((PyObject *)replace___0->code)->ob_refcnt) --;
#line 909
          if (! (((PyObject *)replace___0->code)->ob_refcnt != 0L)) {
            {
#line 909
            (*((((PyObject *)replace___0->code)->ob_type)->tp_dealloc))((PyObject *)replace___0->code);
            }
          }
#line 909
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 909
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 910
    replace___0->code = (PyCodeObject *)((void *)0);
#line 913
    if ((unsigned long )replace___0->file != (unsigned long )sh_path) {
#line 914
      if (replace___0->file) {
        {
#line 915
        cf_free_string(replace___0->file);
        }
      }
      {
#line 917
      replace___0->file = cf_add_string(sh_path);
      }
    }
    {
#line 924
    scriptfile = cfpython_openpyfile(filename);
    }
#line 924
    if (scriptfile) {
      {
#line 930
      tmp___0 = cfpython_pyfile_asfile(scriptfile);
#line 930
      pyfile = tmp___0;
#line 931
      n = PyParser_SimpleParseFileFlags(pyfile, (char const   *)filename, 257, 0);
      }
#line 931
      if (n) {
        {
#line 932
        replace___0->code = PyNode_Compile(n, (char const   *)filename);
#line 933
        PyNode_Free(n);
        }
      }
      {
#line 936
      tmp___1 = PyErr_Occurred();
      }
#line 936
      if (tmp___1) {
        {
#line 937
        log_python_error();
        }
      } else {
#line 939
        replace___0->cached_time = stat_buf.st_mtim.tv_sec;
      }
#line 940
      run = replace___0;
    } else {
      {
#line 925
      cf_log((LogLevel )2, "cfpython - The Script file %s can\'t be opened\n", filename);
#line 926
      cf_free_string(sh_path);
      }
#line 927
      return ((PyCodeObject *)((void *)0));
    }
  }
  {
#line 944
  cf_free_string(sh_path);
  }
#line 946
  if (scriptfile) {
    {
#line 947
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 947
      (scriptfile->ob_refcnt) --;
#line 947
      if (! (scriptfile->ob_refcnt != 0L)) {
        {
#line 947
        (*((scriptfile->ob_type)->tp_dealloc))(scriptfile);
        }
      }
#line 947
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 950
  if (run) {
    {
#line 951
    run->used_time = time((time_t *)((void *)0));
    }
#line 952
    return (run->code);
  } else {
#line 954
    return ((PyCodeObject *)((void *)0));
  }
}
}
#line 957 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static int do_script(CFPContext *context , int silent ) 
{ 
  PyCodeObject *pycode ;
  PyObject *dict ;
  PyObject *ret ;
  PyObject *tmp ;
  PyObject *tmp___0 ;

  {
  {
#line 966
  pycode = compilePython(context->script);
  }
#line 967
  if (pycode) {
    {
#line 968
    pushContext(context);
#line 969
    dict = PyDict_New();
#line 970
    tmp = PyEval_GetBuiltins();
#line 970
    PyDict_SetItemString(dict, "__builtins__", tmp);
#line 971
    ret = PyEval_EvalCode(pycode, dict, (PyObject *)((void *)0));
#line 972
    tmp___0 = PyErr_Occurred();
    }
#line 972
    if (tmp___0) {
      {
#line 973
      log_python_error();
      }
    }
    {
#line 975
    while (1) {
      while_continue: /* CIL Label */ ;
#line 975
      if (! ((unsigned long )ret == (unsigned long )((void *)0))) {
        {
#line 975
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 975
          (ret->ob_refcnt) --;
#line 975
          if (! (ret->ob_refcnt != 0L)) {
            {
#line 975
            (*((ret->ob_type)->tp_dealloc))(ret);
            }
          }
#line 975
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 975
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 987
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 987
      (dict->ob_refcnt) --;
#line 987
      if (! (dict->ob_refcnt != 0L)) {
        {
#line 987
        (*((dict->ob_type)->tp_dealloc))(dict);
        }
      }
#line 987
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 988
    return (1);
  } else {
#line 990
    return (0);
  }
}
}
#line 998 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static void addConstants(PyObject *module , char const   *name , CFConstant const   *constants ) 
{ 
  int i ;
  char tmp[1024] ;
  PyObject *new ;
  PyObject *dict ;
  size_t tmp___0 ;
  PyObject *tmp___1 ;
  PyObject *tmp___2 ;
  PyObject *tmp___3 ;
  size_t tmp___4 ;
  PyObject *tmp___5 ;

  {
  {
#line 999
  i = 0;
#line 1004
  strncpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)"Crossfire_",
          sizeof(tmp));
#line 1005
  tmp___0 = strlen((char const   *)(tmp));
#line 1005
  strncat((char */* __restrict  */)(tmp), (char const   */* __restrict  */)name, sizeof(tmp) - tmp___0);
#line 1007
  new = PyModule_New((char const   *)(tmp));
#line 1008
  dict = PyDict_New();
  }
  {
#line 1010
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1010
    if (! ((unsigned long )(constants + i)->name != (unsigned long )((void *)0))) {
#line 1010
      goto while_break;
    }
    {
#line 1011
    PyModule_AddIntConstant(new, (char const   *)((char *)(constants + i)->name),
                            (long )(constants + i)->value);
#line 1015
    tmp___1 = PyString_FromString((char const   *)(constants + i)->name);
#line 1015
    tmp___2 = PyLong_FromLong((long )(constants + i)->value);
#line 1015
    PyDict_SetItem(dict, tmp___2, tmp___1);
#line 1017
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1019
  tmp___3 = PyModule_GetDict(module);
#line 1019
  PyDict_SetItemString(tmp___3, name, new);
#line 1021
  strncpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)name, sizeof(tmp));
#line 1022
  tmp___4 = strlen((char const   *)(tmp));
#line 1022
  strncat((char */* __restrict  */)(tmp), (char const   */* __restrict  */)"Name",
          sizeof(tmp) - tmp___4);
#line 1023
  tmp___5 = PyModule_GetDict(module);
#line 1023
  PyDict_SetItemString(tmp___5, (char const   *)(tmp), dict);
  }
  {
#line 1024
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1024
    (dict->ob_refcnt) --;
#line 1024
    if (! (dict->ob_refcnt != 0L)) {
      {
#line 1024
      (*((dict->ob_type)->tp_dealloc))(dict);
      }
    }
#line 1024
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1025
  return;
}
}
#line 1032 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static void addSimpleConstants(PyObject *module , char const   *name , CFConstant const   *constants ) 
{ 
  int i ;
  char tmp[1024] ;
  PyObject *new ;
  size_t tmp___0 ;
  PyObject *tmp___1 ;

  {
  {
#line 1033
  i = 0;
#line 1037
  strncpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)"Crossfire_",
          sizeof(tmp));
#line 1038
  tmp___0 = strlen((char const   *)(tmp));
#line 1038
  strncat((char */* __restrict  */)(tmp), (char const   */* __restrict  */)name, sizeof(tmp) - tmp___0);
#line 1040
  new = PyModule_New((char const   *)(tmp));
  }
  {
#line 1042
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1042
    if (! ((unsigned long )(constants + i)->name != (unsigned long )((void *)0))) {
#line 1042
      goto while_break;
    }
    {
#line 1043
    PyModule_AddIntConstant(new, (char const   *)((char *)(constants + i)->name),
                            (long )(constants + i)->value);
#line 1044
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1046
  tmp___1 = PyModule_GetDict(module);
#line 1046
  PyDict_SetItemString(tmp___1, name, new);
  }
#line 1047
  return;
}
}
#line 1050
static void initConstants(PyObject *module ) ;
#line 1050 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static CFConstant const   cstDirection[9]  = 
#line 1050
  {      {"NORTH", (int const   )1}, 
        {"NORTHEAST", (int const   )2}, 
        {"EAST", (int const   )3}, 
        {"SOUTHEAST", (int const   )4}, 
        {"SOUTH", (int const   )5}, 
        {"SOUTHWEST", (int const   )6}, 
        {"WEST", (int const   )7}, 
        {"NORTHWEST", (int const   )8}, 
        {(char const   *)((void *)0), (int const   )0}};
#line 1062 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static CFConstant const   cstType[110]  = 
#line 1062
  {      {"PLAYER", (int const   )1}, 
        {"TRANSPORT", (int const   )2}, 
        {"ROD", (int const   )3}, 
        {"TREASURE", (int const   )4}, 
        {"POTION", (int const   )5}, 
        {"FOOD", (int const   )6}, 
        {"POISON", (int const   )7}, 
        {"BOOK", (int const   )8}, 
        {"CLOCK", (int const   )9}, 
        {"ARROW", (int const   )13}, 
        {"BOW", (int const   )14}, 
        {"WEAPON", (int const   )15}, 
        {"ARMOUR", (int const   )16}, 
        {"PEDESTAL", (int const   )17}, 
        {"ALTAR", (int const   )18}, 
        {"LOCKED_DOOR", (int const   )20}, 
        {"SPECIAL_KEY", (int const   )21}, 
        {"MAP", (int const   )22}, 
        {"DOOR", (int const   )23}, 
        {"KEY", (int const   )24}, 
        {"TIMED_GATE", (int const   )26}, 
        {"TRIGGER", (int const   )27}, 
        {"GRIMREAPER", (int const   )28}, 
        {"MAGIC_EAR", (int const   )29}, 
        {"TRIGGER_BUTTON", (int const   )30}, 
        {"TRIGGER_ALTAR", (int const   )31}, 
        {"TRIGGER_PEDESTAL", (int const   )32}, 
        {"SHIELD", (int const   )33}, 
        {"HELMET", (int const   )34}, 
        {"MONEY", (int const   )36}, 
        {"CLASS", (int const   )37}, 
        {"AMULET", (int const   )39}, 
        {"PLAYERMOVER", (int const   )40}, 
        {"TELEPORTER", (int const   )41}, 
        {"CREATOR", (int const   )42}, 
        {"SKILL", (int const   )43}, 
        {"EARTHWALL", (int const   )45}, 
        {"GOLEM", (int const   )46}, 
        {"THROWN_OBJ", (int const   )48}, 
        {"BLINDNESS", (int const   )49}, 
        {"GOD", (int const   )50}, 
        {"DETECTOR", (int const   )51}, 
        {"TRIGGER_MARKER", (int const   )52}, 
        {"DEAD_OBJECT", (int const   )53}, 
        {"DRINK", (int const   )54}, 
        {"MARKER", (int const   )55}, 
        {"HOLY_ALTAR", (int const   )56}, 
        {"PLAYER_CHANGER", (int const   )57}, 
        {"BATTLEGROUND", (int const   )58}, 
        {"PEACEMAKER", (int const   )59}, 
        {"GEM", (int const   )60}, 
        {"FIREWALL", (int const   )62}, 
        {"CHECK_INV", (int const   )64}, 
        {"MOOD_FLOOR", (int const   )65}, 
        {"EXIT", (int const   )66}, 
        {"ENCOUNTER", (int const   )67}, 
        {"SHOP_FLOOR", (int const   )68}, 
        {"SHOP_MAT", (int const   )69}, 
        {"RING", (int const   )70}, 
        {"FLOOR", (int const   )71}, 
        {"FLESH", (int const   )72}, 
        {"INORGANIC", (int const   )73}, 
        {"SKILL_TOOL", (int const   )74}, 
        {"LIGHTER", (int const   )75}, 
        {"WALL", (int const   )77}, 
        {"MISC_OBJECT", (int const   )79}, 
        {"MONSTER", (int const   )80}, 
        {"LAMP", (int const   )82}, 
        {"DUPLICATOR", (int const   )83}, 
        {"SPELLBOOK", (int const   )85}, 
        {"CLOAK", (int const   )87}, 
        {"SPINNER", (int const   )90}, 
        {"GATE", (int const   )91}, 
        {"BUTTON", (int const   )92}, 
        {"CF_HANDLE", (int const   )93}, 
        {"HOLE", (int const   )94}, 
        {"TRAPDOOR", (int const   )95}, 
        {"SIGN", (int const   )98}, 
        {"BOOTS", (int const   )99}, 
        {"GLOVES", (int const   )100}, 
        {"SPELL", (int const   )101}, 
        {"SPELL_EFFECT", (int const   )102}, 
        {"CONVERTER", (int const   )103}, 
        {"BRACERS", (int const   )104}, 
        {"POISONING", (int const   )105}, 
        {"SAVEBED", (int const   )106}, 
        {"WAND", (int const   )109}, 
        {"SCROLL", (int const   )111}, 
        {"DIRECTOR", (int const   )112}, 
        {"GIRDLE", (int const   )113}, 
        {"FORCE", (int const   )114}, 
        {"POTION_RESIST_EFFECT", (int const   )115}, 
        {"EVENT_CONNECTOR", (int const   )116}, 
        {"CLOSE_CON", (int const   )121}, 
        {"CONTAINER", (int const   )122}, 
        {"ARMOUR_IMPROVER", (int const   )123}, 
        {"WEAPON_IMPROVER", (int const   )124}, 
        {"SKILLSCROLL", (int const   )130}, 
        {"DEEP_SWAMP", (int const   )138}, 
        {"IDENTIFY_ALTAR", (int const   )139}, 
        {"SHOP_INVENTORY", (int const   )150}, 
        {"RUNE", (int const   )154}, 
        {"TRAP", (int const   )155}, 
        {"POWER_CRYSTAL", (int const   )156}, 
        {"CORPSE", (int const   )157}, 
        {"DISEASE", (int const   )158}, 
        {"SYMPTOM", (int const   )159}, 
        {"BUILDER", (int const   )160}, 
        {"MATERIAL", (int const   )161}, 
        {(char const   *)((void *)0), (int const   )0}};
#line 1175 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static CFConstant const   cstMove[8]  = 
#line 1175
  {      {"WALK", (int const   )1}, 
        {"FLY_LOW", (int const   )2}, 
        {"FLY_HIGH", (int const   )4}, 
        {"FLYING", (int const   )6}, 
        {"SWIM", (int const   )8}, 
        {"BOAT", (int const   )16}, 
        {"ALL", (int const   )31}, 
        {(char const   *)((void *)0), (int const   )0}};
#line 1186 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static CFConstant const   cstMessageFlag[17]  = 
#line 1186
  {      {"NDI_BLACK", (int const   )0}, 
        {"NDI_WHITE", (int const   )1}, 
        {"NDI_NAVY", (int const   )2}, 
        {"NDI_RED", (int const   )3}, 
        {"NDI_ORANGE", (int const   )4}, 
        {"NDI_BLUE", (int const   )5}, 
        {"NDI_DK_ORANGE", (int const   )6}, 
        {"NDI_GREEN", (int const   )7}, 
        {"NDI_LT_GREEN", (int const   )8}, 
        {"NDI_GREY", (int const   )9}, 
        {"NDI_BROWN", (int const   )10}, 
        {"NDI_GOLD", (int const   )11}, 
        {"NDI_TAN", (int const   )12}, 
        {"NDI_UNIQUE", (int const   )256}, 
        {"NDI_ALL", (int const   )512}, 
        {"NDI_ALL_DMS", (int const   )1024}, 
        {(char const   *)((void *)0), (int const   )0}};
#line 1206 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static CFConstant const   cstCostFlag[7]  = {      {"TRUE", (int const   )2}, 
        {"BUY", (int const   )0}, 
        {"SELL", (int const   )1}, 
        {"NOBARGAIN", (int const   )4}, 
        {"IDENTIFIED", (int const   )8}, 
        {"NOTCURSED", (int const   )16}, 
        {(char const   *)((void *)0), (int const   )0}};
#line 1216 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static CFConstant const   cstAttackType[27]  = 
#line 1216
  {      {"PHYSICAL", (int const   )1}, 
        {"MAGIC", (int const   )2}, 
        {"FIRE", (int const   )4}, 
        {"ELECTRICITY", (int const   )8}, 
        {"COLD", (int const   )16}, 
        {"CONFUSION", (int const   )32}, 
        {"ACID", (int const   )64}, 
        {"DRAIN", (int const   )128}, 
        {"WEAPONMAGIC", (int const   )256}, 
        {"GHOSTHIT", (int const   )512}, 
        {"POISON", (int const   )1024}, 
        {"SLOW", (int const   )2048}, 
        {"PARALYZE", (int const   )4096}, 
        {"TURN_UNDEAD", (int const   )8192}, 
        {"FEAR", (int const   )16384}, 
        {"CANCELLATION", (int const   )32768}, 
        {"DEPLETE", (int const   )65536}, 
        {"DEATH", (int const   )131072}, 
        {"CHAOS", (int const   )262144}, 
        {"COUNTERSPELL", (int const   )524288}, 
        {"GODPOWER", (int const   )1048576}, 
        {"HOLYWORD", (int const   )2097152}, 
        {"BLIND", (int const   )4194304}, 
        {"INTERNAL", (int const   )8388608}, 
        {"LIFE_STEALING", (int const   )16777216}, 
        {"DISEASE", (int const   )33554432}, 
        {(char const   *)((void *)0), (int const   )0}};
#line 1246 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static CFConstant const   cstAttackTypeNumber[27]  = 
#line 1246
  {      {"PHYSICAL", (int const   )0}, 
        {"MAGIC", (int const   )1}, 
        {"FIRE", (int const   )2}, 
        {"ELECTRICITY", (int const   )3}, 
        {"COLD", (int const   )4}, 
        {"CONFUSION", (int const   )5}, 
        {"ACID", (int const   )6}, 
        {"DRAIN", (int const   )7}, 
        {"WEAPONMAGIC", (int const   )8}, 
        {"GHOSTHIT", (int const   )9}, 
        {"POISON", (int const   )10}, 
        {"SLOW", (int const   )11}, 
        {"PARALYZE", (int const   )12}, 
        {"TURN_UNDEAD", (int const   )13}, 
        {"FEAR", (int const   )14}, 
        {"CANCELLATION", (int const   )15}, 
        {"DEPLETE", (int const   )16}, 
        {"DEATH", (int const   )17}, 
        {"CHAOS", (int const   )18}, 
        {"COUNTERSPELL", (int const   )19}, 
        {"GODPOWER", (int const   )20}, 
        {"HOLYWORD", (int const   )21}, 
        {"BLIND", (int const   )22}, 
        {"INTERNAL", (int const   )23}, 
        {"LIFE_STEALING", (int const   )24}, 
        {"DISEASE", (int const   )25}, 
        {(char const   *)((void *)0), (int const   )0}};
#line 1276 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static CFConstant const   cstEventType[32]  = 
#line 1276
  {      {"APPLY", (int const   )1}, 
        {"ATTACK", (int const   )2}, 
        {"DEATH", (int const   )3}, 
        {"DROP", (int const   )4}, 
        {"PICKUP", (int const   )5}, 
        {"SAY", (int const   )6}, 
        {"STOP", (int const   )7}, 
        {"TIME", (int const   )8}, 
        {"THROW", (int const   )9}, 
        {"TRIGGER", (int const   )10}, 
        {"CLOSE", (int const   )11}, 
        {"TIMER", (int const   )12}, 
        {"DESTROY", (int const   )13}, 
        {"BORN", (int const   )14}, 
        {"CLOCK", (int const   )15}, 
        {"CRASH", (int const   )16}, 
        {"PLAYER_DEATH", (int const   )17}, 
        {"GKILL", (int const   )18}, 
        {"LOGIN", (int const   )19}, 
        {"LOGOUT", (int const   )20}, 
        {"MAPENTER", (int const   )21}, 
        {"MAPLEAVE", (int const   )22}, 
        {"MAPRESET", (int const   )23}, 
        {"REMOVE", (int const   )24}, 
        {"SHOUT", (int const   )25}, 
        {"TELL", (int const   )26}, 
        {"MUZZLE", (int const   )27}, 
        {"KICK", (int const   )28}, 
        {"MAPUNLOAD", (int const   )29}, 
        {"MAPLOAD", (int const   )30}, 
        {"USER", (int const   )31}, 
        {(char const   *)((void *)0), (int const   )0}};
#line 1311 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static CFConstant const   cstTime[7]  = {      {"HOURS_PER_DAY", (int const   )28}, 
        {"DAYS_PER_WEEK", (int const   )7}, 
        {"WEEKS_PER_MONTH", (int const   )5}, 
        {"MONTHS_PER_YEAR", (int const   )17}, 
        {"SEASONS_PER_YEAR", (int const   )5}, 
        {"PERIODS_PER_DAY", (int const   )6}, 
        {(char const   *)((void *)0), (int const   )0}};
#line 1321 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static CFConstant const   cstReplyTypes[4]  = {      {"SAY", (int const   )0}, 
        {"REPLY", (int const   )1}, 
        {"QUESTION", (int const   )2}, 
        {(char const   *)((void *)0), (int const   )0}};
#line 1049 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static void initConstants(PyObject *module ) 
{ 


  {
  {
#line 1328
  addConstants(module, "Direction", cstDirection);
#line 1329
  addConstants(module, "Type", cstType);
#line 1330
  addConstants(module, "Move", cstMove);
#line 1331
  addConstants(module, "MessageFlag", cstMessageFlag);
#line 1332
  addConstants(module, "CostFlag", cstCostFlag);
#line 1333
  addConstants(module, "AttackType", cstAttackType);
#line 1334
  addConstants(module, "AttackTypeNumber", cstAttackTypeNumber);
#line 1335
  addConstants(module, "EventType", cstEventType);
#line 1336
  addSimpleConstants(module, "Time", cstTime);
#line 1337
  addSimpleConstants(module, "ReplyType", cstReplyTypes);
  }
#line 1338
  return;
}
}
#line 1348 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
static void cfpython_init_types(PyObject *m ) 
{ 
  PyObject *d ;
  PyObject *tmp ;
  PyObject *tmp___0 ;
  PyObject *tmp___1 ;
  PyObject *tmp___2 ;
  PyObject *tmp___3 ;

  {
  {
#line 1349
  tmp = PyModule_GetDict(m);
#line 1349
  d = tmp;
#line 1351
  Crossfire_ObjectType.tp_new = & PyType_GenericNew;
#line 1352
  Crossfire_MapType.tp_new = & PyType_GenericNew;
#line 1353
  Crossfire_PlayerType.tp_new = & PyType_GenericNew;
#line 1354
  Crossfire_ArchetypeType.tp_new = & PyType_GenericNew;
#line 1355
  Crossfire_PartyType.tp_new = & PyType_GenericNew;
#line 1356
  Crossfire_RegionType.tp_new = & PyType_GenericNew;
#line 1357
  PyType_Ready(& Crossfire_ObjectType);
#line 1358
  PyType_Ready(& Crossfire_MapType);
#line 1359
  PyType_Ready(& Crossfire_PlayerType);
#line 1360
  PyType_Ready(& Crossfire_ArchetypeType);
#line 1361
  PyType_Ready(& Crossfire_PartyType);
#line 1362
  PyType_Ready(& Crossfire_RegionType);
#line 1364
  (((PyObject *)(& Crossfire_ObjectType))->ob_refcnt) ++;
#line 1365
  (((PyObject *)(& Crossfire_MapType))->ob_refcnt) ++;
#line 1366
  (((PyObject *)(& Crossfire_PlayerType))->ob_refcnt) ++;
#line 1367
  (((PyObject *)(& Crossfire_ArchetypeType))->ob_refcnt) ++;
#line 1368
  (((PyObject *)(& Crossfire_PartyType))->ob_refcnt) ++;
#line 1369
  (((PyObject *)(& Crossfire_RegionType))->ob_refcnt) ++;
#line 1371
  PyModule_AddObject(m, "Object", (PyObject *)(& Crossfire_ObjectType));
#line 1372
  PyModule_AddObject(m, "Map", (PyObject *)(& Crossfire_MapType));
#line 1373
  PyModule_AddObject(m, "Player", (PyObject *)(& Crossfire_PlayerType));
#line 1374
  PyModule_AddObject(m, "Archetype", (PyObject *)(& Crossfire_ArchetypeType));
#line 1375
  PyModule_AddObject(m, "Party", (PyObject *)(& Crossfire_PartyType));
#line 1376
  PyModule_AddObject(m, "Region", (PyObject *)(& Crossfire_RegionType));
#line 1378
  tmp___0 = Py_BuildValue("i", 0);
#line 1378
  PyModule_AddObject(m, "LogError", tmp___0);
#line 1379
  tmp___1 = Py_BuildValue("i", 1);
#line 1379
  PyModule_AddObject(m, "LogInfo", tmp___1);
#line 1380
  tmp___2 = Py_BuildValue("i", 2);
#line 1380
  PyModule_AddObject(m, "LogDebug", tmp___2);
#line 1381
  tmp___3 = Py_BuildValue("i", 3);
#line 1381
  PyModule_AddObject(m, "LogMonster", tmp___3);
#line 1383
  CFPythonError = PyErr_NewException((char *)"Crossfire.error", (PyObject *)((void *)0),
                                     (PyObject *)((void *)0));
#line 1384
  PyDict_SetItemString(d, "error", CFPythonError);
  }
#line 1385
  return;
}
}
#line 1522 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
void __attribute__((__visibility__("default")))  cfpython_runPluginCommand(object *op ,
                                                                           char const   *params ) 
{ 
  char buf[1024] ;
  char path[1024] ;
  CFPContext *context ;
  char *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1526
  if (current_command < 0) {
    {
#line 1527
    cf_log((LogLevel )0, "Illegal call of cfpython_runPluginCommand, call find_plugin_command first.\n");
    }
#line 1528
    return;
  }
  {
#line 1530
  tmp = cf_get_maps_directory(CustomCommand[current_command].script, path, (int )sizeof(path));
#line 1530
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s.py",
           tmp);
#line 1532
  tmp___0 = malloc(sizeof(CFPContext ));
#line 1532
  context = (CFPContext *)tmp___0;
#line 1533
  context->message[0] = (char)0;
#line 1535
  context->who = Crossfire_Object_wrap(op);
#line 1536
  context->activator = (PyObject *)((void *)0);
#line 1537
  context->third = (PyObject *)((void *)0);
#line 1538
  context->fix = 0;
#line 1539
  snprintf((char */* __restrict  */)(context->script), sizeof(context->script), (char const   */* __restrict  */)"%s",
           buf);
  }
#line 1540
  if (params) {
    {
#line 1541
    snprintf((char */* __restrict  */)(context->options), sizeof(context->options),
             (char const   */* __restrict  */)"%s", params);
    }
  } else {
#line 1543
    context->options[0] = (char)0;
  }
  {
#line 1544
  context->returnvalue = 1;
#line 1546
  current_command = -999;
#line 1547
  tmp___1 = do_script(context, 0);
  }
#line 1547
  if (! tmp___1) {
    {
#line 1548
    freeContext(context);
    }
#line 1549
    return;
  }
  {
#line 1552
  context = popContext();
#line 1553
  freeContext(context);
  }
#line 1555
  return;
}
}
#line 1599 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/plugins/cfpython/cfpython.c"
int __attribute__((__visibility__("default")))  cfpython_globalEventListener(int *type 
                                                                             , ...) 
{ 
  va_list args ;
  int rv ;
  CFPContext *context ;
  char *buf ;
  player *pl ;
  object *op ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  object *tmp___2 ;
  object *tmp___3 ;
  object *tmp___4 ;
  object *tmp___5 ;
  player *tmp___6 ;
  char *tmp___7 ;
  player *tmp___8 ;
  char *tmp___9 ;
  object *tmp___10 ;
  object *tmp___11 ;
  char *tmp___12 ;
  object *tmp___13 ;
  char *tmp___14 ;
  object *tmp___15 ;
  char *tmp___16 ;
  object *tmp___17 ;
  mapstruct *tmp___19 ;
  object *tmp___20 ;
  mapstruct *tmp___22 ;
  mapstruct *tmp___24 ;
  object *tmp___25 ;
  char *tmp___26 ;
  object *tmp___27 ;
  mapstruct *tmp___29 ;
  mapstruct *tmp___31 ;
  int tmp___32 ;

  {
  {
#line 1601
  rv = 0;
#line 1606
  tmp = malloc(sizeof(CFPContext ));
#line 1606
  context = (CFPContext *)tmp;
#line 1608
  __builtin_va_start(args, type);
#line 1609
  tmp___0 = __builtin_va_arg(args, int );
#line 1609
  context->event_code = tmp___0;
#line 1611
  context->message[0] = (char)0;
#line 1613
  context->who = (PyObject *)((void *)0);
#line 1614
  context->activator = (PyObject *)((void *)0);
#line 1615
  context->third = (PyObject *)((void *)0);
#line 1616
  context->event = (PyObject *)((void *)0);
#line 1617
  context->talk = (struct talk_info *)((void *)0);
#line 1618
  tmp___1 = 0;
#line 1618
  context->returnvalue = tmp___1;
#line 1618
  rv = tmp___1;
#line 1619
  cf_get_maps_directory("python/events/python_event.py", context->script, (int )sizeof(context->script));
#line 1620
  strcpy((char */* __restrict  */)(context->options), (char const   */* __restrict  */)"");
  }
  {
#line 1622
  if (context->event_code == 16) {
#line 1622
    goto case_16;
  }
#line 1626
  if (context->event_code == 14) {
#line 1626
    goto case_14;
  }
#line 1632
  if (context->event_code == 17) {
#line 1632
    goto case_17;
  }
#line 1640
  if (context->event_code == 18) {
#line 1640
    goto case_18;
  }
#line 1647
  if (context->event_code == 19) {
#line 1647
    goto case_19;
  }
#line 1656
  if (context->event_code == 20) {
#line 1656
    goto case_20;
  }
#line 1665
  if (context->event_code == 24) {
#line 1665
    goto case_24;
  }
#line 1671
  if (context->event_code == 25) {
#line 1671
    goto case_25;
  }
#line 1680
  if (context->event_code == 27) {
#line 1680
    goto case_27;
  }
#line 1689
  if (context->event_code == 28) {
#line 1689
    goto case_28;
  }
#line 1698
  if (context->event_code == 21) {
#line 1698
    goto case_21;
  }
#line 1705
  if (context->event_code == 22) {
#line 1705
    goto case_22;
  }
#line 1712
  if (context->event_code == 15) {
#line 1712
    goto case_15;
  }
#line 1716
  if (context->event_code == 23) {
#line 1716
    goto case_23;
  }
#line 1721
  if (context->event_code == 26) {
#line 1721
    goto case_26;
  }
#line 1732
  if (context->event_code == 29) {
#line 1732
    goto case_29;
  }
#line 1737
  if (context->event_code == 30) {
#line 1737
    goto case_30;
  }
#line 1621
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 1623
  cf_log((LogLevel )2, "Unimplemented for now\n");
  }
#line 1624
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 1627
  tmp___2 = __builtin_va_arg(args, object *);
#line 1627
  op = tmp___2;
#line 1628
  context->activator = Crossfire_Object_wrap(op);
#line 1629
  snprintf((char */* __restrict  */)(context->options), sizeof(context->options),
           (char const   */* __restrict  */)"born");
  }
#line 1630
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 1633
  tmp___3 = __builtin_va_arg(args, object *);
#line 1633
  op = tmp___3;
#line 1634
  context->who = Crossfire_Object_wrap(op);
#line 1635
  tmp___4 = __builtin_va_arg(args, object *);
#line 1635
  op = tmp___4;
#line 1636
  context->activator = Crossfire_Object_wrap(op);
#line 1637
  snprintf((char */* __restrict  */)(context->options), sizeof(context->options),
           (char const   */* __restrict  */)"death");
  }
#line 1638
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 1641
  tmp___5 = __builtin_va_arg(args, object *);
#line 1641
  op = tmp___5;
#line 1642
  context->who = Crossfire_Object_wrap(op);
#line 1643
  context->activator = Crossfire_Object_wrap(op);
#line 1644
  snprintf((char */* __restrict  */)(context->options), sizeof(context->options),
           (char const   */* __restrict  */)"gkill");
  }
#line 1645
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 1648
  tmp___6 = __builtin_va_arg(args, player *);
#line 1648
  pl = tmp___6;
#line 1649
  context->activator = Crossfire_Object_wrap(pl->ob);
#line 1650
  tmp___7 = __builtin_va_arg(args, char *);
#line 1650
  buf = tmp___7;
  }
#line 1651
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
    {
#line 1652
    snprintf((char */* __restrict  */)(context->message), sizeof(context->message),
             (char const   */* __restrict  */)"%s", buf);
    }
  }
  {
#line 1653
  snprintf((char */* __restrict  */)(context->options), sizeof(context->options),
           (char const   */* __restrict  */)"login");
  }
#line 1654
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 1657
  tmp___8 = __builtin_va_arg(args, player *);
#line 1657
  pl = tmp___8;
#line 1658
  context->activator = Crossfire_Object_wrap(pl->ob);
#line 1659
  tmp___9 = __builtin_va_arg(args, char *);
#line 1659
  buf = tmp___9;
  }
#line 1660
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
    {
#line 1661
    snprintf((char */* __restrict  */)(context->message), sizeof(context->message),
             (char const   */* __restrict  */)"%s", buf);
    }
  }
  {
#line 1662
  snprintf((char */* __restrict  */)(context->options), sizeof(context->options),
           (char const   */* __restrict  */)"logout");
  }
#line 1663
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 1666
  tmp___10 = __builtin_va_arg(args, object *);
#line 1666
  op = tmp___10;
#line 1667
  context->activator = Crossfire_Object_wrap(op);
#line 1668
  snprintf((char */* __restrict  */)(context->options), sizeof(context->options),
           (char const   */* __restrict  */)"remove");
  }
#line 1669
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 1672
  tmp___11 = __builtin_va_arg(args, object *);
#line 1672
  op = tmp___11;
#line 1673
  context->activator = Crossfire_Object_wrap(op);
#line 1674
  tmp___12 = __builtin_va_arg(args, char *);
#line 1674
  buf = tmp___12;
  }
#line 1675
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
    {
#line 1676
    snprintf((char */* __restrict  */)(context->message), sizeof(context->message),
             (char const   */* __restrict  */)"%s", buf);
    }
  }
  {
#line 1677
  snprintf((char */* __restrict  */)(context->options), sizeof(context->options),
           (char const   */* __restrict  */)"shout");
  }
#line 1678
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 1681
  tmp___13 = __builtin_va_arg(args, object *);
#line 1681
  op = tmp___13;
#line 1682
  context->activator = Crossfire_Object_wrap(op);
#line 1683
  tmp___14 = __builtin_va_arg(args, char *);
#line 1683
  buf = tmp___14;
  }
#line 1684
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
    {
#line 1685
    snprintf((char */* __restrict  */)(context->message), sizeof(context->message),
             (char const   */* __restrict  */)"%s", buf);
    }
  }
  {
#line 1686
  snprintf((char */* __restrict  */)(context->options), sizeof(context->options),
           (char const   */* __restrict  */)"muzzle");
  }
#line 1687
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 1690
  tmp___15 = __builtin_va_arg(args, object *);
#line 1690
  op = tmp___15;
#line 1691
  context->activator = Crossfire_Object_wrap(op);
#line 1692
  tmp___16 = __builtin_va_arg(args, char *);
#line 1692
  buf = tmp___16;
  }
#line 1693
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
    {
#line 1694
    snprintf((char */* __restrict  */)(context->message), sizeof(context->message),
             (char const   */* __restrict  */)"%s", buf);
    }
  }
  {
#line 1695
  snprintf((char */* __restrict  */)(context->options), sizeof(context->options),
           (char const   */* __restrict  */)"kick");
  }
#line 1696
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 1699
  tmp___17 = __builtin_va_arg(args, object *);
#line 1699
  op = tmp___17;
#line 1700
  context->activator = Crossfire_Object_wrap(op);
#line 1701
  tmp___19 = __builtin_va_arg(args, mapstruct *);
#line 1701
  context->who = Crossfire_Map_wrap(tmp___19);
#line 1702
  snprintf((char */* __restrict  */)(context->options), sizeof(context->options),
           (char const   */* __restrict  */)"mapenter");
  }
#line 1703
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 1706
  tmp___20 = __builtin_va_arg(args, object *);
#line 1706
  op = tmp___20;
#line 1707
  context->activator = Crossfire_Object_wrap(op);
#line 1708
  tmp___22 = __builtin_va_arg(args, mapstruct *);
#line 1708
  context->who = Crossfire_Map_wrap(tmp___22);
#line 1709
  snprintf((char */* __restrict  */)(context->options), sizeof(context->options),
           (char const   */* __restrict  */)"mapleave");
  }
#line 1710
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 1713
  snprintf((char */* __restrict  */)(context->options), sizeof(context->options),
           (char const   */* __restrict  */)"clock");
  }
#line 1714
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 1717
  tmp___24 = __builtin_va_arg(args, mapstruct *);
#line 1717
  context->who = Crossfire_Map_wrap(tmp___24);
#line 1718
  snprintf((char */* __restrict  */)(context->options), sizeof(context->options),
           (char const   */* __restrict  */)"mapreset");
  }
#line 1719
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 1722
  tmp___25 = __builtin_va_arg(args, object *);
#line 1722
  op = tmp___25;
#line 1723
  tmp___26 = __builtin_va_arg(args, char *);
#line 1723
  buf = tmp___26;
#line 1724
  context->activator = Crossfire_Object_wrap(op);
  }
#line 1725
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
    {
#line 1726
    snprintf((char */* __restrict  */)(context->message), sizeof(context->message),
             (char const   */* __restrict  */)"%s", buf);
    }
  }
  {
#line 1727
  tmp___27 = __builtin_va_arg(args, object *);
#line 1727
  op = tmp___27;
#line 1728
  context->third = Crossfire_Object_wrap(op);
#line 1729
  snprintf((char */* __restrict  */)(context->options), sizeof(context->options),
           (char const   */* __restrict  */)"tell");
  }
#line 1730
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 1733
  tmp___29 = __builtin_va_arg(args, mapstruct *);
#line 1733
  context->who = Crossfire_Map_wrap(tmp___29);
#line 1734
  snprintf((char */* __restrict  */)(context->options), sizeof(context->options),
           (char const   */* __restrict  */)"mapunload");
  }
#line 1735
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 1738
  tmp___31 = __builtin_va_arg(args, mapstruct *);
#line 1738
  context->who = Crossfire_Map_wrap(tmp___31);
#line 1739
  snprintf((char */* __restrict  */)(context->options), sizeof(context->options),
           (char const   */* __restrict  */)"mapload");
  }
#line 1740
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1742
  __builtin_va_end(args);
#line 1743
  context->returnvalue = 0;
#line 1745
  tmp___32 = do_script(context, 1);
  }
#line 1745
  if (! tmp___32) {
    {
#line 1746
    freeContext(context);
    }
#line 1747
    return ((int __attribute__((__visibility__("default")))  )rv);
  }
  {
#line 1750
  context = popContext();
#line 1751
  rv = context->returnvalue;
  }
#line 1754
  if (context->event_code == 29) {
    {
#line 1755
    Handle_Map_Unload_Hook((Crossfire_Map *)context->who);
    }
  }
  {
#line 1757
  freeContext(context);
  }
#line 1759
  return ((int __attribute__((__visibility__("default")))  )rv);
}
}
#line 327 "../include/sproto.h"
void emergency_save(int x ) ;
#line 634
void clean_tmp_files(void) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/glue.c"
static char const   * const  fatalmsgs[5]  = {      (char const   */* const  */)"Failed to allocate memory",      (char const   */* const  */)"Failed repeatedly to load maps",      (char const   */* const  */)"Hashtable for archetypes is too small",      (char const   */* const  */)"Fatal issue in archetype file", 
        (char const   */* const  */)"See last error"};
#line 62 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/glue.c"
void fatal(int err ) 
{ 
  char const   *tmp ;

  {
#line 63
  if ((unsigned long )((unsigned int )err) < sizeof(fatalmsgs) / sizeof(fatalmsgs[0])) {
#line 63
    tmp = fatalmsgs[(unsigned int )err];
  } else {
#line 63
    tmp = (char const   */* const  */)"invalid error code";
  }
  {
#line 63
  fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"Fatal: %s\n",
          tmp);
#line 64
  emergency_save(0);
#line 65
  clean_tmp_files();
#line 66
  fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"Exiting...\n");
#line 67
  exit(err);
  }
}
}
#line 56 "../include/living.h"
char const   * const  restore_msg[7] ;
#line 57
char const   * const  statname[7] ;
#line 58
char const   * const  short_stat_name[7] ;
#line 59
char const   * const  lose_msg[7] ;
#line 80
int get_cha_bonus(int stat___0 ) ;
#line 81
int get_dex_bonus(int stat___0 ) ;
#line 82
int get_thaco_bonus(int stat___0 ) ;
#line 84
int get_learn_spell(int stat___0 ) ;
#line 85
int get_cleric_chance(int stat___0 ) ;
#line 87
int get_dam_bonus(int stat___0 ) ;
#line 88
float get_speed_bonus(int stat___0 ) ;
#line 89
int get_fear_bonus(int stat___0 ) ;
#line 11 "../include/libproto.h"
archetype *get_archetype_by_skill_name(char const   *skill , int type ) ;
#line 136
void check_stat_bounds(living *stats , sint8 min_stat , sint8 max_stat ) ;
#line 139
void drain_specific_stat(object *op , int deplete_stats ) ;
#line 140
int remove_depletion(object *op , int level ) ;
#line 142
void remove_statbonus(object *op ) ;
#line 143
void add_statbonus(object *op ) ;
#line 145
int allowed_class(object const   *op ) ;
#line 146
void set_dragon_name(object *pl , object const   *abil , object const   *skin ) ;
#line 147
object *give_skill_by_name(object *op , char const   *skill_name ) ;
#line 154
void apply_death_exp_penalty(object *op ) ;
#line 167
void init_stats(int reload ) ;
#line 268
extern int object_check_move_on(object *op , object *originator ) ;
#line 333
extern void player_set_dragon_title(struct pl *pl , int level , char const   *attack ,
                                    int skin_resist ) ;
#line 101 "../include/sockproto.h"
void esrv_update_spells(player *pl ) ;
#line 438 "../include/sproto.h"
void dragon_ability_gain(object *ob , int x , int y ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
static float get_con_bonus(int stat___0 ) ;
#line 45
static float get_sp_bonus(int stat___0 ) ;
#line 46
static float get_grace_bonus(int stat___0 ) ;
#line 47
static size_t get_index(int stat___0 , size_t max_index ) ;
#line 81 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
static int *int_bonuses[9]  ;
#line 87 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
static char const   *int_bonus_names[9]  = 
#line 87
  {      "cha_fear_bonus",      "wis_turn_bonus",      "wis_cleric_chance",      "int_wis_learn_spell", 
        "cha_shop_bonus",      "dex_bonus",      "str_damage_bonus",      "str_hit_bonus", 
        "str_weight_limit"};
#line 102 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
static float *float_bonuses[4]  ;
#line 103 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
static char const   *float_bonus_names[4]  = {      "con_hp_bonus",      "dex_speed_bonus",      "pow_int_sp_bonus",      "wis_pow_grace_bonus"};
#line 113
sint64 *levels ;
#line 125 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
static int const   savethrow[111]  = 
#line 125
  {      (int const   )18,      (int const   )18,      (int const   )17,      (int const   )16, 
        (int const   )15,      (int const   )14,      (int const   )14,      (int const   )13, 
        (int const   )13,      (int const   )12,      (int const   )12,      (int const   )12, 
        (int const   )11,      (int const   )11,      (int const   )11,      (int const   )11, 
        (int const   )10,      (int const   )10,      (int const   )10,      (int const   )10, 
        (int const   )9,      (int const   )9,      (int const   )9,      (int const   )9, 
        (int const   )9,      (int const   )8,      (int const   )8,      (int const   )8, 
        (int const   )8,      (int const   )8,      (int const   )8,      (int const   )7, 
        (int const   )7,      (int const   )7,      (int const   )7,      (int const   )7, 
        (int const   )7,      (int const   )7,      (int const   )6,      (int const   )6, 
        (int const   )6,      (int const   )6,      (int const   )6,      (int const   )6, 
        (int const   )6,      (int const   )6,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )4,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1};
#line 141 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
char const   * const  attacks[26]  = 
#line 141
  {      (char const   */* const  */)"physical",      (char const   */* const  */)"magical",      (char const   */* const  */)"fire",      (char const   */* const  */)"electricity", 
        (char const   */* const  */)"cold",      (char const   */* const  */)"confusion",      (char const   */* const  */)"acid",      (char const   */* const  */)"drain", 
        (char const   */* const  */)"weaponmagic",      (char const   */* const  */)"ghosthit",      (char const   */* const  */)"poison",      (char const   */* const  */)"slow", 
        (char const   */* const  */)"paralyze",      (char const   */* const  */)"turn undead",      (char const   */* const  */)"fear",      (char const   */* const  */)"cancellation", 
        (char const   */* const  */)"depletion",      (char const   */* const  */)"death",      (char const   */* const  */)"chaos",      (char const   */* const  */)"counterspell", 
        (char const   */* const  */)"god power",      (char const   */* const  */)"holy power",      (char const   */* const  */)"blinding",      (char const   */* const  */)"", 
        (char const   */* const  */)"life stealing",      (char const   */* const  */)"disease"};
#line 151 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
static char const   * const  drain_msg[7]  = {      (char const   */* const  */)"Oh no! You are weakened!",      (char const   */* const  */)"You\'re feeling clumsy!",      (char const   */* const  */)"You feel less healthy",      (char const   */* const  */)"You suddenly begin to lose your memory!", 
        (char const   */* const  */)"Your face gets distorted!",      (char const   */* const  */)"Watch out, your mind is going!",      (char const   */* const  */)"Your spirit feels drained!"};
#line 162 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
char const   * const  restore_msg[7]  = {      (char const   */* const  */)"You feel your strength return.",      (char const   */* const  */)"You feel your agility return.",      (char const   */* const  */)"You feel your health return.",      (char const   */* const  */)"You feel your wisdom return.", 
        (char const   */* const  */)"You feel your charisma return.",      (char const   */* const  */)"You feel your memory return.",      (char const   */* const  */)"You feel your spirits return."};
#line 173 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
char const   * const  gain_msg[7]  = {      (char const   */* const  */)"You feel stronger.",      (char const   */* const  */)"You feel more agile.",      (char const   */* const  */)"You feel healthy.",      (char const   */* const  */)"You feel wiser.", 
        (char const   */* const  */)"You seem to look better.",      (char const   */* const  */)"You feel smarter.",      (char const   */* const  */)"You feel more potent."};
#line 184 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
char const   * const  lose_msg[7]  = {      (char const   */* const  */)"You feel weaker!",      (char const   */* const  */)"You feel clumsy!",      (char const   */* const  */)"You feel less healthy!",      (char const   */* const  */)"You lose some of your memory!", 
        (char const   */* const  */)"You look ugly!",      (char const   */* const  */)"You feel stupid!",      (char const   */* const  */)"You feel less potent!"};
#line 195 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
char const   * const  statname[7]  = {      (char const   */* const  */)"strength",      (char const   */* const  */)"dexterity",      (char const   */* const  */)"constitution",      (char const   */* const  */)"wisdom", 
        (char const   */* const  */)"charisma",      (char const   */* const  */)"intelligence",      (char const   */* const  */)"power"};
#line 206 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
char const   * const  short_stat_name[7]  = {      (char const   */* const  */)"Str",      (char const   */* const  */)"Dex",      (char const   */* const  */)"Con",      (char const   */* const  */)"Wis", 
        (char const   */* const  */)"Cha",      (char const   */* const  */)"Int",      (char const   */* const  */)"Pow"};
#line 230 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
void set_attr_value(living *stats , int attr , sint8 value ) 
{ 


  {
  {
#line 232
  if (attr == 0) {
#line 232
    goto case_0;
  }
#line 236
  if (attr == 1) {
#line 236
    goto case_1;
  }
#line 240
  if (attr == 2) {
#line 240
    goto case_2;
  }
#line 244
  if (attr == 3) {
#line 244
    goto case_3;
  }
#line 248
  if (attr == 6) {
#line 248
    goto case_6;
  }
#line 252
  if (attr == 4) {
#line 252
    goto case_4;
  }
#line 256
  if (attr == 5) {
#line 256
    goto case_5;
  }
#line 231
  goto switch_break;
  case_0: /* CIL Label */ 
#line 233
  stats->Str = value;
#line 234
  goto switch_break;
  case_1: /* CIL Label */ 
#line 237
  stats->Dex = value;
#line 238
  goto switch_break;
  case_2: /* CIL Label */ 
#line 241
  stats->Con = value;
#line 242
  goto switch_break;
  case_3: /* CIL Label */ 
#line 245
  stats->Wis = value;
#line 246
  goto switch_break;
  case_6: /* CIL Label */ 
#line 249
  stats->Pow = value;
#line 250
  goto switch_break;
  case_4: /* CIL Label */ 
#line 253
  stats->Cha = value;
#line 254
  goto switch_break;
  case_5: /* CIL Label */ 
#line 257
  stats->Int = value;
#line 258
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 260
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
void change_attr_value(living *stats , int attr , sint8 value ) 
{ 


  {
#line 277
  if ((int )value == 0) {
#line 278
    return;
  }
  {
#line 280
  if (attr == 0) {
#line 280
    goto case_0;
  }
#line 284
  if (attr == 1) {
#line 284
    goto case_1;
  }
#line 288
  if (attr == 2) {
#line 288
    goto case_2;
  }
#line 292
  if (attr == 3) {
#line 292
    goto case_3;
  }
#line 296
  if (attr == 6) {
#line 296
    goto case_6;
  }
#line 300
  if (attr == 4) {
#line 300
    goto case_4;
  }
#line 304
  if (attr == 5) {
#line 304
    goto case_5;
  }
#line 308
  goto switch_default;
  case_0: /* CIL Label */ 
#line 281
  stats->Str = (sint8 )((int )stats->Str + (int )value);
#line 282
  goto switch_break;
  case_1: /* CIL Label */ 
#line 285
  stats->Dex = (sint8 )((int )stats->Dex + (int )value);
#line 286
  goto switch_break;
  case_2: /* CIL Label */ 
#line 289
  stats->Con = (sint8 )((int )stats->Con + (int )value);
#line 290
  goto switch_break;
  case_3: /* CIL Label */ 
#line 293
  stats->Wis = (sint8 )((int )stats->Wis + (int )value);
#line 294
  goto switch_break;
  case_6: /* CIL Label */ 
#line 297
  stats->Pow = (sint8 )((int )stats->Pow + (int )value);
#line 298
  goto switch_break;
  case_4: /* CIL Label */ 
#line 301
  stats->Cha = (sint8 )((int )stats->Cha + (int )value);
#line 302
  goto switch_break;
  case_5: /* CIL Label */ 
#line 305
  stats->Int = (sint8 )((int )stats->Int + (int )value);
#line 306
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 309
  LOG((LogLevel )0, "Invalid attribute in change_attr_value: %d\n", attr);
  }
  switch_break: /* CIL Label */ ;
  }
#line 311
  return;
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
sint8 get_attr_value(living const   *stats , int attr ) 
{ 


  {
  {
#line 327
  if (attr == 0) {
#line 327
    goto case_0;
  }
#line 330
  if (attr == 1) {
#line 330
    goto case_1;
  }
#line 333
  if (attr == 2) {
#line 333
    goto case_2;
  }
#line 336
  if (attr == 3) {
#line 336
    goto case_3;
  }
#line 339
  if (attr == 4) {
#line 339
    goto case_4;
  }
#line 342
  if (attr == 5) {
#line 342
    goto case_5;
  }
#line 345
  if (attr == 6) {
#line 345
    goto case_6;
  }
#line 326
  goto switch_break;
  case_0: /* CIL Label */ 
#line 328
  return ((sint8 )stats->Str);
  case_1: /* CIL Label */ 
#line 331
  return ((sint8 )stats->Dex);
  case_2: /* CIL Label */ 
#line 334
  return ((sint8 )stats->Con);
  case_3: /* CIL Label */ 
#line 337
  return ((sint8 )stats->Wis);
  case_4: /* CIL Label */ 
#line 340
  return ((sint8 )stats->Cha);
  case_5: /* CIL Label */ 
#line 343
  return ((sint8 )stats->Int);
  case_6: /* CIL Label */ 
#line 346
  return ((sint8 )stats->Pow);
  switch_break: /* CIL Label */ ;
  }
#line 348
  return ((sint8 )0);
}
}
#line 366 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
void check_stat_bounds(living *stats , sint8 min_stat , sint8 max_stat ) 
{ 
  int i ;
  int v ;
  sint8 tmp ;

  {
#line 368
  i = 0;
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (! (i < 7)) {
#line 368
      goto while_break;
    }
    {
#line 369
    tmp = get_attr_value((living const   *)stats, i);
#line 369
    v = (int )tmp;
    }
#line 369
    if (v > (int )max_stat) {
      {
#line 370
      set_attr_value(stats, i, max_stat);
      }
    } else
#line 371
    if (v < (int )min_stat) {
      {
#line 372
      set_attr_value(stats, i, min_stat);
      }
    }
#line 368
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 373
  return;
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
int change_abil(object *op , object *tmp ) 
{ 
  int flag ;
  int tmp___0 ;
  int i ;
  int j ;
  int success ;
  object refop ;
  int potion_max ;
  int nstat ;
  int ostat ;
  sint8 tmp___1 ;
  sint8 tmp___2 ;
  sint8 tmp___3 ;
  sint8 tmp___4 ;
  sint8 tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  int tmp___18 ;
  char const   *tmp___19 ;
  int tmp___20 ;
  char const   *tmp___21 ;
  int tmp___22 ;
  char const   *tmp___23 ;
  int tmp___24 ;
  char const   *tmp___25 ;
  int tmp___26 ;
  char const   *tmp___27 ;
  int tmp___28 ;
  char const   *tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int tmp___32 ;
  char const   *tmp___33 ;
  int tmp___34 ;
  char const   *tmp___35 ;
  int tmp___36 ;
  char const   *tmp___37 ;
  int tmp___38 ;
  char const   *tmp___39 ;
  int tmp___40 ;
  char const   *tmp___41 ;
  int tmp___42 ;
  char const   *tmp___43 ;
  int tmp___44 ;
  sint8 tmp___45 ;

  {
#line 407
  if (tmp->flags[0] & (1U << 5)) {
#line 407
    tmp___0 = 1;
  } else {
#line 407
    tmp___0 = -1;
  }
  {
#line 407
  flag = tmp___0;
#line 407
  success = 0;
#line 409
  potion_max = 0;
#line 415
  memcpy((void */* __restrict  */)(& refop), (void const   */* __restrict  */)op,
         sizeof(object ));
  }
#line 417
  if ((int )op->type == 1) {
#line 418
    if ((int )tmp->type == 5) {
#line 419
      potion_max = 1;
#line 420
      j = 0;
      {
#line 420
      while (1) {
        while_continue: /* CIL Label */ ;
#line 420
        if (! (j < 7)) {
#line 420
          goto while_break;
        }
        {
#line 423
        tmp___1 = get_attr_value((living const   *)(& (op->contr)->orig_stats), j);
#line 423
        ostat = (int )tmp___1;
#line 424
        tmp___2 = get_attr_value((living const   *)(& tmp->stats), j);
#line 424
        i = (int )tmp___2;
#line 427
        nstat = flag * i + ostat;
        }
#line 434
        if (nstat < 1) {
#line 434
          if (i * flag < 0) {
#line 435
            nstat = 1;
          } else {
#line 434
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 436
          tmp___4 = get_attr_value((living const   *)(& (op->arch)->clone.stats),
                                   j);
          }
#line 436
          if (nstat > 20 + (int )tmp___4) {
            {
#line 437
            tmp___3 = get_attr_value((living const   *)(& (op->arch)->clone.stats),
                                     j);
#line 437
            nstat = 20 + (int )tmp___3;
            }
          }
        }
#line 439
        if (nstat != ostat) {
          {
#line 440
          set_attr_value(& (op->contr)->orig_stats, j, (sint8 )nstat);
#line 441
          potion_max = 0;
          }
        } else
#line 442
        if (i) {
#line 444
          potion_max = 1;
        }
#line 420
        j ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 451
      j = 0;
      {
#line 451
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 451
        if (! (j < 7)) {
#line 451
          goto while_break___0;
        }
        {
#line 452
        tmp___5 = get_attr_value((living const   *)(& tmp->stats), j);
#line 452
        change_attr_value(& op->stats, j, (sint8 )(flag * (int )tmp___5));
#line 451
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 453
      check_stat_bounds(& op->stats, (sint8 )1, (sint8 )settings.max_stat);
      }
    }
  }
#line 460
  if (flag == -1) {
#line 461
    op->attacktype &= ~ tmp->attacktype;
#line 462
    op->path_attuned &= ~ tmp->path_attuned;
#line 463
    op->path_repelled &= ~ tmp->path_repelled;
#line 464
    op->path_denied &= ~ tmp->path_denied;
#line 468
    op->move_type = (MoveType )((int )op->move_type & ~ ((int )tmp->move_type));
  }
  {
#line 475
  fix_object(op);
  }
#line 480
  if (tmp->attacktype & 32U) {
#line 480
    if ((int )tmp->type != 14) {
#line 481
      success = 1;
#line 482
      if (flag > 0) {
#line 482
        tmp___6 = "Your hands begin to glow red.";
      } else {
#line 482
        tmp___6 = "Your hands stop glowing red.";
      }
#line 482
      if (flag > 0) {
#line 482
        tmp___7 = 1;
      } else {
#line 482
        tmp___7 = 2;
      }
      {
#line 482
      draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )tmp___7, tmp___6);
      }
    }
  }
#line 486
  if ((op->flags[2] & 1U) != (refop.flags[2] & 1U)) {
#line 487
    success = 1;
#line 488
    if (flag > 0) {
#line 488
      tmp___8 = "You feel very protected.";
    } else {
#line 488
      tmp___8 = "You don\'t feel protected anymore.";
    }
#line 488
    if (flag > 0) {
#line 488
      tmp___9 = 3;
    } else {
#line 488
      tmp___9 = 4;
    }
    {
#line 488
    draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )tmp___9, tmp___8);
    }
  }
#line 492
  if ((op->flags[1] & (1U << 7)) != (refop.flags[1] & (1U << 7))) {
#line 493
    success = 1;
#line 494
    if (flag > 0) {
#line 494
      tmp___10 = "A magic force shimmers around you.";
    } else {
#line 494
      tmp___10 = "The magic force fades away.";
    }
#line 494
    if (flag > 0) {
#line 494
      tmp___11 = 3;
    } else {
#line 494
      tmp___11 = 4;
    }
    {
#line 494
    draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )tmp___11, tmp___10);
    }
  }
#line 498
  if ((op->flags[1] & (1U << 8)) != (refop.flags[1] & (1U << 8))) {
#line 499
    success = 1;
#line 500
    if (flag > 0) {
#line 500
      tmp___12 = "You feel more safe now, somehow.";
    } else {
#line 500
      tmp___12 = "Suddenly you feel less safe, somehow.";
    }
#line 500
    if (flag > 0) {
#line 500
      tmp___13 = 3;
    } else {
#line 500
      tmp___13 = 4;
    }
    {
#line 500
    draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )tmp___13, tmp___12);
    }
  }
#line 510
  if (tmp->move_type) {
#line 510
    if ((int )op->move_type != (int )refop.move_type) {
#line 511
      success = 1;
#line 516
      if ((int )tmp->move_type & 2) {
#line 516
        if (! ((int )op->move_type & 4)) {
#line 517
          if (flag > 0) {
#line 517
            tmp___14 = "You start to float in the air!";
          } else {
#line 517
            tmp___14 = "You float down to the ground.";
          }
#line 517
          if (flag > 0) {
#line 517
            tmp___15 = 5;
          } else {
#line 517
            tmp___15 = 5;
          }
          {
#line 517
          draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )tmp___15,
                        tmp___14);
          }
        }
      }
#line 522
      if ((int )tmp->move_type & 4) {
#line 526
        if (flag > 0) {
#line 526
          tmp___17 = "You soar into the air!.";
        } else {
#line 526
          if ((int )op->move_type & 2) {
#line 526
            tmp___16 = "You fly lower in the air";
          } else {
#line 526
            tmp___16 = "You float down to the ground.";
          }
#line 526
          tmp___17 = tmp___16;
        }
#line 526
        if (flag > 0) {
#line 526
          tmp___18 = 5;
        } else {
#line 526
          tmp___18 = 5;
        }
        {
#line 526
        draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )tmp___18,
                      tmp___17);
        }
      }
#line 531
      if ((int )tmp->move_type & 8) {
#line 532
        if (flag > 0) {
#line 532
          tmp___19 = "You feel ready for a swim";
        } else {
#line 532
          tmp___19 = "You no longer feel like swimming";
        }
#line 532
        if (flag > 0) {
#line 532
          tmp___20 = 5;
        } else {
#line 532
          tmp___20 = 5;
        }
        {
#line 532
        draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )tmp___20,
                      tmp___19);
        }
      }
      {
#line 537
      object_check_move_on(op, op);
      }
    }
  }
#line 543
  if (! ((op->arch)->clone.flags[1] & (1U << 4))) {
#line 544
    if ((op->flags[1] & (1U << 4)) != (refop.flags[1] & (1U << 4))) {
#line 545
      success = 1;
#line 546
      if (flag > 0) {
#line 547
        if (op->race) {
          {
#line 548
          free_string(op->race);
          }
        }
        {
#line 549
        op->race = add_string("undead");
#line 550
        draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )6, "Your lifeforce drains away!");
        }
      } else {
#line 552
        if (op->race) {
          {
#line 553
          free_string(op->race);
          }
        }
#line 554
        if ((op->arch)->clone.race) {
          {
#line 555
          op->race = add_string((op->arch)->clone.race);
          }
        } else {
#line 557
          op->race = (char const   *)((void *)0);
        }
        {
#line 558
        draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )6, "Your lifeforce returns!");
        }
      }
    }
  }
#line 562
  if ((op->flags[2] & (1U << 7)) != (refop.flags[2] & (1U << 7))) {
#line 563
    success = 1;
#line 564
    if (flag > 0) {
#line 564
      tmp___21 = "You walk more quietly.";
    } else {
#line 564
      tmp___21 = "You walk more noisily.";
    }
#line 564
    if (flag > 0) {
#line 564
      tmp___22 = 13;
    } else {
#line 564
      tmp___22 = 14;
    }
    {
#line 564
    draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )tmp___22, tmp___21);
    }
  }
#line 568
  if ((op->flags[2] & (1U << 21)) != (refop.flags[2] & (1U << 21))) {
#line 569
    success = 1;
#line 570
    if (flag > 0) {
#line 570
      tmp___23 = "You become transparent.";
    } else {
#line 570
      tmp___23 = "You can see yourself.";
    }
#line 570
    if (flag > 0) {
#line 570
      tmp___24 = 13;
    } else {
#line 570
      tmp___24 = 14;
    }
    {
#line 570
    draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )tmp___24, tmp___23);
    }
  }
#line 577
  if (tmp->flags[2] & (1U << 28)) {
#line 578
    success = 1;
#line 579
    if (flag > 0) {
#line 580
      if (op->flags[0] & (1U << 1)) {
        {
#line 581
        draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )7, "Your mortal self is blinded.");
        }
      } else {
        {
#line 583
        draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )7, "You are blinded.");
#line 584
        op->flags[2] |= 1U << 28;
        }
#line 585
        if ((int )op->type == 1) {
#line 586
          (op->contr)->do_los = (uint32 )1;
        }
      }
    } else
#line 589
    if (op->flags[0] & (1U << 1)) {
      {
#line 590
      draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )8, "Your mortal self can now see again.");
      }
    } else {
      {
#line 592
      draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )8, "Your vision returns.");
#line 593
      op->flags[2] &= ~ (1U << 28);
      }
#line 594
      if ((int )op->type == 1) {
#line 595
        (op->contr)->do_los = (uint32 )1;
      }
    }
  }
#line 600
  if ((op->flags[2] & (1U << 29)) != (refop.flags[2] & (1U << 29))) {
#line 601
    success = 1;
#line 602
    if ((int )op->type == 1) {
#line 603
      (op->contr)->do_los = (uint32 )1;
    }
#line 604
    if (flag > 0) {
#line 604
      tmp___25 = "Your vision is better in the dark.";
    } else {
#line 604
      tmp___25 = "You see less well in the dark.";
    }
#line 604
    if (flag > 0) {
#line 604
      tmp___26 = 13;
    } else {
#line 604
      tmp___26 = 14;
    }
    {
#line 604
    draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )tmp___26, tmp___25);
    }
  }
#line 609
  if ((op->flags[1] & (1U << 29)) != (refop.flags[1] & (1U << 29))) {
#line 610
    success = 1;
#line 611
    if (flag > 0) {
#line 612
      if (op->flags[0] & (1U << 1)) {
        {
#line 613
        draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )13, "Your vision becomes a little clearer.");
        }
      } else {
        {
#line 615
        draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )13, "Everything becomes transparent.");
        }
#line 616
        if ((int )op->type == 1) {
#line 617
          (op->contr)->do_los = (uint32 )1;
        }
      }
    } else
#line 620
    if (op->flags[0] & (1U << 1)) {
      {
#line 621
      draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )14, "Your vision becomes a bit out of focus.");
      }
    } else {
      {
#line 623
      draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )14, "Everything suddenly looks very solid.");
      }
#line 624
      if ((int )op->type == 1) {
#line 625
        (op->contr)->do_los = (uint32 )1;
      }
    }
  }
#line 630
  if (tmp->stats.luck) {
#line 631
    success = 1;
#line 632
    if (flag * (int )tmp->stats.luck > 0) {
#line 632
      tmp___27 = "You feel more lucky.";
    } else {
#line 632
      tmp___27 = "You feel less lucky.";
    }
#line 632
    if (flag * (int )tmp->stats.luck > 0) {
#line 632
      tmp___28 = 9;
    } else {
#line 632
      tmp___28 = 10;
    }
    {
#line 632
    draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )tmp___28, tmp___27);
    }
  }
#line 637
  if (tmp->stats.hp) {
#line 637
    if ((int )op->type == 1) {
#line 638
      success = 1;
#line 639
      if (flag * (int )tmp->stats.hp > 0) {
#line 639
        tmp___29 = "You feel much more healthy!";
      } else {
#line 639
        tmp___29 = "You feel much less healthy!";
      }
#line 639
      if (flag * (int )tmp->stats.hp > 0) {
#line 639
        tmp___30 = 9;
      } else {
#line 639
        tmp___30 = 10;
      }
      {
#line 639
      draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )tmp___30, tmp___29);
      }
    }
  }
#line 644
  if (tmp->stats.sp) {
#line 644
    if ((int )op->type == 1) {
#line 644
      if ((int )tmp->type != 43) {
#line 645
        success = 1;
#line 646
        if (flag * (int )tmp->stats.sp > 0) {
#line 646
          tmp___31 = "You feel one with the powers of magic!";
        } else {
#line 646
          tmp___31 = "You suddenly feel very mundane.";
        }
#line 646
        if (flag * (int )tmp->stats.sp > 0) {
#line 646
          tmp___32 = 9;
        } else {
#line 646
          tmp___32 = 10;
        }
        {
#line 646
        draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )tmp___32,
                      tmp___31);
        }
      }
    }
  }
#line 652
  if (tmp->stats.grace) {
#line 652
    if ((int )op->type == 1) {
#line 653
      success = 1;
#line 654
      if (flag * (int )tmp->stats.grace > 0) {
#line 654
        tmp___33 = "You feel closer to your god!";
      } else {
#line 654
        tmp___33 = "You suddenly feel less holy.";
      }
#line 654
      if (flag * (int )tmp->stats.grace > 0) {
#line 654
        tmp___34 = 9;
      } else {
#line 654
        tmp___34 = 10;
      }
      {
#line 654
      draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )tmp___34, tmp___33);
      }
    }
  }
#line 659
  if (tmp->stats.wc) {
#line 659
    if ((int )op->type == 1) {
#line 660
      success = 1;
#line 661
      if (flag * (int )tmp->stats.wc > 0) {
#line 661
        tmp___35 = "You feel more confident in combat.";
      } else {
#line 661
        tmp___35 = "You feel less confident in combat.";
      }
#line 661
      if (flag * (int )tmp->stats.wc > 0) {
#line 661
        tmp___36 = 9;
      } else {
#line 661
        tmp___36 = 10;
      }
      {
#line 661
      draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )tmp___36, tmp___35);
      }
    }
  }
#line 666
  if (tmp->stats.ac) {
#line 666
    if ((int )op->type == 1) {
#line 667
      success = 1;
#line 668
      if (flag * (int )tmp->stats.ac > 0) {
#line 668
        tmp___37 = "You feel more confident in your dodging skills.";
      } else {
#line 668
        tmp___37 = "You feel less confident in your dodging skills.";
      }
#line 668
      if (flag * (int )tmp->stats.ac > 0) {
#line 668
        tmp___38 = 9;
      } else {
#line 668
        tmp___38 = 10;
      }
      {
#line 668
      draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )tmp___38, tmp___37);
      }
    }
  }
#line 673
  if (tmp->stats.exp) {
#line 673
    if ((int )tmp->type != 43) {
#line 673
      if ((int )op->type == 1) {
#line 674
        success = 1;
#line 675
        if ((sint64 )flag * tmp->stats.exp > 0L) {
#line 675
          tmp___39 = "You feel like you\'re moving faster.";
        } else {
#line 675
          tmp___39 = "You feel like you\'re moving more slowly.";
        }
#line 675
        if ((sint64 )flag * tmp->stats.exp > 0L) {
#line 675
          tmp___40 = 9;
        } else {
#line 675
          tmp___40 = 10;
        }
        {
#line 675
        draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )tmp___40,
                      tmp___39);
        }
      }
    }
  }
#line 680
  if (tmp->stats.food) {
#line 680
    if ((int )op->type == 1) {
#line 681
      success = 1;
#line 682
      if (flag * tmp->stats.food > 0) {
#line 682
        tmp___41 = "You feel your digestion slowing down.";
      } else {
#line 682
        tmp___41 = "You feel your digestion speeding up.";
      }
#line 682
      if (flag * tmp->stats.food > 0) {
#line 682
        tmp___42 = 9;
      } else {
#line 682
        tmp___42 = 10;
      }
      {
#line 682
      draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )tmp___42, tmp___41);
      }
    }
  }
#line 688
  i = 0;
  {
#line 688
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 688
    if (! (i < 26)) {
#line 688
      goto while_break___1;
    }
#line 689
    if (i == 0) {
#line 690
      goto __Cont;
    }
#line 692
    if ((int )op->resist[i] != (int )refop.resist[i]) {
#line 693
      success = 1;
#line 694
      if ((int )op->resist[i] > (int )refop.resist[i]) {
        {
#line 695
        draw_ext_info_format(261, 0, (object const   *)op, (uint8 )11, (uint8 )3,
                             "Your resistance to %s rises to %d%%.", change_resist_msg[i],
                             (int )op->resist[i]);
        }
      } else {
        {
#line 699
        draw_ext_info_format(261, 0, (object const   *)op, (uint8 )11, (uint8 )4,
                             "Your resistance to %s drops to %d%%.", change_resist_msg[i],
                             (int )op->resist[i]);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 688
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 705
  if (! potion_max) {
#line 706
    j = 0;
    {
#line 706
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 706
      if (! (j < 7)) {
#line 706
        goto while_break___2;
      }
      {
#line 707
      tmp___45 = get_attr_value((living const   *)(& tmp->stats), j);
#line 707
      i = (int )tmp___45;
      }
#line 707
      if (i != 0) {
#line 708
        success = 1;
#line 709
        if (i * flag > 0) {
#line 709
          tmp___43 = gain_msg[j];
        } else {
#line 709
          tmp___43 = lose_msg[j];
        }
#line 709
        if (i * flag > 0) {
#line 709
          tmp___44 = 9;
        } else {
#line 709
          tmp___44 = 10;
        }
        {
#line 709
        draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )tmp___44,
                      (char const   *)tmp___43);
        }
      }
#line 706
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 713
  return (success);
}
}
#line 724 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
void drain_stat(object *op ) 
{ 
  long tmp ;

  {
  {
#line 725
  tmp = random();
#line 725
  drain_specific_stat(op, (int )(tmp % 7L));
  }
#line 726
  return;
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
void drain_specific_stat(object *op , int deplete_stats ) 
{ 
  object *tmp ;
  archetype *at ;

  {
  {
#line 740
  at = find_archetype("depletion");
  }
#line 741
  if (! at) {
    {
#line 742
    LOG((LogLevel )0, "Couldn\'t find archetype depletion.\n");
    }
#line 743
    return;
  } else {
    {
#line 745
    tmp = arch_present_in_ob((archetype const   *)at, (object const   *)op);
    }
#line 746
    if (! tmp) {
      {
#line 747
      tmp = arch_to_object(at);
#line 748
      tmp = object_insert_in_ob(tmp, op);
#line 749
      tmp->flags[0] |= 1U << 5;
      }
    }
  }
  {
#line 753
  draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )10, (char const   *)drain_msg[deplete_stats]);
#line 754
  change_attr_value(& tmp->stats, deplete_stats, (sint8 )-1);
#line 755
  fix_object(op);
  }
#line 756
  return;
}
}
#line 764 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
int remove_depletion(object *op , int level ) 
{ 
  object *depl ;
  archetype *at ;
  int i ;
  int count ;
  sint8 tmp ;
  int tmp___0 ;

  {
  {
#line 767
  count = 0;
#line 769
  at = find_archetype("depletion");
  }
#line 769
  if ((unsigned long )at == (unsigned long )((void *)0)) {
    {
#line 770
    LOG((LogLevel )0, "Could not find archetype depletion\n");
    }
#line 771
    return (0);
  }
  {
#line 774
  depl = arch_present_in_ob((archetype const   *)at, (object const   *)op);
  }
#line 776
  if ((unsigned long )depl == (unsigned long )((void *)0)) {
#line 777
    return (0);
  }
#line 779
  if (level != -1) {
#line 779
    if (level < (int )op->level) {
#line 780
      return (0);
    }
  }
#line 782
  i = 0;
  {
#line 782
  while (1) {
    while_continue: /* CIL Label */ ;
#line 782
    if (! (i < 7)) {
#line 782
      goto while_break;
    }
    {
#line 783
    tmp = get_attr_value((living const   *)(& depl->stats), i);
    }
#line 783
    if (tmp) {
      {
#line 784
      count ++;
#line 785
      draw_ext_info(256, 0, (object const   *)op, (uint8 )11, (uint8 )9, (char const   *)restore_msg[i]);
      }
    }
#line 782
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 789
  object_remove(depl);
#line 790
  object_free_drop_inventory(depl);
#line 791
  fix_object(op);
  }
#line 793
  if (count == 0) {
#line 793
    tmp___0 = 0;
  } else {
#line 793
    tmp___0 = 1;
  }
#line 793
  return (tmp___0);
}
}
#line 805 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
void change_luck(object *op , int value ) 
{ 
  object *tmp ;
  archetype *at ;
  int new_luck ;
  int diff ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 810
  at = find_archetype("luck");
  }
#line 811
  if (! at) {
    {
#line 812
    LOG((LogLevel )0, "Couldn\'t find archetype luck.\n");
    }
  } else {
    {
#line 814
    tmp = arch_present_in_ob((archetype const   *)at, (object const   *)op);
    }
#line 815
    if (! tmp) {
#line 816
      if (! value) {
#line 817
        return;
      }
      {
#line 818
      tmp = arch_to_object(at);
#line 819
      tmp = object_insert_in_ob(tmp, op);
#line 820
      tmp->flags[0] |= 1U << 5;
      }
    }
#line 822
    if (value) {
#line 827
      new_luck = (int )tmp->stats.luck + value;
#line 828
      if (new_luck >= -100) {
#line 828
        if (new_luck <= 100) {
#line 829
          op->stats.luck = (sint8 )((int )op->stats.luck + value);
#line 830
          tmp->stats.luck = (sint8 )new_luck;
        }
      }
    } else {
#line 833
      if (! tmp->stats.luck) {
#line 834
        return;
      }
      {
#line 839
      tmp___1 = random();
      }
#line 839
      if ((int )tmp->stats.luck < 0) {
#line 839
        tmp___2 = - ((int )tmp->stats.luck);
      } else {
#line 839
        tmp___2 = (int )tmp->stats.luck;
      }
      {
#line 839
      tmp___3 = random();
      }
#line 839
      if (tmp___1 % (long )tmp___2 >= tmp___3 % 30L) {
#line 840
        if ((int )tmp->stats.luck > 0) {
#line 840
          tmp___0 = -1;
        } else {
#line 840
          tmp___0 = 1;
        }
#line 840
        diff = tmp___0;
#line 841
        op->stats.luck = (sint8 )((int )op->stats.luck + diff);
#line 842
        tmp->stats.luck = (sint8 )((int )tmp->stats.luck + diff);
      }
    }
  }
#line 846
  return;
}
}
#line 854 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
void remove_statbonus(object *op ) 
{ 


  {
#line 855
  op->stats.Str = (sint8 )((int )op->stats.Str - (int )(op->arch)->clone.stats.Str);
#line 856
  op->stats.Dex = (sint8 )((int )op->stats.Dex - (int )(op->arch)->clone.stats.Dex);
#line 857
  op->stats.Con = (sint8 )((int )op->stats.Con - (int )(op->arch)->clone.stats.Con);
#line 858
  op->stats.Wis = (sint8 )((int )op->stats.Wis - (int )(op->arch)->clone.stats.Wis);
#line 859
  op->stats.Pow = (sint8 )((int )op->stats.Pow - (int )(op->arch)->clone.stats.Pow);
#line 860
  op->stats.Cha = (sint8 )((int )op->stats.Cha - (int )(op->arch)->clone.stats.Cha);
#line 861
  op->stats.Int = (sint8 )((int )op->stats.Int - (int )(op->arch)->clone.stats.Int);
#line 862
  (op->contr)->orig_stats.Str = (sint8 )((int )(op->contr)->orig_stats.Str - (int )(op->arch)->clone.stats.Str);
#line 863
  (op->contr)->orig_stats.Dex = (sint8 )((int )(op->contr)->orig_stats.Dex - (int )(op->arch)->clone.stats.Dex);
#line 864
  (op->contr)->orig_stats.Con = (sint8 )((int )(op->contr)->orig_stats.Con - (int )(op->arch)->clone.stats.Con);
#line 865
  (op->contr)->orig_stats.Wis = (sint8 )((int )(op->contr)->orig_stats.Wis - (int )(op->arch)->clone.stats.Wis);
#line 866
  (op->contr)->orig_stats.Pow = (sint8 )((int )(op->contr)->orig_stats.Pow - (int )(op->arch)->clone.stats.Pow);
#line 867
  (op->contr)->orig_stats.Cha = (sint8 )((int )(op->contr)->orig_stats.Cha - (int )(op->arch)->clone.stats.Cha);
#line 868
  (op->contr)->orig_stats.Int = (sint8 )((int )(op->contr)->orig_stats.Int - (int )(op->arch)->clone.stats.Int);
#line 869
  return;
}
}
#line 877 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
void add_statbonus(object *op ) 
{ 


  {
#line 878
  op->stats.Str = (sint8 )((int )op->stats.Str + (int )(op->arch)->clone.stats.Str);
#line 879
  op->stats.Dex = (sint8 )((int )op->stats.Dex + (int )(op->arch)->clone.stats.Dex);
#line 880
  op->stats.Con = (sint8 )((int )op->stats.Con + (int )(op->arch)->clone.stats.Con);
#line 881
  op->stats.Wis = (sint8 )((int )op->stats.Wis + (int )(op->arch)->clone.stats.Wis);
#line 882
  op->stats.Pow = (sint8 )((int )op->stats.Pow + (int )(op->arch)->clone.stats.Pow);
#line 883
  op->stats.Cha = (sint8 )((int )op->stats.Cha + (int )(op->arch)->clone.stats.Cha);
#line 884
  op->stats.Int = (sint8 )((int )op->stats.Int + (int )(op->arch)->clone.stats.Int);
#line 885
  (op->contr)->orig_stats.Str = (sint8 )((int )(op->contr)->orig_stats.Str + (int )(op->arch)->clone.stats.Str);
#line 886
  (op->contr)->orig_stats.Dex = (sint8 )((int )(op->contr)->orig_stats.Dex + (int )(op->arch)->clone.stats.Dex);
#line 887
  (op->contr)->orig_stats.Con = (sint8 )((int )(op->contr)->orig_stats.Con + (int )(op->arch)->clone.stats.Con);
#line 888
  (op->contr)->orig_stats.Wis = (sint8 )((int )(op->contr)->orig_stats.Wis + (int )(op->arch)->clone.stats.Wis);
#line 889
  (op->contr)->orig_stats.Pow = (sint8 )((int )(op->contr)->orig_stats.Pow + (int )(op->arch)->clone.stats.Pow);
#line 890
  (op->contr)->orig_stats.Cha = (sint8 )((int )(op->contr)->orig_stats.Cha + (int )(op->arch)->clone.stats.Cha);
#line 891
  (op->contr)->orig_stats.Int = (sint8 )((int )(op->contr)->orig_stats.Int + (int )(op->arch)->clone.stats.Int);
#line 892
  return;
}
}
#line 906 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
static void fix_player(object *op , int *ac , int *wc , object const   *grace_obj ,
                       object const   *mana_obj , object const   *wc_obj , int weapon_speed ,
                       float added_speed ) 
{ 
  int pl_level ;
  int i ;
  float character_load ;
  float maxhp ;
  float tmpf ;
  float tmp ;
  float sp_tmp ;
  float mana_bonus ;
  int mana_lvl_max ;
  float tmp___0 ;
  float tmp___1 ;
  float stmp ;
  float sp_tmp___0 ;
  float grace_bonus ;
  float tmp___2 ;
  float tmp___3 ;
  float grace_tmp ;
  int tmp___4 ;
  char const   *wc_in ;
  char const   *tmp___5 ;
  int wc_increase_rate ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  float tmp___10 ;
  int extra_weight ;
  uint32 tmp___11 ;
  uint32 tmp___12 ;
  uint32 tmp___13 ;
  float tmp___14 ;

  {
#line 909
  character_load = (float )0.0;
#line 911
  if ((int )op->type != 1) {
#line 912
    return;
  }
  {
#line 914
  check_stat_bounds(& op->stats, (sint8 )1, (sint8 )settings.max_stat);
#line 915
  pl_level = (int )op->level;
  }
#line 917
  if (pl_level < 1) {
#line 918
    pl_level = 1;
  }
#line 927
  maxhp = (float )0.0;
#line 928
  i = 1;
#line 928
  op->stats.maxhp = (sint16 )0;
  {
#line 928
  while (1) {
    while_continue: /* CIL Label */ ;
#line 928
    if (i <= pl_level) {
#line 928
      if (! (i <= 10)) {
#line 928
        goto while_break;
      }
    } else {
#line 928
      goto while_break;
    }
    {
#line 930
    tmp = get_con_bonus((int )op->stats.Con);
#line 930
    tmpf = (float )(op->contr)->levhp[i] + tmp;
    }
#line 933
    if ((double )tmpf < 1.0) {
#line 933
      tmpf = (float )1.0;
    }
#line 935
    maxhp += tmpf;
#line 928
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 941
  op->stats.maxhp = (sint16 )((int )((double )maxhp + 0.5));
#line 942
  if ((int )op->level > 10) {
#line 943
    op->stats.maxhp = (sint16 )((int )op->stats.maxhp + 2 * ((int )op->level - 10));
  }
#line 945
  op->stats.maxhp = (sint16 )((int )op->stats.maxhp + (int )(op->arch)->clone.stats.maxhp);
#line 947
  if ((int )op->stats.hp > (int )op->stats.maxhp) {
#line 948
    op->stats.hp = op->stats.maxhp;
  }
#line 954
  if (! mana_obj) {
#line 955
    op->stats.maxsp = (sint16 )1;
  } else
#line 954
  if (! mana_obj->level) {
#line 955
    op->stats.maxsp = (sint16 )1;
  } else {
#line 957
    sp_tmp = (float )0.0;
#line 960
    if ((int const   )mana_obj->level > 10) {
#line 960
      mana_lvl_max = 10;
    } else {
#line 960
      mana_lvl_max = (int )mana_obj->level;
    }
    {
#line 961
    tmp___0 = get_sp_bonus((int )op->stats.Pow);
#line 961
    tmp___1 = get_sp_bonus((int )op->stats.Int);
#line 961
    mana_bonus = (float )((2.0 * (double )tmp___0 + (double )tmp___1) / 3.0);
#line 963
    i = 1;
    }
    {
#line 963
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 963
      if (! (i <= mana_lvl_max)) {
#line 963
        goto while_break___0;
      }
#line 966
      stmp = (float )(op->contr)->levsp[i] + mana_bonus;
#line 969
      if (i == 1) {
#line 969
        stmp += mana_bonus;
      }
#line 971
      if ((double )stmp < 1.0) {
#line 972
        stmp = (float )1.0;
      }
#line 974
      sp_tmp += stmp;
#line 963
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 977
    op->stats.maxsp = (sint16 )((int )sp_tmp + (int )(op->arch)->clone.stats.maxsp);
#line 979
    if ((int const   )mana_obj->level > 10) {
#line 980
      op->stats.maxsp = (sint16 )((int )op->stats.maxsp + 2 * (int )((int const   )mana_obj->level - 10));
    }
  }
#line 984
  if ((int )op->stats.sp > (int )op->stats.maxsp * 2) {
#line 985
    op->stats.sp = (sint16 )((int )op->stats.maxsp * 2);
  }
#line 988
  if (! grace_obj) {
#line 989
    op->stats.maxgrace = (sint16 )1;
  } else
#line 988
  if (! grace_obj->level) {
#line 989
    op->stats.maxgrace = (sint16 )1;
  } else {
    {
#line 996
    sp_tmp___0 = (float )0.0;
#line 998
    tmp___2 = get_grace_bonus((int )op->stats.Pow);
#line 998
    tmp___3 = get_grace_bonus((int )op->stats.Wis);
#line 998
    grace_bonus = (float )(((double )tmp___2 + 2.0 * (double )tmp___3) / 3.0);
#line 1000
    i = 1;
    }
    {
#line 1000
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1000
      if (i <= (int )grace_obj->level) {
#line 1000
        if (! (i <= 10)) {
#line 1000
          goto while_break___1;
        }
      } else {
#line 1000
        goto while_break___1;
      }
#line 1001
      grace_tmp = (float )0.0;
#line 1003
      grace_tmp = (float )(op->contr)->levgrace[i] + grace_bonus;
#line 1006
      if (i == 1) {
#line 1007
        grace_tmp += grace_bonus;
      }
#line 1009
      if ((double )grace_tmp < 1.0) {
#line 1010
        grace_tmp = (float )1.0;
      }
#line 1011
      sp_tmp___0 += grace_tmp;
#line 1000
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1013
    op->stats.maxgrace = (sint16 )((int )sp_tmp___0 + (int )(op->arch)->clone.stats.maxgrace);
#line 1016
    if ((int const   )grace_obj->level > 10) {
#line 1017
      op->stats.maxgrace = (sint16 )((int )op->stats.maxgrace + 2 * (int )((int const   )grace_obj->level - 10));
    }
  }
#line 1021
  if ((op->contr)->braced) {
#line 1022
    *ac += 2;
#line 1023
    *wc += 4;
  } else {
    {
#line 1025
    tmp___4 = get_dex_bonus((int )op->stats.Dex);
#line 1025
    *ac -= tmp___4;
    }
  }
#line 1039
  if (wc_obj) {
#line 1039
    if ((int const   )wc_obj->level >= 1) {
      {
#line 1040
      tmp___5 = object_get_value(wc_obj, (char const   */* const  */)"wc_increase_rate");
#line 1040
      wc_in = tmp___5;
      }
#line 1043
      if (wc_in) {
        {
#line 1043
        tmp___6 = atoi(wc_in);
#line 1043
        wc_increase_rate = tmp___6;
        }
      } else {
#line 1043
        wc_increase_rate = 5;
      }
      {
#line 1044
      tmp___7 = get_thaco_bonus((int )op->stats.Str);
#line 1044
      *wc -= tmp___7;
#line 1045
      *wc -= (int )(((int const   )wc_obj->level - 1) / (int const   )wc_increase_rate);
#line 1046
      op->stats.dam = (sint16 )((int )op->stats.dam + (int )(((int const   )wc_obj->level - 1) / 4));
      }
    } else {
      {
#line 1048
      tmp___8 = get_thaco_bonus((int )op->stats.Str);
#line 1048
      *wc -= ((int )op->level - 1) / 5 + tmp___8;
      }
    }
  } else {
    {
#line 1048
    tmp___8 = get_thaco_bonus((int )op->stats.Str);
#line 1048
    *wc -= ((int )op->level - 1) / 5 + tmp___8;
    }
  }
  {
#line 1050
  tmp___9 = get_dam_bonus((int )op->stats.Str);
#line 1050
  op->stats.dam = (sint16 )((int )op->stats.dam + tmp___9);
  }
#line 1052
  if ((int )op->stats.dam < 1) {
#line 1053
    op->stats.dam = (sint16 )1;
  }
  {
#line 1055
  tmp___10 = get_speed_bonus((int )op->stats.Dex);
#line 1055
  op->speed = (float )(0.75 + (double )tmp___10);
  }
#line 1057
  if (settings.search_items) {
#line 1057
    if ((op->contr)->search_str[0]) {
#line 1058
      op->speed = (float )((double )op->speed - 0.25);
    }
  }
#line 1060
  if (op->attacktype == 0U) {
#line 1061
    op->attacktype = (op->arch)->clone.attacktype;
  }
  {
#line 1071
  tmp___13 = get_weight_limit((int )op->stats.Str);
  }
#line 1071
  if ((double )op->carrying > (double )tmp___13 * 0.50) {
#line 1071
    if (0.50 < 1.0) {
      {
#line 1073
      tmp___11 = get_weight_limit((int )op->stats.Str);
#line 1073
      extra_weight = (int )((double )op->carrying - (double )tmp___11 * 0.50);
#line 1075
      tmp___12 = get_weight_limit((int )op->stats.Str);
#line 1075
      character_load = (float )extra_weight / (float )((double )tmp___12 * (1.0 - 0.50));
      }
#line 1078
      if ((double )character_load >= 1.0) {
#line 1079
        character_load = (float )1.0;
      }
#line 1085
      if ((double )op->speed > 0.75) {
#line 1086
        op->speed = (float )((double )op->speed - (double )character_load * ((double )op->speed - 0.25));
      } else {
#line 1088
        op->speed = (float )((double )op->speed - (double )character_load * (0.75 - 0.25));
      }
    }
  }
  {
#line 1092
  tmp___14 = get_speed_bonus((int )op->stats.Dex);
#line 1092
  op->weapon_speed = (float )(((1.0 + (double )tmp___14) - (double )weapon_speed / 20.0) + (double )added_speed / 10.0);
  }
#line 1093
  if (wc_obj) {
#line 1094
    op->weapon_speed = (float )((double )op->weapon_speed + 0.005 * (double )wc_obj->level);
  } else {
#line 1096
    op->weapon_speed = (float )((double )op->weapon_speed + 0.005 * (double )op->level);
  }
#line 1102
  op->weapon_speed = (float )((double )op->weapon_speed - (double )character_load * 0.2);
#line 1104
  if ((double )op->weapon_speed < 0.05) {
#line 1105
    op->weapon_speed = (float )0.05;
  }
  {
#line 1110
  esrv_update_spells(op->contr);
  }
#line 1111
  return;
}
}
#line 1132 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
void fix_object(object *op ) 
{ 
  int i ;
  float max ;
  float added_speed ;
  float speed_reduce_from_disease ;
  int weapon_speed ;
  int best_wc ;
  int best_ac ;
  int wc ;
  int ac ;
  int prot[26] ;
  int vuln[26] ;
  int potion_resist[26] ;
  object const   *grace_obj ;
  object const   *mana_obj ;
  object const   *wc_obj ;
  sint8 tmp ;
  object *tmp___0 ;
  object *next1233 ;
  tag_t next_tag1233 ;
  tag_t tmp___1 ;
  sint8 value ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 1134
  max = (float )9;
#line 1134
  added_speed = (float )0;
#line 1134
  speed_reduce_from_disease = (float )1;
#line 1135
  weapon_speed = 0;
#line 1136
  best_wc = 0;
#line 1136
  best_ac = 0;
#line 1136
  wc = 0;
#line 1136
  ac = 0;
#line 1138
  grace_obj = (object const   *)((void *)0);
#line 1138
  mana_obj = (object const   *)((void *)0);
#line 1138
  wc_obj = (object const   *)((void *)0);
#line 1141
  if ((int )op->type == 1) {
#line 1142
    i = 0;
    {
#line 1142
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1142
      if (! (i < 7)) {
#line 1142
        goto while_break;
      }
      {
#line 1143
      tmp = get_attr_value((living const   *)(& (op->contr)->orig_stats), i);
#line 1143
      set_attr_value(& op->stats, i, tmp);
#line 1144
      set_attr_value(& (op->contr)->applied_stats, i, (sint8 )0);
#line 1142
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1146
    if ((int )settings.spell_encumbrance == 1) {
#line 1147
      (op->contr)->encumbrance = (sint16 )0;
    }
#line 1149
    op->attacktype = (uint32 )0;
#line 1150
    (op->contr)->digestion = (sint16 )0;
#line 1151
    (op->contr)->gen_hp = (sint16 )0;
#line 1152
    (op->contr)->gen_sp = (sint16 )0;
#line 1153
    (op->contr)->gen_grace = (sint16 )0;
#line 1154
    (op->contr)->gen_sp_armour = (sint16 )10;
#line 1155
    (op->contr)->item_power = (sint16 )0;
#line 1162
    (op->contr)->ranges[1] = (object *)((void *)0);
#line 1163
    (op->contr)->ranges[3] = (object *)((void *)0);
#line 1164
    (op->contr)->ranges[5] = (object *)((void *)0);
  }
  {
#line 1166
  memcpy((void */* __restrict  */)(op->body_used), (void const   */* __restrict  */)(op->body_info),
         sizeof(op->body_info));
  }
#line 1168
  if ((unsigned long )op->slaying != (unsigned long )((void *)0)) {
    {
#line 1169
    free_string(op->slaying);
#line 1170
    op->slaying = (char const   *)((void *)0);
    }
  }
#line 1172
  if (! (op->flags[0] & (1U << 1))) {
#line 1173
    op->flags[1] &= ~ (1U << 29);
#line 1174
    op->flags[2] &= ~ (1U << 21);
  }
#line 1177
  op->flags[2] &= 4294967294U;
#line 1178
  op->flags[2] &= ~ (1U << 7);
#line 1179
  op->flags[2] &= ~ (1U << 28);
#line 1180
  if (! ((op->arch)->clone.flags[1] & (1U << 8))) {
#line 1181
    op->flags[1] &= ~ (1U << 8);
  }
#line 1182
  if (! ((op->arch)->clone.flags[1] & (1U << 7))) {
#line 1183
    op->flags[1] &= ~ (1U << 7);
  }
#line 1184
  if (! ((op->arch)->clone.flags[1] & (1U << 4))) {
#line 1185
    op->flags[1] &= ~ (1U << 4);
  }
#line 1186
  if (! ((op->arch)->clone.flags[2] & (1U << 29))) {
#line 1187
    op->flags[2] &= ~ (1U << 29);
  }
  {
#line 1188
  op->flags[0] &= ~ (1U << 25);
#line 1190
  op->path_attuned = (op->arch)->clone.path_attuned;
#line 1191
  op->path_repelled = (op->arch)->clone.path_repelled;
#line 1192
  op->path_denied = (op->arch)->clone.path_denied;
#line 1193
  op->glow_radius = (op->arch)->clone.glow_radius;
#line 1194
  op->move_type = (op->arch)->clone.move_type;
#line 1195
  op->chosen_skill = (struct obj *)((void *)0);
#line 1200
  memcpy((void */* __restrict  */)(& op->resist), (void const   */* __restrict  */)(& (op->arch)->clone.resist),
         sizeof(op->resist));
#line 1202
  i = 0;
  }
  {
#line 1202
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1202
    if (! (i < 26)) {
#line 1202
      goto while_break___0;
    }
#line 1203
    if ((int )op->resist[i] > 0) {
#line 1204
      prot[i] = (int )op->resist[i];
#line 1204
      vuln[i] = 0;
    } else {
#line 1206
      vuln[i] = - ((int )op->resist[i]);
#line 1206
      prot[i] = 0;
    }
#line 1207
    potion_resist[i] = 0;
#line 1202
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1210
  wc = (int )(op->arch)->clone.stats.wc;
#line 1211
  op->stats.dam = (op->arch)->clone.stats.dam;
#line 1220
  if (! (op->flags[1] & (1U << 24))) {
#line 1220
    if ((int )op->type == 1) {
#line 1221
      if (-10 > (int )(op->arch)->clone.stats.ac - (int )op->level / 3) {
#line 1221
        ac = -10;
      } else {
#line 1221
        ac = (int )(op->arch)->clone.stats.ac - (int )op->level / 3;
      }
#line 1222
      prot[0] += ((100 - prot[1]) * ((80 * (int )op->level) / (int )settings.max_level)) / 100;
    } else {
#line 1224
      ac = (int )(op->arch)->clone.stats.ac;
    }
  } else {
#line 1224
    ac = (int )(op->arch)->clone.stats.ac;
  }
#line 1226
  op->stats.luck = (op->arch)->clone.stats.luck;
#line 1227
  op->speed = (op->arch)->clone.speed;
  {
#line 1233
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1233
    tmp___0 = op->inv;
    {
#line 1233
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1233
      next1233 = tmp___0;
#line 1233
      if ((unsigned long )next1233 == (unsigned long )((void *)0)) {
#line 1233
        tmp___1 = (tag_t )0;
      } else {
#line 1233
        tmp___1 = next1233->count;
      }
#line 1233
      next_tag1233 = tmp___1;
      {
#line 1233
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1233
        tmp___0 = next1233;
#line 1233
        if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 1233
          goto while_break___3;
        }
#line 1233
        if (next1233->count != next_tag1233) {
#line 1233
          goto while_break___3;
        } else
#line 1233
        if (next1233->flags[0] & (1U << 3)) {
#line 1233
          goto while_break___3;
        }
#line 1233
        next1233 = next1233->below;
#line 1233
        if ((unsigned long )next1233 == (unsigned long )((void *)0)) {
#line 1233
          next_tag1233 = (tag_t )0;
        } else {
#line 1233
          next_tag1233 = next1233->count;
        }
#line 1237
        if ((int )tmp___0->glow_radius > (int )op->glow_radius) {
#line 1238
          op->glow_radius = tmp___0->glow_radius;
        }
#line 1244
        if (tmp___0->flags[0] & (1U << 5)) {
#line 1244
          if ((int )tmp___0->type == 5) {
#line 1245
            goto while_continue___3;
          }
        }
#line 1248
        if ((int )tmp___0->type == 43) {
#line 1250
          if ((int )tmp___0->subtype == 36) {
#line 1250
            goto _L;
          } else
#line 1250
          if ((int )tmp___0->subtype == 35) {
#line 1250
            goto _L;
          } else
#line 1250
          if ((int )tmp___0->subtype == 34) {
#line 1250
            goto _L;
          } else
#line 1250
          if ((int )tmp___0->subtype == 33) {
#line 1250
            goto _L;
          } else
#line 1250
          if ((int )tmp___0->subtype == 40) {
#line 1250
            goto _L;
          } else
#line 1250
          if ((int )tmp___0->subtype == 41) {
#line 1250
            goto _L;
          } else
#line 1250
          if ((int )tmp___0->subtype == 43) {
#line 1250
            goto _L;
          } else
#line 1250
          if ((int )tmp___0->subtype == 42) {
            _L: /* CIL Label */ 
#line 1251
            if (! mana_obj) {
#line 1252
              mana_obj = (object const   *)tmp___0;
            } else
#line 1253
            if ((int )tmp___0->level > (int )mana_obj->level) {
#line 1254
              mana_obj = (object const   *)tmp___0;
            }
          }
#line 1256
          if ((int )tmp___0->subtype == 30) {
#line 1257
            if (! grace_obj) {
#line 1258
              grace_obj = (object const   *)tmp___0;
            } else
#line 1259
            if ((int )tmp___0->level > (int )grace_obj->level) {
#line 1260
              grace_obj = (object const   *)tmp___0;
            }
          }
        }
#line 1273
        if (tmp___0->flags[0] & (1U << 5)) {
#line 1273
          if ((int )tmp___0->type != 122) {
#line 1273
            if ((int )tmp___0->type != 121) {
#line 1273
              goto _L___1;
            } else {
#line 1273
              goto _L___3;
            }
          } else {
#line 1273
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 1273
        if ((int )tmp___0->type == 43) {
#line 1273
          if ((int )tmp___0->subtype == 30) {
            _L___1: /* CIL Label */ 
#line 1275
            if ((int )op->type == 1) {
#line 1276
              if ((int )tmp___0->type == 14) {
#line 1277
                (op->contr)->ranges[1] = tmp___0;
              }
#line 1279
              if ((int )tmp___0->type == 109) {
#line 1280
                (op->contr)->ranges[3] = tmp___0;
              } else
#line 1279
              if ((int )tmp___0->type == 3) {
#line 1280
                (op->contr)->ranges[3] = tmp___0;
              }
#line 1282
              i = 0;
              {
#line 1282
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 1282
                if (! (i < 7)) {
#line 1282
                  goto while_break___4;
                }
                {
#line 1285
                value = get_attr_value((living const   *)(& tmp___0->stats), i);
#line 1286
                change_attr_value(& op->stats, i, value);
#line 1287
                tmp___2 = strcmp((tmp___0->arch)->clone.name, "depletion");
                }
#line 1287
                if (tmp___2 != 0) {
                  {
#line 1288
                  change_attr_value(& (op->contr)->applied_stats, i, value);
                  }
                }
#line 1282
                i ++;
              }
              while_break___4: /* CIL Label */ ;
              }
              {
#line 1296
              check_stat_bounds(& tmp___0->stats, (sint8 )(- ((int )settings.max_stat)),
                                (sint8 )(2 * (int )settings.max_stat));
              }
#line 1302
              if ((int )tmp___0->type == 15) {
#line 1302
                goto _L___0;
              } else
#line 1302
              if ((int )tmp___0->type == 16) {
#line 1302
                goto _L___0;
              } else
#line 1302
              if ((int )tmp___0->type == 34) {
#line 1302
                goto _L___0;
              } else
#line 1302
              if ((int )tmp___0->type == 33) {
#line 1302
                goto _L___0;
              } else
#line 1302
              if ((int )tmp___0->type == 70) {
#line 1302
                goto _L___0;
              } else
#line 1302
              if ((int )tmp___0->type == 99) {
#line 1302
                goto _L___0;
              } else
#line 1302
              if ((int )tmp___0->type == 100) {
#line 1302
                goto _L___0;
              } else
#line 1302
              if ((int )tmp___0->type == 39) {
#line 1302
                goto _L___0;
              } else
#line 1302
              if ((int )tmp___0->type == 113) {
#line 1302
                goto _L___0;
              } else
#line 1302
              if ((int )tmp___0->type == 104) {
#line 1302
                goto _L___0;
              } else
#line 1302
              if ((int )tmp___0->type == 87) {
#line 1302
                goto _L___0;
              } else
#line 1302
              if ((int )tmp___0->type == 158) {
#line 1302
                goto _L___0;
              } else
#line 1302
              if ((int )tmp___0->type == 114) {
#line 1302
                goto _L___0;
              } else
#line 1302
              if ((int )tmp___0->type == 43) {
                _L___0: /* CIL Label */ 
#line 1316
                (op->contr)->digestion = (sint16 )((int )(op->contr)->digestion + tmp___0->stats.food);
#line 1317
                (op->contr)->gen_hp = (sint16 )((int )(op->contr)->gen_hp + (int )tmp___0->stats.hp);
#line 1318
                (op->contr)->gen_sp = (sint16 )((int )(op->contr)->gen_sp + (int )tmp___0->stats.sp);
#line 1319
                (op->contr)->gen_grace = (sint16 )((int )(op->contr)->gen_grace + (int )tmp___0->stats.grace);
#line 1320
                (op->contr)->gen_sp_armour = (sint16 )((int )(op->contr)->gen_sp_armour + (int )tmp___0->gen_sp_armour);
#line 1321
                (op->contr)->item_power = (sint16 )((int )(op->contr)->item_power + (int )tmp___0->item_power);
              }
            }
#line 1326
            if (tmp___0->flags[0] & (1U << 5)) {
#line 1327
              i = 0;
              {
#line 1327
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 1327
                if (! (i < 13)) {
#line 1327
                  goto while_break___5;
                }
#line 1328
                op->body_used[i] = (sint8 )((int )op->body_used[i] + (int )tmp___0->body_info[i]);
#line 1327
                i ++;
              }
              while_break___5: /* CIL Label */ ;
              }
            }
#line 1331
            if ((int )tmp___0->type == 159) {
#line 1331
              if (tmp___0->last_sp) {
#line 1333
                if ((double )((float )tmp___0->last_sp) / 100.0 < (double )speed_reduce_from_disease) {
#line 1334
                  speed_reduce_from_disease = (float )((double )((float )tmp___0->last_sp) / 100.0);
                }
              }
            }
#line 1342
            if ((int )tmp___0->type != 5) {
#line 1343
              i = 0;
              {
#line 1343
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 1343
                if (! (i < 26)) {
#line 1343
                  goto while_break___6;
                }
#line 1347
                if ((int )tmp___0->type == 115) {
#line 1348
                  if (potion_resist[i]) {
#line 1349
                    if (potion_resist[i] > (int )tmp___0->resist[i]) {
#line 1349
                      potion_resist[i] = potion_resist[i];
                    } else {
#line 1349
                      potion_resist[i] = (int )tmp___0->resist[i];
                    }
                  } else {
#line 1351
                    potion_resist[i] = (int )tmp___0->resist[i];
                  }
                } else
#line 1352
                if ((int )tmp___0->resist[i] > 0) {
#line 1353
                  prot[i] += ((100 - prot[i]) * (int )tmp___0->resist[i]) / 100;
                } else
#line 1354
                if ((int )tmp___0->resist[i] < 0) {
#line 1355
                  vuln[i] += ((100 - vuln[i]) * - ((int )tmp___0->resist[i])) / 100;
                }
#line 1343
                i ++;
              }
              while_break___6: /* CIL Label */ ;
              }
            }
#line 1360
            if ((int )tmp___0->type != 14) {
#line 1360
              if ((int )tmp___0->type != 159) {
#line 1361
                op->attacktype |= tmp___0->attacktype;
              }
            }
#line 1363
            op->path_attuned |= tmp___0->path_attuned;
#line 1364
            op->path_repelled |= tmp___0->path_repelled;
#line 1365
            op->path_denied |= tmp___0->path_denied;
#line 1366
            op->stats.luck = (sint8 )((int )op->stats.luck + (int )tmp___0->stats.luck);
#line 1367
            op->move_type = (MoveType )((int )op->move_type | (int )tmp___0->move_type);
#line 1369
            if (tmp___0->flags[2] & 1U) {
#line 1370
              op->flags[2] |= 1U;
            }
#line 1371
            if (tmp___0->flags[1] & (1U << 8)) {
#line 1372
              op->flags[1] |= 1U << 8;
            }
#line 1373
            if (tmp___0->flags[1] & (1U << 7)) {
#line 1374
              op->flags[1] |= 1U << 7;
            }
#line 1375
            if (tmp___0->flags[2] & (1U << 7)) {
#line 1376
              op->flags[2] |= 1U << 7;
            }
#line 1377
            if (tmp___0->flags[1] & (1U << 29)) {
#line 1378
              op->flags[1] |= 1U << 29;
            }
#line 1379
            if (tmp___0->flags[2] & (1U << 28)) {
#line 1380
              op->flags[2] |= 1U << 28;
            }
#line 1381
            if (tmp___0->flags[2] & (1U << 29)) {
#line 1382
              op->flags[2] |= 1U << 29;
            }
#line 1383
            if (tmp___0->flags[0] & (1U << 25)) {
#line 1384
              op->flags[0] |= 1U << 25;
            }
#line 1386
            if (tmp___0->flags[1] & (1U << 4)) {
#line 1386
              if (! ((op->arch)->clone.flags[1] & (1U << 4))) {
#line 1387
                op->flags[1] |= 1U << 4;
              }
            }
#line 1389
            if (tmp___0->flags[2] & (1U << 21)) {
#line 1390
              op->flags[2] |= 1U << 21;
#line 1391
              op->invisible = (sint16 )1;
            }
#line 1394
            if (tmp___0->stats.exp) {
#line 1394
              if ((int )tmp___0->type != 43) {
#line 1395
                added_speed = (float )((double )added_speed + (double )((float )tmp___0->stats.exp) / 3.0);
              }
            }
            {
#line 1401
            if ((int )tmp___0->type == 43) {
#line 1401
              goto case_43;
            }
#line 1438
            if ((int )tmp___0->type == 74) {
#line 1438
              goto case_74;
            }
#line 1447
            if ((int )tmp___0->type == 33) {
#line 1447
              goto case_33;
            }
#line 1456
            if ((int )tmp___0->type == 87) {
#line 1456
              goto case_87;
            }
#line 1456
            if ((int )tmp___0->type == 100) {
#line 1456
              goto case_87;
            }
#line 1456
            if ((int )tmp___0->type == 99) {
#line 1456
              goto case_87;
            }
#line 1456
            if ((int )tmp___0->type == 34) {
#line 1456
              goto case_87;
            }
#line 1456
            if ((int )tmp___0->type == 113) {
#line 1456
              goto case_87;
            }
#line 1456
            if ((int )tmp___0->type == 39) {
#line 1456
              goto case_87;
            }
#line 1456
            if ((int )tmp___0->type == 70) {
#line 1456
              goto case_87;
            }
#line 1465
            if ((int )tmp___0->type == 15) {
#line 1465
              goto case_15;
            }
#line 1487
            if ((int )tmp___0->type == 16) {
#line 1487
              goto case_16;
            }
#line 1494
            if ((int )tmp___0->type == 114) {
#line 1494
              goto case_114;
            }
#line 1494
            if ((int )tmp___0->type == 104) {
#line 1494
              goto case_114;
            }
#line 1398
            goto switch_break;
            case_43: /* CIL Label */ 
#line 1402
            if (! (tmp___0->flags[0] & (1U << 5))) {
#line 1403
              goto switch_break;
            }
#line 1405
            if ((int )tmp___0->subtype == 17) {
#line 1406
              wc_obj = (object const   *)tmp___0;
            } else
#line 1405
            if ((int )tmp___0->subtype == 18) {
#line 1406
              wc_obj = (object const   *)tmp___0;
            } else
#line 1405
            if ((int )tmp___0->subtype == 19) {
#line 1406
              wc_obj = (object const   *)tmp___0;
            } else
#line 1405
            if ((int )tmp___0->subtype == 23) {
#line 1406
              wc_obj = (object const   *)tmp___0;
            } else
#line 1405
            if ((int )tmp___0->subtype == 24) {
#line 1406
              wc_obj = (object const   *)tmp___0;
            } else
#line 1405
            if ((int )tmp___0->subtype == 25) {
#line 1406
              wc_obj = (object const   *)tmp___0;
            } else
#line 1405
            if ((int )tmp___0->subtype == 31) {
#line 1406
              wc_obj = (object const   *)tmp___0;
            } else
#line 1405
            if ((int )tmp___0->subtype == 37) {
#line 1406
              wc_obj = (object const   *)tmp___0;
            } else
#line 1405
            if ((int )tmp___0->subtype == 38) {
#line 1406
              wc_obj = (object const   *)tmp___0;
            }
#line 1408
            if (op->chosen_skill) {
              {
#line 1409
              LOG((LogLevel )2, "fix_object, op %s has multiple skills applied\n",
                  op->name);
              }
            }
#line 1411
            op->chosen_skill = tmp___0;
#line 1412
            if ((int )tmp___0->stats.dam > 0) {
#line 1413
              if (! (op->flags[2] & (1U << 26))) {
#line 1414
                weapon_speed = tmp___0->last_sp;
              }
#line 1415
              if (weapon_speed < 0) {
#line 1416
                weapon_speed = 0;
              }
#line 1417
              op->stats.dam = (sint16 )((int )op->stats.dam + (int )tmp___0->stats.dam * (1 + (int )(op->chosen_skill)->level / 9));
#line 1418
              if (tmp___0->magic) {
#line 1419
                op->stats.dam = (sint16 )((int )op->stats.dam + (int )tmp___0->magic);
              }
            }
#line 1421
            if (tmp___0->stats.wc) {
#line 1422
              wc -= (int )tmp___0->stats.wc + (int )tmp___0->magic;
            }
#line 1424
            if ((unsigned long )tmp___0->slaying != (unsigned long )((void *)0)) {
#line 1425
              if ((unsigned long )op->slaying != (unsigned long )((void *)0)) {
                {
#line 1426
                free_string(op->slaying);
                }
              }
              {
#line 1427
              tmp___3 = tmp___0->slaying;
#line 1427
              op->slaying = tmp___3;
#line 1427
              add_refcount(tmp___3);
              }
            }
#line 1430
            if (tmp___0->stats.ac) {
#line 1431
              ac -= (int )tmp___0->stats.ac + (int )tmp___0->magic;
            }
#line 1432
            if ((int )settings.spell_encumbrance == 1) {
#line 1432
              if ((int )op->type == 1) {
#line 1433
                (op->contr)->encumbrance = (sint16 )((int )(op->contr)->encumbrance + (3 * tmp___0->weight) / 1000);
              }
            }
#line 1434
            if ((int )op->type == 1) {
#line 1435
              (op->contr)->ranges[5] = op;
            }
#line 1436
            goto switch_break;
            case_74: /* CIL Label */ 
#line 1439
            if (op->chosen_skill) {
              {
#line 1440
              LOG((LogLevel )2, "fix_object, op %s has multiple skills applied\n",
                  op->name);
              }
            }
#line 1442
            op->chosen_skill = tmp___0;
#line 1443
            if ((int )op->type == 1) {
#line 1444
              (op->contr)->ranges[5] = op;
            }
#line 1445
            goto switch_break;
            case_33: /* CIL Label */ 
#line 1448
            if ((int )settings.spell_encumbrance == 1) {
#line 1448
              if ((int )op->type == 1) {
#line 1449
                (op->contr)->encumbrance = (sint16 )((int )(op->contr)->encumbrance + tmp___0->weight / 2000);
              }
            }
            case_87: /* CIL Label */ 
            case_100: /* CIL Label */ 
            case_99: /* CIL Label */ 
            case_34: /* CIL Label */ 
            case_113: /* CIL Label */ 
            case_39: /* CIL Label */ 
            case_70: /* CIL Label */ 
#line 1457
            if (tmp___0->stats.wc) {
#line 1458
              wc -= (int )tmp___0->stats.wc;
            }
#line 1459
            if (tmp___0->stats.dam) {
#line 1460
              op->stats.dam = (sint16 )((int )op->stats.dam + ((int )tmp___0->stats.dam + (int )tmp___0->magic));
            }
#line 1461
            if (tmp___0->stats.ac) {
#line 1462
              ac -= (int )tmp___0->stats.ac + (int )tmp___0->magic;
            }
#line 1463
            goto switch_break;
            case_15: /* CIL Label */ 
#line 1466
            wc -= (int )tmp___0->stats.wc;
#line 1467
            if (tmp___0->stats.ac) {
#line 1467
              if ((int )tmp___0->stats.ac + (int )tmp___0->magic > 0) {
#line 1468
                ac -= (int )tmp___0->stats.ac + (int )tmp___0->magic;
              }
            }
#line 1469
            op->stats.dam = (sint16 )((int )op->stats.dam + ((int )tmp___0->stats.dam + (int )tmp___0->magic));
#line 1470
            weapon_speed = (tmp___0->last_sp * 2 - (int )tmp___0->magic) / 2;
#line 1471
            if (weapon_speed < 0) {
#line 1472
              weapon_speed = 0;
            }
#line 1473
            if ((unsigned long )tmp___0->slaying != (unsigned long )((void *)0)) {
#line 1474
              if ((unsigned long )op->slaying != (unsigned long )((void *)0)) {
                {
#line 1475
                free_string(op->slaying);
                }
              }
              {
#line 1476
              tmp___4 = tmp___0->slaying;
#line 1476
              op->slaying = tmp___4;
#line 1476
              add_refcount(tmp___4);
              }
            }
#line 1482
            op->current_weapon = tmp___0;
#line 1483
            if ((int )settings.spell_encumbrance == 1) {
#line 1483
              if ((int )op->type == 1) {
#line 1484
                (op->contr)->encumbrance = (sint16 )((int )(op->contr)->encumbrance + (3 * tmp___0->weight) / 1000);
              }
            }
#line 1485
            goto switch_break;
            case_16: /* CIL Label */ 
#line 1488
            if ((int )settings.spell_encumbrance == 1) {
#line 1488
              if ((int )op->type == 1) {
#line 1489
                (op->contr)->encumbrance = (sint16 )((int )(op->contr)->encumbrance + tmp___0->weight / 1000);
              }
            }
            case_114: /* CIL Label */ 
            case_104: /* CIL Label */ 
#line 1495
            if (tmp___0->stats.wc) {
#line 1496
              if (best_wc < (int )tmp___0->stats.wc) {
#line 1497
                wc += best_wc;
#line 1498
                best_wc = (int )tmp___0->stats.wc;
              } else {
#line 1500
                wc += (int )tmp___0->stats.wc;
              }
            }
#line 1502
            if (tmp___0->stats.ac) {
#line 1503
              if (best_ac < (int )tmp___0->stats.ac + (int )tmp___0->magic) {
#line 1504
                ac += best_ac;
#line 1505
                best_ac = (int )tmp___0->stats.ac + (int )tmp___0->magic;
              } else {
#line 1507
                ac += (int )tmp___0->stats.ac + (int )tmp___0->magic;
              }
            }
#line 1509
            if (tmp___0->stats.dam) {
#line 1509
              if ((int )tmp___0->type == 104) {
#line 1510
                op->stats.dam = (sint16 )((int )op->stats.dam + ((int )tmp___0->stats.dam + (int )tmp___0->magic));
              }
            }
#line 1511
            if (tmp___0->stats.wc) {
#line 1512
              wc -= (int )tmp___0->stats.wc;
            }
#line 1513
            if (tmp___0->stats.ac) {
#line 1514
              ac -= (int )tmp___0->stats.ac + (int )tmp___0->magic;
            }
#line 1515
            if (tmp___0->last_sp) {
#line 1515
              if ((double )tmp___0->last_sp / 10.0 < (double )max) {
#line 1516
                max = (float )((double )tmp___0->last_sp / 10.0);
              }
            }
#line 1517
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
          }
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1233
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1233
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1532
  i = 0;
  {
#line 1532
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1532
    if (! (i < 26)) {
#line 1532
      goto while_break___7;
    }
#line 1533
    op->resist[i] = (sint16 )(prot[i] - vuln[i]);
#line 1534
    if (potion_resist[i]) {
#line 1534
      if (potion_resist[i] > (int )op->resist[i]) {
#line 1536
        op->resist[i] = (sint16 )potion_resist[i];
      } else
#line 1534
      if (potion_resist[i] < 0) {
#line 1536
        op->resist[i] = (sint16 )potion_resist[i];
      }
    }
#line 1532
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 1539
  fix_player(op, & ac, & wc, grace_obj, mana_obj, wc_obj, weapon_speed, added_speed);
#line 1541
  op->speed *= speed_reduce_from_disease;
  }
#line 1544
  if (op->speed > max) {
#line 1545
    op->speed = max;
  }
#line 1547
  op->speed = (float )((double )op->speed + (double )added_speed / 10.0);
#line 1553
  if ((double )op->speed < 0.05) {
#line 1553
    if ((int )op->type == 1) {
#line 1554
      op->speed = (float )0.05;
    }
  }
#line 1557
  if ((int )op->type != 1) {
#line 1557
    if ((unsigned long )op->arch != (unsigned long )((void *)0)) {
#line 1557
      if ((int )op->stats.dam > (int )(op->arch)->clone.stats.dam * 3) {
#line 1560
        op->stats.dam = (sint16 )((int )(op->arch)->clone.stats.dam * 3);
      }
    }
  }
#line 1566
  if (wc > 120) {
#line 1567
    wc = 120;
  } else
#line 1568
  if (wc < -120) {
#line 1569
    wc = -120;
  }
#line 1570
  op->stats.wc = (sint8 )wc;
#line 1572
  if (ac > 120) {
#line 1573
    ac = 120;
  } else
#line 1574
  if (ac < -120) {
#line 1575
    ac = -120;
  }
#line 1576
  op->stats.ac = (sint8 )ac;
#line 1584
  if ((int )op->move_type == 0) {
#line 1585
    op->move_type = (MoveType )1;
  } else
#line 1586
  if ((int )op->move_type & 6) {
#line 1587
    op->move_type = (MoveType )((int )op->move_type & -2);
  }
  {
#line 1589
  object_update_speed(op);
  }
#line 1590
  return;
}
}
#line 1604 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
int allowed_class(object const   *op ) 
{ 
  int tmp ;

  {
#line 1605
  if ((int const   )op->stats.Dex > 0) {
#line 1605
    if ((int const   )op->stats.Str > 0) {
#line 1605
      if ((int const   )op->stats.Con > 0) {
#line 1605
        if ((int const   )op->stats.Int > 0) {
#line 1605
          if ((int const   )op->stats.Wis > 0) {
#line 1605
            if ((int const   )op->stats.Pow > 0) {
#line 1605
              if ((int const   )op->stats.Cha > 0) {
#line 1605
                tmp = 1;
              } else {
#line 1605
                tmp = 0;
              }
            } else {
#line 1605
              tmp = 0;
            }
          } else {
#line 1605
            tmp = 0;
          }
        } else {
#line 1605
          tmp = 0;
        }
      } else {
#line 1605
        tmp = 0;
      }
    } else {
#line 1605
      tmp = 0;
    }
  } else {
#line 1605
    tmp = 0;
  }
#line 1605
  return (tmp);
}
}
#line 1631 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
void set_dragon_name(object *pl , object const   *abil , object const   *skin ) 
{ 
  int atnr ;
  int level ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 1632
  atnr = -1;
#line 1633
  level = 0;
#line 1637
  if (! abil) {
#line 1638
    return;
  } else
#line 1637
  if (! skin) {
#line 1638
    return;
  }
#line 1641
  i = 0;
  {
#line 1641
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1641
    if (! (i < 26)) {
#line 1641
      goto while_break;
    }
    {
#line 1642
    tmp = atnr_is_dragon_enabled(i);
    }
#line 1642
    if (tmp) {
#line 1642
      if (atnr == -1) {
#line 1644
        level = (int )abil->resist[i];
#line 1645
        atnr = i;
      } else
#line 1642
      if ((int )abil->resist[i] > (int )abil->resist[atnr]) {
#line 1644
        level = (int )abil->resist[i];
#line 1645
        atnr = i;
      }
    }
#line 1641
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1651
  tmp___0 = atnr_is_dragon_enabled((int )abil->stats.exp);
  }
#line 1651
  if (tmp___0) {
#line 1651
    if ((int )abil->resist[abil->stats.exp] >= level) {
#line 1653
      atnr = (int )abil->stats.exp;
    }
  }
#line 1655
  level = (int )((double )level / 5.);
#line 1658
  if ((unsigned long )pl->contr != (unsigned long )((void *)0)) {
    {
#line 1659
    player_set_dragon_title(pl->contr, level, (char const   *)attacks[atnr], (int )skin->resist[atnr]);
    }
  }
#line 1661
  return;
}
}
#line 1671 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
static void dragon_level_gain(object *who ) 
{ 
  object *abil ;
  object *skin ;
  int tmp ;

  {
  {
#line 1672
  abil = (object *)((void *)0);
#line 1673
  skin = (object *)((void *)0);
#line 1676
  abil = object_find_by_type_and_arch_name((object const   *)who, 114, "dragon_ability_force");
#line 1677
  skin = object_find_by_type_and_arch_name((object const   *)who, 114, "dragon_skin_force");
  }
#line 1679
  if ((unsigned long )abil == (unsigned long )((void *)0)) {
#line 1680
    return;
  }
#line 1685
  if ((int )who->level > (int )abil->level) {
#line 1687
    abil->resist[abil->stats.exp] = (sint16 )((int )abil->resist[abil->stats.exp] + 1);
#line 1689
    if ((int )abil->resist[abil->stats.exp] > 0) {
#line 1689
      if ((int )abil->resist[abil->stats.exp] % 5 == 0) {
        {
#line 1691
        dragon_ability_gain(who, (int )abil->stats.exp, (int )((double )(1 + (int )abil->resist[abil->stats.exp]) / 5.));
        }
      }
    }
#line 1694
    if (abil->last_eat > 0) {
      {
#line 1694
      tmp = atnr_is_dragon_enabled(abil->last_eat);
      }
#line 1694
      if (tmp) {
        {
#line 1696
        draw_ext_info_format(261, 0, (object const   *)who, (uint8 )11, (uint8 )6,
                             "Your metabolism now focuses on %s!", change_resist_msg[abil->last_eat]);
#line 1700
        abil->stats.exp = (sint64 )abil->last_eat;
#line 1701
        abil->last_eat = 0;
        }
      }
    }
#line 1704
    abil->level = who->level;
  }
  {
#line 1708
  set_dragon_name(who, (object const   *)abil, (object const   *)skin);
  }
#line 1709
  return;
}
}
#line 1729 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
object *give_skill_by_name(object *op , char const   *skill_name ) 
{ 
  object *skill_obj ;
  archetype *skill_arch ;

  {
  {
#line 1733
  skill_arch = get_archetype_by_skill_name(skill_name, 43);
  }
#line 1734
  if (! skill_arch) {
    {
#line 1735
    LOG((LogLevel )0, "add_player_exp: couldn\'t find skill %s\n", skill_name);
    }
#line 1736
    return ((object *)((void *)0));
  }
  {
#line 1738
  skill_obj = arch_to_object(skill_arch);
#line 1743
  skill_obj->flags[2] &= ~ (1U << 15);
#line 1744
  skill_obj->stats.exp = (sint64 )0;
#line 1745
  skill_obj->level = (sint16 )1;
#line 1746
  object_insert_in_ob(skill_obj, op);
  }
#line 1747
  if (op->contr) {
#line 1748
    (op->contr)->last_skill_ob[skill_obj->subtype] = skill_obj;
#line 1749
    (op->contr)->last_skill_exp[skill_obj->subtype] = (sint64 )-1;
  }
#line 1751
  return (skill_obj);
}
}
#line 1770 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
void player_lvl_adj(object *who , object *op ) 
{ 
  char buf[256] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  sint64 tmp___3 ;
  sint64 tmp___4 ;

  {
#line 1773
  if (! who) {
    {
#line 1773
    __assert_fail("who", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c",
                  1773U, "player_lvl_adj");
    }
  }
#line 1775
  if (! op) {
#line 1776
    op = who;
  }
#line 1778
  if ((int )op->level < (int )settings.max_level) {
    {
#line 1778
    tmp___4 = level_exp((int )op->level + 1, who->expmul);
    }
#line 1778
    if (op->stats.exp >= tmp___4) {
#line 1779
      op->level = (sint16 )((int )op->level + 1);
#line 1781
      if ((unsigned long )op != (unsigned long )((void *)0)) {
#line 1781
        if ((unsigned long )op == (unsigned long )who) {
#line 1781
          if (op->stats.exp > 1L) {
            {
#line 1781
            tmp = is_dragon_pl((object const   *)who);
            }
#line 1781
            if (tmp) {
              {
#line 1782
              dragon_level_gain(who);
              }
            }
          }
        }
      }
#line 1785
      if ((unsigned long )op == (unsigned long )who) {
#line 1785
        if ((int )who->level < 11) {
#line 1785
          if ((int )who->type == 1) {
            {
#line 1786
            tmp___0 = die_roll(2, 4, (object const   *)who, 1);
#line 1786
            (who->contr)->levhp[who->level] = (sint8 )(tmp___0 + 1);
#line 1787
            tmp___1 = die_roll(2, 3, (object const   *)who, 1);
#line 1787
            (who->contr)->levsp[who->level] = (sint8 )tmp___1;
#line 1788
            tmp___2 = die_roll(2, 2, (object const   *)who, 1);
#line 1788
            (who->contr)->levgrace[who->level] = (sint8 )(tmp___2 - 1);
            }
          }
        }
      }
      {
#line 1791
      fix_object(who);
      }
#line 1792
      if ((int )op->level > 1) {
#line 1793
        if ((int )op->type != 1) {
          {
#line 1794
          snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You are now level %d in the %s skill.",
                   (int )op->level, op->name);
          }
        } else {
          {
#line 1796
          snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You are now level %d.",
                   (int )op->level);
          }
        }
        {
#line 1798
        draw_ext_info(259, 0, (object const   *)who, (uint8 )11, (uint8 )11, (char const   *)(buf));
        }
      }
      {
#line 1800
      player_lvl_adj(who, op);
      }
    } else {
#line 1778
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1801
  if ((int )op->level > 1) {
    {
#line 1801
    tmp___3 = level_exp((int )op->level, who->expmul);
    }
#line 1801
    if (op->stats.exp < tmp___3) {
      {
#line 1802
      op->level = (sint16 )((int )op->level - 1);
#line 1803
      fix_object(who);
      }
#line 1804
      if ((int )op->type != 1) {
        {
#line 1805
        snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You are now level %d in the %s skill.",
                 (int )op->level, op->name);
        }
      } else {
        {
#line 1807
        snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"You are now level %d.",
                 (int )op->level);
        }
      }
      {
#line 1809
      draw_ext_info(259, 0, (object const   *)who, (uint8 )11, (uint8 )12, (char const   *)(buf));
#line 1811
      player_lvl_adj(who, op);
      }
    }
  }
#line 1813
  return;
}
}
#line 1824 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
sint64 level_exp(int level , double expmul ) 
{ 


  {
#line 1825
  if (level > (int )settings.max_level) {
#line 1826
    return ((sint64 )(expmul * (double )*(levels + settings.max_level)));
  }
#line 1827
  return ((sint64 )(expmul * (double )*(levels + level)));
}
}
#line 1840 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
void calc_perm_exp(object *op ) 
{ 
  sint64 p_exp_min ;

  {
#line 1846
  p_exp_min = ((sint64 )settings.permanent_exp_ratio * op->stats.exp) / 100L;
#line 1848
  if (op->perm_exp < p_exp_min) {
#line 1849
    op->perm_exp = p_exp_min;
  }
#line 1852
  if (op->perm_exp < 0L) {
#line 1853
    op->perm_exp = (sint64 )0;
  } else
#line 1854
  if (op->perm_exp > *(levels + settings.max_level)) {
#line 1855
    op->perm_exp = *(levels + settings.max_level);
  }
#line 1856
  return;
}
}
#line 1873 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
static void add_player_exp(object *op , sint64 exp , char const   *skill_name , int flag ) 
{ 
  object *skill_obj ;
  sint64 limit ;
  sint64 exp_to_add ;
  int i ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 1874
  skill_obj = (object *)((void *)0);
#line 1879
  if ((op->contr)->braced) {
#line 1880
    exp /= 5L;
  }
#line 1887
  if (skill_name) {
#line 1888
    if (op->chosen_skill) {
#line 1888
      if ((int )(op->chosen_skill)->type == 43) {
        {
#line 1888
        tmp___0 = strcmp(skill_name, (op->chosen_skill)->skill);
        }
#line 1888
        if (tmp___0) {
#line 1888
          goto _L___0;
        } else {
#line 1891
          skill_obj = op->chosen_skill;
        }
      } else {
#line 1888
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1893
      i = 0;
      {
#line 1893
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1893
        if (! (i < 44)) {
#line 1893
          goto while_break;
        }
#line 1894
        if ((op->contr)->last_skill_ob[i]) {
          {
#line 1894
          tmp = strcmp(((op->contr)->last_skill_ob[i])->skill, skill_name);
          }
#line 1894
          if (! tmp) {
#line 1896
            skill_obj = (op->contr)->last_skill_ob[i];
#line 1897
            goto while_break;
          }
        }
#line 1893
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1903
      if (! skill_obj) {
#line 1904
        if (flag == 2) {
#line 1905
          return;
        } else
#line 1906
        if (flag == 0) {
          {
#line 1907
          skill_obj = give_skill_by_name(op, skill_name);
          }
        }
      }
    }
  }
#line 1915
  exp_to_add = exp;
#line 1916
  limit = (*(levels + ((int )op->level + 1)) - *(levels + op->level)) / 2L;
#line 1917
  if (exp_to_add > limit) {
#line 1918
    exp_to_add = limit;
  }
#line 1920
  if (skill_obj) {
#line 1920
    tmp___1 = skill_obj->expmul;
  } else {
#line 1920
    tmp___1 = (double )1;
  }
#line 1920
  op->stats.exp = (sint64 )((double )op->stats.exp + (double )((float )exp_to_add) * tmp___1);
#line 1920
  if (op->stats.exp > *(levels + settings.max_level)) {
#line 1920
    op->stats.exp = *(levels + settings.max_level);
  }
#line 1921
  if (settings.permanent_exp_ratio) {
#line 1922
    if (skill_obj) {
#line 1922
      tmp___2 = skill_obj->expmul;
    } else {
#line 1922
      tmp___2 = (double )1;
    }
#line 1922
    op->perm_exp = (sint64 )((double )op->perm_exp + (double )((float )exp_to_add * 0.50f) * tmp___2);
#line 1922
    if (op->perm_exp > *(levels + settings.max_level)) {
#line 1922
      op->perm_exp = *(levels + settings.max_level);
    }
    {
#line 1923
    calc_perm_exp(op);
    }
  }
  {
#line 1926
  player_lvl_adj(op, (object *)((void *)0));
  }
#line 1927
  if (skill_obj) {
#line 1928
    exp_to_add = exp;
#line 1929
    limit = (*(levels + ((int )skill_obj->level + 1)) - *(levels + skill_obj->level)) / 2L;
#line 1930
    if (exp_to_add > limit) {
#line 1931
      exp_to_add = limit;
    }
#line 1932
    skill_obj->stats.exp += exp_to_add;
#line 1932
    if (skill_obj->stats.exp > *(levels + settings.max_level)) {
#line 1932
      skill_obj->stats.exp = *(levels + settings.max_level);
    }
#line 1933
    if (settings.permanent_exp_ratio) {
      {
#line 1934
      skill_obj->perm_exp = (sint64 )((float )skill_obj->perm_exp + (float )exp_to_add * 0.50f);
#line 1935
      calc_perm_exp(skill_obj);
      }
    }
    {
#line 1937
    player_lvl_adj(op, skill_obj);
    }
  }
#line 1939
  return;
}
}
#line 1956 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
sint64 check_exp_loss(object const   *op , sint64 exp ) 
{ 
  sint64 del_exp ;

  {
#line 1959
  if (exp > (sint64 )op->stats.exp) {
#line 1960
    exp = (sint64 )op->stats.exp;
  }
#line 1961
  if (settings.permanent_exp_ratio) {
#line 1962
    del_exp = (sint64 )((float )(op->stats.exp - op->perm_exp) * 0.50f);
#line 1963
    if (del_exp < 0L) {
#line 1964
      del_exp = (sint64 )0;
    }
#line 1965
    if (exp > del_exp) {
#line 1966
      exp = del_exp;
    }
  }
#line 1968
  return (exp);
}
}
#line 1981 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
sint64 check_exp_adjust(object const   *op , sint64 exp ) 
{ 
  sint64 tmp ;
  sint64 tmp___0 ;

  {
#line 1982
  if (exp < 0L) {
    {
#line 1983
    tmp = check_exp_loss(op, exp);
    }
#line 1983
    return (tmp);
  } else {
#line 1985
    if (exp < *(levels + settings.max_level) - (sint64 )op->stats.exp) {
#line 1985
      tmp___0 = exp;
    } else {
#line 1985
      tmp___0 = *(levels + settings.max_level) - (sint64 )op->stats.exp;
    }
#line 1985
    return (tmp___0);
  }
}
}
#line 2010 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
static void subtract_player_exp(object *op , sint64 exp , char const   *skill , int flag ) 
{ 
  float fraction ;
  sint64 del_exp ;
  object *tmp ;
  object *next2014 ;
  tag_t next_tag2014 ;
  tag_t tmp___0 ;
  int tmp___1 ;

  {
#line 2011
  fraction = (float )exp / (float )op->stats.exp;
  {
#line 2014
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2014
    tmp = op->inv;
    {
#line 2014
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2014
      next2014 = tmp;
#line 2014
      if ((unsigned long )next2014 == (unsigned long )((void *)0)) {
#line 2014
        tmp___0 = (tag_t )0;
      } else {
#line 2014
        tmp___0 = next2014->count;
      }
#line 2014
      next_tag2014 = tmp___0;
      {
#line 2014
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2014
        tmp = next2014;
#line 2014
        if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 2014
          goto while_break___1;
        }
#line 2014
        if (next2014->count != next_tag2014) {
#line 2014
          goto while_break___1;
        } else
#line 2014
        if (next2014->flags[0] & (1U << 3)) {
#line 2014
          goto while_break___1;
        }
#line 2014
        next2014 = next2014->below;
#line 2014
        if ((unsigned long )next2014 == (unsigned long )((void *)0)) {
#line 2014
          next_tag2014 = (tag_t )0;
        } else {
#line 2014
          next_tag2014 = next2014->count;
        }
#line 2015
        if ((int )tmp->type == 43) {
#line 2015
          if (tmp->stats.exp) {
#line 2016
            if (flag == 3) {
#line 2016
              if (skill) {
                {
#line 2016
                tmp___1 = strcmp(tmp->skill, skill);
                }
#line 2016
                if (tmp___1) {
#line 2016
                  goto _L___0;
                } else {
                  {
#line 2017
                  del_exp = check_exp_loss((object const   *)tmp, exp);
#line 2018
                  tmp->stats.exp -= del_exp;
#line 2019
                  player_lvl_adj(op, tmp);
                  }
                }
              } else {
#line 2016
                goto _L___0;
              }
            } else
            _L___0: /* CIL Label */ 
#line 2020
            if (flag != 3) {
              {
#line 2024
              del_exp = check_exp_loss((object const   *)tmp, (sint64 )((float )tmp->stats.exp * fraction));
#line 2025
              tmp->stats.exp -= del_exp;
#line 2026
              player_lvl_adj(op, tmp);
              }
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2014
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2014
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2030
  if (flag != 3) {
    {
#line 2031
    del_exp = check_exp_loss((object const   *)op, exp);
#line 2032
    op->stats.exp -= del_exp;
#line 2033
    player_lvl_adj(op, (object *)((void *)0));
    }
  }
#line 2035
  return;
}
}
#line 2058 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
void change_exp(object *op , sint64 exp , char const   *skill_name , int flag ) 
{ 
  sint64 tmp ;

  {
#line 2070
  if (! op) {
    {
#line 2071
    LOG((LogLevel )0, "change_exp() called for null object!\n");
    }
#line 2072
    return;
  }
#line 2078
  if (exp == 0L) {
#line 2079
    return;
  }
#line 2086
  if ((int )op->type != 1) {
#line 2088
    if (! (op->flags[0] & 1U)) {
#line 2089
      return;
    }
#line 2095
    if (exp > 0L) {
#line 2095
      if (op->stats.exp > *(levels + settings.max_level) - exp) {
#line 2096
        exp = *(levels + settings.max_level) - op->stats.exp;
#line 2097
        if (exp < 0L) {
#line 2098
          return;
        }
      }
    }
#line 2101
    op->stats.exp += exp;
  } else
#line 2103
  if (exp > 0L) {
    {
#line 2104
    add_player_exp(op, exp, skill_name, flag);
    }
  } else {
#line 2106
    if (exp < 0L) {
#line 2106
      tmp = - exp;
    } else {
#line 2106
      tmp = exp;
    }
    {
#line 2106
    subtract_player_exp(op, tmp, skill_name, flag);
    }
  }
#line 2108
  return;
}
}
#line 2118 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
void apply_death_exp_penalty(object *op ) 
{ 
  sint64 loss ;
  sint64 percentage_loss ;
  sint64 level_loss ;
  object *tmp ;
  object *next2123 ;
  tag_t next_tag2123 ;
  tag_t tmp___0 ;
  int tmp___1 ;
  sint64 tmp___2 ;
  int tmp___3 ;
  sint64 tmp___4 ;

  {
  {
#line 2123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2123
    tmp = op->inv;
    {
#line 2123
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2123
      next2123 = tmp;
#line 2123
      if ((unsigned long )next2123 == (unsigned long )((void *)0)) {
#line 2123
        tmp___0 = (tag_t )0;
      } else {
#line 2123
        tmp___0 = next2123->count;
      }
#line 2123
      next_tag2123 = tmp___0;
      {
#line 2123
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2123
        tmp = next2123;
#line 2123
        if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 2123
          goto while_break___1;
        }
#line 2123
        if (next2123->count != next_tag2123) {
#line 2123
          goto while_break___1;
        } else
#line 2123
        if (next2123->flags[0] & (1U << 3)) {
#line 2123
          goto while_break___1;
        }
#line 2123
        next2123 = next2123->below;
#line 2123
        if ((unsigned long )next2123 == (unsigned long )((void *)0)) {
#line 2123
          next_tag2123 = (tag_t )0;
        } else {
#line 2123
          next_tag2123 = next2123->count;
        }
#line 2124
        if ((int )tmp->type == 43) {
#line 2124
          if (tmp->stats.exp) {
#line 2125
            percentage_loss = (tmp->stats.exp * (sint64 )settings.death_penalty_ratio) / 100L;
#line 2126
            if (0 > (int )tmp->level - (int )settings.death_penalty_level) {
#line 2126
              tmp___1 = 0;
            } else {
#line 2126
              tmp___1 = (int )tmp->level - (int )settings.death_penalty_level;
            }
#line 2126
            level_loss = tmp->stats.exp - *(levels + tmp___1);
#line 2133
            if (level_loss < 0L) {
#line 2134
              level_loss = (sint64 )0;
            }
#line 2136
            if (level_loss < percentage_loss) {
#line 2136
              tmp___2 = level_loss;
            } else {
#line 2136
              tmp___2 = percentage_loss;
            }
            {
#line 2136
            loss = check_exp_loss((object const   *)tmp, tmp___2);
#line 2138
            tmp->stats.exp -= loss;
#line 2139
            player_lvl_adj(op, tmp);
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2123
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2123
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2143
  percentage_loss = (op->stats.exp * (sint64 )settings.death_penalty_ratio) / 100L;
#line 2144
  if (0 > (int )op->level - (int )settings.death_penalty_level) {
#line 2144
    tmp___3 = 0;
  } else {
#line 2144
    tmp___3 = (int )op->level - (int )settings.death_penalty_level;
  }
#line 2144
  level_loss = op->stats.exp - *(levels + tmp___3);
#line 2145
  if (level_loss < 0L) {
#line 2146
    level_loss = (sint64 )0;
  }
#line 2147
  if (level_loss < percentage_loss) {
#line 2147
    tmp___4 = level_loss;
  } else {
#line 2147
    tmp___4 = percentage_loss;
  }
  {
#line 2147
  loss = check_exp_loss((object const   *)op, tmp___4);
#line 2149
  op->stats.exp -= loss;
#line 2150
  player_lvl_adj(op, (object *)((void *)0));
  }
#line 2151
  return;
}
}
#line 2167 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
int did_make_save(object const   *op , int level , int bonus ) 
{ 
  int tmp ;

  {
#line 2168
  if (level > 110) {
#line 2169
    level = 110;
  }
  {
#line 2171
  tmp = random_roll(1, 20, op, 1);
  }
#line 2171
  if (tmp + bonus < (int )savethrow[level]) {
#line 2172
    return (0);
  }
#line 2173
  return (1);
}
}
#line 2197 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
void share_exp(object *op , sint64 exp , char const   *skill , int flag ) 
{ 
  int shares ;
  int count ;
  player *pl ;
  partylist *party ;
  int tmp ;
  sint64 share ;
  sint64 given ;
  sint64 nexp ;
  int tmp___0 ;

  {
#line 2198
  shares = 0;
#line 2198
  count = 0;
#line 2202
  if ((int )op->type != 1) {
    {
#line 2203
    change_exp(op, exp, skill, 0);
    }
#line 2204
    return;
  } else
#line 2202
  if ((unsigned long )(op->contr)->party == (unsigned long )((void *)0)) {
    {
#line 2203
    change_exp(op, exp, skill, 0);
    }
#line 2204
    return;
  }
#line 2207
  party = (op->contr)->party;
#line 2209
  pl = first_player;
  {
#line 2209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2209
    if (! ((unsigned long )pl != (unsigned long )((void *)0))) {
#line 2209
      goto while_break;
    }
#line 2210
    if (party) {
#line 2210
      if ((unsigned long )((pl->ob)->contr)->party == (unsigned long )party) {
        {
#line 2210
        tmp = on_same_map((object const   *)pl->ob, (object const   *)op);
        }
#line 2210
        if (tmp) {
#line 2211
          count ++;
#line 2212
          shares += (int )(pl->ob)->level + 4;
        }
      }
    }
#line 2209
    pl = pl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2215
  if (count == 1) {
    {
#line 2216
    change_exp(op, exp, skill, flag);
    }
  } else
#line 2215
  if ((sint64 )shares > exp) {
    {
#line 2216
    change_exp(op, exp, skill, flag);
    }
  } else {
#line 2218
    share = exp / (sint64 )shares;
#line 2218
    given = (sint64 )0;
#line 2219
    pl = first_player;
    {
#line 2219
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2219
      if (! ((unsigned long )pl != (unsigned long )((void *)0))) {
#line 2219
        goto while_break___0;
      }
#line 2220
      if (party) {
#line 2220
        if ((unsigned long )((pl->ob)->contr)->party == (unsigned long )party) {
          {
#line 2220
          tmp___0 = on_same_map((object const   *)pl->ob, (object const   *)op);
          }
#line 2220
          if (tmp___0) {
            {
#line 2221
            nexp = (sint64 )((int )(pl->ob)->level + 4) * share;
#line 2222
            change_exp(pl->ob, nexp, skill, 1);
#line 2223
            given += nexp;
            }
          }
        }
      }
#line 2219
      pl = pl->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2226
    exp -= given;
#line 2228
    change_exp(op, exp, skill, flag);
    }
  }
#line 2230
  return;
}
}
#line 2232 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
int get_cha_bonus(int stat___0 ) 
{ 
  size_t tmp ;

  {
  {
#line 2233
  tmp = get_index(stat___0, (size_t )settings.max_stat);
  }
#line 2233
  return (*(int_bonuses[4] + tmp));
}
}
#line 2236 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
int get_dex_bonus(int stat___0 ) 
{ 
  size_t tmp ;

  {
  {
#line 2237
  tmp = get_index(stat___0, (size_t )settings.max_stat);
  }
#line 2237
  return (*(int_bonuses[5] + tmp));
}
}
#line 2240 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
int get_thaco_bonus(int stat___0 ) 
{ 
  size_t tmp ;

  {
  {
#line 2241
  tmp = get_index(stat___0, (size_t )settings.max_stat);
  }
#line 2241
  return (*(int_bonuses[7] + tmp));
}
}
#line 2244 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
uint32 get_weight_limit(int stat___0 ) 
{ 
  size_t tmp ;

  {
  {
#line 2245
  tmp = get_index(stat___0, (size_t )settings.max_stat);
  }
#line 2245
  return ((uint32 )*(int_bonuses[8] + tmp));
}
}
#line 2248 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
int get_learn_spell(int stat___0 ) 
{ 
  size_t tmp ;

  {
  {
#line 2249
  tmp = get_index(stat___0, (size_t )settings.max_stat);
  }
#line 2249
  return (*(int_bonuses[3] + tmp));
}
}
#line 2252 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
int get_cleric_chance(int stat___0 ) 
{ 
  size_t tmp ;

  {
  {
#line 2253
  tmp = get_index(stat___0, (size_t )settings.max_stat);
  }
#line 2253
  return (*(int_bonuses[2] + tmp));
}
}
#line 2256 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
int get_turn_bonus(int stat___0 ) 
{ 
  size_t tmp ;

  {
  {
#line 2257
  tmp = get_index(stat___0, (size_t )settings.max_stat);
  }
#line 2257
  return (*(int_bonuses[1] + tmp));
}
}
#line 2260 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
int get_dam_bonus(int stat___0 ) 
{ 
  size_t tmp ;

  {
  {
#line 2261
  tmp = get_index(stat___0, (size_t )settings.max_stat);
  }
#line 2261
  return (*(int_bonuses[6] + tmp));
}
}
#line 2264 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
float get_speed_bonus(int stat___0 ) 
{ 
  size_t tmp ;

  {
  {
#line 2265
  tmp = get_index(stat___0, (size_t )settings.max_stat);
  }
#line 2265
  return (*(float_bonuses[1] + tmp));
}
}
#line 2268 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
int get_fear_bonus(int stat___0 ) 
{ 
  size_t tmp ;

  {
  {
#line 2269
  tmp = get_index(stat___0, (size_t )settings.max_stat);
  }
#line 2269
  return (*(int_bonuses[0] + tmp));
}
}
#line 2272 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
static float get_con_bonus(int stat___0 ) 
{ 
  size_t tmp ;

  {
  {
#line 2273
  tmp = get_index(stat___0, (size_t )settings.max_stat);
  }
#line 2273
  return (*(float_bonuses[0] + tmp));
}
}
#line 2276 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
static float get_sp_bonus(int stat___0 ) 
{ 
  size_t tmp ;

  {
  {
#line 2277
  tmp = get_index(stat___0, (size_t )settings.max_stat);
  }
#line 2277
  return (*(float_bonuses[2] + tmp));
}
}
#line 2280 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
static float get_grace_bonus(int stat___0 ) 
{ 
  size_t tmp ;

  {
  {
#line 2281
  tmp = get_index(stat___0, (size_t )settings.max_stat);
  }
#line 2281
  return (*(float_bonuses[3] + tmp));
}
}
#line 2292 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
static size_t get_index(int stat___0 , size_t max_index ) 
{ 
  size_t index___0 ;
  size_t tmp ;

  {
#line 2295
  if (stat___0 < 0) {
#line 2296
    return ((size_t )0);
  }
#line 2299
  index___0 = (size_t )stat___0;
#line 2300
  if (index___0 < max_index) {
#line 2300
    tmp = index___0;
  } else {
#line 2300
    tmp = max_index;
  }
#line 2300
  return (tmp);
}
}
#line 2320 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
static int load_table_int(int **bonuses , FILE *fp , char *bonus_name ) 
{ 
  char buf[256] ;
  char *cp ;
  int on_stat ;
  int tmp_bonus ;
  void *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 2323
  on_stat = 0;
#line 2325
  tmp = calloc((size_t )((int )settings.max_stat + 1), sizeof(int ));
#line 2325
  *bonuses = (int *)tmp;
  }
  {
#line 2327
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2327
    tmp___2 = fgets((char */* __restrict  */)(buf), 255, (FILE */* __restrict  */)fp);
    }
#line 2327
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 2327
      goto while_break;
    }
#line 2328
    if ((int )buf[0] == 35) {
#line 2329
      goto while_continue;
    }
#line 2332
    if ((int )buf[0] == 10) {
#line 2333
      goto while_continue;
    }
#line 2336
    if ((int )buf[0] == 123) {
#line 2337
      goto while_continue;
    }
#line 2339
    if ((int )buf[0] == 125) {
#line 2340
      if (on_stat - 1 != (int )settings.max_stat) {
        {
#line 2341
        LOG((LogLevel )0, "Number of bonus does not match max stat (%d!=%d, bonus=%s)\n",
            on_stat, (int )settings.max_stat, bonus_name);
        }
#line 2343
        return (1);
      } else {
#line 2345
        return (0);
      }
    }
#line 2351
    cp = buf;
    {
#line 2352
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2352
      if (! ((int )*cp != 0)) {
#line 2352
        goto while_break___0;
      }
      {
#line 2354
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 2354
        tmp___0 = __ctype_b_loc();
        }
#line 2354
        if ((int const   )*(*tmp___0 + (int )*cp) & 2048) {
#line 2354
          goto while_break___1;
        } else
#line 2354
        if ((int )*cp != 46) {
#line 2354
          if ((int )*cp != 45) {
#line 2354
            if ((int )*cp != 43) {
#line 2354
              if (! ((int )*cp != 0)) {
#line 2354
                goto while_break___1;
              }
            } else {
#line 2354
              goto while_break___1;
            }
          } else {
#line 2354
            goto while_break___1;
          }
        } else {
#line 2354
          goto while_break___1;
        }
#line 2355
        cp ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2357
      if ((int )*cp == 0) {
#line 2357
        goto while_break___0;
      }
      {
#line 2359
      tmp_bonus = atoi((char const   *)cp);
      }
#line 2361
      if (on_stat > (int )settings.max_stat) {
        {
#line 2362
        LOG((LogLevel )0, "Number of bonus entries exceed max stat (line=%s, bonus=%s)\n",
            buf, bonus_name);
        }
#line 2364
        return (1);
      }
#line 2366
      *(*bonuses + on_stat) = tmp_bonus;
#line 2367
      on_stat ++;
      {
#line 2370
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 2370
        tmp___1 = __ctype_b_loc();
        }
#line 2370
        if ((int const   )*(*tmp___1 + (int )*cp) & 2048) {
#line 2370
          goto _L;
        } else
#line 2370
        if ((int )*cp == 45) {
#line 2370
          goto _L;
        } else
#line 2370
        if ((int )*cp == 43) {
          _L: /* CIL Label */ 
#line 2370
          if (! ((int )*cp != 0)) {
#line 2370
            goto while_break___2;
          }
        } else {
#line 2370
          goto while_break___2;
        }
#line 2371
        cp ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2375
  LOG((LogLevel )0, "Reached end of file without getting close brace?  bonus=%s\n",
      bonus_name);
  }
#line 2376
  return (1);
}
}
#line 2396 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
static int load_table_float(float **bonuses , FILE *fp , char *bonus_name ) 
{ 
  char buf[256] ;
  char *cp ;
  int on_stat ;
  float tmp_bonus ;
  void *tmp ;
  unsigned short const   **tmp___0 ;
  double tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 2399
  on_stat = 0;
#line 2402
  tmp = calloc((size_t )((int )settings.max_stat + 1), sizeof(float ));
#line 2402
  *bonuses = (float *)tmp;
  }
  {
#line 2404
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2404
    tmp___3 = fgets((char */* __restrict  */)(buf), 255, (FILE */* __restrict  */)fp);
    }
#line 2404
    if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
#line 2404
      goto while_break;
    }
#line 2405
    if ((int )buf[0] == 35) {
#line 2406
      goto while_continue;
    }
#line 2409
    if ((int )buf[0] == 10) {
#line 2410
      goto while_continue;
    }
#line 2413
    if ((int )buf[0] == 123) {
#line 2414
      goto while_continue;
    }
#line 2416
    if ((int )buf[0] == 125) {
#line 2417
      if (on_stat - 1 != (int )settings.max_stat) {
        {
#line 2418
        LOG((LogLevel )0, "Number of bonus does not match max stat (%d!=%d, bonus=%s)\n",
            on_stat, (int )settings.max_stat, bonus_name);
        }
#line 2420
        return (1);
      } else {
#line 2422
        return (0);
      }
    }
#line 2428
    cp = buf;
    {
#line 2429
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2429
      if (! ((int )*cp != 0)) {
#line 2429
        goto while_break___0;
      }
      {
#line 2431
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 2431
        tmp___0 = __ctype_b_loc();
        }
#line 2431
        if ((int const   )*(*tmp___0 + (int )*cp) & 2048) {
#line 2431
          goto while_break___1;
        } else
#line 2431
        if ((int )*cp != 46) {
#line 2431
          if ((int )*cp != 45) {
#line 2431
            if ((int )*cp != 43) {
#line 2431
              if (! ((int )*cp != 0)) {
#line 2431
                goto while_break___1;
              }
            } else {
#line 2431
              goto while_break___1;
            }
          } else {
#line 2431
            goto while_break___1;
          }
        } else {
#line 2431
          goto while_break___1;
        }
#line 2432
        cp ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2434
      if ((int )*cp == 0) {
#line 2434
        goto while_break___0;
      }
      {
#line 2436
      tmp___1 = atof((char const   *)cp);
#line 2436
      tmp_bonus = (float )tmp___1;
      }
#line 2438
      if (on_stat > (int )settings.max_stat) {
        {
#line 2439
        LOG((LogLevel )0, "Number of bonus entries exceed max stat (line=%s, bonus=%s)\n",
            buf, bonus_name);
        }
#line 2441
        return (1);
      }
#line 2443
      *(*bonuses + on_stat) = tmp_bonus;
#line 2444
      on_stat ++;
      {
#line 2449
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 2449
        tmp___2 = __ctype_b_loc();
        }
#line 2449
        if ((int const   )*(*tmp___2 + (int )*cp) & 2048) {
#line 2449
          goto _L;
        } else
#line 2449
        if ((int )*cp == 45) {
#line 2449
          goto _L;
        } else
#line 2449
        if ((int )*cp == 43) {
#line 2449
          goto _L;
        } else
#line 2449
        if ((int )*cp == 46) {
          _L: /* CIL Label */ 
#line 2449
          if (! ((int )*cp != 0)) {
#line 2449
            goto while_break___2;
          }
        } else {
#line 2449
          goto while_break___2;
        }
#line 2450
        cp ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2454
  LOG((LogLevel )0, "Reached end of file without getting close brace?  bonus=%s\n",
      bonus_name);
  }
#line 2455
  return (1);
}
}
#line 2476 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/living.c"
void init_stats(int reload ) 
{ 
  char buf[256] ;
  char *cp ;
  int error ;
  int i ;
  int oldmax ;
  FILE *fp ;
  float *new_float_bonuses[4] ;
  int *new_int_bonuses[9] ;
  unsigned short const   **tmp ;
  int newmax ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 2478
  error = 0;
#line 2478
  oldmax = (int )settings.max_stat;
#line 2483
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s/stat_bonus",
           settings.confdir);
#line 2485
  memset((void *)(new_int_bonuses), 0, 9UL * sizeof(int ));
#line 2486
  memset((void *)(new_float_bonuses), 0, 4UL * sizeof(float ));
#line 2488
  fp = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"r");
  }
#line 2488
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 2489
    LOG((LogLevel )0, "Fatal error: could not open experience table (%s)\n", buf);
    }
#line 2490
    if (reload) {
#line 2490
      return;
    } else {
      {
#line 2491
      exit(1);
      }
    }
  }
  {
#line 2493
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2493
    tmp___6 = fgets((char */* __restrict  */)(buf), 255, (FILE */* __restrict  */)fp);
    }
#line 2493
    if (! ((unsigned long )tmp___6 != (unsigned long )((void *)0))) {
#line 2493
      goto while_break;
    }
#line 2494
    if ((int )buf[0] == 35) {
#line 2495
      goto while_continue;
    }
    {
#line 2498
    cp = strrchr((char const   *)(buf), '\n');
    }
#line 2498
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 2499
      *cp = (char )'\000';
    }
#line 2502
    if ((int )buf[0] == 0) {
#line 2503
      goto while_continue;
    }
#line 2506
    cp = buf;
    {
#line 2507
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2507
      tmp = __ctype_b_loc();
      }
#line 2507
      if ((int const   )*(*tmp + (int )*cp) & 8192) {
#line 2507
        if (! ((int )*cp != 0)) {
#line 2507
          goto while_break___0;
        }
      } else {
#line 2507
        goto while_break___0;
      }
#line 2508
      cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2510
    tmp___1 = strncasecmp((char const   *)cp, "max_stat", (size_t )8);
    }
#line 2510
    if (! tmp___1) {
      {
#line 2511
      tmp___0 = atoi((char const   *)(cp + 8));
#line 2511
      newmax = tmp___0;
      }
#line 2521
      if (newmax < 1) {
#line 2521
        goto _L;
      } else
#line 2521
      if (newmax < (int )settings.max_stat) {
        _L: /* CIL Label */ 
        {
#line 2522
        LOG((LogLevel )0, "Got invalid max_stat (%d) from stat_bonus file\n", newmax);
#line 2523
        fclose(fp);
        }
#line 2524
        if (reload) {
#line 2524
          return;
        } else {
          {
#line 2525
          exit(1);
          }
        }
      }
#line 2527
      settings.max_stat = (uint8 )newmax;
#line 2528
      goto while_continue;
    }
#line 2533
    if ((int )settings.max_stat == 0) {
      {
#line 2534
      LOG((LogLevel )0, "Got bonus line or otherwise unknown value before max stat! (%s)\n",
          buf);
      }
#line 2536
      if (reload) {
#line 2536
        return;
      } else {
        {
#line 2537
        exit(1);
        }
      }
    }
#line 2540
    i = 0;
    {
#line 2540
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2540
      if (! (i < 9)) {
#line 2540
        goto while_break___1;
      }
      {
#line 2541
      tmp___2 = strlen(int_bonus_names[i]);
#line 2541
      tmp___3 = strncasecmp((char const   *)cp, int_bonus_names[i], tmp___2);
      }
#line 2541
      if (! tmp___3) {
        {
#line 2542
        error = load_table_int(& new_int_bonuses[i], fp, cp);
        }
#line 2543
        goto while_break___1;
      }
#line 2540
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2549
    if (i == 9) {
#line 2550
      i = 0;
      {
#line 2550
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2550
        if (! (i < 4)) {
#line 2550
          goto while_break___2;
        }
        {
#line 2551
        tmp___4 = strlen(float_bonus_names[i]);
#line 2551
        tmp___5 = strncasecmp((char const   *)cp, float_bonus_names[i], tmp___4);
        }
#line 2551
        if (! tmp___5) {
          {
#line 2552
          error = load_table_float(& new_float_bonuses[i], fp, cp);
          }
#line 2553
          goto while_break___2;
        }
#line 2550
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2557
      if (i == 4) {
        {
#line 2558
        LOG((LogLevel )0, "Unknown line in stat_bonus file: %s\n", buf);
        }
      }
    }
#line 2561
    if (error) {
#line 2561
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2563
  fclose(fp);
#line 2569
  i = 0;
  }
  {
#line 2569
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2569
    if (! (i < 9)) {
#line 2569
      goto while_break___3;
    }
#line 2570
    if (! new_int_bonuses[i]) {
      {
#line 2571
      LOG((LogLevel )0, "No bonus loaded for %s\n", int_bonus_names[i]);
#line 2572
      error = 2;
      }
    }
#line 2569
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2576
  i = 0;
  {
#line 2576
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2576
    if (! (i < 4)) {
#line 2576
      goto while_break___4;
    }
#line 2577
    if (! new_float_bonuses[i]) {
      {
#line 2578
      LOG((LogLevel )0, "No bonus loaded for %s\n", float_bonus_names[i]);
#line 2579
      error = 2;
      }
    }
#line 2576
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2587
  if (error) {
#line 2588
    if (error == 1) {
      {
#line 2589
      LOG((LogLevel )0, "Got error reading stat_bonus: %s\n", buf);
      }
    }
#line 2591
    if (reload) {
#line 2592
      i = 0;
      {
#line 2592
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2592
        if (! (i < 9)) {
#line 2592
          goto while_break___5;
        }
#line 2593
        if (new_int_bonuses[i]) {
          {
#line 2593
          free((void *)new_int_bonuses[i]);
#line 2593
          new_int_bonuses[i] = (int *)((void *)0);
          }
        }
#line 2592
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 2594
      i = 0;
      {
#line 2594
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2594
        if (! (i < 4)) {
#line 2594
          goto while_break___6;
        }
#line 2595
        if (new_float_bonuses[i]) {
          {
#line 2595
          free((void *)new_float_bonuses[i]);
#line 2595
          new_float_bonuses[i] = (float *)((void *)0);
          }
        }
#line 2594
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 2596
      settings.max_stat = (uint8 )oldmax;
    } else {
      {
#line 2598
      exit(1);
      }
    }
  } else {
#line 2604
    i = 0;
    {
#line 2604
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2604
      if (! (i < 9)) {
#line 2604
        goto while_break___7;
      }
#line 2605
      if (int_bonuses[i]) {
        {
#line 2605
        free((void *)int_bonuses[i]);
        }
      }
#line 2606
      int_bonuses[i] = new_int_bonuses[i];
#line 2607
      new_int_bonuses[i] = (int *)((void *)0);
#line 2604
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 2610
    i = 0;
    {
#line 2610
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 2610
      if (! (i < 4)) {
#line 2610
        goto while_break___8;
      }
#line 2611
      if (float_bonuses[i]) {
        {
#line 2611
        free((void *)float_bonuses[i]);
        }
      }
#line 2612
      float_bonuses[i] = new_float_bonuses[i];
#line 2613
      new_float_bonuses[i] = (float *)((void *)0);
#line 2610
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 2616
  return;
}
}
#line 242 "../include/global.h"
int animations_allocated ;
#line 2 "../include/libproto.h"
void free_all_anim(void) ;
#line 3
void init_anim(void) ;
#line 4
int find_animation(char const   *name ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/anim.c"
void free_all_anim(void) 
{ 
  int i ;

  {
#line 44
  i = 0;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (i <= num_animations)) {
#line 44
      goto while_break;
    }
    {
#line 45
    free_string((animations + i)->name);
#line 46
    free((void *)(animations + i)->faces);
#line 44
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 48
  free((void *)animations);
  }
#line 49
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/anim.c"
void init_anim(void) 
{ 
  char buf[256] ;
  FILE *fp ;
  int num_frames ;
  int i ;
  New_Face const   *faces[256] ;
  void *tmp ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  uint8 tmp___8 ;
  int tmp___9 ;
  unsigned int face ;
  unsigned int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;

  {
  {
#line 58
  num_frames = 0;
#line 61
  animations_allocated = 9;
#line 62
  num_animations = 0;
#line 67
  tmp = malloc(10UL * sizeof(Animations ));
#line 67
  animations = (Animations *)tmp;
#line 72
  (animations + 0)->name = add_string("###none");
#line 73
  (animations + 0)->num_animations = (uint8 )1;
#line 74
  tmp___0 = malloc(sizeof(New_Face *));
#line 74
  (animations + 0)->faces = (New_Face const   **)tmp___0;
#line 75
  tmp___1 = find_face("bug.111", 0U);
#line 75
  *((animations + 0)->faces + 0) = (New_Face const   *)(new_faces + tmp___1);
#line 76
  (animations + 0)->facings = (uint8 )0;
#line 78
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s/animations",
           settings.datadir);
#line 79
  LOG((LogLevel )2, "Reading animations from %s...\n", buf);
#line 80
  fp = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"r");
  }
#line 80
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 81
    tmp___2 = __errno_location();
#line 81
    tmp___3 = strerror_local(*tmp___2, buf, sizeof(buf));
#line 81
    LOG((LogLevel )0, "Cannot open animations file %s: %s\n", buf, tmp___3);
#line 82
    exit(-1);
    }
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 84
    tmp___15 = fgets((char */* __restrict  */)(buf), 255, (FILE */* __restrict  */)fp);
    }
#line 84
    if (! ((unsigned long )tmp___15 != (unsigned long )((void *)0))) {
#line 84
      goto while_break;
    }
#line 85
    if ((int )buf[0] == 35) {
#line 86
      goto while_continue;
    }
    {
#line 87
    tmp___4 = strlen((char const   *)(buf));
    }
#line 87
    if (tmp___4 == 0UL) {
#line 88
      goto while_break;
    }
    {
#line 90
    tmp___5 = strlen((char const   *)(buf));
#line 90
    buf[tmp___5 - 1UL] = (char )'\000';
#line 91
    tmp___14 = strncmp((char const   *)(buf), "anim ", (size_t )5);
    }
#line 91
    if (tmp___14) {
      {
#line 104
      tmp___13 = strncmp((char const   *)(buf), "mina", (size_t )4);
      }
#line 104
      if (tmp___13) {
        {
#line 117
        tmp___12 = strncmp((char const   *)(buf), "facings", (size_t )7);
        }
#line 117
        if (tmp___12) {
          {
#line 124
          tmp___10 = find_face((char const   *)(buf), 4294967295U);
#line 124
          face = tmp___10;
          }
#line 125
          if (face == 4294967295U) {
            {
#line 126
            LOG((LogLevel )0, "Could not find face %s for animation %s\n", buf, (animations + num_animations)->name);
#line 128
            face = find_face("bug.111", 0U);
            }
          }
#line 130
          tmp___11 = num_frames;
#line 130
          num_frames ++;
#line 130
          faces[tmp___11] = (New_Face const   *)(new_faces + face);
        } else {
          {
#line 118
          tmp___9 = atoi((char const   *)(buf + 7));
#line 118
          tmp___8 = (uint8 )tmp___9;
#line 118
          (animations + num_animations)->facings = tmp___8;
          }
#line 118
          if (! tmp___8) {
            {
#line 119
            LOG((LogLevel )2, "Animation %s has 0 facings, line=%s\n", (animations + num_animations)->name,
                buf);
#line 121
            (animations + num_animations)->facings = (uint8 )1;
            }
          }
        }
      } else {
        {
#line 105
        tmp___7 = malloc(sizeof(New_Face *) * (unsigned long )num_frames);
#line 105
        (animations + num_animations)->faces = (New_Face const   **)tmp___7;
#line 106
        i = 0;
        }
        {
#line 106
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 106
          if (! (i < num_frames)) {
#line 106
            goto while_break___0;
          }
#line 107
          *((animations + num_animations)->faces + i) = faces[i];
#line 106
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 108
        (animations + num_animations)->num_animations = (uint8 )num_frames;
#line 109
        if (num_frames <= 1) {
          {
#line 110
          LOG((LogLevel )2, "Animation %s has only one or none face!\n", (animations + num_animations)->name);
          }
        }
#line 112
        if (num_frames % (int )(animations + num_animations)->facings) {
          {
#line 113
          LOG((LogLevel )2, "Animation %s frame numbers (%d) is not a multiple of facings (%d)\n",
              (animations + num_animations)->name, num_frames, (int )(animations + num_animations)->facings);
          }
        }
#line 116
        num_frames = 0;
      }
    } else {
#line 92
      if (num_frames) {
        {
#line 93
        LOG((LogLevel )0, "Didn\'t get a mina before %s\n", buf);
#line 94
        num_frames = 0;
        }
      }
#line 96
      num_animations ++;
#line 97
      if (num_animations == animations_allocated) {
        {
#line 98
        tmp___6 = realloc((void *)animations, sizeof(Animations ) * (unsigned long )(animations_allocated + 10));
#line 98
        animations = (Animations *)tmp___6;
#line 99
        animations_allocated += 10;
        }
      }
      {
#line 101
      (animations + num_animations)->name = add_string((char const   *)(buf + 5));
#line 102
      (animations + num_animations)->num = (uint16 )num_animations;
#line 103
      (animations + num_animations)->facings = (uint8 )1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 133
  fclose(fp);
#line 134
  LOG((LogLevel )2, "done. got (%d)\n", num_animations);
  }
#line 135
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/anim.c"
static int anim_compare(Animations const   *a , Animations const   *b ) 
{ 
  int tmp ;

  {
  {
#line 142
  tmp = strcmp((char const   *)a->name, (char const   *)b->name);
  }
#line 142
  return (tmp);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/anim.c"
int find_animation(char const   *name ) 
{ 
  int face ;
  int tmp ;

  {
  {
#line 154
  tmp = try_find_animation(name);
#line 154
  face = tmp;
  }
#line 155
  if (! face) {
    {
#line 156
    LOG((LogLevel )0, "Unable to find animation %s\n", name);
    }
  }
#line 157
  return (face);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/anim.c"
int try_find_animation(char const   *name ) 
{ 
  Animations search ;
  Animations *match ;
  void *tmp ;

  {
  {
#line 171
  search.name = name;
#line 173
  tmp = bsearch((void const   *)(& search), (void const   *)animations, (size_t )(num_animations + 1),
                sizeof(Animations ), (int (*)(void const   * , void const   * ))(& anim_compare));
#line 173
  match = (Animations *)tmp;
  }
#line 176
  if (match) {
#line 177
    return ((int )match->num);
  }
#line 178
  return (0);
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/anim.c"
void animate_object(object *op , int dir ) 
{ 
  int max_state ;
  int base_state ;
  int oldface ;
  StringBuffer *sb ;
  char *diff ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 198
  oldface = (int )(op->face)->number;
#line 200
  if (! op->animation_id) {
#line 200
    goto _L;
  } else {
#line 200
    if (op->temp_animation_id) {
#line 200
      tmp = (int )(animations + op->temp_animation_id)->num_animations;
    } else {
#line 200
      tmp = (int )(animations + op->animation_id)->num_animations;
    }
#line 200
    if (! tmp) {
      _L: /* CIL Label */ 
      {
#line 204
      LOG((LogLevel )0, "Object lacks animation.\n");
#line 205
      sb = stringbuffer_new();
#line 206
      object_dump((object const   *)op, sb);
#line 207
      diff = stringbuffer_finish(sb);
#line 208
      LOG((LogLevel )0, "%s", diff);
#line 209
      free((void *)diff);
      }
#line 210
      return;
    }
  }
#line 213
  if (op->head) {
#line 214
    dir = (int )(op->head)->direction;
#line 216
    if (op->temp_animation_id) {
#line 216
      tmp___0 = (int )(animations + op->temp_animation_id)->num_animations;
    } else {
#line 216
      tmp___0 = (int )(animations + op->animation_id)->num_animations;
    }
#line 216
    if ((op->head)->temp_animation_id) {
#line 216
      tmp___1 = (int )(animations + (op->head)->temp_animation_id)->num_animations;
    } else {
#line 216
      tmp___1 = (int )(animations + (op->head)->animation_id)->num_animations;
    }
#line 216
    if (tmp___0 == tmp___1) {
#line 217
      op->state = (op->head)->state;
    }
  } else
#line 218
  if (op->flags[0] & (1U << 24)) {
#line 219
    dir = (int )op->direction;
  }
#line 225
  if (op->temp_animation_id) {
#line 225
    tmp___2 = (int )(animations + op->temp_animation_id)->num_animations;
  } else {
#line 225
    tmp___2 = (int )(animations + op->animation_id)->num_animations;
  }
#line 225
  if (op->temp_animation_id) {
#line 225
    tmp___3 = (int )(animations + op->temp_animation_id)->facings;
  } else {
#line 225
    tmp___3 = (int )(animations + op->animation_id)->facings;
  }
#line 225
  max_state = tmp___2 / tmp___3;
#line 226
  base_state = 0;
#line 233
  if (op->temp_animation_id) {
#line 233
    tmp___11 = (int )(animations + op->temp_animation_id)->facings;
  } else {
#line 233
    tmp___11 = (int )(animations + op->animation_id)->facings;
  }
#line 233
  if (tmp___11 == 2) {
#line 234
    if (dir < 5) {
#line 235
      base_state = 0;
    } else {
#line 237
      if (op->temp_animation_id) {
#line 237
        tmp___4 = (int )(animations + op->temp_animation_id)->num_animations;
      } else {
#line 237
        tmp___4 = (int )(animations + op->animation_id)->num_animations;
      }
#line 237
      base_state = tmp___4 / 2;
    }
  } else {
#line 238
    if (op->temp_animation_id) {
#line 238
      tmp___10 = (int )(animations + op->temp_animation_id)->facings;
    } else {
#line 238
      tmp___10 = (int )(animations + op->animation_id)->facings;
    }
#line 238
    if (tmp___10 == 4) {
#line 239
      if (dir == 0) {
#line 240
        base_state = 0;
      } else {
#line 242
        if (op->temp_animation_id) {
#line 242
          tmp___5 = (int )(animations + op->temp_animation_id)->num_animations;
        } else {
#line 242
          tmp___5 = (int )(animations + op->animation_id)->num_animations;
        }
#line 242
        base_state = ((dir - 1) / 2) * (tmp___5 / 4);
      }
    } else {
#line 243
      if (op->temp_animation_id) {
#line 243
        tmp___9 = (int )(animations + op->temp_animation_id)->facings;
      } else {
#line 243
        tmp___9 = (int )(animations + op->animation_id)->facings;
      }
#line 243
      if (tmp___9 == 8) {
#line 244
        if (dir == 0) {
#line 245
          base_state = 0;
        } else {
#line 247
          if (op->temp_animation_id) {
#line 247
            tmp___6 = (int )(animations + op->temp_animation_id)->num_animations;
          } else {
#line 247
            tmp___6 = (int )(animations + op->animation_id)->num_animations;
          }
#line 247
          base_state = (dir - 1) * (tmp___6 / 8);
        }
      } else
#line 248
      if (op->flags[0] & (1U << 24)) {
#line 249
        if (op->temp_animation_id) {
#line 249
          tmp___7 = (int )(animations + op->temp_animation_id)->num_animations;
        } else {
#line 249
          tmp___7 = (int )(animations + op->animation_id)->num_animations;
        }
#line 249
        base_state = (tmp___7 / 9) * dir;
#line 250
        if (op->temp_animation_id) {
#line 250
          tmp___8 = (int )(animations + op->temp_animation_id)->num_animations;
        } else {
#line 250
          tmp___8 = (int )(animations + op->animation_id)->num_animations;
        }
#line 250
        max_state = tmp___8 / 9;
      }
    }
  }
#line 254
  if ((int )op->state >= max_state) {
#line 255
    op->state = (uint8 )0;
#line 256
    if (op->temp_animation_id) {
      {
#line 257
      op->temp_animation_id = (uint16 )0;
#line 258
      animate_object(op, dir);
      }
#line 259
      return;
    }
  }
#line 262
  if (op->temp_animation_id) {
#line 262
    op->face = *((animations + op->temp_animation_id)->faces + ((int )op->state + base_state));
  } else {
#line 262
    op->face = *((animations + op->animation_id)->faces + ((int )op->state + base_state));
  }
#line 264
  if ((unsigned long )op->face == (unsigned long )blank_face) {
#line 265
    op->invisible = (sint16 )1;
  } else
#line 272
  if ((int )op->type != 1) {
#line 272
    if ((op->arch)->clone.flags[0] & 1U) {
#line 273
      if ((int const   )(op->face)->number == 0) {
#line 274
        op->invisible = (sint16 )1;
#line 275
        op->flags[0] &= 4294967294U;
      } else {
#line 277
        op->invisible = (sint16 )0;
#line 278
        op->flags[0] |= 1U;
      }
    }
  }
#line 282
  if (op->more) {
    {
#line 283
    animate_object(op->more, dir);
    }
  }
#line 289
  if (! op->head) {
#line 289
    if (oldface != (int )(op->face)->number) {
      {
#line 290
      object_update(op, 4);
      }
    }
  }
#line 291
  return;
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/anim.c"
void apply_anim_suffix(object *who , sstring suffix ) 
{ 
  int anim ;
  object *head ;
  object *orig ;
  char buf[256] ;

  {
#line 306
  if (! who) {
    {
#line 306
    __assert_fail("who", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/anim.c",
                  306U, "apply_anim_suffix");
    }
  }
#line 307
  if (! suffix) {
    {
#line 307
    __assert_fail("suffix", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/anim.c",
                  307U, "apply_anim_suffix");
    }
  }
#line 309
  if ((int )who->temp_animation_id != 0) {
#line 311
    return;
  }
#line 313
  if ((unsigned long )who->head != (unsigned long )((void *)0)) {
#line 313
    head = who->head;
  } else {
#line 313
    head = who;
  }
  {
#line 314
  orig = head;
#line 315
  snprintf((char */* __restrict  */)(buf), (size_t )256, (char const   */* __restrict  */)"%s_%s",
           (animations + head->animation_id)->name, suffix);
#line 316
  anim = try_find_animation((char const   *)(buf));
  }
#line 317
  if (anim) {
    {
#line 318
    while (1) {
      while_continue: /* CIL Label */ ;
#line 318
      if (! ((unsigned long )head != (unsigned long )((void *)0))) {
#line 318
        goto while_break;
      }
#line 319
      head->temp_animation_id = (uint16 )anim;
#line 320
      head->temp_anim_speed = (uint8 )((int )(animations + anim)->num_animations / (int )(animations + anim)->facings);
#line 321
      head->last_anim = (uint8 )0;
#line 322
      head->state = (uint8 )0;
#line 318
      head = head->more;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 324
    animate_object(orig, (int )orig->facing);
    }
  }
#line 326
  return;
}
}
#line 78 "./../random_maps/rproto.h"
char **make_snake_layout(int xsize , int ysize ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/snake.c"
char **make_snake_layout(int xsize , int ysize ) 
{ 
  int i ;
  int j ;
  char **maze ;
  void *tmp ;
  void *tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int n_walls ;
  long tmp___3 ;
  int spacing ;
  int orientation ;
  int n_walls___0 ;
  long tmp___4 ;
  int spacing___0 ;
  int orientation___0 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  {
#line 24
  tmp = calloc(sizeof(char *), (size_t )xsize);
#line 24
  maze = (char **)tmp;
#line 25
  i = 0;
  }
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
#line 25
    if (! (i < xsize)) {
#line 25
      goto while_break;
    }
    {
#line 26
    tmp___0 = calloc(sizeof(char ), (size_t )ysize);
#line 26
    *(maze + i) = (char *)tmp___0;
#line 25
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 30
  i = 0;
  {
#line 30
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 30
    if (! (i < xsize)) {
#line 30
      goto while_break___0;
    }
#line 31
    tmp___1 = (char )'#';
#line 31
    *(*(maze + i) + (ysize - 1)) = tmp___1;
#line 31
    *(*(maze + i) + 0) = tmp___1;
#line 30
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 32
  j = 0;
  {
#line 32
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 32
    if (! (j < ysize)) {
#line 32
      goto while_break___1;
    }
#line 33
    tmp___2 = (char )'#';
#line 33
    *(*(maze + (xsize - 1)) + j) = tmp___2;
#line 33
    *(*(maze + 0) + j) = tmp___2;
#line 32
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 36
  if (xsize < 8) {
#line 37
    return (maze);
  } else
#line 36
  if (ysize < 8) {
#line 37
    return (maze);
  }
  {
#line 42
  tmp___5 = random();
  }
#line 42
  if (tmp___5 % 2L) {
    {
#line 43
    tmp___3 = random();
#line 43
    n_walls = (int )(tmp___3 % (long )((xsize - 5) / 3) + 1L);
#line 44
    spacing = xsize / (n_walls + 1);
#line 45
    orientation = 1;
#line 47
    i = spacing;
    }
    {
#line 47
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 47
      if (! (i < xsize - 3)) {
#line 47
        goto while_break___2;
      }
#line 48
      if (orientation) {
#line 49
        j = 1;
        {
#line 49
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 49
          if (! (j < ysize - 2)) {
#line 49
            goto while_break___3;
          }
#line 50
          *(*(maze + i) + j) = (char )'#';
#line 49
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 52
        *(*(maze + i) + j) = (char )'D';
      } else {
#line 54
        j = 2;
        {
#line 54
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 54
          if (! (j < ysize)) {
#line 54
            goto while_break___4;
          }
#line 55
          *(*(maze + i) + j) = (char )'#';
#line 54
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 57
        *(*(maze + i) + 1) = (char )'D';
      }
#line 59
      orientation ^= 1;
#line 47
      i += spacing;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 62
    tmp___4 = random();
#line 62
    n_walls___0 = (int )(tmp___4 % (long )((ysize - 5) / 3) + 1L);
#line 63
    spacing___0 = ysize / (n_walls___0 + 1);
#line 64
    orientation___0 = 1;
#line 66
    i = spacing___0;
    }
    {
#line 66
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 66
      if (! (i < ysize - 3)) {
#line 66
        goto while_break___5;
      }
#line 67
      if (orientation___0) {
#line 68
        j = 1;
        {
#line 68
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 68
          if (! (j < xsize - 2)) {
#line 68
            goto while_break___6;
          }
#line 69
          *(*(maze + j) + i) = (char )'#';
#line 68
          j ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 71
        *(*(maze + j) + i) = (char )'D';
      } else {
#line 73
        j = 2;
        {
#line 73
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 73
          if (! (j < xsize)) {
#line 73
            goto while_break___7;
          }
#line 74
          *(*(maze + j) + i) = (char )'#';
#line 73
          j ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 76
        *(*(maze + 1) + i) = (char )'D';
      }
#line 78
      orientation___0 ^= 1;
#line 66
      i += spacing___0;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  {
#line 83
  tmp___6 = random();
  }
#line 83
  if (tmp___6 % 2L) {
#line 84
    *(*(maze + 1) + 1) = (char )'<';
#line 85
    *(*(maze + (xsize - 2)) + (ysize - 2)) = (char )'>';
  } else {
#line 87
    *(*(maze + 1) + 1) = (char )'>';
#line 88
    *(*(maze + (xsize - 2)) + (ysize - 2)) = (char )'<';
  }
#line 91
  return (maze);
}
}
#line 120 "../include/libproto.h"
int i18n_get_language_by_code(char const   *code ) ;
#line 124
int get_language(object *op ) ;
#line 125
void i18n_init(void) ;
#line 126
void i18n_free(void) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/languages.c"
static int i18n_count  =    0;
#line 54 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/languages.c"
static struct i18n_file *i18n_files  =    (struct i18n_file *)((void *)0);
#line 56 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/languages.c"
static int i18n_default  =    -1;
#line 58 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/languages.c"
static int i18n_message_compare_code(i18n_message const   *a , i18n_message const   *b ) 
{ 
  int tmp ;

  {
  {
#line 59
  tmp = strcmp((char const   *)a->code, (char const   *)b->code);
  }
#line 59
  return (tmp);
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/languages.c"
int get_language(object *op ) 
{ 


  {
#line 69
  if (! op->contr) {
#line 70
    return (0);
  }
#line 71
  if ((op->contr)->language < 0) {
#line 72
    return (0);
  } else
#line 71
  if ((op->contr)->language >= i18n_count) {
#line 72
    return (0);
  }
#line 73
  return ((op->contr)->language);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/languages.c"
char const   *i18n(object const   *who , char const   *code ) 
{ 
  i18n_message search ;
  i18n_message *found ;
  void *tmp ;

  {
#line 85
  if (! who) {
#line 86
    return (code);
  } else
#line 85
  if (! who->contr) {
#line 86
    return (code);
  }
#line 88
  if ((who->contr)->language < 0) {
#line 89
    return (code);
  } else
#line 88
  if ((who->contr)->language >= i18n_count) {
#line 89
    return (code);
  }
  {
#line 91
  search.code = add_string(code);
#line 93
  tmp = bsearch((void const   *)(& search), (void const   *)(i18n_files + (who->contr)->language)->messages,
                (size_t )(i18n_files + (who->contr)->language)->count, sizeof(i18n_message ),
                (int (*)(void const   * , void const   * ))(& i18n_message_compare_code));
#line 93
  found = (i18n_message *)tmp;
#line 95
  free_string(search.code);
  }
#line 97
  if (found) {
#line 98
    return (found->message);
  }
#line 100
  return (code);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/languages.c"
int i18n_find_language_by_code(char const   *code ) 
{ 
  int index___0 ;
  int tmp ;

  {
#line 110
  index___0 = 0;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! (index___0 < i18n_count)) {
#line 110
      goto while_break;
    }
    {
#line 111
    tmp = strcmp(code, (i18n_files + index___0)->code);
    }
#line 111
    if (tmp == 0) {
#line 112
      return (index___0);
    }
#line 110
    index___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return (-1);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/languages.c"
int i18n_get_language_by_code(char const   *code ) 
{ 
  int try ;
  int tmp ;

  {
  {
#line 124
  tmp = i18n_find_language_by_code(code);
#line 124
  try = tmp;
  }
#line 125
  if (try != -1) {
#line 126
    return (try);
  }
#line 127
  return (i18n_default);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/languages.c"
sstring i18n_get_language_code(int language ) 
{ 


  {
#line 136
  if (language < 0) {
#line 137
    return ((i18n_files + i18n_default)->code);
  } else
#line 136
  if (language >= i18n_count) {
#line 137
    return ((i18n_files + i18n_default)->code);
  }
#line 138
  return ((i18n_files + language)->code);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/languages.c"
void i18n_list_languages(object *who ) 
{ 
  int index___0 ;

  {
#line 147
  index___0 = 0;
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! (index___0 < i18n_count)) {
#line 147
      goto while_break;
    }
    {
#line 148
    draw_ext_info_format(256, 0, (object const   *)who, (uint8 )10, (uint8 )0, "[fixed]%s: %s",
                         (i18n_files + index___0)->code, (i18n_files + index___0)->name);
#line 147
    index___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/languages.c"
static void convert_newline(char *line ) 
{ 
  char *next ;
  char buf[256] ;

  {
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 168
    next = strstr((char const   *)line, "\\n");
    }
#line 168
    if (! ((unsigned long )next != (unsigned long )((void *)0))) {
#line 168
      goto while_break;
    }
    {
#line 169
    *next = (char )'\n';
#line 170
    *(next + 1) = (char )'\000';
#line 171
    snprintf((char */* __restrict  */)(buf), (size_t )256, (char const   */* __restrict  */)"%s%s",
             line, next + 2);
#line 172
    strcpy((char */* __restrict  */)line, (char const   */* __restrict  */)(buf));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/languages.c"
void i18n_init(void) 
{ 
  char dirname[256] ;
  char filename[256] ;
  char line[4096] ;
  FILE *fp ;
  char *token ;
  DIR *dir ;
  struct dirent *file ;
  i18n_message code ;
  i18n_message *found ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 189
  snprintf((char */* __restrict  */)(dirname), sizeof(dirname), (char const   */* __restrict  */)"%s/i18n/",
           settings.datadir);
#line 191
  dir = opendir((char const   *)(dirname));
  }
#line 192
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
    {
#line 193
    LOG((LogLevel )0, "couldn\'t open i18n directory %s\n", dirname);
#line 194
    fatal(4);
    }
  }
  {
#line 197
  code.code = add_string("LN");
  }
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 199
    file = readdir(dir);
    }
#line 199
    if (! ((unsigned long )file != (unsigned long )((void *)0))) {
#line 199
      goto while_break;
    }
    {
#line 200
    tmp = strncmp((char const   *)(file->d_name), "messages.", (size_t )9);
    }
#line 200
    if (tmp != 0) {
#line 201
      goto while_continue;
    }
    {
#line 203
    snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s%s",
             dirname, file->d_name);
#line 204
    fp = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"r");
    }
#line 204
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 205
      tmp___0 = __errno_location();
#line 205
      tmp___1 = strerror_local(*tmp___0, line, sizeof(line));
#line 205
      LOG((LogLevel )0, "Cannot open i18n file %s: %s\n", filename, tmp___1);
#line 206
      fatal(4);
      }
    }
    {
#line 209
    tmp___2 = realloc((void *)i18n_files, (unsigned long )(i18n_count + 1) * sizeof(i18n_file ));
#line 209
    i18n_files = (struct i18n_file *)tmp___2;
#line 210
    (i18n_files + i18n_count)->code = add_string((char const   *)(file->d_name + 9));
#line 211
    (i18n_files + i18n_count)->count = 0;
#line 212
    (i18n_files + i18n_count)->messages = (struct i18n_message *)((void *)0);
    }
    {
#line 214
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 214
      tmp___5 = fgets((char */* __restrict  */)(line), 256, (FILE */* __restrict  */)fp);
      }
#line 214
      if (! tmp___5) {
#line 214
        goto while_break___0;
      }
#line 215
      if ((int )line[0] != 35) {
        {
#line 216
        tmp___3 = strlen((char const   *)(line));
#line 216
        line[tmp___3 - 1UL] = (char )'\000';
#line 218
        tmp___4 = realloc((void *)(i18n_files + i18n_count)->messages, (unsigned long )((i18n_files + i18n_count)->count + 1) * sizeof(i18n_message ));
#line 218
        (i18n_files + i18n_count)->messages = (struct i18n_message *)tmp___4;
#line 220
        token = strtok((char */* __restrict  */)(line), (char const   */* __restrict  */)"|");
#line 221
        convert_newline(token);
#line 222
        ((i18n_files + i18n_count)->messages + (i18n_files + i18n_count)->count)->code = add_string((char const   *)token);
#line 223
        token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"|");
        }
#line 224
        if ((unsigned long )token != (unsigned long )((void *)0)) {
          {
#line 225
          convert_newline(token);
#line 226
          ((i18n_files + i18n_count)->messages + (i18n_files + i18n_count)->count)->message = add_string((char const   *)token);
          }
        } else {
          {
#line 228
          ((i18n_files + i18n_count)->messages + (i18n_files + i18n_count)->count)->message = add_refcount(((i18n_files + i18n_count)->messages + (i18n_files + i18n_count)->count)->code);
          }
        }
#line 230
        ((i18n_files + i18n_count)->count) ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 233
    fclose(fp);
#line 235
    qsort((void *)(i18n_files + i18n_count)->messages, (size_t )(i18n_files + i18n_count)->count,
          sizeof(i18n_message ), (int (*)(void const   * , void const   * ))(& i18n_message_compare_code));
#line 236
    tmp___6 = bsearch((void const   *)(& code), (void const   *)(i18n_files + i18n_count)->messages,
                      (size_t )(i18n_files + i18n_count)->count, sizeof(i18n_message ),
                      (int (*)(void const   * , void const   * ))(& i18n_message_compare_code));
#line 236
    found = (i18n_message *)tmp___6;
    }
#line 237
    if ((unsigned long )found == (unsigned long )((void *)0)) {
      {
#line 238
      LOG((LogLevel )0, "couldn\'t find language name (LN) for %s\n", filename);
#line 239
      fatal(4);
      }
    }
    {
#line 242
    (i18n_files + i18n_count)->name = found->message;
#line 243
    LOG((LogLevel )2, "Read %i strings for language: %s\n", (i18n_files + i18n_count)->count,
        found->message);
#line 245
    tmp___7 = strcmp((i18n_files + i18n_count)->code, "en");
    }
#line 245
    if (tmp___7 == 0) {
#line 246
      i18n_default = i18n_count;
    }
#line 248
    i18n_count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  closedir(dir);
#line 252
  free_string(code.code);
  }
#line 254
  if (i18n_default == -1) {
    {
#line 255
    LOG((LogLevel )0, "couldn\'t find default language en!\n");
#line 256
    fatal(4);
    }
  }
#line 258
  return;
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/languages.c"
void i18n_free(void) 
{ 
  int file ;
  int message ;

  {
#line 266
  file = 0;
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 266
    if (! (file < i18n_count)) {
#line 266
      goto while_break;
    }
    {
#line 267
    free_string((i18n_files + file)->code);
#line 268
    message = 0;
    }
    {
#line 268
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 268
      if (! (message < (i18n_files + file)->count)) {
#line 268
        goto while_break___0;
      }
      {
#line 269
      free_string(((i18n_files + file)->messages + message)->code);
#line 270
      free_string(((i18n_files + file)->messages + message)->message);
#line 268
      message ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 272
    free((void *)(i18n_files + file)->messages);
#line 266
    file ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 274
  free((void *)i18n_files);
#line 275
  i18n_files = (struct i18n_file *)((void *)0);
#line 276
  i18n_count = 0;
  }
#line 277
  return;
}
}
#line 157 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1), __leaf__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 62 "../include/libproto.h"
sint64 new_exp(object const   *ob ) ;
#line 63
int has_ability(object const   *ob ) ;
#line 64
void init_experience(void) ;
#line 65
void dump_experience(void) ;
#line 66
void free_experience(void) ;
#line 291
extern object *object_find_by_type(object const   *who , int type ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/exp.c"
sint64 *levels  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/exp.c"
static float const   exp_att_mult[26]  = 
#line 44
  {      (float const   )0.0,      (float const   )0.0,      (float const   )0.0,      (float const   )0.0, 
        (float const   )0.0,      (float const   )0.0,      (float const   )0.4,      (float const   )1.5, 
        (float const   )0.0,      (float const   )0.1,      (float const   )0.3,      (float const   )0.1, 
        (float const   )0.3,      (float const   )0.0,      (float const   )0.0,      (float const   )0.0, 
        (float const   )0.0,      (float const   )0.0,      (float const   )0.0,      (float const   )0.0, 
        (float const   )0.5,      (float const   )0.1,      (float const   )0.2,      (float const   )0.0, 
        (float const   )0.5,      (float const   )0.2};
#line 73 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/exp.c"
static float const   exp_prot_mult[26]  = 
#line 73
  {      (float const   )0.4,      (float const   )0.5,      (float const   )0.1,      (float const   )0.1, 
        (float const   )0.1,      (float const   )0.1,      (float const   )0.1,      (float const   )0.1, 
        (float const   )0.1,      (float const   )0.1,      (float const   )0.1,      (float const   )0.0, 
        (float const   )0.1,      (float const   )0.1,      (float const   )0.1,      (float const   )0.0, 
        (float const   )0.0,      (float const   )0.0,      (float const   )0.0,      (float const   )0.0, 
        (float const   )0.0,      (float const   )0.1,      (float const   )0.0,      (float const   )0.0, 
        (float const   )0.0,      (float const   )0.1};
#line 116 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/exp.c"
sint64 new_exp(object const   *ob ) 
{ 
  double att_mult ;
  double prot_mult ;
  double spec_mult ;
  double exp ;
  int i ;
  long mask ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  float tmp___3 ;

  {
#line 120
  mask = 1L;
#line 122
  spec_mult = 1.0;
#line 122
  prot_mult = spec_mult;
#line 122
  att_mult = prot_mult;
#line 123
  i = 0;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! (i < 26)) {
#line 123
      goto while_break;
    }
#line 124
    mask = (long )(1 << i);
#line 125
    att_mult += (double )(exp_att_mult[i] * (float const   )(((long )ob->attacktype & mask) != 0L));
#line 135
    prot_mult += (double )(exp_prot_mult[i] * (float const   )ob->resist[i]) / 10.0;
#line 123
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  if (prot_mult < (double )0) {
#line 139
    prot_mult = (double )1;
  }
#line 141
  spec_mult += (((((((0.3 * (double )((ob->flags[0] & (1U << 21)) != 0U) + 0.5 * (double )((ob->flags[1] & 1U) != 0U)) + 0.3 * (double )((ob->flags[1] & (1U << 1)) != 0U)) + 0.1 * (double )((ob->flags[1] & (1U << 7)) != 0U)) + 0.3 * (double )((ob->flags[1] & (1U << 8)) != 0U)) + 1.0 * (double )((ob->flags[1] & (1U << 9)) != 0U)) + 0.1 * (double )((ob->flags[1] & (1U << 21)) != 0U)) + 0.2 * (double )((ob->flags[1] & (1U << 22)) != 0U)) + 0.1 * (double )((ob->flags[1] & (1U << 23)) != 0U);
#line 151
  if ((int const   )ob->stats.maxhp > 5) {
#line 151
    exp = (double )ob->stats.maxhp;
  } else {
#line 151
    exp = (double )5;
  }
#line 152
  if (ob->flags[1] & (1U << 20)) {
    {
#line 152
    tmp___2 = has_ability(ob);
    }
#line 152
    if (tmp___2) {
#line 152
      if ((int const   )ob->stats.maxsp < 80) {
#line 152
        tmp___0 = (int const   )ob->stats.maxsp;
      } else {
#line 152
        tmp___0 = (int const   )80;
      }
#line 152
      tmp___1 = (40 + (int )tmp___0) / 40;
    } else {
#line 152
      tmp___1 = 1;
    }
  } else {
#line 152
    tmp___1 = 1;
  }
#line 152
  exp *= (double )tmp___1;
#line 153
  exp *= (((80.0 / (70.0 + (double )ob->stats.wc)) * (80.0 / (70.0 + (double )ob->stats.ac))) * (50.0 + (double )ob->stats.dam)) / 50.0;
#line 154
  exp *= (att_mult * prot_mult) * spec_mult;
#line 156
  if (ob->speed < (float const   )0) {
#line 156
    tmp___3 = - ob->speed;
  } else {
#line 156
    tmp___3 = ob->speed;
  }
#line 156
  exp *= 2.0 / (2.0 - (double )tmp___3);
#line 157
  exp *= (20.0 + (double )ob->stats.Con) / 20.0;
#line 158
  if (ob->flags[2] & (1U << 3)) {
#line 159
    exp /= (double )2;
  }
#line 161
  return ((sint64 )exp);
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/exp.c"
int has_ability(object const   *ob ) 
{ 
  object *tmp ;
  object *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 170
  tmp = object_find_by_type(ob, 101);
  }
#line 170
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 170
    tmp___1 = 1;
  } else {
    {
#line 170
    tmp___0 = object_find_by_type(ob, 85);
    }
#line 170
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 170
      tmp___1 = 1;
    } else {
#line 170
      tmp___1 = 0;
    }
  }
#line 170
  return (tmp___1);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/exp.c"
void init_experience(void) 
{ 
  char buf[256] ;
  char *cp ;
  int lastlevel ;
  sint64 lastexp ;
  sint64 tmpexp ;
  FILE *fp ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  long long tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 185
  lastlevel = 0;
#line 186
  lastexp = (sint64 )-1;
#line 189
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s/exp_table",
           settings.confdir);
#line 191
  fp = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"r");
  }
#line 191
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 192
    LOG((LogLevel )0, "Fatal error: could not open experience table (%s)\n", buf);
#line 193
    exit(1);
    }
  }
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 195
    tmp___7 = fgets((char */* __restrict  */)(buf), 255, (FILE */* __restrict  */)fp);
    }
#line 195
    if (! ((unsigned long )tmp___7 != (unsigned long )((void *)0))) {
#line 195
      goto while_break;
    }
#line 196
    if ((int )buf[0] == 35) {
#line 197
      goto while_continue;
    }
    {
#line 200
    cp = strrchr((char const   *)(buf), '\n');
    }
#line 200
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 201
      *cp = (char )'\000';
    }
#line 204
    if ((int )buf[0] == 0) {
#line 205
      goto while_continue;
    }
#line 206
    cp = buf;
    {
#line 207
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 207
      tmp = __ctype_b_loc();
      }
#line 207
      if ((int const   )*(*tmp + (int )*cp) & 8192) {
#line 207
        if (! ((int )*cp != 0)) {
#line 207
          goto while_break___0;
        }
      } else {
#line 207
        goto while_break___0;
      }
#line 208
      cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 209
    tmp___2 = strncasecmp((char const   *)cp, "max_level", (size_t )9);
    }
#line 209
    if (! tmp___2) {
#line 210
      if (settings.max_level) {
        {
#line 211
        LOG((LogLevel )2, "Got more than one max_level value from exp_table file?\n");
#line 212
        free((void *)levels);
        }
      }
      {
#line 214
      tmp___0 = atoi((char const   *)(cp + 9));
#line 214
      settings.max_level = (sint16 )tmp___0;
      }
#line 215
      if (! settings.max_level) {
        {
#line 216
        LOG((LogLevel )2, "Got invalid max_level from exp_table file? %s\n", buf);
        }
      } else {
        {
#line 218
        tmp___1 = calloc((size_t )((int )settings.max_level + 1), sizeof(sint64 ));
#line 218
        levels = (sint64 *)tmp___1;
        }
      }
    }
    {
#line 221
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 221
      tmp___6 = __ctype_b_loc();
      }
#line 221
      if ((int const   )*(*tmp___6 + (int )*cp) & 2048) {
#line 221
        if (! ((int )*cp != 0)) {
#line 221
          goto while_break___1;
        }
      } else {
#line 221
        goto while_break___1;
      }
#line 222
      if (! settings.max_level) {
        {
#line 223
        LOG((LogLevel )0, "max_level is not set in exp_table file.  Did you remember to update it?\n");
#line 224
        exit(1);
        }
      }
      {
#line 227
      tmp___3 = atoll((char const   *)cp);
#line 227
      tmpexp = (sint64 )tmp___3;
      }
#line 231
      if (tmpexp <= lastexp) {
        {
#line 232
        LOG((LogLevel )0, "Experience for level %d is lower than previous level (%ld <= %ld)\n",
            lastlevel + 1, tmpexp, lastexp);
#line 233
        exit(1);
        }
      }
#line 235
      lastlevel ++;
#line 236
      if (lastlevel > (int )settings.max_level) {
        {
#line 237
        LOG((LogLevel )0, "Too many levels specified in table (%d > %d)\n", lastlevel,
            (int )settings.max_level);
#line 238
        exit(1);
        }
      }
#line 240
      *(levels + lastlevel) = tmpexp;
#line 241
      lastexp = tmpexp;
      {
#line 245
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 245
        tmp___4 = __ctype_b_loc();
        }
#line 245
        if ((int const   )*(*tmp___4 + (int )*cp) & 2048) {
#line 245
          if (! ((int )*cp != 0)) {
#line 245
            goto while_break___2;
          }
        } else {
#line 245
          goto while_break___2;
        }
#line 246
        cp ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 247
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 247
        tmp___5 = __ctype_b_loc();
        }
#line 247
        if ((int const   )*(*tmp___5 + (int )*cp) & 2048) {
#line 247
          goto while_break___3;
        } else
#line 247
        if (! ((int )*cp != 0)) {
#line 247
          goto while_break___3;
        }
#line 248
        cp ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 251
  fclose(fp);
  }
#line 252
  if ((int )settings.max_level == 0) {
    {
#line 253
    LOG((LogLevel )0, "Fatal: exp_table does not have any level definition or not %d as defined, found %d.\n",
        (int )settings.max_level, lastlevel);
#line 254
    exit(1);
    }
  } else
#line 252
  if (lastlevel != (int )settings.max_level) {
    {
#line 253
    LOG((LogLevel )0, "Fatal: exp_table does not have any level definition or not %d as defined, found %d.\n",
        (int )settings.max_level, lastlevel);
#line 254
    exit(1);
    }
  }
#line 256
  if (lastlevel != (int )settings.max_level) {
#line 256
    if (lastlevel != 0) {
      {
#line 257
      LOG((LogLevel )0, "Warning: exp_table does not have %d entries (%d)\n", (int )settings.max_level,
          lastlevel);
#line 258
      exit(1);
      }
    }
  }
#line 260
  return;
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/exp.c"
void dump_experience(void) 
{ 
  int i ;

  {
#line 269
  i = 1;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! (i <= (int )settings.max_level)) {
#line 269
      goto while_break;
    }
    {
#line 270
    fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%4d %20ld\n",
            i, *(levels + i));
#line 269
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 272
  exit(0);
  }
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/exp.c"
void free_experience(void) 
{ 


  {
  {
#line 279
  free((void *)levels);
#line 279
  levels = (sint64 *)((void *)0);
  }
#line 280
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 200 "../include/global.h"
godlink *first_god ;
#line 119 "../include/stringbuffer.h"
void stringbuffer_append_stringbuffer(StringBuffer *sb , StringBuffer const   *sb2 ) ;
#line 127
size_t stringbuffer_length(StringBuffer *sb ) ;
#line 76 "../include/libproto.h"
void init_gods(void) ;
#line 77
godlink *get_rand_god(void) ;
#line 78
object const   *pntr_to_god_obj(godlink *godlnk ) ;
#line 79
int describe_god(object const   *god , int what , StringBuffer *buf , size_t maxlen ) ;
#line 80
void free_all_god(void) ;
#line 81
void dump_gods(void) ;
#line 106
StringBuffer *describe_resistance(object const   *op , int newline , StringBuffer *buf ) ;
#line 341
extern int nstrtok(char const   *buf1 , char const   *buf2 ) ;
#line 342
extern char *strtoktolin(char const   *buf1 , char const   *buf2 , char *retbuf ,
                         size_t size ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/holy.c"
static void add_god_to_list(archetype *god_arch ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/holy.c"
static godlink *init_godslist(void) 
{ 
  godlink *gl ;
  void *tmp ;

  {
  {
#line 50
  tmp = malloc(sizeof(godlink ));
#line 50
  gl = (godlink *)tmp;
  }
#line 51
  if ((unsigned long )gl == (unsigned long )((void *)0)) {
    {
#line 52
    fatal(0);
    }
  }
#line 53
  gl->name = (char const   *)((void *)0);
#line 54
  gl->arch = (struct archt *)((void *)0);
#line 55
  gl->id = 0;
#line 56
  gl->next = (struct glnk *)((void *)0);
#line 58
  return (gl);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/holy.c"
void init_gods(void) 
{ 
  archetype *at ;

  {
  {
#line 66
  at = (archetype *)((void *)0);
#line 68
  LOG((LogLevel )2, "Initializing gods...\n");
#line 69
  at = first_archetype;
  }
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! ((unsigned long )at != (unsigned long )((void *)0))) {
#line 69
      goto while_break;
    }
#line 70
    if ((int )at->clone.type == 50) {
      {
#line 71
      add_god_to_list(at);
      }
    }
#line 69
    at = at->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 73
  LOG((LogLevel )2, "done.\n");
  }
#line 74
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/holy.c"
static void add_god_to_list(archetype *god_arch ) 
{ 
  godlink *god ;

  {
#line 85
  if (! god_arch) {
    {
#line 86
    LOG((LogLevel )0, "ERROR: Tried to add null god to list!\n");
    }
#line 87
    return;
  }
  {
#line 90
  god = init_godslist();
#line 92
  god->arch = god_arch;
#line 93
  god->name = add_string(god_arch->clone.name);
  }
#line 94
  if (! first_god) {
#line 95
    god->id = 1;
  } else {
#line 97
    god->id = first_god->id + 1;
#line 98
    god->next = first_god;
  }
#line 100
  first_god = god;
#line 105
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/holy.c"
godlink *get_rand_god(void) 
{ 
  godlink *god ;
  int i ;
  long tmp ;

  {
#line 114
  god = first_god;
#line 117
  if (god) {
    {
#line 118
    tmp = random();
#line 118
    i = (int )(tmp % (long )god->id + 1L);
    }
    {
#line 118
    while (1) {
      while_continue: /* CIL Label */ ;
#line 118
      if (! god) {
#line 118
        goto while_break;
      }
#line 119
      if (god->id == i) {
#line 120
        goto while_break;
      }
#line 118
      god = god->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 122
  if (! god) {
    {
#line 123
    LOG((LogLevel )0, "get_rand_god(): can\'t find a random god!\n");
    }
  }
#line 124
  return (god);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/holy.c"
object const   *pntr_to_god_obj(godlink *godlnk ) 
{ 


  {
#line 136
  if (godlnk) {
#line 136
    if (godlnk->arch) {
#line 137
      return ((object const   *)(& (godlnk->arch)->clone));
    }
  }
#line 138
  return ((object const   *)((void *)0));
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/holy.c"
int describe_god(object const   *god , int what , StringBuffer *buf , size_t maxlen ) 
{ 
  int hassomething ;
  int real ;
  char temp[4096] ;
  StringBuffer *add ;
  char const   *name ;
  char *tmp ;
  int tmp___0 ;
  int has_effect ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int has_effect___0 ;
  int tmpvar ;
  char tmpbuf[256] ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  char *cp ;
  StringBuffer *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  int i ;
  int tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  char *cp___0 ;
  StringBuffer *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  size_t tmp___34 ;
  size_t tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  size_t tmp___38 ;
  size_t tmp___39 ;

  {
#line 150
  hassomething = 0;
#line 150
  real = 0;
#line 155
  name = (char const   *)god->name;
#line 158
  if (! buf) {
    {
#line 158
    __assert_fail("buf", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/holy.c",
                  158U, "describe_god");
    }
  }
  {
#line 159
  stringbuffer_append_printf(buf, "This document contains knowledge concerning the diety %s",
                             name);
#line 162
  tmp___0 = nstrtok((char const   *)god->msg, ",");
  }
#line 162
  if (tmp___0 > 0) {
    {
#line 163
    stringbuffer_append_string(buf, ", known as");
#line 164
    tmp = strtoktolin((char const   *)god->msg, ",", temp, sizeof(temp));
#line 164
    stringbuffer_append_string(buf, (char const   *)tmp);
    }
  } else {
    {
#line 166
    stringbuffer_append_string(buf, "...");
    }
  }
  {
#line 168
  stringbuffer_append_string(buf, "\n ---\n");
  }
#line 170
  if (what & 64) {
    {
#line 172
    has_effect = 0;
#line 174
    add = stringbuffer_new();
#line 175
    stringbuffer_append_printf(add, "It is rarely known fact that the priests of %s are mystically transformed. Effects of this include:\n",
                               name);
    }
#line 177
    if (god->path_attuned) {
      {
#line 178
      has_effect = 1;
#line 179
      describe_spellpath_attenuation("Attuned", (int )god->path_attuned, add);
      }
    }
#line 181
    if (god->path_repelled) {
      {
#line 182
      has_effect = 1;
#line 183
      describe_spellpath_attenuation("Repelled", (int )god->path_repelled, add);
      }
    }
#line 185
    if (god->path_denied) {
      {
#line 186
      has_effect = 1;
#line 187
      describe_spellpath_attenuation("Denied", (int )god->path_denied, add);
      }
    }
#line 189
    if (has_effect) {
      {
#line 190
      stringbuffer_append_string(add, "\n ---\n");
      }
#line 192
      if (maxlen == 0UL) {
        {
#line 193
        stringbuffer_append_stringbuffer(buf, (StringBuffer const   *)add);
#line 194
        tmp___1 = stringbuffer_finish(add);
#line 194
        free((void *)tmp___1);
#line 195
        hassomething = 1;
        }
      } else {
        {
#line 192
        tmp___3 = stringbuffer_length(add);
#line 192
        tmp___4 = stringbuffer_length(buf);
        }
#line 192
        if (tmp___3 + tmp___4 < maxlen) {
          {
#line 193
          stringbuffer_append_stringbuffer(buf, (StringBuffer const   *)add);
#line 194
          tmp___1 = stringbuffer_finish(add);
#line 194
          free((void *)tmp___1);
#line 195
          hassomething = 1;
          }
        } else {
          {
#line 197
          tmp___2 = stringbuffer_finish(add);
#line 197
          free((void *)tmp___2);
          }
#line 198
          return (real);
        }
      }
    } else {
      {
#line 201
      tmp___5 = stringbuffer_finish(add);
#line 201
      free((void *)tmp___5);
      }
    }
#line 203
    what |= 64;
  }
#line 206
  if (what & 32) {
    {
#line 207
    has_effect___0 = 0;
#line 210
    add = stringbuffer_new();
#line 211
    stringbuffer_append_printf(add, "\nThe priests of %s are known to make cast a mighty prayer of possession which gives the recipient ",
                               name);
#line 213
    tmpvar = 0;
    }
    {
#line 213
    while (1) {
      while_continue: /* CIL Label */ ;
#line 213
      if (! (tmpvar < 26)) {
#line 213
        goto while_break;
      }
#line 214
      if ((int )god->resist[tmpvar] == 100) {
        {
#line 215
        has_effect___0 = 1;
#line 216
        snprintf((char */* __restrict  */)(tmpbuf), (size_t )256, (char const   */* __restrict  */)"Immunity to %s",
                 attacktype_desc[tmpvar]);
        }
      }
#line 213
      tmpvar ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 219
    if (has_effect___0) {
      {
#line 220
      stringbuffer_append_printf(add, "%s\n ---\n", tmpbuf);
      }
#line 221
      if (maxlen == 0UL) {
        {
#line 222
        stringbuffer_append_stringbuffer(buf, (StringBuffer const   *)add);
#line 223
        tmp___6 = stringbuffer_finish(add);
#line 223
        free((void *)tmp___6);
#line 224
        hassomething = 1;
        }
      } else {
        {
#line 221
        tmp___8 = stringbuffer_length(add);
#line 221
        tmp___9 = stringbuffer_length(buf);
        }
#line 221
        if (tmp___8 + tmp___9 < maxlen) {
          {
#line 222
          stringbuffer_append_stringbuffer(buf, (StringBuffer const   *)add);
#line 223
          tmp___6 = stringbuffer_finish(add);
#line 223
          free((void *)tmp___6);
#line 224
          hassomething = 1;
          }
        } else {
          {
#line 226
          tmp___7 = stringbuffer_finish(add);
#line 226
          free((void *)tmp___7);
          }
#line 227
          return (real);
        }
      }
    } else {
      {
#line 230
      tmp___10 = stringbuffer_finish(add);
#line 230
      free((void *)tmp___10);
      }
    }
#line 232
    real |= 32;
  }
#line 235
  if (what & 16) {
    {
#line 236
    tmp___11 = describe_resistance(god, 1, (StringBuffer *)((void *)0));
#line 236
    tmp___12 = stringbuffer_finish(tmp___11);
#line 236
    cp = tmp___12;
    }
#line 238
    if (*cp) {
      {
#line 239
      add = stringbuffer_new();
#line 240
      stringbuffer_append_printf(add, "\nThe priests of %s are known to be able to bestow a blessing which makes the recipient %s\n ---\n",
                                 name, cp);
      }
#line 242
      if (maxlen == 0UL) {
        {
#line 243
        stringbuffer_append_stringbuffer(buf, (StringBuffer const   *)add);
#line 244
        tmp___13 = stringbuffer_finish(add);
#line 244
        free((void *)tmp___13);
#line 245
        hassomething = 1;
        }
      } else {
        {
#line 242
        tmp___15 = stringbuffer_length(add);
#line 242
        tmp___16 = stringbuffer_length(buf);
        }
#line 242
        if (tmp___15 + tmp___16 < maxlen) {
          {
#line 243
          stringbuffer_append_stringbuffer(buf, (StringBuffer const   *)add);
#line 244
          tmp___13 = stringbuffer_finish(add);
#line 244
          free((void *)tmp___13);
#line 245
          hassomething = 1;
          }
        } else {
          {
#line 247
          tmp___14 = stringbuffer_finish(add);
#line 247
          free((void *)tmp___14);
          }
#line 248
          return (real);
        }
      }
    }
    {
#line 251
    free((void *)cp);
#line 252
    real |= 16;
    }
  }
#line 255
  if (what & 8) {
#line 256
    if (god->race) {
#line 256
      if (! (god->path_denied & 64U)) {
        {
#line 257
        tmp___17 = nstrtok((char const   *)god->race, ",");
#line 257
        i = tmp___17;
#line 258
        add = stringbuffer_new();
#line 259
        stringbuffer_append_printf(add, "Creatures sacred to %s include the\n", name);
        }
#line 261
        if (i > 1) {
          {
#line 262
          tmp___18 = strtoktolin((char const   *)god->race, ",", temp, sizeof(temp));
#line 262
          stringbuffer_append_printf(add, "following races:%s\n ---\n", tmp___18);
          }
        } else {
          {
#line 264
          tmp___19 = strtoktolin((char const   *)god->race, ",", temp, sizeof(temp));
#line 264
          stringbuffer_append_printf(add, "race of %s\n ---\n", tmp___19);
          }
        }
#line 266
        if (maxlen == 0UL) {
          {
#line 267
          stringbuffer_append_stringbuffer(buf, (StringBuffer const   *)add);
#line 268
          tmp___20 = stringbuffer_finish(add);
#line 268
          free((void *)tmp___20);
#line 269
          hassomething = 1;
          }
        } else {
          {
#line 266
          tmp___22 = stringbuffer_length(add);
#line 266
          tmp___23 = stringbuffer_length(buf);
          }
#line 266
          if (tmp___22 + tmp___23 < maxlen) {
            {
#line 267
            stringbuffer_append_stringbuffer(buf, (StringBuffer const   *)add);
#line 268
            tmp___20 = stringbuffer_finish(add);
#line 268
            free((void *)tmp___20);
#line 269
            hassomething = 1;
            }
          } else {
            {
#line 271
            tmp___21 = stringbuffer_finish(add);
#line 271
            free((void *)tmp___21);
            }
#line 272
            return (real);
          }
        }
      }
    }
#line 275
    real |= 8;
  }
#line 278
  if (what & 4) {
    {
#line 280
    tmp___24 = describe_resistance(god, 1, (StringBuffer *)((void *)0));
#line 280
    cp___0 = stringbuffer_finish(tmp___24);
    }
#line 282
    if (*cp___0) {
      {
#line 283
      add = stringbuffer_new();
#line 284
      stringbuffer_append_printf(add, "%s has a potent aura which is extended to faithful priests. The effects of this aura include:\n%s\n ---\n",
                                 name, cp___0);
      }
#line 286
      if (maxlen == 0UL) {
        {
#line 287
        stringbuffer_append_stringbuffer(buf, (StringBuffer const   *)add);
#line 288
        tmp___25 = stringbuffer_finish(add);
#line 288
        free((void *)tmp___25);
#line 289
        hassomething = 1;
        }
      } else {
        {
#line 286
        tmp___27 = stringbuffer_length(add);
#line 286
        tmp___28 = stringbuffer_length(buf);
        }
#line 286
        if (tmp___27 + tmp___28 < maxlen) {
          {
#line 287
          stringbuffer_append_stringbuffer(buf, (StringBuffer const   *)add);
#line 288
          tmp___25 = stringbuffer_finish(add);
#line 288
          free((void *)tmp___25);
#line 289
          hassomething = 1;
          }
        } else {
          {
#line 291
          tmp___26 = stringbuffer_finish(add);
#line 291
          free((void *)tmp___26);
          }
#line 292
          return (real);
        }
      }
    }
    {
#line 295
    free((void *)cp___0);
#line 296
    real |= 4;
    }
  }
#line 299
  if (what & 2) {
#line 300
    if (god->slaying) {
#line 300
      if (! (god->path_denied & 65536U)) {
        {
#line 301
        add = stringbuffer_new();
#line 302
        stringbuffer_append_printf(add, "The holy words of %s have the power to slay creatures belonging to the ",
                                   name);
#line 304
        tmp___31 = nstrtok((char const   *)god->slaying, ",");
        }
#line 304
        if (tmp___31 > 1) {
          {
#line 305
          tmp___29 = strtoktolin((char const   *)god->slaying, ",", temp, sizeof(temp));
#line 305
          stringbuffer_append_printf(add, "following races:%s\n ---\n", tmp___29);
          }
        } else {
          {
#line 307
          tmp___30 = strtoktolin((char const   *)god->slaying, ",", temp, sizeof(temp));
#line 307
          stringbuffer_append_printf(add, "race of%s\n ---\n", tmp___30);
          }
        }
#line 309
        if (maxlen == 0UL) {
          {
#line 310
          stringbuffer_append_stringbuffer(buf, (StringBuffer const   *)add);
#line 311
          tmp___32 = stringbuffer_finish(add);
#line 311
          free((void *)tmp___32);
#line 312
          hassomething = 1;
          }
        } else {
          {
#line 309
          tmp___34 = stringbuffer_length(add);
#line 309
          tmp___35 = stringbuffer_length(buf);
          }
#line 309
          if (tmp___34 + tmp___35 < maxlen) {
            {
#line 310
            stringbuffer_append_stringbuffer(buf, (StringBuffer const   *)add);
#line 311
            tmp___32 = stringbuffer_finish(add);
#line 311
            free((void *)tmp___32);
#line 312
            hassomething = 1;
            }
          } else {
            {
#line 314
            tmp___33 = stringbuffer_finish(add);
#line 314
            free((void *)tmp___33);
            }
#line 315
            return (real);
          }
        }
      }
    }
#line 318
    real |= 2;
  }
#line 321
  if (what & 1) {
#line 322
    if (god->title) {
      {
#line 323
      add = stringbuffer_new();
#line 324
      stringbuffer_append_printf(add, "The gods %s and %s are enemies.\n ---\n", name,
                                 god->title);
      }
#line 326
      if (maxlen == 0UL) {
        {
#line 327
        stringbuffer_append_stringbuffer(buf, (StringBuffer const   *)add);
#line 328
        tmp___36 = stringbuffer_finish(add);
#line 328
        free((void *)tmp___36);
#line 329
        hassomething = 1;
        }
      } else {
        {
#line 326
        tmp___38 = stringbuffer_length(add);
#line 326
        tmp___39 = stringbuffer_length(buf);
        }
#line 326
        if (tmp___38 + tmp___39 < maxlen) {
          {
#line 327
          stringbuffer_append_stringbuffer(buf, (StringBuffer const   *)add);
#line 328
          tmp___36 = stringbuffer_finish(add);
#line 328
          free((void *)tmp___36);
#line 329
          hassomething = 1;
          }
        } else {
          {
#line 331
          tmp___37 = stringbuffer_finish(add);
#line 331
          free((void *)tmp___37);
          }
#line 332
          return (real);
        }
      }
    }
#line 335
    real |= 1;
  }
#line 338
  if (hassomething == 0) {
    {
#line 340
    stringbuffer_append_string(buf, " Unfortunately the rest of the information is hopelessly garbled!\n ---\n");
    }
  }
#line 343
  return (real);
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/holy.c"
void free_all_god(void) 
{ 
  godlink *god ;
  godlink *godnext ;

  {
  {
#line 352
  LOG((LogLevel )2, "Freeing god information\n");
#line 353
  god = first_god;
  }
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 353
    if (! god) {
#line 353
      goto while_break;
    }
#line 354
    godnext = god->next;
#line 355
    if (god->name) {
      {
#line 356
      free_string(god->name);
      }
    }
    {
#line 357
    free((void *)god);
#line 353
    god = godnext;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 359
  first_god = (godlink *)((void *)0);
#line 360
  return;
}
}
#line 398 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/holy.c"
void dump_gods(void) 
{ 
  godlink *glist ;
  object const   *god ;
  object const   *tmp ;
  char tmpbuf[4096] ;
  char *final ;
  int tmpvar ;
  int gifts ;
  char const   *tmp___0 ;
  object *serv ;
  char const   *tmp___1 ;
  StringBuffer *tmp___2 ;
  int i ;
  int j ;
  int i___0 ;
  int j___0 ;
  int i___1 ;
  int j___1 ;
  int i___2 ;
  int j___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 401
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 402
  glist = first_god;
  }
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 402
    if (! glist) {
#line 402
      goto while_break;
    }
    {
#line 403
    tmp = pntr_to_god_obj(glist);
#line 403
    god = tmp;
#line 405
    gifts = 0;
#line 407
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"GOD: %s\n",
            god->name);
#line 408
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" avatar stats:\n");
#line 409
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  S:%d C:%d D:%d I:%d W:%d P:%d\n",
            (int const   )god->stats.Str, (int const   )god->stats.Con, (int const   )god->stats.Dex,
            (int const   )god->stats.Int, (int const   )god->stats.Wis, (int const   )god->stats.Pow);
#line 410
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  lvl:%d speed:%4.2f\n",
            (int const   )god->level, (double const   )god->speed);
#line 411
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  wc:%d ac:%d hp:%d dam:%d\n",
            (int const   )god->stats.wc, (int const   )god->stats.ac, (int const   )god->stats.hp,
            (int const   )god->stats.dam);
    }
#line 412
    if (god->title) {
#line 412
      tmp___0 = god->title;
    } else {
#line 412
      tmp___0 = (char const   */* const  */)"NONE";
    }
    {
#line 412
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" enemy: %s\n",
            tmp___0);
    }
#line 413
    if (god->other_arch) {
      {
#line 414
      serv = & (god->other_arch)->clone;
#line 415
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" servant stats: (%s)\n",
              (god->other_arch)->name);
#line 416
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  S:%d C:%d D:%d I:%d W:%d P:%d\n",
              (int )serv->stats.Str, (int )serv->stats.Con, (int )serv->stats.Dex,
              (int )serv->stats.Int, (int )serv->stats.Wis, (int )serv->stats.Pow);
#line 417
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  lvl:%d speed:%4.2f\n",
              (int )serv->level, (double )serv->speed);
#line 418
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  wc:%d ac:%d hp:%d dam:%d\n",
              (int )serv->stats.wc, (int )serv->stats.ac, (int )serv->stats.hp, (int )serv->stats.dam);
      }
    } else {
      {
#line 420
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" servant: NONE\n");
      }
    }
    {
#line 421
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" aligned_race(s): %s\n",
            god->race);
    }
#line 422
    if (god->slaying) {
#line 422
      tmp___1 = god->slaying;
    } else {
#line 422
      tmp___1 = (char const   */* const  */)"none";
    }
    {
#line 422
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" enemy_race(s): %s\n",
            tmp___1);
#line 423
    tmp___2 = describe_resistance(god, 1, (StringBuffer *)((void *)0));
#line 423
    final = stringbuffer_finish(tmp___2);
#line 424
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            final);
#line 425
    free((void *)final);
#line 426
    snprintf((char */* __restrict  */)(tmpbuf), sizeof(tmpbuf), (char const   */* __restrict  */)" attacktype:");
#line 427
    tmpvar = (int )god->attacktype;
    }
#line 427
    if (tmpvar) {
      {
#line 428
      strcat((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)"\n  ");
      }
#line 429
      if (tmpvar) {
        {
#line 429
        j = 0;
#line 429
        strcat((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)"(Attacks: ");
#line 429
        i = 0;
        }
        {
#line 429
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 429
          if (! (i < 26)) {
#line 429
            goto while_break___0;
          }
#line 429
          if (tmpvar & (1 << i)) {
#line 429
            if (j) {
              {
#line 429
              strcat((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)", ");
              }
            } else {
#line 429
              j = 1;
            }
            {
#line 429
            strcat((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)attacks[i]);
            }
          }
#line 429
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 429
        strcat((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)")");
        }
      }
    }
    {
#line 431
    strcat((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)"\n aura:");
#line 433
    strcat((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)"\n paths:");
#line 434
    tmpvar = (int )god->path_attuned;
    }
#line 434
    if (tmpvar) {
      {
#line 435
      strcat((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)"\n  ");
      }
#line 436
      if (tmpvar) {
        {
#line 436
        j___0 = 0;
#line 436
        strcat((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)"(Attuned: ");
#line 436
        i___0 = 0;
        }
        {
#line 436
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 436
          if (! (i___0 < 20)) {
#line 436
            goto while_break___1;
          }
#line 436
          if (tmpvar & (1 << i___0)) {
#line 436
            if (j___0) {
              {
#line 436
              strcat((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)", ");
              }
            } else {
#line 436
              j___0 = 1;
            }
            {
#line 436
            strcat((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)spellpathnames[i___0]);
            }
          }
#line 436
          i___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 436
        strcat((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)")");
        }
      }
    }
#line 438
    tmpvar = (int )god->path_repelled;
#line 438
    if (tmpvar) {
      {
#line 439
      strcat((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)"\n  ");
      }
#line 440
      if (tmpvar) {
        {
#line 440
        j___1 = 0;
#line 440
        strcat((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)"(Repelled: ");
#line 440
        i___1 = 0;
        }
        {
#line 440
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 440
          if (! (i___1 < 20)) {
#line 440
            goto while_break___2;
          }
#line 440
          if (tmpvar & (1 << i___1)) {
#line 440
            if (j___1) {
              {
#line 440
              strcat((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)", ");
              }
            } else {
#line 440
              j___1 = 1;
            }
            {
#line 440
            strcat((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)spellpathnames[i___1]);
            }
          }
#line 440
          i___1 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 440
        strcat((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)")");
        }
      }
    }
#line 442
    tmpvar = (int )god->path_denied;
#line 442
    if (tmpvar) {
      {
#line 443
      strcat((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)"\n  ");
      }
#line 444
      if (tmpvar) {
        {
#line 444
        j___2 = 0;
#line 444
        strcat((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)"(Denied: ");
#line 444
        i___2 = 0;
        }
        {
#line 444
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 444
          if (! (i___2 < 20)) {
#line 444
            goto while_break___3;
          }
#line 444
          if (tmpvar & (1 << i___2)) {
#line 444
            if (j___2) {
              {
#line 444
              strcat((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)", ");
              }
            } else {
#line 444
              j___2 = 1;
            }
            {
#line 444
            strcat((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)spellpathnames[i___2]);
            }
          }
#line 444
          i___2 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 444
        strcat((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)")");
        }
      }
    }
    {
#line 446
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            tmpbuf);
    }
#line 447
    if (god->msg) {
#line 447
      tmp___3 = god->msg;
    } else {
#line 447
      tmp___3 = (char const   */* const  */)"---\n";
    }
    {
#line 447
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Desc: %s",
            tmp___3);
#line 448
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Priest gifts/limitations: ");
    }
#line 449
    if (! (god->flags[1] & (1U << 25))) {
      {
#line 449
      gifts = 1;
#line 449
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  weapon use is forbidden");
      }
    }
#line 450
    if (! (god->flags[1] & (1U << 24))) {
      {
#line 450
      gifts = 1;
#line 450
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  no armour may be worn");
      }
    }
#line 451
    if (god->flags[1] & (1U << 4)) {
      {
#line 451
      gifts = 1;
#line 451
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  is undead");
      }
    }
#line 452
    if (god->flags[2] & (1U << 29)) {
      {
#line 452
      gifts = 1;
#line 452
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  has infravision ");
      }
    }
#line 453
    if (god->flags[1] & (1U << 29)) {
      {
#line 453
      gifts = 1;
#line 453
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  has X-ray vision");
      }
    }
#line 454
    if (god->flags[1] & (1U << 7)) {
      {
#line 454
      gifts = 1;
#line 454
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  reflect missiles");
      }
    }
#line 455
    if (god->flags[1] & (1U << 8)) {
      {
#line 455
      gifts = 1;
#line 455
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  reflect spells");
      }
    }
#line 456
    if (god->flags[2] & (1U << 7)) {
      {
#line 456
      gifts = 1;
#line 456
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  is stealthy");
      }
    }
#line 457
    if (god->flags[2] & (1U << 21)) {
      {
#line 457
      gifts = 1;
#line 457
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  is (permanently) invisible");
      }
    }
#line 458
    if (god->flags[2] & (1U << 28)) {
      {
#line 458
      gifts = 1;
#line 458
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  is blind");
      }
    }
#line 459
    if (god->last_heal) {
      {
#line 459
      gifts = 1;
#line 459
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  hp regenerate at %d",
              god->last_heal);
      }
    }
#line 460
    if (god->last_sp) {
      {
#line 460
      gifts = 1;
#line 460
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  sp regenerate at %d",
              god->last_sp);
      }
    }
#line 461
    if (god->last_eat) {
#line 461
      gifts = 1;
#line 461
      if (god->last_eat < 0) {
#line 461
        tmp___4 = "slowed";
      } else {
#line 461
        tmp___4 = "faster";
      }
      {
#line 461
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  digestion is %s (%d)",
              tmp___4, god->last_eat);
      }
    }
#line 462
    if (god->last_grace) {
      {
#line 462
      gifts = 1;
#line 462
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  grace regenerates at %d",
              (int const   )god->last_grace);
      }
    }
#line 463
    if (god->stats.luck) {
      {
#line 463
      gifts = 1;
#line 463
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  luck is %d",
              (int const   )god->stats.luck);
      }
    }
#line 464
    if (! gifts) {
      {
#line 464
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NONE");
      }
    }
    {
#line 465
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\n");
#line 402
    glist = glist->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 467
  return;
}
}
#line 371 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 14 "../include/libproto.h"
void init_archetypes(void) ;
#line 96
void init_library(void) ;
#line 97
void init_globals(void) ;
#line 344
extern void init_readable(void) ;
#line 355
extern void init_formulae(void) ;
#line 31 "../include/sockproto.h"
void esrv_del_item(player *pl , object *ob ) ;
#line 127 "./../random_maps/random_map.h"
extern int load_parameters(FILE *fp , int bufstate , RMParms *RP ) ;
#line 3 "./../random_maps/rproto.h"
extern mapstruct *generate_random_map(char const   *OutFileName , RMParms *RP , char **use_layout ) ;
#line 593 "../include/sproto.h"
void rod_adjust(object *rod ) ;
#line 609
void move_firewall(object *ob ) ;
#line 622
void set_darkness_map(mapstruct *m ) ;
#line 631
void set_map_timeout(mapstruct *oldmap ) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/standalone.c"
void set_map_timeout(mapstruct *oldmap ) 
{ 


  {
#line 80
  return;
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/standalone.c"
void draw_ext_info(int flags , int pri , object const   *pl , uint8 type , uint8 subtype ,
                   char const   *message ) 
{ 


  {
  {
#line 169
  fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%s\n",
          message);
  }
#line 170
  return;
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/standalone.c"
void draw_ext_info_format(int flags , int pri , object const   *pl , uint8 type ,
                          uint8 subtype , char const   *format  , ...) 
{ 
  va_list ap ;

  {
  {
#line 175
  __builtin_va_start(ap, format);
#line 176
  vfprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)format,
           ap);
#line 177
  __builtin_va_end(ap);
  }
#line 178
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/standalone.c"
void ext_info_map(int color , mapstruct const   *map , uint8 type , uint8 subtype ,
                  char const   *str1 ) 
{ 


  {
  {
#line 182
  fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"ext_info_map: %s\n",
          str1);
  }
#line 183
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/standalone.c"
void move_firewall(object *ob ) 
{ 


  {
#line 186
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/standalone.c"
void emergency_save(int x ) 
{ 


  {
#line 189
  return;
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/standalone.c"
void clean_tmp_files(void) 
{ 


  {
#line 192
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/standalone.c"
void esrv_send_item(object *ob , object *obx ) 
{ 


  {
#line 195
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/standalone.c"
void esrv_update_item(int flags , object *pl , object *op ) 
{ 


  {
#line 198
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/standalone.c"
void dragon_ability_gain(object *ob , int x , int y ) 
{ 


  {
#line 201
  return;
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/standalone.c"
void set_darkness_map(mapstruct *m ) 
{ 


  {
#line 204
  return;
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/standalone.c"
object *find_skill_by_number(object *who , int skillno ) 
{ 


  {
#line 207
  return ((object *)((void *)0));
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/standalone.c"
void esrv_del_item(player *pl , object *ob ) 
{ 


  {
#line 211
  return;
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/standalone.c"
void esrv_update_spells(player *pl ) 
{ 


  {
#line 214
  return;
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/standalone.c"
void rod_adjust(object *rod ) 
{ 


  {
#line 217
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/standalone.c"
int execute_event(object *op , int eventcode , object *activator , object *third ,
                  char const   *message , int fix ) 
{ 


  {
#line 220
  return (0);
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/random_maps/standalone.c"
int execute_global_event(int eventcode  , ...) 
{ 


  {
#line 224
  return (0);
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 187 "../include/global.h"
New_Face *new_faces  ;
#line 242
int bmaps_checksum ;
#line 263 "../include/global.h"
New_Face *blank_face  ;
#line 263 "../include/global.h"
New_Face *empty_face  ;
#line 264 "../include/global.h"
New_Face *smooth_face  ;
#line 86 "../include/libproto.h"
void read_bmap_names(void) ;
#line 88
int read_smooth(void) ;
#line 89
int find_smooth(uint16 face , uint16 *smoothed ) ;
#line 90
void free_all_images(void) ;
#line 91
void read_client_images(void) ;
#line 92
int is_valid_faceset(int fsn ) ;
#line 93
void free_socket_images(void) ;
#line 94
int get_face_fallback(int faceset , int imageno ) ;
#line 51 "../include/image.h"
face_sets facesets[20]  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/image.c"
unsigned int nrofpixmaps  =    0U;
#line 65 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/image.c"
static char const   * const  colorname[13]  = 
#line 65
  {      (char const   */* const  */)"black",      (char const   */* const  */)"white",      (char const   */* const  */)"blue",      (char const   */* const  */)"red", 
        (char const   */* const  */)"orange",      (char const   */* const  */)"light_blue",      (char const   */* const  */)"dark_orange",      (char const   */* const  */)"green", 
        (char const   */* const  */)"light_green",      (char const   */* const  */)"grey",      (char const   */* const  */)"brown",      (char const   */* const  */)"yellow", 
        (char const   */* const  */)"khaki"};
#line 92 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/image.c"
static int compare_face(New_Face const   *a , New_Face const   *b ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 93
  tmp___1 = strcmp((char const   *)a->name, "bug.111");
  }
#line 93
  if (tmp___1 == 0) {
    {
#line 94
    tmp = strcmp((char const   *)b->name, "bug.111");
    }
#line 94
    if (tmp == 0) {
#line 95
      return (0);
    }
#line 96
    return (-1);
  } else {
    {
#line 97
    tmp___0 = strcmp((char const   *)b->name, "bug.111");
    }
#line 97
    if (tmp___0 == 0) {
#line 98
      return (1);
    }
  }
  {
#line 99
  tmp___2 = strcmp((char const   *)a->name, (char const   *)b->name);
  }
#line 99
  return (tmp___2);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/image.c"
static uint8 find_color(char const   *name ) 
{ 
  uint8 i ;
  int tmp ;

  {
#line 118
  i = (uint8 )0;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! ((unsigned long )i < sizeof(colorname) / sizeof(colorname[0]))) {
#line 118
      goto while_break;
    }
    {
#line 119
    tmp = strcmp(name, (char const   *)colorname[i]);
    }
#line 119
    if (! tmp) {
#line 120
      return (i);
    }
#line 118
    i = (uint8 )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 122
  LOG((LogLevel )0, "Unknown color: %s\n", name);
  }
#line 123
  return ((uint8 )0);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/image.c"
static void read_face_data(void) 
{ 
  char buf[256] ;
  char *cp ;
  New_Face *on_face ;
  FILE *fp ;
  int *tmp ;
  char *tmp___0 ;
  unsigned int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int value ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 135
  on_face = (New_Face *)((void *)0);
#line 138
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s/faces",
           settings.datadir);
#line 139
  LOG((LogLevel )2, "Reading faces from %s...\n", buf);
#line 140
  fp = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"r");
  }
#line 140
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 141
    tmp = __errno_location();
#line 141
    tmp___0 = strerror_local(*tmp, buf, sizeof(buf));
#line 141
    LOG((LogLevel )0, "Cannot open faces file: %s\n", tmp___0);
#line 142
    exit(-1);
    }
  }
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 145
    tmp___11 = fgets((char */* __restrict  */)(buf), 256, (FILE */* __restrict  */)fp);
    }
#line 145
    if (! ((unsigned long )tmp___11 != (unsigned long )((void *)0))) {
#line 145
      goto while_break;
    }
#line 146
    if ((int )buf[0] == 35) {
#line 147
      goto while_continue;
    }
    {
#line 148
    tmp___10 = strncmp((char const   *)(buf), "end", (size_t )3);
    }
#line 148
    if (tmp___10) {
      {
#line 150
      tmp___9 = strncmp((char const   *)(buf), "face", (size_t )4);
      }
#line 150
      if (tmp___9) {
#line 163
        if ((unsigned long )on_face == (unsigned long )((void *)0)) {
          {
#line 164
          LOG((LogLevel )0, "Got line with no face set: %s\n", buf);
          }
        } else {
          {
#line 165
          tmp___8 = strncmp((char const   *)(buf), "visibility", (size_t )10);
          }
#line 165
          if (tmp___8) {
            {
#line 167
            tmp___7 = strncmp((char const   *)(buf), "magicmap", (size_t )8);
            }
#line 167
            if (tmp___7) {
              {
#line 171
              tmp___6 = strncmp((char const   *)(buf), "is_floor", (size_t )8);
              }
#line 171
              if (tmp___6) {
                {
#line 176
                LOG((LogLevel )2, "Got unknown line in faces file: %s\n", buf);
                }
              } else {
                {
#line 172
                tmp___5 = atoi((char const   *)(buf + 9));
#line 172
                value = tmp___5;
                }
#line 173
                if (value) {
#line 174
                  on_face->magicmap = (uint8 )((int )on_face->magicmap | 128);
                }
              }
            } else {
              {
#line 168
              cp = buf + 9;
#line 169
              tmp___4 = strlen((char const   *)cp);
#line 169
              *(cp + (tmp___4 - 1UL)) = (char )'\000';
#line 170
              on_face->magicmap = find_color((char const   *)cp);
              }
            }
          } else {
            {
#line 166
            tmp___3 = atoi((char const   *)(buf + 11));
#line 166
            on_face->visibility = (uint8 )tmp___3;
            }
          }
        }
      } else {
        {
#line 153
        cp = buf + 5;
#line 154
        tmp___2 = strlen((char const   *)cp);
#line 154
        *(cp + (tmp___2 - 1UL)) = (char )'\000';
#line 156
        tmp___1 = find_face((char const   *)cp, 4294967295U);
        }
#line 156
        if (tmp___1 == 4294967295U) {
          {
#line 157
          LOG((LogLevel )0, "Could not find face %s\n", cp);
#line 158
          on_face = (New_Face *)((void *)0);
          }
#line 159
          goto while_continue;
        }
#line 161
        on_face = new_faces + tmp___1;
#line 162
        on_face->visibility = (uint8 )0;
      }
    } else {
#line 149
      on_face = (New_Face *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 178
  LOG((LogLevel )2, "done\n");
#line 179
  fclose(fp);
  }
#line 180
  return;
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/image.c"
void read_bmap_names(void) 
{ 
  char buf[256] ;
  char *p ;
  char *q ;
  FILE *fp ;
  int value ;
  unsigned int i ;
  size_t l ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  unsigned int tmp___6 ;
  uint8 tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;

  {
  {
#line 198
  bmaps_checksum = 0;
#line 199
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s/bmaps",
           settings.datadir);
#line 200
  LOG((LogLevel )2, "Reading bmaps from %s...\n", buf);
#line 201
  fp = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"r");
  }
#line 201
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 202
    tmp = __errno_location();
#line 202
    tmp___0 = strerror_local(*tmp, buf, sizeof(buf));
#line 202
    LOG((LogLevel )0, "Cannot open bmaps file: %s\n", tmp___0);
#line 203
    exit(-1);
    }
  }
#line 206
  nrofpixmaps = 0U;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 209
    tmp___1 = fgets((char */* __restrict  */)(buf), 256, (FILE */* __restrict  */)fp);
    }
#line 209
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 209
      goto while_break;
    }
#line 210
    if ((int )buf[0] != 35) {
#line 210
      if ((int )buf[0] != 10) {
#line 211
        nrofpixmaps ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 212
  rewind(fp);
#line 214
  tmp___2 = malloc(sizeof(New_Face ) * (unsigned long )nrofpixmaps);
#line 214
  new_faces = (New_Face *)tmp___2;
  }
#line 215
  if ((unsigned long )new_faces == (unsigned long )((void *)0)) {
    {
#line 216
    LOG((LogLevel )0, "read_bmap_names: new_faces memory allocation failure.\n");
#line 217
    abort();
    }
  }
#line 220
  i = 0U;
  {
#line 220
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 220
    if (! (i < nrofpixmaps)) {
#line 220
      goto while_break___0;
    }
#line 221
    (new_faces + i)->name = (char const   *)((void *)0);
#line 222
    (new_faces + i)->visibility = (uint8 )0;
#line 223
    (new_faces + i)->magicmap = (uint8 )255;
#line 224
    (new_faces + i)->smoothface = (uint16 )-1;
#line 220
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 227
  i = 0U;
  {
#line 228
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 228
    if (i < nrofpixmaps) {
      {
#line 228
      tmp___5 = fgets((char */* __restrict  */)(buf), 256, (FILE */* __restrict  */)fp);
      }
#line 228
      if (! ((unsigned long )tmp___5 != (unsigned long )((void *)0))) {
#line 228
        goto while_break___1;
      }
    } else {
#line 228
      goto while_break___1;
    }
#line 229
    if ((int )buf[0] == 35) {
#line 230
      goto while_continue___1;
    }
#line 232
    if ((int )buf[0] == 92) {
#line 232
      p = buf + 1;
    } else {
#line 232
      p = buf;
    }
    {
#line 233
    p = strtok((char */* __restrict  */)p, (char const   */* __restrict  */)" \t");
    }
#line 233
    if (p) {
      {
#line 233
      q = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
      }
#line 233
      if (! q) {
        {
#line 234
        LOG((LogLevel )2, "Warning, syntax error: %s\n", buf);
        }
#line 235
        goto while_continue___1;
      }
    } else {
      {
#line 234
      LOG((LogLevel )2, "Warning, syntax error: %s\n", buf);
      }
#line 235
      goto while_continue___1;
    }
    {
#line 237
    value = atoi((char const   *)p);
#line 238
    tmp___3 = strdup_local((char const   *)q);
#line 238
    (new_faces + i)->name = (char const   *)tmp___3;
    }
#line 247
    if (bmaps_checksum & 1) {
#line 247
      bmaps_checksum = (int )((unsigned int )(bmaps_checksum >> 1) + 2147483648U);
    } else {
#line 247
      bmaps_checksum >>= 1;
    }
#line 248
    bmaps_checksum += value & 255;
#line 249
    bmaps_checksum = (int )((unsigned int )bmaps_checksum & 4294967295U);
#line 251
    if (bmaps_checksum & 1) {
#line 251
      bmaps_checksum = (int )((unsigned int )(bmaps_checksum >> 1) + 2147483648U);
    } else {
#line 251
      bmaps_checksum >>= 1;
    }
#line 252
    bmaps_checksum += (value >> 8) & 255;
#line 253
    bmaps_checksum = (int )((unsigned int )bmaps_checksum & 4294967295U);
#line 254
    l = (size_t )0;
    {
#line 254
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 254
      tmp___4 = strlen((char const   *)q);
      }
#line 254
      if (! (l < tmp___4)) {
#line 254
        goto while_break___2;
      }
#line 255
      if (bmaps_checksum & 1) {
#line 255
        bmaps_checksum = (int )((unsigned int )(bmaps_checksum >> 1) + 2147483648U);
      } else {
#line 255
        bmaps_checksum >>= 1;
      }
#line 256
      bmaps_checksum += (int )*(q + l);
#line 257
      bmaps_checksum = (int )((unsigned int )bmaps_checksum & 4294967295U);
#line 254
      l ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 260
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 262
  fclose(fp);
  }
#line 264
  if (i != nrofpixmaps) {
    {
#line 265
    LOG((LogLevel )0, "read_bmap_names: first read gave %d faces but only loaded %d??\n",
        nrofpixmaps, i);
#line 266
    fatal(4);
    }
  }
  {
#line 269
  LOG((LogLevel )2, "done (got %d faces)\n", nrofpixmaps);
#line 271
  qsort((void *)new_faces, (size_t )nrofpixmaps, sizeof(New_Face ), (int (*)(void const   * ,
                                                                             void const   * ))(& compare_face));
#line 273
  i = 0U;
  }
  {
#line 273
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 273
    if (! (i < nrofpixmaps)) {
#line 273
      goto while_break___3;
    }
#line 274
    (new_faces + i)->number = (uint16 )i;
#line 273
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 277
  read_face_data();
#line 279
  i = 0U;
  }
  {
#line 279
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 279
    if (! (i < nrofpixmaps)) {
#line 279
      goto while_break___4;
    }
#line 280
    if ((int )(new_faces + i)->magicmap == 255) {
#line 281
      (new_faces + i)->magicmap = (uint8 )0;
    }
#line 279
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 287
  tmp___6 = find_face("blank.111", 0U);
#line 287
  blank_face = new_faces + tmp___6;
#line 288
  tmp___7 = find_color("khaki");
#line 288
  blank_face->magicmap = (uint8 )((int )tmp___7 | 128);
#line 290
  tmp___8 = find_face("empty.111", 0U);
#line 290
  empty_face = new_faces + tmp___8;
#line 292
  tmp___9 = find_face("default_smoothed.111", 0U);
#line 292
  smooth_face = new_faces + tmp___9;
  }
#line 293
  return;
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/image.c"
unsigned int find_face(char const   *name , unsigned int error ) 
{ 
  New_Face *bp ;
  New_Face tmp ;
  void *tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 317
  tmp.name = name;
#line 318
  tmp___0 = bsearch((void const   *)(& tmp), (void const   *)new_faces, (size_t )nrofpixmaps,
                    sizeof(New_Face ), (int (*)(void const   * , void const   * ))(& compare_face));
#line 318
  bp = (New_Face *)tmp___0;
  }
#line 320
  if (bp) {
#line 320
    tmp___1 = (unsigned int )bp->number;
  } else {
#line 320
    tmp___1 = error;
  }
#line 320
  return (tmp___1);
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/image.c"
int read_smooth(void) 
{ 
  char buf[256] ;
  char *p ;
  char *q ;
  FILE *fp ;
  unsigned int regular ;
  unsigned int smoothed ;
  int nrofsmooth ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 338
  nrofsmooth = 0;
#line 340
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s/smooth",
           settings.datadir);
#line 341
  LOG((LogLevel )2, "Reading smooth from %s...\n", buf);
#line 342
  fp = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"r");
  }
#line 342
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 343
    tmp = __errno_location();
#line 343
    tmp___0 = strerror_local(*tmp, buf, sizeof(buf));
#line 343
    LOG((LogLevel )0, "Cannot open smooth file: %s\n", tmp___0);
#line 344
    exit(-1);
    }
  }
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 347
    tmp___1 = fgets((char */* __restrict  */)(buf), 256, (FILE */* __restrict  */)fp);
    }
#line 347
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 347
      goto while_break;
    }
#line 348
    if ((int )buf[0] == 35) {
#line 349
      goto while_continue;
    }
    {
#line 351
    p = strchr((char const   *)(buf), '\n');
    }
#line 351
    if (p) {
#line 352
      *p = (char )'\000';
    }
    {
#line 354
    p = strchr((char const   *)(buf), ' ');
    }
#line 355
    if (! p) {
#line 356
      goto while_continue;
    }
    {
#line 358
    *p = (char )'\000';
#line 359
    q = buf;
#line 360
    regular = find_face((char const   *)q, 4294967295U);
    }
#line 361
    if (regular == 4294967295U) {
      {
#line 362
      LOG((LogLevel )0, "invalid regular face: %s\n", q);
      }
#line 363
      goto while_continue;
    }
    {
#line 365
    q = p + 1;
#line 366
    smoothed = find_face((char const   *)q, 4294967295U);
    }
#line 367
    if (smoothed == 4294967295U) {
      {
#line 368
      LOG((LogLevel )0, "invalid smoothed face: %s\n", q);
      }
#line 369
      goto while_continue;
    }
#line 372
    (new_faces + regular)->smoothface = (uint16 )smoothed;
#line 374
    nrofsmooth ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 376
  fclose(fp);
#line 378
  LOG((LogLevel )2, "done (got %d smooth entries)\n", nrofsmooth);
  }
#line 379
  return (nrofsmooth);
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/image.c"
int find_smooth(uint16 face , uint16 *smoothed ) 
{ 


  {
#line 392
  *smoothed = (uint16 )0;
#line 394
  if ((unsigned int )face < nrofpixmaps) {
#line 395
    if ((int )(new_faces + face)->smoothface == 65535) {
#line 396
      return (0);
    }
#line 398
    *smoothed = (new_faces + face)->smoothface;
#line 399
    return (1);
  }
#line 402
  return (0);
}
}
#line 408 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/image.c"
void free_all_images(void) 
{ 
  unsigned int i ;

  {
#line 411
  i = 0U;
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 411
    if (! (i < nrofpixmaps)) {
#line 411
      goto while_break;
    }
    {
#line 412
    free((void *)((char *)(new_faces + i)->name));
#line 411
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 413
  free((void *)new_faces);
  }
#line 414
  return;
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/image.c"
static void check_faceset_fallback(int faceset , int togo ) 
{ 
  int fallback ;

  {
#line 425
  fallback = (int )facesets[faceset].fallback;
#line 428
  if (fallback == 0) {
#line 429
    return;
  }
#line 431
  if (! facesets[fallback].prefix) {
    {
#line 432
    LOG((LogLevel )0, "Face set %d falls to non set faceset %d\n", faceset, fallback);
#line 433
    abort();
    }
  }
#line 435
  togo --;
#line 436
  if (togo == 0) {
    {
#line 437
    LOG((LogLevel )0, "Infinite loop found in facesets. aborting.\n");
#line 438
    abort();
    }
  }
  {
#line 440
  check_faceset_fallback(fallback, togo);
  }
#line 441
  return;
}
}
#line 460 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/image.c"
void read_client_images(void) 
{ 
  char filename[400] ;
  char buf[4096] ;
  char *cp ;
  char *cps[8] ;
  char *slash ;
  FILE *infile ;
  int len ;
  int fileno___0 ;
  int i ;
  unsigned int num ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 468
  memset((void *)(facesets), 0, sizeof(facesets));
#line 469
  snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s/image_info",
           settings.datadir);
#line 470
  infile = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"r");
  }
#line 470
  if ((unsigned long )infile == (unsigned long )((void *)0)) {
    {
#line 471
    LOG((LogLevel )0, "Unable to open %s\n", filename);
#line 472
    abort();
    }
  }
  {
#line 474
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 474
    tmp___1 = fgets((char */* __restrict  */)(buf), 4095, (FILE */* __restrict  */)infile);
    }
#line 474
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 474
      goto while_break;
    }
#line 475
    if ((int )buf[0] == 35) {
#line 476
      goto while_continue;
    }
    {
#line 477
    tmp___0 = split_string(buf, cps, sizeof(cps) / sizeof(cps[0]), (char )':');
    }
#line 477
    if (tmp___0 != 7UL) {
      {
#line 478
      LOG((LogLevel )0, "Bad line in image_info file, ignoring line:\n  %s", buf);
      }
    } else {
      {
#line 480
      len = atoi((char const   *)cps[0]);
      }
#line 481
      if (len >= 20) {
        {
#line 482
        LOG((LogLevel )0, "To high a setnum in image_info file: %d > %d\n", len, 20);
#line 483
        abort();
        }
      }
      {
#line 485
      facesets[len].prefix = strdup_local((char const   *)cps[1]);
#line 486
      facesets[len].fullname = strdup_local((char const   *)cps[2]);
#line 487
      tmp = atoi((char const   *)cps[3]);
#line 487
      facesets[len].fallback = (uint8 )tmp;
#line 488
      facesets[len].size = strdup_local((char const   *)cps[4]);
#line 489
      facesets[len].extension = strdup_local((char const   *)cps[5]);
#line 490
      facesets[len].comment = strdup_local((char const   *)cps[6]);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 493
  fclose(infile);
#line 494
  i = 0;
  }
  {
#line 494
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 494
    if (! (i < 20)) {
#line 494
      goto while_break___0;
    }
#line 495
    if (facesets[i].prefix) {
      {
#line 496
      check_faceset_fallback(i, 20);
      }
    }
#line 494
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 502
  fileno___0 = 0;
  {
#line 502
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 502
    if (! (fileno___0 < 20)) {
#line 502
      goto while_break___1;
    }
#line 504
    if (! facesets[fileno___0].prefix) {
#line 505
      goto __Cont;
    }
    {
#line 506
    tmp___2 = calloc((size_t )nrofpixmaps, sizeof(face_info ));
#line 506
    facesets[fileno___0].faces = (face_info *)tmp___2;
#line 508
    snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s/crossfire.%d",
             settings.datadir, fileno___0);
#line 509
    LOG((LogLevel )2, "Loading image file %s\n", filename);
#line 511
    infile = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"rb");
    }
#line 511
    if ((unsigned long )infile == (unsigned long )((void *)0)) {
      {
#line 512
      LOG((LogLevel )0, "Unable to open %s\n", filename);
#line 513
      abort();
      }
    }
    {
#line 515
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 515
      tmp___8 = fgets((char */* __restrict  */)(buf), 4095, (FILE */* __restrict  */)infile);
      }
#line 515
      if (! ((unsigned long )tmp___8 != (unsigned long )((void *)0))) {
#line 515
        goto while_break___2;
      }
      {
#line 516
      tmp___3 = strncmp((char const   *)(buf), "IMAGE ", (size_t )6);
      }
#line 516
      if (tmp___3 != 0) {
        {
#line 517
        LOG((LogLevel )0, "read_client_images:Bad image line - not IMAGE, instead\n%s",
            buf);
#line 518
        abort();
        }
      }
      {
#line 520
      cp = buf + 6;
#line 521
      len = atoi((char const   *)cp);
      }
#line 522
      if (len == 0) {
        {
#line 523
        LOG((LogLevel )0, "read_client_images: length not valid: %d > %d \n%s", len,
            10000, buf);
#line 524
        abort();
        }
      } else
#line 522
      if (len > 10000) {
        {
#line 523
        LOG((LogLevel )0, "read_client_images: length not valid: %d > %d \n%s", len,
            10000, buf);
#line 524
        abort();
        }
      }
      {
#line 527
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 527
        if ((int )*cp != 32) {
#line 527
          if ((int )*cp != 10) {
#line 527
            if (! ((int )*cp != 0)) {
#line 527
              goto while_break___3;
            }
          } else {
#line 527
            goto while_break___3;
          }
        } else {
#line 527
          goto while_break___3;
        }
#line 527
        cp ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 529
      if ((int )*cp != 32) {
        {
#line 530
        LOG((LogLevel )0, "read_client_images: couldn\'t find name start for %d\n",
            num);
#line 531
        abort();
        }
      }
      {
#line 533
      cp ++;
#line 535
      slash = strrchr((char const   *)cp, '/');
      }
#line 536
      if ((unsigned long )slash != (unsigned long )((void *)0)) {
#line 537
        cp = slash + 1;
      }
      {
#line 538
      tmp___5 = strlen((char const   *)cp);
      }
#line 538
      if ((int )*(cp + (tmp___5 - 1UL)) == 10) {
        {
#line 539
        tmp___4 = strlen((char const   *)cp);
#line 539
        *(cp + (tmp___4 - 1UL)) = (char )'\000';
        }
      }
      {
#line 542
      num = find_face((char const   *)cp, 4294967295U);
      }
#line 543
      if (num == 4294967295U) {
        {
#line 544
        LOG((LogLevel )0, "read_client_images: couldn\'t find picture %s\n", cp);
#line 545
        abort();
        }
      }
#line 547
      if (num >= nrofpixmaps) {
        {
#line 548
        LOG((LogLevel )0, "read_client_images: invalid picture number %d for %s\n",
            num, cp);
#line 549
        abort();
        }
      }
      {
#line 552
      (facesets[fileno___0].faces + num)->datalen = (uint16 )len;
#line 553
      tmp___6 = malloc((size_t )len);
#line 553
      (facesets[fileno___0].faces + num)->data = (uint8 *)tmp___6;
#line 554
      tmp___7 = fread((void */* __restrict  */)(facesets[fileno___0].faces + num)->data,
                      (size_t )len, (size_t )1, (FILE */* __restrict  */)infile);
#line 554
      i = (int )tmp___7;
      }
#line 554
      if (i != 1) {
        {
#line 555
        LOG((LogLevel )0, "read_client_images: Did not read desired amount of data, wanted %d, got %d\n%s",
            len, i, buf);
#line 556
        abort();
        }
      }
#line 558
      (facesets[fileno___0].faces + num)->checksum = (uint32 )0;
#line 559
      i = 0;
      {
#line 559
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 559
        if (! (i < len)) {
#line 559
          goto while_break___4;
        }
#line 560
        if ((facesets[fileno___0].faces + num)->checksum & 1U) {
#line 560
          (facesets[fileno___0].faces + num)->checksum = ((facesets[fileno___0].faces + num)->checksum >> 1) + 2147483648U;
        } else {
#line 560
          (facesets[fileno___0].faces + num)->checksum >>= 1;
        }
#line 561
        (facesets[fileno___0].faces + num)->checksum += (uint32 )*((facesets[fileno___0].faces + num)->data + i);
#line 562
        (facesets[fileno___0].faces + num)->checksum &= 4294967295U;
#line 559
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 565
    fclose(infile);
    }
    __Cont: /* CIL Label */ 
#line 502
    fileno___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 567
  return;
}
}
#line 573 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/image.c"
int is_valid_faceset(int fsn ) 
{ 


  {
#line 574
  if (fsn >= 0) {
#line 574
    if (fsn < 20) {
#line 574
      if (facesets[fsn].prefix) {
#line 575
        return (1);
      }
    }
  }
#line 576
  return (0);
}
}
#line 582 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/image.c"
void free_socket_images(void) 
{ 
  int num ;
  unsigned int q ;

  {
#line 586
  num = 0;
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 586
    if (! (num < 20)) {
#line 586
      goto while_break;
    }
#line 587
    if (facesets[num].prefix) {
#line 588
      q = 0U;
      {
#line 588
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 588
        if (! (q < nrofpixmaps)) {
#line 588
          goto while_break___0;
        }
        {
#line 589
        free((void *)(facesets[num].faces + q)->data);
#line 588
        q ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 590
      free((void *)facesets[num].prefix);
#line 591
      free((void *)facesets[num].fullname);
#line 592
      free((void *)facesets[num].size);
#line 593
      free((void *)facesets[num].extension);
#line 594
      free((void *)facesets[num].comment);
#line 595
      free((void *)facesets[num].faces);
      }
    }
#line 586
    num ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 598
  return;
}
}
#line 612 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/image.c"
int get_face_fallback(int faceset , int imageno ) 
{ 
  int tmp ;

  {
#line 619
  if (faceset == 0) {
#line 620
    return (0);
  }
#line 622
  if (! facesets[faceset].prefix) {
    {
#line 623
    LOG((LogLevel )0, "get_face_fallback called with unused set (%d)?\n", faceset);
    }
#line 624
    return (0);
  }
#line 626
  if ((facesets[faceset].faces + imageno)->data) {
#line 627
    return (faceset);
  }
  {
#line 628
  tmp = get_face_fallback((int )facesets[faceset].fallback, imageno);
  }
#line 628
  return (tmp);
}
}
#line 128 "../include/libproto.h"
objectlink *get_objectlink(void) ;
#line 129
oblinkpt *get_objectlinkpt(void) ;
#line 130
void free_objectlink(objectlink *ol ) ;
#line 131
void free_objectlinkpt(oblinkpt *obp ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/links.c"
objectlink *get_objectlink(void) 
{ 
  objectlink *ol ;
  void *tmp ;

  {
  {
#line 46
  tmp = calloc((size_t )1, sizeof(objectlink ));
#line 46
  ol = (objectlink *)tmp;
  }
#line 47
  if (! ol) {
    {
#line 48
    fatal(0);
    }
  }
#line 49
  ol->ob = (object *)((void *)0);
#line 50
  ol->next = (struct oblnk *)((void *)0);
#line 51
  ol->id = (tag_t )0;
#line 52
  return (ol);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/links.c"
oblinkpt *get_objectlinkpt(void) 
{ 
  oblinkpt *obp ;
  void *tmp ;

  {
  {
#line 66
  tmp = malloc(sizeof(oblinkpt ));
#line 66
  obp = (oblinkpt *)tmp;
  }
#line 68
  if (! obp) {
    {
#line 69
    fatal(0);
    }
  }
#line 70
  obp->link = (struct oblnk *)((void *)0);
#line 71
  obp->next = (struct oblinkpt *)((void *)0);
#line 72
  obp->value = 0L;
#line 73
  return (obp);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/links.c"
void free_objectlink(objectlink *ol ) 
{ 


  {
#line 84
  if (ol->next) {
    {
#line 85
    free_objectlink(ol->next);
    }
  }
  {
#line 86
  free((void *)ol);
  }
#line 87
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/links.c"
void free_objectlinkpt(oblinkpt *obp ) 
{ 


  {
#line 96
  if (obp->next) {
    {
#line 97
    free_objectlinkpt(obp->next);
    }
  }
#line 98
  if (obp->link) {
    {
#line 99
    free_objectlink(obp->link);
    }
  }
  {
#line 100
  free((void *)obp);
  }
#line 101
  return;
}
}
#line 336 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 159 "../include/attack.h"
attackmess_t attack_mess[21][21]  ;
#line 173 "../include/attack.h"
char const   * const  resist_save[26]  = 
#line 173
  {      (char const   */* const  */)"physical ",      (char const   */* const  */)"magic ",      (char const   */* const  */)"fire ",      (char const   */* const  */)"electricity ", 
        (char const   */* const  */)"cold ",      (char const   */* const  */)"confusion ",      (char const   */* const  */)"acid ",      (char const   */* const  */)"drain ", 
        (char const   */* const  */)"weaponmagic ",      (char const   */* const  */)"ghosthit ",      (char const   */* const  */)"poison ",      (char const   */* const  */)"slow ", 
        (char const   */* const  */)"paralyze ",      (char const   */* const  */)"turn_undead ",      (char const   */* const  */)"fear ",      (char const   */* const  */)"cancellation ", 
        (char const   */* const  */)"deplete ",      (char const   */* const  */)"death ",      (char const   */* const  */)"chaos ",      (char const   */* const  */)"counterspell ", 
        (char const   */* const  */)"godpower ",      (char const   */* const  */)"holyword ",      (char const   */* const  */)"blind ",      (char const   */* const  */)"internal ", 
        (char const   */* const  */)"life_stealing ",      (char const   */* const  */)"disease "};
#line 182 "../include/attack.h"
char const   * const  attacktype_desc[26]  = 
#line 182
  {      (char const   */* const  */)"physical",      (char const   */* const  */)"magic",      (char const   */* const  */)"fire",      (char const   */* const  */)"electricity", 
        (char const   */* const  */)"cold",      (char const   */* const  */)"confusion",      (char const   */* const  */)"acid",      (char const   */* const  */)"drain", 
        (char const   */* const  */)"weapon magic",      (char const   */* const  */)"ghost hit",      (char const   */* const  */)"poison",      (char const   */* const  */)"slow", 
        (char const   */* const  */)"paralyze",      (char const   */* const  */)"turn undead",      (char const   */* const  */)"fear",      (char const   */* const  */)"cancellation", 
        (char const   */* const  */)"deplete",      (char const   */* const  */)"death",      (char const   */* const  */)"chaos",      (char const   */* const  */)"counterspell", 
        (char const   */* const  */)"god power",      (char const   */* const  */)"holy word",      (char const   */* const  */)"blind",      (char const   */* const  */)"internal", 
        (char const   */* const  */)"life stealing",      (char const   */* const  */)"disease"};
#line 191 "../include/attack.h"
char const   * const  resist_plus[26]  = 
#line 191
  {      (char const   */* const  */)"armour",      (char const   */* const  */)"resist magic",      (char const   */* const  */)"resist fire",      (char const   */* const  */)"resist electricity", 
        (char const   */* const  */)"resist cold",      (char const   */* const  */)"resist confusion",      (char const   */* const  */)"resist acid",      (char const   */* const  */)"resist drain", 
        (char const   */* const  */)"resist weaponmagic",      (char const   */* const  */)"resist ghosthit",      (char const   */* const  */)"resist poison",      (char const   */* const  */)"resist slow", 
        (char const   */* const  */)"resist paralyzation",      (char const   */* const  */)"resist turn undead",      (char const   */* const  */)"resist fear",      (char const   */* const  */)"resist cancellation", 
        (char const   */* const  */)"resist depletion",      (char const   */* const  */)"resist death",      (char const   */* const  */)"resist chaos",      (char const   */* const  */)"resist counterspell", 
        (char const   */* const  */)"resist god power",      (char const   */* const  */)"resist holy word",      (char const   */* const  */)"resist blindness",      (char const   */* const  */)"resist internal", 
        (char const   */* const  */)"resist life stealing",      (char const   */* const  */)"resist diseases"};
#line 206 "../include/attack.h"
char const   * const  change_resist_msg[26]  = 
#line 206
  {      (char const   */* const  */)"physical",      (char const   */* const  */)"magic",      (char const   */* const  */)"fire",      (char const   */* const  */)"electricity", 
        (char const   */* const  */)"cold",      (char const   */* const  */)"confusion",      (char const   */* const  */)"acid",      (char const   */* const  */)"draining", 
        (char const   */* const  */)"weapon magic",      (char const   */* const  */)"ghosts",      (char const   */* const  */)"poison",      (char const   */* const  */)"slow", 
        (char const   */* const  */)"paralyze",      (char const   */* const  */)"turn undead",      (char const   */* const  */)"fear",      (char const   */* const  */)"cancellation", 
        (char const   */* const  */)"depletion",      (char const   */* const  */)"death attacks",      (char const   */* const  */)"chaos",      (char const   */* const  */)"counterspell", 
        (char const   */* const  */)"god power",      (char const   */* const  */)"holy word",      (char const   */* const  */)"blinding attacks",      (char const   */* const  */)"internal", 
        (char const   */* const  */)"life stealing",      (char const   */* const  */)"disease"};
#line 216 "../include/attack.h"
Chaos_Attacks ATTACKS[22]  = 
#line 216
  {      {1, 0}, 
        {1, 0}, 
        {1, 0}, 
        {2, 1}, 
        {2, 1}, 
        {2, 1}, 
        {4, 2}, 
        {4, 2}, 
        {4, 2}, 
        {8, 3}, 
        {8, 3}, 
        {8, 3}, 
        {16, 4}, 
        {16, 4}, 
        {16, 4}, 
        {32, 5}, 
        {1024, 7}, 
        {1024, 7}, 
        {1024, 7}, 
        {2048, 8}, 
        {4096, 9}, 
        {16384, 10}};
#line 72 "../include/material.h"
materialtype_t *materialt  ;
#line 331 "../include/object.h"
extern object *objects ;
#line 332
extern object *active_objects ;
#line 333
extern object *free_objects ;
#line 334
extern object objarray[500] ;
#line 193 "../include/global.h"
player *first_player  ;
#line 194 "../include/global.h"
mapstruct *first_map  ;
#line 195 "../include/global.h"
region *first_region  ;
#line 196 "../include/global.h"
treasurelist *first_treasurelist  ;
#line 197 "../include/global.h"
artifactlist *first_artifactlist  ;
#line 198 "../include/global.h"
archetype *first_archetype  ;
#line 199 "../include/global.h"
objectlink *first_friendly_object  ;
#line 200 "../include/global.h"
godlink *first_god  ;
#line 201 "../include/global.h"
racelink *first_race  ;
#line 208 "../include/global.h"
long warn_archetypes  ;
#line 210 "../include/global.h"
long init_done  ;
#line 211 "../include/global.h"
long trying_emergency_save  ;
#line 212 "../include/global.h"
long nroferrors  ;
#line 220 "../include/global.h"
FILE *logfile  ;
#line 222 "../include/global.h"
int exiting  ;
#line 223 "../include/global.h"
long nroftreasures  ;
#line 224 "../include/global.h"
long nrofartifacts  ;
#line 225 "../include/global.h"
long nrofallowedstr  ;
#line 227 "../include/global.h"
archetype *empty_archetype  ;
#line 228 "../include/global.h"
archetype *map_archeytpe  ;
#line 229 "../include/global.h"
char first_map_path[256]  ;
#line 230 "../include/global.h"
char first_map_ext_path[256]  ;
#line 232 "../include/global.h"
long ob_count  ;
#line 238 "../include/global.h"
archetype *ring_arch  ;
#line 238 "../include/global.h"
archetype *amulet_arch  ;
#line 238 "../include/global.h"
archetype *staff_arch  ;
#line 238 "../include/global.h"
archetype *crown_arch  ;
#line 239 "../include/global.h"
char const   *undead_name  ;
#line 241 "../include/global.h"
Animations *animations  ;
#line 242 "../include/global.h"
int num_animations  ;
#line 242 "../include/global.h"
int animations_allocated  ;
#line 242 "../include/global.h"
int bmaps_checksum  ;
#line 98 "../include/libproto.h"
void free_globals(void) ;
#line 99
void init_objects(void) ;
#line 100
void write_todclock(void) ;
#line 199
extern mapstruct *ready_map_name(char const   *name , int flags ) ;
#line 373
extern void init_regions(void) ;
#line 376
extern void init_hash_table(void) ;
#line 455
extern void init_vars(void) ;
#line 451 "../include/global.h"
struct Statistics statistics  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/init.c"
static void init_environ(void) ;
#line 40
static void init_defaults(void) ;
#line 41
static void init_dynamic(void) ;
#line 42
static void init_clocks(void) ;
#line 43
static void init_attackmess(void) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/init.c"
struct Settings settings  = 
#line 49
     {"/var/log/crossfire/logfile", (uint16 )13327, (LogLevel )1, (uint8 )0, (char const   *)((void *)0),
    (uint8 )0, 0, (char **)((void *)0), "/usr/games/crossfire/etc/crossfire", "/usr/games/crossfire/share/crossfire",
    "/usr/games/crossfire/var/crossfire", "players", "maps", "archetypes", "regions.reg",
    "treasures", "unique-items", "template-maps", "/tmp", (uint8 )0, (sint16 )1, (uint8 )50,
    (uint8 )20, (uint8 )3, (uint8 )0, (uint8 )1, (uint8 )1, 3600, (uint8 )1, (uint8 )0,
    (uint8 )1, (uint8 )1, (uint8 )0, (uint8 )0, (uint8 )1, (uint8 )0, (uint8 )1, (uint16 )5,
    {(char )'\000'}, {(char )'\000'}, {(char )'m', (char )'o', (char )'t', (char )'d',
                                       (char )'\000'}, "rules", "news", {(char )'\000'},
    0U, {(char )'\000'}, {(char )'\000'}, (uint16 )0, {(char )'\000'}, (uint32 )0,
    (uint32 )0, (uint32 )0, (uint32 )0, (uint32 )0, (uint32 )0, (uint8 )0, (char *)((void *)0),
    (uint16 )5, (uint16 )37, (sint16 )0, (float )1.0, 5, 10, (uint8 )1, 10, (uint8 )1,
    (uint8 )1, (uint8 )0, (uint8 )1, (sint64 )5000000, 10, 0, 0, 0, (char *)((void *)0),
    (uint8 )3, (uint8 )18, (uint8 )85, (uint8 )115, (uint8 )0, (uint8 )1, (linked_char *)((void *)0),
    (uint8 )0};
#line 129 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/init.c"
char const   * const  spellpathnames[20]  = 
#line 129
  {      (char const   */* const  */)"Protection",      (char const   */* const  */)"Fire",      (char const   */* const  */)"Frost",      (char const   */* const  */)"Electricity", 
        (char const   */* const  */)"Missiles",      (char const   */* const  */)"Self",      (char const   */* const  */)"Summoning",      (char const   */* const  */)"Abjuration", 
        (char const   */* const  */)"Restoration",      (char const   */* const  */)"Detonation",      (char const   */* const  */)"Mind",      (char const   */* const  */)"Creation", 
        (char const   */* const  */)"Teleportation",      (char const   */* const  */)"Information",      (char const   */* const  */)"Transmutation",      (char const   */* const  */)"Transferrence", 
        (char const   */* const  */)"Turning",      (char const   */* const  */)"Wounding",      (char const   */* const  */)"Death",      (char const   */* const  */)"Light"};
#line 164 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/init.c"
static void init_emergency_mappath(void) 
{ 
  char filename[256] ;
  char tmpbuf[256] ;
  FILE *fp ;
  int online ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 167
  online = 0;
#line 169
  settings.emergency_mapname = strdup_local("/world/world_105_115");
#line 172
  snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s/%s/.emergency",
           settings.datadir, settings.mapdir);
#line 173
  fp = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"r");
  }
#line 174
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 175
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 175
      tmp___2 = fgets((char */* __restrict  */)(tmpbuf), 255, (FILE */* __restrict  */)fp);
      }
#line 175
      if (! tmp___2) {
#line 175
        goto while_break;
      }
#line 176
      if ((int )tmpbuf[0] == 35) {
#line 177
        goto while_continue;
      }
#line 179
      if (online == 0) {
        {
#line 180
        tmp = strlen((char const   *)(tmpbuf));
#line 180
        tmpbuf[tmp - 1UL] = (char)0;
#line 181
        free((void *)settings.emergency_mapname);
#line 182
        settings.emergency_mapname = strdup_local((char const   *)(tmpbuf));
        }
      } else
#line 183
      if (online == 1) {
        {
#line 184
        tmp___0 = atoi((char const   *)(tmpbuf));
#line 184
        settings.emergency_x = (uint16 )tmp___0;
        }
      } else
#line 185
      if (online == 2) {
        {
#line 186
        tmp___1 = atoi((char const   *)(tmpbuf));
#line 186
        settings.emergency_y = (uint16 )tmp___1;
        }
      }
#line 188
      online ++;
#line 189
      if (online > 2) {
#line 190
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 192
    fclose(fp);
    }
#line 193
    if (online <= 2) {
      {
#line 194
      LOG((LogLevel )0, "Online read partial data from %s\n", filename);
      }
    }
    {
#line 195
    LOG((LogLevel )2, "Emergency mappath reset to %s (%d, %d)\n", settings.emergency_mapname,
        (int )settings.emergency_x, (int )settings.emergency_y);
    }
  }
#line 197
  return;
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/init.c"
void init_library(void) 
{ 


  {
  {
#line 209
  init_environ();
#line 210
  init_globals();
#line 211
  init_stats(0);
#line 214
  init_hash_table();
#line 215
  i18n_init();
#line 216
  init_objects();
#line 217
  init_vars();
#line 218
  init_block();
#line 219
  read_bmap_names();
#line 220
  read_smooth();
#line 221
  init_anim();
#line 222
  init_archetypes();
#line 223
  init_attackmess();
#line 224
  init_clocks();
#line 225
  init_emergency_mappath();
#line 226
  init_experience();
#line 227
  init_regions();
#line 228
  init_dynamic();
  }
#line 229
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/init.c"
static void init_environ(void) 
{ 
  char *cp ;

  {
  {
#line 239
  cp = getenv("CROSSFIRE_LIBDIR");
  }
#line 240
  if (cp) {
#line 241
    settings.datadir = (char const   *)cp;
  }
  {
#line 242
  cp = getenv("CROSSFIRE_LOCALDIR");
  }
#line 243
  if (cp) {
#line 244
    settings.localdir = (char const   *)cp;
  }
  {
#line 245
  cp = getenv("CROSSFIRE_PLAYERDIR");
  }
#line 246
  if (cp) {
#line 247
    settings.playerdir = (char const   *)cp;
  }
  {
#line 248
  cp = getenv("CROSSFIRE_MAPDIR");
  }
#line 249
  if (cp) {
#line 250
    settings.mapdir = (char const   *)cp;
  }
  {
#line 251
  cp = getenv("CROSSFIRE_ARCHETYPES");
  }
#line 252
  if (cp) {
#line 253
    settings.archetypes = (char const   *)cp;
  }
  {
#line 254
  cp = getenv("CROSSFIRE_TREASURES");
  }
#line 255
  if (cp) {
#line 256
    settings.treasures = (char const   *)cp;
  }
  {
#line 257
  cp = getenv("CROSSFIRE_UNIQUEDIR");
  }
#line 258
  if (cp) {
#line 259
    settings.uniquedir = (char const   *)cp;
  }
  {
#line 260
  cp = getenv("CROSSFIRE_TEMPLATEDIR");
  }
#line 261
  if (cp) {
#line 262
    settings.templatedir = (char const   *)cp;
  }
  {
#line 263
  cp = getenv("CROSSFIRE_TMPDIR");
  }
#line 264
  if (cp) {
#line 265
    settings.tmpdir = (char const   *)cp;
  }
#line 266
  return;
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/init.c"
void init_globals(void) 
{ 


  {
  {
#line 275
  memset((void *)(& statistics), 0, sizeof(struct Statistics ));
  }
#line 276
  if ((int const   )*(settings.logfilename + 0) == 0) {
#line 277
    logfile = stderr;
  } else {
    {
#line 278
    logfile = fopen((char const   */* __restrict  */)settings.logfilename, (char const   */* __restrict  */)"a");
    }
#line 278
    if ((unsigned long )logfile == (unsigned long )((void *)0)) {
      {
#line 279
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to open %s as the logfile - will use stderr instead\n",
              settings.logfilename);
#line 280
      logfile = stderr;
      }
    } else {
      {
#line 282
      setvbuf((FILE */* __restrict  */)logfile, (char */* __restrict  */)((void *)0),
              1, (size_t )0);
      }
    }
  }
  {
#line 284
  exiting = 0;
#line 285
  first_player = (player *)((void *)0);
#line 286
  first_friendly_object = (objectlink *)((void *)0);
#line 287
  first_map = (mapstruct *)((void *)0);
#line 288
  first_treasurelist = (treasurelist *)((void *)0);
#line 289
  first_artifactlist = (artifactlist *)((void *)0);
#line 290
  first_archetype = (archetype *)((void *)0);
#line 291
  first_map_ext_path[0] = (char)0;
#line 292
  warn_archetypes = 0L;
#line 293
  nroftreasures = 0L;
#line 294
  nrofartifacts = 0L;
#line 295
  nrofallowedstr = 0L;
#line 296
  ring_arch = (archetype *)((void *)0);
#line 297
  amulet_arch = (archetype *)((void *)0);
#line 298
  staff_arch = (archetype *)((void *)0);
#line 299
  undead_name = add_string("undead");
#line 300
  trying_emergency_save = 0L;
#line 301
  num_animations = 0;
#line 302
  animations = (Animations *)((void *)0);
#line 303
  animations_allocated = 0;
#line 304
  init_defaults();
  }
#line 305
  return;
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/init.c"
void free_globals(void) 
{ 
  int msg ;
  int attack ;
  objectlink *friend ;
  region *reg ;

  {
  {
#line 322
  free_string(undead_name);
#line 322
  undead_name = (char const   *)((void *)0);
#line 323
  msg = 0;
  }
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (! (msg < 21)) {
#line 323
      goto while_break;
    }
#line 324
    attack = 0;
    {
#line 324
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 324
      if (! (attack < 21)) {
#line 324
        goto while_break___0;
      }
      {
#line 325
      free((void *)attack_mess[msg][attack].buf1);
#line 326
      free((void *)attack_mess[msg][attack].buf2);
#line 327
      free((void *)attack_mess[msg][attack].buf3);
#line 324
      attack ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 323
    msg ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 330
  free((void *)settings.emergency_mapname);
  }
  {
#line 332
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 332
    if (! first_friendly_object) {
#line 332
      goto while_break___1;
    }
    {
#line 333
    friend = first_friendly_object->next;
#line 334
    free((void *)first_friendly_object);
#line 334
    first_friendly_object = (objectlink *)((void *)0);
#line 335
    first_friendly_object = friend;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 338
  free_experience();
  }
  {
#line 340
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 340
    if (! first_region) {
#line 340
      goto while_break___2;
    }
    {
#line 341
    reg = first_region->next;
#line 342
    free((void *)first_region->name);
#line 342
    first_region->name = (char *)((void *)0);
#line 343
    free((void *)first_region->parent_name);
#line 343
    first_region->parent_name = (char *)((void *)0);
#line 344
    free((void *)first_region->jailmap);
#line 344
    first_region->jailmap = (char *)((void *)0);
#line 345
    free((void *)first_region->msg);
#line 345
    first_region->msg = (char *)((void *)0);
#line 346
    free((void *)first_region->longname);
#line 346
    first_region->longname = (char *)((void *)0);
#line 347
    free((void *)first_region);
#line 347
    first_region = (region *)((void *)0);
#line 348
    first_region = reg;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 350
  return;
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/init.c"
void init_objects(void) 
{ 
  int i ;

  {
#line 362
  objects = (object *)((void *)0);
#line 363
  active_objects = (object *)((void *)0);
#line 368
  free_objects = objarray;
#line 369
  objarray[0].prev = (struct obj *)((void *)0);
#line 369
  objarray[0].next = & objarray[1];
#line 369
  objarray[0].flags[0] |= 1U << 2;
#line 372
  objarray[0].flags[0] |= 1U << 3;
#line 373
  i = 1;
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 373
    if (! (i < 499)) {
#line 373
      goto while_break;
    }
#line 374
    objarray[i].next = & objarray[i + 1];
#line 375
    objarray[i].prev = & objarray[i - 1];
#line 376
    objarray[i].flags[0] |= 1U << 2;
#line 377
    objarray[i].flags[0] |= 1U << 3;
#line 373
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 379
  objarray[499].next = (struct obj *)((void *)0);
#line 380
  objarray[499].prev = & objarray[498];
#line 381
  objarray[499].flags[0] |= 1U << 2;
#line 382
  objarray[499].flags[0] |= 1U << 3;
#line 384
  return;
}
}
#line 390 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/init.c"
static void init_defaults(void) 
{ 


  {
#line 391
  nroferrors = 0L;
#line 392
  return;
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/init.c"
static void init_dynamic(void) 
{ 
  archetype *at ;
  mapstruct *first ;

  {
#line 403
  at = first_archetype;
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 404
    if (! at) {
#line 404
      goto while_break;
    }
#line 405
    if ((int )at->clone.type == 22) {
#line 405
      if ((int )at->clone.subtype == 1) {
#line 406
        if (at->clone.race) {
          {
#line 407
          strcpy((char */* __restrict  */)(first_map_ext_path), (char const   */* __restrict  */)at->clone.race);
          }
        }
#line 409
        if (at->clone.slaying) {
          {
#line 412
          snprintf((char */* __restrict  */)(first_map_path), sizeof(first_map_path),
                   (char const   */* __restrict  */)"%s", at->clone.slaying);
#line 413
          first = ready_map_name((char const   *)(first_map_path), 0);
          }
#line 414
          if (! first) {
            {
#line 415
            LOG((LogLevel )0, "Initial map %s can\'t be found! Please ensure maps are correctly installed.\n",
                first_map_path);
#line 416
            LOG((LogLevel )0, "Unable to continue without initial map.\n");
#line 417
            abort();
            }
          }
          {
#line 419
          delete_map(first);
          }
#line 420
          return;
        }
      }
    }
#line 423
    at = at->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 425
  LOG((LogLevel )0, "You need a archetype called \'map\' and it have to contain start map\n");
#line 426
  exit(-1);
  }
}
}
#line 430 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/init.c"
unsigned long todtick  ;
#line 436 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/init.c"
void write_todclock(void) 
{ 
  char filename[256] ;
  FILE *fp ;

  {
  {
#line 440
  snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s/clockdata",
           settings.localdir);
#line 441
  fp = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"w");
  }
#line 442
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 443
    LOG((LogLevel )0, "Cannot open %s for writing\n", filename);
    }
#line 444
    return;
  }
  {
#line 446
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%lu", todtick);
#line 447
  fclose(fp);
  }
#line 448
  return;
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/init.c"
static int has_been_done  =    0;
#line 454 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/init.c"
static void init_clocks(void) 
{ 
  char filename[256] ;
  FILE *fp ;
  int tmp ;

  {
#line 459
  if (has_been_done) {
#line 460
    return;
  } else {
#line 462
    has_been_done = 1;
  }
  {
#line 464
  snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s/clockdata",
           settings.localdir);
#line 465
  LOG((LogLevel )2, "Reading clockdata from %s...\n", filename);
#line 466
  fp = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"r");
  }
#line 467
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 468
    LOG((LogLevel )0, "Can\'t open %s.\n", filename);
#line 469
    todtick = 0UL;
#line 470
    write_todclock();
    }
#line 471
    return;
  }
  {
#line 474
  tmp = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%lu",
               & todtick);
  }
#line 474
  if (tmp == 1) {
    {
#line 475
    LOG((LogLevel )2, "todtick=%lu\n", todtick);
#line 476
    fclose(fp);
    }
  } else {
    {
#line 478
    LOG((LogLevel )0, "Couldn\'t parse todtick, using default value 0\n");
#line 479
    todtick = 0UL;
#line 480
    fclose(fp);
#line 481
    write_todclock();
    }
  }
#line 483
  return;
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/init.c"
static int has_been_done___0  =    0;
#line 491 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/init.c"
static void init_attackmess(void) 
{ 
  char buf[256] ;
  char filename[256] ;
  char *cp ;
  char *p ;
  FILE *fp ;
  int mess ;
  int level ;
  int mode ;
  int total ;
  int tmp ;
  char *tmp___0 ;

  {
#line 497
  mess = -1;
#line 498
  mode = 0;
#line 498
  total = 0;
#line 500
  if (has_been_done___0) {
#line 501
    return;
  } else {
#line 503
    has_been_done___0 = 1;
  }
  {
#line 505
  snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s/attackmess",
           settings.datadir);
#line 506
  LOG((LogLevel )2, "Reading attack messages from %s...\n", filename);
#line 507
  fp = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"r");
  }
#line 508
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 509
    LOG((LogLevel )0, "Can\'t open %s.\n", filename);
    }
#line 510
    return;
  }
#line 513
  level = 0;
  {
#line 514
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 514
    tmp___0 = fgets((char */* __restrict  */)(buf), 256, (FILE */* __restrict  */)fp);
    }
#line 514
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 514
      goto while_break;
    }
#line 515
    if ((int )buf[0] == 35) {
#line 516
      goto while_continue;
    }
    {
#line 517
    cp = strchr((char const   *)(buf), '\n');
    }
#line 518
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 519
      *cp = (char )'\000';
    }
#line 520
    cp = buf;
    {
#line 521
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 521
      if (! ((int )*cp == 32)) {
#line 521
        goto while_break___0;
      }
#line 522
      cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 524
    tmp = strncmp((char const   *)cp, "TYPE:", (size_t )5);
    }
#line 524
    if (tmp == 0) {
      {
#line 525
      p = strtok((char */* __restrict  */)(buf), (char const   */* __restrict  */)":");
#line 526
      p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":");
      }
#line 527
      if (mode == 1) {
#line 528
        attack_mess[mess][level].level = -1;
#line 529
        attack_mess[mess][level].buf1 = (char *)((void *)0);
#line 530
        attack_mess[mess][level].buf2 = (char *)((void *)0);
#line 531
        attack_mess[mess][level].buf3 = (char *)((void *)0);
      }
      {
#line 533
      level = 0;
#line 534
      mess = atoi((char const   *)p);
#line 535
      mode = 1;
      }
#line 536
      goto while_continue;
    }
#line 538
    if (mode == 1) {
      {
#line 539
      p = strtok((char */* __restrict  */)(buf), (char const   */* __restrict  */)"=");
#line 540
      attack_mess[mess][level].level = atoi((char const   *)(buf));
#line 541
      p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"=");
      }
#line 542
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 543
        attack_mess[mess][level].buf1 = strdup_local((char const   *)p);
        }
      } else {
        {
#line 545
        attack_mess[mess][level].buf1 = strdup_local("");
        }
      }
#line 546
      mode = 2;
#line 547
      goto while_continue;
    } else
#line 548
    if (mode == 2) {
      {
#line 549
      p = strtok((char */* __restrict  */)(buf), (char const   */* __restrict  */)"=");
#line 550
      attack_mess[mess][level].level = atoi((char const   *)(buf));
#line 551
      p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"=");
      }
#line 552
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 553
        attack_mess[mess][level].buf2 = strdup_local((char const   *)p);
        }
      } else {
        {
#line 555
        attack_mess[mess][level].buf2 = strdup_local("");
        }
      }
#line 556
      mode = 3;
#line 557
      goto while_continue;
    } else
#line 558
    if (mode == 3) {
      {
#line 559
      p = strtok((char */* __restrict  */)(buf), (char const   */* __restrict  */)"=");
#line 560
      attack_mess[mess][level].level = atoi((char const   *)(buf));
#line 561
      p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"=");
      }
#line 562
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 563
        attack_mess[mess][level].buf3 = strdup_local((char const   *)p);
        }
      } else {
        {
#line 565
        attack_mess[mess][level].buf3 = strdup_local("");
        }
      }
#line 566
      mode = 1;
#line 567
      level ++;
#line 568
      total ++;
#line 569
      goto while_continue;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 572
  LOG((LogLevel )2, "got %d messages in %d categories.\n", total, mess + 1);
#line 573
  fclose(fp);
  }
#line 574
  return;
}
}
#line 68 "../include/libproto.h"
void add_friendly_object(object *op ) ;
#line 71
void clean_friendly_list(void) ;
#line 72
int is_friendly(object const   *op ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/friend.c"
void add_friendly_object(object *op ) 
{ 
  objectlink *ol ;
  int tmp ;

  {
  {
#line 51
  tmp = is_friendly((object const   *)op);
  }
#line 51
  if (tmp) {
    {
#line 52
    LOG((LogLevel )0, "add_friendly_object: Trying to add object already on list (%s)\n",
        op->name);
    }
#line 53
    return;
  }
  {
#line 56
  ol = first_friendly_object;
#line 57
  first_friendly_object = get_objectlink();
#line 58
  first_friendly_object->ob = op;
#line 59
  first_friendly_object->id = op->count;
#line 60
  first_friendly_object->next = ol;
  }
#line 61
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/friend.c"
void remove_friendly_object(object *op ) 
{ 
  objectlink *this ;
  objectlink *prev ;
  char const   *tmp ;

  {
#line 72
  op->flags[0] &= ~ (1U << 15);
#line 74
  if (! first_friendly_object) {
    {
#line 75
    LOG((LogLevel )0, "remove_friendly_object called with empty friendly list, remove ob=%s\n",
        op->name);
    }
#line 76
    return;
  }
#line 81
  if ((unsigned long )first_friendly_object->ob == (unsigned long )op) {
    {
#line 82
    this = first_friendly_object;
#line 83
    first_friendly_object = this->next;
#line 84
    free((void *)this);
    }
  } else {
#line 86
    prev = first_friendly_object;
#line 88
    this = first_friendly_object->next;
    {
#line 88
    while (1) {
      while_continue: /* CIL Label */ ;
#line 88
      if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 88
        goto while_break;
      }
#line 89
      if ((unsigned long )this->ob == (unsigned long )op) {
#line 90
        goto while_break;
      }
#line 91
      prev = this;
#line 88
      this = this->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 93
    if (this) {
#line 97
      if (this->id != op->count) {
#line 98
        if (op->name) {
#line 98
          tmp = op->name;
        } else {
#line 98
          tmp = "none";
        }
        {
#line 98
        LOG((LogLevel )0, "remove_friendly_object, tags do no match, %s, %u != %u\n",
            tmp, op->count, this->id);
        }
      }
      {
#line 101
      prev->next = this->next;
#line 102
      free((void *)this);
      }
    }
  }
#line 105
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/friend.c"
void dump_friendly_objects(void) 
{ 
  objectlink *ol ;

  {
#line 116
  ol = first_friendly_object;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! ((unsigned long )ol != (unsigned long )((void *)0))) {
#line 116
      goto while_break;
    }
    {
#line 117
    LOG((LogLevel )0, "%s (%u)\n", (ol->ob)->name, (ol->ob)->count);
#line 116
    ol = ol->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/friend.c"
void clean_friendly_list(void) 
{ 
  objectlink *this ;
  objectlink *prev ;
  objectlink *next ;
  int count ;

  {
#line 125
  prev = (objectlink *)((void *)0);
#line 126
  count = 0;
#line 128
  this = first_friendly_object;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! ((unsigned long )this != (unsigned long )((void *)0))) {
#line 128
      goto while_break;
    }
#line 129
    next = this->next;
#line 130
    if ((this->ob)->flags[0] & (1U << 3)) {
#line 130
      goto _L;
    } else
#line 130
    if (! ((this->ob)->flags[0] & (1U << 15))) {
#line 130
      goto _L;
    } else
#line 130
    if (this->id != (this->ob)->count) {
      _L: /* CIL Label */ 
#line 133
      if (prev) {
#line 134
        prev->next = this->next;
      } else {
#line 136
        first_friendly_object = this->next;
      }
      {
#line 138
      count ++;
#line 139
      free((void *)this);
      }
    } else {
#line 142
      prev = this;
    }
#line 128
    this = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  if (count) {
    {
#line 145
    LOG((LogLevel )2, "clean_friendly_list: Removed %d bogus links\n", count);
    }
  }
#line 146
  return;
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/friend.c"
int is_friendly(object const   *op ) 
{ 
  objectlink *ol ;

  {
#line 160
  ol = first_friendly_object;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! ((unsigned long )ol != (unsigned long )((void *)0))) {
#line 160
      goto while_break;
    }
#line 161
    if ((unsigned long )ol->ob == (unsigned long )op) {
#line 162
      return (1);
    }
#line 160
    ol = ol->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return (0);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
static artifactlist *get_empty_artifactlist___0(void) 
{ 
  artifactlist *tl ;
  void *tmp ;

  {
  {
#line 51
  tmp = malloc(sizeof(artifactlist ));
#line 51
  tl = (artifactlist *)tmp;
  }
#line 52
  if ((unsigned long )tl == (unsigned long )((void *)0)) {
    {
#line 53
    fatal(0);
    }
  }
#line 54
  tl->next = (struct artifactliststruct *)((void *)0);
#line 55
  tl->items = (struct artifactstruct *)((void *)0);
#line 56
  tl->total_chance = (uint16 )0;
#line 57
  return (tl);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
static artifact *get_empty_artifact___0(void) 
{ 
  artifact *t ;
  void *tmp ;

  {
  {
#line 70
  tmp = malloc(sizeof(artifact ));
#line 70
  t = (artifact *)tmp;
  }
#line 71
  if ((unsigned long )t == (unsigned long )((void *)0)) {
    {
#line 72
    fatal(0);
    }
  }
#line 73
  t->item = (object *)((void *)0);
#line 74
  t->next = (struct artifactstruct *)((void *)0);
#line 75
  t->chance = (uint16 )0;
#line 76
  t->difficulty = (uint8 )0;
#line 77
  t->allowed = (linked_char *)((void *)0);
#line 78
  t->allowed_size = 0;
#line 79
  return (t);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
static void free_charlinks___0(linked_char *lc ) 
{ 


  {
#line 89
  if (lc->next) {
    {
#line 90
    free_charlinks___0(lc->next);
    }
  }
  {
#line 91
  free((void *)lc);
  }
#line 92
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
static void free_artifact___0(artifact *at ) 
{ 
  object *next ;

  {
#line 109
  if (at->next) {
    {
#line 110
    free_artifact___0(at->next);
    }
  }
#line 111
  if (at->allowed) {
    {
#line 112
    free_charlinks___0(at->allowed);
    }
  }
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! at->item) {
#line 113
      goto while_break;
    }
#line 114
    next = (at->item)->next;
#line 115
    if ((at->item)->name) {
      {
#line 116
      free_string((at->item)->name);
      }
    }
#line 117
    if ((at->item)->name_pl) {
      {
#line 118
      free_string((at->item)->name_pl);
      }
    }
#line 119
    if ((at->item)->msg) {
      {
#line 120
      free_string((at->item)->msg);
      }
    }
#line 121
    if ((at->item)->title) {
      {
#line 122
      free_string((at->item)->title);
      }
    }
    {
#line 123
    object_free_key_values(at->item);
#line 124
    free((void *)at->item);
#line 125
    at->item = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  free((void *)at);
  }
#line 128
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
static void free_artifactlist___0(artifactlist *al ) 
{ 
  artifactlist *nextal ;

  {
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! ((unsigned long )al != (unsigned long )((void *)0))) {
#line 139
      goto while_break;
    }
#line 140
    nextal = al->next;
#line 141
    if (al->items) {
      {
#line 142
      free_artifact___0(al->items);
      }
    }
    {
#line 144
    free((void *)al);
#line 139
    al = nextal;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return;
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
static artifactlist *find_artifactlist_internal___0(int type ) 
{ 
  artifactlist *al ;

  {
#line 474
  al = first_artifactlist;
  {
#line 474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 474
    if (! ((unsigned long )al != (unsigned long )((void *)0))) {
#line 474
      goto while_break;
    }
#line 475
    if ((int )al->type == type) {
#line 476
      return (al);
    }
#line 474
    al = al->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  return ((artifactlist *)((void *)0));
}
}
#line 485 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/artifact.c"
static int has_been_inited___0  =    0;
#line 67 "../include/stringbuffer.h"
void stringbuffer_delete(StringBuffer *sb ) ;
#line 91
sstring stringbuffer_finish_shared(StringBuffer *sb ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/stringbuffer.c"
static void stringbuffer_ensure(StringBuffer *sb , size_t len ) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/stringbuffer.c"
StringBuffer *stringbuffer_new(void) 
{ 
  StringBuffer *sb ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 67
  tmp = malloc(sizeof(*sb));
#line 67
  sb = (StringBuffer *)tmp;
  }
#line 68
  if ((unsigned long )sb == (unsigned long )((void *)0)) {
    {
#line 69
    fatal(0);
    }
  }
  {
#line 72
  sb->size = (size_t )256;
#line 73
  tmp___0 = malloc(sb->size);
#line 73
  sb->buf = (char *)tmp___0;
#line 74
  sb->pos = (size_t )0;
  }
#line 75
  return (sb);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/stringbuffer.c"
void stringbuffer_delete(StringBuffer *sb ) 
{ 


  {
  {
#line 79
  free((void *)sb->buf);
#line 80
  free((void *)sb);
  }
#line 81
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/stringbuffer.c"
char *stringbuffer_finish(StringBuffer *sb ) 
{ 
  char *result ;

  {
  {
#line 86
  *(sb->buf + sb->pos) = (char )'\000';
#line 87
  result = sb->buf;
#line 88
  free((void *)sb);
  }
#line 89
  return (result);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/stringbuffer.c"
sstring stringbuffer_finish_shared(StringBuffer *sb ) 
{ 
  char *str ;
  sstring result ;

  {
  {
#line 96
  str = stringbuffer_finish(sb);
#line 97
  result = add_string((char const   *)str);
#line 98
  free((void *)str);
  }
#line 99
  return (result);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/stringbuffer.c"
void stringbuffer_append_string(StringBuffer *sb , char const   *str ) 
{ 
  size_t len ;

  {
  {
#line 105
  len = strlen(str);
#line 106
  stringbuffer_ensure(sb, len + 1UL);
#line 107
  memcpy((void */* __restrict  */)(sb->buf + sb->pos), (void const   */* __restrict  */)str,
         len);
#line 108
  sb->pos += len;
  }
#line 109
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/stringbuffer.c"
void stringbuffer_append_printf(StringBuffer *sb , char const   *format  , ...) 
{ 
  size_t size ;
  int n ;
  va_list arg ;

  {
#line 114
  size = (size_t )100;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 119
    stringbuffer_ensure(sb, size);
#line 121
    __builtin_va_start(arg, format);
#line 122
    n = vsnprintf((char */* __restrict  */)(sb->buf + sb->pos), size, (char const   */* __restrict  */)format,
                  arg);
#line 123
    __builtin_va_end(arg);
    }
#line 125
    if (n > -1) {
#line 125
      if ((size_t )n < size) {
#line 126
        sb->pos += (size_t )n;
#line 127
        goto while_break;
      }
    }
#line 130
    if (n > -1) {
#line 131
      size = (size_t )(n + 1);
    } else {
#line 133
      size *= 2UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/stringbuffer.c"
void stringbuffer_append_stringbuffer(StringBuffer *sb , StringBuffer const   *sb2 ) 
{ 


  {
  {
#line 139
  stringbuffer_ensure(sb, (size_t )(sb2->pos + 1UL));
#line 140
  memcpy((void */* __restrict  */)(sb->buf + sb->pos), (void const   */* __restrict  */)sb2->buf,
         (size_t )sb2->pos);
#line 141
  sb->pos += (size_t )sb2->pos;
  }
#line 142
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/stringbuffer.c"
static void stringbuffer_ensure(StringBuffer *sb , size_t len ) 
{ 
  char *tmp ;
  size_t new_size ;
  void *tmp___0 ;

  {
#line 148
  if (sb->pos + len <= sb->size) {
#line 149
    return;
  }
  {
#line 152
  new_size = (sb->pos + len) + 256UL;
#line 153
  tmp___0 = realloc((void *)sb->buf, new_size);
#line 153
  tmp = (char *)tmp___0;
  }
#line 154
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 155
    fatal(0);
    }
  }
#line 157
  sb->buf = tmp;
#line 158
  sb->size = new_size;
#line 159
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/stringbuffer.c"
size_t stringbuffer_length(StringBuffer *sb ) 
{ 


  {
#line 162
  return (sb->pos);
}
}
#line 83 "../include/libproto.h"
void dump_abilities(void) ;
#line 84
void print_monsters(void) ;
#line 113
StringBuffer *describe_item(object const   *op , object const   *owner , StringBuffer *buf ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/info.c"
static void bitstostring(long bits , int num , char *str ) 
{ 
  int i ;
  int j ;

  {
#line 53
  j = 0;
#line 55
  if (num > 32) {
#line 56
    num = 32;
  }
#line 58
  i = 0;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (i < num)) {
#line 58
      goto while_break;
    }
#line 59
    if (i) {
#line 59
      if (i % 3 == 0) {
#line 60
        *(str + (i + j)) = (char )' ';
#line 61
        j ++;
      }
    }
#line 63
    if (bits & 1L) {
#line 64
      *(str + (i + j)) = (char )'1';
    } else {
#line 66
      *(str + (i + j)) = (char )'0';
    }
#line 67
    bits >>= 1;
#line 58
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  *(str + (i + j)) = (char )'\000';
#line 70
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/info.c"
void dump_abilities(void) 
{ 
  archetype *at ;
  char *name ;
  char const   *gen_name ;
  archetype *gen ;
  StringBuffer *tmp ;

  {
#line 80
  at = first_archetype;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! at) {
#line 80
      goto while_break;
    }
#line 81
    gen_name = "";
#line 84
    if (! (at->clone.flags[0] & (1U << 14))) {
#line 85
      goto __Cont;
    }
#line 88
    if (at->clone.flags[0] & (1U << 31)) {
#line 89
      goto __Cont;
    }
#line 91
    gen = first_archetype;
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 91
      if (! gen) {
#line 91
        goto while_break___0;
      }
#line 92
      if (gen->clone.other_arch) {
#line 92
        if ((unsigned long )gen->clone.other_arch == (unsigned long )at) {
#line 93
          gen_name = gen->name;
#line 94
          goto while_break___0;
        }
      }
#line 91
      gen = gen->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 98
    tmp = describe_item((object const   *)(& at->clone), (object const   *)((void *)0),
                        (StringBuffer *)((void *)0));
#line 98
    name = stringbuffer_finish(tmp);
#line 99
    printf((char const   */* __restrict  */)"%-16s|%6ld|%4d|%3d|%s|%s|%s\n", at->clone.name,
           at->clone.stats.exp, (int )at->clone.stats.hp, (int )at->clone.stats.ac,
           name, at->name, gen_name);
#line 101
    free((void *)name);
    }
    __Cont: /* CIL Label */ 
#line 80
    at = at->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/info.c"
void print_monsters(void) 
{ 
  archetype *at ;
  object *op ;
  char attbuf[34] ;
  int i ;
  sint64 tmp ;

  {
  {
#line 114
  printf((char const   */* __restrict  */)"               |     |   |    |    |      attack       |                        resistances                                                                       |\n");
#line 115
  printf((char const   */* __restrict  */)"monster        | hp  |dam| ac | wc |pmf ecw adw gpd ptf|phy mag fir ele cld cfs acd drn wmg ght poi slo par tud fer cnc dep dth chs csp gpw hwd bln int |  exp   | new exp |\n");
#line 116
  printf((char const   */* __restrict  */)"---------------------------------------------------------------------------------------------------------------------------------------------------\n");
#line 117
  at = first_archetype;
  }
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! ((unsigned long )at != (unsigned long )((void *)0))) {
#line 117
      goto while_break;
    }
    {
#line 118
    op = arch_to_object(at);
    }
#line 119
    if (op->flags[0] & (1U << 14)) {
      {
#line 120
      bitstostring((long )op->attacktype, 26, attbuf);
#line 121
      printf((char const   */* __restrict  */)"%-15s|%5d|%3d|%4d|%4d|%s|", (op->arch)->name,
             (int )op->stats.maxhp, (int )op->stats.dam, (int )op->stats.ac, (int )op->stats.wc,
             attbuf);
#line 124
      i = 0;
      }
      {
#line 124
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 124
        if (! (i < 26)) {
#line 124
          goto while_break___0;
        }
        {
#line 125
        printf((char const   */* __restrict  */)"%4d", (int )op->resist[i]);
#line 124
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 126
      tmp = new_exp((object const   *)op);
#line 126
      printf((char const   */* __restrict  */)"|%8ld|%9ld|\n", op->stats.exp, tmp);
      }
    }
    {
#line 128
    object_free_drop_inventory(op);
#line 117
    at = at->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  return;
}
}
#line 43 "../include/libproto.h"
void trigger_connected(objectlink *ol , object *cause , int const   state ) ;
#line 44
void push_button(object *op ) ;
#line 45
void update_button(object *op ) ;
#line 46
void update_buttons(mapstruct *m ) ;
#line 47
void use_trigger(object *op ) ;
#line 48
void animate_turning(object *op ) ;
#line 49
int check_altar_sacrifice(object const   *altar , object const   *sacrifice , int remove_others ,
                          int *toremove ) ;
#line 50
int operate_altar(object *altar , object **sacrifice ) ;
#line 54
int get_button_value(object const   *button ) ;
#line 55
object *check_inv_recursive(object *op , object const   *trig ) ;
#line 56
void check_inv(object *op , object *trig ) ;
#line 57
void verify_button_links(mapstruct const   *map ) ;
#line 218
extern method_ret ob_trigger(object *op , object *cause , int state ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/button.c"
static objectlink *get_button_links(object const   *button ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/button.c"
void trigger_connected(objectlink *ol , object *cause , int const   state ) 
{ 
  object *tmp ;
  object *part ;
  char const   *tmp___0 ;
  int tmp___1 ;
  sint32 tmp___2 ;
  sint32 tmp___3 ;
  sint16 tmp___4 ;

  {
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! ol) {
#line 55
      goto while_break;
    }
#line 58
    if (! ol->ob) {
#line 58
      goto _L;
    } else
#line 58
    if ((ol->ob)->count != ol->id) {
      _L: /* CIL Label */ 
#line 59
      if (cause) {
#line 59
        if (cause->name) {
#line 59
          tmp___0 = cause->name;
        } else {
#line 59
          tmp___0 = "";
        }
      } else {
#line 59
        tmp___0 = "";
      }
      {
#line 59
      LOG((LogLevel )0, "Internal error in trigger_connect. No object associated with link id (%u) (cause=\'%s\'.\n",
          ol->id, tmp___0);
      }
#line 60
      goto __Cont;
    }
#line 70
    if ((ol->ob)->flags[0] & (1U << 3)) {
#line 71
      return;
    }
#line 72
    tmp = ol->ob;
#line 75
    if (state) {
#line 75
      if (! (tmp->flags[3] & (1U << 9))) {
#line 76
        goto __Cont;
      }
    }
#line 77
    if (! state) {
#line 77
      if (! (tmp->flags[3] & (1U << 10))) {
#line 78
        goto __Cont;
      }
    }
    {
#line 85
    tmp___1 = execute_event(tmp, 10, cause, (object *)((void *)0), (char const   *)((void *)0),
                            1);
    }
#line 85
    if (tmp___1 != 0) {
#line 86
      goto __Cont;
    }
    {
#line 90
    if ((int )tmp->type == 94) {
#line 90
      goto case_94;
    }
#line 90
    if ((int )tmp->type == 91) {
#line 90
      goto case_94;
    }
#line 96
    if ((int )tmp->type == 93) {
#line 96
      goto case_93;
    }
#line 101
    if ((int )tmp->type == 98) {
#line 101
      goto case_98;
    }
#line 111
    if ((int )tmp->type == 18) {
#line 111
      goto case_18;
    }
#line 118
    if ((int )tmp->type == 17) {
#line 118
      goto case_17;
    }
#line 118
    if ((int )tmp->type == 92) {
#line 118
      goto case_17;
    }
#line 124
    if ((int )tmp->type == 26) {
#line 124
      goto case_26;
    }
#line 135
    if ((int )tmp->type == 62) {
#line 135
      goto case_62;
    }
#line 135
    if ((int )tmp->type == 112) {
#line 135
      goto case_62;
    }
#line 145
    goto switch_default;
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
#line 91
    if (tmp->stats.maxsp) {
#line 91
      tmp->value = ! state;
    } else {
#line 91
      tmp->value = (sint32 )state;
    }
    {
#line 92
    tmp->speed = (float )0.5;
#line 93
    object_update_speed(tmp);
    }
#line 94
    goto switch_break;
    case_93: /* CIL Label */ 
#line 97
    if (tmp->temp_animation_id) {
#line 97
      if (tmp->stats.maxsp) {
#line 97
        tmp___2 = ! state;
      } else {
#line 97
        tmp___2 = (sint32 )state;
      }
#line 97
      tmp->value = tmp___2;
#line 97
      tmp->face = *((animations + tmp->temp_animation_id)->faces + tmp___2);
    } else {
#line 97
      if (tmp->stats.maxsp) {
#line 97
        tmp___3 = ! state;
      } else {
#line 97
        tmp___3 = (sint32 )state;
      }
#line 97
      tmp->value = tmp___3;
#line 97
      tmp->face = *((animations + tmp->animation_id)->faces + tmp___3);
    }
    {
#line 98
    object_update(tmp, 4);
    }
#line 99
    goto switch_break;
    case_98: /* CIL Label */ 
#line 102
    if (! tmp->stats.food) {
#line 102
      goto _L___0;
    } else
#line 102
    if (tmp->last_eat < tmp->stats.food) {
      _L___0: /* CIL Label */ 
      {
#line 103
      ext_info_map(258, (mapstruct const   *)tmp->map, (uint8 )4, (uint8 )0, tmp->msg);
      }
#line 106
      if (tmp->stats.food) {
#line 107
        (tmp->last_eat) ++;
      }
    }
#line 109
    goto switch_break;
    case_18: /* CIL Label */ 
#line 112
    tmp->value = 1;
#line 113
    if (tmp->temp_animation_id) {
#line 113
      tmp->face = *((animations + tmp->temp_animation_id)->faces + tmp->value);
    } else {
#line 113
      tmp->face = *((animations + tmp->animation_id)->faces + tmp->value);
    }
    {
#line 114
    object_update(tmp, 4);
    }
#line 115
    goto switch_break;
    case_17: /* CIL Label */ 
    case_92: /* CIL Label */ 
#line 119
    tmp->value = (sint32 )state;
#line 120
    if (tmp->temp_animation_id) {
#line 120
      tmp->face = *((animations + tmp->temp_animation_id)->faces + tmp->value);
    } else {
#line 120
      tmp->face = *((animations + tmp->animation_id)->faces + tmp->value);
    }
    {
#line 121
    object_update(tmp, 4);
    }
#line 122
    goto switch_break;
    case_26: /* CIL Label */ 
#line 125
    part = tmp;
    {
#line 125
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 125
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 125
        goto while_break___0;
      }
      {
#line 126
      part->speed = (tmp->arch)->clone.speed;
#line 127
      part->value = (tmp->arch)->clone.value;
#line 128
      part->stats.sp = (sint16 )1;
#line 129
      part->stats.hp = tmp->stats.maxhp;
#line 130
      object_update_speed(part);
#line 125
      tmp = tmp->more;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 132
    goto switch_break;
    case_62: /* CIL Label */ 
    case_112: /* CIL Label */ 
#line 136
    if (! (tmp->flags[0] & (1U << 11))) {
#line 136
      if ((int )tmp->type == 62) {
        {
#line 137
        move_firewall(tmp);
        }
      } else {
#line 136
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 139
      tmp___4 = (sint16 )((int )tmp->stats.sp + (int )tmp->stats.maxsp);
#line 139
      tmp->stats.sp = tmp___4;
#line 139
      if ((int )tmp___4 > 8) {
#line 140
        tmp->stats.sp = (sint16 )(((int )tmp->stats.sp - 1) % 8 + 1);
      }
      {
#line 141
      animate_turning(tmp);
      }
    }
#line 143
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 146
    ob_trigger(tmp, cause, (int )state);
    }
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 55
    ol = ol->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/button.c"
void push_button(object *op ) 
{ 
  objectlink *tmp ;

  {
  {
#line 161
  tmp = get_button_links((object const   *)op);
#line 161
  trigger_connected(tmp, op, (int const   )op->value);
  }
#line 162
  return;
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/button.c"
void update_button(object *op ) 
{ 
  object *tmp ;
  object *head ;
  int tot ;
  int any_down ;
  int old_value ;
  objectlink *ol ;
  object *ab ;
  object *next187 ;
  tag_t next_tag187 ;
  tag_t tmp___0 ;
  uint32 tmp___1 ;
  object *ab___0 ;
  object *next210 ;
  tag_t next_tag210 ;
  tag_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 174
  any_down = 0;
#line 174
  old_value = op->value;
#line 178
  ol = get_button_links((object const   *)op);
  }
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! ol) {
#line 178
      goto while_break;
    }
#line 179
    if (! ol->ob) {
      {
#line 180
      LOG((LogLevel )2, "Internal error in update_button (%s).\n", op->name);
      }
#line 181
      goto __Cont;
    } else
#line 179
    if ((ol->ob)->count != ol->id) {
      {
#line 180
      LOG((LogLevel )2, "Internal error in update_button (%s).\n", op->name);
      }
#line 181
      goto __Cont;
    }
#line 184
    tmp = ol->ob;
#line 185
    if ((int )tmp->type == 92) {
#line 186
      tot = 0;
      {
#line 187
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 187
        ab = tmp->above;
        {
#line 187
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 187
          next187 = ab;
#line 187
          if ((unsigned long )next187 == (unsigned long )((void *)0)) {
#line 187
            tmp___0 = (tag_t )0;
          } else {
#line 187
            tmp___0 = next187->count;
          }
#line 187
          next_tag187 = tmp___0;
          {
#line 187
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 187
            ab = next187;
#line 187
            if (! ((unsigned long )ab != (unsigned long )((void *)0))) {
#line 187
              goto while_break___2;
            }
#line 187
            if (next187->count != next_tag187) {
#line 187
              goto while_break___2;
            } else
#line 187
            if (next187->flags[0] & (1U << 3)) {
#line 187
              goto while_break___2;
            }
#line 187
            next187 = next187->above;
#line 187
            if ((unsigned long )next187 == (unsigned long )((void *)0)) {
#line 187
              next_tag187 = (tag_t )0;
            } else {
#line 187
              next_tag187 = next187->count;
            }
#line 201
            if ((int )ab->move_type & (int )tmp->move_on) {
#line 201
              goto _L;
            } else
#line 201
            if ((int )ab->move_type == 0) {
              _L: /* CIL Label */ 
#line 202
              if (ab->nrof) {
#line 202
                tmp___1 = ab->nrof;
              } else {
#line 202
                tmp___1 = (uint32 )1;
              }
#line 202
              tot = (int )((uint32 )tot + ((uint32 )ab->weight * tmp___1 + (uint32 )ab->carrying));
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 187
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 187
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 205
      if (tot >= tmp->weight) {
#line 205
        tmp->value = 1;
      } else {
#line 205
        tmp->value = 0;
      }
#line 206
      if (tmp->value) {
#line 207
        any_down = 1;
      }
    } else
#line 208
    if ((int )tmp->type == 17) {
#line 209
      tmp->value = 0;
      {
#line 210
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 210
        ab___0 = tmp->above;
        {
#line 210
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 210
          next210 = ab___0;
#line 210
          if ((unsigned long )next210 == (unsigned long )((void *)0)) {
#line 210
            tmp___2 = (tag_t )0;
          } else {
#line 210
            tmp___2 = next210->count;
          }
#line 210
          next_tag210 = tmp___2;
          {
#line 210
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 210
            ab___0 = next210;
#line 210
            if (! ((unsigned long )ab___0 != (unsigned long )((void *)0))) {
#line 210
              goto while_break___5;
            }
#line 210
            if (next210->count != next_tag210) {
#line 210
              goto while_break___5;
            } else
#line 210
            if (next210->flags[0] & (1U << 3)) {
#line 210
              goto while_break___5;
            }
#line 210
            next210 = next210->above;
#line 210
            if ((unsigned long )next210 == (unsigned long )((void *)0)) {
#line 210
              next_tag210 = (tag_t )0;
            } else {
#line 210
              next_tag210 = next210->count;
            }
#line 211
            if (ab___0->head) {
#line 211
              head = ab___0->head;
            } else {
#line 211
              head = ab___0;
            }
#line 213
            if ((int )head->move_type & (int )tmp->move_on) {
#line 213
              goto _L___1;
            } else
#line 213
            if ((int )ab___0->move_type == 0) {
              _L___1: /* CIL Label */ 
#line 213
              if ((unsigned long )head->race == (unsigned long )tmp->slaying) {
#line 217
                tmp->value = 1;
              } else
#line 213
              if ((int )head->type == 21) {
#line 213
                if ((unsigned long )head->slaying == (unsigned long )tmp->slaying) {
#line 217
                  tmp->value = 1;
                } else {
#line 213
                  goto _L___0;
                }
              } else {
                _L___0: /* CIL Label */ 
                {
#line 213
                tmp___3 = strcmp(tmp->slaying, "player");
                }
#line 213
                if (! tmp___3) {
#line 213
                  if ((int )head->type == 1) {
#line 217
                    tmp->value = 1;
                  }
                }
              }
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 210
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 210
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 219
      if (tmp->value) {
#line 220
        any_down = 1;
      }
    }
    __Cont: /* CIL Label */ 
#line 178
    ol = ol->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  if (any_down) {
#line 224
    op->value = 1;
  }
#line 227
  if (op->value != old_value) {
#line 228
    if (op->temp_animation_id) {
#line 228
      op->face = *((animations + op->temp_animation_id)->faces + op->value);
    } else {
#line 228
      op->face = *((animations + op->animation_id)->faces + op->value);
    }
    {
#line 229
    object_update(op, 4);
#line 230
    push_button(op);
    }
  }
#line 232
  return;
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/button.c"
void update_buttons(mapstruct *m ) 
{ 
  objectlink *ol ;
  oblinkpt *obp ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 241
  obp = m->buttons;
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! obp) {
#line 241
      goto while_break;
    }
#line 242
    ol = obp->link;
    {
#line 242
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 242
      if (! ol) {
#line 242
        goto while_break___0;
      }
#line 243
      if (! ol->ob) {
#line 243
        goto _L;
      } else
#line 243
      if ((ol->ob)->count != ol->id) {
        _L: /* CIL Label */ 
#line 244
        if (ol->ob) {
#line 244
          tmp = (int )(ol->ob)->y;
        } else {
#line 244
          tmp = -1;
        }
#line 244
        if (ol->ob) {
#line 244
          tmp___0 = (int )(ol->ob)->x;
        } else {
#line 244
          tmp___0 = -1;
        }
#line 244
        if (ol->ob) {
#line 244
          tmp___1 = (ol->ob)->name;
        } else {
#line 244
          tmp___1 = "null";
        }
        {
#line 244
        LOG((LogLevel )0, "Internal error in update_button (%s (%dx%d):%u, connected %ld).\n",
            tmp___1, tmp___0, tmp, ol->id, obp->value);
        }
#line 250
        goto __Cont;
      }
#line 252
      if ((int )(ol->ob)->type == 92) {
        {
#line 253
        update_button(ol->ob);
        }
#line 254
        goto while_break___0;
      } else
#line 252
      if ((int )(ol->ob)->type == 17) {
        {
#line 253
        update_button(ol->ob);
        }
#line 254
        goto while_break___0;
      }
      __Cont: /* CIL Label */ 
#line 242
      ol = ol->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 241
    obp = obp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  return;
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/button.c"
void use_trigger(object *op ) 
{ 


  {
  {
#line 266
  op->value = ! op->value;
#line 267
  push_button(op);
  }
#line 268
  return;
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/button.c"
void animate_turning(object *op ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 281
  op->state = (uint8 )((int )op->state + 1);
#line 281
  if (op->temp_animation_id) {
#line 281
    tmp = (int )(animations + op->temp_animation_id)->num_animations;
  } else {
#line 281
    tmp = (int )(animations + op->animation_id)->num_animations;
  }
#line 281
  if ((int )op->state >= tmp / 8) {
#line 282
    op->state = (uint8 )0;
  }
#line 283
  if (op->temp_animation_id) {
#line 283
    if (op->temp_animation_id) {
#line 283
      tmp___0 = (int )(animations + op->temp_animation_id)->num_animations;
    } else {
#line 283
      tmp___0 = (int )(animations + op->animation_id)->num_animations;
    }
#line 283
    op->face = *((animations + op->temp_animation_id)->faces + ((((int )op->stats.sp - 1) * tmp___0) / 8 + (int )op->state));
  } else {
#line 283
    if (op->temp_animation_id) {
#line 283
      tmp___1 = (int )(animations + op->temp_animation_id)->num_animations;
    } else {
#line 283
      tmp___1 = (int )(animations + op->animation_id)->num_animations;
    }
#line 283
    op->face = *((animations + op->animation_id)->faces + ((((int )op->stats.sp - 1) * tmp___1) / 8 + (int )op->state));
  }
  {
#line 284
  object_update(op, 4);
  }
#line 285
  return;
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/button.c"
static int matches_sacrifice(object const   *altar , object const   *sacrifice ) 
{ 
  char name[256] ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 304
  if (sacrifice->flags[0] & 1U) {
    {
#line 304
    tmp = object_get_value(altar, (char const   */* const  */)"accept_alive");
    }
#line 304
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 307
      return (0);
    } else {
#line 304
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 304
  if (sacrifice->flags[2] & (1U << 9)) {
#line 307
    return (0);
  } else
#line 304
  if ((int const   )sacrifice->type == 1) {
#line 307
    return (0);
  }
  {
#line 309
  query_base_name(sacrifice, 0, name, (size_t )256);
  }
#line 310
  if ((unsigned long )altar->slaying == (unsigned long )(sacrifice->arch)->name) {
#line 314
    return (1);
  } else
#line 310
  if ((unsigned long )altar->slaying == (unsigned long )sacrifice->name) {
#line 314
    return (1);
  } else
#line 310
  if ((unsigned long )altar->slaying == (unsigned long )sacrifice->slaying) {
#line 314
    return (1);
  } else {
    {
#line 310
    tmp___0 = strcmp((char const   *)altar->slaying, (char const   *)(name));
    }
#line 310
    if (! tmp___0) {
#line 314
      return (1);
    }
  }
  {
#line 316
  tmp___1 = strcmp((char const   *)altar->slaying, "money");
  }
#line 316
  if (tmp___1 == 0) {
#line 316
    if ((int const   )sacrifice->type == 36) {
#line 318
      return (1);
    }
  }
#line 320
  return (0);
}
}
#line 351 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/button.c"
int check_altar_sacrifice(object const   *altar , object const   *sacrifice , int remove_others ,
                          int *toremove ) 
{ 
  int money ;
  uint32 wanted ;
  uint32 rest ;
  int tmp ;
  int tmp___1 ;
  uint32 tmp___2 ;
  uint32 tmp___3 ;
  object *tmp___4 ;
  object *next394 ;
  tag_t next_tag394 ;
  tag_t tmp___5 ;
  int tmp___6 ;
  uint32 tmp___7 ;
  object *tmp___8 ;
  object *next419 ;
  tag_t next_tag419 ;
  tag_t tmp___9 ;
  int tmp___10 ;
  uint32 tmp___11 ;
  uint32 tmp___12 ;

  {
  {
#line 355
  tmp = matches_sacrifice(altar, sacrifice);
  }
#line 355
  if (! tmp) {
#line 358
    return (0);
  }
#line 361
  if (sacrifice->flags[0] & (1U << 6)) {
#line 362
    return (0);
  }
  {
#line 365
  tmp___1 = strcmp((char const   *)altar->slaying, "money");
  }
#line 365
  if (tmp___1 == 0) {
#line 365
    money = 1;
  } else {
#line 365
    money = 0;
  }
#line 368
  if (money) {
#line 368
    if (sacrifice->nrof * (uint32 const   )sacrifice->value >= (uint32 const   )((uint32 )altar->stats.food)) {
#line 369
      if (toremove) {
#line 370
        *toremove = (int )((uint32 )altar->stats.food / (uint32 )sacrifice->value);
#line 372
        if ((uint32 )altar->stats.food % (unsigned int )sacrifice->value) {
#line 373
          (*toremove) ++;
        }
      }
#line 375
      return (1);
    }
  }
#line 378
  if (! money) {
#line 378
    if (sacrifice->nrof) {
#line 378
      tmp___2 = sacrifice->nrof;
    } else {
#line 378
      tmp___2 = (uint32 const   )1;
    }
#line 378
    if ((uint32 )altar->stats.food <= (uint32 )tmp___2) {
#line 379
      if (toremove) {
#line 380
        *toremove = (int )((uint32 )altar->stats.food);
      }
#line 381
      return (1);
    }
  }
#line 384
  if (money) {
#line 385
    wanted = (uint32 )altar->stats.food - (uint32 )(sacrifice->nrof * (uint32 const   )sacrifice->value);
  } else {
#line 387
    if (sacrifice->nrof) {
#line 387
      tmp___3 = sacrifice->nrof;
    } else {
#line 387
      tmp___3 = (uint32 const   )1;
    }
#line 387
    wanted = (uint32 )altar->stats.food - (uint32 )tmp___3;
  }
#line 389
  rest = wanted;
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    tmp___4 = (object *)altar->above;
    {
#line 394
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 394
      next394 = tmp___4;
#line 394
      if ((unsigned long )next394 == (unsigned long )((void *)0)) {
#line 394
        tmp___5 = (tag_t )0;
      } else {
#line 394
        tmp___5 = next394->count;
      }
#line 394
      next_tag394 = tmp___5;
      {
#line 394
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 394
        tmp___4 = next394;
#line 394
        if (! ((unsigned long )tmp___4 != (unsigned long )((void *)0))) {
#line 394
          goto while_break___1;
        }
#line 394
        if (next394->count != next_tag394) {
#line 394
          goto while_break___1;
        } else
#line 394
        if (next394->flags[0] & (1U << 3)) {
#line 394
          goto while_break___1;
        }
#line 394
        next394 = next394->above;
#line 394
        if ((unsigned long )next394 == (unsigned long )((void *)0)) {
#line 394
          next_tag394 = (tag_t )0;
        } else {
#line 394
          next_tag394 = next394->count;
        }
#line 395
        if (wanted <= 0U) {
#line 396
          goto while_break___1;
        }
#line 397
        if ((unsigned long )tmp___4 == (unsigned long )sacrifice) {
#line 398
          goto while_continue___1;
        } else {
          {
#line 397
          tmp___6 = matches_sacrifice(altar, (object const   *)tmp___4);
          }
#line 397
          if (! tmp___6) {
#line 398
            goto while_continue___1;
          }
        }
#line 399
        if (money) {
#line 400
          wanted -= tmp___4->nrof * (uint32 )tmp___4->value;
        } else {
#line 402
          if (tmp___4->nrof) {
#line 402
            tmp___7 = tmp___4->nrof;
          } else {
#line 402
            tmp___7 = (uint32 )1;
          }
#line 402
          wanted -= tmp___7;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 394
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 394
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 405
  if (wanted > 0U) {
#line 407
    return (0);
  }
#line 412
  if (toremove) {
#line 413
    if (sacrifice->nrof) {
#line 413
      *toremove = (int )sacrifice->nrof;
    } else {
#line 413
      *toremove = 1;
    }
  }
#line 415
  if (! remove_others) {
#line 416
    return (1);
  }
  {
#line 419
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 419
    tmp___8 = (object *)altar->above;
    {
#line 419
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 419
      next419 = tmp___8;
#line 419
      if ((unsigned long )next419 == (unsigned long )((void *)0)) {
#line 419
        tmp___9 = (tag_t )0;
      } else {
#line 419
        tmp___9 = next419->count;
      }
#line 419
      next_tag419 = tmp___9;
      {
#line 419
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 419
        tmp___8 = next419;
#line 419
        if (! ((unsigned long )tmp___8 != (unsigned long )((void *)0))) {
#line 419
          goto while_break___4;
        }
#line 419
        if (next419->count != next_tag419) {
#line 419
          goto while_break___4;
        } else
#line 419
        if (next419->flags[0] & (1U << 3)) {
#line 419
          goto while_break___4;
        }
#line 419
        next419 = next419->above;
#line 419
        if ((unsigned long )next419 == (unsigned long )((void *)0)) {
#line 419
          next_tag419 = (tag_t )0;
        } else {
#line 419
          next_tag419 = next419->count;
        }
#line 420
        if (rest <= 0U) {
#line 421
          goto while_break___4;
        }
#line 422
        if ((unsigned long )tmp___8 == (unsigned long )sacrifice) {
#line 423
          goto while_continue___4;
        } else {
          {
#line 422
          tmp___10 = matches_sacrifice(altar, (object const   *)tmp___8);
          }
#line 422
          if (! tmp___10) {
#line 423
            goto while_continue___4;
          }
        }
#line 424
        if (money) {
#line 425
          wanted = tmp___8->nrof * (uint32 )tmp___8->value;
#line 426
          if (rest > wanted) {
            {
#line 427
            object_remove(tmp___8);
#line 428
            rest -= wanted;
            }
          } else {
#line 430
            wanted = rest / (uint32 )tmp___8->value;
#line 431
            if (rest % (unsigned int )tmp___8->value) {
#line 432
              wanted ++;
            }
            {
#line 433
            object_decrease_nrof(tmp___8, wanted);
            }
#line 434
            return (1);
          }
        } else {
#line 437
          if (tmp___8->nrof) {
#line 437
            tmp___12 = tmp___8->nrof;
          } else {
#line 437
            tmp___12 = (uint32 )1;
          }
#line 437
          if (rest > tmp___12) {
#line 438
            if (tmp___8->nrof) {
#line 438
              tmp___11 = tmp___8->nrof;
            } else {
#line 438
              tmp___11 = (uint32 )1;
            }
            {
#line 438
            rest -= tmp___11;
#line 439
            object_remove(tmp___8);
            }
          } else {
            {
#line 441
            object_decrease_nrof(tmp___8, rest);
            }
#line 442
            return (1);
          }
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 419
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 419
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 447
  LOG((LogLevel )0, "check_altar_sacrifice on %s: found objects to sacrifice, but couldn\'t remove them??\n",
      (altar->map)->path);
  }
#line 448
  return (1);
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/button.c"
int operate_altar(object *altar , object **sacrifice ) 
{ 
  int number ;
  int tmp ;

  {
#line 470
  if (! altar->map) {
    {
#line 471
    LOG((LogLevel )0, "BUG: operate_altar(): altar has no map\n");
    }
#line 472
    return (0);
  }
#line 475
  if (! altar->slaying) {
#line 476
    return (0);
  } else
#line 475
  if (altar->value) {
#line 476
    return (0);
  }
  {
#line 478
  tmp = check_altar_sacrifice((object const   *)altar, (object const   *)*sacrifice,
                              1, & number);
  }
#line 478
  if (! tmp) {
#line 479
    return (0);
  }
  {
#line 482
  *sacrifice = object_decrease_nrof(*sacrifice, (uint32 )number);
  }
#line 484
  if (altar->msg) {
    {
#line 485
    ext_info_map(0, (mapstruct const   *)altar->map, (uint8 )6, (uint8 )2, altar->msg);
    }
  }
#line 486
  return (1);
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/button.c"
static void trigger_move(object *op , int state ) 
{ 


  {
#line 493
  op->stats.wc = (sint8 )state;
#line 494
  if (state) {
    {
#line 495
    use_trigger(op);
    }
#line 496
    if (op->stats.exp > 0L) {
#line 497
      op->speed = (float )(1.0 / (double )op->stats.exp);
    } else {
#line 499
      op->speed = (float )1.0;
    }
    {
#line 500
    object_update_speed(op);
#line 501
    op->speed_left = (float )-1;
    }
  } else {
    {
#line 503
    use_trigger(op);
#line 504
    op->speed = (float )0;
#line 505
    object_update_speed(op);
    }
  }
#line 507
  return;
}
}
#line 522 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/button.c"
int check_trigger(object *op , object *cause ) 
{ 
  int push ;
  int tot ;
  int in_movement ;
  int tmp ;
  object *tmp___0 ;
  object *next530 ;
  tag_t next_tag530 ;
  tag_t tmp___1 ;
  uint32 tmp___2 ;
  int tmp___3 ;
  object *tmp___4 ;
  object *next560 ;
  tag_t next_tag560 ;
  tag_t tmp___5 ;
  object *head ;
  struct obj *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 523
  push = 0;
#line 523
  tot = 0;
#line 524
  if (op->stats.wc) {
#line 524
    tmp = 1;
  } else
#line 524
  if (op->speed) {
#line 524
    tmp = 1;
  } else {
#line 524
    tmp = 0;
  }
#line 524
  in_movement = tmp;
  {
#line 527
  if ((int )op->type == 30) {
#line 527
    goto case_30;
  }
#line 558
  if ((int )op->type == 32) {
#line 558
    goto case_32;
  }
#line 583
  if ((int )op->type == 31) {
#line 583
    goto case_31;
  }
#line 632
  if ((int )op->type == 27) {
#line 632
    goto case_27;
  }
#line 645
  goto switch_default;
  case_30: /* CIL Label */ 
#line 528
  if (op->weight > 0) {
#line 529
    if (cause) {
      {
#line 530
      while (1) {
        while_continue: /* CIL Label */ ;
#line 530
        tmp___0 = op->above;
        {
#line 530
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 530
          next530 = tmp___0;
#line 530
          if ((unsigned long )next530 == (unsigned long )((void *)0)) {
#line 530
            tmp___1 = (tag_t )0;
          } else {
#line 530
            tmp___1 = next530->count;
          }
#line 530
          next_tag530 = tmp___1;
          {
#line 530
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 530
            tmp___0 = next530;
#line 530
            if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 530
              goto while_break___1;
            }
#line 530
            if (next530->count != next_tag530) {
#line 530
              goto while_break___1;
            } else
#line 530
            if (next530->flags[0] & (1U << 3)) {
#line 530
              goto while_break___1;
            }
#line 530
            next530 = next530->above;
#line 530
            if ((unsigned long )next530 == (unsigned long )((void *)0)) {
#line 530
              next_tag530 = (tag_t )0;
            } else {
#line 530
              next_tag530 = next530->count;
            }
#line 538
            if ((int )tmp___0->move_type & (int )op->move_on) {
#line 538
              goto _L;
            } else
#line 538
            if ((int )tmp___0->move_type == 0) {
              _L: /* CIL Label */ 
#line 539
              if (tmp___0->nrof) {
#line 539
                tmp___2 = tmp___0->nrof;
              } else {
#line 539
                tmp___2 = (uint32 )1;
              }
#line 539
              tot = (int )((uint32 )tot + ((uint32 )tmp___0->weight * tmp___2 + (uint32 )tmp___0->carrying));
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 530
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 530
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 542
      if (tot >= op->weight) {
#line 543
        push = 1;
      }
#line 544
      if ((int )op->stats.ac == push) {
#line 545
        return (0);
      }
#line 546
      op->stats.ac = (sint8 )push;
#line 547
      if (op->temp_animation_id) {
#line 547
        tmp___3 = (int )(animations + op->temp_animation_id)->num_animations;
      } else {
#line 547
        tmp___3 = (int )(animations + op->animation_id)->num_animations;
      }
#line 547
      if (tmp___3 > 1) {
#line 548
        if (op->temp_animation_id) {
#line 548
          op->face = *((animations + op->temp_animation_id)->faces + push);
        } else {
#line 548
          op->face = *((animations + op->animation_id)->faces + push);
        }
        {
#line 549
        object_update(op, 4);
        }
      }
#line 551
      if (in_movement) {
#line 552
        return (0);
      } else
#line 551
      if (! push) {
#line 552
        return (0);
      }
    }
    {
#line 554
    trigger_move(op, push);
    }
  }
#line 556
  return (0);
  case_32: /* CIL Label */ 
#line 559
  if (cause) {
    {
#line 560
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 560
      tmp___4 = op->above;
      {
#line 560
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 560
        next560 = tmp___4;
#line 560
        if ((unsigned long )next560 == (unsigned long )((void *)0)) {
#line 560
          tmp___5 = (tag_t )0;
        } else {
#line 560
          tmp___5 = next560->count;
        }
#line 560
        next_tag560 = tmp___5;
        {
#line 560
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 560
          tmp___4 = next560;
#line 560
          if (! ((unsigned long )tmp___4 != (unsigned long )((void *)0))) {
#line 560
            goto while_break___4;
          }
#line 560
          if (next560->count != next_tag560) {
#line 560
            goto while_break___4;
          } else
#line 560
          if (next560->flags[0] & (1U << 3)) {
#line 560
            goto while_break___4;
          }
#line 560
          next560 = next560->above;
#line 560
          if ((unsigned long )next560 == (unsigned long )((void *)0)) {
#line 560
            next_tag560 = (tag_t )0;
          } else {
#line 560
            next_tag560 = next560->count;
          }
#line 561
          if (tmp___4->head) {
#line 561
            tmp___6 = tmp___4->head;
          } else {
#line 561
            tmp___6 = tmp___4;
          }
#line 561
          head = tmp___6;
#line 564
          if ((int )head->move_type & (int )op->move_on) {
#line 564
            goto _L___0;
          } else
#line 564
          if ((int )head->move_type == 0) {
            _L___0: /* CIL Label */ 
#line 564
            if ((unsigned long )head->race == (unsigned long )op->slaying) {
#line 566
              push = 1;
#line 567
              goto while_break___4;
            } else {
              {
#line 564
              tmp___7 = strcmp(op->slaying, "player");
              }
#line 564
              if (! tmp___7) {
#line 564
                if ((int )head->type == 1) {
#line 566
                  push = 1;
#line 567
                  goto while_break___4;
                }
              }
            }
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 560
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 560
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 570
    if ((int )op->stats.ac == push) {
#line 571
      return (0);
    }
#line 572
    op->stats.ac = (sint8 )push;
#line 573
    if (op->temp_animation_id) {
#line 573
      tmp___8 = (int )(animations + op->temp_animation_id)->num_animations;
    } else {
#line 573
      tmp___8 = (int )(animations + op->animation_id)->num_animations;
    }
#line 573
    if (tmp___8 > 1) {
#line 574
      if (op->temp_animation_id) {
#line 574
        op->face = *((animations + op->temp_animation_id)->faces + push);
      } else {
#line 574
        op->face = *((animations + op->animation_id)->faces + push);
      }
      {
#line 575
      object_update(op, 4);
      }
    }
#line 577
    if (in_movement) {
#line 578
      return (0);
    } else
#line 577
    if (! push) {
#line 578
      return (0);
    }
  }
  {
#line 580
  trigger_move(op, push);
  }
#line 581
  return (0);
  case_31: /* CIL Label */ 
#line 584
  if (cause) {
#line 585
    if (in_movement) {
#line 586
      return (0);
    }
    {
#line 587
    tmp___10 = operate_altar(op, & cause);
    }
#line 587
    if (tmp___10) {
#line 588
      if (op->temp_animation_id) {
#line 588
        tmp___9 = (int )(animations + op->temp_animation_id)->num_animations;
      } else {
#line 588
        tmp___9 = (int )(animations + op->animation_id)->num_animations;
      }
#line 588
      if (tmp___9 > 1) {
#line 589
        if (op->temp_animation_id) {
#line 589
          op->face = *((animations + op->temp_animation_id)->faces + 1);
        } else {
#line 589
          op->face = *((animations + op->animation_id)->faces + 1);
        }
        {
#line 590
        object_update(op, 4);
        }
      }
#line 593
      if (op->last_sp >= 0) {
        {
#line 594
        trigger_move(op, 1);
        }
#line 595
        if (op->last_sp > 0) {
#line 596
          op->last_sp = - op->last_sp;
        }
      } else {
        {
#line 601
        op->value = ! op->value;
#line 602
        trigger_move(op, 1);
#line 603
        op->last_sp = - op->last_sp;
#line 604
        op->value = ! op->value;
        }
      }
#line 606
      return ((unsigned long )cause == (unsigned long )((void *)0));
    } else {
#line 608
      return (0);
    }
  } else {
#line 611
    if (op->temp_animation_id) {
#line 611
      tmp___11 = (int )(animations + op->temp_animation_id)->num_animations;
    } else {
#line 611
      tmp___11 = (int )(animations + op->animation_id)->num_animations;
    }
#line 611
    if (tmp___11 > 1) {
#line 612
      if (op->temp_animation_id) {
#line 612
        op->face = *((animations + op->temp_animation_id)->faces + 0);
      } else {
#line 612
        op->face = *((animations + op->animation_id)->faces + 0);
      }
      {
#line 613
      object_update(op, 4);
      }
    }
#line 621
    if (! op->last_sp) {
      {
#line 622
      trigger_move(op, 0);
      }
    } else {
      {
#line 624
      op->stats.wc = (sint8 )0;
#line 625
      op->value = ! op->value;
#line 626
      op->speed = (float )0;
#line 627
      object_update_speed(op);
      }
    }
  }
#line 630
  return (0);
  case_27: /* CIL Label */ 
#line 633
  if (cause) {
#line 634
    if (in_movement) {
#line 635
      return (0);
    }
#line 636
    push = 1;
  }
#line 638
  if (op->temp_animation_id) {
#line 638
    tmp___12 = (int )(animations + op->temp_animation_id)->num_animations;
  } else {
#line 638
    tmp___12 = (int )(animations + op->animation_id)->num_animations;
  }
#line 638
  if (tmp___12 > 1) {
#line 639
    if (op->temp_animation_id) {
#line 639
      op->face = *((animations + op->temp_animation_id)->faces + push);
    } else {
#line 639
      op->face = *((animations + op->animation_id)->faces + push);
    }
    {
#line 640
    object_update(op, 4);
    }
  }
  {
#line 642
  trigger_move(op, push);
  }
#line 643
  return (1);
  switch_default: /* CIL Label */ 
  {
#line 646
  LOG((LogLevel )2, "Unknown trigger type: %s (%d)\n", op->name, (int )op->type);
  }
#line 647
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 660 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/button.c"
void add_button_link(object *button , mapstruct *map , int connected ) 
{ 
  oblinkpt *obp ;
  objectlink *ol ;
  objectlink *tmp ;

  {
  {
#line 662
  tmp = get_objectlink();
#line 662
  ol = tmp;
  }
#line 664
  if (! map) {
    {
#line 665
    LOG((LogLevel )0, "Tried to add button-link without map.\n");
#line 666
    free_objectlink(ol);
    }
#line 667
    return;
  }
#line 670
  button->flags[2] |= 1U << 9;
#line 672
  ol->ob = button;
#line 673
  ol->id = button->count;
#line 675
  obp = map->buttons;
  {
#line 675
  while (1) {
    while_continue: /* CIL Label */ ;
#line 675
    if (obp) {
#line 675
      if (! (obp->value != (long )connected)) {
#line 675
        goto while_break;
      }
    } else {
#line 675
      goto while_break;
    }
#line 675
    obp = obp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 678
  if (obp) {
#line 679
    ol->next = obp->link;
#line 680
    obp->link = ol;
  } else {
    {
#line 682
    obp = get_objectlinkpt();
#line 683
    obp->value = (long )connected;
#line 685
    obp->next = map->buttons;
#line 686
    map->buttons = obp;
#line 687
    obp->link = ol;
    }
  }
#line 689
  return;
}
}
#line 697 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/button.c"
void remove_button_link(object *op ) 
{ 
  oblinkpt *obp ;
  objectlink **olp ;
  objectlink *ol ;

  {
#line 701
  if ((unsigned long )op->map == (unsigned long )((void *)0)) {
    {
#line 702
    LOG((LogLevel )0, "remove_button_link() in object without map.\n");
    }
#line 703
    return;
  }
#line 705
  if (! (op->flags[2] & (1U << 9))) {
    {
#line 706
    LOG((LogLevel )0, "remove_button_linked() in unlinked object.\n");
    }
#line 707
    return;
  }
#line 710
  obp = (op->map)->buttons;
  {
#line 710
  while (1) {
    while_continue: /* CIL Label */ ;
#line 710
    if (! obp) {
#line 710
      goto while_break;
    }
#line 711
    olp = & obp->link;
    {
#line 711
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 711
      ol = *olp;
#line 711
      if (! ol) {
#line 711
        goto while_break___0;
      }
#line 712
      if ((unsigned long )ol->ob == (unsigned long )op) {
        {
#line 716
        *olp = ol->next;
#line 717
        free((void *)ol);
        }
#line 718
        return;
      }
#line 711
      olp = & ol->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 710
    obp = obp->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 720
  LOG((LogLevel )0, "remove_button_linked(): couldn\'t find object.\n");
#line 721
  op->flags[2] &= ~ (1U << 9);
  }
#line 722
  return;
}
}
#line 731 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/button.c"
static objectlink *get_button_links(object const   *button ) 
{ 
  oblinkpt *obp ;
  objectlink *ol ;

  {
#line 735
  if (! button->map) {
#line 736
    return ((objectlink *)((void *)0));
  }
#line 738
  obp = (button->map)->buttons;
  {
#line 738
  while (1) {
    while_continue: /* CIL Label */ ;
#line 738
    if (! obp) {
#line 738
      goto while_break;
    }
#line 739
    ol = obp->link;
    {
#line 739
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 739
      if (! ol) {
#line 739
        goto while_break___0;
      }
#line 740
      if ((unsigned long )ol->ob == (unsigned long )button) {
#line 740
        if (ol->id == (tag_t )button->count) {
#line 741
          return (obp->link);
        }
      }
#line 739
      ol = ol->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 738
    obp = obp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 742
  return ((objectlink *)((void *)0));
}
}
#line 753 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/button.c"
int get_button_value(object const   *button ) 
{ 
  oblinkpt *obp ;
  objectlink *ol ;

  {
#line 757
  if (! button->map) {
#line 758
    return (0);
  }
#line 760
  obp = (button->map)->buttons;
  {
#line 760
  while (1) {
    while_continue: /* CIL Label */ ;
#line 760
    if (! obp) {
#line 760
      goto while_break;
    }
#line 761
    ol = obp->link;
    {
#line 761
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 761
      if (! ol) {
#line 761
        goto while_break___0;
      }
#line 762
      if ((unsigned long )ol->ob == (unsigned long )button) {
#line 762
        if (ol->id == (tag_t )button->count) {
#line 763
          return ((int )obp->value);
        }
      }
#line 761
      ol = ol->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 760
    obp = obp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 764
  return (0);
}
}
#line 785 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/button.c"
object *check_inv_recursive(object *op , object const   *trig ) 
{ 
  object *ret ;
  object *tmp ;
  object *next795 ;
  tag_t next_tag795 ;
  tag_t tmp___0 ;

  {
#line 786
  ret = (object *)((void *)0);
#line 789
  if (! trig->stats.hp) {
#line 789
    goto _L___1;
  } else
#line 789
  if ((int )op->type == (int )trig->stats.hp) {
    _L___1: /* CIL Label */ 
#line 789
    if (! trig->slaying) {
#line 789
      goto _L___0;
    } else
#line 789
    if ((unsigned long )op->slaying == (unsigned long )trig->slaying) {
      _L___0: /* CIL Label */ 
#line 789
      if (! trig->race) {
#line 789
        goto _L;
      } else
#line 789
      if ((unsigned long )(op->arch)->name == (unsigned long )trig->race) {
        _L: /* CIL Label */ 
#line 789
        if (! trig->title) {
#line 793
          return (op);
        } else
#line 789
        if ((unsigned long )op->title == (unsigned long )trig->title) {
#line 793
          return (op);
        }
      }
    }
  }
  {
#line 795
  while (1) {
    while_continue: /* CIL Label */ ;
#line 795
    tmp = op->inv;
    {
#line 795
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 795
      next795 = tmp;
#line 795
      if ((unsigned long )next795 == (unsigned long )((void *)0)) {
#line 795
        tmp___0 = (tag_t )0;
      } else {
#line 795
        tmp___0 = next795->count;
      }
#line 795
      next_tag795 = tmp___0;
      {
#line 795
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 795
        tmp = next795;
#line 795
        if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 795
          goto while_break___1;
        }
#line 795
        if (next795->count != next_tag795) {
#line 795
          goto while_break___1;
        } else
#line 795
        if (next795->flags[0] & (1U << 3)) {
#line 795
          goto while_break___1;
        }
#line 795
        next795 = next795->below;
#line 795
        if ((unsigned long )next795 == (unsigned long )((void *)0)) {
#line 795
          next_tag795 = (tag_t )0;
        } else {
#line 795
          next_tag795 = next795->count;
        }
#line 796
        if (tmp->inv) {
          {
#line 797
          ret = check_inv_recursive(tmp, trig);
          }
#line 798
          if (ret) {
#line 799
            return (ret);
          }
        } else
#line 800
        if (! trig->stats.hp) {
#line 800
          goto _L___4;
        } else
#line 800
        if ((int )tmp->type == (int )trig->stats.hp) {
          _L___4: /* CIL Label */ 
#line 800
          if (! trig->slaying) {
#line 800
            goto _L___3;
          } else
#line 800
          if ((unsigned long )tmp->slaying == (unsigned long )trig->slaying) {
            _L___3: /* CIL Label */ 
#line 800
            if (! trig->race) {
#line 800
              goto _L___2;
            } else
#line 800
            if ((unsigned long )(tmp->arch)->name == (unsigned long )trig->race) {
              _L___2: /* CIL Label */ 
#line 800
              if (! trig->title) {
#line 804
                return (tmp);
              } else
#line 800
              if ((unsigned long )tmp->title == (unsigned long )trig->title) {
#line 804
                return (tmp);
              }
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 795
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 795
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 807
  return ((object *)((void *)0));
}
}
#line 825 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/button.c"
void check_inv(object *op , object *trig ) 
{ 
  object *match ;

  {
#line 828
  if ((int )op->type != 1) {
#line 829
    return;
  }
  {
#line 831
  match = check_inv_recursive(op, (object const   *)trig);
  }
#line 832
  if (match) {
#line 832
    if (trig->last_sp) {
#line 833
      if (trig->last_heal) {
        {
#line 834
        object_decrease_nrof(match, (uint32 )1);
        }
      }
      {
#line 835
      use_trigger(trig);
      }
    } else {
#line 832
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 836
  if (! match) {
#line 836
    if (! trig->last_sp) {
      {
#line 837
      use_trigger(trig);
      }
    }
  }
#line 838
  return;
}
}
#line 850 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/button.c"
void verify_button_links(mapstruct const   *map ) 
{ 
  oblinkpt *obp ;
  objectlink *ol ;

  {
#line 854
  if (! map) {
#line 855
    return;
  }
#line 857
  obp = (oblinkpt *)map->buttons;
  {
#line 857
  while (1) {
    while_continue: /* CIL Label */ ;
#line 857
    if (! obp) {
#line 857
      goto while_break;
    }
#line 858
    ol = obp->link;
    {
#line 858
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 858
      if (! ol) {
#line 858
        goto while_break___0;
      }
#line 859
      if (ol->id != (ol->ob)->count) {
        {
#line 860
        LOG((LogLevel )0, "verify_button_links: object %s on list is corrupt (%u!=%u)\n",
            (ol->ob)->name, ol->id, (ol->ob)->count);
        }
      }
#line 858
      ol = ol->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 857
    obp = obp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 863
  return;
}
}
#line 10 "../include/libproto.h"
archetype *find_archetype_by_object_type_name(int type , char const   *name ) ;
#line 12
archetype *get_archetype_by_type_subtype(int type , int subtype ) ;
#line 13
object *create_archetype_by_object_name(char const   *name ) ;
#line 16
void clear_archetable(void) ;
#line 17
void dump_arch(archetype *at , StringBuffer *sb ) ;
#line 19
void free_arch(archetype *at ) ;
#line 20
void free_all_archs(void) ;
#line 21
archetype *get_archetype_struct(void) ;
#line 22
void check_generators(void) ;
#line 23
void check_summoned(void) ;
#line 25
object *create_singularity(char const   *name ) ;
#line 30
int is_type_valid(uint8 type ) ;
#line 244
extern void object_clear(object *op ) ;
#line 408
extern void load_treasures(void) ;
#line 409
extern treasurelist *find_treasurelist(char const   *name ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
static void add_arch(archetype *at ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
static archetype *arch_table[8192]  ;
#line 52 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
static int arch_cmp  =    0;
#line 53 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
static int arch_search  =    0;
#line 54 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
int arch_init  ;
#line 56
static void load_archetypes(void) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
archetype *find_archetype_by_object_name(char const   *name ) 
{ 
  archetype *at ;
  char const   *tmp ;

  {
#line 74
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 75
    return ((archetype *)((void *)0));
  }
  {
#line 76
  tmp = add_string(name);
#line 77
  at = first_archetype;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! ((unsigned long )at != (unsigned long )((void *)0))) {
#line 77
      goto while_break;
    }
#line 78
    if ((unsigned long )at->clone.name == (unsigned long )tmp) {
      {
#line 79
      free_string(tmp);
      }
#line 80
      return (at);
    }
#line 77
    at = at->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 83
  free_string(tmp);
  }
#line 84
  return ((archetype *)((void *)0));
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
archetype *find_archetype_by_object_type_name(int type , char const   *name ) 
{ 
  archetype *at ;
  int tmp ;

  {
#line 99
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 100
    return ((archetype *)((void *)0));
  }
#line 102
  at = first_archetype;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! ((unsigned long )at != (unsigned long )((void *)0))) {
#line 102
      goto while_break;
    }
#line 103
    if ((int )at->clone.type == type) {
      {
#line 103
      tmp = strcmp(at->clone.name, name);
      }
#line 103
      if (tmp == 0) {
#line 104
        return (at);
      }
    }
#line 102
    at = at->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  return ((archetype *)((void *)0));
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
archetype *get_archetype_by_skill_name(char const   *skill , int type ) 
{ 
  archetype *at ;
  int tmp ;

  {
#line 123
  if ((unsigned long )skill == (unsigned long )((void *)0)) {
#line 124
    return ((archetype *)((void *)0));
  }
#line 126
  at = first_archetype;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! ((unsigned long )at != (unsigned long )((void *)0))) {
#line 126
      goto while_break;
    }
#line 127
    if (type == -1) {
#line 127
      goto _L;
    } else
#line 127
    if (type == (int )at->clone.type) {
      _L: /* CIL Label */ 
#line 127
      if (at->clone.skill) {
        {
#line 127
        tmp = strcmp(at->clone.skill, skill);
        }
#line 127
        if (! tmp) {
#line 129
          return (at);
        }
      }
    }
#line 126
    at = at->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  return ((archetype *)((void *)0));
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
archetype *get_archetype_by_type_subtype(int type , int subtype ) 
{ 
  archetype *at ;

  {
#line 152
  at = first_archetype;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! ((unsigned long )at != (unsigned long )((void *)0))) {
#line 152
      goto while_break;
    }
#line 153
    if (type == -1) {
#line 153
      goto _L;
    } else
#line 153
    if (type == (int )at->clone.type) {
      _L: /* CIL Label */ 
#line 153
      if (subtype == -1) {
#line 155
        return (at);
      } else
#line 153
      if (subtype == (int )at->clone.subtype) {
#line 155
        return (at);
      }
    }
#line 152
    at = at->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return ((archetype *)((void *)0));
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
object *create_archetype_by_object_name(char const   *name ) 
{ 
  archetype *at ;
  char tmpname[256] ;
  size_t i ;
  object *tmp ;
  object *tmp___0 ;

  {
  {
#line 178
  strncpy((char */* __restrict  */)(tmpname), (char const   */* __restrict  */)name,
          (size_t )255);
#line 179
  tmpname[255] = (char)0;
#line 180
  i = strlen((char const   *)(tmpname));
  }
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! (i > 0UL)) {
#line 180
      goto while_break;
    }
    {
#line 181
    tmpname[i] = (char)0;
#line 182
    at = find_archetype_by_object_name((char const   *)(tmpname));
    }
#line 183
    if ((unsigned long )at != (unsigned long )((void *)0)) {
      {
#line 184
      tmp = arch_to_object(at);
      }
#line 184
      return (tmp);
    }
#line 180
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 187
  tmp___0 = create_singularity(name);
  }
#line 187
  return (tmp___0);
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
void init_archetypes(void) 
{ 


  {
#line 196
  if ((unsigned long )first_archetype != (unsigned long )((void *)0)) {
#line 197
    return;
  }
  {
#line 198
  arch_init = 1;
#line 199
  load_archetypes();
#line 200
  arch_init = 0;
#line 201
  empty_archetype = find_archetype("empty_archetype");
  }
#line 203
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
void arch_info(object *op ) 
{ 


  {
  {
#line 210
  draw_ext_info_format(256, 0, (object const   *)op, (uint8 )10, (uint8 )10, "%d searches and %d strcmp()\'s",
                       arch_search, arch_cmp);
  }
#line 213
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
void clear_archetable(void) 
{ 


  {
  {
#line 219
  memset((void *)(arch_table), 0, 8192UL * sizeof(archetype *));
  }
#line 220
  return;
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
static void init_archetable(void) 
{ 
  archetype *at ;
  char const   *tmp ;

  {
  {
#line 228
  LOG((LogLevel )2, " Setting up archetable...\n");
#line 229
  at = first_archetype;
  }
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (! ((unsigned long )at != (unsigned long )((void *)0))) {
#line 229
      goto while_break;
    }
#line 230
    if ((unsigned long )at->name == (unsigned long )((void *)0)) {
#line 231
      if (at->clone.name) {
#line 231
        tmp = at->clone.name;
      } else {
#line 231
        tmp = "(no clone name)";
      }
      {
#line 231
      LOG((LogLevel )0, "archetype without name? %s\n", tmp);
#line 232
      abort();
      }
    }
    {
#line 234
    add_arch(at);
    }
#line 229
    if ((unsigned long )at->more == (unsigned long )((void *)0)) {
#line 229
      at = at->next;
    } else {
#line 229
      at = at->more;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 236
  LOG((LogLevel )2, "done\n");
  }
#line 237
  return;
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
void dump_arch(archetype *at , StringBuffer *sb ) 
{ 


  {
  {
#line 248
  object_dump((object const   *)(& at->clone), sb);
  }
#line 249
  return;
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
void dump_all_archetypes(void) 
{ 
  archetype *at ;
  StringBuffer *sb ;
  char *diff ;

  {
#line 259
  at = first_archetype;
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! ((unsigned long )at != (unsigned long )((void *)0))) {
#line 259
      goto while_break;
    }
    {
#line 263
    sb = stringbuffer_new();
#line 264
    dump_arch(at, sb);
#line 265
    diff = stringbuffer_finish(sb);
#line 266
    LOG((LogLevel )2, "%s\n", diff);
#line 267
    free((void *)diff);
    }
#line 259
    if ((unsigned long )at->more == (unsigned long )((void *)0)) {
#line 259
      at = at->next;
    } else {
#line 259
      at = at->more;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  return;
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
void free_arch(archetype *at ) 
{ 


  {
#line 278
  if (at->name) {
    {
#line 279
    free_string(at->name);
    }
  }
#line 280
  if (at->clone.name) {
    {
#line 281
    free_string(at->clone.name);
    }
  }
#line 282
  if (at->clone.name_pl) {
    {
#line 283
    free_string(at->clone.name_pl);
    }
  }
#line 284
  if (at->clone.title) {
    {
#line 285
    free_string(at->clone.title);
    }
  }
#line 286
  if (at->clone.race) {
    {
#line 287
    free_string(at->clone.race);
    }
  }
#line 288
  if (at->clone.slaying) {
    {
#line 289
    free_string(at->clone.slaying);
    }
  }
#line 290
  if (at->clone.msg) {
    {
#line 291
    free_string(at->clone.msg);
    }
  }
  {
#line 292
  free((void *)at->clone.discrete_damage);
#line 293
  object_free_key_values(& at->clone);
#line 294
  free((void *)at);
  }
#line 295
  return;
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
void free_all_archs(void) 
{ 
  archetype *at ;
  archetype *next ;
  int i ;

  {
#line 303
  i = 0;
#line 305
  at = first_archetype;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! ((unsigned long )at != (unsigned long )((void *)0))) {
#line 305
      goto while_break;
    }
#line 306
    if (at->more) {
#line 307
      next = at->more;
    } else {
#line 309
      next = at->next;
    }
    {
#line 310
    free_arch(at);
#line 311
    i ++;
#line 305
    at = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 313
  first_archetype = (archetype *)((void *)0);
#line 315
  clear_archetable();
#line 316
  LOG((LogLevel )2, "Freed %d archetypes\n", i);
  }
#line 317
  return;
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
archetype *get_archetype_struct(void) 
{ 
  archetype *new ;
  void *tmp ;

  {
  {
#line 329
  tmp = calloc((size_t )1, sizeof(archetype ));
#line 329
  new = (archetype *)tmp;
  }
#line 330
  if ((unsigned long )new == (unsigned long )((void *)0)) {
    {
#line 331
    fatal(0);
    }
  }
  {
#line 332
  new->next = (struct archt *)((void *)0);
#line 333
  new->name = (char const   *)((void *)0);
#line 334
  new->clone.other_arch = (struct archt *)((void *)0);
#line 335
  new->clone.name = (char const   *)((void *)0);
#line 336
  new->clone.name_pl = (char const   *)((void *)0);
#line 337
  new->clone.title = (char const   *)((void *)0);
#line 338
  new->clone.race = (char const   *)((void *)0);
#line 339
  new->clone.slaying = (char const   *)((void *)0);
#line 340
  new->clone.msg = (char const   *)((void *)0);
#line 341
  object_clear(& new->clone);
#line 342
  new->clone.flags[0] &= ~ (1U << 3);
#line 343
  new->clone.flags[0] |= 1U << 2;
#line 344
  new->head = (struct archt *)((void *)0);
#line 345
  new->more = (struct archt *)((void *)0);
#line 346
  new->clone.arch = new;
  }
#line 347
  return (new);
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
static void first_arch_pass(FILE *fp ) 
{ 
  archetype *at ;
  archetype *head ;
  archetype *last_more ;
  int i ;
  int first ;

  {
  {
#line 361
  head = (archetype *)((void *)0);
#line 361
  last_more = (archetype *)((void *)0);
#line 362
  first = 2;
#line 364
  at = get_archetype_struct();
#line 365
  first_archetype = at;
  }
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 367
    i = load_object(fp, & at->clone, first, 0);
    }
#line 367
    if (! i) {
#line 367
      goto while_break;
    }
#line 368
    first = 0;
#line 369
    at->clone.speed_left = (float )(- 0.1);
    {
#line 372
    if (i == 2) {
#line 372
      goto case_2;
    }
#line 382
    if (i == 1) {
#line 382
      goto case_1;
    }
#line 371
    goto switch_break;
    case_2: /* CIL Label */ 
#line 373
    if ((unsigned long )last_more != (unsigned long )((void *)0)) {
#line 374
      last_more->next = at;
    }
#line 375
    if ((unsigned long )head != (unsigned long )((void *)0)) {
#line 376
      head->next = at;
    }
#line 377
    last_more = at;
#line 377
    head = last_more;
#line 378
    at->tail_x = (sint8 )0;
#line 379
    at->tail_y = (sint8 )0;
#line 380
    goto switch_break;
    case_1: /* CIL Label */ 
#line 383
    at->head = head;
#line 384
    at->clone.head = & head->clone;
#line 385
    if ((unsigned long )last_more != (unsigned long )((void *)0)) {
#line 386
      last_more->more = at;
#line 387
      last_more->clone.more = & at->clone;
    }
#line 389
    last_more = at;
#line 392
    if (head->clone.flags[0] & (1U << 14)) {
#line 393
      at->clone.flags[0] |= 1U << 14;
    }
#line 401
    if ((unsigned long )at->clone.face != (unsigned long )head->clone.face) {
#line 402
      head->tail_x = (sint8 )0;
#line 403
      head->tail_y = (sint8 )0;
    } else {
#line 405
      if ((int )at->clone.x > (int )head->tail_x) {
#line 406
        head->tail_x = (sint8 )at->clone.x;
      }
#line 407
      if ((int )at->clone.y > (int )head->tail_y) {
#line 408
        head->tail_y = (sint8 )at->clone.y;
      }
    }
#line 410
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 413
    at = get_archetype_struct();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 415
  at->clone.arch = (struct archt *)((void *)0);
#line 416
  free((void *)at);
  }
#line 417
  return;
}
}
#line 428 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
static void second_arch_pass(FILE *fp ) 
{ 
  char buf[256] ;
  char *variable ;
  char *argument ;
  char *cp ;
  archetype *at ;
  archetype *other ;
  object *inv ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  treasurelist *tl ;
  treasurelist *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
#line 429
  variable = buf;
#line 430
  at = (archetype *)((void *)0);
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 433
    tmp___6 = fgets((char */* __restrict  */)(buf), 256, (FILE */* __restrict  */)fp);
    }
#line 433
    if (! ((unsigned long )tmp___6 != (unsigned long )((void *)0))) {
#line 433
      goto while_break;
    }
#line 434
    if ((int )buf[0] == 35) {
#line 435
      goto while_continue;
    }
    {
#line 436
    argument = strchr((char const   *)(buf), ' ');
    }
#line 436
    if ((unsigned long )argument != (unsigned long )((void *)0)) {
      {
#line 437
      *argument = (char )'\000';
#line 437
      argument ++;
#line 438
      tmp = strlen((char const   *)argument);
#line 438
      cp = (argument + tmp) - 1;
      }
      {
#line 439
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 439
        tmp___0 = __ctype_b_loc();
        }
#line 439
        if (! ((int const   )*(*tmp___0 + (int )*cp) & 8192)) {
#line 439
          goto while_break___0;
        }
#line 440
        *cp = (char )'\000';
#line 441
        cp --;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 444
    tmp___5 = strcmp("Object", (char const   *)variable);
    }
#line 444
    if (tmp___5) {
      {
#line 450
      tmp___4 = strcmp("other_arch", (char const   *)variable);
      }
#line 450
      if (tmp___4) {
        {
#line 457
        tmp___3 = strcmp("randomitems", (char const   *)variable);
        }
#line 457
        if (tmp___3) {
          {
#line 465
          tmp___2 = strcmp("arch", (char const   *)variable);
          }
#line 465
          if (! tmp___2) {
            {
#line 466
            inv = create_archetype((char const   *)argument);
#line 467
            load_object(fp, inv, 1, 0);
            }
#line 468
            if (at) {
              {
#line 469
              object_insert_in_ob(inv, & at->clone);
              }
            } else {
              {
#line 472
              LOG((LogLevel )0, "Got an arch %s not inside an Object.\n", argument);
#line 473
              object_free_drop_inventory(inv);
              }
            }
          }
        } else
#line 458
        if ((unsigned long )at != (unsigned long )((void *)0)) {
          {
#line 459
          tmp___1 = find_treasurelist((char const   *)argument);
#line 459
          tl = tmp___1;
          }
#line 460
          if ((unsigned long )tl == (unsigned long )((void *)0)) {
            {
#line 461
            LOG((LogLevel )0, "Failed to link treasure to arch (%s): %s\n", at->name,
                argument);
            }
          } else {
#line 463
            at->clone.randomitems = tl;
          }
        }
      } else
#line 451
      if ((unsigned long )at != (unsigned long )((void *)0)) {
#line 451
        if ((unsigned long )at->clone.other_arch == (unsigned long )((void *)0)) {
          {
#line 452
          other = find_archetype((char const   *)argument);
          }
#line 452
          if ((unsigned long )other == (unsigned long )((void *)0)) {
            {
#line 453
            LOG((LogLevel )0, "Warning: failed to find other_arch %s\n", argument);
            }
          } else
#line 454
          if ((unsigned long )at != (unsigned long )((void *)0)) {
#line 455
            at->clone.other_arch = other;
          }
        }
      }
    } else {
      {
#line 445
      at = find_archetype((char const   *)argument);
      }
#line 445
      if ((unsigned long )at == (unsigned long )((void *)0)) {
        {
#line 447
        LOG((LogLevel )0, "Fatal: failed to find arch %s in second_arch_pass\n", argument);
#line 448
        fatal(3);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  return;
}
}
#line 482 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
void check_generators(void) 
{ 
  archetype const   *at ;
  int abort___0 ;

  {
#line 484
  abort___0 = 0;
#line 486
  at = (archetype const   *)first_archetype;
  {
#line 486
  while (1) {
    while_continue: /* CIL Label */ ;
#line 486
    if (! ((unsigned long )at != (unsigned long )((void *)0))) {
#line 486
      goto while_break;
    }
#line 487
    if (! (at->clone.flags[0] & (1U << 16))) {
#line 488
      goto __Cont;
    }
#line 490
    if (! (at->clone.flags[3] & (1U << 12))) {
#line 490
      if ((unsigned long )at->clone.other_arch == (unsigned long )((void *)0)) {
        {
#line 491
        LOG((LogLevel )0, "Fatal: %s is generator without content_on_gen but lacks other_arch.\n",
            at->name);
#line 492
        abort___0 = 1;
        }
#line 493
        goto __Cont;
      }
    }
#line 495
    if (at->clone.flags[3] & (1U << 12)) {
#line 495
      if ((unsigned long )at->clone.inv == (unsigned long )((void *)0)) {
        {
#line 496
        LOG((LogLevel )0, "Fatal: %s is generator with content_on_gen but lacks inventory.\n",
            at->name);
#line 497
        abort___0 = 1;
        }
#line 498
        goto __Cont;
      }
    }
    __Cont: /* CIL Label */ 
#line 486
    at = (archetype const   *)at->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 502
  if (abort___0) {
    {
#line 503
    fatal(4);
    }
  }
#line 504
  return;
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
void check_summoned(void) 
{ 
  archetype const   *at ;

  {
#line 513
  at = (archetype const   *)first_archetype;
  {
#line 513
  while (1) {
    while_continue: /* CIL Label */ ;
#line 513
    if (! ((unsigned long )at != (unsigned long )((void *)0))) {
#line 513
      goto while_break;
    }
#line 514
    if ((int const   )at->clone.type == 101) {
#line 514
      if ((int const   )at->clone.subtype == 12) {
#line 514
        if (at->clone.other_arch) {
#line 515
          if ((int )(at->clone.other_arch)->clone.move_type == 0) {
            {
#line 516
            LOG((LogLevel )0, "Summonable archetype %s [%s] has no move_type defined!\n",
                (at->clone.other_arch)->name, (at->clone.other_arch)->clone.name);
#line 517
            fatal(4);
            }
          }
        }
      }
    }
#line 513
    at = (archetype const   *)at->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 521
  return;
}
}
#line 526 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
static void check_spells(void) 
{ 
  int abort___0 ;
  archetype const   *at ;

  {
#line 527
  abort___0 = 0;
#line 530
  at = (archetype const   *)first_archetype;
  {
#line 530
  while (1) {
    while_continue: /* CIL Label */ ;
#line 530
    if (! ((unsigned long )at != (unsigned long )((void *)0))) {
#line 530
      goto while_break;
    }
#line 531
    if ((int const   )at->clone.type == 101) {
#line 531
      if ((unsigned long )at->clone.skill == (unsigned long )((void *)0)) {
        {
#line 532
        LOG((LogLevel )0, "Spell archetype %s [%s] has no skill defined!\n", at->name,
            at->clone.name);
#line 533
        abort___0 = 1;
        }
      }
    }
#line 530
    at = (archetype const   *)at->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  if (abort___0) {
    {
#line 537
    fatal(4);
    }
  }
#line 538
  return;
}
}
#line 547 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
static void load_archetypes(void) 
{ 
  FILE *fp ;
  char filename[256] ;

  {
  {
#line 554
  snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s/%s",
           settings.datadir, settings.archetypes);
#line 555
  LOG((LogLevel )2, "Reading archetypes from %s...\n", filename);
#line 556
  fp = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"r");
  }
#line 556
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 557
    LOG((LogLevel )0, " Can\'t open archetype file.\n");
    }
#line 558
    return;
  }
  {
#line 560
  clear_archetable();
#line 561
  LOG((LogLevel )2, " arch-pass 1...\n");
#line 565
  first_arch_pass(fp);
#line 581
  LOG((LogLevel )2, " done\n");
#line 582
  init_archetable();
#line 583
  warn_archetypes = 1L;
#line 585
  rewind(fp);
#line 587
  LOG((LogLevel )2, " loading treasure...\n");
#line 588
  load_treasures();
#line 589
  LOG((LogLevel )2, " done\n");
#line 590
  LOG((LogLevel )2, "arch-pass 2...\n");
#line 591
  second_arch_pass(fp);
#line 592
  LOG((LogLevel )2, " done\n");
#line 593
  check_generators();
#line 594
  check_spells();
#line 595
  check_summoned();
#line 596
  fclose(fp);
#line 597
  LOG((LogLevel )2, " done\n");
  }
#line 598
  return;
}
}
#line 611 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
object *arch_to_object(archetype *at ) 
{ 
  object *op ;

  {
#line 614
  if ((unsigned long )at == (unsigned long )((void *)0)) {
#line 615
    if (warn_archetypes) {
      {
#line 616
      LOG((LogLevel )0, "Couldn\'t find archetype.\n");
      }
    }
#line 617
    return ((object *)((void *)0));
  }
  {
#line 619
  op = object_new();
#line 620
  object_copy_with_inv((object const   *)(& at->clone), op);
#line 621
  op->arch = at;
  }
#line 622
  return (op);
}
}
#line 638 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
object *create_singularity(char const   *name ) 
{ 
  object *op ;
  char buf[256] ;

  {
  {
#line 642
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s (%s)",
           "singularity", name);
#line 643
  op = object_new();
#line 644
  op->name = add_string((char const   *)(buf));
#line 645
  op->name_pl = add_string((char const   *)(buf));
#line 646
  op->flags[0] |= 1U << 8;
  }
#line 647
  return (op);
}
}
#line 660 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
object *create_archetype(char const   *name ) 
{ 
  archetype *at ;
  object *tmp ;
  object *tmp___0 ;

  {
  {
#line 663
  at = find_archetype(name);
  }
#line 664
  if ((unsigned long )at == (unsigned long )((void *)0)) {
    {
#line 665
    tmp = create_singularity(name);
    }
#line 665
    return (tmp);
  }
  {
#line 666
  tmp___0 = arch_to_object(at);
  }
#line 666
  return (tmp___0);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
static unsigned long hasharch(char const   *str , int tablesize ) 
{ 
  unsigned long hash ;
  int i ;
  char const   *p ;

  {
#line 680
  hash = 0UL;
#line 681
  i = 0;
#line 689
  p = str;
  {
#line 689
  while (1) {
    while_continue: /* CIL Label */ ;
#line 689
    if (i < 20) {
#line 689
      if (! *p) {
#line 689
        goto while_break;
      }
    } else {
#line 689
      goto while_break;
    }
#line 690
    hash += (unsigned long )*p;
#line 691
    hash += hash << 10;
#line 692
    hash ^= hash >> 6;
#line 689
    p ++;
#line 689
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 694
  hash += hash << 3;
#line 695
  hash ^= hash >> 11;
#line 696
  hash += hash << 15;
#line 697
  return (hash % (unsigned long )tablesize);
}
}
#line 706 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
archetype *try_find_archetype(char const   *name ) 
{ 
  archetype *at ;
  unsigned long index___0 ;
  int tmp ;

  {
#line 710
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 711
    return ((archetype *)((void *)0));
  }
  {
#line 713
  index___0 = hasharch(name, 8192);
#line 714
  arch_search ++;
  }
  {
#line 715
  while (1) {
    while_continue: /* CIL Label */ ;
#line 716
    at = arch_table[index___0];
#line 717
    if ((unsigned long )at == (unsigned long )((void *)0)) {
#line 718
      return ((archetype *)((void *)0));
    }
    {
#line 720
    arch_cmp ++;
#line 721
    tmp = strcmp(at->name, name);
    }
#line 721
    if (! tmp) {
#line 722
      return (at);
    }
#line 723
    index___0 ++;
#line 723
    if (index___0 >= 8192UL) {
#line 724
      index___0 = 0UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 735 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
archetype *find_archetype(char const   *name ) 
{ 
  archetype *at ;

  {
#line 738
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 739
    return ((archetype *)((void *)0));
  }
  {
#line 740
  at = try_find_archetype(name);
  }
#line 741
  if ((unsigned long )at == (unsigned long )((void *)0)) {
#line 741
    if (warn_archetypes) {
      {
#line 742
      LOG((LogLevel )0, "Couldn\'t find archetype %s\n", name);
      }
    }
  }
#line 743
  return (at);
}
}
#line 750 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
static void add_arch(archetype *at ) 
{ 
  unsigned long index___0 ;
  unsigned long tmp ;
  unsigned long org_index ;

  {
  {
#line 751
  tmp = hasharch(at->name, 8192);
#line 751
  index___0 = tmp;
#line 751
  org_index = index___0;
  }
  {
#line 753
  while (1) {
    while_continue: /* CIL Label */ ;
#line 754
    if ((unsigned long )arch_table[index___0] == (unsigned long )((void *)0)) {
#line 755
      arch_table[index___0] = at;
#line 756
      return;
    }
#line 758
    index___0 ++;
#line 758
    if (index___0 == 8192UL) {
#line 759
      index___0 = 0UL;
    }
#line 760
    if (index___0 == org_index) {
      {
#line 761
      fatal(2);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 776 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
object *object_create_arch(archetype *at ) 
{ 
  object *op ;
  object *prev ;
  object *head ;

  {
#line 777
  prev = (object *)((void *)0);
#line 777
  head = (object *)((void *)0);
  {
#line 779
  while (1) {
    while_continue: /* CIL Label */ ;
#line 779
    if (! at) {
#line 779
      goto while_break;
    }
    {
#line 780
    op = arch_to_object(at);
#line 781
    op->x = at->clone.x;
#line 782
    op->y = at->clone.y;
    }
#line 783
    if (head) {
#line 784
      op->head = head;
#line 784
      prev->more = op;
    }
#line 785
    if (! head) {
#line 786
      head = op;
    }
#line 787
    prev = op;
#line 788
    at = at->more;
  }
  while_break: /* CIL Label */ ;
  }
#line 790
  return (head);
}
}
#line 803 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/arch.c"
int is_type_valid(uint8 type ) 
{ 


  {
#line 804
  if ((int )type >= 162) {
#line 805
    return (0);
  }
#line 807
  if ((int )type == 11) {
#line 808
    return (0);
  } else
#line 807
  if ((int )type == 12) {
#line 808
    return (0);
  }
#line 809
  if ((int )type == 19) {
#line 810
    return (0);
  } else
#line 809
  if ((int )type == 25) {
#line 810
    return (0);
  } else
#line 809
  if ((int )type == 35) {
#line 810
    return (0);
  } else
#line 809
  if ((int )type == 38) {
#line 810
    return (0);
  } else
#line 809
  if ((int )type == 44) {
#line 810
    return (0);
  } else
#line 809
  if ((int )type == 47) {
#line 810
    return (0);
  }
#line 811
  if ((int )type == 61) {
#line 812
    return (0);
  } else
#line 811
  if ((int )type == 63) {
#line 812
    return (0);
  } else
#line 811
  if ((int )type == 76) {
#line 812
    return (0);
  } else
#line 811
  if ((int )type == 78) {
#line 812
    return (0);
  } else
#line 811
  if ((int )type == 81) {
#line 812
    return (0);
  }
#line 813
  if ((int )type == 81) {
#line 814
    return (0);
  } else
#line 813
  if ((int )type == 84) {
#line 814
    return (0);
  } else
#line 813
  if ((int )type == 86) {
#line 814
    return (0);
  } else
#line 813
  if ((int )type == 88) {
#line 814
    return (0);
  } else
#line 813
  if ((int )type == 89) {
#line 814
    return (0);
  }
#line 815
  if ((int )type == 96) {
#line 816
    return (0);
  } else
#line 815
  if ((int )type == 97) {
#line 816
    return (0);
  } else
#line 815
  if ((int )type == 107) {
#line 816
    return (0);
  } else
#line 815
  if ((int )type == 108) {
#line 816
    return (0);
  } else
#line 815
  if ((int )type == 110) {
#line 816
    return (0);
  }
#line 817
  if ((int )type >= 117) {
#line 817
    if ((int )type <= 120) {
#line 818
      return (0);
    }
  }
#line 819
  if ((int )type >= 125) {
#line 819
    if ((int )type <= 129) {
#line 820
      return (0);
    }
  }
#line 821
  if ((int )type >= 131) {
#line 821
    if ((int )type <= 137) {
#line 822
      return (0);
    }
  }
#line 823
  if ((int )type >= 140) {
#line 823
    if ((int )type <= 149) {
#line 824
      return (0);
    }
  }
#line 825
  if ((int )type >= 151) {
#line 825
    if ((int )type <= 153) {
#line 826
      return (0);
    }
  }
#line 828
  return (1);
}
}
#line 848 "../include/define.h"
__inline static void safe_strcat(char *dest , char const   *orig , size_t *curlen ,
                                 size_t maxlen ) 
{ 
  size_t tmp ;

  {
#line 849
  if (*curlen == maxlen - 1UL) {
#line 850
    return;
  }
  {
#line 851
  strncpy((char */* __restrict  */)(dest + *curlen), (char const   */* __restrict  */)orig,
          (maxlen - *curlen) - 1UL);
#line 852
  *(dest + (maxlen - 1UL)) = (char)0;
#line 853
  tmp = strlen(orig);
#line 853
  *curlen += tmp;
  }
#line 854
  if (*curlen > maxlen - 1UL) {
#line 855
    *curlen = maxlen - 1UL;
  }
#line 856
  return;
}
}
#line 102 "../include/libproto.h"
int get_power_from_ench(int ench ) ;
#line 103
int calc_item_power(object const   *op ) ;
#line 105
typedata const   *get_typedata_by_name(char const   *name ) ;
#line 112
StringBuffer *describe_monster(object const   *op , StringBuffer *buf ) ;
#line 114
int is_magical(object const   *op ) ;
#line 270
extern object *map_find_by_type(mapstruct *m , int x , int y , uint8 type ) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
body_locations_struct body_locations[13]  = 
#line 65 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
  {      {"body_range", "in your range slot", "in a human\'s range slot"}, 
        {"body_arm", "on your arm", "on a human\'s arm"}, 
        {"body_torso", "on your body", "on a human\'s torso"}, 
        {"body_head", "on your head", "on a human\'s head"}, 
        {"body_neck", "around your neck", "around a humans neck"}, 
        {"body_skill", "in your skill slot", "in a human\'s skill slot"}, 
        {"body_finger", "on your finger", "on a human\'s finger"}, 
        {"body_shoulder", "around your shoulders", "around a human\'s shoulders"}, 
        {"body_foot", "on your feet", "on a human\'s feet"}, 
        {"body_hand", "on your hands", "on a human\'s hands"}, 
        {"body_wrist", "around your wrists", "around a human\'s wrist"}, 
        {"body_waist", "around your waist", "around a human\'s waist"}, 
        {"body_leg", "around your legs", "around a human\'s legs"}};
#line 83 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
static char const   * const  numbers_10[10]  = 
#line 83
  {      (char const   */* const  */)"zero",      (char const   */* const  */)"ten",      (char const   */* const  */)"twenty",      (char const   */* const  */)"thirty", 
        (char const   */* const  */)"fourty",      (char const   */* const  */)"fifty",      (char const   */* const  */)"sixty",      (char const   */* const  */)"seventy", 
        (char const   */* const  */)"eighty",      (char const   */* const  */)"ninety"};
#line 89 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
static char const   * const  levelnumbers[21]  = 
#line 89
  {      (char const   */* const  */)"zeroth",      (char const   */* const  */)"first",      (char const   */* const  */)"second",      (char const   */* const  */)"third", 
        (char const   */* const  */)"fourth",      (char const   */* const  */)"fifth",      (char const   */* const  */)"sixth",      (char const   */* const  */)"seventh", 
        (char const   */* const  */)"eighth",      (char const   */* const  */)"ninth",      (char const   */* const  */)"tenth",      (char const   */* const  */)"eleventh", 
        (char const   */* const  */)"twelfth",      (char const   */* const  */)"thirteenth",      (char const   */* const  */)"fourteenth",      (char const   */* const  */)"fifteenth", 
        (char const   */* const  */)"sixteenth",      (char const   */* const  */)"seventeenth",      (char const   */* const  */)"eighteen",      (char const   */* const  */)"nineteen", 
        (char const   */* const  */)"twentieth"};
#line 97 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
static char const   * const  levelnumbers_10[10]  = 
#line 97
  {      (char const   */* const  */)"zeroth",      (char const   */* const  */)"tenth",      (char const   */* const  */)"twentieth",      (char const   */* const  */)"thirtieth", 
        (char const   */* const  */)"fortieth",      (char const   */* const  */)"fiftieth",      (char const   */* const  */)"sixtieth",      (char const   */* const  */)"seventieth", 
        (char const   */* const  */)"eightieth",      (char const   */* const  */)"ninetieth"};
#line 109 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
static typedata const   item_types[108]  = 
#line 109
  {      {0, "none", "none", 0, 0}, 
        {1, "player", "players", 0, 0}, 
        {3, "rod", "rods", 29, 0}, 
        {4, "treasure", "treasure", 0, 0}, 
        {5, "potion", "potions", 6, 0}, 
        {6, "food", "food", 21, 0}, 
        {7, "poison", "poisons", 6, 0}, 
        {8, "book", "books", 8, 0}, 
        {9, "clock", "clocks", 0, 0}, 
        {13, "arrow", "arrows", 4, 0}, 
        {14, "bow", "bows", 4, 0}, 
        {15, "weapon", "weapons", 3, 0}, 
        {16, "armour", "armour", 3, 0}, 
        {17, "pedestal", "pedestals", 0, 0}, 
        {18, "altar", "altars", 0, 0}, 
        {20, "locked door", "locked doors", 0, 0}, 
        {21, "special key", "special keys", 0, 0}, 
        {22, "map", "maps", 0, 0}, 
        {23, "door", "doors", 0, 0}, 
        {24, "key", "keys", 0, 0}, 
        {26, "timed_gate", "timed_gates", 0, 0}, 
        {27, "trigger", "triggers", 0, 0}, 
        {28, "grimreaper", "grimreapers", 0, 0}, 
        {29, "magic ear", "magic ears", 0, 0}, 
        {30, "trigger button", "trigger buttons", 0, 0}, 
        {31, "trigger altar", "trigger altars", 0, 0}, 
        {32, "trigger pedestal", "trigger pedestals", 0, 0}, 
        {33, "shield", "shields", 3, 0}, 
        {34, "helmet", "helmets", 3, 0}, 
        {36, "money", "money", 0, 0}, 
        {37, "class", "classes", 0, 0}, 
        {39, "amulet", "amulets", 5, 0}, 
        {40, "player mover", "player movers", 0, 0}, 
        {41, "teleporter", "teleporters", 0, 0}, 
        {42, "creator", "creators", 0, 0}, 
        {43, "skill", "skills", 0, 0}, 
        {45, "earthwall", "earthwalls", 0, 0}, 
        {46, "golem", "golems", 0, 0}, 
        {48, "projectile", "projectiles", 0, 0}, 
        {49, "blindness", "blindness", 0, 0}, 
        {50, "god", "gods", 0, 0}, 
        {51, "detector", "detectors", 0, 0}, 
        {52, "trigger marker", "trigger markers", 0, 0}, 
        {53, "dead object", "dead objects", 0, 0}, 
        {54, "drink", "drinks", 21, 6}, 
        {55, "marker", "markers", 0, 0}, 
        {56, "holy altar", "holy altars", 0, 0}, 
        {57, "player changer", "player changers", 0, 0}, 
        {58, "battleground", "battlegrounds", 0, 0}, 
        {59, "peacemaker", "peacemakers", 0, 0}, 
        {60, "gem", "gems", 5, 0}, 
        {62, "firewall", "firewalls", 0, 0}, 
        {64, "inventory checker", "inventory checkers", 0, 0}, 
        {65, "mood floor", "mood floors", 0, 0}, 
        {66, "exit", "exits", 0, 0}, 
        {67, "encounter", "encounters", 0, 0}, 
        {68, "shop floor", "shop floors", 0, 0}, 
        {69, "shop mat", "shop mats", 0, 0}, 
        {70, "ring", "rings", 5, 0}, 
        {71, "floor", "floors", 0, 0}, 
        {72, "flesh", "flesh", 21, 0}, 
        {73, "inorganic", "inorganics", 6, 0}, 
        {74, "skill tool", "skill tools", 0, 0}, 
        {75, "lighter", "lighters", 0, 0}, 
        {77, "wall", "walls", 0, 0}, 
        {79, "bric-a-brac", "bric-a-brac", 0, 0}, 
        {80, "monster", "monsters", 0, 0}, 
        {82, "lamp", "lamps", 0, 0}, 
        {83, "duplicator", "duplicators", 0, 0}, 
        {85, "spellbook", "spellbooks", 8, 0}, 
        {87, "cloak", "cloaks", 3, 0}, 
        {90, "spinner", "spinners", 0, 0}, 
        {91, "gate", "gates", 0, 0}, 
        {92, "button", "buttons", 0, 0}, 
        {93, "cf handle", "cf handles", 0, 0}, 
        {94, "hole", "holes", 0, 0}, 
        {95, "trapdoor", "trapdoors", 0, 0}, 
        {98, "sign", "signs", 0, 0}, 
        {99, "boots", "boots", 3, 0}, 
        {100, "gloves", "gloves", 3, 0}, 
        {101, "spell", "spells", 0, 0}, 
        {102, "spell effect", "spell effects", 0, 0}, 
        {103, "converter", "converters", 0, 0}, 
        {104, "bracers", "bracers", 3, 0}, 
        {105, "poisoning", "poisonings", 0, 0}, 
        {106, "savebed", "savebeds", 0, 0}, 
        {109, "wand", "wands", 29, 0}, 
        {111, "scroll", "scrolls", 8, 0}, 
        {112, "director", "directors", 0, 0}, 
        {113, "girdle", "girdles", 3, 0}, 
        {114, "force", "forces", 0, 0}, 
        {115, "potion effect", "potion effects", 0, 0}, 
        {121, "closed container", "closed container", 0, 0}, 
        {122, "container", "containers", 6, 0}, 
        {123, "armour improver", "armour improvers", 8, 0}, 
        {124, "weapon improver", "weapon improvers", 8, 0}, 
        {130, "skillscroll", "skillscrolls", 8, 0}, 
        {138, "deep swamp", "deep swamps", 0, 0}, 
        {139, "identify altar", "identify altars", 0, 0}, 
        {150, "inventory list", "inventory lists", 0, 0}, 
        {154, "rune", "runes", 0, 0}, 
        {155, "trap", "traps", 0, 0}, 
        {156, "power_crystal", "power_crystals", 0, 0}, 
        {157, "corpse", "corpses", 0, 0}, 
        {158, "disease", "diseases", 0, 0}, 
        {159, "symptom", "symptoms", 0, 0}, 
        {160, "item builder", "item builders", 0, 0}, 
        {161, "building material", "building materials", 0, 0}};
#line 221 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
static int const   item_types_size  =    (int const   )(sizeof(item_types) / sizeof(item_types[0]));
#line 232 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
static int const   enc_to_item_power[21]  = 
#line 232
  {      (int const   )0,      (int const   )0,      (int const   )1,      (int const   )2, 
        (int const   )3,      (int const   )4,      (int const   )5,      (int const   )7, 
        (int const   )9,      (int const   )11,      (int const   )13,      (int const   )15, 
        (int const   )18,      (int const   )21,      (int const   )24,      (int const   )27, 
        (int const   )30,      (int const   )35,      (int const   )40,      (int const   )45, 
        (int const   )50};
#line 239 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
int get_power_from_ench(int ench ) 
{ 


  {
#line 240
  if (ench < 0) {
#line 241
    ench = 0;
  }
#line 242
  if (ench > (int )(sizeof(enc_to_item_power) / sizeof(enc_to_item_power[0]) - 1UL)) {
#line 243
    ench = (int )(sizeof(enc_to_item_power) / sizeof(enc_to_item_power[0]) - 1UL);
  }
#line 244
  return ((int )enc_to_item_power[ench]);
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
int calc_item_power(object const   *op ) 
{ 
  int i ;
  int tmp ;
  int enc ;
  sint8 tmp___0 ;
  int tmp___1 ;

  {
#line 260
  enc = 0;
#line 261
  i = 0;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! (i < 7)) {
#line 261
      goto while_break;
    }
    {
#line 262
    tmp___0 = get_attr_value(& op->stats, i);
#line 262
    enc += (int )tmp___0;
#line 261
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  tmp = 0;
#line 270
  i = 1;
  {
#line 270
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 270
    if (! (i < 26)) {
#line 270
      goto while_break___0;
    }
#line 271
    tmp += (int )op->resist[i];
#line 270
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 274
  if (tmp > 0) {
#line 275
    enc += (tmp + 10) / 20;
  } else
#line 276
  if (tmp < 0) {
#line 277
    enc += (tmp - 10) / 20;
  }
#line 279
  enc += (int )op->magic;
#line 284
  if ((int const   )op->type == 15) {
#line 285
    i = 1;
    {
#line 285
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 285
      if (! (i < 26)) {
#line 285
        goto while_break___1;
      }
#line 286
      if (op->attacktype & (unsigned int const   )(1 << i)) {
#line 287
        enc ++;
      }
#line 285
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 288
    if (op->slaying) {
#line 289
      enc += 2;
    }
  }
#line 292
  if ((int const   )op->type == 15) {
#line 303
    enc += (int )op->stats.food;
#line 304
    enc += (int )op->stats.hp;
#line 305
    enc += (int )op->stats.sp;
#line 306
    enc += (int )op->stats.grace;
#line 307
    enc = (int )((sint64 const   )enc + op->stats.exp);
  } else
#line 292
  if ((int const   )op->type == 16) {
#line 303
    enc += (int )op->stats.food;
#line 304
    enc += (int )op->stats.hp;
#line 305
    enc += (int )op->stats.sp;
#line 306
    enc += (int )op->stats.grace;
#line 307
    enc = (int )((sint64 const   )enc + op->stats.exp);
  } else
#line 292
  if ((int const   )op->type == 34) {
#line 303
    enc += (int )op->stats.food;
#line 304
    enc += (int )op->stats.hp;
#line 305
    enc += (int )op->stats.sp;
#line 306
    enc += (int )op->stats.grace;
#line 307
    enc = (int )((sint64 const   )enc + op->stats.exp);
  } else
#line 292
  if ((int const   )op->type == 33) {
#line 303
    enc += (int )op->stats.food;
#line 304
    enc += (int )op->stats.hp;
#line 305
    enc += (int )op->stats.sp;
#line 306
    enc += (int )op->stats.grace;
#line 307
    enc = (int )((sint64 const   )enc + op->stats.exp);
  } else
#line 292
  if ((int const   )op->type == 70) {
#line 303
    enc += (int )op->stats.food;
#line 304
    enc += (int )op->stats.hp;
#line 305
    enc += (int )op->stats.sp;
#line 306
    enc += (int )op->stats.grace;
#line 307
    enc = (int )((sint64 const   )enc + op->stats.exp);
  } else
#line 292
  if ((int const   )op->type == 99) {
#line 303
    enc += (int )op->stats.food;
#line 304
    enc += (int )op->stats.hp;
#line 305
    enc += (int )op->stats.sp;
#line 306
    enc += (int )op->stats.grace;
#line 307
    enc = (int )((sint64 const   )enc + op->stats.exp);
  } else
#line 292
  if ((int const   )op->type == 100) {
#line 303
    enc += (int )op->stats.food;
#line 304
    enc += (int )op->stats.hp;
#line 305
    enc += (int )op->stats.sp;
#line 306
    enc += (int )op->stats.grace;
#line 307
    enc = (int )((sint64 const   )enc + op->stats.exp);
  } else
#line 292
  if ((int const   )op->type == 39) {
#line 303
    enc += (int )op->stats.food;
#line 304
    enc += (int )op->stats.hp;
#line 305
    enc += (int )op->stats.sp;
#line 306
    enc += (int )op->stats.grace;
#line 307
    enc = (int )((sint64 const   )enc + op->stats.exp);
  } else
#line 292
  if ((int const   )op->type == 113) {
#line 303
    enc += (int )op->stats.food;
#line 304
    enc += (int )op->stats.hp;
#line 305
    enc += (int )op->stats.sp;
#line 306
    enc += (int )op->stats.grace;
#line 307
    enc = (int )((sint64 const   )enc + op->stats.exp);
  } else
#line 292
  if ((int const   )op->type == 104) {
#line 303
    enc += (int )op->stats.food;
#line 304
    enc += (int )op->stats.hp;
#line 305
    enc += (int )op->stats.sp;
#line 306
    enc += (int )op->stats.grace;
#line 307
    enc = (int )((sint64 const   )enc + op->stats.exp);
  } else
#line 292
  if ((int const   )op->type == 87) {
#line 303
    enc += (int )op->stats.food;
#line 304
    enc += (int )op->stats.hp;
#line 305
    enc += (int )op->stats.sp;
#line 306
    enc += (int )op->stats.grace;
#line 307
    enc = (int )((sint64 const   )enc + op->stats.exp);
  }
#line 309
  enc += (int )op->stats.luck;
#line 312
  i = 1;
  {
#line 312
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 312
    if (! (i < 20)) {
#line 312
      goto while_break___2;
    }
#line 313
    if (op->path_attuned & (unsigned int const   )(1 << i)) {
#line 314
      enc ++;
    } else
#line 315
    if (op->path_denied & (unsigned int const   )(1 << i)) {
#line 316
      enc -= 2;
    } else
#line 317
    if (op->path_repelled & (unsigned int const   )(1 << i)) {
#line 318
      enc --;
    }
#line 312
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 321
  if (op->flags[2] & 1U) {
#line 322
    enc += 5;
  }
#line 323
  if (op->flags[1] & (1U << 8)) {
#line 324
    enc += 3;
  }
#line 325
  if (op->flags[1] & (1U << 7)) {
#line 326
    enc += 2;
  }
#line 327
  if (op->flags[2] & (1U << 7)) {
#line 328
    enc ++;
  }
#line 329
  if (op->flags[1] & (1U << 29)) {
#line 330
    enc += 2;
  }
#line 331
  if (op->flags[2] & (1U << 29)) {
#line 332
    enc ++;
  }
#line 333
  if (op->flags[2] & (1U << 21)) {
#line 334
    enc ++;
  }
  {
#line 336
  tmp___1 = get_power_from_ench(enc);
  }
#line 336
  return (tmp___1);
}
}
#line 345 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
typedata const   *get_typedata(int itemtype ) 
{ 
  int i ;

  {
#line 348
  i = 0;
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! (i < (int )item_types_size)) {
#line 348
      goto while_break;
    }
#line 349
    if (item_types[i].number == (int const   )itemtype) {
#line 350
      return (& item_types[i]);
    }
#line 348
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 351
  return ((typedata const   *)((void *)0));
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
typedata const   *get_typedata_by_name(char const   *name ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 368
  i = 0;
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (! (i < (int )item_types_size)) {
#line 368
      goto while_break;
    }
    {
#line 369
    tmp = strcmp((char const   *)item_types[i].name, name);
    }
#line 369
    if (! tmp) {
#line 370
      return (& item_types[i]);
    }
#line 368
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 371
  i = 0;
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 371
    if (! (i < (int )item_types_size)) {
#line 371
      goto while_break___0;
    }
    {
#line 372
    tmp___0 = strcmp((char const   *)item_types[i].name_pl, name);
    }
#line 372
    if (! tmp___0) {
      {
#line 373
      LOG((LogLevel )1, "get_typedata_by_name: I have been sent the plural %s, the singular form %s is preffered\n",
          name, item_types[i].name);
      }
#line 374
      return (& item_types[i]);
    }
#line 371
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 376
  return ((typedata const   *)((void *)0));
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
StringBuffer *describe_resistance(object const   *op , int newline , StringBuffer *buf ) 
{ 
  int tmpvar ;
  int tmp ;

  {
#line 394
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 395
    buf = stringbuffer_new();
    }
  }
#line 397
  tmpvar = 0;
  {
#line 397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 397
    if (! (tmpvar < 26)) {
#line 397
      goto while_break;
    }
#line 398
    if (op->resist[tmpvar]) {
#line 398
      if ((int const   )op->type != 72) {
#line 398
        goto _L;
      } else {
        {
#line 398
        tmp = atnr_is_dragon_enabled(tmpvar);
        }
#line 398
        if (tmp == 1) {
          _L: /* CIL Label */ 
#line 399
          if (! newline) {
            {
#line 400
            stringbuffer_append_printf(buf, "(%s %+d)", resist_plus[tmpvar], (int )op->resist[tmpvar]);
            }
          } else {
            {
#line 402
            stringbuffer_append_printf(buf, "%s %d\n", resist_plus[tmpvar], (int )op->resist[tmpvar]);
            }
          }
        }
      }
    }
#line 397
    tmpvar ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 406
  return (buf);
}
}
#line 418 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
void query_weight(object const   *op , char *buf , size_t size ) 
{ 
  sint32 i ;
  uint32 tmp ;

  {
#line 419
  if (op->nrof) {
#line 419
    tmp = op->nrof;
  } else {
#line 419
    tmp = (uint32 const   )1;
  }
#line 419
  i = (sint32 )(tmp * (uint32 const   )op->weight + (uint32 const   )op->carrying);
#line 421
  if (op->weight < 0) {
    {
#line 422
    snprintf((char */* __restrict  */)buf, size, (char const   */* __restrict  */)"      ");
    }
  } else
#line 423
  if (i % 1000) {
    {
#line 424
    snprintf((char */* __restrict  */)buf, size, (char const   */* __restrict  */)"%6.1f",
             (double )i / 1000.0);
    }
  } else {
    {
#line 426
    snprintf((char */* __restrict  */)buf, size, (char const   */* __restrict  */)"%4d  ",
             i / 1000);
    }
  }
#line 427
  return;
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
void get_levelnumber(int i , char *buf , size_t size ) 
{ 


  {
#line 439
  if (i > 99) {
    {
#line 440
    snprintf((char */* __restrict  */)buf, size, (char const   */* __restrict  */)"%d.",
             i);
    }
#line 441
    return;
  } else
#line 439
  if (i < 0) {
    {
#line 440
    snprintf((char */* __restrict  */)buf, size, (char const   */* __restrict  */)"%d.",
             i);
    }
#line 441
    return;
  }
#line 443
  if (i < 21) {
    {
#line 444
    snprintf((char */* __restrict  */)buf, size, (char const   */* __restrict  */)"%s",
             levelnumbers[i]);
    }
#line 445
    return;
  }
#line 447
  if (! (i % 10)) {
    {
#line 448
    snprintf((char */* __restrict  */)buf, size, (char const   */* __restrict  */)"%s",
             levelnumbers_10[i / 10]);
    }
#line 449
    return;
  }
  {
#line 451
  snprintf((char */* __restrict  */)buf, size, (char const   */* __restrict  */)"%s%s",
           numbers_10[i / 10], levelnumbers[i % 10]);
  }
#line 452
  return;
}
}
#line 464 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
static StringBuffer *ring_desc(object const   *op , StringBuffer *buf ) 
{ 
  int attr ;
  int val ;
  size_t len ;
  sint8 tmp ;
  size_t tmp___0 ;

  {
#line 468
  if (! ((unsigned long )op != (unsigned long )((void *)0))) {
    {
#line 468
    __assert_fail("op != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c",
                  468U, "ring_desc");
    }
  }
#line 469
  if (! ((int const   )op->type == 70)) {
#line 469
    if (! ((int const   )op->type == 39)) {
#line 469
      if (! ((int const   )op->type == 43)) {
        {
#line 469
        __assert_fail("op->type == 70 || op->type == 39 || op->type == 43", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c",
                      469U, "ring_desc");
        }
      }
    }
  }
#line 471
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 472
    buf = stringbuffer_new();
    }
  }
  {
#line 473
  len = stringbuffer_length(buf);
  }
#line 475
  if (! (op->flags[0] & (1U << 29))) {
#line 476
    return (buf);
  }
#line 478
  attr = 0;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! (attr < 7)) {
#line 478
      goto while_break;
    }
    {
#line 479
    tmp = get_attr_value(& op->stats, attr);
#line 479
    val = (int )tmp;
    }
#line 479
    if (val != 0) {
      {
#line 480
      stringbuffer_append_printf(buf, "(%s%+d)", short_stat_name[attr], val);
      }
    }
#line 478
    attr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 483
  if (op->stats.exp) {
    {
#line 484
    stringbuffer_append_printf(buf, "(speed %+ld)", op->stats.exp);
    }
  }
#line 485
  if (op->stats.wc) {
    {
#line 486
    stringbuffer_append_printf(buf, "(wc%+d)", (int const   )op->stats.wc);
    }
  }
#line 487
  if (op->stats.dam) {
    {
#line 488
    stringbuffer_append_printf(buf, "(dam%+d)", (int const   )op->stats.dam);
    }
  }
#line 489
  if (op->stats.ac) {
    {
#line 490
    stringbuffer_append_printf(buf, "(ac%+d)", (int const   )op->stats.ac);
    }
  }
  {
#line 492
  describe_resistance(op, 0, buf);
  }
#line 494
  if (op->stats.food != 0) {
    {
#line 495
    stringbuffer_append_printf(buf, "(sustenance%+d)", op->stats.food);
    }
  }
#line 496
  if (op->stats.grace) {
    {
#line 497
    stringbuffer_append_printf(buf, "(grace%+d)", (int const   )op->stats.grace);
    }
  }
#line 498
  if (op->stats.sp) {
#line 498
    if ((int const   )op->type != 43) {
      {
#line 499
      stringbuffer_append_printf(buf, "(magic%+d)", (int const   )op->stats.sp);
      }
    }
  }
#line 500
  if (op->stats.hp) {
    {
#line 501
    stringbuffer_append_printf(buf, "(regeneration%+d)", (int const   )op->stats.hp);
    }
  }
#line 502
  if (op->stats.luck) {
    {
#line 503
    stringbuffer_append_printf(buf, "(luck%+d)", (int const   )op->stats.luck);
    }
  }
#line 504
  if (op->flags[2] & 1U) {
    {
#line 505
    stringbuffer_append_printf(buf, "(lifesaving)");
    }
  }
#line 506
  if (op->flags[1] & (1U << 8)) {
    {
#line 507
    stringbuffer_append_printf(buf, "(reflect spells)");
    }
  }
#line 508
  if (op->flags[1] & (1U << 7)) {
    {
#line 509
    stringbuffer_append_printf(buf, "(reflect missiles)");
    }
  }
#line 510
  if (op->flags[2] & (1U << 7)) {
    {
#line 511
    stringbuffer_append_printf(buf, "(stealth)");
    }
  }
  {
#line 513
  describe_spellpath_attenuation("Attuned", (int )op->path_attuned, buf);
#line 514
  describe_spellpath_attenuation("Repelled", (int )op->path_repelled, buf);
#line 515
  describe_spellpath_attenuation("Denied", (int )op->path_denied, buf);
#line 520
  tmp___0 = stringbuffer_length(buf);
  }
#line 520
  if (tmp___0 == len) {
#line 520
    if ((int const   )op->type != 43) {
      {
#line 521
      stringbuffer_append_string(buf, "of adornment");
      }
    }
  }
#line 523
  return (buf);
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
void query_short_name(object const   *op , char *buf , size_t size ) 
{ 
  size_t len ;
  int tmp ;
  size_t tmp___0 ;
  char *desc ;
  StringBuffer *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 538
  len = (size_t )0;
#line 540
  if ((unsigned long )op->name == (unsigned long )((void *)0)) {
    {
#line 541
    snprintf((char */* __restrict  */)buf, size, (char const   */* __restrict  */)"(null)");
    }
#line 542
    return;
  }
#line 544
  if (! op->nrof) {
#line 544
    if (! op->weight) {
#line 544
      if (! op->title) {
        {
#line 544
        tmp = is_magical(op);
        }
#line 544
        if (! tmp) {
          {
#line 545
          snprintf((char */* __restrict  */)buf, size, (char const   */* __restrict  */)"%s",
                   op->name);
          }
#line 546
          return;
        }
      }
    }
  }
#line 548
  *(buf + 0) = (char )'\000';
#line 550
  if (op->nrof <= 1U) {
    {
#line 551
    safe_strcat(buf, (char const   *)op->name, & len, size);
    }
  } else {
    {
#line 553
    safe_strcat(buf, (char const   *)op->name_pl, & len, size);
    }
  }
#line 555
  if (op->title) {
#line 555
    if (op->flags[0] & (1U << 29)) {
      {
#line 556
      safe_strcat(buf, " ", & len, size);
#line 557
      safe_strcat(buf, (char const   *)op->title, & len, size);
      }
    }
  }
  {
#line 564
  if ((int const   )op->type == 3) {
#line 564
    goto case_3;
  }
#line 564
  if ((int const   )op->type == 109) {
#line 564
    goto case_3;
  }
#line 564
  if ((int const   )op->type == 111) {
#line 564
    goto case_3;
  }
#line 564
  if ((int const   )op->type == 85) {
#line 564
    goto case_3;
  }
#line 582
  if ((int const   )op->type == 70) {
#line 582
    goto case_70;
  }
#line 582
  if ((int const   )op->type == 39) {
#line 582
    goto case_70;
  }
#line 582
  if ((int const   )op->type == 43) {
#line 582
    goto case_70;
  }
#line 596
  goto switch_default;
  case_3: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_85: /* CIL Label */ 
#line 565
  if (op->flags[0] & (1U << 29)) {
#line 565
    goto _L;
  } else
#line 565
  if (op->flags[2] & (1U << 16)) {
    _L: /* CIL Label */ 
#line 566
    if (! op->title) {
      {
#line 567
      safe_strcat(buf, " of ", & len, size);
      }
#line 568
      if (op->inv) {
        {
#line 569
        safe_strcat(buf, (op->inv)->name, & len, size);
        }
      } else {
        {
#line 571
        LOG((LogLevel )0, "Spellbook %s lacks inventory\n", op->name);
        }
      }
    }
#line 573
    if ((int const   )op->type != 85) {
      {
#line 574
      snprintf((char */* __restrict  */)(buf + len), size - len, (char const   */* __restrict  */)" (lvl %d)",
               (int const   )op->level);
#line 575
      tmp___0 = strlen((char const   *)(buf + len));
#line 575
      len += tmp___0;
      }
    }
  }
#line 578
  goto switch_break;
  case_70: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_43: /* CIL Label */ 
#line 583
  if (! op->title) {
    {
#line 587
    tmp___1 = ring_desc(op, (StringBuffer *)((void *)0));
#line 587
    desc = stringbuffer_finish(tmp___1);
    }
#line 588
    if (*(desc + 0)) {
      {
#line 589
      safe_strcat(buf, " ", & len, size);
#line 590
      safe_strcat(buf, (char const   *)desc, & len, size);
      }
    }
    {
#line 592
    free((void *)desc);
    }
  }
#line 594
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 597
  if (op->magic) {
#line 597
    if (op->flags[2] & (1U << 16)) {
      {
#line 597
      tmp___3 = need_identify(op);
      }
#line 597
      if (tmp___3) {
        {
#line 599
        snprintf((char */* __restrict  */)(buf + len), size - len, (char const   */* __restrict  */)" %+d",
                 (int const   )op->magic);
#line 600
        tmp___2 = strlen((char const   *)(buf + len));
#line 600
        len += tmp___2;
        }
      } else {
#line 597
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 597
    if (op->flags[0] & (1U << 29)) {
      {
#line 599
      snprintf((char */* __restrict  */)(buf + len), size - len, (char const   */* __restrict  */)" %+d",
               (int const   )op->magic);
#line 600
      tmp___2 = strlen((char const   *)(buf + len));
#line 600
      len += tmp___2;
      }
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 603
  return;
}
}
#line 615 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
void query_name(object const   *op , char *buf , size_t size ) 
{ 
  size_t len ;
  size_t tmp ;

  {
  {
#line 616
  len = (size_t )0;
#line 618
  *(buf + 0) = (char )'\000';
#line 620
  query_short_name(op, buf + len, size - len);
#line 621
  tmp = strlen((char const   *)(buf + len));
#line 621
  len += tmp;
  }
#line 623
  if (op->flags[2] & (1U << 22)) {
    {
#line 624
    safe_strcat(buf, " *", & len, size);
    }
  }
#line 625
  if ((int const   )op->type == 122) {
#line 625
    if (op->env) {
#line 625
      if ((unsigned long )(op->env)->container == (unsigned long )op) {
        {
#line 627
        safe_strcat(buf, " (open)", & len, size);
        }
      } else {
#line 625
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 625
    if (! op->env) {
#line 625
      if (op->flags[0] & (1U << 5)) {
        {
#line 627
        safe_strcat(buf, " (open)", & len, size);
        }
      }
    }
  }
#line 629
  if (op->flags[2] & (1U << 14)) {
#line 630
    if (op->flags[2] & (1U << 11)) {
      {
#line 631
      safe_strcat(buf, " (damned)", & len, size);
      }
    } else
#line 632
    if (op->flags[2] & (1U << 10)) {
      {
#line 633
      safe_strcat(buf, " (cursed)", & len, size);
      }
    }
  }
#line 635
  if (op->flags[3] & (1U << 16)) {
#line 635
    if (op->flags[3] & (1U << 17)) {
      {
#line 636
      safe_strcat(buf, " (blessed)", & len, size);
      }
    }
  }
#line 647
  if (op->flags[2] & (1U << 13)) {
#line 647
    if (! (op->flags[0] & (1U << 29))) {
      {
#line 648
      safe_strcat(buf, " (magic)", & len, size);
      }
    }
  }
#line 650
  if (op->flags[0] & (1U << 5)) {
    {
#line 654
    if ((int const   )op->type == 3) {
#line 654
      goto case_3;
    }
#line 654
    if ((int const   )op->type == 109) {
#line 654
      goto case_3;
    }
#line 654
    if ((int const   )op->type == 14) {
#line 654
      goto case_3;
    }
#line 658
    if ((int const   )op->type == 15) {
#line 658
      goto case_15;
    }
#line 671
    if ((int const   )op->type == 87) {
#line 671
      goto case_87;
    }
#line 671
    if ((int const   )op->type == 104) {
#line 671
      goto case_87;
    }
#line 671
    if ((int const   )op->type == 113) {
#line 671
      goto case_87;
    }
#line 671
    if ((int const   )op->type == 39) {
#line 671
      goto case_87;
    }
#line 671
    if ((int const   )op->type == 100) {
#line 671
      goto case_87;
    }
#line 671
    if ((int const   )op->type == 99) {
#line 671
      goto case_87;
    }
#line 671
    if ((int const   )op->type == 70) {
#line 671
      goto case_87;
    }
#line 671
    if ((int const   )op->type == 33) {
#line 671
      goto case_87;
    }
#line 671
    if ((int const   )op->type == 34) {
#line 671
      goto case_87;
    }
#line 671
    if ((int const   )op->type == 16) {
#line 671
      goto case_87;
    }
#line 675
    if ((int const   )op->type == 122) {
#line 675
      goto case_122;
    }
#line 680
    goto switch_default;
    case_3: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_14: /* CIL Label */ 
    {
#line 655
    safe_strcat(buf, " (readied)", & len, size);
    }
#line 656
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 659
    safe_strcat(buf, " (wielded)", & len, size);
    }
#line 660
    goto switch_break;
    case_87: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_39: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_16: /* CIL Label */ 
    {
#line 672
    safe_strcat(buf, " (worn)", & len, size);
    }
#line 673
    goto switch_break;
    case_122: /* CIL Label */ 
    {
#line 676
    safe_strcat(buf, " (active)", & len, size);
    }
#line 677
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 681
    safe_strcat(buf, " (applied)", & len, size);
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 684
  if (op->flags[0] & (1U << 6)) {
    {
#line 685
    safe_strcat(buf, " (unpaid)", & len, size);
    }
  }
#line 686
  return;
}
}
#line 705 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
void query_base_name(object const   *op , int plural , char *buf , size_t size ) 
{ 
  size_t len ;
  int tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  char *s ;
  StringBuffer *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;

  {
#line 708
  if (! plural) {
#line 708
    if (! op->name) {
      {
#line 710
      strncpy((char */* __restrict  */)buf, (char const   */* __restrict  */)"(null)",
              size);
      }
#line 711
      return;
    } else {
#line 708
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 708
  if (plural) {
#line 708
    if (! op->name_pl) {
      {
#line 710
      strncpy((char */* __restrict  */)buf, (char const   */* __restrict  */)"(null)",
              size);
      }
#line 711
      return;
    }
  }
#line 714
  if (! op->nrof) {
#line 714
    if (! op->weight) {
#line 714
      if (! op->title) {
        {
#line 714
        tmp = is_magical(op);
        }
#line 714
        if (! tmp) {
          {
#line 715
          strncpy((char */* __restrict  */)buf, (char const   */* __restrict  */)op->name,
                  size);
          }
#line 716
          return;
        }
      }
    }
  }
#line 719
  *(buf + 0) = (char )'\000';
#line 721
  if (plural) {
#line 721
    tmp___0 = op->name_pl;
  } else {
#line 721
    tmp___0 = op->name;
  }
  {
#line 721
  snprintf((char */* __restrict  */)buf, size, (char const   */* __restrict  */)"%s",
           tmp___0);
#line 722
  len = strlen((char const   *)buf);
  }
#line 724
  if (op->title) {
#line 724
    if (op->flags[0] & (1U << 29)) {
      {
#line 725
      safe_strcat(buf, " ", & len, size);
#line 726
      safe_strcat(buf, (char const   *)op->title, & len, size);
      }
    }
  }
  {
#line 733
  if ((int const   )op->type == 3) {
#line 733
    goto case_3;
  }
#line 733
  if ((int const   )op->type == 109) {
#line 733
    goto case_3;
  }
#line 733
  if ((int const   )op->type == 111) {
#line 733
    goto case_3;
  }
#line 733
  if ((int const   )op->type == 85) {
#line 733
    goto case_3;
  }
#line 751
  if ((int const   )op->type == 70) {
#line 751
    goto case_70;
  }
#line 751
  if ((int const   )op->type == 39) {
#line 751
    goto case_70;
  }
#line 751
  if ((int const   )op->type == 43) {
#line 751
    goto case_70;
  }
#line 765
  goto switch_default;
  case_3: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_85: /* CIL Label */ 
#line 734
  if (op->flags[0] & (1U << 29)) {
#line 734
    goto _L___0;
  } else
#line 734
  if (op->flags[2] & (1U << 16)) {
    _L___0: /* CIL Label */ 
#line 735
    if (! op->title) {
      {
#line 736
      safe_strcat(buf, " of ", & len, size);
      }
#line 737
      if (op->inv) {
        {
#line 738
        safe_strcat(buf, (op->inv)->name, & len, size);
        }
      } else {
        {
#line 740
        LOG((LogLevel )0, "Spellbook %s lacks inventory\n", op->name);
        }
      }
    }
#line 742
    if ((int const   )op->type != 85) {
      {
#line 743
      snprintf((char */* __restrict  */)(buf + len), size - len, (char const   */* __restrict  */)" (lvl %d)",
               (int const   )op->level);
#line 744
      tmp___1 = strlen((char const   *)(buf + len));
#line 744
      len += tmp___1;
      }
    }
  }
#line 747
  goto switch_break;
  case_70: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_43: /* CIL Label */ 
#line 752
  if (! op->title) {
    {
#line 756
    tmp___2 = ring_desc(op, (StringBuffer *)((void *)0));
#line 756
    s = stringbuffer_finish(tmp___2);
    }
#line 757
    if (*(s + 0)) {
      {
#line 758
      safe_strcat(buf, " ", & len, size);
#line 759
      safe_strcat(buf, (char const   *)s, & len, size);
      }
    }
    {
#line 761
    free((void *)s);
    }
  }
#line 763
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 766
  if (op->magic) {
#line 766
    if (op->flags[2] & (1U << 16)) {
      {
#line 766
      tmp___5 = need_identify(op);
      }
#line 766
      if (tmp___5) {
        {
#line 768
        tmp___3 = strlen((char const   *)buf);
#line 768
        tmp___4 = strlen((char const   *)buf);
#line 768
        snprintf((char */* __restrict  */)(buf + tmp___4), size - tmp___3, (char const   */* __restrict  */)" %+d",
                 (int const   )op->magic);
        }
      } else {
#line 766
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 766
    if (op->flags[0] & (1U << 29)) {
      {
#line 768
      tmp___3 = strlen((char const   *)buf);
#line 768
      tmp___4 = strlen((char const   *)buf);
#line 768
      snprintf((char */* __restrict  */)(buf + tmp___4), size - tmp___3, (char const   */* __restrict  */)" %+d",
               (int const   )op->magic);
      }
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 771
  return;
}
}
#line 786 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
StringBuffer *describe_monster(object const   *op , StringBuffer *buf ) 
{ 
  int i ;
  float tmp ;
  float tmp___0 ;
  treasure *t ;
  int first ;
  object *tmp___1 ;
  int tmp___2 ;

  {
#line 789
  if (! ((unsigned long )op != (unsigned long )((void *)0))) {
    {
#line 789
    __assert_fail("op != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c",
                  789U, "describe_monster");
    }
  }
#line 790
  if (! (op->flags[0] & (1U << 14))) {
#line 790
    if (! ((int const   )op->type == 1)) {
      {
#line 790
      __assert_fail("((op)->flags[14/32]&(1U<<(14%32))) || op->type == 1", "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c",
                    790U, "describe_monster");
      }
    }
  }
#line 792
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 793
    buf = stringbuffer_new();
    }
  }
#line 799
  if (op->speed < (float const   )0) {
#line 799
    tmp___0 = - op->speed;
  } else {
#line 799
    tmp___0 = op->speed;
  }
#line 799
  if ((double )tmp___0 > 0.00001) {
#line 800
    if (op->speed < (float const   )0) {
#line 800
      tmp = - op->speed;
    } else {
#line 800
      tmp = op->speed;
    }
    {
#line 801
    if ((int )(tmp * (float const   )15) == 0) {
#line 801
      goto case_0;
    }
#line 805
    if ((int )(tmp * (float const   )15) == 1) {
#line 805
      goto case_1;
    }
#line 809
    if ((int )(tmp * (float const   )15) == 2) {
#line 809
      goto case_2;
    }
#line 814
    if ((int )(tmp * (float const   )15) == 4) {
#line 814
      goto case_4;
    }
#line 814
    if ((int )(tmp * (float const   )15) == 3) {
#line 814
      goto case_4;
    }
#line 819
    if ((int )(tmp * (float const   )15) == 6) {
#line 819
      goto case_6;
    }
#line 819
    if ((int )(tmp * (float const   )15) == 5) {
#line 819
      goto case_6;
    }
#line 826
    if ((int )(tmp * (float const   )15) == 10) {
#line 826
      goto case_10;
    }
#line 826
    if ((int )(tmp * (float const   )15) == 9) {
#line 826
      goto case_10;
    }
#line 826
    if ((int )(tmp * (float const   )15) == 8) {
#line 826
      goto case_10;
    }
#line 826
    if ((int )(tmp * (float const   )15) == 7) {
#line 826
      goto case_10;
    }
#line 830
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 802
    stringbuffer_append_string(buf, "(very slow movement)");
    }
#line 803
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 806
    stringbuffer_append_string(buf, "(slow movement)");
    }
#line 807
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 810
    stringbuffer_append_string(buf, "(normal movement)");
    }
#line 811
    goto switch_break;
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    {
#line 815
    stringbuffer_append_string(buf, "(fast movement)");
    }
#line 816
    goto switch_break;
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    {
#line 820
    stringbuffer_append_string(buf, "(very fast movement)");
    }
#line 821
    goto switch_break;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
    {
#line 827
    stringbuffer_append_string(buf, "(extremely fast movement)");
    }
#line 828
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 831
    stringbuffer_append_string(buf, "(lightning fast movement)");
    }
#line 832
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 835
  if (op->flags[1] & (1U << 4)) {
    {
#line 836
    stringbuffer_append_string(buf, "(undead)");
    }
  }
#line 837
  if (op->flags[0] & (1U << 21)) {
    {
#line 838
    stringbuffer_append_string(buf, "(see invisible)");
    }
  }
#line 839
  if (op->flags[1] & (1U << 25)) {
    {
#line 840
    stringbuffer_append_string(buf, "(wield weapon)");
    }
  }
#line 841
  if (op->flags[1] & (1U << 23)) {
    {
#line 842
    stringbuffer_append_string(buf, "(archer)");
    }
  }
#line 843
  if (op->flags[1] & (1U << 24)) {
    {
#line 844
    stringbuffer_append_string(buf, "(wear armour)");
    }
  }
#line 845
  if (op->flags[1] & (1U << 26)) {
    {
#line 846
    stringbuffer_append_string(buf, "(wear ring)");
    }
  }
#line 847
  if (op->flags[1] & (1U << 21)) {
    {
#line 848
    stringbuffer_append_string(buf, "(read scroll)");
    }
  }
#line 849
  if (op->flags[1] & (1U << 22)) {
    {
#line 850
    stringbuffer_append_string(buf, "(fires wand/rod/horn)");
    }
  }
#line 851
  if (op->flags[2] & (1U << 15)) {
    {
#line 852
    stringbuffer_append_string(buf, "(skill user)");
    }
  }
#line 853
  if (op->flags[1] & (1U << 20)) {
    {
#line 854
    stringbuffer_append_string(buf, "(spellcaster)");
    }
  }
#line 855
  if (op->flags[0] & (1U << 15)) {
    {
#line 856
    stringbuffer_append_string(buf, "(friendly)");
    }
  }
#line 857
  if (op->flags[1] & (1U << 6)) {
    {
#line 858
    stringbuffer_append_string(buf, "(unaggressive)");
    }
  }
#line 859
  if (op->flags[1] & (1U << 1)) {
    {
#line 860
    stringbuffer_append_string(buf, "(hitback)");
    }
  }
#line 861
  if (op->flags[2] & (1U << 7)) {
    {
#line 862
    stringbuffer_append_string(buf, "(stealthy)");
    }
  }
#line 863
  if ((unsigned long )op->randomitems != (unsigned long )((void *)0)) {
#line 865
    first = 1;
#line 867
    t = (op->randomitems)->items;
    {
#line 867
    while (1) {
      while_continue: /* CIL Label */ ;
#line 867
      if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 867
        goto while_break;
      }
#line 868
      if (t->item) {
#line 868
        if ((int )(t->item)->clone.type == 101) {
#line 869
          if (first) {
            {
#line 870
            first = 0;
#line 871
            stringbuffer_append_string(buf, "(Spell abilities:)");
            }
          }
          {
#line 873
          stringbuffer_append_printf(buf, "(%s)", (t->item)->clone.name);
          }
        }
      }
#line 867
      t = t->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 876
  if ((int const   )op->type == 1) {
#line 877
    if ((op->contr)->digestion) {
#line 878
      if ((int )(op->contr)->digestion != 0) {
        {
#line 879
        stringbuffer_append_printf(buf, "(sustenance%+d)", (int )(op->contr)->digestion);
        }
      }
    }
#line 881
    if ((op->contr)->gen_grace) {
      {
#line 882
      stringbuffer_append_printf(buf, "(grace%+d)", (int )(op->contr)->gen_grace);
      }
    }
#line 884
    if ((op->contr)->gen_sp) {
      {
#line 885
      stringbuffer_append_printf(buf, "(magic%+d)", (int )(op->contr)->gen_sp);
      }
    }
#line 887
    if ((op->contr)->gen_hp) {
      {
#line 888
      stringbuffer_append_printf(buf, "(regeneration%+d)", (int )(op->contr)->gen_hp);
      }
    }
#line 890
    if (op->stats.luck) {
      {
#line 891
      stringbuffer_append_printf(buf, "(luck%+d)", (int const   )op->stats.luck);
      }
    }
  }
  {
#line 896
  tmp___2 = is_dragon_pl(op);
  }
#line 896
  if (tmp___2) {
    {
#line 903
    tmp___1 = object_find_by_type_and_name(op, 43, "clawing");
    }
#line 904
    if (tmp___1) {
#line 904
      if (tmp___1->attacktype != 0U) {
        {
#line 905
        describe_attacktype("Claws", (int )tmp___1->attacktype, buf);
        }
      } else {
        {
#line 907
        describe_attacktype("Attacks", (int )op->attacktype, buf);
        }
      }
    } else {
      {
#line 907
      describe_attacktype("Attacks", (int )op->attacktype, buf);
      }
    }
  } else {
    {
#line 910
    describe_attacktype("Attacks", (int )op->attacktype, buf);
    }
  }
  {
#line 912
  describe_spellpath_attenuation("Attuned", (int )(op->path_attuned & ~ op->path_denied),
                                 buf);
#line 913
  describe_spellpath_attenuation("Repelled", (int )(op->path_repelled & ~ op->path_denied),
                                 buf);
#line 914
  describe_spellpath_attenuation("Denied", (int )op->path_denied, buf);
#line 915
  i = 0;
  }
  {
#line 915
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 915
    if (! (i < 26)) {
#line 915
      goto while_break___0;
    }
#line 916
    if (op->resist[i]) {
      {
#line 917
      stringbuffer_append_printf(buf, "(%s %+d)", resist_plus[i], (int )op->resist[i]);
      }
    }
#line 915
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 921
  return (buf);
}
}
#line 963 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
StringBuffer *describe_item(object const   *op , object const   *owner , StringBuffer *buf ) 
{ 
  int identified ;
  int i ;
  StringBuffer *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int attr ;
  int val ;
  sint8 tmp___2 ;
  int more_info ;
  int tmp___3 ;

  {
#line 966
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 967
    buf = stringbuffer_new();
    }
  }
#line 969
  if (op->flags[0] & (1U << 14)) {
    {
#line 970
    tmp = describe_monster(op, buf);
    }
#line 970
    return (tmp);
  } else
#line 969
  if ((int const   )op->type == 1) {
    {
#line 970
    tmp = describe_monster(op, buf);
    }
#line 970
    return (tmp);
  }
  {
#line 976
  tmp___0 = need_identify(op);
  }
#line 976
  if (tmp___0) {
#line 976
    if (op->flags[0] & (1U << 29)) {
#line 977
      identified = 1;
    } else {
      {
#line 979
      stringbuffer_append_string(buf, "(unidentified)");
#line 980
      identified = 0;
      }
    }
  } else {
#line 977
    identified = 1;
  }
  {
#line 996
  if ((int const   )op->type == 74) {
#line 996
    goto case_74;
  }
#line 996
  if ((int const   )op->type == 87) {
#line 996
    goto case_74;
  }
#line 996
  if ((int const   )op->type == 104) {
#line 996
    goto case_74;
  }
#line 996
  if ((int const   )op->type == 113) {
#line 996
    goto case_74;
  }
#line 996
  if ((int const   )op->type == 100) {
#line 996
    goto case_74;
  }
#line 996
  if ((int const   )op->type == 99) {
#line 996
    goto case_74;
  }
#line 996
  if ((int const   )op->type == 33) {
#line 996
    goto case_74;
  }
#line 996
  if ((int const   )op->type == 34) {
#line 996
    goto case_74;
  }
#line 996
  if ((int const   )op->type == 16) {
#line 996
    goto case_74;
  }
#line 996
  if ((int const   )op->type == 15) {
#line 996
    goto case_74;
  }
#line 996
  if ((int const   )op->type == 3) {
#line 996
    goto case_74;
  }
#line 996
  if ((int const   )op->type == 109) {
#line 996
    goto case_74;
  }
#line 996
  if ((int const   )op->type == 13) {
#line 996
    goto case_74;
  }
#line 996
  if ((int const   )op->type == 14) {
#line 996
    goto case_74;
  }
#line 999
  if ((int const   )op->type == 82) {
#line 999
    goto case_82;
  }
#line 1002
  if ((int const   )op->type == 156) {
#line 1002
    goto case_156;
  }
#line 1035
  if ((int const   )op->type == 54) {
#line 1035
    goto case_54;
  }
#line 1035
  if ((int const   )op->type == 72) {
#line 1035
    goto case_54;
  }
#line 1035
  if ((int const   )op->type == 6) {
#line 1035
    goto case_54;
  }
#line 1059
  if ((int const   )op->type == 39) {
#line 1059
    goto case_39;
  }
#line 1059
  if ((int const   )op->type == 70) {
#line 1059
    goto case_39;
  }
#line 1059
  if ((int const   )op->type == 43) {
#line 1059
    goto case_39;
  }
#line 1068
  goto switch_default;
  case_74: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_14: /* CIL Label */ 
#line 997
  goto switch_break;
  case_82: /* CIL Label */ 
#line 1000
  goto switch_break;
  case_156: /* CIL Label */ 
#line 1004
  if ((int const   )op->stats.maxsp == 0) {
    {
#line 1005
    stringbuffer_append_printf(buf, "(capacity %d).", (int const   )op->stats.maxsp);
    }
  } else {
#line 1007
    if ((int const   )op->stats.maxsp > 1000) {
#line 1008
      i = (int )(((int const   )op->stats.maxsp % 1000) / 100);
#line 1009
      if (i) {
        {
#line 1010
        stringbuffer_append_printf(buf, "(capacity %d.%dk). It is ", (int const   )op->stats.maxsp / 1000,
                                   i);
        }
      } else {
        {
#line 1012
        stringbuffer_append_printf(buf, "(capacity %dk). It is ", (int const   )op->stats.maxsp / 1000);
        }
      }
    } else {
      {
#line 1014
      stringbuffer_append_printf(buf, "(capacity %d). It is ", (int const   )op->stats.maxsp);
      }
    }
#line 1015
    i = (int )(((int const   )op->stats.sp * 10) / (int const   )op->stats.maxsp);
#line 1016
    if ((int const   )op->stats.sp == 0) {
      {
#line 1017
      stringbuffer_append_string(buf, "empty.");
      }
    } else
#line 1018
    if (i == 0) {
      {
#line 1019
      stringbuffer_append_string(buf, "almost empty.");
      }
    } else
#line 1020
    if (i < 3) {
      {
#line 1021
      stringbuffer_append_string(buf, "partially filled.");
      }
    } else
#line 1022
    if (i < 6) {
      {
#line 1023
      stringbuffer_append_string(buf, "half full.");
      }
    } else
#line 1024
    if (i < 9) {
      {
#line 1025
      stringbuffer_append_string(buf, "well charged.");
      }
    } else
#line 1026
    if ((int const   )op->stats.sp == (int const   )op->stats.maxsp) {
      {
#line 1027
      stringbuffer_append_string(buf, "fully charged.");
      }
    } else {
      {
#line 1029
      stringbuffer_append_string(buf, "almost full.");
      }
    }
  }
#line 1031
  goto switch_break;
  case_54: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 1036
  if (identified) {
#line 1036
    goto _L;
  } else
#line 1036
  if (op->flags[2] & (1U << 16)) {
    _L: /* CIL Label */ 
    {
#line 1037
    stringbuffer_append_printf(buf, "(food+%d)", op->stats.food);
    }
#line 1039
    if ((int const   )op->type == 72) {
#line 1039
      if (op->last_eat > 0) {
        {
#line 1039
        tmp___1 = atnr_is_dragon_enabled((int )op->last_eat);
        }
#line 1039
        if (tmp___1) {
          {
#line 1040
          stringbuffer_append_printf(buf, "(%s metabolism)", change_resist_msg[op->last_eat]);
          }
        }
      }
    }
#line 1043
    if (! (op->flags[2] & (1U << 10))) {
#line 1044
      if (op->stats.hp) {
        {
#line 1045
        stringbuffer_append_string(buf, "(heals)");
        }
      }
#line 1046
      if (op->stats.sp) {
        {
#line 1047
        stringbuffer_append_string(buf, "(spellpoint regen)");
        }
      }
    } else {
#line 1049
      if (op->stats.hp) {
        {
#line 1050
        stringbuffer_append_string(buf, "(damages)");
        }
      }
#line 1051
      if (op->stats.sp) {
        {
#line 1052
        stringbuffer_append_string(buf, "(spellpoint depletion)");
        }
      }
    }
  }
#line 1055
  goto switch_break;
  case_39: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_43: /* CIL Label */ 
#line 1060
  if (op->item_power) {
    {
#line 1061
    stringbuffer_append_printf(buf, "(item_power %+d)", (int const   )op->item_power);
    }
  }
#line 1063
  if (op->title) {
    {
#line 1064
    ring_desc(op, buf);
    }
  }
#line 1066
  return (buf);
  switch_default: /* CIL Label */ 
#line 1069
  return (buf);
  switch_break: /* CIL Label */ ;
  }
#line 1075
  if (identified) {
#line 1075
    goto _L___1;
  } else
#line 1075
  if (op->flags[2] & (1U << 16)) {
    _L___1: /* CIL Label */ 
#line 1078
    attr = 0;
    {
#line 1078
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1078
      if (! (attr < 7)) {
#line 1078
        goto while_break;
      }
      {
#line 1079
      tmp___2 = get_attr_value(& op->stats, attr);
#line 1079
      val = (int )tmp___2;
      }
#line 1079
      if (val != 0) {
        {
#line 1080
        stringbuffer_append_printf(buf, "(%s%+d)", short_stat_name[attr], val);
        }
      }
#line 1078
      attr ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1083
    if (op->glow_radius) {
      {
#line 1084
      stringbuffer_append_string(buf, "(glowing)");
      }
    }
    {
#line 1087
    if ((int const   )op->type == 72) {
#line 1087
      goto case_72___0;
    }
#line 1090
    goto switch_default___0;
    case_72___0: /* CIL Label */ 
#line 1088
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 1091
    if (op->stats.exp) {
      {
#line 1092
      stringbuffer_append_printf(buf, "(speed %+ld)", op->stats.exp);
      }
    }
#line 1094
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 1111
    if ((int const   )op->type == 87) {
#line 1111
      goto case_87___0;
    }
#line 1111
    if ((int const   )op->type == 114) {
#line 1111
      goto case_87___0;
    }
#line 1111
    if ((int const   )op->type == 104) {
#line 1111
      goto case_87___0;
    }
#line 1111
    if ((int const   )op->type == 16) {
#line 1111
      goto case_87___0;
    }
#line 1111
    if ((int const   )op->type == 39) {
#line 1111
      goto case_87___0;
    }
#line 1111
    if ((int const   )op->type == 70) {
#line 1111
      goto case_87___0;
    }
#line 1111
    if ((int const   )op->type == 43) {
#line 1111
      goto case_87___0;
    }
#line 1111
    if ((int const   )op->type == 15) {
#line 1111
      goto case_87___0;
    }
#line 1111
    if ((int const   )op->type == 100) {
#line 1111
      goto case_87___0;
    }
#line 1111
    if ((int const   )op->type == 99) {
#line 1111
      goto case_87___0;
    }
#line 1111
    if ((int const   )op->type == 33) {
#line 1111
      goto case_87___0;
    }
#line 1111
    if ((int const   )op->type == 34) {
#line 1111
      goto case_87___0;
    }
#line 1111
    if ((int const   )op->type == 113) {
#line 1111
      goto case_87___0;
    }
#line 1111
    if ((int const   )op->type == 13) {
#line 1111
      goto case_87___0;
    }
#line 1111
    if ((int const   )op->type == 14) {
#line 1111
      goto case_87___0;
    }
#line 1126
    goto switch_default___1;
    case_87___0: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_104___0: /* CIL Label */ 
    case_16___0: /* CIL Label */ 
    case_39___0: /* CIL Label */ 
    case_70___0: /* CIL Label */ 
    case_43___0: /* CIL Label */ 
    case_15___0: /* CIL Label */ 
    case_100___0: /* CIL Label */ 
    case_99___0: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
    case_34___0: /* CIL Label */ 
    case_113___0: /* CIL Label */ 
    case_13___0: /* CIL Label */ 
    case_14___0: /* CIL Label */ 
#line 1112
    if (op->stats.wc) {
      {
#line 1113
      stringbuffer_append_printf(buf, "(wc%+d)", (int const   )op->stats.wc);
      }
    }
#line 1115
    if (op->stats.dam) {
      {
#line 1116
      stringbuffer_append_printf(buf, "(dam%+d)", (int const   )op->stats.dam);
      }
    }
#line 1118
    if (op->stats.ac) {
      {
#line 1119
      stringbuffer_append_printf(buf, "(ac%+d)", (int const   )op->stats.ac);
      }
    }
#line 1121
    if ((int const   )op->type == 15) {
#line 1121
      goto _L___0;
    } else
#line 1121
    if ((int const   )op->type == 14) {
      _L___0: /* CIL Label */ 
#line 1121
      if ((int const   )op->level > 0) {
        {
#line 1122
        stringbuffer_append_printf(buf, "(improved %d/%d)", op->last_eat, (int const   )op->level);
        }
      }
    }
#line 1124
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 1127
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 1129
    if (op->flags[1] & (1U << 29)) {
      {
#line 1130
      stringbuffer_append_string(buf, "(xray-vision)");
      }
    }
#line 1131
    if (op->flags[2] & (1U << 29)) {
      {
#line 1132
      stringbuffer_append_string(buf, "(infravision)");
      }
    }
#line 1135
    if ((int const   )op->move_type & 2) {
      {
#line 1136
      stringbuffer_append_string(buf, "(levitate)");
      }
    }
#line 1138
    if ((int const   )op->move_type & 4) {
      {
#line 1139
      stringbuffer_append_string(buf, "(fly)");
      }
    }
#line 1141
    if ((int const   )op->move_type & 8) {
      {
#line 1142
      stringbuffer_append_string(buf, "(swim)");
      }
    }
#line 1146
    if (op->item_power) {
      {
#line 1147
      stringbuffer_append_printf(buf, "(item_power %+d)", (int const   )op->item_power);
      }
    }
  }
#line 1155
  if (identified) {
#line 1156
    more_info = 0;
    {
#line 1165
    if ((int const   )op->type == 54) {
#line 1165
      goto case_54___0;
    }
#line 1165
    if ((int const   )op->type == 72) {
#line 1165
      goto case_54___0;
    }
#line 1165
    if ((int const   )op->type == 6) {
#line 1165
      goto case_54___0;
    }
#line 1165
    if ((int const   )op->type == 109) {
#line 1165
      goto case_54___0;
    }
#line 1165
    if ((int const   )op->type == 13) {
#line 1165
      goto case_54___0;
    }
#line 1165
    if ((int const   )op->type == 14) {
#line 1165
      goto case_54___0;
    }
#line 1165
    if ((int const   )op->type == 3) {
#line 1165
      goto case_54___0;
    }
#line 1177
    if ((int const   )op->type == 87) {
#line 1177
      goto case_87___1;
    }
#line 1177
    if ((int const   )op->type == 104) {
#line 1177
      goto case_87___1;
    }
#line 1177
    if ((int const   )op->type == 113) {
#line 1177
      goto case_87___1;
    }
#line 1177
    if ((int const   )op->type == 100) {
#line 1177
      goto case_87___1;
    }
#line 1177
    if ((int const   )op->type == 99) {
#line 1177
      goto case_87___1;
    }
#line 1177
    if ((int const   )op->type == 33) {
#line 1177
      goto case_87___1;
    }
#line 1177
    if ((int const   )op->type == 34) {
#line 1177
      goto case_87___1;
    }
#line 1177
    if ((int const   )op->type == 16) {
#line 1177
      goto case_87___1;
    }
#line 1187
    if ((int const   )op->type == 15) {
#line 1187
      goto case_15___1;
    }
#line 1158
    goto switch_break___2;
    case_54___0: /* CIL Label */ 
    case_72___1: /* CIL Label */ 
    case_6___0: /* CIL Label */ 
    case_109___0: /* CIL Label */ 
    case_13___1: /* CIL Label */ 
    case_14___1: /* CIL Label */ 
    case_3___0: /* CIL Label */ 
#line 1166
    more_info = 0;
#line 1167
    goto switch_break___2;
    case_87___1: /* CIL Label */ 
    case_104___1: /* CIL Label */ 
    case_113___1: /* CIL Label */ 
    case_100___1: /* CIL Label */ 
    case_99___1: /* CIL Label */ 
    case_33___1: /* CIL Label */ 
    case_34___1: /* CIL Label */ 
    case_16___1: /* CIL Label */ 
#line 1178
    if (op->last_sp) {
      {
#line 1179
      stringbuffer_append_printf(buf, "(Max speed %1.2f)", (double )op->last_sp / 10.0);
      }
    }
#line 1181
    if (op->gen_sp_armour) {
      {
#line 1182
      stringbuffer_append_printf(buf, "(Spell regen penalty %d)", (int const   )op->gen_sp_armour);
      }
    }
#line 1184
    more_info = 1;
#line 1185
    goto switch_break___2;
    case_15___1: /* CIL Label */ 
#line 1191
    i = (int )((op->last_sp * 2 - (sint32 const   )op->magic) / 2);
#line 1192
    if (i < 0) {
#line 1193
      i = 0;
    }
    {
#line 1195
    stringbuffer_append_printf(buf, "(weapon speed %d)", i);
#line 1196
    more_info = 1;
    }
#line 1197
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 1199
    if (more_info) {
#line 1200
      if (op->stats.food) {
#line 1201
        if (op->stats.food != 0) {
          {
#line 1202
          stringbuffer_append_printf(buf, "(sustenance%+d)", op->stats.food);
          }
        }
      }
#line 1204
      if (op->stats.grace) {
        {
#line 1205
        stringbuffer_append_printf(buf, "(grace%+d)", (int const   )op->stats.grace);
        }
      }
#line 1207
      if (op->stats.sp) {
        {
#line 1208
        stringbuffer_append_printf(buf, "(magic%+d)", (int const   )op->stats.sp);
        }
      }
#line 1210
      if (op->stats.hp) {
        {
#line 1211
        stringbuffer_append_printf(buf, "(regeneration%+d)", (int const   )op->stats.hp);
        }
      }
    }
#line 1215
    if (op->stats.luck) {
      {
#line 1216
      stringbuffer_append_printf(buf, "(luck%+d)", (int const   )op->stats.luck);
      }
    }
#line 1218
    if (op->flags[2] & 1U) {
      {
#line 1219
      stringbuffer_append_string(buf, "(lifesaving)");
      }
    }
#line 1220
    if (op->flags[1] & (1U << 8)) {
      {
#line 1221
      stringbuffer_append_string(buf, "(reflect spells)");
      }
    }
#line 1222
    if (op->flags[1] & (1U << 7)) {
      {
#line 1223
      stringbuffer_append_string(buf, "(reflect missiles)");
      }
    }
#line 1224
    if (op->flags[2] & (1U << 7)) {
      {
#line 1225
      stringbuffer_append_string(buf, "(stealth)");
      }
    }
#line 1226
    if ((unsigned long )op->slaying != (unsigned long )((void *)0)) {
#line 1226
      if ((int const   )op->type != 6) {
        {
#line 1227
        stringbuffer_append_printf(buf, "(slay %s)", op->slaying);
        }
      }
    }
    {
#line 1229
    describe_attacktype("Attacks", (int )op->attacktype, buf);
    }
#line 1233
    if ((int const   )op->type != 72) {
      {
#line 1234
      describe_resistance(op, 0, buf);
      }
    } else
#line 1233
    if (owner) {
      {
#line 1233
      tmp___3 = is_dragon_pl(owner);
      }
#line 1233
      if (tmp___3) {
        {
#line 1234
        describe_resistance(op, 0, buf);
        }
      }
    }
    {
#line 1236
    describe_spellpath_attenuation("Attuned", (int )(op->path_attuned & ~ op->path_denied),
                                   buf);
#line 1237
    describe_spellpath_attenuation("Repelled", (int )(op->path_repelled & ~ op->path_denied),
                                   buf);
#line 1238
    describe_spellpath_attenuation("Denied", (int )op->path_denied, buf);
    }
  }
#line 1241
  return (buf);
}
}
#line 1256 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
int is_magical(object const   *op ) 
{ 
  int i ;
  sint8 tmp ;

  {
#line 1260
  if (op->flags[0] & 1U) {
#line 1261
    return (0);
  }
#line 1264
  if ((unsigned long )op->title != (unsigned long )((void *)0)) {
#line 1265
    return (1);
  }
#line 1270
  if ((int const   )op->type == 39) {
#line 1270
    goto _L;
  } else
#line 1270
  if ((int const   )op->type == 70) {
    _L: /* CIL Label */ 
#line 1270
    if (op->stats.ac) {
#line 1272
      return (1);
    } else
#line 1270
    if (op->stats.food) {
#line 1272
      return (1);
    } else
#line 1270
    if (op->stats.exp) {
#line 1272
      return (1);
    } else
#line 1270
    if (op->stats.dam) {
#line 1272
      return (1);
    } else
#line 1270
    if (op->stats.wc) {
#line 1272
      return (1);
    } else
#line 1270
    if (op->stats.sp) {
#line 1272
      return (1);
    } else
#line 1270
    if (op->stats.hp) {
#line 1272
      return (1);
    } else
#line 1270
    if (op->stats.luck) {
#line 1272
      return (1);
    }
  }
#line 1276
  if ((int const   )op->type == 99) {
#line 1276
    if (op->flags[2] & (1U << 7)) {
#line 1278
      return (1);
    } else
#line 1276
    if (op->move_type) {
#line 1278
      return (1);
    } else
#line 1276
    if (op->stats.exp) {
#line 1278
      return (1);
    }
  }
#line 1281
  if ((int const   )op->type == 39) {
#line 1281
    goto _L___0;
  } else
#line 1281
  if ((int const   )op->type == 33) {
    _L___0: /* CIL Label */ 
#line 1281
    if (op->flags[1] & (1U << 8)) {
#line 1283
      return (1);
    } else
#line 1281
    if (op->flags[1] & (1U << 7)) {
#line 1283
      return (1);
    }
  }
#line 1286
  if ((int const   )op->type == 34) {
#line 1286
    if (op->flags[1] & (1U << 29)) {
#line 1288
      return (1);
    }
  }
#line 1293
  if ((int const   )op->type == 5) {
#line 1294
    return (1);
  } else
#line 1293
  if ((int const   )op->type == 3) {
#line 1294
    return (1);
  } else
#line 1293
  if ((int const   )op->type == 109) {
#line 1293
    if (op->stats.food) {
#line 1294
      return (1);
    }
  }
#line 1300
  i = 1;
  {
#line 1300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1300
    if (! (i < 26)) {
#line 1300
      goto while_break;
    }
#line 1301
    if (op->resist[i]) {
#line 1302
      return (1);
    }
#line 1300
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1307
  if (op->resist[0]) {
#line 1307
    if ((int const   )op->type != 34) {
#line 1307
      if ((int const   )op->type != 33) {
#line 1307
        if ((int const   )op->type != 99) {
#line 1307
          if ((int const   )op->type != 100) {
#line 1307
            if ((int const   )op->type != 16) {
#line 1313
              return (1);
            }
          }
        }
      }
    }
  }
#line 1316
  if (op->magic) {
#line 1321
    return (1);
  } else
#line 1316
  if ((int const   )op->type == 156) {
#line 1321
    return (1);
  } else
#line 1316
  if ((int const   )op->type == 85) {
#line 1321
    return (1);
  } else
#line 1316
  if ((int const   )op->type == 111) {
#line 1321
    return (1);
  } else
#line 1316
  if ((int const   )op->type == 113) {
#line 1321
    return (1);
  }
#line 1324
  i = 0;
  {
#line 1324
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1324
    if (! (i < 7)) {
#line 1324
      goto while_break___0;
    }
    {
#line 1325
    tmp = get_attr_value(& op->stats, i);
    }
#line 1325
    if ((int )tmp != 0) {
#line 1326
      return (1);
    }
#line 1324
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1331
  return (0);
}
}
#line 1345 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
int need_identify(object const   *op ) 
{ 


  {
  {
#line 1379
  if ((int const   )op->type == 124) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 123) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 74) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 8) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 7) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 156) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 60) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 87) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 121) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 73) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 72) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 54) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 122) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 113) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 104) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 100) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 99) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 39) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 34) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 33) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 16) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 15) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 13) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 14) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 5) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 6) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 85) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 130) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 43) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 111) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 3) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 109) {
#line 1379
    goto case_124;
  }
#line 1379
  if ((int const   )op->type == 70) {
#line 1379
    goto case_124;
  }
#line 1346
  goto switch_break;
  case_124: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_156: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_130: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_70: /* CIL Label */ 
#line 1380
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 1382
  return (0);
}
}
#line 1389 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
void object_give_identified_properties(object *op ) 
{ 
  sstring key ;
  unsigned int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1392
  key = object_get_value((object const   *)op, (char const   */* const  */)"identified_face");
  }
#line 1393
  if ((unsigned long )key != (unsigned long )((void *)0)) {
    {
#line 1394
    tmp = find_face(key, (unsigned int )(op->face)->number);
#line 1394
    op->face = (New_Face const   *)(new_faces + tmp);
#line 1398
    op->flags[0] &= ~ (1U << 10);
#line 1399
    op->flags[0] &= ~ (1U << 9);
#line 1400
    op->anim_speed = (uint8 )0;
#line 1401
    op->animation_id = (uint16 )0;
#line 1402
    object_set_value(op, "identified_face", (char const   *)((void *)0), 0);
    }
  }
  {
#line 1405
  tmp___0 = object_get_value((object const   *)op, (char const   */* const  */)"identified_anim_random");
  }
#line 1405
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    {
#line 1406
    op->flags[0] |= 1U << 10;
#line 1407
    object_set_value(op, "identified_anim_random", (char const   *)((void *)0), 0);
    }
  }
  {
#line 1410
  key = object_get_value((object const   *)op, (char const   */* const  */)"identified_anim_speed");
  }
#line 1411
  if ((unsigned long )key != (unsigned long )((void *)0)) {
    {
#line 1412
    tmp___1 = atoi(key);
#line 1412
    op->anim_speed = (uint8 )tmp___1;
#line 1413
    op->last_anim = (uint8 )1;
#line 1414
    object_set_value(op, "identified_anim_speed", (char const   *)((void *)0), 0);
    }
  }
  {
#line 1417
  key = object_get_value((object const   *)op, (char const   */* const  */)"identified_animation");
  }
#line 1418
  if ((unsigned long )key != (unsigned long )((void *)0)) {
    {
#line 1419
    tmp___2 = atoi(key);
#line 1419
    op->animation_id = (uint16 )tmp___2;
    }
#line 1420
    if (! (op->flags[0] & (1U << 24))) {
#line 1421
      op->flags[0] |= 1U << 11;
    }
    {
#line 1422
    animate_object(op, (int )op->facing);
#line 1423
    object_set_value(op, "identified_animation", (char const   *)((void *)0), 0);
    }
  }
  {
#line 1426
  key = object_get_value((object const   *)op, (char const   */* const  */)"identified_name");
  }
#line 1427
  if ((unsigned long )key != (unsigned long )((void *)0)) {
#line 1428
    if (op->name) {
      {
#line 1428
      free_string(op->name);
      }
    }
    {
#line 1428
    op->name = add_string(key);
#line 1429
    object_set_value(op, "identified_name", (char const   *)((void *)0), 0);
    }
  }
  {
#line 1431
  key = object_get_value((object const   *)op, (char const   */* const  */)"identified_name_pl");
  }
#line 1432
  if ((unsigned long )key != (unsigned long )((void *)0)) {
#line 1433
    if (op->name_pl) {
      {
#line 1433
      free_string(op->name_pl);
      }
    }
    {
#line 1433
    op->name_pl = add_string(key);
#line 1434
    object_set_value(op, "identified_name_pl", (char const   *)((void *)0), 0);
    }
  }
#line 1436
  return;
}
}
#line 1451 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/item.c"
object *identify(object *op ) 
{ 
  object *pl ;
  object *op1 ;
  object *player___0 ;
  object *tmp ;

  {
  {
#line 1454
  op->flags[0] |= 1U << 29;
#line 1455
  op->flags[2] &= ~ (1U << 13);
#line 1456
  op->flags[2] &= ~ (1U << 27);
#line 1458
  object_give_identified_properties(op);
  }
#line 1463
  if (op->flags[2] & (1U << 10)) {
#line 1464
    op->flags[2] |= 1U << 14;
  } else
#line 1463
  if (op->flags[2] & (1U << 11)) {
#line 1464
    op->flags[2] |= 1U << 14;
  }
#line 1466
  if (op->flags[3] & (1U << 16)) {
#line 1467
    op->flags[3] |= 1U << 17;
  }
#line 1469
  if ((int )op->type == 5) {
#line 1470
    if (op->inv) {
#line 1470
      if (op->randomitems) {
#line 1471
        if (op->title) {
          {
#line 1472
          free_string(op->title);
          }
        }
        {
#line 1473
        op->title = add_refcount((op->inv)->name);
        }
      } else {
#line 1470
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1474
    if (op->arch) {
      {
#line 1475
      free_string(op->name);
#line 1476
      op->name = add_refcount((op->arch)->clone.name);
#line 1477
      free_string(op->name_pl);
#line 1478
      op->name_pl = add_refcount((op->arch)->clone.name_pl);
      }
    }
  }
#line 1482
  if (op->map) {
    {
#line 1486
    tmp = map_find_by_type(op->map, (int )op->x, (int )op->y, (uint8 )1);
#line 1486
    player___0 = tmp;
#line 1488
    object_update(op, 4);
#line 1489
    op1 = object_merge(op, ((op->map)->spaces + ((int )op->x + (int )(op->map)->width * (int )op->y))->top);
    }
#line 1490
    if (op1) {
#line 1490
      op = op1;
    }
#line 1492
    if (player___0) {
      {
#line 1493
      esrv_update_item(26, player___0, op);
      }
    }
  } else {
    {
#line 1496
    pl = object_get_player_container(op->env);
#line 1497
    op1 = object_merge(op, (op->env)->inv);
    }
#line 1498
    if (op1) {
#line 1498
      op = op1;
    }
#line 1500
    if (pl) {
      {
#line 1504
      esrv_update_item(255, pl, op);
      }
    }
  }
#line 1506
  return (op);
}
}
#line 359 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2,3), __leaf__)) strtok_r)(char * __restrict  __s ,
                                                                                                   char const   * __restrict  __delim ,
                                                                                                   char ** __restrict  __save_ptr ) ;
#line 59 "../include/libproto.h"
void free_dialog_information(object *op ) ;
#line 60
int get_dialog_message(object *op , char const   *text , struct_dialog_message **message ,
                       struct_dialog_reply **reply ) ;
#line 339
extern char const   *re_cmp(char const   *str , char const   *regexp ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/dialog.c"
void free_dialog_information(object *op ) 
{ 
  struct_dialog_message *current ;
  struct_dialog_message *next ;
  struct_dialog_reply *currep ;
  struct_dialog_reply *nextrep ;

  {
#line 43
  if (! (op->flags[0] & (1U << 12))) {
#line 44
    return;
  }
#line 46
  op->flags[0] &= ~ (1U << 12);
#line 47
  if (! op->dialog_information) {
#line 48
    return;
  }
#line 50
  current = (op->dialog_information)->all_messages;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! current) {
#line 51
      goto while_break;
    }
    {
#line 52
    next = current->next;
#line 53
    free((void *)current->match);
#line 54
    free((void *)current->message);
#line 55
    currep = current->replies;
    }
    {
#line 56
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 56
      if (! currep) {
#line 56
        goto while_break___0;
      }
      {
#line 57
      nextrep = currep->next;
#line 58
      free((void *)currep->reply);
#line 59
      free((void *)currep->message);
#line 60
      currep = nextrep;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 62
    free((void *)current);
#line 63
    current = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  currep = (op->dialog_information)->all_replies;
  {
#line 67
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 67
    if (! currep) {
#line 67
      goto while_break___1;
    }
    {
#line 68
    nextrep = currep->next;
#line 69
    free((void *)currep->reply);
#line 70
    free((void *)currep->message);
#line 71
    free((void *)currep);
#line 72
    currep = nextrep;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 75
  free((void *)op->dialog_information);
#line 76
  op->dialog_information = (struct struct_dialog_information *)((void *)0);
  }
#line 77
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/dialog.c"
static int matches(char const   *exp , char const   *text ) 
{ 
  char *pipe___0 ;
  char *save ;
  char *msg ;
  int match ;
  char const   *tmp ;

  {
#line 88
  match = 0;
#line 90
  if ((int const   )*(exp + 0) == 42) {
#line 91
    return (1);
  }
  {
#line 93
  msg = strdup(exp);
#line 95
  pipe___0 = strtok_r((char */* __restrict  */)msg, (char const   */* __restrict  */)"|",
                      (char **/* __restrict  */)(& save));
  }
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! pipe___0) {
#line 96
      goto while_break;
    }
    {
#line 97
    tmp = re_cmp(text, (char const   *)pipe___0);
    }
#line 97
    if (tmp) {
#line 98
      match = 1;
#line 99
      goto while_break;
    }
    {
#line 101
    pipe___0 = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"|",
                        (char **/* __restrict  */)(& save));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 104
  free((void *)msg);
  }
#line 105
  return (match);
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/dialog.c"
static void parse_dialog_information(object *op ) 
{ 
  struct_dialog_message *message ;
  struct_dialog_message *last ;
  struct_dialog_reply *reply ;
  char *current ;
  char *save ;
  char *msg ;
  char *cp ;
  int len ;
  char *tmp ;
  size_t tmplen ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int wasnull ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 115
  message = (struct_dialog_message *)((void *)0);
#line 115
  last = (struct_dialog_message *)((void *)0);
#line 116
  reply = (struct_dialog_reply *)((void *)0);
#line 120
  tmp = (char *)((void *)0);
#line 121
  tmplen = (size_t )0;
#line 123
  if (op->flags[0] & (1U << 12)) {
#line 124
    return;
  }
  {
#line 125
  op->flags[0] |= 1U << 12;
#line 127
  tmp___0 = calloc((size_t )1, sizeof(struct_dialog_information ));
#line 127
  op->dialog_information = (struct_dialog_information *)tmp___0;
  }
#line 129
  if (! op->msg) {
#line 130
    return;
  }
  {
#line 132
  msg = strdup(op->msg);
#line 133
  current = strtok_r((char */* __restrict  */)msg, (char const   */* __restrict  */)"\n",
                     (char **/* __restrict  */)(& save));
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! current) {
#line 135
      goto while_break;
    }
    {
#line 136
    tmp___10 = strncmp((char const   *)current, "@match ", (size_t )7);
    }
#line 136
    if (tmp___10 == 0) {
#line 137
      if (message) {
#line 138
        message->message = tmp;
#line 139
        tmp = (char *)((void *)0);
#line 140
        tmplen = (size_t )0;
      }
      {
#line 143
      tmp___1 = calloc((size_t )1, sizeof(struct_dialog_message ));
#line 143
      message = (struct_dialog_message *)tmp___1;
      }
#line 144
      if (last) {
#line 145
        last->next = message;
      } else {
#line 147
        (op->dialog_information)->all_messages = message;
      }
      {
#line 148
      last = message;
#line 150
      message->match = strdup((char const   *)(current + 7));
      }
    } else {
      {
#line 151
      tmp___8 = strncmp((char const   *)current, "@reply ", (size_t )7);
      }
#line 151
      if (tmp___8 == 0) {
#line 151
        len = 7;
#line 151
        if (len) {
#line 151
          goto _L;
        } else {
#line 151
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        {
#line 151
        tmp___9 = strncmp((char const   *)current, "@question ", (size_t )10);
        }
#line 151
        if (tmp___9 == 0) {
#line 151
          len = 10;
#line 151
          if (len) {
            _L: /* CIL Label */ 
#line 152
            if (message) {
              {
#line 153
              tmp___2 = calloc((size_t )1, sizeof(struct_dialog_reply ));
#line 153
              reply = (struct_dialog_reply *)tmp___2;
              }
#line 154
              if (len == 7) {
#line 154
                reply->type = (reply_type )1;
              } else {
#line 154
                reply->type = (reply_type )2;
              }
              {
#line 155
              cp = strchr((char const   *)(current + len), ' ');
              }
#line 156
              if (cp) {
                {
#line 157
                *cp = (char )'\000';
#line 158
                reply->reply = strdup((char const   *)(current + len));
#line 159
                reply->message = strdup((char const   *)(cp + 1));
                }
              } else {
                {
#line 161
                reply->reply = strdup((char const   *)(current + len));
#line 162
                reply->message = strdup((char const   *)reply->reply);
#line 163
                LOG((LogLevel )2, "Warning: @reply/@question without message for %s!\n",
                    op->name);
                }
              }
              {
#line 165
              reply->next = message->replies;
#line 166
              message->replies = reply;
#line 168
              tmp___3 = calloc((size_t )1, sizeof(struct_dialog_reply ));
#line 168
              reply = (struct_dialog_reply *)tmp___3;
#line 169
              reply->reply = strdup((char const   *)(message->replies)->reply);
#line 170
              reply->message = strdup((char const   *)(message->replies)->message);
#line 171
              reply->type = (message->replies)->type;
#line 172
              reply->next = (op->dialog_information)->all_replies;
#line 173
              (op->dialog_information)->all_replies = reply;
              }
            } else {
              {
#line 175
              LOG((LogLevel )2, "Warning: @reply not in @match block for %s!\n", op->name);
              }
            }
          } else {
#line 151
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 176
        if (message) {
          {
#line 178
          wasnull = 0;
#line 179
          tmp___4 = strlen((char const   *)current);
#line 179
          tmplen += tmp___4 + 2UL;
          }
#line 180
          if (! tmp) {
#line 181
            wasnull = 1;
          }
          {
#line 182
          tmp___5 = realloc((void *)tmp, tmplen * sizeof(char ));
#line 182
          tmp = (char *)tmp___5;
          }
#line 183
          if (! tmp) {
            {
#line 184
            fatal(0);
            }
          }
#line 185
          if (wasnull) {
#line 186
            *(tmp + 0) = (char)0;
          }
          {
#line 187
          tmp___6 = strlen((char const   *)tmp);
#line 187
          strncat((char */* __restrict  */)tmp, (char const   */* __restrict  */)current,
                  (tmplen - tmp___6) - 1UL);
#line 188
          tmp___7 = strlen((char const   *)tmp);
#line 188
          strncat((char */* __restrict  */)tmp, (char const   */* __restrict  */)"\n",
                  (tmplen - tmp___7) - 1UL);
          }
        }
      }
    }
    {
#line 190
    current = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\n",
                       (char **/* __restrict  */)(& save));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (message) {
#line 194
    if (! tmp) {
      {
#line 195
      message->message = strdup("");
      }
    } else {
#line 197
      message->message = tmp;
    }
#line 198
    tmp = (char *)((void *)0);
#line 199
    tmplen = (size_t )0;
  }
  {
#line 202
  free((void *)msg);
  }
#line 203
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/common/dialog.c"
int get_dialog_message(object *op , char const   *text , struct_dialog_message **message ,
                       struct_dialog_reply **reply ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 215
  if (! (op->flags[0] & (1U << 12))) {
    {
#line 216
    parse_dialog_information(op);
    }
  }
#line 218
  *message = (op->dialog_information)->all_messages;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! *message) {
#line 218
      goto while_break;
    }
    {
#line 219
    tmp = matches((char const   *)(*message)->match, text);
    }
#line 219
    if (tmp) {
#line 220
      goto while_break;
    }
#line 218
    *message = (*message)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  if (! *message) {
#line 224
    return (0);
  }
#line 226
  *reply = (op->dialog_information)->all_replies;
  {
#line 226
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 226
    if (! *reply) {
#line 226
      goto while_break___0;
    }
    {
#line 227
    tmp___0 = strcmp((char const   *)(*reply)->reply, text);
    }
#line 227
    if (tmp___0 == 0) {
#line 228
      goto while_break___0;
    }
#line 226
    *reply = (*reply)->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 231
  return (1);
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/devel/devel.c"
cf_parameter const   cf_parameter_list[5]  = {      {"CONFDIR", "/usr/games/crossfire/etc/crossfire"}, 
        {"DATADIR", "/usr/games/crossfire/share/crossfire"}, 
        {"LIBDIR", "/usr/games/crossfire/lib/crossfire"}, 
        {"LOCALDIR", "/usr/games/crossfire/var/crossfire"}, 
        {"PLUGIN_SUFFIX", ".so"}};
#line 48 "/home/june/repo/benchmarks/collector/temp/crossfire-1.70.0/devel/devel.c"
int const   cf_parameter_list_size  =    (int const   )(sizeof(cf_parameter_list) / sizeof(cf_parameter ));
