/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 499 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
typedef double bnumber;
#line 586 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct bstr {
   unsigned int length ;
   char *sbuffer ;
   int rab ;
};
#line 586 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
typedef struct bstr bstring;
#line 599 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct bwb_variable {
   char name[41] ;
   int type ;
   bnumber *memnum ;
   bstring *memstr ;
   size_t array_units ;
   int *array_sizes ;
   int *array_pos ;
   int dimensions ;
   struct bwb_variable *next ;
   int common ;
   int preset ;
};
#line 640 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct bwb_function {
   char name[41] ;
   int type ;
   int arguments ;
   struct bwb_variable *(*vector)(int argc , struct bwb_variable *argv , int unique_id ) ;
   struct bwb_function *next ;
   int id ;
};
#line 684 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct exp_ese {
   int operation ;
   char type ;
   bstring sval ;
   bnumber nval ;
   char string[5001] ;
   struct bwb_variable *xvar ;
   struct bwb_function *function ;
   int array_pos[64] ;
   int pos_adv ;
   int rec_pos ;
};
#line 822 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct bwb_op {
   char symbol[8] ;
   int operation ;
   int precedence ;
};
#line 622 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct bwb_line {
   struct bwb_line *next ;
   int number ;
   char xnum ;
   char *buffer ;
   int position ;
   int lnpos ;
   int lnum ;
   int cmdpos ;
   int cmdnum ;
   int startpos ;
   int marked ;
};
#line 656 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct bwb_command {
   char name[65] ;
   struct bwb_line *(*vector)(struct bwb_line * ) ;
};
#line 668 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct dev_element {
   int mode ;
   int width ;
   int col ;
   int reclen ;
   int next_record ;
   int loc ;
   int lof ;
   char filename[41] ;
   FILE *cfp ;
   char *buffer ;
};
#line 701 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct fslte {
   char *name ;
   struct bwb_line *line ;
   int code ;
   int startpos ;
   struct fslte *next ;
   struct bwb_variable *local_variable ;
};
#line 713 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct exse {
   struct bwb_line *line ;
   int code ;
   int position ;
   struct bwb_variable *local_variable ;
   struct bwb_variable *calling_variable[6] ;
   int n_cvs ;
   int for_step ;
   int for_target ;
   struct bwb_line *while_line ;
   struct bwb_line *wend_line ;
   struct exp_ese expression ;
   struct bwb_line *for_line ;
   int for_position ;
};
#line 732 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct xtxtsl {
   int position ;
   struct bwb_line l ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_12 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_12 __sigset_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 48 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 383 "/home/june/collector/temp/bwbasic-2.20pl2/bwx_tty.c"
struct exception;
#line 50 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
union un_integer {
   int the_integer ;
   unsigned char the_chars[sizeof(int )] ;
};
#line 56 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
union un_single {
   float the_float ;
   unsigned char the_chars[sizeof(float )] ;
};
#line 62 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
union un_double {
   double the_double ;
   unsigned char the_chars[sizeof(double )] ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long __tm_gmtoff ;
   char const   *__tm_zone ;
};
#line 43 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
struct prn_fmt {
   int type ;
   int exponential ;
   int right_justified ;
   int width ;
   int precision ;
   int commas ;
   int sign ;
   int money ;
   int fill ;
   int minus ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 10 "/home/june/collector/temp/bwbasic-2.20pl2/renum.c"
int instr(char *astr , char *bstr ) ;
#line 11
char *midstr1(char *astr , int start ) ;
#line 12
char *midstr2(char *astr , int start , int len ) ;
#line 13
void binary_search(void) ;
#line 15 "/home/june/collector/temp/bwbasic-2.20pl2/renum.c"
int f2  ;
#line 15 "/home/june/collector/temp/bwbasic-2.20pl2/renum.c"
int l2  ;
#line 15 "/home/june/collector/temp/bwbasic-2.20pl2/renum.c"
int n  ;
#line 15 "/home/june/collector/temp/bwbasic-2.20pl2/renum.c"
int x  ;
#line 16 "/home/june/collector/temp/bwbasic-2.20pl2/renum.c"
int sidx[1500][2]  ;
#line 17 "/home/june/collector/temp/bwbasic-2.20pl2/renum.c"
char rstr[255]  ;
#line 32
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 37
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 46
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 68
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 271
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 297
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 474
extern int system(char const   *__command ) ;
#line 19 "/home/june/collector/temp/bwbasic-2.20pl2/renum.c"
int main(int argc , char **argv ) 
{ 
  int f ;
  int d ;
  int s___0 ;
  int p___0 ;
  int s1 ;
  int t___0 ;
  int l ;
  int g ;
  int c ;
  int f1 ;
  int c1 ;
  int i ;
  int f8 ;
  int r ;
  int l1 ;
  int l3 ;
  int v1 ;
  int f6 ;
  int l6 ;
  int b___4 ;
  int f9 ;
  int x9 ;
  int b1 ;
  int p8 ;
  int p9 ;
  int a ;
  int d9 ;
  char pstr[255] ;
  char f9str[255] ;
  char s9str[255] ;
  char tempstr___1[255] ;
  FILE *fdin ;
  FILE *fdout ;
  int skip ;
  int bp ;
  int temp ;
  int getout ;
  int disp_msg ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  char *tmp___41 ;

  {
#line 30
  f = 1;
#line 32
  if (argc > 1) {
    {
#line 32
    strcpy(pstr, *(argv + 1));
    }
  } else {
    {
#line 35
    printf((char const   */* __restrict  */)"Program in file? ");
#line 36
    fgets((char */* __restrict  */)(pstr), (int )sizeof(pstr), (FILE */* __restrict  */)stdin);
#line 37
    p___0 = (int )strlen(pstr);
    }
#line 38
    if ((int )pstr[p___0 - 1] == 10) {
#line 38
      p___0 --;
#line 38
      pstr[p___0] = (char )'\000';
    }
  }
  {
#line 40
  tmp = (int )strlen(pstr);
  }
#line 40
  if (tmp == 0) {
    {
#line 40
    strcpy(pstr, "0.doc");
    }
  }
  {
#line 42
  fdin = fopen((char const   */* __restrict  */)(pstr), (char const   */* __restrict  */)"r");
  }
#line 43
  if ((unsigned long )fdin == (unsigned long )((void *)0)) {
    {
#line 45
    printf((char const   */* __restrict  */)"Unable to open input file\n");
#line 46
    exit(1);
    }
  }
  {
#line 48
  strcpy(f9str, pstr);
#line 50
  strcpy(pstr, "editfl");
#line 51
  fdout = fopen((char const   */* __restrict  */)(pstr), (char const   */* __restrict  */)"w");
  }
#line 52
  if ((unsigned long )fdout == (unsigned long )((void *)0)) {
    {
#line 54
    printf((char const   */* __restrict  */)"Unable to open editfl output file\n");
#line 55
    exit(1);
    }
  }
  {
#line 59
  s___0 = 0;
#line 59
  l2 = 0;
#line 59
  d = 0;
#line 60
  f2 = 10000;
#line 61
  printf((char const   */* __restrict  */)"PLEASE WAIT A FEW SECONDS!\n");
  }
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 62
    tmp___2 = fgets((char */* __restrict  */)(pstr), 255, (FILE */* __restrict  */)fdin);
    }
#line 62
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 62
      goto while_break;
    }
    {
#line 64
    tmp___0 = (int )strlen(pstr);
#line 64
    pstr[tmp___0 - 1] = (char )'\000';
#line 65
    p___0 = instr(pstr, " ");
    }
#line 66
    if (p___0 != 0) {
#line 66
      if (p___0 <= 5) {
        {
#line 68
        tmp___1 = midstr2(pstr, 1, p___0);
#line 68
        n = atoi(tmp___1);
        }
#line 69
        if (n != 0) {
#line 71
          s___0 ++;
#line 72
          sidx[s___0][0] = n;
#line 73
          s1 = s___0;
          {
#line 74
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 74
            if (! (s1 >= 2)) {
#line 74
              goto while_break___0;
            }
#line 76
            s1 --;
#line 77
            if (sidx[s1][0] < sidx[s1 + 1][0]) {
#line 77
              goto while_break___0;
            }
#line 78
            if (sidx[s1][0] == sidx[s1 + 1][0]) {
              {
#line 80
              printf((char const   */* __restrict  */)"ERROR !!! MORE THAN ONE STATEMENT FOR A ");
#line 81
              printf((char const   */* __restrict  */)"STATEMENT NUMBER\n");
#line 82
              exit(1);
              }
            }
#line 85
            t___0 = sidx[s1][0];
#line 86
            sidx[s1][0] = sidx[s1 + 1][0];
#line 87
            sidx[s1 + 1][0] = t___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  fclose(fdin);
  }
#line 94
  if (s___0 == 0) {
    {
#line 96
    printf((char const   */* __restrict  */)"NO PROGRAM IS IN THE FILE!\n");
#line 97
    exit(1);
    }
  }
#line 100
  l = 1;
  {
#line 100
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 100
    if (! (l <= s___0)) {
#line 100
      goto while_break___1;
    }
#line 101
    sidx[l][1] = sidx[l][0];
#line 100
    l ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 102
  g = 1;
#line 103
  disp_msg = 1;
  {
#line 110
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 112
    if (disp_msg == 1) {
      {
#line 114
      printf((char const   */* __restrict  */)"RENUMBER (-starting number (,interval (,first statement ");
#line 115
      printf((char const   */* __restrict  */)"(,last))))\n");
#line 116
      disp_msg = 0;
      }
    }
    {
#line 119
    skip = 0;
#line 120
    bp = 0;
#line 121
    printf((char const   */* __restrict  */)"RENUMBER-");
#line 122
    fgets((char */* __restrict  */)(pstr), (int )sizeof(pstr), (FILE */* __restrict  */)stdin);
#line 123
    p___0 = (int )strlen(pstr);
    }
#line 124
    if ((int )pstr[p___0 - 1] == 10) {
#line 124
      p___0 --;
#line 124
      pstr[p___0] = (char )'\000';
    }
#line 126
    if (g == 0) {
      {
#line 128
      tmp___3 = (int )strlen(pstr);
      }
#line 128
      if (tmp___3 == 0) {
#line 128
        goto while_break___2;
      }
#line 129
      if (p___0 == 0) {
#line 129
        skip = 1;
      } else {
        {
#line 132
        tmp___4 = midstr2(pstr, 1, 1);
#line 132
        t___0 = atoi(tmp___4);
        }
#line 133
        if (t___0 == 0) {
#line 133
          goto while_break___2;
        }
      }
    }
    {
#line 137
    tmp___5 = (int )strlen(pstr);
    }
#line 137
    if (tmp___5 == 0) {
#line 137
      skip = 1;
    }
#line 139
    if (skip == 0) {
      {
#line 141
      c = instr(pstr, ",");
#line 142
      temp = 0;
      }
#line 142
      if (c != 0) {
#line 142
        temp = -1;
      }
      {
#line 143
      tmp___6 = midstr2(pstr, 1, p___0 + temp * ((p___0 - c) + 1));
#line 143
      f1 = atoi(tmp___6);
      }
#line 144
      if (f1 == 0) {
#line 144
        bp = 1;
      }
#line 145
      if (c == 0) {
#line 145
        skip = 2;
      }
    }
#line 148
    if (skip == 0) {
#line 148
      if (bp == 0) {
        {
#line 150
        tmp___7 = midstr1(pstr, c + 1);
#line 150
        tmp___8 = instr(tmp___7, ",");
#line 150
        c1 = tmp___8 + c;
#line 151
        temp = 0;
        }
#line 151
        if (c1 != c) {
#line 151
          temp = -1;
        }
        {
#line 152
        tmp___9 = midstr2(pstr, c + 1, (p___0 + temp * ((p___0 - c1) + 1)) - c);
#line 152
        i = atoi(tmp___9);
        }
#line 153
        if (i == 0) {
#line 153
          bp = 1;
        }
#line 154
        if (c1 == c) {
#line 154
          skip = 3;
        }
      }
    }
#line 157
    if (skip == 0) {
#line 157
      if (bp == 0) {
        {
#line 159
        tmp___10 = midstr1(pstr, c1 + 1);
#line 159
        tmp___11 = instr(tmp___10, ",");
#line 159
        c = tmp___11 + c1;
#line 160
        temp = 0;
        }
#line 160
        if (c != c1) {
#line 160
          temp = -1;
        }
        {
#line 161
        tmp___12 = midstr2(pstr, c1 + 1, (p___0 + temp * ((p___0 - c) + 1)) - c1);
#line 161
        f8 = atoi(tmp___12);
        }
#line 162
        if (f8 == 0) {
#line 162
          bp = 1;
        }
#line 163
        if (c == c1) {
#line 163
          skip = 4;
        }
      }
    }
#line 166
    if (skip == 0) {
#line 166
      if (bp == 0) {
        {
#line 168
        tmp___13 = midstr1(pstr, c + 1);
#line 168
        l = atoi(tmp___13);
        }
#line 169
        if (l == 0) {
#line 169
          bp = 1;
        }
      }
    }
#line 172
    if (bp == 0) {
      {
#line 174
      if (skip == 1) {
#line 174
        goto case_1;
      }
#line 181
      if (skip == 2) {
#line 181
        goto case_2;
      }
#line 187
      if (skip == 3) {
#line 187
        goto case_3;
      }
#line 192
      if (skip == 4) {
#line 192
        goto case_4;
      }
#line 172
      goto switch_break;
      case_1: /* CIL Label */ 
#line 175
      f1 = 10;
#line 176
      i = 10;
#line 177
      f8 = 1;
#line 178
      l = 99999;
#line 179
      goto switch_break;
      case_2: /* CIL Label */ 
#line 182
      i = 10;
#line 183
      f8 = 1;
#line 184
      l = 99999;
#line 185
      goto switch_break;
      case_3: /* CIL Label */ 
#line 188
      f8 = 1;
#line 189
      l = 99999;
#line 190
      goto switch_break;
      case_4: /* CIL Label */ 
#line 193
      l = 99999;
#line 194
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 197
    if (f1 < 1) {
#line 197
      bp = 1;
    } else
#line 197
    if (i == 0) {
#line 197
      bp = 1;
    } else
#line 197
    if (f8 < 1) {
#line 197
      bp = 1;
    } else
#line 197
    if (l < 1) {
#line 197
      bp = 1;
    }
#line 199
    if (f1 > 99999) {
#line 200
      bp = 1;
    } else
#line 199
    if (i > 99999) {
#line 200
      bp = 1;
    } else
#line 199
    if (f8 > 99999) {
#line 200
      bp = 1;
    } else
#line 199
    if (l > 99999) {
#line 200
      bp = 1;
    } else
#line 199
    if (f8 > l) {
#line 200
      bp = 1;
    }
#line 202
    c = 0;
#line 203
    r = 1;
    {
#line 203
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 203
      if (! (r <= s___0)) {
#line 203
        goto while_break___3;
      }
#line 204
      if (sidx[r][0] >= f8) {
#line 204
        if (sidx[r][0] <= l) {
#line 204
          c ++;
        }
      }
#line 203
      r ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 205
    if (c == 0) {
      {
#line 207
      printf((char const   */* __restrict  */)"There is nothing to renumber !!\n");
#line 208
      disp_msg = 1;
      }
    }
#line 215
    l1 = f1 + (c - 1) * i;
#line 216
    if (l1 < 1) {
#line 216
      bp = 1;
    } else
#line 216
    if (l1 > 99999) {
#line 216
      bp = 1;
    }
#line 218
    x = 0;
#line 218
    c = 0;
#line 219
    if (bp == 0) {
#line 219
      if (disp_msg == 0) {
#line 219
        r = 1;
        {
#line 219
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 219
          if (! (r <= s___0)) {
#line 219
            goto while_break___4;
          }
#line 221
          if (sidx[r][0] < f8) {
#line 221
            goto _L;
          } else
#line 221
          if (sidx[r][0] > l) {
            _L: /* CIL Label */ 
#line 222
            if (sidx[r][1] >= f1) {
#line 222
              if (sidx[r][1] <= l1) {
                {
#line 224
                printf((char const   */* __restrict  */)"SEQUENCE NUMBER OVERLAP\n");
#line 225
                exit(1);
                }
              }
            }
          } else {
#line 230
            if (sidx[r][0] != f1 + c * i) {
#line 232
              if (x == 0) {
#line 234
                if (r < f2) {
#line 234
                  f2 = r;
                }
#line 235
                x = 1;
              }
#line 238
              if (r > l2) {
#line 238
                l2 = r;
              }
            }
#line 241
            sidx[r][1] = f1 + c * i;
#line 242
            c ++;
#line 243
            l3 = r;
          }
#line 219
          r ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
#line 247
    if (bp == 0) {
#line 247
      if (disp_msg == 0) {
#line 247
        g = 0;
      }
    }
#line 249
    if (bp == 1) {
      {
#line 249
      printf((char const   */* __restrict  */)"BAD PARAMETER\n");
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 256
  if (l2 == 0) {
    {
#line 258
    printf((char const   */* __restrict  */)"NOTHING RENUMBERED!\n");
#line 259
    exit(1);
    }
  }
  {
#line 262
  printf((char const   */* __restrict  */)"RENUMBERING\n");
#line 266
  printf((char const   */* __restrict  */)"VERIFY? ");
#line 267
  fgets((char */* __restrict  */)(pstr), (int )sizeof(pstr), (FILE */* __restrict  */)stdin);
#line 268
  p___0 = (int )strlen(pstr);
  }
#line 269
  if ((int )pstr[p___0 - 1] == 10) {
#line 269
    p___0 --;
#line 269
    pstr[p___0] = (char )'\000';
  }
  {
#line 270
  v1 = 0;
#line 271
  tmp___14 = midstr2(pstr, 1, 1);
#line 271
  tmp___15 = strcmp(tmp___14, "N");
  }
#line 271
  if (tmp___15 == 0) {
#line 271
    v1 = 1;
  }
  {
#line 273
  fdin = fopen((char const   */* __restrict  */)(f9str), (char const   */* __restrict  */)"r");
  }
#line 274
  if ((unsigned long )fdin == (unsigned long )((void *)0)) {
    {
#line 276
    printf((char const   */* __restrict  */)"Unable to open input file\n");
#line 277
    exit(1);
    }
  }
#line 280
  f6 = sidx[f2][0];
#line 281
  l6 = sidx[l2][0];
  {
#line 283
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 283
    tmp___41 = fgets((char */* __restrict  */)(pstr), 255, (FILE */* __restrict  */)fdin);
    }
#line 283
    if (! ((unsigned long )tmp___41 != (unsigned long )((void *)0))) {
#line 283
      goto while_break___5;
    }
    {
#line 285
    tmp___16 = (int )strlen(pstr);
#line 285
    pstr[tmp___16 - 1] = (char )'\000';
#line 286
    b___4 = instr(pstr, " ");
    }
#line 287
    if (b___4 != 0) {
      {
#line 289
      tmp___17 = midstr2(pstr, 1, b___4);
#line 289
      n = atoi(tmp___17);
      }
#line 290
      if (n != 0) {
#line 292
        if (n >= f6) {
#line 292
          if (n <= l6) {
            {
#line 294
            binary_search();
            }
#line 295
            if (x == 0) {
              {
#line 297
              tmp___18 = midstr1(pstr, b___4);
#line 297
              strcat(rstr, tmp___18);
#line 298
              strcpy(pstr, rstr);
#line 299
              b___4 = instr(pstr, " ");
              }
            }
          }
        }
#line 302
        b___4 ++;
        {
#line 314
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 316
          tmp___19 = midstr2(pstr, b___4, 3);
#line 316
          tmp___20 = strcmp(tmp___19, "REM");
          }
#line 316
          if (tmp___20 == 0) {
#line 317
            goto while_break___6;
          } else {
            {
#line 316
            tmp___21 = midstr2(pstr, b___4, 1);
#line 316
            tmp___22 = strcmp(tmp___21, "\'");
            }
#line 316
            if (tmp___22 == 0) {
#line 317
              goto while_break___6;
            }
          }
#line 319
          f9 = 0;
#line 320
          skip = 0;
#line 321
          x9 = b___4;
          {
#line 321
          while (1) {
            while_continue___7: /* CIL Label */ ;
            {
#line 321
            tmp___26 = (int )strlen(pstr);
            }
#line 321
            if (! (x9 <= tmp___26)) {
#line 321
              goto while_break___7;
            }
            {
#line 323
            tmp___25 = midstr2(pstr, x9, 1);
            }
#line 323
            if ((int )*tmp___25 == 34) {
#line 325
              if (f9 == 0) {
#line 326
                f9 = 1;
              } else {
#line 328
                f9 = 0;
              }
            } else {
              {
#line 330
              tmp___23 = midstr2(pstr, x9, 1);
#line 330
              tmp___24 = strcmp(tmp___23, ":");
              }
#line 330
              if (tmp___24 == 0) {
#line 330
                if (f9 == 0) {
#line 333
                  b1 = x9 - 1;
#line 334
                  skip = 1;
#line 335
                  goto while_break___7;
                }
              }
            }
#line 321
            x9 ++;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 338
          if (skip == 0) {
            {
#line 338
            b1 = (int )strlen(pstr);
            }
          }
          {
#line 340
          tmp___27 = midstr2(pstr, b___4, 3);
#line 340
          t___0 = instr("GOSGOTIF ON RESRET", tmp___27);
#line 342
          temp = (t___0 + 5) / 3;
          }
#line 343
          if (temp != 1) {
#line 345
            if (temp == 2) {
              {
#line 353
              getout = 0;
#line 354
              p8 = b___4;
#line 355
              strcpy(s9str, " ");
              }
            } else
#line 345
            if (temp == 3) {
              {
#line 353
              getout = 0;
#line 354
              p8 = b___4;
#line 355
              strcpy(s9str, " ");
              }
            } else
#line 345
            if (temp == 4) {
              {
#line 353
              getout = 0;
#line 354
              p8 = b___4;
#line 355
              strcpy(s9str, " ");
              }
            } else
#line 345
            if (temp == 6) {
              {
#line 353
              getout = 0;
#line 354
              p8 = b___4;
#line 355
              strcpy(s9str, " ");
              }
            } else
#line 345
            if (temp == 7) {
              {
#line 353
              getout = 0;
#line 354
              p8 = b___4;
#line 355
              strcpy(s9str, " ");
              }
            } else
#line 357
            if (temp == 5) {
#line 364
              getout = 1;
#line 365
              x9 = b1;
              {
#line 365
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 365
                if (! (x9 >= b___4)) {
#line 365
                  goto while_break___8;
                }
                {
#line 367
                tmp___28 = midstr2(pstr, x9, 1);
#line 367
                tmp___29 = strcmp(tmp___28, " ");
                }
#line 367
                if (tmp___29 == 0) {
#line 369
                  p8 = x9 + 1;
#line 370
                  getout = 0;
#line 371
                  goto while_break___8;
                }
#line 365
                x9 --;
              }
              while_break___8: /* CIL Label */ ;
              }
#line 375
              if (getout == 0) {
                {
#line 375
                strcpy(s9str, ",");
                }
              }
            }
#line 379
            if (getout == 0) {
              {
#line 379
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 381
                f9 = 0;
#line 382
                skip = 0;
#line 383
                x9 = p8;
                {
#line 383
                while (1) {
                  while_continue___10: /* CIL Label */ ;
#line 383
                  if (! (x9 <= b1)) {
#line 383
                    goto while_break___10;
                  }
                  {
#line 385
                  tmp___32 = midstr2(pstr, x9, 1);
                  }
#line 385
                  if ((int )*tmp___32 == 34) {
#line 387
                    if (f9 == 0) {
#line 388
                      f9 = 1;
                    } else {
#line 390
                      f9 = 0;
                    }
                  } else {
                    {
#line 392
                    tmp___30 = midstr2(pstr, x9, 1);
#line 392
                    tmp___31 = strcmp(tmp___30, s9str);
                    }
#line 392
                    if (tmp___31 == 0) {
#line 392
                      if (f9 == 0) {
#line 395
                        p9 = x9 - 1;
#line 396
                        skip = 1;
#line 397
                        goto while_break___10;
                      }
                    }
                  }
#line 383
                  x9 ++;
                }
                while_break___10: /* CIL Label */ ;
                }
#line 400
                if (skip == 0) {
#line 400
                  p9 = b1;
                }
#line 402
                skip = 0;
#line 403
                x9 = p8;
                {
#line 403
                while (1) {
                  while_continue___11: /* CIL Label */ ;
#line 403
                  if (! (x9 <= p9)) {
#line 403
                    goto while_break___11;
                  }
                  {
#line 405
                  tmp___33 = midstr2(pstr, x9, 1);
#line 405
                  a = (int )*tmp___33;
                  }
#line 406
                  if (a < 48) {
#line 408
                    skip = 1;
#line 409
                    goto while_break___11;
                  } else
#line 406
                  if (a > 57) {
#line 408
                    skip = 1;
#line 409
                    goto while_break___11;
                  }
#line 403
                  x9 ++;
                }
                while_break___11: /* CIL Label */ ;
                }
#line 413
                if (skip == 0) {
                  {
#line 418
                  tmp___34 = midstr2(pstr, p8, (p9 - p8) + 1);
#line 418
                  n = atoi(tmp___34);
                  }
#line 419
                  if (n != 0) {
#line 421
                    if (n >= f6) {
#line 421
                      if (n <= l6) {
                        {
#line 423
                        binary_search();
                        }
#line 424
                        if (x == 0) {
                          {
#line 426
                          tmp___38 = (int )strlen(pstr);
                          }
#line 426
                          if (p9 == tmp___38) {
                            {
#line 428
                            tmp___35 = midstr2(pstr, 1, p8 - 1);
#line 428
                            strcpy(tempstr___1, tmp___35);
#line 429
                            strcat(tempstr___1, rstr);
#line 430
                            strcpy(pstr, tempstr___1);
                            }
                          } else {
                            {
#line 434
                            tmp___36 = midstr2(pstr, 1, p8 - 1);
#line 434
                            strcpy(tempstr___1, tmp___36);
#line 435
                            strcat(tempstr___1, rstr);
#line 436
                            tmp___37 = midstr1(pstr, p9 + 1);
#line 436
                            strcat(tempstr___1, tmp___37);
#line 437
                            strcpy(pstr, tempstr___1);
                            }
                          }
                          {
#line 444
                          tmp___39 = (int )strlen(rstr);
#line 444
                          d9 = tmp___39 - ((p9 - p8) + 1);
#line 445
                          p9 += d9;
#line 446
                          b1 += d9;
                          }
                        }
                      }
                    }
                  }
                }
#line 452
                p8 = p9 + 2;
#line 453
                if (p8 > b1) {
#line 453
                  goto while_break___9;
                }
              }
              while_break___9: /* CIL Label */ ;
              }
            }
          }
          {
#line 461
          tmp___40 = (int )strlen(pstr);
          }
#line 461
          if (b1 == tmp___40) {
#line 461
            goto while_break___6;
          }
#line 462
          b___4 = b1 + 2;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
    }
    {
#line 467
    fprintf((FILE */* __restrict  */)fdout, (char const   */* __restrict  */)"%s\n",
            pstr);
    }
#line 468
    if (v1 == 0) {
      {
#line 468
      printf((char const   */* __restrict  */)"%s\n", pstr);
      }
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 471
  fclose(fdin);
#line 472
  fclose(fdout);
#line 473
  sprintf((char */* __restrict  */)(tempstr___1), (char const   */* __restrict  */)"mv editfl %s\000",
          f9str);
#line 474
  system(tempstr___1);
  }
#line 475
  return (0);
}
}
#line 483
extern int ( /* missing proto */  strstr)() ;
#line 478 "/home/june/collector/temp/bwbasic-2.20pl2/renum.c"
int instr(char *astr , char *bstr ) 
{ 
  char *p___0 ;
  int tmp ;

  {
  {
#line 483
  tmp = strstr(astr, bstr);
#line 483
  p___0 = (char *)tmp;
  }
#line 484
  if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
#line 484
    p___0 = astr - 1;
  }
#line 486
  return ((int )((p___0 - astr) + 1L));
}
}
#line 494 "/home/june/collector/temp/bwbasic-2.20pl2/renum.c"
static char tempstr[255]  ;
#line 490 "/home/june/collector/temp/bwbasic-2.20pl2/renum.c"
char *midstr1(char *astr , int start ) 
{ 
  char *startptr ;

  {
  {
#line 497
  strcpy(tempstr, astr);
#line 498
  startptr = (char *)(((long )(tempstr) + (long )start) - 1L);
  }
#line 500
  return (startptr);
}
}
#line 508 "/home/june/collector/temp/bwbasic-2.20pl2/renum.c"
static char tempstr___0[255]  ;
#line 504 "/home/june/collector/temp/bwbasic-2.20pl2/renum.c"
char *midstr2(char *astr , int start , int len ) 
{ 
  char *startptr ;
  char *endptr ;

  {
  {
#line 511
  strcpy(tempstr___0, astr);
#line 512
  startptr = (char *)(((long )(tempstr___0) + (long )start) - 1L);
#line 513
  endptr = (char *)((((long )(tempstr___0) + (long )start) + (long )len) - 1L);
#line 514
  strcpy(endptr, "\000");
  }
#line 516
  return (startptr);
}
}
#line 520 "/home/june/collector/temp/bwbasic-2.20pl2/renum.c"
void binary_search(void) 
{ 
  int f5 ;
  int l5 ;
  int m ;

  {
#line 524
  f5 = f2;
#line 525
  l5 = l2 + 1;
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 529
    m = (f5 + l5) / 2;
#line 531
    if (sidx[m][0] == n) {
      {
#line 533
      sprintf((char */* __restrict  */)(rstr), (char const   */* __restrict  */)"%d\000",
              sidx[m][1]);
#line 534
      x = 0;
      }
#line 535
      return;
    }
#line 538
    if (m == f5) {
#line 540
      x = 1;
#line 541
      return;
    } else
#line 538
    if (m == l5) {
#line 540
      x = 1;
#line 541
      return;
    }
#line 544
    if (sidx[m][0] < n) {
#line 545
      f5 = m;
    } else {
#line 547
      l5 = m;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 115 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) modf)(double __x ,
                                                                              double *__iptr ) ;
#line 153
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 784 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
int expsc ;
#line 787
struct exp_ese *exps ;
#line 804
char *bwb_ebuf ;
#line 829
struct bwb_op exp_ops[25] ;
#line 839
void FREE(void *ptr , char *str ) ;
#line 848
int bwb_error(char *message ) ;
#line 946
int exp_operation(int entry_level ) ;
#line 948
int dec_esc(void) ;
#line 975
bstring *exp_getsval(struct exp_ese *e___0 ) ;
#line 1004
int str_btob(bstring *d , bstring *s___0 ) ;
#line 1006
int str_cmp(bstring *a , bstring *b___4 ) ;
#line 1007
char *str_cat(bstring *a , bstring *b___4 ) ;
#line 1043
bnumber *var_findnval(struct bwb_variable *v___0 , int *pp___0 ) ;
#line 1044
bnumber exp_getnval(struct exp_ese *e___0 ) ;
#line 41 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_oplevel(int level ) ;
#line 42
static int op_add(int level , int precision ) ;
#line 43
static int op_subtract(int level , int precision ) ;
#line 44
static int op_multiply(int level , int precision ) ;
#line 45
static int op_divide(int level , int precision ) ;
#line 46
static int op_assign(int level , int precision ) ;
#line 47
static int op_equals(int level , int precision ) ;
#line 48
static int op_lessthan(int level , int precision ) ;
#line 49
static int op_greaterthan(int level , int precision ) ;
#line 50
static int op_lteq(int level , int precision ) ;
#line 51
static int op_gteq(int level , int precision ) ;
#line 52
static int op_notequal(int level , int precision ) ;
#line 53
static int op_modulus(int level , int precision ) ;
#line 54
static int op_exponent(int level , int precision ) ;
#line 55
static int op_intdiv(int level , int precision ) ;
#line 56
static int op_or(int level , int precision ) ;
#line 57
static int op_and(int level , int precision ) ;
#line 58
static int op_not(int level , int precision ) ;
#line 59
static int op_xor(int level , int precision ) ;
#line 60
static int op_negation(int level , int precision ) ;
#line 61
static int op_islevelstr(int level ) ;
#line 62
static int op_getprecision(int level ) ;
#line 63
static int op_isoperator(int operation ) ;
#line 64
static int op_pulldown(int how_far ) ;
#line 92 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_level  ;
#line 106 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
int exp_operation(int entry_level ) 
{ 
  register int precedence ;
  int operator ;
  int tmp ;
  int tmp___0 ;

  {
#line 125
  precedence = 0;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! (precedence <= 20)) {
#line 125
      goto while_break;
    }
#line 131
    op_level = entry_level + 1;
    {
#line 132
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 132
      if (op_level < expsc) {
        {
#line 132
        tmp = op_isoperator((exps + op_level)->operation);
        }
#line 132
        if (! (tmp == 0)) {
#line 132
          goto while_break___0;
        }
      } else {
#line 132
        goto while_break___0;
      }
#line 135
      op_level ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 138
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 138
      if (op_level > entry_level) {
#line 138
        if (! (op_level < expsc)) {
#line 138
          goto while_break___1;
        }
      } else {
#line 138
        goto while_break___1;
      }
#line 145
      operator = 0;
      {
#line 145
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 145
        if (! (operator < 25)) {
#line 145
          goto while_break___2;
        }
#line 148
        if (exp_ops[operator].operation == (exps + op_level)->operation) {
#line 153
          if (exp_ops[operator].precedence == precedence) {
            {
#line 162
            op_oplevel(op_level);
            }
          }
        }
#line 145
        operator ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 171
      if (op_level < expsc) {
#line 173
        op_level ++;
        {
#line 181
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 181
          tmp___0 = op_isoperator((exps + op_level)->operation);
          }
#line 181
          if (tmp___0 == 0) {
#line 181
            if (! (op_level < expsc)) {
#line 181
              goto while_break___3;
            }
          } else {
#line 181
            goto while_break___3;
          }
#line 184
          op_level ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 125
    precedence ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  return (-1);
}
}
#line 215 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_oplevel(int level ) 
{ 
  int precision ;

  {
  {
#line 227
  precision = op_getprecision(level);
  }
#line 227
  if (precision == -255) {
    {
#line 230
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"exp_operation(): failed to set precision.");
#line 231
    bwb_error(bwb_ebuf);
#line 235
    op_pulldown(2);
    }
  } else {
    {
#line 250
    if ((exps + level)->operation == 7) {
#line 250
      goto case_7;
    }
#line 254
    if ((exps + level)->operation == 8) {
#line 254
      goto case_8;
    }
#line 258
    if ((exps + level)->operation == 9) {
#line 258
      goto case_9;
    }
#line 262
    if ((exps + level)->operation == 10) {
#line 262
      goto case_10;
    }
#line 266
    if ((exps + level)->operation == 18) {
#line 266
      goto case_18;
    }
#line 270
    if ((exps + level)->operation == 17) {
#line 270
      goto case_17;
    }
#line 274
    if ((exps + level)->operation == 21) {
#line 274
      goto case_21;
    }
#line 278
    if ((exps + level)->operation == 22) {
#line 278
      goto case_22;
    }
#line 282
    if ((exps + level)->operation == 23) {
#line 282
      goto case_23;
    }
#line 286
    if ((exps + level)->operation == 24) {
#line 286
      goto case_24;
    }
#line 290
    if ((exps + level)->operation == 20) {
#line 290
      goto case_20;
    }
#line 294
    if ((exps + level)->operation == 11) {
#line 294
      goto case_11;
    }
#line 298
    if ((exps + level)->operation == 13) {
#line 298
      goto case_13;
    }
#line 302
    if ((exps + level)->operation == 27) {
#line 302
      goto case_27;
    }
#line 306
    if ((exps + level)->operation == 26) {
#line 306
      goto case_26;
    }
#line 310
    if ((exps + level)->operation == 25) {
#line 310
      goto case_25;
    }
#line 314
    if ((exps + level)->operation == 28) {
#line 314
      goto case_28;
    }
#line 318
    if ((exps + level)->operation == 12) {
#line 318
      goto case_12;
    }
#line 322
    if ((exps + level)->operation == 14) {
#line 322
      goto case_14;
    }
#line 326
    goto switch_default;
    case_7: /* CIL Label */ 
    {
#line 251
    op_add(level, precision);
    }
#line 252
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 255
    op_subtract(level, precision);
    }
#line 256
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 259
    op_multiply(level, precision);
    }
#line 260
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 263
    op_divide(level, precision);
    }
#line 264
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 267
    op_assign(level, precision);
    }
#line 268
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 271
    op_equals(level, precision);
    }
#line 272
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 275
    op_lessthan(level, precision);
    }
#line 276
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 279
    op_greaterthan(level, precision);
    }
#line 280
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 283
    op_lteq(level, precision);
    }
#line 284
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 287
    op_gteq(level, precision);
    }
#line 288
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 291
    op_notequal(level, precision);
    }
#line 292
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 295
    op_modulus(level, precision);
    }
#line 296
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 299
    op_intdiv(level, precision);
    }
#line 300
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 303
    op_or(level, precision);
    }
#line 304
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 307
    op_and(level, precision);
    }
#line 308
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 311
    op_not(level, precision);
    }
#line 312
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 315
    op_xor(level, precision);
    }
#line 316
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 319
    op_exponent(level, precision);
    }
#line 320
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 323
    op_negation(level, precision);
    }
#line 324
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 328
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"PROGRAMMING ERROR: operator <%d> not (yet) supported.",
            (exps + level)->operation);
#line 329
    op_pulldown(2);
#line 330
    bwb_error(bwb_ebuf);
    }
#line 334
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 338
  return (-1);
}
}
#line 352 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_isoperator(int operation ) 
{ 
  register int c ;

  {
#line 362
  c = 0;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (! (c < 25)) {
#line 362
      goto while_break;
    }
#line 364
    if (operation == exp_ops[c].operation) {
#line 373
      return (-1);
    }
#line 362
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 385
  return (0);
}
}
#line 409 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static bstring b  ;
#line 399 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_add(int level , int precision ) 
{ 
  int error_condition ;
  int tmp ;
  int tmp___0 ;
  bstring *tmp___1 ;
  bstring *tmp___2 ;
  bnumber tmp___3 ;
  bnumber tmp___4 ;

  {
#line 411
  error_condition = 0;
#line 412
  b.rab = 0;
  {
#line 416
  if (precision == 36) {
#line 416
    goto case_36;
  }
#line 470
  if (precision == 1) {
#line 470
    goto case_1;
  }
#line 414
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 421
  tmp = op_islevelstr(level - 1);
  }
#line 421
  if (tmp != -1) {
    {
#line 425
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in op_add(): Type mismatch in string addition.");
#line 426
    bwb_error(bwb_ebuf);
#line 430
    error_condition = -1;
    }
  } else {
    {
#line 421
    tmp___0 = op_islevelstr(level + 1);
    }
#line 421
    if (tmp___0 != -1) {
      {
#line 425
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in op_add(): Type mismatch in string addition.");
#line 426
      bwb_error(bwb_ebuf);
#line 430
      error_condition = -1;
      }
    }
  }
#line 435
  if (error_condition == 0) {
    {
#line 456
    tmp___1 = exp_getsval(exps + (level - 1));
#line 456
    str_btob(& b, tmp___1);
#line 457
    tmp___2 = exp_getsval(exps + (level + 1));
#line 457
    str_cat(& b, tmp___2);
#line 458
    str_btob(& (exps + (level - 1))->sval, & b);
#line 459
    (exps + (level - 1))->operation = 2;
    }
  }
#line 468
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 471
  tmp___3 = exp_getnval(exps + (level - 1));
#line 471
  tmp___4 = exp_getnval(exps + (level + 1));
#line 471
  (exps + (level - 1))->nval = tmp___3 + tmp___4;
#line 474
  (exps + (level - 1))->operation = 1;
  }
#line 475
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 481
  (exps + (level - 1))->type = (char )precision;
#line 491
  op_pulldown(2);
  }
#line 493
  return (-1);
}
}
#line 507 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_subtract(int level , int precision ) 
{ 
  bnumber tmp ;
  bnumber tmp___0 ;

  {
  {
#line 519
  if (precision == 36) {
#line 519
    goto case_36;
  }
#line 533
  if (precision == 1) {
#line 533
    goto case_1;
  }
#line 517
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 525
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Strings cannot be subtracted.");
#line 526
  bwb_error(bwb_ebuf);
  }
#line 531
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 534
  tmp = exp_getnval(exps + (level - 1));
#line 534
  tmp___0 = exp_getnval(exps + (level + 1));
#line 534
  (exps + (level - 1))->nval = tmp - tmp___0;
  }
#line 537
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 543
  (exps + (level - 1))->type = (char )precision;
#line 544
  (exps + (level - 1))->operation = 1;
#line 548
  op_pulldown(2);
  }
#line 550
  return (-1);
}
}
#line 564 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_multiply(int level , int precision ) 
{ 
  bnumber tmp ;
  bnumber tmp___0 ;

  {
  {
#line 576
  if (precision == 36) {
#line 576
    goto case_36;
  }
#line 590
  if (precision == 1) {
#line 590
    goto case_1;
  }
#line 574
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 582
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Strings cannot be multiplied.");
#line 583
  bwb_error(bwb_ebuf);
  }
#line 588
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 591
  tmp = exp_getnval(exps + (level - 1));
#line 591
  tmp___0 = exp_getnval(exps + (level + 1));
#line 591
  (exps + (level - 1))->nval = tmp * tmp___0;
  }
#line 594
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 600
  (exps + (level - 1))->type = (char )precision;
#line 601
  (exps + (level - 1))->operation = 1;
#line 605
  op_pulldown(2);
  }
#line 607
  return (-1);
}
}
#line 621 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_divide(int level , int precision ) 
{ 
  bnumber tmp ;
  bnumber tmp___0 ;
  bnumber tmp___1 ;

  {
  {
#line 633
  if (precision == 36) {
#line 633
    goto case_36;
  }
#line 647
  if (precision == 1) {
#line 647
    goto case_1;
  }
#line 631
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 639
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Strings cannot be divided.");
#line 640
  bwb_error(bwb_ebuf);
  }
#line 645
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 648
  tmp = exp_getnval(exps + (level + 1));
  }
#line 648
  if (tmp == (bnumber )0) {
    {
#line 651
    (exps + (level - 1))->nval = - 1.0;
#line 652
    op_pulldown(2);
#line 654
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Divide by 0.");
#line 655
    bwb_error(bwb_ebuf);
    }
#line 659
    return (0);
  }
  {
#line 661
  tmp___0 = exp_getnval(exps + (level - 1));
#line 661
  tmp___1 = exp_getnval(exps + (level + 1));
#line 661
  (exps + (level - 1))->nval = tmp___0 / tmp___1;
  }
#line 664
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 669
  (exps + (level - 1))->type = (char )precision;
#line 670
  (exps + (level - 1))->operation = 1;
#line 674
  op_pulldown(2);
  }
#line 676
  return (-1);
}
}
#line 691 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_assign(int level , int precision ) 
{ 
  bstring *tmp ;
  bstring *tmp___0 ;
  bnumber *tmp___1 ;
  bnumber tmp___2 ;

  {
#line 703
  if ((exps + (level - 1))->operation != 5) {
    {
#line 705
    op_pulldown(2);
#line 707
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in op_assign(): Assignment must be to variable: level -1 <%d> op <%d>",
            level - 1, (exps + (level - 1))->operation);
#line 709
    bwb_error(bwb_ebuf);
    }
#line 713
    return (0);
  }
#line 725
  if (precision != 36) {
#line 727
    precision = (int )(exps + (level - 1))->type;
  }
  {
#line 732
  if (precision == 36) {
#line 732
    goto case_36;
  }
#line 751
  if (precision == 1) {
#line 751
    goto case_1;
  }
#line 758
  goto switch_default;
  case_36: /* CIL Label */ 
  {
#line 747
  tmp = exp_getsval(exps + (level + 1));
#line 747
  tmp___0 = exp_getsval(exps + (level - 1));
#line 747
  str_btob(tmp___0, tmp);
  }
#line 749
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 752
  tmp___1 = var_findnval((exps + (level - 1))->xvar, (exps + (level - 1))->array_pos);
#line 752
  tmp___2 = exp_getnval(exps + (level + 1));
#line 752
  (exps + (level - 1))->nval = tmp___2;
#line 752
  *tmp___1 = tmp___2;
  }
#line 756
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 760
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in op_assign(): Variable before assignment operator has unidentified type.");
#line 761
  bwb_error(bwb_ebuf);
  }
#line 765
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 771
  (exps + (level - 1))->type = (char )precision;
#line 775
  op_pulldown(2);
  }
#line 777
  return (-1);
}
}
#line 802 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static bstring b___0  ;
#line 792 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_equals(int level , int precision ) 
{ 
  int error_condition ;
  bstring *bp ;
  int tmp ;
  int tmp___0 ;
  bstring *tmp___1 ;
  int tmp___2 ;
  bnumber tmp___3 ;
  bnumber tmp___4 ;

  {
#line 805
  error_condition = 0;
#line 806
  b___0.rab = 0;
  {
#line 810
  if (precision == 36) {
#line 810
    goto case_36;
  }
#line 850
  if (precision == 1) {
#line 850
    goto case_1;
  }
#line 808
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 815
  tmp = op_islevelstr(level - 1);
  }
#line 815
  if (tmp != -1) {
    {
#line 819
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in op_equals(): Type mismatch in string comparison.");
#line 820
    bwb_error(bwb_ebuf);
#line 824
    error_condition = -1;
    }
  } else {
    {
#line 815
    tmp___0 = op_islevelstr(level + 1);
    }
#line 815
    if (tmp___0 != -1) {
      {
#line 819
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in op_equals(): Type mismatch in string comparison.");
#line 820
      bwb_error(bwb_ebuf);
#line 824
      error_condition = -1;
      }
    }
  }
#line 829
  if (error_condition == 0) {
    {
#line 831
    bp = exp_getsval(exps + (level - 1));
#line 836
    str_btob(& b___0, bp);
#line 838
    tmp___1 = exp_getsval(exps + (level + 1));
#line 838
    tmp___2 = str_cmp(& b___0, tmp___1);
    }
#line 838
    if (tmp___2 == 0) {
#line 841
      (exps + (level - 1))->nval = (bnumber )-1;
    } else {
#line 845
      (exps + (level - 1))->nval = (bnumber )0;
    }
  }
#line 848
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 851
  tmp___3 = exp_getnval(exps + (level - 1));
#line 851
  tmp___4 = exp_getnval(exps + (level + 1));
  }
#line 851
  if (tmp___3 == tmp___4) {
#line 854
    (exps + (level - 1))->nval = (bnumber )-1;
  } else {
#line 858
    (exps + (level - 1))->nval = (bnumber )0;
  }
#line 860
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 868
  (exps + (level - 1))->type = (char)1;
#line 869
  (exps + (level - 1))->operation = 1;
#line 873
  op_pulldown(2);
  }
#line 875
  return (-1);
}
}
#line 891 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_lessthan(int level , int precision ) 
{ 
  int error_condition ;
  int tmp ;
  int tmp___0 ;
  bstring *tmp___1 ;
  bstring *tmp___2 ;
  int tmp___3 ;
  bnumber tmp___4 ;
  bnumber tmp___5 ;

  {
#line 902
  error_condition = 0;
  {
#line 906
  if (precision == 36) {
#line 906
    goto case_36;
  }
#line 939
  if (precision == 1) {
#line 939
    goto case_1;
  }
#line 904
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 911
  tmp = op_islevelstr(level - 1);
  }
#line 911
  if (tmp != -1) {
    {
#line 915
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Type mismatch in string comparison.");
#line 916
    bwb_error(bwb_ebuf);
#line 920
    error_condition = -1;
    }
  } else {
    {
#line 911
    tmp___0 = op_islevelstr(level + 1);
    }
#line 911
    if (tmp___0 != -1) {
      {
#line 915
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Type mismatch in string comparison.");
#line 916
      bwb_error(bwb_ebuf);
#line 920
      error_condition = -1;
      }
    }
  }
#line 925
  if (error_condition == 0) {
    {
#line 927
    tmp___1 = exp_getsval(exps + (level + 1));
#line 927
    tmp___2 = exp_getsval(exps + (level - 1));
#line 927
    tmp___3 = str_cmp(tmp___2, tmp___1);
    }
#line 927
    if (tmp___3 < 0) {
#line 930
      (exps + (level - 1))->nval = (bnumber )-1;
    } else {
#line 934
      (exps + (level - 1))->nval = (bnumber )0;
    }
  }
#line 937
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 940
  tmp___4 = exp_getnval(exps + (level - 1));
#line 940
  tmp___5 = exp_getnval(exps + (level + 1));
  }
#line 940
  if (tmp___4 < tmp___5) {
#line 943
    (exps + (level - 1))->nval = (bnumber )-1;
  } else {
#line 947
    (exps + (level - 1))->nval = (bnumber )0;
  }
#line 949
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 957
  (exps + (level - 1))->type = (char)1;
#line 958
  (exps + (level - 1))->operation = 1;
#line 962
  op_pulldown(2);
  }
#line 964
  return (-1);
}
}
#line 980 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_greaterthan(int level , int precision ) 
{ 
  int error_condition ;
  int tmp ;
  int tmp___0 ;
  bstring *tmp___1 ;
  bstring *tmp___2 ;
  int tmp___3 ;
  bnumber tmp___4 ;
  bnumber tmp___5 ;

  {
#line 991
  error_condition = 0;
  {
#line 995
  if (precision == 36) {
#line 995
    goto case_36;
  }
#line 1028
  if (precision == 1) {
#line 1028
    goto case_1;
  }
#line 993
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 1000
  tmp = op_islevelstr(level - 1);
  }
#line 1000
  if (tmp != -1) {
    {
#line 1004
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Type mismatch in string comparison.");
#line 1005
    bwb_error(bwb_ebuf);
#line 1009
    error_condition = -1;
    }
  } else {
    {
#line 1000
    tmp___0 = op_islevelstr(level + 1);
    }
#line 1000
    if (tmp___0 != -1) {
      {
#line 1004
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Type mismatch in string comparison.");
#line 1005
      bwb_error(bwb_ebuf);
#line 1009
      error_condition = -1;
      }
    }
  }
#line 1014
  if (error_condition == 0) {
    {
#line 1016
    tmp___1 = exp_getsval(exps + (level + 1));
#line 1016
    tmp___2 = exp_getsval(exps + (level - 1));
#line 1016
    tmp___3 = str_cmp(tmp___2, tmp___1);
    }
#line 1016
    if (tmp___3 > 0) {
#line 1019
      (exps + (level - 1))->nval = (bnumber )-1;
    } else {
#line 1023
      (exps + (level - 1))->nval = (bnumber )0;
    }
  }
#line 1026
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1029
  tmp___4 = exp_getnval(exps + (level - 1));
#line 1029
  tmp___5 = exp_getnval(exps + (level + 1));
  }
#line 1029
  if (tmp___4 > tmp___5) {
#line 1032
    (exps + (level - 1))->nval = (bnumber )-1;
  } else {
#line 1036
    (exps + (level - 1))->nval = (bnumber )0;
  }
#line 1038
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1046
  (exps + (level - 1))->type = (char)1;
#line 1047
  (exps + (level - 1))->operation = 1;
#line 1051
  op_pulldown(2);
  }
#line 1053
  return (-1);
}
}
#line 1069 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_lteq(int level , int precision ) 
{ 
  int error_condition ;
  int tmp ;
  int tmp___0 ;
  bstring *tmp___1 ;
  bstring *tmp___2 ;
  int tmp___3 ;
  bnumber tmp___4 ;
  bnumber tmp___5 ;

  {
#line 1080
  error_condition = 0;
  {
#line 1084
  if (precision == 36) {
#line 1084
    goto case_36;
  }
#line 1117
  if (precision == 1) {
#line 1117
    goto case_1;
  }
#line 1082
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 1089
  tmp = op_islevelstr(level - 1);
  }
#line 1089
  if (tmp != -1) {
    {
#line 1093
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Type mismatch in string comparison.");
#line 1094
    bwb_error(bwb_ebuf);
#line 1098
    error_condition = -1;
    }
  } else {
    {
#line 1089
    tmp___0 = op_islevelstr(level + 1);
    }
#line 1089
    if (tmp___0 != -1) {
      {
#line 1093
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Type mismatch in string comparison.");
#line 1094
      bwb_error(bwb_ebuf);
#line 1098
      error_condition = -1;
      }
    }
  }
#line 1103
  if (error_condition == 0) {
    {
#line 1105
    tmp___1 = exp_getsval(exps + (level + 1));
#line 1105
    tmp___2 = exp_getsval(exps + (level - 1));
#line 1105
    tmp___3 = str_cmp(tmp___2, tmp___1);
    }
#line 1105
    if (tmp___3 <= 0) {
#line 1108
      (exps + (level - 1))->nval = (bnumber )-1;
    } else {
#line 1112
      (exps + (level - 1))->nval = (bnumber )0;
    }
  }
#line 1115
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1118
  tmp___4 = exp_getnval(exps + (level - 1));
#line 1118
  tmp___5 = exp_getnval(exps + (level + 1));
  }
#line 1118
  if (tmp___4 <= tmp___5) {
#line 1121
    (exps + (level - 1))->nval = (bnumber )-1;
  } else {
#line 1125
    (exps + (level - 1))->nval = (bnumber )0;
  }
#line 1127
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1135
  (exps + (level - 1))->type = (char)1;
#line 1136
  (exps + (level - 1))->operation = 1;
#line 1140
  op_pulldown(2);
  }
#line 1142
  return (-1);
}
}
#line 1158 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_gteq(int level , int precision ) 
{ 
  int error_condition ;
  int tmp ;
  int tmp___0 ;
  bstring *tmp___1 ;
  bstring *tmp___2 ;
  int tmp___3 ;
  bnumber tmp___4 ;
  bnumber tmp___5 ;

  {
#line 1169
  error_condition = 0;
  {
#line 1173
  if (precision == 36) {
#line 1173
    goto case_36;
  }
#line 1206
  if (precision == 1) {
#line 1206
    goto case_1;
  }
#line 1171
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 1178
  tmp = op_islevelstr(level - 1);
  }
#line 1178
  if (tmp != -1) {
    {
#line 1182
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Type mismatch in string comparison.");
#line 1183
    bwb_error(bwb_ebuf);
#line 1187
    error_condition = -1;
    }
  } else {
    {
#line 1178
    tmp___0 = op_islevelstr(level + 1);
    }
#line 1178
    if (tmp___0 != -1) {
      {
#line 1182
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Type mismatch in string comparison.");
#line 1183
      bwb_error(bwb_ebuf);
#line 1187
      error_condition = -1;
      }
    }
  }
#line 1192
  if (error_condition == 0) {
    {
#line 1194
    tmp___1 = exp_getsval(exps + (level + 1));
#line 1194
    tmp___2 = exp_getsval(exps + (level - 1));
#line 1194
    tmp___3 = str_cmp(tmp___2, tmp___1);
    }
#line 1194
    if (tmp___3 >= 0) {
#line 1197
      (exps + (level - 1))->nval = (bnumber )-1;
    } else {
#line 1201
      (exps + (level - 1))->nval = (bnumber )0;
    }
  }
#line 1204
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1207
  tmp___4 = exp_getnval(exps + (level - 1));
#line 1207
  tmp___5 = exp_getnval(exps + (level + 1));
  }
#line 1207
  if (tmp___4 >= tmp___5) {
#line 1210
    (exps + (level - 1))->nval = (bnumber )-1;
  } else {
#line 1214
    (exps + (level - 1))->nval = (bnumber )0;
  }
#line 1216
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1224
  (exps + (level - 1))->type = (char)1;
#line 1225
  (exps + (level - 1))->operation = 1;
#line 1229
  op_pulldown(2);
  }
#line 1231
  return (-1);
}
}
#line 1246 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_notequal(int level , int precision ) 
{ 
  int error_condition ;
  int tmp ;
  int tmp___0 ;
  bstring *tmp___1 ;
  bstring *tmp___2 ;
  int tmp___3 ;
  bnumber tmp___4 ;
  bnumber tmp___5 ;

  {
#line 1257
  error_condition = 0;
  {
#line 1261
  if (precision == 36) {
#line 1261
    goto case_36;
  }
#line 1295
  if (precision == 1) {
#line 1295
    goto case_1;
  }
#line 1259
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 1266
  tmp = op_islevelstr(level - 1);
  }
#line 1266
  if (tmp != -1) {
    {
#line 1270
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Type mismatch in string comparison.");
#line 1271
    bwb_error(bwb_ebuf);
#line 1275
    error_condition = -1;
    }
  } else {
    {
#line 1266
    tmp___0 = op_islevelstr(level + 1);
    }
#line 1266
    if (tmp___0 != -1) {
      {
#line 1270
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Type mismatch in string comparison.");
#line 1271
      bwb_error(bwb_ebuf);
#line 1275
      error_condition = -1;
      }
    }
  }
#line 1280
  if (error_condition == 0) {
    {
#line 1283
    tmp___1 = exp_getsval(exps + (level + 1));
#line 1283
    tmp___2 = exp_getsval(exps + (level - 1));
#line 1283
    tmp___3 = str_cmp(tmp___2, tmp___1);
    }
#line 1283
    if (tmp___3 != 0) {
#line 1286
      (exps + (level - 1))->nval = (bnumber )-1;
    } else {
#line 1290
      (exps + (level - 1))->nval = (bnumber )0;
    }
  }
#line 1293
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1296
  tmp___4 = exp_getnval(exps + (level - 1));
#line 1296
  tmp___5 = exp_getnval(exps + (level + 1));
  }
#line 1296
  if (tmp___4 != tmp___5) {
#line 1299
    (exps + (level - 1))->nval = (bnumber )-1;
  } else {
#line 1303
    (exps + (level - 1))->nval = (bnumber )0;
  }
#line 1305
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1313
  (exps + (level - 1))->type = (char)1;
#line 1314
  (exps + (level - 1))->operation = 1;
#line 1318
  op_pulldown(2);
  }
#line 1320
  return (-1);
}
}
#line 1344 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static double iportion  ;
#line 1335 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_modulus(int level , int precision ) 
{ 
  bnumber tmp ;
  bnumber tmp___0 ;
  bnumber tmp___1 ;
  bnumber tmp___2 ;
  bnumber tmp___3 ;

  {
  {
#line 1348
  if (precision == 36) {
#line 1348
    goto case_36;
  }
#line 1362
  if (precision == 1) {
#line 1362
    goto case_1;
  }
#line 1346
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 1354
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Strings cannot be divided.");
#line 1355
  bwb_error(bwb_ebuf);
  }
#line 1360
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1363
  tmp = exp_getnval(exps + (level + 1));
  }
#line 1363
  if (tmp == (bnumber )0) {
    {
#line 1366
    (exps + (level - 1))->nval = (bnumber )-1;
#line 1367
    op_pulldown(2);
#line 1369
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Divide by 0.");
#line 1370
    bwb_error(bwb_ebuf);
    }
#line 1374
    return (0);
  }
  {
#line 1376
  tmp___0 = exp_getnval(exps + (level - 1));
#line 1376
  tmp___1 = exp_getnval(exps + (level + 1));
#line 1376
  (exps + level)->nval = tmp___0 / tmp___1;
#line 1379
  modf((exps + level)->nval, & iportion);
#line 1380
  tmp___2 = exp_getnval(exps + (level - 1));
#line 1380
  tmp___3 = exp_getnval(exps + (level + 1));
#line 1380
  (exps + (level - 1))->nval = tmp___2 - tmp___3 * iportion;
  }
#line 1384
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1390
  (exps + (level - 1))->type = (char )precision;
#line 1391
  (exps + (level - 1))->operation = 1;
#line 1395
  op_pulldown(2);
  }
#line 1397
  return (-1);
}
}
#line 1412 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_exponent(int level , int precision ) 
{ 
  bnumber tmp ;
  bnumber tmp___0 ;
  double tmp___1 ;

  {
  {
#line 1430
  if (precision == 36) {
#line 1430
    goto case_36;
  }
#line 1444
  if (precision == 1) {
#line 1444
    goto case_1;
  }
#line 1428
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 1436
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Strings cannot be taken as exponents.");
#line 1437
  bwb_error(bwb_ebuf);
  }
#line 1442
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1445
  tmp = exp_getnval(exps + (level + 1));
#line 1445
  tmp___0 = exp_getnval(exps + (level - 1));
#line 1445
  tmp___1 = pow(tmp___0, tmp);
#line 1445
  (exps + (level - 1))->nval = tmp___1;
  }
#line 1448
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1454
  (exps + (level - 1))->type = (char )precision;
#line 1455
  (exps + (level - 1))->operation = 1;
#line 1459
  op_pulldown(2);
  }
#line 1461
  return (-1);
}
}
#line 1476 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_intdiv(int level , int precision ) 
{ 
  bnumber tmp ;
  bnumber tmp___0 ;
  bnumber tmp___1 ;

  {
  {
#line 1488
  if (precision == 36) {
#line 1488
    goto case_36;
  }
#line 1502
  goto switch_default;
  case_36: /* CIL Label */ 
  {
#line 1494
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Strings cannot be divided.");
#line 1495
  bwb_error(bwb_ebuf);
  }
#line 1500
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1503
  tmp = exp_getnval(exps + (level + 1));
  }
#line 1503
  if (tmp == (bnumber )0) {
    {
#line 1506
    (exps + (level - 1))->nval = (bnumber )-1;
#line 1507
    op_pulldown(2);
#line 1509
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Divide by 0.");
#line 1510
    bwb_error(bwb_ebuf);
    }
#line 1514
    return (0);
  }
  {
#line 1517
  tmp___0 = exp_getnval(exps + (level - 1));
#line 1517
  tmp___1 = exp_getnval(exps + (level + 1));
#line 1517
  (exps + (level - 1))->nval = tmp___0 / tmp___1;
  }
#line 1520
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1525
  (exps + (level - 1))->type = (char)1;
#line 1526
  (exps + (level - 1))->operation = 1;
#line 1530
  op_pulldown(2);
  }
#line 1532
  return (-1);
}
}
#line 1546 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_or(int level , int precision ) 
{ 
  bnumber tmp ;
  bnumber tmp___0 ;

  {
  {
#line 1558
  if (precision == 36) {
#line 1558
    goto case_36;
  }
#line 1572
  if (precision == 1) {
#line 1572
    goto case_1;
  }
#line 1556
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 1564
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Strings cannot be compared logically.");
#line 1565
  bwb_error(bwb_ebuf);
  }
#line 1570
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1573
  tmp = exp_getnval(exps + (level - 1));
#line 1573
  tmp___0 = exp_getnval(exps + (level + 1));
#line 1573
  (exps + (level - 1))->nval = (bnumber )((int )tmp | (int )tmp___0);
  }
#line 1576
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1582
  (exps + (level - 1))->type = (char)1;
#line 1583
  (exps + (level - 1))->operation = 1;
#line 1587
  op_pulldown(2);
  }
#line 1589
  return (-1);
}
}
#line 1603 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_and(int level , int precision ) 
{ 
  bnumber tmp ;
  bnumber tmp___0 ;

  {
  {
#line 1615
  if (precision == 36) {
#line 1615
    goto case_36;
  }
#line 1630
  if (precision == 1) {
#line 1630
    goto case_1;
  }
#line 1613
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 1622
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Strings cannot be compared logically.");
#line 1623
  bwb_error(bwb_ebuf);
  }
#line 1628
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1631
  tmp = exp_getnval(exps + (level - 1));
#line 1631
  tmp___0 = exp_getnval(exps + (level + 1));
#line 1631
  (exps + (level - 1))->nval = (bnumber )((int )tmp & (int )tmp___0);
  }
#line 1634
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1640
  (exps + (level - 1))->type = (char)1;
#line 1641
  (exps + (level - 1))->operation = 1;
#line 1645
  op_pulldown(2);
  }
#line 1647
  return (-1);
}
}
#line 1661 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_not(int level , int precision ) 
{ 
  bnumber tmp ;

  {
  {
#line 1673
  if (precision == 36) {
#line 1673
    goto case_36;
  }
#line 1688
  goto switch_default;
  case_36: /* CIL Label */ 
  {
#line 1680
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Strings cannot be compared logically.");
#line 1681
  bwb_error(bwb_ebuf);
  }
#line 1686
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1696
  tmp = exp_getnval(exps + (level + 1));
#line 1696
  (exps + level)->nval = (bnumber )(~ ((int )tmp));
  }
#line 1705
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1710
  (exps + level)->type = (char)1;
#line 1711
  (exps + level)->operation = 1;
#line 1715
  op_pulldown(1);
  }
#line 1723
  return (-1);
}
}
#line 1737 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_xor(int level , int precision ) 
{ 
  bnumber tmp ;
  bnumber tmp___0 ;

  {
  {
#line 1749
  if (precision == 36) {
#line 1749
    goto case_36;
  }
#line 1763
  if (precision == 1) {
#line 1763
    goto case_1;
  }
#line 1747
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 1755
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Strings cannot be compared logically.");
#line 1756
  bwb_error(bwb_ebuf);
  }
#line 1761
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1764
  tmp = exp_getnval(exps + (level - 1));
#line 1764
  tmp___0 = exp_getnval(exps + (level + 1));
#line 1764
  (exps + (level - 1))->nval = (bnumber )((int )tmp ^ (int )tmp___0);
  }
#line 1767
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1773
  (exps + (level - 1))->type = (char)1;
#line 1774
  (exps + (level - 1))->operation = 1;
#line 1778
  op_pulldown(2);
  }
#line 1780
  return (-1);
}
}
#line 1795 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_negation(int level , int precision ) 
{ 
  bnumber tmp ;

  {
  {
#line 1807
  if (precision == 36) {
#line 1807
    goto case_36;
  }
#line 1822
  goto switch_default;
  case_36: /* CIL Label */ 
  {
#line 1814
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Strings cannot be compared logically.");
#line 1815
  bwb_error(bwb_ebuf);
  }
#line 1820
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1830
  tmp = exp_getnval(exps + (level + 1));
#line 1830
  (exps + level)->nval = - tmp;
  }
#line 1839
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1844
  (exps + level)->type = (char )precision;
#line 1845
  (exps + level)->operation = 1;
#line 1849
  op_pulldown(1);
  }
#line 1857
  return (-1);
}
}
#line 1872 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_islevelstr(int level ) 
{ 


  {
#line 1883
  if ((exps + level)->operation == 2) {
#line 1892
    return (-1);
  }
#line 1897
  if ((exps + level)->operation == 5) {
#line 1899
    if (((exps + level)->xvar)->type == 36) {
#line 1908
      return (-1);
    }
  }
#line 1920
  return (0);
}
}
#line 1935 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_getprecision(int level ) 
{ 


  {
#line 1946
  if ((int )(exps + (level + 1))->type == 36) {
#line 1949
    return ('$');
  } else
#line 1946
  if ((int )(exps + (level - 1))->type == 36) {
#line 1949
    return ('$');
  } else {
#line 1958
    return (1);
  }
}
}
#line 1976 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_ops.c"
static int op_pulldown(int how_far ) 
{ 
  int level ;
  register int c ;
  int tmp ;

  {
#line 1995
  level = op_level + (2 - how_far);
  {
#line 1996
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1996
    if (! (expsc >= level + how_far)) {
#line 1996
      goto while_break;
    }
#line 2005
    if ((unsigned long )(exps + level)->sval.sbuffer != (unsigned long )((void *)0)) {
      {
#line 2006
      FREE((void *)(exps + level)->sval.sbuffer, (char *)"op_pulldown");
      }
    }
    {
#line 2007
    memcpy((void */* __restrict  */)(exps + level), (void const   */* __restrict  */)(exps + (level + how_far)),
           sizeof(struct exp_ese ));
#line 2009
    (exps + (level + how_far))->sval.sbuffer = (char *)((void *)0);
#line 2011
    level ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2017
  c = 0;
  {
#line 2017
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2017
    if (! (c < how_far)) {
#line 2017
      goto while_break___0;
    }
    {
#line 2020
    tmp = dec_esc();
    }
#line 2020
    if (tmp == -1) {
#line 2022
      op_level --;
    } else {
#line 2026
      return (0);
    }
#line 2017
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2031
  return (-1);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 769 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
char progfile[128]  ;
#line 770
int rescan ;
#line 771
int number ;
#line 772 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct bwb_line *bwb_l  ;
#line 773 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct bwb_line bwb_start  ;
#line 774 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct bwb_line bwb_end  ;
#line 775 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct bwb_line *data_line  ;
#line 776
int data_pos ;
#line 777 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct bwb_variable var_start  ;
#line 778 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct bwb_variable var_end  ;
#line 779 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct bwb_function fnc_start  ;
#line 780 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct bwb_function fnc_end  ;
#line 781 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct fslte fslt_start  ;
#line 782 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct fslte fslt_end  ;
#line 783
int exsc ;
#line 785
int xtxtsc ;
#line 786 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct exse *excs  ;
#line 787 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct exp_ese *exps  ;
#line 788 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct xtxtsl *xtxts  ;
#line 791
int bwb_curtask ;
#line 792 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct bwb_variable *ed  ;
#line 793 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct bwb_variable *fi  ;
#line 794 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct bwb_variable *pr  ;
#line 795 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct bwb_variable *im  ;
#line 796 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct bwb_variable *co  ;
#line 804 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
char *bwb_ebuf  ;
#line 805
int bwb_trace ;
#line 807
struct bwb_command bwb_cmdtable[76] ;
#line 808 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
FILE *errfdevice  ;
#line 811
char err_gosubl[41] ;
#line 817
struct dev_element *dev_table ;
#line 838
void *CALLOC(size_t nelem , size_t elsize , char *str ) ;
#line 840
void bwb_init(int argc , char **argv ) ;
#line 841
int bwb_fload(FILE *file ) ;
#line 842
int bwb_ladd(char *buffer , int replace ) ;
#line 844
struct bwb_line *bwb_xtxtline(char *buffer ) ;
#line 845
void bwb_mainloop(void) ;
#line 846
void bwb_execline(void) ;
#line 847
int bwb_gets(char *buffer ) ;
#line 849
void break_handler(void) ;
#line 850
void break_mes(int x___0 ) ;
#line 854
struct bwb_line *bwb_run(struct bwb_line *l ) ;
#line 861
struct bwb_line *bwb_new(struct bwb_line *l ) ;
#line 932
extern void bwb_incexec(void) ;
#line 933
extern void bwb_decexec(void) ;
#line 934
extern int bwb_setexec(struct bwb_line *l , int position___7 , int code ) ;
#line 949
int fnc_init(int task ) ;
#line 953
int bwb_stripcr(char *s___0 ) ;
#line 955
int bwb_freeline(struct bwb_line *l ) ;
#line 959
int var_init(int task ) ;
#line 960
int fslt_init(int task ) ;
#line 968
struct bwb_variable *var_find(char *buffer ) ;
#line 973
bstring *var_getsval(struct bwb_variable *nvar___34 ) ;
#line 974
bstring *var_findsval(struct bwb_variable *v___0 , int *pp___0 ) ;
#line 977
int adv_element(char *buffer , int *pos___2 , char *element___0 ) ;
#line 978
int adv_ws(char *buffer , int *pos___2 ) ;
#line 982
int line_start(char *buffer , int *pos___2 , int *lnpos , int *lnum , int *cmdpos ,
               int *cmdnum , int *startpos___0 ) ;
#line 987
int is_numconst(char *buffer ) ;
#line 996
int *prn_getcol(FILE *f ) ;
#line 998
int prn_xprintf(FILE *f , char *buffer ) ;
#line 1003
int str_btoc(char *buffer , bstring *s___0 ) ;
#line 1005
int str_ctob(bstring *s___0 , char *buffer ) ;
#line 1022
int ln_asbuf(struct bwb_line *l , char *s___0 ) ;
#line 1024
int bwx_signon(void) ;
#line 1028
int bwx_input(char *prompt , char *buffer ) ;
#line 1029
void bwx_terminate(void) ;
#line 1032
extern int bwx_shell(struct bwb_line *l ) ;
#line 1052
int bwb_interact(void) ;
#line 460 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mes.h"
char err_openfile[23] ;
#line 107 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) )  __asm__("__sysv_signal")  ;
#line 63 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 74
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 52 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
static char *read_line  ;
#line 53 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
int bwb_trace  =    0;
#line 57 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
jmp_buf mark  ;
#line 60 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
static int program_run  =    0;
#line 61 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
int bwb_curtask  =    0;
#line 73 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
int rescan  =    -1;
#line 74 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
int number  =    0;
#line 79 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
int data_pos  =    0;
#line 86 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
int exsc  =    -1;
#line 87 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
int expsc  =    0;
#line 88 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
int xtxtsc  =    0;
#line 97
int is_ln(char *buffer ) ;
#line 119 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
static FILE *input  =    (FILE *)((void *)0);
#line 132 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
static char start_buf[2]  = {      (char )'\000',      (char )'\000'};
#line 133 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
static char end_buf[2]  = {      (char )'\000',      (char )'\000'};
#line 110 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
void bwb_init(int argc , char **argv ) 
{ 
  register int n___0 ;
  struct bwb_variable *v___0 ;
  FILE *profile ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  bstring *tmp___5 ;
  bstring *tmp___6 ;
  bstring *tmp___7 ;
  bstring *tmp___8 ;
  bnumber *tmp___9 ;

  {
  {
#line 136
  errfdevice = stderr;
#line 163
  tmp = CALLOC((size_t )16, sizeof(struct xtxtsl ), (char *)"bwb_init");
#line 163
  xtxts = (struct xtxtsl *)tmp;
  }
#line 163
  if ((unsigned long )xtxts == (unsigned long )((void *)0)) {
    {
#line 166
    bwb_error((char *)"in bwb_init(): failed to find memory for xtxts");
    }
  }
  {
#line 175
  tmp___0 = CALLOC((size_t )64, sizeof(struct exp_ese ), (char *)"bwb_init");
#line 175
  exps = (struct exp_ese *)tmp___0;
  }
#line 175
  if ((unsigned long )exps == (unsigned long )((void *)0)) {
    {
#line 178
    bwb_error((char *)"in bwb_init(): failed to find memory for exps");
    }
  }
  {
#line 187
  tmp___1 = CALLOC((size_t )64, sizeof(struct exse ), (char *)"bwb_init");
#line 187
  excs = (struct exse *)tmp___1;
  }
#line 187
  if ((unsigned long )excs == (unsigned long )((void *)0)) {
    {
#line 190
    bwb_error((char *)"in bwb_init(): failed to find memory for excs");
    }
  }
  {
#line 198
  bwb_start.number = 0;
#line 199
  bwb_start.next = & bwb_end;
#line 200
  bwb_end.number = 32767;
#line 201
  bwb_end.next = & bwb_end;
#line 202
  bwb_start.buffer = start_buf;
#line 203
  bwb_end.buffer = end_buf;
#line 204
  data_line = & bwb_start;
#line 205
  data_pos = 0;
#line 206
  exsc = -1;
#line 207
  expsc = 0;
#line 208
  xtxtsc = 0;
#line 209
  bwb_start.position = 0;
#line 210
  bwb_l = & bwb_start;
#line 212
  var_init(0);
#line 213
  fnc_init(0);
#line 214
  fslt_init(0);
#line 221
  tmp___2 = CALLOC((size_t )5001, sizeof(char ), (char *)"bwb_init");
#line 221
  bwb_ebuf = (char *)tmp___2;
  }
#line 221
  if ((unsigned long )bwb_ebuf == (unsigned long )((void *)0)) {
    {
#line 224
    bwb_error((char *)"in bwb_init(): failed to find memory for bwb_ebuf");
    }
  }
  {
#line 230
  tmp___3 = CALLOC((size_t )257, sizeof(char ), (char *)"bwb_init");
#line 230
  read_line = (char *)tmp___3;
  }
#line 230
  if ((unsigned long )read_line == (unsigned long )((void *)0)) {
    {
#line 233
    bwb_error((char *)"in bwb_init(): failed to find memory for read_line");
    }
  }
  {
#line 263
  tmp___4 = CALLOC((size_t )16, sizeof(struct dev_element ), (char *)"bwb_init");
#line 263
  dev_table = (struct dev_element *)tmp___4;
  }
#line 263
  if ((unsigned long )dev_table == (unsigned long )((void *)0)) {
    {
#line 266
    bwb_error((char *)"in bwb_init(): failed to find memory for dev_table");
#line 270
    bwx_terminate();
    }
  }
#line 275
  n___0 = 0;
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    if (! (n___0 < 16)) {
#line 275
      goto while_break;
    }
#line 277
    (dev_table + n___0)->mode = -1;
#line 278
    (dev_table + n___0)->reclen = -1;
#line 279
    (dev_table + n___0)->cfp = (FILE *)((void *)0);
#line 280
    (dev_table + n___0)->buffer = (char *)((void *)0);
#line 281
    (dev_table + n___0)->width = 128;
#line 282
    (dev_table + n___0)->col = 1;
#line 275
    n___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 288
  ed = var_find((char *)"BWB.EDITOR$");
#line 289
  ed->preset = -1;
#line 290
  ed->common = -1;
#line 291
  tmp___5 = var_findsval(ed, ed->array_pos);
#line 291
  str_ctob(tmp___5, (char *)"vi");
#line 293
  fi = var_find((char *)"BWB.FILES$");
#line 294
  fi->preset = -1;
#line 295
  fi->common = -1;
#line 296
  tmp___6 = var_findsval(fi, fi->array_pos);
#line 296
  str_ctob(tmp___6, (char *)"ls -Fx");
#line 298
  pr = var_find((char *)"BWB.PROMPT$");
#line 299
  pr->preset = -1;
#line 300
  pr->common = -1;
#line 301
  tmp___7 = var_findsval(pr, pr->array_pos);
#line 301
  str_ctob(tmp___7, (char *)"bwBASIC: ");
#line 303
  im = var_find((char *)"BWB.IMPLEMENTATION$");
#line 304
  im->preset = -1;
#line 305
  im->common = -1;
#line 306
  tmp___8 = var_findsval(im, im->array_pos);
#line 306
  str_ctob(tmp___8, (char *)"TTY");
#line 308
  co = var_find((char *)"BWB.COLORS");
#line 309
  co->preset = -1;
#line 310
  co->common = -1;
#line 311
  tmp___9 = var_findnval(co, co->array_pos);
#line 311
  *tmp___9 = (bnumber )256;
#line 315
  bwx_signon();
#line 336
  errfdevice = stdout;
#line 342
  profile = fopen((char const   */* __restrict  */)"profile.bas", (char const   */* __restrict  */)"r");
  }
#line 342
  if ((unsigned long )profile != (unsigned long )((void *)0)) {
    {
#line 344
    bwb_fload(profile);
#line 345
    bwb_run(& bwb_start);
    }
    {
#line 349
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 349
      if (! (exsc > -1)) {
#line 349
        goto while_break___0;
      }
      {
#line 351
      bwb_execline();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 356
    v___0 = var_start.next;
    {
#line 356
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 356
      if (! ((unsigned long )v___0 != (unsigned long )(& var_end))) {
#line 356
        goto while_break___1;
      }
#line 365
      v___0->preset = -1;
#line 356
      v___0 = v___0->next;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 368
    bwb_new(& bwb_start);
    }
  }
  {
#line 383
  signal(2, & break_mes);
#line 387
  _setjmp((struct __jmp_buf_tag *)(mark));
#line 411
  program_run ++;
  }
#line 412
  if (argc > 1) {
#line 412
    if (program_run == 1) {
      {
#line 414
      strcpy((char */* __restrict  */)(progfile), (char const   */* __restrict  */)*(argv + 1));
#line 415
      input = fopen((char const   */* __restrict  */)(progfile), (char const   */* __restrict  */)"r");
      }
#line 415
      if ((unsigned long )input == (unsigned long )((void *)0)) {
        {
#line 417
        strcat((char */* __restrict  */)(progfile), (char const   */* __restrict  */)".bas");
#line 418
        input = fopen((char const   */* __restrict  */)(progfile), (char const   */* __restrict  */)"r");
        }
#line 418
        if ((unsigned long )input == (unsigned long )((void *)0)) {
          {
#line 420
          progfile[0] = (char)0;
#line 421
          sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)(err_openfile),
                  *(argv + 1));
#line 422
          bwb_error(bwb_ebuf);
          }
        }
      }
#line 425
      if ((unsigned long )input != (unsigned long )((void *)0)) {
        {
#line 433
        bwb_fload(input);
#line 434
        bwb_run(& bwb_start);
        }
      }
    }
  }
#line 438
  return;
}
}
#line 450 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
int bwb_interact(void) 
{ 
  char tbuf___20[5001] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 466
  bwb_gets(read_line);
#line 467
  bwb_stripcr(read_line);
#line 471
  tmp___0 = is_ln(read_line);
  }
#line 471
  if (tmp___0 == 0) {
    {
#line 473
    bwb_xtxtline(read_line);
    }
  } else {
    {
#line 480
    tmp = is_numconst(read_line);
    }
#line 480
    if (tmp == -1) {
      {
#line 482
      strcpy((char */* __restrict  */)(tbuf___20), (char const   */* __restrict  */)read_line);
#line 483
      sprintf((char */* __restrict  */)read_line, (char const   */* __restrict  */)"delete %s\000",
              tbuf___20);
#line 484
      bwb_xtxtline(read_line);
      }
    } else {
      {
#line 491
      bwb_ladd(read_line, -1);
      }
    }
  }
#line 497
  return (-1);
}
}
#line 512 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
int bwb_fload(FILE *file ) 
{ 
  int *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 521
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 521
    tmp___2 = feof(file);
    }
#line 521
    if (! (tmp___2 == 0)) {
#line 521
      goto while_break;
    }
    {
#line 523
    *(read_line + 0) = (char )'\000';
#line 524
    fgets((char */* __restrict  */)read_line, 256, (FILE */* __restrict  */)file);
    }
#line 525
    if ((unsigned long )file == (unsigned long )stdin) {
      {
#line 527
      tmp = prn_getcol(stdout);
#line 527
      *tmp = 1;
      }
    }
    {
#line 529
    bwb_stripcr(read_line);
#line 533
    tmp___0 = feof(file);
    }
#line 533
    if (tmp___0 == 0) {
      {
#line 535
      bwb_ladd(read_line, 0);
      }
    } else {
      {
#line 533
      tmp___1 = strlen((char const   *)read_line);
      }
#line 533
      if (tmp___1 > 0UL) {
        {
#line 535
        bwb_ladd(read_line, 0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 541
  fclose(file);
  }
#line 543
  return (-1);
}
}
#line 565 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
static char *s_buffer  ;
#line 566 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
static int init  =    0;
#line 567 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
static int prev_num  =    0;
#line 555 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
int bwb_ladd(char *buffer , int replace ) 
{ 
  struct bwb_line *l ;
  struct bwb_line *previous ;
  struct bwb_line *p___0 ;
  char *newbuffer ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 578
  if (init == 0) {
    {
#line 580
    init = -1;
#line 583
    tmp = CALLOC(5001UL, sizeof(char ), (char *)"bwb_ladd");
#line 583
    s_buffer = (char *)tmp;
    }
#line 583
    if ((unsigned long )s_buffer == (unsigned long )((void *)0)) {
      {
#line 586
      bwb_error((char *)"in bwb_ladd(): failed to find memory for s_buffer");
      }
#line 590
      return (0);
    }
  }
  {
#line 602
  tmp___0 = CALLOC((size_t )1, sizeof(struct bwb_line ), (char *)"bwb_ladd");
#line 602
  l = (struct bwb_line *)tmp___0;
  }
#line 602
  if ((unsigned long )l == (unsigned long )((void *)0)) {
    {
#line 605
    bwb_error((char *)"in bwb_ladd(): failed to find memory for new line");
    }
#line 609
    return (0);
  }
  {
#line 619
  l->marked = 0;
#line 620
  rescan = -1;
#line 621
  l->xnum = (char)0;
#line 625
  adv_element(buffer, & l->position, s_buffer);
#line 629
  tmp___1 = is_numconst(s_buffer);
  }
#line 629
  if (tmp___1 == -1) {
    {
#line 632
    l->number = atoi((char const   *)s_buffer);
#line 640
    prev_num = l->number;
#line 641
    l->xnum = (char)-1;
#line 642
    (l->position) ++;
#line 643
    newbuffer = buffer + l->position;
#line 647
    ln_asbuf(l, newbuffer);
    }
  } else {
    {
#line 662
    newbuffer = buffer;
#line 666
    ln_asbuf(l, newbuffer);
#line 668
    l->xnum = (char)0;
#line 669
    l->number = prev_num;
    }
  }
#line 674
  previous = & bwb_start;
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;
#line 674
    if (! ((unsigned long )previous != (unsigned long )(& bwb_end))) {
#line 674
      goto while_break;
    }
#line 679
    if ((int )l->xnum == -1) {
#line 679
      if (previous->number == l->number) {
#line 679
        if (replace == -1) {
          {
#line 693
          ln_asbuf(previous, newbuffer);
#line 700
          bwb_freeline(l);
          }
#line 704
          return (-1);
        } else {
#line 679
          goto _L___1;
        }
      } else {
#line 679
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 711
    if (previous->number == l->number) {
#line 711
      if (replace == 0) {
#line 724
        p___0 = previous;
        {
#line 724
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 724
          if (! (p___0->number == l->number)) {
#line 724
            goto while_break___0;
          }
#line 729
          previous = p___0;
#line 724
          p___0 = p___0->next;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 732
        l->next = previous->next;
#line 733
        previous->next = l;
#line 734
        return (-1);
      } else {
#line 711
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 739
    if (previous->number < l->number) {
#line 739
      if ((previous->next)->number > l->number) {
#line 742
        l->next = previous->next;
#line 743
        previous->next = l;
#line 751
        return (-1);
      }
    }
#line 674
    previous = previous->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 761
  bwb_freeline(l);
#line 763
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Failed to link line number");
#line 764
  bwb_error(bwb_ebuf);
  }
#line 771
  return (0);
}
}
#line 785 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
struct bwb_line *bwb_xtxtline(char *buffer ) 
{ 
  struct bwb_line *c ;
  char *p___0 ;
  int loop ;

  {
#line 804
  if (xtxtsc >= 16) {
    {
#line 806
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Exceeded maximum xtxt stack <%d>",
            xtxtsc);
    }
#line 808
    return (& bwb_end);
  }
#line 811
  xtxtsc ++;
#line 815
  p___0 = buffer;
#line 816
  loop = -1;
  {
#line 817
  while (1) {
    while_continue: /* CIL Label */ ;
#line 817
    if (! (loop == -1)) {
#line 817
      goto while_break;
    }
    {
#line 822
    if ((int )*p___0 == 0) {
#line 822
      goto case_0;
    }
#line 831
    if ((int )*p___0 == 9) {
#line 831
      goto case_9;
    }
#line 831
    if ((int )*p___0 == 32) {
#line 831
      goto case_9;
    }
#line 834
    goto switch_default;
    case_0: /* CIL Label */ 
#line 828
    xtxtsc --;
#line 829
    return (& bwb_end);
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 832
    p___0 ++;
#line 833
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 835
    loop = 0;
#line 836
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 859
  ln_asbuf(& (xtxts + xtxtsc)->l, buffer);
#line 869
  (xtxts + xtxtsc)->l.number = 0;
#line 870
  (xtxts + xtxtsc)->l.marked = 0;
#line 874
  (xtxts + xtxtsc)->l.next = & bwb_end;
#line 875
  c = & (xtxts + xtxtsc)->l;
#line 876
  c->position = 0;
#line 887
  bwb_incexec();
#line 888
  bwb_setexec(c, 0, 0);
#line 892
  xtxtsc --;
  }
#line 894
  return (c);
}
}
#line 908 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
extern void bwb_incexec(void) 
{ 


  {
#line 916
  exsc ++;
#line 918
  if (exsc >= 64) {
    {
#line 920
    exsc --;
#line 922
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_incexec(): incremented EXEC stack past max <%d>",
            64);
#line 924
    bwb_error(bwb_ebuf);
    }
  }
#line 930
  (excs + exsc)->while_line = (struct bwb_line *)((void *)0);
#line 931
  (excs + exsc)->wend_line = (struct bwb_line *)((void *)0);
#line 932
  (excs + exsc)->n_cvs = 0;
#line 933
  (excs + exsc)->local_variable = (struct bwb_variable *)((void *)0);
#line 935
  return;
}
}
#line 947 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
extern void bwb_decexec(void) 
{ 


  {
#line 958
  exsc --;
#line 960
  if (exsc < -1) {
    {
#line 962
    exsc = -1;
#line 964
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_decexec(): decremented EXEC stack past min <-1>");
#line 965
    bwb_error(bwb_ebuf);
    }
  }
#line 973
  if ((excs + exsc)->code == 13) {
    {
#line 979
    bwb_freeline((excs + exsc)->while_line);
#line 981
    bwb_decexec();
    }
  }
#line 984
  return;
}
}
#line 996 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
extern int bwb_setexec(struct bwb_line *l , int position___7 , int code ) 
{ 


  {
#line 1008
  (excs + exsc)->line = l;
#line 1009
  (excs + exsc)->position = position___7;
#line 1010
  (excs + exsc)->code = code;
#line 1012
  return (-1);
}
}
#line 1027 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
void bwb_mainloop(void) 
{ 


  {
#line 1034
  errfdevice = stderr;
#line 1035
  if (exsc > -1) {
    {
#line 1037
    bwb_execline();
    }
  } else {
    {
#line 1042
    bwb_interact();
    }
  }
#line 1045
  return;
}
}
#line 1057 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
void bwb_execline(void) 
{ 
  struct bwb_line *r ;
  struct bwb_line *l ;

  {
#line 1066
  l = (excs + exsc)->line;
#line 1070
  if ((unsigned long )l == (unsigned long )(& bwb_end)) {
#line 1072
    exsc = -1;
#line 1073
    return;
  }
#line 1112
  if (bwb_trace == -1) {
#line 1118
    if (l->number > 0) {
      {
#line 1120
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"[ %d ]",
              l->number);
#line 1121
      prn_xprintf(errfdevice, bwb_ebuf);
      }
    }
  }
  {
#line 1128
  number = l->number;
#line 1129
  bwb_l = l;
#line 1133
  adv_ws(l->buffer, & l->position);
  }
#line 1138
  if ((int )*(l->buffer + l->position) == 58) {
    {
#line 1140
    (l->position) ++;
#line 1141
    adv_ws(l->buffer, & l->position);
    }
  }
#line 1143
  l->marked = 0;
#line 1160
  if (l->marked != -1) {
    {
#line 1162
    line_start(l->buffer, & l->position, & l->lnpos, & l->lnum, & l->cmdpos, & l->cmdnum,
               & l->startpos);
#line 1164
    l->marked = -1;
    }
  } else
#line 1160
  if (l->position > l->startpos) {
    {
#line 1162
    line_start(l->buffer, & l->position, & l->lnpos, & l->lnum, & l->cmdpos, & l->cmdnum,
               & l->startpos);
#line 1164
    l->marked = -1;
    }
  }
#line 1174
  l->position = l->startpos;
#line 1186
  if (l->cmdnum > -1) {
    {
#line 1196
    r = (*(bwb_cmdtable[l->cmdnum].vector))(l);
    }
  } else {
    {
#line 1213
    bwx_shell(l);
#line 1214
    bwb_setexec(l->next, 0, (excs + exsc)->code);
    }
#line 1215
    return;
  }
  {
#line 1229
  adv_ws(r->buffer, & r->position);
  }
  {
#line 1234
  if ((int )*(r->buffer + r->position) == 0) {
#line 1234
    goto case_0;
  }
#line 1234
  if ((int )*(r->buffer + r->position) == 13) {
#line 1234
    goto case_0;
  }
#line 1234
  if ((int )*(r->buffer + r->position) == 10) {
#line 1234
    goto case_0;
  }
#line 1230
  goto switch_break;
  case_0: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  {
#line 1241
  (r->next)->position = 0;
#line 1242
  bwb_setexec(r->next, 0, (excs + exsc)->code);
  }
#line 1243
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1248
  bwb_setexec(r, r->position, (excs + exsc)->code);
  }
#line 1256
  return;
}
}
#line 1267 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
int ln_asbuf(struct bwb_line *l , char *s___0 ) 
{ 
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 1279
  if ((unsigned long )l->buffer != (unsigned long )((void *)0)) {
    {
#line 1282
    FREE((void *)l->buffer, (char *)"ln_asbuf");
#line 1283
    l->buffer = (char *)((void *)0);
    }
  }
  {
#line 1288
  tmp___0 = strlen((char const   *)s___0);
#line 1288
  tmp___1 = CALLOC(tmp___0 + 2UL, sizeof(char ), (char *)"ln_asbuf");
#line 1288
  tmp = (char *)tmp___1;
#line 1288
  l->buffer = tmp;
  }
#line 1288
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 1292
    bwb_error((char *)"in ln_asbuf(): failed to find memory for new line");
    }
#line 1296
    return (0);
  }
  {
#line 1301
  strcpy((char */* __restrict  */)l->buffer, (char const   */* __restrict  */)s___0);
#line 1310
  bwb_stripcr(l->buffer);
  }
#line 1317
  return (-1);
}
}
#line 1330 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
int bwb_gets(char *buffer ) 
{ 
  struct bwb_variable *v___0 ;
  char tbuf___20[5001] ;
  bstring *tmp ;

  {
  {
#line 1344
  number = 0;
#line 1346
  v___0 = var_find((char *)"BWB.PROMPT$");
#line 1347
  tmp = var_getsval(v___0);
#line 1347
  str_btoc(tbuf___20, tmp);
#line 1353
  bwx_input(tbuf___20, buffer);
  }
#line 1355
  return (-1);
}
}
#line 1378 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
static char *tmp_buffer  ;
#line 1379 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
static int init___0  =    0;
#line 1370 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
void break_mes(int x___0 ) 
{ 
  void *tmp ;

  {
#line 1383
  if (init___0 == 0) {
    {
#line 1385
    init___0 = -1;
#line 1388
    tmp = CALLOC((size_t )5001, sizeof(char ), (char *)"break_mes");
#line 1388
    tmp_buffer = (char *)tmp;
    }
#line 1388
    if ((unsigned long )tmp_buffer == (unsigned long )((void *)0)) {
      {
#line 1391
      bwb_error((char *)"in break_mes(): failed to find memory for tmp_buffer");
      }
    }
  }
  {
#line 1398
  expsc = 0;
#line 1400
  sprintf((char */* __restrict  */)tmp_buffer, (char const   */* __restrict  */)"\r%s %d\n",
          "Program interrupted at line", number);
#line 1401
  prn_xprintf(errfdevice, tmp_buffer);
#line 1403
  break_handler();
  }
#line 1405
  return;
}
}
#line 1417 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
void break_handler(void) 
{ 


  {
  {
#line 1429
  exsc = -1;
#line 1430
  expsc = 0;
#line 1431
  xtxtsc = 0;
#line 1432
  err_gosubl[0] = (char )'\000';
#line 1437
  signal(2, & break_mes);
#line 1441
  longjmp((struct __jmp_buf_tag *)(mark), -1);
  }
}
}
#line 1472 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
static int position  ;
#line 1464 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
int is_ln(char *buffer ) 
{ 


  {
  {
#line 1474
  position = 0;
#line 1475
  adv_ws(buffer, & position);
  }
  {
#line 1487
  if ((int )*(buffer + position) == 57) {
#line 1487
    goto case_57;
  }
#line 1487
  if ((int )*(buffer + position) == 56) {
#line 1487
    goto case_57;
  }
#line 1487
  if ((int )*(buffer + position) == 55) {
#line 1487
    goto case_57;
  }
#line 1487
  if ((int )*(buffer + position) == 54) {
#line 1487
    goto case_57;
  }
#line 1487
  if ((int )*(buffer + position) == 53) {
#line 1487
    goto case_57;
  }
#line 1487
  if ((int )*(buffer + position) == 52) {
#line 1487
    goto case_57;
  }
#line 1487
  if ((int )*(buffer + position) == 51) {
#line 1487
    goto case_57;
  }
#line 1487
  if ((int )*(buffer + position) == 50) {
#line 1487
    goto case_57;
  }
#line 1487
  if ((int )*(buffer + position) == 49) {
#line 1487
    goto case_57;
  }
#line 1487
  if ((int )*(buffer + position) == 48) {
#line 1487
    goto case_57;
  }
#line 1489
  goto switch_default;
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 1488
  return (-1);
  switch_default: /* CIL Label */ 
#line 1490
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1504 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
void *CALLOC(size_t nelem , size_t elsize , char *str ) 
{ 
  void *ptr ;

  {
  {
#line 1516
  ptr = calloc(nelem, elsize);
  }
#line 1518
  return (ptr);
}
}
#line 1530 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.c"
void FREE(void *ptr , char *str ) 
{ 


  {
  {
#line 1540
  free(ptr);
  }
#line 1541
  return;
}
}
#line 51 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_str.c"
int str_btob(bstring *d , bstring *s___0 ) 
{ 
  char *t___0 ;
  register int i ;
  void *tmp ;

  {
#line 84
  if ((unsigned long )d->sbuffer == (unsigned long )((void *)0)) {
#line 84
    goto _L;
  } else
#line 84
  if (d->rab == -1) {
    _L: /* CIL Label */ 
    {
#line 86
    tmp = CALLOC((size_t )5001, (size_t )1, (char *)"str_btob");
#line 86
    t___0 = (char *)tmp;
    }
#line 86
    if ((unsigned long )t___0 == (unsigned long )((void *)0)) {
      {
#line 89
      bwb_error((char *)"in str_btob(): failed to get memory for new buffer");
      }
#line 93
      return (0);
    }
  } else {
#line 96
    t___0 = d->sbuffer;
  }
#line 100
  *(t___0 + 0) = (char )'\000';
#line 101
  i = 0;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (i < (int )s___0->length)) {
#line 101
      goto while_break;
    }
#line 103
    *(t___0 + i) = *(s___0->sbuffer + i);
#line 104
    *(t___0 + (i + 1)) = (char )'\000';
#line 101
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  d->rab = 0;
#line 140
  d->sbuffer = t___0;
#line 144
  d->length = s___0->length;
#line 154
  return (-1);
}
}
#line 168 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_str.c"
int str_ctob(bstring *s___0 , char *buffer ) 
{ 
  char *t___0 ;
  register int i ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 203
  if ((unsigned long )s___0->sbuffer == (unsigned long )((void *)0)) {
#line 203
    goto _L;
  } else
#line 203
  if (s___0->rab == -1) {
    _L: /* CIL Label */ 
    {
#line 205
    tmp = CALLOC((size_t )5001, (size_t )1, (char *)"str_ctob");
#line 205
    t___0 = (char *)tmp;
    }
#line 205
    if ((unsigned long )t___0 == (unsigned long )((void *)0)) {
      {
#line 208
      bwb_error((char *)"in str_ctob(): failed to get memory for new buffer");
      }
#line 212
      return (0);
    }
  } else {
#line 215
    t___0 = s___0->sbuffer;
  }
#line 219
  *(t___0 + 0) = (char )'\000';
#line 220
  i = 0;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 220
    tmp___0 = strlen((char const   *)buffer);
    }
#line 220
    if (! (i < (int )tmp___0)) {
#line 220
      goto while_break;
    }
#line 222
    *(t___0 + i) = *(buffer + i);
#line 223
    *(t___0 + (i + 1)) = (char )'\000';
#line 220
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 251
  s___0->rab = 0;
#line 255
  s___0->sbuffer = t___0;
#line 260
  tmp___1 = strlen((char const   *)buffer);
#line 260
  s___0->length = (unsigned int )tmp___1;
  }
#line 270
  return (-1);
}
}
#line 284 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_str.c"
int str_btoc(char *buffer , bstring *s___0 ) 
{ 
  register int i ;

  {
#line 307
  *(buffer + 0) = (char )'\000';
#line 308
  i = 0;
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! (i < (int )s___0->length)) {
#line 308
      goto while_break;
    }
#line 310
    *(buffer + i) = *(s___0->sbuffer + i);
#line 311
    *(buffer + (i + 1)) = (char )'\000';
#line 312
    if (i >= 5000) {
#line 314
      i = (int )(s___0->length + 1U);
    }
#line 308
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 325
  return (-1);
}
}
#line 340 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_str.c"
char *str_cat(bstring *a , bstring *b___4 ) 
{ 
  char abuf[5001] ;
  char bbuf[5001] ;
  char *r ;

  {
  {
#line 353
  str_btoc(abuf, a);
#line 354
  str_btoc(bbuf, b___4);
#line 361
  strcat((char */* __restrict  */)(abuf), (char const   */* __restrict  */)(bbuf));
#line 362
  str_ctob(a, abuf);
  }
#line 369
  return (r);
}
}
#line 383 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_str.c"
int str_cmp(bstring *a , bstring *b___4 ) 
{ 
  char abuf[5001] ;
  char bbuf[5001] ;
  int tmp ;

  {
  {
#line 395
  str_btoc(abuf, a);
#line 396
  str_btoc(bbuf, b___4);
#line 398
  tmp = strcmp((char const   *)(abuf), (char const   *)(bbuf));
  }
#line 398
  return (tmp);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 869 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct bwb_line *bwb_xend(struct bwb_line *l ) ;
#line 879
struct bwb_line *bwb_if(struct bwb_line *l ) ;
#line 880
struct bwb_line *bwb_else(struct bwb_line *l ) ;
#line 881
struct bwb_line *bwb_elseif(struct bwb_line *l ) ;
#line 882
struct bwb_line *bwb_select(struct bwb_line *l ) ;
#line 883
struct bwb_line *bwb_case(struct bwb_line *l ) ;
#line 884
struct bwb_line *bwb_endselect(struct bwb_line *l ) ;
#line 885
struct bwb_line *bwb_endif(struct bwb_line *l ) ;
#line 886
struct bwb_line *bwb_while(struct bwb_line *l ) ;
#line 887
struct bwb_line *bwb_wend(struct bwb_line *l ) ;
#line 888
struct bwb_line *bwb_for(struct bwb_line *l ) ;
#line 889
struct bwb_line *bwb_next(struct bwb_line *l ) ;
#line 919
struct bwb_line *bwb_do(struct bwb_line *l ) ;
#line 925
struct bwb_line *bwb_loop(struct bwb_line *l ) ;
#line 927
struct bwb_line *bwb_exitfor(struct bwb_line *l ) ;
#line 930
extern struct bwb_line *bwb_zline(struct bwb_line *l ) ;
#line 944
struct exp_ese *bwb_exp(char *expression , int assignment , int *position___7 ) ;
#line 945
int exp_getvfname(char *source , char *destination ) ;
#line 980
int adv_eos(char *buffer , int *pos___2 ) ;
#line 986
extern int is_eol(char *buffer , int *position___7 ) ;
#line 990
extern struct bwb_line *find_loop(struct bwb_line *l ) ;
#line 1000
int bwb_strtoupper(char *buffer ) ;
#line 1001
int getcmdnum(char *cmdstr ) ;
#line 1042
bnumber var_getnval(struct bwb_variable *nvar___34 ) ;
#line 473 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mes.h"
char err_mismatch[14] ;
#line 44 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
static int cnd_thenels(char *buffer , int position___7 , int *then , int *els ) ;
#line 45
static int cnd_tostep(char *buffer , int position___7 , int *to , int *step ) ;
#line 46
static struct bwb_line *find_wend(struct bwb_line *l ) ;
#line 47
static struct bwb_line *find_endif(struct bwb_line *l , struct bwb_line **else_line___0 ) ;
#line 49
static int is_endif(struct bwb_line *l ) ;
#line 50
extern int var_setnval(struct bwb_variable *v___0 , bnumber i ) ;
#line 51
static int case_eval(struct exp_ese *expression , struct exp_ese *minval , struct exp_ese *maxval ) ;
#line 53
static struct bwb_line *find_case(struct bwb_line *l ) ;
#line 54
static struct bwb_line *find_endselect(struct bwb_line *l ) ;
#line 55
static int is_endselect(struct bwb_line *l ) ;
#line 56
static struct bwb_line *bwb_caseif(struct bwb_line *l ) ;
#line 59
static struct bwb_line *find_next(struct bwb_line *l ) ;
#line 107 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
static char tbuf[5001]  ;
#line 108 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
static struct bwb_line gline  ;
#line 110 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
static struct bwb_line *else_line  ;
#line 111 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
static struct bwb_line *endif_line  ;
#line 95 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
struct bwb_line *bwb_if(struct bwb_line *l ) 
{ 
  int then ;
  int els ;
  struct exp_ese *e___0 ;
  int glnumber ;
  int tpos ;
  size_t tmp ;
  struct bwb_line *tmp___0 ;
  bnumber tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  unsigned short const   **tmp___5 ;
  size_t tmp___6 ;
  bnumber tmp___7 ;

  {
  {
#line 132
  e___0 = bwb_exp(l->buffer, 0, & l->position);
#line 142
  cnd_thenels(l->buffer, l->position, & then, & els);
#line 154
  tmp = strlen("THEN");
#line 154
  tpos = (int )(((size_t )then + tmp) + 1UL);
#line 155
  tmp___2 = is_eol(l->buffer, & tpos);
  }
#line 155
  if (tmp___2 == -1) {
    {
#line 166
    else_line = (struct bwb_line *)((void *)0);
#line 167
    endif_line = find_endif(l, & else_line);
#line 171
    tmp___1 = exp_getnval(e___0);
    }
#line 171
    if ((int )tmp___1 != 0) {
      {
#line 173
      bwb_incexec();
#line 174
      bwb_setexec(l->next, 0, 6);
#line 177
      adv_eos(l->buffer, & l->position);
#line 179
      tmp___0 = bwb_zline(l);
      }
#line 179
      return (tmp___0);
    } else
#line 182
    if ((unsigned long )else_line != (unsigned long )((void *)0)) {
      {
#line 184
      bwb_incexec();
#line 185
      bwb_setexec(else_line, 0, 7);
#line 186
      else_line->position = 0;
      }
#line 187
      return (else_line);
    } else {
      {
#line 194
      bwb_incexec();
#line 195
      bwb_setexec(endif_line, 0, 7);
#line 196
      endif_line->position = 0;
      }
#line 197
      return (endif_line);
    }
  }
  {
#line 213
  tmp___7 = exp_getnval(e___0);
  }
#line 213
  if ((int )tmp___7 != 0) {
#line 221
    if (then == 0) {
      {
#line 224
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_if(): IF without THEN");
#line 225
      bwb_error(bwb_ebuf);
      }
    } else {
      {
#line 235
      tmp___3 = strlen("THEN");
#line 235
      tpos = (int )(((size_t )then + tmp___3) + 1UL);
#line 236
      adv_element(l->buffer, & tpos, tbuf);
#line 238
      tmp___5 = __ctype_b_loc();
      }
#line 238
      if (((int const   )*(*tmp___5 + (int )tbuf[0]) & 2048) != 0) {
        {
#line 241
        glnumber = atoi((char const   *)(tbuf));
#line 249
        sprintf((char */* __restrict  */)(tbuf), (char const   */* __restrict  */)"%s %d",
                "GOTO", glnumber);
#line 250
        gline.buffer = tbuf;
#line 251
        gline.marked = 0;
#line 252
        gline.position = 0;
#line 253
        gline.next = l->next;
#line 254
        bwb_setexec(& gline, 0, (excs + exsc)->code);
        }
#line 255
        return (& gline);
      } else {
        {
#line 262
        bwb_setexec(l, then, (excs + exsc)->code);
#line 263
        tmp___4 = strlen("THEN");
#line 263
        l->position = (int )(((size_t )then + tmp___4) + 1UL);
        }
      }
#line 266
      return (l);
    }
  } else
#line 277
  if (els != 0) {
    {
#line 279
    tmp___6 = strlen("ELSE");
#line 279
    l->position = (int )(((size_t )els + tmp___6) + 1UL);
#line 281
    bwb_setexec(l, els, (excs + exsc)->code);
    }
#line 282
    return (l);
  }
#line 289
  (l->next)->position = 0;
#line 290
  return (l->next);
}
}
#line 306 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
static int cnd_thenels(char *buffer , int position___7 , int *then , int *els ) 
{ 
  int loop ;
  int t_pos ;
  int b_pos ;
  int p_word ;
  char tbuf___20[5001] ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 328
  tmp = 0;
#line 328
  *els = tmp;
#line 328
  *then = tmp;
#line 332
  b_pos = position___7;
#line 332
  p_word = b_pos;
#line 333
  t_pos = 0;
#line 334
  tbuf___20[0] = (char )'\000';
#line 335
  loop = -1;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! (loop == -1)) {
#line 336
      goto while_break;
    }
    {
#line 343
    if ((int )*(buffer + b_pos) == 9) {
#line 343
      goto case_9;
    }
#line 343
    if ((int )*(buffer + b_pos) == 32) {
#line 343
      goto case_9;
    }
#line 343
    if ((int )*(buffer + b_pos) == 0) {
#line 343
      goto case_9;
    }
#line 394
    goto switch_default;
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 350
    tmp___2 = strlen("THEN");
#line 350
    tmp___3 = strncmp((char const   *)(tbuf___20), "THEN", tmp___2);
    }
#line 350
    if (tmp___3 == 0) {
#line 361
      *then = p_word;
    } else {
      {
#line 363
      tmp___0 = strlen("ELSE");
#line 363
      tmp___1 = strncmp((char const   *)(tbuf___20), "ELSE", tmp___0);
      }
#line 363
      if (tmp___1 == 0) {
#line 374
        *els = p_word;
      }
    }
#line 379
    if ((int )*(buffer + b_pos) == 0) {
#line 385
      return (-1);
    }
#line 388
    b_pos ++;
#line 389
    p_word = b_pos;
#line 390
    t_pos = 0;
#line 391
    tbuf___20[0] = (char )'\000';
#line 392
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 395
    tmp___5 = __ctype_b_loc();
    }
#line 395
    if (((int const   )*(*tmp___5 + (int )*(buffer + b_pos)) & 512) != 0) {
      {
#line 397
      tmp___4 = toupper((int )*(buffer + b_pos));
#line 397
      tbuf___20[t_pos] = (char )tmp___4;
      }
    } else {
#line 401
      tbuf___20[t_pos] = *(buffer + b_pos);
    }
#line 403
    b_pos ++;
#line 404
    t_pos ++;
#line 405
    tbuf___20[t_pos] = (char )'\000';
#line 406
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 416
  return (0);
}
}
#line 434 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
struct bwb_line *bwb_else(struct bwb_line *l ) 
{ 
  struct bwb_line *endif_line___0 ;
  struct bwb_line *else_line___0 ;
  struct bwb_line *tmp ;
  struct bwb_line *tmp___0 ;

  {
#line 471
  if ((excs + exsc)->code != 6) {
#line 471
    if ((excs + exsc)->code != 7) {
#line 480
      (l->next)->position = 0;
#line 481
      return (l->next);
    }
  }
  {
#line 484
  endif_line___0 = find_endif(l, & else_line___0);
  }
#line 486
  if ((excs + exsc)->code == 6) {
#line 488
    endif_line___0->position = 0;
#line 489
    return (endif_line___0);
  } else
#line 491
  if ((excs + exsc)->code == 7) {
    {
#line 494
    tmp = bwb_zline(l);
    }
#line 494
    return (tmp);
  }
  {
#line 498
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_else(): ELSE without IF");
#line 499
  bwb_error(bwb_ebuf);
#line 505
  tmp___0 = bwb_zline(l);
  }
#line 505
  return (tmp___0);
}
}
#line 520 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
struct bwb_line *bwb_elseif(struct bwb_line *l ) 
{ 
  struct bwb_line *endif_line___0 ;
  struct bwb_line *else_line___0 ;
  struct exp_ese *e___0 ;
  struct bwb_line *tmp ;
  bnumber tmp___0 ;
  struct bwb_line *tmp___1 ;

  {
  {
#line 537
  else_line___0 = (struct bwb_line *)((void *)0);
#line 538
  endif_line___0 = find_endif(l, & else_line___0);
  }
#line 540
  if ((excs + exsc)->code == 6) {
#line 542
    endif_line___0->position = 0;
#line 543
    return (endif_line___0);
  } else
#line 546
  if ((excs + exsc)->code == 7) {
    {
#line 552
    e___0 = bwb_exp(l->buffer, 0, & l->position);
#line 554
    tmp___0 = exp_getnval(e___0);
    }
#line 554
    if ((int )tmp___0 != 0) {
      {
#line 559
      (excs + exsc)->code = 6;
#line 562
      adv_eos(l->buffer, & l->position);
#line 564
      tmp = bwb_zline(l);
      }
#line 564
      return (tmp);
    } else
#line 570
    if ((unsigned long )else_line___0 != (unsigned long )((void *)0)) {
      {
#line 572
      bwb_setexec(else_line___0, 0, 7);
#line 573
      else_line___0->position = 0;
      }
#line 574
      return (else_line___0);
    } else {
      {
#line 581
      bwb_setexec(endif_line___0, 0, (excs + exsc)->code);
#line 582
      endif_line___0->position = 0;
      }
#line 583
      return (endif_line___0);
    }
  }
  {
#line 589
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_elseif(): ELSEIF without IF");
#line 590
  bwb_error(bwb_ebuf);
#line 597
  adv_eos(l->buffer, & l->position);
#line 599
  tmp___1 = bwb_zline(l);
  }
#line 599
  return (tmp___1);
}
}
#line 615 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
struct bwb_line *bwb_endif(struct bwb_line *l ) 
{ 
  struct bwb_line *tmp ;

  {
#line 629
  if ((excs + exsc)->code != 6) {
#line 629
    if ((excs + exsc)->code != 7) {
      {
#line 633
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_endif(): END IF without IF");
#line 634
      bwb_error(bwb_ebuf);
      }
    }
  }
  {
#line 640
  bwb_decexec();
#line 644
  adv_eos(l->buffer, & l->position);
#line 646
  tmp = bwb_zline(l);
  }
#line 646
  return (tmp);
}
}
#line 659 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
static struct bwb_line *find_endif(struct bwb_line *l , struct bwb_line **else_line___0 ) 
{ 
  struct bwb_line *current ;
  register int i_level ;
  int position___7 ;
  int tmp ;

  {
#line 672
  *else_line___0 = (struct bwb_line *)((void *)0);
#line 673
  i_level = 1;
#line 674
  current = l->next;
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;
#line 674
    if (! ((unsigned long )current != (unsigned long )(& bwb_end))) {
#line 674
      goto while_break;
    }
#line 676
    position___7 = 0;
#line 677
    if (current->marked != -1) {
      {
#line 679
      line_start(current->buffer, & position___7, & current->lnpos, & current->lnum,
                 & current->cmdpos, & current->cmdnum, & current->startpos);
      }
    }
#line 685
    current->position = current->startpos;
#line 687
    if (current->cmdnum > -1) {
#line 690
      if ((unsigned long )bwb_cmdtable[current->cmdnum].vector == (unsigned long )(& bwb_if)) {
#line 692
        i_level ++;
      } else {
        {
#line 701
        tmp = is_endif(current);
        }
#line 701
        if (tmp == -1) {
#line 703
          i_level --;
#line 711
          if (i_level == 0) {
#line 713
            return (current);
          }
        } else
#line 717
        if ((unsigned long )bwb_cmdtable[current->cmdnum].vector == (unsigned long )(& bwb_else)) {
#line 717
          goto _L;
        } else
#line 717
        if ((unsigned long )bwb_cmdtable[current->cmdnum].vector == (unsigned long )(& bwb_elseif)) {
          _L: /* CIL Label */ 
#line 724
          if (i_level == 1) {
#line 724
            if ((unsigned long )*else_line___0 == (unsigned long )((void *)0)) {
#line 726
              *else_line___0 = current;
            }
          }
        }
      }
    }
#line 674
    current = current->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 734
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Multiline IF without END IF");
#line 735
  bwb_error(bwb_ebuf);
  }
#line 740
  return ((struct bwb_line *)((void *)0));
}
}
#line 754 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
static int is_endif(struct bwb_line *l ) 
{ 
  int position___7 ;
  char tbuf___20[41] ;
  int tmp ;

  {
#line 765
  if ((unsigned long )bwb_cmdtable[l->cmdnum].vector != (unsigned long )(& bwb_xend)) {
#line 767
    return (0);
  }
  {
#line 770
  position___7 = l->startpos;
#line 771
  adv_ws(l->buffer, & position___7);
#line 772
  adv_element(l->buffer, & position___7, tbuf___20);
#line 773
  bwb_strtoupper(tbuf___20);
#line 775
  tmp = strcmp((char const   *)(tbuf___20), "IF");
  }
#line 775
  if (tmp == 0) {
#line 777
    return (-1);
  }
#line 780
  return (0);
}
}
#line 796 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
struct bwb_line *bwb_select(struct bwb_line *l ) 
{ 
  char tbuf___20[5001] ;
  struct exp_ese *e___0 ;
  int tmp ;
  struct bwb_line *tmp___0 ;

  {
  {
#line 814
  adv_element(l->buffer, & l->position, tbuf___20);
#line 815
  bwb_strtoupper(tbuf___20);
#line 816
  tmp = strcmp((char const   *)(tbuf___20), "CASE");
  }
#line 816
  if (tmp != 0) {
    {
#line 819
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"SELECT without CASE");
#line 820
    bwb_error(bwb_ebuf);
    }
  }
  {
#line 830
  bwb_incexec();
#line 831
  (excs + exsc)->code = 10;
#line 835
  e___0 = bwb_exp(l->buffer, 0, & l->position);
  }
#line 842
  if ((int )e___0->type == 36) {
    {
#line 844
    (excs + exsc)->expression.type = (char )'$';
#line 845
    str_btob(& (excs + exsc)->expression.sval, & e___0->sval);
    }
  } else {
    {
#line 850
    (excs + exsc)->expression.type = (char)1;
#line 851
    (excs + exsc)->expression.nval = exp_getnval(e___0);
    }
  }
  {
#line 858
  adv_eos(l->buffer, & l->position);
#line 861
  tmp___0 = bwb_zline(l);
  }
#line 861
  return (tmp___0);
}
}
#line 876 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
struct bwb_line *bwb_case(struct bwb_line *l ) 
{ 
  char tbuf___20[5001] ;
  int oldpos ;
  struct exp_ese minvalue ;
  struct exp_ese *maxval ;
  struct exp_ese *minval ;
  struct bwb_line *retline ;
  char cbuf1[5001] ;
  char cbuf2[5001] ;
  struct bwb_line *tmp ;
  struct bwb_line *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct bwb_line *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  struct bwb_line *tmp___7 ;
  int tmp___8 ;

  {
#line 899
  if ((excs + exsc)->code == 9) {
    {
#line 905
    retline = find_endselect(l);
#line 906
    retline->position = 0;
    }
#line 907
    return (retline);
  }
  {
#line 912
  oldpos = l->position;
#line 913
  adv_element(l->buffer, & l->position, tbuf___20);
#line 914
  bwb_strtoupper(tbuf___20);
#line 918
  tmp___2 = strcmp((char const   *)(tbuf___20), "IF");
  }
#line 918
  if (tmp___2 == 0) {
    {
#line 920
    tmp = bwb_caseif(l);
    }
#line 920
    return (tmp);
  } else {
    {
#line 926
    tmp___1 = strcmp((char const   *)(tbuf___20), "ELSE");
    }
#line 926
    if (tmp___1 == 0) {
      {
#line 933
      tmp___0 = bwb_zline(l);
      }
#line 933
      return (tmp___0);
    }
  }
  {
#line 938
  l->position = oldpos;
#line 939
  minval = bwb_exp(l->buffer, 0, & l->position);
#line 940
  memcpy((void */* __restrict  */)(& minvalue), (void const   */* __restrict  */)minval,
         sizeof(struct exp_ese ));
#line 941
  minval = & minvalue;
#line 941
  maxval = minval;
  }
#line 945
  if ((int )minvalue.type == 36) {
    {
#line 948
    str_btoc(cbuf1, & (excs + exsc)->expression.sval);
#line 949
    str_btoc(cbuf2, & minvalue.sval);
#line 957
    tmp___4 = strncmp((char const   *)(cbuf1), (char const   *)(cbuf2), (size_t )5000);
    }
#line 957
    if (tmp___4 == 0) {
      {
#line 963
      (excs + exsc)->code = 9;
#line 966
      adv_eos(l->buffer, & l->position);
#line 968
      tmp___3 = bwb_zline(l);
      }
#line 968
      return (tmp___3);
    } else {
      {
#line 977
      retline = find_case(l);
#line 978
      retline->position = 0;
      }
#line 979
      return (retline);
    }
  }
  {
#line 986
  adv_ws(l->buffer, & l->position);
#line 990
  tmp___6 = is_eol(l->buffer, & l->position);
  }
#line 990
  if (tmp___6 != -1) {
    {
#line 995
    adv_element(l->buffer, & l->position, tbuf___20);
#line 996
    bwb_strtoupper(tbuf___20);
#line 997
    tmp___5 = strcmp((char const   *)(tbuf___20), "TO");
    }
#line 997
    if (tmp___5 != 0) {
      {
#line 1000
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"CASE has inexplicable code following expression");
#line 1001
      bwb_error(bwb_ebuf);
      }
    }
    {
#line 1014
    maxval = bwb_exp(l->buffer, 0, & l->position);
    }
  }
  {
#line 1020
  tmp___8 = case_eval(& (excs + exsc)->expression, minval, maxval);
  }
#line 1020
  if (tmp___8 == -1) {
    {
#line 1027
    (excs + exsc)->code = 9;
#line 1030
    adv_eos(l->buffer, & l->position);
#line 1032
    tmp___7 = bwb_zline(l);
    }
#line 1032
    return (tmp___7);
  } else {
    {
#line 1043
    retline = find_case(l);
#line 1044
    retline->position = 0;
    }
#line 1045
    return (retline);
  }
}
}
#line 1060 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
static struct bwb_line *bwb_caseif(struct bwb_line *l ) 
{ 
  char tbuf___20[5001] ;
  int position___7 ;
  struct exp_ese *r ;
  struct bwb_line *retline ;
  struct bwb_line *tmp ;
  struct bwb_line *tmp___0 ;

  {
#line 1073
  if ((int )(excs + exsc)->expression.type == 1) {
    {
#line 1075
    sprintf((char */* __restrict  */)(tbuf___20), (char const   */* __restrict  */)"%f %s",
            (double )((float )(excs + exsc)->expression.nval), l->buffer + l->position);
    }
  } else {
    {
#line 1081
    bwb_error(err_mismatch);
#line 1083
    adv_eos(l->buffer, & l->position);
#line 1085
    tmp = bwb_zline(l);
    }
#line 1085
    return (tmp);
  }
  {
#line 1088
  position___7 = 0;
#line 1089
  r = bwb_exp(tbuf___20, 0, & position___7);
  }
#line 1091
  if (r->nval == (bnumber )-1) {
    {
#line 1093
    (excs + exsc)->code = 9;
#line 1096
    adv_eos(l->buffer, & l->position);
#line 1098
    tmp___0 = bwb_zline(l);
    }
#line 1098
    return (tmp___0);
  } else {
    {
#line 1102
    retline = find_case(l);
#line 1103
    retline->position = 0;
    }
#line 1104
    return (retline);
  }
}
}
#line 1121 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
static int case_eval(struct exp_ese *expression , struct exp_ese *minval , struct exp_ese *maxval ) 
{ 


  {
#line 1135
  if ((int )expression->type == 36) {
    {
#line 1137
    bwb_error(err_mismatch);
    }
#line 1138
    return (0);
  }
#line 1151
  if (expression->nval >= minval->nval) {
#line 1151
    if (expression->nval <= maxval->nval) {
#line 1154
      return (-1);
    }
  }
#line 1157
  return (0);
}
}
#line 1172 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
static struct bwb_line *find_case(struct bwb_line *l ) 
{ 
  struct bwb_line *current ;
  register int c_level ;
  int position___7 ;
  int tmp ;

  {
#line 1184
  c_level = 1;
#line 1185
  current = l->next;
  {
#line 1185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1185
    if (! ((unsigned long )current != (unsigned long )(& bwb_end))) {
#line 1185
      goto while_break;
    }
#line 1187
    position___7 = 0;
#line 1188
    if (current->marked != -1) {
      {
#line 1190
      line_start(current->buffer, & position___7, & current->lnpos, & current->lnum,
                 & current->cmdpos, & current->cmdnum, & current->startpos);
      }
    }
#line 1196
    current->position = current->startpos;
#line 1198
    if (current->cmdnum > -1) {
#line 1201
      if ((unsigned long )bwb_cmdtable[current->cmdnum].vector == (unsigned long )(& bwb_select)) {
#line 1203
        c_level ++;
      } else {
        {
#line 1212
        tmp = is_endselect(current);
        }
#line 1212
        if (tmp == -1) {
#line 1214
          c_level --;
#line 1222
          if (c_level == 0) {
#line 1224
            return (current);
          }
        } else
#line 1228
        if ((unsigned long )bwb_cmdtable[current->cmdnum].vector == (unsigned long )(& bwb_case)) {
#line 1230
          c_level --;
#line 1238
          if (c_level == 0) {
#line 1240
            return (current);
          }
        }
      }
    }
#line 1185
    current = current->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1247
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"SELECT without CASE");
#line 1248
  bwb_error(bwb_ebuf);
  }
#line 1253
  return ((struct bwb_line *)((void *)0));
}
}
#line 1268 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
static struct bwb_line *find_endselect(struct bwb_line *l ) 
{ 
  struct bwb_line *current ;
  register int c_level ;
  int position___7 ;
  int tmp ;

  {
#line 1280
  c_level = 1;
#line 1281
  current = l->next;
  {
#line 1281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1281
    if (! ((unsigned long )current != (unsigned long )(& bwb_end))) {
#line 1281
      goto while_break;
    }
#line 1283
    position___7 = 0;
#line 1284
    if (current->marked != -1) {
      {
#line 1286
      line_start(current->buffer, & position___7, & current->lnpos, & current->lnum,
                 & current->cmdpos, & current->cmdnum, & current->startpos);
      }
    }
#line 1292
    current->position = current->startpos;
#line 1294
    if (current->cmdnum > -1) {
#line 1297
      if ((unsigned long )bwb_cmdtable[current->cmdnum].vector == (unsigned long )(& bwb_select)) {
#line 1299
        c_level ++;
      } else {
        {
#line 1308
        tmp = is_endselect(current);
        }
#line 1308
        if (tmp == -1) {
#line 1310
          c_level --;
#line 1318
          if (c_level == 0) {
#line 1320
            return (current);
          }
        }
      }
    }
#line 1281
    current = current->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1327
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"SELECT without END SELECT");
#line 1328
  bwb_error(bwb_ebuf);
  }
#line 1333
  return ((struct bwb_line *)((void *)0));
}
}
#line 1347 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
static int is_endselect(struct bwb_line *l ) 
{ 
  int position___7 ;
  char tbuf___20[41] ;
  int tmp ;

  {
#line 1358
  if ((unsigned long )bwb_cmdtable[l->cmdnum].vector != (unsigned long )(& bwb_xend)) {
#line 1360
    return (0);
  }
  {
#line 1363
  position___7 = l->startpos;
#line 1364
  adv_ws(l->buffer, & position___7);
#line 1365
  adv_element(l->buffer, & position___7, tbuf___20);
#line 1366
  bwb_strtoupper(tbuf___20);
#line 1368
  tmp = strcmp((char const   *)(tbuf___20), "SELECT");
  }
#line 1368
  if (tmp == 0) {
#line 1370
    return (-1);
  }
#line 1373
  return (0);
}
}
#line 1389 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
struct bwb_line *bwb_endselect(struct bwb_line *l ) 
{ 
  struct bwb_line *tmp ;

  {
#line 1403
  if ((excs + exsc)->code != 9) {
#line 1403
    if ((excs + exsc)->code != 10) {
      {
#line 1407
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_endselect(): END SELECT without SELECT");
#line 1408
      bwb_error(bwb_ebuf);
      }
    }
  }
  {
#line 1414
  bwb_decexec();
#line 1418
  adv_eos(l->buffer, & l->position);
#line 1420
  tmp = bwb_zline(l);
  }
#line 1420
  return (tmp);
}
}
#line 1443 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
struct bwb_line *bwb_while(struct bwb_line *l ) 
{ 
  struct exp_ese *e___0 ;
  struct bwb_line *r ;
  int tmp ;
  struct bwb_line *tmp___0 ;
  struct bwb_line *tmp___1 ;
  bnumber tmp___2 ;

  {
#line 1456
  if ((unsigned long )(excs + exsc)->while_line != (unsigned long )l) {
    {
#line 1459
    bwb_incexec();
#line 1460
    (excs + exsc)->while_line = l;
#line 1465
    tmp = getcmdnum((char *)"DO");
    }
#line 1465
    if (l->cmdnum == tmp) {
      {
#line 1467
      (excs + exsc)->wend_line = find_loop(l);
      }
    } else {
      {
#line 1471
      (excs + exsc)->wend_line = find_wend(l);
      }
    }
#line 1477
    if ((unsigned long )(excs + exsc)->wend_line == (unsigned long )((void *)0)) {
      {
#line 1479
      tmp___0 = bwb_zline(l);
      }
#line 1479
      return (tmp___0);
    }
  }
  {
#line 1508
  e___0 = bwb_exp(l->buffer, 0, & l->position);
#line 1510
  tmp___2 = exp_getnval(e___0);
  }
#line 1510
  if ((int )tmp___2 != 0) {
    {
#line 1512
    bwb_setexec(l, l->position, 2);
#line 1513
    tmp___1 = bwb_zline(l);
    }
#line 1513
    return (tmp___1);
  } else {
    {
#line 1517
    (excs + exsc)->while_line = (struct bwb_line *)((void *)0);
#line 1518
    r = (excs + exsc)->wend_line;
#line 1519
    bwb_setexec(r, 0, (excs + (exsc - 1))->code);
#line 1520
    r->position = 0;
#line 1521
    bwb_decexec();
    }
#line 1522
    return (r);
  }
}
}
#line 1541 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
struct bwb_line *bwb_wend(struct bwb_line *l ) 
{ 


  {
#line 1552
  if ((excs + exsc)->code != 2) {
    {
#line 1555
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_wend(): exec stack code != EXEC_WHILE");
#line 1556
    bwb_error(bwb_ebuf);
    }
  }
#line 1562
  if ((unsigned long )(excs + exsc)->while_line == (unsigned long )((void *)0)) {
    {
#line 1565
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_wend(): exec stack while_line == NULL");
#line 1566
    bwb_error(bwb_ebuf);
    }
  }
  {
#line 1580
  ((excs + exsc)->while_line)->position = 0;
#line 1581
  bwb_setexec((excs + exsc)->while_line, 0, 2);
  }
#line 1583
  return ((excs + exsc)->while_line);
}
}
#line 1598 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
static struct bwb_line *find_wend(struct bwb_line *l ) 
{ 
  struct bwb_line *current ;
  register int w_level ;
  int position___7 ;

  {
#line 1610
  w_level = 1;
#line 1611
  current = l->next;
  {
#line 1611
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1611
    if (! ((unsigned long )current != (unsigned long )(& bwb_end))) {
#line 1611
      goto while_break;
    }
#line 1613
    position___7 = 0;
#line 1614
    if (current->marked != -1) {
      {
#line 1616
      line_start(current->buffer, & position___7, & current->lnpos, & current->lnum,
                 & current->cmdpos, & current->cmdnum, & current->startpos);
      }
    }
#line 1622
    current->position = current->startpos;
#line 1624
    if (current->cmdnum > -1) {
#line 1627
      if ((unsigned long )bwb_cmdtable[current->cmdnum].vector == (unsigned long )(& bwb_while)) {
#line 1629
        w_level ++;
      } else
#line 1638
      if ((unsigned long )bwb_cmdtable[current->cmdnum].vector == (unsigned long )(& bwb_wend)) {
#line 1640
        w_level --;
#line 1648
        if (w_level == 0) {
#line 1650
          return (current->next);
        }
      }
    }
#line 1611
    current = current->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1657
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in find_wend(): WHILE without WEND");
#line 1658
  bwb_error(bwb_ebuf);
  }
#line 1663
  return ((struct bwb_line *)((void *)0));
}
}
#line 1680 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
extern struct bwb_line *find_loop(struct bwb_line *l ) 
{ 
  struct bwb_line *current ;
  register int w_level ;
  int position___7 ;

  {
#line 1692
  w_level = 1;
#line 1693
  current = l->next;
  {
#line 1693
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1693
    if (! ((unsigned long )current != (unsigned long )(& bwb_end))) {
#line 1693
      goto while_break;
    }
#line 1695
    position___7 = 0;
#line 1696
    if (current->marked != -1) {
      {
#line 1698
      line_start(current->buffer, & position___7, & current->lnpos, & current->lnum,
                 & current->cmdpos, & current->cmdnum, & current->startpos);
      }
    }
#line 1704
    current->position = current->startpos;
#line 1706
    if (current->cmdnum > -1) {
#line 1709
      if ((unsigned long )bwb_cmdtable[current->cmdnum].vector == (unsigned long )(& bwb_do)) {
#line 1711
        w_level ++;
      } else
#line 1720
      if ((unsigned long )bwb_cmdtable[current->cmdnum].vector == (unsigned long )(& bwb_loop)) {
#line 1722
        w_level --;
#line 1730
        if (w_level == 0) {
#line 1732
          return (current->next);
        }
      }
    }
#line 1693
    current = current->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1739
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in find_loop(): DO without LOOP");
#line 1740
  bwb_error(bwb_ebuf);
  }
#line 1745
  return ((struct bwb_line *)((void *)0));
}
}
#line 1767 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
struct bwb_line *bwb_for(struct bwb_line *l ) 
{ 
  register int n___0 ;
  int e___0 ;
  int loop ;
  int to ;
  int step ;
  int p___0 ;
  int for_step ;
  int for_target ;
  struct exp_ese *exp___0 ;
  struct bwb_variable *v___0 ;
  char tbuf___20[5001] ;
  size_t tmp ;
  struct bwb_line *tmp___0 ;
  struct bwb_line *tmp___1 ;
  bnumber tmp___2 ;
  size_t tmp___3 ;
  bnumber tmp___4 ;
  size_t tmp___5 ;
  bnumber tmp___6 ;
  struct bwb_line *tmp___7 ;

  {
  {
#line 1785
  exp_getvfname(l->buffer + l->position, tbuf___20);
#line 1786
  tmp = strlen((char const   *)(tbuf___20));
#line 1786
  l->position = (int )((size_t )l->position + tmp);
#line 1787
  v___0 = var_find(tbuf___20);
  }
#line 1800
  if ((unsigned long )v___0 == (unsigned long )(excs + exsc)->local_variable) {
    {
#line 1800
    bwb_decexec();
    }
  }
  {
#line 1804
  adv_ws(l->buffer, & l->position);
  }
#line 1806
  if ((int )*(l->buffer + l->position) != 61) {
    {
#line 1809
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_for(): failed to find equals sign, buf <%s>",
            l->buffer + l->position);
#line 1811
    bwb_error(bwb_ebuf);
#line 1815
    tmp___0 = bwb_zline(l);
    }
#line 1815
    return (tmp___0);
  } else {
#line 1819
    (l->position) ++;
  }
  {
#line 1824
  cnd_tostep(l->buffer, l->position, & to, & step);
  }
#line 1828
  if (to < 1) {
    {
#line 1831
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"FOR statement without TO");
#line 1832
    bwb_error(bwb_ebuf);
#line 1836
    tmp___1 = bwb_zline(l);
    }
#line 1836
    return (tmp___1);
  }
#line 1841
  tbuf___20[0] = (char )'\000';
#line 1842
  p___0 = 0;
#line 1843
  n___0 = l->position;
  {
#line 1843
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1843
    if (! (n___0 < to)) {
#line 1843
      goto while_break;
    }
#line 1845
    tbuf___20[p___0] = *(l->buffer + n___0);
#line 1846
    p___0 ++;
#line 1847
    (l->position) ++;
#line 1848
    tbuf___20[p___0] = (char )'\000';
#line 1843
    n___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1857
  p___0 = 0;
#line 1858
  exp___0 = bwb_exp(tbuf___20, 0, & p___0);
#line 1859
  tmp___2 = exp_getnval(exp___0);
#line 1859
  var_setnval(v___0, tmp___2);
#line 1869
  tbuf___20[0] = (char )'\000';
#line 1870
  p___0 = 0;
#line 1871
  l->position = to + 2;
  }
#line 1872
  if (step < 1) {
    {
#line 1874
    tmp___3 = strlen((char const   *)l->buffer);
#line 1874
    e___0 = (int )tmp___3;
    }
  } else {
#line 1878
    e___0 = step - 1;
  }
#line 1881
  loop = -1;
#line 1882
  n___0 = l->position;
  {
#line 1883
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1883
    if (! (loop == -1)) {
#line 1883
      goto while_break___0;
    }
#line 1885
    tbuf___20[p___0] = *(l->buffer + n___0);
#line 1886
    p___0 ++;
#line 1887
    (l->position) ++;
#line 1888
    tbuf___20[p___0] = (char )'\000';
#line 1890
    if (n___0 >= e___0) {
#line 1892
      loop = 0;
    }
#line 1895
    n___0 ++;
#line 1897
    if ((int )*(l->buffer + n___0) == 58) {
#line 1899
      loop = 0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1910
  p___0 = 0;
#line 1911
  exp___0 = bwb_exp(tbuf___20, 0, & p___0);
#line 1912
  tmp___4 = exp_getnval(exp___0);
#line 1912
  for_target = (int )tmp___4;
  }
#line 1923
  if (step > 1) {
#line 1925
    tbuf___20[0] = (char )'\000';
#line 1926
    p___0 = 0;
#line 1927
    l->position = step + 4;
#line 1929
    n___0 = l->position;
    {
#line 1929
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1929
      tmp___5 = strlen((char const   *)l->buffer);
      }
#line 1929
      if (! (n___0 < (int )tmp___5)) {
#line 1929
        goto while_break___1;
      }
#line 1931
      tbuf___20[p___0] = *(l->buffer + n___0);
#line 1932
      p___0 ++;
#line 1933
      (l->position) ++;
#line 1934
      tbuf___20[p___0] = (char )'\000';
#line 1929
      n___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1943
    p___0 = 0;
#line 1944
    exp___0 = bwb_exp(tbuf___20, 0, & p___0);
#line 1945
    tmp___6 = exp_getnval(exp___0);
#line 1945
    for_step = (int )tmp___6;
    }
  } else {
#line 1950
    for_step = 1;
  }
  {
#line 1963
  bwb_incexec();
#line 1965
  (excs + exsc)->local_variable = v___0;
#line 1966
  (excs + exsc)->for_step = for_step;
#line 1967
  (excs + exsc)->for_target = for_target;
#line 1972
  (excs + exsc)->wend_line = find_next(l);
#line 1978
  (excs + exsc)->for_line = l;
#line 1979
  (excs + exsc)->for_position = l->position;
#line 1988
  bwb_setexec(l, l->position, 3);
#line 1998
  tmp___7 = bwb_zline(l);
  }
#line 1998
  return (tmp___7);
}
}
#line 2014 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
struct bwb_line *bwb_next(struct bwb_line *l ) 
{ 
  char tbuf___20[5001] ;
  struct bwb_variable *v___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  bnumber tmp___1 ;
  struct bwb_line *tmp___2 ;
  bnumber tmp___3 ;
  struct bwb_line *tmp___4 ;
  bnumber tmp___5 ;

  {
#line 2033
  if ((excs + exsc)->code != 3) {
    {
#line 2036
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_next(): NEXT without FOR; code is <%d> instead of <%d>",
            (excs + exsc)->code, 3);
#line 2038
    bwb_error(bwb_ebuf);
    }
  }
  {
#line 2047
  exp_getvfname(l->buffer + l->position, tbuf___20);
#line 2049
  tmp___0 = strlen((char const   *)(tbuf___20));
  }
#line 2049
  if (tmp___0 != 0UL) {
    {
#line 2052
    v___0 = var_find(tbuf___20);
#line 2056
    tmp = strlen((char const   *)(tbuf___20));
#line 2056
    l->position = (int )((size_t )l->position + tmp);
    }
    {
#line 2072
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2072
      if (! ((unsigned long )v___0 != (unsigned long )(excs + exsc)->local_variable)) {
#line 2072
        goto while_break;
      }
      {
#line 2072
      bwb_decexec();
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 2075
  tmp___1 = var_getnval((excs + exsc)->local_variable);
#line 2075
  var_setnval((excs + exsc)->local_variable, tmp___1 + (bnumber )(excs + exsc)->for_step);
  }
#line 2081
  if ((excs + exsc)->for_step > 0) {
    {
#line 2083
    tmp___3 = var_getnval((excs + exsc)->local_variable);
    }
#line 2083
    if ((int )tmp___3 > (excs + exsc)->for_target) {
      {
#line 2086
      bwb_decexec();
#line 2088
      bwb_setexec(l, l->position, (excs + exsc)->code);
#line 2102
      tmp___2 = bwb_zline(l);
      }
#line 2102
      return (tmp___2);
    }
  } else {
    {
#line 2108
    tmp___5 = var_getnval((excs + exsc)->local_variable);
    }
#line 2108
    if ((int )tmp___5 < (excs + exsc)->for_target) {
      {
#line 2111
      bwb_decexec();
#line 2112
      bwb_setexec(l->next, 0, (excs + exsc)->code);
#line 2123
      tmp___4 = bwb_zline(l);
      }
#line 2123
      return (tmp___4);
    }
  }
  {
#line 2137
  ((excs + exsc)->for_line)->position = (excs + exsc)->for_position;
#line 2139
  bwb_setexec((excs + exsc)->for_line, (excs + exsc)->for_position, 3);
  }
#line 2142
  return ((excs + exsc)->for_line);
}
}
#line 2169 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
struct bwb_line *bwb_exitfor(struct bwb_line *l ) 
{ 
  struct bwb_line *next_line ;
  int found ;
  register int level ;
  struct bwb_line *tmp ;

  {
#line 2188
  found = 0;
#line 2189
  level = exsc;
  {
#line 2190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2192
    if ((excs + level)->code == 3) {
#line 2194
      next_line = (excs + level)->wend_line;
#line 2195
      found = -1;
    } else {
#line 2199
      level --;
    }
#line 2190
    if (level >= 0) {
#line 2190
      if (! (found == 0)) {
#line 2190
        goto while_break;
      }
    } else {
#line 2190
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2204
  if (found != -1) {
    {
#line 2208
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_exitfor(): EXIT FOR without FOR");
#line 2209
    bwb_error(bwb_ebuf);
#line 2214
    tmp = bwb_zline(l);
    }
#line 2214
    return (tmp);
  }
  {
#line 2226
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2226
    if (! (exsc >= level)) {
#line 2226
      goto while_break___0;
    }
    {
#line 2228
    bwb_decexec();
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2233
  next_line->position = 0;
#line 2235
  bwb_setexec(next_line, 0, (excs + exsc)->code);
  }
#line 2237
  return (next_line);
}
}
#line 2252 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
static struct bwb_line *find_next(struct bwb_line *l ) 
{ 
  struct bwb_line *current ;
  register int w_level ;
  int position___7 ;

  {
#line 2264
  w_level = 1;
#line 2265
  current = l->next;
  {
#line 2265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2265
    if (! ((unsigned long )current != (unsigned long )(& bwb_end))) {
#line 2265
      goto while_break;
    }
#line 2267
    position___7 = 0;
#line 2268
    if (current->marked != -1) {
      {
#line 2270
      line_start(current->buffer, & position___7, & current->lnpos, & current->lnum,
                 & current->cmdpos, & current->cmdnum, & current->startpos);
      }
    }
#line 2276
    current->position = current->startpos;
#line 2278
    if (current->cmdnum > -1) {
#line 2281
      if ((unsigned long )bwb_cmdtable[current->cmdnum].vector == (unsigned long )(& bwb_for)) {
#line 2283
        w_level ++;
      } else
#line 2292
      if ((unsigned long )bwb_cmdtable[current->cmdnum].vector == (unsigned long )(& bwb_next)) {
#line 2294
        w_level --;
#line 2302
        if (w_level == 0) {
#line 2311
          return (current->next);
        }
      }
    }
#line 2265
    current = current->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2318
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"FOR without NEXT");
#line 2319
  bwb_error(bwb_ebuf);
  }
#line 2324
  return ((struct bwb_line *)((void *)0));
}
}
#line 2342 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
static int cnd_tostep(char *buffer , int position___7 , int *to , int *step ) 
{ 
  int loop ;
  int t_pos ;
  int b_pos ;
  int p_word ;
  char tbuf___20[5001] ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 2358
  tmp = 0;
#line 2358
  *step = tmp;
#line 2358
  *to = tmp;
#line 2362
  b_pos = position___7;
#line 2362
  p_word = b_pos;
#line 2363
  t_pos = 0;
#line 2364
  tbuf___20[0] = (char )'\000';
#line 2365
  loop = -1;
  {
#line 2366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2366
    if (! (loop == -1)) {
#line 2366
      goto while_break;
    }
    {
#line 2372
    if ((int )*(buffer + b_pos) == 58) {
#line 2372
      goto case_58;
    }
#line 2372
    if ((int )*(buffer + b_pos) == 0) {
#line 2372
      goto case_58;
    }
#line 2375
    if ((int )*(buffer + b_pos) == 9) {
#line 2375
      goto case_9;
    }
#line 2375
    if ((int )*(buffer + b_pos) == 32) {
#line 2375
      goto case_9;
    }
#line 2410
    goto switch_default;
    case_58: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 2373
    return (-1);
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
    {
#line 2382
    tmp___2 = strlen("TO");
#line 2382
    tmp___3 = strncmp((char const   *)(tbuf___20), "TO", tmp___2);
    }
#line 2382
    if (tmp___3 == 0) {
#line 2391
      *to = p_word;
    } else {
      {
#line 2393
      tmp___0 = strlen("STEP");
#line 2393
      tmp___1 = strncmp((char const   *)(tbuf___20), "STEP", tmp___0);
      }
#line 2393
      if (tmp___1 == 0) {
#line 2402
        *step = p_word;
      }
    }
#line 2404
    b_pos ++;
#line 2405
    p_word = b_pos;
#line 2406
    t_pos = 0;
#line 2407
    tbuf___20[0] = (char )'\000';
#line 2408
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2411
    tmp___5 = __ctype_b_loc();
    }
#line 2411
    if (((int const   )*(*tmp___5 + (int )*(buffer + b_pos)) & 512) != 0) {
      {
#line 2413
      tmp___4 = toupper((int )*(buffer + b_pos));
#line 2413
      tbuf___20[t_pos] = (char )tmp___4;
      }
    } else {
#line 2417
      tbuf___20[t_pos] = *(buffer + b_pos);
    }
#line 2419
    b_pos ++;
#line 2420
    t_pos ++;
#line 2421
    tbuf___20[t_pos] = (char )'\000';
#line 2422
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2427
  return (-1);
}
}
#line 2441 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cnd.c"
extern int var_setnval(struct bwb_variable *v___0 , bnumber i ) 
{ 
  bnumber *tmp ;

  {
  {
#line 2453
  if (v___0->type == 1) {
#line 2453
    goto case_1;
  }
#line 2456
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2454
  tmp = var_findnval(v___0, v___0->array_pos);
#line 2454
  *tmp = i;
  }
#line 2455
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2462
  bwb_error(err_mismatch);
  }
  switch_break: /* CIL Label */ ;
  }
#line 2468
  return (-1);
}
}
#line 573 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 813 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
int prn_col ;
#line 917
struct bwb_line *bwb_edit(struct bwb_line *l ) ;
#line 918
struct bwb_line *bwb_files(struct bwb_line *l ) ;
#line 1025
int bwx_message(char *m ) ;
#line 1026
int bwx_putc(char c ) ;
#line 1027
int bwx_errmes(char *m ) ;
#line 1063
struct bwb_line *bwb_renum(struct bwb_line *l ) ;
#line 461 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mes.h"
char err_getmem[22] ;
#line 108 "/home/june/collector/temp/bwbasic-2.20pl2/bwx_tty.c"
int bwx_signon(void) 
{ 


  {
  {
#line 116
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"\r%s %s\n",
          "Bywater BASIC Interpreter/Shell, version", "2.20 patch level 2");
#line 117
  prn_xprintf(stdout, bwb_ebuf);
#line 118
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"\r%s\n",
          "Copyright (c) 1993, Ted A. Campbell");
#line 119
  prn_xprintf(stdout, bwb_ebuf);
#line 120
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"\r%s\n",
          "Copyright (c) 1995-1997, Jon B. Volkoff");
#line 121
  prn_xprintf(stdout, bwb_ebuf);
#line 126
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"\r%s\n",
          " ");
#line 127
  prn_xprintf(stdout, bwb_ebuf);
  }
#line 130
  return (-1);
}
}
#line 144 "/home/june/collector/temp/bwbasic-2.20pl2/bwx_tty.c"
int bwx_message(char *m ) 
{ 


  {
  {
#line 157
  prn_xprintf(stdout, m);
  }
#line 159
  return (-1);
}
}
#line 173 "/home/june/collector/temp/bwbasic-2.20pl2/bwx_tty.c"
int bwx_putc(char c ) 
{ 
  int tmp ;

  {
  {
#line 182
  tmp = fputc((int )c, stdout);
  }
#line 182
  return (tmp);
}
}
#line 204 "/home/june/collector/temp/bwbasic-2.20pl2/bwx_tty.c"
static char tbuf___0[5001]  ;
#line 196 "/home/june/collector/temp/bwbasic-2.20pl2/bwx_tty.c"
int bwx_errmes(char *m ) 
{ 


  {
#line 208
  if (prn_col != 1) {
#line 208
    if ((unsigned long )errfdevice == (unsigned long )stderr) {
      {
#line 210
      prn_xprintf(errfdevice, (char *)"\n");
      }
    }
  }
#line 212
  if (number == 0) {
    {
#line 214
    sprintf((char */* __restrict  */)(tbuf___0), (char const   */* __restrict  */)"\n%s: %s\n",
            "ERROR", m);
    }
  } else {
    {
#line 218
    sprintf((char */* __restrict  */)(tbuf___0), (char const   */* __restrict  */)"\n%s %d: %s\n",
            "ERROR in line", number, m);
    }
  }
  {
#line 225
  prn_xprintf(errfdevice, tbuf___0);
  }
#line 227
  return (-1);
}
}
#line 242 "/home/june/collector/temp/bwbasic-2.20pl2/bwx_tty.c"
int bwx_input(char *prompt , char *buffer ) 
{ 
  int *tmp ;

  {
  {
#line 256
  prn_xprintf(stdout, prompt);
#line 258
  fgets((char */* __restrict  */)buffer, 256, (FILE */* __restrict  */)stdin);
#line 259
  tmp = prn_getcol(stdout);
#line 259
  *tmp = 1;
  }
#line 261
  return (-1);
}
}
#line 274 "/home/june/collector/temp/bwbasic-2.20pl2/bwx_tty.c"
void bwx_terminate(void) 
{ 


  {
  {
#line 281
  exit(0);
  }
}
}
#line 303 "/home/june/collector/temp/bwbasic-2.20pl2/bwx_tty.c"
static char *s_buffer___0  ;
#line 304 "/home/june/collector/temp/bwbasic-2.20pl2/bwx_tty.c"
static int init___1  =    0;
#line 305 "/home/june/collector/temp/bwbasic-2.20pl2/bwx_tty.c"
static int position___0  ;
#line 295 "/home/june/collector/temp/bwbasic-2.20pl2/bwx_tty.c"
extern int bwx_shell(struct bwb_line *l ) 
{ 
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 309
  if (init___1 == 0) {
    {
#line 311
    init___1 = -1;
#line 314
    tmp = CALLOC((size_t )5001, sizeof(char ), (char *)"bwx_shell");
#line 314
    s_buffer___0 = (char *)tmp;
    }
#line 314
    if ((unsigned long )s_buffer___0 == (unsigned long )((void *)0)) {
      {
#line 316
      bwb_error(err_getmem);
      }
#line 317
      return (0);
    }
  }
  {
#line 328
  position___0 = 0;
#line 329
  adv_element(l->buffer, & position___0, s_buffer___0);
#line 330
  tmp___2 = is_numconst(s_buffer___0);
  }
#line 330
  if (tmp___2 != -1) {
    {
#line 339
    tmp___0 = system((char const   *)l->buffer);
    }
#line 339
    if (tmp___0 == 0) {
#line 341
      return (-1);
    } else {
#line 345
      return (0);
    }
  } else {
    {
#line 351
    adv_ws(l->buffer, & position___0);
#line 359
    tmp___1 = system((char const   *)(l->buffer + position___0));
    }
#line 359
    if (tmp___1 == 0) {
#line 361
      return (-1);
    } else {
#line 365
      return (0);
    }
  }
}
}
#line 383 "/home/june/collector/temp/bwbasic-2.20pl2/bwx_tty.c"
int matherr(struct exception *except ) 
{ 


  {
  {
#line 392
  perror("ERROR");
#line 393
  break_handler();
  }
#line 395
  return (0);
}
}
#line 413 "/home/june/collector/temp/bwbasic-2.20pl2/bwx_tty.c"
struct bwb_line *bwb_edit(struct bwb_line *l ) 
{ 
  char tbuf___20[5001] ;
  char edname[5001] ;
  struct bwb_variable *ed___0 ;
  FILE *loadfile ;
  bstring *tmp ;
  struct bwb_line *tmp___0 ;
  struct bwb_line *tmp___1 ;

  {
  {
#line 426
  ed___0 = var_find((char *)"BWB.EDITOR$");
#line 427
  tmp = var_getsval(ed___0);
#line 427
  str_btoc(edname, tmp);
#line 429
  sprintf((char */* __restrict  */)(tbuf___20), (char const   */* __restrict  */)"%s %s",
          edname, progfile);
#line 435
  system((char const   *)(tbuf___20));
#line 440
  loadfile = fopen((char const   */* __restrict  */)(progfile), (char const   */* __restrict  */)"r");
  }
#line 440
  if ((unsigned long )loadfile == (unsigned long )((void *)0)) {
    {
#line 442
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)(err_openfile),
            progfile);
#line 443
    bwb_error(bwb_ebuf);
#line 445
    tmp___0 = bwb_zline(l);
    }
#line 445
    return (tmp___0);
  }
  {
#line 450
  bwb_new(l);
#line 454
  bwb_fload(loadfile);
#line 457
  tmp___1 = bwb_zline(l);
  }
#line 457
  return (tmp___1);
}
}
#line 474 "/home/june/collector/temp/bwbasic-2.20pl2/bwx_tty.c"
struct bwb_line *bwb_renum(struct bwb_line *l ) 
{ 
  char tbuf___20[5001] ;
  FILE *loadfile ;
  struct bwb_line *tmp ;
  struct bwb_line *tmp___0 ;

  {
  {
#line 485
  sprintf((char */* __restrict  */)(tbuf___20), (char const   */* __restrict  */)"renum %s\000",
          progfile);
#line 491
  system((char const   *)(tbuf___20));
#line 496
  loadfile = fopen((char const   */* __restrict  */)(progfile), (char const   */* __restrict  */)"r");
  }
#line 496
  if ((unsigned long )loadfile == (unsigned long )((void *)0)) {
    {
#line 498
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)(err_openfile),
            progfile);
#line 499
    bwb_error(bwb_ebuf);
#line 501
    tmp = bwb_zline(l);
    }
#line 501
    return (tmp);
  }
  {
#line 506
  bwb_new(l);
#line 510
  bwb_fload(loadfile);
#line 513
  tmp___0 = bwb_zline(l);
  }
#line 513
  return (tmp___0);
}
}
#line 530 "/home/june/collector/temp/bwbasic-2.20pl2/bwx_tty.c"
struct bwb_line *bwb_files(struct bwb_line *l ) 
{ 
  char tbuf___20[41] ;
  char finame[41] ;
  char argument[41] ;
  struct bwb_variable *fi___0 ;
  struct exp_ese *e___0 ;
  bstring *tmp ;
  struct bwb_line *tmp___0 ;
  bstring *tmp___1 ;
  struct bwb_line *tmp___2 ;

  {
  {
#line 544
  fi___0 = var_find((char *)"BWB.FILES$");
#line 545
  tmp = var_getsval(fi___0);
#line 545
  str_btoc(finame, tmp);
#line 549
  adv_ws(l->buffer, & l->position);
  }
  {
#line 554
  if ((int )*(l->buffer + l->position) == 10) {
#line 554
    goto case_10;
  }
#line 554
  if ((int )*(l->buffer + l->position) == 13) {
#line 554
    goto case_10;
  }
#line 554
  if ((int )*(l->buffer + l->position) == 0) {
#line 554
    goto case_10;
  }
#line 557
  goto switch_default;
  case_10: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 555
  argument[0] = (char )'\000';
#line 556
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 558
  e___0 = bwb_exp(l->buffer, 0, & l->position);
  }
#line 559
  if ((int )e___0->type != 36) {
    {
#line 561
    bwb_error(err_mismatch);
#line 562
    tmp___0 = bwb_zline(l);
    }
#line 562
    return (tmp___0);
  }
  {
#line 564
  tmp___1 = exp_getsval(e___0);
#line 564
  str_btoc(argument, tmp___1);
  }
#line 565
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 569
  sprintf((char */* __restrict  */)(tbuf___20), (char const   */* __restrict  */)"%s %s",
          finame, argument);
#line 575
  system((char const   *)(tbuf___20));
#line 578
  tmp___2 = bwb_zline(l);
  }
#line 578
  return (tmp___2);
}
}
#line 947 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
int inc_esc(void) ;
#line 950
struct bwb_function *fnc_find(char *buffer ) ;
#line 963
extern struct bwb_variable *var_islocal(char *buffer ) ;
#line 1008
int exp_findop(char *expression ) ;
#line 1009
int exp_isop(char *expression ) ;
#line 1010
int exp_isfn(char *expression ) ;
#line 1011
int exp_isufn(char *expression ) ;
#line 1012
int exp_isnc(char *expression ) ;
#line 1013
int exp_isvn(char *expression ) ;
#line 1014
int exp_iscmd(char *expression ) ;
#line 1015
int exp_paren(char *expression ) ;
#line 1016
int exp_strconst(char *expression ) ;
#line 1017
int exp_numconst(char *expression ) ;
#line 1018
int exp_function(char *expression ) ;
#line 1019
int exp_ufnc(char *expression ) ;
#line 1020
int exp_variable(char *expression ) ;
#line 1021
int exp_validarg(char *expression ) ;
#line 48 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_exp.c"
struct exp_ese *bwb_exp(char *expression , int assignment , int *position___7 ) 
{ 
  struct exp_ese *rval ;
  int entry_level ;
  int main_loop ;
  int err_condition ;
  char *e___0 ;
  int r ;
  register int c ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 76
  entry_level = expsc;
#line 77
  err_condition = 0;
#line 82
  if ((int )*(expression + *position___7) == 58) {
#line 84
    (*position___7) ++;
  }
  {
#line 87
  adv_ws(expression, position___7);
  }
#line 89
  if ((int )*(expression + *position___7) == 58) {
    {
#line 91
    (*position___7) ++;
#line 92
    adv_ws(expression, position___7);
    }
  }
  {
#line 98
  inc_esc();
#line 103
  tmp = is_eol(expression, position___7);
  }
#line 103
  if (tmp == -1) {
#line 105
    main_loop = 0;
  } else {
#line 109
    main_loop = -1;
#line 110
    (exps + expsc)->pos_adv = 0;
  }
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! (main_loop == -1)) {
#line 139
      goto while_break;
    }
    {
#line 144
    e___0 = expression + *position___7;
#line 154
    (exps + expsc)->operation = exp_findop(e___0);
    }
    {
#line 166
    if ((exps + expsc)->operation == -255) {
#line 166
      goto case_neg_255;
    }
#line 176
    if ((exps + expsc)->operation == 16) {
#line 176
      goto case_16;
    }
#line 176
    if ((exps + expsc)->operation == 15) {
#line 176
      goto case_16;
    }
#line 176
    if ((exps + expsc)->operation == 31) {
#line 176
      goto case_16;
    }
#line 200
    if ((exps + expsc)->operation == 14) {
#line 200
      goto case_14;
    }
#line 200
    if ((exps + expsc)->operation == 30) {
#line 200
      goto case_14;
    }
#line 200
    if ((exps + expsc)->operation == 29) {
#line 200
      goto case_14;
    }
#line 200
    if ((exps + expsc)->operation == 28) {
#line 200
      goto case_14;
    }
#line 200
    if ((exps + expsc)->operation == 27) {
#line 200
      goto case_14;
    }
#line 200
    if ((exps + expsc)->operation == 26) {
#line 200
      goto case_14;
    }
#line 200
    if ((exps + expsc)->operation == 25) {
#line 200
      goto case_14;
    }
#line 200
    if ((exps + expsc)->operation == 20) {
#line 200
      goto case_14;
    }
#line 200
    if ((exps + expsc)->operation == 23) {
#line 200
      goto case_14;
    }
#line 200
    if ((exps + expsc)->operation == 24) {
#line 200
      goto case_14;
    }
#line 200
    if ((exps + expsc)->operation == 21) {
#line 200
      goto case_14;
    }
#line 200
    if ((exps + expsc)->operation == 22) {
#line 200
      goto case_14;
    }
#line 200
    if ((exps + expsc)->operation == 13) {
#line 200
      goto case_14;
    }
#line 200
    if ((exps + expsc)->operation == 12) {
#line 200
      goto case_14;
    }
#line 200
    if ((exps + expsc)->operation == 11) {
#line 200
      goto case_14;
    }
#line 200
    if ((exps + expsc)->operation == 10) {
#line 200
      goto case_14;
    }
#line 200
    if ((exps + expsc)->operation == 9) {
#line 200
      goto case_14;
    }
#line 200
    if ((exps + expsc)->operation == 8) {
#line 200
      goto case_14;
    }
#line 200
    if ((exps + expsc)->operation == 7) {
#line 200
      goto case_14;
    }
#line 225
    if ((exps + expsc)->operation == 17) {
#line 225
      goto case_17;
    }
#line 239
    if ((exps + expsc)->operation == 6) {
#line 239
      goto case_6;
    }
#line 243
    if ((exps + expsc)->operation == 2) {
#line 243
      goto case_2;
    }
#line 247
    if ((exps + expsc)->operation == 3) {
#line 247
      goto case_3;
    }
#line 256
    if ((exps + expsc)->operation == 4) {
#line 256
      goto case_4;
    }
#line 267
    if ((exps + expsc)->operation == 32) {
#line 267
      goto case_32;
    }
#line 285
    if ((exps + expsc)->operation == 5) {
#line 285
      goto case_5;
    }
#line 289
    goto switch_default;
    case_neg_255: /* CIL Label */ 
#line 167
    main_loop = 0;
#line 168
    err_condition = -1;
#line 169
    goto switch_break;
    case_16: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_31: /* CIL Label */ 
    {
#line 177
    main_loop = 0;
#line 178
    err_condition = 0;
#line 179
    dec_esc();
    }
#line 180
    goto switch_break;
    case_14: /* CIL Label */ 
    case_30: /* CIL Label */ 
    case_29: /* CIL Label */ 
    case_28: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_20: /* CIL Label */ 
    case_23: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_21: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_7: /* CIL Label */ 
#line 207
    (exps + expsc)->pos_adv = -1;
#line 211
    c = 0;
    {
#line 211
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 211
      if (! (c < 25)) {
#line 211
        goto while_break___0;
      }
#line 213
      if (exp_ops[c].operation == (exps + expsc)->operation) {
        {
#line 215
        tmp___0 = strlen((char const   *)(exp_ops[c].symbol));
#line 215
        (exps + expsc)->pos_adv = (int )tmp___0;
        }
      }
#line 211
      c ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 219
    if ((exps + expsc)->pos_adv == -1) {
#line 221
      (exps + expsc)->pos_adv = 0;
    }
#line 223
    goto switch_break;
    case_17: /* CIL Label */ 
#line 232
    if (assignment == -1) {
#line 234
      (exps + expsc)->operation = 18;
    }
#line 236
    (exps + expsc)->pos_adv = 1;
#line 237
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 240
    r = exp_paren(e___0);
    }
#line 241
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 244
    r = exp_strconst(e___0);
    }
#line 245
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 248
    r = exp_numconst(e___0);
    }
#line 254
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 264
    r = exp_function(e___0);
    }
#line 265
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 275
    r = exp_ufnc(e___0);
    }
#line 283
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 286
    r = exp_variable(e___0);
    }
#line 287
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 290
    err_condition = -1;
#line 291
    main_loop = 0;
#line 293
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_exp.c:bwb_exp(): unidentified operation (%d).",
            (exps + expsc)->operation);
#line 295
    bwb_error(bwb_ebuf);
    }
#line 299
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 304
    *position___7 += (exps + expsc)->pos_adv;
#line 305
    (exps + expsc)->pos_adv = 0;
#line 323
    tmp___1 = is_eol(expression, position___7);
    }
#line 323
    if (tmp___1 == -1) {
#line 325
      main_loop = 0;
    }
#line 353
    if (main_loop == -1) {
      {
#line 355
      r = inc_esc();
      }
    }
#line 365
    if (r == -255) {
#line 371
      main_loop = 0;
#line 372
      err_condition = -1;
    } else {
#line 376
      r = -1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  if (err_condition == -1) {
    {
#line 399
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 399
      if (! (expsc > entry_level)) {
#line 399
        goto while_break___1;
      }
      {
#line 401
      dec_esc();
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 405
    bwb_error((char *)"in bwb_exp():  Error detected in parsing expression");
    }
  } else {
    {
#line 421
    exp_operation(entry_level);
    }
#line 425
    if (expsc > entry_level + 1) {
      {
#line 429
      if ((exps + expsc)->operation == 15) {
#line 429
        goto case_15___0;
      }
#line 440
      goto switch_default___0;
      case_15___0: /* CIL Label */ 
#line 430
      if (expsc != entry_level + 2) {
        {
#line 433
        sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_exp(): OP_STRJOIN in wrong position.");
#line 434
        bwb_error(bwb_ebuf);
        }
      }
#line 439
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 442
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_exp(): incomplete expression.");
#line 443
      bwb_error(bwb_ebuf);
      }
#line 447
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 458
      dec_esc();
      }
    }
    {
#line 464
    rval = exps + expsc;
#line 468
    dec_esc();
    }
#line 472
    if (entry_level != expsc) {
      {
#line 475
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_exp(): exit stack level (%d) does not match entry stack level (%d)",
              expsc, entry_level);
#line 477
      bwb_error(bwb_ebuf);
      }
    }
  }
#line 487
  return (rval);
}
}
#line 501 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_exp.c"
int exp_findop(char *expression ) 
{ 
  register int c ;
  int carry_on ;
  int rval ;
  char cbuf[5001] ;
  char nbuf[5001] ;
  int position___7 ;
  int adv_loop ;
  char tmp ;
  char tmp___0 ;

  {
  {
#line 524
  rval = 0;
#line 528
  position___7 = 0;
#line 532
  adv_ws(expression, & position___7);
#line 548
  carry_on = -1;
  }
  {
#line 551
  if ((int )*(expression + position___7) == 34) {
#line 551
    goto case_34;
  }
#line 554
  if ((int )*(expression + position___7) == 40) {
#line 554
    goto case_40;
  }
#line 561
  if ((int )*(expression + position___7) == 41) {
#line 561
    goto case_41;
  }
#line 561
  if ((int )*(expression + position___7) == 58) {
#line 561
    goto case_41;
  }
#line 576
  if ((int )*(expression + position___7) == 38) {
#line 576
    goto case_38;
  }
#line 576
  if ((int )*(expression + position___7) == 46) {
#line 576
    goto case_38;
  }
#line 576
  if ((int )*(expression + position___7) == 57) {
#line 576
    goto case_38;
  }
#line 576
  if ((int )*(expression + position___7) == 56) {
#line 576
    goto case_38;
  }
#line 576
  if ((int )*(expression + position___7) == 55) {
#line 576
    goto case_38;
  }
#line 576
  if ((int )*(expression + position___7) == 54) {
#line 576
    goto case_38;
  }
#line 576
  if ((int )*(expression + position___7) == 53) {
#line 576
    goto case_38;
  }
#line 576
  if ((int )*(expression + position___7) == 52) {
#line 576
    goto case_38;
  }
#line 576
  if ((int )*(expression + position___7) == 51) {
#line 576
    goto case_38;
  }
#line 576
  if ((int )*(expression + position___7) == 50) {
#line 576
    goto case_38;
  }
#line 576
  if ((int )*(expression + position___7) == 49) {
#line 576
    goto case_38;
  }
#line 576
  if ((int )*(expression + position___7) == 48) {
#line 576
    goto case_38;
  }
#line 549
  goto switch_break;
  case_34: /* CIL Label */ 
#line 552
  rval = 2;
#line 553
  goto switch_break;
  case_40: /* CIL Label */ 
#line 555
  rval = 6;
#line 556
  goto switch_break;
  case_41: /* CIL Label */ 
  case_58: /* CIL Label */ 
#line 562
  rval = 31;
#line 563
  goto switch_break;
  case_38: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 577
  rval = 3;
#line 578
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 596
  adv_loop = -1;
#line 597
  cbuf[0] = (char )'\000';
#line 598
  nbuf[0] = (char )'\000';
#line 599
  c = 0;
  {
#line 600
  while (1) {
    while_continue: /* CIL Label */ ;
#line 600
    if (! (adv_loop == -1)) {
#line 600
      goto while_break;
    }
    {
#line 616
    if ((int )*(expression + position___7) == 40) {
#line 616
      goto case_40___0;
    }
#line 616
    if ((int )*(expression + position___7) == 0) {
#line 616
      goto case_40___0;
    }
#line 616
    if ((int )*(expression + position___7) == 10) {
#line 616
      goto case_40___0;
    }
#line 616
    if ((int )*(expression + position___7) == 13) {
#line 616
      goto case_40___0;
    }
#line 616
    if ((int )*(expression + position___7) == 9) {
#line 616
      goto case_40___0;
    }
#line 616
    if ((int )*(expression + position___7) == 32) {
#line 616
      goto case_40___0;
    }
#line 619
    goto switch_default;
    case_40___0: /* CIL Label */ 
    case_0: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 617
    adv_loop = 0;
#line 618
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 620
    tmp = *(expression + position___7);
#line 620
    cbuf[c] = tmp;
#line 620
    nbuf[c] = tmp;
#line 621
    c ++;
#line 622
    tmp___0 = (char )'\000';
#line 622
    cbuf[c] = tmp___0;
#line 622
    nbuf[c] = tmp___0;
#line 623
    position___7 ++;
#line 624
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 627
    if (c >= 5000) {
#line 629
      adv_loop = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 633
  bwb_strtoupper(cbuf);
  }
#line 642
  if (rval == 0) {
    {
#line 644
    rval = exp_isnc(cbuf);
    }
  }
#line 649
  if (rval == 0) {
    {
#line 651
    rval = exp_isop(cbuf);
    }
  }
#line 656
  if (rval == 0) {
    {
#line 658
    rval = exp_isufn(nbuf);
    }
  }
#line 663
  if (rval == 0) {
    {
#line 665
    rval = exp_isfn(nbuf);
    }
  }
#line 670
  if (rval == 0) {
    {
#line 672
    rval = exp_iscmd(cbuf);
    }
  }
#line 678
  if (rval == 0) {
    {
#line 680
    rval = exp_isvn(nbuf);
    }
  }
#line 685
  if (rval == 0) {
#line 687
    return (-255);
  } else {
#line 691
    return (rval);
  }
}
}
#line 707 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_exp.c"
int exp_isnc(char *expression ) 
{ 
  char tbuf___20[41] ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 729
  if ((int )*(expression + 0) == 38) {
#line 729
    goto case_38;
  }
#line 729
  if ((int )*(expression + 0) == 57) {
#line 729
    goto case_38;
  }
#line 729
  if ((int )*(expression + 0) == 56) {
#line 729
    goto case_38;
  }
#line 729
  if ((int )*(expression + 0) == 55) {
#line 729
    goto case_38;
  }
#line 729
  if ((int )*(expression + 0) == 54) {
#line 729
    goto case_38;
  }
#line 729
  if ((int )*(expression + 0) == 53) {
#line 729
    goto case_38;
  }
#line 729
  if ((int )*(expression + 0) == 52) {
#line 729
    goto case_38;
  }
#line 729
  if ((int )*(expression + 0) == 51) {
#line 729
    goto case_38;
  }
#line 729
  if ((int )*(expression + 0) == 50) {
#line 729
    goto case_38;
  }
#line 729
  if ((int )*(expression + 0) == 49) {
#line 729
    goto case_38;
  }
#line 729
  if ((int )*(expression + 0) == 48) {
#line 729
    goto case_38;
  }
#line 732
  if ((int )*(expression + 0) == 45) {
#line 732
    goto case_45;
  }
#line 732
  if ((int )*(expression + 0) == 43) {
#line 732
    goto case_45;
  }
#line 781
  goto switch_default;
  case_38: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 730
  return (3);
  case_45: /* CIL Label */ 
  case_43: /* CIL Label */ 
#line 739
  if ((exps + (expsc - 1))->operation == 1) {
#line 749
    return (0);
  } else
#line 739
  if ((exps + (expsc - 1))->operation == 5) {
#line 749
    return (0);
  } else
#line 739
  if ((exps + (expsc - 1))->operation == 2) {
#line 749
    return (0);
  }
#line 756
  if ((exps + (expsc - 1))->operation == 5) {
#line 756
    if ((int )(exps + (expsc - 1))->type != 36) {
#line 759
      return (0);
    }
  }
#line 769
  if ((int )*(expression + 0) == 45) {
    {
#line 771
    tmp = strlen((char const   *)expression);
    }
#line 771
    if (tmp == 1UL) {
#line 771
      return (14);
    }
    {
#line 772
    exp_getvfname(expression + 1, tbuf___20);
#line 773
    tmp___0 = strlen((char const   *)(tbuf___20));
    }
#line 773
    if (tmp___0 != 0UL) {
#line 773
      return (14);
    }
  }
#line 779
  return (3);
  switch_default: /* CIL Label */ 
#line 782
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 801 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_exp.c"
int exp_isop(char *expression ) 
{ 
  register int c ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 819
  c = 0;
  {
#line 819
  while (1) {
    while_continue: /* CIL Label */ ;
#line 819
    if (! (c < 25)) {
#line 819
      goto while_break;
    }
    {
#line 821
    tmp = strlen((char const   *)(exp_ops[c].symbol));
#line 821
    tmp___0 = strncmp((char const   *)expression, (char const   *)(exp_ops[c].symbol),
                      tmp);
    }
#line 821
    if (tmp___0 == 0) {
#line 831
      return (exp_ops[c].operation);
    }
#line 819
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 837
  return (0);
}
}
#line 855 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_exp.c"
int exp_iscmd(char *expression ) 
{ 
  register int n___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 873
  tmp = strcmp((char const   *)expression, "THEN");
  }
#line 873
  if (tmp == 0) {
#line 880
    return (31);
  }
  {
#line 884
  tmp___0 = strcmp((char const   *)expression, "TO");
  }
#line 884
  if (tmp___0 == 0) {
#line 891
    return (31);
  }
  {
#line 895
  tmp___1 = strcmp((char const   *)expression, "ELSE");
  }
#line 895
  if (tmp___1 == 0) {
#line 902
    return (31);
  }
#line 907
  n___0 = 0;
  {
#line 907
  while (1) {
    while_continue: /* CIL Label */ ;
#line 907
    if (! (n___0 < 76)) {
#line 907
      goto while_break;
    }
    {
#line 909
    tmp___2 = strcmp((char const   *)expression, (char const   *)(bwb_cmdtable[n___0].name));
    }
#line 909
    if (tmp___2 == 0) {
#line 916
      return (31);
    }
#line 907
    n___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 931
  return (0);
}
}
#line 946 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_exp.c"
int exp_isufn(char *expression ) 
{ 
  struct fslte *f ;
  char tbuf___20[41] ;
  struct bwb_variable *tmp ;
  int tmp___0 ;

  {
  {
#line 957
  exp_getvfname(expression, tbuf___20);
#line 959
  f = fslt_start.next;
  }
  {
#line 959
  while (1) {
    while_continue: /* CIL Label */ ;
#line 959
    if (! ((unsigned long )f != (unsigned long )(& fslt_end))) {
#line 959
      goto while_break;
    }
    {
#line 961
    tmp___0 = strcmp((char const   *)f->name, (char const   *)(tbuf___20));
    }
#line 961
    if (tmp___0 == 0) {
      {
#line 973
      tmp = var_islocal(tbuf___20);
      }
#line 973
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 975
        return (0);
      } else {
#line 987
        return (32);
      }
    }
#line 959
    f = f->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 992
  return (0);
}
}
#line 1006 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_exp.c"
int exp_isfn(char *expression ) 
{ 
  struct bwb_function *tmp ;

  {
  {
#line 1018
  exp_getvfname(expression, (exps + expsc)->string);
#line 1026
  tmp = fnc_find((exps + expsc)->string);
  }
#line 1026
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1033
    return (0);
  } else {
#line 1042
    return (4);
  }
}
}
#line 1057 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_exp.c"
int exp_isvn(char *expression ) 
{ 
  size_t tmp ;
  struct bwb_variable *tmp___0 ;

  {
  {
#line 1073
  tmp = strlen((char const   *)((exps + expsc)->string));
  }
#line 1073
  if (tmp == 0UL) {
#line 1075
    return (0);
  }
  {
#line 1084
  tmp___0 = var_find((exps + expsc)->string);
  }
#line 1084
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 1091
    return (0);
  } else {
#line 1100
    return (5);
  }
}
}
#line 1115 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_exp.c"
int exp_getvfname(char *source , char *destination ) 
{ 
  int s_pos ;
  int d_pos ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 1131
  d_pos = 0;
#line 1131
  s_pos = d_pos;
#line 1132
  *(destination + 0) = (char )'\000';
  {
#line 1133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1133
    if (! ((int )*(source + s_pos) != 0)) {
#line 1133
      goto while_break;
    }
    {
#line 1138
    tmp___0 = __ctype_b_loc();
    }
#line 1138
    if (((int const   )*(*tmp___0 + (int )*(source + s_pos)) & 1024) != 0) {
#line 1141
      *(destination + d_pos) = *(source + s_pos);
#line 1143
      d_pos ++;
#line 1144
      s_pos ++;
#line 1145
      *(destination + d_pos) = (char )'\000';
    } else {
      {
#line 1150
      tmp = __ctype_b_loc();
      }
#line 1150
      if (((int const   )*(*tmp + (int )*(source + s_pos)) & 2048) != 0) {
#line 1150
        if (d_pos != 0) {
#line 1152
          *(destination + d_pos) = *(source + s_pos);
#line 1153
          d_pos ++;
#line 1154
          s_pos ++;
#line 1155
          *(destination + d_pos) = (char )'\000';
        } else {
#line 1150
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 1166
        if ((int )*(source + s_pos) == 95) {
#line 1166
          goto case_95;
        }
#line 1166
        if ((int )*(source + s_pos) == 46) {
#line 1166
          goto case_95;
        }
#line 1175
        if ((int )*(source + s_pos) == 33) {
#line 1175
          goto case_33;
        }
#line 1175
        if ((int )*(source + s_pos) == 35) {
#line 1175
          goto case_33;
        }
#line 1175
        if ((int )*(source + s_pos) == 36) {
#line 1175
          goto case_33;
        }
#line 1184
        if ((int )*(source + s_pos) == 40) {
#line 1184
          goto case_40;
        }
#line 1187
        goto switch_default;
        case_95: /* CIL Label */ 
        case_46: /* CIL Label */ 
#line 1167
        *(destination + d_pos) = *(source + s_pos);
#line 1168
        d_pos ++;
#line 1169
        s_pos ++;
#line 1170
        *(destination + d_pos) = (char )'\000';
#line 1171
        goto switch_break;
        case_33: /* CIL Label */ 
        case_35: /* CIL Label */ 
        case_36: /* CIL Label */ 
#line 1177
        *(destination + d_pos) = *(source + s_pos);
#line 1178
        d_pos ++;
#line 1179
        s_pos ++;
#line 1180
        *(destination + d_pos) = (char )'\000';
#line 1182
        return (-1);
        case_40: /* CIL Label */ 
#line 1185
        return (-1);
        switch_default: /* CIL Label */ 
#line 1188
        return (0);
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1198
  return (-1);
}
}
#line 1214 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_exp.c"
int exp_validarg(char *expression ) 
{ 
  register int c ;

  {
#line 1230
  c = 0;
  {
#line 1231
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1236
    if ((int )*(expression + c) == 9) {
#line 1236
      goto case_9;
    }
#line 1236
    if ((int )*(expression + c) == 32) {
#line 1236
      goto case_9;
    }
#line 1239
    if ((int )*(expression + c) == 0) {
#line 1239
      goto case_0;
    }
#line 1241
    goto switch_default;
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 1237
    c ++;
#line 1238
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1240
    return (0);
    switch_default: /* CIL Label */ 
#line 1242
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1259 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_exp.c"
bnumber exp_getnval(struct exp_ese *e___0 ) 
{ 
  bnumber *tmp ;

  {
#line 1270
  if (e___0->operation == 5) {
    {
#line 1274
    if ((int )e___0->type == 1) {
#line 1274
      goto case_1;
    }
#line 1276
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 1275
    tmp = var_findnval(e___0->xvar, e___0->array_pos);
    }
#line 1275
    return (*tmp);
    switch_default: /* CIL Label */ 
    {
#line 1277
    bwb_error(err_mismatch);
    }
#line 1278
    return (0.0);
    switch_break: /* CIL Label */ ;
    }
  }
#line 1284
  if (e___0->operation != 1) {
    {
#line 1287
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in exp_getnval(): operation <%d> is not a number",
            e___0->operation);
#line 1289
    bwb_error(bwb_ebuf);
    }
#line 1293
    return (0.0);
  }
  {
#line 1300
  if ((int )e___0->type == 1) {
#line 1300
    goto case_1___0;
  }
#line 1302
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
#line 1301
  return (e___0->nval);
  switch_default___0: /* CIL Label */ 
  {
#line 1304
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in exp_getnval(): type is <%c>",
          (int )e___0->type);
#line 1306
  bwb_error(bwb_ebuf);
  }
#line 1310
  return (0.0);
  switch_break___0: /* CIL Label */ ;
  }
}
}
#line 1334 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_exp.c"
static bstring b___1  ;
#line 1326 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_exp.c"
bstring *exp_getsval(struct exp_ese *e___0 ) 
{ 
  bstring *tmp ;
  bnumber tmp___0 ;
  bnumber tmp___1 ;

  {
#line 1344
  b___1.rab = 0;
  {
#line 1351
  if (e___0->operation == 15) {
#line 1351
    goto case_15;
  }
#line 1351
  if (e___0->operation == 2) {
#line 1351
    goto case_15;
  }
#line 1353
  if (e___0->operation == 5) {
#line 1353
    goto case_5;
  }
#line 1374
  if (e___0->operation == 1) {
#line 1374
    goto case_1___0;
  }
#line 1392
  goto switch_default___1;
  case_15: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 1352
  return (& e___0->sval);
  case_5: /* CIL Label */ 
  {
#line 1356
  if ((int )e___0->type == 36) {
#line 1356
    goto case_36;
  }
#line 1358
  if ((int )e___0->type == 1) {
#line 1358
    goto case_1;
  }
#line 1362
  goto switch_default;
  case_36: /* CIL Label */ 
  {
#line 1357
  tmp = var_findsval(e___0->xvar, e___0->array_pos);
  }
#line 1357
  return (tmp);
  case_1: /* CIL Label */ 
  {
#line 1359
  tmp___0 = exp_getnval(e___0);
#line 1359
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"%lf ",
          tmp___0);
#line 1360
  str_ctob(& b___1, bwb_ebuf);
  }
#line 1361
  return (& b___1);
  switch_default: /* CIL Label */ 
  {
#line 1364
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in exp_getsval(): type <%c> inappropriate for NUMBER",
          (int )e___0->type);
#line 1366
  bwb_error(bwb_ebuf);
  }
#line 1370
  return ((bstring *)((void *)0));
  switch_break___0: /* CIL Label */ ;
  }
#line 1372
  goto switch_break;
  case_1___0: /* CIL Label */ 
  {
#line 1377
  if ((int )e___0->type == 1) {
#line 1377
    goto case_1___1;
  }
#line 1381
  goto switch_default___0;
  case_1___1: /* CIL Label */ 
  {
#line 1378
  tmp___1 = exp_getnval(e___0);
#line 1378
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"%lf ",
          tmp___1);
#line 1379
  str_ctob(& b___1, bwb_ebuf);
  }
#line 1380
  return (& b___1);
  switch_default___0: /* CIL Label */ 
  {
#line 1383
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in exp_getsval(): type <%c> inappropriate for NUMBER",
          (int )e___0->type);
#line 1385
  bwb_error(bwb_ebuf);
  }
#line 1389
  return ((bstring *)((void *)0));
  switch_break___1: /* CIL Label */ ;
  }
#line 1391
  goto switch_break;
  switch_default___1: /* CIL Label */ 
  {
#line 1394
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in exp_getsval(): operation <%d> inappropriate",
          e___0->operation);
#line 1396
  bwb_error(bwb_ebuf);
  }
#line 1400
  return ((bstring *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 1405
  return ((bstring *)((void *)0));
}
}
#line 1419 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_exp.c"
int inc_esc(void) 
{ 


  {
#line 1433
  expsc ++;
#line 1434
  if (expsc >= 64) {
    {
#line 1436
    expsc --;
#line 1438
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in inc_esc(): Maximum expression stack exceeded <%d>",
            expsc);
#line 1440
    bwb_error(bwb_ebuf);
    }
#line 1444
    return (0);
  }
#line 1451
  (exps + expsc)->type = (char)1;
#line 1452
  (exps + expsc)->operation = 0;
#line 1453
  (exps + expsc)->pos_adv = 0;
#line 1455
  return (-1);
}
}
#line 1468 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_exp.c"
int dec_esc(void) 
{ 


  {
#line 1475
  expsc --;
#line 1476
  if (expsc < 0) {
    {
#line 1478
    expsc = 0;
#line 1480
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in dec_esc(): Expression stack counter < 0.");
#line 1481
    bwb_error(bwb_ebuf);
    }
#line 1485
    return (0);
  }
#line 1488
  return (-1);
}
}
#line 954 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
int bwb_numseq(char *buffer , int *start , int *end ) ;
#line 984
int is_cmd(char *buffer , int *cmdnum ) ;
#line 985
int is_let(char *buffer , int *cmdnum ) ;
#line 988
extern int is_label(char *buffer ) ;
#line 991
int int_qmdstr(char *buffer_a , char *buffer_b ) ;
#line 993
extern int scan_element(char *buffer , int *pos___2 , char *element___0 ) ;
#line 53 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_int.c"
int adv_element(char *buffer , int *pos___2 , char *element___0 ) 
{ 
  int loop ;
  int e_pos ;
  int str_const ;

  {
  {
#line 69
  adv_ws(buffer, pos___2);
#line 79
  loop = -1;
#line 80
  e_pos = 0;
#line 81
  *(element___0 + e_pos) = (char )'\000';
#line 82
  str_const = 0;
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (loop == -1)) {
#line 84
      goto while_break;
    }
    {
#line 98
    if ((int )*(buffer + *pos___2) == 13) {
#line 98
      goto case_13;
    }
#line 98
    if ((int )*(buffer + *pos___2) == 10) {
#line 98
      goto case_13;
    }
#line 98
    if ((int )*(buffer + *pos___2) == 9) {
#line 98
      goto case_13;
    }
#line 98
    if ((int )*(buffer + *pos___2) == 32) {
#line 98
      goto case_13;
    }
#line 98
    if ((int )*(buffer + *pos___2) == 61) {
#line 98
      goto case_13;
    }
#line 98
    if ((int )*(buffer + *pos___2) == 58) {
#line 98
      goto case_13;
    }
#line 98
    if ((int )*(buffer + *pos___2) == 59) {
#line 98
      goto case_13;
    }
#line 98
    if ((int )*(buffer + *pos___2) == 44) {
#line 98
      goto case_13;
    }
#line 112
    if ((int )*(buffer + *pos___2) == 0) {
#line 112
      goto case_0;
    }
#line 121
    if ((int )*(buffer + *pos___2) == 34) {
#line 121
      goto case_34;
    }
#line 136
    goto switch_default;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_61: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_44: /* CIL Label */ 
#line 99
    if (str_const == -1) {
#line 101
      *(element___0 + e_pos) = *(buffer + *pos___2);
#line 102
      e_pos ++;
#line 103
      (*pos___2) ++;
#line 104
      *(element___0 + e_pos) = (char )'\000';
    } else {
#line 108
      return (-1);
    }
#line 110
    goto switch_break;
    case_0: /* CIL Label */ 
#line 113
    if (str_const == -1) {
#line 115
      *(element___0 + e_pos) = (char )'\"';
#line 116
      e_pos ++;
#line 116
      *(element___0 + e_pos) = (char )'\000';
    }
#line 118
    return (-1);
#line 119
    goto switch_break;
    case_34: /* CIL Label */ 
#line 122
    *(element___0 + e_pos) = *(buffer + *pos___2);
#line 123
    e_pos ++;
#line 124
    (*pos___2) ++;
#line 125
    *(element___0 + e_pos) = (char )'\000';
#line 126
    if (str_const == -1) {
#line 128
      return (-1);
    } else {
#line 132
      str_const = -1;
    }
#line 134
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 137
    *(element___0 + e_pos) = *(buffer + *pos___2);
#line 138
    e_pos ++;
#line 139
    (*pos___2) ++;
#line 140
    *(element___0 + e_pos) = (char )'\000';
#line 141
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return (0);
}
}
#line 163 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_int.c"
int adv_ws(char *buffer , int *pos___2 ) 
{ 
  int loop ;

  {
#line 174
  loop = -1;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (loop == -1)) {
#line 175
      goto while_break;
    }
    {
#line 180
    if ((int )*(buffer + *pos___2) == 9) {
#line 180
      goto case_9;
    }
#line 180
    if ((int )*(buffer + *pos___2) == 32) {
#line 180
      goto case_9;
    }
#line 183
    goto switch_default;
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 181
    (*pos___2) ++;
#line 182
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 184
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  return (0);
}
}
#line 207 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_int.c"
int adv_eos(char *buffer , int *pos___2 ) 
{ 
  int loop ;
  int tmp ;
  int tmp___0 ;

  {
#line 218
  loop = -1;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! (loop == -1)) {
#line 219
      goto while_break;
    }
    {
#line 222
    tmp = is_eol(buffer, pos___2);
    }
#line 222
    if (tmp == -1) {
#line 224
      return (0);
    }
    {
#line 229
    if ((int )*(buffer + *pos___2) == 58) {
#line 229
      goto case_58;
    }
#line 233
    if ((int )*(buffer + *pos___2) == 34) {
#line 233
      goto case_34;
    }
#line 251
    goto switch_default;
    case_58: /* CIL Label */ 
#line 230
    (*pos___2) ++;
#line 231
    return (-1);
    case_34: /* CIL Label */ 
#line 235
    (*pos___2) ++;
    {
#line 237
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 237
      if (! ((int )*(buffer + *pos___2) != 34)) {
#line 237
        goto while_break___0;
      }
      {
#line 239
      tmp___0 = is_eol(buffer, pos___2);
      }
#line 239
      if (tmp___0 == -1) {
#line 241
        return (0);
      } else {
#line 245
        (*pos___2) ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 249
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 252
    (*pos___2) ++;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  return (0);
}
}
#line 274 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_int.c"
int bwb_strtoupper(char *buffer ) 
{ 
  char *p___0 ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 284
  p___0 = buffer;
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (! ((int )*p___0 != 0)) {
#line 285
      goto while_break;
    }
    {
#line 287
    tmp___0 = __ctype_b_loc();
    }
#line 287
    if (((int const   )*(*tmp___0 + (int )*p___0) & 512) != 0) {
      {
#line 289
      tmp = toupper((int )*p___0);
#line 289
      *p___0 = (char )tmp;
      }
    }
#line 291
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 294
  return (-1);
}
}
#line 339 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_int.c"
static int position___1  ;
#line 340 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_int.c"
static char *tbuf___1  ;
#line 341 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_int.c"
static int init___2  =    0;
#line 324 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_int.c"
int line_start(char *buffer , int *pos___2 , int *lnpos , int *lnum , int *cmdpos ,
               int *cmdnum , int *startpos___0 ) 
{ 
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 345
  if (init___2 == 0) {
    {
#line 347
    init___2 = -1;
#line 350
    tmp = CALLOC((size_t )5001, sizeof(char ), (char *)"line_start");
#line 350
    tbuf___1 = (char *)tmp;
    }
#line 350
    if ((unsigned long )tbuf___1 == (unsigned long )((void *)0)) {
      {
#line 353
      bwb_error((char *)"in line_start(): failed to get memory for tbuf");
      }
    }
  }
  {
#line 368
  position___1 = *pos___2;
#line 368
  *startpos___0 = position___1;
#line 369
  tmp___0 = *pos___2;
#line 369
  *lnpos = tmp___0;
#line 369
  *cmdpos = tmp___0;
#line 370
  tmp___1 = -1;
#line 370
  *lnum = tmp___1;
#line 370
  *cmdnum = tmp___1;
#line 374
  adv_ws(buffer, & position___1);
  }
#line 375
  if ((int )*(buffer + position___1) == 0) {
    {
#line 380
    *cmdnum = getcmdnum((char *)"REM");
    }
#line 381
    return (-1);
  }
  {
#line 386
  *lnpos = position___1;
#line 387
  scan_element(buffer, & position___1, tbuf___1);
#line 388
  adv_ws(buffer, & position___1);
#line 392
  tmp___10 = is_numconst(tbuf___1);
  }
#line 392
  if (tmp___10 == -1) {
    {
#line 395
    *lnum = atoi((char const   *)tbuf___1);
#line 396
    *startpos___0 = position___1;
#line 397
    *cmdpos = position___1;
#line 399
    scan_element(buffer, & position___1, tbuf___1);
#line 407
    tmp___5 = is_label(tbuf___1);
    }
#line 407
    if (tmp___5 == -1) {
      {
#line 409
      *cmdnum = getcmdnum((char *)"lAbEl");
#line 410
      adv_ws(buffer, & position___1);
#line 411
      *startpos___0 = position___1;
      }
    } else {
      {
#line 414
      tmp___4 = is_cmd(tbuf___1, cmdnum);
      }
#line 414
      if (tmp___4 == -1) {
        {
#line 419
        adv_ws(buffer, & position___1);
#line 420
        *startpos___0 = position___1;
        }
      } else {
        {
#line 423
        tmp___3 = is_let(buffer + *cmdpos, cmdnum);
        }
#line 423
        if (tmp___3 == -1) {
#line 425
          *cmdpos = -1;
        } else {
#line 430
          tmp___2 = -1;
#line 430
          *cmdnum = tmp___2;
#line 430
          *cmdpos = tmp___2;
        }
      }
    }
  } else {
    {
#line 438
    *lnum = -1;
#line 439
    *lnpos = -1;
#line 448
    tmp___9 = is_label(tbuf___1);
    }
#line 448
    if (tmp___9 == -1) {
      {
#line 457
      *cmdnum = getcmdnum((char *)"lAbEl");
#line 458
      adv_ws(buffer, & position___1);
#line 459
      *startpos___0 = position___1;
      }
    } else {
      {
#line 462
      tmp___8 = is_cmd(tbuf___1, cmdnum);
      }
#line 462
      if (tmp___8 == -1) {
        {
#line 467
        adv_ws(buffer, & position___1);
#line 468
        *startpos___0 = position___1;
        }
      } else {
        {
#line 471
        tmp___7 = is_let(buffer + position___1, cmdnum);
        }
#line 471
        if (tmp___7 == -1) {
          {
#line 473
          adv_ws(buffer, & position___1);
#line 474
          *cmdpos = -1;
          }
        } else {
#line 479
          tmp___6 = -1;
#line 479
          *cmdnum = tmp___6;
#line 479
          *cmdpos = tmp___6;
        }
      }
    }
  }
#line 494
  return (-1);
}
}
#line 512 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_int.c"
int is_cmd(char *buffer , int *cmdnum ) 
{ 
  register int n___0 ;
  int tmp ;

  {
  {
#line 525
  bwb_strtoupper(buffer);
#line 529
  n___0 = 0;
  }
  {
#line 529
  while (1) {
    while_continue: /* CIL Label */ ;
#line 529
    if (! (n___0 < 76)) {
#line 529
      goto while_break;
    }
    {
#line 531
    tmp = strcmp((char const   *)(bwb_cmdtable[n___0].name), (char const   *)buffer);
    }
#line 531
    if (tmp == 0) {
#line 533
      *cmdnum = n___0;
#line 534
      return (-1);
    }
#line 529
    n___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 540
  *cmdnum = -1;
#line 541
  return (0);
}
}
#line 556 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_int.c"
int is_let(char *buffer , int *cmdnum ) 
{ 
  register int n___0 ;
  register int i ;
  int tmp ;

  {
#line 574
  n___0 = 0;
  {
#line 574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 574
    if (! ((int )*(buffer + n___0) != 0)) {
#line 574
      goto while_break;
    }
    {
#line 578
    if ((int )*(buffer + n___0) == 34) {
#line 578
      goto case_34;
    }
#line 597
    if ((int )*(buffer + n___0) == 61) {
#line 597
      goto case_61;
    }
#line 576
    goto switch_break;
    case_34: /* CIL Label */ 
#line 579
    n___0 ++;
    {
#line 580
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 580
      if (! ((int )*(buffer + n___0) != 34)) {
#line 580
        goto while_break___0;
      }
#line 582
      n___0 ++;
#line 583
      if ((int )*(buffer + n___0) == 0) {
        {
#line 586
        sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Incomplete string constant");
#line 587
        bwb_error(bwb_ebuf);
#line 591
        *cmdnum = -1;
        }
#line 592
        return (0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 595
    n___0 ++;
#line 596
    goto switch_break;
    case_61: /* CIL Label */ 
#line 604
    i = 0;
    {
#line 604
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 604
      if (! (i < 76)) {
#line 604
        goto while_break___1;
      }
      {
#line 606
      tmp = strncmp((char const   *)(bwb_cmdtable[i].name), "LET", (size_t )3);
      }
#line 606
      if (tmp == 0) {
#line 608
        *cmdnum = i;
      }
#line 604
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 611
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 574
    n___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 617
  *cmdnum = -1;
#line 618
  return (0);
}
}
#line 632 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_int.c"
int bwb_stripcr(char *s___0 ) 
{ 
  char *p___0 ;

  {
#line 642
  p___0 = s___0;
  {
#line 643
  while (1) {
    while_continue: /* CIL Label */ ;
#line 643
    if (! ((int )*p___0 != 0)) {
#line 643
      goto while_break;
    }
    {
#line 650
    if ((int )*p___0 == 10) {
#line 650
      goto case_10;
    }
#line 650
    if ((int )*p___0 == 13) {
#line 650
      goto case_10;
    }
#line 645
    goto switch_break;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
#line 651
    *p___0 = (char)0;
#line 652
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 654
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 656
  *p___0 = (char)0;
#line 657
  return (-1);
}
}
#line 673 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_int.c"
int is_numconst(char *buffer ) 
{ 
  char *p___0 ;

  {
#line 690
  if ((int )*(buffer + 0) == 0) {
#line 692
    return (0);
  }
#line 697
  p___0 = buffer;
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
#line 698
    if (! ((int )*p___0 != 0)) {
#line 698
      goto while_break;
    }
    {
#line 711
    if ((int )*p___0 == 57) {
#line 711
      goto case_57;
    }
#line 711
    if ((int )*p___0 == 56) {
#line 711
      goto case_57;
    }
#line 711
    if ((int )*p___0 == 55) {
#line 711
      goto case_57;
    }
#line 711
    if ((int )*p___0 == 54) {
#line 711
      goto case_57;
    }
#line 711
    if ((int )*p___0 == 53) {
#line 711
      goto case_57;
    }
#line 711
    if ((int )*p___0 == 52) {
#line 711
      goto case_57;
    }
#line 711
    if ((int )*p___0 == 51) {
#line 711
      goto case_57;
    }
#line 711
    if ((int )*p___0 == 50) {
#line 711
      goto case_57;
    }
#line 711
    if ((int )*p___0 == 49) {
#line 711
      goto case_57;
    }
#line 711
    if ((int )*p___0 == 48) {
#line 711
      goto case_57;
    }
#line 713
    goto switch_default;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 712
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 714
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 716
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 721
  return (-1);
}
}
#line 750 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_int.c"
static char *tbuf___2  ;
#line 751 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_int.c"
static int init___3  =    0;
#line 738 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_int.c"
int bwb_numseq(char *buffer , int *start , int *end ) 
{ 
  register int b___4 ;
  register int n___0 ;
  int numbers ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 755
  if (init___3 == 0) {
    {
#line 757
    init___3 = -1;
#line 760
    tmp = CALLOC((size_t )5001, sizeof(char ), (char *)"bwb_numseq");
#line 760
    tbuf___2 = (char *)tmp;
    }
#line 760
    if ((unsigned long )tbuf___2 == (unsigned long )((void *)0)) {
      {
#line 763
      bwb_error((char *)"in bwb_numseq(): failed to find memory for tbuf");
      }
    }
  }
#line 770
  if ((int )*(buffer + 0) == 0) {
#line 772
    tmp___0 = 0;
#line 772
    *end = tmp___0;
#line 772
    *start = tmp___0;
#line 773
    return (0);
  }
#line 776
  b___4 = 0;
#line 776
  n___0 = b___4;
#line 776
  numbers = n___0;
#line 777
  *(tbuf___2 + 0) = (char)0;
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 784
    if ((int )*(buffer + b___4) == 13) {
#line 784
      goto case_13;
    }
#line 784
    if ((int )*(buffer + b___4) == 10) {
#line 784
      goto case_13;
    }
#line 784
    if ((int )*(buffer + b___4) == 0) {
#line 784
      goto case_13;
    }
#line 822
    if ((int )*(buffer + b___4) == 45) {
#line 822
      goto case_45;
    }
#line 848
    if ((int )*(buffer + b___4) == 57) {
#line 848
      goto case_57;
    }
#line 848
    if ((int )*(buffer + b___4) == 56) {
#line 848
      goto case_57;
    }
#line 848
    if ((int )*(buffer + b___4) == 55) {
#line 848
      goto case_57;
    }
#line 848
    if ((int )*(buffer + b___4) == 54) {
#line 848
      goto case_57;
    }
#line 848
    if ((int )*(buffer + b___4) == 53) {
#line 848
      goto case_57;
    }
#line 848
    if ((int )*(buffer + b___4) == 52) {
#line 848
      goto case_57;
    }
#line 848
    if ((int )*(buffer + b___4) == 51) {
#line 848
      goto case_57;
    }
#line 848
    if ((int )*(buffer + b___4) == 50) {
#line 848
      goto case_57;
    }
#line 848
    if ((int )*(buffer + b___4) == 49) {
#line 848
      goto case_57;
    }
#line 848
    if ((int )*(buffer + b___4) == 48) {
#line 848
      goto case_57;
    }
#line 854
    goto switch_default;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 785
    if (n___0 > 0) {
#line 787
      if (numbers == 0) {
        {
#line 789
        *end = 0;
#line 790
        *start = atoi((char const   *)tbuf___2);
#line 791
        numbers ++;
        }
      } else {
        {
#line 796
        *end = atoi((char const   *)tbuf___2);
        }
#line 797
        return (-1);
      }
    } else
#line 802
    if (numbers == 0) {
#line 804
      tmp___1 = 0;
#line 804
      *end = tmp___1;
#line 804
      *start = tmp___1;
    } else
#line 806
    if (numbers == 1) {
#line 808
      *end = 0;
    } else
#line 810
    if (numbers == 2) {
#line 810
      if ((int )*(tbuf___2 + 0) == 0) {
#line 812
        *end = 0;
      }
    }
#line 815
    return (-1);
    case_45: /* CIL Label */ 
#line 823
    if (n___0 > 0) {
#line 825
      if (numbers == 0) {
        {
#line 827
        *start = atoi((char const   *)tbuf___2);
#line 828
        numbers ++;
        }
      } else {
        {
#line 832
        *end = atoi((char const   *)tbuf___2);
        }
#line 833
        return (-1);
      }
    }
#line 836
    b___4 ++;
#line 837
    n___0 = 0;
#line 838
    goto switch_break;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 849
    *(tbuf___2 + n___0) = *(buffer + b___4);
#line 850
    n___0 ++;
#line 851
    *(tbuf___2 + n___0) = (char)0;
#line 852
    b___4 ++;
#line 853
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 856
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"ERROR: character <%c> unexpected in numerical sequence",
            (int )*(buffer + b___4));
#line 859
    b___4 ++;
#line 860
    bwb_error(bwb_ebuf);
    }
#line 864
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 880 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_int.c"
int bwb_freeline(struct bwb_line *l ) 
{ 


  {
#line 892
  if ((unsigned long )l->buffer != (unsigned long )((void *)0)) {
    {
#line 894
    FREE((void *)l->buffer, (char *)"bwb_freeline");
#line 895
    l->buffer = (char *)((void *)0);
    }
  }
  {
#line 897
  FREE((void *)l, (char *)"bwb_freeline");
#line 898
  l = (struct bwb_line *)((void *)0);
  }
#line 900
  return (-1);
}
}
#line 913 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_int.c"
int int_qmdstr(char *buffer_a , char *buffer_b ) 
{ 
  char *a ;
  char *b___4 ;

  {
#line 924
  a = buffer_a;
#line 925
  a ++;
#line 926
  b___4 = buffer_b;
  {
#line 928
  while (1) {
    while_continue: /* CIL Label */ ;
#line 928
    if (! ((int )*a != 34)) {
#line 928
      goto while_break;
    }
#line 930
    *b___4 = *a;
#line 931
    a ++;
#line 932
    b___4 ++;
#line 933
    *b___4 = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
#line 936
  return (-1);
}
}
#line 950 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_int.c"
extern int is_eol(char *buffer , int *position___7 ) 
{ 


  {
  {
#line 960
  adv_ws(buffer, position___7);
  }
  {
#line 974
  if ((int )*(buffer + *position___7) == 58) {
#line 974
    goto case_58;
  }
#line 974
  if ((int )*(buffer + *position___7) == 13) {
#line 974
    goto case_58;
  }
#line 974
  if ((int )*(buffer + *position___7) == 10) {
#line 974
    goto case_58;
  }
#line 974
  if ((int )*(buffer + *position___7) == 0) {
#line 974
    goto case_58;
  }
#line 977
  goto switch_default;
  case_58: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 976
  return (-1);
  switch_default: /* CIL Label */ 
#line 978
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 58 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atan)(double __x ) ;
#line 63
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 65
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 67
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) tan)(double __x ) ;
#line 100
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) exp)(double __x ) ;
#line 109
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log)(double __x ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 178
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ceil)(double __x )  __attribute__((__const__)) ;
#line 181
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 184
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 972 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
int var_make(struct bwb_variable *v___0 , int type ) ;
#line 995
int prn_precision(struct bwb_variable *v___0 ) ;
#line 1084
struct bwb_variable *fnc_core(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1106
struct bwb_variable *fnc_val(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1108
struct bwb_variable *fnc_hex(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1109
struct bwb_variable *fnc_oct(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1110
struct bwb_variable *fnc_cint(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1112
struct bwb_variable *fnc_mkd(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1113
struct bwb_variable *fnc_mki(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1114
struct bwb_variable *fnc_mks(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1115
struct bwb_variable *fnc_cvi(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1116
struct bwb_variable *fnc_cvd(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1117
struct bwb_variable *fnc_cvs(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1128
struct bwb_variable *fnc_csng(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1130
struct bwb_variable *fnc_str(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1133
bnumber trnc_int(bnumber x___0 ) ;
#line 44 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
bnumber round_int(bnumber x___0 ) ;
#line 50 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
union un_integer an_integer  ;
#line 56 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
union un_single a_float  ;
#line 62 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
union un_double a_double  ;
#line 92 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static struct bwb_variable nvar  ;
#line 93 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static int init___4  =    0;
#line 82 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
struct bwb_variable *fnc_core(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  bnumber nval ;
  bnumber *tmp ;
  bnumber tmp___0 ;
  double tmp___1 ;
  bnumber *tmp___2 ;
  bnumber tmp___3 ;
  double tmp___4 ;
  bnumber *tmp___5 ;
  bnumber tmp___6 ;
  double tmp___7 ;
  bnumber *tmp___8 ;
  bnumber tmp___9 ;
  double tmp___10 ;
  bnumber *tmp___11 ;
  bnumber tmp___12 ;
  double tmp___13 ;
  bnumber *tmp___14 ;
  bnumber tmp___15 ;
  double tmp___16 ;
  bnumber *tmp___17 ;
  int tmp___18 ;
  bnumber *tmp___19 ;
  bnumber *tmp___20 ;
  bnumber *tmp___21 ;
  bnumber *tmp___22 ;
  bnumber tmp___23 ;
  double tmp___24 ;
  bnumber *tmp___25 ;
  bnumber tmp___26 ;
  double tmp___27 ;
  bnumber *tmp___28 ;
  bnumber tmp___29 ;
  double tmp___30 ;

  {
#line 103
  if (init___4 == 0) {
    {
#line 105
    init___4 = -1;
#line 106
    strncpy((char */* __restrict  */)(nvar.name), (char const   */* __restrict  */)"(core var)",
            (size_t )40);
#line 112
    var_make(& nvar, 1);
    }
  }
  {
#line 125
  if (unique_id == 7) {
#line 125
    goto case_7;
  }
#line 127
  goto switch_default;
  case_7: /* CIL Label */ 
#line 126
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 129
  if (argc < 1) {
    {
#line 131
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough parameters (%d) to core function.",
            argc);
#line 133
    bwb_error(bwb_ebuf);
    }
#line 134
    return ((struct bwb_variable *)((void *)0));
  } else
#line 136
  if (argc > 1) {
    {
#line 138
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to core function.",
            argc);
#line 140
    bwb_error(bwb_ebuf);
    }
#line 141
    return ((struct bwb_variable *)((void *)0));
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 161
  if (unique_id == 1) {
#line 161
    goto case_1;
  }
#line 166
  if (unique_id == 2) {
#line 166
    goto case_2;
  }
#line 170
  if (unique_id == 3) {
#line 170
    goto case_3;
  }
#line 174
  if (unique_id == 4) {
#line 174
    goto case_4;
  }
#line 179
  if (unique_id == 5) {
#line 179
    goto case_5;
  }
#line 183
  if (unique_id == 6) {
#line 183
    goto case_6;
  }
#line 187
  if (unique_id == 7) {
#line 187
    goto case_7___0;
  }
#line 192
  if (unique_id == 8) {
#line 192
    goto case_8;
  }
#line 207
  if (unique_id == 9) {
#line 207
    goto case_9;
  }
#line 211
  if (unique_id == 10) {
#line 211
    goto case_10;
  }
#line 215
  if (unique_id == 11) {
#line 215
    goto case_11;
  }
#line 159
  goto switch_break___0;
  case_1: /* CIL Label */ 
  {
#line 163
  tmp = var_findnval(& nvar, nvar.array_pos);
#line 163
  tmp___0 = var_getnval(argv + 0);
#line 163
  tmp___1 = fabs(tmp___0);
#line 163
  *tmp = tmp___1;
  }
#line 165
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 167
  tmp___2 = var_findnval(& nvar, nvar.array_pos);
#line 167
  tmp___3 = var_getnval(argv + 0);
#line 167
  tmp___4 = atan(tmp___3);
#line 167
  *tmp___2 = tmp___4;
  }
#line 169
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 171
  tmp___5 = var_findnval(& nvar, nvar.array_pos);
#line 171
  tmp___6 = var_getnval(argv + 0);
#line 171
  tmp___7 = cos(tmp___6);
#line 171
  *tmp___5 = tmp___7;
  }
#line 173
  goto switch_break___0;
  case_4: /* CIL Label */ 
  {
#line 176
  tmp___8 = var_findnval(& nvar, nvar.array_pos);
#line 176
  tmp___9 = var_getnval(argv + 0);
#line 176
  tmp___10 = exp(tmp___9);
#line 176
  *tmp___8 = tmp___10;
  }
#line 178
  goto switch_break___0;
  case_5: /* CIL Label */ 
  {
#line 180
  tmp___11 = var_findnval(& nvar, nvar.array_pos);
#line 180
  tmp___12 = var_getnval(argv + 0);
#line 180
  tmp___13 = floor(tmp___12);
#line 180
  *tmp___11 = tmp___13;
  }
#line 182
  goto switch_break___0;
  case_6: /* CIL Label */ 
  {
#line 184
  tmp___14 = var_findnval(& nvar, nvar.array_pos);
#line 184
  tmp___15 = var_getnval(argv + 0);
#line 184
  tmp___16 = log(tmp___15);
#line 184
  *tmp___14 = tmp___16;
  }
#line 186
  goto switch_break___0;
  case_7___0: /* CIL Label */ 
  {
#line 189
  tmp___17 = var_findnval(& nvar, nvar.array_pos);
#line 189
  tmp___18 = rand();
#line 189
  *tmp___17 = (bnumber )((float )tmp___18 / (float )2147483647);
  }
#line 191
  goto switch_break___0;
  case_8: /* CIL Label */ 
  {
#line 193
  nval = var_getnval(argv + 0);
  }
#line 194
  if (nval == 0.0) {
    {
#line 196
    tmp___19 = var_findnval(& nvar, nvar.array_pos);
#line 196
    *tmp___19 = (bnumber )0;
    }
  } else
#line 198
  if (nval > 0.0) {
    {
#line 200
    tmp___20 = var_findnval(& nvar, nvar.array_pos);
#line 200
    *tmp___20 = (bnumber )1;
    }
  } else {
    {
#line 204
    tmp___21 = var_findnval(& nvar, nvar.array_pos);
#line 204
    *tmp___21 = (bnumber )-1;
    }
  }
#line 206
  goto switch_break___0;
  case_9: /* CIL Label */ 
  {
#line 208
  tmp___22 = var_findnval(& nvar, nvar.array_pos);
#line 208
  tmp___23 = var_getnval(argv + 0);
#line 208
  tmp___24 = sin(tmp___23);
#line 208
  *tmp___22 = tmp___24;
  }
#line 210
  goto switch_break___0;
  case_10: /* CIL Label */ 
  {
#line 212
  tmp___25 = var_findnval(& nvar, nvar.array_pos);
#line 212
  tmp___26 = var_getnval(argv + 0);
#line 212
  tmp___27 = sqrt(tmp___26);
#line 212
  *tmp___25 = tmp___27;
  }
#line 214
  goto switch_break___0;
  case_11: /* CIL Label */ 
  {
#line 216
  tmp___28 = var_findnval(& nvar, nvar.array_pos);
#line 216
  tmp___29 = var_getnval(argv + 0);
#line 216
  tmp___30 = tan(tmp___29);
#line 216
  *tmp___28 = tmp___30;
  }
#line 218
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 221
  return (& nvar);
}
}
#line 1036 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static struct bwb_variable nvar___0  ;
#line 1037 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static char *tbuf___3  ;
#line 1038 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static int init___5  =    0;
#line 1026 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
struct bwb_variable *fnc_val(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  void *tmp ;
  bstring *tmp___0 ;
  bnumber *tmp___1 ;
  bnumber *tmp___2 ;
  size_t tmp___3 ;

  {
#line 1042
  if (init___5 == 0) {
    {
#line 1044
    init___5 = -1;
#line 1045
    var_make(& nvar___0, 1);
#line 1048
    tmp = CALLOC((size_t )5001, sizeof(char ), (char *)"fnc_val");
#line 1048
    tbuf___3 = (char *)tmp;
    }
#line 1048
    if ((unsigned long )tbuf___3 == (unsigned long )((void *)0)) {
      {
#line 1051
      bwb_error((char *)"in fnc_val(): failed to get memory for tbuf");
      }
    }
  }
#line 1061
  if (argc < 1) {
    {
#line 1063
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough arguments to function VAL()");
#line 1064
    bwb_error(bwb_ebuf);
    }
#line 1065
    return ((struct bwb_variable *)((void *)0));
  } else
#line 1067
  if (argc > 1) {
    {
#line 1069
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to function VAL().",
            argc);
#line 1071
    bwb_error(bwb_ebuf);
    }
#line 1072
    return ((struct bwb_variable *)((void *)0));
  }
#line 1082
  if ((argv + 0)->type != 36) {
    {
#line 1085
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Argument to function VAL() must be a string.");
#line 1086
    bwb_error(bwb_ebuf);
    }
#line 1090
    return ((struct bwb_variable *)((void *)0));
  }
  {
#line 1095
  tmp___0 = var_getsval(argv + 0);
#line 1095
  str_btoc(tbuf___3, tmp___0);
#line 1096
  tmp___1 = var_findnval(& nvar___0, nvar___0.array_pos);
#line 1096
  *tmp___1 = (bnumber )0;
#line 1097
  tmp___3 = strlen((char const   *)tbuf___3);
  }
#line 1097
  if (tmp___3 != 0UL) {
    {
#line 1099
    tmp___2 = var_findnval(& nvar___0, nvar___0.array_pos);
#line 1099
    sscanf((char const   */* __restrict  */)tbuf___3, (char const   */* __restrict  */)"%lf",
           tmp___2);
    }
  }
#line 1106
  return (& nvar___0);
}
}
#line 1132 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static struct bwb_variable nvar___1  ;
#line 1133 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static char *tbuf___4  ;
#line 1134 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static int init___6  =    0;
#line 1122 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
struct bwb_variable *fnc_str(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  void *tmp ;
  bnumber tmp___0 ;
  int tmp___1 ;
  bstring *tmp___2 ;

  {
#line 1138
  if (init___6 == 0) {
    {
#line 1140
    init___6 = -1;
#line 1141
    var_make(& nvar___1, '$');
#line 1144
    tmp = CALLOC((size_t )5001, sizeof(char ), (char *)"fnc_str");
#line 1144
    tbuf___4 = (char *)tmp;
    }
#line 1144
    if ((unsigned long )tbuf___4 == (unsigned long )((void *)0)) {
      {
#line 1147
      bwb_error((char *)"in fnc_str(): failed to get memory for tbuf");
      }
    }
  }
#line 1157
  if (argc < 1) {
    {
#line 1159
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough parameters (%d) to function STR$().",
            argc);
#line 1161
    bwb_error(bwb_ebuf);
    }
#line 1162
    return ((struct bwb_variable *)((void *)0));
  } else
#line 1164
  if (argc > 1) {
    {
#line 1166
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to function STR$().",
            argc);
#line 1168
    bwb_error(bwb_ebuf);
    }
#line 1169
    return ((struct bwb_variable *)((void *)0));
  }
  {
#line 1180
  tmp___0 = var_getnval(argv + 0);
#line 1180
  tmp___1 = prn_precision(argv + 0);
#line 1180
  sprintf((char */* __restrict  */)tbuf___4, (char const   */* __restrict  */)" %.*f",
          tmp___1, tmp___0);
#line 1182
  tmp___2 = var_findsval(& nvar___1, nvar___1.array_pos);
#line 1182
  str_ctob(tmp___2, tbuf___4);
  }
#line 1184
  return (& nvar___1);
}
}
#line 1215 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static struct bwb_variable nvar___2  ;
#line 1216 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static char *tbuf___5  ;
#line 1217 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static int init___7  =    0;
#line 1205 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
struct bwb_variable *fnc_hex(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  void *tmp ;
  bnumber tmp___0 ;
  bnumber tmp___1 ;
  bstring *tmp___2 ;

  {
#line 1221
  if (init___7 == 0) {
    {
#line 1223
    init___7 = -1;
#line 1224
    var_make(& nvar___2, '$');
#line 1227
    tmp = CALLOC((size_t )5001, sizeof(char ), (char *)"fnc_hex");
#line 1227
    tbuf___5 = (char *)tmp;
    }
#line 1227
    if ((unsigned long )tbuf___5 == (unsigned long )((void *)0)) {
      {
#line 1230
      bwb_error((char *)"in fnc_hex(): failed to get memory for tbuf");
      }
    }
  }
#line 1240
  if (argc < 1) {
    {
#line 1242
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough parameters (%d) to function HEX$().",
            argc);
#line 1244
    bwb_error(bwb_ebuf);
    }
#line 1245
    return ((struct bwb_variable *)((void *)0));
  } else
#line 1247
  if (argc > 1) {
    {
#line 1249
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to function HEX$().",
            argc);
#line 1251
    bwb_error(bwb_ebuf);
    }
#line 1252
    return ((struct bwb_variable *)((void *)0));
  }
  {
#line 1263
  tmp___0 = var_getnval(argv + 0);
#line 1263
  tmp___1 = trnc_int(tmp___0);
#line 1263
  sprintf((char */* __restrict  */)tbuf___5, (char const   */* __restrict  */)"%X",
          (int )tmp___1);
#line 1264
  tmp___2 = var_findsval(& nvar___2, nvar___2.array_pos);
#line 1264
  str_ctob(tmp___2, tbuf___5);
  }
#line 1265
  return (& nvar___2);
}
}
#line 1292 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static struct bwb_variable nvar___3  ;
#line 1293 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static char *tbuf___6  ;
#line 1294 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static int init___8  =    0;
#line 1282 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
struct bwb_variable *fnc_oct(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  void *tmp ;
  bnumber tmp___0 ;
  bnumber tmp___1 ;
  bstring *tmp___2 ;

  {
#line 1298
  if (init___8 == 0) {
    {
#line 1300
    init___8 = -1;
#line 1301
    var_make(& nvar___3, '$');
#line 1304
    tmp = CALLOC((size_t )5001, sizeof(char ), (char *)"fnc_oct");
#line 1304
    tbuf___6 = (char *)tmp;
    }
#line 1304
    if ((unsigned long )tbuf___6 == (unsigned long )((void *)0)) {
      {
#line 1307
      bwb_error((char *)"in fnc_oct(): failed to get memory for tbuf");
      }
    }
  }
#line 1317
  if (argc < 1) {
    {
#line 1319
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough parameters (%d) to function OCT$().",
            argc);
#line 1321
    bwb_error(bwb_ebuf);
    }
#line 1322
    return ((struct bwb_variable *)((void *)0));
  } else
#line 1324
  if (argc > 1) {
    {
#line 1326
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to function OCT$().",
            argc);
#line 1328
    bwb_error(bwb_ebuf);
    }
#line 1329
    return ((struct bwb_variable *)((void *)0));
  }
  {
#line 1342
  tmp___0 = var_getnval(argv + 0);
#line 1342
  tmp___1 = trnc_int(tmp___0);
#line 1342
  sprintf((char */* __restrict  */)tbuf___6, (char const   */* __restrict  */)"%o",
          (int )tmp___1);
#line 1343
  tmp___2 = var_findsval(& nvar___3, nvar___3.array_pos);
#line 1343
  str_ctob(tmp___2, tbuf___6);
  }
#line 1344
  return (& nvar___3);
}
}
#line 1374 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static struct bwb_variable nvar___4  ;
#line 1376 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static char tbuf___7[4UL]  ;
#line 1377 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static int init___9  =    0;
#line 1363 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
struct bwb_variable *fnc_mki(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  register int i ;
  bstring *b___4 ;
  bnumber tmp ;

  {
#line 1381
  if (init___9 == 0) {
    {
#line 1383
    init___9 = -1;
#line 1384
    var_make(& nvar___4, '$');
    }
  }
#line 1388
  if (argc < 1) {
    {
#line 1390
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough parameters (%d) to function MKI$().",
            argc);
#line 1392
    bwb_error(bwb_ebuf);
    }
#line 1393
    return ((struct bwb_variable *)((void *)0));
  } else
#line 1395
  if (argc > 1) {
    {
#line 1397
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to function MKI$().",
            argc);
#line 1399
    bwb_error(bwb_ebuf);
    }
#line 1400
    return ((struct bwb_variable *)((void *)0));
  }
  {
#line 1411
  tmp = var_getnval(argv + 0);
#line 1411
  an_integer.the_integer = (int )tmp;
#line 1413
  i = 0;
  }
  {
#line 1413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1413
    if (! ((unsigned long )i < sizeof(int ))) {
#line 1413
      goto while_break;
    }
#line 1415
    tbuf___7[i] = (char )an_integer.the_chars[i];
#line 1416
    tbuf___7[i + 1] = (char )'\000';
#line 1413
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1418
  b___4 = var_getsval(& nvar___4);
#line 1419
  b___4->length = (unsigned int )sizeof(int );
#line 1420
  b___4->sbuffer = tbuf___7;
#line 1421
  b___4->rab = 0;
  }
#line 1423
  return (& nvar___4);
}
}
#line 1453 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static struct bwb_variable nvar___5  ;
#line 1455 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static char tbuf___8[8UL]  ;
#line 1456 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static int init___10  =    0;
#line 1442 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
struct bwb_variable *fnc_mkd(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  register int i ;
  bstring *b___4 ;

  {
#line 1460
  if (init___10 == 0) {
    {
#line 1462
    init___10 = -1;
#line 1463
    var_make(& nvar___5, '$');
    }
  }
#line 1467
  if (argc < 1) {
    {
#line 1469
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough parameters (%d) to function MKD$().",
            argc);
#line 1471
    bwb_error(bwb_ebuf);
    }
#line 1472
    return ((struct bwb_variable *)((void *)0));
  } else
#line 1474
  if (argc > 1) {
    {
#line 1476
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to function MKD$().",
            argc);
#line 1478
    bwb_error(bwb_ebuf);
    }
#line 1479
    return ((struct bwb_variable *)((void *)0));
  }
  {
#line 1490
  a_double.the_double = var_getnval(argv + 0);
#line 1492
  i = 0;
  }
  {
#line 1492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1492
    if (! ((unsigned long )i < sizeof(double ))) {
#line 1492
      goto while_break;
    }
#line 1494
    tbuf___8[i] = (char )a_double.the_chars[i];
#line 1495
    tbuf___8[i + 1] = (char )'\000';
#line 1492
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1497
  b___4 = var_getsval(& nvar___5);
#line 1498
  b___4->length = (unsigned int )sizeof(double );
#line 1499
  b___4->sbuffer = tbuf___8;
#line 1500
  b___4->rab = 0;
  }
#line 1502
  return (& nvar___5);
}
}
#line 1532 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static struct bwb_variable nvar___6  ;
#line 1533 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static char tbuf___9[5]  ;
#line 1535 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static int init___11  =    0;
#line 1521 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
struct bwb_variable *fnc_mks(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  register int i ;
  bstring *b___4 ;
  bnumber tmp ;

  {
#line 1539
  if (init___11 == 0) {
    {
#line 1541
    init___11 = -1;
#line 1542
    var_make(& nvar___6, '$');
    }
  }
#line 1546
  if (argc < 1) {
    {
#line 1548
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough parameters (%d) to function MKS$().",
            argc);
#line 1550
    bwb_error(bwb_ebuf);
    }
#line 1551
    return ((struct bwb_variable *)((void *)0));
  } else
#line 1553
  if (argc > 1) {
    {
#line 1555
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to function MKS$().",
            argc);
#line 1557
    bwb_error(bwb_ebuf);
    }
#line 1558
    return ((struct bwb_variable *)((void *)0));
  }
  {
#line 1569
  tmp = var_getnval(argv + 0);
#line 1569
  a_float.the_float = (float )tmp;
#line 1571
  i = 0;
  }
  {
#line 1571
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1571
    if (! ((unsigned long )i < sizeof(float ))) {
#line 1571
      goto while_break;
    }
#line 1573
    tbuf___9[i] = (char )a_float.the_chars[i];
#line 1574
    tbuf___9[i + 1] = (char )'\000';
#line 1571
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1576
  b___4 = var_getsval(& nvar___6);
#line 1577
  b___4->length = (unsigned int )sizeof(float );
#line 1578
  b___4->sbuffer = tbuf___9;
#line 1579
  b___4->rab = 0;
  }
#line 1587
  return (& nvar___6);
}
}
#line 1619 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static struct bwb_variable nvar___7  ;
#line 1620 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static int init___12  =    0;
#line 1606 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
struct bwb_variable *fnc_cvi(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  register int i ;
  struct bwb_variable *v___0 ;
  bstring *b___4 ;
  bnumber *tmp ;

  {
#line 1624
  if (init___12 == 0) {
    {
#line 1626
    init___12 = -1;
#line 1627
    var_make(& nvar___7, 1);
    }
  }
#line 1631
  if (argc < 1) {
    {
#line 1633
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough parameters (%d) to function CVI().",
            argc);
#line 1635
    bwb_error(bwb_ebuf);
    }
#line 1636
    return ((struct bwb_variable *)((void *)0));
  } else
#line 1638
  if (argc > 1) {
    {
#line 1640
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to function CVI().",
            argc);
#line 1642
    bwb_error(bwb_ebuf);
    }
#line 1643
    return ((struct bwb_variable *)((void *)0));
  }
  {
#line 1654
  v___0 = argv + 0;
#line 1655
  b___4 = var_findsval(v___0, v___0->array_pos);
#line 1657
  i = 0;
  }
  {
#line 1657
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1657
    if (! ((unsigned long )i < sizeof(int ))) {
#line 1657
      goto while_break;
    }
#line 1659
    an_integer.the_chars[i] = (unsigned char )*(b___4->sbuffer + i);
#line 1657
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1662
  tmp = var_findnval(& nvar___7, nvar___7.array_pos);
#line 1662
  *tmp = (bnumber )an_integer.the_integer;
  }
#line 1664
  return (& nvar___7);
}
}
#line 1696 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static struct bwb_variable nvar___8  ;
#line 1697 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static int init___13  =    0;
#line 1683 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
struct bwb_variable *fnc_cvd(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  register int i ;
  struct bwb_variable *v___0 ;
  bstring *b___4 ;
  bnumber *tmp ;

  {
#line 1701
  if (init___13 == 0) {
    {
#line 1703
    init___13 = -1;
#line 1704
    var_make(& nvar___8, 1);
    }
  }
#line 1708
  if (argc < 1) {
    {
#line 1710
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough parameters (%d) to function CVD().",
            argc);
#line 1712
    bwb_error(bwb_ebuf);
    }
#line 1713
    return ((struct bwb_variable *)((void *)0));
  } else
#line 1715
  if (argc > 1) {
    {
#line 1717
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to function CVD().",
            argc);
#line 1719
    bwb_error(bwb_ebuf);
    }
#line 1720
    return ((struct bwb_variable *)((void *)0));
  }
  {
#line 1731
  v___0 = argv + 0;
#line 1732
  b___4 = var_findsval(v___0, v___0->array_pos);
#line 1734
  i = 0;
  }
  {
#line 1734
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1734
    if (! ((unsigned long )i < sizeof(double ))) {
#line 1734
      goto while_break;
    }
#line 1736
    a_double.the_chars[i] = (unsigned char )*(b___4->sbuffer + i);
#line 1734
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1739
  tmp = var_findnval(& nvar___8, nvar___8.array_pos);
#line 1739
  *tmp = a_double.the_double;
  }
#line 1741
  return (& nvar___8);
}
}
#line 1774 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static struct bwb_variable nvar___9  ;
#line 1775 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static int init___14  =    0;
#line 1761 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
struct bwb_variable *fnc_cvs(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  register int i ;
  struct bwb_variable *v___0 ;
  bstring *b___4 ;
  bnumber *tmp ;

  {
#line 1779
  if (init___14 == 0) {
    {
#line 1781
    init___14 = -1;
#line 1782
    var_make(& nvar___9, 1);
    }
  }
#line 1786
  if (argc < 1) {
    {
#line 1788
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough parameters (%d) to function CVS().",
            argc);
#line 1790
    bwb_error(bwb_ebuf);
    }
#line 1791
    return ((struct bwb_variable *)((void *)0));
  } else
#line 1793
  if (argc > 1) {
    {
#line 1795
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to function CVS().",
            argc);
#line 1797
    bwb_error(bwb_ebuf);
    }
#line 1798
    return ((struct bwb_variable *)((void *)0));
  }
  {
#line 1809
  v___0 = argv + 0;
#line 1810
  b___4 = var_findsval(v___0, v___0->array_pos);
#line 1812
  i = 0;
  }
  {
#line 1812
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1812
    if (! ((unsigned long )i < sizeof(float ))) {
#line 1812
      goto while_break;
    }
#line 1814
    a_float.the_chars[i] = (unsigned char )*(b___4->sbuffer + i);
#line 1812
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1824
  tmp = var_findnval(& nvar___9, nvar___9.array_pos);
#line 1824
  *tmp = (bnumber )a_float.the_float;
  }
#line 1826
  return (& nvar___9);
}
}
#line 1855 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static struct bwb_variable nvar___10  ;
#line 1856 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static int init___15  =    0;
#line 1845 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
struct bwb_variable *fnc_csng(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  bnumber *tmp ;
  bnumber tmp___0 ;

  {
#line 1860
  if (init___15 == 0) {
    {
#line 1862
    init___15 = -1;
#line 1863
    var_make(& nvar___10, 1);
    }
  }
#line 1869
  if (argc < 1) {
    {
#line 1871
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough parameters (%d) to function CINT().",
            argc);
#line 1873
    bwb_error(bwb_ebuf);
    }
#line 1874
    return ((struct bwb_variable *)((void *)0));
  } else
#line 1876
  if (argc > 1) {
    {
#line 1878
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to function CINT().",
            argc);
#line 1880
    bwb_error(bwb_ebuf);
    }
#line 1881
    return ((struct bwb_variable *)((void *)0));
  }
  {
#line 1892
  tmp = var_findnval(& nvar___10, nvar___10.array_pos);
#line 1892
  tmp___0 = var_getnval(argv + 0);
#line 1892
  *tmp = tmp___0;
  }
#line 1895
  return (& nvar___10);
}
}
#line 1921 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static struct bwb_variable nvar___11  ;
#line 1922 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
static int init___16  =    0;
#line 1911 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
struct bwb_variable *fnc_cint(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  bnumber *tmp ;
  bnumber tmp___0 ;

  {
#line 1926
  if (init___16 == 0) {
    {
#line 1928
    init___16 = -1;
#line 1929
    var_make(& nvar___11, 1);
    }
  }
#line 1935
  if (argc < 1) {
    {
#line 1937
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough parameters (%d) to function CINT().",
            argc);
#line 1939
    bwb_error(bwb_ebuf);
    }
#line 1940
    return ((struct bwb_variable *)((void *)0));
  } else
#line 1942
  if (argc > 1) {
    {
#line 1944
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to function CINT().",
            argc);
#line 1946
    bwb_error(bwb_ebuf);
    }
#line 1947
    return ((struct bwb_variable *)((void *)0));
  }
  {
#line 1958
  tmp = var_findnval(& nvar___11, nvar___11.array_pos);
#line 1958
  tmp___0 = var_getnval(argv + 0);
#line 1958
  *tmp = round_int(tmp___0);
  }
#line 1961
  return (& nvar___11);
}
}
#line 1977 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
bnumber trnc_int(bnumber x___0 ) 
{ 
  double sign ;
  double tmp ;
  double tmp___0 ;

  {
#line 1987
  if (x___0 < 0.0) {
#line 1989
    sign = - 1.0;
  } else {
#line 1993
    sign = 1.0;
  }
  {
#line 1997
  tmp = fabs(x___0);
#line 1997
  tmp___0 = floor(tmp);
  }
#line 1997
  return (tmp___0 * sign);
}
}
#line 2011 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mth.c"
bnumber round_int(bnumber x___0 ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;

  {
#line 2020
  if (x___0 < 0.00) {
    {
#line 2023
    tmp___1 = floor(x___0);
#line 2023
    tmp___2 = fabs(tmp___1 - x___0);
    }
#line 2023
    if (tmp___2 < 0.500) {
      {
#line 2025
      tmp = floor(x___0);
      }
#line 2025
      return (tmp);
    } else {
      {
#line 2029
      tmp___0 = ceil(x___0);
      }
#line 2029
      return (tmp___0);
    }
  } else {
    {
#line 2034
    tmp___5 = floor(x___0);
    }
#line 2034
    if (x___0 - tmp___5 < 0.500) {
      {
#line 2036
      tmp___3 = floor(x___0);
      }
#line 2036
      return (tmp___3);
    } else {
      {
#line 2040
      tmp___4 = ceil(x___0);
      }
#line 2040
      return (tmp___4);
    }
  }
}
}
#line 754 "/usr/include/stdio.h"
extern long ftell(FILE *__stream ) ;
#line 187 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fmod)(double __x ,
                                                                              double __y ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 809 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
int err_line ;
#line 810
int err_number ;
#line 814
struct bwb_function bwb_prefuncs[45] ;
#line 1082
struct bwb_variable *fnc_null(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1098
struct bwb_variable *fnc_tab(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1099
struct bwb_variable *fnc_date(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1100
struct bwb_variable *fnc_time(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1101
struct bwb_variable *fnc_chr(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1102
struct bwb_variable *fnc_mid(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1103
struct bwb_variable *fnc_left(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1104
struct bwb_variable *fnc_right(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1105
struct bwb_variable *fnc_timer(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1107
struct bwb_variable *fnc_len(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1111
struct bwb_variable *fnc_asc(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1118
struct bwb_variable *fnc_string(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1119
struct bwb_variable *fnc_spc(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1120
struct bwb_variable *fnc_space(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1121
struct bwb_variable *fnc_environ(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1122
struct bwb_variable *fnc_pos(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1123
struct bwb_variable *fnc_err(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1124
struct bwb_variable *fnc_erl(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1125
struct bwb_variable *fnc_loc(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1126
struct bwb_variable *fnc_lof(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1127
struct bwb_variable *fnc_eof(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 1129
struct bwb_variable *fnc_instr(int argc , struct bwb_variable *argv , int unique_id ) ;
#line 468 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mes.h"
char err_devnum[22] ;
#line 50 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static time_t t  ;
#line 51 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static struct tm *lt  ;
#line 64 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
int fnc_init(int task ) 
{ 
  register int n___0 ;
  struct bwb_function *f ;

  {
  {
#line 75
  strcpy((char */* __restrict  */)(fnc_start.name), (char const   */* __restrict  */)"FNC_START");
#line 76
  fnc_start.type = 'X';
#line 77
  fnc_start.vector = & fnc_null;
#line 78
  strcpy((char */* __restrict  */)(fnc_end.name), (char const   */* __restrict  */)"FNC_END");
#line 79
  fnc_end.type = 'x';
#line 80
  fnc_end.vector = & fnc_null;
#line 81
  fnc_end.next = & fnc_end;
#line 83
  f = & fnc_start;
#line 89
  n___0 = 0;
  }
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (n___0 < 45)) {
#line 89
      goto while_break;
    }
#line 91
    f->next = & bwb_prefuncs[n___0];
#line 92
    f = f->next;
#line 89
    n___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  f->next = & fnc_end;
#line 99
  return (-1);
}
}
#line 125 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static char *tbuf___10  ;
#line 126 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static int init___17  =    0;
#line 115 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
struct bwb_function *fnc_find(char *buffer ) 
{ 
  struct bwb_function *f ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 128
  tmp = strlen((char const   *)buffer);
  }
#line 128
  if (tmp == 0UL) {
#line 130
    return ((struct bwb_function *)((void *)0));
  }
#line 135
  if (init___17 == 0) {
    {
#line 137
    init___17 = -1;
#line 140
    tmp___0 = CALLOC((size_t )5001, sizeof(char ), (char *)"fnc_find");
#line 140
    tbuf___10 = (char *)tmp___0;
    }
#line 140
    if ((unsigned long )tbuf___10 == (unsigned long )((void *)0)) {
      {
#line 143
      bwb_error((char *)"in fnc_find(): failed to find memory for tbuf");
      }
    }
  }
  {
#line 155
  strcpy((char */* __restrict  */)tbuf___10, (char const   */* __restrict  */)buffer);
#line 156
  bwb_strtoupper(tbuf___10);
#line 158
  f = fnc_start.next;
  }
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! ((unsigned long )f != (unsigned long )(& fnc_end))) {
#line 158
      goto while_break;
    }
    {
#line 160
    tmp___1 = strcmp((char const   *)(f->name), (char const   *)tbuf___10);
    }
#line 160
    if (tmp___1 == 0) {
#line 166
      return (f);
    }
#line 158
    f = f->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  return ((struct bwb_function *)((void *)0));
}
}
#line 197 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static struct bwb_variable nvar___12  ;
#line 198 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static int init___18  =    0;
#line 187 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
struct bwb_variable *fnc_null(int argc , struct bwb_variable *argv , int unique_id ) 
{ 


  {
#line 202
  if (init___18 == 0) {
    {
#line 204
    init___18 = -1;
#line 205
    var_make(& nvar___12, 1);
    }
  }
#line 208
  return (& nvar___12);
}
}
#line 237 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static struct bwb_variable nvar___13  ;
#line 238 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static int init___19  =    0;
#line 239 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static char t_string[4]  ;
#line 227 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
struct bwb_variable *fnc_tab(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  bstring *b___4 ;
  bnumber tmp ;

  {
#line 244
  if (init___19 == 0) {
    {
#line 246
    init___19 = -1;
#line 247
    var_make(& nvar___13, '$');
    }
  }
#line 252
  if (argc < 1) {
    {
#line 255
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough parameters (%d) to function TAB().",
            argc);
#line 257
    bwb_error(bwb_ebuf);
#line 261
    break_handler();
    }
#line 262
    return ((struct bwb_variable *)((void *)0));
  } else
#line 264
  if (argc > 1) {
    {
#line 267
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to function TAB().",
            argc);
#line 269
    bwb_error(bwb_ebuf);
#line 273
    break_handler();
    }
#line 274
    return ((struct bwb_variable *)((void *)0));
  }
  {
#line 277
  t_string[0] = (char)2;
#line 278
  tmp = var_getnval(argv + 0);
#line 278
  t_string[1] = (char )tmp;
#line 279
  t_string[2] = (char )'\000';
#line 281
  b___4 = var_getsval(& nvar___13);
#line 282
  str_ctob(b___4, t_string);
  }
#line 284
  return (& nvar___13);
}
}
#line 314 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static struct bwb_variable nvar___14  ;
#line 315 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static int init___20  =    0;
#line 316 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static char *tbuf___11  ;
#line 304 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
struct bwb_variable *fnc_date(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  void *tmp ;
  bstring *tmp___0 ;

  {
#line 320
  if (init___20 == 0) {
    {
#line 322
    init___20 = -1;
#line 323
    var_make(& nvar___14, '$');
#line 326
    tmp = CALLOC((size_t )5001, sizeof(char ), (char *)"fnc_date");
#line 326
    tbuf___11 = (char *)tmp;
    }
#line 326
    if ((unsigned long )tbuf___11 == (unsigned long )((void *)0)) {
      {
#line 329
      bwb_error((char *)"in fnc_date(): failed to get memory for tbuf");
      }
    }
  }
  {
#line 336
  time(& t);
#line 337
  lt = localtime((time_t const   *)(& t));
#line 339
  sprintf((char */* __restrict  */)tbuf___11, (char const   */* __restrict  */)"%02d-%02d-%04d",
          lt->tm_mon + 1, lt->tm_mday, 1900 + lt->tm_year);
#line 341
  tmp___0 = var_findsval(& nvar___14, nvar___14.array_pos);
#line 341
  str_ctob(tmp___0, tbuf___11);
  }
#line 343
  return (& nvar___14);
}
}
#line 370 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static struct bwb_variable nvar___15  ;
#line 371 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static char *tbuf___12  ;
#line 372 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static int init___21  =    0;
#line 360 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
struct bwb_variable *fnc_time(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  void *tmp ;
  bstring *tmp___0 ;

  {
#line 376
  if (init___21 == 0) {
    {
#line 378
    init___21 = -1;
#line 379
    var_make(& nvar___15, '$');
#line 382
    tmp = CALLOC((size_t )5001, sizeof(char ), (char *)"fnc_time");
#line 382
    tbuf___12 = (char *)tmp;
    }
#line 382
    if ((unsigned long )tbuf___12 == (unsigned long )((void *)0)) {
      {
#line 385
      bwb_error((char *)"in fnc_time(): failed to get memory for tbuf");
      }
    }
  }
  {
#line 392
  time(& t);
#line 393
  lt = localtime((time_t const   *)(& t));
#line 395
  sprintf((char */* __restrict  */)tbuf___12, (char const   */* __restrict  */)"%02d:%02d:%02d",
          lt->tm_hour, lt->tm_min, lt->tm_sec);
#line 397
  tmp___0 = var_findsval(& nvar___15, nvar___15.array_pos);
#line 397
  str_ctob(tmp___0, tbuf___12);
  }
#line 399
  return (& nvar___15);
}
}
#line 427 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static struct bwb_variable nvar___16  ;
#line 429 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static int init___22  =    0;
#line 417 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
struct bwb_variable *fnc_chr(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  char tbuf___20[5001] ;
  bnumber tmp ;
  bstring *tmp___0 ;

  {
#line 442
  if (init___22 == 0) {
    {
#line 444
    init___22 = -1;
#line 445
    var_make(& nvar___16, '$');
    }
  }
#line 455
  if (argc < 1) {
    {
#line 457
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough arguments to function CHR$()");
#line 458
    bwb_error(bwb_ebuf);
    }
#line 459
    return ((struct bwb_variable *)((void *)0));
  } else
#line 461
  if (argc > 1) {
    {
#line 463
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to function CHR$().",
            argc);
#line 465
    bwb_error(bwb_ebuf);
    }
#line 466
    return ((struct bwb_variable *)((void *)0));
  }
  {
#line 480
  tmp = var_getnval(argv + 0);
#line 480
  tbuf___20[0] = (char )tmp;
#line 481
  tbuf___20[1] = (char )'\000';
#line 482
  tmp___0 = var_findsval(& nvar___16, nvar___16.array_pos);
#line 482
  str_ctob(tmp___0, tbuf___20);
  }
#line 494
  return (& nvar___16);
}
}
#line 520 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static struct bwb_variable nvar___17  ;
#line 521 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static int init___23  =    0;
#line 522 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static char *tbuf___13  ;
#line 510 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
struct bwb_variable *fnc_len(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  void *tmp ;
  bstring *tmp___0 ;
  bnumber *tmp___1 ;
  size_t tmp___2 ;

  {
#line 526
  if (init___23 == 0) {
    {
#line 528
    init___23 = -1;
#line 529
    var_make(& nvar___17, 1);
#line 532
    tmp = CALLOC((size_t )5001, sizeof(char ), (char *)"fnc_len");
#line 532
    tbuf___13 = (char *)tmp;
    }
#line 532
    if ((unsigned long )tbuf___13 == (unsigned long )((void *)0)) {
      {
#line 535
      bwb_error((char *)"in fnc_len(): failed to get memory for tbuf");
      }
    }
  }
#line 545
  if (argc < 1) {
    {
#line 547
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough parameters (%d) to function LEN().",
            argc);
#line 549
    bwb_error(bwb_ebuf);
    }
#line 550
    return ((struct bwb_variable *)((void *)0));
  } else
#line 552
  if (argc > 1) {
    {
#line 554
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to function LEN().",
            argc);
#line 556
    bwb_error(bwb_ebuf);
    }
#line 557
    return ((struct bwb_variable *)((void *)0));
  }
  {
#line 568
  tmp___0 = var_getsval(argv + 0);
#line 568
  str_btoc(tbuf___13, tmp___0);
#line 569
  tmp___1 = var_findnval(& nvar___17, nvar___17.array_pos);
#line 569
  tmp___2 = strlen((char const   *)tbuf___13);
#line 569
  *tmp___1 = (bnumber )tmp___2;
  }
#line 572
  return (& nvar___17);
}
}
#line 598 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static struct bwb_variable nvar___18  ;
#line 599 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static int init___24  =    0;
#line 588 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
struct bwb_variable *fnc_pos(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  bnumber *tmp ;

  {
#line 603
  if (init___24 == 0) {
    {
#line 605
    init___24 = -1;
#line 606
    var_make(& nvar___18, 1);
    }
  }
  {
#line 609
  tmp = var_findnval(& nvar___18, nvar___18.array_pos);
#line 609
  *tmp = (bnumber )prn_col;
  }
#line 611
  return (& nvar___18);
}
}
#line 640 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static struct bwb_variable nvar___19  ;
#line 641 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static time_t now  ;
#line 642 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static int init___25  =    0;
#line 630 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
struct bwb_variable *fnc_timer(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  bnumber *tmp ;
  double tmp___0 ;

  {
#line 646
  if (init___25 == 0) {
    {
#line 648
    init___25 = -1;
#line 649
    var_make(& nvar___19, 1);
    }
  }
  {
#line 652
  time(& now);
#line 654
  tmp = var_findnval(& nvar___19, nvar___19.array_pos);
#line 654
  tmp___0 = fmod((double )now, (double )86400);
#line 654
  *tmp = (bnumber )((float )tmp___0);
  }
#line 657
  return (& nvar___19);
}
}
#line 682 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static struct bwb_variable nvar___20  ;
#line 687 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static int init___26  =    0;
#line 672 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
struct bwb_variable *fnc_mid(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  register int c ;
  char target_string[5001] ;
  int target_counter ;
  int num_spaces ;
  char tbuf___20[5001] ;
  bstring *tmp ;
  bnumber tmp___0 ;
  bstring *tmp___1 ;
  size_t tmp___2 ;
  bnumber tmp___3 ;
  bstring *tmp___4 ;

  {
#line 691
  if (init___26 == 0) {
    {
#line 693
    init___26 = -1;
#line 694
    var_make(& nvar___20, '$');
    }
  }
#line 700
  if (argc < 2) {
    {
#line 702
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough arguments to function MID$()");
#line 703
    bwb_error(bwb_ebuf);
    }
#line 704
    return (& nvar___20);
  }
#line 707
  if (argc > 3) {
    {
#line 709
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Two many arguments to function MID$()");
#line 710
    bwb_error(bwb_ebuf);
    }
#line 711
    return (& nvar___20);
  }
  {
#line 723
  tmp = var_getsval(argv + 0);
#line 723
  str_btoc(target_string, tmp);
#line 724
  tmp___0 = var_getnval(argv + 1);
#line 724
  target_counter = (int )tmp___0 - 1;
#line 725
  tmp___2 = strlen((char const   *)(target_string));
  }
#line 725
  if (target_counter > (int )tmp___2) {
    {
#line 727
    tbuf___20[0] = (char )'\000';
#line 728
    tmp___1 = var_findsval(& nvar___20, nvar___20.array_pos);
#line 728
    str_ctob(tmp___1, tbuf___20);
    }
#line 729
    return (& nvar___20);
  }
#line 732
  if (argc == 3) {
    {
#line 734
    tmp___3 = var_getnval(argv + 2);
#line 734
    num_spaces = (int )tmp___3;
    }
  } else {
#line 738
    num_spaces = 5000;
  }
#line 747
  c = 0;
#line 748
  tbuf___20[c] = (char )'\000';
  {
#line 749
  while (1) {
    while_continue: /* CIL Label */ ;
#line 749
    if (c < num_spaces) {
#line 749
      if (! ((int )target_string[target_counter] != 0)) {
#line 749
        goto while_break;
      }
    } else {
#line 749
      goto while_break;
    }
#line 751
    tbuf___20[c] = target_string[target_counter];
#line 752
    c ++;
#line 753
    tbuf___20[c] = (char )'\000';
#line 754
    target_counter ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 756
  tmp___4 = var_findsval(& nvar___20, nvar___20.array_pos);
#line 756
  str_ctob(tmp___4, tbuf___20);
  }
#line 758
  return (& nvar___20);
}
}
#line 783 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static struct bwb_variable nvar___21  ;
#line 788 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static int init___27  =    0;
#line 773 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
struct bwb_variable *fnc_left(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  register int c ;
  char target_string[5001] ;
  int target_counter ;
  int num_spaces ;
  char tbuf___20[5001] ;
  bstring *tmp ;
  bnumber tmp___0 ;
  bstring *tmp___1 ;

  {
#line 792
  if (init___27 == 0) {
    {
#line 794
    init___27 = -1;
#line 795
    var_make(& nvar___21, '$');
    }
  }
#line 801
  if (argc < 2) {
    {
#line 803
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough arguments to function LEFT$()");
#line 804
    bwb_error(bwb_ebuf);
    }
#line 805
    return (& nvar___21);
  }
#line 808
  if (argc > 2) {
    {
#line 810
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Two many arguments to function LEFT$()");
#line 811
    bwb_error(bwb_ebuf);
    }
#line 812
    return (& nvar___21);
  }
  {
#line 824
  tmp = var_getsval(argv + 0);
#line 824
  str_btoc(tbuf___20, tmp);
#line 825
  target_counter = 0;
#line 826
  tmp___0 = var_getnval(argv + 1);
#line 826
  num_spaces = (int )tmp___0;
#line 834
  c = 0;
#line 835
  target_string[0] = (char )'\000';
  }
  {
#line 836
  while (1) {
    while_continue: /* CIL Label */ ;
#line 836
    if (c < num_spaces) {
#line 836
      if (! ((int )tbuf___20[c] != 0)) {
#line 836
        goto while_break;
      }
    } else {
#line 836
      goto while_break;
    }
#line 838
    target_string[target_counter] = tbuf___20[c];
#line 839
    target_counter ++;
#line 840
    target_string[target_counter] = (char )'\000';
#line 841
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 843
  tmp___1 = var_findsval(& nvar___21, nvar___21.array_pos);
#line 843
  str_ctob(tmp___1, target_string);
  }
#line 845
  return (& nvar___21);
}
}
#line 870 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static struct bwb_variable nvar___22  ;
#line 875 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static int init___28  =    0;
#line 860 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
struct bwb_variable *fnc_right(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  register int c ;
  char target_string[5001] ;
  int target_counter ;
  int num_spaces ;
  char tbuf___20[5001] ;
  bstring *tmp ;
  size_t tmp___0 ;
  bnumber tmp___1 ;
  bstring *tmp___2 ;

  {
#line 879
  if (init___28 == 0) {
    {
#line 881
    init___28 = -1;
#line 882
    var_make(& nvar___22, '$');
    }
  }
#line 888
  if (argc < 2) {
    {
#line 890
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough arguments to function RIGHT$()");
#line 891
    bwb_error(bwb_ebuf);
    }
#line 892
    return (& nvar___22);
  }
#line 895
  if (argc > 2) {
    {
#line 897
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Two many arguments to function RIGHT$()");
#line 898
    bwb_error(bwb_ebuf);
    }
#line 899
    return (& nvar___22);
  }
  {
#line 911
  tmp = var_getsval(argv + 0);
#line 911
  str_btoc(target_string, tmp);
#line 912
  tmp___0 = strlen((char const   *)(target_string));
#line 912
  tmp___1 = var_getnval(argv + 1);
#line 912
  target_counter = (int )(tmp___0 - (size_t )((int )tmp___1));
#line 913
  num_spaces = 5000;
#line 921
  c = 0;
#line 922
  tbuf___20[c] = (char )'\000';
  }
  {
#line 923
  while (1) {
    while_continue: /* CIL Label */ ;
#line 923
    if (c < num_spaces) {
#line 923
      if (! ((int )target_string[target_counter] != 0)) {
#line 923
        goto while_break;
      }
    } else {
#line 923
      goto while_break;
    }
#line 925
    tbuf___20[c] = target_string[target_counter];
#line 926
    c ++;
#line 927
    tbuf___20[c] = (char )'\000';
#line 928
    target_counter ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 930
  tmp___2 = var_findsval(& nvar___22, nvar___22.array_pos);
#line 930
  str_ctob(tmp___2, tbuf___20);
  }
#line 932
  return (& nvar___22);
}
}
#line 959 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static struct bwb_variable nvar___23  ;
#line 960 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static char *tbuf___14  ;
#line 961 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static int init___29  =    0;
#line 949 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
struct bwb_variable *fnc_asc(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  void *tmp ;
  bstring *tmp___0 ;
  bnumber *tmp___1 ;

  {
#line 965
  if (init___29 == 0) {
    {
#line 967
    init___29 = -1;
#line 968
    var_make(& nvar___23, 1);
#line 971
    tmp = CALLOC((size_t )5001, sizeof(char ), (char *)"fnc_asc");
#line 971
    tbuf___14 = (char *)tmp;
    }
#line 971
    if ((unsigned long )tbuf___14 == (unsigned long )((void *)0)) {
      {
#line 974
      bwb_error((char *)"in fnc_asc(): failed to get memory for tbuf");
      }
    }
  }
#line 984
  if (argc < 1) {
    {
#line 986
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough parameters (%d) to function ASC().",
            argc);
#line 988
    bwb_error(bwb_ebuf);
    }
#line 989
    return ((struct bwb_variable *)((void *)0));
  } else
#line 991
  if (argc > 1) {
    {
#line 993
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to function ASC().",
            argc);
#line 995
    bwb_error(bwb_ebuf);
    }
#line 996
    return ((struct bwb_variable *)((void *)0));
  }
#line 1005
  if ((argv + 0)->type != 36) {
    {
#line 1008
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Argument to function ASC() must be a string.");
#line 1009
    bwb_error(bwb_ebuf);
    }
#line 1013
    return ((struct bwb_variable *)((void *)0));
  }
  {
#line 1018
  tmp___0 = var_findsval(argv + 0, (argv + 0)->array_pos);
#line 1018
  str_btoc(tbuf___14, tmp___0);
#line 1019
  tmp___1 = var_findnval(& nvar___23, nvar___23.array_pos);
#line 1019
  *tmp___1 = (bnumber )*(tbuf___14 + 0);
  }
#line 1027
  return (& nvar___23);
}
}
#line 1052 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static struct bwb_variable nvar___24  ;
#line 1056 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static char *tbuf___15  ;
#line 1057 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static int init___30  =    0;
#line 1042 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
struct bwb_variable *fnc_string(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  int length ;
  register int i ;
  char c ;
  void *tmp ;
  bnumber tmp___0 ;
  bstring *tmp___1 ;
  bnumber tmp___2 ;
  bstring *tmp___3 ;

  {
#line 1061
  if (init___30 == 0) {
    {
#line 1063
    init___30 = -1;
#line 1064
    var_make(& nvar___24, '$');
#line 1067
    tmp = CALLOC((size_t )5001, sizeof(char ), (char *)"fnc_string");
#line 1067
    tbuf___15 = (char *)tmp;
    }
#line 1067
    if ((unsigned long )tbuf___15 == (unsigned long )((void *)0)) {
      {
#line 1070
      bwb_error((char *)"in fnc_string(): failed to get memory for tbuf");
      }
    }
  }
#line 1080
  if (argc < 2) {
    {
#line 1082
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough parameters (%d) to function STRING$().",
            argc);
#line 1084
    bwb_error(bwb_ebuf);
    }
#line 1085
    return ((struct bwb_variable *)((void *)0));
  } else
#line 1087
  if (argc > 2) {
    {
#line 1089
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to function STRING$().",
            argc);
#line 1091
    bwb_error(bwb_ebuf);
    }
#line 1092
    return ((struct bwb_variable *)((void *)0));
  }
  {
#line 1101
  strcpy((char */* __restrict  */)(nvar___24.name), (char const   */* __restrict  */)"(string$)!");
#line 1102
  nvar___24.type = '$';
#line 1103
  *(tbuf___15 + 0) = (char )'\000';
#line 1104
  tmp___0 = var_getnval(argv + 0);
#line 1104
  length = (int )tmp___0;
  }
#line 1106
  if ((argv + 1)->type == 36) {
    {
#line 1108
    tmp___1 = var_getsval(argv + 1);
#line 1108
    str_btoc(tbuf___15, tmp___1);
#line 1109
    c = *(tbuf___15 + 0);
    }
  } else {
    {
#line 1113
    tmp___2 = var_getnval(argv + 1);
#line 1113
    c = (char )tmp___2;
    }
  }
#line 1127
  i = 0;
  {
#line 1127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1127
    if (! (i < length)) {
#line 1127
      goto while_break;
    }
#line 1129
    *(tbuf___15 + i) = c;
#line 1130
    *(tbuf___15 + (i + 1)) = (char )'\000';
#line 1127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1132
  tmp___3 = var_findsval(& nvar___24, nvar___24.array_pos);
#line 1132
  str_ctob(tmp___3, tbuf___15);
  }
#line 1134
  return (& nvar___24);
}
}
#line 1161 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static struct bwb_variable nvar___25  ;
#line 1162 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static int init___31  =    0;
#line 1151 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
struct bwb_variable *fnc_instr(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  int n_pos ;
  int x_pos ;
  int y_pos ;
  int start_pos ;
  register int n___0 ;
  char xbuf[5001] ;
  char ybuf[5001] ;
  bnumber tmp ;
  bstring *tmp___0 ;
  bstring *tmp___1 ;
  bnumber *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  bnumber *tmp___6 ;

  {
#line 1171
  if (init___31 == 0) {
    {
#line 1173
    init___31 = -1;
#line 1174
    var_make(& nvar___25, 1);
    }
  }
#line 1180
  if (argc < 2) {
    {
#line 1182
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough parameters (%d) to function INSTR().",
            argc);
#line 1184
    bwb_error(bwb_ebuf);
    }
#line 1185
    return ((struct bwb_variable *)((void *)0));
  } else
#line 1187
  if (argc > 3) {
    {
#line 1189
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to function INSTR().",
            argc);
#line 1191
    bwb_error(bwb_ebuf);
    }
#line 1192
    return ((struct bwb_variable *)((void *)0));
  }
#line 1203
  if (argc == 3) {
#line 1205
    n_pos = 0;
#line 1206
    x_pos = 1;
#line 1207
    y_pos = 2;
  } else {
#line 1211
    n_pos = -1;
#line 1212
    x_pos = 0;
#line 1213
    y_pos = 1;
  }
#line 1218
  if (n_pos == 0) {
    {
#line 1220
    tmp = var_getnval(argv + n_pos);
#line 1220
    start_pos = (int )tmp - 1;
    }
  } else {
#line 1224
    start_pos = 0;
  }
  {
#line 1229
  tmp___0 = var_getsval(argv + x_pos);
#line 1229
  str_btoc(xbuf, tmp___0);
#line 1230
  tmp___1 = var_getsval(argv + y_pos);
#line 1230
  str_btoc(ybuf, tmp___1);
#line 1234
  n___0 = start_pos;
  }
  {
#line 1234
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1234
    tmp___5 = strlen((char const   *)(xbuf));
    }
#line 1234
    if (! (n___0 < (int )tmp___5)) {
#line 1234
      goto while_break;
    }
    {
#line 1236
    tmp___3 = strlen((char const   *)(ybuf));
#line 1236
    tmp___4 = strncmp((char const   *)(& xbuf[n___0]), (char const   *)(ybuf), tmp___3);
    }
#line 1236
    if (tmp___4 == 0) {
      {
#line 1238
      tmp___2 = var_findnval(& nvar___25, nvar___25.array_pos);
#line 1238
      *tmp___2 = (bnumber )n___0 + (bnumber )1;
      }
#line 1239
      return (& nvar___25);
    }
#line 1234
    n___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1245
  tmp___6 = var_findnval(& nvar___25, nvar___25.array_pos);
#line 1245
  *tmp___6 = (bnumber )0;
  }
#line 1246
  return (& nvar___25);
}
}
#line 1264 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
struct bwb_variable *fnc_spc(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  struct bwb_variable *tmp ;

  {
  {
#line 1274
  tmp = fnc_space(argc, argv, unique_id);
  }
#line 1274
  return (tmp);
}
}
#line 1301 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static struct bwb_variable nvar___26  ;
#line 1302 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static char *tbuf___16  ;
#line 1303 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static int init___32  =    0;
#line 1291 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
struct bwb_variable *fnc_space(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  int spaces ;
  register int i ;
  bstring *b___4 ;
  void *tmp ;
  bnumber tmp___0 ;

  {
#line 1310
  if (argc < 1) {
    {
#line 1313
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough parameters (%d) to function SPACE$().",
            argc);
#line 1315
    bwb_error(bwb_ebuf);
#line 1319
    break_handler();
    }
#line 1320
    return ((struct bwb_variable *)((void *)0));
  } else
#line 1322
  if (argc > 1) {
    {
#line 1325
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to function SPACE$().",
            argc);
#line 1327
    bwb_error(bwb_ebuf);
#line 1331
    break_handler();
    }
#line 1332
    return ((struct bwb_variable *)((void *)0));
  }
#line 1337
  if (init___32 == 0) {
    {
#line 1339
    init___32 = -1;
#line 1340
    var_make(& nvar___26, '$');
#line 1343
    tmp = CALLOC((size_t )5001, sizeof(char ), (char *)"fnc_space");
#line 1343
    tbuf___16 = (char *)tmp;
    }
#line 1343
    if ((unsigned long )tbuf___16 == (unsigned long )((void *)0)) {
      {
#line 1346
      bwb_error((char *)"in fnc_space(): failed to get memory for tbuf");
      }
    }
  }
  {
#line 1353
  *(tbuf___16 + 0) = (char )'\000';
#line 1354
  tmp___0 = var_getnval(argv + 0);
#line 1354
  spaces = (int )tmp___0;
#line 1358
  i = 0;
  }
  {
#line 1358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1358
    if (! (i < spaces)) {
#line 1358
      goto while_break;
    }
#line 1360
    *(tbuf___16 + i) = (char )' ';
#line 1361
    *(tbuf___16 + (i + 1)) = (char )'\000';
#line 1358
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1364
  b___4 = var_getsval(& nvar___26);
#line 1365
  str_ctob(b___4, tbuf___16);
  }
#line 1367
  return (& nvar___26);
}
}
#line 1395 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static struct bwb_variable nvar___27  ;
#line 1396 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static int init___33  =    0;
#line 1383 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
struct bwb_variable *fnc_environ(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  char tbuf___20[5001] ;
  char tmp[5001] ;
  bstring *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  bstring *tmp___3 ;

  {
#line 1400
  if (init___33 == 0) {
    {
#line 1402
    init___33 = -1;
#line 1403
    var_make(& nvar___27, '$');
    }
  }
#line 1409
  if (argc < 1) {
    {
#line 1411
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough parameters (%d) to function ENVIRON$().",
            argc);
#line 1413
    bwb_error(bwb_ebuf);
    }
#line 1414
    return ((struct bwb_variable *)((void *)0));
  } else
#line 1416
  if (argc > 1) {
    {
#line 1418
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to function ENVIRON$().",
            argc);
#line 1420
    bwb_error(bwb_ebuf);
    }
#line 1421
    return ((struct bwb_variable *)((void *)0));
  }
  {
#line 1432
  tmp___0 = var_getsval(argv + 0);
#line 1432
  str_btoc(tbuf___20, tmp___0);
#line 1444
  tmp___2 = getenv((char const   *)(tbuf___20));
  }
#line 1444
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
    {
#line 1444
    tmp___1 = getenv((char const   *)(tbuf___20));
#line 1444
    strncpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)tmp___1,
            sizeof(tmp) - 1UL);
    }
  }
  {
#line 1446
  tmp___3 = var_findsval(& nvar___27, nvar___27.array_pos);
#line 1446
  str_ctob(tmp___3, tmp);
  }
#line 1450
  return (& nvar___27);
}
}
#line 1484 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static struct bwb_variable nvar___28  ;
#line 1485 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static int init___34  =    0;
#line 1474 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
struct bwb_variable *fnc_err(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  bnumber *tmp ;

  {
#line 1489
  if (init___34 == 0) {
    {
#line 1491
    init___34 = -1;
#line 1492
    var_make(& nvar___28, 1);
    }
  }
  {
#line 1495
  tmp = var_findnval(& nvar___28, nvar___28.array_pos);
#line 1495
  *tmp = (bnumber )err_number;
  }
#line 1497
  return (& nvar___28);
}
}
#line 1523 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static struct bwb_variable nvar___29  ;
#line 1524 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static int init___35  =    0;
#line 1513 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
struct bwb_variable *fnc_erl(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  bnumber *tmp ;

  {
#line 1528
  if (init___35 == 0) {
    {
#line 1530
    init___35 = -1;
#line 1531
    var_make(& nvar___29, 1);
    }
  }
  {
#line 1534
  tmp = var_findnval(& nvar___29, nvar___29.array_pos);
#line 1534
  *tmp = (bnumber )err_line;
  }
#line 1536
  return (& nvar___29);
}
}
#line 1562 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static struct bwb_variable nvar___30  ;
#line 1563 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static int init___36  =    0;
#line 1552 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
struct bwb_variable *fnc_loc(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  int dev_number ;
  bnumber tmp ;
  bnumber *tmp___0 ;
  bnumber *tmp___1 ;

  {
#line 1572
  if (argc < 1) {
    {
#line 1575
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough parameters (%d) to function LOC().",
            argc);
#line 1577
    bwb_error(bwb_ebuf);
    }
#line 1581
    return ((struct bwb_variable *)((void *)0));
  } else
#line 1583
  if (argc > 1) {
    {
#line 1586
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to function LOC().",
            argc);
#line 1588
    bwb_error(bwb_ebuf);
    }
#line 1592
    return ((struct bwb_variable *)((void *)0));
  }
  {
#line 1595
  tmp = var_getnval(argv + 0);
#line 1595
  dev_number = (int )tmp;
  }
#line 1597
  if (init___36 == 0) {
    {
#line 1599
    init___36 = -1;
#line 1600
    var_make(& nvar___30, 1);
    }
  }
#line 1605
  if ((dev_table + dev_number)->loc == 0) {
    {
#line 1607
    tmp___0 = var_findnval(& nvar___30, nvar___30.array_pos);
#line 1607
    *tmp___0 = (bnumber )0;
    }
  } else {
    {
#line 1611
    tmp___1 = var_findnval(& nvar___30, nvar___30.array_pos);
#line 1611
    *tmp___1 = (bnumber )(dev_table + dev_number)->next_record;
    }
  }
#line 1615
  return (& nvar___30);
}
}
#line 1640 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static struct bwb_variable nvar___31  ;
#line 1641 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static int init___37  =    0;
#line 1630 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
struct bwb_variable *fnc_eof(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  int dev_number ;
  bnumber tmp ;
  bnumber *tmp___0 ;
  bnumber *tmp___1 ;
  bnumber *tmp___2 ;
  bnumber *tmp___3 ;
  long tmp___4 ;

  {
#line 1651
  if (argc < 1) {
    {
#line 1654
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough parameters (%d) to function EOF().",
            argc);
#line 1656
    bwb_error(bwb_ebuf);
    }
#line 1660
    return ((struct bwb_variable *)((void *)0));
  } else
#line 1662
  if (argc > 1) {
    {
#line 1665
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to function EOF().",
            argc);
#line 1667
    bwb_error(bwb_ebuf);
    }
#line 1671
    return ((struct bwb_variable *)((void *)0));
  }
  {
#line 1674
  tmp = var_getnval(argv + 0);
#line 1674
  dev_number = (int )tmp;
  }
#line 1676
  if (init___37 == 0) {
    {
#line 1678
    init___37 = -1;
#line 1679
    var_make(& nvar___31, 1);
    }
  }
#line 1684
  if ((dev_table + dev_number)->mode == -1) {
    {
#line 1686
    bwb_error(err_devnum);
#line 1687
    tmp___0 = var_findnval(& nvar___31, nvar___31.array_pos);
#line 1687
    *tmp___0 = (bnumber )-1;
    }
  } else
#line 1689
  if ((dev_table + dev_number)->mode == 0) {
    {
#line 1691
    bwb_error(err_devnum);
#line 1692
    tmp___1 = var_findnval(& nvar___31, nvar___31.array_pos);
#line 1692
    *tmp___1 = (bnumber )-1;
    }
  } else {
    {
#line 1705
    tmp___4 = ftell((dev_table + dev_number)->cfp);
    }
#line 1705
    if (tmp___4 != (long )(dev_table + dev_number)->lof) {
      {
#line 1708
      tmp___2 = var_findnval(& nvar___31, nvar___31.array_pos);
#line 1708
      *tmp___2 = (bnumber )0;
      }
    } else {
      {
#line 1712
      tmp___3 = var_findnval(& nvar___31, nvar___31.array_pos);
#line 1712
      *tmp___3 = (bnumber )-1;
      }
    }
  }
#line 1715
  return (& nvar___31);
}
}
#line 1740 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static struct bwb_variable nvar___32  ;
#line 1741 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
static int init___38  =    0;
#line 1730 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_fnc.c"
struct bwb_variable *fnc_lof(int argc , struct bwb_variable *argv , int unique_id ) 
{ 
  int dev_number ;
  bnumber tmp ;
  bnumber *tmp___0 ;

  {
#line 1756
  if (argc < 1) {
    {
#line 1759
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Not enough parameters (%d) to function LOF().",
            argc);
#line 1761
    bwb_error(bwb_ebuf);
    }
#line 1765
    return ((struct bwb_variable *)((void *)0));
  } else
#line 1767
  if (argc > 1) {
    {
#line 1770
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Too many parameters (%d) to function LOF().",
            argc);
#line 1772
    bwb_error(bwb_ebuf);
    }
#line 1776
    return ((struct bwb_variable *)((void *)0));
  }
  {
#line 1779
  tmp = var_getnval(argv + 0);
#line 1779
  dev_number = (int )tmp;
  }
#line 1781
  if (init___38 == 0) {
    {
#line 1783
    init___38 = -1;
#line 1784
    var_make(& nvar___32, 1);
    }
  }
  {
#line 1813
  tmp___0 = var_findnval(& nvar___32, nvar___32.array_pos);
#line 1813
  *tmp___0 = (bnumber )(dev_table + dev_number)->lof;
  }
#line 1818
  return (& nvar___32);
}
}
#line 812 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
char *err_table[25] ;
#line 853
struct bwb_line *bwb_lerror(struct bwb_line *l ) ;
#line 915
struct bwb_line *bwb_width(struct bwb_line *l ) ;
#line 916
struct bwb_line *bwb_write(struct bwb_line *l ) ;
#line 956
struct bwb_line *bwb_print(struct bwb_line *l ) ;
#line 957
int bwb_xprint(struct bwb_line *l , FILE *f ) ;
#line 997
int prn_getwidth(FILE *f ) ;
#line 999
int prn_xxprintf(FILE *f , char *buffer ) ;
#line 1023
int xputc(FILE *f , char c ) ;
#line 465 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mes.h"
char err_incomplete[21] ;
#line 40 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
int prn_col  =    1;
#line 41 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static int prn_width  =    80;
#line 58
static int prn_cr(char *buffer , FILE *f ) ;
#line 59
static struct prn_fmt *get_prnfmt(char *buffer , int *position___7 , FILE *f ) ;
#line 60
static int bwb_xerror(char *message ) ;
#line 61
static int xxputc(FILE *f , char c ) ;
#line 62
static int xxxputc(FILE *f , char c ) ;
#line 63
static struct bwb_variable *bwb_esetovar(struct exp_ese *e___0 ) ;
#line 95 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static int pos  ;
#line 98 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static char *s_buffer___1  ;
#line 99 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static int init___39  =    0;
#line 86 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
struct bwb_line *bwb_print(struct bwb_line *l ) 
{ 
  FILE *fp ;
  int req_devnumber___0 ;
  struct exp_ese *v___0 ;
  void *tmp ;
  struct bwb_line *tmp___0 ;
  bnumber tmp___1 ;
  struct bwb_line *tmp___2 ;
  struct bwb_line *tmp___3 ;
  struct bwb_line *tmp___4 ;
  struct bwb_line *tmp___5 ;

  {
#line 108
  if (init___39 == 0) {
    {
#line 110
    init___39 = -1;
#line 113
    tmp = CALLOC((size_t )5001, sizeof(char ), (char *)"bwb_print");
#line 113
    s_buffer___1 = (char *)tmp;
    }
#line 113
    if ((unsigned long )s_buffer___1 == (unsigned long )((void *)0)) {
      {
#line 116
      bwb_error((char *)"in bwb_print(): failed to get memory for s_buffer");
      }
    }
  }
  {
#line 125
  adv_ws(l->buffer, & l->position);
  }
#line 128
  if ((int )*(l->buffer + l->position) == 35) {
    {
#line 130
    (l->position) ++;
#line 131
    adv_element(l->buffer, & l->position, s_buffer___1);
#line 132
    pos = 0;
#line 133
    v___0 = bwb_exp(s_buffer___1, 0, & pos);
#line 134
    adv_ws(l->buffer, & l->position);
    }
#line 135
    if ((int )*(l->buffer + l->position) == 44) {
#line 137
      (l->position) ++;
    } else {
      {
#line 142
      bwb_error((char *)"in bwb_print(): no comma after #n");
#line 146
      tmp___0 = bwb_zline(l);
      }
#line 146
      return (tmp___0);
    }
    {
#line 149
    tmp___1 = exp_getnval(v___0);
#line 149
    req_devnumber___0 = (int )tmp___1;
    }
#line 153
    if (req_devnumber___0 < 0) {
      {
#line 156
      bwb_error((char *)"in bwb_input(): Requested device number is out of range.");
#line 160
      tmp___2 = bwb_zline(l);
      }
#line 160
      return (tmp___2);
    } else
#line 153
    if (req_devnumber___0 >= 16) {
      {
#line 156
      bwb_error((char *)"in bwb_input(): Requested device number is out of range.");
#line 160
      tmp___2 = bwb_zline(l);
      }
#line 160
      return (tmp___2);
    }
#line 163
    if ((dev_table + req_devnumber___0)->mode == 0) {
      {
#line 167
      bwb_error((char *)"in bwb_input(): Requested device number is not open.");
#line 172
      tmp___3 = bwb_zline(l);
      }
#line 172
      return (tmp___3);
    } else
#line 163
    if ((dev_table + req_devnumber___0)->mode == -1) {
      {
#line 167
      bwb_error((char *)"in bwb_input(): Requested device number is not open.");
#line 172
      tmp___3 = bwb_zline(l);
      }
#line 172
      return (tmp___3);
    }
#line 175
    if ((dev_table + req_devnumber___0)->mode != 1) {
      {
#line 178
      bwb_error((char *)"in bwb_print(): Requested device is not open for OUTPUT.");
#line 183
      tmp___4 = bwb_zline(l);
      }
#line 183
      return (tmp___4);
    }
#line 194
    fp = (dev_table + req_devnumber___0)->cfp;
  } else {
#line 200
    fp = stdout;
  }
  {
#line 207
  bwb_xprint(l, fp);
#line 209
  tmp___5 = bwb_zline(l);
  }
#line 209
  return (tmp___5);
}
}
#line 234 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static int p  ;
#line 235 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static int fs_pos  ;
#line 237 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static char *format_string  ;
#line 238 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static char *output_string  ;
#line 239 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static char *element  ;
#line 240 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static char *prnbuf  ;
#line 241 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static int init___40  =    0;
#line 223 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
int bwb_xprint(struct bwb_line *l , FILE *f ) 
{ 
  struct exp_ese *e___0 ;
  int loop ;
  struct prn_fmt *format ;
  register int i ;
  register int j ;
  int dig_pos ;
  int dec_pos ;
  char tbuf___20[5001] ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  bstring *tmp___3 ;
  int tmp___4 ;
  bstring *tmp___5 ;
  bnumber tmp___6 ;
  bnumber tmp___7 ;
  bnumber tmp___8 ;
  bnumber tmp___9 ;
  size_t tmp___10 ;
  bnumber tmp___11 ;
  unsigned short const   **tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  unsigned short const   **tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  bnumber tmp___21 ;
  struct bwb_variable *tmp___22 ;
  int tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;

  {
#line 251
  if (init___40 == 0) {
    {
#line 253
    init___40 = -1;
#line 256
    tmp = CALLOC((size_t )5001, sizeof(char ), (char *)"bwb_xprint");
#line 256
    format_string = (char *)tmp;
    }
#line 256
    if ((unsigned long )format_string == (unsigned long )((void *)0)) {
      {
#line 259
      bwb_error((char *)"in bwb_xprint(): failed to get memory for format_string");
      }
    }
    {
#line 265
    tmp___0 = CALLOC((size_t )5001, sizeof(char ), (char *)"bwb_xprint");
#line 265
    output_string = (char *)tmp___0;
    }
#line 265
    if ((unsigned long )output_string == (unsigned long )((void *)0)) {
      {
#line 268
      bwb_error((char *)"in bwb_xprint(): failed to get memory for output_string");
      }
    }
    {
#line 274
    tmp___1 = CALLOC((size_t )5001, sizeof(char ), (char *)"bwb_xprint");
#line 274
    element = (char *)tmp___1;
    }
#line 274
    if ((unsigned long )element == (unsigned long )((void *)0)) {
      {
#line 277
      bwb_error((char *)"in bwb_xprint(): failed to get memory for element buffer");
      }
    }
    {
#line 283
    tmp___2 = CALLOC((size_t )5001, sizeof(char ), (char *)"bwb_xprint");
#line 283
    prnbuf = (char *)tmp___2;
    }
#line 283
    if ((unsigned long )prnbuf == (unsigned long )((void *)0)) {
      {
#line 286
      bwb_error((char *)"in bwb_xprint(): failed to get memory for prnbuf");
      }
    }
  }
  {
#line 295
  fs_pos = -1;
#line 299
  p = l->position;
#line 300
  adv_element(l->buffer, & p, format_string);
#line 301
  bwb_strtoupper(format_string);
#line 307
  tmp___4 = strcmp((char const   *)format_string, "USING");
  }
#line 307
  if (tmp___4 == 0) {
    {
#line 309
    l->position = p;
#line 310
    adv_ws(l->buffer, & l->position);
#line 314
    e___0 = bwb_exp(l->buffer, 0, & l->position);
    }
#line 315
    if ((int )e___0->type == 36) {
      {
#line 320
      tmp___3 = exp_getsval(e___0);
#line 320
      str_btoc(format_string, tmp___3);
#line 324
      fs_pos = 0;
#line 325
      adv_ws(l->buffer, & l->position);
      }
#line 326
      if ((int )*(l->buffer + l->position) == 59) {
        {
#line 328
        (l->position) ++;
#line 329
        adv_ws(l->buffer, & l->position);
        }
      } else {
        {
#line 334
        bwb_error((char *)"Failed to find \";\" after format string in PRINT USING");
        }
#line 338
        return (0);
      }
    } else {
      {
#line 352
      bwb_error((char *)"Failed to find format string after PRINT USING");
      }
#line 356
      return (0);
    }
  }
  {
#line 364
  adv_ws(l->buffer, & l->position);
  }
  {
#line 370
  if ((int )*(l->buffer + l->position) == 58) {
#line 370
    goto case_58;
  }
#line 370
  if ((int )*(l->buffer + l->position) == 13) {
#line 370
    goto case_58;
  }
#line 370
  if ((int )*(l->buffer + l->position) == 10) {
#line 370
    goto case_58;
  }
#line 370
  if ((int )*(l->buffer + l->position) == 0) {
#line 370
    goto case_58;
  }
#line 373
  goto switch_default;
  case_58: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 371
  prn_xprintf(f, (char *)"\n");
  }
#line 372
  return (-1);
  switch_default: /* CIL Label */ 
#line 374
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 379
  loop = -1;
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
#line 380
    if (! (loop == -1)) {
#line 380
      goto while_break;
    }
    {
#line 385
    e___0 = bwb_exp(l->buffer, 0, & l->position);
    }
#line 396
    if (e___0->operation != 0) {
      {
#line 404
      tmp___5 = exp_getsval(e___0);
#line 404
      str_btoc(element, tmp___5);
      }
    } else {
#line 408
      *(element + 0) = (char )'\000';
    }
#line 419
    if (fs_pos > -1) {
      {
#line 419
      tmp___25 = strlen((char const   *)element);
      }
#line 419
      if (tmp___25 > 0UL) {
        {
#line 424
        format = get_prnfmt(format_string, & fs_pos, f);
        }
        {
#line 434
        if (format->type == 36) {
#line 434
          goto case_36;
        }
#line 456
        if (format->type == 1) {
#line 456
          goto case_1;
        }
#line 580
        goto switch_default___0;
        case_36: /* CIL Label */ 
#line 435
        if ((int )e___0->type != 36) {
          {
#line 438
          bwb_error((char *)"Type mismatch in PRINT USING");
          }
        }
#line 443
        if (format->width == -1) {
          {
#line 444
          sprintf((char */* __restrict  */)output_string, (char const   */* __restrict  */)"%s",
                  element);
          }
        } else {
          {
#line 445
          sprintf((char */* __restrict  */)output_string, (char const   */* __restrict  */)"%.*s",
                  format->width, element);
          }
        }
        {
#line 453
        prn_xxprintf(f, output_string);
        }
#line 454
        goto switch_break___0;
        case_1: /* CIL Label */ 
#line 457
        if ((int )e___0->type == 36) {
          {
#line 460
          bwb_error((char *)"Type mismatch in PRINT USING");
          }
        }
#line 466
        if (format->exponential == -1) {
#line 472
          if (format->sign == -1) {
            {
#line 473
            tmp___6 = exp_getnval(e___0);
#line 473
            sprintf((char */* __restrict  */)output_string, (char const   */* __restrict  */)"%+e",
                    tmp___6);
            }
          } else {
            {
#line 475
            tmp___7 = exp_getnval(e___0);
#line 475
            sprintf((char */* __restrict  */)output_string, (char const   */* __restrict  */)"%e",
                    tmp___7);
            }
          }
        } else {
#line 483
          if (format->sign == -1) {
            {
#line 484
            tmp___8 = exp_getnval(e___0);
#line 484
            sprintf((char */* __restrict  */)output_string, (char const   */* __restrict  */)"%+*.*f",
                    format->width, format->precision, tmp___8);
            }
          } else
#line 486
          if (format->minus == -1) {
            {
#line 488
            tmp___9 = exp_getnval(e___0);
#line 488
            sprintf((char */* __restrict  */)output_string, (char const   */* __restrict  */)"%*.*f",
                    format->width, format->precision, tmp___9);
#line 490
            i = 0;
            }
            {
#line 490
            while (1) {
              while_continue___0: /* CIL Label */ ;
              {
#line 490
              tmp___10 = strlen((char const   *)output_string);
              }
#line 490
              if (! ((size_t )i < tmp___10)) {
#line 490
                goto while_break___0;
              }
#line 492
              if ((int )*(output_string + i) != 32) {
#line 494
                if ((int )*(output_string + i) == 45) {
                  {
#line 496
                  *(output_string + i) = (char )' ';
#line 497
                  strcat((char */* __restrict  */)output_string, (char const   */* __restrict  */)"-");
                  }
                } else {
                  {
#line 499
                  strcat((char */* __restrict  */)output_string, (char const   */* __restrict  */)" ");
                  }
                }
#line 500
                goto while_break___0;
              }
#line 490
              i ++;
            }
            while_break___0: /* CIL Label */ ;
            }
          } else {
            {
#line 505
            tmp___11 = exp_getnval(e___0);
#line 505
            sprintf((char */* __restrict  */)output_string, (char const   */* __restrict  */)"%*.*f",
                    format->width, format->precision, tmp___11);
            }
          }
#line 508
          if (format->commas == -1) {
#line 510
            dig_pos = -1;
#line 511
            dec_pos = -1;
#line 512
            i = 0;
            {
#line 512
            while (1) {
              while_continue___1: /* CIL Label */ ;
              {
#line 512
              tmp___13 = strlen((char const   *)output_string);
              }
#line 512
              if (! ((size_t )i < tmp___13)) {
#line 512
                goto while_break___1;
              }
              {
#line 514
              tmp___12 = __ctype_b_loc();
              }
#line 514
              if (((int const   )*(*tmp___12 + (int )*(output_string + i)) & 2048) != 0) {
#line 514
                if (dig_pos == -1) {
#line 516
                  dig_pos = i;
                }
              }
#line 517
              if ((int )*(output_string + i) == 46) {
#line 517
                if (dec_pos == -1) {
#line 519
                  dec_pos = i;
                }
              }
#line 520
              if (dig_pos != -1) {
#line 520
                if (dec_pos != -1) {
#line 520
                  goto while_break___1;
                }
              }
#line 512
              i ++;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 522
            if (dec_pos == -1) {
              {
#line 522
              tmp___14 = strlen((char const   *)output_string);
#line 522
              dec_pos = (int )tmp___14;
              }
            }
#line 523
            j = 0;
#line 524
            i = 0;
            {
#line 524
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 524
              tmp___15 = strlen((char const   *)output_string);
              }
#line 524
              if (! ((size_t )i < tmp___15)) {
#line 524
                goto while_break___2;
              }
#line 526
              if ((dec_pos - i) % 3 == 0) {
#line 526
                if (i > dig_pos) {
#line 526
                  if (i < dec_pos) {
#line 529
                    tbuf___20[j] = (char )',';
#line 530
                    j ++;
#line 531
                    tbuf___20[j] = (char )'\000';
                  }
                }
              }
#line 533
              tbuf___20[j] = *(output_string + i);
#line 534
              j ++;
#line 535
              tbuf___20[j] = (char )'\000';
#line 524
              i ++;
            }
            while_break___2: /* CIL Label */ ;
            }
            {
#line 537
            tmp___16 = strlen((char const   *)(tbuf___20));
#line 537
            tmp___17 = strlen((char const   *)output_string);
#line 537
            strcpy((char */* __restrict  */)output_string, (char const   */* __restrict  */)(& tbuf___20[tmp___16 - tmp___17]));
            }
          }
#line 541
          if (format->money == -1) {
#line 543
            i = 0;
            {
#line 543
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 543
              tmp___19 = strlen((char const   *)output_string);
              }
#line 543
              if (! ((size_t )i < tmp___19)) {
#line 543
                goto while_break___3;
              }
#line 545
              if ((int )*(output_string + i) != 32) {
#line 547
                if (i > 0) {
                  {
#line 549
                  tmp___18 = __ctype_b_loc();
                  }
#line 549
                  if (((int const   )*(*tmp___18 + (int )*(output_string + i)) & 2048) == 0) {
#line 551
                    *(output_string + (i - 1)) = *(output_string + i);
#line 553
                    *(output_string + i) = (char )'$';
                  } else {
#line 555
                    *(output_string + (i - 1)) = (char )'$';
                  }
                }
#line 557
                goto while_break___3;
              }
#line 543
              i ++;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
        }
#line 564
        if (format->fill == 42) {
#line 565
          i = 0;
          {
#line 565
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 565
            tmp___20 = strlen((char const   *)output_string);
            }
#line 565
            if (! ((size_t )i < tmp___20)) {
#line 565
              goto while_break___4;
            }
#line 567
            if ((int )*(output_string + i) != 32) {
#line 567
              goto while_break___4;
            }
#line 568
            *(output_string + i) = (char )'*';
#line 565
            i ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
        {
#line 577
        prn_xxprintf(f, output_string);
        }
#line 578
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
        {
#line 582
        sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_xprint(): get_prnfmt() returns unknown type <%c>",
                format->type);
#line 584
        bwb_error(bwb_ebuf);
        }
#line 588
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      } else {
#line 419
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 597
      tmp___24 = strlen((char const   *)element);
      }
#line 597
      if (tmp___24 > 0UL) {
        {
#line 602
        if ((int )e___0->type == 36) {
#line 602
          goto case_36___0;
        }
#line 605
        goto switch_default___1;
        case_36___0: /* CIL Label */ 
        {
#line 603
        prn_xprintf(f, element);
        }
#line 604
        goto switch_break___1;
        switch_default___1: /* CIL Label */ 
        {
#line 607
        tmp___21 = exp_getnval(e___0);
#line 607
        tmp___22 = bwb_esetovar(e___0);
#line 607
        tmp___23 = prn_precision(tmp___22);
#line 607
        sprintf((char */* __restrict  */)prnbuf, (char const   */* __restrict  */)" %.*lf",
                tmp___23, tmp___21);
#line 613
        prn_xprintf(f, prnbuf);
        }
#line 614
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
      }
    }
    {
#line 620
    adv_ws(l->buffer, & l->position);
    }
    {
#line 633
    if ((int )*(l->buffer + l->position) == 44) {
#line 633
      goto case_44;
    }
#line 640
    if ((int )*(l->buffer + l->position) == 59) {
#line 640
      goto case_59;
    }
#line 644
    goto switch_default___2;
    case_44: /* CIL Label */ 
#line 635
    if (fs_pos == -1) {
      {
#line 636
      xputc(f, (char )'\t');
      }
    } else {
      {
#line 635
      tmp___26 = strlen((char const   *)element);
      }
#line 635
      if (tmp___26 == 0UL) {
        {
#line 636
        xputc(f, (char )'\t');
        }
      }
    }
    {
#line 637
    (l->position) ++;
#line 638
    adv_ws(l->buffer, & l->position);
    }
#line 639
    goto switch_break___2;
    case_59: /* CIL Label */ 
    {
#line 641
    (l->position) ++;
#line 642
    adv_ws(l->buffer, & l->position);
    }
#line 643
    goto switch_break___2;
    switch_default___2: /* CIL Label */ 
#line 645
    loop = 0;
#line 646
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 651
  if (fs_pos > -1) {
    {
#line 651
    tmp___27 = strlen((char const   *)element);
    }
#line 651
    if (tmp___27 > 0UL) {
      {
#line 652
      format = get_prnfmt(format_string, & fs_pos, f);
      }
    }
  }
  {
#line 657
  prn_cr(l->buffer, f);
  }
#line 659
  return (-1);
}
}
#line 686 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static struct prn_fmt retstruct  ;
#line 676 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static struct prn_fmt *get_prnfmt(char *buffer , int *position___7 , FILE *f ) 
{ 
  int loop ;

  {
#line 691
  retstruct.precision = 0;
#line 692
  retstruct.type = 0;
#line 693
  retstruct.exponential = 0;
#line 694
  retstruct.right_justified = 0;
#line 695
  retstruct.commas = 0;
#line 696
  retstruct.sign = 0;
#line 697
  retstruct.money = 0;
#line 698
  retstruct.fill = ' ';
#line 699
  retstruct.minus = 0;
#line 700
  retstruct.width = 0;
#line 704
  if (*position___7 < 0) {
#line 706
    return (& retstruct);
  }
#line 715
  loop = -1;
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;
#line 716
    if (! (loop == -1)) {
#line 716
      goto while_break;
    }
    {
#line 727
    if ((int )*(buffer + *position___7) == 32) {
#line 727
      goto case_32;
    }
#line 734
    if ((int )*(buffer + *position___7) == 13) {
#line 734
      goto case_13;
    }
#line 734
    if ((int )*(buffer + *position___7) == 10) {
#line 734
      goto case_13;
    }
#line 734
    if ((int )*(buffer + *position___7) == 0) {
#line 734
      goto case_13;
    }
#line 737
    if ((int )*(buffer + *position___7) == 95) {
#line 737
      goto case_95;
    }
#line 743
    if ((int )*(buffer + *position___7) == 33) {
#line 743
      goto case_33;
    }
#line 749
    if ((int )*(buffer + *position___7) == 38) {
#line 749
      goto case_38;
    }
#line 755
    if ((int )*(buffer + *position___7) == 92) {
#line 755
      goto case_92;
    }
#line 775
    if ((int )*(buffer + *position___7) == 36) {
#line 775
      goto case_36;
    }
#line 785
    if ((int )*(buffer + *position___7) == 42) {
#line 785
      goto case_42;
    }
#line 795
    if ((int )*(buffer + *position___7) == 43) {
#line 795
      goto case_43;
    }
#line 799
    if ((int )*(buffer + *position___7) == 35) {
#line 799
      goto case_35;
    }
#line 831
    if ((int )*(buffer + *position___7) == 94) {
#line 831
      goto case_94;
    }
#line 840
    goto switch_default;
    case_32: /* CIL Label */ 
    {
#line 728
    xxputc(f, *(buffer + *position___7));
#line 729
    (*position___7) ++;
    }
#line 730
    if (retstruct.type != 0) {
#line 730
      loop = 0;
    }
#line 731
    goto switch_break;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 735
    *position___7 = -1;
#line 736
    return (& retstruct);
    case_95: /* CIL Label */ 
    {
#line 738
    (*position___7) ++;
#line 739
    xxputc(f, *(buffer + *position___7));
#line 740
    (*position___7) ++;
    }
#line 741
    goto switch_break;
    case_33: /* CIL Label */ 
#line 744
    retstruct.type = '$';
#line 745
    retstruct.width = 1;
#line 746
    (*position___7) ++;
#line 747
    return (& retstruct);
    case_38: /* CIL Label */ 
#line 750
    retstruct.type = '$';
#line 751
    retstruct.width = -1;
#line 752
    (*position___7) ++;
#line 753
    return (& retstruct);
    case_92: /* CIL Label */ 
#line 762
    retstruct.type = '$';
#line 763
    (retstruct.width) ++;
#line 764
    (*position___7) ++;
    {
#line 765
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 765
      if (! ((int )*(buffer + *position___7) == 32)) {
#line 765
        goto while_break___0;
      }
#line 767
      (retstruct.width) ++;
#line 765
      (*position___7) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 769
    if ((int )*(buffer + *position___7) == 92) {
#line 771
      (retstruct.width) ++;
#line 772
      (*position___7) ++;
    }
#line 774
    return (& retstruct);
    case_36: /* CIL Label */ 
#line 776
    (retstruct.width) ++;
#line 777
    (*position___7) ++;
#line 778
    retstruct.money = -1;
#line 779
    if ((int )*(buffer + *position___7) == 36) {
#line 781
      (retstruct.width) ++;
#line 782
      (*position___7) ++;
    }
#line 784
    goto switch_break;
    case_42: /* CIL Label */ 
#line 786
    (retstruct.width) ++;
#line 787
    (*position___7) ++;
#line 788
    retstruct.fill = '*';
#line 789
    if ((int )*(buffer + *position___7) == 42) {
#line 791
      (retstruct.width) ++;
#line 792
      (*position___7) ++;
    }
#line 794
    goto switch_break;
    case_43: /* CIL Label */ 
#line 796
    (*position___7) ++;
#line 797
    retstruct.sign = -1;
#line 798
    goto switch_break;
    case_35: /* CIL Label */ 
#line 800
    retstruct.type = 1;
    {
#line 803
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 803
      if (! ((int )*(buffer + *position___7) == 35)) {
#line 803
        goto while_break___1;
      }
#line 805
      (retstruct.width) ++;
#line 803
      (*position___7) ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 807
    if ((int )*(buffer + *position___7) == 44) {
#line 809
      retstruct.commas = -1;
#line 810
      (retstruct.width) ++;
#line 811
      (*position___7) ++;
    }
#line 813
    if ((int )*(buffer + *position___7) == 46) {
#line 815
      retstruct.type = 1;
#line 816
      (retstruct.width) ++;
#line 817
      (*position___7) ++;
#line 818
      retstruct.precision = 0;
      {
#line 818
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 818
        if (! ((int )*(buffer + *position___7) == 35)) {
#line 818
          goto while_break___2;
        }
#line 820
        (retstruct.precision) ++;
#line 821
        (retstruct.width) ++;
#line 818
        (*position___7) ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 824
    if ((int )*(buffer + *position___7) == 45) {
#line 826
      retstruct.minus = -1;
#line 827
      (*position___7) ++;
    }
#line 829
    return (& retstruct);
    case_94: /* CIL Label */ 
#line 832
    retstruct.type = 1;
#line 833
    retstruct.exponential = -1;
#line 834
    retstruct.width = 1;
    {
#line 834
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 834
      if (! ((int )*(buffer + *position___7) == 94)) {
#line 834
        goto while_break___3;
      }
#line 836
      (retstruct.width) ++;
#line 834
      (*position___7) ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 838
    return (& retstruct);
    switch_default: /* CIL Label */ 
    {
#line 841
    xxputc(f, *(buffer + *position___7));
#line 842
    (*position___7) ++;
    }
#line 843
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 848
  return (& retstruct);
}
}
#line 863 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static int prn_cr(char *buffer , FILE *f ) 
{ 
  register int c ;
  int loop ;

  {
#line 877
  c = 0;
  {
#line 877
  while (1) {
    while_continue: /* CIL Label */ ;
#line 877
    if (! ((int )*(buffer + c) != 0)) {
#line 877
      goto while_break;
    }
#line 877
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 888
  loop = -1;
  {
#line 889
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 889
    if (! (loop == -1)) {
#line 889
      goto while_break___0;
    }
    {
#line 895
    if ((int )*(buffer + c) == 0) {
#line 895
      goto case_0;
    }
#line 895
    if ((int )*(buffer + c) == 9) {
#line 895
      goto case_0;
    }
#line 895
    if ((int )*(buffer + c) == 32) {
#line 895
      goto case_0;
    }
#line 910
    goto switch_default;
    case_0: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 903
    c --;
#line 904
    if (c < 0) {
#line 906
      loop = 0;
    }
#line 908
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 916
    loop = 0;
#line 917
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 921
  if ((int )*(buffer + c) == 59) {
#line 929
    return (0);
  } else {
    {
#line 934
    prn_xprintf(f, (char *)"\n");
    }
#line 935
    return (-1);
  }
}
}
#line 951 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
int prn_xprintf(FILE *f , char *buffer ) 
{ 
  char *p___0 ;

  {
#line 966
  p___0 = buffer;
  {
#line 966
  while (1) {
    while_continue: /* CIL Label */ ;
#line 966
    if (! ((int )*p___0 != 0)) {
#line 966
      goto while_break;
    }
    {
#line 968
    xputc(f, *p___0);
#line 966
    p___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 971
  return (-1);
}
}
#line 987 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
int prn_xxprintf(FILE *f , char *buffer ) 
{ 
  char *p___0 ;

  {
#line 1002
  p___0 = buffer;
  {
#line 1002
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1002
    if (! ((int )*p___0 != 0)) {
#line 1002
      goto while_break;
    }
    {
#line 1004
    xxputc(f, *p___0);
#line 1002
    p___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1007
  return (-1);
}
}
#line 1031 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static int tab_pending  =    0;
#line 1022 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
int xputc(FILE *f , char c ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 1036
  if ((unsigned long )f != (unsigned long )stdout) {
#line 1036
    if ((unsigned long )f != (unsigned long )stderr) {
      {
#line 1038
      xxputc(f, c);
      }
#line 1039
      return (-1);
    }
  }
#line 1044
  if (tab_pending == -1) {
    {
#line 1046
    tmp = prn_getcol(f);
    }
#line 1046
    if ((int )c < *tmp) {
      {
#line 1048
      xxputc(f, (char )'\n');
      }
    }
    {
#line 1050
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1050
      tmp___0 = prn_getcol(f);
      }
#line 1050
      if (! (*tmp___0 < (int )c)) {
#line 1050
        goto while_break;
      }
      {
#line 1052
      xxputc(f, (char )' ');
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1054
    tab_pending = 0;
#line 1055
    return (-1);
  }
  {
#line 1062
  if ((int )c == 2) {
#line 1062
    goto case_2;
  }
#line 1066
  if ((int )c == 9) {
#line 1066
    goto case_9;
  }
#line 1073
  goto switch_default;
  case_2: /* CIL Label */ 
#line 1063
  tab_pending = -1;
#line 1064
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 1067
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1067
    tmp___1 = prn_getcol(f);
    }
#line 1067
    if (! (*tmp___1 % 14 != 0)) {
#line 1067
      goto while_break___0;
    }
    {
#line 1069
    xxputc(f, (char )' ');
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1071
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1074
  xxputc(f, c);
  }
#line 1075
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1078
  return (-1);
}
}
#line 1094 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static int xxputc(FILE *f , char c ) 
{ 
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 1107
  if ((unsigned long )f != (unsigned long )stdout) {
#line 1107
    if ((unsigned long )f != (unsigned long )stderr) {
      {
#line 1109
      tmp = xxxputc(f, c);
      }
#line 1109
      return (tmp);
    }
  }
  {
#line 1114
  tmp___1 = prn_getcol(f);
#line 1114
  tmp___2 = prn_getwidth(f);
  }
#line 1114
  if (*tmp___1 >= tmp___2) {
    {
#line 1116
    xxxputc(f, (char )'\n');
#line 1117
    tmp___0 = prn_getcol(f);
#line 1117
    *tmp___0 = 1;
    }
  }
#line 1122
  if ((int )c == 10) {
    {
#line 1124
    tmp___3 = prn_getcol(f);
#line 1124
    *tmp___3 = 1;
    }
  } else {
    {
#line 1128
    tmp___4 = prn_getcol(f);
#line 1128
    (*tmp___4) ++;
    }
  }
  {
#line 1133
  tmp___5 = xxxputc(f, c);
  }
#line 1133
  return (tmp___5);
}
}
#line 1147 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static int xxxputc(FILE *f , char c ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1156
  if ((unsigned long )f == (unsigned long )stdout) {
    {
#line 1158
    tmp = bwx_putc(c);
    }
#line 1158
    return (tmp);
  } else
#line 1156
  if ((unsigned long )f == (unsigned long )stderr) {
    {
#line 1158
    tmp = bwx_putc(c);
    }
#line 1158
    return (tmp);
  } else {
    {
#line 1162
    tmp___0 = fputc((int )c, f);
    }
#line 1162
    return (tmp___0);
  }
}
}
#line 1186 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static int dummy_pos  ;
#line 1177 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
int *prn_getcol(FILE *f ) 
{ 
  register int n___0 ;

  {
#line 1188
  if ((unsigned long )f == (unsigned long )stdout) {
#line 1190
    return (& prn_col);
  } else
#line 1188
  if ((unsigned long )f == (unsigned long )stderr) {
#line 1190
    return (& prn_col);
  }
#line 1194
  n___0 = 0;
  {
#line 1194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1194
    if (! (n___0 < 16)) {
#line 1194
      goto while_break;
    }
#line 1196
    if ((unsigned long )(dev_table + n___0)->cfp == (unsigned long )f) {
#line 1198
      return (& (dev_table + n___0)->col);
    }
#line 1194
    n___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1206
  bwb_error((char *)"in prn_getcol(): failed to find file pointer");
  }
#line 1211
  return (& dummy_pos);
}
}
#line 1225 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
int prn_getwidth(FILE *f ) 
{ 
  register int n___0 ;

  {
#line 1235
  if ((unsigned long )f == (unsigned long )stdout) {
#line 1237
    return (prn_width);
  } else
#line 1235
  if ((unsigned long )f == (unsigned long )stderr) {
#line 1237
    return (prn_width);
  }
#line 1241
  n___0 = 0;
  {
#line 1241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1241
    if (! (n___0 < 16)) {
#line 1241
      goto while_break;
    }
#line 1243
    if ((unsigned long )(dev_table + n___0)->cfp == (unsigned long )f) {
#line 1245
      return ((dev_table + n___0)->width);
    }
#line 1241
    n___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1253
  bwb_error((char *)"in prn_getwidth(): failed to find file pointer");
  }
#line 1258
  return (1);
}
}
#line 1272 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
int prn_precision(struct bwb_variable *v___0 ) 
{ 
  int max_precision ;
  bnumber nval ;
  bnumber d ;
  int r ;
  bnumber tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 1280
  max_precision = 6;
#line 1286
  if (v___0->type == 1) {
#line 1288
    max_precision = 12;
  }
  {
#line 1293
  tmp = var_getnval(v___0);
#line 1293
  tmp___0 = fabs(tmp);
#line 1293
  nval = tmp___0;
#line 1297
  d = (bnumber )1;
#line 1298
  r = 0;
  }
  {
#line 1298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1298
    if (! (r < max_precision)) {
#line 1298
      goto while_break;
    }
    {
#line 1307
    tmp___1 = fmod(nval, d);
    }
#line 1307
    if (tmp___1 < 0.0000001) {
#line 1309
      return (r);
    }
#line 1311
    d /= (bnumber )10;
#line 1298
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1316
  return (r);
}
}
#line 1369 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
struct bwb_line *bwb_lerror(struct bwb_line *l ) 
{ 
  char tbuf___20[5001] ;
  int n___0 ;
  struct exp_ese *e___0 ;
  int pos___2 ;
  struct bwb_line *tmp ;
  bnumber tmp___0 ;
  struct bwb_line *tmp___1 ;
  struct bwb_line *tmp___2 ;

  {
  {
#line 1389
  adv_ws(l->buffer, & l->position);
  }
  {
#line 1395
  if ((int )*(l->buffer + l->position) == 58) {
#line 1395
    goto case_58;
  }
#line 1395
  if ((int )*(l->buffer + l->position) == 13) {
#line 1395
    goto case_58;
  }
#line 1395
  if ((int )*(l->buffer + l->position) == 10) {
#line 1395
    goto case_58;
  }
#line 1395
  if ((int )*(l->buffer + l->position) == 0) {
#line 1395
    goto case_58;
  }
#line 1398
  goto switch_default;
  case_58: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 1396
  bwb_error(err_incomplete);
#line 1397
  tmp = bwb_zline(l);
  }
#line 1397
  return (tmp);
  switch_default: /* CIL Label */ 
#line 1399
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1404
  adv_element(l->buffer, & l->position, tbuf___20);
#line 1408
  pos___2 = 0;
#line 1409
  e___0 = bwb_exp(tbuf___20, 0, & pos___2);
#line 1410
  tmp___0 = exp_getnval(e___0);
#line 1410
  n___0 = (int )tmp___0;
  }
#line 1419
  if (n___0 < 0) {
    {
#line 1421
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Error number %d is out of range",
            n___0);
#line 1422
    bwb_xerror(bwb_ebuf);
#line 1423
    tmp___1 = bwb_zline(l);
    }
#line 1423
    return (tmp___1);
  } else
#line 1419
  if (n___0 >= 25) {
    {
#line 1421
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Error number %d is out of range",
            n___0);
#line 1422
    bwb_xerror(bwb_ebuf);
#line 1423
    tmp___1 = bwb_zline(l);
    }
#line 1423
    return (tmp___1);
  }
  {
#line 1426
  bwb_xerror(err_table[n___0]);
#line 1428
  tmp___2 = bwb_zline(l);
  }
#line 1428
  return (tmp___2);
}
}
#line 1445 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
struct bwb_line *bwb_width(struct bwb_line *l ) 
{ 
  int req_devnumber___0 ;
  int req_width ;
  struct exp_ese *e___0 ;
  char tbuf___20[5001] ;
  int pos___2 ;
  struct bwb_line *tmp ;
  bnumber tmp___0 ;
  struct bwb_line *tmp___1 ;
  bnumber tmp___2 ;
  struct bwb_line *tmp___3 ;

  {
  {
#line 1461
  req_devnumber___0 = -1;
#line 1462
  adv_ws(l->buffer, & l->position);
  }
#line 1464
  if ((int )*(l->buffer + l->position) == 35) {
    {
#line 1466
    (l->position) ++;
#line 1467
    adv_element(l->buffer, & l->position, tbuf___20);
#line 1468
    pos___2 = 0;
#line 1469
    e___0 = bwb_exp(tbuf___20, 0, & pos___2);
#line 1470
    adv_ws(l->buffer, & l->position);
    }
#line 1471
    if ((int )*(l->buffer + l->position) == 44) {
#line 1473
      (l->position) ++;
    } else {
      {
#line 1478
      bwb_error((char *)"in bwb_width(): no comma after#n");
#line 1482
      tmp = bwb_zline(l);
      }
#line 1482
      return (tmp);
    }
    {
#line 1485
    tmp___0 = exp_getnval(e___0);
#line 1485
    req_devnumber___0 = (int )tmp___0;
    }
#line 1489
    if (req_devnumber___0 < 0) {
      {
#line 1492
      bwb_error((char *)"in bwb_width(): Requested device number is out of range.");
#line 1496
      tmp___1 = bwb_zline(l);
      }
#line 1496
      return (tmp___1);
    } else
#line 1489
    if (req_devnumber___0 >= 16) {
      {
#line 1492
      bwb_error((char *)"in bwb_width(): Requested device number is out of range.");
#line 1496
      tmp___1 = bwb_zline(l);
      }
#line 1496
      return (tmp___1);
    }
  }
  {
#line 1509
  e___0 = bwb_exp(l->buffer, 0, & l->position);
#line 1510
  tmp___2 = exp_getnval(e___0);
#line 1510
  req_width = (int )tmp___2;
  }
#line 1514
  if (req_width < 1) {
    {
#line 1517
    bwb_error((char *)"in bwb_width(): Requested width is out of range (1-255)");
    }
  } else
#line 1514
  if (req_width > 255) {
    {
#line 1517
    bwb_error((char *)"in bwb_width(): Requested width is out of range (1-255)");
    }
  }
#line 1525
  if (req_devnumber___0 == -1) {
#line 1527
    prn_width = req_width;
  } else {
#line 1531
    (dev_table + req_devnumber___0)->width = req_width;
  }
  {
#line 1536
  tmp___3 = bwb_zline(l);
  }
#line 1536
  return (tmp___3);
}
}
#line 1562 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static char tbuf___17[5001]  ;
#line 1563 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static struct bwb_line eline  ;
#line 1553 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
int bwb_error(char *message ) 
{ 
  register int e___0 ;
  int save_elevel ;
  struct bwb_line *cur_l ;
  int cur_mode ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 1570
  err_number = -1;
#line 1571
  err_line = number;
#line 1573
  e___0 = 0;
  {
#line 1573
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1573
    if (! (e___0 < 25)) {
#line 1573
      goto while_break;
    }
#line 1575
    if ((unsigned long )message == (unsigned long )err_table[e___0]) {
#line 1577
      err_number = e___0;
#line 1578
      e___0 = 25;
    }
#line 1573
    e___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1584
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1584
    tmp = is_eol(bwb_l->buffer, & bwb_l->position);
    }
#line 1584
    if (! (tmp != -1)) {
#line 1584
      goto while_break___0;
    }
#line 1586
    (bwb_l->position) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1591
  tmp___1 = strlen((char const   *)(err_gosubl));
  }
#line 1591
  if (tmp___1 == 0UL) {
    {
#line 1593
    tmp___0 = bwb_xerror(message);
    }
#line 1593
    return (tmp___0);
  }
  {
#line 1602
  cur_l = bwb_l;
#line 1603
  cur_mode = (excs + exsc)->code;
#line 1607
  sprintf((char */* __restrict  */)(tbuf___17), (char const   */* __restrict  */)"%s %s",
          "GOSUB", err_gosubl);
#line 1608
  eline.next = & bwb_end;
#line 1609
  eline.position = 0;
#line 1610
  eline.marked = 0;
#line 1611
  eline.buffer = tbuf___17;
#line 1612
  bwb_setexec(& eline, 0, 0);
#line 1616
  save_elevel = exsc;
#line 1617
  bwb_execline();
  }
  {
#line 1620
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1620
    if (! (exsc != save_elevel)) {
#line 1620
      goto while_break___1;
    }
    {
#line 1622
    bwb_execline();
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1625
  (cur_l->next)->position = 0;
#line 1626
  bwb_setexec(cur_l->next, 0, cur_mode);
  }
#line 1628
  return (-1);
}
}
#line 1644 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static int bwb_xerror(char *message ) 
{ 


  {
  {
#line 1653
  bwx_errmes(message);
#line 1655
  break_handler();
  }
#line 1657
  return (0);
}
}
#line 1678 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static struct bwb_variable b___2  ;
#line 1670 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static struct bwb_variable *bwb_esetovar(struct exp_ese *e___0 ) 
{ 
  bstring *tmp ;
  bstring *tmp___0 ;
  bnumber *tmp___1 ;

  {
  {
#line 1680
  var_make(& b___2, (int )e___0->type);
  }
  {
#line 1684
  if ((int )e___0->type == 36) {
#line 1684
    goto case_36;
  }
#line 1687
  goto switch_default;
  case_36: /* CIL Label */ 
  {
#line 1685
  tmp = exp_getsval(e___0);
#line 1685
  tmp___0 = var_findsval(& b___2, b___2.array_pos);
#line 1685
  str_btob(tmp___0, tmp);
  }
#line 1686
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1688
  tmp___1 = var_findnval(& b___2, b___2.array_pos);
#line 1688
  *tmp___1 = e___0->nval;
  }
#line 1689
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1692
  return (& b___2);
}
}
#line 1724 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static struct bwb_variable nvar___33  ;
#line 1725 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
static int init___41  =    0;
#line 1710 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_prn.c"
struct bwb_line *bwb_write(struct bwb_line *l ) 
{ 
  struct exp_ese *e___0 ;
  int req_devnumber___0 ;
  int pos___2 ;
  FILE *fp ;
  char tbuf___20[5001] ;
  int loop ;
  struct bwb_line *tmp ;
  bnumber tmp___0 ;
  struct bwb_line *tmp___1 ;
  struct bwb_line *tmp___2 ;
  struct bwb_line *tmp___3 ;
  bstring *tmp___4 ;
  bnumber *tmp___5 ;
  bnumber tmp___6 ;
  int tmp___7 ;
  struct bwb_line *tmp___8 ;

  {
#line 1729
  if (init___41 == 0) {
    {
#line 1731
    init___41 = -1;
#line 1732
    var_make(& nvar___33, 1);
    }
  }
  {
#line 1737
  adv_ws(l->buffer, & l->position);
  }
#line 1739
  if ((int )*(l->buffer + l->position) == 35) {
    {
#line 1741
    (l->position) ++;
#line 1742
    adv_element(l->buffer, & l->position, tbuf___20);
#line 1743
    pos___2 = 0;
#line 1744
    e___0 = bwb_exp(tbuf___20, 0, & pos___2);
#line 1745
    adv_ws(l->buffer, & l->position);
    }
#line 1746
    if ((int )*(l->buffer + l->position) == 44) {
#line 1748
      (l->position) ++;
    } else {
      {
#line 1753
      bwb_error((char *)"in bwb_write(): no comma after#n");
#line 1757
      tmp = bwb_zline(l);
      }
#line 1757
      return (tmp);
    }
    {
#line 1760
    tmp___0 = exp_getnval(e___0);
#line 1760
    req_devnumber___0 = (int )tmp___0;
    }
#line 1764
    if (req_devnumber___0 < 0) {
      {
#line 1767
      bwb_error((char *)"in bwb_write(): Requested device number is out of range.");
#line 1771
      tmp___1 = bwb_zline(l);
      }
#line 1771
      return (tmp___1);
    } else
#line 1764
    if (req_devnumber___0 >= 16) {
      {
#line 1767
      bwb_error((char *)"in bwb_write(): Requested device number is out of range.");
#line 1771
      tmp___1 = bwb_zline(l);
      }
#line 1771
      return (tmp___1);
    }
#line 1774
    if ((dev_table + req_devnumber___0)->mode == 0) {
      {
#line 1778
      bwb_error((char *)"in bwb_write(): Requested device number is not open.");
#line 1783
      tmp___2 = bwb_zline(l);
      }
#line 1783
      return (tmp___2);
    } else
#line 1774
    if ((dev_table + req_devnumber___0)->mode == -1) {
      {
#line 1778
      bwb_error((char *)"in bwb_write(): Requested device number is not open.");
#line 1783
      tmp___2 = bwb_zline(l);
      }
#line 1783
      return (tmp___2);
    }
#line 1786
    if ((dev_table + req_devnumber___0)->mode != 1) {
      {
#line 1789
      bwb_error((char *)"in bwb_write(): Requested device is not open for OUTPUT.");
#line 1794
      tmp___3 = bwb_zline(l);
      }
#line 1794
      return (tmp___3);
    }
#line 1805
    fp = (dev_table + req_devnumber___0)->cfp;
  } else {
#line 1811
    fp = stdout;
  }
  {
#line 1816
  adv_ws(l->buffer, & l->position);
#line 1817
  loop = -1;
  }
  {
#line 1823
  if ((int )*(l->buffer + l->position) == 58) {
#line 1823
    goto case_58;
  }
#line 1823
  if ((int )*(l->buffer + l->position) == 0) {
#line 1823
    goto case_58;
  }
#line 1823
  if ((int )*(l->buffer + l->position) == 13) {
#line 1823
    goto case_58;
  }
#line 1823
  if ((int )*(l->buffer + l->position) == 10) {
#line 1823
    goto case_58;
  }
#line 1818
  goto switch_break;
  case_58: /* CIL Label */ 
  case_0: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
#line 1824
  loop = 0;
#line 1825
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1830
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1830
    if (! (loop == -1)) {
#line 1830
      goto while_break;
    }
    {
#line 1835
    e___0 = bwb_exp(l->buffer, 0, & l->position);
    }
    {
#line 1841
    if ((int )e___0->type == 36) {
#line 1841
      goto case_36;
    }
#line 1852
    goto switch_default;
    case_36: /* CIL Label */ 
    {
#line 1842
    xputc(fp, (char )'\"');
#line 1843
    tmp___4 = exp_getsval(e___0);
#line 1843
    str_btoc(tbuf___20, tmp___4);
#line 1844
    prn_xprintf(fp, tbuf___20);
#line 1845
    xputc(fp, (char )'\"');
    }
#line 1851
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 1853
    tmp___5 = var_findnval(& nvar___33, nvar___33.array_pos);
#line 1853
    *tmp___5 = exp_getnval(e___0);
#line 1856
    tmp___6 = var_getnval(& nvar___33);
#line 1856
    tmp___7 = prn_precision(& nvar___33);
#line 1856
    sprintf((char */* __restrict  */)(tbuf___20), (char const   */* __restrict  */)" %.*lf",
            tmp___7, tmp___6);
#line 1862
    prn_xprintf(fp, tbuf___20);
    }
#line 1868
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 1873
    adv_ws(l->buffer, & l->position);
    }
#line 1874
    if ((int )*(l->buffer + l->position) == 44) {
      {
#line 1876
      xputc(fp, (char )',');
#line 1877
      (l->position) ++;
      }
    } else {
#line 1884
      loop = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1891
  xputc(fp, (char )'\n');
#line 1895
  tmp___8 = bwb_zline(l);
  }
#line 1895
  return (tmp___8);
}
}
#line 806 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
int dim_base ;
#line 859
struct bwb_line *bwb_common(struct bwb_line *l ) ;
#line 890
struct bwb_line *bwb_dim(struct bwb_line *l ) ;
#line 891
struct bwb_line *bwb_option(struct bwb_line *l ) ;
#line 906
struct bwb_line *bwb_ddbl(struct bwb_line *l ) ;
#line 907
struct bwb_line *bwb_dint(struct bwb_line *l ) ;
#line 908
struct bwb_line *bwb_dsng(struct bwb_line *l ) ;
#line 909
struct bwb_line *bwb_dstr(struct bwb_line *l ) ;
#line 910
struct bwb_line *bwb_mid(struct bwb_line *l ) ;
#line 911
struct bwb_line *bwb_clear(struct bwb_line *l ) ;
#line 912
struct bwb_line *bwb_erase(struct bwb_line *l ) ;
#line 913
struct bwb_line *bwb_swap(struct bwb_line *l ) ;
#line 961
int var_delcvars(void) ;
#line 962
struct bwb_variable *var_new(char *name ) ;
#line 966
int bwb_const(char *lb , char *sb , int *n___0 ) ;
#line 967
int bwb_getvarname(char *lb , char *sb , int *n___0 ) ;
#line 969
int bwb_isvar(char *buffer ) ;
#line 976
int dim_getparams(char *buffer , int *pos___2 , int *n_params___0 , int **pp___0 ) ;
#line 467 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mes.h"
char err_syntax[13] ;
#line 472
char err_defchar[43] ;
#line 474
char err_dimnotarray[30] ;
#line 44 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
int dim_base  =    0;
#line 45 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
static int dimmed  =    0;
#line 46 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
static int first  ;
#line 46 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
static int last  ;
#line 51
static int dim_check(struct bwb_variable *v___0 , int *pp___0 ) ;
#line 52
static int var_defx(struct bwb_line *l , int type ) ;
#line 53
static int var_letseq(char *buffer , int *position___7 , int *start , int *end ) ;
#line 54
static size_t dim_unit(struct bwb_variable *v___0 , int *pp___0 ) ;
#line 72 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
int var_init(int task ) 
{ 


  {
  {
#line 80
  var_start.next = & var_end;
#line 81
  strcpy((char */* __restrict  */)(var_start.name), (char const   */* __restrict  */)"<START>");
#line 82
  strcpy((char */* __restrict  */)(var_end.name), (char const   */* __restrict  */)"<END>");
  }
#line 83
  return (-1);
}
}
#line 100 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
struct bwb_line *bwb_common(struct bwb_line *l ) 
{ 
  register int loop ;
  struct bwb_variable *v___0 ;
  char tbuf___20[5001] ;
  struct bwb_line *tmp ;
  struct bwb_line *tmp___0 ;
  struct bwb_line *tmp___1 ;

  {
#line 114
  loop = -1;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! (loop == -1)) {
#line 115
      goto while_break;
    }
    {
#line 120
    bwb_getvarname(l->buffer, tbuf___20, & l->position);
#line 122
    v___0 = var_find(tbuf___20);
    }
#line 122
    if ((unsigned long )v___0 == (unsigned long )((void *)0)) {
      {
#line 124
      bwb_error(err_syntax);
#line 125
      tmp = bwb_zline(l);
      }
#line 125
      return (tmp);
    }
    {
#line 128
    v___0->common = -1;
#line 132
    adv_ws(l->buffer, & l->position);
    }
#line 133
    if ((int )*(l->buffer + l->position) != 44) {
      {
#line 135
      tmp___0 = bwb_zline(l);
      }
#line 135
      return (tmp___0);
    }
    {
#line 137
    (l->position) ++;
#line 138
    adv_ws(l->buffer, & l->position);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 142
  tmp___1 = bwb_zline(l);
  }
#line 142
  return (tmp___1);
}
}
#line 158 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
struct bwb_line *bwb_erase(struct bwb_line *l ) 
{ 
  register int loop ;
  struct bwb_variable *v___0 ;
  struct bwb_variable *p___0 ;
  char tbuf___20[5001] ;
  bstring *sp ;
  register int n___0 ;
  struct bwb_line *tmp ;
  struct bwb_line *tmp___0 ;
  struct bwb_line *tmp___1 ;
  struct bwb_line *tmp___2 ;

  {
#line 175
  loop = -1;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (loop == -1)) {
#line 176
      goto while_break;
    }
    {
#line 181
    bwb_getvarname(l->buffer, tbuf___20, & l->position);
#line 183
    v___0 = var_find(tbuf___20);
    }
#line 183
    if ((unsigned long )v___0 == (unsigned long )((void *)0)) {
      {
#line 185
      bwb_error(err_syntax);
#line 186
      tmp = bwb_zline(l);
      }
#line 186
      return (tmp);
    }
#line 191
    if (v___0->dimensions < 1) {
      {
#line 193
      bwb_error(err_dimnotarray);
#line 194
      tmp___0 = bwb_zline(l);
      }
#line 194
      return (tmp___0);
    } else
#line 191
    if (*(v___0->array_sizes + 0) < 1) {
      {
#line 193
      bwb_error(err_dimnotarray);
#line 194
      tmp___0 = bwb_zline(l);
      }
#line 194
      return (tmp___0);
    }
#line 199
    p___0 = & var_start;
    {
#line 199
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 199
      if (! ((unsigned long )p___0->next != (unsigned long )v___0)) {
#line 199
        goto while_break___0;
      }
#line 199
      p___0 = p___0->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 206
    p___0->next = v___0->next;
#line 211
    FREE((void *)v___0->array_sizes, (char *)"bwb_erase");
#line 212
    v___0->array_sizes = (int *)((void *)0);
#line 213
    FREE((void *)v___0->array_pos, (char *)"bwb_erase");
#line 214
    v___0->array_pos = (int *)((void *)0);
    }
#line 215
    if (v___0->type == 1) {
      {
#line 218
      FREE((void *)v___0->memnum, (char *)"bwb_erase");
#line 219
      v___0->memnum = (bnumber *)((void *)0);
      }
    } else {
#line 224
      sp = v___0->memstr;
#line 225
      n___0 = 0;
      {
#line 225
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 225
        if (! (n___0 < (int )v___0->array_units)) {
#line 225
          goto while_break___1;
        }
#line 227
        if ((unsigned long )(sp + n___0)->sbuffer != (unsigned long )((void *)0)) {
          {
#line 230
          FREE((void *)(sp + n___0)->sbuffer, (char *)"bwb_erase");
#line 231
          (sp + n___0)->sbuffer = (char *)((void *)0);
          }
        }
#line 233
        (sp + n___0)->rab = 0;
#line 234
        (sp + n___0)->length = 0U;
#line 225
        n___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 237
      FREE((void *)v___0->memstr, (char *)"bwb_erase");
#line 238
      v___0->memstr = (bstring *)((void *)0);
      }
    }
    {
#line 241
    FREE((void *)v___0, (char *)"bwb_erase");
#line 242
    v___0 = (struct bwb_variable *)((void *)0);
#line 246
    adv_ws(l->buffer, & l->position);
    }
#line 247
    if ((int )*(l->buffer + l->position) != 44) {
      {
#line 249
      tmp___1 = bwb_zline(l);
      }
#line 249
      return (tmp___1);
    }
    {
#line 251
    (l->position) ++;
#line 252
    adv_ws(l->buffer, & l->position);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 256
  tmp___2 = bwb_zline(l);
  }
#line 256
  return (tmp___2);
}
}
#line 272 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
struct bwb_line *bwb_swap(struct bwb_line *l ) 
{ 
  struct bwb_variable tmp ;
  struct bwb_variable *lhs ;
  struct bwb_variable *rhs ;
  char tbuf___20[5001] ;
  struct bwb_line *tmp___0 ;
  struct bwb_line *tmp___1 ;
  struct bwb_line *tmp___2 ;
  struct bwb_line *tmp___3 ;
  struct bwb_line *tmp___4 ;

  {
  {
#line 292
  bwb_getvarname(l->buffer, tbuf___20, & l->position);
#line 299
  lhs = var_find(tbuf___20);
  }
#line 299
  if ((unsigned long )lhs == (unsigned long )((void *)0)) {
    {
#line 301
    bwb_error(err_syntax);
#line 302
    tmp___0 = bwb_zline(l);
    }
#line 302
    return (tmp___0);
  }
  {
#line 313
  adv_ws(l->buffer, & l->position);
  }
#line 314
  if ((int )*(l->buffer + l->position) != 44) {
    {
#line 316
    bwb_error(err_syntax);
#line 317
    tmp___1 = bwb_zline(l);
    }
#line 317
    return (tmp___1);
  }
  {
#line 319
  (l->position) ++;
#line 320
  adv_ws(l->buffer, & l->position);
#line 330
  bwb_getvarname(l->buffer, tbuf___20, & l->position);
#line 337
  rhs = var_find(tbuf___20);
  }
#line 337
  if ((unsigned long )rhs == (unsigned long )((void *)0)) {
    {
#line 339
    bwb_error(err_syntax);
#line 340
    tmp___2 = bwb_zline(l);
    }
#line 340
    return (tmp___2);
  }
#line 345
  if (rhs->type != lhs->type) {
    {
#line 347
    bwb_error(err_mismatch);
#line 348
    tmp___3 = bwb_zline(l);
    }
#line 348
    return (tmp___3);
  }
#line 353
  if (lhs->type == 1) {
#line 355
    tmp.memnum = lhs->memnum;
  } else {
#line 359
    tmp.memstr = lhs->memstr;
  }
#line 361
  tmp.array_sizes = lhs->array_sizes;
#line 362
  tmp.array_units = lhs->array_units;
#line 363
  tmp.array_pos = lhs->array_pos;
#line 364
  tmp.dimensions = lhs->dimensions;
#line 366
  if (lhs->type == 1) {
#line 368
    lhs->memnum = rhs->memnum;
  } else {
#line 372
    lhs->memstr = rhs->memstr;
  }
#line 374
  lhs->array_sizes = rhs->array_sizes;
#line 375
  lhs->array_units = rhs->array_units;
#line 376
  lhs->array_pos = rhs->array_pos;
#line 377
  lhs->dimensions = rhs->dimensions;
#line 379
  if (lhs->type == 1) {
#line 381
    rhs->memnum = tmp.memnum;
  } else {
#line 385
    rhs->memstr = tmp.memstr;
  }
  {
#line 387
  rhs->array_sizes = tmp.array_sizes;
#line 388
  rhs->array_units = tmp.array_units;
#line 389
  rhs->array_pos = tmp.array_pos;
#line 390
  rhs->dimensions = tmp.dimensions;
#line 394
  tmp___4 = bwb_zline(l);
  }
#line 394
  return (tmp___4);
}
}
#line 412 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
struct bwb_line *bwb_clear(struct bwb_line *l ) 
{ 
  struct bwb_variable *v___0 ;
  register int n___0 ;
  bstring *sp ;
  bnumber *np ;
  struct bwb_line *tmp ;

  {
#line 425
  v___0 = var_start.next;
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! ((unsigned long )v___0 != (unsigned long )(& var_end))) {
#line 425
      goto while_break;
    }
#line 427
    if (v___0->preset != -1) {
      {
#line 431
      if (v___0->type == 1) {
#line 431
        goto case_1;
      }
#line 438
      if (v___0->type == 36) {
#line 438
        goto case_36;
      }
#line 429
      goto switch_break;
      case_1: /* CIL Label */ 
#line 432
      np = v___0->memnum;
#line 433
      n___0 = 0;
      {
#line 433
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 433
        if (! (n___0 < (int )v___0->array_units)) {
#line 433
          goto while_break___0;
        }
#line 435
        *(np + n___0) = 0.0;
#line 433
        n___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 437
      goto switch_break;
      case_36: /* CIL Label */ 
#line 439
      sp = v___0->memstr;
#line 440
      n___0 = 0;
      {
#line 440
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 440
        if (! (n___0 < (int )v___0->array_units)) {
#line 440
          goto while_break___1;
        }
#line 442
        if ((unsigned long )(sp + n___0)->sbuffer != (unsigned long )((void *)0)) {
          {
#line 445
          FREE((void *)(sp + n___0)->sbuffer, (char *)"bwb_clear");
#line 446
          (sp + n___0)->sbuffer = (char *)((void *)0);
          }
        }
#line 448
        (sp + n___0)->rab = 0;
#line 449
        (sp + n___0)->length = 0U;
#line 440
        n___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 451
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 425
    v___0 = v___0->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 456
  tmp = bwb_zline(l);
  }
#line 456
  return (tmp);
}
}
#line 471 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
int var_delcvars(void) 
{ 
  struct bwb_variable *v___0 ;
  struct bwb_variable *p___0 ;
  bstring *sp ;
  register int n___0 ;

  {
#line 483
  p___0 = & var_start;
#line 484
  v___0 = var_start.next;
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;
#line 484
    if (! ((unsigned long )v___0 != (unsigned long )(& var_end))) {
#line 484
      goto while_break;
    }
#line 487
    if (v___0->common != -1) {
#line 492
      if (v___0->dimensions > 0) {
        {
#line 498
        FREE((void *)v___0->array_sizes, (char *)"var_delcvars");
#line 499
        v___0->array_sizes = (int *)((void *)0);
#line 500
        FREE((void *)v___0->array_pos, (char *)"var_delcvars");
#line 501
        v___0->array_pos = (int *)((void *)0);
        }
#line 502
        if (v___0->type == 1) {
          {
#line 505
          FREE((void *)v___0->memnum, (char *)"var_delcvars");
#line 506
          v___0->memnum = (bnumber *)((void *)0);
          }
        } else {
#line 511
          sp = v___0->memstr;
#line 512
          n___0 = 0;
          {
#line 512
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 512
            if (! (n___0 < (int )v___0->array_units)) {
#line 512
              goto while_break___0;
            }
#line 514
            if ((unsigned long )(sp + n___0)->sbuffer != (unsigned long )((void *)0)) {
              {
#line 517
              FREE((void *)(sp + n___0)->sbuffer, (char *)"var_delcvars");
#line 518
              (sp + n___0)->sbuffer = (char *)((void *)0);
              }
            }
#line 520
            (sp + n___0)->rab = 0;
#line 521
            (sp + n___0)->length = 0U;
#line 512
            n___0 ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 524
          FREE((void *)v___0->memstr, (char *)"var_delcvars");
#line 525
          v___0->memstr = (bstring *)((void *)0);
          }
        }
      }
      {
#line 531
      p___0->next = v___0->next;
#line 536
      FREE((void *)v___0, (char *)"var_delcvars");
#line 537
      v___0 = (struct bwb_variable *)((void *)0);
      }
    } else {
#line 545
      p___0 = v___0;
    }
#line 484
    v___0 = v___0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 550
  return (-1);
}
}
#line 568 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
struct bwb_line *bwb_ddbl(struct bwb_line *l ) 
{ 
  struct bwb_line *tmp ;

  {
  {
#line 579
  var_defx(l, 1);
#line 581
  tmp = bwb_zline(l);
  }
#line 581
  return (tmp);
}
}
#line 597 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
struct bwb_line *bwb_dint(struct bwb_line *l ) 
{ 
  struct bwb_line *tmp ;

  {
  {
#line 608
  var_defx(l, 1);
#line 610
  tmp = bwb_zline(l);
  }
#line 610
  return (tmp);
}
}
#line 626 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
struct bwb_line *bwb_dsng(struct bwb_line *l ) 
{ 
  struct bwb_line *tmp ;

  {
  {
#line 637
  var_defx(l, 1);
#line 639
  tmp = bwb_zline(l);
  }
#line 639
  return (tmp);
}
}
#line 655 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
struct bwb_line *bwb_dstr(struct bwb_line *l ) 
{ 
  struct bwb_line *tmp ;

  {
  {
#line 666
  var_defx(l, '$');
#line 668
  tmp = bwb_zline(l);
  }
#line 668
  return (tmp);
}
}
#line 700 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
static int pos___0  ;
#line 689 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
struct bwb_line *bwb_mid(struct bwb_line *l ) 
{ 
  char tbuf___20[5001] ;
  char source_string[5001] ;
  struct bwb_variable *v___0 ;
  bstring *d ;
  int *pp___0 ;
  int n_params___0 ;
  int p___0 ;
  register int n___0 ;
  int startpos___0 ;
  int numchars ;
  int endpos ;
  int source_counter ;
  int source_length ;
  int target_length ;
  int target_terminate ;
  struct exp_ese *e___0 ;
  bnumber tmp ;
  bnumber tmp___0 ;
  bstring *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  struct bwb_line *tmp___4 ;

  {
  {
#line 717
  adv_ws(l->buffer, & l->position);
#line 718
  (l->position) ++;
#line 719
  adv_ws(l->buffer, & l->position);
#line 722
  bwb_getvarname(l->buffer, tbuf___20, & l->position);
#line 723
  v___0 = var_find(tbuf___20);
  }
#line 724
  if ((unsigned long )v___0 == (unsigned long )((void *)0)) {
    {
#line 727
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_mid(): failed to find variable");
#line 728
    bwb_error(bwb_ebuf);
    }
  }
#line 734
  if (v___0->type != 36) {
    {
#line 737
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_mid(): assignment must be to string variable");
#line 738
    bwb_error(bwb_ebuf);
    }
  }
#line 745
  pos___0 = 0;
#line 746
  if (v___0->dimensions == 1) {
#line 746
    if (*(v___0->array_sizes + 0) == 1) {
#line 753
      n_params___0 = 1;
#line 754
      pp___0 = & p___0;
#line 755
      *(pp___0 + 0) = dim_base;
    } else {
      {
#line 764
      dim_getparams(l->buffer, & l->position, & n_params___0, & pp___0);
      }
    }
  } else {
    {
#line 764
    dim_getparams(l->buffer, & l->position, & n_params___0, & pp___0);
    }
  }
#line 767
  (exps + expsc)->pos_adv = pos___0;
#line 768
  n___0 = 0;
  {
#line 768
  while (1) {
    while_continue: /* CIL Label */ ;
#line 768
    if (! (n___0 < v___0->dimensions)) {
#line 768
      goto while_break;
    }
#line 770
    *(v___0->array_pos + n___0) = *(pp___0 + n___0);
#line 768
    n___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 774
  d = var_findsval(v___0, pp___0);
#line 777
  adv_ws(l->buffer, & l->position);
#line 778
  (l->position) ++;
#line 779
  adv_ws(l->buffer, & l->position);
#line 782
  adv_element(l->buffer, & l->position, tbuf___20);
#line 783
  pos___0 = 0;
#line 784
  e___0 = bwb_exp(tbuf___20, 0, & pos___0);
#line 785
  tmp = exp_getnval(e___0);
#line 785
  startpos___0 = (int )tmp;
#line 794
  adv_ws(l->buffer, & l->position);
  }
#line 795
  if ((int )*(l->buffer + l->position) == 44) {
    {
#line 797
    target_terminate = 0;
#line 798
    (l->position) ++;
#line 799
    adv_ws(l->buffer, & l->position);
#line 800
    adv_element(l->buffer, & l->position, tbuf___20);
#line 801
    pos___0 = 0;
#line 802
    e___0 = bwb_exp(tbuf___20, 0, & pos___0);
#line 803
    tmp___0 = exp_getnval(e___0);
#line 803
    numchars = (int )tmp___0;
    }
#line 804
    if (numchars == 0) {
      {
#line 807
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_mid(): destination string no. of chars out of range");
#line 808
      bwb_error(bwb_ebuf);
      }
    }
  } else {
#line 816
    target_terminate = 1;
#line 817
    numchars = 0;
  }
#line 820
  if (numchars < 0) {
    {
#line 823
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_mid(): negative string length");
#line 824
    bwb_error(bwb_ebuf);
    }
  }
  {
#line 836
  adv_ws(l->buffer, & l->position);
  }
#line 837
  if ((int )*(l->buffer + l->position) == 41) {
    {
#line 839
    (l->position) ++;
#line 840
    adv_ws(l->buffer, & l->position);
    }
  }
  {
#line 842
  (l->position) ++;
#line 843
  adv_ws(l->buffer, & l->position);
#line 846
  e___0 = bwb_exp(l->buffer, 0, & l->position);
  }
#line 847
  if ((int )e___0->type != 36) {
    {
#line 850
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_mid(): assignment must be from string expression");
#line 851
    bwb_error(bwb_ebuf);
    }
  }
  {
#line 858
  tmp___1 = exp_getsval(e___0);
#line 858
  str_btoc(source_string, tmp___1);
#line 859
  str_btoc(tbuf___20, d);
#line 860
  tmp___2 = strlen((char const   *)(tbuf___20));
#line 860
  target_length = (int )tmp___2;
  }
#line 861
  if (startpos___0 > target_length + 1) {
    {
#line 864
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_mid(): non-contiguous string created");
#line 865
    bwb_error(bwb_ebuf);
    }
  }
#line 871
  if (startpos___0 < 1) {
    {
#line 874
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_mid(): destination string start position out of range");
#line 875
    bwb_error(bwb_ebuf);
    }
  }
  {
#line 881
  tmp___3 = strlen((char const   *)(source_string));
#line 881
  source_length = (int )tmp___3;
  }
#line 882
  if (numchars == 0) {
#line 882
    numchars = source_length;
  }
#line 883
  endpos = (startpos___0 + numchars) - 1;
#line 886
  if (endpos < startpos___0) {
#line 886
    tbuf___20[startpos___0 - 1] = (char )'\000';
  } else {
#line 889
    source_counter = 0;
#line 890
    n___0 = startpos___0 - 1;
    {
#line 890
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 890
      if (! (n___0 < endpos)) {
#line 890
        goto while_break___0;
      }
#line 892
      if (source_counter < source_length) {
#line 893
        tbuf___20[n___0] = source_string[source_counter];
      } else {
#line 895
        tbuf___20[n___0] = (char )' ';
      }
#line 896
      source_counter ++;
#line 890
      n___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 899
    if (endpos > target_length) {
#line 900
      tbuf___20[endpos] = (char )'\000';
    } else
#line 899
    if (target_terminate == 1) {
#line 900
      tbuf___20[endpos] = (char )'\000';
    }
  }
  {
#line 902
  str_ctob(d, tbuf___20);
#line 905
  adv_eos(l->buffer, & l->position);
#line 908
  tmp___4 = bwb_zline(l);
  }
#line 908
  return (tmp___4);
}
}
#line 932 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
static char vname[2]  ;
#line 921 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
static int var_defx(struct bwb_line *l , int type ) 
{ 
  int loop ;
  register int c ;
  struct bwb_variable *v___0 ;
  int tmp ;

  {
#line 937
  loop = -1;
  {
#line 938
  while (1) {
    while_continue: /* CIL Label */ ;
#line 938
    if (! (loop == -1)) {
#line 938
      goto while_break;
    }
    {
#line 943
    adv_ws(l->buffer, & l->position);
    }
    {
#line 949
    if ((int )*(l->buffer + l->position) == 58) {
#line 949
      goto case_58;
    }
#line 949
    if ((int )*(l->buffer + l->position) == 0) {
#line 949
      goto case_58;
    }
#line 949
    if ((int )*(l->buffer + l->position) == 13) {
#line 949
      goto case_58;
    }
#line 949
    if ((int )*(l->buffer + l->position) == 10) {
#line 949
      goto case_58;
    }
#line 944
    goto switch_break;
    case_58: /* CIL Label */ 
    case_0: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 950
    return (0);
    switch_break: /* CIL Label */ ;
    }
    {
#line 955
    tmp = var_letseq(l->buffer, & l->position, & first, & last);
    }
#line 955
    if (tmp == 0) {
#line 957
      return (0);
    }
#line 962
    c = first;
    {
#line 962
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 962
      if (! (c <= last)) {
#line 962
        goto while_break___0;
      }
      {
#line 964
      vname[0] = (char )c;
#line 965
      vname[1] = (char )'\000';
#line 973
      v___0 = var_find(vname);
#line 979
      var_make(v___0, type);
#line 962
      c ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 985
  return (-1);
}
}
#line 1001 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
static int var_letseq(char *buffer , int *position___7 , int *start , int *end ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 1020
  adv_ws(buffer, position___7);
  }
  {
#line 1029
  if ((int )*(buffer + *position___7) == 58) {
#line 1029
    goto case_58;
  }
#line 1029
  if ((int )*(buffer + *position___7) == 13) {
#line 1029
    goto case_58;
  }
#line 1029
  if ((int )*(buffer + *position___7) == 10) {
#line 1029
    goto case_58;
  }
#line 1029
  if ((int )*(buffer + *position___7) == 0) {
#line 1029
    goto case_58;
  }
#line 1024
  goto switch_break;
  case_58: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 1030
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1035
  tmp = __ctype_b_loc();
  }
#line 1035
  if (((int const   )*(*tmp + (int )*(buffer + *position___7)) & 1024) == 0) {
    {
#line 1037
    bwb_error(err_defchar);
    }
#line 1038
    return (0);
  }
  {
#line 1041
  tmp___0 = (int )*(buffer + *position___7);
#line 1041
  *start = tmp___0;
#line 1041
  *end = tmp___0;
#line 1045
  (*position___7) ++;
#line 1046
  adv_ws(buffer, position___7);
  }
#line 1050
  if ((int )*(buffer + *position___7) == 45) {
    {
#line 1053
    (*position___7) ++;
#line 1057
    adv_ws(buffer, position___7);
#line 1061
    tmp___1 = __ctype_b_loc();
    }
#line 1061
    if (((int const   )*(*tmp___1 + (int )*(buffer + *position___7)) & 1024) == 0) {
#line 1063
      *end = *start;
    } else {
#line 1067
      *end = (int )*(buffer + *position___7);
#line 1068
      (*position___7) ++;
    }
  }
#line 1075
  if ((int )*(buffer + *position___7) == 44) {
#line 1077
    (*position___7) ++;
  }
#line 1080
  return (-1);
}
}
#line 1098 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
int bwb_const(char *lb , char *sb , int *n___0 ) 
{ 
  register int s___0 ;

  {
#line 1110
  (*n___0) ++;
#line 1111
  s___0 = 0;
  {
#line 1113
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1117
    if ((int )*(lb + *n___0) == 34) {
#line 1117
      goto case_34;
    }
#line 1123
    if ((int )*(lb + *n___0) == 0) {
#line 1123
      goto case_0;
    }
#line 1123
    if ((int )*(lb + *n___0) == 13) {
#line 1123
      goto case_0;
    }
#line 1123
    if ((int )*(lb + *n___0) == 10) {
#line 1123
      goto case_0;
    }
#line 1126
    goto switch_default;
    case_34: /* CIL Label */ 
#line 1118
    *(sb + s___0) = (char)0;
#line 1119
    (*n___0) ++;
#line 1120
    return (-1);
    case_0: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 1124
    *(sb + s___0) = (char)0;
#line 1125
    return (-1);
    switch_default: /* CIL Label */ 
#line 1127
    *(sb + s___0) = *(lb + *n___0);
#line 1128
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1131
    (*n___0) ++;
#line 1132
    s___0 ++;
#line 1133
    *(sb + s___0) = (char)0;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1151 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
int bwb_getvarname(char *lb , char *sb , int *n___0 ) 
{ 
  register int s___0 ;

  {
  {
#line 1163
  s___0 = 0;
#line 1167
  adv_ws(lb, n___0);
  }
  {
#line 1169
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1183
    if ((int )*(lb + *n___0) == 61) {
#line 1183
      goto case_61;
    }
#line 1183
    if ((int )*(lb + *n___0) == 43) {
#line 1183
      goto case_61;
    }
#line 1183
    if ((int )*(lb + *n___0) == 40) {
#line 1183
      goto case_61;
    }
#line 1183
    if ((int )*(lb + *n___0) == 59) {
#line 1183
      goto case_61;
    }
#line 1183
    if ((int )*(lb + *n___0) == 44) {
#line 1183
      goto case_61;
    }
#line 1183
    if ((int )*(lb + *n___0) == 58) {
#line 1183
      goto case_61;
    }
#line 1183
    if ((int )*(lb + *n___0) == 0) {
#line 1183
      goto case_61;
    }
#line 1183
    if ((int )*(lb + *n___0) == 13) {
#line 1183
      goto case_61;
    }
#line 1183
    if ((int )*(lb + *n___0) == 10) {
#line 1183
      goto case_61;
    }
#line 1183
    if ((int )*(lb + *n___0) == 9) {
#line 1183
      goto case_61;
    }
#line 1183
    if ((int )*(lb + *n___0) == 32) {
#line 1183
      goto case_61;
    }
#line 1186
    goto switch_default;
    case_61: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_40: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_0: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 1184
    *(sb + s___0) = (char)0;
#line 1185
    return (-1);
    switch_default: /* CIL Label */ 
#line 1187
    *(sb + s___0) = *(lb + *n___0);
#line 1188
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1191
    (*n___0) ++;
#line 1192
    s___0 ++;
#line 1193
    *(sb + s___0) = (char)0;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1215 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
struct bwb_variable *var_find(char *buffer ) 
{ 
  struct bwb_variable *v___0 ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 1232
  v___0 = var_islocal(buffer);
  }
#line 1233
  if ((unsigned long )v___0 != (unsigned long )((void *)0)) {
#line 1235
    return (v___0);
  }
#line 1240
  v___0 = var_start.next;
  {
#line 1240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1240
    if (! ((unsigned long )v___0 != (unsigned long )(& var_end))) {
#line 1240
      goto while_break;
    }
    {
#line 1243
    tmp = strcmp((char const   *)(v___0->name), (char const   *)buffer);
    }
#line 1243
    if (tmp == 0) {
      {
#line 1248
      if (v___0->type == 1) {
#line 1248
        goto case_1;
      }
#line 1248
      if (v___0->type == 36) {
#line 1248
        goto case_1;
      }
#line 1250
      goto switch_default;
      case_1: /* CIL Label */ 
      case_36: /* CIL Label */ 
#line 1249
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1252
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in var_find(): inappropriate precision for variable <%s>",
              v___0->name);
#line 1254
      bwb_error(bwb_ebuf);
      }
#line 1256
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1263
      return (v___0);
    }
#line 1240
    v___0 = v___0->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1271
  tmp___0 = strlen((char const   *)buffer);
  }
#line 1271
  if (tmp___0 == 0UL) {
    {
#line 1274
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in var_find(): NULL variable name received\n");
#line 1275
    bwb_error(bwb_ebuf);
    }
#line 1279
    return ((struct bwb_variable *)((void *)0));
  }
  {
#line 1284
  v___0 = var_new(buffer);
#line 1288
  v___0->next = var_start.next;
#line 1289
  var_start.next = v___0;
#line 1293
  v___0->preset = 0;
  }
#line 1302
  return (v___0);
}
}
#line 1315 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
struct bwb_variable *var_new(char *name ) 
{ 
  struct bwb_variable *v___0 ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 1328
  tmp = CALLOC((size_t )1, sizeof(struct bwb_variable ), (char *)"var_new");
#line 1328
  v___0 = (struct bwb_variable *)tmp;
  }
#line 1328
  if ((unsigned long )v___0 == (unsigned long )((void *)0)) {
    {
#line 1331
    bwb_error(err_getmem);
    }
#line 1332
    return ((struct bwb_variable *)((void *)0));
  }
  {
#line 1337
  strcpy((char */* __restrict  */)(v___0->name), (char const   */* __restrict  */)name);
#line 1341
  tmp___0 = strlen((char const   *)(v___0->name));
#line 1341
  var_make(v___0, (int )v___0->name[tmp___0 - 1UL]);
  }
#line 1345
  return (v___0);
}
}
#line 1360 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
int bwb_isvar(char *buffer ) 
{ 
  struct bwb_variable *v___0 ;
  int tmp ;

  {
#line 1372
  v___0 = var_start.next;
  {
#line 1372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1372
    if (! ((unsigned long )v___0 != (unsigned long )(& var_end))) {
#line 1372
      goto while_break;
    }
    {
#line 1375
    tmp = strcmp((char const   *)(v___0->name), (char const   *)buffer);
    }
#line 1375
    if (tmp == 0) {
#line 1377
      return (-1);
    }
#line 1372
    v___0 = v___0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1384
  return (0);
}
}
#line 1398 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
bnumber var_getnval(struct bwb_variable *nvar___34 ) 
{ 
  bnumber *tmp ;

  {
  {
#line 1409
  if (nvar___34->type == 1) {
#line 1409
    goto case_1;
  }
#line 1407
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1410
  tmp = var_findnval(nvar___34, nvar___34->array_pos);
  }
#line 1410
  return (*tmp);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1414
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in var_getnval(): type is <%d>=<%c>.",
          nvar___34->type, nvar___34->type);
#line 1416
  bwb_error(bwb_ebuf);
  }
#line 1422
  return (0.0);
}
}
#line 1445 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
static bstring b___3  ;
#line 1437 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
bstring *var_getsval(struct bwb_variable *nvar___34 ) 
{ 
  bstring *tmp ;
  bnumber *tmp___0 ;
  int tmp___1 ;

  {
#line 1447
  b___3.rab = 0;
  {
#line 1451
  if (nvar___34->type == 36) {
#line 1451
    goto case_36;
  }
#line 1453
  if (nvar___34->type == 1) {
#line 1453
    goto case_1;
  }
#line 1458
  goto switch_default;
  case_36: /* CIL Label */ 
  {
#line 1452
  tmp = var_findsval(nvar___34, nvar___34->array_pos);
  }
#line 1452
  return (tmp);
  case_1: /* CIL Label */ 
  {
#line 1454
  tmp___0 = var_findnval(nvar___34, nvar___34->array_pos);
#line 1454
  tmp___1 = prn_precision(nvar___34);
#line 1454
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"%*f ",
          tmp___1, *tmp___0);
#line 1456
  str_ctob(& b___3, bwb_ebuf);
  }
#line 1457
  return (& b___3);
  switch_default: /* CIL Label */ 
  {
#line 1460
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in var_getsval(): type is <%d>=<%c>.",
          nvar___34->type, nvar___34->type);
#line 1462
  bwb_error(bwb_ebuf);
  }
#line 1466
  return ((bstring *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1493 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
static int n_params  ;
#line 1494 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
static int *pp  ;
#line 1484 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
struct bwb_line *bwb_dim(struct bwb_line *l ) 
{ 
  register int n___0 ;
  struct bwb_variable *newvar ;
  bnumber *np ;
  int loop ;
  int old_name ;
  int old_dimensions ;
  char tbuf___20[5001] ;
  int tmp ;
  struct bwb_line *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  struct bwb_line *tmp___3 ;
  int *tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  struct bwb_line *tmp___7 ;
  bstring *tmp___8 ;
  void *tmp___9 ;
  struct bwb_line *tmp___10 ;
  void *tmp___11 ;
  struct bwb_line *tmp___12 ;
  struct bwb_line *tmp___13 ;

  {
#line 1506
  loop = -1;
  {
#line 1507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1507
    if (! (loop == -1)) {
#line 1507
      goto while_break;
    }
    {
#line 1510
    old_name = 0;
#line 1514
    adv_ws(l->buffer, & l->position);
#line 1515
    bwb_getvarname(l->buffer, tbuf___20, & l->position);
#line 1519
    tmp = bwb_isvar(tbuf___20);
    }
#line 1519
    if (tmp == -1) {
#line 1526
      old_name = -1;
    }
    {
#line 1531
    newvar = var_find(tbuf___20);
#line 1541
    dimmed = -1;
#line 1545
    old_dimensions = newvar->dimensions;
#line 1546
    dim_getparams(l->buffer, & l->position, & n_params, & pp);
#line 1547
    newvar->dimensions = n_params;
    }
#line 1551
    if (old_name == -1) {
#line 1556
      if (newvar->dimensions != old_dimensions) {
        {
#line 1559
        sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_dim(): variable <%s> cannot be re-dimensioned",
                newvar->name);
#line 1561
        bwb_error(bwb_ebuf);
        }
      }
#line 1569
      n___0 = 0;
      {
#line 1569
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1569
        if (! (n___0 < newvar->dimensions)) {
#line 1569
          goto while_break___0;
        }
#line 1576
        if (*(pp + n___0) + (1 - dim_base) != *(newvar->array_sizes + n___0)) {
          {
#line 1579
          sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_dim(): variable <%s> parameter <%d> cannot be resized",
                  newvar->name, n___0);
#line 1581
          bwb_error(bwb_ebuf);
          }
        }
#line 1569
        n___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 1599
      tmp___2 = CALLOC((size_t )n_params, sizeof(int ), (char *)"bwb_dim");
#line 1599
      tmp___1 = (int *)tmp___2;
#line 1599
      newvar->array_sizes = tmp___1;
      }
#line 1599
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
        {
#line 1602
        sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in line %d: Failed to find memory for array_sizes for <%s>",
                l->number, newvar->name);
#line 1604
        bwb_error(bwb_ebuf);
#line 1608
        tmp___0 = bwb_zline(l);
        }
#line 1608
        return (tmp___0);
      }
#line 1611
      n___0 = 0;
      {
#line 1611
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1611
        if (! (n___0 < newvar->dimensions)) {
#line 1611
          goto while_break___1;
        }
#line 1613
        *(newvar->array_sizes + n___0) = *(pp + n___0) + (1 - dim_base);
#line 1611
        n___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1624
      tmp___5 = CALLOC((size_t )n_params, sizeof(int ), (char *)"bwb_dim");
#line 1624
      tmp___4 = (int *)tmp___5;
#line 1624
      newvar->array_pos = tmp___4;
      }
#line 1624
      if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
        {
#line 1627
        sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in line %d: Failed to find memory for array_pos for <%s>",
                l->number, newvar->name);
#line 1629
        bwb_error(bwb_ebuf);
#line 1633
        tmp___3 = bwb_zline(l);
        }
#line 1633
        return (tmp___3);
      }
#line 1636
      n___0 = 0;
      {
#line 1636
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1636
        if (! (n___0 < newvar->dimensions)) {
#line 1636
          goto while_break___2;
        }
#line 1638
        *(newvar->array_pos + n___0) = dim_base;
#line 1636
        n___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1643
      newvar->array_units = (size_t )2147483647;
#line 1644
      tmp___6 = dim_unit(newvar, pp);
#line 1644
      newvar->array_units = tmp___6 + 1UL;
      }
      {
#line 1656
      if (newvar->type == 36) {
#line 1656
        goto case_36;
      }
#line 1682
      if (newvar->type == 1) {
#line 1682
        goto case_1;
      }
#line 1707
      goto switch_default;
      case_36: /* CIL Label */ 
      {
#line 1669
      tmp___9 = CALLOC(newvar->array_units, sizeof(bstring ), (char *)"bwb_dim");
#line 1669
      tmp___8 = (bstring *)tmp___9;
#line 1669
      newvar->memstr = tmp___8;
      }
#line 1669
      if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
        {
#line 1673
        sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in line %d: Failed to find memory for array <%s>",
                l->number, newvar->name);
#line 1675
        bwb_error(bwb_ebuf);
#line 1679
        tmp___7 = bwb_zline(l);
        }
#line 1679
        return (tmp___7);
      }
#line 1681
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 1693
      tmp___11 = CALLOC(newvar->array_units, sizeof(bnumber ), (char *)"bwb_dim");
#line 1693
      np = (bnumber *)tmp___11;
      }
#line 1693
      if ((unsigned long )np == (unsigned long )((void *)0)) {
        {
#line 1697
        sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in line %d: Failed to find memory for array <%s>",
                l->number, newvar->name);
#line 1699
        bwb_error(bwb_ebuf);
#line 1703
        tmp___10 = bwb_zline(l);
        }
#line 1703
        return (tmp___10);
      }
#line 1705
      newvar->memnum = np;
#line 1706
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1709
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in line %d: New variable has unrecognized type.",
              l->number);
#line 1711
      bwb_error(bwb_ebuf);
#line 1715
      tmp___12 = bwb_zline(l);
      }
#line 1715
      return (tmp___12);
      switch_break: /* CIL Label */ ;
      }
    }
#line 1722
    if ((int )*(l->buffer + l->position) == 41) {
#line 1724
      (l->position) ++;
    }
    {
#line 1726
    adv_ws(l->buffer, & l->position);
    }
    {
#line 1732
    if ((int )*(l->buffer + l->position) == 0) {
#line 1732
      goto case_0;
    }
#line 1732
    if ((int )*(l->buffer + l->position) == 58) {
#line 1732
      goto case_0;
    }
#line 1732
    if ((int )*(l->buffer + l->position) == 13) {
#line 1732
      goto case_0;
    }
#line 1732
    if ((int )*(l->buffer + l->position) == 10) {
#line 1732
      goto case_0;
    }
#line 1735
    if ((int )*(l->buffer + l->position) == 44) {
#line 1735
      goto case_44;
    }
#line 1740
    goto switch_default___0;
    case_0: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 1733
    loop = 0;
#line 1734
    goto switch_break___0;
    case_44: /* CIL Label */ 
    {
#line 1736
    (l->position) ++;
#line 1737
    adv_ws(l->buffer, & l->position);
#line 1738
    loop = -1;
    }
#line 1739
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 1742
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_dim(): unexpected end of string, buf <%s>",
            l->buffer + l->position);
#line 1744
    bwb_error(bwb_ebuf);
#line 1748
    loop = 0;
    }
#line 1749
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1756
  tmp___13 = bwb_zline(l);
  }
#line 1756
  return (tmp___13);
}
}
#line 1770 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
static size_t dim_unit(struct bwb_variable *v___0 , int *pp___0 ) 
{ 
  size_t r ;
  size_t b___4 ;
  register int n___0 ;

  {
#line 1785
  b___4 = (size_t )1;
#line 1786
  r = (size_t )0;
#line 1787
  n___0 = 0;
  {
#line 1787
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1787
    if (! (n___0 < v___0->dimensions)) {
#line 1787
      goto while_break;
    }
#line 1789
    r += b___4 * (size_t )(*(pp___0 + n___0) - dim_base);
#line 1790
    b___4 *= (size_t )*(v___0->array_sizes + n___0);
#line 1787
    n___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1805
  if (r > v___0->array_units) {
    {
#line 1808
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in dim_unit(): unit value <%ld> exceeds array units <%ld>",
            (long )r, (long )v___0->array_units);
#line 1810
    bwb_error(bwb_ebuf);
    }
#line 1814
    return ((size_t )0);
  }
#line 1817
  return (r);
}
}
#line 1848 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
static int params[64]  ;
#line 1836 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
int dim_getparams(char *buffer , int *pos___2 , int *n_params___0 , int **pp___0 ) 
{ 
  int loop ;
  int x_pos ;
  int s_pos ;
  struct exp_ese *e___0 ;
  char tbuf___20[5001] ;
  int paren_level ;
  int quote_level ;
  bnumber tmp ;
  bnumber tmp___0 ;

  {
  {
#line 1859
  *n_params___0 = 0;
#line 1866
  adv_ws(buffer, pos___2);
  }
#line 1867
  if ((int )*(buffer + *pos___2) != 40) {
#line 1869
    *n_params___0 = 1;
#line 1870
    params[0] = dim_base;
#line 1871
    *pp___0 = params;
#line 1872
    return (-1);
  } else {
#line 1876
    (*pos___2) ++;
  }
#line 1881
  s_pos = 0;
#line 1882
  tbuf___20[0] = (char )'\000';
#line 1883
  loop = -1;
#line 1884
  paren_level = 1;
#line 1885
  quote_level = 0;
  {
#line 1886
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1886
    if (! (loop == -1)) {
#line 1886
      goto while_break;
    }
    {
#line 1890
    if ((int )*(buffer + *pos___2) == 41) {
#line 1890
      goto case_41;
    }
#line 1927
    if ((int )*(buffer + *pos___2) == 44) {
#line 1927
      goto case_44;
    }
#line 1961
    if ((int )*(buffer + *pos___2) == 9) {
#line 1961
      goto case_9;
    }
#line 1961
    if ((int )*(buffer + *pos___2) == 32) {
#line 1961
      goto case_9;
    }
#line 1965
    goto switch_default;
    case_41: /* CIL Label */ 
#line 1894
    if (quote_level == 0) {
#line 1894
      paren_level --;
    }
#line 1895
    if (paren_level != 0) {
#line 1897
      tbuf___20[s_pos] = *(buffer + *pos___2);
#line 1898
      (*pos___2) ++;
#line 1899
      s_pos ++;
#line 1900
      tbuf___20[s_pos] = (char )'\000';
#line 1901
      goto switch_break;
    } else
#line 1895
    if (quote_level != 0) {
#line 1897
      tbuf___20[s_pos] = *(buffer + *pos___2);
#line 1898
      (*pos___2) ++;
#line 1899
      s_pos ++;
#line 1900
      tbuf___20[s_pos] = (char )'\000';
#line 1901
      goto switch_break;
    }
#line 1904
    x_pos = 0;
#line 1905
    if ((int )tbuf___20[0] == 0) {
#line 1907
      params[*n_params___0] = 11;
    } else {
      {
#line 1915
      e___0 = bwb_exp(tbuf___20, 0, & x_pos);
#line 1920
      tmp = exp_getnval(e___0);
#line 1920
      params[*n_params___0] = (int )tmp;
      }
    }
#line 1922
    (*n_params___0) ++;
#line 1923
    loop = 0;
#line 1924
    (*pos___2) ++;
#line 1925
    goto switch_break;
    case_44: /* CIL Label */ 
#line 1931
    if (paren_level != 1) {
#line 1933
      tbuf___20[s_pos] = *(buffer + *pos___2);
#line 1934
      (*pos___2) ++;
#line 1935
      s_pos ++;
#line 1936
      tbuf___20[s_pos] = (char )'\000';
#line 1937
      goto switch_break;
    } else
#line 1931
    if (quote_level != 0) {
#line 1933
      tbuf___20[s_pos] = *(buffer + *pos___2);
#line 1934
      (*pos___2) ++;
#line 1935
      s_pos ++;
#line 1936
      tbuf___20[s_pos] = (char )'\000';
#line 1937
      goto switch_break;
    }
#line 1940
    x_pos = 0;
#line 1941
    if ((int )tbuf___20[0] == 0) {
#line 1943
      params[*n_params___0] = 11;
    } else {
      {
#line 1951
      e___0 = bwb_exp(tbuf___20, 0, & x_pos);
#line 1952
      tmp___0 = exp_getnval(e___0);
#line 1952
      params[*n_params___0] = (int )tmp___0;
      }
    }
#line 1954
    (*n_params___0) ++;
#line 1955
    tbuf___20[0] = (char )'\000';
#line 1956
    (*pos___2) ++;
#line 1957
    s_pos = 0;
#line 1958
    goto switch_break;
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 1962
    (*pos___2) ++;
#line 1963
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1966
    if ((int )*(buffer + *pos___2) == 40) {
#line 1966
      if (quote_level == 0) {
#line 1967
        paren_level ++;
      }
    }
#line 1968
    if ((int )*(buffer + *pos___2) == 34) {
#line 1970
      if (quote_level == 0) {
#line 1970
        quote_level = 1;
      } else {
#line 1971
        quote_level = 0;
      }
    }
#line 1973
    tbuf___20[s_pos] = *(buffer + *pos___2);
#line 1974
    (*pos___2) ++;
#line 1975
    s_pos ++;
#line 1976
    tbuf___20[s_pos] = (char )'\000';
#line 1977
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1992
  *pp___0 = params;
#line 1994
  return (-1);
}
}
#line 2011 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
struct bwb_line *bwb_option(struct bwb_line *l ) 
{ 
  register int n___0 ;
  int newval ;
  struct exp_ese *e___0 ;
  struct bwb_variable *current ;
  char tbuf___20[5000] ;
  struct bwb_line *tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  struct bwb_line *tmp___2 ;
  int tmp___3 ;
  bnumber tmp___4 ;
  struct bwb_line *tmp___5 ;
  struct bwb_line *tmp___6 ;

  {
#line 2032
  if (dimmed != 0) {
    {
#line 2035
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"at line %d: OPTION BASE must be called before DIM.",
            l->number);
#line 2037
    bwb_error(bwb_ebuf);
#line 2041
    tmp = bwb_zline(l);
    }
#line 2041
    return (tmp);
  }
  {
#line 2046
  adv_element(l->buffer, & l->position, tbuf___20);
#line 2047
  n___0 = 0;
  }
  {
#line 2047
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2047
    if (! ((int )tbuf___20[n___0] != 0)) {
#line 2047
      goto while_break;
    }
    {
#line 2049
    tmp___1 = __ctype_b_loc();
    }
#line 2049
    if (((int const   )*(*tmp___1 + (int )tbuf___20[n___0]) & 512) != 0) {
      {
#line 2051
      tmp___0 = toupper((int )tbuf___20[n___0]);
#line 2051
      tbuf___20[n___0] = (char )tmp___0;
      }
    }
#line 2047
    n___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2057
  tmp___3 = strncmp((char const   *)(tbuf___20), "BASE", (size_t )4);
  }
#line 2057
  if (tmp___3 != 0) {
    {
#line 2060
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"at line %d: Unknown statement <%s> following OPTION.",
            l->number, tbuf___20);
#line 2062
    bwb_error(bwb_ebuf);
#line 2066
    tmp___2 = bwb_zline(l);
    }
#line 2066
    return (tmp___2);
  }
  {
#line 2071
  adv_ws(l->buffer, & l->position);
#line 2072
  e___0 = bwb_exp(l->buffer, 0, & l->position);
#line 2073
  tmp___4 = exp_getnval(e___0);
#line 2073
  newval = (int )tmp___4;
  }
#line 2082
  if (newval < 0) {
    {
#line 2085
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"at line %d: value for OPTION BASE must be 1 or 0.",
            l->number);
#line 2087
    bwb_error(bwb_ebuf);
#line 2091
    tmp___5 = bwb_zline(l);
    }
#line 2091
    return (tmp___5);
  } else
#line 2082
  if (newval > 1) {
    {
#line 2085
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"at line %d: value for OPTION BASE must be 1 or 0.",
            l->number);
#line 2087
    bwb_error(bwb_ebuf);
#line 2091
    tmp___5 = bwb_zline(l);
    }
#line 2091
    return (tmp___5);
  }
#line 2096
  dim_base = newval;
#line 2101
  current = var_start.next;
  {
#line 2101
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2101
    if (! ((unsigned long )current != (unsigned long )(& var_end))) {
#line 2101
      goto while_break___0;
    }
#line 2103
    *(current->array_pos + 0) = dim_base;
#line 2101
    current = current->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2108
  tmp___6 = bwb_zline(l);
  }
#line 2108
  return (tmp___6);
}
}
#line 2127 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
bnumber *var_findnval(struct bwb_variable *v___0 , int *pp___0 ) 
{ 
  size_t offset ;
  bnumber *p___0 ;
  int tmp ;

  {
#line 2144
  if (v___0->type != 1) {
    {
#line 2147
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in var_findnval(): Variable <%s> is not a number.",
            v___0->name);
#line 2149
    bwb_error(bwb_ebuf);
    }
#line 2153
    return ((bnumber *)((void *)0));
  }
  {
#line 2158
  tmp = dim_check(v___0, pp___0);
  }
#line 2158
  if (tmp == 0) {
#line 2160
    return ((bnumber *)((void *)0));
  }
  {
#line 2165
  offset = dim_unit(v___0, pp___0);
#line 2177
  p___0 = v___0->memnum;
  }
#line 2178
  return (p___0 + offset);
}
}
#line 2196 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
bstring *var_findsval(struct bwb_variable *v___0 , int *pp___0 ) 
{ 
  size_t offset ;
  bstring *p___0 ;
  int tmp ;

  {
#line 2217
  if (v___0->type != 36) {
    {
#line 2220
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in var_findsval(): Variable <%s> is not a string.",
            v___0->name);
#line 2221
    bwb_error(bwb_ebuf);
    }
#line 2225
    return ((bstring *)((void *)0));
  }
  {
#line 2230
  tmp = dim_check(v___0, pp___0);
  }
#line 2230
  if (tmp == 0) {
#line 2232
    return ((bstring *)((void *)0));
  }
  {
#line 2237
  offset = dim_unit(v___0, pp___0);
#line 2249
  p___0 = v___0->memstr;
  }
#line 2250
  return (p___0 + offset);
}
}
#line 2265 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
static int dim_check(struct bwb_variable *v___0 , int *pp___0 ) 
{ 
  register int n___0 ;

  {
#line 2278
  if (v___0->dimensions < 1) {
    {
#line 2281
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in dim_check(): var <%s> dimensions <%d>",
            v___0->name, v___0->dimensions);
#line 2283
    bwb_error(bwb_ebuf);
    }
#line 2287
    return (0);
  }
#line 2292
  if (v___0->type == 1) {
#line 2292
    if ((unsigned long )v___0->memnum == (unsigned long )((void *)0)) {
      {
#line 2295
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in dim_check(): numerical var <%s> memnum not allocated",
              v___0->name);
#line 2297
      bwb_error(bwb_ebuf);
      }
#line 2301
      return (0);
    }
  }
#line 2304
  if (v___0->type == 36) {
#line 2304
    if ((unsigned long )v___0->memstr == (unsigned long )((void *)0)) {
      {
#line 2307
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in dim_check(): string var <%s> memstr not allocated",
              v___0->name);
#line 2309
      bwb_error(bwb_ebuf);
      }
#line 2313
      return (0);
    }
  }
#line 2318
  n___0 = 0;
  {
#line 2318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2318
    if (! (n___0 < v___0->dimensions)) {
#line 2318
      goto while_break;
    }
#line 2320
    if (*(pp___0 + n___0) < dim_base) {
      {
#line 2324
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in dim_check(): array subscript var <%s> pos <%d> val <%d> out of range <%d>-<%d>.",
              v___0->name, n___0, *(pp___0 + n___0), dim_base, *(v___0->array_sizes + n___0));
#line 2326
      bwb_error(bwb_ebuf);
      }
#line 2330
      return (0);
    } else
#line 2320
    if (*(pp___0 + n___0) - dim_base > *(v___0->array_sizes + n___0)) {
      {
#line 2324
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in dim_check(): array subscript var <%s> pos <%d> val <%d> out of range <%d>-<%d>.",
              v___0->name, n___0, *(pp___0 + n___0), dim_base, *(v___0->array_sizes + n___0));
#line 2326
      bwb_error(bwb_ebuf);
      }
#line 2330
      return (0);
    }
#line 2318
    n___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2336
  return (-1);
}
}
#line 2350 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
int var_make(struct bwb_variable *v___0 , int type ) 
{ 
  size_t data_size ;
  bstring *b___4 ;
  bstring *sp ;
  register int n___0 ;
  bnumber *tmp ;
  void *tmp___0 ;
  bstring *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 2369
  if (type == 36) {
#line 2369
    goto case_36;
  }
#line 2373
  goto switch_default;
  case_36: /* CIL Label */ 
#line 2370
  v___0->type = '$';
#line 2371
  data_size = sizeof(bstring );
#line 2372
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2374
  v___0->type = 1;
#line 2375
  data_size = sizeof(bnumber );
#line 2376
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2382
  if ((unsigned long )v___0->memnum != (unsigned long )((void *)0)) {
    {
#line 2385
    FREE((void *)v___0->memnum, (char *)"var_make");
#line 2386
    v___0->memnum = (bnumber *)((void *)0);
    }
  }
#line 2388
  if ((unsigned long )v___0->memstr != (unsigned long )((void *)0)) {
#line 2391
    sp = v___0->memstr;
#line 2392
    n___0 = 0;
    {
#line 2392
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2392
      if (! (n___0 < (int )v___0->array_units)) {
#line 2392
        goto while_break;
      }
#line 2394
      if ((unsigned long )(sp + n___0)->sbuffer != (unsigned long )((void *)0)) {
        {
#line 2397
        FREE((void *)(sp + n___0)->sbuffer, (char *)"var_make");
#line 2398
        (sp + n___0)->sbuffer = (char *)((void *)0);
        }
      }
#line 2400
      (sp + n___0)->rab = 0;
#line 2401
      (sp + n___0)->length = 0U;
#line 2392
      n___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2404
    FREE((void *)v___0->memstr, (char *)"var_make");
#line 2405
    v___0->memstr = (bstring *)((void *)0);
    }
  }
#line 2408
  if ((unsigned long )v___0->array_sizes != (unsigned long )((void *)0)) {
    {
#line 2410
    FREE((void *)v___0->array_sizes, (char *)"var_make");
#line 2411
    v___0->array_sizes = (int *)((void *)0);
    }
  }
#line 2413
  if ((unsigned long )v___0->array_pos != (unsigned long )((void *)0)) {
    {
#line 2415
    FREE((void *)v___0->array_pos, (char *)"var_make");
#line 2416
    v___0->array_pos = (int *)((void *)0);
    }
  }
#line 2419
  if (v___0->type == 1) {
    {
#line 2422
    tmp___0 = CALLOC((size_t )2, sizeof(bnumber ), (char *)"var_make");
#line 2422
    tmp = (bnumber *)tmp___0;
#line 2422
    v___0->memnum = tmp;
    }
#line 2422
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 2424
      bwb_error(err_getmem);
      }
#line 2425
      return (0);
    }
  } else {
    {
#line 2431
    tmp___2 = CALLOC((size_t )2, sizeof(bstring ), (char *)"var_make");
#line 2431
    tmp___1 = (bstring *)tmp___2;
#line 2431
    v___0->memstr = tmp___1;
    }
#line 2431
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
#line 2433
      bwb_error(err_getmem);
      }
#line 2434
      return (0);
    }
  }
  {
#line 2441
  tmp___4 = CALLOC((size_t )2, sizeof(int ), (char *)"var_make");
#line 2441
  tmp___3 = (int *)tmp___4;
#line 2441
  v___0->array_sizes = tmp___3;
  }
#line 2441
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
    {
#line 2443
    bwb_error(err_getmem);
    }
#line 2444
    return (0);
  }
  {
#line 2448
  tmp___6 = CALLOC((size_t )2, sizeof(int ), (char *)"var_make");
#line 2448
  tmp___5 = (int *)tmp___6;
#line 2448
  v___0->array_pos = tmp___5;
  }
#line 2448
  if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
    {
#line 2450
    bwb_error(err_getmem);
    }
#line 2451
    return (0);
  }
#line 2454
  *(v___0->array_pos + 0) = dim_base;
#line 2455
  *(v___0->array_sizes + 0) = 1;
#line 2456
  v___0->dimensions = 1;
#line 2457
  v___0->common = 0;
#line 2458
  v___0->array_units = (size_t )1;
#line 2460
  if (type == 36) {
    {
#line 2462
    b___4 = var_findsval(v___0, v___0->array_pos);
#line 2463
    b___4->rab = 0;
    }
  }
#line 2484
  return (-1);
}
}
#line 2500 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_var.c"
extern struct bwb_variable *var_islocal(char *buffer ) 
{ 
  struct bwb_variable *v___0 ;
  int tmp ;

  {
#line 2510
  if (exsc < 0) {
#line 2513
    return ((struct bwb_variable *)((void *)0));
  }
#line 2524
  v___0 = (excs + exsc)->local_variable;
  {
#line 2524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2524
    if (! ((unsigned long )v___0 != (unsigned long )((void *)0))) {
#line 2524
      goto while_break;
    }
    {
#line 2533
    tmp = strcmp((char const   *)(v___0->name), (char const   *)buffer);
    }
#line 2533
    if (tmp == 0) {
      {
#line 2540
      if (v___0->type == 1) {
#line 2540
        goto case_1;
      }
#line 2540
      if (v___0->type == 36) {
#line 2540
        goto case_1;
      }
#line 2542
      goto switch_default;
      case_1: /* CIL Label */ 
      case_36: /* CIL Label */ 
#line 2541
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 2543
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in var_islocal(): inappropriate precision for variable <%s>",
              v___0->name);
#line 2545
      bwb_error(bwb_ebuf);
      }
#line 2546
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 2555
      return (v___0);
    }
#line 2524
    v___0 = v___0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2568
  return ((struct bwb_variable *)((void *)0));
}
}
#line 52 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_elx.c"
int exp_paren(char *expression ) 
{ 
  struct exp_ese *e___0 ;
  int s_pos ;
  int loop ;
  int paren_level ;
  bstring *tmp ;
  bstring *tmp___0 ;

  {
#line 67
  (exps + expsc)->pos_adv = 1;
#line 68
  s_pos = 0;
#line 69
  loop = -1;
#line 70
  paren_level = 1;
#line 71
  (exps + expsc)->string[0] = (char )'\000';
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! (loop == -1)) {
#line 73
      goto while_break;
    }
    {
#line 83
    if ((int )*(expression + (exps + expsc)->pos_adv) == 0) {
#line 83
      goto case_0;
    }
#line 83
    if ((int )*(expression + (exps + expsc)->pos_adv) == 10) {
#line 83
      goto case_0;
    }
#line 83
    if ((int )*(expression + (exps + expsc)->pos_adv) == 13) {
#line 83
      goto case_0;
    }
#line 88
    if ((int )*(expression + (exps + expsc)->pos_adv) == 40) {
#line 88
      goto case_40;
    }
#line 96
    if ((int )*(expression + (exps + expsc)->pos_adv) == 41) {
#line 96
      goto case_41;
    }
#line 112
    if ((int )*(expression + (exps + expsc)->pos_adv) == 34) {
#line 112
      goto case_34;
    }
#line 125
    goto switch_default;
    case_0: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    {
#line 84
    bwb_error(err_incomplete);
#line 85
    loop = 0;
    }
#line 86
    goto switch_break;
    case_40: /* CIL Label */ 
#line 89
    paren_level ++;
#line 90
    (exps + expsc)->string[s_pos] = *(expression + (exps + expsc)->pos_adv);
#line 92
    s_pos ++;
#line 93
    (exps + expsc)->string[s_pos] = (char )'\000';
#line 94
    goto switch_break;
    case_41: /* CIL Label */ 
#line 98
    paren_level --;
#line 99
    if (paren_level == 0) {
#line 101
      loop = 0;
    } else {
#line 105
      (exps + expsc)->string[s_pos] = *(expression + (exps + expsc)->pos_adv);
#line 107
      s_pos ++;
#line 108
      (exps + expsc)->string[s_pos] = (char )'\000';
    }
#line 110
    goto switch_break;
    case_34: /* CIL Label */ 
#line 113
    ((exps + expsc)->pos_adv) ++;
    {
#line 114
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 114
      if ((int )*(expression + (exps + expsc)->pos_adv) != 34) {
#line 114
        if (! ((int )*(expression + (exps + expsc)->pos_adv) != 0)) {
#line 114
          goto while_break___0;
        }
      } else {
#line 114
        goto while_break___0;
      }
#line 117
      (exps + expsc)->string[s_pos] = *(expression + (exps + expsc)->pos_adv);
#line 119
      s_pos ++;
#line 120
      (exps + expsc)->string[s_pos] = (char )'\000';
#line 121
      ((exps + expsc)->pos_adv) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 123
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 126
    (exps + expsc)->string[s_pos] = *(expression + (exps + expsc)->pos_adv);
#line 128
    s_pos ++;
#line 129
    (exps + expsc)->string[s_pos] = (char )'\000';
#line 130
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 135
    ((exps + expsc)->pos_adv) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 147
  (exps + expsc)->rec_pos = 0;
#line 148
  e___0 = bwb_exp((exps + expsc)->string, 0, & (exps + expsc)->rec_pos);
#line 153
  (exps + expsc)->type = e___0->type;
  }
  {
#line 157
  if ((int )e___0->type == 36) {
#line 157
    goto case_36;
  }
#line 161
  goto switch_default___0;
  case_36: /* CIL Label */ 
  {
#line 158
  (exps + expsc)->operation = 2;
#line 159
  tmp = exp_getsval(e___0);
#line 159
  tmp___0 = exp_getsval(exps + expsc);
#line 159
  str_btob(tmp___0, tmp);
  }
#line 160
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 162
  (exps + expsc)->operation = 1;
#line 163
  (exps + expsc)->nval = exp_getnval(e___0);
  }
#line 164
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 167
  return (-1);
}
}
#line 181 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_elx.c"
int exp_strconst(char *expression ) 
{ 
  int e_pos ;
  int s_pos ;

  {
#line 193
  (exps + expsc)->type = (char )'$';
#line 194
  (exps + expsc)->operation = 2;
#line 198
  s_pos = 0;
#line 199
  e_pos = 1;
#line 199
  (exps + expsc)->pos_adv = e_pos;
#line 200
  (exps + expsc)->string[0] = (char )'\000';
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if ((int )*(expression + e_pos) != 34) {
#line 205
      if (! ((int )*(expression + e_pos) != 0)) {
#line 205
        goto while_break;
      }
    } else {
#line 205
      goto while_break;
    }
#line 207
    (exps + expsc)->string[s_pos] = *(expression + e_pos);
#line 208
    e_pos ++;
#line 209
    s_pos ++;
#line 210
    ((exps + expsc)->pos_adv) ++;
#line 211
    (exps + expsc)->string[s_pos] = (char )'\000';
#line 212
    if (s_pos >= 4999) {
      {
#line 215
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"string <%s> exceeds maximum size (%d) for string constant.",
              expression, 5000);
#line 217
      bwb_error(bwb_ebuf);
      }
#line 221
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 227
  str_ctob(& (exps + expsc)->sval, (exps + expsc)->string);
  }
#line 235
  if ((int )*(expression + e_pos) == 34) {
#line 235
    ((exps + expsc)->pos_adv) ++;
  }
#line 239
  return (-1);
}
}
#line 262 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_elx.c"
static struct bwb_variable mantissa  ;
#line 263 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_elx.c"
static int init___42  =    0;
#line 253 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_elx.c"
int exp_numconst(char *expression ) 
{ 
  int base ;
  int exponent ;
  int man_start ;
  int s_pos ;
  int build_loop ;
  int need_pm ;
  int i ;
  bnumber d ;
  bnumber *tmp ;
  bnumber tmp___0 ;
  bnumber tmp___1 ;
  bnumber tmp___2 ;
  double tmp___3 ;

  {
#line 296
  if (init___42 == 0) {
    {
#line 298
    init___42 = -1;
#line 299
    var_make(& mantissa, 1);
    }
  }
#line 306
  *(mantissa.array_pos + 0) = dim_base;
#line 314
  need_pm = 0;
#line 315
  (exps + expsc)->nval = (bnumber )0;
  {
#line 334
  if ((int )*(expression + 0) == 46) {
#line 334
    goto case_46;
  }
#line 334
  if ((int )*(expression + 0) == 57) {
#line 334
    goto case_46;
  }
#line 334
  if ((int )*(expression + 0) == 56) {
#line 334
    goto case_46;
  }
#line 334
  if ((int )*(expression + 0) == 55) {
#line 334
    goto case_46;
  }
#line 334
  if ((int )*(expression + 0) == 54) {
#line 334
    goto case_46;
  }
#line 334
  if ((int )*(expression + 0) == 53) {
#line 334
    goto case_46;
  }
#line 334
  if ((int )*(expression + 0) == 52) {
#line 334
    goto case_46;
  }
#line 334
  if ((int )*(expression + 0) == 51) {
#line 334
    goto case_46;
  }
#line 334
  if ((int )*(expression + 0) == 50) {
#line 334
    goto case_46;
  }
#line 334
  if ((int )*(expression + 0) == 49) {
#line 334
    goto case_46;
  }
#line 334
  if ((int )*(expression + 0) == 48) {
#line 334
    goto case_46;
  }
#line 334
  if ((int )*(expression + 0) == 43) {
#line 334
    goto case_46;
  }
#line 334
  if ((int )*(expression + 0) == 45) {
#line 334
    goto case_46;
  }
#line 339
  if ((int )*(expression + 0) == 38) {
#line 339
    goto case_38;
  }
#line 358
  goto switch_default;
  case_46: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_45: /* CIL Label */ 
#line 335
  base = 10;
#line 336
  man_start = 0;
#line 337
  need_pm = 0;
#line 338
  goto switch_break;
  case_38: /* CIL Label */ 
#line 340
  if ((int )*(expression + 1) == 72) {
#line 342
    base = 16;
#line 343
    man_start = 2;
  } else
#line 340
  if ((int )*(expression + 1) == 104) {
#line 342
    base = 16;
#line 343
    man_start = 2;
  } else {
#line 347
    base = 8;
#line 348
    if ((int )*(expression + 1) == 79) {
#line 350
      man_start = 2;
    } else
#line 348
    if ((int )*(expression + 1) == 111) {
#line 350
      man_start = 2;
    } else {
#line 354
      man_start = 1;
    }
  }
#line 357
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 361
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"expression <%s> is not a numerical constant.",
          expression);
#line 363
  bwb_error(bwb_ebuf);
  }
#line 367
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 375
  if (base == 10) {
#line 375
    goto case_10;
  }
#line 588
  if (base == 8) {
#line 588
    goto case_8;
  }
#line 633
  if (base == 16) {
#line 633
    goto case_16;
  }
#line 372
  goto switch_break___0;
  case_10: /* CIL Label */ 
#line 379
  (exps + expsc)->pos_adv = man_start;
#line 380
  (exps + expsc)->type = (char)1;
#line 381
  (exps + expsc)->string[0] = (char )'\000';
#line 382
  s_pos = 0;
#line 383
  exponent = 0;
#line 384
  build_loop = -1;
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! (build_loop == -1)) {
#line 388
      goto while_break;
    }
    {
#line 393
    if ((int )*(expression + (exps + expsc)->pos_adv) == 43) {
#line 393
      goto case_43___0;
    }
#line 393
    if ((int )*(expression + (exps + expsc)->pos_adv) == 45) {
#line 393
      goto case_43___0;
    }
#line 426
    if ((int )*(expression + (exps + expsc)->pos_adv) == 57) {
#line 426
      goto case_57___0;
    }
#line 426
    if ((int )*(expression + (exps + expsc)->pos_adv) == 56) {
#line 426
      goto case_57___0;
    }
#line 426
    if ((int )*(expression + (exps + expsc)->pos_adv) == 55) {
#line 426
      goto case_57___0;
    }
#line 426
    if ((int )*(expression + (exps + expsc)->pos_adv) == 54) {
#line 426
      goto case_57___0;
    }
#line 426
    if ((int )*(expression + (exps + expsc)->pos_adv) == 53) {
#line 426
      goto case_57___0;
    }
#line 426
    if ((int )*(expression + (exps + expsc)->pos_adv) == 52) {
#line 426
      goto case_57___0;
    }
#line 426
    if ((int )*(expression + (exps + expsc)->pos_adv) == 51) {
#line 426
      goto case_57___0;
    }
#line 426
    if ((int )*(expression + (exps + expsc)->pos_adv) == 50) {
#line 426
      goto case_57___0;
    }
#line 426
    if ((int )*(expression + (exps + expsc)->pos_adv) == 49) {
#line 426
      goto case_57___0;
    }
#line 426
    if ((int )*(expression + (exps + expsc)->pos_adv) == 48) {
#line 426
      goto case_57___0;
    }
#line 426
    if ((int )*(expression + (exps + expsc)->pos_adv) == 46) {
#line 426
      goto case_57___0;
    }
#line 434
    if ((int )*(expression + (exps + expsc)->pos_adv) == 33) {
#line 434
      goto case_33;
    }
#line 434
    if ((int )*(expression + (exps + expsc)->pos_adv) == 35) {
#line 434
      goto case_33;
    }
#line 442
    if ((int )*(expression + (exps + expsc)->pos_adv) == 101) {
#line 442
      goto case_101;
    }
#line 442
    if ((int )*(expression + (exps + expsc)->pos_adv) == 69) {
#line 442
      goto case_101;
    }
#line 450
    if ((int )*(expression + (exps + expsc)->pos_adv) == 100) {
#line 450
      goto case_100;
    }
#line 450
    if ((int )*(expression + (exps + expsc)->pos_adv) == 68) {
#line 450
      goto case_100;
    }
#line 457
    goto switch_default___0;
    case_43___0: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
#line 399
    if ((exps + expsc)->pos_adv == man_start) {
#line 401
      (exps + expsc)->string[s_pos] = *(expression + (exps + expsc)->pos_adv);
#line 402
      ((exps + expsc)->pos_adv) ++;
#line 403
      s_pos ++;
#line 404
      (exps + expsc)->string[s_pos] = (char )'\000';
    } else {
#line 413
      build_loop = 0;
    }
#line 415
    goto switch_break___1;
    case_57___0: /* CIL Label */ 
    case_56___0: /* CIL Label */ 
    case_55___0: /* CIL Label */ 
    case_54___0: /* CIL Label */ 
    case_53___0: /* CIL Label */ 
    case_52___0: /* CIL Label */ 
    case_51___0: /* CIL Label */ 
    case_50___0: /* CIL Label */ 
    case_49___0: /* CIL Label */ 
    case_48___0: /* CIL Label */ 
    case_46___0: /* CIL Label */ 
#line 427
    (exps + expsc)->string[s_pos] = *(expression + (exps + expsc)->pos_adv);
#line 428
    ((exps + expsc)->pos_adv) ++;
#line 429
    s_pos ++;
#line 430
    (exps + expsc)->string[s_pos] = (char )'\000';
#line 431
    goto switch_break___1;
    case_33: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 435
    ((exps + expsc)->pos_adv) ++;
#line 436
    (exps + expsc)->type = (char)1;
#line 437
    exponent = 0;
#line 438
    build_loop = 0;
#line 439
    goto switch_break___1;
    case_101: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 443
    ((exps + expsc)->pos_adv) ++;
#line 444
    (exps + expsc)->type = (char)1;
#line 445
    exponent = -1;
#line 446
    build_loop = 0;
#line 447
    goto switch_break___1;
    case_100: /* CIL Label */ 
    case_68: /* CIL Label */ 
#line 451
    ((exps + expsc)->pos_adv) ++;
#line 452
    (exps + expsc)->type = (char)1;
#line 453
    exponent = -1;
#line 454
    build_loop = 0;
#line 455
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 458
    build_loop = 0;
#line 459
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 467
  tmp = var_findnval(& mantissa, mantissa.array_pos);
#line 467
  sscanf((char const   */* __restrict  */)((exps + expsc)->string), (char const   */* __restrict  */)"%lf",
         tmp);
  }
#line 482
  if ((int )(exps + expsc)->type == 1) {
    {
#line 484
    tmp___0 = var_getnval(& mantissa);
#line 484
    i = (int )tmp___0;
#line 485
    d = (bnumber )i;
#line 486
    tmp___1 = var_getnval(& mantissa);
    }
#line 486
    if (d != tmp___1) {
#line 488
      (exps + expsc)->type = (char)1;
    }
  }
#line 498
  if (exponent == -1) {
#line 503
    need_pm = -1;
#line 507
    (exps + expsc)->string[0] = (char )'\000';
#line 508
    s_pos = 0;
#line 509
    build_loop = -1;
    {
#line 513
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 513
      if (! (build_loop == -1)) {
#line 513
        goto while_break___0;
      }
      {
#line 518
      if ((int )*(expression + (exps + expsc)->pos_adv) == 43) {
#line 518
        goto case_43___1;
      }
#line 518
      if ((int )*(expression + (exps + expsc)->pos_adv) == 45) {
#line 518
        goto case_43___1;
      }
#line 542
      if ((int )*(expression + (exps + expsc)->pos_adv) == 57) {
#line 542
        goto case_57___1;
      }
#line 542
      if ((int )*(expression + (exps + expsc)->pos_adv) == 56) {
#line 542
        goto case_57___1;
      }
#line 542
      if ((int )*(expression + (exps + expsc)->pos_adv) == 55) {
#line 542
        goto case_57___1;
      }
#line 542
      if ((int )*(expression + (exps + expsc)->pos_adv) == 54) {
#line 542
        goto case_57___1;
      }
#line 542
      if ((int )*(expression + (exps + expsc)->pos_adv) == 53) {
#line 542
        goto case_57___1;
      }
#line 542
      if ((int )*(expression + (exps + expsc)->pos_adv) == 52) {
#line 542
        goto case_57___1;
      }
#line 542
      if ((int )*(expression + (exps + expsc)->pos_adv) == 51) {
#line 542
        goto case_57___1;
      }
#line 542
      if ((int )*(expression + (exps + expsc)->pos_adv) == 50) {
#line 542
        goto case_57___1;
      }
#line 542
      if ((int )*(expression + (exps + expsc)->pos_adv) == 49) {
#line 542
        goto case_57___1;
      }
#line 542
      if ((int )*(expression + (exps + expsc)->pos_adv) == 48) {
#line 542
        goto case_57___1;
      }
#line 551
      goto switch_default___1;
      case_43___1: /* CIL Label */ 
      case_45___1: /* CIL Label */ 
#line 520
      if (need_pm == -1) {
#line 522
        (exps + expsc)->string[s_pos] = *(expression + (exps + expsc)->pos_adv);
#line 523
        ((exps + expsc)->pos_adv) ++;
#line 524
        s_pos ++;
#line 525
        (exps + expsc)->string[s_pos] = (char )'\000';
      } else {
#line 529
        build_loop = 0;
      }
#line 531
      goto switch_break___2;
      case_57___1: /* CIL Label */ 
      case_56___1: /* CIL Label */ 
      case_55___1: /* CIL Label */ 
      case_54___1: /* CIL Label */ 
      case_53___1: /* CIL Label */ 
      case_52___1: /* CIL Label */ 
      case_51___1: /* CIL Label */ 
      case_50___1: /* CIL Label */ 
      case_49___1: /* CIL Label */ 
      case_48___1: /* CIL Label */ 
#line 544
      (exps + expsc)->string[s_pos] = *(expression + (exps + expsc)->pos_adv);
#line 545
      ((exps + expsc)->pos_adv) ++;
#line 546
      s_pos ++;
#line 547
      (exps + expsc)->string[s_pos] = (char )'\000';
#line 548
      need_pm = 0;
#line 549
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
#line 552
      build_loop = 0;
#line 553
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 561
    sscanf((char const   */* __restrict  */)((exps + expsc)->string), (char const   */* __restrict  */)"%lf",
           & (exps + expsc)->nval);
    }
  }
#line 576
  if ((exps + expsc)->nval == (bnumber )0) {
    {
#line 578
    (exps + expsc)->nval = var_getnval(& mantissa);
    }
  } else {
    {
#line 582
    tmp___2 = var_getnval(& mantissa);
#line 582
    tmp___3 = pow(10.0, (exps + expsc)->nval);
#line 582
    (exps + expsc)->nval = tmp___2 * tmp___3;
    }
  }
#line 586
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 592
  (exps + expsc)->pos_adv = man_start;
#line 593
  (exps + expsc)->type = (char)1;
#line 594
  (exps + expsc)->string[0] = (char )'\000';
#line 595
  s_pos = 0;
#line 596
  exponent = 0;
#line 597
  build_loop = -1;
  {
#line 601
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 601
    if (! (build_loop == -1)) {
#line 601
      goto while_break___1;
    }
    {
#line 612
    if ((int )*(expression + (exps + expsc)->pos_adv) == 55) {
#line 612
      goto case_55___2;
    }
#line 612
    if ((int )*(expression + (exps + expsc)->pos_adv) == 54) {
#line 612
      goto case_55___2;
    }
#line 612
    if ((int )*(expression + (exps + expsc)->pos_adv) == 53) {
#line 612
      goto case_55___2;
    }
#line 612
    if ((int )*(expression + (exps + expsc)->pos_adv) == 52) {
#line 612
      goto case_55___2;
    }
#line 612
    if ((int )*(expression + (exps + expsc)->pos_adv) == 51) {
#line 612
      goto case_55___2;
    }
#line 612
    if ((int )*(expression + (exps + expsc)->pos_adv) == 50) {
#line 612
      goto case_55___2;
    }
#line 612
    if ((int )*(expression + (exps + expsc)->pos_adv) == 49) {
#line 612
      goto case_55___2;
    }
#line 612
    if ((int )*(expression + (exps + expsc)->pos_adv) == 48) {
#line 612
      goto case_55___2;
    }
#line 619
    goto switch_default___2;
    case_55___2: /* CIL Label */ 
    case_54___2: /* CIL Label */ 
    case_53___2: /* CIL Label */ 
    case_52___2: /* CIL Label */ 
    case_51___2: /* CIL Label */ 
    case_50___2: /* CIL Label */ 
    case_49___2: /* CIL Label */ 
    case_48___2: /* CIL Label */ 
#line 613
    (exps + expsc)->string[s_pos] = *(expression + (exps + expsc)->pos_adv);
#line 614
    ((exps + expsc)->pos_adv) ++;
#line 615
    s_pos ++;
#line 616
    (exps + expsc)->string[s_pos] = (char )'\000';
#line 617
    goto switch_break___3;
    switch_default___2: /* CIL Label */ 
#line 620
    build_loop = 0;
#line 621
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 628
  sscanf((char const   */* __restrict  */)((exps + expsc)->string), (char const   */* __restrict  */)"%o",
         & i);
#line 629
  (exps + expsc)->nval = (bnumber )i;
  }
#line 631
  goto switch_break___0;
  case_16: /* CIL Label */ 
#line 637
  (exps + expsc)->pos_adv = man_start;
#line 638
  (exps + expsc)->type = (char)1;
#line 639
  (exps + expsc)->string[0] = (char )'\000';
#line 640
  s_pos = 0;
#line 641
  exponent = 0;
#line 642
  build_loop = -1;
  {
#line 646
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 646
    if (! (build_loop == -1)) {
#line 646
      goto while_break___2;
    }
    {
#line 671
    if ((int )*(expression + (exps + expsc)->pos_adv) == 102) {
#line 671
      goto case_102;
    }
#line 671
    if ((int )*(expression + (exps + expsc)->pos_adv) == 70) {
#line 671
      goto case_102;
    }
#line 671
    if ((int )*(expression + (exps + expsc)->pos_adv) == 101) {
#line 671
      goto case_102;
    }
#line 671
    if ((int )*(expression + (exps + expsc)->pos_adv) == 69) {
#line 671
      goto case_102;
    }
#line 671
    if ((int )*(expression + (exps + expsc)->pos_adv) == 100) {
#line 671
      goto case_102;
    }
#line 671
    if ((int )*(expression + (exps + expsc)->pos_adv) == 68) {
#line 671
      goto case_102;
    }
#line 671
    if ((int )*(expression + (exps + expsc)->pos_adv) == 99) {
#line 671
      goto case_102;
    }
#line 671
    if ((int )*(expression + (exps + expsc)->pos_adv) == 67) {
#line 671
      goto case_102;
    }
#line 671
    if ((int )*(expression + (exps + expsc)->pos_adv) == 98) {
#line 671
      goto case_102;
    }
#line 671
    if ((int )*(expression + (exps + expsc)->pos_adv) == 66) {
#line 671
      goto case_102;
    }
#line 671
    if ((int )*(expression + (exps + expsc)->pos_adv) == 97) {
#line 671
      goto case_102;
    }
#line 671
    if ((int )*(expression + (exps + expsc)->pos_adv) == 65) {
#line 671
      goto case_102;
    }
#line 671
    if ((int )*(expression + (exps + expsc)->pos_adv) == 57) {
#line 671
      goto case_102;
    }
#line 671
    if ((int )*(expression + (exps + expsc)->pos_adv) == 56) {
#line 671
      goto case_102;
    }
#line 671
    if ((int )*(expression + (exps + expsc)->pos_adv) == 55) {
#line 671
      goto case_102;
    }
#line 671
    if ((int )*(expression + (exps + expsc)->pos_adv) == 54) {
#line 671
      goto case_102;
    }
#line 671
    if ((int )*(expression + (exps + expsc)->pos_adv) == 53) {
#line 671
      goto case_102;
    }
#line 671
    if ((int )*(expression + (exps + expsc)->pos_adv) == 52) {
#line 671
      goto case_102;
    }
#line 671
    if ((int )*(expression + (exps + expsc)->pos_adv) == 51) {
#line 671
      goto case_102;
    }
#line 671
    if ((int )*(expression + (exps + expsc)->pos_adv) == 50) {
#line 671
      goto case_102;
    }
#line 671
    if ((int )*(expression + (exps + expsc)->pos_adv) == 49) {
#line 671
      goto case_102;
    }
#line 671
    if ((int )*(expression + (exps + expsc)->pos_adv) == 48) {
#line 671
      goto case_102;
    }
#line 679
    goto switch_default___3;
    case_102: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_101___0: /* CIL Label */ 
    case_69___0: /* CIL Label */ 
    case_100___0: /* CIL Label */ 
    case_68___0: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_57___2: /* CIL Label */ 
    case_56___2: /* CIL Label */ 
    case_55___3: /* CIL Label */ 
    case_54___3: /* CIL Label */ 
    case_53___3: /* CIL Label */ 
    case_52___3: /* CIL Label */ 
    case_51___3: /* CIL Label */ 
    case_50___3: /* CIL Label */ 
    case_49___3: /* CIL Label */ 
    case_48___3: /* CIL Label */ 
#line 672
    (exps + expsc)->string[s_pos] = *(expression + (exps + expsc)->pos_adv);
#line 674
    ((exps + expsc)->pos_adv) ++;
#line 675
    s_pos ++;
#line 676
    (exps + expsc)->string[s_pos] = (char )'\000';
#line 677
    goto switch_break___4;
    switch_default___3: /* CIL Label */ 
#line 680
    build_loop = 0;
#line 681
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 688
  sscanf((char const   */* __restrict  */)((exps + expsc)->string), (char const   */* __restrict  */)"%x",
         & i);
#line 689
  (exps + expsc)->nval = (bnumber )i;
  }
#line 690
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 695
  (exps + expsc)->operation = 1;
#line 707
  return (-1);
}
}
#line 722 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_elx.c"
int exp_function(char *expression ) 
{ 
  struct exp_ese *e___0 ;
  int s_pos ;
  int loop ;
  int paren_level ;
  int n_args ;
  struct bwb_variable *v___0 ;
  struct bwb_variable *argv ;
  bstring *b___4 ;
  register int i ;
  register int j ;
  void *tmp ;
  size_t tmp___0 ;
  bnumber *tmp___1 ;
  bstring *tmp___2 ;
  bstring *tmp___3 ;
  int tmp___4 ;
  bnumber *tmp___5 ;
  bstring *tmp___6 ;
  bstring *tmp___7 ;
  int tmp___8 ;
  bstring *tmp___9 ;

  {
  {
#line 753
  tmp = CALLOC((size_t )6, sizeof(struct bwb_variable ), (char *)"exp_function");
#line 753
  argv = (struct bwb_variable *)tmp;
  }
#line 753
  if ((unsigned long )argv == (unsigned long )((void *)0)) {
    {
#line 756
    bwb_error(err_getmem);
    }
#line 757
    return (-255);
  }
  {
#line 764
  exp_getvfname(expression, (exps + expsc)->string);
#line 774
  (exps + expsc)->function = fnc_find((exps + expsc)->string);
  }
#line 778
  if ((unsigned long )(exps + expsc)->function == (unsigned long )((void *)0)) {
    {
#line 781
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Failed to find function <%s>.",
            (exps + expsc)->string);
#line 783
    bwb_error(bwb_ebuf);
    }
#line 787
    return (-255);
  }
  {
#line 792
  (exps + expsc)->operation = 4;
#line 793
  tmp___0 = strlen((char const   *)((exps + expsc)->string));
#line 793
  (exps + expsc)->pos_adv = (int )tmp___0;
#line 797
  loop = -1;
  }
  {
#line 798
  while (1) {
    while_continue: /* CIL Label */ ;
#line 798
    if (! (loop == -1)) {
#line 798
      goto while_break;
    }
    {
#line 804
    if ((int )*(expression + (exps + expsc)->pos_adv) == 9) {
#line 804
      goto case_9;
    }
#line 804
    if ((int )*(expression + (exps + expsc)->pos_adv) == 32) {
#line 804
      goto case_9;
    }
#line 808
    if ((int )*(expression + (exps + expsc)->pos_adv) == 40) {
#line 808
      goto case_40;
    }
#line 820
    goto switch_default;
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 805
    ((exps + expsc)->pos_adv) ++;
#line 806
    goto switch_break;
    case_40: /* CIL Label */ 
#line 815
    ((exps + expsc)->pos_adv) ++;
#line 816
    paren_level = 1;
#line 817
    loop = 0;
#line 818
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 821
    loop = 0;
#line 822
    paren_level = 0;
#line 823
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 830
  n_args = 0;
#line 831
  s_pos = 0;
#line 832
  (exps + expsc)->string[0] = (char )'\000';
  {
#line 834
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 834
    if (! (paren_level > 0)) {
#line 834
      goto while_break___0;
    }
    {
#line 842
    if ((int )*(expression + (exps + expsc)->pos_adv) == 44) {
#line 842
      goto case_44;
    }
#line 894
    if ((int )*(expression + (exps + expsc)->pos_adv) == 40) {
#line 894
      goto case_40___0;
    }
#line 902
    if ((int )*(expression + (exps + expsc)->pos_adv) == 41) {
#line 902
      goto case_41;
    }
#line 974
    if ((int )*(expression + (exps + expsc)->pos_adv) == 34) {
#line 974
      goto case_34;
    }
#line 1008
    goto switch_default___0;
    case_44: /* CIL Label */ 
#line 844
    if (paren_level == 1) {
      {
#line 849
      tmp___4 = exp_validarg((exps + expsc)->string);
      }
#line 849
      if (tmp___4 == -1) {
        {
#line 857
        (exps + expsc)->rec_pos = 0;
#line 858
        e___0 = bwb_exp((exps + expsc)->string, 0, & (exps + expsc)->rec_pos);
#line 863
        var_make(argv + n_args, (int )e___0->type);
        }
        {
#line 867
        if ((argv + n_args)->type == 1) {
#line 867
          goto case_1;
        }
#line 871
        if ((argv + n_args)->type == 36) {
#line 871
          goto case_36;
        }
#line 865
        goto switch_break___1;
        case_1: /* CIL Label */ 
        {
#line 868
        tmp___1 = var_findnval(argv + n_args, (argv + n_args)->array_pos);
#line 868
        *tmp___1 = exp_getnval(e___0);
        }
#line 870
        goto switch_break___1;
        case_36: /* CIL Label */ 
        {
#line 872
        tmp___2 = exp_getsval(e___0);
#line 872
        tmp___3 = var_findsval(argv + n_args, (argv + n_args)->array_pos);
#line 872
        str_btob(tmp___3, tmp___2);
        }
#line 874
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
#line 877
        n_args ++;
      }
#line 881
      s_pos = 0;
#line 882
      (exps + expsc)->string[0] = (char )'\000';
    } else {
#line 887
      (exps + expsc)->string[s_pos] = *(expression + (exps + expsc)->pos_adv);
#line 889
      s_pos ++;
#line 890
      (exps + expsc)->string[s_pos] = (char )'\000';
    }
#line 892
    goto switch_break___0;
    case_40___0: /* CIL Label */ 
#line 895
    paren_level ++;
#line 896
    (exps + expsc)->string[s_pos] = *(expression + (exps + expsc)->pos_adv);
#line 898
    s_pos ++;
#line 899
    (exps + expsc)->string[s_pos] = (char )'\000';
#line 900
    goto switch_break___0;
    case_41: /* CIL Label */ 
#line 903
    paren_level --;
#line 911
    if (paren_level == 0) {
      {
#line 922
      tmp___8 = exp_validarg((exps + expsc)->string);
      }
#line 922
      if (tmp___8 == -1) {
        {
#line 930
        (exps + expsc)->rec_pos = 0;
#line 931
        e___0 = bwb_exp((exps + expsc)->string, 0, & (exps + expsc)->rec_pos);
#line 943
        var_make(argv + n_args, (int )e___0->type);
        }
        {
#line 947
        if ((argv + n_args)->type == 1) {
#line 947
          goto case_1___0;
        }
#line 951
        if ((argv + n_args)->type == 36) {
#line 951
          goto case_36___0;
        }
#line 945
        goto switch_break___2;
        case_1___0: /* CIL Label */ 
        {
#line 948
        tmp___5 = var_findnval(argv + n_args, (argv + n_args)->array_pos);
#line 948
        *tmp___5 = exp_getnval(e___0);
        }
#line 950
        goto switch_break___2;
        case_36___0: /* CIL Label */ 
        {
#line 952
        tmp___6 = exp_getsval(e___0);
#line 952
        tmp___7 = var_findsval(argv + n_args, (argv + n_args)->array_pos);
#line 952
        str_btob(tmp___7, tmp___6);
        }
#line 954
        goto switch_break___2;
        switch_break___2: /* CIL Label */ ;
        }
#line 957
        n_args ++;
      }
#line 961
      s_pos = 0;
#line 962
      (exps + expsc)->string[0] = (char )'\000';
    } else {
#line 967
      (exps + expsc)->string[s_pos] = *(expression + (exps + expsc)->pos_adv);
#line 969
      s_pos ++;
#line 970
      (exps + expsc)->string[s_pos] = (char )'\000';
    }
#line 972
    goto switch_break___0;
    case_34: /* CIL Label */ 
#line 978
    (exps + expsc)->string[s_pos] = *(expression + (exps + expsc)->pos_adv);
#line 980
    s_pos ++;
#line 981
    (exps + expsc)->string[s_pos] = (char )'\000';
#line 982
    ((exps + expsc)->pos_adv) ++;
    {
#line 986
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 986
      if ((int )*(expression + (exps + expsc)->pos_adv) != 34) {
#line 986
        if (! ((int )*(expression + (exps + expsc)->pos_adv) != 0)) {
#line 986
          goto while_break___1;
        }
      } else {
#line 986
        goto while_break___1;
      }
#line 989
      (exps + expsc)->string[s_pos] = *(expression + (exps + expsc)->pos_adv);
#line 991
      s_pos ++;
#line 992
      (exps + expsc)->string[s_pos] = (char )'\000';
#line 993
      ((exps + expsc)->pos_adv) ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 998
    (exps + expsc)->string[s_pos] = *(expression + (exps + expsc)->pos_adv);
#line 1000
    s_pos ++;
#line 1001
    (exps + expsc)->string[s_pos] = (char )'\000';
#line 1006
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 1009
    (exps + expsc)->string[s_pos] = *(expression + (exps + expsc)->pos_adv);
#line 1011
    s_pos ++;
#line 1012
    (exps + expsc)->string[s_pos] = (char )'\000';
#line 1022
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1027
    ((exps + expsc)->pos_adv) ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1043
  v___0 = (*(((exps + expsc)->function)->vector))(n_args, argv + 0, ((exps + expsc)->function)->id);
#line 1053
  i = 0;
  }
  {
#line 1053
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1053
    if (! (i < n_args)) {
#line 1053
      goto while_break___2;
    }
#line 1055
    if ((unsigned long )(argv + i)->memnum != (unsigned long )((void *)0)) {
      {
#line 1058
      FREE((void *)(argv + i)->memnum, (char *)"exp_function");
#line 1059
      (argv + i)->memnum = (bnumber *)((void *)0);
      }
    }
#line 1061
    if ((unsigned long )(argv + i)->memstr != (unsigned long )((void *)0)) {
#line 1064
      j = 0;
      {
#line 1064
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1064
        if (! (j < (int )(argv + i)->array_units)) {
#line 1064
          goto while_break___3;
        }
#line 1066
        if ((unsigned long )((argv + i)->memstr + j)->sbuffer != (unsigned long )((void *)0)) {
          {
#line 1069
          FREE((void *)((argv + i)->memstr + j)->sbuffer, (char *)"exp_function");
#line 1070
          ((argv + i)->memstr + j)->sbuffer = (char *)((void *)0);
          }
        }
#line 1072
        ((argv + i)->memstr + j)->rab = 0;
#line 1073
        ((argv + i)->memstr + j)->length = 0U;
#line 1064
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1076
      FREE((void *)(argv + i)->memstr, (char *)"exp_function");
#line 1077
      (argv + i)->memstr = (bstring *)((void *)0);
      }
    }
#line 1080
    if ((unsigned long )(argv + i)->array_sizes != (unsigned long )((void *)0)) {
      {
#line 1082
      FREE((void *)(argv + i)->array_sizes, (char *)"exp_function");
#line 1083
      (argv + i)->array_sizes = (int *)((void *)0);
      }
    }
#line 1085
    if ((unsigned long )(argv + i)->array_pos != (unsigned long )((void *)0)) {
      {
#line 1087
      FREE((void *)(argv + i)->array_pos, (char *)"exp_function");
#line 1088
      (argv + i)->array_pos = (int *)((void *)0);
      }
    }
#line 1053
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1092
  FREE((void *)argv, (char *)"exp_function");
#line 1102
  (exps + expsc)->type = (char )v___0->type;
  }
  {
#line 1106
  if (v___0->type == 36) {
#line 1106
    goto case_36___1;
  }
#line 1125
  goto switch_default___1;
  case_36___1: /* CIL Label */ 
  {
#line 1107
  (exps + expsc)->operation = 2;
#line 1114
  b___4 = var_findsval(v___0, v___0->array_pos);
#line 1115
  tmp___9 = exp_getsval(exps + expsc);
#line 1115
  str_btob(tmp___9, b___4);
  }
#line 1123
  goto switch_break___3;
  switch_default___1: /* CIL Label */ 
  {
#line 1126
  (exps + expsc)->operation = 1;
#line 1127
  (exps + expsc)->nval = var_getnval(v___0);
  }
#line 1128
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 1138
  return (-1);
}
}
#line 1151 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_elx.c"
int exp_variable(char *expression ) 
{ 
  int pos___2 ;
  int *pp___0 ;
  int n_params___0 ;
  register int n___0 ;
  struct bwb_variable *v___0 ;
  bstring *b___4 ;
  int p___0 ;
  struct bwb_variable *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1174
  exp_getvfname(expression, (exps + expsc)->string);
#line 1178
  tmp = var_find((exps + expsc)->string);
#line 1178
  (exps + expsc)->xvar = tmp;
#line 1178
  v___0 = tmp;
#line 1188
  (exps + expsc)->operation = 5;
#line 1192
  tmp___0 = strlen((char const   *)((exps + expsc)->string));
#line 1192
  pos___2 = (int )tmp___0;
  }
#line 1193
  if (v___0->dimensions == 1) {
#line 1193
    if (*(v___0->array_sizes + 0) == 1) {
      {
#line 1200
      tmp___1 = strlen((char const   *)(v___0->name));
#line 1200
      pos___2 = (int )tmp___1;
#line 1201
      n_params___0 = 1;
#line 1202
      pp___0 = & p___0;
#line 1203
      *(pp___0 + 0) = dim_base;
      }
    } else {
      {
#line 1212
      dim_getparams(expression, & pos___2, & n_params___0, & pp___0);
      }
    }
  } else {
    {
#line 1212
    dim_getparams(expression, & pos___2, & n_params___0, & pp___0);
    }
  }
#line 1215
  (exps + expsc)->pos_adv = pos___2;
#line 1216
  n___0 = 0;
  {
#line 1216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1216
    if (! (n___0 < v___0->dimensions)) {
#line 1216
      goto while_break;
    }
#line 1218
    tmp___2 = *(pp___0 + n___0);
#line 1218
    *(v___0->array_pos + n___0) = tmp___2;
#line 1218
    (exps + expsc)->array_pos[n___0] = tmp___2;
#line 1216
    n___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1232
  (exps + expsc)->type = (char )v___0->type;
  {
#line 1236
  if (v___0->type == 36) {
#line 1236
    goto case_36;
  }
#line 1249
  goto switch_default;
  case_36: /* CIL Label */ 
  {
#line 1237
  b___4 = var_findsval(v___0, v___0->array_pos);
#line 1247
  str_btob(& (exps + expsc)->sval, b___4);
  }
#line 1248
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1250
  (exps + expsc)->nval = var_getnval(v___0);
  }
#line 1251
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1262
  return (-1);
}
}
#line 851 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct bwb_line *bwb_null(struct bwb_line *l ) ;
#line 852
struct bwb_line *bwb_rem(struct bwb_line *l ) ;
#line 855
struct bwb_line *bwb_let(struct bwb_line *l ) ;
#line 856
struct bwb_line *bwb_load(struct bwb_line *l ) ;
#line 857
struct bwb_line *bwb_merge(struct bwb_line *l ) ;
#line 858
struct bwb_line *bwb_chain(struct bwb_line *l ) ;
#line 862
struct bwb_line *bwb_save(struct bwb_line *l ) ;
#line 863
struct bwb_line *bwb_list(struct bwb_line *l ) ;
#line 865
struct bwb_line *bwb_go(struct bwb_line *l ) ;
#line 866
struct bwb_line *bwb_goto(struct bwb_line *l ) ;
#line 867
struct bwb_line *bwb_gosub(struct bwb_line *l ) ;
#line 868
struct bwb_line *bwb_return(struct bwb_line *l ) ;
#line 870
struct bwb_line *bwb_system(struct bwb_line *l ) ;
#line 871
struct bwb_line *bwb_tron(struct bwb_line *l ) ;
#line 872
struct bwb_line *bwb_troff(struct bwb_line *l ) ;
#line 873
struct bwb_line *bwb_randomize(struct bwb_line *l ) ;
#line 874
struct bwb_line *bwb_stop(struct bwb_line *l ) ;
#line 875
struct bwb_line *bwb_data(struct bwb_line *l ) ;
#line 876
struct bwb_line *bwb_read(struct bwb_line *l ) ;
#line 877
struct bwb_line *bwb_restore(struct bwb_line *l ) ;
#line 878
struct bwb_line *bwb_delete(struct bwb_line *l ) ;
#line 892
struct bwb_line *bwb_open(struct bwb_line *l ) ;
#line 893
struct bwb_line *bwb_close(struct bwb_line *l ) ;
#line 894
struct bwb_line *bwb_get(struct bwb_line *l ) ;
#line 895
struct bwb_line *bwb_put(struct bwb_line *l ) ;
#line 896
struct bwb_line *bwb_rmdir(struct bwb_line *l ) ;
#line 897
struct bwb_line *bwb_chdir(struct bwb_line *l ) ;
#line 898
struct bwb_line *bwb_mkdir(struct bwb_line *l ) ;
#line 899
struct bwb_line *bwb_kill(struct bwb_line *l ) ;
#line 900
struct bwb_line *bwb_name(struct bwb_line *l ) ;
#line 901
struct bwb_line *bwb_rset(struct bwb_line *l ) ;
#line 902
struct bwb_line *bwb_lset(struct bwb_line *l ) ;
#line 903
struct bwb_line *bwb_field(struct bwb_line *l ) ;
#line 904
struct bwb_line *bwb_on(struct bwb_line *l ) ;
#line 905
struct bwb_line *bwb_line(struct bwb_line *l ) ;
#line 914
struct bwb_line *bwb_environ(struct bwb_line *l ) ;
#line 926
struct bwb_line *bwb_exit(struct bwb_line *l ) ;
#line 951
struct bwb_line *bwb_def(struct bwb_line *l ) ;
#line 970
struct bwb_line *bwb_input(struct bwb_line *l ) ;
#line 1036
struct bwb_line *bwb_call(struct bwb_line *l ) ;
#line 1037
struct bwb_line *bwb_sub(struct bwb_line *l ) ;
#line 1040
struct bwb_line *bwb_function(struct bwb_line *l ) ;
#line 462 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_mes.h"
char err_noln[15] ;
#line 463
char err_nofn[13] ;
#line 464
char err_lnnotfound[25] ;
#line 466
char err_valoorange[22] ;
#line 469
char err_dev[13] ;
#line 470
char err_opsys[34] ;
#line 471
char err_argstr[26] ;
#line 475
char err_retnogosub[21] ;
#line 476
char err_od[12] ;
#line 477
char err_overflow[9] ;
#line 478
char err_nf[17] ;
#line 479
char err_uf[19] ;
#line 480
char err_dbz[15] ;
#line 481
char err_redim[33] ;
#line 482
char err_obdim[40] ;
#line 483
char err_uc[16] ;
#line 484
char err_noprogfile[27] ;
#line 37 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
int err_line  =    0;
#line 38 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
int err_number  =    0;
#line 46 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
struct bwb_command bwb_cmdtable[76]  = 
#line 46
  {      {{(char )'C', (char )'H', (char )'D', (char )'I', (char )'R', (char )'\000'},
      & bwb_chdir}, 
        {{(char )'M', (char )'K', (char )'D', (char )'I', (char )'R', (char )'\000'},
      & bwb_mkdir}, 
        {{(char )'R', (char )'M', (char )'D', (char )'I', (char )'R', (char )'\000'},
      & bwb_rmdir}, 
        {{(char )'K', (char )'I', (char )'L', (char )'L', (char )'\000'}, & bwb_kill}, 
        {{(char )'E',
       (char )'N', (char )'V', (char )'I', (char )'R', (char )'O', (char )'N', (char )'\000'},
      & bwb_environ}, 
        {{(char )'L', (char )'I', (char )'S', (char )'T', (char )'\000'}, & bwb_list}, 
        {{(char )'L',
       (char )'O', (char )'A', (char )'D', (char )'\000'}, & bwb_load}, 
        {{(char )'R', (char )'U', (char )'N', (char )'\000'}, & bwb_run}, 
        {{(char )'S', (char )'A', (char )'V', (char )'E', (char )'\000'}, & bwb_save}, 
        {{(char )'D',
       (char )'E', (char )'L', (char )'E', (char )'T', (char )'E', (char )'\000'},
      & bwb_delete}, 
        {{(char )'N', (char )'E', (char )'W', (char )'\000'}, & bwb_new}, 
        {{(char )'Q', (char )'U', (char )'I', (char )'T', (char )'\000'}, & bwb_system}, 
        {{(char )'S',
       (char )'Y', (char )'S', (char )'T', (char )'E', (char )'M', (char )'\000'},
      & bwb_system}, 
        {{(char )'D', (char )'E', (char )'F', (char )'D', (char )'B', (char )'L', (char )'\000'},
      & bwb_ddbl}, 
        {{(char )'D', (char )'E', (char )'F', (char )'I', (char )'N', (char )'T', (char )'\000'},
      & bwb_dint}, 
        {{(char )'D', (char )'E', (char )'F', (char )'S', (char )'N', (char )'G', (char )'\000'},
      & bwb_dsng}, 
        {{(char )'D', (char )'E', (char )'F', (char )'S', (char )'T', (char )'R', (char )'\000'},
      & bwb_dstr}, 
        {{(char )'M', (char )'I', (char )'D', (char )'$', (char )'\000'}, & bwb_mid}, 
        {{(char )'C',
       (char )'A', (char )'L', (char )'L', (char )'\000'}, & bwb_call}, 
        {{(char )'S', (char )'U', (char )'B', (char )'\000'}, & bwb_sub}, 
        {{(char )'F', (char )'U', (char )'N', (char )'C', (char )'T', (char )'I', (char )'O',
       (char )'N', (char )'\000'}, & bwb_function}, 
        {{(char )'l', (char )'A', (char )'b', (char )'E', (char )'l', (char )'\000'},
      & bwb_null}, 
        {{(char )'E', (char )'L', (char )'S', (char )'E', (char )'\000'}, & bwb_else}, 
        {{(char )'E',
       (char )'L', (char )'S', (char )'E', (char )'I', (char )'F', (char )'\000'},
      & bwb_elseif}, 
        {{(char )'S', (char )'E', (char )'L', (char )'E', (char )'C', (char )'T', (char )'\000'},
      & bwb_select}, 
        {{(char )'C', (char )'A', (char )'S', (char )'E', (char )'\000'}, & bwb_case}, 
        {{(char )'L',
       (char )'O', (char )'O', (char )'P', (char )'\000'}, & bwb_loop}, 
        {{(char )'E', (char )'X', (char )'I', (char )'T', (char )'\000'}, & bwb_exit}, 
        {{(char )'M',
       (char )'E', (char )'R', (char )'G', (char )'E', (char )'\000'}, & bwb_merge}, 
        {{(char )'C',
       (char )'H', (char )'A', (char )'I', (char )'N', (char )'\000'}, & bwb_chain}, 
        {{(char )'C',
       (char )'O', (char )'M', (char )'M', (char )'O', (char )'N', (char )'\000'},
      & bwb_common}, 
        {{(char )'E', (char )'R', (char )'R', (char )'O', (char )'R', (char )'\000'},
      & bwb_lerror}, 
        {{(char )'W', (char )'I', (char )'D', (char )'T', (char )'H', (char )'\000'},
      & bwb_width}, 
        {{(char )'T', (char )'R', (char )'O', (char )'N', (char )'\000'}, & bwb_tron}, 
        {{(char )'T',
       (char )'R', (char )'O', (char )'F', (char )'F', (char )'\000'}, & bwb_troff}, 
        {{(char )'F',
       (char )'I', (char )'L', (char )'E', (char )'S', (char )'\000'}, & bwb_files}, 
        {{(char )'E',
       (char )'D', (char )'I', (char )'T', (char )'\000'}, & bwb_edit}, 
        {{(char )'E', (char )'R', (char )'A', (char )'S', (char )'E', (char )'\000'},
      & bwb_erase}, 
        {{(char )'S', (char )'W', (char )'A', (char )'P', (char )'\000'}, & bwb_swap}, 
        {{(char )'N',
       (char )'A', (char )'M', (char )'E', (char )'\000'}, & bwb_name}, 
        {{(char )'C', (char )'L', (char )'E', (char )'A', (char )'R', (char )'\000'},
      & bwb_clear}, 
        {{(char )'W', (char )'H', (char )'I', (char )'L', (char )'E', (char )'\000'},
      & bwb_while}, 
        {{(char )'W', (char )'E', (char )'N', (char )'D', (char )'\000'}, & bwb_wend}, 
        {{(char )'W',
       (char )'R', (char )'I', (char )'T', (char )'E', (char )'\000'}, & bwb_write}, 
        {{(char )'O',
       (char )'P', (char )'E', (char )'N', (char )'\000'}, & bwb_open}, 
        {{(char )'C', (char )'L', (char )'O', (char )'S', (char )'E', (char )'\000'},
      & bwb_close}, 
        {{(char )'G', (char )'E', (char )'T', (char )'\000'}, & bwb_get}, 
        {{(char )'P', (char )'U', (char )'T', (char )'\000'}, & bwb_put}, 
        {{(char )'L', (char )'S', (char )'E', (char )'T', (char )'\000'}, & bwb_lset}, 
        {{(char )'R',
       (char )'S', (char )'E', (char )'T', (char )'\000'}, & bwb_rset}, 
        {{(char )'F', (char )'I', (char )'E', (char )'L', (char )'D', (char )'\000'},
      & bwb_field}, 
        {{(char )'L', (char )'I', (char )'N', (char )'E', (char )'\000'}, & bwb_line}, 
        {{(char )'R',
       (char )'E', (char )'N', (char )'U', (char )'M', (char )'\000'}, & bwb_renum}, 
        {{(char )'D',
       (char )'A', (char )'T', (char )'A', (char )'\000'}, & bwb_data}, 
        {{(char )'D', (char )'E', (char )'F', (char )'\000'}, & bwb_def}, 
        {{(char )'D', (char )'I', (char )'M', (char )'\000'}, & bwb_dim}, 
        {{(char )'E', (char )'N', (char )'D', (char )'\000'}, & bwb_xend}, 
        {{(char )'F', (char )'O', (char )'R', (char )'\000'}, & bwb_for}, 
        {{(char )'D', (char )'O', (char )'\000'}, & bwb_do}, 
        {{(char )'G', (char )'O', (char )'\000'}, & bwb_go}, 
        {{(char )'G', (char )'O', (char )'S', (char )'U', (char )'B', (char )'\000'},
      & bwb_gosub}, 
        {{(char )'G', (char )'O', (char )'T', (char )'O', (char )'\000'}, & bwb_goto}, 
        {{(char )'I',
       (char )'F', (char )'\000'}, & bwb_if}, 
        {{(char )'I', (char )'N', (char )'P', (char )'U', (char )'T', (char )'\000'},
      & bwb_input}, 
        {{(char )'L', (char )'E', (char )'T', (char )'\000'}, & bwb_let}, 
        {{(char )'N', (char )'E', (char )'X', (char )'T', (char )'\000'}, & bwb_next}, 
        {{(char )'O',
       (char )'N', (char )'\000'}, & bwb_on}, 
        {{(char )'O', (char )'P', (char )'T', (char )'I', (char )'O', (char )'N', (char )'\000'},
      & bwb_option}, 
        {{(char )'P', (char )'R', (char )'I', (char )'N', (char )'T', (char )'\000'},
      & bwb_print}, 
        {{(char )'?', (char )'\000'}, & bwb_print}, 
        {{(char )'R', (char )'A', (char )'N', (char )'D', (char )'O', (char )'M', (char )'I',
       (char )'Z', (char )'E', (char )'\000'}, & bwb_randomize}, 
        {{(char )'R', (char )'E', (char )'A', (char )'D', (char )'\000'}, & bwb_read}, 
        {{(char )'R',
       (char )'E', (char )'M', (char )'\000'}, & bwb_rem}, 
        {{(char )'R', (char )'E', (char )'S', (char )'T', (char )'O', (char )'R', (char )'E',
       (char )'\000'}, & bwb_restore}, 
        {{(char )'R', (char )'E', (char )'T', (char )'U', (char )'R', (char )'N', (char )'\000'},
      & bwb_return}, 
        {{(char )'S', (char )'T', (char )'O', (char )'P', (char )'\000'}, & bwb_stop}};
#line 165 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
struct bwb_function bwb_prefuncs[45]  = 
#line 165
  {      {{(char )'A', (char )'S', (char )'C', (char )'\000'}, 1, 1, & fnc_asc, (struct bwb_function *)((void *)0),
      0}, 
        {{(char )'M', (char )'K', (char )'D', (char )'$', (char )'\000'}, '$', 1, & fnc_mkd,
      (struct bwb_function *)((void *)0), 0}, 
        {{(char )'M', (char )'K', (char )'I', (char )'$', (char )'\000'}, '$', 1, & fnc_mki,
      (struct bwb_function *)((void *)0), 0}, 
        {{(char )'M', (char )'K', (char )'S', (char )'$', (char )'\000'}, '$', 1, & fnc_mks,
      (struct bwb_function *)((void *)0), 0}, 
        {{(char )'C', (char )'V', (char )'D', (char )'\000'}, 1, 1, & fnc_cvd, (struct bwb_function *)((void *)0),
      0}, 
        {{(char )'C', (char )'V', (char )'S', (char )'\000'}, 1, 1, & fnc_cvs, (struct bwb_function *)((void *)0),
      0}, 
        {{(char )'C', (char )'V', (char )'I', (char )'\000'}, 1, 1, & fnc_cvi, (struct bwb_function *)((void *)0),
      0}, 
        {{(char )'C', (char )'I', (char )'N', (char )'T', (char )'\000'}, 1, 1, & fnc_cint,
      (struct bwb_function *)((void *)0), 0}, 
        {{(char )'C', (char )'S', (char )'N', (char )'G', (char )'\000'}, 1, 1, & fnc_csng,
      (struct bwb_function *)((void *)0), 0}, 
        {{(char )'E', (char )'N', (char )'V', (char )'I', (char )'R', (char )'O', (char )'N',
       (char )'$', (char )'\000'}, '$', 1, & fnc_environ, (struct bwb_function *)((void *)0),
      0}, 
        {{(char )'E', (char )'R', (char )'R', (char )'\000'}, 1, 0, & fnc_err, (struct bwb_function *)((void *)0),
      0}, 
        {{(char )'E', (char )'R', (char )'L', (char )'\000'}, 1, 0, & fnc_erl, (struct bwb_function *)((void *)0),
      0}, 
        {{(char )'L', (char )'O', (char )'C', (char )'\000'}, 1, 1, & fnc_loc, (struct bwb_function *)((void *)0),
      0}, 
        {{(char )'L', (char )'O', (char )'F', (char )'\000'}, 1, 1, & fnc_lof, (struct bwb_function *)((void *)0),
      0}, 
        {{(char )'E', (char )'O', (char )'F', (char )'\000'}, 1, 1, & fnc_eof, (struct bwb_function *)((void *)0),
      0}, 
        {{(char )'I', (char )'N', (char )'S', (char )'T', (char )'R', (char )'\000'},
      1, 1, & fnc_instr, (struct bwb_function *)((void *)0), 0}, 
        {{(char )'S', (char )'P', (char )'C', (char )'\000'}, '$', 1, & fnc_spc, (struct bwb_function *)((void *)0),
      0}, 
        {{(char )'S', (char )'P', (char )'A', (char )'C', (char )'E', (char )'$', (char )'\000'},
      '$', 1, & fnc_space, (struct bwb_function *)((void *)0), 0}, 
        {{(char )'S', (char )'T', (char )'R', (char )'I', (char )'N', (char )'G', (char )'$',
       (char )'\000'}, '$', 1, & fnc_string, (struct bwb_function *)((void *)0), 0}, 
        {{(char )'M',
       (char )'I', (char )'D', (char )'$', (char )'\000'}, '$', 3, & fnc_mid, (struct bwb_function *)((void *)0),
      0}, 
        {{(char )'L', (char )'E', (char )'F', (char )'T', (char )'$', (char )'\000'},
      '$', 2, & fnc_left, (struct bwb_function *)((void *)0), 0}, 
        {{(char )'R', (char )'I', (char )'G', (char )'H', (char )'T', (char )'$', (char )'\000'},
      '$', 2, & fnc_right, (struct bwb_function *)((void *)0), 0}, 
        {{(char )'T', (char )'I', (char )'M', (char )'E', (char )'R', (char )'\000'},
      1, 0, & fnc_timer, (struct bwb_function *)((void *)0), 0}, 
        {{(char )'H', (char )'E', (char )'X', (char )'$', (char )'\000'}, '$', 1, & fnc_hex,
      (struct bwb_function *)((void *)0), 0}, 
        {{(char )'O', (char )'C', (char )'T', (char )'$', (char )'\000'}, '$', 1, & fnc_oct,
      (struct bwb_function *)((void *)0), 0}, 
        {{(char )'C', (char )'H', (char )'R', (char )'$', (char )'\000'}, 1, 0, & fnc_chr,
      (struct bwb_function *)((void *)0), 0}, 
        {{(char )'L', (char )'E', (char )'N', (char )'\000'}, 1, 1, & fnc_len, (struct bwb_function *)((void *)0),
      0}, 
        {{(char )'P', (char )'O', (char )'S', (char )'\000'}, 1, 0, & fnc_pos, (struct bwb_function *)((void *)0),
      0}, 
        {{(char )'V', (char )'A', (char )'L', (char )'\000'}, 1, 1, & fnc_val, (struct bwb_function *)((void *)0),
      0}, 
        {{(char )'S', (char )'T', (char )'R', (char )'$', (char )'\000'}, '$', 1, & fnc_str,
      (struct bwb_function *)((void *)0), 0}, 
        {{(char )'D', (char )'A', (char )'T', (char )'E', (char )'$', (char )'\000'},
      '$', 0, & fnc_date, (struct bwb_function *)((void *)0), 0}, 
        {{(char )'T', (char )'I', (char )'M', (char )'E', (char )'$', (char )'\000'},
      '$', 0, & fnc_time, (struct bwb_function *)((void *)0), 0}, 
        {{(char )'A', (char )'B', (char )'S', (char )'\000'}, 1, 1, & fnc_core, (struct bwb_function *)((void *)0),
      1}, 
        {{(char )'A', (char )'T', (char )'N', (char )'\000'}, 1, 1, & fnc_core, (struct bwb_function *)((void *)0),
      2}, 
        {{(char )'C', (char )'O', (char )'S', (char )'\000'}, 1, 1, & fnc_core, (struct bwb_function *)((void *)0),
      3}, 
        {{(char )'E', (char )'X', (char )'P', (char )'\000'}, 1, 1, & fnc_core, (struct bwb_function *)((void *)0),
      4}, 
        {{(char )'I', (char )'N', (char )'T', (char )'\000'}, 1, 1, & fnc_core, (struct bwb_function *)((void *)0),
      5}, 
        {{(char )'L', (char )'O', (char )'G', (char )'\000'}, 1, 1, & fnc_core, (struct bwb_function *)((void *)0),
      6}, 
        {{(char )'R', (char )'N', (char )'D', (char )'\000'}, 1, 0, & fnc_core, (struct bwb_function *)((void *)0),
      7}, 
        {{(char )'S', (char )'G', (char )'N', (char )'\000'}, 1, 1, & fnc_core, (struct bwb_function *)((void *)0),
      8}, 
        {{(char )'S', (char )'I', (char )'N', (char )'\000'}, 1, 1, & fnc_core, (struct bwb_function *)((void *)0),
      9}, 
        {{(char )'S', (char )'Q', (char )'R', (char )'\000'}, 1, 1, & fnc_core, (struct bwb_function *)((void *)0),
      10}, 
        {{(char )'T', (char )'A', (char )'N', (char )'\000'}, 1, 1, & fnc_core, (struct bwb_function *)((void *)0),
      11}, 
        {{(char )'T', (char )'A', (char )'B', (char )'\000'}, '$', 1, & fnc_tab, (struct bwb_function *)((void *)0),
      0}};
#line 252 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
struct bwb_op exp_ops[25]  = 
#line 252
  {      {{(char )'N', (char )'O', (char )'T', (char )'\000'}, 25, 2}, 
        {{(char )'A', (char )'N', (char )'D', (char )'\000'}, 26, 13}, 
        {{(char )'O', (char )'R', (char )'\000'}, 27, 14}, 
        {{(char )'X', (char )'O', (char )'R', (char )'\000'}, 28, 15}, 
        {{(char )'I', (char )'M', (char )'P', (char )'\000'}, 29, 16}, 
        {{(char )'E', (char )'Q', (char )'V', (char )'\000'}, 30, 17}, 
        {{(char )'M', (char )'O', (char )'D', (char )'\000'}, 11, 5}, 
        {{(char )'<', (char )'>', (char )'\000'}, 20, 8}, 
        {{(char )'<', (char )'=', (char )'\000'}, 23, 11}, 
        {{(char )'=', (char )'<', (char )'\000'}, 23, 11}, 
        {{(char )'>', (char )'=', (char )'\000'}, 24, 12}, 
        {{(char )'=', (char )'>', (char )'\000'}, 24, 12}, 
        {{(char )'<', (char )'\000'}, 21, 9}, 
        {{(char )'>', (char )'\000'}, 22, 10}, 
        {{(char )'^', (char )'\000'}, 12, 0}, 
        {{(char )'*', (char )'\000'}, 9, 3}, 
        {{(char )'/', (char )'\000'}, 10, 3}, 
        {{(char )'\\', (char )'\000'}, 13, 4}, 
        {{(char )'+', (char )'\000'}, 7, 6}, 
        {{(char )'-', (char )'\000'}, 8, 6}, 
        {{(char )'=', (char )'\000'}, 17, 7}, 
        {{(char )'=', (char )'\000'}, 18, 18}, 
        {{(char )';', (char )'\000'}, 15, 19}, 
        {{(char )',', (char )'\000'}, 16, 20}, 
        {{(char )'-', (char )'\000'}, 14, 1}};
#line 283 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_openfile[23]  = 
#line 283
  {      (char )'F',      (char )'a',      (char )'i',      (char )'l', 
        (char )'e',      (char )'d',      (char )' ',      (char )'t', 
        (char )'o',      (char )' ',      (char )'o',      (char )'p', 
        (char )'e',      (char )'n',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )' ', 
        (char )'%',      (char )'s',      (char )'\000'};
#line 284 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_getmem[22]  = 
#line 284
  {      (char )'F',      (char )'a',      (char )'i',      (char )'l', 
        (char )'e',      (char )'d',      (char )' ',      (char )'t', 
        (char )'o',      (char )' ',      (char )'f',      (char )'i', 
        (char )'n',      (char )'d',      (char )' ',      (char )'m', 
        (char )'e',      (char )'m',      (char )'o',      (char )'r', 
        (char )'y',      (char )'\000'};
#line 285 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_noln[15]  = 
#line 285
  {      (char )'N',      (char )'o',      (char )' ',      (char )'l', 
        (char )'i',      (char )'n',      (char )'e',      (char )' ', 
        (char )'n',      (char )'u',      (char )'m',      (char )'b', 
        (char )'e',      (char )'r',      (char )'\000'};
#line 286 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_nofn[13]  = 
#line 286
  {      (char )'N',      (char )'o',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )' ', 
        (char )'n',      (char )'a',      (char )'m',      (char )'e', 
        (char )'\000'};
#line 287 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_lnnotfound[25]  = 
#line 287
  {      (char )'L',      (char )'i',      (char )'n',      (char )'e', 
        (char )' ',      (char )'n',      (char )'u',      (char )'m', 
        (char )'b',      (char )'e',      (char )'r',      (char )' ', 
        (char )'%',      (char )'d',      (char )' ',      (char )'n', 
        (char )'o',      (char )'t',      (char )' ',      (char )'f', 
        (char )'o',      (char )'u',      (char )'n',      (char )'d', 
        (char )'\000'};
#line 288 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_incomplete[21]  = 
#line 288
  {      (char )'I',      (char )'n',      (char )'c',      (char )'o', 
        (char )'m',      (char )'p',      (char )'l',      (char )'e', 
        (char )'t',      (char )'e',      (char )' ',      (char )'s', 
        (char )'t',      (char )'a',      (char )'t',      (char )'e', 
        (char )'m',      (char )'e',      (char )'n',      (char )'t', 
        (char )'\000'};
#line 289 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_valoorange[22]  = 
#line 289
  {      (char )'V',      (char )'a',      (char )'l',      (char )'u', 
        (char )'e',      (char )' ',      (char )'i',      (char )'s', 
        (char )' ',      (char )'o',      (char )'u',      (char )'t', 
        (char )' ',      (char )'o',      (char )'f',      (char )' ', 
        (char )'r',      (char )'a',      (char )'n',      (char )'g', 
        (char )'e',      (char )'\000'};
#line 290 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_syntax[13]  = 
#line 290
  {      (char )'S',      (char )'y',      (char )'n',      (char )'t', 
        (char )'a',      (char )'x',      (char )' ',      (char )'e', 
        (char )'r',      (char )'r',      (char )'o',      (char )'r', 
        (char )'\000'};
#line 291 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_devnum[22]  = 
#line 291
  {      (char )'I',      (char )'n',      (char )'v',      (char )'a', 
        (char )'l',      (char )'i',      (char )'d',      (char )' ', 
        (char )'d',      (char )'e',      (char )'v',      (char )'i', 
        (char )'c',      (char )'e',      (char )' ',      (char )'n', 
        (char )'u',      (char )'m',      (char )'b',      (char )'e', 
        (char )'r',      (char )'\000'};
#line 292 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_dev[13]  = 
#line 292
  {      (char )'D',      (char )'e',      (char )'v',      (char )'i', 
        (char )'c',      (char )'e',      (char )' ',      (char )'e', 
        (char )'r',      (char )'r',      (char )'o',      (char )'r', 
        (char )'\000'};
#line 293 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_opsys[34]  = 
#line 293
  {      (char )'E',      (char )'r',      (char )'r',      (char )'o', 
        (char )'r',      (char )' ',      (char )'i',      (char )'n', 
        (char )' ',      (char )'o',      (char )'p',      (char )'e', 
        (char )'r',      (char )'a',      (char )'t',      (char )'i', 
        (char )'n',      (char )'g',      (char )' ',      (char )'s', 
        (char )'y',      (char )'s',      (char )'t',      (char )'e', 
        (char )'m',      (char )' ',      (char )'c',      (char )'o', 
        (char )'m',      (char )'m',      (char )'a',      (char )'n', 
        (char )'d',      (char )'\000'};
#line 294 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_argstr[26]  = 
#line 294
  {      (char )'A',      (char )'r',      (char )'g',      (char )'u', 
        (char )'m',      (char )'e',      (char )'n',      (char )'t', 
        (char )' ',      (char )'m',      (char )'u',      (char )'s', 
        (char )'t',      (char )' ',      (char )'b',      (char )'e', 
        (char )' ',      (char )'a',      (char )' ',      (char )'s', 
        (char )'t',      (char )'r',      (char )'i',      (char )'n', 
        (char )'g',      (char )'\000'};
#line 295 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_defchar[43]  = 
#line 295
  {      (char )'I',      (char )'n',      (char )'c',      (char )'o', 
        (char )'r',      (char )'r',      (char )'e',      (char )'c', 
        (char )'t',      (char )' ',      (char )'a',      (char )'r', 
        (char )'g',      (char )'u',      (char )'m',      (char )'e', 
        (char )'n',      (char )'t',      (char )' ',      (char )'f', 
        (char )'o',      (char )'r',      (char )' ',      (char )'v', 
        (char )'a',      (char )'r',      (char )'i',      (char )'a', 
        (char )'b',      (char )'l',      (char )'e',      (char )' ', 
        (char )'d',      (char )'e',      (char )'f',      (char )'i', 
        (char )'n',      (char )'i',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'\000'};
#line 296 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_mismatch[14]  = 
#line 296
  {      (char )'T',      (char )'y',      (char )'p',      (char )'e', 
        (char )' ',      (char )'m',      (char )'i',      (char )'s', 
        (char )'m',      (char )'a',      (char )'t',      (char )'c', 
        (char )'h',      (char )'\000'};
#line 297 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_dimnotarray[30]  = 
#line 297
  {      (char )'A',      (char )'r',      (char )'g',      (char )'u', 
        (char )'m',      (char )'e',      (char )'n',      (char )'t', 
        (char )' ',      (char )'i',      (char )'s',      (char )' ', 
        (char )'n',      (char )'o',      (char )'t',      (char )' ', 
        (char )'a',      (char )'n',      (char )' ',      (char )'a', 
        (char )'r',      (char )'r',      (char )'a',      (char )'y', 
        (char )' ',      (char )'n',      (char )'a',      (char )'m', 
        (char )'e',      (char )'\000'};
#line 298 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_retnogosub[21]  = 
#line 298
  {      (char )'R',      (char )'E',      (char )'T',      (char )'U', 
        (char )'R',      (char )'N',      (char )' ',      (char )'w', 
        (char )'i',      (char )'t',      (char )'h',      (char )'o', 
        (char )'u',      (char )'t',      (char )' ',      (char )'G', 
        (char )'O',      (char )'S',      (char )'U',      (char )'B', 
        (char )'\000'};
#line 299 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_od[12]  = 
#line 299
  {      (char )'O',      (char )'u',      (char )'t',      (char )' ', 
        (char )'o',      (char )'f',      (char )' ',      (char )'d', 
        (char )'a',      (char )'t',      (char )'a',      (char )'\000'};
#line 300 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_overflow[9]  = 
#line 300
  {      (char )'O',      (char )'v',      (char )'e',      (char )'r', 
        (char )'f',      (char )'l',      (char )'o',      (char )'w', 
        (char )'\000'};
#line 301 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_nf[17]  = 
#line 301
  {      (char )'N',      (char )'E',      (char )'X',      (char )'T', 
        (char )' ',      (char )'w',      (char )'i',      (char )'t', 
        (char )'h',      (char )'o',      (char )'u',      (char )'t', 
        (char )' ',      (char )'F',      (char )'O',      (char )'R', 
        (char )'\000'};
#line 302 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_uf[19]  = 
#line 302
  {      (char )'U',      (char )'n',      (char )'d',      (char )'e', 
        (char )'f',      (char )'i',      (char )'n',      (char )'e', 
        (char )'d',      (char )' ',      (char )'f',      (char )'u', 
        (char )'n',      (char )'c',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'\000'};
#line 303 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_dbz[15]  = 
#line 303
  {      (char )'D',      (char )'i',      (char )'v',      (char )'i', 
        (char )'d',      (char )'e',      (char )' ',      (char )'b', 
        (char )'y',      (char )' ',      (char )'z',      (char )'e', 
        (char )'r',      (char )'o',      (char )'\000'};
#line 304 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_redim[33]  = 
#line 304
  {      (char )'V',      (char )'a',      (char )'r',      (char )'i', 
        (char )'a',      (char )'b',      (char )'l',      (char )'e', 
        (char )' ',      (char )'c',      (char )'a',      (char )'n', 
        (char )'n',      (char )'o',      (char )'t',      (char )' ', 
        (char )'b',      (char )'e',      (char )' ',      (char )'r', 
        (char )'e',      (char )'d',      (char )'i',      (char )'m', 
        (char )'e',      (char )'n',      (char )'s',      (char )'i', 
        (char )'o',      (char )'n',      (char )'e',      (char )'d', 
        (char )'\000'};
#line 305 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_obdim[40]  = 
#line 305
  {      (char )'O',      (char )'P',      (char )'T',      (char )'I', 
        (char )'O',      (char )'N',      (char )' ',      (char )'B', 
        (char )'A',      (char )'S',      (char )'E',      (char )' ', 
        (char )'m',      (char )'u',      (char )'s',      (char )'t', 
        (char )' ',      (char )'b',      (char )'e',      (char )' ', 
        (char )'c',      (char )'a',      (char )'l',      (char )'l', 
        (char )'e',      (char )'d',      (char )' ',      (char )'p', 
        (char )'r',      (char )'i',      (char )'o',      (char )'r', 
        (char )' ',      (char )'t',      (char )'o',      (char )' ', 
        (char )'D',      (char )'I',      (char )'M',      (char )'\000'};
#line 306 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_uc[16]  = 
#line 306
  {      (char )'U',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'c',      (char )'o',      (char )'m',      (char )'m', 
        (char )'a',      (char )'n',      (char )'d',      (char )'\000'};
#line 307 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char err_noprogfile[27]  = 
#line 307
  {      (char )'P',      (char )'r',      (char )'o',      (char )'g', 
        (char )'r',      (char )'a',      (char )'m',      (char )' ', 
        (char )'f',      (char )'i',      (char )'l',      (char )'e', 
        (char )' ',      (char )'n',      (char )'o',      (char )'t', 
        (char )' ',      (char )'s',      (char )'p',      (char )'e', 
        (char )'c',      (char )'i',      (char )'f',      (char )'i', 
        (char )'e',      (char )'d',      (char )'\000'};
#line 315 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_tbl.c"
char *err_table[25]  = 
#line 315
  {      err_openfile,      err_getmem,      err_noln,      err_nofn, 
        err_lnnotfound,      err_incomplete,      err_valoorange,      err_syntax, 
        err_devnum,      err_dev,      err_opsys,      err_argstr, 
        err_defchar,      err_mismatch,      err_dimnotarray,      err_od, 
        err_overflow,      err_nf,      err_uf,      err_dbz, 
        err_redim,      err_obdim,      err_uc,      err_noprogfile};
#line 376 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 860 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct bwb_line *bwb_xload(struct bwb_line *l ) ;
#line 864
struct bwb_line *bwb_xlist(struct bwb_line *l , FILE *file ) ;
#line 920
struct bwb_line *bwb_doloop(struct bwb_line *l ) ;
#line 971
int inp_adv(char *b___4 , int *c ) ;
#line 989
extern struct bwb_line *find_label(char *buffer ) ;
#line 1035
int bwb_scan(void) ;
#line 1038
struct bwb_line *bwb_endsub(struct bwb_line *line ) ;
#line 1039
struct bwb_line *bwb_endfnc(struct bwb_line *l ) ;
#line 139 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) raise)(int __sig ) ;
#line 68 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
char err_gosubl[41]  = {      (char )'\000'};
#line 71
struct bwb_line *bwb_xnew(struct bwb_line *l ) ;
#line 72
struct bwb_line *bwb_onerror(struct bwb_line *l ) ;
#line 73
struct bwb_line *bwb_donum(struct bwb_line *l ) ;
#line 74
struct bwb_line *bwb_dounnum(struct bwb_line *l ) ;
#line 75
static int xl_line(FILE *file , struct bwb_line *l ) ;
#line 95 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_null(struct bwb_line *l ) 
{ 
  struct bwb_line *tmp ;

  {
  {
#line 110
  adv_eos(l->buffer, & l->position);
#line 113
  tmp = bwb_zline(l);
  }
#line 113
  return (tmp);
}
}
#line 127 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_rem(struct bwb_line *l ) 
{ 


  {
#line 143
  (l->next)->position = 0;
#line 144
  return (l->next);
}
}
#line 161 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_let(struct bwb_line *l ) 
{ 
  struct bwb_line *tmp ;

  {
  {
#line 178
  bwb_exp(l->buffer, -1, & l->position);
#line 181
  tmp = bwb_zline(l);
  }
#line 181
  return (tmp);
}
}
#line 196 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_go(struct bwb_line *l ) 
{ 
  char tbuf___20[5001] ;
  struct bwb_line *tmp ;
  int tmp___0 ;
  struct bwb_line *tmp___1 ;
  int tmp___2 ;
  struct bwb_line *tmp___3 ;

  {
  {
#line 206
  adv_element(l->buffer, & l->position, tbuf___20);
#line 207
  bwb_strtoupper(tbuf___20);
#line 209
  tmp___0 = strcmp((char const   *)(tbuf___20), "SUB");
  }
#line 209
  if (tmp___0 == 0) {
    {
#line 211
    tmp = bwb_gosub(l);
    }
#line 211
    return (tmp);
  }
  {
#line 214
  tmp___2 = strcmp((char const   *)(tbuf___20), "TO");
  }
#line 214
  if (tmp___2 == 0) {
    {
#line 216
    tmp___1 = bwb_goto(l);
    }
#line 216
    return (tmp___1);
  }
  {
#line 220
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_go(): Nonsense following GO");
#line 221
  bwb_error(bwb_ebuf);
#line 226
  tmp___3 = bwb_zline(l);
  }
#line 226
  return (tmp___3);
}
}
#line 242 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_goto(struct bwb_line *l ) 
{ 
  struct bwb_line *x___0 ;
  char tbuf___20[5001] ;
  struct bwb_line *tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  struct bwb_line *tmp___3 ;

  {
  {
#line 260
  adv_ws(l->buffer, & l->position);
  }
  {
#line 266
  if ((int )*(l->buffer + l->position) == 58) {
#line 266
    goto case_58;
  }
#line 266
  if ((int )*(l->buffer + l->position) == 13) {
#line 266
    goto case_58;
  }
#line 266
  if ((int )*(l->buffer + l->position) == 10) {
#line 266
    goto case_58;
  }
#line 266
  if ((int )*(l->buffer + l->position) == 0) {
#line 266
    goto case_58;
  }
#line 270
  goto switch_default;
  case_58: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 267
  bwb_error(err_noln);
#line 269
  tmp = bwb_zline(l);
  }
#line 269
  return (tmp);
  switch_default: /* CIL Label */ 
#line 271
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 274
  adv_element(l->buffer, & l->position, tbuf___20);
#line 285
  tmp___1 = __ctype_b_loc();
  }
#line 285
  if ((int const   )*(*tmp___1 + (int )tbuf___20[0]) & 1024) {
    {
#line 293
    x___0 = find_label(tbuf___20);
#line 294
    x___0->position = 0;
    }
#line 295
    return (x___0);
  } else {
#line 300
    x___0 = & bwb_start;
    {
#line 300
    while (1) {
      while_continue: /* CIL Label */ ;
#line 300
      if (! ((unsigned long )x___0 != (unsigned long )(& bwb_end))) {
#line 300
        goto while_break;
      }
      {
#line 302
      tmp___0 = atoi((char const   *)(tbuf___20));
      }
#line 302
      if (x___0->number == tmp___0) {
#line 312
        x___0->position = 0;
#line 313
        return (x___0);
      }
#line 300
      x___0 = x___0->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 339
  tmp___2 = atoi((char const   *)(tbuf___20));
#line 339
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)(err_lnnotfound),
          tmp___2);
#line 340
  bwb_error(bwb_ebuf);
#line 342
  tmp___3 = bwb_zline(l);
  }
#line 342
  return (tmp___3);
}
}
#line 357 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_gosub(struct bwb_line *l ) 
{ 
  struct bwb_line *x___0 ;
  char atbuf___4[5001] ;
  struct bwb_line *tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct bwb_line *tmp___3 ;

  {
  {
#line 370
  adv_ws(l->buffer, & l->position);
  }
  {
#line 376
  if ((int )*(l->buffer + l->position) == 58) {
#line 376
    goto case_58;
  }
#line 376
  if ((int )*(l->buffer + l->position) == 13) {
#line 376
    goto case_58;
  }
#line 376
  if ((int )*(l->buffer + l->position) == 10) {
#line 376
    goto case_58;
  }
#line 376
  if ((int )*(l->buffer + l->position) == 0) {
#line 376
    goto case_58;
  }
#line 381
  goto switch_default;
  case_58: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 377
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)(err_noln));
#line 378
  bwb_error(bwb_ebuf);
#line 380
  tmp = bwb_zline(l);
  }
#line 380
  return (tmp);
  switch_default: /* CIL Label */ 
#line 382
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 387
  adv_element(l->buffer, & l->position, atbuf___4);
#line 390
  adv_eos(l->buffer, & l->position);
#line 397
  tmp___0 = __ctype_b_loc();
  }
#line 397
  if ((int const   )*(*tmp___0 + (int )atbuf___4[0]) & 1024) {
    {
#line 399
    x___0 = find_label(atbuf___4);
#line 402
    (excs + exsc)->position = l->position;
#line 405
    bwb_incexec();
#line 409
    x___0->cmdnum = -1;
#line 410
    x___0->marked = 0;
#line 411
    x___0->position = 0;
#line 412
    bwb_setexec(x___0, 0, 1);
    }
#line 414
    return (x___0);
  }
#line 420
  x___0 = & bwb_start;
  {
#line 420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 420
    if (! ((unsigned long )x___0 != (unsigned long )(& bwb_end))) {
#line 420
      goto while_break;
    }
    {
#line 423
    tmp___1 = atoi((char const   *)(atbuf___4));
    }
#line 423
    if (x___0->number == tmp___1) {
      {
#line 429
      (excs + exsc)->position = l->position;
#line 434
      bwb_incexec();
#line 438
      x___0->cmdnum = -1;
#line 439
      x___0->marked = 0;
#line 440
      x___0->position = 0;
#line 441
      bwb_setexec(x___0, 0, 1);
      }
#line 443
      return (x___0);
    }
#line 420
    x___0 = x___0->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 449
  tmp___2 = atoi((char const   *)(atbuf___4));
#line 449
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)(err_lnnotfound),
          tmp___2);
#line 450
  bwb_error(bwb_ebuf);
#line 452
  tmp___3 = bwb_zline(l);
  }
#line 452
  return (tmp___3);
}
}
#line 468 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_return(struct bwb_line *l ) 
{ 


  {
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    if (! ((excs + exsc)->code != 1)) {
#line 499
      goto while_break;
    }
    {
#line 501
    bwb_decexec();
    }
#line 502
    if ((excs + exsc)->code == 0) {
      {
#line 504
      bwb_error(err_retnogosub);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 510
  bwb_decexec();
#line 515
  ((excs + exsc)->line)->position = (excs + exsc)->position;
  }
#line 517
  return ((excs + exsc)->line);
}
}
#line 555 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
static int startpos  ;
#line 544 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_on(struct bwb_line *l ) 
{ 
  struct bwb_line *oline ;
  struct bwb_line *x___0 ;
  char varname[41] ;
  char tbuf___20[5001] ;
  struct exp_ese *rvar ;
  int v___0 ;
  int loop ;
  int num_lines ;
  int command ;
  int lines[12] ;
  char sbuf[7] ;
  struct bwb_line *tmp ;
  struct bwb_line *tmp___0 ;
  int tmp___1 ;
  bnumber tmp___2 ;
  struct bwb_line *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  struct bwb_line *tmp___8 ;
  struct bwb_line *tmp___9 ;
  void *tmp___10 ;
  char *tmp___11 ;
  void *tmp___12 ;
  struct bwb_line *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  {
#line 566
  adv_ws(l->buffer, & l->position);
  }
  {
#line 573
  if ((int )*(l->buffer + l->position) == 58) {
#line 573
    goto case_58;
  }
#line 573
  if ((int )*(l->buffer + l->position) == 13) {
#line 573
    goto case_58;
  }
#line 573
  if ((int )*(l->buffer + l->position) == 10) {
#line 573
    goto case_58;
  }
#line 573
  if ((int )*(l->buffer + l->position) == 0) {
#line 573
    goto case_58;
  }
#line 578
  goto switch_default;
  case_58: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 574
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)(err_incomplete));
#line 575
  bwb_error(bwb_ebuf);
#line 577
  tmp = bwb_zline(l);
  }
#line 577
  return (tmp);
  switch_default: /* CIL Label */ 
#line 579
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 584
  startpos = l->position;
#line 588
  adv_element(l->buffer, & l->position, varname);
#line 593
  strncpy((char */* __restrict  */)(sbuf), (char const   */* __restrict  */)(varname),
          (size_t )6);
#line 594
  bwb_strtoupper(sbuf);
#line 595
  tmp___1 = strcmp((char const   *)(sbuf), "ERROR");
  }
#line 595
  if (tmp___1 == 0) {
    {
#line 601
    tmp___0 = bwb_onerror(l);
    }
#line 601
    return (tmp___0);
  }
  {
#line 607
  l->position = startpos;
#line 608
  rvar = bwb_exp(l->buffer, 0, & l->position);
#line 609
  tmp___2 = exp_getnval(rvar);
#line 609
  v___0 = (int )tmp___2;
#line 618
  adv_element(l->buffer, & l->position, tbuf___20);
#line 619
  bwb_strtoupper(tbuf___20);
#line 620
  tmp___6 = strlen("GOTO");
#line 620
  tmp___7 = strncmp((char const   *)(tbuf___20), "GOTO", tmp___6);
  }
#line 620
  if (tmp___7 == 0) {
    {
#line 622
    command = getcmdnum((char *)"GOTO");
    }
  } else {
    {
#line 624
    tmp___4 = strlen("GOSUB");
#line 624
    tmp___5 = strncmp((char const   *)(tbuf___20), "GOSUB", tmp___4);
    }
#line 624
    if (tmp___5 == 0) {
      {
#line 626
      command = getcmdnum((char *)"GOSUB");
      }
    } else {
      {
#line 630
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"ON without GOTO or GOSUB");
#line 631
      bwb_error(bwb_ebuf);
#line 633
      tmp___3 = bwb_zline(l);
      }
#line 633
      return (tmp___3);
    }
  }
#line 636
  num_lines = 0;
#line 638
  loop = -1;
  {
#line 639
  while (1) {
    while_continue: /* CIL Label */ ;
#line 639
    if (! (loop == -1)) {
#line 639
      goto while_break;
    }
    {
#line 644
    inp_adv(l->buffer, & l->position);
#line 645
    adv_element(l->buffer, & l->position, tbuf___20);
#line 647
    lines[num_lines] = atoi((char const   *)(tbuf___20));
#line 649
    num_lines ++;
    }
#line 651
    if (num_lines >= 12) {
#line 653
      loop = 0;
    }
    {
#line 658
    adv_ws(l->buffer, & l->position);
    }
    {
#line 664
    if ((int )*(l->buffer + l->position) == 58) {
#line 664
      goto case_58___0;
    }
#line 664
    if ((int )*(l->buffer + l->position) == 13) {
#line 664
      goto case_58___0;
    }
#line 664
    if ((int )*(l->buffer + l->position) == 10) {
#line 664
      goto case_58___0;
    }
#line 664
    if ((int )*(l->buffer + l->position) == 0) {
#line 664
      goto case_58___0;
    }
#line 659
    goto switch_break___0;
    case_58___0: /* CIL Label */ 
    case_13___0: /* CIL Label */ 
    case_10___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
#line 665
    loop = 0;
#line 666
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 674
  adv_eos(l->buffer, & l->position);
  }
#line 679
  if (v___0 < 1) {
    {
#line 681
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)(err_valoorange));
#line 682
    bwb_error(bwb_ebuf);
#line 684
    tmp___8 = bwb_zline(l);
    }
#line 684
    return (tmp___8);
  } else
#line 679
  if (v___0 > num_lines) {
    {
#line 681
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)(err_valoorange));
#line 682
    bwb_error(bwb_ebuf);
#line 684
    tmp___8 = bwb_zline(l);
    }
#line 684
    return (tmp___8);
  }
  {
#line 687
  tmp___15 = getcmdnum((char *)"GOTO");
  }
#line 687
  if (command == tmp___15) {
#line 695
    oline = (struct bwb_line *)((void *)0);
#line 696
    x___0 = & bwb_start;
    {
#line 696
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 696
      if (! ((unsigned long )x___0 != (unsigned long )(& bwb_end))) {
#line 696
        goto while_break___0;
      }
#line 698
      if (x___0->number == lines[v___0 - 1]) {
#line 708
        oline = x___0;
      }
#line 696
      x___0 = x___0->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 712
    if ((unsigned long )oline == (unsigned long )((void *)0)) {
      {
#line 714
      bwb_error(err_lnnotfound);
#line 715
      tmp___9 = bwb_zline(l);
      }
#line 715
      return (tmp___9);
    }
    {
#line 718
    oline->position = 0;
#line 719
    bwb_setexec(oline, 0, (excs + exsc)->code);
    }
#line 721
    return (oline);
  } else {
    {
#line 725
    tmp___14 = getcmdnum((char *)"GOSUB");
    }
#line 725
    if (command == tmp___14) {
      {
#line 735
      bwb_setexec(l, l->position, (excs + exsc)->code);
#line 739
      bwb_incexec();
#line 744
      tmp___10 = CALLOC((size_t )1, sizeof(struct bwb_line ), (char *)"bwb_on");
#line 744
      oline = (struct bwb_line *)tmp___10;
      }
#line 744
      if ((unsigned long )oline == (unsigned long )((void *)0)) {
        {
#line 747
        bwb_error((char *)"in bwb_on(): failed to find memory for oline");
        }
      }
      {
#line 753
      tmp___12 = CALLOC((size_t )1, (size_t )5001, (char *)"bwb_on");
#line 753
      tmp___11 = (char *)tmp___12;
#line 753
      oline->buffer = tmp___11;
      }
#line 753
      if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
        {
#line 756
        bwb_error((char *)"in bwb_on(): failed to find memory for oline buffer");
        }
      }
      {
#line 762
      (excs + exsc)->while_line = oline;
#line 764
      sprintf((char */* __restrict  */)oline->buffer, (char const   */* __restrict  */)"%s %d",
              "GOSUB", lines[v___0 - 1]);
#line 765
      oline->marked = 0;
#line 766
      oline->position = 0;
#line 767
      oline->next = l->next;
#line 768
      bwb_setexec(oline, 0, 13);
      }
#line 769
      return (oline);
    } else {
      {
#line 775
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_on(): invalid value for command.");
#line 776
      bwb_error(bwb_ebuf);
#line 781
      tmp___13 = bwb_zline(l);
      }
#line 781
      return (tmp___13);
    }
  }
}
}
#line 799 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_stop(struct bwb_line *l ) 
{ 
  struct bwb_line *tmp ;

  {
  {
#line 810
  raise(2);
#line 816
  tmp = bwb_xend(l);
  }
#line 816
  return (tmp);
}
}
#line 831 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_xend(struct bwb_line *l ) 
{ 
  char tbuf___20[5001] ;
  struct bwb_line *tmp ;
  int tmp___0 ;
  struct bwb_line *tmp___1 ;
  int tmp___2 ;
  struct bwb_line *tmp___3 ;
  int tmp___4 ;
  struct bwb_line *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 851
  adv_element(l->buffer, & l->position, tbuf___20);
#line 852
  bwb_strtoupper(tbuf___20);
#line 854
  tmp___0 = strcmp((char const   *)(tbuf___20), "SUB");
  }
#line 854
  if (tmp___0 == 0) {
    {
#line 856
    tmp = bwb_endsub(l);
    }
#line 856
    return (tmp);
  }
  {
#line 859
  tmp___2 = strcmp((char const   *)(tbuf___20), "FUNCTION");
  }
#line 859
  if (tmp___2 == 0) {
    {
#line 861
    tmp___1 = bwb_endfnc(l);
    }
#line 861
    return (tmp___1);
  }
  {
#line 864
  tmp___4 = strcmp((char const   *)(tbuf___20), "IF");
  }
#line 864
  if (tmp___4 == 0) {
    {
#line 866
    tmp___3 = bwb_endif(l);
    }
#line 866
    return (tmp___3);
  }
  {
#line 869
  tmp___6 = strcmp((char const   *)(tbuf___20), "SELECT");
  }
#line 869
  if (tmp___6 == 0) {
    {
#line 871
    tmp___5 = bwb_endselect(l);
    }
#line 871
    return (tmp___5);
  }
  {
#line 878
  break_handler();
  }
#line 880
  return (& bwb_end);
}
}
#line 895 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_do(struct bwb_line *l ) 
{ 
  char tbuf___20[5001] ;
  struct bwb_line *tmp ;
  size_t tmp___0 ;
  struct bwb_line *tmp___1 ;
  int tmp___2 ;
  struct bwb_line *tmp___3 ;
  int tmp___4 ;
  struct bwb_line *tmp___5 ;
  int tmp___6 ;
  struct bwb_line *tmp___7 ;

  {
  {
#line 905
  adv_element(l->buffer, & l->position, tbuf___20);
#line 906
  bwb_strtoupper(tbuf___20);
#line 913
  tmp___0 = strlen((char const   *)(tbuf___20));
  }
#line 913
  if (tmp___0 == 0UL) {
    {
#line 915
    tmp = bwb_doloop(l);
    }
#line 915
    return (tmp);
  }
  {
#line 918
  tmp___2 = strcmp((char const   *)(tbuf___20), "WHILE");
  }
#line 918
  if (tmp___2 == 0) {
    {
#line 920
    tmp___1 = bwb_while(l);
    }
#line 920
    return (tmp___1);
  }
  {
#line 925
  tmp___4 = strcmp((char const   *)(tbuf___20), "NUM");
  }
#line 925
  if (tmp___4 == 0) {
    {
#line 927
    tmp___3 = bwb_donum(l);
    }
#line 927
    return (tmp___3);
  }
  {
#line 930
  tmp___6 = strcmp((char const   *)(tbuf___20), "UNNUM");
  }
#line 930
  if (tmp___6 == 0) {
    {
#line 932
    tmp___5 = bwb_dounnum(l);
    }
#line 932
    return (tmp___5);
  }
  {
#line 938
  bwb_error(err_syntax);
#line 939
  tmp___7 = bwb_zline(l);
  }
#line 939
  return (tmp___7);
}
}
#line 959 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_run(struct bwb_line *l ) 
{ 
  struct bwb_line *current ;
  struct bwb_line *x___0 ;
  int go_lnumber ;
  char tbuf___20[5001] ;
  struct exp_ese *e___0 ;
  FILE *input___0 ;
  bstring *tmp ;
  bnumber tmp___0 ;

  {
  {
#line 981
  current = (struct bwb_line *)((void *)0);
#line 982
  adv_ws(l->buffer, & l->position);
  }
  {
#line 993
  if ((int )*(l->buffer + l->position) == 58) {
#line 993
    goto case_58;
  }
#line 993
  if ((int )*(l->buffer + l->position) == 13) {
#line 993
    goto case_58;
  }
#line 993
  if ((int )*(l->buffer + l->position) == 10) {
#line 993
    goto case_58;
  }
#line 993
  if ((int )*(l->buffer + l->position) == 0) {
#line 993
    goto case_58;
  }
#line 1001
  goto switch_default;
  case_58: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 998
  current = bwb_start.next;
#line 999
  e___0 = (struct exp_ese *)((void *)0);
#line 1000
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1002
  e___0 = bwb_exp(l->buffer, 0, & l->position);
  }
#line 1003
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1008
  if ((unsigned long )e___0 != (unsigned long )((void *)0)) {
#line 1008
    if ((int )e___0->type == 36) {
      {
#line 1010
      bwb_new(l);
#line 1011
      tmp = exp_getsval(e___0);
#line 1011
      str_btoc(tbuf___20, tmp);
#line 1012
      input___0 = fopen((char const   */* __restrict  */)(tbuf___20), (char const   */* __restrict  */)"r");
      }
#line 1012
      if ((unsigned long )input___0 == (unsigned long )((void *)0)) {
        {
#line 1014
        sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)(err_openfile),
                tbuf___20);
#line 1015
        bwb_error(bwb_ebuf);
        }
      }
      {
#line 1017
      bwb_fload(input___0);
#line 1021
      current = & bwb_start;
      }
    }
  }
#line 1036
  if ((unsigned long )e___0 != (unsigned long )((void *)0)) {
#line 1036
    if ((int )e___0->type != 36) {
      {
#line 1038
      tmp___0 = exp_getnval(e___0);
#line 1038
      go_lnumber = (int )tmp___0;
#line 1046
      x___0 = bwb_start.next;
      }
      {
#line 1046
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1046
        if (! ((unsigned long )x___0 != (unsigned long )(& bwb_end))) {
#line 1046
          goto while_break;
        }
#line 1048
        if (x___0->number == go_lnumber) {
#line 1050
          current = x___0;
        }
#line 1046
        x___0 = x___0->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1057
  if ((unsigned long )current == (unsigned long )((void *)0)) {
    {
#line 1059
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)(err_lnnotfound),
            go_lnumber);
#line 1060
    bwb_error(bwb_ebuf);
    }
#line 1061
    return (& bwb_end);
  }
#line 1070
  if (rescan == -1) {
    {
#line 1072
    bwb_scan();
    }
  }
  {
#line 1075
  current->position = 0;
#line 1076
  exsc = 0;
#line 1077
  bwb_setexec(current, 0, 0);
  }
#line 1086
  return (current);
}
}
#line 1107 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_new(struct bwb_line *l ) 
{ 
  struct bwb_line *tmp ;

  {
  {
#line 1118
  bwb_xnew(l);
#line 1122
  bwb_clear(l);
#line 1125
  tmp = bwb_zline(l);
  }
#line 1125
  return (tmp);
}
}
#line 1149 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_system(struct bwb_line *l ) 
{ 


  {
  {
#line 1157
  prn_xprintf(stdout, (char *)"\n");
#line 1163
  bwx_terminate();
  }
#line 1164
  return (& bwb_end);
}
}
#line 1180 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_load(struct bwb_line *l ) 
{ 
  struct bwb_line *tmp ;

  {
  {
#line 1191
  bwb_new(l);
#line 1195
  bwb_xload(l);
#line 1197
  tmp = bwb_zline(l);
  }
#line 1197
  return (tmp);
}
}
#line 1211 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_xload(struct bwb_line *l ) 
{ 
  FILE *loadfile ;
  struct exp_ese *e___0 ;
  struct bwb_line *tmp ;
  struct bwb_line *tmp___0 ;
  bstring *tmp___1 ;
  struct bwb_line *tmp___2 ;
  struct bwb_line *tmp___3 ;

  {
  {
#line 1224
  adv_ws(l->buffer, & l->position);
  }
  {
#line 1230
  if ((int )*(l->buffer + l->position) == 58) {
#line 1230
    goto case_58;
  }
#line 1230
  if ((int )*(l->buffer + l->position) == 13) {
#line 1230
    goto case_58;
  }
#line 1230
  if ((int )*(l->buffer + l->position) == 10) {
#line 1230
    goto case_58;
  }
#line 1230
  if ((int )*(l->buffer + l->position) == 0) {
#line 1230
    goto case_58;
  }
#line 1234
  goto switch_default;
  case_58: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 1231
  bwb_error(err_nofn);
#line 1233
  tmp = bwb_zline(l);
  }
#line 1233
  return (tmp);
  switch_default: /* CIL Label */ 
#line 1235
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1239
  e___0 = bwb_exp(l->buffer, 0, & l->position);
  }
#line 1240
  if ((int )e___0->type != 36) {
    {
#line 1243
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_xload(): Missing filespec");
#line 1244
    bwb_error(bwb_ebuf);
#line 1249
    tmp___0 = bwb_zline(l);
    }
#line 1249
    return (tmp___0);
  }
  {
#line 1254
  tmp___1 = exp_getsval(e___0);
#line 1254
  str_btoc(progfile, tmp___1);
#line 1256
  loadfile = fopen((char const   */* __restrict  */)(progfile), (char const   */* __restrict  */)"r");
  }
#line 1256
  if ((unsigned long )loadfile == (unsigned long )((void *)0)) {
    {
#line 1258
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)(err_openfile),
            progfile);
#line 1259
    bwb_error(bwb_ebuf);
#line 1261
    tmp___2 = bwb_zline(l);
    }
#line 1261
    return (tmp___2);
  }
  {
#line 1264
  bwb_fload(loadfile);
#line 1267
  tmp___3 = bwb_zline(l);
  }
#line 1267
  return (tmp___3);
}
}
#line 1291 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
static char filename[128]  ;
#line 1282 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_save(struct bwb_line *l ) 
{ 
  FILE *outfile ;
  struct exp_ese *e___0 ;
  struct bwb_line *tmp ;
  struct bwb_line *tmp___0 ;
  bstring *tmp___1 ;
  struct bwb_line *tmp___2 ;
  struct bwb_line *tmp___3 ;

  {
  {
#line 1301
  adv_ws(l->buffer, & l->position);
  }
  {
#line 1307
  if ((int )*(l->buffer + l->position) == 58) {
#line 1307
    goto case_58;
  }
#line 1307
  if ((int )*(l->buffer + l->position) == 13) {
#line 1307
    goto case_58;
  }
#line 1307
  if ((int )*(l->buffer + l->position) == 10) {
#line 1307
    goto case_58;
  }
#line 1307
  if ((int )*(l->buffer + l->position) == 0) {
#line 1307
    goto case_58;
  }
#line 1311
  goto switch_default;
  case_58: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 1308
  bwb_error(err_nofn);
#line 1310
  tmp = bwb_zline(l);
  }
#line 1310
  return (tmp);
  switch_default: /* CIL Label */ 
#line 1312
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1316
  e___0 = bwb_exp(l->buffer, 0, & l->position);
  }
#line 1317
  if ((int )e___0->type != 36) {
    {
#line 1320
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_save(): Missing filespec");
#line 1321
    bwb_error(bwb_ebuf);
#line 1326
    tmp___0 = bwb_zline(l);
    }
#line 1326
    return (tmp___0);
  }
  {
#line 1331
  tmp___1 = exp_getsval(e___0);
#line 1331
  str_btoc(filename, tmp___1);
#line 1333
  outfile = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"w");
  }
#line 1333
  if ((unsigned long )outfile == (unsigned long )((void *)0)) {
    {
#line 1335
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)(err_openfile),
            filename);
#line 1336
    bwb_error(bwb_ebuf);
#line 1338
    tmp___2 = bwb_zline(l);
    }
#line 1338
    return (tmp___2);
  }
  {
#line 1341
  bwb_xlist(l, outfile);
#line 1342
  fclose(outfile);
#line 1345
  tmp___3 = bwb_zline(l);
  }
#line 1345
  return (tmp___3);
}
}
#line 1361 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_list(struct bwb_line *l ) 
{ 
  struct bwb_line *tmp ;

  {
  {
#line 1369
  bwb_xlist(l, stdout);
#line 1371
  tmp = bwb_zline(l);
  }
#line 1371
  return (tmp);
}
}
#line 1384 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_xlist(struct bwb_line *l , FILE *file ) 
{ 
  struct bwb_line *start ;
  struct bwb_line *end ;
  struct bwb_line *current ;
  int s___0 ;
  int e___0 ;
  int f ;
  int r ;
  struct bwb_line *tmp ;
  struct bwb_line *tmp___0 ;
  struct bwb_line *tmp___1 ;

  {
  {
#line 1397
  start = bwb_start.next;
#line 1398
  end = & bwb_end;
#line 1400
  r = bwb_numseq(l->buffer + l->position, & s___0, & e___0);
#line 1405
  adv_eos(l->buffer, & l->position);
  }
#line 1408
  if (r == 0) {
#line 1410
    s___0 = (bwb_start.next)->number;
  } else
#line 1408
  if (s___0 == 0) {
#line 1410
    s___0 = (bwb_start.next)->number;
  }
#line 1413
  if (e___0 == 0) {
#line 1415
    e___0 = s___0;
  }
#line 1418
  if (r == 0) {
#line 1420
    current = bwb_start.next;
    {
#line 1420
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1420
      if (! ((unsigned long )current != (unsigned long )(& bwb_end))) {
#line 1420
        goto while_break;
      }
#line 1422
      if ((unsigned long )current->next == (unsigned long )(& bwb_end)) {
#line 1424
        e___0 = current->number;
      }
#line 1420
      current = current->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1436
  if (s___0 == 32767) {
    {
#line 1439
    tmp = bwb_zline(l);
    }
#line 1439
    return (tmp);
  } else
#line 1436
  if (e___0 == 32767) {
    {
#line 1439
    tmp = bwb_zline(l);
    }
#line 1439
    return (tmp);
  }
#line 1444
  f = 0;
#line 1446
  current = bwb_start.next;
  {
#line 1446
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1446
    if (! ((unsigned long )current != (unsigned long )(& bwb_end))) {
#line 1446
      goto while_break___0;
    }
#line 1448
    if ((unsigned long )current != (unsigned long )l) {
#line 1450
      if (current->number == s___0) {
#line 1450
        if (f == 0) {
#line 1452
          f = -1;
#line 1453
          start = current;
        }
      }
    }
#line 1446
    current = current->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1467
  if (f == 0) {
    {
#line 1469
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)(err_lnnotfound),
            s___0);
#line 1470
    bwb_error(bwb_ebuf);
#line 1472
    tmp___0 = bwb_zline(l);
    }
#line 1472
    return (tmp___0);
  }
#line 1475
  if (e___0 >= s___0) {
#line 1477
    current = bwb_start.next;
    {
#line 1477
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1477
      if (! ((unsigned long )current != (unsigned long )(& bwb_end))) {
#line 1477
        goto while_break___1;
      }
#line 1479
      if ((unsigned long )current != (unsigned long )l) {
#line 1481
        if (current->number == e___0) {
#line 1489
          end = current->next;
        }
      }
#line 1477
      current = current->next;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 1496
    end = start;
  }
#line 1510
  if ((unsigned long )start == (unsigned long )end) {
    {
#line 1516
    xl_line(file, start);
    }
  } else {
#line 1520
    current = start;
    {
#line 1520
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1520
      if (! ((unsigned long )current != (unsigned long )end)) {
#line 1520
        goto while_break___2;
      }
      {
#line 1522
      xl_line(file, current);
#line 1520
      current = current->next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 1526
  tmp___1 = bwb_zline(l);
  }
#line 1526
  return (tmp___1);
}
}
#line 1541 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
static int xl_line(FILE *file , struct bwb_line *l ) 
{ 
  char tbuf___20[5001] ;

  {
#line 1552
  if ((unsigned long )file == (unsigned long )stdout) {
#line 1552
    goto _L;
  } else
#line 1552
  if ((unsigned long )file == (unsigned long )stderr) {
    _L: /* CIL Label */ 
#line 1555
    if ((int )l->xnum == -1) {
      {
#line 1557
      sprintf((char */* __restrict  */)(tbuf___20), (char const   */* __restrict  */)"%7d: %s\n",
              l->number, l->buffer);
      }
    } else {
      {
#line 1561
      sprintf((char */* __restrict  */)(tbuf___20), (char const   */* __restrict  */)"       : %s\n",
              l->buffer);
      }
    }
    {
#line 1564
    prn_xprintf(file, tbuf___20);
    }
  } else
#line 1569
  if ((int )l->xnum == -1) {
    {
#line 1571
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%d %s\n",
            l->number, l->buffer);
    }
  } else {
    {
#line 1575
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%s\n",
            l->buffer);
    }
  }
#line 1580
  return (-1);
}
}
#line 1606 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
static int s  ;
#line 1606 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
static int e  ;
#line 1597 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_delete(struct bwb_line *l ) 
{ 
  struct bwb_line *start ;
  struct bwb_line *end ;
  struct bwb_line *current ;
  struct bwb_line *previous ;
  struct bwb_line *p___0 ;
  struct bwb_line *next ;
  int f ;
  struct bwb_line *tmp ;
  struct bwb_line *tmp___0 ;

  {
  {
#line 1609
  previous = & bwb_start;
#line 1610
  start = bwb_start.next;
#line 1611
  end = & bwb_end;
#line 1613
  bwb_numseq(l->buffer + l->position, & s, & e);
#line 1623
  adv_eos(l->buffer, & l->position);
#line 1628
  p___0 = & bwb_start;
#line 1628
  previous = p___0;
#line 1629
  f = 0;
#line 1631
  current = bwb_start.next;
  }
  {
#line 1631
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1631
    if (! ((unsigned long )current != (unsigned long )(& bwb_end))) {
#line 1631
      goto while_break;
    }
#line 1633
    if ((unsigned long )current != (unsigned long )l) {
#line 1636
      if ((int )current->xnum == -1) {
#line 1636
        if (current->number == s) {
#line 1638
          f = -1;
#line 1639
          previous = p___0;
#line 1640
          start = current;
        }
      }
    }
#line 1650
    p___0 = current;
#line 1631
    current = current->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1655
  if (f == 0) {
    {
#line 1657
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)(err_lnnotfound),
            s);
#line 1658
    bwb_error(bwb_ebuf);
#line 1660
    tmp = bwb_zline(l);
    }
#line 1660
    return (tmp);
  }
#line 1663
  if (e > s) {
#line 1665
    current = bwb_start.next;
    {
#line 1665
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1665
      if (! ((unsigned long )current != (unsigned long )(& bwb_end))) {
#line 1665
        goto while_break___0;
      }
#line 1667
      if ((unsigned long )current != (unsigned long )l) {
#line 1670
        if ((int )current->xnum == -1) {
#line 1670
          if (current->number == e) {
#line 1678
            end = current->next;
          }
        }
      }
#line 1665
      current = current->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1685
    end = start->next;
  }
#line 1693
  current = start;
  {
#line 1694
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1694
    if ((unsigned long )current != (unsigned long )end) {
#line 1694
      if (! ((unsigned long )current != (unsigned long )(& bwb_end))) {
#line 1694
        goto while_break___1;
      }
    } else {
#line 1694
      goto while_break___1;
    }
    {
#line 1696
    next = current->next;
#line 1706
    bwb_freeline(current);
#line 1710
    current = next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1715
  previous->next = current;
#line 1718
  tmp___0 = bwb_zline(l);
  }
#line 1718
  return (tmp___0);
}
}
#line 1735 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_donum(struct bwb_line *l ) 
{ 
  struct bwb_line *current ;
  register int lnumber ;
  struct bwb_line *tmp ;
  struct bwb_line *tmp___0 ;

  {
#line 1746
  lnumber = 10;
#line 1747
  current = bwb_start.next;
  {
#line 1747
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1747
    if (! ((unsigned long )current != (unsigned long )(& bwb_end))) {
#line 1747
      goto while_break;
    }
#line 1749
    current->number = lnumber;
#line 1750
    current->xnum = (char)-1;
#line 1752
    lnumber += 10;
#line 1753
    if (lnumber >= 32766) {
      {
#line 1755
      tmp = bwb_zline(l);
      }
#line 1755
      return (tmp);
    }
#line 1747
    current = current->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1759
  tmp___0 = bwb_zline(l);
  }
#line 1759
  return (tmp___0);
}
}
#line 1775 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_dounnum(struct bwb_line *l ) 
{ 
  struct bwb_line *current ;
  struct bwb_line *tmp ;

  {
#line 1785
  current = bwb_start.next;
  {
#line 1785
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1785
    if (! ((unsigned long )current != (unsigned long )(& bwb_end))) {
#line 1785
      goto while_break;
    }
#line 1787
    current->number = 0;
#line 1788
    current->xnum = (char)0;
#line 1785
    current = current->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1791
  tmp = bwb_zline(l);
  }
#line 1791
  return (tmp);
}
}
#line 1810 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_chain(struct bwb_line *l ) 
{ 
  struct bwb_line *tmp ;

  {
  {
#line 1821
  var_delcvars();
#line 1825
  bwb_xnew(l);
#line 1829
  bwb_xload(l);
#line 1833
  exsc = -1;
#line 1834
  expsc = 0;
#line 1835
  xtxtsc = 0;
#line 1839
  tmp = bwb_run(& bwb_start);
  }
#line 1839
  return (tmp);
}
}
#line 1857 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_merge(struct bwb_line *l ) 
{ 
  struct bwb_line *tmp ;

  {
  {
#line 1868
  bwb_xload(l);
#line 1871
  tmp = bwb_zline(l);
  }
#line 1871
  return (tmp);
}
}
#line 1887 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_onerror(struct bwb_line *l ) 
{ 
  char tbuf___20[5001] ;
  struct bwb_line *tmp ;
  int tmp___0 ;
  struct bwb_line *tmp___1 ;

  {
  {
#line 1904
  adv_element(l->buffer, & l->position, tbuf___20);
#line 1908
  bwb_strtoupper(tbuf___20);
#line 1909
  tmp___0 = strcmp((char const   *)(tbuf___20), "GOSUB");
  }
#line 1909
  if (tmp___0 != 0) {
    {
#line 1912
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_onerror(): GOSUB statement missing");
#line 1913
    bwb_error(bwb_ebuf);
#line 1918
    tmp = bwb_zline(l);
    }
#line 1918
    return (tmp);
  }
  {
#line 1923
  adv_element(l->buffer, & l->position, err_gosubl);
#line 1925
  tmp___1 = bwb_zline(l);
  }
#line 1925
  return (tmp___1);
}
}
#line 1941 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_tron(struct bwb_line *l ) 
{ 
  struct bwb_line *tmp ;

  {
  {
#line 1949
  bwb_trace = -1;
#line 1950
  prn_xprintf(stdout, (char *)"Trace is ON\n");
#line 1952
  tmp = bwb_zline(l);
  }
#line 1952
  return (tmp);
}
}
#line 1967 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_troff(struct bwb_line *l ) 
{ 
  struct bwb_line *tmp ;

  {
  {
#line 1975
  bwb_trace = 0;
#line 1976
  prn_xprintf(stdout, (char *)"Trace is OFF\n");
#line 1978
  tmp = bwb_zline(l);
  }
#line 1978
  return (tmp);
}
}
#line 1996 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_randomize(struct bwb_line *l ) 
{ 
  register unsigned int n___0 ;
  struct exp_ese *e___0 ;
  bnumber tmp ;
  struct bwb_line *tmp___0 ;

  {
  {
#line 2009
  adv_ws(l->buffer, & l->position);
  }
  {
#line 2016
  if ((int )*(l->buffer + l->position) == 58) {
#line 2016
    goto case_58;
  }
#line 2016
  if ((int )*(l->buffer + l->position) == 13) {
#line 2016
    goto case_58;
  }
#line 2016
  if ((int )*(l->buffer + l->position) == 10) {
#line 2016
    goto case_58;
  }
#line 2016
  if ((int )*(l->buffer + l->position) == 0) {
#line 2016
    goto case_58;
  }
#line 2020
  goto switch_default;
  case_58: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 2018
  n___0 = 1U;
#line 2019
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2021
  n___0 = 0U;
#line 2022
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2027
  if (n___0 == 0U) {
    {
#line 2029
    e___0 = bwb_exp(l->buffer, 0, & l->position);
#line 2030
    tmp = exp_getnval(e___0);
#line 2030
    n___0 = (unsigned int )tmp;
    }
  }
  {
#line 2038
  srand(n___0);
#line 2040
  tmp___0 = bwb_zline(l);
  }
#line 2040
  return (tmp___0);
}
}
#line 2054 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_xnew(struct bwb_line *l ) 
{ 
  struct bwb_line *current ;
  struct bwb_line *previous ;
  int wait ;
  struct bwb_line *tmp ;

  {
#line 2065
  wait = -1;
#line 2066
  current = bwb_start.next;
  {
#line 2066
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2066
    if (! ((unsigned long )current != (unsigned long )(& bwb_end))) {
#line 2066
      goto while_break;
    }
#line 2068
    if (wait != -1) {
      {
#line 2071
      FREE((void *)previous, (char *)"bwb_xnew");
#line 2072
      previous = (struct bwb_line *)((void *)0);
      }
    }
#line 2074
    wait = 0;
#line 2075
    previous = current;
#line 2066
    current = current->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2078
  bwb_start.next = & bwb_end;
#line 2080
  tmp = bwb_zline(l);
  }
#line 2080
  return (tmp);
}
}
#line 2106 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
static char tbuf___18[5001]  ;
#line 2175
extern int ( /* missing proto */  putenv)() ;
#line 2098 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
struct bwb_line *bwb_environ(struct bwb_line *l ) 
{ 
  char tmp[5001] ;
  register int i ;
  int pos___2 ;
  struct exp_ese *e___0 ;
  bstring *tmp___0 ;
  struct bwb_line *tmp___1 ;
  bstring *tmp___2 ;
  struct bwb_line *tmp___3 ;
  int tmp___4 ;
  struct bwb_line *tmp___5 ;

  {
#line 2114
  i = 0;
  {
#line 2114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2114
    if ((int )*(l->buffer + l->position) != 61) {
#line 2114
      if (! ((int )*(l->buffer + l->position) != 0)) {
#line 2114
        goto while_break;
      }
    } else {
#line 2114
      goto while_break;
    }
#line 2116
    tbuf___18[i] = *(l->buffer + l->position);
#line 2117
    tbuf___18[i + 1] = (char )'\000';
#line 2118
    (l->position) ++;
#line 2114
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2128
  pos___2 = 0;
#line 2129
  e___0 = bwb_exp(tbuf___18, 0, & pos___2);
#line 2130
  tmp___0 = exp_getsval(e___0);
#line 2130
  str_btoc(tbuf___18, tmp___0);
#line 2139
  adv_ws(l->buffer, & l->position);
  }
#line 2140
  if ((int )*(l->buffer + l->position) != 61) {
    {
#line 2143
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_environ(): failed to find equal sign");
#line 2144
    bwb_error(bwb_ebuf);
#line 2149
    tmp___1 = bwb_zline(l);
    }
#line 2149
    return (tmp___1);
  }
  {
#line 2151
  (l->position) ++;
#line 2155
  e___0 = bwb_exp(l->buffer, 0, & l->position);
#line 2156
  tmp___2 = exp_getsval(e___0);
#line 2156
  str_btoc(tmp, tmp___2);
#line 2165
  strcat((char */* __restrict  */)(tbuf___18), (char const   */* __restrict  */)"=");
#line 2166
  strcat((char */* __restrict  */)(tbuf___18), (char const   */* __restrict  */)(tmp));
#line 2175
  tmp___4 = putenv(tbuf___18);
  }
#line 2175
  if (tmp___4 == -1) {
    {
#line 2177
    bwb_error(err_opsys);
#line 2179
    tmp___3 = bwb_zline(l);
    }
#line 2179
    return (tmp___3);
  }
  {
#line 2185
  tmp___5 = bwb_zline(l);
  }
#line 2185
  return (tmp___5);
}
}
#line 2243 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
int getcmdnum(char *cmdstr ) 
{ 
  register int c ;
  int tmp ;

  {
#line 2253
  c = 0;
  {
#line 2253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2253
    if (! (c < 76)) {
#line 2253
      goto while_break;
    }
    {
#line 2255
    tmp = strcmp((char const   *)(bwb_cmdtable[c].name), (char const   *)cmdstr);
    }
#line 2255
    if (tmp == 0) {
#line 2257
      return (c);
    }
#line 2253
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2261
  return (-1);
}
}
#line 2279 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_cmd.c"
extern struct bwb_line *bwb_zline(struct bwb_line *l ) 
{ 


  {
#line 2289
  return (l);
}
}
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 835
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *__path ) ;
#line 817 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct dev_element *dev_table  ;
#line 321 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 54 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
static struct bwb_variable *v  ;
#line 55 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
static int pos___1  ;
#line 56 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
static int req_devnumber  ;
#line 57 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
static int rlen  ;
#line 58 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
static int mode  ;
#line 61
static struct bwb_line *dio_lrset(struct bwb_line *l , int rset ) ;
#line 62
static int dio_flush(int dev_number ) ;
#line 83 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
struct bwb_line *bwb_open(struct bwb_line *l ) 
{ 
  FILE *fp ;
  struct exp_ese *e___0 ;
  char atbuf___4[5001] ;
  char first___0[5001] ;
  char devname[5001] ;
  bstring *tmp ;
  struct bwb_line *tmp___0 ;
  bnumber tmp___1 ;
  struct bwb_line *tmp___2 ;
  bstring *tmp___3 ;
  struct bwb_line *tmp___4 ;
  bnumber tmp___5 ;
  struct bwb_line *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  struct bwb_line *tmp___11 ;
  int tmp___12 ;
  struct bwb_line *tmp___13 ;
  bnumber tmp___14 ;
  size_t tmp___15 ;
  struct bwb_line *tmp___16 ;
  struct bwb_line *tmp___17 ;
  bnumber tmp___18 ;
  int tmp___19 ;
  struct bwb_line *tmp___20 ;
  struct bwb_line *tmp___21 ;
  struct bwb_line *tmp___22 ;
  long tmp___23 ;
  struct bwb_line *tmp___24 ;
  char *tmp___25 ;
  void *tmp___26 ;
  struct bwb_line *tmp___27 ;

  {
  {
#line 99
  rlen = -1;
#line 99
  req_devnumber = rlen;
#line 99
  mode = req_devnumber;
#line 103
  adv_element(l->buffer, & l->position, atbuf___4);
#line 107
  pos___1 = 0;
#line 108
  e___0 = bwb_exp(atbuf___4, 0, & pos___1);
#line 109
  tmp = exp_getsval(e___0);
#line 109
  str_btoc(first___0, tmp);
#line 121
  adv_ws(l->buffer, & l->position);
  }
#line 125
  if ((int )*(l->buffer + l->position) == 44) {
    {
#line 130
    (l->position) ++;
#line 131
    adv_ws(l->buffer, & l->position);
    }
#line 132
    if ((int )*(l->buffer + l->position) == 35) {
      {
#line 134
      (l->position) ++;
#line 135
      adv_ws(l->buffer, & l->position);
      }
    }
    {
#line 138
    adv_element(l->buffer, & l->position, atbuf___4);
#line 140
    pos___1 = 0;
#line 141
    e___0 = bwb_exp(atbuf___4, 0, & pos___1);
    }
#line 142
    if ((int )e___0->type == 36) {
      {
#line 145
      bwb_error((char *)"String where number was expected for device number");
#line 149
      tmp___0 = bwb_zline(l);
      }
#line 149
      return (tmp___0);
    }
    {
#line 151
    tmp___1 = exp_getnval(e___0);
#line 151
    req_devnumber = (int )tmp___1;
#line 161
    adv_ws(l->buffer, & l->position);
#line 162
    (l->position) ++;
#line 163
    adv_element(l->buffer, & l->position, atbuf___4);
#line 165
    pos___1 = 0;
#line 166
    e___0 = bwb_exp(atbuf___4, 0, & pos___1);
    }
#line 167
    if ((int )e___0->type != 36) {
      {
#line 170
      bwb_error((char *)"in bwb_open(): number where string was expected for devname");
#line 174
      tmp___2 = bwb_zline(l);
      }
#line 174
      return (tmp___2);
    }
    {
#line 176
    tmp___3 = exp_getsval(e___0);
#line 176
    str_btoc(devname, tmp___3);
#line 187
    adv_ws(l->buffer, & l->position);
    }
#line 188
    if ((int )*(l->buffer + l->position) == 44) {
      {
#line 191
      (l->position) ++;
#line 192
      adv_element(l->buffer, & l->position, atbuf___4);
#line 194
      pos___1 = 0;
#line 195
      e___0 = bwb_exp(atbuf___4, 0, & pos___1);
      }
#line 196
      if ((int )e___0->type == 36) {
        {
#line 199
        bwb_error((char *)"String where number was expected for record length");
#line 203
        tmp___4 = bwb_zline(l);
        }
#line 203
        return (tmp___4);
      }
      {
#line 205
      tmp___5 = exp_getnval(e___0);
#line 205
      rlen = (int )tmp___5;
      }
    }
#line 221
    if ((int )first___0[0] == 105) {
#line 223
      mode = 2;
    } else
#line 221
    if ((int )first___0[0] == 73) {
#line 223
      mode = 2;
    } else
#line 228
    if ((int )first___0[0] == 111) {
#line 230
      mode = 1;
    } else
#line 228
    if ((int )first___0[0] == 79) {
#line 230
      mode = 1;
    } else
#line 235
    if ((int )first___0[0] == 114) {
#line 237
      mode = 4;
    } else
#line 235
    if ((int )first___0[0] == 82) {
#line 237
      mode = 4;
    } else {
      {
#line 245
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_open(): invalid mode");
#line 246
      bwb_error(bwb_ebuf);
      }
    }
  } else {
    {
#line 266
    strcpy((char */* __restrict  */)(devname), (char const   */* __restrict  */)(first___0));
#line 276
    adv_element(l->buffer, & l->position, atbuf___4);
#line 280
    bwb_strtoupper(atbuf___4);
#line 281
    tmp___10 = strcmp((char const   *)(atbuf___4), "FOR");
    }
#line 281
    if (tmp___10 == 0) {
      {
#line 283
      adv_element(l->buffer, & l->position, atbuf___4);
#line 284
      bwb_strtoupper(atbuf___4);
#line 285
      tmp___9 = strcmp((char const   *)(atbuf___4), "INPUT");
      }
#line 285
      if (tmp___9 == 0) {
#line 287
        mode = 2;
      } else {
        {
#line 289
        tmp___8 = strcmp((char const   *)(atbuf___4), "OUTPUT");
        }
#line 289
        if (tmp___8 == 0) {
#line 291
          mode = 1;
        } else {
          {
#line 293
          tmp___7 = strcmp((char const   *)(atbuf___4), "APPEND");
          }
#line 293
          if (tmp___7 == 0) {
#line 295
            mode = 4;
          } else {
            {
#line 300
            bwb_error((char *)"in bwb_open(): Invalid device i/o mode specified");
#line 304
            tmp___6 = bwb_zline(l);
            }
#line 304
            return (tmp___6);
          }
        }
      }
      {
#line 309
      adv_element(l->buffer, & l->position, atbuf___4);
      }
    } else {
#line 314
      mode = 4;
    }
    {
#line 325
    bwb_strtoupper(atbuf___4);
#line 326
    tmp___12 = strcmp((char const   *)(atbuf___4), "AS");
    }
#line 326
    if (tmp___12 != 0) {
      {
#line 329
      bwb_error((char *)"in bwb_open(): expected AS statement");
#line 333
      tmp___11 = bwb_zline(l);
      }
#line 333
      return (tmp___11);
    }
    {
#line 338
    adv_ws(l->buffer, & l->position);
    }
#line 340
    if ((int )*(l->buffer + l->position) == 35) {
#line 342
      (l->position) ++;
    }
    {
#line 345
    adv_element(l->buffer, & l->position, atbuf___4);
#line 353
    pos___1 = 0;
#line 354
    e___0 = bwb_exp(atbuf___4, 0, & pos___1);
    }
#line 355
    if ((int )e___0->type == 36) {
      {
#line 358
      bwb_error((char *)"String where number was expected for dev number");
#line 362
      tmp___13 = bwb_zline(l);
      }
#line 362
      return (tmp___13);
    }
    {
#line 364
    tmp___14 = exp_getnval(e___0);
#line 364
    req_devnumber = (int )tmp___14;
#line 374
    adv_element(l->buffer, & l->position, atbuf___4);
#line 375
    bwb_strtoupper(atbuf___4);
#line 376
    tmp___19 = strncmp((char const   *)(atbuf___4), "LEN", (size_t )3);
    }
#line 376
    if (tmp___19 == 0) {
      {
#line 379
      tmp___15 = strlen((char const   *)(atbuf___4));
#line 379
      pos___1 = (int )((size_t )l->position - tmp___15);
      }
      {
#line 380
      while (1) {
        while_continue: /* CIL Label */ ;
#line 380
        if ((int )*(l->buffer + pos___1) != 61) {
#line 380
          if (! ((int )*(l->buffer + pos___1) != 0)) {
#line 380
            goto while_break;
          }
        } else {
#line 380
          goto while_break;
        }
#line 382
        pos___1 ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 384
      if ((int )*(l->buffer + pos___1) == 0) {
        {
#line 387
        bwb_error((char *)"Failed to find equals sign after LEN element");
#line 391
        tmp___16 = bwb_zline(l);
        }
#line 391
        return (tmp___16);
      }
      {
#line 393
      pos___1 ++;
#line 395
      e___0 = bwb_exp(l->buffer, 0, & pos___1);
      }
#line 397
      if ((int )e___0->type == 36) {
        {
#line 400
        bwb_error((char *)"String where number was expected for record length");
#line 404
        tmp___17 = bwb_zline(l);
        }
#line 404
        return (tmp___17);
      }
      {
#line 406
      tmp___18 = exp_getnval(e___0);
#line 406
      rlen = (int )tmp___18;
      }
    }
  }
#line 420
  if (req_devnumber < 0) {
    {
#line 423
    bwb_error((char *)"in bwb_open(): Requested device number is out of range.");
#line 427
    tmp___20 = bwb_zline(l);
    }
#line 427
    return (tmp___20);
  } else
#line 420
  if (req_devnumber >= 16) {
    {
#line 423
    bwb_error((char *)"in bwb_open(): Requested device number is out of range.");
#line 427
    tmp___20 = bwb_zline(l);
    }
#line 427
    return (tmp___20);
  }
#line 430
  if ((dev_table + req_devnumber)->mode == 0) {
#line 440
    if ((unsigned long )(dev_table + req_devnumber)->buffer != (unsigned long )((void *)0)) {
      {
#line 442
      free((void *)(dev_table + req_devnumber)->buffer);
#line 443
      (dev_table + req_devnumber)->buffer = (char *)((void *)0);
      }
    }
  }
#line 447
  if ((dev_table + req_devnumber)->mode != 0) {
#line 447
    if ((dev_table + req_devnumber)->mode != -1) {
      {
#line 451
      bwb_error((char *)"in bwb_open(): Requested device number is already in use.");
#line 456
      tmp___21 = bwb_zline(l);
      }
#line 456
      return (tmp___21);
    }
  }
  {
#line 469
  if (mode == 1) {
#line 469
    goto case_1;
  }
#line 472
  if (mode == 2) {
#line 472
    goto case_2;
  }
#line 475
  if (mode == 3) {
#line 475
    goto case_3;
  }
#line 478
  if (mode == 4) {
#line 478
    goto case_4;
  }
#line 467
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 470
  fp = fopen((char const   */* __restrict  */)(devname), (char const   */* __restrict  */)"w");
  }
#line 471
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 473
  fp = fopen((char const   */* __restrict  */)(devname), (char const   */* __restrict  */)"r");
  }
#line 474
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 476
  fp = fopen((char const   */* __restrict  */)(devname), (char const   */* __restrict  */)"a");
  }
#line 477
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 479
  fp = fopen((char const   */* __restrict  */)(devname), (char const   */* __restrict  */)"r+");
  }
#line 480
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 482
    fp = fopen((char const   */* __restrict  */)(devname), (char const   */* __restrict  */)"w");
#line 483
    fclose(fp);
#line 484
    fp = fopen((char const   */* __restrict  */)(devname), (char const   */* __restrict  */)"r+");
    }
  }
#line 486
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 491
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 494
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Failed to open device <%s>",
            devname);
#line 495
    bwb_error(bwb_ebuf);
#line 499
    tmp___22 = bwb_zline(l);
    }
#line 499
    return (tmp___22);
  }
#line 505
  if (mode == 4) {
#line 505
    if (rlen == -1) {
#line 505
      rlen = 128;
    }
  }
  {
#line 507
  (dev_table + req_devnumber)->mode = mode;
#line 508
  (dev_table + req_devnumber)->cfp = fp;
#line 509
  (dev_table + req_devnumber)->reclen = rlen;
#line 510
  (dev_table + req_devnumber)->next_record = 1;
#line 511
  (dev_table + req_devnumber)->loc = 0;
#line 512
  strcpy((char */* __restrict  */)((dev_table + req_devnumber)->filename), (char const   */* __restrict  */)(devname));
#line 515
  fseek((dev_table + req_devnumber)->cfp, 0L, 2);
#line 516
  tmp___23 = ftell((dev_table + req_devnumber)->cfp);
#line 516
  (dev_table + req_devnumber)->lof = (int )tmp___23;
#line 517
  fseek((dev_table + req_devnumber)->cfp, 0L, 0);
  }
#line 521
  if (mode == 4) {
    {
#line 524
    tmp___26 = CALLOC((size_t )(rlen + 1), (size_t )1, (char *)"bwb_open");
#line 524
    tmp___25 = (char *)tmp___26;
#line 524
    (dev_table + req_devnumber)->buffer = tmp___25;
    }
#line 524
    if ((unsigned long )tmp___25 == (unsigned long )((void *)0)) {
      {
#line 527
      bwb_error((char *)"in bwb_open(): failed to find memory for device buffer");
#line 531
      tmp___24 = bwb_zline(l);
      }
#line 531
      return (tmp___24);
    }
    {
#line 534
    dio_flush(req_devnumber);
    }
  }
  {
#line 550
  tmp___27 = bwb_zline(l);
  }
#line 550
  return (tmp___27);
}
}
#line 565 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
struct bwb_line *bwb_close(struct bwb_line *l ) 
{ 
  struct exp_ese *e___0 ;
  char atbuf___4[5001] ;
  int blanket_close ;
  register int n___0 ;
  struct bwb_line *tmp ;
  size_t tmp___0 ;
  bnumber tmp___1 ;
  struct bwb_line *tmp___2 ;
  struct bwb_line *tmp___3 ;
  struct bwb_line *tmp___4 ;
  int tmp___5 ;
  struct bwb_line *tmp___6 ;

  {
#line 578
  blanket_close = -1;
#line 579
  req_devnumber = 0;
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;
#line 586
    if ((int )*(l->buffer + l->position) == 44) {
#line 586
      if (blanket_close == 0) {
#line 587
        (l->position) ++;
      }
    }
    {
#line 588
    adv_ws(l->buffer, & l->position);
    }
#line 589
    if ((int )*(l->buffer + l->position) == 35) {
#line 591
      (l->position) ++;
    }
    {
#line 594
    adv_element(l->buffer, & l->position, atbuf___4);
#line 596
    pos___1 = 0;
#line 597
    e___0 = bwb_exp(atbuf___4, 0, & pos___1);
    }
#line 599
    if ((int )e___0->type == 36) {
      {
#line 602
      bwb_error((char *)"String where number was expected for device number");
#line 606
      tmp = bwb_zline(l);
      }
#line 606
      return (tmp);
    }
#line 612
    if (blanket_close == -1) {
      {
#line 613
      tmp___0 = strlen((char const   *)(atbuf___4));
      }
#line 613
      if (tmp___0 != 0UL) {
#line 613
        blanket_close = 0;
      } else {
#line 614
        blanket_close = 1;
      }
    }
#line 616
    if (blanket_close == 0) {
      {
#line 616
      tmp___1 = exp_getnval(e___0);
#line 616
      req_devnumber = (int )tmp___1;
      }
    } else {
#line 619
      req_devnumber ++;
#line 622
      n___0 = req_devnumber;
      {
#line 622
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 622
        if (! (n___0 < 16)) {
#line 622
          goto while_break___0;
        }
#line 624
        req_devnumber = -1;
#line 625
        if ((dev_table + n___0)->mode != 0) {
#line 625
          if ((dev_table + n___0)->mode != -1) {
#line 628
            req_devnumber = n___0;
#line 629
            goto while_break___0;
          }
        }
#line 622
        n___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 632
      if (req_devnumber == -1) {
#line 632
        goto while_break;
      }
    }
#line 643
    if (req_devnumber < 0) {
      {
#line 646
      bwb_error((char *)"in bwb_close(): Requested device number is out if range.");
#line 650
      tmp___2 = bwb_zline(l);
      }
#line 650
      return (tmp___2);
    } else
#line 643
    if (req_devnumber >= 16) {
      {
#line 646
      bwb_error((char *)"in bwb_close(): Requested device number is out if range.");
#line 650
      tmp___2 = bwb_zline(l);
      }
#line 650
      return (tmp___2);
    }
#line 653
    if ((dev_table + req_devnumber)->mode == 0) {
      {
#line 657
      bwb_error((char *)"in bwb_close(): Requested device number is not in use.");
#line 662
      tmp___3 = bwb_zline(l);
      }
#line 662
      return (tmp___3);
    } else
#line 653
    if ((dev_table + req_devnumber)->mode == -1) {
      {
#line 657
      bwb_error((char *)"in bwb_close(): Requested device number is not in use.");
#line 662
      tmp___3 = bwb_zline(l);
      }
#line 662
      return (tmp___3);
    }
    {
#line 673
    tmp___5 = fclose((dev_table + req_devnumber)->cfp);
    }
#line 673
    if (tmp___5 != 0) {
      {
#line 676
      bwb_error((char *)"in bwb_close(): Failed to close the device");
#line 680
      tmp___4 = bwb_zline(l);
      }
#line 680
      return (tmp___4);
    }
#line 685
    (dev_table + req_devnumber)->mode = 0;
#line 688
    if ((unsigned long )(dev_table + req_devnumber)->buffer != (unsigned long )((void *)0)) {
      {
#line 690
      FREE((void *)(dev_table + req_devnumber)->buffer, (char *)"bwb_close");
#line 691
      (dev_table + req_devnumber)->buffer = (char *)((void *)0);
      }
    }
    {
#line 696
    adv_ws(l->buffer, & l->position);
    }
#line 583
    if (! ((int )*(l->buffer + l->position) == 44)) {
#line 583
      if (! (blanket_close == 1)) {
#line 583
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 704
  tmp___6 = bwb_zline(l);
  }
#line 704
  return (tmp___6);
}
}
#line 731 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
static int position___2  ;
#line 733 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
static char *atbuf  ;
#line 734 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
static int init___43  =    0;
#line 722 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
struct bwb_line *bwb_chdir(struct bwb_line *l ) 
{ 
  int r ;
  struct exp_ese *e___0 ;
  void *tmp ;
  struct bwb_line *tmp___0 ;
  struct bwb_line *tmp___1 ;
  struct bwb_line *tmp___2 ;

  {
#line 738
  if (init___43 == 0) {
    {
#line 740
    init___43 = -1;
#line 743
    tmp = CALLOC((size_t )5001, sizeof(char ), (char *)"bwb_chdir");
#line 743
    atbuf = (char *)tmp;
    }
#line 743
    if ((unsigned long )atbuf == (unsigned long )((void *)0)) {
      {
#line 746
      bwb_error((char *)"in bwb_chdir(): failed to find memory for atbuf");
      }
    }
  }
  {
#line 755
  adv_element(l->buffer, & l->position, atbuf);
#line 764
  position___2 = 0;
#line 765
  e___0 = bwb_exp(atbuf, 0, & position___2);
  }
#line 767
  if ((int )e___0->type != 36) {
    {
#line 769
    bwb_error(err_argstr);
#line 770
    tmp___0 = bwb_zline(l);
    }
#line 770
    return (tmp___0);
  }
  {
#line 775
  str_btoc(atbuf, & e___0->sval);
#line 776
  r = chdir((char const   *)atbuf);
  }
#line 780
  if (r == -1) {
    {
#line 782
    bwb_error(err_opsys);
#line 783
    tmp___1 = bwb_zline(l);
    }
#line 783
    return (tmp___1);
  }
  {
#line 786
  tmp___2 = bwb_zline(l);
  }
#line 786
  return (tmp___2);
}
}
#line 811 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
static int position___3  ;
#line 813 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
static char *atbuf___0  ;
#line 814 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
static int init___44  =    0;
#line 802 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
struct bwb_line *bwb_rmdir(struct bwb_line *l ) 
{ 
  int r ;
  struct exp_ese *e___0 ;
  void *tmp ;
  struct bwb_line *tmp___0 ;
  struct bwb_line *tmp___1 ;

  {
#line 818
  if (init___44 == 0) {
    {
#line 820
    init___44 = -1;
#line 823
    tmp = CALLOC((size_t )5001, sizeof(char ), (char *)"bwb_rmdir");
#line 823
    atbuf___0 = (char *)tmp;
    }
#line 823
    if ((unsigned long )atbuf___0 == (unsigned long )((void *)0)) {
      {
#line 826
      bwb_error((char *)"in rmdir(): failed to find memory for atbuf");
      }
    }
  }
  {
#line 835
  adv_element(l->buffer, & l->position, atbuf___0);
#line 844
  position___3 = 0;
#line 845
  e___0 = bwb_exp(atbuf___0, 0, & position___3);
  }
#line 847
  if ((int )e___0->type != 36) {
    {
#line 849
    bwb_error(err_argstr);
#line 850
    tmp___0 = bwb_zline(l);
    }
#line 850
    return (tmp___0);
  }
  {
#line 855
  str_btoc(atbuf___0, & e___0->sval);
#line 856
  r = rmdir((char const   *)atbuf___0);
  }
#line 860
  if (r == -1) {
    {
#line 862
    bwb_error(err_opsys);
    }
  }
  {
#line 865
  tmp___1 = bwb_zline(l);
  }
#line 865
  return (tmp___1);
}
}
#line 890 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
static int position___4  ;
#line 892 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
static char *atbuf___1  ;
#line 893 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
static int init___45  =    0;
#line 881 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
struct bwb_line *bwb_mkdir(struct bwb_line *l ) 
{ 
  int r ;
  struct exp_ese *e___0 ;
  void *tmp ;
  struct bwb_line *tmp___0 ;
  struct bwb_line *tmp___1 ;

  {
#line 897
  if (init___45 == 0) {
    {
#line 899
    init___45 = -1;
#line 902
    tmp = CALLOC((size_t )5001, sizeof(char ), (char *)"bwb_mkdir");
#line 902
    atbuf___1 = (char *)tmp;
    }
#line 902
    if ((unsigned long )atbuf___1 == (unsigned long )((void *)0)) {
      {
#line 905
      bwb_error((char *)"in bwb_mkdir(): failed to find memory for atbuf");
      }
    }
  }
  {
#line 914
  adv_element(l->buffer, & l->position, atbuf___1);
#line 923
  position___4 = 0;
#line 924
  e___0 = bwb_exp(atbuf___1, 0, & position___4);
  }
#line 926
  if ((int )e___0->type != 36) {
    {
#line 928
    bwb_error(err_argstr);
#line 929
    tmp___0 = bwb_zline(l);
    }
#line 929
    return (tmp___0);
  }
  {
#line 934
  str_btoc(atbuf___1, & e___0->sval);
#line 938
  r = mkdir((char const   *)atbuf___1, (__mode_t )644);
  }
#line 943
  if (r == -1) {
    {
#line 945
    bwb_error(err_opsys);
    }
  }
  {
#line 948
  tmp___1 = bwb_zline(l);
  }
#line 948
  return (tmp___1);
}
}
#line 973 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
static int position___5  ;
#line 975 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
static char *atbuf___2  ;
#line 976 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
static int init___46  =    0;
#line 964 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
struct bwb_line *bwb_kill(struct bwb_line *l ) 
{ 
  int r ;
  struct exp_ese *e___0 ;
  void *tmp ;
  struct bwb_line *tmp___0 ;
  struct bwb_line *tmp___1 ;

  {
#line 980
  if (init___46 == 0) {
    {
#line 982
    init___46 = -1;
#line 985
    tmp = CALLOC((size_t )5001, sizeof(char ), (char *)"bwb_kill");
#line 985
    atbuf___2 = (char *)tmp;
    }
#line 985
    if ((unsigned long )atbuf___2 == (unsigned long )((void *)0)) {
      {
#line 988
      bwb_error((char *)"in bwb_kill(): failed to find memory for atbuf");
      }
    }
  }
  {
#line 997
  adv_element(l->buffer, & l->position, atbuf___2);
#line 1006
  position___5 = 0;
#line 1007
  e___0 = bwb_exp(atbuf___2, 0, & position___5);
  }
#line 1009
  if ((int )e___0->type != 36) {
    {
#line 1011
    bwb_error(err_argstr);
#line 1012
    tmp___0 = bwb_zline(l);
    }
#line 1012
    return (tmp___0);
  }
  {
#line 1017
  str_btoc(atbuf___2, & e___0->sval);
#line 1018
  r = unlink((char const   *)atbuf___2);
  }
#line 1022
  if (r == -1) {
    {
#line 1024
    bwb_error(err_opsys);
    }
  }
  {
#line 1027
  tmp___1 = bwb_zline(l);
  }
#line 1027
  return (tmp___1);
}
}
#line 1056 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
static int position___6  ;
#line 1058 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
static char *atbuf___3  ;
#line 1059 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
static char *btbuf  ;
#line 1060 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
static int init___47  =    0;
#line 1047 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
struct bwb_line *bwb_name(struct bwb_line *l ) 
{ 
  int r ;
  struct exp_ese *e___0 ;
  void *tmp ;
  void *tmp___0 ;
  struct bwb_line *tmp___1 ;
  struct bwb_line *tmp___2 ;
  int tmp___3 ;
  struct bwb_line *tmp___4 ;
  struct bwb_line *tmp___5 ;

  {
#line 1064
  if (init___47 == 0) {
    {
#line 1066
    init___47 = -1;
#line 1069
    tmp = CALLOC((size_t )5001, sizeof(char ), (char *)"bwb_name");
#line 1069
    atbuf___3 = (char *)tmp;
    }
#line 1069
    if ((unsigned long )atbuf___3 == (unsigned long )((void *)0)) {
      {
#line 1072
      bwb_error((char *)"in bwb_name(): failed to find memory for atbuf");
      }
    }
    {
#line 1078
    tmp___0 = CALLOC((size_t )5001, sizeof(char ), (char *)"bwb_name");
#line 1078
    btbuf = (char *)tmp___0;
    }
#line 1078
    if ((unsigned long )btbuf == (unsigned long )((void *)0)) {
      {
#line 1081
      bwb_error((char *)"in bwb_name(): failed to find memory for btbuf");
      }
    }
  }
  {
#line 1090
  adv_element(l->buffer, & l->position, atbuf___3);
#line 1094
  position___6 = 0;
#line 1095
  e___0 = bwb_exp(atbuf___3, 0, & position___6);
  }
#line 1097
  if ((int )e___0->type != 36) {
    {
#line 1099
    bwb_error(err_argstr);
#line 1100
    tmp___1 = bwb_zline(l);
    }
#line 1100
    return (tmp___1);
  }
  {
#line 1107
  str_btoc(atbuf___3, & e___0->sval);
#line 1116
  adv_element(l->buffer, & l->position, btbuf);
#line 1117
  bwb_strtoupper(btbuf);
#line 1124
  tmp___3 = strcmp((char const   *)btbuf, "AS");
  }
#line 1124
  if (tmp___3 != 0) {
    {
#line 1126
    bwb_error(err_syntax);
#line 1127
    tmp___2 = bwb_zline(l);
    }
#line 1127
    return (tmp___2);
  }
  {
#line 1132
  adv_element(l->buffer, & l->position, btbuf);
#line 1136
  position___6 = 0;
#line 1137
  e___0 = bwb_exp(btbuf, 0, & position___6);
  }
#line 1139
  if ((int )e___0->type != 36) {
    {
#line 1141
    bwb_error(err_argstr);
#line 1142
    tmp___4 = bwb_zline(l);
    }
#line 1142
    return (tmp___4);
  }
  {
#line 1145
  str_btoc(btbuf, & e___0->sval);
#line 1154
  r = rename((char const   *)atbuf___3, (char const   *)btbuf);
  }
#line 1158
  if (r != 0) {
    {
#line 1160
    bwb_error(err_opsys);
    }
  }
  {
#line 1163
  tmp___5 = bwb_zline(l);
  }
#line 1163
  return (tmp___5);
}
}
#line 1177 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
struct bwb_line *bwb_field(struct bwb_line *l ) 
{ 
  int dev_number ;
  int length ;
  struct exp_ese *e___0 ;
  struct bwb_variable *v___0 ;
  bstring *b___4 ;
  int current_pos ;
  char atbuf___4[5001] ;
  struct bwb_line *tmp ;
  bnumber tmp___0 ;
  struct bwb_line *tmp___1 ;
  struct bwb_line *tmp___2 ;
  bnumber tmp___3 ;
  struct bwb_line *tmp___4 ;
  int tmp___5 ;
  struct bwb_line *tmp___6 ;
  struct bwb_line *tmp___7 ;
  struct bwb_line *tmp___8 ;

  {
  {
#line 1193
  current_pos = 0;
#line 1197
  adv_ws(l->buffer, & l->position);
  }
#line 1198
  if ((int )*(l->buffer + l->position) == 35) {
#line 1200
    (l->position) ++;
  }
  {
#line 1203
  adv_element(l->buffer, & l->position, atbuf___4);
#line 1210
  pos___1 = 0;
#line 1211
  e___0 = bwb_exp(atbuf___4, 0, & pos___1);
  }
#line 1213
  if ((int )e___0->type != 1) {
    {
#line 1216
    bwb_error((char *)"in bwb_field(): Number was expected for device number");
#line 1220
    tmp = bwb_zline(l);
    }
#line 1220
    return (tmp);
  }
  {
#line 1223
  tmp___0 = exp_getnval(e___0);
#line 1223
  dev_number = (int )tmp___0;
  }
#line 1232
  if ((dev_table + dev_number)->mode == 0) {
    {
#line 1236
    bwb_error((char *)"in bwb_field(): Requested device number is not in use.");
#line 1240
    tmp___1 = bwb_zline(l);
    }
#line 1240
    return (tmp___1);
  } else
#line 1232
  if ((dev_table + req_devnumber)->mode == -1) {
    {
#line 1236
    bwb_error((char *)"in bwb_field(): Requested device number is not in use.");
#line 1240
    tmp___1 = bwb_zline(l);
    }
#line 1240
    return (tmp___1);
  }
  {
#line 1245
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1250
    adv_ws(l->buffer, & l->position);
    }
#line 1251
    if ((int )*(l->buffer + l->position) == 44) {
#line 1253
      (l->position) ++;
    }
    {
#line 1258
    adv_element(l->buffer, & l->position, atbuf___4);
#line 1260
    pos___1 = 0;
#line 1261
    e___0 = bwb_exp(atbuf___4, 0, & pos___1);
    }
#line 1263
    if ((int )e___0->type != 1) {
      {
#line 1266
      bwb_error((char *)"in bwb_field(): number value for field size not found");
#line 1270
      tmp___2 = bwb_zline(l);
      }
#line 1270
      return (tmp___2);
    }
    {
#line 1273
    tmp___3 = exp_getnval(e___0);
#line 1273
    length = (int )tmp___3;
#line 1283
    adv_element(l->buffer, & l->position, atbuf___4);
#line 1284
    bwb_strtoupper(atbuf___4);
#line 1291
    tmp___5 = strncmp((char const   *)(atbuf___4), "AS", (size_t )2);
    }
#line 1291
    if (tmp___5 != 0) {
      {
#line 1294
      bwb_error((char *)"in bwb_field(): AS statement not found");
#line 1298
      tmp___4 = bwb_zline(l);
      }
#line 1298
      return (tmp___4);
    }
    {
#line 1303
    adv_element(l->buffer, & l->position, atbuf___4);
#line 1304
    v___0 = var_find(atbuf___4);
    }
#line 1306
    if (v___0->type != 36) {
      {
#line 1309
      bwb_error((char *)"in bwb_field(): string variable name not found");
#line 1313
      tmp___6 = bwb_zline(l);
      }
#line 1313
      return (tmp___6);
    }
#line 1324
    if (current_pos + length > (dev_table + dev_number)->reclen) {
      {
#line 1327
      bwb_error((char *)"in bwb_field(): record length exceeded");
#line 1331
      tmp___7 = bwb_zline(l);
      }
#line 1331
      return (tmp___7);
    }
    {
#line 1336
    b___4 = var_findsval(v___0, v___0->array_pos);
#line 1347
    b___4->sbuffer = (dev_table + dev_number)->buffer + current_pos;
#line 1348
    b___4->length = (unsigned int )length;
#line 1349
    b___4->rab = -1;
#line 1351
    current_pos += length;
#line 1361
    adv_ws(l->buffer, & l->position);
    }
#line 1245
    if (! ((int )*(l->buffer + l->position) == 44)) {
#line 1245
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1369
  tmp___8 = bwb_zline(l);
  }
#line 1369
  return (tmp___8);
}
}
#line 1385 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
struct bwb_line *bwb_lset(struct bwb_line *l ) 
{ 
  struct bwb_line *tmp ;

  {
  {
#line 1393
  tmp = dio_lrset(l, 0);
  }
#line 1393
  return (tmp);
}
}
#line 1408 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
struct bwb_line *bwb_rset(struct bwb_line *l ) 
{ 
  struct bwb_line *tmp ;

  {
  {
#line 1416
  tmp = dio_lrset(l, -1);
  }
#line 1416
  return (tmp);
}
}
#line 1429 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
static struct bwb_line *dio_lrset(struct bwb_line *l , int rset ) 
{ 
  char varname[41] ;
  bstring *d ;
  bstring *s___0 ;
  int *pp___0 ;
  int n_params___0 ;
  int p___0 ;
  register int n___0 ;
  register int i ;
  int startpos___0 ;
  struct exp_ese *e___0 ;
  struct bwb_line *tmp ;

  {
  {
#line 1449
  bwb_getvarname(l->buffer, varname, & l->position);
#line 1451
  v = var_find(varname);
  }
#line 1453
  if ((unsigned long )v == (unsigned long )((void *)0)) {
    {
#line 1456
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in dio_lrset(): failed to find variable");
#line 1457
    bwb_error(bwb_ebuf);
    }
  }
#line 1463
  if (v->type != 36) {
    {
#line 1466
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in dio_lrset(): assignment must be to string variable");
#line 1467
    bwb_error(bwb_ebuf);
    }
  }
#line 1475
  pos___1 = 0;
#line 1476
  if (v->dimensions == 1) {
#line 1476
    if (*(v->array_sizes + 0) == 1) {
#line 1483
      n_params___0 = 1;
#line 1484
      pp___0 = & p___0;
#line 1485
      *(pp___0 + 0) = dim_base;
    } else {
      {
#line 1494
      dim_getparams(l->buffer, & l->position, & n_params___0, & pp___0);
      }
    }
  } else {
    {
#line 1494
    dim_getparams(l->buffer, & l->position, & n_params___0, & pp___0);
    }
  }
#line 1497
  (exps + expsc)->pos_adv = pos___1;
#line 1498
  n___0 = 0;
  {
#line 1498
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1498
    if (! (n___0 < v->dimensions)) {
#line 1498
      goto while_break;
    }
#line 1500
    *(v->array_pos + n___0) = *(pp___0 + n___0);
#line 1498
    n___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1505
  d = var_findsval(v, pp___0);
#line 1509
  adv_ws(l->buffer, & l->position);
  }
#line 1510
  if ((int )*(l->buffer + l->position) != 61) {
    {
#line 1513
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in dio_lrset(): failed to find equal sign");
#line 1514
    bwb_error(bwb_ebuf);
    }
  }
  {
#line 1519
  (l->position) ++;
#line 1520
  adv_ws(l->buffer, & l->position);
#line 1524
  e___0 = bwb_exp(l->buffer, 0, & l->position);
#line 1525
  s___0 = exp_getsval(e___0);
#line 1529
  startpos___0 = 0;
  }
#line 1530
  if (rset == -1) {
#line 1532
    if (s___0->length < d->length) {
#line 1534
      startpos___0 = (int )(d->length - s___0->length);
    }
  }
#line 1546
  i = 0;
#line 1547
  n___0 = startpos___0;
  {
#line 1547
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1547
    if (i < (int )s___0->length) {
#line 1547
      if (! (n___0 < (int )d->length)) {
#line 1547
        goto while_break___0;
      }
    } else {
#line 1547
      goto while_break___0;
    }
#line 1549
    *(d->sbuffer + n___0) = *(s___0->sbuffer + i);
#line 1550
    i ++;
#line 1547
    n___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1555
  tmp = bwb_zline(l);
  }
#line 1555
  return (tmp);
}
}
#line 1571 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
struct bwb_line *bwb_get(struct bwb_line *l ) 
{ 
  int dev_number ;
  int rec_number ;
  register int i ;
  struct exp_ese *e___0 ;
  char atbuf___4[5001] ;
  long offset ;
  struct bwb_line *tmp ;
  bnumber tmp___0 ;
  struct bwb_line *tmp___1 ;
  bnumber tmp___2 ;
  struct bwb_line *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct bwb_line *tmp___6 ;

  {
  {
#line 1588
  adv_ws(l->buffer, & l->position);
  }
#line 1589
  if ((int )*(l->buffer + l->position) == 35) {
#line 1591
    (l->position) ++;
  }
  {
#line 1594
  adv_element(l->buffer, & l->position, atbuf___4);
#line 1596
  pos___1 = 0;
#line 1597
  e___0 = bwb_exp(atbuf___4, 0, & pos___1);
  }
#line 1599
  if ((int )e___0->type != 1) {
    {
#line 1602
    bwb_error((char *)"in bwb_get(): Number was expected for device number");
#line 1606
    tmp = bwb_zline(l);
    }
#line 1606
    return (tmp);
  }
  {
#line 1609
  tmp___0 = exp_getnval(e___0);
#line 1609
  dev_number = (int )tmp___0;
  }
#line 1618
  if ((dev_table + dev_number)->mode == 0) {
    {
#line 1622
    bwb_error((char *)"in bwb_get(): Requested device number is not in use.");
#line 1626
    tmp___1 = bwb_zline(l);
    }
#line 1626
    return (tmp___1);
  } else
#line 1618
  if ((dev_table + req_devnumber)->mode == -1) {
    {
#line 1622
    bwb_error((char *)"in bwb_get(): Requested device number is not in use.");
#line 1626
    tmp___1 = bwb_zline(l);
    }
#line 1626
    return (tmp___1);
  }
  {
#line 1631
  adv_ws(l->buffer, & l->position);
  }
#line 1632
  if ((int )*(l->buffer + l->position) == 44) {
    {
#line 1634
    (l->position) ++;
#line 1638
    adv_element(l->buffer, & l->position, atbuf___4);
#line 1640
    pos___1 = 0;
#line 1641
    e___0 = bwb_exp(atbuf___4, 0, & pos___1);
#line 1642
    tmp___2 = exp_getnval(e___0);
#line 1642
    rec_number = (int )tmp___2;
    }
  } else {
#line 1648
    rec_number = (dev_table + dev_number)->next_record;
  }
  {
#line 1659
  offset = (long )((rec_number - 1) * (dev_table + dev_number)->reclen);
#line 1661
  tmp___4 = fseek((dev_table + dev_number)->cfp, offset, 0);
  }
#line 1661
  if (tmp___4 != 0) {
    {
#line 1664
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_get(): fseek() failed, rec number <%d> offset <%ld>",
            rec_number, (long )((rec_number - 1) * (dev_table + dev_number)->reclen));
#line 1666
    bwb_error(bwb_ebuf);
#line 1670
    tmp___3 = bwb_zline(l);
    }
#line 1670
    return (tmp___3);
  }
#line 1675
  (dev_table + dev_number)->loc = (int )offset;
#line 1676
  i = 0;
  {
#line 1676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1676
    if (! (i < (dev_table + dev_number)->reclen)) {
#line 1676
      goto while_break;
    }
    {
#line 1678
    tmp___5 = fgetc((dev_table + dev_number)->cfp);
#line 1678
    *((dev_table + dev_number)->buffer + i) = (char )tmp___5;
#line 1680
    ((dev_table + dev_number)->loc) ++;
#line 1676
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1685
  (dev_table + dev_number)->next_record = rec_number + 1;
#line 1687
  tmp___6 = bwb_zline(l);
  }
#line 1687
  return (tmp___6);
}
}
#line 1703 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
struct bwb_line *bwb_put(struct bwb_line *l ) 
{ 
  int dev_number ;
  int rec_number ;
  register int i ;
  struct exp_ese *e___0 ;
  char atbuf___4[5001] ;
  long offset ;
  struct bwb_line *tmp ;
  bnumber tmp___0 ;
  struct bwb_line *tmp___1 ;
  bnumber tmp___2 ;
  struct bwb_line *tmp___3 ;
  int tmp___4 ;
  struct bwb_line *tmp___5 ;

  {
  {
#line 1720
  adv_ws(l->buffer, & l->position);
  }
#line 1721
  if ((int )*(l->buffer + l->position) == 35) {
#line 1723
    (l->position) ++;
  }
  {
#line 1726
  adv_element(l->buffer, & l->position, atbuf___4);
#line 1730
  pos___1 = 0;
#line 1731
  e___0 = bwb_exp(atbuf___4, 0, & pos___1);
  }
#line 1733
  if ((int )e___0->type != 1) {
    {
#line 1736
    bwb_error((char *)"in bwb_put(): Number was expected for device number");
#line 1740
    tmp = bwb_zline(l);
    }
#line 1740
    return (tmp);
  }
  {
#line 1743
  tmp___0 = exp_getnval(e___0);
#line 1743
  dev_number = (int )tmp___0;
  }
#line 1752
  if ((dev_table + dev_number)->mode == 0) {
    {
#line 1756
    bwb_error((char *)"in bwb_put(): Requested device number is not in use.");
#line 1760
    tmp___1 = bwb_zline(l);
    }
#line 1760
    return (tmp___1);
  } else
#line 1752
  if ((dev_table + req_devnumber)->mode == -1) {
    {
#line 1756
    bwb_error((char *)"in bwb_put(): Requested device number is not in use.");
#line 1760
    tmp___1 = bwb_zline(l);
    }
#line 1760
    return (tmp___1);
  }
  {
#line 1765
  adv_ws(l->buffer, & l->position);
  }
#line 1766
  if ((int )*(l->buffer + l->position) == 44) {
    {
#line 1768
    (l->position) ++;
#line 1772
    adv_element(l->buffer, & l->position, atbuf___4);
#line 1779
    pos___1 = 0;
#line 1780
    e___0 = bwb_exp(atbuf___4, 0, & pos___1);
#line 1787
    tmp___2 = exp_getnval(e___0);
#line 1787
    rec_number = (int )tmp___2;
    }
  } else {
#line 1793
    rec_number = (dev_table + dev_number)->next_record;
  }
  {
#line 1804
  offset = (long )((rec_number - 1) * (dev_table + dev_number)->reclen);
#line 1806
  tmp___4 = fseek((dev_table + dev_number)->cfp, offset, 0);
  }
#line 1806
  if (tmp___4 != 0) {
    {
#line 1809
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_get(): fseek() failed, rec number <%d> offset <%ld>",
            rec_number, (long )((rec_number - 1) * (dev_table + dev_number)->reclen));
#line 1811
    bwb_error(bwb_ebuf);
#line 1815
    tmp___3 = bwb_zline(l);
    }
#line 1815
    return (tmp___3);
  }
#line 1827
  (dev_table + dev_number)->loc = (int )offset;
#line 1828
  i = 0;
  {
#line 1828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1828
    if (! (i < (dev_table + dev_number)->reclen)) {
#line 1828
      goto while_break;
    }
    {
#line 1830
    fputc((int )*((dev_table + dev_number)->buffer + i), (dev_table + dev_number)->cfp);
#line 1835
    ((dev_table + dev_number)->loc) ++;
#line 1828
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1846
  dio_flush(dev_number);
#line 1850
  (dev_table + dev_number)->next_record = rec_number + 1;
#line 1852
  tmp___5 = bwb_zline(l);
  }
#line 1852
  return (tmp___5);
}
}
#line 1866 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_dio.c"
static int dio_flush(int dev_number ) 
{ 
  register int n___0 ;

  {
#line 1876
  if ((dev_table + dev_number)->mode != 4) {
    {
#line 1879
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in dio_flush(): only random-access buffers can be flushed");
#line 1880
    bwb_error(bwb_ebuf);
    }
  }
#line 1888
  n___0 = 0;
  {
#line 1888
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1888
    if (! (n___0 < (dev_table + req_devnumber)->reclen)) {
#line 1888
      goto while_break;
    }
#line 1890
    *((dev_table + req_devnumber)->buffer + n___0) = (char )' ';
#line 1888
    n___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1893
  return (-1);
}
}
#line 140 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 47 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_inp.c"
static struct bwb_line *bwb_xinp(struct bwb_line *l , FILE *f ) ;
#line 48
static struct bwb_line *inp_str(struct bwb_line *l , char *input_buffer , char *var_list ,
                                int *vl_position ) ;
#line 50
static int inp_const(char *m_buffer , char *s_buffer___2 , int *position___7 ) ;
#line 51
static int inp_assign(char *b___4 , struct bwb_variable *v___0 ) ;
#line 52
static int inp_advws(FILE *f ) ;
#line 53
static int inp_xgetc(FILE *f , int is_string ) ;
#line 54
static int inp_eatcomma(FILE *f ) ;
#line 55
static bnumber inp_numconst(char *expression ) ;
#line 67 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_inp.c"
static int char_saved  =    0;
#line 68 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_inp.c"
static int cs  ;
#line 69 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_inp.c"
static int last_inp_adv_rval  =    0;
#line 83 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_inp.c"
struct bwb_line *bwb_read(struct bwb_line *l ) 
{ 
  int pos___2 ;
  register int n___0 ;
  int main_loop ;
  int adv_loop ;
  struct bwb_variable *v___0 ;
  int n_params___0 ;
  int *pp___0 ;
  char tbuf___20[5001] ;
  struct bwb_line *tmp ;
  struct bwb_line *tmp___0 ;

  {
#line 107
  main_loop = -1;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! (main_loop == -1)) {
#line 108
      goto while_break;
    }
#line 113
    adv_loop = -1;
    {
#line 114
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 114
      if (! (adv_loop == -1)) {
#line 114
        goto while_break___0;
      }
      {
#line 127
      if ((int )*(l->buffer + l->position) == 9) {
#line 127
        goto case_9;
      }
#line 127
      if ((int )*(l->buffer + l->position) == 32) {
#line 127
        goto case_9;
      }
#line 127
      if ((int )*(l->buffer + l->position) == 44) {
#line 127
        goto case_9;
      }
#line 133
      if ((int )*(l->buffer + l->position) == 0) {
#line 133
        goto case_0;
      }
#line 133
      if ((int )*(l->buffer + l->position) == 13) {
#line 133
        goto case_0;
      }
#line 133
      if ((int )*(l->buffer + l->position) == 10) {
#line 133
        goto case_0;
      }
#line 133
      if ((int )*(l->buffer + l->position) == 58) {
#line 133
        goto case_0;
      }
#line 137
      goto switch_default;
      case_9: /* CIL Label */ 
      case_32: /* CIL Label */ 
      case_44: /* CIL Label */ 
#line 128
      (l->position) ++;
#line 129
      goto switch_break;
      case_0: /* CIL Label */ 
      case_13: /* CIL Label */ 
      case_10: /* CIL Label */ 
      case_58: /* CIL Label */ 
#line 134
      adv_loop = 0;
#line 135
      main_loop = 0;
#line 136
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 138
      adv_loop = 0;
#line 139
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 151
    if (main_loop == -1) {
      {
#line 156
      bwb_getvarname(l->buffer, tbuf___20, & l->position);
#line 157
      inp_adv(l->buffer, & l->position);
#line 158
      v___0 = var_find(tbuf___20);
#line 171
      inp_adv(data_line->buffer, & data_pos);
      }
      {
#line 179
      if ((int )*(data_line->buffer + data_pos) == 13) {
#line 179
        goto case_13___0;
      }
#line 179
      if ((int )*(data_line->buffer + data_pos) == 10) {
#line 179
        goto case_13___0;
      }
#line 179
      if ((int )*(data_line->buffer + data_pos) == 0) {
#line 179
        goto case_13___0;
      }
#line 175
      goto switch_break___0;
      case_13___0: /* CIL Label */ 
      case_10___0: /* CIL Label */ 
      case_0___0: /* CIL Label */ 
      {
#line 181
      data_line = data_line->next;
#line 185
      pos___2 = 0;
#line 186
      line_start(data_line->buffer, & pos___2, & data_line->lnpos, & data_line->lnum,
                 & data_line->cmdpos, & data_line->cmdnum, & data_line->startpos);
#line 192
      data_pos = data_line->startpos;
      }
#line 200
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 203
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 203
        if (! ((unsigned long )bwb_cmdtable[data_line->cmdnum].vector != (unsigned long )(& bwb_data))) {
#line 203
          goto while_break___1;
        }
#line 206
        if ((unsigned long )data_line == (unsigned long )(& bwb_end)) {
#line 208
          data_line = bwb_start.next;
        } else {
#line 213
          data_line = data_line->next;
        }
        {
#line 216
        pos___2 = 0;
#line 217
        line_start(data_line->buffer, & pos___2, & data_line->lnpos, & data_line->lnum,
                   & data_line->cmdpos, & data_line->cmdnum, & data_line->startpos);
#line 223
        data_pos = data_line->startpos;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 235
      adv_loop = -1;
      {
#line 236
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 236
        if (! (adv_loop == -1)) {
#line 236
          goto while_break___2;
        }
        {
#line 242
        if ((int )*(data_line->buffer + data_pos) == 13) {
#line 242
          goto case_13___1;
        }
#line 242
        if ((int )*(data_line->buffer + data_pos) == 10) {
#line 242
          goto case_13___1;
        }
#line 242
        if ((int )*(data_line->buffer + data_pos) == 0) {
#line 242
          goto case_13___1;
        }
#line 246
        if ((int )*(data_line->buffer + data_pos) == 9) {
#line 246
          goto case_9___0;
        }
#line 246
        if ((int )*(data_line->buffer + data_pos) == 32) {
#line 246
          goto case_9___0;
        }
#line 249
        goto switch_default___0;
        case_13___1: /* CIL Label */ 
        case_10___1: /* CIL Label */ 
        case_0___1: /* CIL Label */ 
        {
#line 243
        bwb_error(err_od);
#line 244
        tmp = bwb_zline(l);
        }
#line 244
        return (tmp);
        case_9___0: /* CIL Label */ 
        case_32___0: /* CIL Label */ 
#line 247
        data_pos ++;
#line 248
        goto switch_break___1;
        switch_default___0: /* CIL Label */ 
#line 250
        adv_loop = 0;
#line 251
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 261
      inp_const(data_line->buffer, tbuf___20, & data_pos);
#line 270
      adv_ws(l->buffer, & l->position);
      }
#line 271
      if ((int )*(l->buffer + l->position) == 40) {
        {
#line 278
        dim_getparams(l->buffer, & l->position, & n_params___0, & pp___0);
#line 279
        n___0 = 0;
        }
        {
#line 279
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 279
          if (! (n___0 < v___0->dimensions)) {
#line 279
            goto while_break___3;
          }
#line 281
          *(v___0->array_pos + n___0) = *(pp___0 + n___0);
#line 279
          n___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      {
#line 298
      inp_assign(tbuf___20, v___0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 310
  tmp___0 = bwb_zline(l);
  }
#line 310
  return (tmp___0);
}
}
#line 330 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_inp.c"
struct bwb_line *bwb_data(struct bwb_line *l ) 
{ 
  struct bwb_line *tmp ;

  {
  {
#line 340
  adv_eos(l->buffer, & l->position);
#line 343
  tmp = bwb_zline(l);
  }
#line 343
  return (tmp);
}
}
#line 358 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_inp.c"
struct bwb_line *bwb_restore(struct bwb_line *l ) 
{ 
  struct bwb_line *r ;
  struct bwb_line *r_line ;
  int n___0 ;
  int pos___2 ;
  char tbuf___20[5001] ;
  struct bwb_line *tmp ;
  int tmp___0 ;
  struct bwb_line *tmp___1 ;
  struct bwb_line *tmp___2 ;
  struct bwb_line *tmp___3 ;

  {
  {
#line 374
  adv_element(l->buffer, & l->position, tbuf___20);
#line 379
  tmp___0 = is_numconst(tbuf___20);
  }
#line 379
  if (tmp___0 != -1) {
    {
#line 381
    data_line = & bwb_start;
#line 382
    data_pos = 0;
#line 387
    tmp = bwb_zline(l);
    }
#line 387
    return (tmp);
  }
  {
#line 392
  n___0 = atoi((char const   *)(tbuf___20));
#line 399
  r_line = (struct bwb_line *)((void *)0);
#line 400
  r = bwb_start.next;
  }
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! ((unsigned long )r != (unsigned long )(& bwb_end))) {
#line 400
      goto while_break;
    }
#line 403
    if (r->number == n___0) {
#line 405
      r_line = r;
    }
#line 400
    r = r->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 409
  if ((unsigned long )r_line == (unsigned long )((void *)0)) {
    {
#line 412
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"at line %d: Can\'t find line number for RESTORE.",
            l->number);
#line 414
    bwb_error(bwb_ebuf);
#line 419
    tmp___1 = bwb_zline(l);
    }
#line 419
    return (tmp___1);
  }
  {
#line 424
  pos___2 = 0;
#line 425
  line_start(r_line->buffer, & pos___2, & r_line->lnpos, & r_line->lnum, & r_line->cmdpos,
             & r_line->cmdnum, & r_line->startpos);
  }
#line 434
  if ((unsigned long )bwb_cmdtable[r_line->cmdnum].vector != (unsigned long )(& bwb_data)) {
    {
#line 437
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"at line %d: Line %d is not a DATA statement.",
            l->number, r_line->number);
#line 439
    bwb_error(bwb_ebuf);
#line 443
    tmp___2 = bwb_zline(l);
    }
#line 443
    return (tmp___2);
  }
  {
#line 448
  data_line = r_line;
#line 449
  data_pos = data_line->startpos;
#line 451
  tmp___3 = bwb_zline(l);
  }
#line 451
  return (tmp___3);
}
}
#line 481 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_inp.c"
static char tbuf___19[5001]  ;
#line 482 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_inp.c"
static char pstring[5001]  ;
#line 467 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_inp.c"
struct bwb_line *bwb_input(struct bwb_line *l ) 
{ 
  FILE *fp ;
  int pos___2 ;
  int req_devnumber___0 ;
  struct exp_ese *v___0 ;
  int is_prompt ;
  int suppress_qm ;
  struct bwb_line *tmp ;
  bnumber tmp___0 ;
  struct bwb_line *tmp___1 ;
  struct bwb_line *tmp___2 ;
  struct bwb_line *tmp___3 ;
  struct bwb_line *tmp___4 ;
  int *tmp___5 ;
  struct bwb_line *tmp___6 ;

  {
  {
#line 489
  pstring[0] = (char )'\000';
#line 495
  adv_ws(l->buffer, & l->position);
  }
#line 497
  if ((int )*(l->buffer + l->position) == 35) {
    {
#line 499
    (l->position) ++;
#line 500
    adv_element(l->buffer, & l->position, tbuf___19);
#line 501
    pos___2 = 0;
#line 502
    v___0 = bwb_exp(tbuf___19, 0, & pos___2);
#line 503
    adv_ws(l->buffer, & l->position);
    }
#line 504
    if ((int )*(l->buffer + l->position) == 44) {
#line 506
      (l->position) ++;
    } else {
      {
#line 511
      bwb_error((char *)"in bwb_input(): no comma after#n");
#line 515
      tmp = bwb_zline(l);
      }
#line 515
      return (tmp);
    }
    {
#line 518
    tmp___0 = exp_getnval(v___0);
#line 518
    req_devnumber___0 = (int )tmp___0;
    }
#line 528
    if (req_devnumber___0 < 0) {
      {
#line 531
      bwb_error((char *)"in bwb_input(): Requested device number is out if range.");
#line 535
      tmp___1 = bwb_zline(l);
      }
#line 535
      return (tmp___1);
    } else
#line 528
    if (req_devnumber___0 >= 16) {
      {
#line 531
      bwb_error((char *)"in bwb_input(): Requested device number is out if range.");
#line 535
      tmp___1 = bwb_zline(l);
      }
#line 535
      return (tmp___1);
    }
#line 538
    if ((dev_table + req_devnumber___0)->mode == 0) {
      {
#line 542
      bwb_error((char *)"in bwb_input(): Requested device number is not open.");
#line 547
      tmp___2 = bwb_zline(l);
      }
#line 547
      return (tmp___2);
    } else
#line 538
    if ((dev_table + req_devnumber___0)->mode == -1) {
      {
#line 542
      bwb_error((char *)"in bwb_input(): Requested device number is not open.");
#line 547
      tmp___2 = bwb_zline(l);
      }
#line 547
      return (tmp___2);
    }
#line 550
    if ((dev_table + req_devnumber___0)->mode != 2) {
      {
#line 553
      bwb_error((char *)"in bwb_input(): Requested device is not open for INPUT.");
#line 558
      tmp___3 = bwb_zline(l);
      }
#line 558
      return (tmp___3);
    }
#line 563
    fp = (dev_table + req_devnumber___0)->cfp;
  } else {
#line 568
    fp = stdin;
  }
#line 577
  if ((unsigned long )fp != (unsigned long )stdin) {
    {
#line 579
    tmp___4 = bwb_xinp(l, fp);
    }
#line 579
    return (tmp___4);
  }
  {
#line 587
  is_prompt = 0;
#line 587
  suppress_qm = is_prompt;
#line 589
  adv_ws(l->buffer, & l->position);
  }
  {
#line 593
  if ((int )*(l->buffer + l->position) == 34) {
#line 593
    goto case_34;
  }
#line 597
  if ((int )*(l->buffer + l->position) == 59) {
#line 597
    goto case_59;
  }
#line 608
  if ((int )*(l->buffer + l->position) == 44) {
#line 608
    goto case_44;
  }
#line 591
  goto switch_break;
  case_34: /* CIL Label */ 
#line 594
  is_prompt = -1;
#line 595
  goto switch_break;
  case_59: /* CIL Label */ 
#line 604
  is_prompt = -1;
#line 605
  (l->position) ++;
#line 606
  goto switch_break;
  case_44: /* CIL Label */ 
#line 616
  suppress_qm = -1;
#line 617
  (l->position) ++;
#line 618
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 623
  if (is_prompt == -1) {
    {
#line 628
    inp_const(l->buffer, tbuf___19, & l->position);
#line 640
    suppress_qm = last_inp_adv_rval;
#line 644
    strncpy((char */* __restrict  */)(pstring), (char const   */* __restrict  */)(tbuf___19),
            (size_t )5000);
    }
  }
#line 650
  if (suppress_qm != -1) {
    {
#line 652
    strncat((char */* __restrict  */)(pstring), (char const   */* __restrict  */)"? ",
            (size_t )5000);
    }
  }
  {
#line 662
  bwx_input(pstring, tbuf___19);
#line 663
  bwb_stripcr(tbuf___19);
#line 674
  tmp___5 = prn_getcol(stdout);
#line 674
  *tmp___5 = 1;
#line 676
  tmp___6 = inp_str(l, tbuf___19, l->buffer, & l->position);
  }
#line 676
  return (tmp___6);
}
}
#line 690 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_inp.c"
static struct bwb_line *bwb_xinp(struct bwb_line *l , FILE *f ) 
{ 
  int loop ;
  struct bwb_variable *v___0 ;
  char c ;
  register int n___0 ;
  int *pp___0 ;
  int n_params___0 ;
  char tbuf___20[5001] ;
  int tmp ;
  int tmp___0 ;
  bstring *tmp___1 ;
  int tmp___2 ;
  bnumber *tmp___3 ;
  struct bwb_line *tmp___4 ;

  {
#line 715
  loop = -1;
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;
#line 716
    if (! (loop == -1)) {
#line 716
      goto while_break;
    }
    {
#line 721
    bwb_getvarname(l->buffer, tbuf___20, & l->position);
#line 722
    v___0 = var_find(tbuf___20);
#line 732
    adv_ws(l->buffer, & l->position);
    }
#line 733
    if ((int )*(l->buffer + l->position) == 40) {
      {
#line 740
      dim_getparams(l->buffer, & l->position, & n_params___0, & pp___0);
#line 741
      n___0 = 0;
      }
      {
#line 741
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 741
        if (! (n___0 < v___0->dimensions)) {
#line 741
          goto while_break___0;
        }
#line 743
        *(v___0->array_pos + n___0) = *(pp___0 + n___0);
#line 741
        n___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 747
    inp_advws(f);
    }
    {
#line 753
    if (v___0->type == 36) {
#line 753
      goto case_36;
    }
#line 778
    goto switch_default;
    case_36: /* CIL Label */ 
    {
#line 754
    tmp = inp_xgetc(f, -1);
    }
#line 754
    if (tmp != 34) {
      {
#line 757
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_xinp(): expected quotation mark");
#line 758
      bwb_error(bwb_ebuf);
      }
    }
#line 763
    n___0 = 0;
    {
#line 764
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 764
      tmp___0 = inp_xgetc(f, -1);
#line 764
      c = (char )tmp___0;
      }
#line 764
      if (! ((int )c != 34)) {
#line 764
        goto while_break___1;
      }
#line 766
      tbuf___20[n___0] = c;
#line 767
      n___0 ++;
#line 768
      tbuf___20[n___0] = (char )'\000';
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 770
    tmp___1 = var_findsval(v___0, v___0->array_pos);
#line 770
    str_ctob(tmp___1, tbuf___20);
#line 776
    inp_eatcomma(f);
    }
#line 777
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 779
    n___0 = 0;
    {
#line 780
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 780
      tmp___2 = inp_xgetc(f, 0);
#line 780
      c = (char )tmp___2;
      }
#line 780
      if (! ((int )c != 44)) {
#line 780
        goto while_break___2;
      }
#line 782
      tbuf___20[n___0] = c;
#line 783
      n___0 ++;
#line 784
      tbuf___20[n___0] = (char )'\000';
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 796
    tmp___3 = var_findnval(v___0, v___0->array_pos);
#line 796
    *tmp___3 = inp_numconst(tbuf___20);
    }
#line 797
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 802
    adv_ws(l->buffer, & l->position);
    }
#line 803
    if ((int )*(l->buffer + l->position) == 44) {
#line 805
      (l->position) ++;
    } else {
#line 809
      loop = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 816
  tmp___4 = bwb_zline(l);
  }
#line 816
  return (tmp___4);
}
}
#line 830 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_inp.c"
static int inp_advws(FILE *f ) 
{ 
  register int c ;
  int loop ;
  int tmp ;

  {
#line 841
  loop = -1;
  {
#line 842
  while (1) {
    while_continue: /* CIL Label */ ;
#line 842
    if (! (loop == -1)) {
#line 842
      goto while_break;
    }
    {
#line 844
    tmp = inp_xgetc(f, -1);
#line 844
    c = (int )((char )tmp);
    }
    {
#line 851
    if (c == 9) {
#line 851
      goto case_9;
    }
#line 851
    if (c == 32) {
#line 851
      goto case_9;
    }
#line 851
    if (c == 13) {
#line 851
      goto case_9;
    }
#line 851
    if (c == 10) {
#line 851
      goto case_9;
    }
#line 853
    goto switch_default;
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 852
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 854
    char_saved = -1;
#line 855
    cs = c;
#line 856
    loop = 0;
#line 857
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 861
  return (-1);
}
}
#line 884 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_inp.c"
static int prev_eof  =    0;
#line 874 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_inp.c"
static int inp_xgetc(FILE *f , int is_string ) 
{ 
  register int c ;
  int tmp ;

  {
#line 886
  if (char_saved == -1) {
#line 888
    char_saved = 0;
#line 889
    return (cs);
  }
  {
#line 892
  tmp = feof(f);
  }
#line 892
  if (tmp != 0) {
#line 894
    if (prev_eof == -1) {
      {
#line 896
      bwb_error(err_od);
      }
    } else {
#line 900
      prev_eof = -1;
#line 901
      return (',');
    }
  }
  {
#line 905
  prev_eof = 0;
#line 907
  c = fgetc(f);
  }
#line 909
  if (is_string == -1) {
#line 911
    return (c);
  }
  {
#line 919
  if (c == 13) {
#line 919
    goto case_13;
  }
#line 919
  if (c == 44) {
#line 919
    goto case_13;
  }
#line 919
  if (c == 10) {
#line 919
    goto case_13;
  }
#line 919
  if (c == 32) {
#line 919
    goto case_13;
  }
#line 914
  goto switch_break;
  case_13: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 920
  return (',');
  switch_break: /* CIL Label */ ;
  }
#line 923
  return (c);
}
}
#line 937 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_inp.c"
static int inp_eatcomma(FILE *f ) 
{ 
  char c ;
  int tmp ;

  {
  {
#line 947
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 947
    tmp = inp_xgetc(f, -1);
#line 947
    c = (char )tmp;
    }
#line 947
    if (! ((int )c == 44)) {
#line 947
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 951
  char_saved = -1;
#line 952
  cs = (int )c;
#line 954
  return (-1);
}
}
#line 971 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_inp.c"
static struct bwb_line *inp_str(struct bwb_line *l , char *input_buffer , char *var_list ,
                                int *vl_position ) 
{ 
  int i ;
  register int n___0 ;
  struct bwb_variable *v___0 ;
  int loop ;
  int *pp___0 ;
  int n_params___0 ;
  char ttbuf[5001] ;
  char varname[5001] ;
  struct bwb_line *tmp ;

  {
#line 1005
  i = 0;
#line 1006
  loop = -1;
  {
#line 1007
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1007
    if (! (loop == -1)) {
#line 1007
      goto while_break;
    }
    {
#line 1012
    bwb_getvarname(var_list, varname, vl_position);
#line 1013
    v___0 = var_find(varname);
#line 1023
    adv_ws(var_list, vl_position);
    }
#line 1024
    if ((int )*(var_list + *vl_position) == 40) {
      {
#line 1031
      dim_getparams(var_list, vl_position, & n_params___0, & pp___0);
#line 1032
      n___0 = 0;
      }
      {
#line 1032
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1032
        if (! (n___0 < v___0->dimensions)) {
#line 1032
          goto while_break___0;
        }
#line 1034
        *(v___0->array_pos + n___0) = *(pp___0 + n___0);
#line 1032
        n___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1040
    n___0 = 0;
#line 1041
    ttbuf[0] = (char )'\000';
    {
#line 1042
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1042
      if ((int )*(input_buffer + i) != 44) {
#line 1042
        if (! ((int )*(input_buffer + i) != 0)) {
#line 1042
          goto while_break___1;
        }
      } else {
#line 1042
        goto while_break___1;
      }
#line 1045
      ttbuf[n___0] = *(input_buffer + i);
#line 1046
      n___0 ++;
#line 1047
      i ++;
#line 1048
      ttbuf[n___0] = (char )'\000';
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1059
    inp_assign(ttbuf, v___0);
#line 1063
    adv_ws(var_list, vl_position);
    }
    {
#line 1069
    if ((int )*(var_list + *vl_position) == 58) {
#line 1069
      goto case_58;
    }
#line 1069
    if ((int )*(var_list + *vl_position) == 0) {
#line 1069
      goto case_58;
    }
#line 1069
    if ((int )*(var_list + *vl_position) == 13) {
#line 1069
      goto case_58;
    }
#line 1069
    if ((int )*(var_list + *vl_position) == 10) {
#line 1069
      goto case_58;
    }
#line 1072
    if ((int )*(var_list + *vl_position) == 44) {
#line 1072
      goto case_44;
    }
#line 1064
    goto switch_break;
    case_58: /* CIL Label */ 
    case_0: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 1070
    loop = 0;
#line 1071
    goto switch_break;
    case_44: /* CIL Label */ 
#line 1073
    (*vl_position) ++;
#line 1074
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1076
    adv_ws(var_list, vl_position);
#line 1078
    adv_ws(input_buffer, & i);
    }
    {
#line 1084
    if ((int )*(input_buffer + i) == 58) {
#line 1084
      goto case_58___0;
    }
#line 1084
    if ((int )*(input_buffer + i) == 0) {
#line 1084
      goto case_58___0;
    }
#line 1084
    if ((int )*(input_buffer + i) == 13) {
#line 1084
      goto case_58___0;
    }
#line 1084
    if ((int )*(input_buffer + i) == 10) {
#line 1084
      goto case_58___0;
    }
#line 1087
    if ((int )*(input_buffer + i) == 44) {
#line 1087
      goto case_44___0;
    }
#line 1079
    goto switch_break___0;
    case_58___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
    case_13___0: /* CIL Label */ 
    case_10___0: /* CIL Label */ 
#line 1085
    loop = 0;
#line 1086
    goto switch_break___0;
    case_44___0: /* CIL Label */ 
#line 1088
    i ++;
#line 1089
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 1091
    adv_ws(input_buffer, & i);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1103
  tmp = bwb_zline(l);
  }
#line 1103
  return (tmp);
}
}
#line 1119 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_inp.c"
static int inp_assign(char *b___4 , struct bwb_variable *v___0 ) 
{ 
  bstring *tmp ;
  bnumber *tmp___0 ;
  bnumber *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 1131
  if (v___0->type == 36) {
#line 1131
    goto case_36;
  }
#line 1135
  if (v___0->type == 1) {
#line 1135
    goto case_1;
  }
#line 1151
  goto switch_default;
  case_36: /* CIL Label */ 
  {
#line 1132
  tmp = var_findsval(v___0, v___0->array_pos);
#line 1132
  str_ctob(tmp, b___4);
  }
#line 1133
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1136
  tmp___2 = strlen((char const   *)b___4);
  }
#line 1136
  if (tmp___2 == 0UL) {
    {
#line 1138
    tmp___0 = var_findnval(v___0, v___0->array_pos);
#line 1138
    *tmp___0 = 0.0;
    }
  } else {
    {
#line 1147
    tmp___1 = var_findnval(v___0, v___0->array_pos);
#line 1147
    *tmp___1 = inp_numconst(b___4);
    }
  }
#line 1149
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1153
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in inp_assign(): variable <%s> of unknown type",
          v___0->name);
#line 1155
  bwb_error(bwb_ebuf);
  }
#line 1159
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 1163
  return (0);
}
}
#line 1178 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_inp.c"
int inp_adv(char *b___4 , int *c ) 
{ 
  int rval ;

  {
#line 1189
  rval = 0;
  {
#line 1191
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1197
    if ((int )*(b___4 + *c) == 59) {
#line 1197
      goto case_59;
    }
#line 1197
    if ((int )*(b___4 + *c) == 9) {
#line 1197
      goto case_59;
    }
#line 1197
    if ((int )*(b___4 + *c) == 32) {
#line 1197
      goto case_59;
    }
#line 1200
    if ((int )*(b___4 + *c) == 44) {
#line 1200
      goto case_44;
    }
#line 1205
    if ((int )*(b___4 + *c) == 58) {
#line 1205
      goto case_58;
    }
#line 1205
    if ((int )*(b___4 + *c) == 0) {
#line 1205
      goto case_58;
    }
#line 1209
    goto switch_default;
    case_59: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 1198
    (*c) ++;
#line 1199
    goto switch_break;
    case_44: /* CIL Label */ 
#line 1201
    rval = -1;
#line 1202
    (*c) ++;
#line 1203
    goto switch_break;
    case_58: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1206
    rval = -1;
#line 1207
    last_inp_adv_rval = rval;
#line 1208
    return (rval);
    switch_default: /* CIL Label */ 
#line 1210
    last_inp_adv_rval = rval;
#line 1211
    return (rval);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1227 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_inp.c"
static int inp_const(char *m_buffer , char *s_buffer___2 , int *position___7 ) 
{ 
  int string ;
  int s_pos ;
  int loop ;

  {
#line 1247
  string = 0;
#line 1251
  if ((int )*(m_buffer + *position___7) == 34) {
#line 1253
    string = -1;
#line 1254
    (*position___7) ++;
  } else {
#line 1258
    string = 0;
  }
#line 1263
  *(s_buffer___2 + 0) = (char )'\000';
#line 1264
  s_pos = 0;
#line 1265
  loop = -1;
  {
#line 1267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1267
    if (! (loop == -1)) {
#line 1267
      goto while_break;
    }
    {
#line 1274
    if ((int )*(m_buffer + *position___7) == 13) {
#line 1274
      goto case_13;
    }
#line 1274
    if ((int )*(m_buffer + *position___7) == 10) {
#line 1274
      goto case_13;
    }
#line 1274
    if ((int )*(m_buffer + *position___7) == 0) {
#line 1274
      goto case_13;
    }
#line 1278
    if ((int )*(m_buffer + *position___7) == 44) {
#line 1278
      goto case_44;
    }
#line 1278
    if ((int )*(m_buffer + *position___7) == 9) {
#line 1278
      goto case_44;
    }
#line 1278
    if ((int )*(m_buffer + *position___7) == 32) {
#line 1278
      goto case_44;
    }
#line 1291
    if ((int )*(m_buffer + *position___7) == 34) {
#line 1291
      goto case_34;
    }
#line 1308
    goto switch_default;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1275
    return (-1);
    case_44: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 1279
    if (string == 0) {
#line 1281
      return (-1);
    } else {
#line 1285
      *(s_buffer___2 + s_pos) = *(m_buffer + *position___7);
#line 1286
      (*position___7) ++;
#line 1287
      s_buffer___2 ++;
#line 1288
      *(s_buffer___2 + s_pos) = (char )'\000';
    }
#line 1290
    goto switch_break;
    case_34: /* CIL Label */ 
#line 1292
    if (string == -1) {
      {
#line 1294
      (*position___7) ++;
#line 1295
      inp_adv(m_buffer, position___7);
      }
#line 1296
      return (-1);
    } else {
      {
#line 1301
      sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"Unexpected character in numerical constant.");
#line 1302
      bwb_error(bwb_ebuf);
      }
#line 1306
      return (0);
    }
    switch_default: /* CIL Label */ 
#line 1309
    *(s_buffer___2 + s_pos) = *(m_buffer + *position___7);
#line 1310
    (*position___7) ++;
#line 1311
    s_buffer___2 ++;
#line 1312
    *(s_buffer___2 + s_pos) = (char )'\000';
#line 1313
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1318
  return (0);
}
}
#line 1336 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_inp.c"
struct bwb_line *bwb_line(struct bwb_line *l ) 
{ 
  int dev_no ;
  struct bwb_variable *v___0 ;
  FILE *inp_device ;
  char tbuf___20[5001] ;
  char pstring___0[5001] ;
  struct exp_ese *e___0 ;
  int pos___2 ;
  struct bwb_line *tmp ;
  int tmp___0 ;
  bnumber tmp___1 ;
  struct bwb_line *tmp___2 ;
  struct bwb_line *tmp___3 ;
  bstring *tmp___4 ;
  struct bwb_line *tmp___5 ;

  {
  {
#line 1354
  inp_device = stdin;
#line 1356
  pstring___0[0] = (char )'\000';
#line 1360
  adv_element(l->buffer, & l->position, tbuf___20);
#line 1361
  bwb_strtoupper(tbuf___20);
#line 1362
  tmp___0 = strcmp((char const   *)(tbuf___20), "INPUT");
  }
#line 1362
  if (tmp___0 != 0) {
    {
#line 1364
    bwb_error(err_syntax);
#line 1365
    tmp = bwb_zline(l);
    }
#line 1365
    return (tmp);
  }
  {
#line 1367
  adv_ws(l->buffer, & l->position);
  }
#line 1371
  if ((int )*(l->buffer + l->position) == 59) {
    {
#line 1373
    (l->position) ++;
#line 1374
    adv_ws(l->buffer, & l->position);
    }
  } else
#line 1379
  if ((int )*(l->buffer + l->position) == 35) {
    {
#line 1381
    (l->position) ++;
#line 1382
    adv_element(l->buffer, & l->position, tbuf___20);
#line 1383
    adv_ws(l->buffer, & l->position);
#line 1385
    pos___2 = 0;
#line 1386
    e___0 = bwb_exp(tbuf___20, 0, & pos___2);
#line 1387
    tmp___1 = exp_getnval(e___0);
#line 1387
    dev_no = (int )tmp___1;
    }
#line 1394
    if ((unsigned long )(dev_table + dev_no)->cfp == (unsigned long )((void *)0)) {
      {
#line 1396
      bwb_error(err_dev);
#line 1397
      tmp___2 = bwb_zline(l);
      }
#line 1397
      return (tmp___2);
    } else {
#line 1401
      inp_device = (dev_table + dev_no)->cfp;
    }
  }
#line 1407
  if ((int )*(l->buffer + l->position) == 44) {
    {
#line 1409
    (l->position) ++;
#line 1410
    adv_ws(l->buffer, & l->position);
    }
  }
#line 1415
  if ((int )*(l->buffer + l->position) == 34) {
    {
#line 1417
    inp_const(l->buffer, pstring___0, & l->position);
    }
  }
  {
#line 1431
  adv_element(l->buffer, & l->position, tbuf___20);
#line 1437
  v___0 = var_find(tbuf___20);
  }
#line 1438
  if (v___0->type != 36) {
    {
#line 1441
    bwb_error((char *)"in bwb_line(): String variable required");
#line 1445
    tmp___3 = bwb_zline(l);
    }
#line 1445
    return (tmp___3);
  }
#line 1455
  if ((unsigned long )inp_device == (unsigned long )stdin) {
    {
#line 1457
    bwx_input(pstring___0, tbuf___20);
    }
  } else {
    {
#line 1462
    fgets((char */* __restrict  */)(tbuf___20), 5002, (FILE */* __restrict  */)inp_device);
    }
  }
  {
#line 1464
  bwb_stripcr(tbuf___20);
#line 1465
  tmp___4 = var_findsval(v___0, v___0->array_pos);
#line 1465
  str_ctob(tmp___4, tbuf___20);
#line 1469
  tmp___5 = bwb_zline(l);
  }
#line 1469
  return (tmp___5);
}
}
#line 1493 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_inp.c"
static struct bwb_variable mantissa___0  ;
#line 1494 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_inp.c"
static int init___48  =    0;
#line 1484 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_inp.c"
static bnumber inp_numconst(char *expression ) 
{ 
  int base ;
  int exponent ;
  int man_start ;
  int s_pos ;
  int build_loop ;
  int need_pm ;
  int i ;
  bnumber d ;
  char type ;
  bnumber nval ;
  char string[5001] ;
  int pos_adv ;
  bnumber *tmp ;
  bnumber tmp___0 ;
  bnumber tmp___1 ;
  bnumber tmp___2 ;
  double tmp___3 ;

  {
#line 1515
  if (init___48 == 0) {
    {
#line 1517
    init___48 = -1;
#line 1518
    var_make(& mantissa___0, 1);
    }
  }
#line 1525
  *(mantissa___0.array_pos + 0) = dim_base;
#line 1533
  need_pm = 0;
#line 1534
  nval = (bnumber )0;
  {
#line 1553
  if ((int )*(expression + 0) == 46) {
#line 1553
    goto case_46;
  }
#line 1553
  if ((int )*(expression + 0) == 57) {
#line 1553
    goto case_46;
  }
#line 1553
  if ((int )*(expression + 0) == 56) {
#line 1553
    goto case_46;
  }
#line 1553
  if ((int )*(expression + 0) == 55) {
#line 1553
    goto case_46;
  }
#line 1553
  if ((int )*(expression + 0) == 54) {
#line 1553
    goto case_46;
  }
#line 1553
  if ((int )*(expression + 0) == 53) {
#line 1553
    goto case_46;
  }
#line 1553
  if ((int )*(expression + 0) == 52) {
#line 1553
    goto case_46;
  }
#line 1553
  if ((int )*(expression + 0) == 51) {
#line 1553
    goto case_46;
  }
#line 1553
  if ((int )*(expression + 0) == 50) {
#line 1553
    goto case_46;
  }
#line 1553
  if ((int )*(expression + 0) == 49) {
#line 1553
    goto case_46;
  }
#line 1553
  if ((int )*(expression + 0) == 48) {
#line 1553
    goto case_46;
  }
#line 1553
  if ((int )*(expression + 0) == 43) {
#line 1553
    goto case_46;
  }
#line 1553
  if ((int )*(expression + 0) == 45) {
#line 1553
    goto case_46;
  }
#line 1558
  if ((int )*(expression + 0) == 38) {
#line 1558
    goto case_38;
  }
#line 1577
  goto switch_default;
  case_46: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_45: /* CIL Label */ 
#line 1554
  base = 10;
#line 1555
  man_start = 0;
#line 1556
  need_pm = 0;
#line 1557
  goto switch_break;
  case_38: /* CIL Label */ 
#line 1559
  if ((int )*(expression + 1) == 72) {
#line 1561
    base = 16;
#line 1562
    man_start = 2;
  } else
#line 1559
  if ((int )*(expression + 1) == 104) {
#line 1561
    base = 16;
#line 1562
    man_start = 2;
  } else {
#line 1566
    base = 8;
#line 1567
    if ((int )*(expression + 1) == 79) {
#line 1569
      man_start = 2;
    } else
#line 1567
    if ((int )*(expression + 1) == 111) {
#line 1569
      man_start = 2;
    } else {
#line 1573
      man_start = 1;
    }
  }
#line 1576
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1580
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"expression <%s> is not a numerical constant.",
          expression);
#line 1582
  bwb_error(bwb_ebuf);
  }
#line 1586
  return ((bnumber )0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1594
  if (base == 10) {
#line 1594
    goto case_10;
  }
#line 1803
  if (base == 8) {
#line 1803
    goto case_8;
  }
#line 1848
  if (base == 16) {
#line 1848
    goto case_16;
  }
#line 1591
  goto switch_break___0;
  case_10: /* CIL Label */ 
#line 1598
  pos_adv = man_start;
#line 1599
  type = (char)1;
#line 1600
  string[0] = (char )'\000';
#line 1601
  s_pos = 0;
#line 1602
  exponent = 0;
#line 1603
  build_loop = -1;
  {
#line 1607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1607
    if (! (build_loop == -1)) {
#line 1607
      goto while_break;
    }
    {
#line 1612
    if ((int )*(expression + pos_adv) == 43) {
#line 1612
      goto case_43___0;
    }
#line 1612
    if ((int )*(expression + pos_adv) == 45) {
#line 1612
      goto case_43___0;
    }
#line 1645
    if ((int )*(expression + pos_adv) == 57) {
#line 1645
      goto case_57___0;
    }
#line 1645
    if ((int )*(expression + pos_adv) == 56) {
#line 1645
      goto case_57___0;
    }
#line 1645
    if ((int )*(expression + pos_adv) == 55) {
#line 1645
      goto case_57___0;
    }
#line 1645
    if ((int )*(expression + pos_adv) == 54) {
#line 1645
      goto case_57___0;
    }
#line 1645
    if ((int )*(expression + pos_adv) == 53) {
#line 1645
      goto case_57___0;
    }
#line 1645
    if ((int )*(expression + pos_adv) == 52) {
#line 1645
      goto case_57___0;
    }
#line 1645
    if ((int )*(expression + pos_adv) == 51) {
#line 1645
      goto case_57___0;
    }
#line 1645
    if ((int )*(expression + pos_adv) == 50) {
#line 1645
      goto case_57___0;
    }
#line 1645
    if ((int )*(expression + pos_adv) == 49) {
#line 1645
      goto case_57___0;
    }
#line 1645
    if ((int )*(expression + pos_adv) == 48) {
#line 1645
      goto case_57___0;
    }
#line 1645
    if ((int )*(expression + pos_adv) == 46) {
#line 1645
      goto case_57___0;
    }
#line 1653
    if ((int )*(expression + pos_adv) == 33) {
#line 1653
      goto case_33;
    }
#line 1653
    if ((int )*(expression + pos_adv) == 35) {
#line 1653
      goto case_33;
    }
#line 1661
    if ((int )*(expression + pos_adv) == 101) {
#line 1661
      goto case_101;
    }
#line 1661
    if ((int )*(expression + pos_adv) == 69) {
#line 1661
      goto case_101;
    }
#line 1669
    if ((int )*(expression + pos_adv) == 100) {
#line 1669
      goto case_100;
    }
#line 1669
    if ((int )*(expression + pos_adv) == 68) {
#line 1669
      goto case_100;
    }
#line 1676
    goto switch_default___0;
    case_43___0: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
#line 1618
    if (pos_adv == man_start) {
#line 1620
      string[s_pos] = *(expression + pos_adv);
#line 1621
      pos_adv ++;
#line 1622
      s_pos ++;
#line 1623
      string[s_pos] = (char )'\000';
    } else {
#line 1632
      build_loop = 0;
    }
#line 1634
    goto switch_break___1;
    case_57___0: /* CIL Label */ 
    case_56___0: /* CIL Label */ 
    case_55___0: /* CIL Label */ 
    case_54___0: /* CIL Label */ 
    case_53___0: /* CIL Label */ 
    case_52___0: /* CIL Label */ 
    case_51___0: /* CIL Label */ 
    case_50___0: /* CIL Label */ 
    case_49___0: /* CIL Label */ 
    case_48___0: /* CIL Label */ 
    case_46___0: /* CIL Label */ 
#line 1646
    string[s_pos] = *(expression + pos_adv);
#line 1647
    pos_adv ++;
#line 1648
    s_pos ++;
#line 1649
    string[s_pos] = (char )'\000';
#line 1650
    goto switch_break___1;
    case_33: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 1654
    pos_adv ++;
#line 1655
    type = (char)1;
#line 1656
    exponent = 0;
#line 1657
    build_loop = 0;
#line 1658
    goto switch_break___1;
    case_101: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 1662
    pos_adv ++;
#line 1663
    type = (char)1;
#line 1664
    exponent = -1;
#line 1665
    build_loop = 0;
#line 1666
    goto switch_break___1;
    case_100: /* CIL Label */ 
    case_68: /* CIL Label */ 
#line 1670
    pos_adv ++;
#line 1671
    type = (char)1;
#line 1672
    exponent = -1;
#line 1673
    build_loop = 0;
#line 1674
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 1677
    build_loop = 0;
#line 1678
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1686
  tmp = var_findnval(& mantissa___0, mantissa___0.array_pos);
#line 1686
  sscanf((char const   */* __restrict  */)(string), (char const   */* __restrict  */)"%lf",
         tmp);
  }
#line 1699
  if ((int )type == 1) {
    {
#line 1701
    tmp___0 = var_getnval(& mantissa___0);
#line 1701
    i = (int )tmp___0;
#line 1702
    d = (bnumber )i;
#line 1703
    tmp___1 = var_getnval(& mantissa___0);
    }
#line 1703
    if (d != tmp___1) {
#line 1705
      type = (char)1;
    }
  }
#line 1715
  if (exponent == -1) {
#line 1720
    need_pm = -1;
#line 1724
    string[0] = (char )'\000';
#line 1725
    s_pos = 0;
#line 1726
    build_loop = -1;
    {
#line 1730
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1730
      if (! (build_loop == -1)) {
#line 1730
        goto while_break___0;
      }
      {
#line 1735
      if ((int )*(expression + pos_adv) == 43) {
#line 1735
        goto case_43___1;
      }
#line 1735
      if ((int )*(expression + pos_adv) == 45) {
#line 1735
        goto case_43___1;
      }
#line 1759
      if ((int )*(expression + pos_adv) == 57) {
#line 1759
        goto case_57___1;
      }
#line 1759
      if ((int )*(expression + pos_adv) == 56) {
#line 1759
        goto case_57___1;
      }
#line 1759
      if ((int )*(expression + pos_adv) == 55) {
#line 1759
        goto case_57___1;
      }
#line 1759
      if ((int )*(expression + pos_adv) == 54) {
#line 1759
        goto case_57___1;
      }
#line 1759
      if ((int )*(expression + pos_adv) == 53) {
#line 1759
        goto case_57___1;
      }
#line 1759
      if ((int )*(expression + pos_adv) == 52) {
#line 1759
        goto case_57___1;
      }
#line 1759
      if ((int )*(expression + pos_adv) == 51) {
#line 1759
        goto case_57___1;
      }
#line 1759
      if ((int )*(expression + pos_adv) == 50) {
#line 1759
        goto case_57___1;
      }
#line 1759
      if ((int )*(expression + pos_adv) == 49) {
#line 1759
        goto case_57___1;
      }
#line 1759
      if ((int )*(expression + pos_adv) == 48) {
#line 1759
        goto case_57___1;
      }
#line 1768
      goto switch_default___1;
      case_43___1: /* CIL Label */ 
      case_45___1: /* CIL Label */ 
#line 1737
      if (need_pm == -1) {
#line 1739
        string[s_pos] = *(expression + pos_adv);
#line 1740
        pos_adv ++;
#line 1741
        s_pos ++;
#line 1742
        string[s_pos] = (char )'\000';
      } else {
#line 1746
        build_loop = 0;
      }
#line 1748
      goto switch_break___2;
      case_57___1: /* CIL Label */ 
      case_56___1: /* CIL Label */ 
      case_55___1: /* CIL Label */ 
      case_54___1: /* CIL Label */ 
      case_53___1: /* CIL Label */ 
      case_52___1: /* CIL Label */ 
      case_51___1: /* CIL Label */ 
      case_50___1: /* CIL Label */ 
      case_49___1: /* CIL Label */ 
      case_48___1: /* CIL Label */ 
#line 1761
      string[s_pos] = *(expression + pos_adv);
#line 1762
      pos_adv ++;
#line 1763
      s_pos ++;
#line 1764
      string[s_pos] = (char )'\000';
#line 1765
      need_pm = 0;
#line 1766
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
#line 1769
      build_loop = 0;
#line 1770
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1778
    sscanf((char const   */* __restrict  */)(string), (char const   */* __restrict  */)"%lf",
           & nval);
    }
  }
#line 1791
  if (nval == (bnumber )0) {
    {
#line 1793
    nval = var_getnval(& mantissa___0);
    }
  } else {
    {
#line 1797
    tmp___2 = var_getnval(& mantissa___0);
#line 1797
    tmp___3 = pow(10.0, nval);
#line 1797
    nval = tmp___2 * tmp___3;
    }
  }
#line 1801
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 1807
  pos_adv = man_start;
#line 1808
  type = (char)1;
#line 1809
  string[0] = (char )'\000';
#line 1810
  s_pos = 0;
#line 1811
  exponent = 0;
#line 1812
  build_loop = -1;
  {
#line 1816
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1816
    if (! (build_loop == -1)) {
#line 1816
      goto while_break___1;
    }
    {
#line 1827
    if ((int )*(expression + pos_adv) == 55) {
#line 1827
      goto case_55___2;
    }
#line 1827
    if ((int )*(expression + pos_adv) == 54) {
#line 1827
      goto case_55___2;
    }
#line 1827
    if ((int )*(expression + pos_adv) == 53) {
#line 1827
      goto case_55___2;
    }
#line 1827
    if ((int )*(expression + pos_adv) == 52) {
#line 1827
      goto case_55___2;
    }
#line 1827
    if ((int )*(expression + pos_adv) == 51) {
#line 1827
      goto case_55___2;
    }
#line 1827
    if ((int )*(expression + pos_adv) == 50) {
#line 1827
      goto case_55___2;
    }
#line 1827
    if ((int )*(expression + pos_adv) == 49) {
#line 1827
      goto case_55___2;
    }
#line 1827
    if ((int )*(expression + pos_adv) == 48) {
#line 1827
      goto case_55___2;
    }
#line 1834
    goto switch_default___2;
    case_55___2: /* CIL Label */ 
    case_54___2: /* CIL Label */ 
    case_53___2: /* CIL Label */ 
    case_52___2: /* CIL Label */ 
    case_51___2: /* CIL Label */ 
    case_50___2: /* CIL Label */ 
    case_49___2: /* CIL Label */ 
    case_48___2: /* CIL Label */ 
#line 1828
    string[s_pos] = *(expression + pos_adv);
#line 1829
    pos_adv ++;
#line 1830
    s_pos ++;
#line 1831
    string[s_pos] = (char )'\000';
#line 1832
    goto switch_break___3;
    switch_default___2: /* CIL Label */ 
#line 1835
    build_loop = 0;
#line 1836
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1843
  sscanf((char const   */* __restrict  */)(string), (char const   */* __restrict  */)"%o",
         & i);
#line 1844
  nval = (bnumber )i;
  }
#line 1846
  goto switch_break___0;
  case_16: /* CIL Label */ 
#line 1852
  pos_adv = man_start;
#line 1853
  type = (char)1;
#line 1854
  string[0] = (char )'\000';
#line 1855
  s_pos = 0;
#line 1856
  exponent = 0;
#line 1857
  build_loop = -1;
  {
#line 1861
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1861
    if (! (build_loop == -1)) {
#line 1861
      goto while_break___2;
    }
    {
#line 1886
    if ((int )*(expression + pos_adv) == 102) {
#line 1886
      goto case_102;
    }
#line 1886
    if ((int )*(expression + pos_adv) == 70) {
#line 1886
      goto case_102;
    }
#line 1886
    if ((int )*(expression + pos_adv) == 101) {
#line 1886
      goto case_102;
    }
#line 1886
    if ((int )*(expression + pos_adv) == 69) {
#line 1886
      goto case_102;
    }
#line 1886
    if ((int )*(expression + pos_adv) == 100) {
#line 1886
      goto case_102;
    }
#line 1886
    if ((int )*(expression + pos_adv) == 68) {
#line 1886
      goto case_102;
    }
#line 1886
    if ((int )*(expression + pos_adv) == 99) {
#line 1886
      goto case_102;
    }
#line 1886
    if ((int )*(expression + pos_adv) == 67) {
#line 1886
      goto case_102;
    }
#line 1886
    if ((int )*(expression + pos_adv) == 98) {
#line 1886
      goto case_102;
    }
#line 1886
    if ((int )*(expression + pos_adv) == 66) {
#line 1886
      goto case_102;
    }
#line 1886
    if ((int )*(expression + pos_adv) == 97) {
#line 1886
      goto case_102;
    }
#line 1886
    if ((int )*(expression + pos_adv) == 65) {
#line 1886
      goto case_102;
    }
#line 1886
    if ((int )*(expression + pos_adv) == 57) {
#line 1886
      goto case_102;
    }
#line 1886
    if ((int )*(expression + pos_adv) == 56) {
#line 1886
      goto case_102;
    }
#line 1886
    if ((int )*(expression + pos_adv) == 55) {
#line 1886
      goto case_102;
    }
#line 1886
    if ((int )*(expression + pos_adv) == 54) {
#line 1886
      goto case_102;
    }
#line 1886
    if ((int )*(expression + pos_adv) == 53) {
#line 1886
      goto case_102;
    }
#line 1886
    if ((int )*(expression + pos_adv) == 52) {
#line 1886
      goto case_102;
    }
#line 1886
    if ((int )*(expression + pos_adv) == 51) {
#line 1886
      goto case_102;
    }
#line 1886
    if ((int )*(expression + pos_adv) == 50) {
#line 1886
      goto case_102;
    }
#line 1886
    if ((int )*(expression + pos_adv) == 49) {
#line 1886
      goto case_102;
    }
#line 1886
    if ((int )*(expression + pos_adv) == 48) {
#line 1886
      goto case_102;
    }
#line 1894
    goto switch_default___3;
    case_102: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_101___0: /* CIL Label */ 
    case_69___0: /* CIL Label */ 
    case_100___0: /* CIL Label */ 
    case_68___0: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_57___2: /* CIL Label */ 
    case_56___2: /* CIL Label */ 
    case_55___3: /* CIL Label */ 
    case_54___3: /* CIL Label */ 
    case_53___3: /* CIL Label */ 
    case_52___3: /* CIL Label */ 
    case_51___3: /* CIL Label */ 
    case_50___3: /* CIL Label */ 
    case_49___3: /* CIL Label */ 
    case_48___3: /* CIL Label */ 
#line 1887
    string[s_pos] = *(expression + pos_adv);
#line 1889
    pos_adv ++;
#line 1890
    s_pos ++;
#line 1891
    string[s_pos] = (char )'\000';
#line 1892
    goto switch_break___4;
    switch_default___3: /* CIL Label */ 
#line 1895
    build_loop = 0;
#line 1896
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1903
  sscanf((char const   */* __restrict  */)(string), (char const   */* __restrict  */)"%x",
         & i);
#line 1904
  nval = (bnumber )i;
  }
#line 1905
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1914
  return (nval);
}
}
#line 928 "/home/june/collector/temp/bwbasic-2.20pl2/bwbasic.h"
struct bwb_line *bwb_exitdo(struct bwb_line *l ) ;
#line 46 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
static int fslt_clear(void) ;
#line 47
static int fslt_add(struct bwb_line *line , int *position___7 , int code ) ;
#line 48
static struct bwb_line *fslt_findl(char *buffer ) ;
#line 49
static struct fslte *fslt_findf(char *buffer ) ;
#line 50
static int scan_getcmd(struct bwb_line *line , int *position___7 ) ;
#line 51
static int scan_readargs(struct fslte *f , struct bwb_line *line , int *position___7 ) ;
#line 53
static int call_readargs(struct fslte *f , char *expression , int *position___7 ) ;
#line 55
static int is_endsub(struct bwb_line *l ) ;
#line 56
static struct bwb_line *find_endsub(struct bwb_line *l ) ;
#line 57
static struct bwb_line *bwb_loopuntil(struct bwb_line *l ) ;
#line 58
struct bwb_variable *bwb_vtov(struct bwb_variable *dst , struct bwb_variable *src ) ;
#line 59
struct bwb_variable *bwb_etov(struct bwb_variable *dst , struct exp_ese *src ) ;
#line 60
struct bwb_variable *var_pos(struct bwb_variable *firstvar , int p___0 ) ;
#line 61
int fslt_addcallvar(struct bwb_variable *v___0 ) ;
#line 62
int fslt_addlocalvar(struct fslte *f , struct bwb_variable *v___0 ) ;
#line 92 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
int bwb_scan(void) 
{ 
  struct bwb_line *current ;
  int position___7 ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 104
  if (rescan != -1) {
    {
#line 106
    bwb_error((char *)"in bwb_scan(): call to scan while CURTASK rescan != TRUE");
    }
#line 107
    return (0);
  }
  {
#line 119
  fslt_clear();
#line 123
  current = bwb_start.next;
  }
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! ((unsigned long )current != (unsigned long )(& bwb_end))) {
#line 123
      goto while_break;
    }
    {
#line 131
    c = scan_getcmd(current, & position___7);
#line 132
    tmp___2 = getcmdnum((char *)"SUB");
    }
#line 132
    if (c == tmp___2) {
      {
#line 134
      fslt_add(current, & position___7, 5);
      }
    } else {
      {
#line 136
      tmp___1 = getcmdnum((char *)"FUNCTION");
      }
#line 136
      if (c == tmp___1) {
        {
#line 138
        fslt_add(current, & position___7, 4);
        }
      } else {
        {
#line 140
        tmp___0 = getcmdnum((char *)"DEF");
        }
#line 140
        if (c == tmp___0) {
          {
#line 142
          fslt_add(current, & position___7, 4);
          }
        } else {
          {
#line 145
          tmp = getcmdnum((char *)"lAbEl");
          }
#line 145
          if (c == tmp) {
            {
#line 147
            fslt_add(current, & position___7, 11);
            }
          }
        }
      }
    }
#line 123
    current = current->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  rescan = 0;
#line 155
  return (-1);
}
}
#line 169 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
static int fslt_clear(void) 
{ 
  struct fslte *current ;
  struct fslte *next ;
  struct bwb_variable *c ;
  struct bwb_variable *n___0 ;

  {
#line 181
  next = fslt_start.next;
#line 182
  current = fslt_start.next;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! ((unsigned long )current != (unsigned long )(& fslt_end))) {
#line 182
      goto while_break;
    }
#line 188
    c = current->local_variable;
    {
#line 189
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 189
      if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 189
        goto while_break___0;
      }
      {
#line 191
      n___0 = c->next;
#line 194
      FREE((void *)c, (char *)"fslt_clear");
#line 195
      c = n___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 198
    next = current->next;
#line 201
    if ((unsigned long )current->name != (unsigned long )((void *)0)) {
      {
#line 203
      FREE((void *)current->name, (char *)"fslt_clear");
#line 204
      current->name = (char *)((void *)0);
      }
    }
    {
#line 206
    FREE((void *)current, (char *)"fslt_clear");
#line 207
    current = (struct fslte *)((void *)0);
#line 182
    current = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 212
  fslt_start.next = & fslt_end;
#line 214
  return (-1);
}
}
#line 228 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
static int scan_getcmd(struct bwb_line *line , int *position___7 ) 
{ 
  char tbuf___20[5001] ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 239
  *position___7 = 0;
#line 240
  adv_ws(line->buffer, position___7);
  }
#line 244
  if ((int )*(line->buffer + *position___7) == 0) {
#line 246
    return (-1);
  }
  {
#line 251
  tmp = __ctype_b_loc();
  }
#line 251
  if ((int const   )*(*tmp + (int )*(line->buffer + *position___7)) & 2048) {
    {
#line 253
    scan_element(line->buffer, position___7, tbuf___20);
    }
  }
  {
#line 258
  scan_element(line->buffer, position___7, tbuf___20);
#line 267
  tmp___1 = is_label(tbuf___20);
  }
#line 267
  if (tmp___1 == -1) {
    {
#line 274
    tmp___0 = getcmdnum((char *)"lAbEl");
    }
#line 274
    return (tmp___0);
  }
  {
#line 279
  bwb_strtoupper(tbuf___20);
#line 283
  tmp___2 = getcmdnum(tbuf___20);
  }
#line 283
  return (tmp___2);
}
}
#line 307 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
extern int scan_element(char *buffer , int *pos___2 , char *element___0 ) 
{ 
  int loop ;
  int e_pos ;
  int str_const ;
  int tmp ;

  {
  {
#line 323
  adv_ws(buffer, pos___2);
#line 333
  loop = -1;
#line 334
  e_pos = 0;
#line 335
  *(element___0 + e_pos) = (char )'\000';
#line 336
  str_const = 0;
  }
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! (loop == -1)) {
#line 338
      goto while_break;
    }
    {
#line 349
    if ((int )*(buffer + *pos___2) == 13) {
#line 349
      goto case_13;
    }
#line 349
    if ((int )*(buffer + *pos___2) == 10) {
#line 349
      goto case_13;
    }
#line 349
    if ((int )*(buffer + *pos___2) == 0) {
#line 349
      goto case_13;
    }
#line 349
    if ((int )*(buffer + *pos___2) == 9) {
#line 349
      goto case_13;
    }
#line 349
    if ((int )*(buffer + *pos___2) == 32) {
#line 349
      goto case_13;
    }
#line 349
    if ((int )*(buffer + *pos___2) == 61) {
#line 349
      goto case_13;
    }
#line 349
    if ((int )*(buffer + *pos___2) == 59) {
#line 349
      goto case_13;
    }
#line 349
    if ((int )*(buffer + *pos___2) == 44) {
#line 349
      goto case_13;
    }
#line 363
    if ((int )*(buffer + *pos___2) == 34) {
#line 363
      goto case_34;
    }
#line 378
    if ((int )*(buffer + *pos___2) == 40) {
#line 378
      goto case_40;
    }
#line 390
    goto switch_default;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_0: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_61: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_44: /* CIL Label */ 
#line 350
    if (str_const == -1) {
#line 352
      *(element___0 + e_pos) = *(buffer + *pos___2);
#line 353
      e_pos ++;
#line 354
      (*pos___2) ++;
#line 355
      *(element___0 + e_pos) = (char )'\000';
    } else {
#line 359
      return (-1);
    }
#line 361
    goto switch_break;
    case_34: /* CIL Label */ 
#line 364
    *(element___0 + e_pos) = *(buffer + *pos___2);
#line 365
    e_pos ++;
#line 366
    (*pos___2) ++;
#line 367
    *(element___0 + e_pos) = (char )'\000';
#line 368
    if (str_const == -1) {
#line 370
      return (-1);
    } else {
#line 374
      str_const = -1;
    }
#line 376
    goto switch_break;
    case_40: /* CIL Label */ 
    {
#line 380
    tmp = strcmp((char const   *)element___0, "MID$");
    }
#line 380
    if (tmp == 0) {
#line 381
      return (-1);
    }
#line 384
    *(element___0 + e_pos) = *(buffer + *pos___2);
#line 385
    e_pos ++;
#line 386
    (*pos___2) ++;
#line 387
    *(element___0 + e_pos) = (char )'\000';
#line 388
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 391
    *(element___0 + e_pos) = *(buffer + *pos___2);
#line 392
    e_pos ++;
#line 393
    (*pos___2) ++;
#line 394
    *(element___0 + e_pos) = (char )'\000';
#line 395
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 401
  return (0);
}
}
#line 415 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
static int fslt_add(struct bwb_line *line , int *position___7 , int code ) 
{ 
  char tbuf___20[5001] ;
  char *name ;
  struct bwb_variable *v___0 ;
  struct fslte *f ;
  struct fslte *n___0 ;
  int p___0 ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 433
  if (code == 11) {
    {
#line 435
    p___0 = 0;
#line 436
    scan_element(line->buffer, & p___0, tbuf___20);
#line 437
    tmp = __ctype_b_loc();
    }
#line 437
    if ((int const   )*(*tmp + (int )tbuf___20[0]) & 2048) {
      {
#line 439
      scan_element(line->buffer, & p___0, tbuf___20);
      }
    }
    {
#line 441
    tmp___0 = strlen((char const   *)(tbuf___20));
#line 441
    tbuf___20[tmp___0 - 1UL] = (char )'\000';
    }
  } else {
    {
#line 445
    adv_ws(line->buffer, position___7);
#line 446
    exp_getvfname(line->buffer + *position___7, tbuf___20);
#line 447
    tmp___1 = strlen((char const   *)(tbuf___20));
#line 447
    *position___7 = (int )((size_t )*position___7 + tmp___1);
    }
  }
  {
#line 459
  tmp___2 = strlen((char const   *)(tbuf___20));
#line 459
  tmp___3 = CALLOC((size_t )1, tmp___2 + 1UL, (char *)"fslt_add");
#line 459
  name = (char *)tmp___3;
  }
#line 459
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    {
#line 462
    bwb_error((char *)"in fslt_add(): failed to get memory for name buffer");
    }
#line 466
    return (0);
  }
  {
#line 469
  strcpy((char */* __restrict  */)name, (char const   */* __restrict  */)(tbuf___20));
#line 473
  tmp___4 = CALLOC((size_t )1, sizeof(struct fslte ), (char *)"fslt_add");
#line 473
  f = (struct fslte *)tmp___4;
  }
#line 473
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 476
    bwb_error((char *)"in fslt_add(): failed to get memory for fslt structure");
    }
#line 480
    return (0);
  }
  {
#line 485
  f->line = line;
#line 486
  f->name = name;
#line 487
  f->code = code;
#line 488
  f->local_variable = (struct bwb_variable *)((void *)0);
#line 498
  adv_ws(line->buffer, position___7);
  }
#line 499
  if ((int )*(line->buffer + *position___7) == 40) {
    {
#line 501
    scan_readargs(f, line, position___7);
    }
  }
#line 507
  if (code == 4) {
    {
#line 510
    v___0 = var_new(tbuf___20);
#line 511
    fslt_addlocalvar(f, v___0);
    }
  }
#line 524
  n___0 = fslt_start.next;
#line 525
  fslt_start.next = f;
#line 526
  f->next = n___0;
#line 528
  return (-1);
}
}
#line 543 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
static int scan_readargs(struct fslte *f , struct bwb_line *line , int *position___7 ) 
{ 
  int control_loop ;
  struct bwb_variable *v___0 ;
  char tbuf___20[5001] ;
  size_t tmp ;

  {
#line 565
  if ((int )*(line->buffer + *position___7) == 40) {
#line 567
    (*position___7) ++;
  }
  {
#line 572
  control_loop = -1;
#line 573
  adv_ws(line->buffer, position___7);
  }
  {
#line 574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 574
    if (! (control_loop == -1)) {
#line 574
      goto while_break;
    }
    {
#line 581
    if ((int )*(line->buffer + *position___7) == 0) {
#line 581
      goto case_0;
    }
#line 581
    if ((int )*(line->buffer + *position___7) == 13) {
#line 581
      goto case_0;
    }
#line 581
    if ((int )*(line->buffer + *position___7) == 10) {
#line 581
      goto case_0;
    }
#line 586
    if ((int )*(line->buffer + *position___7) == 41) {
#line 586
      goto case_41;
    }
#line 592
    goto switch_default;
    case_0: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    {
#line 582
    control_loop = 0;
#line 583
    f->startpos = *position___7;
#line 584
    bwb_error(err_syntax);
    }
#line 585
    return (0);
    case_41: /* CIL Label */ 
#line 587
    (*position___7) ++;
#line 588
    control_loop = 0;
#line 589
    f->startpos = *position___7;
#line 590
    return (-1);
    switch_default: /* CIL Label */ 
    {
#line 594
    exp_getvfname(line->buffer + *position___7, tbuf___20);
#line 595
    tmp = strlen((char const   *)(tbuf___20));
#line 595
    *position___7 = (int )((size_t )*position___7 + tmp);
#line 605
    v___0 = var_new(tbuf___20);
#line 606
    fslt_addlocalvar(f, v___0);
    }
#line 610
    if ((int )*(line->buffer + *position___7) == 44) {
#line 612
      (*position___7) ++;
    }
#line 615
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 618
    adv_ws(line->buffer, position___7);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  return (-1);
}
}
#line 636 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
static int call_readargs(struct fslte *f , char *expression , int *position___7 ) 
{ 
  int control_loop ;
  struct bwb_variable *v___0 ;
  struct bwb_variable *c ;
  char tbuf___20[5001] ;
  int argument_counter ;
  int local_pos ;
  int single_var ;
  struct exp_ese *e___0 ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 661
  if ((int )*(expression + *position___7) == 40) {
#line 663
    (*position___7) ++;
  }
#line 668
  control_loop = -1;
#line 669
  argument_counter = 0;
  {
#line 671
  while (1) {
    while_continue: /* CIL Label */ ;
#line 671
    if (! (control_loop == -1)) {
#line 671
      goto while_break;
    }
    {
#line 674
    adv_ws(expression, position___7);
    }
    {
#line 688
    if ((int )*(expression + *position___7) == 58) {
#line 688
      goto case_58;
    }
#line 688
    if ((int )*(expression + *position___7) == 0) {
#line 688
      goto case_58;
    }
#line 688
    if ((int )*(expression + *position___7) == 13) {
#line 688
      goto case_58;
    }
#line 688
    if ((int )*(expression + *position___7) == 10) {
#line 688
      goto case_58;
    }
#line 693
    if ((int )*(expression + *position___7) == 41) {
#line 693
      goto case_41;
    }
#line 698
    goto switch_default;
    case_58: /* CIL Label */ 
    case_0: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 690
    control_loop = 0;
#line 691
    return (0);
    case_41: /* CIL Label */ 
#line 694
    (*position___7) ++;
#line 695
    control_loop = 0;
#line 696
    return (-1);
    switch_default: /* CIL Label */ 
    {
#line 702
    single_var = 0;
#line 703
    exp_getvfname(expression + *position___7, tbuf___20);
#line 704
    tmp = strlen((char const   *)(tbuf___20));
#line 704
    local_pos = (int )((size_t )*position___7 + tmp);
#line 706
    adv_ws(expression, & local_pos);
#line 716
    tmp___0 = strlen((char const   *)(tbuf___20));
    }
#line 716
    if (tmp___0 == 0UL) {
#line 718
      single_var = 0;
    } else {
      {
#line 725
      if ((int )*(expression + local_pos) == 41) {
#line 725
        goto case_41___0;
      }
#line 737
      if ((int )*(expression + local_pos) == 58) {
#line 737
        goto case_58___0;
      }
#line 737
      if ((int )*(expression + local_pos) == 0) {
#line 737
        goto case_58___0;
      }
#line 737
      if ((int )*(expression + local_pos) == 13) {
#line 737
        goto case_58___0;
      }
#line 737
      if ((int )*(expression + local_pos) == 10) {
#line 737
        goto case_58___0;
      }
#line 741
      if ((int )*(expression + local_pos) == 44) {
#line 741
        goto case_44;
      }
#line 763
      goto switch_default___0;
      case_41___0: /* CIL Label */ 
#line 732
      local_pos ++;
      case_58___0: /* CIL Label */ 
      case_0___0: /* CIL Label */ 
      case_13___0: /* CIL Label */ 
      case_10___0: /* CIL Label */ 
#line 739
      control_loop = 0;
      case_44: /* CIL Label */ 
      {
#line 743
      single_var = -1;
#line 747
      exsc --;
#line 748
      v___0 = var_find(tbuf___20);
#line 749
      exsc ++;
#line 751
      c = var_pos((excs + exsc)->local_variable, argument_counter);
#line 753
      bwb_vtov(c, v___0);
#line 761
      *position___7 = local_pos;
      }
#line 762
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 764
      single_var = 0;
#line 765
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 769
    if (single_var == 0) {
      {
#line 777
      e___0 = bwb_exp(expression, 0, position___7);
#line 785
      v___0 = var_pos((excs + exsc)->local_variable, argument_counter);
#line 787
      bwb_etov(v___0, e___0);
      }
    }
    {
#line 792
    fslt_addcallvar(v___0);
#line 812
    adv_ws(expression, position___7);
    }
#line 813
    if ((int )*(expression + *position___7) == 44) {
#line 815
      (*position___7) ++;
    }
#line 818
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 821
    argument_counter ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 830
  return (-1);
}
}
#line 845 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
static struct bwb_line *fslt_findl(char *buffer ) 
{ 
  struct fslte *r ;

  {
  {
#line 855
  r = fslt_findf(buffer);
  }
#line 857
  return (r->line);
}
}
#line 872 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
static struct fslte *fslt_findf(char *buffer ) 
{ 
  struct fslte *f ;
  register int c ;
  int tmp ;

  {
#line 885
  c = 0;
  {
#line 885
  while (1) {
    while_continue: /* CIL Label */ ;
#line 885
    if (! ((int )*(buffer + c) != 0)) {
#line 885
      goto while_break;
    }
#line 887
    if ((int )*(buffer + c) == 40) {
#line 889
      *(buffer + c) = (char )'\000';
    }
#line 885
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  f = fslt_start.next;
  {
#line 900
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 900
    if (! ((unsigned long )f != (unsigned long )(& fslt_end))) {
#line 900
      goto while_break___0;
    }
    {
#line 902
    tmp = strcmp((char const   *)f->name, (char const   *)buffer);
    }
#line 902
    if (tmp == 0) {
#line 904
      return (f);
    }
#line 900
    f = f->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 911
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in fslt_findf(): failed to find Function/Subroutine <%s>",
          buffer);
#line 913
  bwb_error(bwb_ebuf);
  }
#line 918
  return ((struct fslte *)((void *)0));
}
}
#line 939 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
struct bwb_line *bwb_def(struct bwb_line *l ) 
{ 
  struct bwb_line *tmp ;

  {
  {
#line 949
  adv_eos(l->buffer, & l->position);
#line 952
  tmp = bwb_zline(l);
  }
#line 952
  return (tmp);
}
}
#line 969 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
struct bwb_line *bwb_function(struct bwb_line *l ) 
{ 
  struct bwb_line *tmp ;

  {
  {
#line 978
  tmp = bwb_def(l);
  }
#line 978
  return (tmp);
}
}
#line 999 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
struct bwb_line *bwb_endfnc(struct bwb_line *l ) 
{ 
  struct bwb_variable *local ;
  register int c ;

  {
#line 1012
  local = (excs + exsc)->local_variable;
#line 1013
  c = 0;
  {
#line 1013
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1013
    if (! (c < (excs + exsc)->n_cvs)) {
#line 1013
      goto while_break;
    }
    {
#line 1015
    bwb_vtov((excs + exsc)->calling_variable[c], local);
#line 1016
    local = local->next;
#line 1013
    c ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1021
  bwb_decexec();
#line 1025
  (((excs + exsc)->line)->next)->position = 0;
  }
#line 1026
  return (((excs + exsc)->line)->next);
}
}
#line 1042 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
struct bwb_line *bwb_call(struct bwb_line *l ) 
{ 
  char tbuf___20[5001] ;
  struct bwb_line *call_line ;
  struct fslte *f ;
  struct bwb_line *tmp ;

  {
  {
#line 1054
  adv_element(l->buffer, & l->position, tbuf___20);
#line 1063
  call_line = fslt_findl(tbuf___20);
#line 1064
  f = fslt_findf(tbuf___20);
  }
#line 1066
  if ((unsigned long )call_line == (unsigned long )((void *)0)) {
    {
#line 1068
    tmp = bwb_zline(l);
    }
#line 1068
    return (tmp);
  }
  {
#line 1079
  bwb_setexec(l, l->position, (excs + exsc)->code);
#line 1083
  bwb_incexec();
#line 1084
  call_line->position = 0;
#line 1085
  bwb_setexec(call_line, 0, 5);
#line 1089
  (excs + exsc)->local_variable = f->local_variable;
#line 1093
  call_readargs(f, l->buffer, & l->position);
  }
#line 1095
  return (call_line);
}
}
#line 1114 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
struct bwb_line *bwb_sub(struct bwb_line *l ) 
{ 
  char tbuf___20[5001] ;
  struct bwb_line *rline ;
  struct fslte *f ;
  struct bwb_line *tmp ;
  int tmp___0 ;
  struct bwb_line *tmp___1 ;

  {
#line 1136
  if (exsc == 0) {
    {
#line 1138
    adv_element(l->buffer, & l->position, tbuf___20);
#line 1139
    bwb_strtoupper(tbuf___20);
#line 1140
    tmp___0 = strcmp((char const   *)(tbuf___20), "MAIN");
    }
#line 1140
    if (tmp___0 == 0) {
      {
#line 1147
      bwb_incexec();
#line 1149
      bwb_setexec(l->next, 0, 8);
#line 1151
      tmp = bwb_zline(l);
      }
#line 1151
      return (tmp);
    } else {
      {
#line 1165
      rline = find_endsub(l);
#line 1166
      bwb_setexec(rline->next, 0, 5);
#line 1167
      (rline->next)->position = 0;
      }
#line 1168
      return (rline->next);
    }
  } else
#line 1174
  if ((excs + exsc)->code != 5) {
    {
#line 1177
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_sub(): SUB without CALL");
#line 1178
    bwb_error(bwb_ebuf);
    }
  }
  {
#line 1187
  adv_ws(l->buffer, & l->position);
#line 1188
  adv_element(l->buffer, & l->position, tbuf___20);
#line 1189
  f = fslt_findf(tbuf___20);
#line 1191
  l->position = f->startpos;
#line 1193
  tmp___1 = bwb_zline(l);
  }
#line 1193
  return (tmp___1);
}
}
#line 1210 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
static struct bwb_line *find_endsub(struct bwb_line *l ) 
{ 
  struct bwb_line *current ;
  register int s_level ;
  int position___7 ;
  int tmp ;

  {
#line 1222
  s_level = 1;
#line 1223
  current = l->next;
  {
#line 1223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1223
    if (! ((unsigned long )current != (unsigned long )(& bwb_end))) {
#line 1223
      goto while_break;
    }
#line 1225
    position___7 = 0;
#line 1226
    if (current->marked != -1) {
      {
#line 1228
      line_start(current->buffer, & position___7, & current->lnpos, & current->lnum,
                 & current->cmdpos, & current->cmdnum, & current->startpos);
      }
    }
#line 1234
    current->position = current->startpos;
#line 1236
    if (current->cmdnum > -1) {
#line 1239
      if ((unsigned long )bwb_cmdtable[current->cmdnum].vector == (unsigned long )(& bwb_sub)) {
#line 1241
        s_level ++;
      } else {
        {
#line 1250
        tmp = is_endsub(current);
        }
#line 1250
        if (tmp == -1) {
#line 1252
          s_level --;
#line 1260
          if (s_level == 0) {
#line 1262
            return (current);
          }
        }
      }
    }
#line 1223
    current = current->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1270
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"SUB without END SUB");
#line 1271
  bwb_error(bwb_ebuf);
  }
#line 1276
  return ((struct bwb_line *)((void *)0));
}
}
#line 1291 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
static int is_endsub(struct bwb_line *l ) 
{ 
  int position___7 ;
  char tbuf___20[41] ;
  int tmp ;

  {
#line 1302
  if ((unsigned long )bwb_cmdtable[l->cmdnum].vector != (unsigned long )(& bwb_xend)) {
#line 1304
    return (0);
  }
  {
#line 1307
  position___7 = l->startpos;
#line 1308
  adv_ws(l->buffer, & position___7);
#line 1309
  adv_element(l->buffer, & position___7, tbuf___20);
#line 1310
  bwb_strtoupper(tbuf___20);
#line 1312
  tmp = strcmp((char const   *)(tbuf___20), "SUB");
  }
#line 1312
  if (tmp == 0) {
#line 1314
    return (-1);
  }
#line 1317
  return (0);
}
}
#line 1338 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
struct bwb_line *bwb_endsub(struct bwb_line *line ) 
{ 
  struct bwb_variable *l ;
  register int c ;
  struct bwb_line *tmp ;

  {
#line 1351
  l = (excs + exsc)->local_variable;
#line 1352
  c = 0;
  {
#line 1352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1352
    if (! (c < (excs + exsc)->n_cvs)) {
#line 1352
      goto while_break;
    }
    {
#line 1354
    bwb_vtov((excs + exsc)->calling_variable[c], l);
#line 1355
    l = l->next;
#line 1352
    c ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1360
  bwb_decexec();
  }
#line 1365
  if ((excs + (exsc + 1))->code == 8) {
    {
#line 1367
    tmp = bwb_zline(line);
    }
#line 1367
    return (tmp);
  }
#line 1372
  (((excs + exsc)->line)->next)->position = 0;
#line 1373
  return (((excs + exsc)->line)->next);
}
}
#line 1387 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
extern struct bwb_line *find_label(char *buffer ) 
{ 
  struct fslte *f ;
  int tmp ;

  {
#line 1397
  f = fslt_start.next;
  {
#line 1397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1397
    if (! ((unsigned long )f != (unsigned long )(& fslt_end))) {
#line 1397
      goto while_break;
    }
    {
#line 1399
    tmp = strcmp((char const   *)buffer, (char const   *)f->name);
    }
#line 1399
    if (tmp == 0) {
#line 1405
      return (f->line);
    }
#line 1397
    f = f->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1410
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in find_label(): failed to find label <%s>",
          buffer);
#line 1411
  bwb_error(bwb_ebuf);
  }
#line 1416
  return ((struct bwb_line *)((void *)0));
}
}
#line 1434 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
struct bwb_line *bwb_doloop(struct bwb_line *l ) 
{ 
  struct bwb_line *tmp ;
  struct bwb_line *tmp___0 ;

  {
#line 1445
  if ((unsigned long )(excs + exsc)->while_line != (unsigned long )l) {
    {
#line 1448
    bwb_incexec();
#line 1449
    (excs + exsc)->while_line = l;
#line 1453
    (excs + exsc)->wend_line = find_loop(l);
    }
#line 1455
    if ((unsigned long )(excs + exsc)->wend_line == (unsigned long )((void *)0)) {
      {
#line 1457
      tmp = bwb_zline(l);
      }
#line 1457
      return (tmp);
    }
  }
  {
#line 1476
  bwb_setexec(l, l->position, 12);
#line 1477
  tmp___0 = bwb_zline(l);
  }
#line 1477
  return (tmp___0);
}
}
#line 1492 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
struct bwb_line *bwb_loop(struct bwb_line *l ) 
{ 
  char tbuf___20[5001] ;
  struct bwb_line *tmp ;
  struct bwb_line *tmp___0 ;
  int tmp___1 ;

  {
#line 1511
  if ((excs + exsc)->code == 2) {
    {
#line 1513
    tmp = bwb_wend(l);
    }
#line 1513
    return (tmp);
  }
#line 1518
  if ((excs + exsc)->code != 12) {
    {
#line 1521
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_loop(): exec stack code != EXEC_DO");
#line 1522
    bwb_error(bwb_ebuf);
    }
  }
#line 1528
  if ((unsigned long )(excs + exsc)->while_line == (unsigned long )((void *)0)) {
    {
#line 1531
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_loop(): exec stack while_line == NULL");
#line 1532
    bwb_error(bwb_ebuf);
    }
  }
  {
#line 1540
  adv_element(l->buffer, & l->position, tbuf___20);
#line 1541
  bwb_strtoupper(tbuf___20);
#line 1545
  tmp___1 = strcmp((char const   *)(tbuf___20), "UNTIL");
  }
#line 1545
  if (tmp___1 == 0) {
    {
#line 1553
    tmp___0 = bwb_loopuntil(l);
    }
#line 1553
    return (tmp___0);
  } else {
    {
#line 1570
    ((excs + exsc)->while_line)->position = 0;
#line 1571
    bwb_setexec((excs + exsc)->while_line, 0, 12);
    }
#line 1573
    return ((excs + exsc)->while_line);
  }
}
}
#line 1590 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
static struct bwb_line *bwb_loopuntil(struct bwb_line *l ) 
{ 
  struct exp_ese *e___0 ;
  struct bwb_line *r ;
  bnumber tmp ;

  {
  {
#line 1608
  e___0 = bwb_exp(l->buffer, 0, & l->position);
#line 1610
  tmp = exp_getnval(e___0);
  }
#line 1610
  if ((int )tmp != 0) {
    {
#line 1612
    (excs + exsc)->while_line = (struct bwb_line *)((void *)0);
#line 1613
    r = (excs + exsc)->wend_line;
#line 1614
    bwb_setexec(r, 0, (excs + (exsc - 1))->code);
#line 1615
    r->position = 0;
#line 1616
    bwb_decexec();
    }
#line 1617
    return (r);
  } else {
    {
#line 1631
    ((excs + exsc)->while_line)->position = 0;
#line 1632
    bwb_setexec((excs + exsc)->while_line, 0, 12);
    }
#line 1634
    return ((excs + exsc)->while_line);
  }
}
}
#line 1653 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
struct bwb_line *bwb_exit(struct bwb_line *l ) 
{ 
  char tbuf___20[5001] ;
  struct bwb_line *tmp ;
  int tmp___0 ;
  struct bwb_line *tmp___1 ;
  int tmp___2 ;
  struct bwb_line *tmp___3 ;

  {
  {
#line 1668
  adv_element(l->buffer, & l->position, tbuf___20);
#line 1669
  bwb_strtoupper(tbuf___20);
#line 1671
  tmp___0 = strcmp((char const   *)(tbuf___20), "FOR");
  }
#line 1671
  if (tmp___0 == 0) {
    {
#line 1679
    tmp = bwb_exitfor(l);
    }
#line 1679
    return (tmp);
  }
  {
#line 1682
  tmp___2 = strcmp((char const   *)(tbuf___20), "DO");
  }
#line 1682
  if (tmp___2 == 0) {
    {
#line 1684
    tmp___1 = bwb_exitdo(l);
    }
#line 1684
    return (tmp___1);
  }
  {
#line 1688
  sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_exit(): Nonsense or nothing following EXIT");
#line 1689
  bwb_error(bwb_ebuf);
#line 1694
  tmp___3 = bwb_zline(l);
  }
#line 1694
  return (tmp___3);
}
}
#line 1710 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
struct bwb_line *bwb_exitdo(struct bwb_line *l ) 
{ 
  struct bwb_line *next_line ;
  int found ;
  register int level ;
  struct bwb_line *tmp ;

  {
#line 1729
  found = 0;
#line 1730
  level = exsc;
  {
#line 1731
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1733
    if ((excs + level)->code == 12) {
#line 1735
      next_line = (excs + level)->wend_line;
#line 1736
      found = -1;
    } else {
#line 1740
      level --;
    }
#line 1731
    if (level >= 0) {
#line 1731
      if (! (found == 0)) {
#line 1731
        goto while_break;
      }
    } else {
#line 1731
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1745
  if (found != -1) {
    {
#line 1750
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_exitdo(): EXIT DO without DO");
#line 1751
    bwb_error(bwb_ebuf);
#line 1756
    tmp = bwb_zline(l);
    }
#line 1756
    return (tmp);
  }
  {
#line 1768
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1768
    if (! (exsc >= level)) {
#line 1768
      goto while_break___0;
    }
    {
#line 1770
    bwb_decexec();
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1775
  next_line->position = 0;
#line 1776
  bwb_setexec(next_line, 0, 0);
  }
#line 1778
  return (next_line);
}
}
#line 1795 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
struct bwb_variable *bwb_vtov(struct bwb_variable *dst , struct bwb_variable *src ) 
{ 
  bnumber *tmp ;
  bstring *tmp___0 ;
  bstring *tmp___1 ;

  {
#line 1806
  if ((unsigned long )dst == (unsigned long )src) {
#line 1808
    return (dst);
  }
#line 1811
  if (src->type != dst->type) {
    {
#line 1814
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_vtov(): mismatch src <%s> type <%d> dst <%s> type <%d>",
            src->name, src->type, dst->name, dst->type);
#line 1816
    bwb_error(bwb_ebuf);
    }
#line 1820
    return ((struct bwb_variable *)((void *)0));
  }
#line 1823
  if (dst->type == 1) {
    {
#line 1832
    tmp = var_findnval(dst, dst->array_pos);
#line 1832
    *tmp = var_getnval(src);
    }
  } else {
    {
#line 1836
    tmp___0 = var_getsval(src);
#line 1836
    tmp___1 = var_getsval(dst);
#line 1836
    str_btob(tmp___1, tmp___0);
    }
  }
#line 1839
  return (dst);
}
}
#line 1853 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
struct bwb_variable *bwb_etov(struct bwb_variable *dst , struct exp_ese *src ) 
{ 
  bnumber *tmp ;
  bstring *tmp___0 ;
  bstring *tmp___1 ;

  {
#line 1863
  if ((int )src->type != dst->type) {
    {
#line 1866
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in bwb_etov(): mismatch src <%d> dst <%d>",
            (int )src->type, dst->type);
#line 1868
    bwb_error(bwb_ebuf);
    }
#line 1872
    return ((struct bwb_variable *)((void *)0));
  }
#line 1875
  if (dst->type == 1) {
    {
#line 1877
    tmp = var_findnval(dst, dst->array_pos);
#line 1877
    *tmp = exp_getnval(src);
    }
  } else {
    {
#line 1881
    tmp___0 = exp_getsval(src);
#line 1881
    tmp___1 = var_getsval(dst);
#line 1881
    str_btob(tmp___1, tmp___0);
    }
  }
#line 1884
  return (dst);
}
}
#line 1898 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
struct bwb_variable *var_pos(struct bwb_variable *firstvar , int p___0 ) 
{ 
  register int c ;
  struct bwb_variable *v___0 ;

  {
#line 1910
  v___0 = firstvar;
#line 1911
  c = 0;
  {
#line 1911
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1911
    if (! (c != p___0)) {
#line 1911
      goto while_break;
    }
#line 1913
    v___0 = v___0->next;
#line 1911
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1922
  return (v___0);
}
}
#line 1936 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
int fslt_addcallvar(struct bwb_variable *v___0 ) 
{ 


  {
#line 1945
  if ((excs + exsc)->n_cvs >= 6) {
    {
#line 1948
    sprintf((char */* __restrict  */)bwb_ebuf, (char const   */* __restrict  */)"in fslt_addcallvar(): Maximum number of Function Args Exceeded");
#line 1949
    bwb_error(bwb_ebuf);
    }
  }
#line 1955
  (excs + exsc)->calling_variable[(excs + exsc)->n_cvs] = v___0;
#line 1956
  ((excs + exsc)->n_cvs) ++;
#line 1958
  return (-1);
}
}
#line 1973 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
int exp_ufnc(char *expression ) 
{ 
  char tbuf___20[5001] ;
  struct bwb_line *call_line ;
  struct fslte *f ;
  struct fslte *c ;
  struct bwb_variable *v___0 ;
  struct bwb_variable *r ;
  struct exp_ese *e___0 ;
  int save_elevel ;
  int position___7 ;
  int epos ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  bstring *tmp___2 ;
  bstring *tmp___3 ;

  {
  {
#line 1992
  position___7 = 0;
#line 1996
  exp_getvfname(expression, tbuf___20);
#line 2000
  f = fslt_start.next;
  }
  {
#line 2000
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2000
    if (! ((unsigned long )f != (unsigned long )(& fslt_end))) {
#line 2000
      goto while_break;
    }
    {
#line 2002
    tmp = strcmp((char const   *)f->name, (char const   *)(tbuf___20));
    }
#line 2002
    if (tmp == 0) {
#line 2009
      c = f;
#line 2010
      call_line = f->line;
    }
#line 2000
    f = f->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2019
  tmp___0 = strlen((char const   *)(tbuf___20));
#line 2019
  position___7 = (int )((size_t )position___7 + tmp___0);
#line 2029
  bwb_setexec((excs + exsc)->line, position___7, (excs + exsc)->code);
#line 2031
  save_elevel = exsc;
#line 2035
  bwb_incexec();
#line 2036
  call_line->position = 0;
#line 2037
  bwb_setexec(call_line, 0, 4);
#line 2041
  (excs + exsc)->local_variable = c->local_variable;
#line 2060
  call_readargs(c, expression, & position___7);
#line 2070
  epos = c->startpos;
#line 2071
  adv_ws(call_line->buffer, & epos);
  }
#line 2072
  if ((int )*(call_line->buffer + epos) == 61) {
    {
#line 2080
    epos ++;
#line 2081
    call_line->position = epos;
#line 2082
    bwb_setexec(call_line, epos, 4);
#line 2090
    e___0 = bwb_exp(call_line->buffer, 0, & epos);
#line 2091
    v___0 = var_find(tbuf___20);
#line 2114
    bwb_etov(v___0, e___0);
#line 2115
    bwb_decexec();
    }
  } else {
    {
#line 2130
    bwb_execline();
    }
    {
#line 2131
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2131
      if (! (exsc > save_elevel)) {
#line 2131
        goto while_break___0;
      }
      {
#line 2133
      bwb_execline();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2138
    r = c->local_variable;
    {
#line 2138
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2138
      if (! ((unsigned long )r != (unsigned long )((void *)0))) {
#line 2138
        goto while_break___1;
      }
      {
#line 2140
      tmp___1 = strcmp((char const   *)(r->name), (char const   *)c->name);
      }
#line 2140
      if (tmp___1 == 0) {
#line 2142
        v___0 = r;
      }
#line 2138
      r = r->next;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 2150
  (exps + expsc)->type = (char )v___0->type;
#line 2151
  (exps + expsc)->pos_adv = position___7;
  {
#line 2155
  if (v___0->type == 36) {
#line 2155
    goto case_36;
  }
#line 2175
  goto switch_default;
  case_36: /* CIL Label */ 
  {
#line 2156
  (exps + expsc)->operation = 2;
#line 2164
  tmp___2 = var_getsval(v___0);
#line 2164
  tmp___3 = exp_getsval(exps + expsc);
#line 2164
  str_btob(tmp___3, tmp___2);
  }
#line 2173
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2176
  (exps + expsc)->operation = 1;
#line 2177
  (exps + expsc)->nval = var_getnval(v___0);
  }
#line 2178
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2181
  return (-1);
}
}
#line 2196 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
int fslt_addlocalvar(struct fslte *f , struct bwb_variable *v___0 ) 
{ 
  struct bwb_variable *c ;
  struct bwb_variable *p___0 ;

  {
#line 2212
  if ((unsigned long )f->local_variable == (unsigned long )((void *)0)) {
#line 2217
    f->local_variable = v___0;
  } else {
#line 2224
    p___0 = f->local_variable;
#line 2225
    c = (f->local_variable)->next;
    {
#line 2225
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2225
      if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 2225
        goto while_break;
      }
#line 2227
      p___0 = c;
#line 2225
      c = c->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 2232
    p___0->next = v___0;
  }
#line 2235
  v___0->next = (struct bwb_variable *)((void *)0);
#line 2244
  return (-1);
}
}
#line 2258 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
int fslt_init(int task ) 
{ 


  {
#line 2266
  fslt_start.next = & fslt_end;
#line 2267
  return (-1);
}
}
#line 2281 "/home/june/collector/temp/bwbasic-2.20pl2/bwb_stc.c"
extern int is_label(char *buffer ) 
{ 
  size_t tmp ;

  {
  {
#line 2295
  tmp = strlen((char const   *)buffer);
  }
#line 2295
  if ((int )*(buffer + (tmp - 1UL)) == 58) {
#line 2297
    return (-1);
  } else {
#line 2301
    return (0);
  }
}
}
