/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 38 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
typedef unsigned int GlyphIndex;
#line 320 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
struct __anonstruct_chr_24 {
   double x ;
   double y ;
};
#line 320 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
struct __anonstruct_MetricsRec_23 {
   double blx ;
   double bly ;
   double toprx ;
   double topry ;
   struct __anonstruct_chr_24 chr[256] ;
};
#line 320 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
typedef struct __anonstruct_MetricsRec_23 MetricsRec;
#line 324 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
typedef MetricsRec *Metrics;
#line 325 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
typedef Metrics MetricsTable[];
#line 327 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
typedef GlyphIndex EncodingVector[256];
#line 328 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
typedef EncodingVector *Encoding;
#line 329 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
typedef Encoding EncodingTable[];
#line 331 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
struct __anonstruct_FontRec_25 {
   double x ;
   double y ;
   double xp ;
   double yp ;
   int e ;
   int m ;
   double bx ;
   double by ;
   double tx ;
   double ty ;
};
#line 331 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
typedef struct __anonstruct_FontRec_25 FontRec;
#line 338 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
typedef FontRec *Font;
#line 339 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
typedef Font FontTable[];
#line 346 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
struct __anonstruct_T_26 {
   double itransform[6] ;
   int metricsSize ;
   MetricsTable *metrics ;
   int encodingSize ;
   EncodingTable *encoding ;
   int dvipsIsCork ;
   int fontSize ;
   FontTable *font ;
   char buf[1000] ;
   int lbuf ;
   int f ;
   double x0 ;
   double y0 ;
   double x1 ;
   double y1 ;
   int nonEmptyPage ;
   long blx ;
   long bly ;
   long toprx ;
   long topry ;
   char word[1000] ;
   int state ;
   int encoding_e ;
   int encoding_n ;
   int encoding_i ;
   int metrics_m ;
   int metrics_i ;
};
#line 346 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
typedef struct __anonstruct_T_26 T;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 260 "/usr/include/unistd.h"
typedef __pid_t pid_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 56 "/home/wheatley/newnew/temp/pstotext-1.9/main.c"
enum __anonenum_orientation_52 {
    portrait = 0,
    landscape = 1,
    landscapeOther = 2
} ;
#line 139 "/home/wheatley/newnew/temp/pstotext-1.9/main.c"
union __anonunion_53 {
   int __in ;
   int __i ;
};
#line 138 "/home/wheatley/newnew/temp/pstotext-1.9/main.c"
union __anonunion_54 {
   int __in ;
   int __i ;
};
#line 137 "/home/wheatley/newnew/temp/pstotext-1.9/main.c"
union __anonunion_55 {
   int __in ;
   int __i ;
};
#line 178 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ceil)(double __x )  __attribute__((__const__)) ;
#line 184
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 38 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.h"
int pstotextInit(void **instance___0 ) ;
#line 43
int pstotextSetCork(void *instance___0 , int value ) ;
#line 47
int pstotextFilter(void *instance___0 , char *instr , char const   **pre , char const   **word ,
                   char const   **post , int *llx , int *lly , int *urx , int *ury ) ;
#line 73
int pstotextExit(void *instance___0 ) ;
#line 51 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
static char const   *SpecialGlyphs[28]  = 
#line 51 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
  {      "\'\'",      "S\237",      "+",      "<", 
        "Z\237",      "#",      "L/",      "...", 
        ">",      "oe",      "fi",      ".", 
        "o/oo",      "\'\'",      "--",      "---", 
        "^TM",      "f",      "l/",      "s\237", 
        "Y\250",      "fl",      "/",      "``", 
        "\'",      "\'",      "z\237",      "OE"};
#line 101 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
static char const   *TTSpecialGlyphs[30]  = 
#line 101
  {      "\'",      "f",      "\'\'",      "...", 
        "+",      "#",      "\223",      "o/oo", 
        "S\237",      "<",      "OE",      "#", 
        "#",      "#",      "#",      "`", 
        "\'",      "``",      "\'\'",      ".", 
        "--",      "---",      "~",      "^TM", 
        "s\237",      ">",      "oe",      "#", 
        "#",      "Y\250"};
#line 136 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
static char const   *DvipsGlyphs[128]  = 
#line 136
  {      "\\Gamma",      "\\Delta",      "\\Theta",      "\\Lambda", 
        "\\Xi",      "\\Pi",      "\\Sigma",      "\\Upsilon", 
        "\\Phi",      "\\Psi",      "\\Omega",      "ff", 
        "fi",      "fl",      "ffi",      "ffl", 
        "i",      "j",      "`",      "\'", 
        "\237",      "\226",      "\257",      "\232", 
        "\270",      "\337",      "ae",      "oe", 
        "\370",      "AE",      "OE",      "\330", 
        "/",      "!",      "\'\'",      "#", 
        "$",      "%",      "&",      "\'", 
        "(",      ")",      "*",      "+", 
        ",",      "\255",      ".",      "/", 
        "0",      "1",      "2",      "3", 
        "4",      "5",      "6",      "7", 
        "8",      "9",      ":",      ";", 
        "!",      "=",      "?",      "?", 
        "@",      "A",      "B",      "C", 
        "D",      "E",      "F",      "G", 
        "H",      "I",      "J",      "K", 
        "L",      "M",      "N",      "O", 
        "P",      "Q",      "R",      "S", 
        "T",      "U",      "V",      "W", 
        "X",      "Y",      "Z",      "[", 
        "``",      "]",      "\223",      "\227", 
        "`",      "a",      "b",      "c", 
        "d",      "e",      "f",      "g", 
        "h",      "i",      "j",      "k", 
        "l",      "m",      "n",      "o", 
        "p",      "q",      "r",      "s", 
        "t",      "u",      "v",      "w", 
        "x",      "y",      "z",      "--", 
        "---",      "\235",      "~",      "\250"};
#line 197 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
static char const   *CorkSpecialGlyphs[192]  = 
#line 197
  {      "`",      "\'",      "^",      "~", 
        "\230",      "\235",      "\232",      "\237", 
        "\226",      "\257",      "\227",      "\270", 
        "\236",      "\'",      "<",      ">", 
        "``",      "\'\'",      ",,",      "<<", 
        ">>",      "--",      "---",      "", 
        "o",      "\220",      "j",      "ff", 
        "fi",      "fl",      "ffi",      "ffl", 
        "_",      "!",      "\"",      "#", 
        "$",      "%",      "&",      "\'", 
        "(",      ")",      "*",      "+", 
        ",",      "-",      ".",      "/", 
        "0",      "1",      "2",      "3", 
        "4",      "5",      "6",      "7", 
        "8",      "9",      ":",      ";", 
        "<",      "=",      ">",      "?", 
        "@",      "A",      "B",      "C", 
        "D",      "E",      "F",      "G", 
        "H",      "I",      "J",      "K", 
        "L",      "M",      "N",      "O", 
        "P",      "Q",      "R",      "S", 
        "T",      "U",      "V",      "W", 
        "X",      "Y",      "Z",      "[", 
        "\\",      "]",      "^",      "_", 
        "`",      "a",      "b",      "c", 
        "d",      "e",      "f",      "g", 
        "h",      "i",      "j",      "k", 
        "l",      "m",      "n",      "o", 
        "p",      "q",      "r",      "s", 
        "t",      "u",      "v",      "w", 
        "x",      "y",      "z",      "{", 
        "|",      "}",      "~",      "\255", 
        "A\226",      "A\236",      "C\264",      "C\237", 
        "D\237",      "E\237",      "E\236",      "G\226", 
        "L\264",      "L\237",      "L/",      "N\264", 
        "N\237",      "\\NG",      "O\235",      "R\264", 
        "R\237",      "S\264",      "S\237",      "S\270", 
        "T\237",      "T\270",      "U\235",      "U\232", 
        "Y\250",      "Z\264",      "Z\237",      "Z\227", 
        "IJ",      "I\227",      "\\dj",      "\247", 
        "a\226",      "a\236",      "c\222",      "c\237", 
        "d\237",      "e\237",      "e\236",      "g\226", 
        "l\222",      "l\237",      "l/",      "n\222", 
        "n\237",      "\\ng",      "o\235",      "r\222", 
        "r\237",      "s\222",      "s\237",      "s\270", 
        "t\237",      "t\270",      "u\235",      "u\232", 
        "y\230",      "z\222",      "z\237",      "z\227", 
        "ij",      "\241",      "\277",      "\243"};
#line 371
static int ReadChar(char **instr ) ;
#line 372
static void UnreadChar(char **instr ) ;
#line 373
static int ReadInt(char **instr ) ;
#line 374
static long ReadLong(char **instr ) ;
#line 375
static int ParseInverseTransform(T *t , char *instr ) ;
#line 376
static int ParseEncoding(T *t , char *instr ) ;
#line 377
static int ParseEncodingMore(T *t , char *instr ) ;
#line 378
static void ReadPair(double *x , double *y , char **instr ) ;
#line 379
static int ParseFont(T *t , char *instr ) ;
#line 380
static int ParseMetrics(T *t , char *instr ) ;
#line 381
static int ParseMetricsMore(T *t , char *instr ) ;
#line 382
static void Itransform(T *t , double *x1 , double *y1___0 , double x0 , double y0___0 ) ;
#line 383
static void Output(T *t , char const   **pre , char const   **word , int *llx , int *lly ,
                   int *urx , int *ury ) ;
#line 385
static int SameDirection(double x0 , double y0___0 , double x1 , double y1___0 ) ;
#line 386
static int ParseString(T *t , char *instr , char const   **pre , char const   **word ,
                       char const   **post , int *llx , int *lly , int *urx , int *ury ) ;
#line 390 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
int pstotextInit(void **instance___0 ) 
{ 
  T *t ;
  int i ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;

  {
  {
#line 394
  tmp = malloc(sizeof(T ));
#line 394
  t = (T *)tmp;
  }
#line 395
  if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 395
    return (100);
  }
  {
#line 397
  t->state = 0;
#line 400
  t->itransform[0] = 1.0;
#line 401
  t->itransform[1] = 0.0;
#line 402
  t->itransform[2] = 0.0;
#line 403
  t->itransform[3] = 1.0;
#line 404
  t->itransform[4] = 0.0;
#line 405
  t->itransform[5] = 0.0;
#line 407
  tmp___1 = 100;
#line 407
  t->fontSize = tmp___1;
#line 407
  tmp___0 = tmp___1;
#line 407
  t->encodingSize = tmp___0;
#line 407
  t->metricsSize = tmp___0;
#line 409
  tmp___2 = malloc((unsigned long )t->metricsSize * sizeof(Metrics ));
#line 409
  t->metrics = (MetricsTable *)tmp___2;
  }
#line 410
  if ((unsigned long )t->metrics == (unsigned long )((void *)0)) {
    {
#line 411
    free((void *)t);
    }
#line 412
    return (100);
  }
#line 414
  i = 0;
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! (i < t->metricsSize)) {
#line 414
      goto while_break;
    }
#line 414
    (*(t->metrics))[i] = (Metrics )((void *)0);
#line 414
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 416
  tmp___3 = malloc((unsigned long )t->encodingSize * sizeof(Encoding ));
#line 416
  t->encoding = (EncodingTable *)tmp___3;
  }
#line 417
  if ((unsigned long )t->encoding == (unsigned long )((void *)0)) {
    {
#line 418
    free((void *)t);
    }
#line 419
    return (100);
  }
#line 421
  i = 0;
  {
#line 421
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 421
    if (! (i < t->encodingSize)) {
#line 421
      goto while_break___0;
    }
#line 421
    (*(t->encoding))[i] = (Encoding )((void *)0);
#line 421
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 423
  t->dvipsIsCork = 0;
#line 425
  tmp___4 = malloc((unsigned long )t->fontSize * sizeof(Font ));
#line 425
  t->font = (FontTable *)tmp___4;
  }
#line 426
  if ((unsigned long )t->font == (unsigned long )((void *)0)) {
    {
#line 427
    free((void *)t);
    }
#line 428
    return (100);
  }
#line 430
  i = 0;
  {
#line 430
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 430
    if (! (i < t->fontSize)) {
#line 430
      goto while_break___1;
    }
#line 430
    (*(t->font))[i] = (Font )((void *)0);
#line 430
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 432
  t->lbuf = 0;
#line 433
  t->nonEmptyPage = 0;
#line 434
  tmp___7 = 0L;
#line 434
  t->topry = tmp___7;
#line 434
  tmp___6 = tmp___7;
#line 434
  t->toprx = tmp___6;
#line 434
  tmp___5 = tmp___6;
#line 434
  t->bly = tmp___5;
#line 434
  t->blx = tmp___5;
#line 436
  *instance___0 = (void *)t;
#line 438
  return (0);
}
}
#line 441 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
int pstotextSetCork(void *instance___0 , int value ) 
{ 
  T *t ;

  {
#line 442
  t = (T *)instance___0;
#line 443
  t->dvipsIsCork = value;
#line 444
  return (0);
}
}
#line 447 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
int pstotextExit(void *instance___0 ) 
{ 
  T *t ;

  {
  {
#line 448
  t = (T *)instance___0;
#line 449
  free((void *)t->metrics);
#line 450
  free((void *)t->encoding);
#line 451
  free((void *)t->font);
#line 452
  free((void *)t);
  }
#line 453
  return (0);
}
}
#line 456 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
static int ReadChar(char **instr ) 
{ 
  int c ;

  {
#line 457
  c = (int )*(*((unsigned char **)instr));
#line 458
  (*instr) ++;
#line 459
  return (c);
}
}
#line 462 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
static void UnreadChar(char **instr ) 
{ 


  {
#line 463
  (*instr) --;
#line 464
  return;
}
}
#line 466 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
static int ReadInt(char **instr ) 
{ 
  int i ;
  int sign ;
  int c ;

  {
#line 467
  i = 0;
#line 468
  sign = 1;
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 470
    c = ReadChar(instr);
    }
#line 470
    if (! (c == 32)) {
#line 470
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 471
  if (c == 45) {
    {
#line 471
    sign = -1;
#line 471
    c = ReadChar(instr);
    }
  }
  {
#line 472
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 472
    if (48 <= c) {
#line 472
      if (! (c <= 57)) {
#line 472
        goto while_break___0;
      }
    } else {
#line 472
      goto while_break___0;
    }
    {
#line 472
    i = i * 10 + (c - 48);
#line 472
    c = ReadChar(instr);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 473
  UnreadChar(instr);
  }
#line 474
  return (i * sign);
}
}
#line 477 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
static long ReadLong(char **instr ) 
{ 
  long i ;
  int sign ;
  int c ;

  {
#line 478
  i = 0L;
#line 479
  sign = 1;
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 481
    c = ReadChar(instr);
    }
#line 481
    if (! (c == 32)) {
#line 481
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 482
  if (c == 45) {
    {
#line 482
    sign = -1;
#line 482
    c = ReadChar(instr);
    }
  }
  {
#line 483
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 483
    if (48 <= c) {
#line 483
      if (! (c <= 57)) {
#line 483
        goto while_break___0;
      }
    } else {
#line 483
      goto while_break___0;
    }
    {
#line 483
    i = i * 10L + (long )(c - 48);
#line 483
    c = ReadChar(instr);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 484
  UnreadChar(instr);
  }
#line 485
  return (i * (long )sign);
}
}
#line 488 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
static int ParseInverseTransform(T *t , char *instr ) 
{ 
  int i ;
  long tmp ;

  {
#line 490
  i = 0;
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! (i < 6)) {
#line 490
      goto while_break;
    }
    {
#line 490
    tmp = ReadLong(& instr);
#line 490
    t->itransform[i] = (double )tmp / 100.0;
#line 490
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 491
  return (0);
}
}
#line 494 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
static int ParseEncoding(T *t , char *instr ) 
{ 
  int e ;
  int tmp ;
  int n ;
  int tmp___0 ;
  int i ;
  int oldSize ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 496
  tmp = ReadInt(& instr);
#line 496
  e = tmp;
#line 497
  tmp___0 = ReadInt(& instr);
#line 497
  n = tmp___0;
  }
#line 499
  if (e < 0) {
#line 499
    return (200);
  }
#line 500
  if (n > 1024) {
#line 500
    return (201);
  }
#line 503
  if (t->encodingSize <= e) {
    {
#line 504
    oldSize = t->encodingSize;
#line 505
    t->encodingSize = 2 * e;
#line 506
    tmp___1 = realloc((void *)((char *)t->encoding), (unsigned long )t->encodingSize * sizeof(Encoding ));
#line 506
    t->encoding = (EncodingTable *)tmp___1;
#line 510
    i = oldSize;
    }
    {
#line 510
    while (1) {
      while_continue: /* CIL Label */ ;
#line 510
      if (! (i < t->encodingSize)) {
#line 510
        goto while_break;
      }
#line 510
      (*(t->encoding))[i] = (Encoding )((void *)0);
#line 510
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 514
  if ((unsigned long )(*(t->encoding))[e] == (unsigned long )((void *)0)) {
    {
#line 515
    tmp___2 = malloc(sizeof(EncodingVector ));
#line 515
    (*(t->encoding))[e] = (EncodingVector *)tmp___2;
    }
  }
#line 517
  t->state = 2;
#line 518
  t->encoding_e = e;
#line 518
  t->encoding_n = n;
#line 518
  t->encoding_i = 0;
#line 520
  return (0);
}
}
#line 523 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
static int ParseEncodingMore(T *t , char *instr ) 
{ 
  Encoding enc ;
  int i ;
  int tooSparse ;
  int tmp ;

  {
#line 525
  enc = (*(t->encoding))[t->encoding_e];
#line 528
  i = t->encoding_i;
  {
#line 528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 528
    if (! (i < t->encoding_i + 16)) {
#line 528
      goto while_break;
    }
#line 529
    if (i < t->encoding_n) {
      {
#line 529
      tmp = ReadInt(& instr);
#line 529
      (*enc)[i] = (GlyphIndex )tmp;
      }
    } else {
#line 529
      (*enc)[i] = (GlyphIndex )9999;
    }
#line 528
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 531
  t->encoding_i += 16;
#line 532
  if (! (t->encoding_i < 256)) {
#line 535
    t->state = 0;
#line 540
    tooSparse = 0;
#line 541
    i = 'a';
    {
#line 541
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 541
      if (! (i <= 122)) {
#line 541
        goto while_break___0;
      }
#line 542
      tooSparse = (*enc)[i] == 9999U;
#line 541
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 543
    if (tooSparse) {
#line 544
      i = 0;
      {
#line 544
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 544
        if (! (i < 256)) {
#line 544
          goto while_break___1;
        }
#line 545
        if ((*enc)[i] == 9999U) {
#line 545
          (*enc)[i] = (GlyphIndex )i;
        }
#line 544
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 548
  return (0);
}
}
#line 555 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
static void ReadPair(double *x , double *y , char **instr ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
  {
#line 556
  tmp = ReadLong(instr);
#line 556
  *x = (double )tmp / 100.0;
#line 557
  tmp___0 = ReadLong(instr);
#line 557
  *y = (double )tmp___0 / 100.0;
  }
#line 558
  return;
}
}
#line 560 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
static int ParseFont(T *t , char *instr ) 
{ 
  int n ;
  int tmp ;
  int i ;
  Metrics mt ;
  Font f ;
  double xmax ;
  double bly ;
  double topry ;
  int oldSize ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 562
  tmp = ReadInt(& instr);
#line 562
  n = tmp;
  }
#line 566
  if (n < 0) {
#line 566
    return (202);
  }
#line 569
  if (t->fontSize <= n) {
    {
#line 570
    oldSize = t->fontSize;
#line 571
    t->fontSize = 2 * n;
#line 572
    tmp___0 = realloc((void *)((char *)t->font), (unsigned long )t->fontSize * sizeof(Font ));
#line 572
    t->font = (FontTable *)tmp___0;
#line 576
    i = oldSize;
    }
    {
#line 576
    while (1) {
      while_continue: /* CIL Label */ ;
#line 576
      if (! (i < t->fontSize)) {
#line 576
        goto while_break;
      }
#line 576
      (*(t->font))[i] = (Font )((void *)0);
#line 576
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 580
  if ((unsigned long )(*(t->font))[n] == (unsigned long )((void *)0)) {
    {
#line 581
    tmp___1 = malloc(sizeof(FontRec ));
#line 581
    (*(t->font))[n] = (Font )tmp___1;
    }
  }
  {
#line 583
  f = (*(t->font))[n];
#line 584
  ReadPair(& f->x, & f->y, & instr);
#line 585
  ReadPair(& f->xp, & f->yp, & instr);
#line 586
  f->e = ReadInt(& instr);
  }
#line 587
  if ((unsigned long )(*(t->encoding))[f->e] == (unsigned long )((void *)0)) {
#line 587
    return (200);
  }
  {
#line 588
  f->m = ReadInt(& instr);
#line 589
  mt = (*(t->metrics))[f->m];
  }
#line 590
  if ((unsigned long )mt == (unsigned long )((void *)0)) {
#line 590
    return (203);
  }
#line 593
  f->bx = (f->xp * mt->bly) / 1000.0;
#line 594
  f->by = (f->yp * mt->bly) / 1000.0;
#line 595
  f->tx = (f->xp * mt->topry) / 1000.0;
#line 596
  f->ty = (f->yp * mt->topry) / 1000.0;
#line 601
  if (f->by - f->ty < 1.1) {
#line 602
    xmax = 0.0;
#line 603
    i = 0;
    {
#line 603
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 603
      if (! (i < 256)) {
#line 603
        goto while_break___0;
      }
#line 604
      if (mt->chr[i].x > xmax) {
#line 604
        xmax = mt->chr[i].x;
      }
#line 603
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 605
    bly = - 0.3 * xmax;
#line 605
    topry = 0.9 * xmax;
#line 606
    f->bx = (f->xp * bly) / 1000.0;
#line 607
    f->by = (f->yp * bly) / 1000.0;
#line 608
    f->tx = (f->xp * topry) / 1000.0;
#line 609
    f->ty = (f->yp * topry) / 1000.0;
  }
#line 612
  return (0);
}
}
#line 615 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
static int ParseMetrics(T *t , char *instr ) 
{ 
  int m ;
  int tmp ;
  int i ;
  Metrics mt ;
  int oldSize ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 617
  tmp = ReadInt(& instr);
#line 617
  m = tmp;
  }
#line 620
  if (m < 0) {
#line 620
    return (203);
  }
#line 623
  if (t->metricsSize <= m) {
    {
#line 624
    oldSize = t->metricsSize;
#line 625
    t->metricsSize = 2 * m;
#line 626
    tmp___0 = realloc((void *)((char *)t->metrics), (unsigned long )t->metricsSize * sizeof(Metrics ));
#line 626
    t->metrics = (MetricsTable *)tmp___0;
#line 630
    i = oldSize;
    }
    {
#line 630
    while (1) {
      while_continue: /* CIL Label */ ;
#line 630
      if (! (i < t->metricsSize)) {
#line 630
        goto while_break;
      }
#line 630
      (*(t->metrics))[i] = (Metrics )((void *)0);
#line 630
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 634
  if ((unsigned long )(*(t->metrics))[m] == (unsigned long )((void *)0)) {
    {
#line 635
    tmp___1 = malloc(sizeof(MetricsRec ));
#line 635
    (*(t->metrics))[m] = (Metrics )tmp___1;
    }
  }
  {
#line 637
  mt = (*(t->metrics))[m];
#line 639
  ReadPair(& mt->blx, & mt->bly, & instr);
#line 640
  ReadPair(& mt->toprx, & mt->topry, & instr);
#line 642
  t->state = 1;
#line 642
  t->metrics_m = m;
#line 642
  t->metrics_i = 0;
  }
#line 644
  return (0);
}
}
#line 647 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
static int ParseMetricsMore(T *t , char *instr ) 
{ 
  int i ;
  Metrics mt ;

  {
#line 650
  mt = (*(t->metrics))[t->metrics_m];
#line 652
  i = t->metrics_i;
  {
#line 652
  while (1) {
    while_continue: /* CIL Label */ ;
#line 652
    if (! (i < t->metrics_i + 8)) {
#line 652
      goto while_break;
    }
    {
#line 653
    ReadPair(& mt->chr[i].x, & mt->chr[i].y, & instr);
#line 652
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 655
  t->metrics_i += 8;
#line 656
  if (! (t->metrics_i < 256)) {
#line 659
    t->state = 0;
#line 662
    if (mt->blx == 0.0) {
#line 662
      if (mt->bly == 0.0) {
#line 662
        if (mt->toprx == 0.0) {
#line 662
          if (mt->topry == 0.0) {
#line 663
            i = 0;
            {
#line 663
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 663
              if (! (i < 256)) {
#line 663
                goto while_break___0;
              }
#line 664
              if (mt->chr[i].x > mt->toprx) {
#line 664
                mt->toprx = mt->chr[i].x;
              }
#line 663
              i ++;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 665
            mt->bly = - 0.3 * mt->toprx;
#line 666
            mt->topry = 0.9 * mt->toprx;
          }
        }
      }
    }
  }
#line 670
  return (0);
}
}
#line 673 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
static void Itransform(T *t , double *x1 , double *y1___0 , double x0 , double y0___0 ) 
{ 


  {
#line 675
  *x1 = (t->itransform[0] * x0 + t->itransform[2] * y0___0) + t->itransform[4];
#line 676
  *y1___0 = (t->itransform[1] * x0 + t->itransform[3] * y0___0) + t->itransform[5];
#line 677
  return;
}
}
#line 679 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
static void Output(T *t , char const   **pre , char const   **word , int *llx , int *lly ,
                   int *urx , int *ury ) 
{ 
  double x0 ;
  double y0___0 ;
  double x1 ;
  double y1___0 ;
  double x2 ;
  double y2 ;
  double x3 ;
  double y3 ;
  long blx ;
  long bly ;
  long toprx ;
  long topry ;
  long mid ;
  Font f ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  double tmp___23 ;
  double tmp___24 ;
  double tmp___25 ;
  double tmp___26 ;
  double tmp___32 ;
  double tmp___33 ;
  double tmp___34 ;
  double tmp___35 ;
  double tmp___37 ;
  double tmp___38 ;
  double tmp___39 ;
  double tmp___40 ;
  double tmp___46 ;
  double tmp___47 ;
  double tmp___48 ;
  double tmp___49 ;
  double tmp___51 ;
  double tmp___52 ;
  double tmp___53 ;
  double tmp___54 ;
  double tmp___55 ;
  double tmp___56 ;
  double tmp___57 ;
  double tmp___58 ;

  {
#line 686
  f = (*(t->font))[t->f];
#line 693
  x0 = t->x0 + f->bx;
#line 693
  y0___0 = t->y0 + f->by;
#line 694
  x1 = t->x1 + f->bx;
#line 694
  y1___0 = t->y1 + f->by;
#line 695
  x2 = t->x0 + f->tx;
#line 695
  y2 = t->y0 + f->ty;
#line 696
  x3 = t->x1 + f->tx;
#line 696
  y3 = t->y1 + f->ty;
#line 698
  if (x0 <= x1) {
#line 698
    tmp___11 = x0;
  } else {
#line 698
    tmp___11 = x1;
  }
#line 698
  if (tmp___11 <= x2) {
#line 698
    if (x0 <= x1) {
#line 698
      tmp___9 = x0;
    } else {
#line 698
      tmp___9 = x1;
    }
#line 698
    tmp___10 = tmp___9;
  } else {
#line 698
    tmp___10 = x2;
  }
#line 698
  if (tmp___10 <= x3) {
#line 698
    if (x0 <= x1) {
#line 698
      tmp___6 = x0;
    } else {
#line 698
      tmp___6 = x1;
    }
#line 698
    if (tmp___6 <= x2) {
#line 698
      if (x0 <= x1) {
#line 698
        tmp___4 = x0;
      } else {
#line 698
        tmp___4 = x1;
      }
#line 698
      tmp___5 = tmp___4;
    } else {
#line 698
      tmp___5 = x2;
    }
#line 698
    tmp___7 = tmp___5;
  } else {
#line 698
    tmp___7 = x3;
  }
  {
#line 698
  tmp___12 = ceil(tmp___7);
#line 698
  blx = (long )tmp___12;
  }
#line 699
  if (y1___0 <= y0___0) {
#line 699
    tmp___25 = y0___0;
  } else {
#line 699
    tmp___25 = y1___0;
  }
#line 699
  if (y2 <= tmp___25) {
#line 699
    if (y1___0 <= y0___0) {
#line 699
      tmp___23 = y0___0;
    } else {
#line 699
      tmp___23 = y1___0;
    }
#line 699
    tmp___24 = tmp___23;
  } else {
#line 699
    tmp___24 = y2;
  }
#line 699
  if (y3 <= tmp___24) {
#line 699
    if (y1___0 <= y0___0) {
#line 699
      tmp___20 = y0___0;
    } else {
#line 699
      tmp___20 = y1___0;
    }
#line 699
    if (y2 <= tmp___20) {
#line 699
      if (y1___0 <= y0___0) {
#line 699
        tmp___18 = y0___0;
      } else {
#line 699
        tmp___18 = y1___0;
      }
#line 699
      tmp___19 = tmp___18;
    } else {
#line 699
      tmp___19 = y2;
    }
#line 699
    tmp___21 = tmp___19;
  } else {
#line 699
    tmp___21 = y3;
  }
  {
#line 699
  tmp___26 = ceil(tmp___21);
#line 699
  bly = (long )tmp___26;
  }
#line 700
  if (x1 <= x0) {
#line 700
    tmp___39 = x0;
  } else {
#line 700
    tmp___39 = x1;
  }
#line 700
  if (x2 <= tmp___39) {
#line 700
    if (x1 <= x0) {
#line 700
      tmp___37 = x0;
    } else {
#line 700
      tmp___37 = x1;
    }
#line 700
    tmp___38 = tmp___37;
  } else {
#line 700
    tmp___38 = x2;
  }
#line 700
  if (x3 <= tmp___38) {
#line 700
    if (x1 <= x0) {
#line 700
      tmp___34 = x0;
    } else {
#line 700
      tmp___34 = x1;
    }
#line 700
    if (x2 <= tmp___34) {
#line 700
      if (x1 <= x0) {
#line 700
        tmp___32 = x0;
      } else {
#line 700
        tmp___32 = x1;
      }
#line 700
      tmp___33 = tmp___32;
    } else {
#line 700
      tmp___33 = x2;
    }
#line 700
    tmp___35 = tmp___33;
  } else {
#line 700
    tmp___35 = x3;
  }
  {
#line 700
  tmp___40 = floor(tmp___35);
#line 700
  toprx = (long )tmp___40;
  }
#line 701
  if (y0___0 <= y1___0) {
#line 701
    tmp___53 = y0___0;
  } else {
#line 701
    tmp___53 = y1___0;
  }
#line 701
  if (tmp___53 <= y2) {
#line 701
    if (y0___0 <= y1___0) {
#line 701
      tmp___51 = y0___0;
    } else {
#line 701
      tmp___51 = y1___0;
    }
#line 701
    tmp___52 = tmp___51;
  } else {
#line 701
    tmp___52 = y2;
  }
#line 701
  if (tmp___52 <= y3) {
#line 701
    if (y0___0 <= y1___0) {
#line 701
      tmp___48 = y0___0;
    } else {
#line 701
      tmp___48 = y1___0;
    }
#line 701
    if (tmp___48 <= y2) {
#line 701
      if (y0___0 <= y1___0) {
#line 701
        tmp___46 = y0___0;
      } else {
#line 701
        tmp___46 = y1___0;
      }
#line 701
      tmp___47 = tmp___46;
    } else {
#line 701
      tmp___47 = y2;
    }
#line 701
    tmp___49 = tmp___47;
  } else {
#line 701
    tmp___49 = y3;
  }
  {
#line 701
  tmp___54 = floor(tmp___49);
#line 701
  topry = (long )tmp___54;
  }
#line 703
  if (blx != toprx) {
#line 703
    if (bly != topry) {
#line 706
      if (t->nonEmptyPage) {
#line 707
        mid = (topry + bly) / 2L;
#line 708
        if (blx < toprx) {
#line 708
          if (topry < bly) {
#line 708
            if (t->blx <= blx) {
#line 708
              if (t->topry <= mid) {
#line 708
                if (mid <= t->bly) {
#line 711
                  *pre = " ";
                } else {
#line 712
                  *pre = "\n";
                }
              } else {
#line 712
                *pre = "\n";
              }
            } else {
#line 712
              *pre = "\n";
            }
          } else {
#line 712
            *pre = "\n";
          }
        } else {
#line 712
          *pre = "\n";
        }
      } else {
#line 714
        *pre = "";
      }
      {
#line 717
      t->buf[t->lbuf] = (char )'\000';
#line 718
      strncpy((char */* __restrict  */)(t->word), (char const   */* __restrict  */)(t->buf),
              (size_t )(t->lbuf + 1));
#line 719
      *word = (char const   *)(t->word);
#line 721
      t->nonEmptyPage = 1;
#line 722
      t->blx = blx;
#line 722
      t->bly = bly;
#line 722
      t->toprx = toprx;
#line 722
      t->topry = topry;
#line 725
      Itransform(t, & x1, & y1___0, (double )blx, (double )bly);
#line 726
      tmp___55 = floor(x1);
#line 726
      blx = (long )tmp___55;
#line 726
      tmp___56 = floor(y1___0);
#line 726
      bly = (long )tmp___56;
#line 727
      Itransform(t, & x1, & y1___0, (double )toprx, (double )topry);
#line 728
      tmp___57 = ceil(x1);
#line 728
      toprx = (long )tmp___57;
#line 728
      tmp___58 = ceil(y1___0);
#line 728
      topry = (long )tmp___58;
      }
#line 730
      if (blx < toprx) {
#line 731
        *llx = (int )blx;
#line 732
        *urx = (int )toprx;
      } else {
#line 735
        *llx = (int )toprx;
#line 736
        *urx = (int )blx;
      }
#line 738
      if (bly < topry) {
#line 739
        *lly = (int )bly;
#line 740
        *ury = (int )topry;
      } else {
#line 743
        *lly = (int )topry;
#line 744
        *ury = (int )bly;
      }
    }
  }
#line 749
  t->lbuf = 0;
#line 750
  return;
}
}
#line 752 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
static int SameDirection(double x0 , double y0___0 , double x1 , double y1___0 ) 
{ 
  int tmp ;

  {
#line 753
  if (y0___0 == 0.0) {
#line 753
    if (y1___0 == 0.0) {
#line 753
      if (x0 * x1 > 0.0) {
#line 753
        tmp = 1;
      } else {
#line 753
        goto _L___2;
      }
    } else {
#line 753
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 753
  if (x0 == 0.0) {
#line 753
    if (x1 == 0.0) {
#line 753
      if (y0___0 * y1___0 > 0.0) {
#line 753
        tmp = 1;
      } else {
#line 753
        goto _L___0;
      }
    } else {
#line 753
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 753
  if (x0 * y1___0 == x1 * y0___0) {
#line 753
    tmp = 1;
  } else {
#line 753
    tmp = 0;
  }
#line 753
  return (tmp);
}
}
#line 758 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
static int ParseString(T *t , char *instr , char const   **pre , char const   **word ,
                       char const   **post , int *llx , int *lly , int *urx , int *ury ) 
{ 
  char buf[1000] ;
  int n ;
  int ch ;
  int i ;
  int j ;
  int in ;
  int l ;
  Font f ;
  Encoding enc ;
  GlyphIndex glyph ;
  double x0 ;
  double y0___0 ;
  double x1 ;
  double y1___0 ;
  double xsp ;
  double ysp ;
  double dx ;
  double dy ;
  double maxx ;
  double maxy ;
  int k ;
  int tt ;
  char const   *str ;
  int lstr ;
  size_t tmp ;
  char const   *str___0 ;
  int lstr___0 ;
  char tempstr[2] ;
  size_t tmp___0 ;
  char const   *str___1 ;
  int lstr___1 ;
  size_t tmp___1 ;
  char const   *str___2 ;
  int lstr___2 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 778
  n = ReadInt(& instr);
#line 779
  f = (*(t->font))[n];
  }
#line 780
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 780
    return (202);
  }
#line 781
  enc = (*(t->encoding))[f->e];
#line 782
  if ((unsigned long )enc == (unsigned long )((void *)0)) {
#line 782
    return (200);
  }
  {
#line 783
  ReadPair(& x0, & y0___0, & instr);
#line 784
  j = ReadInt(& instr);
#line 785
  ch = ReadChar(& instr);
  }
#line 786
  if (ch != 32) {
#line 787
    return (204);
  }
#line 789
  l = 0;
#line 790
  i = 0;
  {
#line 790
  while (1) {
    while_continue: /* CIL Label */ ;
#line 790
    if (! (i <= j - 1)) {
#line 790
      goto while_break;
    }
    {
#line 791
    in = ReadChar(& instr);
#line 793
    glyph = (*enc)[in];
    }
#line 797
    if (glyph == 0U) {
#line 801
      tt = 0;
#line 802
      k = 0;
      {
#line 802
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 802
        if (! tt) {
#line 802
          if (! ((unsigned long )k < sizeof(*enc) / sizeof((*enc)[0]))) {
#line 802
            goto while_break___0;
          }
        } else {
#line 802
          goto while_break___0;
        }
#line 803
        if (540U <= (*enc)[k]) {
#line 803
          if ((*enc)[k] <= 1051U) {
#line 803
            tt = 1;
          }
        }
#line 802
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 805
      if (tt) {
#line 805
        glyph = (GlyphIndex )(540 + in);
      }
    }
#line 813
    if (! (glyph == 0U)) {
#line 815
      if (glyph <= 255U) {
#line 816
        buf[l] = (char )glyph;
#line 818
        l ++;
      } else
#line 820
      if (glyph <= 283U) {
        {
#line 821
        str = SpecialGlyphs[glyph - 256U];
#line 822
        tmp = strlen(str);
#line 822
        lstr = (int )tmp;
#line 823
        strncpy((char */* __restrict  */)(& buf[l]), (char const   */* __restrict  */)str,
                (size_t )lstr);
#line 824
        l += lstr;
        }
      } else
#line 826
      if (glyph <= 539U) {
#line 828
        if (t->dvipsIsCork) {
#line 829
          if (glyph <= 475U) {
#line 830
            str___0 = CorkSpecialGlyphs[glyph - 284U];
          } else
#line 831
          if (glyph == 507U) {
#line 832
            str___0 = "SS";
          } else
#line 833
          if (glyph == 539U) {
#line 834
            str___0 = "\337";
          } else {
#line 836
            tempstr[0] = (char )(glyph - 284U);
#line 836
            tempstr[1] = (char )'\000';
#line 837
            str___0 = (char const   *)(& tempstr[0]);
          }
        } else
#line 840
        if (glyph <= 411U) {
#line 842
          str___0 = DvipsGlyphs[glyph - 284U];
        } else {
#line 844
          tempstr[0] = (char )'#';
#line 844
          tempstr[1] = (char )'\000';
#line 845
          str___0 = (char const   *)(& tempstr[0]);
        }
        {
#line 847
        tmp___0 = strlen(str___0);
#line 847
        lstr___0 = (int )tmp___0;
#line 848
        strncpy((char */* __restrict  */)(& buf[l]), (char const   */* __restrict  */)str___0,
                (size_t )lstr___0);
#line 849
        l += lstr___0;
        }
      } else
#line 851
      if (glyph <= 1051U) {
#line 852
        if (796U <= glyph) {
#line 852
          glyph -= 256U;
        }
#line 853
        if (glyph < 572U) {
#line 854
          buf[l] = (char )'#';
#line 854
          l ++;
        } else
#line 856
        if (glyph < 670U) {
#line 858
          buf[l] = (char )(glyph - 540U);
#line 858
          l ++;
        } else
#line 856
        if (699U < glyph) {
#line 858
          buf[l] = (char )(glyph - 540U);
#line 858
          l ++;
        } else {
          {
#line 861
          str___1 = TTSpecialGlyphs[glyph - 670U];
#line 862
          tmp___1 = strlen(str___1);
#line 862
          lstr___1 = (int )tmp___1;
#line 863
          strncpy((char */* __restrict  */)(& buf[l]), (char const   */* __restrict  */)str___1,
                  (size_t )lstr___1);
#line 864
          l += lstr___1;
          }
        }
      } else
#line 867
      if (glyph <= 1179U) {
        {
#line 868
        str___2 = DvipsGlyphs[glyph - 1052U];
#line 869
        tmp___2 = strlen(str___2);
#line 869
        lstr___2 = (int )tmp___2;
#line 870
        strncpy((char */* __restrict  */)(& buf[l]), (char const   */* __restrict  */)str___2,
                (size_t )lstr___2);
#line 871
        l += lstr___2;
        }
      } else
#line 873
      if (glyph == 9999U) {
#line 874
        buf[l] = (char )'#';
#line 875
        l ++;
      } else {
#line 877
        return (205);
      }
    }
#line 790
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 883
  ReadPair(& x1, & y1___0, & instr);
  }
#line 884
  if (l != 0) {
#line 885
    if (t->lbuf == 0) {
      {
#line 885
      strncpy((char */* __restrict  */)(t->buf), (char const   */* __restrict  */)(buf),
              (size_t )l);
#line 885
      t->lbuf = l;
#line 885
      t->f = n;
#line 885
      t->x0 = x0;
#line 885
      t->y0 = y0___0;
#line 885
      t->x1 = x1;
#line 885
      t->y1 = y1___0;
      }
    } else {
#line 903
      if ((t->x1 - t->x0) / (double )t->lbuf <= (x1 - x0) / (double )l) {
#line 903
        xsp = (t->x1 - t->x0) / (double )t->lbuf;
      } else {
#line 903
        xsp = (x1 - x0) / (double )l;
      }
#line 904
      if ((t->y1 - t->y0) / (double )t->lbuf <= (y1___0 - y0___0) / (double )l) {
#line 904
        ysp = (t->y1 - t->y0) / (double )t->lbuf;
      } else {
#line 904
        ysp = (y1___0 - y0___0) / (double )l;
      }
#line 906
      dx = x0 - t->x1;
#line 907
      dy = y0___0 - t->y1;
#line 908
      maxx = 0.3 * xsp;
#line 909
      maxy = 0.3 * ysp;
#line 910
      if (dx * dx + dy * dy < maxx * maxx + maxy * maxy) {
#line 910
        goto _L;
      } else
#line 910
      if (t->y1 == y0___0) {
#line 910
        if (t->x0 <= t->x1) {
#line 910
          if (t->x0 <= x0) {
#line 910
            if (x0 <= t->x1) {
              {
#line 910
              tmp___3 = SameDirection(t->x1 - t->x0, t->y1 - t->y0, x1 - x0, y1___0 - y0___0);
              }
#line 910
              if (tmp___3) {
                _L: /* CIL Label */ 
#line 913
                if ((unsigned long )(t->lbuf + l) >= sizeof(t->buf)) {
                  {
#line 914
                  Output(t, pre, word, llx, lly, urx, ury);
#line 915
                  *post = "";
#line 916
                  strncpy((char */* __restrict  */)(t->buf), (char const   */* __restrict  */)(buf),
                          (size_t )l);
#line 916
                  t->lbuf = l;
#line 916
                  t->f = n;
#line 916
                  t->x0 = x0;
#line 916
                  t->y0 = y0___0;
#line 916
                  t->x1 = x1;
#line 916
                  t->y1 = y1___0;
                  }
                } else {
                  {
#line 919
                  strncpy((char */* __restrict  */)(& t->buf[t->lbuf]), (char const   */* __restrict  */)(buf),
                          (size_t )l);
#line 920
                  t->lbuf += l;
#line 921
                  t->x1 = x1;
#line 921
                  t->y1 = y1___0;
                  }
                }
              } else {
#line 910
                goto _L___3;
              }
            } else {
#line 910
              goto _L___3;
            }
          } else {
#line 910
            goto _L___3;
          }
        } else {
#line 910
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
        {
#line 926
        Output(t, pre, word, llx, lly, urx, ury);
#line 927
        *post = "";
#line 928
        strncpy((char */* __restrict  */)(t->buf), (char const   */* __restrict  */)(buf),
                (size_t )l);
#line 928
        t->lbuf = l;
#line 928
        t->f = n;
#line 928
        t->x0 = x0;
#line 928
        t->y0 = y0___0;
#line 928
        t->x1 = x1;
#line 928
        t->y1 = y1___0;
        }
      }
    }
  }
#line 933
  return (0);
}
}
#line 936 "/home/wheatley/newnew/temp/pstotext-1.9/ptotdll.c"
int pstotextFilter(void *instance___0 , char *instr , char const   **pre , char const   **word ,
                   char const   **post , int *llx , int *lly , int *urx , int *ury ) 
{ 
  T *t ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 939
  t = (T *)instance___0;
#line 941
  *word = (char const   *)((void *)0);
  {
#line 943
  if (t->state == 0) {
#line 943
    goto case_0;
  }
#line 975
  if (t->state == 1) {
#line 975
    goto case_1;
  }
#line 976
  if (t->state == 2) {
#line 976
    goto case_2;
  }
#line 942
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 944
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 944
    c = ReadChar(& instr);
    }
#line 944
    if (c == 0) {
#line 944
      return (0);
    }
#line 944
    if (! (c != 81)) {
#line 944
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 945
  c = ReadChar(& instr);
  }
  {
#line 947
  if (c == 73) {
#line 947
    goto case_73;
  }
#line 948
  if (c == 77) {
#line 948
    goto case_77;
  }
#line 949
  if (c == 69) {
#line 949
    goto case_69;
  }
#line 950
  if (c == 70) {
#line 950
    goto case_70;
  }
#line 951
  if (c == 83) {
#line 951
    goto case_83;
  }
#line 954
  if (c == 80) {
#line 954
    goto case_80;
  }
#line 954
  if (c == 67) {
#line 954
    goto case_80;
  }
#line 970
  if (c == 90) {
#line 970
    goto case_90;
  }
#line 971
  if (c == 0) {
#line 971
    goto case_0___0;
  }
#line 946
  goto switch_break___0;
  case_73: /* CIL Label */ 
  {
#line 947
  tmp = ParseInverseTransform(t, instr);
  }
#line 947
  return (tmp);
  case_77: /* CIL Label */ 
  {
#line 948
  tmp___0 = ParseMetrics(t, instr);
  }
#line 948
  return (tmp___0);
  case_69: /* CIL Label */ 
  {
#line 949
  tmp___1 = ParseEncoding(t, instr);
  }
#line 949
  return (tmp___1);
  case_70: /* CIL Label */ 
  {
#line 950
  tmp___2 = ParseFont(t, instr);
  }
#line 950
  return (tmp___2);
  case_83: /* CIL Label */ 
  {
#line 951
  tmp___3 = ParseString(t, instr, pre, word, post, llx, lly, urx, ury);
  }
#line 951
  return (tmp___3);
  case_80: /* CIL Label */ 
  case_67: /* CIL Label */ 
#line 957
  if (t->lbuf > 0) {
    {
#line 958
    Output(t, pre, word, llx, lly, urx, ury);
#line 959
    *post = "\n\f\n";
    }
  } else {
#line 962
    *pre = "";
#line 963
    *word = "";
#line 964
    *llx = 0;
#line 964
    *lly = 0;
#line 964
    *urx = 0;
#line 964
    *ury = 0;
#line 965
    *post = "\f\n";
  }
#line 967
  t->nonEmptyPage = 0;
#line 968
  tmp___6 = 0L;
#line 968
  t->topry = tmp___6;
#line 968
  tmp___5 = tmp___6;
#line 968
  t->toprx = tmp___5;
#line 968
  tmp___4 = tmp___5;
#line 968
  t->bly = tmp___4;
#line 968
  t->blx = tmp___4;
#line 969
  goto switch_break___0;
  case_90: /* CIL Label */ 
#line 970
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
#line 971
  return (0);
  switch_break___0: /* CIL Label */ ;
  }
#line 974
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 975
  tmp___7 = ParseMetricsMore(t, instr);
  }
#line 975
  return (tmp___7);
  case_2: /* CIL Label */ 
  {
#line 976
  tmp___8 = ParseEncodingMore(t, instr);
  }
#line 976
  return (tmp___8);
  switch_break: /* CIL Label */ ;
  }
#line 978
  return (0);
}
}
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 620
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 10 "/home/wheatley/newnew/temp/pstotext-1.9/bundle.h"
void putbundle(char const   **b , FILE *f ) ;
#line 1 "/home/wheatley/newnew/temp/pstotext-1.9/ocr.h"
char const   *ocr[833]  = 
#line 1 "/home/wheatley/newnew/temp/pstotext-1.9/ocr.h"
  {      "% Copyright (C) 1995, Digital Equipment Corporation.\n",      "% All rights reserved.\n",      "% See the file pstotext.txt for a full description.\n",      "\n", 
        "% ocr.ps, part of BuildLectern\n",      "%\n",      "%   This is a PostScript library to send the characters rendered by a\n",      "%   PostScript job back on stdout.  The output is intended to allow\n", 
        "%   reconstruction of the document\'s words and an approximation of the words\'\n",      "%   bounding rectangles.\n",      "\n",      "% Last modified on Fri Jan  9 21:20:00 AEST 2004 by rjl\n", 
        "%      modified on Sat Feb  5 21:00:00 AEST 2000 by rjl\n",      "%      modified on Fri Oct  2 17:13:53 PDT 1998 by mcjones\n",      "%      modified on Thu Jan 25 15:24:37 PST 1996 by deutsch\n",      "%      modified on Wed May  3 15:41:30 PDT 1995 by birrell\n", 
        "\n",      "% Modified by rjl\n",      "%   For Ghostscript 6 or later.\n",      "%   Change ashow, widthshow and awidthshow to call show for each character.\n", 
        "%   Add xshow, yshow, xyshow.\n",      "\n",      "% Restrictions:\n",      "%\n", 
        "%   This library redefines some names that are originally defined as\n",      "%   operators, and of course the new definitions are procedures. Some\n",      "%   jobs might be sensitive to this distinction.  In this case, you\'d\n",      "%   need to make \"redef\" create a new operator.  For example, \"odef\".\n", 
        "%\n",      "%   This library reports characters rendered by show, ashow, widthshow,\n",      "%   awidthshow, kshow, xshow, yshow and xyshow.  \n",      "%   The characters are reported even if they would\n", 
        "%   be invisible in final hardcopy.  This could happen, for example, if the\n",      "%   characters get clipped, or if they get overprinted, or if they are the\n",      "%   same color as their background, or if the font\'s glyph make no marks.\n",      "%\n", 
        "%   PostScript doesn\'t specify a standard character code for the characters\n",      "%   being rendered; rather, the font maps small integers into glyphs.  It\'s\n",      "%   not possible in general to determine a translation back into a standard\n",      "%   character code.  This library approximates this by giving mappings from\n", 
        "%   the job\'s characters to indexes into a table of known glyph names.  This\n",      "%   handles most PostScript jobs that we\'ve encountered, but it\'s not an\n",      "%   absolute solution to the problem.\n",      "\n", 
        "% Output format:\n",      "%\n",      "%    The \"reporting coordinate system\" is the device coordinate system.  The\n",      "%    application interpreting this library\'s output needs to understand the\n", 
        "%    device coordinate system.\n",      "%\n",      "%    Positions are reported in the reporting coordinate system, but with (x,y) \n",      "%    values multiplied by 100 and rounded to integers.  Note that\n", 
        "%    positions might involve negative integers.\n",      "%\n",      "%    The directives, whitespace and numbers are themselves encoded in ASCII.\n",      "%    The strings in the \"S\" directives are in currentfont\'s encoding: they\n", 
        "%    should be treated as 8-bit binary data.\n",      "%\n",      "%    QI 6-integers\n",      "%                       Specifies the inverse of the currentmatrix for\n", 
        "%                       the current output device, after rotXXX.ps and\n",      "%                       before the document is processed.\n",      "%\n",      "%    QM m blx bly trx try 256-pairs\n", 
        "%\t\t\tIntroduces a new character metrics table used by\n",      "%\t\t\tsome font, where \"m\" is an integer that identifies\n",      "%\t\t\tthe metrics table in subsequent \"F\" directives.  \"m\"\n",      "%\t\t\tis small.  (blx,bly) is the bottom left corner of the\n", 
        "%\t\t\tfont\'s bounding box, and (trx,try) is its top right. \n",      "%\t\t\tThe pairs are the stringwidth of each character in the\n",      "%\t\t\tfont\'s encoding.  All of these are reported in the\n",      "%\t\t\tfont\'s character coordinate system, multiplied by 100\n", 
        "%\t\t\tand rounded to integers.  The metrics\n",      "%\t\t\ttable will be referenced in a subsequent \"F\"\n",      "%\t\t\tdirective, which includes information mapping the\n",      "%\t\t\tfont\'s metrics to the initial user coordinate system. \n", 
        "%\t\t\tNote that values of \"m\" might get reused, after a\n",      "%\t\t\t\"restore\".\n",      "%\n",      "% QE e n n-integers\tIntroduces a new encoding, where \"e\" is an integer\n", 
        "%\t\t\tthat identifies the encoding in subsequent \"F\"\n",      "%\t\t\tdirectives.  \"e\" is small.  \"e\" is followed by\n",      "%\t\t\tan integer \"n\" and then by a sequence of\n",      "%\t\t\texactly n integers.  The i\'th integer\n", 
        "%\t\t\tspecifies the glyph for the i\'th entry of the\n",      "%\t\t\tfont\'s encoding vector.  The value of the\n",      "%\t\t\tinteger is usually an index in the array\n",      "%\t\t\t\"StandardGlyphs\", defined below.  Note that\n", 
        "%\t\t\tthe first 256 entries of that array equal the\n",      "%\t\t\tcorresponding entries of ISOLatin1Encoding.\n",      "%\t\t\tThe value 9999 indicates that this entry in\n",      "%\t\t\tthe font\'s encoding specifies a glyph not\n", 
        "%\t\t\tnamed in StandardGlyphs.  Note that values of\n",      "%\t\t\t\"e\" might get reused, after a \"restore\".\n",      "%\n",      "%    QF n x y x\' y\' e m\tIntroduces a new font, where \"n\" is an integer\n", 
        "%\t\t\tthat identifies the font in subsequent \"S\"\n",      "%\t\t\tdirectives.  \"n\" is small.  (x,y) is the\n",      "%\t\t\tposition corresponding to (1000,0) in the font\'s\n",      "%\t\t\tcharacter coordinate system, and (x\',y\') is the\n", 
        "%\t\t\tposition corresponding to (0,1000), both as they would\n",      "%\t\t\tbe if the character were drawn with its origin at\n",      "%\t\t\tthe origin of the reporting coordinate system. \"e\" is\n",      "%\t\t\tan integer specifying a previously defined\n", 
        "%\t\t\tencoding vector.  \"m\" is an integer specifying a\n",      "%\t\t\tpreviously defined metrics table.  Note that values\n",      "%\t\t\tof \"n\" might get reused, after a \"restore\".\n",      "%\n", 
        "%    QS n x y l s x\' y\'\tReports rendering of string \"s\" in font \"n\".\n",      "%\t\t\t(x,y) is the position corresponding to the origin of\n",      "%\t\t\tthe first character. \"l\" is length of the string,\n",      "%\t\t\tfollowed immediately by a single space then the string.\n", 
        "%\t\t\t(x\',y\') is the position that would correspond to the\n",      "%\t\t\torigin of a subsequent character. The\n",      "%\t\t\tstring reported by this directive is never empty.\n",      "%\t\t\tThe string also never contains a \"space\": strings\n", 
        "%\t\t\tthat would have contained a \"space\" are split up\n",      "%\t\t\tinto multiple directives, with the \"space\"\n",      "%\t\t\tomitted.  Here \"space\" means the first character\n",      "%\t\t\tin the font\'s encoding that maps to the glyph\n", 
        "%\t\t\tnamed \"/space\", if there is such a character.\n",      "%\n",      "%    QC\t\t\tcopypage was invoked\n",      "%\n", 
        "%    QZ\t\t\terasepage was invoked\n",      "%\n",      "%    QP\t\t\tshowpage was invoked\n",      "\n", 
        "%\n",      "% globals and subroutines\n",      "%\n",      "\n", 
        "%/setglobal where\n",      "% { pop currentglobal /setglobal load true setglobal }\n",      "% { { } }\n",      "%ifelse\n", 
        "revision 353 ge {\n",      "NOBIND /DELAYBIND where { pop DELAYBIND or } if\n",      " { systemdict begin\n",      "                /bind /.bind load\n", 
        "                  /.forcedef where { pop .forcedef } { def } ifelse\n",      "              end\n",      " }\n",      "if\n", 
        "} if\n",      "\n",      "% put our private stuff in a local dictionary,\n",      "% but place a reference to it in systemdict\n", 
        "systemdict begin\n",      "/pstotextLocalDict 30 dict /.forcedef where { pop .forcedef } { def } ifelse\n",      "end\n",      "\n", 
        "pstotextLocalDict begin\t\t% following stuff is private\n",      "/redef { systemdict begin 1 index exch .makeoperator def end } bind def\n",      "/privateDict currentdict def\t% for lastFontNum and lastEncoding\n",      "/fonts 200 dict def\t\t% maps font to integer \"n\"\n", 
        "/fontsUnit 200 dict def \t% (1000,0) and (0,1000) transformed, per font\n",      "/encodings 200 dict def\t\t% maps encoding array to integer \"e\"\n",      "/encodingSpace 200 dict def\t% space char for each encoding\n",      "/metrics 200 dict def\t\t% maps font UniqueID to integer  \"m\"\n", 
        "/lastFontNum 0 def\t\t% last integer used for a font\n",      "/lastEncoding 0 def\t\t% last integer used for an encoding\n",      "/lastMetrics 0 def\t\t% last integer used for a metrics table\n",      "/tempString 20 string def\t% scratch for printing integers\n", 
        "/reportMatrix matrix identmatrix def % maps device coords to reporting coords\n",      "/inUse false def\t\t% prevents recursive invokcation of \"report\"\n",      "\n",      "/TimesRomanGlyphs [\n", 
        "  % ISOLatin1Encoding ...\n",      "  /.notdef /.notdef /.notdef /.notdef /.notdef\n",      "  /.notdef /.notdef /.notdef /.notdef /.notdef\n",      "  /.notdef /.notdef /.notdef /.notdef /.notdef\n", 
        "  /.notdef /.notdef /.notdef /.notdef /.notdef\n",      "  /.notdef /.notdef /.notdef /.notdef /.notdef\n",      "  /.notdef /.notdef /.notdef /.notdef /.notdef\n",      "  /.notdef /.notdef /space /exclam /quotedbl\n", 
        "  /numbersign /dollar /percent /ampersand /quoteright\n",      "  /parenleft /parenright /asterisk /plus /comma\n",      "  /minus /period /slash /zero /one\n",      "  % 50\n", 
        "  /two /three /four /five /six\n",      "  /seven /eight /nine /colon /semicolon\n",      "  /less /equal /greater /question /at\n",      "  /A /B /C /D /E\n", 
        "  /F /G /H /I /J\n",      "  /K /L /M /N /O\n",      "  /P /Q /R /S /T\n",      "  /U /V /W /X /Y\n", 
        "  /Z /bracketleft /backslash /bracketright /asciicircum\n",      "  /underscore /quoteleft /a /b /c\n",      "  % 100\n",      "  /d /e /f /g /h\n", 
        "  /i /j /k /l /m\n",      "  /n /o /p /q /r\n",      "  /s /t /u /v /w\n",      "  /x /y /z /braceleft /bar\n", 
        "  /braceright /asciitilde /.notdef /.notdef /.notdef\n",      "  /.notdef /.notdef /.notdef /.notdef /.notdef\n",      "  /.notdef /.notdef /.notdef /.notdef /.notdef\n",      "  /.notdef /.notdef /.notdef /.notdef /dotlessi\n", 
        "  /grave /acute /circumflex /tilde /macron\n",      "  % 150\n",      "  /breve /dotaccent /dieresis /.notdef /ring\n",      "  /cedilla /.notdef /hungarumlaut /ogonek /caron\n", 
        "  /space /exclamdown /cent /sterling /currency\n",      "  /yen /brokenbar /section /dieresis /copyright\n",      "  /ordfeminine /guillemotleft /logicalnot /hyphen /registered\n",      "  /macron /degree /plusminus /twosuperior /threesuperior\n", 
        "  /acute /mu /paragraph /periodcentered /cedilla\n",      "  /onesuperior /ordmasculine /guillemotright /onequarter /onehalf\n",      "  /threequarters /questiondown /Agrave /Aacute /Acircumflex\n",      "  /Atilde /Adieresis /Aring /AE /Ccedilla\n", 
        "  % 200\n",      "  /Egrave /Eacute /Ecircumflex /Edieresis /Igrave\n",      "  /Iacute /Icircumflex /Idieresis /Eth /Ntilde\n",      "  /Ograve /Oacute /Ocircumflex /Otilde /Odieresis\n", 
        "  /multiply /Oslash /Ugrave /Uacute /Ucircumflex\n",      "  /Udieresis /Yacute /Thorn /germandbls /agrave\n",      "  /aacute /acircumflex /atilde /adieresis /aring\n",      "  /ae /ccedilla /egrave /eacute /ecircumflex\n", 
        "  /edieresis /igrave /iacute /icircumflex /idieresis\n",      "  /eth /ntilde /ograve /oacute /ocircumflex\n",      "  /otilde /odieresis /divide /oslash /ugrave\n",      "  % 250\n", 
        "  /uacute /ucircumflex /udieresis /yacute /thorn\n",      "  /ydieresis \n",      "  % Other glyphs from /Times-Roman ...\n",      "  % 256\n", 
        "  /quotedblright /Scaron /dagger /guilsinglleft\n",      "  /Zcaron /daggerdbl /Lslash /ellipsis /guilsinglright\n",      "  /oe /fi /bullet /perthousand /quotedblbase\n",      "  /endash /emdash /trademark /florin /lslash\n", 
        "  /scaron /Ydieresis /fl /fraction /quotedblleft\n",      "  /quotesinglbase /quotesingle /zcaron /OE\n",      "  % 284\n",      "  ] def\n", 
        "\n",      "/dvipsGlyphs [\n",      "  % Self-named glyphs for dvitops type 3 fonts ...\n",      "  % 284\n", 
        "  0 1 255 { 1 string dup 0 4 -1 roll put cvn } for\n",      "  % 540\n",      "  ] def\n",      "\n", 
        "/ttypeGlyphs1 [\n",      "  % Glyph names used by MS TrueType encodings ...\n",      "  % 540\n",      "  /G00 /G01 /G02 /G03 /G04 /G05 /G06 /G07 /G08 /G09 /G0a /G0b /G0c /G0d /G0e\n", 
        "  /G0f /G10 /G11 /G12 /G13 /G14 /G15 /G16 /G17 /G18 /G19 /G1a /G1b /G1c /G1d\n",      "  /G1e /G1f /G20 /G21 /G22 /G23 /G24 /G25 /G26 /G27 /G28 /G29 /G2a /G2b /G2c\n",      "  /G2d /G2e /G2f /G30 /G31 /G32 /G33 /G34 /G35 /G36 /G37 /G38 /G39 /G3a /G3b\n",      "  % 600\n", 
        "  /G3c /G3d /G3e /G3f /G40 /G41 /G42 /G43 /G44 /G45 /G46 /G47 /G48 /G49 /G4a\n",      "  /G4b /G4c /G4d /G4e /G4f /G50 /G51 /G52 /G53 /G54 /G55 /G56 /G57 /G58 /G59\n",      "  /G5a /G5b /G5c /G5d /G5e /G5f /G60 /G61 /G62 /G63 /G64 /G65 /G66 /G67 /G68\n",      "  /G69 /G6a /G6b /G6c /G6d /G6e /G6f /G70 /G71 /G72 /G73 /G74 /G75 /G76 /G77\n", 
        "  /G78 /G79 /G7a /G7b /G7c /G7d /G7e /G7f /G80 /G81 /G82 /G83 /G84 /G85 /G86\n",      "  /G87 /G88 /G89 /G8a /G8b /G8c /G8d /G8e /G8f /G90 /G91 /G92 /G93 /G94 /G95\n",      "  /G96 /G97 /G98 /G99 /G9a /G9b /G9c /G9d /G9e /G9f /Ga0 /Ga1 /Ga2 /Ga3 /Ga4\n",      "  /Ga5 /Ga6 /Ga7 /Ga8 /Ga9 /Gaa /Gab /Gac /Gad /Gae /Gaf /Gb0 /Gb1 /Gb2 /Gb3\n", 
        "  /Gb4 /Gb5 /Gb6 /Gb7 /Gb8 /Gb9 /Gba /Gbb /Gbc /Gbd /Gbe /Gbf /Gc0 /Gc1 /Gc2\n",      "  /Gc3 /Gc4 /Gc5 /Gc6 /Gc7 /Gc8 /Gc9 /Gca /Gcb /Gcc /Gcd /Gce /Gcf /Gd0 /Gd1\n",      "  % 750\n",      "  /Gd2 /Gd3 /Gd4 /Gd5 /Gd6 /Gd7 /Gd8 /Gd9 /Gda /Gdb /Gdc /Gdd /Gde /Gdf /Ge0\n", 
        "  /Ge1 /Ge2 /Ge3 /Ge4 /Ge5 /Ge6 /Ge7 /Ge8 /Ge9 /Gea /Geb /Gec /Ged /Gee /Gef\n",      "  /Gf0 /Gf1 /Gf2 /Gf3 /Gf4 /Gf5 /Gf6 /Gf7 /Gf8 /Gf9 /Gfa /Gfb /Gfc /Gfd /Gfe\n",      "  /Gff \n",      "  % 796\n", 
        "  ] def\n",      "\n",      "/ttypeGlyphs2 [\n",      "  % 796\n", 
        "  /G00 /G01 /G02 /G03 /G04 /G05 /G06 /G07 /G08 /G09 /G0A /G0B /G0C /G0D\n",      "  /G0E /G0F /G10 /G11 /G12 /G13 /G14 /G15 /G16 /G17 /G18 /G19 /G1A /G1B /G1C\n",      "  /G1D /G1E /G1F /G20 /G21 /G22 /G23 /G24 /G25 /G26 /G27 /G28 /G29 /G2A /G2B\n",      "  /G2C /G2D /G2E /G2F /G30 /G31 /G32 /G33 /G34 /G35 /G36 /G37 /G38 /G39 /G3A\n", 
        "  /G3B /G3C /G3D /G3E /G3F /G40 /G41 /G42 /G43 /G44 /G45 /G46 /G47 /G48 /G49\n",      "  /G4A /G4B /G4C /G4D /G4E /G4F /G50 /G51 /G52 /G53 /G54 /G55 /G56 /G57 /G58\n",      "  /G59 /G5A /G5B /G5C /G5D /G5E /G5F /G60 /G61 /G62 /G63 /G64 /G65 /G66 /G67\n",      "  % 900\n", 
        "  /G68 /G69 /G6A /G6B /G6C /G6D /G6E /G6F /G70 /G71 /G72 /G73 /G74 /G75 /G76\n",      "  /G77 /G78 /G79 /G7A /G7B /G7C /G7D /G7E /G7F /G80 /G81 /G82 /G83 /G84 /G85\n",      "  /G86 /G87 /G88 /G89 /G8A /G8B /G8C /G8D /G8E /G8F /G90 /G91 /G92 /G93 /G94\n",      "  /G95 /G96 /G97 /G98 /G99 /G9A /G9B /G9C /G9D /G9E /G9F /GA0 /GA1 /GA2 /GA3\n", 
        "  /GA4 /GA5 /GA6 /GA7 /GA8 /GA9 /GAA /GAB /GAC /GAD /GAE /GAF /GB0 /GB1 /GB2\n",      "  /GB3 /GB4 /GB5 /GB6 /GB7 /GB8 /GB9 /GBA /GBB /GBC /GBD /GBE /GBF /GC0 /GC1\n",      "  /GC2 /GC3 /GC4 /GC5 /GC6 /GC7 /GC8 /GC9 /GCA /GCB /GCC /GCD /GCE /GCF /GD0\n",      "  /GD1 /GD2 /GD3 /GD4 /GD5 /GD6 /GD7 /GD8 /GD9 /GDA /GDB /GDC /GDD /GDE /GDF\n", 
        "  /GE0 /GE1 /GE2 /GE3 /GE4 /GE5 /GE6 /GE7 /GE8 /GE9 /GEA /GEB /GEC /GED /GEE\n",      "  /GEF /GF0 /GF1 /GF2 /GF3 /GF4 /GF5 /GF6 /GF7 /GF8 /GF9 /GFA /GFB /GFC /GFD\n",      "  % 1050\n",      "  /GFE /GFF \n", 
        "  % 1052\n",      "  ] def\n",      "\n",      "/oldDviGlyphs [\n", 
        "  % More self-named glyphs for old dvitops type 3 fonts ...\n",      "  % 1052\n",      "  0 1 127 { 10 3 string cvrs cvn } for\n",      "  % 1180\n", 
        "  ] def\n",      "\n",      "/StandardGlyphs //TimesRomanGlyphs length 896 add array def\n",      "//StandardGlyphs 0 //TimesRomanGlyphs putinterval\n", 
        "//StandardGlyphs //TimesRomanGlyphs length //dvipsGlyphs putinterval\n",      "//StandardGlyphs //TimesRomanGlyphs length 256 add //ttypeGlyphs1 putinterval\n",      "//StandardGlyphs //TimesRomanGlyphs length 512 add //ttypeGlyphs2 putinterval\n",      "//StandardGlyphs //TimesRomanGlyphs length 768 add //oldDviGlyphs putinterval\n", 
        "\n",      "/standardMap StandardGlyphs length dict\n",      "  % Maps names to indices in StandardGlyphs.\n",      "  0 StandardGlyphs {\n", 
        "    2 index exch\n",      "    2 copy known { pop pop } { 2 index put } ifelse\n",      "    1 add\n",      "    } forall\n", 
        "  pop def\n",      "\n",      "/printInt {\t\t\t% stack: n\n",      "  % Prints an integer followed by a space on stdout\n", 
        "  //tempString cvs print ( ) print\n",      "  } bind def\n",      "\n",      "/showxy {\t\t\t%stack:  x y\n", 
        "  % prints a pair of integers on stdout, converting to 1/100th\'s\n",      "  exch\n",      "  100 mul round cvi //printInt exec\n",      "  100 mul round cvi //printInt exec\n", 
        "  } bind def\n",      "\n",      "/characterToReporting {\t\t% stack: x y -> x\' y\'\n",      "  % Transforms a vector in currentfont\'s character coordinate\n", 
        "  % system to the reporting coordinate system\n",      "  currentfont /FontMatrix get\n",      "  dtransform\t\t\t% to current user coordinates\n",      "  dtransform\t\t\t% to device coordinates\n", 
        "  //reportMatrix idtransform\t% to reporting coordinates\n",      "  } def\n",      "\n",      "/printCharacterOrigin {\n", 
        "  % Prints the position in the reporting coordinate system at which a\n",      "  % character origin would be painted using currentfont\n",      "  0 0 currentfont /FontMatrix get transform\n",      "  currentpoint exch 4 -1 roll add 3 1 roll add\n", 
        "  transform //reportMatrix itransform\n",      "  //showxy exec\n",      "  } bind def\n",      "\n", 
        "/printMap {\n",      "  % Print map from indices in currentfont/Encoding to StandardEncoding indices\n",      "  16 currentfont /Encoding get dup length //printInt exec {\n",      "    exch dup 16 eq { () = pop 1 } { 1 add } ifelse exch\n", 
        "    //standardMap exch\n",      "    2 copy known {\n",      "      get //printInt exec\n",      "      } {\n", 
        "      pop pop (9999 ) print\n",      "      } ifelse\n",      "    } forall\n",      "  pop () =\n", 
        "  } bind def\n",      "\n",      "/metricsString (X) def\n",      "\n", 
        "/printMetrics {\n",      "  % Print bounding box and character metrics for currentfont\n",      "  % Sadly, dvitops produces illegal type 3 fonts with no /.notdef entry. The\n",      "  % use of \"stopped\" deals with that and any other silliness.\n", 
        "  currentfont /FontBBox get aload pop 4 2 roll\n",      "  //showxy exec\n",      "  //showxy exec\n",      "  currentfont /FontMatrix get\n", 
        "  currentfont /FontType get 3 eq {\n",      "    //privateDict /pm.dictCount countdictstack put\n",      "    count //privateDict exch /pm.count exch put\n",      "    //privateDict /pm.save save put\n", 
        "    0 1 255 {\n",      "      dup 8 mod 0 eq { () = } if\n",      "      //metricsString exch 0 exch put\n",      "      { //metricsString //stringwidth exec\n", 
        "        2 index idtransform\t\t% to font\'s character coordinates\n",      "        } stopped {\n",      "        count //privateDict /pm.count get sub { pop } repeat\n",      "        countdictstack //privateDict /pm.dictCount get sub { end } repeat\n", 
        "        //privateDict /pm.save get restore\n",      "        //privateDict /pm.save save put\n",      "        0 0\n",      "        } if\n", 
        "      //showxy exec\n",      "      } for\n",      "    //privateDict /pm.save get restore % necessary to balance the \"save\"\n",      "    }{\n", 
        "    currentfont /CharStrings get\n",      "    currentfont /Encoding get\n",      "    0 1 255 {\n",      "      dup 8 mod 0 eq { () = } if\n", 
        "      2 copy get 3 index exch known {\n",      "        //metricsString exch 0 exch put\n",      "        //metricsString //stringwidth exec\n",      "        4 index idtransform\t\t% to font\'s character coordinates\n", 
        "        } {\n",      "        pop 0 0\n",      "        } ifelse\n",      "      //showxy exec\n", 
        "      } for\n",      "      pop pop\t\t\t\t% encoding, charstrings\n",      "    } ifelse\n",      "  pop\t\t\t\t% fontmatrix\n", 
        "  } bind def\n",      "\n",      "\n",      "%\n", 
        "% The main work: reportMetrics, reportEncoding, reportFont and report\n",      "%\n",      "\n",      "/reportMetrics {\t\t% stack: -> m\n", 
        "\t\t\t\t% privateDict is open\n",      "  % Print new \"m\" directive for currentfont\n",      "  (QM ) print\n",      "  lastMetrics 1 add /lastMetrics 1 index def\n", 
        "  dup //printInt exec\n",      "  //printMetrics exec\n",      "  () =\n",      "  } bind def\n", 
        "\n",      "/reportEncoding {\t\t% stack: -> e\n",      "\t\t\t\t% privateDict is open\n",      "  % Print new \"e\" directive for currentfont\n", 
        "  (QE ) print\n",      "  lastEncoding 1 add /lastEncoding 1 index def\n",      "  dup //printInt exec\n",      "  //printMap exec\n", 
        "  } bind def\n",      "\n",      "/spaceString (X) def\t\t% for space char from current encoding\n",      "\n", 
        "/reportFont {\t\t\t% stack: any -> unchanged\n",      "  % Report currentfont to the user and record its number\n",      "  % //privateDict is open\n",      "  % Sets //privateDict/spaceString to font\'s encoding\'s space string, if any,\n", 
        "  % and sets //privateDict/hasSpace to indicate whether there\'s a space char.\n",      "  currentfont /UniqueID known not {\n",      "    //reportMetrics exec\n",      "    } {\n", 
        "    //metrics currentfont /UniqueID get\n",      "    2 copy known {\n",      "      get\n",      "      } {\n", 
        "      //reportMetrics exec\n",      "      dup 4 1 roll put\t\t% define in /metrics\n",      "      } ifelse\n",      "    } ifelse\t\t\t% stack: m\n", 
        "  //encodings currentfont /Encoding get\n",      "  2 copy known {\n",      "    get\n",      "    } {\n", 
        "    //reportEncoding exec\t% leaves e on stack\n",      "    dup 4 1 roll put\t\t% define in /encodings\n",      "    % Find space character number for the encoding.\n",      "    % Biased towards number 32, so avoid problems with weird encodings\n", 
        "    //encodingSpace 1 index\t% dict and key for putting the result\n",      "    currentfont /Encoding get\n",      "    dup length 32 le {\n",      "      false\n", 
        "      } {\n",      "      dup 32 get dup /space eq exch /G20 eq or\n",      "      } ifelse {\n",      "      pop 32\n", 
        "      } {\n",      "      % It\'s not character number 32: search from 0\n",      "      0 exch {\n",      "        dup /space eq exch dup /G20 eq exch /suppress eq or or { exit } if\n", 
        "        1 add\n",      "        } forall\n",      "      } ifelse\n",      "    put\t\t\t\t% put in /encodingSpace\n", 
        "    } ifelse\t\t\t% stack: m e\n",      "  //encodingSpace 1 index get\t% font\'s space character (256 if none)\n",      "  /hasSpace 1 index 256 lt def\n",      "  hasSpace { //spaceString exch 0 exch put } { pop } ifelse\n", 
        "  (QF ) print\n",      "  lastFontNum 1 add /lastFontNum 1 index def\n",      "  //fonts currentfont 2 index put % record fontNum in /fonts\n",      "  dup //printInt exec\t\t% print fontNum\n", 
        "\t\t\t\t% stack: m e f\n",      "  1000 0 //characterToReporting exec 2 copy //showxy exec\n",      "  0 1000 //characterToReporting exec 2 copy //showxy exec\n",      "  4 array astore\t\t% stack: m e f array\n", 
        "  //fontsUnit 3 1 roll put\t% stack: m e\n",      "  //printInt exec\t\t% print encoding number\n",      "  //printInt exec\t\t% print metrics number\n",      "  () =\n", 
        "  } bind def\n",      "\n",      "/reportFontCreation {\t\t% stack: font\n",      "  % Report a newly created font. Called now so that if later uses are\n", 
        "  % inside a save/restore we don\'t forget it.\n",      "  % NOTE: this is currently not used, since it actually slows things down\n",      "  //privateDict begin\n",      "  inUse not {\n", 
        "    /inUse true def\n",      "    dup currentfont exch setfont //reportFont exec setfont\n",      "    /inUse false def\n",      "    } if\n", 
        "  end\n",      "  } bind def\n",      "\n",      "/reportSubString {\t\t% stack: args string -> args\n", 
        "  % Report the rendering of a string, assumed to be a single word.\n",      "  % privateDict is open.  /n is font number, /p is call-back\n",      "  dup length 0 eq {\n",      "    p\n", 
        "    } {\n",      "    (QS ) print\n",      "    n //printInt exec\n",      "    //printCharacterOrigin exec\n", 
        "    dup length //printInt exec\n",      "    dup print ( ) print\n",      "    /p load end\t\t\t% close privateDict during the call-back\n",      "    exec\t\t\t% render the string; leaves args on stack\n", 
        "    //privateDict begin\n",      "    //printCharacterOrigin exec\n",      "    () =\n",      "    } ifelse\n", 
        "  } bind def\n",      "\n",      "/report {\t\t\t% stack: args string proc -> args\n",      "  % Report the rendering of a string.\n", 
        "  % Calls proc for each word and space.  The call-back should expect \"args\"\n",      "  % on the stack followed by a string, and should leave \"args\" on the stack.\n",      "  //privateDict begin\n",      "  inUse {\n", 
        "    end exec\n",      "    } {\n",      "    /inUse true def\n",      "    //fonts currentfont\n", 
        "    2 copy known not { //reportFont exec } if\n",      "    get\t\t\t\t% stack: probable font-number\n",      "    % check if points transform as before ...\n",      "    //fontsUnit 1 index get\n", 
        "    1000 0 //characterToReporting exec\n",      "    0 1000 //characterToReporting exec\n",      "    4 index 3 get ne 4 1 roll\n",      "    4 index 2 get ne 4 1 roll\n", 
        "    4 index 1 get ne 4 1 roll\n",      "    4 index 0 get ne 5 -1 roll pop\n",      "    or or or {\t\t\t% if transformed points differ\n",      "      //reportFont exec\n", 
        "      pop //fonts currentfont get\n",      "      } if\t\t\t% stack: args string proc n\n",      "    /n exch def\n",      "    /p exch def\t\t% stack: args string\n", 
        "    hasSpace {\n",      "      {\t\t\t% begin loop\n",      "        //spaceString search {\n",      "          exch pop exch /s exch def\n", 
        "          //reportSubString exec\n",      "          //spaceString p\n",      "          s\n",      "          } {\n", 
        "          //reportSubString exec\n",      "          exit\n",      "          } ifelse\n",      "        } loop\n", 
        "      } {\n",      "      //reportSubString exec\n",      "      } ifelse\n",      "    /inUse false def\n", 
        "    end\n",      "    } ifelse\n",      "  } bind def\n",      "\n", 
        "/dontReport {\t\t\t% stack: proc\n",      "  % Call \"proc\" with //privateDict/inUse set to true\n",      "  //privateDict /inUse get {\n",      "    exec\n", 
        "    } {\n",      "    //privateDict /inUse true put\n",      "    exec\n",      "    //privateDict /inUse false put\n", 
        "    } ifelse\n",      "  } bind def\n",      "\n",      "/kshow.temp (X) def\t\t% scratch space for kshow\n", 
        "\n",      "% Output from groff 1.08 sometimes uses ashow to show letters from \n",      "% two separate words, with the offset being used to add the space.\n",      "% Implement \'awidthshow\' and friends as calls to \'show\' to catch this.\n", 
        "\n",      "/pstotext_awidthshow { % cx cy char ax ay string --\n",      "  //kshow.temp\n",      "  0 1 3 index length 1 sub\n", 
        "  {\n",      "    2 index exch get\n",      "    1 index 0 2 index put\n",      "    1 index show\n", 
        "    4 index 4 index rmoveto\n",      "    5 index eq\n",      "    { 6 index 6 index rmoveto } if\n",      "  } for\n", 
        "  pop pop pop pop pop pop pop\n",      "} def\n",      "\n",      "/pstotext_xshow { % string numarray --\n", 
        "  //kshow.temp\n",      "  0 1 4 index length 1 sub\n",      "  {\n",      "    currentpoint 2 index\n", 
        "    6 index exch get\n",      "    4 index 0 2 index put pop\n",      "    3 index show \n",      "    moveto\n", 
        "    % set char width from array\n",      "    2 index exch get\n",      "    0 rmoveto\n",      "  } for\n", 
        "  pop pop pop\n",      "} def\n",      "\n",      "/pstotext_yshow { % string numarray --\n", 
        "  //kshow.temp\n",      "  0 1 4 index length 1 sub\n",      "  {\n",      "    currentpoint 2 index\n", 
        "    6 index exch get\n",      "    4 index 0 2 index put pop\n",      "    3 index show\n",      "    moveto\n", 
        "    % set char height from array\n",      "    2 index exch get\n",      "    0 exch rmoveto\n",      "  } for\n", 
        "  pop pop pop\n",      "} def\n",      "\n",      "/pstotext_xyshow { % string numarray --\n", 
        "  //kshow.temp\n",      "  0 1 4 index length 1 sub\n",      "  {\n",      "    currentpoint 2 index\n", 
        "    6 index exch get\n",      "    4 index 0 2 index put pop\n",      "    3 index show\n",      "    moveto\n", 
        "    % set char width and height from array\n",      "    dup add\n",      "    2 index 1 index get exch\n",      "    3 index exch 1 add get\n", 
        "    rmoveto\n",      "  } for\n",      "  pop pop pop\n",      "} def\n", 
        "\n",      "% Output inverse of initial currentmatrix, for possible use by postprocessor.\n",      "(QI ) print\n",      "matrix currentmatrix matrix invertmatrix\n", 
        "{ 100 mul round cvi //printInt exec } forall\n",      "() =\n",      "\n",      "userdict begin\t\t\t% subsequent definitions are publicly visible\n", 
        "\n",      "% Objects placed in systemdict must be in global memory,\n",      "% and must not reference local objects.\n",      "/setglobal where\n", 
        " { pop currentglobal true setglobal }\n",      " { }\n",      "ifelse\n",      "\n", 
        "\n",      "%\n",      "% Redefine the character rendering operations to call \"report\"\n",      "%\n", 
        "\n",      "/show { { show }\n",      "  //systemdict /pstotextLocalDict get /report get\n",      "  exec } bind redef\n", 
        "\n",      "%/ashow { {3 copy ashow pop}\n",      "%  //systemdict /pstotextLocalDict get /report get\n",      "%  exec pop pop } bind redef\n", 
        "\n",      "% Implement as call to show to catch PostScript that uses\n",      "% these to show letters from separate words.\n",      "/ashow {\n", 
        "   0 0 -1 6 3 roll\n",      "  //systemdict /pstotextLocalDict get /pstotext_awidthshow get exec \n",      "} bind redef\n",      "\n", 
        "/widthshow {\n",      "   0 0 3 -1 roll\n",      "  //systemdict /pstotextLocalDict get /pstotext_awidthshow get exec \n",      "} bind redef\n", 
        "\n",      "/awidthshow {\n",      "  //systemdict /pstotextLocalDict get /pstotext_awidthshow get exec \n",      "} bind redef\n", 
        "\n",      "/xshow {\n",      "  //systemdict /pstotextLocalDict get /pstotext_xshow get exec \n",      "} bind redef\n", 
        "\n",      "/yshow {\n",      "  //systemdict /pstotextLocalDict get /pstotext_yshow get exec \n",      "} bind redef\n", 
        "\n",      "/xyshow {\n",      "  //systemdict /pstotextLocalDict get /pstotext_xyshow get exec \n",      "} bind redef\n", 
        "\n",      "/kshow {\t\t\t% stack: proc string\n",      "  exch //systemdict /pstotextLocalDict get exch /kshow.proc exch put\n",      "  false exch\t\t\t% stack: false string\n", 
        "  {\t\t\t\t% stack: false next | prev true next\n",      "    //systemdict /pstotextLocaldict get /kshow.temp get 0 2 index put\n",      "    exch { //systemdict /pstotextLocalDict get\n",      "           /kshow.proc get exec\n", 
        "         } { pop } ifelse\n",      "    //systemdict /pstotextLocaldict get\n",      "    /kshow.temp get //show exec\n",      "    //systemdict /pstotextLocaldict get\n", 
        "    /kshow.temp get 0 get true\t% stack: this true\n",      "    } forall\n",      "\t\t\t\t% stack: false | last true\n",      "  { pop } if\n", 
        "  } bind redef\n",      "\n",      "\n",      "%\n", 
        "% Redefine non-rendering operations so that they don\'t report\n",      "%\n",      "\n",      "/stringwidth { {stringwidth}\n", 
        "  //systemdict /pstotextLocalDict get /dontReport get\n",      "  exec } bind redef\n",      "\n",      "/charpath { {charpath}\n", 
        "  //systemdict /pstotextLocalDict get /dontReport get\n",      "  exec } bind redef\n",      "\n",      "\n", 
        "%\n",      "% Intercept and report the page operations\n",      "%\n",      "\n", 
        "/copypage { (QC) = flush copypage } bind redef\n",      "\n",      "/erasepage { (QZ) = flush erasepage } bind redef\n",      "\n", 
        "/showpage { (QP) = flush showpage } bind redef\n",      "\n",      "\n",      "%\n", 
        "% Intercept font creation so as to record the font inside less save/restore\'s\n",      "% NOTE: disabled, because it actually slows things down\n",      "%\n",      "\n", 
        "% /definefont { definefont //reportFontCreation exec } bind redef\n",      "\n",      "% /makefont { makefont //reportFontCreation exec } bind redef\n",      "\n", 
        "% /scalefont { scalefont //reportFontCreation exec } bind redef\n",      "\n",      "%\n",      "% Clean-up\n", 
        "%\n",      "\n",      "% restore local/global state\n",      "/setglobal where\n", 
        " { pop setglobal }\n",      " { }\n",      "ifelse\n",      "\n", 
        "end\t\t\t\t% close nested userdict begin\n",      "end\t\t\t\t% close private dictionary\n",      "\n",      "% Bind the operators we just defined, and all the others if we didn\'t\n", 
        "% do it before.  Also reenable \'bind\' for future files.\n",      "\n",      "revision 353 ge {\n",      ".bindoperators\n", 
        "NOBIND currentdict systemdict ne and\n",      " { systemdict begin .bindoperators end }\n",      "if\n",      "/DELAYBIND where { pop DELAYBIND { .bindnow } if } if\n", 
        "} if\n",      "\n",      "systemdict readonly pop\n",      "% Restore the current local/global VM mode.\n", 
        "% exec\n",      "\n",      "\n",      "%\n", 
        "% Testing\n",      "%\n",      "\n",      "false {\n", 
        "  100 dict begin\n",      "  (Times 12, two strings; second one sloping up with ashow:)=\n",      "  /Times-Roman findfont 12 scalefont dup /t12 exch def setfont\n",      "  72 300 moveto (Hello world) show\n", 
        "  72 280 moveto 10 1 (Hello world once more) ashow\n",      "  (Times 10 two strings:)=\n",      "  /Times-Roman findfont 10 scalefont setfont\n",      "  72 260 moveto (Third) show\n", 
        "  72 240 moveto (Fourth) show\n",      "  (Symbol 12, one string:)=\n",      "  /Symbol findfont 12 scalefont setfont\n",      "  72 220 moveto (symbol string) show\n", 
        "  (Helvetica 12, two strings:)=\n",      "  /Helvetica findfont 12 scalefont setfont\n",      "  72 200 moveto (Fifth) show\n",      "  72 180 moveto (Sixth) show\n", 
        "  (Times 12 again, two strings; second one with kshow:)=\n",      "  t12 setfont\n",      "  72 160 moveto (Seventh) show\n",      "  end\n", 
        "  72 140 moveto\n",      "  gsave\n",      "    /dx 1.0 def\n",      "    { pop pop\n", 
        "      dx 1 add /dx 1 index def\n",      "      0 rmoveto } (Accelerated letter spacing) kshow\n",      "    grestore\n",      "  (Times 12 scaled by 2:)=\n", 
        "  72 100 moveto\n",      "  gsave\n",      "    2 2 scale\n",      "    (Ninth) show\n", 
        "    grestore\n",      "  count 0 ne { (Left on stack:)= pstack } if\n",      "  flush\n",      "  } if\n", 
        (char const   *)0};
#line 1 "/home/wheatley/newnew/temp/pstotext-1.9/rot270.h"
char const   *rot270[85]  = 
#line 1 "/home/wheatley/newnew/temp/pstotext-1.9/rot270.h"
  {      "% Copyright (C) 1995, Digital Equipment Corporation.\n",      "% All rights reserved.\n",      "% See the file pstotext.txt for a full description.\n",      "%\n", 
        "% Lectern:\n",      "%   PostScript to be prepended to a job to rotate its images by //angle,\n",      "%   adjusting the page shape appropriately.  This works only for\n",      "%   devices (such as ppmraw) that allow arbitrary imaging areas.\n", 
        "\n",      "% Last modified on Thu Aug  1 11:36:13 PDT 1996 by mcjones\n",      "%      modified on Tue Mar 14 14:54:44 PST 1995 by birrell\n",      "\n", 
        "4 dict begin\n",      "/myDict currentdict def\n",      "/angle 270 def\n",      "\n", 
        "/languagelevel where { pop languagelevel 2 ge } { FALSE } ifelse \n",      "  {\n",      "  % Use setpagedevice for level 2 implementations\n",      "  /lastW 0 def\n", 
        "  /lastH 0 def\n",      "  <<\n",      "    /BeginPage {\n",      "      //myDict begin\n", 
        "      pop % page number\n",      "      currentpagedevice /PageSize get aload pop % stack: W H\n",      "%      (H = ) print dup =\n",      "%      (W = ) print 1 index = flush\n", 
        "%      (lastH = ) print lastH =\n",      "%      (lastW = ) print lastW = flush\n",      "      lastH ne exch lastW ne or {\n",      "        % /PageSize has changed: rotate it\n", 
        "        <<\n",      "          /PageSize [\n",      "            currentpagedevice /PageSize get aload pop % stack: W H\n",      "            exch % stack: newW newH\n", 
        "            /lastW 2 index def\n",      "            /lastH 1 index def\n",      "            ]\n",      "          >> setpagedevice % calls BeginPage recursively\n", 
        "%        (H := ) print lastH =\n",      "%        (W := ) print lastW = flush\n",      "        } {\n",      "        % Rotate ctm.  Don\'t do this if we\'re also adjusting PageSize,\n", 
        "        % because that causes another BeginPage call, which does this.\n",      "        currentpagedevice /PageSize get aload pop % stack: width height\n",      "        2 div exch 2 div exch % stack: center\n",      "        2 copy translate //angle rotate neg exch neg translate\n", 
        "        } ifelse\n",      "      end % //myDict\n",      "      }\n",      "    >> setpagedevice\n", 
        "  } {\n",      "  % Use ghostscript specific code for earlier systems\n",      "  % flip current frame buffer\n",      "    currentdevice getdeviceprops >> /HWSize get\n", 
        "    aload pop exch 2 array astore\n",      "    mark exch /HWSize exch currentdevice putdeviceprops pop\n",      "  % fix showpage to add a rotation and translation\n",      "    /adbFixup {\n", 
        "        currentdevice getdeviceprops >>\n",      "        dup /HWSize get aload pop 3 -1 roll\n",      "        /HWResolution get aload pop\n",      "        % stack: xsize ysize xres yres\n", 
        "        exch 4 -1 roll exch div 72 mul\n",      "        % stack: ysize yres xpts\n",      "        3 1 roll div 72 mul\n",      "        % stack: xpts ypts\n", 
        "        2 div exch 2 div exch\n",      "        2 copy translate //angle rotate neg exch neg translate\n",      "        } bind odef\n",      "    /adbShowpage /showpage load def\n", 
        "    userdict begin /showpage { adbShowpage adbFixup } bind odef end\n",      "    adbFixup\n",      "  % define new \".setpagesize\" that flips its arguments\n",      "    statusdict begin\n", 
        "        /adbSet /.setpagesize load def\n",      "        /.setpagesize {\n",      "          exch adbSet adbFixup\n",      "          } bind def\n", 
        "        end\n",      "  } ifelse\n",      "\n",      "end % //myDict\n", 
        (char const   *)0};
#line 1 "/home/wheatley/newnew/temp/pstotext-1.9/rot90.h"
char const   *rot90[85]  = 
#line 1 "/home/wheatley/newnew/temp/pstotext-1.9/rot90.h"
  {      "% Copyright (C) 1995, Digital Equipment Corporation.\n",      "% All rights reserved.\n",      "% See the file pstotext.txt for a full description.\n",      "%\n", 
        "% Lectern:\n",      "%   PostScript to be prepended to a job to rotate its images by //angle,\n",      "%   adjusting the page shape appropriately.  This works only for\n",      "%   devices (such as ppmraw) that allow arbitrary imaging areas.\n", 
        "\n",      "% Last modified on Thu Aug  1 11:36:25 PDT 1996 by mcjones\n",      "%      modified on Tue Mar 14 14:55:13 PST 1995 by birrell\n",      "\n", 
        "4 dict begin\n",      "/myDict currentdict def\n",      "/angle 90 def\n",      "\n", 
        "/languagelevel where { pop languagelevel 2 ge } { FALSE } ifelse \n",      "  {\n",      "  % Use setpagedevice for level 2 implementations\n",      "  /lastW 0 def\n", 
        "  /lastH 0 def\n",      "  <<\n",      "    /BeginPage {\n",      "      //myDict begin\n", 
        "      pop % page number\n",      "      currentpagedevice /PageSize get aload pop % stack: W H\n",      "%      (H = ) print dup =\n",      "%      (W = ) print 1 index = flush\n", 
        "%      (lastH = ) print lastH =\n",      "%      (lastW = ) print lastW = flush\n",      "      lastH ne exch lastW ne or {\n",      "        % /PageSize has changed: rotate it\n", 
        "        <<\n",      "          /PageSize [\n",      "            currentpagedevice /PageSize get aload pop % stack: W H\n",      "            exch % stack: newW newH\n", 
        "            /lastW 2 index def\n",      "            /lastH 1 index def\n",      "            ]\n",      "          >> setpagedevice % calls BeginPage recursively\n", 
        "%        (H := ) print lastH =\n",      "%        (W := ) print lastW = flush\n",      "        } {\n",      "        % Rotate ctm.  Don\'t do this if we\'re also adjusting PageSize,\n", 
        "        % because that causes another BeginPage call, which does this.\n",      "        currentpagedevice /PageSize get aload pop % stack: width height\n",      "        2 div exch 2 div exch % stack: center\n",      "        2 copy translate //angle rotate neg exch neg translate\n", 
        "        } ifelse\n",      "      end % //myDict\n",      "      }\n",      "    >> setpagedevice\n", 
        "  } {\n",      "  % Use ghostscript specific code for earlier systems\n",      "  % flip current frame buffer\n",      "    currentdevice getdeviceprops >> /HWSize get\n", 
        "    aload pop exch 2 array astore\n",      "    mark exch /HWSize exch currentdevice putdeviceprops pop\n",      "  % fix showpage to add a rotation and translation\n",      "    /adbFixup {\n", 
        "        currentdevice getdeviceprops >>\n",      "        dup /HWSize get aload pop 3 -1 roll\n",      "        /HWResolution get aload pop\n",      "        % stack: xsize ysize xres yres\n", 
        "        exch 4 -1 roll exch div 72 mul\n",      "        % stack: ysize yres xpts\n",      "        3 1 roll div 72 mul\n",      "        % stack: xpts ypts\n", 
        "        2 div exch 2 div exch\n",      "        2 copy translate //angle rotate neg exch neg translate\n",      "        } bind odef\n",      "    /adbShowpage /showpage load def\n", 
        "    userdict begin /showpage { adbShowpage adbFixup } bind odef end\n",      "    adbFixup\n",      "  % define new \".setpagesize\" that flips its arguments\n",      "    statusdict begin\n", 
        "        /adbSet /.setpagesize load def\n",      "        /.setpagesize {\n",      "          exch adbSet adbFixup\n",      "          } bind def\n", 
        "        end\n",      "  } ifelse\n",      "\n",      "end % //myDict\n", 
        (char const   *)0};
#line 49 "/home/wheatley/newnew/temp/pstotext-1.9/main.c"
static int cork  =    0;
#line 50 "/home/wheatley/newnew/temp/pstotext-1.9/main.c"
static int debug  =    0;
#line 51 "/home/wheatley/newnew/temp/pstotext-1.9/main.c"
static char const   *gs_cmd  =    "gs";
#line 52 "/home/wheatley/newnew/temp/pstotext-1.9/main.c"
static char const   *outfile  =    "";
#line 54 "/home/wheatley/newnew/temp/pstotext-1.9/main.c"
static char *cmd  ;
#line 56 "/home/wheatley/newnew/temp/pstotext-1.9/main.c"
static enum __anonenum_orientation_52 orientation  =    (enum __anonenum_orientation_52 )0;
#line 61 "/home/wheatley/newnew/temp/pstotext-1.9/main.c"
static int bboxes  =    0;
#line 63 "/home/wheatley/newnew/temp/pstotext-1.9/main.c"
static int explicitFiles  =    0;
#line 65 "/home/wheatley/newnew/temp/pstotext-1.9/main.c"
static void usage(void) 
{ 


  {
  {
#line 66
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"pstotext 1.9 of 2003-01-09\n");
#line 67
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Copyright (C) 1995-1998, Digital Equipment Corporation.\n");
#line 68
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Modified by Ghostgum Software Pty Ltd.\n");
#line 69
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Comments to {mcjones,birrell}@pa.dec.com\n\n");
#line 73
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [option|file]...\n",
          cmd);
#line 74
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options:\n");
#line 75
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -cork            assume Cork encoding for dvips output\n");
#line 76
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -landscape       rotate 270 degrees\n");
#line 80
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -landscapeOther  rotate 90 degrees\n");
#line 82
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -portrait        don\'t rotate (default)\n");
#line 83
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -bboxes          output one word per line with bounding box\n");
#line 84
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -debug           show Ghostscript output and error messages\n");
#line 85
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -gs \"command\"    Ghostscript command\n");
#line 86
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -                read from stdin (default if no files specified)\n");
#line 87
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -output file     output results to \"file\" (default is stdout)\n");
  }
#line 88
  return;
}
}
#line 90 "/home/wheatley/newnew/temp/pstotext-1.9/main.c"
static char *make_temp(char const   **b ) 
{ 
  FILE *f ;
  char *path ;
  char const   *pattern ;
  char *templ ;
  size_t tmp ;
  void *tmp___0 ;
  int fd ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 94
  path = (char *)((void *)0);
#line 98
  pattern = "/tmp/ps2tXXXXXX";
#line 99
  tmp = strlen(pattern);
#line 99
  tmp___0 = malloc(tmp + 1UL);
#line 99
  templ = (char *)tmp___0;
#line 102
  strcpy((char */* __restrict  */)templ, (char const   */* __restrict  */)pattern);
#line 103
  fd = mkstemp(templ);
  }
#line 104
  if (fd == -1) {
    {
#line 105
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mkstemp() failed");
#line 106
    exit(1);
    }
  }
  {
#line 108
  close(fd);
#line 109
  tmp___1 = strlen((char const   *)templ);
#line 109
  tmp___2 = malloc(tmp___1 + 1UL);
#line 109
  path = (char *)tmp___2;
#line 110
  strcpy((char */* __restrict  */)path, (char const   */* __restrict  */)templ);
#line 112
  f = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"w");
  }
#line 113
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 113
    perror((char const   *)cmd);
#line 113
    exit(1);
    }
  }
  {
#line 114
  putbundle(b, f);
#line 115
  fclose(f);
  }
#line 116
  return (path);
}
}
#line 119 "/home/wheatley/newnew/temp/pstotext-1.9/main.c"
static char *ocr_path  =    (char *)((void *)0);
#line 119 "/home/wheatley/newnew/temp/pstotext-1.9/main.c"
static char *rotate_path  =    (char *)((void *)0);
#line 120 "/home/wheatley/newnew/temp/pstotext-1.9/main.c"
static FILE *gs  =    (FILE *)((void *)0);
#line 121 "/home/wheatley/newnew/temp/pstotext-1.9/main.c"
static void *instance  ;
#line 126 "/home/wheatley/newnew/temp/pstotext-1.9/main.c"
static int cleanup(void) 
{ 
  int gsstatus ;
  int status ;
  union __anonunion_53 __constr_expr_0 ;
  union __anonunion_54 __constr_expr_1 ;
  union __anonunion_55 __constr_expr_2 ;
  int tmp ;

  {
  {
#line 127
  status = 0;
#line 128
  pstotextExit(instance);
#line 134
  waitpid(-1, & gsstatus, 0);
  }
#line 136
  if (gsstatus) {
#line 137
    __constr_expr_2.__in = gsstatus;
#line 137
    if ((__constr_expr_2.__i & 127) == 0) {
#line 138
      __constr_expr_1.__in = gsstatus;
#line 138
      if ((__constr_expr_1.__i & 65280) >> 8 != 0) {
#line 138
        status = 3;
      } else {
#line 139
        __constr_expr_0.__in = gsstatus;
#line 139
        if ((int )((signed char )((__constr_expr_0.__i & 127) + 1)) >> 1 > 0) {
#line 139
          status = 4;
        }
      }
    }
  }
#line 142
  if ((unsigned long )rotate_path != (unsigned long )((void *)0)) {
    {
#line 142
    tmp = strcmp((char const   *)rotate_path, "");
    }
#line 142
    if (tmp != 0) {
      {
#line 143
      unlink((char const   *)rotate_path);
#line 144
      free((void *)rotate_path);
#line 145
      rotate_path = (char *)((void *)0);
      }
    }
  }
#line 147
  if ((unsigned long )ocr_path != (unsigned long )((void *)0)) {
    {
#line 148
    unlink((char const   *)ocr_path);
#line 149
    free((void *)ocr_path);
#line 150
    ocr_path = (char *)((void *)0);
    }
  }
#line 156
  return (status);
}
}
#line 159 "/home/wheatley/newnew/temp/pstotext-1.9/main.c"
static void handler(int x ) 
{ 
  int status ;
  int tmp ;

  {
  {
#line 160
  tmp = cleanup();
#line 160
  status = tmp;
  }
#line 161
  if (status != 0) {
    {
#line 161
    exit(status);
    }
  }
  {
#line 165
  exit(2);
  }
}
}
#line 169 "/home/wheatley/newnew/temp/pstotext-1.9/main.c"
static int do_it(char *path ) 
{ 
  char *gs_argv[32] ;
  int gs_argc ;
  int fd[2] ;
  pid_t p ;
  int status ;
  char norotate[1] ;
  FILE *fileout ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char line[2000] ;
  char const   *pre ;
  char const   *word ;
  char const   *post ;
  int llx ;
  int lly ;
  int urx ;
  int ury ;
  char *tmp___18 ;

  {
  {
#line 172
  gs_argc = 0;
#line 179
  norotate[0] = (char )'\000';
#line 185
  fileout = stdout;
#line 186
  tmp = strlen(outfile);
  }
#line 186
  if (tmp != 0UL) {
    {
#line 190
    fileout = fopen((char const   */* __restrict  */)outfile, (char const   */* __restrict  */)"w");
    }
#line 192
    if ((unsigned long )fileout == (unsigned long )((void *)0)) {
      {
#line 192
      perror((char const   *)cmd);
#line 192
      exit(1);
      }
    }
  }
  {
#line 195
  signal(2, & handler);
#line 196
  signal(1, & handler);
#line 198
  ocr_path = make_temp(ocr);
  }
  {
#line 201
  if ((unsigned int )orientation == 0U) {
#line 201
    goto case_0;
  }
#line 202
  if ((unsigned int )orientation == 1U) {
#line 202
    goto case_1;
  }
#line 203
  if ((unsigned int )orientation == 2U) {
#line 203
    goto case_2;
  }
#line 200
  goto switch_break;
  case_0: /* CIL Label */ 
#line 201
  rotate_path = norotate;
#line 201
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 202
  rotate_path = make_temp(rot270);
  }
#line 202
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 203
  rotate_path = make_temp(rot90);
  }
#line 203
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 205
  if ((unsigned long )ocr_path == (unsigned long )((void *)0)) {
    {
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No memory available\n");
#line 207
    cleanup();
#line 208
    exit(1);
    }
  } else
#line 205
  if ((unsigned long )rotate_path == (unsigned long )((void *)0)) {
    {
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No memory available\n");
#line 207
    cleanup();
#line 208
    exit(1);
    }
  }
#line 211
  tmp___0 = gs_argc;
#line 211
  gs_argc ++;
#line 211
  gs_argv[tmp___0] = (char *)"gs";
#line 212
  tmp___1 = gs_argc;
#line 212
  gs_argc ++;
#line 212
  gs_argv[tmp___1] = (char *)"-r72";
#line 213
  tmp___2 = gs_argc;
#line 213
  gs_argc ++;
#line 213
  gs_argv[tmp___2] = (char *)"-dNODISPLAY";
#line 214
  tmp___3 = gs_argc;
#line 214
  gs_argc ++;
#line 214
  gs_argv[tmp___3] = (char *)"-dFIXEDMEDIA";
#line 215
  tmp___4 = gs_argc;
#line 215
  gs_argc ++;
#line 215
  gs_argv[tmp___4] = (char *)"-dDELAYBIND";
#line 216
  tmp___5 = gs_argc;
#line 216
  gs_argc ++;
#line 216
  gs_argv[tmp___5] = (char *)"-dWRITESYSTEMDICT";
#line 217
  if (! debug) {
#line 218
    tmp___6 = gs_argc;
#line 218
    gs_argc ++;
#line 218
    gs_argv[tmp___6] = (char *)"-q";
  }
#line 220
  tmp___7 = gs_argc;
#line 220
  gs_argc ++;
#line 220
  gs_argv[tmp___7] = (char *)"-dNOPAUSE";
#line 221
  tmp___8 = gs_argc;
#line 221
  gs_argc ++;
#line 221
  gs_argv[tmp___8] = (char *)"-dSAFER";
#line 222
  if (rotate_path) {
    {
#line 222
    tmp___10 = strcmp((char const   *)rotate_path, "");
    }
#line 222
    if (tmp___10) {
#line 223
      tmp___9 = gs_argc;
#line 223
      gs_argc ++;
#line 223
      gs_argv[tmp___9] = rotate_path;
    }
  }
#line 225
  if (ocr_path) {
    {
#line 225
    tmp___12 = strcmp((char const   *)ocr_path, "");
    }
#line 225
    if (tmp___12) {
#line 226
      tmp___11 = gs_argc;
#line 226
      gs_argc ++;
#line 226
      gs_argv[tmp___11] = ocr_path;
    }
  }
#line 228
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 229
    tmp___13 = gs_argc;
#line 229
    gs_argc ++;
#line 229
    gs_argv[tmp___13] = (char *)"-";
  } else {
#line 232
    tmp___14 = gs_argc;
#line 232
    gs_argc ++;
#line 232
    gs_argv[tmp___14] = (char *)"--";
#line 233
    tmp___15 = gs_argc;
#line 233
    gs_argc ++;
#line 233
    gs_argv[tmp___15] = path;
  }
  {
#line 235
  tmp___16 = gs_argc;
#line 235
  gs_argc ++;
#line 235
  gs_argv[tmp___16] = (char *)((void *)0);
#line 253
  tmp___17 = pipe((int *)(fd));
  }
#line 253
  if (tmp___17) {
    {
#line 254
    perror("pipe failed: ");
#line 254
    exit(1);
    }
  }
  {
#line 256
  p = fork();
  }
#line 257
  if (p == -1) {
    {
#line 258
    perror("fork failed: ");
#line 258
    exit(1);
    }
  }
#line 260
  if (p == 0) {
    {
#line 261
    close(fd[0]);
#line 262
    dup2(fd[1], 1);
#line 263
    execvp("/usr/bin/gs", (char * const  *)(gs_argv));
#line 264
    perror("execvp: ");
#line 264
    status = cleanup();
#line 264
    exit(1);
    }
  } else {
    {
#line 266
    close(fd[1]);
#line 267
    gs = fdopen(fd[0], "r");
    }
#line 268
    if ((unsigned long )gs == (unsigned long )((void *)0)) {
      {
#line 269
      perror("fdopen: ");
#line 269
      status = cleanup();
#line 269
      exit(1);
      }
    }
  }
  {
#line 273
  status = pstotextInit(& instance);
  }
#line 274
  if (status != 0) {
    {
#line 275
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: internal error %d\n",
            cmd, status);
#line 276
    exit(5);
    }
  }
#line 278
  if (cork) {
    {
#line 279
    status = pstotextSetCork(instance, 1);
    }
#line 280
    if (status != 0) {
      {
#line 281
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: internal error %d\n",
              cmd, status);
#line 282
      exit(5);
      }
    }
  }
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 289
    tmp___18 = fgets((char */* __restrict  */)(line), 2000, (FILE */* __restrict  */)gs);
    }
#line 289
    if ((unsigned long )tmp___18 == (unsigned long )((void *)0)) {
#line 289
      goto while_break;
    }
#line 290
    if (debug) {
      {
#line 290
      fputs((char const   */* __restrict  */)(line), (FILE */* __restrict  */)stderr);
      }
    }
    {
#line 291
    status = pstotextFilter(instance, line, & pre, & word, & post, & llx, & lly, & urx,
                            & ury);
    }
#line 293
    if (status != 0) {
      {
#line 294
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: internal error %d\n",
              cmd, status);
#line 295
      exit(5);
      }
    }
#line 297
    if ((unsigned long )word != (unsigned long )((void *)0)) {
#line 298
      if (! bboxes) {
        {
#line 299
        fputs((char const   */* __restrict  */)pre, (FILE */* __restrict  */)fileout);
#line 299
        fputs((char const   */* __restrict  */)word, (FILE */* __restrict  */)fileout);
#line 299
        fputs((char const   */* __restrict  */)post, (FILE */* __restrict  */)fileout);
        }
#line 300
        if (debug) {
          {
#line 300
          fputc('\n', stderr);
          }
        }
      } else {
#line 303
        if (pre) {
#line 304
          if ((int const   )*pre == 32) {
#line 305
            pre ++;
          }
          {
#line 306
          fputs((char const   */* __restrict  */)pre, (FILE */* __restrict  */)fileout);
          }
        }
        {
#line 308
        fprintf((FILE */* __restrict  */)fileout, (char const   */* __restrict  */)"%6d\t%6d\t%6d\t%6d\t%s\n",
                llx, lly, urx, ury, word);
        }
#line 309
        if (post) {
          {
#line 310
          fputs((char const   */* __restrict  */)post, (FILE */* __restrict  */)fileout);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 314
  if ((unsigned long )fileout != (unsigned long )stdout) {
    {
#line 314
    fclose(fileout);
    }
  }
  {
#line 315
  status = cleanup();
  }
#line 316
  if (status != 0) {
    {
#line 316
    exit(status);
    }
  }
#line 317
  return (status);
}
}
#line 320 "/home/wheatley/newnew/temp/pstotext-1.9/main.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  char *arg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 323
  cmd = *(argv + 0);
#line 324
  i = 1;
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    if (! (i < argc)) {
#line 324
      goto while_break;
    }
    {
#line 325
    arg = *(argv + i);
#line 326
    tmp___7 = strcasecmp((char const   *)arg, "-landscape");
    }
#line 326
    if (tmp___7 == 0) {
#line 326
      orientation = (enum __anonenum_orientation_52 )1;
    } else {
      {
#line 327
      tmp___6 = strcasecmp((char const   *)arg, "-cork");
      }
#line 327
      if (tmp___6 == 0) {
#line 327
        cork = 1;
      } else {
        {
#line 328
        tmp___5 = strcasecmp((char const   *)arg, "-landscapeOther");
        }
#line 328
        if (tmp___5 == 0) {
#line 328
          orientation = (enum __anonenum_orientation_52 )2;
        } else {
          {
#line 329
          tmp___4 = strcasecmp((char const   *)arg, "-portrait");
          }
#line 329
          if (tmp___4 == 0) {
#line 329
            orientation = (enum __anonenum_orientation_52 )0;
          } else {
            {
#line 330
            tmp___3 = strcasecmp((char const   *)arg, "-bboxes");
            }
#line 330
            if (tmp___3 == 0) {
#line 330
              bboxes = 1;
            } else {
              {
#line 331
              tmp___2 = strcasecmp((char const   *)arg, "-debug");
              }
#line 331
              if (tmp___2 == 0) {
#line 331
                debug = 1;
              } else {
                {
#line 332
                tmp___1 = strcasecmp((char const   *)arg, "-gs");
                }
#line 332
                if (tmp___1 == 0) {
#line 333
                  i ++;
#line 334
                  if (i >= argc) {
                    {
#line 334
                    usage();
#line 334
                    exit(1);
                    }
                  }
#line 335
                  gs_cmd = (char const   *)*(argv + i);
                } else {
                  {
#line 337
                  tmp___0 = strcasecmp((char const   *)arg, "-output");
                  }
#line 337
                  if (tmp___0 == 0) {
#line 338
                    i ++;
#line 339
                    if (i >= argc) {
                      {
#line 339
                      usage();
#line 339
                      exit(1);
                      }
                    }
#line 340
                    outfile = (char const   *)*(argv + i);
                  } else {
                    {
#line 342
                    tmp = strcmp((char const   *)arg, "-");
                    }
#line 342
                    if (tmp == 0) {
                      {
#line 342
                      do_it((char *)((void *)0));
                      }
                    } else
#line 343
                    if ((int )*(arg + 0) == 45) {
                      {
#line 343
                      usage();
#line 343
                      exit(1);
                      }
                    } else {
                      {
#line 345
                      explicitFiles ++;
#line 346
                      do_it(arg);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 324
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  if (explicitFiles == 0) {
    {
#line 349
    do_it((char *)((void *)0));
    }
  }
  {
#line 350
  exit(0);
  }
}
}
#line 11 "/home/wheatley/newnew/temp/pstotext-1.9/bundle.c"
void putbundle(char const   **b , FILE *f ) 
{ 
  char const   **ppLine ;

  {
#line 12
  ppLine = b;
#line 13
  ppLine = b;
  {
#line 13
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13
    if (! ((unsigned long )*ppLine != (unsigned long )((void *)0))) {
#line 13
      goto while_break;
    }
    {
#line 14
    fputs((char const   */* __restrict  */)*ppLine, (FILE */* __restrict  */)f);
#line 13
    ppLine ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 16
  return;
}
}
