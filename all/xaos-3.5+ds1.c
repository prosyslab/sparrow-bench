/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 29 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/param.h"
struct params {
   char const   *name ;
   int type ;
   void *value ;
   char const   *help ;
};
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 53 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/fconfig.h"
typedef long double number_t;
#line 8 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/filter.h"
typedef unsigned char pixel_t;
#line 9 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/filter.h"
typedef unsigned char rgb_t[4];
#line 10 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/filter.h"
struct truec {
   int rshift ;
   int gshift ;
   int bshift ;
   int rprec ;
   int gprec ;
   int bprec ;
   unsigned int rmask ;
   unsigned int gmask ;
   unsigned int bmask ;
   unsigned int mask1 ;
   unsigned int mask2 ;
   unsigned int allmask ;
   int byteexact ;
   int missingbyte ;
};
#line 20 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/filter.h"
union paletteinfo {
   struct truec truec ;
};
#line 23 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/filter.h"
struct palette {
   int start ;
   int end ;
   int maxentries ;
   int version ;
   int type ;
   unsigned int *pixels ;
   int npreallocated ;
   rgb_t *rgb ;
   int flags ;
   int (*alloccolor)(struct palette *pal , int init , int r , int g , int b ) ;
   void (*setpalette)(struct palette *pal , int start , int end , rgb_t *rgb ) ;
   void (*allocfinished)(struct palette *pal ) ;
   void (*cyclecolors)(struct palette *pal , int direction ) ;
   int size ;
   void *data ;
   int ncells ;
   unsigned int *index ;
   rgb_t const   *prergb ;
   union paletteinfo info ;
};
#line 47 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/filter.h"
struct image {
   float pixelwidth ;
   float pixelheight ;
   pixel_t **oldlines ;
   pixel_t **currlines ;
   void (*flip)(struct image *img ) ;
   int width ;
   int height ;
   int nimages ;
   int bytesperpixel ;
   int currimage ;
   int flags ;
   int scanline ;
   int version ;
   struct palette *palette ;
   void *data ;
};
#line 160 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/filter.h"
struct requirements {
   int nimages ;
   int supportedmask ;
   int flags ;
};
#line 165
struct queue;
#line 165
struct filteraction;
#line 165
struct fractal_context;
#line 165 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/filter.h"
struct filter {
   struct filter *next ;
   struct filter *previous ;
   struct queue *queue ;
   struct filteraction  const  *action ;
   struct image *image ;
   struct image *childimage ;
   struct requirements req ;
   struct fractal_context *fractalc ;
   void *data ;
   char const   *name ;
   int flags ;
   int imageversion ;
   void (*wait_function)(struct filter *f ) ;
   int pos ;
   int max ;
   int incalculation ;
   int readyforinterrupt ;
   int interrupt ;
   char const   *pass ;
};
#line 181 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/filter.h"
struct initdata {
   void (*wait_function)(struct filter *f ) ;
   struct image *image ;
   struct fractal_context *fractalc ;
   int flags ;
};
#line 187 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/filter.h"
struct filteraction {
   char const   *name ;
   char const   *shortname ;
   int flags ;
   struct filter *(*getinstance)(struct filteraction  const  *a ) ;
   void (*destroyinstance)(struct filter *f ) ;
   int (*doit)(struct filter *f , int flags , int time ) ;
   int (*requirement)(struct filter *f , struct requirements *r ) ;
   int (*initialize)(struct filter *f , struct initdata *i ) ;
   void (*convertup)(struct filter *f , int *x , int *y ) ;
   void (*convertdown)(struct filter *f , int *x , int *y ) ;
   void (*removefilter)(struct filter *f ) ;
};
#line 200 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/filter.h"
struct queue {
   struct filter *first ;
   struct filter *last ;
   int isinitialized ;
   struct filter *palettechg ;
   struct image *saveimage ;
};
#line 35 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/fractal.h"
struct __anonstruct_symetrytype_24 {
   number_t y0 ;
   number_t k ;
};
#line 35 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/fractal.h"
typedef struct __anonstruct_symetrytype_24 symetrytype;
#line 39 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/fractal.h"
struct symetryinfo {
   number_t xsym ;
   number_t ysym ;
   int nsymetries ;
   symetrytype const   *symetry ;
};
#line 44 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/fractal.h"
struct __anonstruct_vrect_25 {
   number_t mc ;
   number_t nc ;
   number_t mi ;
   number_t ni ;
};
#line 44 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/fractal.h"
typedef struct __anonstruct_vrect_25 vrect;
#line 48 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/fractal.h"
struct __anonstruct_vinfo_26 {
   number_t cr ;
   number_t ci ;
   number_t rr ;
   number_t ri ;
};
#line 48 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/fractal.h"
typedef struct __anonstruct_vinfo_26 vinfo;
#line 52 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/fractal.h"
typedef unsigned int (* __attribute__((__const__)) iterationfunc)(number_t  , number_t  ,
                                                                  number_t  , number_t  );
#line 54 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/fractal.h"
struct formula {
   int magic ;
   unsigned int (* __attribute__((__const__)) calculate)(number_t  , number_t  , number_t  ,
                                                         number_t  ) ;
   unsigned int (* __attribute__((__const__)) calculate_periodicity)(number_t  , number_t  ,
                                                                     number_t  , number_t  ) ;
   unsigned int (* __attribute__((__const__)) smooth_calculate)(number_t  , number_t  ,
                                                                number_t  , number_t  ) ;
   unsigned int (* __attribute__((__const__)) smooth_calculate_periodicity)(number_t  ,
                                                                            number_t  ,
                                                                            number_t  ,
                                                                            number_t  ) ;
   void (*calculate_julia)(struct image *img , number_t pre , number_t pim ) ;
   char const   *name[2] ;
   char const   *shortname ;
   vinfo v ;
   int hasperiodicity ;
   int mandelbrot ;
   number_t pre ;
   number_t pim ;
   struct symetryinfo out[12] ;
   struct symetryinfo in[12] ;
   int flags ;
};
#line 73 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/fractal.h"
struct fractal_context {
   number_t pre ;
   number_t pim ;
   number_t bre ;
   number_t bim ;
   struct formula  const  *currentformula ;
   number_t angle ;
   int periodicity ;
   unsigned int maxiter ;
   number_t bailout ;
   int coloringmode ;
   int incoloringmode ;
   int intcolor ;
   int outtcolor ;
   int mandelbrot ;
   int plane ;
   int version ;
   int range ;
   float windowwidth ;
   float windowheight ;
   vinfo s ;
   vrect rs ;
   number_t sin ;
   number_t cos ;
   int slowmode ;
   iterationfunc calculate[2] ;
   number_t periodicity_limit ;
   struct palette *palette ;
};
#line 30 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/timers.h"
struct timer;
#line 31
struct timeemulator;
#line 32 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/timers.h"
typedef struct timer tl_timer;
#line 33 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/timers.h"
typedef struct timer tl_group;
#line 13 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xio.h"
struct xio_filestruct {
   void *data ;
   int (*fputc)(int c , struct xio_filestruct *f ) ;
   int (*fputs)(char const   *s , struct xio_filestruct *f ) ;
   int (*fgetc)(struct xio_filestruct *f ) ;
   int (*fungetc)(int c , struct xio_filestruct *f ) ;
   int (*xeof)(struct xio_filestruct *f ) ;
   int (*fclose)(struct xio_filestruct *f ) ;
   int (*flush)(struct xio_filestruct *f ) ;
};
#line 24 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xio.h"
typedef struct xio_filestruct *xio_file;
#line 46 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xio.h"
typedef char *xio_path;
#line 47 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xio.h"
typedef char const   *xio_constpath;
#line 28 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui_helper.h"
struct uih_window;
#line 28 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui_helper.h"
struct uih_message {
   char *message[5] ;
   tl_timer *messagetimer[5] ;
   int messagetype[5] ;
   struct uih_window *w[5] ;
   int pid[5] ;
   int messagestart ;
};
#line 36 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui_helper.h"
struct uih_line {
   int key ;
   int morph ;
   int color ;
   int posmode ;
   number_t x1 ;
   number_t y1 ;
   number_t x2 ;
   number_t y2 ;
   int mposmode ;
   number_t mx1 ;
   number_t my1 ;
   number_t mx2 ;
   number_t my2 ;
   struct uih_line *next ;
   struct uih_line *prev ;
   struct uih_window *w ;
};
#line 47 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui_helper.h"
struct uih_lines {
   struct uih_line *first ;
   int morphing ;
   int currkey ;
};
#line 53 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui_helper.h"
struct uih_savedcontext {
   xio_file file ;
   int mode ;
   number_t speedup ;
   number_t maxstep ;
   number_t xcenter ;
   number_t ycenter ;
   tl_timer *timer ;
   tl_timer *synctimer ;
   struct fractal_context *fcontext ;
   int clearscreen ;
   int fastmode ;
   int juliamode ;
   int fastrotate ;
   int autorotate ;
   number_t rotationspeed ;
   int firsttime ;
   int filter[20] ;
   int pressed ;
   int rotatepressed ;
   int cycling ;
   int shifted ;
   int manualpaletteshift ;
   int direction ;
   int cyclingspeed ;
   int zoomactive ;
   int xtextpos ;
   int ytextpos ;
   int writefailed ;
   int nonfractalscreen ;
   int color ;
};
#line 80 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui_helper.h"
struct uih_playcontext {
   xio_file file ;
   xio_file prevfiles[11] ;
   int level ;
   xio_path directory ;
   tl_timer *timer ;
   int waittime ;
   int playframe ;
   int timerin ;
   int frametime ;
   int starttime ;
   int morph ;
   int morphtimes[2] ;
   int morphjulia ;
   int morphjuliatimes[2] ;
   int morphangle ;
   int morphangletimes[2] ;
   vinfo destination ;
   vinfo source ;
   number_t srcangle ;
   number_t destangle ;
   number_t sr ;
   number_t si ;
   number_t dr ;
   number_t di ;
   int readfailed ;
   int line ;
   struct uih_lines lines ;
   int morphlinetimes[2] ;
};
#line 120 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui_helper.h"
struct uih_undocontext {
   int last ;
   char *undos[256] ;
};
#line 124
struct xfont;
#line 124 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui_helper.h"
struct uih_context {
   void (*updatemenus)(struct uih_context * , char const   * ) ;
   number_t speedup ;
   number_t maxstep ;
   char const   *menuroot ;
   int display ;
   int save ;
   int play ;
   int cycling ;
   int incalculation ;
   int flags ;
   int interrupt ;
   int (*passfunc)(struct uih_context * , int  , char const   * , float  ) ;
   void (*longwait)(struct uih_context * ) ;
   struct uih_undocontext undo ;
   struct image *image ;
   struct palette *palette ;
   struct fractal_context *fcontext ;
   struct queue *queue ;
   struct filter *uifilter ;
   struct filter *rotatef ;
   struct filter *zengine ;
   struct filter *fixedcolor ;
   struct filter *subwindow ;
   struct filter *julia ;
   struct filter *smalliter ;
   struct filter *filter[20] ;
   double mul ;
   int rotatemode ;
   number_t rotationspeed ;
   int fastmode ;
   int juliamode ;
   int fastrotate ;
   int uncomplette ;
   int dirty ;
   int inanimation ;
   int fastanimation ;
   int palettetype ;
   int paletteseed ;
   int clearscreen ;
   int indofractal ;
   int xtextpos ;
   int ytextpos ;
   int color ;
   int recalculatemode ;
   int stoppedtimers ;
   int nletters ;
   int letterspersec ;
   char *text[3] ;
   struct uih_window *textwindow[3] ;
   struct uih_window *cscreenwindow ;
   int textpos[3] ;
   int textcolor[3] ;
   char const   *errstring ;
   struct xfont  const  *font ;
   struct uih_window *wtop ;
   int wflipped ;
   int wdisplayed ;
   int todisplayletters ;
   struct uih_savedcontext *savec ;
   int viewchanged ;
   int palettechanged ;
   int displaytext ;
   int nonfractalscreen ;
   void (*complettehandler)(void * ) ;
   void *handlerdata ;
   struct uih_playcontext *playc ;
   int playpos ;
   char const   *playstring ;
   struct timeemulator *emulator ;
   int emulatedframetime ;
   int aliasnum ;
   int fixedstep ;
   number_t speed ;
   number_t step ;
   number_t xcenter ;
   number_t ycenter ;
   int xcenterm ;
   int ycenterm ;
   int zoomactive ;
   int pressed ;
   number_t oldx ;
   number_t oldy ;
   int moved ;
   int rotatepressed ;
   number_t oldangle ;
   int ddatalost ;
   int tbreak ;
   int autopilot ;
   int autopilotx ;
   int autopiloty ;
   int autopilotbuttons ;
   int interruptiblemode ;
   int starttime ;
   int endtime ;
   int maxtime ;
   int times[2][50] ;
   int timespos ;
   int count[2] ;
   double lastspeed ;
   double lasttime ;
   tl_timer *maintimer ;
   tl_timer *cyclingtimer ;
   tl_timer *autopilottimer ;
   tl_timer *calculatetimer ;
   tl_timer *doittimer ;
   tl_group *autopilotgroup ;
   int direction ;
   int cyclingdirection ;
   int stopped ;
   int cyclingspeed ;
   int x1 ;
   int y1 ;
   int c1 ;
   number_t minsize ;
   number_t maxsize ;
   int autopilotversion ;
   int autime ;
   int minlong ;
   int interlevel ;
   struct palette *palette2 ;
   int paletteshift ;
   int manualpaletteshift ;
   struct uih_message messg ;
   int lastbuttons ;
   int encoding ;
   int inhibittextoutput ;
};
#line 286 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui_helper.h"
struct uih_window {
   int x ;
   int y ;
   int width ;
   int height ;
   void (*getpos)(struct uih_context *c , int *x , int *y , int *width , int *height ,
                  void *data ) ;
   void (*draw)(struct uih_context *c , void *data ) ;
   struct uih_window *next ;
   struct uih_window *previous ;
   int savedline ;
   int savedpos ;
   char *saveddata ;
   void *data ;
   int flags ;
};
#line 297 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui_helper.h"
typedef struct uih_context uih_context;
#line 6 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/grlib.h"
struct xfont {
   unsigned char const   *data ;
   int width ;
   int height ;
   int realwidth ;
};
#line 14 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uiint.h"
struct ui_textdata {
   int x ;
   int y ;
   int width ;
   char *text ;
   int size ;
   int cursor ;
   int cursorpos ;
   int start ;
   int ndisplayed ;
   int clear ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 48 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xio.h"
typedef char xio_pathdata[4096];
#line 10 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xmenu.h"
union __anonunion_dialogparam_29 {
   char *dstring ;
   int dint ;
   number_t number ;
   number_t dcoord[2] ;
   xio_path dpath ;
   void *dummy ;
};
#line 10 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xmenu.h"
typedef union __anonunion_dialogparam_29 dialogparam;
#line 18 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xmenu.h"
struct dialog {
   char const   *question ;
   int type ;
   int defint ;
   char const   *defstr ;
   number_t deffloat ;
   number_t deffloat2 ;
};
#line 18 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xmenu.h"
typedef struct dialog menudialog;
#line 115 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xmenu.h"
struct menuitem {
   char const   *menuname ;
   char const   *key ;
   char const   *name ;
   char const   *shortname ;
   int type ;
   int flags ;
   void (*function)(void) ;
   int iparam ;
   void const   *pparam ;
   int (*control)(void) ;
   menudialog const   *(*dialog)(struct uih_context * ) ;
};
#line 115 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xmenu.h"
typedef struct menuitem menuitem;
#line 97 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/fractal.h"
typedef struct fractal_context fractal_context;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 10 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/catalog.h"
struct varnames {
   struct varnames *left ;
   struct varnames *right ;
   char *name ;
   char *value ;
};
#line 15 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/catalog.h"
struct catalog {
   struct varnames *root[31] ;
};
#line 15 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/catalog.h"
typedef struct catalog catalog_t;
#line 72 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui.h"
typedef unsigned char ui_rgb[4];
#line 73 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui.h"
typedef ui_rgb *ui_palette;
#line 75 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui.h"
struct gui_driver {
   void (*setrootmenu)(struct uih_context *c , char const   *name ) ;
   void (*enabledisable)(struct uih_context *c , char const   *name ) ;
   void (*menu)(struct uih_context *c , char const   *name ) ;
   void (*dialog)(struct uih_context *c , char const   *name ) ;
   void (*help)(struct uih_context *c , char const   *name ) ;
};
#line 82 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui.h"
struct ui_driver {
   char const   *name ;
   int (*init)(void) ;
   void (*getsize)(int * , int * ) ;
   void (*processevents)(int  , int * , int * , int * , int * ) ;
   void (*getmouse)(int * , int * , int * ) ;
   void (*uninit)(void) ;
   int (*set_color)(int  , int  , int  , int  ) ;
   void (*set_range)(ui_palette palette , int  , int  ) ;
   void (*print)(int  , int  , char const   * ) ;
   void (*display)(void) ;
   int (*alloc_buffers)(char **buffer1 , char **buffer2 ) ;
   void (*free_buffers)(char *buffer1 , char *buffer2 ) ;
   void (*flip_buffers)(void) ;
   void (*mousetype)(int type ) ;
   void (*flush)(void) ;
   int textwidth ;
   int textheight ;
   struct params  const  *params ;
   int flags ;
   float width ;
   float height ;
   int maxwidth ;
   int maxheight ;
   int imagetype ;
   int palettestart ;
   int paletteend ;
   int maxentries ;
   int rmask ;
   int gmask ;
   int bmask ;
   struct gui_driver  const  *gui_driver ;
};
#line 59 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
struct dialogitem;
#line 60 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
struct dialogtype {
   void (*build)(struct dialogitem *item , menudialog const   *entry ) ;
   int (*key)(struct dialogitem *item , int key ) ;
   void (*mouse)(struct dialogitem *item , int x , int y , int buttons , int flags ) ;
   void (*destroy)(struct dialogitem *item , dialogparam *param ) ;
   void (*draw)(struct dialogitem *item ) ;
   void (*unselect)(struct dialogitem *item ) ;
};
#line 69 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
struct dialogitem {
   int y ;
   int width ;
   int width1 ;
   int height ;
   menudialog const   *dialog ;
   void *data ;
   struct dialogtype  const  *type ;
};
#line 76 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
struct opendialog {
   int x ;
   int y ;
   int width ;
   int height ;
   int half ;
   int nitems ;
   menudialog const   *dialog ;
   int mousereleased ;
   int mousegrab ;
   menuitem const   *item ;
   int current ;
   struct dialogitem *items ;
   struct uih_window *window ;
};
#line 95 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
struct yesnodialog {
   int width ;
   int questionwidth ;
   int mousereleased ;
   char *question ;
   void (*handler)(int yes ) ;
   int selected ;
   int pressed ;
   struct uih_window *window ;
};
#line 131 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
struct okdata {
   int pressed ;
   int selected ;
};
#line 746 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
struct ui_filedata {
   struct ui_textdata *text ;
   int active ;
   int pressed ;
};
#line 946 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
struct ui_coorddata {
   struct ui_textdata *text[2] ;
   int active ;
};
#line 1082 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
struct ui_choicedata {
   char const   **texts ;
   int selected ;
   int n ;
   struct uih_window *menu ;
   int x ;
   int y ;
   int width ;
   int height ;
   int active ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 102 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/render.c"
struct frame_info {
   vrect rect ;
   number_t angle ;
   char *name ;
   int newimage ;
};
#line 2 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/pixel_t.h"
typedef unsigned int pixel32_t;
#line 10 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/pixel_t.h"
typedef unsigned short pixel16_t;
#line 17 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/pixel_t.h"
typedef unsigned char pixel8_t;
#line 47 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uimenu.c"
struct ui_menuitems {
   int x ;
   int y ;
   int width ;
   int height ;
   menuitem const   *item ;
   int separator ;
};
#line 52 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uimenu.c"
struct ui_menu {
   int x ;
   int y ;
   int width ;
   int height ;
   char const   *name ;
   char const   *fullname ;
   int namewidth ;
   int selected ;
   int n ;
   int flags ;
   struct ui_menuitems *items ;
   struct uih_window *window ;
   tl_timer *timer ;
};
#line 19 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/pixel_t.h"
typedef pixel8_t *ppixel8_t;
#line 20 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/pixel_t.h"
typedef pixel16_t *ppixel16_t;
#line 21 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/pixel_t.h"
typedef pixel32_t *ppixel32_t;
#line 34 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xthread.h"
struct taskinfo {
   int n ;
};
#line 17 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/engine/palettef.c"
struct palettedata {
   struct palette *palette ;
   int active ;
   unsigned int table[256] ;
};
#line 17 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xshl.h"
struct xshl_context {
   int flags ;
   char *linktext ;
};
#line 21 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xshl.h"
struct xshl_item {
   struct xshl_context c ;
   char *text ;
   int x ;
   int width ;
   struct xshl_item *next ;
};
#line 28 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xshl.h"
struct xshl_line {
   int y ;
   struct xshl_item *first ;
};
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 42 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/param.h"
int params_parser(int argc , char **argv ) ;
#line 43
void params_register(struct params  const  *par ) ;
#line 362 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xmenu.h"
extern void menu_printhelp(void) ;
#line 367
extern int menu_processargs(int n , int argc , char **argv ) ;
#line 7 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xerror.h"
extern void x_error(char *text  , ...) ;
#line 36 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/param.c"
static struct params  const  *params[40]  ;
#line 37 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/param.c"
int nparams  ;
#line 39 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/param.c"
int params_parser(int argc , char **argv ) 
{ 
  int i ;
  int p ;
  int d ;
  int ie ;
  int is ;
  struct params  const  *par ;
  int error___1 ;
  int found ;
  int tmp ;
  int n ;
  int tmp___0 ;
  float n___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *name___0[4] ;

  {
#line 41
  p = 0;
#line 42
  ie = 0;
#line 44
  par = (struct params  const  *)((void *)0);
#line 45
  error___1 = 0;
#line 47
  i = 1;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (i < argc) {
#line 47
      if (! (! error___1)) {
#line 47
        goto while_break;
      }
    } else {
#line 47
      goto while_break;
    }
    {
#line 48
    found = 0;
#line 53
    tmp = strcmp("-help", (char const   *)*(argv + i));
    }
#line 53
    if (! tmp) {
#line 54
      error___1 = 1;
#line 55
      goto while_break;
    }
#line 57
    d = 0;
    {
#line 57
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 57
      if (! (d < nparams)) {
#line 57
        goto while_break___0;
      }
#line 58
      par = params[d];
#line 59
      p = 0;
      {
#line 59
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 59
        if ((unsigned long )(par + p)->name != (unsigned long )((void *)0)) {
#line 59
          if (! (! error___1)) {
#line 59
            goto while_break___1;
          }
        } else {
#line 59
          goto while_break___1;
        }
        {
#line 60
        tmp___2 = strcmp((char const   *)(par + p)->name, (char const   *)*(argv + i));
        }
#line 60
        if (! tmp___2) {
#line 61
          found = 1;
#line 62
          is = i;
          {
#line 64
          if ((par + p)->type == 0) {
#line 64
            goto case_0;
          }
#line 67
          if ((par + p)->type == 1) {
#line 67
            goto case_1;
          }
#line 87
          if ((par + p)->type == 3) {
#line 87
            goto case_3;
          }
#line 108
          if ((par + p)->type == 2) {
#line 108
            goto case_2;
          }
#line 63
          goto switch_break;
          case_0: /* CIL Label */ 
#line 65
          *((int *)(par + p)->value) = 1;
#line 66
          goto switch_break;
          case_1: /* CIL Label */ 
#line 70
          if (i == argc - 1) {
            {
#line 71
            x_error((char *)"parameter %s requires numeric value.", *(argv + i));
#line 74
            error___1 = 1;
            }
#line 75
            goto switch_break;
          }
          {
#line 77
          tmp___0 = sscanf((char const   */* __restrict  */)*(argv + (i + 1)), (char const   */* __restrict  */)"%i",
                           & n);
          }
#line 77
          if (tmp___0 != 1) {
            {
#line 78
            x_error((char *)"parameter for %s is not number.", *(argv + i));
#line 80
            error___1 = 1;
            }
#line 81
            goto switch_break;
          }
#line 83
          *((int *)(par + p)->value) = n;
#line 84
          i ++;
#line 86
          goto switch_break;
          case_3: /* CIL Label */ 
#line 90
          if (i == argc - 1) {
            {
#line 91
            x_error((char *)"parameter %s requires floating point numeric value.",
                    *(argv + i));
#line 94
            error___1 = 1;
            }
#line 95
            goto switch_break;
          }
          {
#line 97
          tmp___1 = sscanf((char const   */* __restrict  */)*(argv + (i + 1)), (char const   */* __restrict  */)"%f",
                           & n___0);
          }
#line 97
          if (tmp___1 != 1) {
            {
#line 98
            x_error((char *)"parameter for %s is not floating point number.", *(argv + i));
#line 101
            error___1 = 1;
            }
#line 102
            goto switch_break;
          }
#line 104
          *((float *)(par + p)->value) = n___0;
#line 105
          i ++;
#line 107
          goto switch_break;
          case_2: /* CIL Label */ 
#line 110
          if (i == argc - 1) {
            {
#line 111
            x_error((char *)"parameter %s requires string value.", *(argv + i));
#line 114
            error___1 = 1;
            }
#line 115
            goto switch_break;
          }
#line 117
          i ++;
#line 118
          *((char **)(par + p)->value) = *(argv + i);
          switch_break: /* CIL Label */ ;
          }
#line 121
          ie = i;
#line 122
          i = is;
        }
#line 59
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 57
      d ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 126
    if (d == nparams) {
#line 126
      if (! found) {
        {
#line 127
        i = menu_processargs(i, argc, argv);
        }
#line 128
        if (i < 0) {
#line 129
          error___1 = 1;
#line 130
          goto while_break;
        } else {
#line 132
          i ++;
        }
      } else {
#line 134
        i = ie;
      }
    } else {
#line 134
      i = ie;
    }
#line 47
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  if (error___1) {
    {
#line 137
    name___0[0] = "";
#line 137
    name___0[1] = "number";
#line 137
    name___0[2] = "string";
#line 137
    name___0[3] = "f.point";
#line 144
    printf((char const   */* __restrict  */)"                 XaoS3.5 help text\n");
#line 145
    printf((char const   */* __restrict  */)" (This help is genereated automagically. I am sorry for all inconvencies)\n\n");
#line 148
    printf((char const   */* __restrict  */)"option string   param   description\n\n");
#line 149
    d = 0;
    }
    {
#line 149
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 149
      if (! (d < nparams)) {
#line 149
        goto while_break___2;
      }
#line 150
      par = params[d];
#line 151
      p = 0;
      {
#line 151
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 151
        if (! ((unsigned long )(par + p)->name != (unsigned long )((void *)0))) {
#line 151
          goto while_break___3;
        }
#line 152
        if ((par + p)->type == 4) {
          {
#line 153
          printf((char const   */* __restrict  */)"\n%s\n\n", (par + p)->help);
          }
        } else
#line 154
        if (! (par + p)->type) {
          {
#line 155
          printf((char const   */* __restrict  */)" %-14s   %s\n", (par + p)->name,
                 (par + p)->help);
          }
        } else {
          {
#line 157
          printf((char const   */* __restrict  */)" %-14s  %s\n%14s    %s\n", (par + p)->name,
                 name___0[(par + p)->type], "", (par + p)->help);
          }
        }
#line 151
        p ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 160
      if (p == 0) {
        {
#line 161
        printf((char const   */* __restrict  */)" No options available for now\n");
        }
      }
#line 149
      d ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 163
    menu_printhelp();
    }
#line 164
    return (0);
  }
#line 166
  return (1);
}
}
#line 169 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/param.c"
void params_register(struct params  const  *par ) 
{ 
  int tmp ;

  {
#line 171
  tmp = nparams;
#line 171
  nparams ++;
#line 171
  params[tmp] = par;
#line 172
  return;
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 511 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 98 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xio.h"
int xio_getfiles(xio_constpath path1 , char ***names___1 , char ***dirs___0 , int *nnames2 ,
                 int *ndirs2 ) ;
#line 489 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui_helper.h"
extern struct uih_window *uih_registerw(struct uih_context *uih , void (*getpos)(struct uih_context *c ,
                                                                                 int *x ,
                                                                                 int *y ,
                                                                                 int *width ,
                                                                                 int *height ,
                                                                                 void *data ) ,
                                        void (*draw)(struct uih_context *c , void *data ) ,
                                        void *data , int flags ) ;
#line 493
extern void uih_removew(struct uih_context *uih , struct uih_window *w ) ;
#line 496
extern void uih_drawborder(struct uih_context *uih , int x , int y , int width , int height ,
                           int flags ) ;
#line 13 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/grlib.h"
extern int xprint(struct image *image , struct xfont  const  *current , int x , int y ,
                  char const   *text , int encoding , int fgcolor , int bgcolor ,
                  int mode ) ;
#line 20
extern int xtextwidth(struct xfont  const  *font , char const   *text ) ;
#line 21
extern void xrectangle(struct image *image , int x , int y , int width , int height ,
                       int fgcolor ) ;
#line 119 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui.h"
struct uih_context *globaluih  ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xerror.h"
extern void x_fatalerror(char *text  , ...) ;
#line 11 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/misc-f.h"
extern char *mystrdup(char const   * ) ;
#line 24 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uiint.h"
uih_context *uih ;
#line 32 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uiint.h"
int filevisible  ;
#line 39
struct ui_textdata *ui_opentext(int x , int y , int width , char const   *def ) ;
#line 40
void ui_drawtext(struct ui_textdata *d , int active___0 ) ;
#line 41
void ui_textmouse(struct ui_textdata *d , int x , int y ) ;
#line 42
void ui_closetext(struct ui_textdata *d ) ;
#line 43
int ui_textkey(struct ui_textdata *d , int key ) ;
#line 60
void ui_drawbutton(char const   *text , int pressed , int selected , int x1 , int x2 ,
                   int y ) ;
#line 64
void ui_buildfilesel(char const   *f , char const   *m , void (*c)(char const   * ,
                                                                   int  ) ) ;
#line 66
int ui_keyfilesel(int k ) ;
#line 67
int ui_mousefilesel(int x , int y , int buttons , int flags ) ;
#line 68
void ui_closefilesel(int success ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 24 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static char **dirs  ;
#line 25 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static char **sdirs  ;
#line 26 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static int ndirs  ;
#line 27 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static char **names___0  ;
#line 28 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static char **snames  ;
#line 29 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static int nnames  ;
#line 31 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
struct ui_textdata *dir  ;
#line 31 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
struct ui_textdata *filename  ;
#line 32 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static char lastdir[256]  ;
#line 33 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static char *currdir  ;
#line 35 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static struct uih_window *filew  ;
#line 36 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static char const   *mask  ;
#line 37 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static void (*callback)(char const   *name , int succ )  ;
#line 39 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static int filex  ;
#line 39 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static int filey  ;
#line 39 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static int filewidth  ;
#line 39 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static int fileheight  ;
#line 58 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static int selectedname  ;
#line 59 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static int selecteddir  ;
#line 60 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static int namestart  ;
#line 61 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static int dirstart  ;
#line 63 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static int pressedbutton  ;
#line 64 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static int activebutton  ;
#line 65 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static int active  ;
#line 67 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static void ui_freenames(void) 
{ 
  int i ;

  {
#line 70
  selectedname = 0;
#line 71
  selecteddir = 0;
#line 72
  if (nnames) {
#line 73
    i = 0;
    {
#line 73
    while (1) {
      while_continue: /* CIL Label */ ;
#line 73
      if (! (i < nnames)) {
#line 73
        goto while_break;
      }
      {
#line 74
      free((void *)*(names___0 + i));
#line 74
      free((void *)*(snames + i));
#line 73
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 75
    free((void *)names___0);
#line 76
    nnames = 0;
    }
  }
#line 78
  if (ndirs) {
#line 79
    i = 0;
    {
#line 79
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 79
      if (! (i < ndirs)) {
#line 79
        goto while_break___0;
      }
      {
#line 80
      free((void *)*(dirs + i));
#line 80
      free((void *)*(sdirs + i));
#line 79
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 81
    free((void *)dirs);
#line 82
    ndirs = 0;
    }
  }
#line 84
  if (snames) {
    {
#line 85
    free((void *)snames);
#line 85
    snames = (char **)((void *)0);
    }
  }
#line 86
  if (sdirs) {
    {
#line 87
    free((void *)sdirs);
#line 87
    sdirs = (char **)((void *)0);
    }
  }
#line 88
  return;
}
}
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static int compar(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 92
  tmp = strcmp(*((char const   **)a), *((char const   **)b));
  }
#line 92
  return (tmp);
}
}
#line 95 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static char **ui_mksnames(int nnames___0 , char **names___1 , int width ) 
{ 
  char **snames___0 ;
  int i ;
  void *tmp ;
  int y ;
  int swidth ;
  int len ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 97
  snames___0 = (char **)((void *)0);
#line 99
  if (nnames___0) {
    {
#line 100
    qsort((void *)names___1, (size_t )nnames___0, sizeof(*names___1), & compar);
#line 102
    tmp = malloc(sizeof(*snames___0) * (unsigned long )nnames___0);
#line 102
    snames___0 = (char **)tmp;
#line 103
    i = 0;
    }
    {
#line 103
    while (1) {
      while_continue: /* CIL Label */ ;
#line 103
      if (! (i < nnames___0)) {
#line 103
        goto while_break;
      }
      {
#line 104
      tmp___3 = xtextwidth(uih->font, (char const   *)*(names___1 + i));
      }
#line 104
      if (tmp___3 <= width) {
        {
#line 105
        *(snames___0 + i) = mystrdup((char const   *)*(names___1 + i));
        }
      } else {
        {
#line 108
        swidth = 0;
#line 109
        tmp___0 = strlen((char const   *)*(names___1 + i));
#line 109
        len = (int )tmp___0;
#line 110
        tmp___1 = strlen((char const   *)*(names___1 + i));
#line 110
        tmp___2 = malloc(tmp___1 + 2UL);
#line 110
        *(snames___0 + i) = (char *)tmp___2;
#line 111
        y = len - 4;
        }
        {
#line 111
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 111
          if (! (y < len)) {
#line 111
            goto while_break___0;
          }
#line 112
          swidth += (int )(uih->font)->width;
#line 111
          y ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 113
        swidth += (int )(uih->font)->width;
#line 114
        y = 0;
        {
#line 115
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 115
          if (! (swidth < width)) {
#line 115
            goto while_break___1;
          }
#line 116
          *(*(snames___0 + i) + y) = *(*(names___1 + i) + y);
#line 117
          swidth += (int )(uih->font)->width;
#line 118
          y ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 120
        *(*(snames___0 + i) + (y - 1)) = (char )'|';
#line 121
        *(*(snames___0 + i) + y) = (char)0;
#line 122
        strcat((char */* __restrict  */)*(snames___0 + i), (char const   */* __restrict  */)((*(names___1 + i) + len) - 4));
        }
      }
#line 103
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 126
  return (snames___0);
}
}
#line 129 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static void ui_buildnames(int width ) 
{ 


  {
  {
#line 131
  ui_freenames();
#line 132
  xio_getfiles((xio_constpath )currdir, & names___0, & dirs, & nnames, & ndirs);
  }
#line 133
  if (snames) {
    {
#line 134
    free((void *)snames);
#line 134
    snames = (char **)((void *)0);
    }
  }
#line 135
  if (sdirs) {
    {
#line 136
    free((void *)sdirs);
#line 136
    sdirs = (char **)((void *)0);
    }
  }
  {
#line 137
  snames = ui_mksnames(nnames, names___0, width);
#line 138
  sdirs = ui_mksnames(ndirs, dirs, width);
  }
#line 139
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
void ui_closefilesel(int success ) 
{ 
  char *text ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 143
  tmp = strlen((char const   *)filename->text);
#line 143
  tmp___0 = strlen((char const   *)currdir);
#line 143
  tmp___1 = malloc((size_t )(((int )tmp + (int )tmp___0) + 3));
#line 143
  text = (char *)tmp___1;
#line 146
  filevisible = 0;
#line 147
  uih_removew(uih, filew);
#line 148
  ui_freenames();
#line 149
  sprintf((char */* __restrict  */)text, (char const   */* __restrict  */)"%s/%s",
          currdir, filename->text);
#line 150
  ui_closetext(dir);
#line 151
  ui_closetext(filename);
#line 152
  strcpy((char */* __restrict  */)(lastdir), (char const   */* __restrict  */)currdir);
#line 153
  free((void *)currdir);
#line 154
  (*callback)((char const   *)text, success);
#line 155
  free((void *)text);
#line 156
  uih->display = 1;
#line 157
  ui_freenames();
  }
#line 158
  return;
}
}
#line 160 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static void filepos(uih_context *c , int *x , int *y , int *w , int *h , void *data ) 
{ 


  {
#line 163
  *x = filex;
#line 164
  *y = filey;
#line 165
  *w = filewidth;
#line 166
  *h = fileheight;
#line 167
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static void drawfile(uih_context *c , void *data ) 
{ 
  int i ;
  int ypos ;
  int h ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  int xstart ;
  int xend ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int xstart___0 ;
  int xend___0 ;

  {
  {
#line 173
  h = (int )((uih->font)->height + 1);
#line 174
  uih_drawborder(uih, filex + 2, filey + 2, filewidth - 4, (int )(((uih->font)->height + 1) + 4),
                 20);
#line 177
  uih_drawborder(uih, filex + 2, ((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4),
                 filewidth - 4, (int )(((uih->font)->height + 1) + 4), 20);
  }
#line 181
  if (active == 4) {
#line 181
    if (activebutton == 0) {
#line 181
      tmp = 1;
    } else {
#line 181
      tmp = 0;
    }
  } else {
#line 181
    tmp = 0;
  }
  {
#line 181
  ui_drawbutton("OK", pressedbutton == 0, tmp, filex + 2, (filex + filewidth / 2) - 2,
                ((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4));
  }
#line 184
  if (active == 4) {
#line 184
    if (activebutton == 1) {
#line 184
      tmp___0 = 1;
    } else {
#line 184
      tmp___0 = 0;
    }
  } else {
#line 184
    tmp___0 = 0;
  }
  {
#line 184
  tmp___1 = gettext("Cancel");
#line 184
  ui_drawbutton((char const   *)tmp___1, pressedbutton == 1, tmp___0, (filex + filewidth / 2) + 2,
                (filex + filewidth) - 2, ((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4));
#line 189
  uih_drawborder(uih, filex + 2, ((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2,
                 (((filewidth - 20) - 20) / 2 + 6) + 10, ((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2),
                 4);
#line 192
  uih_drawborder(uih, (filex + filewidth / 2) + 2, ((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2,
                 (((filewidth - 20) - 20) / 2 + 6) + 10, ((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2),
                 4);
#line 195
  ypos = (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2) + 2;
#line 196
  i = 0;
  }
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (ypos + h < (((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) {
#line 196
      if (! (i + namestart < nnames)) {
#line 196
        goto while_break;
      }
    } else {
#line 196
      goto while_break;
    }
#line 197
    if (i + namestart == selectedname) {
#line 198
      if ((uih->palette)->type & 3840) {
#line 198
        tmp___2 = *((uih->palette)->index + 0);
      } else {
#line 198
        tmp___2 = *((uih->palette)->index + 4);
      }
      {
#line 198
      xrectangle(uih->image, filex + 4, ypos, ((filewidth - 20) - 20) / 2, h, (int )tmp___2);
      }
    }
#line 204
    if ((uih->palette)->type & 3840) {
#line 205
      if (i + namestart == selectedname) {
#line 205
        tmp___3 = *((uih->palette)->index + 1);
      } else {
#line 205
        tmp___3 = *((uih->palette)->index + 0);
      }
      {
#line 205
      xprint(uih->image, uih->font, filex + 4, ypos, (char const   *)*(snames + (i + namestart)),
             uih->encoding, (int )tmp___3, (int )*((uih->palette)->index + 0), 1);
      }
    } else {
#line 211
      if (i + namestart == selectedname) {
#line 211
        if (active == 1) {
#line 211
          tmp___4 = *((uih->palette)->index + 2);
        } else {
#line 211
          tmp___4 = *((uih->palette)->index + 1);
        }
      } else {
#line 211
        tmp___4 = *((uih->palette)->index + 1);
      }
      {
#line 211
      xprint(uih->image, uih->font, filex + 4, ypos, (char const   *)*(snames + (i + namestart)),
             uih->encoding, (int )tmp___4, (int )*((uih->palette)->index + 0), 0);
      }
    }
#line 216
    ypos += h;
#line 196
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  if (nnames) {
#line 219
    xstart = (namestart * (((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2))) / nnames;
#line 220
    xend = ((namestart + ((((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4) / (int )((uih->font)->height + 1)) * (((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2))) / nnames;
#line 221
    if (xstart > (((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4) {
#line 222
      xstart = (((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4;
    }
#line 223
    if (xend > (((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4) {
#line 224
      xend = (((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4;
    }
    {
#line 225
    uih_drawborder(uih, (filex + ((filewidth - 20) - 20) / 2) + 6, ((((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2) + xstart) + 2,
                   10, xend - xstart, 0);
    }
  }
#line 229
  ypos = (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2) + 2;
#line 230
  i = 0;
  {
#line 230
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 230
    if (ypos + h < (((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) {
#line 230
      if (! (i + dirstart < ndirs)) {
#line 230
        goto while_break___0;
      }
    } else {
#line 230
      goto while_break___0;
    }
#line 231
    if (i + dirstart == selecteddir) {
#line 232
      if ((uih->palette)->type & 3840) {
#line 232
        tmp___5 = *((uih->palette)->index + 0);
      } else {
#line 232
        tmp___5 = *((uih->palette)->index + 4);
      }
      {
#line 232
      xrectangle(uih->image, (filex + filewidth / 2) + 4, ypos, ((filewidth - 20) - 20) / 2,
                 h, (int )tmp___5);
      }
    }
#line 237
    if ((uih->palette)->type & 3840) {
#line 238
      if (i + dirstart == selecteddir) {
#line 238
        tmp___6 = *((uih->palette)->index + 1);
      } else {
#line 238
        tmp___6 = *((uih->palette)->index + 0);
      }
      {
#line 238
      xprint(uih->image, uih->font, (filex + filewidth / 2) + 4, ypos, (char const   *)*(sdirs + (i + dirstart)),
             uih->encoding, (int )tmp___6, (int )*((uih->palette)->index + 0), 1);
      }
    } else {
#line 245
      if (i + dirstart == selecteddir) {
#line 245
        if (active == 2) {
#line 245
          tmp___7 = *((uih->palette)->index + 2);
        } else {
#line 245
          tmp___7 = *((uih->palette)->index + 1);
        }
      } else {
#line 245
        tmp___7 = *((uih->palette)->index + 1);
      }
      {
#line 245
      xprint(uih->image, uih->font, (filex + filewidth / 2) + 4, ypos, (char const   *)*(sdirs + (i + dirstart)),
             uih->encoding, (int )tmp___7, (int )*((uih->palette)->index + 0), 0);
      }
    }
#line 251
    ypos += h;
#line 230
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 253
  if (ndirs) {
#line 254
    xstart___0 = (dirstart * (((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2))) / ndirs;
#line 255
    xend___0 = ((dirstart + ((((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4) / (int )((uih->font)->height + 1)) * (((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2))) / ndirs;
#line 256
    if (xstart___0 > (((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4) {
#line 257
      xstart___0 = (((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4;
    }
#line 258
    if (xend___0 > (((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4) {
#line 259
      xend___0 = (((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4;
    }
    {
#line 260
    uih_drawborder(uih, ((filex + filewidth / 2) + ((filewidth - 20) - 20) / 2) + 6,
                   ((((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2) + xstart___0) + 2,
                   10, xend___0 - xstart___0, 0);
    }
  }
  {
#line 263
  ui_drawtext(filename, active == 3);
#line 264
  ui_drawtext(dir, active == 0);
  }
#line 265
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static void setname(int name___0 ) 
{ 


  {
  {
#line 269
  ui_closetext(filename);
#line 270
  filename = ui_opentext(filex + 4, (((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) + 2,
                         filewidth - 8, (char const   *)*(names___0 + name___0));
  }
#line 273
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static void setdir(int name___0 ) 
{ 
  char *dirstring ;
  char *s ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int i___0 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;

  {
#line 283
  dirstring = *(dirs + name___0);
#line 284
  s = (char *)((void *)0);
#line 285
  if ((int )*(dirstring + 0) == 46) {
#line 285
    if (! *(dirstring + 1)) {
      {
#line 287
      s = mystrdup((char const   *)currdir);
      }
    } else {
#line 285
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 288
  if (*(dirstring + 0)) {
#line 288
    if (*(dirstring + 1)) {
#line 288
      if ((int )*(dirstring + 0) == 46) {
#line 288
        if ((int )*(dirstring + 1) == 46) {
#line 288
          if (! *(dirstring + 2)) {
            {
#line 290
            tmp = strlen((char const   *)currdir);
#line 290
            i = (int )tmp;
#line 291
            tmp___0 = strlen((char const   *)dirstring);
#line 291
            tmp___1 = strlen((char const   *)currdir);
#line 291
            tmp___2 = malloc((size_t )(((int )tmp___0 + (int )tmp___1) + 2));
#line 291
            s = (char *)tmp___2;
#line 293
            strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)currdir);
            }
            {
#line 294
            while (1) {
              while_continue: /* CIL Label */ ;
#line 294
              if (i >= 0) {
#line 294
                if ((int )*(s + i) != 47) {
#line 294
                  if ((int )*(s + i) != 92) {
#line 294
                    if (! ((int )*(s + i) != 47)) {
#line 294
                      goto while_break;
                    }
                  } else {
#line 294
                    goto while_break;
                  }
                } else {
#line 294
                  goto while_break;
                }
              } else {
#line 294
                goto while_break;
              }
#line 294
              i --;
            }
            while_break: /* CIL Label */ ;
            }
#line 297
            if (i < 0) {
              {
#line 298
              free((void *)s);
#line 298
              s = (char *)((void *)0);
              }
            } else {
#line 300
              *(s + i) = (char)0;
            }
          }
        }
      }
    }
  }
#line 302
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 303
    tmp___3 = strlen((char const   *)currdir);
#line 303
    i___0 = (int )tmp___3;
#line 304
    tmp___4 = strlen((char const   *)dirstring);
#line 304
    tmp___5 = strlen((char const   *)currdir);
#line 304
    tmp___6 = malloc((size_t )(((int )tmp___4 + (int )tmp___5) + 2));
#line 304
    s = (char *)tmp___6;
#line 306
    strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)currdir);
    }
#line 307
    if ((int )*(currdir + (i___0 - 1)) != 47) {
#line 307
      if ((int )*(currdir + (i___0 - 1)) != 92) {
#line 307
        if ((int )*(currdir + (i___0 - 1)) != 47) {
          {
#line 309
          strcat((char */* __restrict  */)s, (char const   */* __restrict  */)"/");
          }
        }
      }
    }
    {
#line 310
    strcat((char */* __restrict  */)s, (char const   */* __restrict  */)dirstring);
    }
#line 311
    if (! *(s + 0)) {
#line 312
      *(s + 0) = (char )'/';
#line 312
      *(s + 1) = (char)0;
    }
  }
  {
#line 314
  free((void *)currdir);
#line 321
  currdir = s;
#line 322
  ui_closetext(dir);
#line 323
  dir = ui_opentext(filex + 4, (filey + 2) + 2, filewidth - 8, (char const   *)currdir);
#line 326
  ui_freenames();
#line 327
  ui_buildnames(((filewidth - 20) - 20) / 2);
#line 328
  dirstart = 0;
#line 329
  selecteddir = 0;
#line 330
  namestart = 0;
#line 331
  selectedname = 0;
#line 332
  uih->display = 1;
  }
#line 333
  return;
}
}
#line 335 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static void setexactdir(char const   *dirstring ) 
{ 


  {
  {
#line 337
  free((void *)currdir);
#line 338
  currdir = mystrdup(dirstring);
#line 339
  ui_closetext(dir);
#line 340
  dir = ui_opentext(filex + 4, (filey + 2) + 2, filewidth - 8, (char const   *)currdir);
#line 343
  ui_freenames();
#line 344
  ui_buildnames(((filewidth - 20) - 20) / 2);
#line 345
  dirstart = 0;
#line 346
  selecteddir = 0;
#line 347
  namestart = 0;
#line 348
  selectedname = 0;
#line 349
  uih->display = 1;
  }
#line 350
  return;
}
}
#line 352 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
int ui_keyfilesel(int k ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 354
  if (! filevisible) {
#line 355
    return (0);
  }
#line 356
  if (k == 261) {
    {
#line 357
    ui_closefilesel(0);
    }
  } else {
    {
#line 364
    if (active == 0) {
#line 364
      goto case_0;
    }
#line 382
    if (active == 1) {
#line 382
      goto case_1;
    }
#line 431
    if (active == 2) {
#line 431
      goto case_2;
    }
#line 479
    if (active == 3) {
#line 479
      goto case_3;
    }
#line 496
    if (active == 4) {
#line 496
      goto case_4;
    }
#line 360
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 361
    active = 3;
#line 362
    uih->display = 1;
#line 363
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 365
    tmp = ui_textkey(dir, k);
    }
#line 365
    if (tmp) {
#line 366
      goto switch_break;
    }
#line 367
    if (k == 10) {
      {
#line 368
      active = 3;
#line 369
      setexactdir((char const   *)dir->text);
#line 370
      uih->display = 1;
      }
    } else
#line 367
    if (k == 13) {
      {
#line 368
      active = 3;
#line 369
      setexactdir((char const   *)dir->text);
#line 370
      uih->display = 1;
      }
    }
#line 372
    if (k == 257) {
#line 373
      active = 4;
#line 374
      uih->display = 1;
#line 375
      activebutton = 1;
    }
#line 377
    if (k == 9) {
#line 378
      active ++;
#line 379
      uih->display = 1;
    } else
#line 377
    if (k == 258) {
#line 378
      active ++;
#line 379
      uih->display = 1;
    }
#line 381
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 385
    if (k == 260) {
#line 385
      goto case_260;
    }
#line 385
    if (k == 9) {
#line 385
      goto case_260;
    }
#line 389
    if (k == 259) {
#line 389
      goto case_259;
    }
#line 393
    if (k == 257) {
#line 393
      goto case_257;
    }
#line 401
    if (k == 258) {
#line 401
      goto case_258;
    }
#line 409
    if (k == 262) {
#line 409
      goto case_262;
    }
#line 415
    if (k == 263) {
#line 415
      goto case_263;
    }
#line 424
    if (k == 13) {
#line 424
      goto case_13;
    }
#line 424
    if (k == 10) {
#line 424
      goto case_13;
    }
#line 383
    goto switch_break___0;
    case_260: /* CIL Label */ 
    case_9: /* CIL Label */ 
#line 386
    uih->display = 1;
#line 387
    active = 2;
#line 388
    goto switch_break___0;
    case_259: /* CIL Label */ 
#line 390
    uih->display = 1;
#line 391
    active = 0;
#line 392
    goto switch_break___0;
    case_257: /* CIL Label */ 
#line 394
    if (selectedname) {
#line 395
      uih->display = 1;
#line 396
      selectedname --;
#line 397
      if (selectedname < namestart) {
#line 398
        namestart = selectedname;
      }
    }
#line 400
    goto switch_break___0;
    case_258: /* CIL Label */ 
#line 402
    if (selectedname < nnames - 1) {
#line 403
      uih->display = 1;
#line 404
      selectedname ++;
#line 405
      if (selectedname >= namestart + ((((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4) / (int )((uih->font)->height + 1)) {
#line 406
        namestart = (selectedname - ((((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4) / (int )((uih->font)->height + 1)) + 1;
      }
    }
#line 408
    goto switch_break___0;
    case_262: /* CIL Label */ 
#line 410
    if (selectedname) {
#line 411
      uih->display = 1;
#line 412
      namestart = 0;
#line 412
      selectedname = namestart;
    }
#line 414
    goto switch_break___0;
    case_263: /* CIL Label */ 
#line 416
    if (selectedname < nnames - 1) {
#line 417
      uih->display = 1;
#line 418
      selectedname = nnames - 1;
#line 419
      if (selectedname >= namestart + ((((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4) / (int )((uih->font)->height + 1)) {
#line 420
        namestart = (selectedname - ((((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4) / (int )((uih->font)->height + 1)) + 1;
      }
    }
#line 422
    goto switch_break___0;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    {
#line 425
    setname(selectedname);
#line 426
    uih->display = 1;
#line 427
    active = 3;
    }
#line 428
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 430
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 434
    if (k == 260) {
#line 434
      goto case_260___0;
    }
#line 434
    if (k == 9) {
#line 434
      goto case_260___0;
    }
#line 438
    if (k == 259) {
#line 438
      goto case_259___0;
    }
#line 442
    if (k == 257) {
#line 442
      goto case_257___0;
    }
#line 450
    if (k == 258) {
#line 450
      goto case_258___0;
    }
#line 458
    if (k == 262) {
#line 458
      goto case_262___0;
    }
#line 464
    if (k == 263) {
#line 464
      goto case_263___0;
    }
#line 473
    if (k == 13) {
#line 473
      goto case_13___0;
    }
#line 473
    if (k == 10) {
#line 473
      goto case_13___0;
    }
#line 432
    goto switch_break___1;
    case_260___0: /* CIL Label */ 
    case_9___0: /* CIL Label */ 
#line 435
    uih->display = 1;
#line 436
    active = 3;
#line 437
    goto switch_break___1;
    case_259___0: /* CIL Label */ 
#line 439
    uih->display = 1;
#line 440
    active = 1;
#line 441
    goto switch_break___1;
    case_257___0: /* CIL Label */ 
#line 443
    if (selecteddir) {
#line 444
      uih->display = 1;
#line 445
      selecteddir --;
#line 446
      if (selecteddir < dirstart) {
#line 447
        dirstart = selecteddir;
      }
    }
#line 449
    goto switch_break___1;
    case_258___0: /* CIL Label */ 
#line 451
    if (selecteddir < ndirs - 1) {
#line 452
      uih->display = 1;
#line 453
      selecteddir ++;
#line 454
      if (selecteddir >= dirstart + ((((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4) / (int )((uih->font)->height + 1)) {
#line 455
        dirstart = (selecteddir - ((((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4) / (int )((uih->font)->height + 1)) + 1;
      }
    }
#line 457
    goto switch_break___1;
    case_262___0: /* CIL Label */ 
#line 459
    if (selecteddir) {
#line 460
      uih->display = 1;
#line 461
      dirstart = 0;
#line 461
      selecteddir = dirstart;
    }
#line 463
    goto switch_break___1;
    case_263___0: /* CIL Label */ 
#line 465
    if (selecteddir < ndirs - 1) {
#line 466
      uih->display = 1;
#line 467
      selecteddir = ndirs - 1;
#line 468
      if (selecteddir >= dirstart + ((((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4) / (int )((uih->font)->height + 1)) {
#line 469
        dirstart = (selecteddir - ((((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4) / (int )((uih->font)->height + 1)) + 1;
      }
    }
#line 471
    goto switch_break___1;
    case_13___0: /* CIL Label */ 
    case_10___0: /* CIL Label */ 
    {
#line 474
    setdir(selecteddir);
#line 475
    uih->display = 1;
    }
#line 476
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 478
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 480
    tmp___0 = ui_textkey(filename, k);
    }
#line 480
    if (tmp___0) {
#line 481
      goto switch_break;
    }
#line 482
    if (k == 9) {
#line 483
      active ++;
#line 484
      uih->display = 1;
#line 485
      activebutton = 0;
    } else
#line 482
    if (k == 258) {
#line 483
      active ++;
#line 484
      uih->display = 1;
#line 485
      activebutton = 0;
    }
#line 487
    if (k == 257) {
#line 488
      active --;
#line 489
      uih->display = 1;
    }
#line 492
    if (k == 10) {
      {
#line 493
      ui_closefilesel(1);
      }
    } else
#line 492
    if (k == 13) {
      {
#line 493
      ui_closefilesel(1);
      }
    }
#line 495
    goto switch_break;
    case_4: /* CIL Label */ 
#line 497
    if (k == 10) {
      {
#line 498
      ui_closefilesel(! activebutton);
      }
    } else
#line 497
    if (k == 13) {
      {
#line 498
      ui_closefilesel(! activebutton);
      }
    }
#line 499
    if (k == 9) {
#line 499
      goto _L;
    } else
#line 499
    if (k == 260) {
#line 499
      goto _L;
    } else
#line 499
    if (k == 258) {
      _L: /* CIL Label */ 
#line 500
      uih->display = 1;
#line 501
      activebutton ++;
#line 502
      if (activebutton > 2) {
#line 503
        activebutton = 0;
#line 504
        active = 0;
      }
    }
#line 507
    if (k == 259) {
#line 507
      goto _L___0;
    } else
#line 507
    if (k == 257) {
      _L___0: /* CIL Label */ 
#line 508
      uih->display = 1;
#line 509
      activebutton --;
#line 510
      if (activebutton < 0) {
#line 511
        activebutton = 0;
#line 512
        active = 3;
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 516
  return (1);
}
}
#line 521 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
static int grabbed  =    -1;
#line 519 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
int ui_mousefilesel(int x , int y , int buttons , int flags ) 
{ 
  int pos ;
  int pos___0 ;
  int mouseat ;
  int atitem ;
  int tmp ;
  int mouseat___0 ;

  {
#line 522
  if (! filevisible) {
#line 523
    return (0);
  }
#line 524
  if (grabbed >= 0) {
#line 524
    if (flags & 4) {
#line 525
      if (! grabbed) {
#line 527
        pos = ((y - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) * nnames) / ((((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4);
#line 530
        if (pos >= nnames - ((((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4) / (int )((uih->font)->height + 1)) {
#line 531
          pos = nnames - ((((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4) / (int )((uih->font)->height + 1);
        }
#line 532
        if (pos < 0) {
#line 533
          pos = 0;
        }
#line 534
        if (pos != namestart) {
#line 535
          namestart = pos;
#line 536
          uih->display = 1;
#line 537
          if (selectedname < pos) {
#line 538
            selectedname = pos;
          }
#line 539
          if (selectedname >= pos + ((((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4) / (int )((uih->font)->height + 1)) {
#line 540
            selectedname = (pos + ((((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4) / (int )((uih->font)->height + 1)) - 1;
          }
        }
      } else {
#line 544
        pos___0 = ((y - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) * ndirs) / ((((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4);
#line 547
        if (pos___0 >= ndirs - ((((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4) / (int )((uih->font)->height + 1)) {
#line 548
          pos___0 = ndirs - ((((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4) / (int )((uih->font)->height + 1);
        }
#line 549
        if (pos___0 < 0) {
#line 550
          pos___0 = 0;
        }
#line 551
        if (pos___0 != dirstart) {
#line 552
          dirstart = pos___0;
#line 553
          uih->display = 1;
#line 554
          if (selecteddir < pos___0) {
#line 555
            selecteddir = pos___0;
          }
#line 556
          if (selecteddir >= pos___0 + ((((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4) / (int )((uih->font)->height + 1)) {
#line 557
            selecteddir = (pos___0 + ((((((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 4) / (int )((uih->font)->height + 1)) - 1;
          }
        }
      }
    } else {
#line 561
      grabbed = -1;
    }
  } else {
#line 561
    grabbed = -1;
  }
#line 562
  if (x < filex) {
#line 562
    goto _L;
  } else
#line 562
  if (y < filey) {
#line 562
    goto _L;
  } else
#line 562
  if (x > filex + filewidth) {
#line 562
    goto _L;
  } else
#line 562
  if (y > filex + fileheight) {
    _L: /* CIL Label */ 
#line 564
    if (flags & 1) {
      {
#line 565
      ui_closefilesel(0);
      }
    }
#line 566
    return (1);
  }
#line 568
  if (y < ((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2) {
#line 569
    if (pressedbutton != -1) {
#line 570
      pressedbutton = -1;
#line 570
      uih->display = 1;
    }
#line 571
    if (flags & 8) {
#line 571
      if (active != 0) {
#line 572
        active = 0;
#line 572
        uih->display = 1;
      }
    }
#line 573
    if (flags & 1) {
      {
#line 574
      ui_textmouse(dir, x, y);
      }
    }
  } else
#line 575
  if (y < (((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) {
#line 576
    mouseat = 0;
#line 577
    if (pressedbutton != -1) {
#line 578
      pressedbutton = -1;
#line 578
      uih->display = 1;
    }
#line 579
    if (x > filex + filewidth / 2) {
#line 580
      mouseat = 1;
#line 580
      x -= filewidth / 2;
    }
#line 581
    x -= filex;
#line 582
    if (flags & 8) {
#line 583
      if (! mouseat) {
#line 583
        if (active != 1) {
#line 584
          active = 1;
#line 584
          uih->display = 1;
        }
      }
#line 585
      if (mouseat) {
#line 585
        if (active != 2) {
#line 586
          active = 2;
#line 586
          uih->display = 1;
        }
      }
    }
#line 588
    if (x > ((filewidth - 20) - 20) / 2) {
#line 588
      if (flags & 1) {
#line 589
        grabbed = mouseat;
      } else {
#line 588
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 591
    if (flags & 1) {
#line 592
      atitem = ((y - (((filey + 2) + (int )(((uih->font)->height + 1) + 4)) + 2)) - 2) / (int )((uih->font)->height + 1);
#line 595
      if (atitem < 0) {
#line 596
        atitem = 0;
      }
#line 597
      if (! mouseat) {
#line 598
        atitem += namestart;
#line 599
        if (atitem < nnames) {
#line 600
          if (atitem == selectedname) {
            {
#line 600
            tmp = strcmp((char const   *)*(names___0 + selectedname), (char const   *)filename->text);
            }
#line 600
            if (tmp) {
              {
#line 605
              selectedname = atitem;
#line 606
              uih->display = 1;
#line 607
              setname(selectedname);
              }
            } else {
              {
#line 603
              ui_closefilesel(1);
              }
            }
          } else {
            {
#line 605
            selectedname = atitem;
#line 606
            uih->display = 1;
#line 607
            setname(selectedname);
            }
          }
        }
      } else {
#line 611
        atitem += dirstart;
#line 612
        if (atitem < ndirs) {
          {
#line 613
          selecteddir = atitem;
#line 614
          uih->display = 1;
#line 615
          setdir(selecteddir);
          }
        }
      }
    }
  } else
#line 620
  if (y < ((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) {
#line 621
    if (pressedbutton != -1) {
#line 622
      pressedbutton = -1;
#line 622
      uih->display = 1;
    }
#line 624
    if (flags & 8) {
#line 624
      if (active != 3) {
#line 625
        active = 3;
#line 625
        uih->display = 1;
      }
    }
#line 626
    if (flags & 1) {
      {
#line 627
      ui_textmouse(filename, x, y);
      }
    }
  } else {
#line 629
    mouseat___0 = 0;
#line 630
    if (x > filex + filewidth / 2) {
#line 631
      mouseat___0 = 1;
    }
#line 632
    if (flags & 1) {
#line 633
      if (active != 4) {
#line 634
        active = 4;
#line 634
        uih->display = 1;
      }
#line 635
      if (activebutton != mouseat___0) {
#line 636
        pressedbutton = mouseat___0;
#line 636
        activebutton = pressedbutton;
#line 636
        uih->display = 1;
      } else
#line 635
      if (pressedbutton != mouseat___0) {
#line 636
        pressedbutton = mouseat___0;
#line 636
        activebutton = pressedbutton;
#line 636
        uih->display = 1;
      }
    }
#line 638
    if (flags & 8) {
#line 638
      if (pressedbutton != mouseat___0) {
#line 639
        uih->display = 1;
#line 639
        pressedbutton = -1;
#line 639
        active = 4;
#line 639
        activebutton = mouseat___0;
      }
    }
#line 641
    if (flags & 2) {
#line 641
      if (pressedbutton == mouseat___0) {
        {
#line 642
        ui_closefilesel(! mouseat___0);
        }
      }
    }
  }
#line 644
  return (1);
}
}
#line 647 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/filesel.c"
void ui_buildfilesel(char const   *f , char const   *m , void (*c)(char const   * ,
                                                                   int  ) ) 
{ 


  {
#line 651
  if (filevisible) {
    {
#line 652
    x_fatalerror((char *)"Internal error!");
    }
  }
#line 654
  active = -1;
#line 654
  activebutton = active;
#line 654
  pressedbutton = activebutton;
#line 655
  if ((int )lastdir[0] == 0) {
    {
#line 656
    getcwd(lastdir, (size_t )256);
    }
  }
  {
#line 657
  lastdir[255] = (char)0;
#line 658
  currdir = mystrdup((char const   *)(lastdir));
#line 659
  callback = c;
#line 660
  active = 3;
#line 661
  filex = 0;
#line 662
  filey = 0;
#line 663
  filewidth = (uih->image)->width;
#line 664
  fileheight = (uih->image)->height;
#line 665
  dirstart = 0;
#line 665
  namestart = dirstart;
#line 666
  mask = m;
#line 667
  dir = ui_opentext(filex + 4, (filey + 2) + 2, filewidth - 8, (char const   *)(lastdir));
#line 670
  filename = ui_opentext(filex + 4, (((((filey + fileheight) - 2) - (int )(((uih->font)->height + 1) + 4)) - 2) - (int )(((uih->font)->height + 1) + 4)) + 2,
                         filewidth - 8, f);
#line 673
  filevisible = 1;
#line 674
  ui_buildnames(((filewidth - 20) - 20) / 2);
#line 675
  filew = uih_registerw(uih, & filepos, & drawfile, (void *)0, 2);
  }
#line 676
  return;
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 208
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) rewinddir)(DIR *__dirp ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 435
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 49 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xio.h"
char *xio_appdir  ;
#line 50 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xio.h"
char *xio_homedir  ;
#line 80
char *xio_fixpath(char const   *c ) ;
#line 83
xio_file xio_ropen(char const   *name___0 ) ;
#line 84
xio_file xio_wopen(char const   *name___0 ) ;
#line 88
xio_path xio_getdirectory(xio_constpath filename___0 ) ;
#line 89
xio_path xio_getfilename(char const   *basename , char const   *extension ) ;
#line 90
xio_file xio_getrandomexample(xio_path name___0 ) ;
#line 91
xio_file xio_getcatalog(char const   *name___0 ) ;
#line 92
xio_file xio_gethelp(void) ;
#line 93
xio_file xio_gettutorial(char const   *name___0 , xio_path tmp ) ;
#line 97
int xio_exist(xio_constpath name___0 ) ;
#line 100
void xio_init(char const   *name___0 ) ;
#line 101
void xio_uninit(void) ;
#line 30 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
char *xio_fixpath(char const   *c ) 
{ 
  char *c1 ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *c1___0 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;

  {
#line 32
  if ((int const   )*(c + 0) == 126) {
    {
#line 33
    tmp = strlen(c);
#line 33
    tmp___0 = strlen((char const   *)xio_homedir);
#line 33
    tmp___1 = malloc((tmp + tmp___0) + 5UL);
#line 33
    c1 = (char *)tmp___1;
#line 34
    sprintf((char */* __restrict  */)c1, (char const   */* __restrict  */)"%s%s",
            xio_homedir, c + 1);
    }
#line 35
    return (c1);
  }
#line 37
  if ((int const   )*(c + 0) == 1) {
    {
#line 38
    tmp___2 = strlen(c);
#line 38
    tmp___3 = strlen((char const   *)xio_appdir);
#line 38
    tmp___4 = malloc((tmp___2 + tmp___3) + 5UL);
#line 38
    c1___0 = (char *)tmp___4;
#line 39
    sprintf((char */* __restrict  */)c1___0, (char const   */* __restrict  */)"%s%s",
            xio_appdir, c + 1);
    }
#line 40
    return (c1___0);
  }
  {
#line 42
  tmp___5 = mystrdup(c);
  }
#line 42
  return (tmp___5);
}
}
#line 45 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
int xio_getfiles(xio_constpath path1 , char ***names___1 , char ***dirs___0 , int *nnames2 ,
                 int *ndirs2 ) 
{ 
  char *path ;
  char *tmp ;
  int maxnames ;
  int maxdirs ;
  int nnames___0 ;
  int ndirs___0 ;
  DIR *dir___0 ;
  DIR *tmp___0 ;
  struct stat buf ;
  char buff[4096] ;
  int pathlen ;
  struct dirent *e ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char *n ;
  char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 52
  tmp = xio_fixpath(path1);
#line 52
  path = tmp;
#line 53
  maxnames = 200;
#line 53
  maxdirs = 200;
#line 54
  nnames___0 = 0;
#line 54
  ndirs___0 = 0;
#line 55
  tmp___0 = opendir((char const   *)path);
#line 55
  dir___0 = tmp___0;
  }
#line 60
  if ((unsigned long )dir___0 == (unsigned long )((void *)0)) {
#line 61
    return (0);
  }
  {
#line 62
  *nnames2 = 0;
#line 63
  *ndirs2 = 0;
#line 64
  e = readdir(dir___0);
#line 65
  strcpy((char */* __restrict  */)(buff), (char const   */* __restrict  */)path);
#line 66
  tmp___1 = strlen((char const   *)path);
#line 66
  pathlen = (int )tmp___1;
  }
#line 67
  if ((int )buff[pathlen - 1] != 47) {
#line 68
    buff[pathlen] = (char )'/';
  } else {
#line 70
    pathlen --;
  }
  {
#line 71
  tmp___2 = malloc((unsigned long )maxnames * sizeof(*(*names___1)));
#line 71
  *names___1 = (char **)tmp___2;
#line 72
  tmp___3 = malloc((unsigned long )maxdirs * sizeof(*(*dirs___0)));
#line 72
  *dirs___0 = (char **)tmp___3;
#line 73
  free((void *)path);
  }
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 74
      goto while_break;
    }
    {
#line 75
    tmp___4 = mystrdup((char const   *)(e->d_name));
#line 75
    n = tmp___4;
#line 76
    strcpy((char */* __restrict  */)((buff + pathlen) + 1), (char const   */* __restrict  */)(e->d_name));
#line 77
    stat((char const   */* __restrict  */)(buff), (struct stat */* __restrict  */)(& buf));
    }
#line 78
    if ((buf.st_mode & 61440U) == 16384U) {
#line 79
      if (ndirs___0 == maxdirs) {
        {
#line 80
        maxdirs *= 2;
#line 80
        tmp___5 = realloc((void *)*dirs___0, (unsigned long )maxdirs * sizeof(*(*dirs___0)));
#line 80
        *dirs___0 = (char **)tmp___5;
        }
      }
#line 82
      *(*dirs___0 + ndirs___0) = n;
#line 83
      ndirs___0 ++;
    } else {
#line 85
      if (nnames___0 == maxnames) {
        {
#line 86
        maxnames *= 2;
#line 86
        tmp___6 = realloc((void *)*names___1, (unsigned long )maxnames * sizeof(*(*names___1)));
#line 86
        *names___1 = (char **)tmp___6;
        }
      }
#line 88
      *(*names___1 + nnames___0) = n;
#line 89
      nnames___0 ++;
    }
    {
#line 91
    e = readdir(dir___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  if (nnames___0) {
    {
#line 94
    tmp___7 = realloc((void *)*names___1, (unsigned long )nnames___0 * sizeof(*(*names___1)));
#line 94
    *names___1 = (char **)tmp___7;
    }
  } else {
    {
#line 96
    free((void *)*names___1);
#line 96
    *names___1 = (char **)((void *)0);
    }
  }
#line 97
  if (ndirs___0) {
    {
#line 98
    tmp___8 = realloc((void *)*dirs___0, (unsigned long )ndirs___0 * sizeof(*(*dirs___0)));
#line 98
    *dirs___0 = (char **)tmp___8;
    }
  } else {
    {
#line 100
    free((void *)*dirs___0);
#line 100
    *dirs___0 = (char **)((void *)0);
    }
  }
  {
#line 101
  *nnames2 = nnames___0;
#line 102
  *ndirs2 = ndirs___0;
#line 103
  closedir(dir___0);
  }
#line 104
  return (1);
}
}
#line 108 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
xio_path xio_getdirectory(xio_constpath filename___0 ) 
{ 
  int i ;
  xio_pathdata directory ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 112
  tmp = strlen(filename___0);
#line 112
  i = (int )tmp;
  }
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (i) {
#line 112
      if ((int const   )*(filename___0 + i) != 47) {
#line 112
        if ((int const   )*(filename___0 + i) != 92) {
#line 112
          if (! ((int const   )*(filename___0 + i) != 47)) {
#line 112
            goto while_break;
          }
        } else {
#line 112
          goto while_break;
        }
      } else {
#line 112
        goto while_break;
      }
    } else {
#line 112
      goto while_break;
    }
#line 112
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  if ((int const   )*(filename___0 + i) == 47) {
#line 116
    i ++;
  } else
#line 114
  if ((int const   )*(filename___0 + i) == 92) {
#line 116
    i ++;
  } else
#line 114
  if ((int const   )*(filename___0 + i) == 47) {
#line 116
    i ++;
  }
#line 117
  directory[i] = (char)0;
#line 118
  i --;
  {
#line 119
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 119
    if (! (i >= 0)) {
#line 119
      goto while_break___0;
    }
#line 120
    directory[i] = (char )*(filename___0 + i);
#line 119
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 121
  tmp___0 = mystrdup((char const   *)(directory));
  }
#line 121
  return (tmp___0);
}
}
#line 126 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
static char name[40]  ;
#line 124 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
xio_path xio_getfilename(char const   *basename , char const   *extension ) 
{ 
  int nimage ;
  struct stat sb ;
  char *base ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 127
  nimage = 0;
#line 138
  tmp = xio_fixpath(basename);
#line 138
  base = tmp;
  }
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 140
    tmp___0 = nimage;
#line 140
    nimage ++;
#line 140
    sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"%s%i%s",
            base, tmp___0, extension);
#line 139
    tmp___1 = stat((char const   */* __restrict  */)(name), (struct stat */* __restrict  */)(& sb));
    }
#line 139
    if (! (tmp___1 != -1)) {
#line 139
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 151
  free((void *)base);
  }
#line 152
  return (name);
}
}
#line 158 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
static char const   * const  paths[6]  = {      (char const   */* const  */)"/usr/local/share/XaoS/examples/",      (char const   */* const  */)"\001/examples",      (char const   */* const  */)"\001/../examples",      (char const   */* const  */)"./examples", 
        (char const   */* const  */)"../examples",      (char const   */* const  */)"./"};
#line 155 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
xio_file xio_getrandomexample(xio_path name___0 ) 
{ 
  int i ;
  int p ;
  DIR *d ;
  xio_file f ;
  struct dirent *dir___0 ;
  int n ;
  int max ;
  char *realpath___0 ;
  char *pp ;
  char *tmp ;
  size_t tmp___0 ;
  int s ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int s___0 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;

  {
#line 169
  i = -1;
#line 170
  d = (DIR *)((void *)0);
#line 174
  max = 0;
#line 175
  realpath___0 = (char *)((void *)0);
#line 177
  p = 0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (p < (int )(sizeof(paths) / sizeof(char *))) {
#line 177
      if (! ((unsigned long )d == (unsigned long )((void *)0))) {
#line 177
        goto while_break;
      }
    } else {
#line 177
      goto while_break;
    }
    {
#line 179
    tmp = xio_fixpath((char const   *)paths[p]);
#line 179
    pp = tmp;
#line 180
    d = opendir((char const   *)pp);
#line 181
    free((void *)pp);
    }
#line 182
    if ((unsigned long )d != (unsigned long )((void *)0)) {
      {
#line 183
      realpath___0 = xio_fixpath((char const   *)paths[p]);
#line 184
      tmp___0 = strlen((char const   *)realpath___0);
#line 184
      max = 800 - (int )tmp___0;
#line 185
      i = 0;
      }
      {
#line 185
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 185
        dir___0 = readdir(d);
        }
#line 185
        if (! ((unsigned long )dir___0 != (unsigned long )((void *)0))) {
#line 185
          goto while_break___0;
        }
        {
#line 186
        tmp___1 = strlen((char const   *)(dir___0->d_name));
#line 186
        s = (int )tmp___1;
        }
#line 187
        if (s > max) {
#line 189
          i --;
        } else
#line 187
        if (s < 4) {
#line 189
          i --;
        } else {
          {
#line 187
          tmp___2 = strcmp(".xpf", (char const   *)((dir___0->d_name + s) - 4));
          }
#line 187
          if (tmp___2) {
#line 189
            i --;
          }
        }
#line 185
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 192
      if (! i) {
        {
#line 194
        closedir(d);
#line 195
        free((void *)realpath___0);
#line 196
        d = (DIR *)((void *)0);
        }
#line 197
        goto __Cont;
      }
#line 199
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 177
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 204
    return ((xio_file )((void *)0));
  }
  {
#line 209
  rewinddir(d);
#line 210
  dir___0 = (struct dirent *)((void *)0);
#line 211
  tmp___3 = rand();
#line 211
  n = (int )(((number_t )i * (number_t )tmp___3) / (number_t )((double )2147483647 + 1.0));
#line 213
  i = 0;
  }
  {
#line 213
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 213
    if (! (i <= n)) {
#line 213
      goto while_break___1;
    }
    {
#line 215
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 217
      dir___0 = readdir(d);
      }
#line 218
      if ((unsigned long )dir___0 == (unsigned long )((void *)0)) {
        {
#line 220
        closedir(d);
#line 221
        free((void *)realpath___0);
        }
#line 222
        return ((xio_file )((void *)0));
      }
      {
#line 224
      tmp___4 = strlen((char const   *)(dir___0->d_name));
#line 224
      s___0 = (int )tmp___4;
      }
#line 215
      if (! (s___0 > max)) {
#line 215
        if (! (s___0 < 4)) {
          {
#line 215
          tmp___5 = strcmp(".xpf", (char const   *)((dir___0->d_name + s___0) - 4));
          }
#line 215
          if (! tmp___5) {
#line 215
            goto while_break___2;
          }
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 213
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 228
  if ((unsigned long )dir___0 == (unsigned long )((void *)0)) {
    {
#line 230
    closedir(d);
#line 231
    free((void *)realpath___0);
    }
#line 232
    return ((xio_file )((void *)0));
  }
  {
#line 234
  strcpy((char */* __restrict  */)name___0, (char const   */* __restrict  */)realpath___0);
#line 235
  tmp___6 = strlen((char const   *)name___0);
  }
#line 235
  if ((int )*(name___0 + (tmp___6 - 1UL)) != 47) {
    {
#line 236
    strcat((char */* __restrict  */)name___0, (char const   */* __restrict  */)"/");
    }
  }
  {
#line 237
  strcat((char */* __restrict  */)name___0, (char const   */* __restrict  */)(dir___0->d_name));
#line 238
  closedir(d);
#line 241
  f = xio_ropen((xio_constpath )name___0);
#line 242
  free((void *)realpath___0);
  }
#line 243
  return (f);
}
}
#line 249 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
static xio_constpath const   paths___0[6]  = {      (xio_constpath const   )"/usr/local/share/XaoS/catalogs/",      (xio_constpath const   )"\001/catalogs/",      (xio_constpath const   )"\001/../catalogs/",      (xio_constpath const   )"./catalogs/", 
        (xio_constpath const   )"../catalogs/",      (xio_constpath const   )"./"};
#line 247 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
xio_file xio_getcatalog(char const   *name___0 ) 
{ 
  int i ;
  xio_file f ;
  xio_pathdata tmp ;
  char *p ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 267
  f = (xio_file )((void *)0);
#line 269
  i = 0;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (i < (int )(sizeof(paths___0) / sizeof(char *))) {
#line 269
      if (! ((unsigned long )f == (unsigned long )((void *)0))) {
#line 269
        goto while_break;
      }
    } else {
#line 269
      goto while_break;
    }
    {
#line 272
    tmp___0 = xio_fixpath((char const   *)paths___0[i]);
#line 272
    p = tmp___0;
#line 273
    strcpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)p);
#line 273
    tmp___1 = strlen((char const   *)p);
    }
#line 273
    if (tmp___1) {
      {
#line 273
      tmp___2 = strlen((char const   *)(tmp));
      }
#line 273
      if ((int )tmp[tmp___2 - 1UL] != 47) {
        {
#line 273
        strcat((char */* __restrict  */)(tmp), (char const   */* __restrict  */)"/");
        }
      }
    }
    {
#line 273
    strcat((char */* __restrict  */)(tmp), (char const   */* __restrict  */)name___0);
#line 274
    free((void *)p);
#line 275
    f = xio_ropen((xio_constpath )(tmp));
    }
#line 276
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 277
      strcat((char */* __restrict  */)(tmp), (char const   */* __restrict  */)".cat");
#line 278
      f = xio_ropen((xio_constpath )(tmp));
      }
    }
#line 269
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  return (f);
}
}
#line 286 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
static xio_constpath const   paths___1[6]  = {      (xio_constpath const   )"/usr/local/share/XaoS/help/xaos.hlp",      (xio_constpath const   )"\001/help/xaos.hlp",      (xio_constpath const   )"\001/../help/xaos.hlp",      (xio_constpath const   )"./help/xaos.hlp", 
        (xio_constpath const   )"../help/xaos.hlp",      (xio_constpath const   )"./xaos.hlp"};
#line 284 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
xio_file xio_gethelp(void) 
{ 
  int i ;
  xio_file f ;
  char *p ;
  char *tmp ;

  {
#line 307
  f = (xio_file )((void *)0);
#line 308
  i = 0;
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (i < (int )(sizeof(paths___1) / sizeof(char *))) {
#line 308
      if (! ((unsigned long )f == (unsigned long )((void *)0))) {
#line 308
        goto while_break;
      }
    } else {
#line 308
      goto while_break;
    }
    {
#line 311
    tmp = xio_fixpath((char const   *)paths___1[i]);
#line 311
    p = tmp;
#line 312
    f = xio_ropen((xio_constpath )p);
#line 313
    free((void *)p);
#line 308
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  return (f);
}
}
#line 322 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
static xio_constpath const   paths___2[6]  = {      (xio_constpath const   )"/usr/local/share/XaoS/tutorial/",      (xio_constpath const   )"\001/tutorial/",      (xio_constpath const   )"\001/../tutorial/",      (xio_constpath const   )"./tutorial/", 
        (xio_constpath const   )"../tutorial/",      (xio_constpath const   )"./"};
#line 318 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
xio_file xio_gettutorial(char const   *name___0 , xio_path tmp ) 
{ 
  int i ;
  xio_file f ;
  char *p ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 321
  f = (xio_file )((void *)0);
#line 336
  i = 0;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (i < (int )(sizeof(paths___2) / sizeof(char *))) {
#line 336
      if (! ((unsigned long )f == (unsigned long )((void *)0))) {
#line 336
        goto while_break;
      }
    } else {
#line 336
      goto while_break;
    }
    {
#line 339
    tmp___0 = xio_fixpath((char const   *)paths___2[i]);
#line 339
    p = tmp___0;
#line 340
    strcpy((char */* __restrict  */)tmp, (char const   */* __restrict  */)p);
#line 340
    tmp___1 = strlen((char const   *)p);
    }
#line 340
    if (tmp___1) {
      {
#line 340
      tmp___2 = strlen((char const   *)tmp);
      }
#line 340
      if ((int )*(tmp + (tmp___2 - 1UL)) != 47) {
        {
#line 340
        strcat((char */* __restrict  */)tmp, (char const   */* __restrict  */)"/");
        }
      }
    }
    {
#line 340
    strcat((char */* __restrict  */)tmp, (char const   */* __restrict  */)name___0);
#line 341
    f = xio_ropen((xio_constpath )tmp);
#line 342
    free((void *)p);
#line 336
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 344
  return (f);
}
}
#line 347 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
int xio_exist(xio_constpath name___0 ) 
{ 
  struct stat buf ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 353
  tmp = stat((char const   */* __restrict  */)name___0, (struct stat */* __restrict  */)(& buf));
  }
#line 353
  if (tmp) {
#line 353
    tmp___0 = 0;
  } else {
#line 353
    tmp___0 = 1;
  }
#line 353
  return (tmp___0);
}
}
#line 357 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
static int sputc(int c , xio_file f ) 
{ 
  int tmp ;

  {
  {
#line 359
  tmp = _IO_putc(c, (FILE *)f->data);
  }
#line 359
  return (tmp);
}
}
#line 362 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
static int sputs(char const   *c , xio_file f ) 
{ 
  int tmp ;

  {
  {
#line 364
  tmp = fputs((char const   */* __restrict  */)c, (FILE */* __restrict  */)((FILE *)f->data));
  }
#line 364
  return (tmp);
}
}
#line 367 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
static int sungetc(int c , xio_file f ) 
{ 
  int tmp ;

  {
  {
#line 369
  tmp = ungetc(c, (FILE *)f->data);
  }
#line 369
  return (tmp);
}
}
#line 372 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
static int sgetc(xio_file f ) 
{ 
  int tmp ;

  {
  {
#line 374
  tmp = _IO_getc((FILE *)f->data);
  }
#line 374
  return (tmp);
}
}
#line 377 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
static int sfeof(xio_file f ) 
{ 
  int tmp ;

  {
  {
#line 379
  tmp = feof((FILE *)f->data);
  }
#line 379
  return (tmp);
}
}
#line 382 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
static int sflush(xio_file f ) 
{ 
  int tmp ;

  {
  {
#line 384
  tmp = fflush((FILE *)f->data);
  }
#line 384
  return (tmp);
}
}
#line 387 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
static int ssclose(xio_file f ) 
{ 
  int r ;
  int tmp ;

  {
  {
#line 389
  tmp = fclose((FILE *)f->data);
#line 389
  r = tmp;
#line 390
  free((void *)f);
  }
#line 391
  return (r);
}
}
#line 394 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
xio_file xio_ropen(char const   *name___0 ) 
{ 
  xio_file f ;
  void *tmp ;
  char *tmp___0 ;
  FILE *tmp___1 ;

  {
  {
#line 396
  tmp = calloc((size_t )1, sizeof(*f));
#line 396
  f = (xio_file )tmp;
#line 397
  tmp___0 = xio_fixpath(name___0);
#line 397
  name___0 = (char const   *)tmp___0;
#line 398
  tmp___1 = fopen((char const   */* __restrict  */)name___0, (char const   */* __restrict  */)"rt");
#line 398
  f->data = (void *)tmp___1;
  }
#line 400
  if (! f->data) {
    {
#line 401
    free((void *)f);
    }
#line 402
    return ((xio_file )0);
  }
#line 404
  f->fclose = & ssclose;
#line 405
  f->xeof = & sfeof;
#line 406
  f->fgetc = & sgetc;
#line 407
  f->fungetc = & sungetc;
#line 408
  return (f);
}
}
#line 411 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
xio_file xio_wopen(char const   *name___0 ) 
{ 
  xio_file f ;
  void *tmp ;
  char *tmp___0 ;
  FILE *tmp___1 ;

  {
  {
#line 413
  tmp = calloc((size_t )1, sizeof(*f));
#line 413
  f = (xio_file )tmp;
#line 414
  tmp___0 = xio_fixpath(name___0);
#line 414
  name___0 = (char const   *)tmp___0;
#line 415
  tmp___1 = fopen((char const   */* __restrict  */)name___0, (char const   */* __restrict  */)"wt");
#line 415
  f->data = (void *)tmp___1;
  }
#line 417
  if (! f->data) {
    {
#line 418
    free((void *)f);
    }
#line 419
    return ((xio_file )0);
  }
#line 421
  f->fputc = & sputc;
#line 422
  f->fputs = & sputs;
#line 423
  f->fclose = & ssclose;
#line 424
  f->flush = & sflush;
#line 425
  return (f);
}
}
#line 434 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
void xio_init(char const   *name___0 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *c ;
  char *tmp___1 ;
  int i ;
  int pos ;
  size_t tmp___2 ;
  char buf[4096] ;
  char *c___0 ;
  char *tmp___3 ;
  char *c1 ;
  int i___0 ;
  int pos___0 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 436
  tmp___0 = getenv("HOME");
  }
#line 436
  if (tmp___0) {
    {
#line 437
    tmp = getenv("HOME");
#line 437
    xio_homedir = mystrdup((char const   *)tmp);
    }
  } else {
    {
#line 439
    xio_homedir = mystrdup("./");
    }
  }
#line 440
  if ((int const   )*(name___0 + 0) == 47) {
#line 440
    goto _L;
  } else
#line 440
  if ((int const   )*(name___0 + 0) == 92) {
#line 440
    goto _L;
  } else
#line 440
  if ((int const   )*(name___0 + 0) == 47) {
#line 440
    goto _L;
  } else
#line 440
  if ((int const   )*(name___0 + 0) == 126) {
    _L: /* CIL Label */ 
    {
#line 448
    tmp___1 = mystrdup(name___0);
#line 448
    c = tmp___1;
#line 450
    pos = 0;
#line 451
    i = 0;
    }
    {
#line 451
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 451
      tmp___2 = strlen((char const   *)c);
      }
#line 451
      if (! (i < (int )tmp___2)) {
#line 451
        goto while_break;
      }
#line 452
      if ((int const   )*(name___0 + i) == 47) {
#line 454
        pos = i;
      } else
#line 452
      if ((int const   )*(name___0 + i) == 92) {
#line 454
        pos = i;
      } else
#line 452
      if ((int const   )*(name___0 + i) == 47) {
#line 454
        pos = i;
      }
#line 451
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 455
    *(c + pos) = (char)0;
#line 456
    xio_appdir = xio_fixpath((char const   *)c);
#line 457
    free((void *)c);
    }
  } else {
    {
#line 460
    buf[0] = (char )'.';
#line 461
    buf[1] = (char)0;
#line 463
    getcwd(buf, sizeof(buf));
#line 465
    xio_appdir = mystrdup((char const   *)(buf));
#line 467
    tmp___3 = mystrdup(name___0);
#line 467
    c___0 = tmp___3;
#line 469
    pos___0 = 0;
#line 470
    i___0 = 0;
    }
    {
#line 470
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 470
      tmp___4 = strlen((char const   *)c___0);
      }
#line 470
      if (! (i___0 < (int )tmp___4)) {
#line 470
        goto while_break___0;
      }
#line 471
      if ((int const   )*(name___0 + i___0) == 47) {
#line 473
        pos___0 = i___0;
      } else
#line 471
      if ((int const   )*(name___0 + i___0) == 92) {
#line 473
        pos___0 = i___0;
      } else
#line 471
      if ((int const   )*(name___0 + i___0) == 47) {
#line 473
        pos___0 = i___0;
      }
#line 470
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 474
    *(c___0 + pos___0) = (char)0;
#line 475
    tmp___5 = strlen((char const   *)c___0);
#line 475
    tmp___6 = strlen((char const   *)xio_appdir);
#line 475
    tmp___7 = malloc((tmp___5 + tmp___6) + 2UL);
#line 475
    c1 = (char *)tmp___7;
#line 476
    sprintf((char */* __restrict  */)c1, (char const   */* __restrict  */)"%s%s%s",
            xio_appdir, "/", c___0);
#line 477
    free((void *)c___0);
#line 478
    free((void *)xio_appdir);
#line 479
    xio_appdir = c1;
    }
  }
#line 482
  return;
}
}
#line 484 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/util/xstdio.c"
void xio_uninit(void) 
{ 


  {
  {
#line 486
  free((void *)xio_appdir);
#line 487
  free((void *)xio_homedir);
  }
#line 488
  return;
}
}
#line 282 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/filter.h"
extern int mkpalette(struct palette *palette , int seed , int algorithm ) ;
#line 283
extern int shiftpalette(struct palette *palette , int n ) ;
#line 54 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/formulas.h"
extern char const   * const  incolorname[] ;
#line 55
extern struct formula  const  formulas[] ;
#line 56
extern char const   * const  outcolorname[] ;
#line 57
extern char const   * const  tcolorname[] ;
#line 58
extern int const   nformulas ;
#line 59
extern int const   nmformulas ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 347 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui_helper.h"
struct filteraction  const  * const  uih_filters[20] ;
#line 348
int const   uih_nfilters ;
#line 366
void uih_mkdefaultpalette(uih_context *c ) ;
#line 367
void uih_mkpalette(uih_context *c ) ;
#line 373
void uih_autopilot_on(uih_context *c ) ;
#line 374
void uih_autopilot_off(uih_context *c ) ;
#line 384
void uih_interrupt(uih_context *c ) ;
#line 386
void uih_setspeedup(uih_context *c , number_t p ) ;
#line 387
void uih_setmaxstep(uih_context *c , number_t p ) ;
#line 390
void uih_recalculate(struct uih_context *c ) ;
#line 391
void uih_initstate(struct uih_context *uih___2 ) ;
#line 397
void uih_cycling_off(struct uih_context *c ) ;
#line 400
void uih_setcycling(struct uih_context *c , int speed ) ;
#line 401
int uih_cycling_on(struct uih_context *c ) ;
#line 405
void uih_setformula(uih_context *c , int num ) ;
#line 406
void uih_setperbutation(uih_context *c , number_t zre , number_t zim ) ;
#line 408
void uih_setmaxiter(uih_context *c , int maxiter___0 ) ;
#line 409
void uih_setbailout(uih_context *c , number_t bailout ) ;
#line 410
void uih_setincoloringmode(uih_context *c , int mode ) ;
#line 411
void uih_setoutcoloringmode(uih_context *c , int mode ) ;
#line 412
void uih_setintcolor(uih_context *c , int mode ) ;
#line 413
void uih_setouttcolor(uih_context *c , int mode ) ;
#line 414
void uih_setplane(uih_context *c , int mode ) ;
#line 417
void uih_setfastmode(uih_context *c , int mode ) ;
#line 418
void uih_setguessing(uih_context *c , int range ) ;
#line 419
void uih_setperiodicity(uih_context *c , int periodicity ) ;
#line 420
void uih_display(struct uih_context *c ) ;
#line 421
void uih_disablejulia(uih_context *c ) ;
#line 422
int uih_enablejulia(uih_context *c ) ;
#line 424
void uih_setjuliaseed(uih_context *c , number_t zre , number_t zim ) ;
#line 427
int uih_enablefilter(uih_context *c , int n ) ;
#line 428
void uih_disablefilter(uih_context *c , int n ) ;
#line 438
void uih_playstr(struct uih_context *c , char const   *data ) ;
#line 440
void uih_replaydisable(struct uih_context *uih___2 ) ;
#line 444
void uih_command(struct uih_context *uih___2 , char const   *command ) ;
#line 445
void uih_playtutorial(struct uih_context *c , char const   *name___0 ) ;
#line 448
void uih_loadfile(struct uih_context *c , xio_constpath d ) ;
#line 449
void uih_playfile(struct uih_context *c , xio_constpath d ) ;
#line 450
void uih_loadexample(struct uih_context *c ) ;
#line 451
void uih_savepngfile(struct uih_context *c , xio_constpath d ) ;
#line 452
void uih_saveposfile(struct uih_context *c , xio_constpath d ) ;
#line 454
void uih_savecfg(struct uih_context *c ) ;
#line 455
void uih_saveanimfile(struct uih_context *c , xio_constpath d ) ;
#line 465
void uih_clearscreen(uih_context *c ) ;
#line 466
void uih_settextpos(uih_context *c , int x , int y ) ;
#line 467
void uih_text(uih_context *c , char const   *text ) ;
#line 468
void uih_letterspersec(uih_context *c , int n ) ;
#line 471
int uih_fastrotate(uih_context *c , int mode ) ;
#line 474
void uih_angle(uih_context *c , number_t angle ) ;
#line 476
void uih_rotate(struct uih_context *c , int n ) ;
#line 477
void uih_rotationspeed(uih_context *c , number_t speed ) ;
#line 483
void uih_registermenus(void) ;
#line 484
void uih_registermenus_i18n(void) ;
#line 485
void uih_registermenudialogs_i18n(void) ;
#line 486
void uih_unregistermenus(void) ;
#line 507
int uih_message(uih_context *c , char const   *message ) ;
#line 508
int uih_error(uih_context *c , char const   *error___1 ) ;
#line 519
void uih_undo(struct uih_context *c ) ;
#line 520
void uih_redo(struct uih_context *c ) ;
#line 525
int uih_renderanimation(struct uih_context *gc1 , char const   *basename , xio_constpath const   animation ,
                        int width , int height , float pixelwidth , float pixelheight ,
                        int frametime , int type , int antialias , int slowmode___0 ,
                        int letterspersec___0 , char const   *catalog___0 , int motionvectors ,
                        int iframedist2 ) ;
#line 541
void uih_inhibittextsw(uih_context *c ) ;
#line 542
int uih_inhibittextselected(uih_context *c ) ;
#line 49 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/plane.h"
extern char const   * const  planename[] ;
#line 333 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xmenu.h"
extern void menu_add(menuitem const   *item , int n ) ;
#line 336
extern menuitem const   *menu_findcommand(char const   *name ) ;
#line 337
extern char const   *menu_fullname(char const   *menu ) ;
#line 338
extern menuitem const   *menu_item(char const   *menu , int n ) ;
#line 339
extern void menu_delete(menuitem const   *items , int n ) ;
#line 340
extern int menu_enabled(menuitem const   *item , struct uih_context *c ) ;
#line 343
extern menuitem const   *menu_genernumbered(int n , char const   *menuname , char const   * const  * const  names ,
                                            char const   *keys , int type , int flags ,
                                            void (*fint)(struct uih_context *context ,
                                                         int  ) , int (*cint)(struct uih_context *context ,
                                                                              int  ) ,
                                            char const   *prefix ) ;
#line 352
extern void menu_delnumbered(int n , char const   *name ) ;
#line 368
extern void uih_xshlprintmenu(struct uih_context *c , char const   *name ) ;
#line 369
extern void uih_xshlprintmenus(struct uih_context *c ) ;
#line 18 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.h"
char const   * const  save_fastmode[6] ;
#line 19
char const   * const  uih_colornames[4] ;
#line 20
void uih_play_formula(struct uih_context *uih___2 , char *fname ) ;
#line 21
void uih_playfilter(struct uih_context *uih___2 , dialogparam *p ) ;
#line 22
void uih_zoomcenter(struct uih_context *uih___2 , number_t x , number_t y ) ;
#line 24
void uih_playdefpalette(struct uih_context *uih___2 , int shift ) ;
#line 25
void uih_playusleep(struct uih_context *uih___2 , int time___0 ) ;
#line 26
void uih_playtextsleep(struct uih_context *uih___2 ) ;
#line 27
void uih_playwait(struct uih_context *uih___2 ) ;
#line 28
void uih_playjulia(struct uih_context *uih___2 , int julia ) ;
#line 29
void uih_playzoom(struct uih_context *uih___2 ) ;
#line 30
void uih_playunzoom(struct uih_context *uih___2 ) ;
#line 31
void uih_playstop(struct uih_context *uih___2 ) ;
#line 32
void uih_playmorph(struct uih_context *uih___2 , dialogparam *d ) ;
#line 33
void uih_playmove(struct uih_context *uih___2 , number_t x , number_t y ) ;
#line 34
void uih_playtextpos(struct uih_context *uih___2 , dialogparam *p ) ;
#line 36
void uih_playmorphjulia(struct uih_context *uih___2 , number_t x , number_t y ) ;
#line 37
void uih_playmorphangle(struct uih_context *uih___2 , number_t angle ) ;
#line 38
void uih_playautorotate(struct uih_context *uih___2 , int mode ) ;
#line 39
void uih_playmessage(struct uih_context *uih___2 , char *name___0 ) ;
#line 40
void uih_playload(struct uih_context *uih___2 , char *file ) ;
#line 43
void uih_line(uih_context *c , dialogparam *d ) ;
#line 44
void uih_morphline(uih_context *c , dialogparam *d ) ;
#line 45
void uih_morphlastline(uih_context *c , dialogparam *d ) ;
#line 46
void uih_setkey(uih_context *c , int line ) ;
#line 47
void uih_clear_line(uih_context *c ) ;
#line 48
void uih_clear_lines(uih_context *c ) ;
#line 29 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static char const   * const  morphstypes[4]  = {      (char const   */* const  */)"view",      (char const   */* const  */)"julia",      (char const   */* const  */)"angle",      (char const   */* const  */)"line"};
#line 36 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static char const   * const  imgtypes[3]  = {      (char const   */* const  */)"Truecolor",      (char const   */* const  */)"256 colors",      (char const   */* const  */)((void *)0)};
#line 42 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static char const   * const  yesno[3]  = {      (char const   */* const  */)"No",      (char const   */* const  */)"Yes",      (char const   */* const  */)((void *)0)};
#line 48 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static char const   * const  lineposs[4]  = {      (char const   */* const  */)"screen",      (char const   */* const  */)"scaled",      (char const   */* const  */)"fractal",      (char const   */* const  */)((void *)0)};
#line 55 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
char const   * const  uih_colornames[4]  = {      (char const   */* const  */)"white",      (char const   */* const  */)"black",      (char const   */* const  */)"red",      (char const   */* const  */)((void *)0)};
#line 87 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog menudialogs_i18n[100]  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_perturbationdialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_juliadialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_smoothmorphdialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_renderdialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_viewdialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_linedialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_colordialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_rotationdialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_lettersdialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_iterdialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *dtextparam  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *dcommand  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *loaddialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *playdialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *saveimgdialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *saveposdialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_formuladialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_plviewdialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_coorddialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_angledialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_autorotatedialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_fastrotatedialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_filterdialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_shiftdialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_speeddialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *printdialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_bailoutdialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *saveanimdialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_juliamodedialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_textposdialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_fastmodedialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_timedialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_numdialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_fpdialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *palettedialog  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_cyclingdialog  ;
#line 106
char const   * const  xtextposnames[4] ;
#line 107
char const   * const  ytextposnames[4] ;
#line 110 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
void uih_registermenudialogs_i18n(void) 
{ 
  int no_menudialogs_i18n ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;

  {
  {
#line 112
  no_menudialogs_i18n = 0;
#line 128
  uih_perturbationdialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 129
  tmp = gettext("Perturbation:");
#line 129
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp;
#line 129
  menudialogs_i18n[no_menudialogs_i18n].type = 9;
#line 129
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 129
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 129
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 129
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 129
  no_menudialogs_i18n ++;
#line 130
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 130
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 130
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 130
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 130
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 130
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 130
  no_menudialogs_i18n ++;
#line 132
  uih_juliadialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 133
  tmp___0 = gettext("Julia-seed:");
#line 133
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___0;
#line 133
  menudialogs_i18n[no_menudialogs_i18n].type = 9;
#line 133
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 133
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 133
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 133
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 133
  no_menudialogs_i18n ++;
#line 134
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 134
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 134
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 134
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 134
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 134
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 134
  no_menudialogs_i18n ++;
#line 136
  uih_smoothmorphdialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 137
  tmp___1 = gettext("Morphing type:");
#line 137
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___1;
#line 137
  menudialogs_i18n[no_menudialogs_i18n].type = 7;
#line 137
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 137
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)(morphstypes);
#line 137
  no_menudialogs_i18n ++;
#line 138
  tmp___2 = gettext("Startuptime:");
#line 138
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___2;
#line 138
  menudialogs_i18n[no_menudialogs_i18n].type = 1;
#line 138
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 138
  no_menudialogs_i18n ++;
#line 139
  tmp___3 = gettext("Stoptime:");
#line 139
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___3;
#line 139
  menudialogs_i18n[no_menudialogs_i18n].type = 1;
#line 139
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 139
  no_menudialogs_i18n ++;
#line 140
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 140
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 140
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 140
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 140
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 140
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 140
  no_menudialogs_i18n ++;
#line 142
  uih_renderdialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 143
  tmp___4 = gettext("File to render:");
#line 143
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___4;
#line 143
  menudialogs_i18n[no_menudialogs_i18n].type = 5;
#line 143
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 143
  menudialogs_i18n[no_menudialogs_i18n].defstr = "fract*.xaf";
#line 143
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 143
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 143
  no_menudialogs_i18n ++;
#line 144
  tmp___5 = gettext("Basename:");
#line 144
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___5;
#line 144
  menudialogs_i18n[no_menudialogs_i18n].type = 6;
#line 144
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 144
  menudialogs_i18n[no_menudialogs_i18n].defstr = "anim";
#line 144
  no_menudialogs_i18n ++;
#line 145
  tmp___6 = gettext("Width:");
#line 145
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___6;
#line 145
  menudialogs_i18n[no_menudialogs_i18n].type = 1;
#line 145
  menudialogs_i18n[no_menudialogs_i18n].defint = 640;
#line 145
  no_menudialogs_i18n ++;
#line 146
  tmp___7 = gettext("Height:");
#line 146
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___7;
#line 146
  menudialogs_i18n[no_menudialogs_i18n].type = 1;
#line 146
  menudialogs_i18n[no_menudialogs_i18n].defint = 480;
#line 146
  no_menudialogs_i18n ++;
#line 147
  tmp___8 = gettext("Real width (cm):");
#line 147
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___8;
#line 147
  menudialogs_i18n[no_menudialogs_i18n].type = 2;
#line 147
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 147
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 147
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )29.0;
#line 147
  no_menudialogs_i18n ++;
#line 148
  tmp___9 = gettext("Real height (cm):");
#line 148
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___9;
#line 148
  menudialogs_i18n[no_menudialogs_i18n].type = 2;
#line 148
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 148
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 148
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )21.0;
#line 148
  no_menudialogs_i18n ++;
#line 149
  tmp___10 = gettext("Framerate:");
#line 149
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___10;
#line 149
  menudialogs_i18n[no_menudialogs_i18n].type = 2;
#line 149
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 149
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 149
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )30;
#line 149
  no_menudialogs_i18n ++;
#line 150
  tmp___11 = gettext("Image type:");
#line 150
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___11;
#line 150
  menudialogs_i18n[no_menudialogs_i18n].type = 7;
#line 150
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 150
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)(imgtypes);
#line 150
  no_menudialogs_i18n ++;
#line 151
  tmp___12 = gettext("Antialiasing:");
#line 151
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___12;
#line 151
  menudialogs_i18n[no_menudialogs_i18n].type = 7;
#line 151
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 151
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)(yesno);
#line 151
  no_menudialogs_i18n ++;
#line 152
  tmp___13 = gettext("Always recalculate:");
#line 152
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___13;
#line 152
  menudialogs_i18n[no_menudialogs_i18n].type = 7;
#line 152
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 152
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)(yesno);
#line 152
  no_menudialogs_i18n ++;
#line 153
  tmp___14 = gettext("Calculate MPEG motion vectors:");
#line 153
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___14;
#line 153
  menudialogs_i18n[no_menudialogs_i18n].type = 7;
#line 153
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 153
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)(yesno);
#line 153
  no_menudialogs_i18n ++;
#line 154
  tmp___15 = gettext("Recommended I frame distance:");
#line 154
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___15;
#line 154
  menudialogs_i18n[no_menudialogs_i18n].type = 1;
#line 154
  menudialogs_i18n[no_menudialogs_i18n].defint = 27;
#line 154
  no_menudialogs_i18n ++;
#line 155
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 155
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 155
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 155
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 155
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 155
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 155
  no_menudialogs_i18n ++;
#line 157
  uih_viewdialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 158
  tmp___16 = gettext("Center:");
#line 158
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___16;
#line 158
  menudialogs_i18n[no_menudialogs_i18n].type = 9;
#line 158
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 158
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 158
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 158
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 158
  no_menudialogs_i18n ++;
#line 159
  tmp___17 = gettext("Radius:");
#line 159
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___17;
#line 159
  menudialogs_i18n[no_menudialogs_i18n].type = 2;
#line 159
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 159
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 159
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )1;
#line 159
  no_menudialogs_i18n ++;
#line 160
  tmp___18 = gettext("Angle:");
#line 160
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___18;
#line 160
  menudialogs_i18n[no_menudialogs_i18n].type = 2;
#line 160
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 160
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 160
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 160
  no_menudialogs_i18n ++;
#line 161
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 161
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 161
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 161
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 161
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 161
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 161
  no_menudialogs_i18n ++;
#line 163
  uih_linedialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 164
  tmp___19 = gettext("Mode:");
#line 164
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___19;
#line 164
  menudialogs_i18n[no_menudialogs_i18n].type = 7;
#line 164
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 164
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)(lineposs);
#line 164
  no_menudialogs_i18n ++;
#line 165
  tmp___20 = gettext("Start:");
#line 165
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___20;
#line 165
  menudialogs_i18n[no_menudialogs_i18n].type = 9;
#line 165
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 165
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 165
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 165
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 165
  no_menudialogs_i18n ++;
#line 166
  tmp___21 = gettext("End:");
#line 166
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___21;
#line 166
  menudialogs_i18n[no_menudialogs_i18n].type = 9;
#line 166
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 166
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 166
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 166
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 166
  no_menudialogs_i18n ++;
#line 167
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 167
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 167
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 167
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 167
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 167
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 167
  no_menudialogs_i18n ++;
#line 169
  uih_colordialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 170
  tmp___22 = gettext("Color:");
#line 170
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___22;
#line 170
  menudialogs_i18n[no_menudialogs_i18n].type = 7;
#line 170
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 170
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)(uih_colornames);
#line 170
  no_menudialogs_i18n ++;
#line 171
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 171
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 171
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 171
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 171
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 171
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 171
  no_menudialogs_i18n ++;
#line 173
  uih_rotationdialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 174
  tmp___23 = gettext("Rotations per second:");
#line 174
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___23;
#line 174
  menudialogs_i18n[no_menudialogs_i18n].type = 2;
#line 174
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 174
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 174
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 174
  no_menudialogs_i18n ++;
#line 175
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 175
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 175
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 175
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 175
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 175
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 175
  no_menudialogs_i18n ++;
#line 177
  uih_lettersdialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 178
  tmp___24 = gettext("Letters per second:");
#line 178
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___24;
#line 178
  menudialogs_i18n[no_menudialogs_i18n].type = 1;
#line 178
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 178
  no_menudialogs_i18n ++;
#line 179
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 179
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 179
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 179
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 179
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 179
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 179
  no_menudialogs_i18n ++;
#line 181
  uih_iterdialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 182
  tmp___25 = gettext("Iterations:");
#line 182
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___25;
#line 182
  menudialogs_i18n[no_menudialogs_i18n].type = 1;
#line 182
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 182
  no_menudialogs_i18n ++;
#line 183
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 183
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 183
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 183
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 183
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 183
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 183
  no_menudialogs_i18n ++;
#line 185
  dtextparam = & menudialogs_i18n[no_menudialogs_i18n];
#line 186
  tmp___26 = gettext("Text:");
#line 186
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___26;
#line 186
  menudialogs_i18n[no_menudialogs_i18n].type = 3;
#line 186
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 186
  menudialogs_i18n[no_menudialogs_i18n].defstr = "";
#line 186
  no_menudialogs_i18n ++;
#line 187
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 187
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 187
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 187
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 187
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 187
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 187
  no_menudialogs_i18n ++;
#line 189
  dcommand = & menudialogs_i18n[no_menudialogs_i18n];
#line 190
  tmp___27 = gettext("Your command:");
#line 190
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___27;
#line 190
  menudialogs_i18n[no_menudialogs_i18n].type = 3;
#line 190
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 190
  menudialogs_i18n[no_menudialogs_i18n].defstr = "";
#line 190
  no_menudialogs_i18n ++;
#line 191
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 191
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 191
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 191
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 191
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 191
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 191
  no_menudialogs_i18n ++;
#line 193
  loaddialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 194
  tmp___28 = gettext("Filename:");
#line 194
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___28;
#line 194
  menudialogs_i18n[no_menudialogs_i18n].type = 5;
#line 194
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 194
  menudialogs_i18n[no_menudialogs_i18n].defstr = "fract*.xpf";
#line 194
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 194
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 194
  no_menudialogs_i18n ++;
#line 195
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 195
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 195
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 195
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 195
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 195
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 195
  no_menudialogs_i18n ++;
#line 197
  playdialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 198
  tmp___29 = gettext("Filename:");
#line 198
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___29;
#line 198
  menudialogs_i18n[no_menudialogs_i18n].type = 5;
#line 198
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 198
  menudialogs_i18n[no_menudialogs_i18n].defstr = "anim*.xaf";
#line 198
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 198
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 198
  no_menudialogs_i18n ++;
#line 199
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 199
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 199
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 199
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 199
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 199
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 199
  no_menudialogs_i18n ++;
#line 201
  saveimgdialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 202
  tmp___30 = gettext("Filename:");
#line 202
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___30;
#line 202
  menudialogs_i18n[no_menudialogs_i18n].type = 6;
#line 202
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 202
  menudialogs_i18n[no_menudialogs_i18n].defstr = "fract*.png";
#line 202
  no_menudialogs_i18n ++;
#line 203
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 203
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 203
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 203
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 203
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 203
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 203
  no_menudialogs_i18n ++;
#line 205
  saveposdialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 206
  tmp___31 = gettext("Filename:");
#line 206
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___31;
#line 206
  menudialogs_i18n[no_menudialogs_i18n].type = 6;
#line 206
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 206
  menudialogs_i18n[no_menudialogs_i18n].defstr = "fract*.xpf";
#line 206
  no_menudialogs_i18n ++;
#line 207
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 207
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 207
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 207
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 207
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 207
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 207
  no_menudialogs_i18n ++;
#line 209
  uih_formuladialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 210
  tmp___32 = gettext("Formula:");
#line 210
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___32;
#line 210
  menudialogs_i18n[no_menudialogs_i18n].type = 4;
#line 210
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 210
  menudialogs_i18n[no_menudialogs_i18n].defstr = "mandel";
#line 210
  no_menudialogs_i18n ++;
#line 211
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 211
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 211
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 211
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 211
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 211
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 211
  no_menudialogs_i18n ++;
#line 213
  uih_plviewdialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 214
  tmp___33 = gettext("X center:");
#line 214
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___33;
#line 214
  menudialogs_i18n[no_menudialogs_i18n].type = 2;
#line 214
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 214
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 214
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 214
  no_menudialogs_i18n ++;
#line 215
  tmp___34 = gettext("Y center:");
#line 215
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___34;
#line 215
  menudialogs_i18n[no_menudialogs_i18n].type = 2;
#line 215
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 215
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 215
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 215
  no_menudialogs_i18n ++;
#line 216
  tmp___35 = gettext("X Radius:");
#line 216
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___35;
#line 216
  menudialogs_i18n[no_menudialogs_i18n].type = 2;
#line 216
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 216
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 216
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )1;
#line 216
  no_menudialogs_i18n ++;
#line 217
  tmp___36 = gettext("Y Radius:");
#line 217
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___36;
#line 217
  menudialogs_i18n[no_menudialogs_i18n].type = 2;
#line 217
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 217
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 217
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )1;
#line 217
  no_menudialogs_i18n ++;
#line 218
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 218
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 218
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 218
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 218
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 218
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 218
  no_menudialogs_i18n ++;
#line 220
  uih_coorddialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 221
  tmp___37 = gettext("Coordinates:");
#line 221
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___37;
#line 221
  menudialogs_i18n[no_menudialogs_i18n].type = 9;
#line 221
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 221
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 221
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 221
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 221
  no_menudialogs_i18n ++;
#line 222
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 222
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 222
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 222
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 222
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 222
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 222
  no_menudialogs_i18n ++;
#line 224
  uih_angledialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 225
  tmp___38 = gettext("Angle:");
#line 225
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___38;
#line 225
  menudialogs_i18n[no_menudialogs_i18n].type = 2;
#line 225
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 225
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 225
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )1;
#line 225
  no_menudialogs_i18n ++;
#line 226
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 226
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 226
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 226
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 226
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 226
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 226
  no_menudialogs_i18n ++;
#line 228
  uih_autorotatedialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 229
  tmp___39 = gettext("continuous rotation");
#line 229
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___39;
#line 229
  menudialogs_i18n[no_menudialogs_i18n].type = 8;
#line 229
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 229
  no_menudialogs_i18n ++;
#line 230
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 230
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 230
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 230
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 230
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 230
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 230
  no_menudialogs_i18n ++;
#line 232
  uih_fastrotatedialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 233
  tmp___40 = gettext("Fast rotation");
#line 233
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___40;
#line 233
  menudialogs_i18n[no_menudialogs_i18n].type = 8;
#line 233
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 233
  no_menudialogs_i18n ++;
#line 234
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 234
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 234
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 234
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 234
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 234
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 234
  no_menudialogs_i18n ++;
#line 236
  uih_filterdialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 237
  tmp___41 = gettext("filter");
#line 237
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___41;
#line 237
  menudialogs_i18n[no_menudialogs_i18n].type = 4;
#line 237
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 237
  menudialogs_i18n[no_menudialogs_i18n].defstr = "";
#line 237
  no_menudialogs_i18n ++;
#line 238
  tmp___42 = gettext("enable");
#line 238
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___42;
#line 238
  menudialogs_i18n[no_menudialogs_i18n].type = 8;
#line 238
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 238
  no_menudialogs_i18n ++;
#line 239
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 239
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 239
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 239
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 239
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 239
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 239
  no_menudialogs_i18n ++;
#line 241
  uih_shiftdialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 242
  tmp___43 = gettext("Amount:");
#line 242
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___43;
#line 242
  menudialogs_i18n[no_menudialogs_i18n].type = 1;
#line 242
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 242
  no_menudialogs_i18n ++;
#line 243
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 243
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 243
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 243
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 243
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 243
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 243
  no_menudialogs_i18n ++;
#line 245
  uih_speeddialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 246
  tmp___44 = gettext("Zooming speed:");
#line 246
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___44;
#line 246
  menudialogs_i18n[no_menudialogs_i18n].type = 2;
#line 246
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 246
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 246
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 246
  no_menudialogs_i18n ++;
#line 247
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 247
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 247
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 247
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 247
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 247
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 247
  no_menudialogs_i18n ++;
#line 249
  printdialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 250
  tmp___45 = gettext("Name:");
#line 250
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___45;
#line 250
  menudialogs_i18n[no_menudialogs_i18n].type = 3;
#line 250
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 250
  menudialogs_i18n[no_menudialogs_i18n].defstr = "";
#line 250
  no_menudialogs_i18n ++;
#line 251
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 251
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 251
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 251
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 251
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 251
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 251
  no_menudialogs_i18n ++;
#line 253
  uih_bailoutdialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 254
  tmp___46 = gettext("Bailout:");
#line 254
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___46;
#line 254
  menudialogs_i18n[no_menudialogs_i18n].type = 2;
#line 254
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 254
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 254
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 254
  no_menudialogs_i18n ++;
#line 255
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 255
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 255
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 255
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 255
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 255
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 255
  no_menudialogs_i18n ++;
#line 257
  saveanimdialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 258
  tmp___47 = gettext("Filename:");
#line 258
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___47;
#line 258
  menudialogs_i18n[no_menudialogs_i18n].type = 6;
#line 258
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 258
  menudialogs_i18n[no_menudialogs_i18n].defstr = "anim*.xaf";
#line 258
  no_menudialogs_i18n ++;
#line 259
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 259
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 259
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 259
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 259
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 259
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 259
  no_menudialogs_i18n ++;
#line 261
  uih_juliamodedialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 262
  tmp___48 = gettext("Julia mode:");
#line 262
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___48;
#line 262
  menudialogs_i18n[no_menudialogs_i18n].type = 8;
#line 262
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 262
  no_menudialogs_i18n ++;
#line 263
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 263
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 263
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 263
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 263
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 263
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 263
  no_menudialogs_i18n ++;
#line 265
  uih_textposdialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 266
  tmp___49 = gettext("Horizontal position:");
#line 266
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___49;
#line 266
  menudialogs_i18n[no_menudialogs_i18n].type = 7;
#line 266
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 266
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)(xtextposnames);
#line 266
  no_menudialogs_i18n ++;
#line 267
  tmp___50 = gettext("Vertical position:");
#line 267
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___50;
#line 267
  menudialogs_i18n[no_menudialogs_i18n].type = 7;
#line 267
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 267
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)(ytextposnames);
#line 267
  no_menudialogs_i18n ++;
#line 268
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 268
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 268
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 268
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 268
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 268
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 268
  no_menudialogs_i18n ++;
#line 270
  uih_fastmodedialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 271
  tmp___51 = gettext("Dynamic resolution:");
#line 271
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___51;
#line 271
  menudialogs_i18n[no_menudialogs_i18n].type = 7;
#line 271
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 271
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)(save_fastmode);
#line 271
  no_menudialogs_i18n ++;
#line 272
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 272
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 272
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 272
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 272
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 272
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 272
  no_menudialogs_i18n ++;
#line 274
  uih_timedialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 275
  tmp___52 = gettext("Time:");
#line 275
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___52;
#line 275
  menudialogs_i18n[no_menudialogs_i18n].type = 1;
#line 275
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 275
  no_menudialogs_i18n ++;
#line 276
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 276
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 276
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 276
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 276
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 276
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 276
  no_menudialogs_i18n ++;
#line 278
  uih_numdialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 279
  tmp___53 = gettext("Number:");
#line 279
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___53;
#line 279
  menudialogs_i18n[no_menudialogs_i18n].type = 1;
#line 279
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 279
  no_menudialogs_i18n ++;
#line 280
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 280
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 280
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 280
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 280
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 280
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 280
  no_menudialogs_i18n ++;
#line 282
  uih_fpdialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 283
  tmp___54 = gettext("Number:");
#line 283
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___54;
#line 283
  menudialogs_i18n[no_menudialogs_i18n].type = 2;
#line 283
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 283
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 283
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 283
  no_menudialogs_i18n ++;
#line 284
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 284
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 284
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 284
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 284
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 284
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 284
  no_menudialogs_i18n ++;
#line 286
  palettedialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 287
  tmp___55 = gettext("Algorithm number:");
#line 287
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___55;
#line 287
  menudialogs_i18n[no_menudialogs_i18n].type = 1;
#line 287
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 287
  no_menudialogs_i18n ++;
#line 288
  tmp___56 = gettext("Seed:");
#line 288
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___56;
#line 288
  menudialogs_i18n[no_menudialogs_i18n].type = 1;
#line 288
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 288
  no_menudialogs_i18n ++;
#line 289
  tmp___57 = gettext("Shift:");
#line 289
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___57;
#line 289
  menudialogs_i18n[no_menudialogs_i18n].type = 1;
#line 289
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 289
  no_menudialogs_i18n ++;
#line 290
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 290
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 290
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 290
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 290
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 290
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 290
  no_menudialogs_i18n ++;
#line 292
  uih_cyclingdialog = & menudialogs_i18n[no_menudialogs_i18n];
#line 293
  tmp___58 = gettext("Frames per second:");
#line 293
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)tmp___58;
#line 293
  menudialogs_i18n[no_menudialogs_i18n].type = 1;
#line 293
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 293
  no_menudialogs_i18n ++;
#line 294
  menudialogs_i18n[no_menudialogs_i18n].question = (char const   *)((void *)0);
#line 294
  menudialogs_i18n[no_menudialogs_i18n].type = 0;
#line 294
  menudialogs_i18n[no_menudialogs_i18n].defint = 0;
#line 294
  menudialogs_i18n[no_menudialogs_i18n].defstr = (char const   *)((void *)0);
#line 294
  menudialogs_i18n[no_menudialogs_i18n].deffloat = (number_t )0;
#line 294
  menudialogs_i18n[no_menudialogs_i18n].deffloat2 = (number_t )0;
#line 294
  no_menudialogs_i18n ++;
  }
#line 310
  return;
}
}
#line 323 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_smoothmorph(struct uih_context *c , dialogparam *p ) 
{ 


  {
#line 325
  if (! c->playc) {
#line 326
    return;
  }
  {
#line 328
  if ((p + 0)->dint == 0) {
#line 328
    goto case_0;
  }
#line 332
  if ((p + 0)->dint == 1) {
#line 332
    goto case_1;
  }
#line 336
  if ((p + 0)->dint == 2) {
#line 336
    goto case_2;
  }
#line 340
  if ((p + 0)->dint == 3) {
#line 340
    goto case_3;
  }
#line 327
  goto switch_break;
  case_0: /* CIL Label */ 
#line 329
  (c->playc)->morphtimes[0] = (p + 1)->dint;
#line 330
  (c->playc)->morphtimes[1] = (p + 2)->dint;
#line 331
  goto switch_break;
  case_1: /* CIL Label */ 
#line 333
  (c->playc)->morphjuliatimes[0] = (p + 1)->dint;
#line 334
  (c->playc)->morphjuliatimes[1] = (p + 2)->dint;
#line 335
  goto switch_break;
  case_2: /* CIL Label */ 
#line 337
  (c->playc)->morphangletimes[0] = (p + 1)->dint;
#line 338
  (c->playc)->morphangletimes[1] = (p + 2)->dint;
#line 339
  goto switch_break;
  case_3: /* CIL Label */ 
#line 341
  (c->playc)->morphlinetimes[0] = (p + 1)->dint;
#line 342
  (c->playc)->morphlinetimes[1] = (p + 2)->dint;
#line 343
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 345
  return;
}
}
#line 347 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_render(struct uih_context *c , dialogparam *d ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 361
  if ((d + 2)->dint <= 0) {
    {
#line 362
    tmp = gettext("renderanim: Width parameter must be positive integer in the range 0..4096");
#line 362
    uih_error(c, (char const   *)tmp);
    }
#line 365
    return;
  } else
#line 361
  if ((d + 2)->dint > 4096) {
    {
#line 362
    tmp = gettext("renderanim: Width parameter must be positive integer in the range 0..4096");
#line 362
    uih_error(c, (char const   *)tmp);
    }
#line 365
    return;
  }
#line 367
  if ((d + 3)->dint <= 0) {
    {
#line 368
    tmp___0 = gettext("renderanim: Height parameter must be positive integer in the range 0..4096");
#line 368
    uih_error(c, (char const   *)tmp___0);
    }
#line 371
    return;
  } else
#line 367
  if ((d + 3)->dint > 4096) {
    {
#line 368
    tmp___0 = gettext("renderanim: Height parameter must be positive integer in the range 0..4096");
#line 368
    uih_error(c, (char const   *)tmp___0);
    }
#line 371
    return;
  }
#line 373
  if ((d + 4)->number <= (number_t )0) {
    {
#line 374
    tmp___1 = gettext("renderanim: Invalid real width and height dimensions");
#line 374
    uih_error(c, (char const   *)tmp___1);
    }
#line 377
    return;
  } else
#line 373
  if ((d + 5)->number <= (number_t )0) {
    {
#line 374
    tmp___1 = gettext("renderanim: Invalid real width and height dimensions");
#line 374
    uih_error(c, (char const   *)tmp___1);
    }
#line 377
    return;
  }
#line 379
  if ((d + 6)->number <= (number_t )0) {
    {
#line 380
    tmp___2 = gettext("renderanim: invalid framerate");
#line 380
    uih_error(c, (char const   *)tmp___2);
    }
#line 381
    return;
  } else
#line 379
  if ((d + 6)->number >= (number_t )1000000) {
    {
#line 380
    tmp___2 = gettext("renderanim: invalid framerate");
#line 380
    uih_error(c, (char const   *)tmp___2);
    }
#line 381
    return;
  }
#line 383
  if ((d + 7)->dint) {
#line 383
    if ((d + 8)->dint) {
      {
#line 384
      tmp___3 = gettext("renderanim: antialiasing not supported in 256 color mode");
#line 384
      uih_error(c, (char const   *)tmp___3);
      }
#line 387
      return;
    }
  }
#line 389
  if ((d + 11)->dint <= 0) {
    {
#line 390
    tmp___4 = gettext("renderanim: incorrect I frame distance");
#line 390
    uih_error(c, (char const   *)tmp___4);
    }
#line 391
    return;
  } else
#line 389
  if ((d + 11)->dint >= 1000000) {
    {
#line 390
    tmp___4 = gettext("renderanim: incorrect I frame distance");
#line 390
    uih_error(c, (char const   *)tmp___4);
    }
#line 391
    return;
  }
#line 393
  if ((d + 7)->dint) {
#line 393
    tmp___5 = 1;
  } else {
#line 393
    tmp___5 = 8;
  }
  {
#line 393
  uih_renderanimation(c, (char const   *)(d + 1)->dstring, (xio_constpath const   )(d + 0)->dstring,
                      (d + 2)->dint, (d + 3)->dint, (float )((d + 4)->number / (number_t )(d + 2)->dint),
                      (float )((d + 5)->number / (number_t )(d + 3)->dint), (int )((number_t )1000000 / (d + 6)->number),
                      tmp___5, (d + 8)->dint, (d + 9)->dint, c->letterspersec, (char const   *)((void *)0),
                      (d + 10)->dint, (d + 11)->dint);
  }
#line 404
  return;
}
}
#line 406 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_getcolordialog(struct uih_context *c ) 
{ 


  {
#line 408
  if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 409
    (uih_colordialog + 0)->defint = c->color;
  }
#line 411
  return (uih_colordialog);
}
}
#line 414 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_setcolor(struct uih_context *c , int color ) 
{ 


  {
#line 416
  c->color = color;
#line 417
  return;
}
}
#line 420 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_getperturbationdialog(struct uih_context *c ) 
{ 


  {
#line 422
  if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 423
    (uih_perturbationdialog + 0)->deffloat = (c->fcontext)->bre;
#line 424
    (uih_perturbationdialog + 0)->deffloat2 = (c->fcontext)->bim;
  }
#line 426
  return (uih_perturbationdialog);
}
}
#line 429 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_getjuliadialog(struct uih_context *c ) 
{ 


  {
#line 431
  if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 432
    (uih_juliadialog + 0)->deffloat = (c->fcontext)->pre;
#line 433
    (uih_juliadialog + 0)->deffloat2 = (c->fcontext)->pim;
  }
#line 435
  return (uih_juliadialog);
}
}
#line 438 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_plview(struct uih_context *c , dialogparam *d ) 
{ 
  char *tmp ;

  {
#line 440
  if ((d + 2)->number <= (number_t )0) {
    {
#line 441
    tmp = gettext("animateview: Invalid viewpoint");
#line 441
    uih_error(c, (char const   *)tmp);
    }
#line 442
    return;
  } else
#line 440
  if ((d + 3)->number <= (number_t )0) {
    {
#line 441
    tmp = gettext("animateview: Invalid viewpoint");
#line 441
    uih_error(c, (char const   *)tmp);
    }
#line 442
    return;
  }
#line 444
  (c->fcontext)->s.cr = (d + 0)->number;
#line 445
  (c->fcontext)->s.ci = (d + 1)->number;
#line 446
  (c->fcontext)->s.rr = (d + 2)->number;
#line 447
  (c->fcontext)->s.ri = (d + 3)->number;
#line 448
  c->display = 1;
#line 448
  if (c->recalculatemode > 2) {
#line 448
    c->recalculatemode = c->recalculatemode;
  } else {
#line 448
    c->recalculatemode = 2;
  }
#line 449
  return;
}
}
#line 451 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_plview2(struct uih_context *c , dialogparam *d ) 
{ 
  char *tmp ;

  {
#line 453
  if ((d + 2)->number <= (number_t )0) {
    {
#line 454
    tmp = gettext("animateview: Invalid viewpoint");
#line 454
    uih_error(c, (char const   *)tmp);
    }
#line 455
    return;
  } else
#line 453
  if ((d + 3)->number <= (number_t )0) {
    {
#line 454
    tmp = gettext("animateview: Invalid viewpoint");
#line 454
    uih_error(c, (char const   *)tmp);
    }
#line 455
    return;
  }
#line 457
  (c->fcontext)->s.cr = (d + 0)->number;
#line 458
  (c->fcontext)->s.ci = (d + 1)->number;
#line 459
  (c->fcontext)->s.rr = (d + 2)->number;
#line 460
  (c->fcontext)->s.ri = (d + 3)->number;
#line 461
  c->display = 1;
#line 461
  if (c->recalculatemode > 1) {
#line 461
    c->recalculatemode = c->recalculatemode;
  } else {
#line 461
    c->recalculatemode = 1;
  }
#line 462
  return;
}
}
#line 464 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_dview(struct uih_context *c , dialogparam *d ) 
{ 
  char *tmp ;

  {
#line 466
  if ((d + 1)->number <= (number_t )0) {
    {
#line 467
    tmp = gettext("Invalid viewpoint");
#line 467
    uih_error(c, (char const   *)tmp);
    }
#line 468
    return;
  }
  {
#line 470
  (c->fcontext)->s.cr = (d + 0)->dcoord[0];
#line 471
  (c->fcontext)->s.ci = (d + 0)->dcoord[1];
#line 472
  (c->fcontext)->s.rr = (d + 1)->number;
#line 473
  (c->fcontext)->s.ri = (d + 1)->number;
#line 474
  uih_angle(c, (d + 2)->number);
#line 475
  c->display = 1;
  }
#line 475
  if (c->recalculatemode > 2) {
#line 475
    c->recalculatemode = c->recalculatemode;
  } else {
#line 475
    c->recalculatemode = 2;
  }
#line 476
  return;
}
}
#line 478 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_getviewdialog(struct uih_context *c ) 
{ 
  number_t xs ;
  number_t ys ;

  {
#line 481
  if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 482
    xs = (c->fcontext)->s.rr;
#line 483
    ys = ((c->fcontext)->s.ri * (number_t )(c->fcontext)->windowwidth) / (number_t )(c->fcontext)->windowheight;
#line 485
    (uih_viewdialog + 0)->deffloat = (c->fcontext)->s.cr;
#line 486
    (uih_viewdialog + 0)->deffloat2 = (c->fcontext)->s.ci;
#line 487
    (uih_viewdialog + 2)->deffloat = (c->fcontext)->angle;
#line 488
    if (xs > ys) {
#line 489
      (uih_viewdialog + 1)->deffloat = (c->fcontext)->s.rr;
    } else {
#line 491
      (uih_viewdialog + 1)->deffloat = (c->fcontext)->s.ri;
    }
  }
#line 493
  return (uih_viewdialog);
}
}
#line 496 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_printdialog(struct uih_context *c , char const   *name___0 ) 
{ 
  menuitem const   *item ;
  menuitem const   *tmp ;
  int y ;
  menudialog const   *di ;
  menudialog const   *tmp___0 ;
  char const   *tmp___1 ;
  int y___0 ;
  char const   **str___0 ;

  {
  {
#line 498
  tmp = menu_findcommand(name___0);
#line 498
  item = tmp;
  }
#line 501
  if ((unsigned long )item == (unsigned long )((void *)0)) {
    {
#line 502
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"print_dialog:unknown function %s\n",
            name___0);
    }
#line 503
    return;
  }
#line 505
  if (item->type != 6) {
#line 505
    if (item->type != 7) {
      {
#line 506
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"print_dialog:%s don\'t have any dialog. Sorry.\n",
              name___0);
      }
#line 508
      return;
    }
  }
#line 510
  if (item->type == 6) {
#line 510
    di = (menudialog const   *)item->pparam;
  } else {
    {
#line 510
    tmp___0 = (*(item->dialog))(c);
#line 510
    di = tmp___0;
    }
  }
#line 511
  if (item->type == 7) {
    {
#line 512
    printf((char const   */* __restrict  */)"customdialog \"%s\"\n", item->shortname);
    }
  } else {
    {
#line 514
    printf((char const   */* __restrict  */)"dialog \"%s\"\n", item->shortname);
    }
  }
#line 515
  y = 0;
  {
#line 515
  while (1) {
    while_continue: /* CIL Label */ ;
#line 515
    if (! ((unsigned long )(di + y)->question != (unsigned long )((void *)0))) {
#line 515
      goto while_break;
    }
    {
#line 516
    printf((char const   */* __restrict  */)"dialogentry \"%s\" ", (di + y)->question);
    }
    {
#line 518
    if ((di + y)->type == 1) {
#line 518
      goto case_1;
    }
#line 521
    if ((di + y)->type == 2) {
#line 521
      goto case_2;
    }
#line 524
    if ((di + y)->type == 3) {
#line 524
      goto case_3;
    }
#line 526
    if ((di + y)->type == 4) {
#line 526
      goto case_4;
    }
#line 529
    if ((di + y)->type == 5) {
#line 529
      goto case_5;
    }
#line 532
    if ((di + y)->type == 6) {
#line 532
      goto case_6;
    }
#line 535
    if ((di + y)->type == 8) {
#line 535
      goto case_8;
    }
#line 538
    if ((di + y)->type == 9) {
#line 538
      goto case_9;
    }
#line 542
    if ((di + y)->type == 7) {
#line 542
      goto case_7;
    }
#line 517
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 519
    printf((char const   */* __restrict  */)"integer %i", di->defint);
    }
#line 520
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 522
    printf((char const   */* __restrict  */)"float %f", (double )di->deffloat);
    }
#line 523
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 525
    printf((char const   */* __restrict  */)"string \"%s\"", di->defstr);
    }
    case_4: /* CIL Label */ 
    {
#line 527
    printf((char const   */* __restrict  */)"keyword \"%s\"", di->defstr);
    }
#line 528
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 530
    printf((char const   */* __restrict  */)"inputfile \"%s\"", di->defstr);
    }
#line 531
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 533
    printf((char const   */* __restrict  */)"outputfile \"%s\"", di->defstr);
    }
#line 534
    goto switch_break;
    case_8: /* CIL Label */ 
#line 536
    if (di->defint) {
#line 536
      tmp___1 = "#t";
    } else {
#line 536
      tmp___1 = "#f";
    }
    {
#line 536
    printf((char const   */* __restrict  */)"onoff %s", tmp___1);
    }
#line 537
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 539
    printf((char const   */* __restrict  */)"complex %f %f", (double )di->deffloat,
           (double )di->deffloat2);
    }
#line 541
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 543
    printf((char const   */* __restrict  */)"choice {");
#line 546
    str___0 = (char const   **)di->defstr;
#line 547
    y___0 = 0;
    }
    {
#line 547
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 547
      if (! ((unsigned long )*(str___0 + y___0) != (unsigned long )((void *)0))) {
#line 547
        goto while_break___0;
      }
      {
#line 548
      printf((char const   */* __restrict  */)"%s ", *(str___0 + y___0));
#line 547
      y___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 549
    printf((char const   */* __restrict  */)"}");
#line 550
    printf((char const   */* __restrict  */)"%s ", *(str___0 + di->defint));
    }
#line 552
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 554
    printf((char const   */* __restrict  */)"\n");
#line 515
    y ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 556
  printf((char const   */* __restrict  */)"enddialog\n");
  }
#line 557
  return;
}
}
#line 559 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_printmenu(struct uih_context *c , char const   *name___0 , int recursive ) 
{ 
  char const   *fullname ;
  int i ;
  menuitem const   *item ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 563
  i = 0;
#line 565
  fullname = menu_fullname(name___0);
  }
#line 565
  if ((unsigned long )fullname == (unsigned long )((void *)0)) {
    {
#line 566
    printf((char const   */* __restrict  */)"Menu not found\n");
    }
#line 567
    return;
  }
  {
#line 569
  printf((char const   */* __restrict  */)"\n\nmenu \"%s\" \"%s\"\n", fullname, name___0);
#line 570
  i = 0;
  }
  {
#line 570
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 570
    item = menu_item(name___0, i);
    }
#line 570
    if (! ((unsigned long )item != (unsigned long )((void *)0))) {
#line 570
      goto while_break;
    }
#line 571
    if (item->type == 2) {
      {
#line 572
      printf((char const   */* __restrict  */)"submenu \"%s\" \"%s\"\n", item->name,
             item->shortname);
      }
#line 573
      goto __Cont;
    }
#line 575
    if (item->type == 2) {
      {
#line 576
      printf((char const   */* __restrict  */)"separator");
      }
#line 577
      goto __Cont;
    }
    {
#line 579
    printf((char const   */* __restrict  */)"menuentry \"%s\" \"%s\" ", item->name,
           item->shortname);
    }
#line 580
    if (item->flags & 2) {
      {
#line 581
      tmp___1 = menu_enabled(item, c);
      }
#line 581
      if (tmp___1) {
#line 581
        tmp___0 = "on";
      } else {
#line 581
        tmp___0 = "off";
      }
      {
#line 581
      printf((char const   */* __restrict  */)"radio %s", tmp___0);
      }
    } else
#line 582
    if (item->flags & 1) {
      {
#line 583
      tmp___4 = menu_enabled(item, c);
      }
#line 583
      if (tmp___4) {
#line 583
        tmp___3 = "on";
      } else {
#line 583
        tmp___3 = "off";
      }
      {
#line 583
      printf((char const   */* __restrict  */)"checkbox %s", tmp___3);
      }
    } else {
      {
#line 585
      printf((char const   */* __restrict  */)"normal");
      }
    }
#line 586
    if (item->flags & 256) {
      {
#line 587
      printf((char const   */* __restrict  */)" dialogatdisable");
      }
    }
#line 588
    if (item->type == 6) {
      {
#line 589
      printf((char const   */* __restrict  */)" dialog");
      }
    } else
#line 588
    if (item->type == 7) {
      {
#line 589
      printf((char const   */* __restrict  */)" dialog");
      }
    }
    {
#line 590
    printf((char const   */* __restrict  */)"\n");
    }
    __Cont: /* CIL Label */ 
#line 570
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 592
  printf((char const   */* __restrict  */)"endmenu\n");
  }
#line 593
  if (recursive) {
#line 594
    i = 0;
    {
#line 594
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 594
      item = menu_item(name___0, i);
      }
#line 594
      if (! ((unsigned long )item != (unsigned long )((void *)0))) {
#line 594
        goto while_break___0;
      }
#line 595
      if (item->type == 2) {
        {
#line 596
        uih_printmenu(c, (char const   *)item->shortname, 1);
        }
      }
#line 594
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 599
  return;
}
}
#line 601 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_printmenuwr(struct uih_context *c , char const   *name___0 ) 
{ 


  {
  {
#line 603
  uih_printmenu(c, name___0, 0);
  }
#line 604
  return;
}
}
#line 606 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_printallmenus(struct uih_context *c ) 
{ 


  {
  {
#line 608
  uih_printmenu(c, "root", 1);
#line 609
  uih_printmenu(c, "animroot", 1);
#line 610
  printf((char const   */* __restrict  */)"endmenu\n");
  }
#line 611
  return;
}
}
#line 613 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_getlettersdialog(struct uih_context *c ) 
{ 


  {
#line 615
  if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 616
    (uih_lettersdialog + 0)->defint = c->letterspersec;
  }
#line 617
  return (uih_lettersdialog);
}
}
#line 620 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_getiterdialog(struct uih_context *c ) 
{ 


  {
#line 622
  if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 623
    (uih_iterdialog + 0)->defint = (int )(c->fcontext)->maxiter;
  }
#line 624
  return (uih_iterdialog);
}
}
#line 627 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_getbailoutdialog(struct uih_context *c ) 
{ 


  {
#line 629
  if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 630
    (uih_bailoutdialog + 0)->deffloat = (c->fcontext)->bailout;
  }
#line 631
  return (uih_bailoutdialog);
}
}
#line 634 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static int uih_saveanimenabled(struct uih_context *c ) 
{ 


  {
#line 636
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 637
    return (0);
  }
#line 638
  return (c->save);
}
}
#line 643 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_getrotationdialog(struct uih_context *c ) 
{ 


  {
#line 645
  if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 646
    (uih_rotationdialog + 0)->deffloat = c->rotationspeed;
  }
#line 647
  return (uih_rotationdialog);
}
}
#line 650 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_getpalettedialog(struct uih_context *uih___2 ) 
{ 


  {
#line 652
  if ((unsigned long )uih___2 != (unsigned long )((void *)0)) {
#line 653
    (palettedialog + 0)->defint = uih___2->palettetype;
#line 654
    (palettedialog + 1)->defint = uih___2->paletteseed;
#line 655
    (palettedialog + 2)->defint = uih___2->paletteshift + uih___2->manualpaletteshift;
  }
#line 658
  return (palettedialog);
}
}
#line 661 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_getcyclingdialog(struct uih_context *uih___2 ) 
{ 


  {
#line 663
  if ((unsigned long )uih___2 != (unsigned long )((void *)0)) {
#line 664
    (uih_cyclingdialog + 0)->defint = uih___2->cyclingspeed * uih___2->direction;
  }
#line 665
  return (uih_cyclingdialog);
}
}
#line 668 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menudialog *uih_getspeeddialog(struct uih_context *uih___2 ) 
{ 


  {
#line 670
  if ((unsigned long )uih___2 != (unsigned long )((void *)0)) {
#line 671
    (uih_speeddialog + 0)->deffloat = uih___2->speedup / (number_t )(0.0006 * (double )3);
  }
#line 672
  return (uih_speeddialog);
}
}
#line 675 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_setspeed(uih_context *c , number_t p ) 
{ 


  {
#line 677
  if (p >= (number_t )100) {
#line 678
    p = (number_t )1.0;
  }
#line 679
  if (p < (number_t )0) {
#line 680
    p = (number_t )0;
  }
#line 681
  c->speedup = (number_t )(0.0006 * (double )3) * p;
#line 682
  c->maxstep = (number_t )(0.008 * (double )3) * p;
#line 684
  return;
}
}
#line 686 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_palette(struct uih_context *uih___2 , dialogparam *p ) 
{ 
  int n1 ;
  int n2 ;
  int shift ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 688
  n1 = (p + 0)->dint;
#line 689
  n2 = (p + 1)->dint;
#line 690
  shift = (p + 2)->dint;
#line 691
  if (! n1) {
    {
#line 692
    uih_playdefpalette(uih___2, shift);
    }
#line 693
    return;
  }
#line 695
  if (n1 < 1) {
    {
#line 696
    tmp = gettext("Unknown palette type");
#line 696
    uih_error(uih___2, (char const   *)tmp);
    }
  } else
#line 695
  if (n1 > 3) {
    {
#line 696
    tmp = gettext("Unknown palette type");
#line 696
    uih_error(uih___2, (char const   *)tmp);
    }
  }
#line 698
  if ((unsigned long )((uih___2->zengine)->fractalc)->palette == (unsigned long )((void *)0)) {
#line 699
    return;
  }
  {
#line 700
  tmp___0 = mkpalette(((uih___2->zengine)->fractalc)->palette, n2, n1 - 1);
  }
#line 700
  if (tmp___0 != 0) {
#line 701
    uih___2->display = 1;
#line 701
    if (uih___2->recalculatemode > 2) {
#line 701
      uih___2->recalculatemode = uih___2->recalculatemode;
    } else {
#line 701
      uih___2->recalculatemode = 2;
    }
  }
  {
#line 703
  uih___2->manualpaletteshift = 0;
#line 704
  uih___2->palettetype = n1;
#line 705
  uih___2->palettechanged = 1;
#line 706
  uih___2->paletteseed = n2;
#line 707
  tmp___1 = shiftpalette(((uih___2->zengine)->fractalc)->palette, shift);
  }
#line 707
  if (tmp___1) {
#line 708
    uih___2->display = 1;
#line 708
    if (uih___2->recalculatemode > 2) {
#line 708
      uih___2->recalculatemode = uih___2->recalculatemode;
    } else {
#line 708
      uih___2->recalculatemode = 2;
    }
  }
#line 710
  uih___2->paletteshift = shift;
#line 711
  return;
}
}
#line 713 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static int uih_rotateselected(struct uih_context *c , int n ) 
{ 


  {
#line 715
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 716
    return (0);
  }
#line 717
  if (! c->fastrotate) {
#line 718
    return (! n);
  }
#line 719
  return (c->rotatemode == n);
}
}
#line 722 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static int uih_guessingselected(struct uih_context *c , int n ) 
{ 


  {
#line 724
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 725
    return (0);
  }
#line 726
  return ((c->fcontext)->range == n);
}
}
#line 729 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static int uih_fastmode(struct uih_context *c , int n ) 
{ 


  {
#line 731
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 732
    return (0);
  }
#line 733
  return (c->fastmode == n);
}
}
#line 736 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static int uih_periodicityselected(struct uih_context *c ) 
{ 


  {
#line 738
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 739
    return (0);
  }
#line 740
  return ((c->fcontext)->periodicity);
}
}
#line 743 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_periodicitysw(struct uih_context *c ) 
{ 


  {
  {
#line 745
  uih_setperiodicity(c, (c->fcontext)->periodicity ^ 1);
  }
#line 746
  return;
}
}
#line 748 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static int uih_cyclingselected(struct uih_context *c ) 
{ 
  int tmp ;

  {
#line 750
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 751
    return (0);
  }
#line 752
  if (c->cycling) {
#line 752
    if (c->cyclingdirection == 1) {
#line 752
      tmp = 1;
    } else {
#line 752
      tmp = 0;
    }
  } else {
#line 752
    tmp = 0;
  }
#line 752
  return (tmp);
}
}
#line 755 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static int uih_rcyclingselected(struct uih_context *c ) 
{ 
  int tmp ;

  {
#line 757
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 758
    return (0);
  }
#line 759
  if (c->cycling) {
#line 759
    if (c->cyclingdirection == -1) {
#line 759
      tmp = 1;
    } else {
#line 759
      tmp = 0;
    }
  } else {
#line 759
    tmp = 0;
  }
#line 759
  return (tmp);
}
}
#line 762 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_cyclingsw(struct uih_context *c ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 765
  if (c->cycling) {
#line 765
    if (c->cyclingdirection == -1) {
      {
#line 766
      uih_cycling_off(c);
      }
    }
  }
#line 767
  c->cyclingdirection = 1;
#line 768
  if (c->cycling) {
    {
#line 769
    uih_cycling_off(c);
    }
  } else {
    {
#line 770
    tmp___1 = uih_cycling_on(c);
    }
#line 770
    if (! tmp___1) {
      {
#line 771
      tmp = gettext("Initialization of color cycling failed.");
#line 771
      uih_error(c, (char const   *)tmp);
#line 771
      tmp___0 = gettext("Try to enable palette emulation filter");
#line 771
      uih_message(c, (char const   *)tmp___0);
      }
    }
  }
#line 774
  return;
}
}
#line 776 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_rcyclingsw(struct uih_context *c ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 779
  if (c->cycling) {
#line 779
    if (c->cyclingdirection == 1) {
      {
#line 780
      uih_cycling_off(c);
      }
    }
  }
#line 781
  c->cyclingdirection = -1;
#line 782
  if (c->cycling) {
    {
#line 783
    uih_cycling_off(c);
    }
  } else {
    {
#line 784
    tmp___1 = uih_cycling_on(c);
    }
#line 784
    if (! tmp___1) {
      {
#line 785
      tmp = gettext("Initialization of color cycling failed.");
#line 785
      uih_error(c, (char const   *)tmp);
#line 785
      tmp___0 = gettext("Try to enable palette emulation filter");
#line 785
      uih_message(c, (char const   *)tmp___0);
      }
    }
  }
#line 788
  return;
}
}
#line 790 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_juliasw(struct uih_context *c ) 
{ 


  {
#line 792
  if (! c->juliamode) {
    {
#line 793
    uih_enablejulia(c);
    }
  } else {
    {
#line 795
    uih_disablejulia(c);
    }
  }
#line 796
  return;
}
}
#line 798 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static int uih_juliaselected(struct uih_context *c ) 
{ 


  {
#line 800
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 801
    return (0);
  }
#line 802
  return (c->juliamode);
}
}
#line 805 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static int uih_mandelbrotselected(struct uih_context *c ) 
{ 


  {
#line 807
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 808
    return (0);
  }
#line 809
  return ((c->fcontext)->mandelbrot);
}
}
#line 812 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_mandelbrotsw(struct uih_context *c , number_t x , number_t y ) 
{ 


  {
#line 814
  (c->fcontext)->mandelbrot ^= 1;
#line 815
  if ((c->fcontext)->mandelbrot == 0) {
#line 815
    if (! c->juliamode) {
#line 816
      (c->fcontext)->pre = x;
#line 817
      (c->fcontext)->pim = y;
    } else {
      {
#line 819
      uih_disablejulia(c);
      }
    }
  } else {
    {
#line 819
    uih_disablejulia(c);
    }
  }
#line 820
  ((c->fcontext)->version) ++;
#line 821
  c->display = 1;
#line 821
  if (c->recalculatemode > 2) {
#line 821
    c->recalculatemode = c->recalculatemode;
  } else {
#line 821
    c->recalculatemode = 2;
  }
#line 822
  if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
    {
#line 822
    (*(c->updatemenus))(c, "uimandelbrot");
    }
  }
#line 823
  return;
}
}
#line 825 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static int uih_autopilotselected(struct uih_context *c ) 
{ 


  {
#line 827
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 828
    return (0);
  }
#line 829
  return (c->autopilot);
}
}
#line 832 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static int uih_fixedstepselected(struct uih_context *c ) 
{ 


  {
#line 834
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 835
    return (0);
  }
#line 836
  return (c->fixedstep);
}
}
#line 839 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_persw(struct uih_context *c , number_t x , number_t y ) 
{ 


  {
#line 841
  if ((c->fcontext)->bre) {
    {
#line 842
    uih_setperbutation(c, (number_t )0.0, (number_t )0.0);
    }
  } else
#line 841
  if ((c->fcontext)->bim) {
    {
#line 842
    uih_setperbutation(c, (number_t )0.0, (number_t )0.0);
    }
  } else {
    {
#line 844
    uih_setperbutation(c, x, y);
    }
  }
#line 846
  return;
}
}
#line 848 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static int uih_perselected(struct uih_context *c ) 
{ 
  int tmp ;

  {
#line 850
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 851
    return (0);
  }
#line 852
  if ((c->fcontext)->bre) {
#line 852
    tmp = 1;
  } else
#line 852
  if ((c->fcontext)->bim) {
#line 852
    tmp = 1;
  } else {
#line 852
    tmp = 0;
  }
#line 852
  return (tmp);
}
}
#line 855 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_autopilotsw(struct uih_context *c ) 
{ 


  {
#line 857
  if (c->autopilot) {
    {
#line 858
    uih_autopilot_off(c);
    }
  } else {
    {
#line 860
    uih_autopilot_on(c);
    }
  }
#line 861
  return;
}
}
#line 863 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_fixedstepsw(struct uih_context *c ) 
{ 


  {
#line 865
  c->fixedstep ^= 1;
#line 866
  return;
}
}
#line 868 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_setxtextpos(uih_context *c , int p ) 
{ 


  {
  {
#line 870
  uih_settextpos(c, p, c->ytextpos);
  }
#line 871
  return;
}
}
#line 873 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static int uih_xtextselected(uih_context *c , int p ) 
{ 


  {
#line 875
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 876
    return (0);
  }
#line 877
  return (c->xtextpos == p);
}
}
#line 880 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_setytextpos(uih_context *c , int p ) 
{ 


  {
  {
#line 882
  uih_settextpos(c, c->xtextpos, p);
  }
#line 883
  return;
}
}
#line 885 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static int uih_ytextselected(uih_context *c , int p ) 
{ 


  {
#line 887
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 888
    return (0);
  }
#line 889
  return (c->ytextpos == p);
}
}
#line 892 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_menumkpalette(uih_context *c ) 
{ 
  char s[256] ;
  char *tmp ;

  {
  {
#line 895
  uih_mkpalette(c);
#line 896
  tmp = gettext("Algorithm:%i seed:%i size:%i");
#line 896
  sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)tmp, c->palettetype,
          c->paletteseed, (((c->zengine)->fractalc)->palette)->size);
#line 898
  uih_message(c, (char const   *)(s));
  }
#line 899
  return;
}
}
#line 901 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_shiftpalette(uih_context *c , int shift ) 
{ 
  int tmp ;

  {
  {
#line 903
  tmp = shiftpalette(((c->zengine)->fractalc)->palette, shift);
  }
#line 903
  if (tmp) {
#line 904
    c->display = 1;
#line 904
    if (c->recalculatemode > 2) {
#line 904
      c->recalculatemode = c->recalculatemode;
    } else {
#line 904
      c->recalculatemode = 2;
    }
  }
#line 906
  c->manualpaletteshift += shift;
#line 907
  return;
}
}
#line 909 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_fshift(uih_context *c ) 
{ 


  {
  {
#line 911
  uih_shiftpalette(c, 1);
  }
#line 912
  return;
}
}
#line 914 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_bshift(uih_context *c ) 
{ 


  {
  {
#line 916
  uih_shiftpalette(c, -1);
  }
#line 917
  return;
}
}
#line 919 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menuitem const   *menuitems  ;
#line 940 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menuitem menuitems_i18n[250]  ;
#line 941 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
int uih_no_menuitems_i18n  ;
#line 943 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
void uih_registermenus_i18n(void) 
{ 
  int no_menuitems_i18n ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;
  char *tmp___69 ;
  char *tmp___70 ;
  char *tmp___71 ;
  char *tmp___72 ;
  char *tmp___73 ;
  char *tmp___74 ;
  char *tmp___75 ;
  char *tmp___76 ;
  char *tmp___77 ;
  char *tmp___78 ;
  char *tmp___79 ;
  char *tmp___80 ;
  char *tmp___81 ;
  char *tmp___82 ;
  char *tmp___83 ;
  char *tmp___84 ;
  char *tmp___85 ;
  char *tmp___86 ;
  char *tmp___87 ;
  char *tmp___88 ;
  char *tmp___89 ;
  char *tmp___90 ;
  char *tmp___91 ;
  char *tmp___92 ;
  char *tmp___93 ;
  char *tmp___94 ;
  char *tmp___95 ;
  char *tmp___96 ;
  char *tmp___97 ;
  char *tmp___98 ;
  char *tmp___99 ;
  char *tmp___100 ;
  char *tmp___101 ;
  char *tmp___102 ;
  char *tmp___103 ;
  char *tmp___104 ;
  char *tmp___105 ;
  char *tmp___106 ;
  char *tmp___107 ;
  char *tmp___108 ;
  char *tmp___109 ;
  char *tmp___110 ;
  char *tmp___111 ;
  char *tmp___112 ;
  char *tmp___113 ;
  char *tmp___114 ;
  char *tmp___115 ;
  char *tmp___116 ;
  char *tmp___117 ;
  char *tmp___118 ;
  char *tmp___119 ;
  char *tmp___120 ;
  char *tmp___121 ;
  char *tmp___122 ;
  char *tmp___123 ;
  char *tmp___124 ;
  char *tmp___125 ;
  char *tmp___126 ;
  char *tmp___127 ;
  char *tmp___128 ;
  char *tmp___129 ;
  char *tmp___130 ;
  char *tmp___131 ;
  char *tmp___132 ;
  char *tmp___133 ;
  char *tmp___134 ;
  char *tmp___135 ;
  char *tmp___136 ;
  char *tmp___137 ;
  char *tmp___138 ;
  char *tmp___139 ;
  char *tmp___140 ;
  char *tmp___141 ;
  char *tmp___142 ;
  char *tmp___143 ;
  char *tmp___144 ;
  char *tmp___145 ;
  char *tmp___146 ;
  char *tmp___147 ;
  char *tmp___148 ;
  char *tmp___149 ;
  char *tmp___150 ;
  char *tmp___151 ;
  char *tmp___152 ;
  char *tmp___153 ;
  char *tmp___154 ;
  char *tmp___155 ;
  char *tmp___156 ;
  char *tmp___157 ;
  char *tmp___158 ;
  char *tmp___159 ;
  char *tmp___160 ;
  char *tmp___161 ;
  char *tmp___162 ;
  char *tmp___163 ;
  char *tmp___164 ;
  char *tmp___165 ;
  char *tmp___166 ;

  {
  {
#line 946
  no_menuitems_i18n = 0;
#line 947
  menuitems_i18n[no_menuitems_i18n].menuname = "";
#line 947
  menuitems_i18n[no_menuitems_i18n].shortname = "root";
#line 947
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 947
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 947
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 947
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 947
  tmp = gettext("Root menu");
#line 947
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp;
#line 947
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 947
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 947
  no_menuitems_i18n ++;
#line 948
  menuitems_i18n[no_menuitems_i18n].menuname = "";
#line 948
  menuitems_i18n[no_menuitems_i18n].shortname = "animroot";
#line 948
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 948
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 948
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 948
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 948
  tmp___0 = gettext("Animation root menu");
#line 948
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___0;
#line 948
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 948
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 948
  no_menuitems_i18n ++;
#line 949
  menuitems_i18n[no_menuitems_i18n].menuname = "";
#line 949
  menuitems_i18n[no_menuitems_i18n].shortname = "plc";
#line 949
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 949
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 949
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 949
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 949
  tmp___1 = gettext("Replay only commands");
#line 949
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___1;
#line 949
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 949
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 949
  no_menuitems_i18n ++;
#line 950
  menuitems_i18n[no_menuitems_i18n].menuname = "";
#line 950
  menuitems_i18n[no_menuitems_i18n].shortname = "comm";
#line 950
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 950
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 950
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 950
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 950
  tmp___2 = gettext("Command line options only");
#line 950
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___2;
#line 950
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 950
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 950
  no_menuitems_i18n ++;
#line 952
  menuitems_i18n[no_menuitems_i18n].menuname = "comm";
#line 952
  menuitems_i18n[no_menuitems_i18n].shortname = "print_menus";
#line 952
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 952
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 952
  menuitems_i18n[no_menuitems_i18n].flags = 208;
#line 952
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 952
  tmp___3 = gettext("print menus specifications of all menus");
#line 952
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___3;
#line 952
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 952
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_printallmenus);
#line 952
  no_menuitems_i18n ++;
#line 955
  menuitems_i18n[no_menuitems_i18n].menuname = "comm";
#line 955
  menuitems_i18n[no_menuitems_i18n].shortname = "print_menu";
#line 955
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 955
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 955
  menuitems_i18n[no_menuitems_i18n].flags = 208;
#line 955
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 955
  tmp___4 = gettext("print menu specification");
#line 955
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___4;
#line 955
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)printdialog;
#line 955
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_printmenuwr);
#line 955
  no_menuitems_i18n ++;
#line 960
  menuitems_i18n[no_menuitems_i18n].menuname = "comm";
#line 960
  menuitems_i18n[no_menuitems_i18n].shortname = "xshl_print_menu";
#line 960
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 960
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 960
  menuitems_i18n[no_menuitems_i18n].flags = 208;
#line 960
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 960
  tmp___5 = gettext("print menu specification in xshl format");
#line 960
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___5;
#line 960
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)printdialog;
#line 960
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_xshlprintmenu);
#line 960
  no_menuitems_i18n ++;
#line 963
  menuitems_i18n[no_menuitems_i18n].menuname = "comm";
#line 963
  menuitems_i18n[no_menuitems_i18n].shortname = "xshl_print_menus";
#line 963
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 963
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 963
  menuitems_i18n[no_menuitems_i18n].flags = 208;
#line 963
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 963
  tmp___6 = gettext("print all menu specifications in xshl format");
#line 963
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___6;
#line 963
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 963
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_xshlprintmenus);
#line 963
  no_menuitems_i18n ++;
#line 967
  menuitems_i18n[no_menuitems_i18n].menuname = "comm";
#line 967
  menuitems_i18n[no_menuitems_i18n].shortname = "print_dialog";
#line 967
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 967
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 967
  menuitems_i18n[no_menuitems_i18n].flags = 208;
#line 967
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 967
  tmp___7 = gettext("print dialog specification");
#line 967
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___7;
#line 967
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)printdialog;
#line 967
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_printdialog);
#line 967
  no_menuitems_i18n ++;
#line 972
  menuitems_i18n[no_menuitems_i18n].menuname = "plc";
#line 972
  menuitems_i18n[no_menuitems_i18n].shortname = "linemenu";
#line 972
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 972
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 972
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 972
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 972
  tmp___8 = gettext("Line drawing functions");
#line 972
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___8;
#line 972
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 972
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 972
  no_menuitems_i18n ++;
#line 973
  menuitems_i18n[no_menuitems_i18n].menuname = "linemenu";
#line 973
  menuitems_i18n[no_menuitems_i18n].shortname = "line";
#line 973
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 973
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 973
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 973
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 973
  tmp___9 = gettext("Line");
#line 973
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___9;
#line 973
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_linedialog;
#line 973
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_line);
#line 973
  no_menuitems_i18n ++;
#line 975
  menuitems_i18n[no_menuitems_i18n].menuname = "linemenu";
#line 975
  menuitems_i18n[no_menuitems_i18n].shortname = "morphline";
#line 975
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 975
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 975
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 975
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 975
  tmp___10 = gettext("Morph line");
#line 975
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___10;
#line 975
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_linedialog;
#line 975
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_morphline);
#line 975
  no_menuitems_i18n ++;
#line 978
  menuitems_i18n[no_menuitems_i18n].menuname = "linemenu";
#line 978
  menuitems_i18n[no_menuitems_i18n].shortname = "morphlastline";
#line 978
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 978
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 978
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 978
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 978
  tmp___11 = gettext("Morph last line");
#line 978
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___11;
#line 978
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_linedialog;
#line 978
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_morphlastline);
#line 978
  no_menuitems_i18n ++;
#line 980
  menuitems_i18n[no_menuitems_i18n].menuname = "linemenu";
#line 980
  menuitems_i18n[no_menuitems_i18n].shortname = "linekey";
#line 980
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 980
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 980
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 980
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 980
  tmp___12 = gettext("Set line key");
#line 980
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___12;
#line 980
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_numdialog;
#line 980
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setkey);
#line 980
  no_menuitems_i18n ++;
#line 983
  menuitems_i18n[no_menuitems_i18n].menuname = "linemenu";
#line 983
  menuitems_i18n[no_menuitems_i18n].shortname = "clearline";
#line 983
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 983
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 983
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 983
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 983
  tmp___13 = gettext("Clear line");
#line 983
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___13;
#line 983
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 983
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_clear_line);
#line 983
  no_menuitems_i18n ++;
#line 985
  menuitems_i18n[no_menuitems_i18n].menuname = "linemenu";
#line 985
  menuitems_i18n[no_menuitems_i18n].shortname = "clearlines";
#line 985
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 985
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 985
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 985
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 985
  tmp___14 = gettext("Clear all lines");
#line 985
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___14;
#line 985
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 985
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_clear_lines);
#line 985
  no_menuitems_i18n ++;
#line 988
  menuitems_i18n[no_menuitems_i18n].menuname = "plc";
#line 988
  menuitems_i18n[no_menuitems_i18n].shortname = "animf";
#line 988
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 988
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 988
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 988
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 988
  tmp___15 = gettext("Animation functions");
#line 988
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___15;
#line 988
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 988
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 988
  no_menuitems_i18n ++;
#line 989
  menuitems_i18n[no_menuitems_i18n].menuname = "animf";
#line 989
  menuitems_i18n[no_menuitems_i18n].shortname = "animateview";
#line 989
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 989
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 989
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 989
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 989
  tmp___16 = gettext("View");
#line 989
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___16;
#line 989
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_plviewdialog;
#line 989
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_plview2);
#line 989
  no_menuitems_i18n ++;
#line 991
  menuitems_i18n[no_menuitems_i18n].menuname = "animf";
#line 991
  menuitems_i18n[no_menuitems_i18n].shortname = "morphview";
#line 991
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 991
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 991
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 991
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 991
  tmp___17 = gettext("Morph view");
#line 991
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___17;
#line 991
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_plviewdialog;
#line 991
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playmorph);
#line 991
  no_menuitems_i18n ++;
#line 995
  menuitems_i18n[no_menuitems_i18n].menuname = "animf";
#line 995
  menuitems_i18n[no_menuitems_i18n].shortname = "morphjulia";
#line 995
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 995
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 995
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 995
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 995
  tmp___18 = gettext("Morph julia");
#line 995
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___18;
#line 995
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_coorddialog;
#line 995
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playmorphjulia);
#line 995
  no_menuitems_i18n ++;
#line 997
  menuitems_i18n[no_menuitems_i18n].menuname = "animf";
#line 997
  menuitems_i18n[no_menuitems_i18n].shortname = "moveview";
#line 997
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 997
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 997
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 997
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 997
  tmp___19 = gettext("Move view");
#line 997
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___19;
#line 997
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_coorddialog;
#line 997
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playmove);
#line 997
  no_menuitems_i18n ++;
#line 1002
  menuitems_i18n[no_menuitems_i18n].menuname = "animf";
#line 1002
  menuitems_i18n[no_menuitems_i18n].shortname = "morphangle";
#line 1002
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1002
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1002
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 1002
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1002
  tmp___20 = gettext("Morph angle");
#line 1002
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___20;
#line 1002
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_angledialog;
#line 1002
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playmorphangle);
#line 1002
  no_menuitems_i18n ++;
#line 1004
  menuitems_i18n[no_menuitems_i18n].menuname = "animf";
#line 1004
  menuitems_i18n[no_menuitems_i18n].shortname = "zoomcenter";
#line 1004
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1004
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1004
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 1004
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1004
  tmp___21 = gettext("Zoom center");
#line 1004
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___21;
#line 1004
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_coorddialog;
#line 1004
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_zoomcenter);
#line 1004
  no_menuitems_i18n ++;
#line 1006
  menuitems_i18n[no_menuitems_i18n].menuname = "animf";
#line 1006
  menuitems_i18n[no_menuitems_i18n].shortname = "zoom";
#line 1006
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1006
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1006
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 1006
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1006
  tmp___22 = gettext("Zoom");
#line 1006
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___22;
#line 1006
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1006
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playzoom);
#line 1006
  no_menuitems_i18n ++;
#line 1007
  menuitems_i18n[no_menuitems_i18n].menuname = "animf";
#line 1007
  menuitems_i18n[no_menuitems_i18n].shortname = "unzoom";
#line 1007
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1007
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1007
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 1007
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1007
  tmp___23 = gettext("Un-zoom");
#line 1007
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___23;
#line 1007
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1007
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playunzoom);
#line 1007
  no_menuitems_i18n ++;
#line 1009
  menuitems_i18n[no_menuitems_i18n].menuname = "animf";
#line 1009
  menuitems_i18n[no_menuitems_i18n].shortname = "stop";
#line 1009
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1009
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1009
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 1009
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1009
  tmp___24 = gettext("Stop zooming");
#line 1009
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___24;
#line 1009
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1009
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playstop);
#line 1009
  no_menuitems_i18n ++;
#line 1011
  menuitems_i18n[no_menuitems_i18n].menuname = "animf";
#line 1011
  menuitems_i18n[no_menuitems_i18n].shortname = "smoothmorph";
#line 1011
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1011
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1011
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 1011
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1011
  tmp___25 = gettext("Smooth morphing parameters");
#line 1011
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___25;
#line 1011
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_smoothmorphdialog;
#line 1011
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_smoothmorph);
#line 1011
  no_menuitems_i18n ++;
#line 1014
  menuitems_i18n[no_menuitems_i18n].menuname = "plc";
#line 1014
  menuitems_i18n[no_menuitems_i18n].shortname = "time";
#line 1014
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1014
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1014
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1014
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1014
  tmp___26 = gettext("Timing functions");
#line 1014
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___26;
#line 1014
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1014
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1014
  no_menuitems_i18n ++;
#line 1015
  menuitems_i18n[no_menuitems_i18n].menuname = "time";
#line 1015
  menuitems_i18n[no_menuitems_i18n].shortname = "usleep";
#line 1015
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1015
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1015
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 1015
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1015
  tmp___27 = gettext("Usleep");
#line 1015
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___27;
#line 1015
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_timedialog;
#line 1015
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playusleep);
#line 1015
  no_menuitems_i18n ++;
#line 1017
  menuitems_i18n[no_menuitems_i18n].menuname = "time";
#line 1017
  menuitems_i18n[no_menuitems_i18n].shortname = "textsleep";
#line 1017
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1017
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1017
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 1017
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1017
  tmp___28 = gettext("Wait for text");
#line 1017
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___28;
#line 1017
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1017
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtextsleep);
#line 1017
  no_menuitems_i18n ++;
#line 1020
  menuitems_i18n[no_menuitems_i18n].menuname = "time";
#line 1020
  menuitems_i18n[no_menuitems_i18n].shortname = "wait";
#line 1020
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1020
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1020
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 1020
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1020
  tmp___29 = gettext("Wait for complete image");
#line 1020
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___29;
#line 1020
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1020
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playwait);
#line 1020
  no_menuitems_i18n ++;
#line 1022
  menuitems_i18n[no_menuitems_i18n].menuname = "plc";
#line 1022
  menuitems_i18n[no_menuitems_i18n].shortname = "load";
#line 1022
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1022
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1022
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 1022
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1022
  tmp___30 = gettext("Include file");
#line 1022
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___30;
#line 1022
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)loaddialog;
#line 1022
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playload);
#line 1022
  no_menuitems_i18n ++;
#line 1024
  menuitems_i18n[no_menuitems_i18n].menuname = "palette";
#line 1024
  menuitems_i18n[no_menuitems_i18n].shortname = "defaultpalette";
#line 1024
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1024
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1024
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 1024
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1024
  tmp___31 = gettext("Default palette");
#line 1024
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___31;
#line 1024
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_numdialog;
#line 1024
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playdefpalette);
#line 1024
  no_menuitems_i18n ++;
#line 1026
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1026
  menuitems_i18n[no_menuitems_i18n].shortname = "formula";
#line 1026
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1026
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1026
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 1026
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1026
  tmp___32 = gettext("Formula");
#line 1026
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___32;
#line 1026
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_formuladialog;
#line 1026
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_play_formula);
#line 1026
  no_menuitems_i18n ++;
#line 1028
  menuitems_i18n[no_menuitems_i18n].menuname = "ui";
#line 1028
  menuitems_i18n[no_menuitems_i18n].shortname = "maxstep";
#line 1028
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1028
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1028
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 1028
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1028
  tmp___33 = gettext("Maximal zooming step");
#line 1028
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___33;
#line 1028
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_fpdialog;
#line 1028
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setmaxstep);
#line 1028
  no_menuitems_i18n ++;
#line 1030
  menuitems_i18n[no_menuitems_i18n].menuname = "ui";
#line 1030
  menuitems_i18n[no_menuitems_i18n].shortname = "speedup";
#line 1030
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1030
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1030
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 1030
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1030
  tmp___34 = gettext("Zooming speedup");
#line 1030
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___34;
#line 1030
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_fpdialog;
#line 1030
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setspeedup);
#line 1030
  no_menuitems_i18n ++;
#line 1032
  menuitems_i18n[no_menuitems_i18n].menuname = "mfilter";
#line 1032
  menuitems_i18n[no_menuitems_i18n].shortname = "filter";
#line 1032
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1032
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1032
  menuitems_i18n[no_menuitems_i18n].flags = 48;
#line 1032
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1032
  tmp___35 = gettext("Filter");
#line 1032
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___35;
#line 1032
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_filterdialog;
#line 1032
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playfilter);
#line 1032
  no_menuitems_i18n ++;
#line 1036
  menuitems_i18n[no_menuitems_i18n].menuname = "ui";
#line 1036
  menuitems_i18n[no_menuitems_i18n].shortname = "letterspersec";
#line 1036
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1036
  menuitems_i18n[no_menuitems_i18n].type = 7;
#line 1036
  menuitems_i18n[no_menuitems_i18n].flags = 16;
#line 1036
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1036
  tmp___36 = gettext("Letters per second");
#line 1036
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___36;
#line 1036
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1036
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))((void *)0);
#line 1036
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_letterspersec);
#line 1036
  menuitems_i18n[no_menuitems_i18n].dialog = (menudialog const   *(*)(struct uih_context * ))(& uih_getlettersdialog);
#line 1036
  no_menuitems_i18n ++;
#line 1039
  menuitems_i18n[no_menuitems_i18n].menuname = "uia";
#line 1039
  menuitems_i18n[no_menuitems_i18n].shortname = "letters";
#line 1039
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1039
  menuitems_i18n[no_menuitems_i18n].type = 7;
#line 1039
  menuitems_i18n[no_menuitems_i18n].flags = 96;
#line 1039
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1039
  tmp___37 = gettext("Letters per second");
#line 1039
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___37;
#line 1039
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1039
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))((void *)0);
#line 1039
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_letterspersec);
#line 1039
  menuitems_i18n[no_menuitems_i18n].dialog = (menudialog const   *(*)(struct uih_context * ))(& uih_getlettersdialog);
#line 1039
  no_menuitems_i18n ++;
#line 1043
  menuitems_i18n[no_menuitems_i18n].menuname = "uia";
#line 1043
  menuitems_i18n[no_menuitems_i18n].shortname = "animinterrupt";
#line 1043
  menuitems_i18n[no_menuitems_i18n].key = "z";
#line 1043
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1043
  menuitems_i18n[no_menuitems_i18n].flags = 12;
#line 1043
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1043
  tmp___38 = gettext("Interrupt");
#line 1043
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___38;
#line 1043
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1043
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_interrupt);
#line 1043
  no_menuitems_i18n ++;
#line 1045
  menuitems_i18n[no_menuitems_i18n].menuname = "root";
#line 1045
  menuitems_i18n[no_menuitems_i18n].shortname = "file";
#line 1045
  menuitems_i18n[no_menuitems_i18n].key = "s";
#line 1045
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1045
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1045
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1045
  tmp___39 = gettext("File");
#line 1045
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___39;
#line 1045
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1045
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1045
  no_menuitems_i18n ++;
#line 1046
  menuitems_i18n[no_menuitems_i18n].menuname = "root";
#line 1046
  menuitems_i18n[no_menuitems_i18n].shortname = "edit";
#line 1046
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1046
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1046
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1046
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1046
  tmp___40 = gettext("Edit");
#line 1046
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___40;
#line 1046
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1046
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1046
  no_menuitems_i18n ++;
#line 1047
  menuitems_i18n[no_menuitems_i18n].menuname = "root";
#line 1047
  menuitems_i18n[no_menuitems_i18n].shortname = "fractal";
#line 1047
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1047
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1047
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1047
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1047
  tmp___41 = gettext("Fractal");
#line 1047
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___41;
#line 1047
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1047
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1047
  no_menuitems_i18n ++;
#line 1048
  menuitems_i18n[no_menuitems_i18n].menuname = "root";
#line 1048
  menuitems_i18n[no_menuitems_i18n].shortname = "calc";
#line 1048
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1048
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1048
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1048
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1048
  tmp___42 = gettext("Calculation");
#line 1048
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___42;
#line 1048
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1048
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1048
  no_menuitems_i18n ++;
#line 1049
  menuitems_i18n[no_menuitems_i18n].menuname = "root";
#line 1049
  menuitems_i18n[no_menuitems_i18n].shortname = "mfilter";
#line 1049
  menuitems_i18n[no_menuitems_i18n].key = "e";
#line 1049
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1049
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1049
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1049
  tmp___43 = gettext("Filters");
#line 1049
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___43;
#line 1049
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1049
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1049
  no_menuitems_i18n ++;
#line 1050
  menuitems_i18n[no_menuitems_i18n].menuname = "root";
#line 1050
  menuitems_i18n[no_menuitems_i18n].shortname = "ui";
#line 1050
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1050
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1050
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1050
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1050
  tmp___44 = gettext("UI");
#line 1050
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___44;
#line 1050
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1050
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1050
  no_menuitems_i18n ++;
#line 1051
  menuitems_i18n[no_menuitems_i18n].menuname = "root";
#line 1051
  menuitems_i18n[no_menuitems_i18n].shortname = "misc";
#line 1051
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1051
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1051
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1051
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1051
  tmp___45 = gettext("Misc");
#line 1051
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___45;
#line 1051
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1051
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1051
  no_menuitems_i18n ++;
#line 1055
  menuitems_i18n[no_menuitems_i18n].menuname = "root";
#line 1055
  menuitems_i18n[no_menuitems_i18n].shortname = "helpmenu";
#line 1055
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1055
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1055
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1055
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1055
  tmp___46 = gettext("Help");
#line 1055
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___46;
#line 1055
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1055
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1055
  no_menuitems_i18n ++;
#line 1056
  menuitems_i18n[no_menuitems_i18n].menuname = "helpmenu";
#line 1056
  menuitems_i18n[no_menuitems_i18n].shortname = "tutor";
#line 1056
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1056
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1056
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1056
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1056
  tmp___47 = gettext("Tutorials");
#line 1056
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___47;
#line 1056
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1056
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1056
  no_menuitems_i18n ++;
#line 1057
  menuitems_i18n[no_menuitems_i18n].menuname = "animroot";
#line 1057
  menuitems_i18n[no_menuitems_i18n].shortname = "file";
#line 1057
  menuitems_i18n[no_menuitems_i18n].key = "f";
#line 1057
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1057
  menuitems_i18n[no_menuitems_i18n].flags = 32;
#line 1057
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1057
  tmp___48 = gettext("File");
#line 1057
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___48;
#line 1057
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1057
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1057
  no_menuitems_i18n ++;
#line 1066
  menuitems_i18n[no_menuitems_i18n].menuname = "animroot";
#line 1066
  menuitems_i18n[no_menuitems_i18n].shortname = "stopreplay";
#line 1066
  menuitems_i18n[no_menuitems_i18n].key = "s";
#line 1066
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1066
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1066
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1066
  tmp___49 = gettext("Stop replay");
#line 1066
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___49;
#line 1066
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1066
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_replaydisable);
#line 1066
  no_menuitems_i18n ++;
#line 1069
  menuitems_i18n[no_menuitems_i18n].menuname = "animroot";
#line 1069
  menuitems_i18n[no_menuitems_i18n].shortname = "uia";
#line 1069
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1069
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1069
  menuitems_i18n[no_menuitems_i18n].flags = 32;
#line 1069
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1069
  tmp___50 = gettext("UI");
#line 1069
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___50;
#line 1069
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1069
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1069
  no_menuitems_i18n ++;
#line 1070
  menuitems_i18n[no_menuitems_i18n].menuname = "animroot";
#line 1070
  menuitems_i18n[no_menuitems_i18n].shortname = "helpmenu";
#line 1070
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1070
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1070
  menuitems_i18n[no_menuitems_i18n].flags = 32;
#line 1070
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1070
  tmp___51 = gettext("Help");
#line 1070
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___51;
#line 1070
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1070
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1070
  no_menuitems_i18n ++;
#line 1071
  menuitems_i18n[no_menuitems_i18n].menuname = "misc";
#line 1071
  menuitems_i18n[no_menuitems_i18n].shortname = "command";
#line 1071
  menuitems_i18n[no_menuitems_i18n].key = "!";
#line 1071
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1071
  menuitems_i18n[no_menuitems_i18n].flags = 96;
#line 1071
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1071
  tmp___52 = gettext("Command");
#line 1071
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___52;
#line 1071
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)dcommand;
#line 1071
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_command);
#line 1071
  no_menuitems_i18n ++;
#line 1073
  menuitems_i18n[no_menuitems_i18n].menuname = "misc";
#line 1073
  menuitems_i18n[no_menuitems_i18n].shortname = "playstr";
#line 1073
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1073
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1073
  menuitems_i18n[no_menuitems_i18n].flags = 16;
#line 1073
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1073
  tmp___53 = gettext("Play string");
#line 1073
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___53;
#line 1073
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)dcommand;
#line 1073
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playstr);
#line 1073
  no_menuitems_i18n ++;
#line 1075
  menuitems_i18n[no_menuitems_i18n].menuname = "misc";
#line 1075
  menuitems_i18n[no_menuitems_i18n].shortname = "renderanim";
#line 1075
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1075
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1075
  menuitems_i18n[no_menuitems_i18n].flags = 96;
#line 1075
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1075
  tmp___54 = gettext("Render animation");
#line 1075
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___54;
#line 1075
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_renderdialog;
#line 1075
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_render);
#line 1075
  no_menuitems_i18n ++;
#line 1077
  menuitems_i18n[no_menuitems_i18n].menuname = "misc";
#line 1077
  menuitems_i18n[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1077
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)0;
#line 1077
  menuitems_i18n[no_menuitems_i18n].type = 8;
#line 1077
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1077
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1077
  menuitems_i18n[no_menuitems_i18n].name = "";
#line 1077
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1077
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1077
  no_menuitems_i18n ++;
#line 1078
  menuitems_i18n[no_menuitems_i18n].menuname = "misc";
#line 1078
  menuitems_i18n[no_menuitems_i18n].shortname = "clearscreen";
#line 1078
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1078
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1078
  menuitems_i18n[no_menuitems_i18n].flags = 32;
#line 1078
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1078
  tmp___55 = gettext("Clear screen");
#line 1078
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___55;
#line 1078
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1078
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_clearscreen);
#line 1078
  no_menuitems_i18n ++;
#line 1080
  menuitems_i18n[no_menuitems_i18n].menuname = "misc";
#line 1080
  menuitems_i18n[no_menuitems_i18n].shortname = "display";
#line 1080
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1080
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1080
  menuitems_i18n[no_menuitems_i18n].flags = 32;
#line 1080
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1080
  tmp___56 = gettext("Display fractal");
#line 1080
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___56;
#line 1080
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1080
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_display);
#line 1080
  no_menuitems_i18n ++;
#line 1082
  menuitems_i18n[no_menuitems_i18n].menuname = "misc";
#line 1082
  menuitems_i18n[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1082
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)0;
#line 1082
  menuitems_i18n[no_menuitems_i18n].type = 8;
#line 1082
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1082
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1082
  menuitems_i18n[no_menuitems_i18n].name = "";
#line 1082
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1082
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1082
  no_menuitems_i18n ++;
#line 1083
  menuitems_i18n[no_menuitems_i18n].menuname = "misc";
#line 1083
  menuitems_i18n[no_menuitems_i18n].shortname = "text";
#line 1083
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1083
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1083
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1083
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1083
  tmp___57 = gettext("Display text");
#line 1083
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___57;
#line 1083
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)dtextparam;
#line 1083
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_text);
#line 1083
  no_menuitems_i18n ++;
#line 1085
  menuitems_i18n[no_menuitems_i18n].menuname = "misc";
#line 1085
  menuitems_i18n[no_menuitems_i18n].shortname = "color";
#line 1085
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1085
  menuitems_i18n[no_menuitems_i18n].type = 7;
#line 1085
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1085
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1085
  tmp___58 = gettext("Color");
#line 1085
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___58;
#line 1085
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1085
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))((void *)0);
#line 1085
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setcolor);
#line 1085
  menuitems_i18n[no_menuitems_i18n].dialog = (menudialog const   *(*)(struct uih_context * ))(& uih_getcolordialog);
#line 1085
  no_menuitems_i18n ++;
#line 1087
  menuitems_i18n[no_menuitems_i18n].menuname = "misc";
#line 1087
  menuitems_i18n[no_menuitems_i18n].shortname = "xtextpos";
#line 1087
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1087
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1087
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1087
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1087
  tmp___59 = gettext("Horizontal text position");
#line 1087
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___59;
#line 1087
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1087
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1087
  no_menuitems_i18n ++;
#line 1089
  menuitems_i18n[no_menuitems_i18n].menuname = "misc";
#line 1089
  menuitems_i18n[no_menuitems_i18n].shortname = "ytextpos";
#line 1089
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1089
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1089
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1089
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1089
  tmp___60 = gettext("Vertical text position");
#line 1089
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___60;
#line 1089
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1089
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1089
  no_menuitems_i18n ++;
#line 1090
  menuitems_i18n[no_menuitems_i18n].menuname = "misc";
#line 1090
  menuitems_i18n[no_menuitems_i18n].shortname = "textposition";
#line 1090
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1090
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1090
  menuitems_i18n[no_menuitems_i18n].flags = 24;
#line 1090
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1090
  tmp___61 = gettext("Text position");
#line 1090
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___61;
#line 1090
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_textposdialog;
#line 1090
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtextpos);
#line 1090
  no_menuitems_i18n ++;
#line 1095
  menuitems_i18n[no_menuitems_i18n].menuname = "misc";
#line 1095
  menuitems_i18n[no_menuitems_i18n].shortname = "message";
#line 1095
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1095
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1095
  menuitems_i18n[no_menuitems_i18n].flags = 16;
#line 1095
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1095
  tmp___62 = gettext("Message");
#line 1095
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___62;
#line 1095
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)dtextparam;
#line 1095
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playmessage);
#line 1095
  no_menuitems_i18n ++;
#line 1101
  menuitems_i18n[no_menuitems_i18n].menuname = "ytextpos";
#line 1101
  menuitems_i18n[no_menuitems_i18n].shortname = "ytextup";
#line 1101
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1101
  menuitems_i18n[no_menuitems_i18n].type = 3;
#line 1101
  menuitems_i18n[no_menuitems_i18n].flags = 98;
#line 1101
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1101
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1101
  menuitems_i18n[no_menuitems_i18n].name = "Up";
#line 1101
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setytextpos);
#line 1101
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_ytextselected);
#line 1101
  no_menuitems_i18n ++;
#line 1103
  menuitems_i18n[no_menuitems_i18n].menuname = "ytextpos";
#line 1103
  menuitems_i18n[no_menuitems_i18n].shortname = "ytextmiddle";
#line 1103
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1103
  menuitems_i18n[no_menuitems_i18n].type = 3;
#line 1103
  menuitems_i18n[no_menuitems_i18n].flags = 98;
#line 1103
  menuitems_i18n[no_menuitems_i18n].iparam = 1;
#line 1103
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1103
  menuitems_i18n[no_menuitems_i18n].name = "Middle";
#line 1103
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setytextpos);
#line 1103
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_ytextselected);
#line 1103
  no_menuitems_i18n ++;
#line 1107
  menuitems_i18n[no_menuitems_i18n].menuname = "ytextpos";
#line 1107
  menuitems_i18n[no_menuitems_i18n].shortname = "ytextbottom";
#line 1107
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1107
  menuitems_i18n[no_menuitems_i18n].type = 3;
#line 1107
  menuitems_i18n[no_menuitems_i18n].flags = 98;
#line 1107
  menuitems_i18n[no_menuitems_i18n].iparam = 2;
#line 1107
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1107
  menuitems_i18n[no_menuitems_i18n].name = "Bottom";
#line 1107
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setytextpos);
#line 1107
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_ytextselected);
#line 1107
  no_menuitems_i18n ++;
#line 1109
  menuitems_i18n[no_menuitems_i18n].menuname = "xtextpos";
#line 1109
  menuitems_i18n[no_menuitems_i18n].shortname = "xtextleft";
#line 1109
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1109
  menuitems_i18n[no_menuitems_i18n].type = 3;
#line 1109
  menuitems_i18n[no_menuitems_i18n].flags = 98;
#line 1109
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1109
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1109
  menuitems_i18n[no_menuitems_i18n].name = "Left";
#line 1109
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setxtextpos);
#line 1109
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_xtextselected);
#line 1109
  no_menuitems_i18n ++;
#line 1112
  menuitems_i18n[no_menuitems_i18n].menuname = "xtextpos";
#line 1112
  menuitems_i18n[no_menuitems_i18n].shortname = "xtextcenter";
#line 1112
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1112
  menuitems_i18n[no_menuitems_i18n].type = 3;
#line 1112
  menuitems_i18n[no_menuitems_i18n].flags = 98;
#line 1112
  menuitems_i18n[no_menuitems_i18n].iparam = 1;
#line 1112
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1112
  menuitems_i18n[no_menuitems_i18n].name = "Center";
#line 1112
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setxtextpos);
#line 1112
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_xtextselected);
#line 1112
  no_menuitems_i18n ++;
#line 1114
  menuitems_i18n[no_menuitems_i18n].menuname = "xtextpos";
#line 1114
  menuitems_i18n[no_menuitems_i18n].shortname = "xtexteight";
#line 1114
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1114
  menuitems_i18n[no_menuitems_i18n].type = 3;
#line 1114
  menuitems_i18n[no_menuitems_i18n].flags = 98;
#line 1114
  menuitems_i18n[no_menuitems_i18n].iparam = 2;
#line 1114
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1114
  menuitems_i18n[no_menuitems_i18n].name = "Right";
#line 1114
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setxtextpos);
#line 1114
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_xtextselected);
#line 1114
  no_menuitems_i18n ++;
#line 1117
  menuitems_i18n[no_menuitems_i18n].menuname = "file";
#line 1117
  menuitems_i18n[no_menuitems_i18n].shortname = "loadpos";
#line 1117
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1117
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1117
  menuitems_i18n[no_menuitems_i18n].flags = 68;
#line 1117
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1117
  tmp___63 = gettext("Load");
#line 1117
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___63;
#line 1117
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)loaddialog;
#line 1117
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_loadfile);
#line 1117
  no_menuitems_i18n ++;
#line 1120
  menuitems_i18n[no_menuitems_i18n].menuname = "file";
#line 1120
  menuitems_i18n[no_menuitems_i18n].shortname = "savepos";
#line 1120
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1120
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1120
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1120
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1120
  tmp___64 = gettext("Save");
#line 1120
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___64;
#line 1120
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)saveposdialog;
#line 1120
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_saveposfile);
#line 1120
  no_menuitems_i18n ++;
#line 1122
  menuitems_i18n[no_menuitems_i18n].menuname = "file";
#line 1122
  menuitems_i18n[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1122
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)0;
#line 1122
  menuitems_i18n[no_menuitems_i18n].type = 8;
#line 1122
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1122
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1122
  menuitems_i18n[no_menuitems_i18n].name = "";
#line 1122
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1122
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1122
  no_menuitems_i18n ++;
#line 1122
  menuitems_i18n[no_menuitems_i18n].menuname = "file";
#line 1122
  menuitems_i18n[no_menuitems_i18n].shortname = "record";
#line 1122
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1122
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1122
  menuitems_i18n[no_menuitems_i18n].flags = 1;
#line 1122
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1122
  tmp___65 = gettext("Record");
#line 1122
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___65;
#line 1122
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)saveanimdialog;
#line 1122
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_saveanimfile);
#line 1122
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_saveanimenabled);
#line 1122
  no_menuitems_i18n ++;
#line 1126
  menuitems_i18n[no_menuitems_i18n].menuname = "file";
#line 1126
  menuitems_i18n[no_menuitems_i18n].shortname = "play";
#line 1126
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1126
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1126
  menuitems_i18n[no_menuitems_i18n].flags = 68;
#line 1126
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1126
  tmp___66 = gettext("Replay");
#line 1126
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___66;
#line 1126
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)playdialog;
#line 1126
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playfile);
#line 1126
  no_menuitems_i18n ++;
#line 1129
  menuitems_i18n[no_menuitems_i18n].menuname = "file";
#line 1129
  menuitems_i18n[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1129
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)0;
#line 1129
  menuitems_i18n[no_menuitems_i18n].type = 8;
#line 1129
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1129
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1129
  menuitems_i18n[no_menuitems_i18n].name = "";
#line 1129
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1129
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1129
  no_menuitems_i18n ++;
#line 1130
  menuitems_i18n[no_menuitems_i18n].menuname = "file";
#line 1130
  menuitems_i18n[no_menuitems_i18n].shortname = "saveimg";
#line 1130
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1130
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1130
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1130
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1130
  tmp___67 = gettext("Save image");
#line 1130
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___67;
#line 1130
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)saveimgdialog;
#line 1130
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_savepngfile);
#line 1130
  no_menuitems_i18n ++;
#line 1135
  menuitems_i18n[no_menuitems_i18n].menuname = "file";
#line 1135
  menuitems_i18n[no_menuitems_i18n].shortname = "loadexample";
#line 1135
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1135
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1135
  menuitems_i18n[no_menuitems_i18n].flags = 4;
#line 1135
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1135
  tmp___68 = gettext("Load random example");
#line 1135
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___68;
#line 1135
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1135
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_loadexample);
#line 1135
  no_menuitems_i18n ++;
#line 1137
  menuitems_i18n[no_menuitems_i18n].menuname = "file";
#line 1137
  menuitems_i18n[no_menuitems_i18n].shortname = "savecfg";
#line 1137
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1137
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1137
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1137
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1137
  tmp___69 = gettext("Save configuration");
#line 1137
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___69;
#line 1137
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1137
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_savecfg);
#line 1137
  no_menuitems_i18n ++;
#line 1140
  menuitems_i18n[no_menuitems_i18n].menuname = "file";
#line 1140
  menuitems_i18n[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1140
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)0;
#line 1140
  menuitems_i18n[no_menuitems_i18n].type = 8;
#line 1140
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1140
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1140
  menuitems_i18n[no_menuitems_i18n].name = "";
#line 1140
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1140
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1140
  no_menuitems_i18n ++;
#line 1142
  menuitems_i18n[no_menuitems_i18n].menuname = "edit";
#line 1142
  menuitems_i18n[no_menuitems_i18n].shortname = "undo";
#line 1142
  menuitems_i18n[no_menuitems_i18n].key = "u";
#line 1142
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1142
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1142
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1142
  tmp___70 = gettext("Undo");
#line 1142
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___70;
#line 1142
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1142
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_undo);
#line 1142
  no_menuitems_i18n ++;
#line 1145
  menuitems_i18n[no_menuitems_i18n].menuname = "edit";
#line 1145
  menuitems_i18n[no_menuitems_i18n].shortname = "redo";
#line 1145
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1145
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1145
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1145
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1145
  tmp___71 = gettext("Redo");
#line 1145
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___71;
#line 1145
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1145
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_redo);
#line 1145
  no_menuitems_i18n ++;
#line 1150
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1150
  menuitems_i18n[no_menuitems_i18n].shortname = "mformula";
#line 1150
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1150
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1150
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1150
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1150
  tmp___72 = gettext("Formulae");
#line 1150
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___72;
#line 1150
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1150
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1150
  no_menuitems_i18n ++;
#line 1151
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1151
  menuitems_i18n[no_menuitems_i18n].shortname = "oformula";
#line 1151
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1151
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1151
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1151
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1151
  tmp___73 = gettext("More formulae");
#line 1151
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___73;
#line 1151
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1151
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1151
  no_menuitems_i18n ++;
#line 1162
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1162
  menuitems_i18n[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1162
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)0;
#line 1162
  menuitems_i18n[no_menuitems_i18n].type = 8;
#line 1162
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1162
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1162
  menuitems_i18n[no_menuitems_i18n].name = "";
#line 1162
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1162
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1162
  no_menuitems_i18n ++;
#line 1163
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1163
  menuitems_i18n[no_menuitems_i18n].shortname = "mincoloring";
#line 1163
  menuitems_i18n[no_menuitems_i18n].key = "f";
#line 1163
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1163
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1163
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1163
  tmp___74 = gettext("Incoloring mode");
#line 1163
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___74;
#line 1163
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1163
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1163
  no_menuitems_i18n ++;
#line 1164
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1164
  menuitems_i18n[no_menuitems_i18n].shortname = "moutcoloring";
#line 1164
  menuitems_i18n[no_menuitems_i18n].key = "c";
#line 1164
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1164
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1164
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1164
  tmp___75 = gettext("Outcoloring mode");
#line 1164
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___75;
#line 1164
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1164
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1164
  no_menuitems_i18n ++;
#line 1165
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1165
  menuitems_i18n[no_menuitems_i18n].shortname = "mplane";
#line 1165
  menuitems_i18n[no_menuitems_i18n].key = "i";
#line 1165
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1165
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1165
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1165
  tmp___76 = gettext("Plane");
#line 1165
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___76;
#line 1165
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1165
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1165
  no_menuitems_i18n ++;
#line 1166
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1166
  menuitems_i18n[no_menuitems_i18n].shortname = "palettemenu";
#line 1166
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1166
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1166
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1166
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1166
  tmp___77 = gettext("Palette");
#line 1166
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___77;
#line 1166
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1166
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1166
  no_menuitems_i18n ++;
#line 1167
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1167
  menuitems_i18n[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1167
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)0;
#line 1167
  menuitems_i18n[no_menuitems_i18n].type = 8;
#line 1167
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1167
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1167
  menuitems_i18n[no_menuitems_i18n].name = "";
#line 1167
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1167
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1167
  no_menuitems_i18n ++;
#line 1168
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1168
  menuitems_i18n[no_menuitems_i18n].shortname = "uimandelbrot";
#line 1168
  menuitems_i18n[no_menuitems_i18n].key = "m";
#line 1168
  menuitems_i18n[no_menuitems_i18n].type = 7;
#line 1168
  menuitems_i18n[no_menuitems_i18n].flags = 357;
#line 1168
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1168
  tmp___78 = gettext("Mandelbrot mode");
#line 1168
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___78;
#line 1168
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)(& uih_getjuliadialog);
#line 1168
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_mandelbrotsw);
#line 1168
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_mandelbrotselected);
#line 1168
  menuitems_i18n[no_menuitems_i18n].dialog = (menudialog const   *(*)(struct uih_context * ))(& uih_getjuliadialog);
#line 1168
  no_menuitems_i18n ++;
#line 1175
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1175
  menuitems_i18n[no_menuitems_i18n].shortname = "uiperturbation";
#line 1175
  menuitems_i18n[no_menuitems_i18n].key = "b";
#line 1175
  menuitems_i18n[no_menuitems_i18n].type = 7;
#line 1175
  menuitems_i18n[no_menuitems_i18n].flags = 101;
#line 1175
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1175
  tmp___79 = gettext("Perturbation");
#line 1175
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___79;
#line 1175
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)(& uih_getperturbationdialog);
#line 1175
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_persw);
#line 1175
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_perselected);
#line 1175
  menuitems_i18n[no_menuitems_i18n].dialog = (menudialog const   *(*)(struct uih_context * ))(& uih_getperturbationdialog);
#line 1175
  no_menuitems_i18n ++;
#line 1178
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1178
  menuitems_i18n[no_menuitems_i18n].shortname = "perturbation";
#line 1178
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1178
  menuitems_i18n[no_menuitems_i18n].type = 7;
#line 1178
  menuitems_i18n[no_menuitems_i18n].flags = 20;
#line 1178
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1178
  tmp___80 = gettext("Perturbation");
#line 1178
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___80;
#line 1178
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1178
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))((void *)0);
#line 1178
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setperbutation);
#line 1178
  menuitems_i18n[no_menuitems_i18n].dialog = (menudialog const   *(*)(struct uih_context * ))(& uih_getperturbationdialog);
#line 1178
  no_menuitems_i18n ++;
#line 1184
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1184
  menuitems_i18n[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1184
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)0;
#line 1184
  menuitems_i18n[no_menuitems_i18n].type = 8;
#line 1184
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1184
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1184
  menuitems_i18n[no_menuitems_i18n].name = "";
#line 1184
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1184
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1184
  no_menuitems_i18n ++;
#line 1185
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1185
  menuitems_i18n[no_menuitems_i18n].shortname = "uiview";
#line 1185
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1185
  menuitems_i18n[no_menuitems_i18n].type = 7;
#line 1185
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1185
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1185
  tmp___81 = gettext("View");
#line 1185
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___81;
#line 1185
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1185
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))((void *)0);
#line 1185
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_dview);
#line 1185
  menuitems_i18n[no_menuitems_i18n].dialog = (menudialog const   *(*)(struct uih_context * ))(& uih_getviewdialog);
#line 1185
  no_menuitems_i18n ++;
#line 1188
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1188
  menuitems_i18n[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1188
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)0;
#line 1188
  menuitems_i18n[no_menuitems_i18n].type = 8;
#line 1188
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1188
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1188
  menuitems_i18n[no_menuitems_i18n].name = "";
#line 1188
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1188
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1188
  no_menuitems_i18n ++;
#line 1189
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1189
  menuitems_i18n[no_menuitems_i18n].shortname = "initstate";
#line 1189
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1189
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1189
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1189
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1189
  tmp___82 = gettext("Reset to defaults");
#line 1189
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___82;
#line 1189
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1189
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_initstate);
#line 1189
  no_menuitems_i18n ++;
#line 1191
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1191
  menuitems_i18n[no_menuitems_i18n].shortname = "julia";
#line 1191
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1191
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1191
  menuitems_i18n[no_menuitems_i18n].flags = 20;
#line 1191
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1191
  tmp___83 = gettext("Julia mode");
#line 1191
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___83;
#line 1191
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_juliamodedialog;
#line 1191
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playjulia);
#line 1191
  no_menuitems_i18n ++;
#line 1194
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1194
  menuitems_i18n[no_menuitems_i18n].shortname = "view";
#line 1194
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1194
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1194
  menuitems_i18n[no_menuitems_i18n].flags = 20;
#line 1194
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1194
  tmp___84 = gettext("View");
#line 1194
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___84;
#line 1194
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_plviewdialog;
#line 1194
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_plview);
#line 1194
  no_menuitems_i18n ++;
#line 1198
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1198
  menuitems_i18n[no_menuitems_i18n].shortname = "angle";
#line 1198
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1198
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1198
  menuitems_i18n[no_menuitems_i18n].flags = 20;
#line 1198
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1198
  tmp___85 = gettext("Set angle");
#line 1198
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___85;
#line 1198
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_angledialog;
#line 1198
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_angle);
#line 1198
  no_menuitems_i18n ++;
#line 1201
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1201
  menuitems_i18n[no_menuitems_i18n].shortname = "plane";
#line 1201
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1201
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1201
  menuitems_i18n[no_menuitems_i18n].flags = 20;
#line 1201
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1201
  tmp___86 = gettext("Set plane");
#line 1201
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___86;
#line 1201
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_numdialog;
#line 1201
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setplane);
#line 1201
  no_menuitems_i18n ++;
#line 1206
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1206
  menuitems_i18n[no_menuitems_i18n].shortname = "incoloring";
#line 1206
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1206
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1206
  menuitems_i18n[no_menuitems_i18n].flags = 20;
#line 1206
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1206
  tmp___87 = gettext("Inside coloring mode");
#line 1206
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___87;
#line 1206
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_numdialog;
#line 1206
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setincoloringmode);
#line 1206
  no_menuitems_i18n ++;
#line 1209
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1209
  menuitems_i18n[no_menuitems_i18n].shortname = "outcoloring";
#line 1209
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1209
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1209
  menuitems_i18n[no_menuitems_i18n].flags = 20;
#line 1209
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1209
  tmp___88 = gettext("Outside coloring mode");
#line 1209
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___88;
#line 1209
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_numdialog;
#line 1209
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setoutcoloringmode);
#line 1209
  no_menuitems_i18n ++;
#line 1216
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1216
  menuitems_i18n[no_menuitems_i18n].shortname = "intcoloring";
#line 1216
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1216
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1216
  menuitems_i18n[no_menuitems_i18n].flags = 20;
#line 1216
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1216
  tmp___89 = gettext("Inside truecolor coloring mode");
#line 1216
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___89;
#line 1216
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_numdialog;
#line 1216
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setintcolor);
#line 1216
  no_menuitems_i18n ++;
#line 1220
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1220
  menuitems_i18n[no_menuitems_i18n].shortname = "outtcoloring";
#line 1220
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1220
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1220
  menuitems_i18n[no_menuitems_i18n].flags = 20;
#line 1220
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1220
  tmp___90 = gettext("Outside truecolor coloring mode");
#line 1220
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___90;
#line 1220
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_numdialog;
#line 1220
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setouttcolor);
#line 1220
  no_menuitems_i18n ++;
#line 1224
  menuitems_i18n[no_menuitems_i18n].menuname = "fractal";
#line 1224
  menuitems_i18n[no_menuitems_i18n].shortname = "juliaseed";
#line 1224
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1224
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1224
  menuitems_i18n[no_menuitems_i18n].flags = 20;
#line 1224
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1224
  tmp___91 = gettext("Julia seed");
#line 1224
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___91;
#line 1224
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_coorddialog;
#line 1224
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setjuliaseed);
#line 1224
  no_menuitems_i18n ++;
#line 1227
  menuitems_i18n[no_menuitems_i18n].menuname = "palettemenu";
#line 1227
  menuitems_i18n[no_menuitems_i18n].shortname = "defpalette";
#line 1227
  menuitems_i18n[no_menuitems_i18n].key = "d";
#line 1227
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1227
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1227
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1227
  tmp___92 = gettext("Default palette");
#line 1227
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___92;
#line 1227
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1227
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_mkdefaultpalette);
#line 1227
  no_menuitems_i18n ++;
#line 1229
  menuitems_i18n[no_menuitems_i18n].menuname = "palettemenu";
#line 1229
  menuitems_i18n[no_menuitems_i18n].shortname = "randompalette";
#line 1229
  menuitems_i18n[no_menuitems_i18n].key = "p";
#line 1229
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1229
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1229
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1229
  tmp___93 = gettext("Random palette");
#line 1229
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___93;
#line 1229
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1229
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_menumkpalette);
#line 1229
  no_menuitems_i18n ++;
#line 1231
  menuitems_i18n[no_menuitems_i18n].menuname = "palettemenu";
#line 1231
  menuitems_i18n[no_menuitems_i18n].shortname = "palette";
#line 1231
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1231
  menuitems_i18n[no_menuitems_i18n].type = 7;
#line 1231
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1231
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1231
  tmp___94 = gettext("Custom palette");
#line 1231
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___94;
#line 1231
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1231
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))((void *)0);
#line 1231
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_palette);
#line 1231
  menuitems_i18n[no_menuitems_i18n].dialog = (menudialog const   *(*)(struct uih_context * ))(& uih_getpalettedialog);
#line 1231
  no_menuitems_i18n ++;
#line 1233
  menuitems_i18n[no_menuitems_i18n].menuname = "palettemenu";
#line 1233
  menuitems_i18n[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1233
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)0;
#line 1233
  menuitems_i18n[no_menuitems_i18n].type = 8;
#line 1233
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1233
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1233
  menuitems_i18n[no_menuitems_i18n].name = "";
#line 1233
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1233
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1233
  no_menuitems_i18n ++;
#line 1234
  menuitems_i18n[no_menuitems_i18n].menuname = "palettemenu";
#line 1234
  menuitems_i18n[no_menuitems_i18n].shortname = "cycling";
#line 1234
  menuitems_i18n[no_menuitems_i18n].key = "y";
#line 1234
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1234
  menuitems_i18n[no_menuitems_i18n].flags = 1;
#line 1234
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1234
  tmp___95 = gettext("Color cycling");
#line 1234
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___95;
#line 1234
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1234
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_cyclingsw);
#line 1234
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_cyclingselected);
#line 1234
  no_menuitems_i18n ++;
#line 1237
  menuitems_i18n[no_menuitems_i18n].menuname = "palettemenu";
#line 1237
  menuitems_i18n[no_menuitems_i18n].shortname = "rcycling";
#line 1237
  menuitems_i18n[no_menuitems_i18n].key = "Y";
#line 1237
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1237
  menuitems_i18n[no_menuitems_i18n].flags = 97;
#line 1237
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1237
  tmp___96 = gettext("Reversed color cycling");
#line 1237
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___96;
#line 1237
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1237
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_rcyclingsw);
#line 1237
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_rcyclingselected);
#line 1237
  no_menuitems_i18n ++;
#line 1240
  menuitems_i18n[no_menuitems_i18n].menuname = "palettemenu";
#line 1240
  menuitems_i18n[no_menuitems_i18n].shortname = "cyclingspeed";
#line 1240
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1240
  menuitems_i18n[no_menuitems_i18n].type = 7;
#line 1240
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1240
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1240
  tmp___97 = gettext("Color cycling speed");
#line 1240
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___97;
#line 1240
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1240
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))((void *)0);
#line 1240
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setcycling);
#line 1240
  menuitems_i18n[no_menuitems_i18n].dialog = (menudialog const   *(*)(struct uih_context * ))(& uih_getcyclingdialog);
#line 1240
  no_menuitems_i18n ++;
#line 1244
  menuitems_i18n[no_menuitems_i18n].menuname = "palettemenu";
#line 1244
  menuitems_i18n[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1244
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)0;
#line 1244
  menuitems_i18n[no_menuitems_i18n].type = 8;
#line 1244
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1244
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1244
  menuitems_i18n[no_menuitems_i18n].name = "";
#line 1244
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1244
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1244
  no_menuitems_i18n ++;
#line 1245
  menuitems_i18n[no_menuitems_i18n].menuname = "palettemenu";
#line 1245
  menuitems_i18n[no_menuitems_i18n].shortname = "shiftpalette";
#line 1245
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1245
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1245
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1245
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1245
  tmp___98 = gettext("Shift palette");
#line 1245
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___98;
#line 1245
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_shiftdialog;
#line 1245
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_shiftpalette);
#line 1245
  no_menuitems_i18n ++;
#line 1248
  menuitems_i18n[no_menuitems_i18n].menuname = "palettemenu";
#line 1248
  menuitems_i18n[no_menuitems_i18n].shortname = "fshift";
#line 1248
  menuitems_i18n[no_menuitems_i18n].key = "+";
#line 1248
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1248
  menuitems_i18n[no_menuitems_i18n].flags = 96;
#line 1248
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1248
  tmp___99 = gettext("Shift one forward");
#line 1248
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___99;
#line 1248
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1248
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_fshift);
#line 1248
  no_menuitems_i18n ++;
#line 1250
  menuitems_i18n[no_menuitems_i18n].menuname = "palettemenu";
#line 1250
  menuitems_i18n[no_menuitems_i18n].shortname = "bshift";
#line 1250
  menuitems_i18n[no_menuitems_i18n].key = "-";
#line 1250
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1250
  menuitems_i18n[no_menuitems_i18n].flags = 96;
#line 1250
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1250
  tmp___100 = gettext("Shift one backward");
#line 1250
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___100;
#line 1250
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1250
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_bshift);
#line 1250
  no_menuitems_i18n ++;
#line 1253
  menuitems_i18n[no_menuitems_i18n].menuname = "calc";
#line 1253
  menuitems_i18n[no_menuitems_i18n].shortname = "mguess";
#line 1253
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1253
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1253
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1253
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1253
  tmp___101 = gettext("Solid guessing");
#line 1253
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___101;
#line 1253
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1253
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1253
  no_menuitems_i18n ++;
#line 1254
  menuitems_i18n[no_menuitems_i18n].menuname = "calc";
#line 1254
  menuitems_i18n[no_menuitems_i18n].shortname = "dynamic";
#line 1254
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1254
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1254
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1254
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1254
  tmp___102 = gettext("Dynamic resolution");
#line 1254
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___102;
#line 1254
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1254
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1254
  no_menuitems_i18n ++;
#line 1255
  menuitems_i18n[no_menuitems_i18n].menuname = "calc";
#line 1255
  menuitems_i18n[no_menuitems_i18n].shortname = "periodicity";
#line 1255
  menuitems_i18n[no_menuitems_i18n].key = "k";
#line 1255
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1255
  menuitems_i18n[no_menuitems_i18n].flags = 1;
#line 1255
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1255
  tmp___103 = gettext("Periodicity checking");
#line 1255
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___103;
#line 1255
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1255
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_periodicitysw);
#line 1255
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_periodicityselected);
#line 1255
  no_menuitems_i18n ++;
#line 1259
  menuitems_i18n[no_menuitems_i18n].menuname = "calc";
#line 1259
  menuitems_i18n[no_menuitems_i18n].shortname = "maxiter";
#line 1259
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1259
  menuitems_i18n[no_menuitems_i18n].type = 7;
#line 1259
  menuitems_i18n[no_menuitems_i18n].flags = 4;
#line 1259
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1259
  tmp___104 = gettext("Iterations");
#line 1259
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___104;
#line 1259
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1259
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))((void *)0);
#line 1259
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setmaxiter);
#line 1259
  menuitems_i18n[no_menuitems_i18n].dialog = (menudialog const   *(*)(struct uih_context * ))(& uih_getiterdialog);
#line 1259
  no_menuitems_i18n ++;
#line 1261
  menuitems_i18n[no_menuitems_i18n].menuname = "calc";
#line 1261
  menuitems_i18n[no_menuitems_i18n].shortname = "bailout";
#line 1261
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1261
  menuitems_i18n[no_menuitems_i18n].type = 7;
#line 1261
  menuitems_i18n[no_menuitems_i18n].flags = 4;
#line 1261
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1261
  tmp___105 = gettext("Bailout");
#line 1261
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___105;
#line 1261
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1261
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))((void *)0);
#line 1261
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setbailout);
#line 1261
  menuitems_i18n[no_menuitems_i18n].dialog = (menudialog const   *(*)(struct uih_context * ))(& uih_getbailoutdialog);
#line 1261
  no_menuitems_i18n ++;
#line 1264
  menuitems_i18n[no_menuitems_i18n].menuname = "calc";
#line 1264
  menuitems_i18n[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1264
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)0;
#line 1264
  menuitems_i18n[no_menuitems_i18n].type = 8;
#line 1264
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1264
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1264
  menuitems_i18n[no_menuitems_i18n].name = "";
#line 1264
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1264
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1264
  no_menuitems_i18n ++;
#line 1265
  menuitems_i18n[no_menuitems_i18n].menuname = "calc";
#line 1265
  menuitems_i18n[no_menuitems_i18n].shortname = "fastjulia";
#line 1265
  menuitems_i18n[no_menuitems_i18n].key = "j";
#line 1265
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1265
  menuitems_i18n[no_menuitems_i18n].flags = 1;
#line 1265
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1265
  tmp___106 = gettext("Fast julia mode");
#line 1265
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___106;
#line 1265
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1265
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_juliasw);
#line 1265
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_juliaselected);
#line 1265
  no_menuitems_i18n ++;
#line 1267
  menuitems_i18n[no_menuitems_i18n].menuname = "calc";
#line 1267
  menuitems_i18n[no_menuitems_i18n].shortname = "rotate";
#line 1267
  menuitems_i18n[no_menuitems_i18n].key = "o";
#line 1267
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1267
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1267
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1267
  tmp___107 = gettext("Rotation");
#line 1267
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___107;
#line 1267
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1267
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1267
  no_menuitems_i18n ++;
#line 1268
  menuitems_i18n[no_menuitems_i18n].menuname = "calc";
#line 1268
  menuitems_i18n[no_menuitems_i18n].shortname = "range";
#line 1268
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1268
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1268
  menuitems_i18n[no_menuitems_i18n].flags = 16;
#line 1268
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1268
  tmp___108 = gettext("Solid guessing range");
#line 1268
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___108;
#line 1268
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_numdialog;
#line 1268
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setguessing);
#line 1268
  no_menuitems_i18n ++;
#line 1270
  menuitems_i18n[no_menuitems_i18n].menuname = "rotate";
#line 1270
  menuitems_i18n[no_menuitems_i18n].shortname = "norotate";
#line 1270
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1270
  menuitems_i18n[no_menuitems_i18n].type = 3;
#line 1270
  menuitems_i18n[no_menuitems_i18n].flags = 98;
#line 1270
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1270
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1270
  tmp___109 = gettext("Disable rotation");
#line 1270
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___109;
#line 1270
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_rotate);
#line 1270
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_rotateselected);
#line 1270
  no_menuitems_i18n ++;
#line 1273
  menuitems_i18n[no_menuitems_i18n].menuname = "rotate";
#line 1273
  menuitems_i18n[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1273
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)0;
#line 1273
  menuitems_i18n[no_menuitems_i18n].type = 8;
#line 1273
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1273
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1273
  menuitems_i18n[no_menuitems_i18n].name = "";
#line 1273
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1273
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1273
  no_menuitems_i18n ++;
#line 1274
  menuitems_i18n[no_menuitems_i18n].menuname = "rotate";
#line 1274
  menuitems_i18n[no_menuitems_i18n].shortname = "controtate";
#line 1274
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1274
  menuitems_i18n[no_menuitems_i18n].type = 3;
#line 1274
  menuitems_i18n[no_menuitems_i18n].flags = 98;
#line 1274
  menuitems_i18n[no_menuitems_i18n].iparam = 2;
#line 1274
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1274
  tmp___110 = gettext("Continuous rotation");
#line 1274
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___110;
#line 1274
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_rotate);
#line 1274
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_rotateselected);
#line 1274
  no_menuitems_i18n ++;
#line 1278
  menuitems_i18n[no_menuitems_i18n].menuname = "rotate";
#line 1278
  menuitems_i18n[no_menuitems_i18n].shortname = "mouserotate";
#line 1278
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1278
  menuitems_i18n[no_menuitems_i18n].type = 3;
#line 1278
  menuitems_i18n[no_menuitems_i18n].flags = 98;
#line 1278
  menuitems_i18n[no_menuitems_i18n].iparam = 1;
#line 1278
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1278
  tmp___111 = gettext("Rotate by mouse");
#line 1278
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___111;
#line 1278
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_rotate);
#line 1278
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_rotateselected);
#line 1278
  no_menuitems_i18n ++;
#line 1280
  menuitems_i18n[no_menuitems_i18n].menuname = "rotate";
#line 1280
  menuitems_i18n[no_menuitems_i18n].shortname = "rotationspeed";
#line 1280
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1280
  menuitems_i18n[no_menuitems_i18n].type = 7;
#line 1280
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1280
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1280
  tmp___112 = gettext("Rotation speed");
#line 1280
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___112;
#line 1280
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1280
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))((void *)0);
#line 1280
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_rotationspeed);
#line 1280
  menuitems_i18n[no_menuitems_i18n].dialog = (menudialog const   *(*)(struct uih_context * ))(& uih_getrotationdialog);
#line 1280
  no_menuitems_i18n ++;
#line 1285
  menuitems_i18n[no_menuitems_i18n].menuname = "rotate";
#line 1285
  menuitems_i18n[no_menuitems_i18n].shortname = "autorotate";
#line 1285
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1285
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1285
  menuitems_i18n[no_menuitems_i18n].flags = 16;
#line 1285
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1285
  tmp___113 = gettext("Automatic rotation");
#line 1285
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___113;
#line 1285
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_autorotatedialog;
#line 1285
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playautorotate);
#line 1285
  no_menuitems_i18n ++;
#line 1288
  menuitems_i18n[no_menuitems_i18n].menuname = "rotate";
#line 1288
  menuitems_i18n[no_menuitems_i18n].shortname = "fastrotate";
#line 1288
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1288
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1288
  menuitems_i18n[no_menuitems_i18n].flags = 16;
#line 1288
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1288
  tmp___114 = gettext("Fast rotation mode");
#line 1288
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___114;
#line 1288
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_fastrotatedialog;
#line 1288
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_fastrotate);
#line 1288
  no_menuitems_i18n ++;
#line 1294
  menuitems_i18n[no_menuitems_i18n].menuname = "dynamic";
#line 1294
  menuitems_i18n[no_menuitems_i18n].shortname = "nodynamic";
#line 1294
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1294
  menuitems_i18n[no_menuitems_i18n].type = 3;
#line 1294
  menuitems_i18n[no_menuitems_i18n].flags = 98;
#line 1294
  menuitems_i18n[no_menuitems_i18n].iparam = 1;
#line 1294
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1294
  tmp___115 = gettext("Disable dynamic resolution");
#line 1294
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___115;
#line 1294
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setfastmode);
#line 1294
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_fastmode);
#line 1294
  no_menuitems_i18n ++;
#line 1296
  menuitems_i18n[no_menuitems_i18n].menuname = "dynamic";
#line 1296
  menuitems_i18n[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1296
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)0;
#line 1296
  menuitems_i18n[no_menuitems_i18n].type = 8;
#line 1296
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1296
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1296
  menuitems_i18n[no_menuitems_i18n].name = "";
#line 1296
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1296
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1296
  no_menuitems_i18n ++;
#line 1297
  menuitems_i18n[no_menuitems_i18n].menuname = "dynamic";
#line 1297
  menuitems_i18n[no_menuitems_i18n].shortname = "dynamicanimation";
#line 1297
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1297
  menuitems_i18n[no_menuitems_i18n].type = 3;
#line 1297
  menuitems_i18n[no_menuitems_i18n].flags = 98;
#line 1297
  menuitems_i18n[no_menuitems_i18n].iparam = 2;
#line 1297
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1297
  tmp___116 = gettext("Use only during animation");
#line 1297
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___116;
#line 1297
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setfastmode);
#line 1297
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_fastmode);
#line 1297
  no_menuitems_i18n ++;
#line 1299
  menuitems_i18n[no_menuitems_i18n].menuname = "dynamic";
#line 1299
  menuitems_i18n[no_menuitems_i18n].shortname = "dynamicnew";
#line 1299
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1299
  menuitems_i18n[no_menuitems_i18n].type = 3;
#line 1299
  menuitems_i18n[no_menuitems_i18n].flags = 98;
#line 1299
  menuitems_i18n[no_menuitems_i18n].iparam = 3;
#line 1299
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1299
  tmp___117 = gettext("Use also for new images");
#line 1299
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___117;
#line 1299
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setfastmode);
#line 1299
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_fastmode);
#line 1299
  no_menuitems_i18n ++;
#line 1303
  menuitems_i18n[no_menuitems_i18n].menuname = "dynamic";
#line 1303
  menuitems_i18n[no_menuitems_i18n].shortname = "fastmode";
#line 1303
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1303
  menuitems_i18n[no_menuitems_i18n].type = 6;
#line 1303
  menuitems_i18n[no_menuitems_i18n].flags = 16;
#line 1303
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1303
  tmp___118 = gettext("Dynamic resolution mode");
#line 1303
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___118;
#line 1303
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)uih_fastmodedialog;
#line 1303
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setfastmode);
#line 1303
  no_menuitems_i18n ++;
#line 1306
  menuitems_i18n[no_menuitems_i18n].menuname = "ui";
#line 1306
  menuitems_i18n[no_menuitems_i18n].shortname = "autopilot";
#line 1306
  menuitems_i18n[no_menuitems_i18n].key = "a";
#line 1306
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1306
  menuitems_i18n[no_menuitems_i18n].flags = 1;
#line 1306
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1306
  tmp___119 = gettext("Autopilot");
#line 1306
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___119;
#line 1306
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1306
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_autopilotsw);
#line 1306
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_autopilotselected);
#line 1306
  no_menuitems_i18n ++;
#line 1309
  menuitems_i18n[no_menuitems_i18n].menuname = "ui";
#line 1309
  menuitems_i18n[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1309
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)0;
#line 1309
  menuitems_i18n[no_menuitems_i18n].type = 8;
#line 1309
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1309
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1309
  menuitems_i18n[no_menuitems_i18n].name = "";
#line 1309
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1309
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1309
  no_menuitems_i18n ++;
#line 1310
  menuitems_i18n[no_menuitems_i18n].menuname = "ui";
#line 1310
  menuitems_i18n[no_menuitems_i18n].shortname = "inhibittextoutput";
#line 1310
  menuitems_i18n[no_menuitems_i18n].key = "v";
#line 1310
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1310
  menuitems_i18n[no_menuitems_i18n].flags = 1;
#line 1310
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1310
  tmp___120 = gettext("VJ mode");
#line 1310
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___120;
#line 1310
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1310
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_inhibittextsw);
#line 1310
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_inhibittextselected);
#line 1310
  no_menuitems_i18n ++;
#line 1314
  menuitems_i18n[no_menuitems_i18n].menuname = "ui";
#line 1314
  menuitems_i18n[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1314
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)0;
#line 1314
  menuitems_i18n[no_menuitems_i18n].type = 8;
#line 1314
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1314
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1314
  menuitems_i18n[no_menuitems_i18n].name = "";
#line 1314
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1314
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1314
  no_menuitems_i18n ++;
#line 1315
  menuitems_i18n[no_menuitems_i18n].menuname = "ui";
#line 1315
  menuitems_i18n[no_menuitems_i18n].shortname = "recalculate";
#line 1315
  menuitems_i18n[no_menuitems_i18n].key = "r";
#line 1315
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1315
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1315
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1315
  tmp___121 = gettext("Recalculate");
#line 1315
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___121;
#line 1315
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1315
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_recalculate);
#line 1315
  no_menuitems_i18n ++;
#line 1317
  menuitems_i18n[no_menuitems_i18n].menuname = "ui";
#line 1317
  menuitems_i18n[no_menuitems_i18n].shortname = "interrupt";
#line 1317
  menuitems_i18n[no_menuitems_i18n].key = "z";
#line 1317
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1317
  menuitems_i18n[no_menuitems_i18n].flags = 12;
#line 1317
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1317
  tmp___122 = gettext("Interrupt");
#line 1317
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___122;
#line 1317
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1317
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_interrupt);
#line 1317
  no_menuitems_i18n ++;
#line 1322
  menuitems_i18n[no_menuitems_i18n].menuname = "ui";
#line 1322
  menuitems_i18n[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1322
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)0;
#line 1322
  menuitems_i18n[no_menuitems_i18n].type = 8;
#line 1322
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1322
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1322
  menuitems_i18n[no_menuitems_i18n].name = "";
#line 1322
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1322
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1322
  no_menuitems_i18n ++;
#line 1323
  menuitems_i18n[no_menuitems_i18n].menuname = "ui";
#line 1323
  menuitems_i18n[no_menuitems_i18n].shortname = "speed";
#line 1323
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1323
  menuitems_i18n[no_menuitems_i18n].type = 7;
#line 1323
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1323
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1323
  tmp___123 = gettext("Zooming speed");
#line 1323
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___123;
#line 1323
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1323
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))((void *)0);
#line 1323
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setspeed);
#line 1323
  menuitems_i18n[no_menuitems_i18n].dialog = (menudialog const   *(*)(struct uih_context * ))(& uih_getspeeddialog);
#line 1323
  no_menuitems_i18n ++;
#line 1326
  menuitems_i18n[no_menuitems_i18n].menuname = "ui";
#line 1326
  menuitems_i18n[no_menuitems_i18n].shortname = "fixedstep";
#line 1326
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1326
  menuitems_i18n[no_menuitems_i18n].type = 1;
#line 1326
  menuitems_i18n[no_menuitems_i18n].flags = 1;
#line 1326
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1326
  tmp___124 = gettext("Fixed step");
#line 1326
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___124;
#line 1326
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1326
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_fixedstepsw);
#line 1326
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_fixedstepselected);
#line 1326
  no_menuitems_i18n ++;
#line 1328
  menuitems_i18n[no_menuitems_i18n].menuname = "mguess";
#line 1328
  menuitems_i18n[no_menuitems_i18n].shortname = "noguess";
#line 1328
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1328
  menuitems_i18n[no_menuitems_i18n].type = 3;
#line 1328
  menuitems_i18n[no_menuitems_i18n].flags = 98;
#line 1328
  menuitems_i18n[no_menuitems_i18n].iparam = 1;
#line 1328
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1328
  tmp___125 = gettext("Disable solid guessing");
#line 1328
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___125;
#line 1328
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setguessing);
#line 1328
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_guessingselected);
#line 1328
  no_menuitems_i18n ++;
#line 1332
  menuitems_i18n[no_menuitems_i18n].menuname = "mguess";
#line 1332
  menuitems_i18n[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1332
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)0;
#line 1332
  menuitems_i18n[no_menuitems_i18n].type = 8;
#line 1332
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1332
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1332
  menuitems_i18n[no_menuitems_i18n].name = "";
#line 1332
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1332
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1332
  no_menuitems_i18n ++;
#line 1333
  menuitems_i18n[no_menuitems_i18n].menuname = "mguess";
#line 1333
  menuitems_i18n[no_menuitems_i18n].shortname = "guess2";
#line 1333
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1333
  menuitems_i18n[no_menuitems_i18n].type = 3;
#line 1333
  menuitems_i18n[no_menuitems_i18n].flags = 98;
#line 1333
  menuitems_i18n[no_menuitems_i18n].iparam = 2;
#line 1333
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1333
  tmp___126 = gettext("Guess 2x2 rectangles");
#line 1333
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___126;
#line 1333
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setguessing);
#line 1333
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_guessingselected);
#line 1333
  no_menuitems_i18n ++;
#line 1336
  menuitems_i18n[no_menuitems_i18n].menuname = "mguess";
#line 1336
  menuitems_i18n[no_menuitems_i18n].shortname = "guess3";
#line 1336
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1336
  menuitems_i18n[no_menuitems_i18n].type = 3;
#line 1336
  menuitems_i18n[no_menuitems_i18n].flags = 98;
#line 1336
  menuitems_i18n[no_menuitems_i18n].iparam = 3;
#line 1336
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1336
  tmp___127 = gettext("Guess 3x3 rectangles");
#line 1336
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___127;
#line 1336
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setguessing);
#line 1336
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_guessingselected);
#line 1336
  no_menuitems_i18n ++;
#line 1338
  menuitems_i18n[no_menuitems_i18n].menuname = "mguess";
#line 1338
  menuitems_i18n[no_menuitems_i18n].shortname = "guess4";
#line 1338
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1338
  menuitems_i18n[no_menuitems_i18n].type = 3;
#line 1338
  menuitems_i18n[no_menuitems_i18n].flags = 98;
#line 1338
  menuitems_i18n[no_menuitems_i18n].iparam = 4;
#line 1338
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1338
  tmp___128 = gettext("Guess 4x4 rectangles");
#line 1338
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___128;
#line 1338
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setguessing);
#line 1338
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_guessingselected);
#line 1338
  no_menuitems_i18n ++;
#line 1342
  menuitems_i18n[no_menuitems_i18n].menuname = "mguess";
#line 1342
  menuitems_i18n[no_menuitems_i18n].shortname = "guess5";
#line 1342
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1342
  menuitems_i18n[no_menuitems_i18n].type = 3;
#line 1342
  menuitems_i18n[no_menuitems_i18n].flags = 98;
#line 1342
  menuitems_i18n[no_menuitems_i18n].iparam = 5;
#line 1342
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1342
  tmp___129 = gettext("Guess 5x5 rectangles");
#line 1342
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___129;
#line 1342
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setguessing);
#line 1342
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_guessingselected);
#line 1342
  no_menuitems_i18n ++;
#line 1344
  menuitems_i18n[no_menuitems_i18n].menuname = "mguess";
#line 1344
  menuitems_i18n[no_menuitems_i18n].shortname = "guess6";
#line 1344
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1344
  menuitems_i18n[no_menuitems_i18n].type = 3;
#line 1344
  menuitems_i18n[no_menuitems_i18n].flags = 98;
#line 1344
  menuitems_i18n[no_menuitems_i18n].iparam = 6;
#line 1344
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1344
  tmp___130 = gettext("Guess 6x6 rectangles");
#line 1344
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___130;
#line 1344
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setguessing);
#line 1344
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_guessingselected);
#line 1344
  no_menuitems_i18n ++;
#line 1348
  menuitems_i18n[no_menuitems_i18n].menuname = "mguess";
#line 1348
  menuitems_i18n[no_menuitems_i18n].shortname = "guess7";
#line 1348
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1348
  menuitems_i18n[no_menuitems_i18n].type = 3;
#line 1348
  menuitems_i18n[no_menuitems_i18n].flags = 98;
#line 1348
  menuitems_i18n[no_menuitems_i18n].iparam = 7;
#line 1348
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1348
  tmp___131 = gettext("Guess 7x7 rectangles");
#line 1348
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___131;
#line 1348
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setguessing);
#line 1348
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_guessingselected);
#line 1348
  no_menuitems_i18n ++;
#line 1350
  menuitems_i18n[no_menuitems_i18n].menuname = "mguess";
#line 1350
  menuitems_i18n[no_menuitems_i18n].shortname = "guess8";
#line 1350
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1350
  menuitems_i18n[no_menuitems_i18n].type = 3;
#line 1350
  menuitems_i18n[no_menuitems_i18n].flags = 98;
#line 1350
  menuitems_i18n[no_menuitems_i18n].iparam = 8;
#line 1350
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1350
  tmp___132 = gettext("Guess 8x8 rectangles");
#line 1350
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___132;
#line 1350
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setguessing);
#line 1350
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_guessingselected);
#line 1350
  no_menuitems_i18n ++;
#line 1354
  menuitems_i18n[no_menuitems_i18n].menuname = "mguess";
#line 1354
  menuitems_i18n[no_menuitems_i18n].shortname = "guessall";
#line 1354
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1354
  menuitems_i18n[no_menuitems_i18n].type = 3;
#line 1354
  menuitems_i18n[no_menuitems_i18n].flags = 98;
#line 1354
  menuitems_i18n[no_menuitems_i18n].iparam = 2048;
#line 1354
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1354
  tmp___133 = gettext("Guess unlimited rectangles");
#line 1354
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___133;
#line 1354
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_setguessing);
#line 1354
  menuitems_i18n[no_menuitems_i18n].control = (int (*)(void))(& uih_guessingselected);
#line 1354
  no_menuitems_i18n ++;
#line 1362
  menuitems_i18n[no_menuitems_i18n].menuname = "tutor";
#line 1362
  menuitems_i18n[no_menuitems_i18n].shortname = "intro";
#line 1362
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1362
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1362
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1362
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1362
  tmp___134 = gettext("An introduction to fractals");
#line 1362
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___134;
#line 1362
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1362
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1362
  no_menuitems_i18n ++;
#line 1364
  menuitems_i18n[no_menuitems_i18n].menuname = "tutor";
#line 1364
  menuitems_i18n[no_menuitems_i18n].shortname = "features";
#line 1364
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1364
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1364
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1364
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1364
  tmp___135 = gettext("XaoS features overview");
#line 1364
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___135;
#line 1364
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1364
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1364
  no_menuitems_i18n ++;
#line 1366
  menuitems_i18n[no_menuitems_i18n].menuname = "tutor";
#line 1366
  menuitems_i18n[no_menuitems_i18n].shortname = "fmath";
#line 1366
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1366
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1366
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1366
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1366
  tmp___136 = gettext("Math behind fractals");
#line 1366
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___136;
#line 1366
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1366
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1366
  no_menuitems_i18n ++;
#line 1367
  menuitems_i18n[no_menuitems_i18n].menuname = "tutor";
#line 1367
  menuitems_i18n[no_menuitems_i18n].shortname = "otherf";
#line 1367
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1367
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1367
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1367
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1367
  tmp___137 = gettext("Other fractal types in XaoS");
#line 1367
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___137;
#line 1367
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1367
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1367
  no_menuitems_i18n ++;
#line 1369
  menuitems_i18n[no_menuitems_i18n].menuname = "tutor";
#line 1369
  menuitems_i18n[no_menuitems_i18n].shortname = "new";
#line 1369
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1369
  menuitems_i18n[no_menuitems_i18n].type = 2;
#line 1369
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1369
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1369
  tmp___138 = gettext("What\'s new?");
#line 1369
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___138;
#line 1369
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1369
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1369
  no_menuitems_i18n ++;
#line 1379
  menuitems_i18n[no_menuitems_i18n].menuname = "intro";
#line 1379
  menuitems_i18n[no_menuitems_i18n].shortname = "fractal.xaf";
#line 1379
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1379
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1379
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1379
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1379
  tmp___139 = gettext("Whole story");
#line 1379
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___139;
#line 1379
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"fractal.xaf";
#line 1379
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1379
  no_menuitems_i18n ++;
#line 1380
  menuitems_i18n[no_menuitems_i18n].menuname = "intro";
#line 1380
  menuitems_i18n[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1380
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)0;
#line 1380
  menuitems_i18n[no_menuitems_i18n].type = 8;
#line 1380
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1380
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1380
  menuitems_i18n[no_menuitems_i18n].name = "";
#line 1380
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1380
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1380
  no_menuitems_i18n ++;
#line 1381
  menuitems_i18n[no_menuitems_i18n].menuname = "intro";
#line 1381
  menuitems_i18n[no_menuitems_i18n].shortname = "intro.xaf";
#line 1381
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1381
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1381
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1381
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1381
  tmp___140 = gettext("Introduction");
#line 1381
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___140;
#line 1381
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"intro.xaf";
#line 1381
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1381
  no_menuitems_i18n ++;
#line 1382
  menuitems_i18n[no_menuitems_i18n].menuname = "intro";
#line 1382
  menuitems_i18n[no_menuitems_i18n].shortname = "mset.xaf";
#line 1382
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1382
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1382
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1382
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1382
  tmp___141 = gettext("Mandelbrot set");
#line 1382
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___141;
#line 1382
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"mset.xaf";
#line 1382
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1382
  no_menuitems_i18n ++;
#line 1383
  menuitems_i18n[no_menuitems_i18n].menuname = "intro";
#line 1383
  menuitems_i18n[no_menuitems_i18n].shortname = "julia.xaf";
#line 1383
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1383
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1383
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1383
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1383
  tmp___142 = gettext("Julia set");
#line 1383
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___142;
#line 1383
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"julia.xaf";
#line 1383
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1383
  no_menuitems_i18n ++;
#line 1384
  menuitems_i18n[no_menuitems_i18n].menuname = "intro";
#line 1384
  menuitems_i18n[no_menuitems_i18n].shortname = "power.xaf";
#line 1384
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1384
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1384
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1384
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1384
  tmp___143 = gettext("Higher power Mandelbrots");
#line 1384
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___143;
#line 1384
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"power.xaf";
#line 1384
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1384
  no_menuitems_i18n ++;
#line 1385
  menuitems_i18n[no_menuitems_i18n].menuname = "intro";
#line 1385
  menuitems_i18n[no_menuitems_i18n].shortname = "newton.xaf";
#line 1385
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1385
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1385
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1385
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1385
  tmp___144 = gettext("Newton\'s method");
#line 1385
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___144;
#line 1385
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"newton.xaf";
#line 1385
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1385
  no_menuitems_i18n ++;
#line 1386
  menuitems_i18n[no_menuitems_i18n].menuname = "intro";
#line 1386
  menuitems_i18n[no_menuitems_i18n].shortname = "barnsley.xaf";
#line 1386
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1386
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1386
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1386
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1386
  tmp___145 = gettext("Barnsley\'s formula");
#line 1386
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___145;
#line 1386
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"barnsley.xaf";
#line 1386
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1386
  no_menuitems_i18n ++;
#line 1387
  menuitems_i18n[no_menuitems_i18n].menuname = "intro";
#line 1387
  menuitems_i18n[no_menuitems_i18n].shortname = "phoenix.xaf";
#line 1387
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1387
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1387
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1387
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1387
  tmp___146 = gettext("Phoenix");
#line 1387
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___146;
#line 1387
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"phoenix.xaf";
#line 1387
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1387
  no_menuitems_i18n ++;
#line 1388
  menuitems_i18n[no_menuitems_i18n].menuname = "intro";
#line 1388
  menuitems_i18n[no_menuitems_i18n].shortname = "octo.xaf";
#line 1388
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1388
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1388
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1388
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1388
  tmp___147 = gettext("Octo");
#line 1388
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___147;
#line 1388
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"octo.xaf";
#line 1388
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1388
  no_menuitems_i18n ++;
#line 1389
  menuitems_i18n[no_menuitems_i18n].menuname = "intro";
#line 1389
  menuitems_i18n[no_menuitems_i18n].shortname = "magnet.xaf";
#line 1389
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1389
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1389
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1389
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1389
  tmp___148 = gettext("Magnet");
#line 1389
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___148;
#line 1389
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"magnet.xaf";
#line 1389
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1389
  no_menuitems_i18n ++;
#line 1390
  menuitems_i18n[no_menuitems_i18n].menuname = "features";
#line 1390
  menuitems_i18n[no_menuitems_i18n].shortname = "features.xaf";
#line 1390
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1390
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1390
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1390
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1390
  tmp___149 = gettext("All features");
#line 1390
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___149;
#line 1390
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"features.xaf";
#line 1390
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1390
  no_menuitems_i18n ++;
#line 1391
  menuitems_i18n[no_menuitems_i18n].menuname = "features";
#line 1391
  menuitems_i18n[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1391
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)0;
#line 1391
  menuitems_i18n[no_menuitems_i18n].type = 8;
#line 1391
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1391
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1391
  menuitems_i18n[no_menuitems_i18n].name = "";
#line 1391
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1391
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1391
  no_menuitems_i18n ++;
#line 1392
  menuitems_i18n[no_menuitems_i18n].menuname = "features";
#line 1392
  menuitems_i18n[no_menuitems_i18n].shortname = "outcolor.xaf";
#line 1392
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1392
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1392
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1392
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1392
  tmp___150 = gettext("Outcoloring modes");
#line 1392
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___150;
#line 1392
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"outcolor.xaf";
#line 1392
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1392
  no_menuitems_i18n ++;
#line 1393
  menuitems_i18n[no_menuitems_i18n].menuname = "features";
#line 1393
  menuitems_i18n[no_menuitems_i18n].shortname = "incolor.xaf";
#line 1393
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1393
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1393
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1393
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1393
  tmp___151 = gettext("Incoloring modes");
#line 1393
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___151;
#line 1393
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"incolor.xaf";
#line 1393
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1393
  no_menuitems_i18n ++;
#line 1394
  menuitems_i18n[no_menuitems_i18n].menuname = "features";
#line 1394
  menuitems_i18n[no_menuitems_i18n].shortname = "truecol.xaf";
#line 1394
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1394
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1394
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1394
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1394
  tmp___152 = gettext("True-color coloring modes");
#line 1394
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___152;
#line 1394
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"truecol.xaf";
#line 1394
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1394
  no_menuitems_i18n ++;
#line 1396
  menuitems_i18n[no_menuitems_i18n].menuname = "features";
#line 1396
  menuitems_i18n[no_menuitems_i18n].shortname = "filter.xaf";
#line 1396
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1396
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1396
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1396
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1396
  tmp___153 = gettext("Filters");
#line 1396
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___153;
#line 1396
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"filter.xaf";
#line 1396
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1396
  no_menuitems_i18n ++;
#line 1397
  menuitems_i18n[no_menuitems_i18n].menuname = "features";
#line 1397
  menuitems_i18n[no_menuitems_i18n].shortname = "plane.xaf";
#line 1397
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1397
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1397
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1397
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1397
  tmp___154 = gettext("Planes");
#line 1397
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___154;
#line 1397
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"plane.xaf";
#line 1397
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1397
  no_menuitems_i18n ++;
#line 1398
  menuitems_i18n[no_menuitems_i18n].menuname = "features";
#line 1398
  menuitems_i18n[no_menuitems_i18n].shortname = "anim.xaf";
#line 1398
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1398
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1398
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1398
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1398
  tmp___155 = gettext("Animations and position files");
#line 1398
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___155;
#line 1398
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"anim.xaf";
#line 1398
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1398
  no_menuitems_i18n ++;
#line 1400
  menuitems_i18n[no_menuitems_i18n].menuname = "features";
#line 1400
  menuitems_i18n[no_menuitems_i18n].shortname = "pert.xaf";
#line 1400
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1400
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1400
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1400
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1400
  tmp___156 = gettext("Perturbation");
#line 1400
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___156;
#line 1400
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"pert.xaf";
#line 1400
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1400
  no_menuitems_i18n ++;
#line 1401
  menuitems_i18n[no_menuitems_i18n].menuname = "features";
#line 1401
  menuitems_i18n[no_menuitems_i18n].shortname = "palette.xaf";
#line 1401
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1401
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1401
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1401
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1401
  tmp___157 = gettext("Random palettes");
#line 1401
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___157;
#line 1401
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"palette.xaf";
#line 1401
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1401
  no_menuitems_i18n ++;
#line 1402
  menuitems_i18n[no_menuitems_i18n].menuname = "features";
#line 1402
  menuitems_i18n[no_menuitems_i18n].shortname = "other.xaf";
#line 1402
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1402
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1402
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1402
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1402
  tmp___158 = gettext("Other noteworthy features");
#line 1402
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___158;
#line 1402
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"other.xaf";
#line 1402
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1402
  no_menuitems_i18n ++;
#line 1403
  menuitems_i18n[no_menuitems_i18n].menuname = "fmath";
#line 1403
  menuitems_i18n[no_menuitems_i18n].shortname = "fmath.xaf";
#line 1403
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1403
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1403
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1403
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1403
  tmp___159 = gettext("Whole story");
#line 1403
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___159;
#line 1403
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"fmath.xaf";
#line 1403
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1403
  no_menuitems_i18n ++;
#line 1404
  menuitems_i18n[no_menuitems_i18n].menuname = "fmath";
#line 1404
  menuitems_i18n[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1404
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)0;
#line 1404
  menuitems_i18n[no_menuitems_i18n].type = 8;
#line 1404
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1404
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1404
  menuitems_i18n[no_menuitems_i18n].name = "";
#line 1404
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1404
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1404
  no_menuitems_i18n ++;
#line 1405
  menuitems_i18n[no_menuitems_i18n].menuname = "fmath";
#line 1405
  menuitems_i18n[no_menuitems_i18n].shortname = "dimension.xaf";
#line 1405
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1405
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1405
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1405
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1405
  tmp___160 = gettext("The definition and fractal dimension");
#line 1405
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___160;
#line 1405
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"dimension.xaf";
#line 1405
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1405
  no_menuitems_i18n ++;
#line 1407
  menuitems_i18n[no_menuitems_i18n].menuname = "fmath";
#line 1407
  menuitems_i18n[no_menuitems_i18n].shortname = "escape.xaf";
#line 1407
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1407
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1407
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1407
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1407
  tmp___161 = gettext("Escape time fractals");
#line 1407
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___161;
#line 1407
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"escape.xaf";
#line 1407
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1407
  no_menuitems_i18n ++;
#line 1408
  menuitems_i18n[no_menuitems_i18n].menuname = "otherf";
#line 1408
  menuitems_i18n[no_menuitems_i18n].shortname = "otherfr.xaf";
#line 1408
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1408
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1408
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1408
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1408
  tmp___162 = gettext("Other fractal types in XaoS");
#line 1408
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___162;
#line 1408
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"otherfr.xaf";
#line 1408
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1408
  no_menuitems_i18n ++;
#line 1410
  menuitems_i18n[no_menuitems_i18n].menuname = "otherf";
#line 1410
  menuitems_i18n[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1410
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)0;
#line 1410
  menuitems_i18n[no_menuitems_i18n].type = 8;
#line 1410
  menuitems_i18n[no_menuitems_i18n].flags = 0;
#line 1410
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1410
  menuitems_i18n[no_menuitems_i18n].name = "";
#line 1410
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1410
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1410
  no_menuitems_i18n ++;
#line 1411
  menuitems_i18n[no_menuitems_i18n].menuname = "otherf";
#line 1411
  menuitems_i18n[no_menuitems_i18n].shortname = "trice.xaf";
#line 1411
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1411
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1411
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1411
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1411
  tmp___163 = gettext("Triceratops and Catseye fractals");
#line 1411
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___163;
#line 1411
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"trice.xaf";
#line 1411
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1411
  no_menuitems_i18n ++;
#line 1413
  menuitems_i18n[no_menuitems_i18n].menuname = "otherf";
#line 1413
  menuitems_i18n[no_menuitems_i18n].shortname = "fourfr.xaf";
#line 1413
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1413
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1413
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1413
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1413
  tmp___164 = gettext("Mandelbar, Lambda, Manowar and Spider");
#line 1413
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___164;
#line 1413
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"fourfr.xaf";
#line 1413
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1413
  no_menuitems_i18n ++;
#line 1415
  menuitems_i18n[no_menuitems_i18n].menuname = "otherf";
#line 1415
  menuitems_i18n[no_menuitems_i18n].shortname = "classic.xaf";
#line 1415
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1415
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1415
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1415
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1415
  tmp___165 = gettext("Sierpinski Gasket, S.Carpet, Koch Snowflake");
#line 1415
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___165;
#line 1415
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"classic.xaf";
#line 1415
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1415
  no_menuitems_i18n ++;
#line 1418
  menuitems_i18n[no_menuitems_i18n].menuname = "new";
#line 1418
  menuitems_i18n[no_menuitems_i18n].shortname = "new30.xaf";
#line 1418
  menuitems_i18n[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1418
  menuitems_i18n[no_menuitems_i18n].type = 4;
#line 1418
  menuitems_i18n[no_menuitems_i18n].flags = 100;
#line 1418
  menuitems_i18n[no_menuitems_i18n].iparam = 0;
#line 1418
  tmp___166 = gettext("What\'s new in 3.0?");
#line 1418
  menuitems_i18n[no_menuitems_i18n].name = (char const   *)tmp___166;
#line 1418
  menuitems_i18n[no_menuitems_i18n].pparam = (void const   *)"new30.xaf";
#line 1418
  menuitems_i18n[no_menuitems_i18n].function = (void (*)(void))(& uih_playtutorial);
#line 1418
  no_menuitems_i18n ++;
#line 1423
  menu_add((menuitem const   *)(menuitems_i18n), no_menuitems_i18n);
#line 1424
  uih_no_menuitems_i18n = no_menuitems_i18n;
  }
#line 1425
  return;
}
}
#line 1428 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menuitem const   menuitems2[2]  = {      {"mincoloring", (char const   *)((void *)0), "True-color incoloring mode", "tincoloring",
      2, 0, (void (*)(void))((void *)0), 0, (void const   *)((void *)0), (int (*)(void))0,
      (menudialog const   *(*)(struct uih_context * ))0}, 
        {"moutcoloring", (char const   *)((void *)0), "True-color outcoloring mode",
      "toutcoloring", 2, 0, (void (*)(void))((void *)0), 0, (void const   *)((void *)0),
      (int (*)(void))0, (menudialog const   *(*)(struct uih_context * ))0}};
#line 1435 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static int uih_selectedformula(struct uih_context *c , int n ) 
{ 


  {
#line 1437
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 1438
    return (0);
  }
#line 1439
  return ((unsigned long )(c->fcontext)->currentformula == (unsigned long )(formulas + n));
}
}
#line 1442 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static int uih_selectedincoloring(struct uih_context *c , int n ) 
{ 


  {
#line 1444
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 1445
    return (0);
  }
#line 1446
  return ((c->fcontext)->incoloringmode == n);
}
}
#line 1449 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_setintruecolor(struct uih_context *c , int n ) 
{ 


  {
  {
#line 1451
  uih_setincoloringmode(c, 10);
#line 1452
  uih_setintcolor(c, n);
  }
#line 1453
  return;
}
}
#line 1455 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static int uih_selectedintcoloring(struct uih_context *c , int n ) 
{ 


  {
#line 1457
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 1458
    return (0);
  }
#line 1459
  return ((c->fcontext)->intcolor == n);
}
}
#line 1462 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static int uih_selectedoutcoloring(struct uih_context *c , int n ) 
{ 


  {
#line 1464
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 1465
    return (0);
  }
#line 1466
  return ((c->fcontext)->coloringmode == n);
}
}
#line 1469 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static int uih_selectedplane(struct uih_context *c , int n ) 
{ 


  {
#line 1471
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 1472
    return (0);
  }
#line 1473
  return ((c->fcontext)->plane == n);
}
}
#line 1476 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_setouttruecolor(struct uih_context *c , int n ) 
{ 


  {
  {
#line 1478
  uih_setoutcoloringmode(c, 10);
#line 1479
  uih_setouttcolor(c, n);
  }
#line 1480
  return;
}
}
#line 1482 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static int uih_selectedouttcoloring(struct uih_context *c , int n ) 
{ 


  {
#line 1484
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 1485
    return (0);
  }
#line 1486
  return ((c->fcontext)->outtcolor == n);
}
}
#line 1489 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static int uih_filterenabled(struct uih_context *c , int n ) 
{ 


  {
#line 1491
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 1492
    return (0);
  }
#line 1493
  return ((unsigned long )c->filter[n] != (unsigned long )((void *)0));
}
}
#line 1496 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static void uih_filtersw(struct uih_context *c , int n ) 
{ 


  {
#line 1498
  if ((unsigned long )c->filter[n] != (unsigned long )((void *)0)) {
    {
#line 1499
    uih_disablefilter(c, n);
    }
  } else {
    {
#line 1501
    uih_enablefilter(c, n);
    }
  }
#line 1502
  return;
}
}
#line 1504 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menuitem *formulaitems  ;
#line 1505 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static menuitem *filteritems  ;
#line 1506 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
static char (*keys)[2]  ;
#line 1507 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
void uih_registermenus(void) 
{ 
  menuitem *item ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  int i___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1511
  menu_add(menuitems, (int )(sizeof(menuitems) / sizeof(menuitem )));
#line 1512
  tmp = malloc(sizeof(menuitem ) * (unsigned long )nformulas);
#line 1512
  item = (menuitem *)tmp;
#line 1512
  formulaitems = item;
#line 1517
  tmp___0 = malloc(sizeof(*keys) * (unsigned long )nformulas);
#line 1517
  keys = (char (*)[2])tmp___0;
#line 1518
  i = 0;
  }
  {
#line 1518
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1518
    if (! (i < (int )nformulas)) {
#line 1518
      goto while_break;
    }
#line 1519
    if (i < (int )nmformulas) {
#line 1520
      (item + i)->menuname = "mformula";
    } else {
#line 1522
      (item + i)->menuname = "oformula";
    }
#line 1524
    (item + i)->key = (char const   *)(*(keys + i));
#line 1525
    if (i < 9) {
#line 1526
      (*(keys + i))[0] = (char )(49 + i);
    } else
#line 1527
    if (i == 9) {
#line 1528
      (*(keys + i))[0] = (char )'0';
    } else {
#line 1531
      (*(keys + i))[0] = (char )(55 + i);
    }
#line 1533
    (*(keys + i))[1] = (char)0;
#line 1534
    (item + i)->type = 3;
#line 1535
    (item + i)->flags = 70;
#line 1537
    (item + i)->iparam = i;
#line 1538
    (item + i)->name = formulas[i].name[! formulas[i].mandelbrot];
#line 1539
    (item + i)->shortname = (char const   *)formulas[i].shortname;
#line 1540
    (item + i)->function = (void (*)(void))(& uih_setformula);
#line 1541
    (item + i)->control = (int (*)(void))(& uih_selectedformula);
#line 1518
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1543
  menu_add((menuitem const   *)item, (int )nformulas);
#line 1545
  menu_genernumbered(10, "mincoloring", (char const   * const  */* const  */)(incolorname),
                     (char const   *)((void *)0), 3, 102, & uih_setincoloringmode,
                     & uih_selectedincoloring, "in");
#line 1550
  menu_genernumbered(14, "tincoloring", (char const   * const  */* const  */)(tcolorname),
                     (char const   *)((void *)0), 3, 102, & uih_setintruecolor, & uih_selectedintcoloring,
                     "int");
#line 1554
  menu_genernumbered(10, "moutcoloring", (char const   * const  */* const  */)(outcolorname),
                     (char const   *)((void *)0), 3, 102, & uih_setoutcoloringmode,
                     & uih_selectedoutcoloring, "out");
#line 1559
  menu_genernumbered(14, "toutcoloring", (char const   * const  */* const  */)(tcolorname),
                     (char const   *)((void *)0), 3, 102, & uih_setouttruecolor, & uih_selectedouttcoloring,
                     "outt");
#line 1566
  i___0 = 0;
  }
  {
#line 1566
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1566
    if (! ((unsigned long )planename[i___0] != (unsigned long )((void *)0))) {
#line 1566
      goto while_break___0;
    }
#line 1566
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1567
  menu_genernumbered(i___0, "mplane", (char const   * const  */* const  */)(planename),
                     (char const   *)((void *)0), 3, 102, & uih_setplane, & uih_selectedplane,
                     "plane");
#line 1571
  tmp___1 = malloc(sizeof(menuitem ) * (unsigned long )uih_nfilters);
#line 1571
  item = (menuitem *)tmp___1;
#line 1571
  filteritems = item;
#line 1576
  i = 0;
  }
  {
#line 1576
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1576
    if (! (i < (int )uih_nfilters)) {
#line 1576
      goto while_break___1;
    }
    {
#line 1577
    (item + i)->menuname = "mfilter";
#line 1578
    (item + i)->key = (char const   *)((void *)0);
#line 1579
    (item + i)->type = 3;
#line 1580
    (item + i)->flags = 69;
#line 1582
    (item + i)->iparam = i;
#line 1583
    (item + i)->name = (char const   *)(uih_filters[i])->name;
#line 1584
    (item + i)->shortname = (char const   *)(uih_filters[i])->shortname;
#line 1585
    tmp___2 = strcmp((item + i)->shortname, "palette");
    }
#line 1585
    if (! tmp___2) {
#line 1586
      (item + i)->shortname = "palettef";
    }
#line 1588
    (item + i)->function = (void (*)(void))(& uih_filtersw);
#line 1589
    (item + i)->control = (int (*)(void))(& uih_filterenabled);
#line 1576
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1591
  menu_add((menuitem const   *)item, (int )uih_nfilters);
#line 1593
  menu_add(menuitems2, (int )(sizeof(menuitems2) / sizeof(menuitem )));
  }
#line 1594
  return;
}
}
#line 1596 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/menu.c"
void uih_unregistermenus(void) 
{ 
  int i ;

  {
  {
#line 1598
  menu_delete(menuitems, (int )(sizeof(menuitems) / sizeof(menuitem )));
#line 1599
  menu_delete((menuitem const   *)(menuitems_i18n), uih_no_menuitems_i18n);
#line 1601
  free((void *)keys);
#line 1602
  menu_delete((menuitem const   *)formulaitems, (int )nformulas);
#line 1603
  free((void *)formulaitems);
#line 1605
  menu_delnumbered(10, "in");
#line 1607
  menu_delnumbered(14, "int");
#line 1609
  menu_delnumbered(10, "out");
#line 1611
  menu_delnumbered(14, "outt");
#line 1614
  i = 0;
  }
  {
#line 1614
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1614
    if (! ((unsigned long )planename[i] != (unsigned long )((void *)0))) {
#line 1614
      goto while_break;
    }
#line 1614
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1615
  menu_delnumbered(i, "plane");
#line 1618
  menu_delete((menuitem const   *)filteritems, (int )uih_nfilters);
#line 1619
  free((void *)filteritems);
#line 1621
  menu_delete(menuitems2, (int )(sizeof(menuitems2) / sizeof(menuitem )));
  }
#line 1622
  return;
}
}
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 151 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/fractal.h"
extern void set_formula(fractal_context * , int  ) ;
#line 156
extern fractal_context *make_fractalc(int const    , float  , float  ) ;
#line 36 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/timers.h"
extern tl_timer *tl_create_timer(void) ;
#line 46
extern void tl_free_timer(tl_timer *timer ) ;
#line 55
extern int tl_lookup_timer(tl_timer *t ) ;
#line 56
extern void tl_reset_timer(tl_timer *t ) ;
#line 431 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui_helper.h"
int uih_save_enable(struct uih_context *uih___2 , xio_file f , int mode ) ;
#line 432
void uih_save_disable(struct uih_context *uih___2 ) ;
#line 433
void uih_saveframe(struct uih_context *uih___2 ) ;
#line 434
void uih_save_possition(struct uih_context *uih___2 , xio_file f , int mode ) ;
#line 513
void uih_emulatetimers(uih_context *c ) ;
#line 23 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static int first  ;
#line 24 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static int changed  ;
#line 25 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static int last  ;
#line 26 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
char const   * const  save_fastmode[6]  = {      (char const   */* const  */)"zero",      (char const   */* const  */)"never",      (char const   */* const  */)"animation",      (char const   */* const  */)"new", 
        (char const   */* const  */)"allways",      (char const   */* const  */)((void *)0)};
#line 28 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
char const   * const  xtextposnames[4]  = {      (char const   */* const  */)"left",      (char const   */* const  */)"center",      (char const   */* const  */)"right",      (char const   */* const  */)((void *)0)};
#line 29 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
char const   * const  ytextposnames[4]  = {      (char const   */* const  */)"top",      (char const   */* const  */)"middle",      (char const   */* const  */)"bottom",      (char const   */* const  */)((void *)0)};
#line 34 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static char error[245]  ;
#line 32 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static void outputerror(struct uih_context *uih___2 ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
#line 35
  if ((uih___2->savec)->writefailed) {
#line 36
    return;
  }
  {
#line 37
  tmp = __errno_location();
#line 37
  tmp___0 = strerror(*tmp);
#line 37
  sprintf((char */* __restrict  */)(error), (char const   */* __restrict  */)"Write failed:%s",
          tmp___0);
#line 38
  uih_error(uih___2, (char const   *)(error));
#line 39
  (uih___2->savec)->writefailed = 1;
  }
#line 40
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static void start_save(struct uih_context *uih___2 , char const   *name___0 ) 
{ 
  char s[256] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 45
  if (! changed) {
#line 45
    if (! (uih___2->savec)->firsttime) {
      {
#line 47
      tmp = tl_lookup_timer((uih___2->savec)->timer);
#line 47
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"\n(usleep %i)\n",
              tmp);
#line 48
      tmp___0 = (*(((uih___2->savec)->file)->fputs))((char const   *)(s), (uih___2->savec)->file);
      }
#line 48
      if (tmp___0 == -1) {
        {
#line 48
        outputerror(uih___2);
        }
      }
      {
#line 49
      tl_reset_timer((uih___2->savec)->timer);
      }
    }
  }
  {
#line 51
  changed = 1;
#line 52
  tmp___1 = (*(((uih___2->savec)->file)->fputc))('(', (uih___2->savec)->file);
  }
#line 52
  if (tmp___1 == -1) {
    {
#line 52
    outputerror(uih___2);
    }
  }
  {
#line 53
  tmp___2 = (*(((uih___2->savec)->file)->fputs))(name___0, (uih___2->savec)->file);
  }
#line 53
  if (tmp___2 == -1) {
    {
#line 53
    outputerror(uih___2);
    }
  }
#line 54
  first = 0;
#line 55
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static void stop_save(struct uih_context *uih___2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 60
  tmp = (*(((uih___2->savec)->file)->fputc))(')', (uih___2->savec)->file);
  }
#line 60
  if (tmp == -1) {
    {
#line 60
    outputerror(uih___2);
    }
  }
  {
#line 61
  tmp___0 = (*(((uih___2->savec)->file)->fputc))('\n', (uih___2->savec)->file);
  }
#line 61
  if (tmp___0 == -1) {
    {
#line 61
    outputerror(uih___2);
    }
  }
#line 62
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static void save_keystring(struct uih_context *uih___2 , char const   *name___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 78
  if (! first) {
    {
#line 79
    tmp = (*(((uih___2->savec)->file)->fputc))(' ', (uih___2->savec)->file);
    }
#line 79
    if (tmp == -1) {
      {
#line 79
      outputerror(uih___2);
      }
    }
  } else {
#line 81
    first = 0;
  }
  {
#line 82
  tmp___0 = (*(((uih___2->savec)->file)->fputc))('\'', (uih___2->savec)->file);
  }
#line 82
  if (tmp___0 == -1) {
    {
#line 82
    outputerror(uih___2);
    }
  }
  {
#line 83
  tmp___1 = (*(((uih___2->savec)->file)->fputs))(name___0, (uih___2->savec)->file);
  }
#line 83
  if (tmp___1 == -1) {
    {
#line 83
    outputerror(uih___2);
    }
  }
#line 84
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static void save_float(struct uih_context *uih___2 , number_t number ) 
{ 
  int tmp ;
  char s[256] ;
  int tmp___0 ;

  {
#line 89
  if (! first) {
    {
#line 90
    tmp = (*(((uih___2->savec)->file)->fputc))(' ', (uih___2->savec)->file);
    }
#line 90
    if (tmp == -1) {
      {
#line 90
      outputerror(uih___2);
      }
    }
  } else {
#line 92
    first = 0;
  }
  {
#line 100
  sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%.20LG",
          number);
#line 101
  tmp___0 = (*(((uih___2->savec)->file)->fputs))((char const   *)(s), (uih___2->savec)->file);
  }
#line 101
  if (tmp___0 == -1) {
    {
#line 101
    outputerror(uih___2);
    }
  }
#line 111
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static void save_float2(struct uih_context *uih___2 , number_t number , int places ) 
{ 
  char fs[10] ;
  int tmp ;
  char s[256] ;
  int tmp___0 ;

  {
#line 118
  if (! first) {
    {
#line 119
    tmp = (*(((uih___2->savec)->file)->fputc))(' ', (uih___2->savec)->file);
    }
#line 119
    if (tmp == -1) {
      {
#line 119
      outputerror(uih___2);
      }
    }
  } else {
#line 121
    first = 0;
  }
#line 122
  if (places < 0) {
#line 123
    places = 0;
  }
#line 124
  if (places > 20) {
#line 125
    places = 20;
  }
  {
#line 133
  sprintf((char */* __restrict  */)(fs), (char const   */* __restrict  */)"%%.%iLG",
          places);
#line 134
  sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)(fs), number);
#line 135
  tmp___0 = (*(((uih___2->savec)->file)->fputs))((char const   *)(s), (uih___2->savec)->file);
  }
#line 135
  if (tmp___0 == -1) {
    {
#line 135
    outputerror(uih___2);
    }
  }
#line 146
  return;
}
}
#line 149 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static void save_int(struct uih_context *uih___2 , int number ) 
{ 
  char s[256] ;
  int tmp ;
  int tmp___0 ;

  {
#line 152
  if (! first) {
    {
#line 153
    tmp = (*(((uih___2->savec)->file)->fputc))(' ', (uih___2->savec)->file);
    }
#line 153
    if (tmp == -1) {
      {
#line 153
      outputerror(uih___2);
      }
    }
  } else {
#line 155
    first = 0;
  }
  {
#line 156
  sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%i", number);
#line 157
  tmp___0 = (*(((uih___2->savec)->file)->fputs))((char const   *)(s), (uih___2->savec)->file);
  }
#line 157
  if (tmp___0 == -1) {
    {
#line 157
    outputerror(uih___2);
    }
  }
#line 158
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static void save_onoff(struct uih_context *uih___2 , int number ) 
{ 
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 163
  if (! first) {
    {
#line 164
    tmp = (*(((uih___2->savec)->file)->fputc))(' ', (uih___2->savec)->file);
    }
#line 164
    if (tmp == -1) {
      {
#line 164
      outputerror(uih___2);
      }
    }
  } else {
#line 166
    first = 0;
  }
#line 167
  if (number) {
#line 167
    tmp___0 = "#t";
  } else {
#line 167
    tmp___0 = "#f";
  }
  {
#line 167
  tmp___1 = (*(((uih___2->savec)->file)->fputs))(tmp___0, (uih___2->savec)->file);
  }
#line 167
  if (tmp___1 == -1) {
    {
#line 167
    outputerror(uih___2);
    }
  }
#line 168
  return;
}
}
#line 171 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static void save_string(struct uih_context *uih___2 , char const   *text ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 173
  i = 0;
#line 174
  if (! first) {
    {
#line 175
    tmp = (*(((uih___2->savec)->file)->fputc))(' ', (uih___2->savec)->file);
    }
#line 175
    if (tmp == -1) {
      {
#line 175
      outputerror(uih___2);
      }
    }
  } else {
#line 177
    first = 0;
  }
  {
#line 178
  tmp___0 = (*(((uih___2->savec)->file)->fputc))('\"', (uih___2->savec)->file);
  }
#line 178
  if (tmp___0 == -1) {
    {
#line 178
    outputerror(uih___2);
    }
  }
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! ((int const   )*(text + i) != 0)) {
#line 179
      goto while_break;
    }
#line 180
    if ((int const   )*(text + i) == 34) {
      {
#line 181
      tmp___1 = (*(((uih___2->savec)->file)->fputc))('\\', (uih___2->savec)->file);
      }
#line 181
      if (tmp___1 == -1) {
        {
#line 181
        outputerror(uih___2);
        }
      }
    }
    {
#line 182
    tmp___2 = (*(((uih___2->savec)->file)->fputc))((int )*(text + i), (uih___2->savec)->file);
    }
#line 182
    if (tmp___2 == -1) {
      {
#line 182
      outputerror(uih___2);
      }
    }
#line 183
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 185
  tmp___3 = (*(((uih___2->savec)->file)->fputc))('\"', (uih___2->savec)->file);
  }
#line 185
  if (tmp___3 == -1) {
    {
#line 185
    outputerror(uih___2);
    }
  }
#line 186
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static void save_intc(struct uih_context *uih___2 , char const   *name___0 , int number ) 
{ 


  {
  {
#line 192
  start_save(uih___2, name___0);
#line 193
  save_int(uih___2, number);
#line 194
  stop_save(uih___2);
  }
#line 195
  return;
}
}
#line 198 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static void save_onoffc(struct uih_context *uih___2 , char const   *name___0 , int number ) 
{ 


  {
  {
#line 201
  start_save(uih___2, name___0);
#line 202
  save_onoff(uih___2, number);
#line 203
  stop_save(uih___2);
  }
#line 204
  return;
}
}
#line 207 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static void save_floatc(struct uih_context *uih___2 , char const   *name___0 , number_t number ) 
{ 


  {
  {
#line 210
  start_save(uih___2, name___0);
#line 211
  save_float(uih___2, number);
#line 212
  stop_save(uih___2);
  }
#line 213
  return;
}
}
#line 216 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static void save_float2c(struct uih_context *uih___2 , char const   *name___0 , number_t number ,
                         int places ) 
{ 


  {
  {
#line 220
  start_save(uih___2, name___0);
#line 221
  save_float2(uih___2, number, places);
#line 222
  stop_save(uih___2);
  }
#line 223
  return;
}
}
#line 226 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static void save_coordc(struct uih_context *uih___2 , char const   *name___0 , number_t number ,
                        number_t number2 ) 
{ 


  {
  {
#line 230
  start_save(uih___2, name___0);
#line 231
  save_float(uih___2, number);
#line 232
  save_float(uih___2, number2);
#line 233
  stop_save(uih___2);
  }
#line 234
  return;
}
}
#line 237 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static void save_keystringc(struct uih_context *uih___2 , char const   *name___0 ,
                            char const   *param ) 
{ 


  {
  {
#line 241
  start_save(uih___2, name___0);
#line 242
  save_keystring(uih___2, param);
#line 243
  stop_save(uih___2);
  }
#line 244
  return;
}
}
#line 247 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static void save_stringc(struct uih_context *uih___2 , char const   *name___0 , char const   *param ) 
{ 


  {
  {
#line 250
  start_save(uih___2, name___0);
#line 251
  save_string(uih___2, param);
#line 252
  stop_save(uih___2);
  }
#line 253
  return;
}
}
#line 256 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static void save_noparam(struct uih_context *uih___2 , char const   *name___0 ) 
{ 


  {
  {
#line 258
  start_save(uih___2, name___0);
#line 259
  stop_save(uih___2);
  }
#line 260
  return;
}
}
#line 263 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static void save_nstring(struct uih_context *uih___2 , int number , char const   * const  * const  texts ) 
{ 


  {
  {
#line 267
  save_keystring(uih___2, (char const   *)*(texts + number));
  }
#line 268
  return;
}
}
#line 271 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static void save_nstringc(struct uih_context *uih___2 , char const   *name___0 , int number ,
                          char const   * const  * const  texts ) 
{ 


  {
  {
#line 275
  save_keystringc(uih___2, name___0, (char const   *)*(texts + number));
  }
#line 276
  return;
}
}
#line 278 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static int ndecimals(struct uih_context *uih___2 ) 
{ 
  number_t n ;
  number_t m ;
  int i ;

  {
#line 280
  n = (number_t )10000;
#line 281
  m = (uih___2->fcontext)->s.rr;
#line 283
  if ((uih___2->fcontext)->s.ri < m) {
#line 284
    m = (uih___2->fcontext)->s.ri;
  }
#line 285
  if ((uih___2->fcontext)->s.ri > (number_t )100) {
#line 286
    return (20);
  } else
#line 285
  if ((uih___2->fcontext)->s.rr > (number_t )100) {
#line 286
    return (20);
  }
#line 287
  i = 0;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (i < 20) {
#line 287
      if (! (m < n)) {
#line 287
        goto while_break;
      }
    } else {
#line 287
      goto while_break;
    }
#line 287
    i ++;
#line 287
    n /= (number_t )10;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return (i);
}
}
#line 291
static void savepos(struct uih_context *uih___2 ) ;
#line 293 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static void savepos(struct uih_context *uih___2 ) 
{ 
  int n ;
  int tmp ;

  {
  {
#line 295
  tmp = ndecimals(uih___2);
#line 295
  n = tmp;
#line 296
  start_save(uih___2, "view");
#line 297
  save_float2(uih___2, (uih___2->fcontext)->s.cr, n);
#line 298
  save_float2(uih___2, (uih___2->fcontext)->s.ci, n);
#line 299
  save_float2(uih___2, (uih___2->fcontext)->s.rr, n);
#line 300
  save_float2(uih___2, (uih___2->fcontext)->s.ri, n);
#line 301
  stop_save(uih___2);
#line 302
  ((uih___2->savec)->fcontext)->s = (uih___2->fcontext)->s;
  }
#line 303
  return;
}
}
#line 305
static void savepos2(struct uih_context *uih___2 ) ;
#line 307 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static void savepos2(struct uih_context *uih___2 ) 
{ 
  int n ;
  int tmp ;

  {
  {
#line 309
  tmp = ndecimals(uih___2);
#line 309
  n = tmp;
#line 310
  start_save(uih___2, "animateview");
#line 311
  save_float2(uih___2, (uih___2->fcontext)->s.cr, n);
#line 312
  save_float2(uih___2, (uih___2->fcontext)->s.ci, n);
#line 313
  save_float2(uih___2, (uih___2->fcontext)->s.rr, n);
#line 314
  save_float2(uih___2, (uih___2->fcontext)->s.ri, n);
#line 315
  stop_save(uih___2);
#line 316
  ((uih___2->savec)->fcontext)->s = (uih___2->fcontext)->s;
  }
#line 317
  return;
}
}
#line 319
static void savepos3(struct uih_context *uih___2 ) ;
#line 321 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
static void savepos3(struct uih_context *uih___2 ) 
{ 
  int n ;
  int tmp ;

  {
  {
#line 323
  tmp = ndecimals(uih___2);
#line 323
  n = tmp;
#line 324
  start_save(uih___2, "morphview");
#line 325
  save_float2(uih___2, (uih___2->fcontext)->s.cr, n);
#line 326
  save_float2(uih___2, (uih___2->fcontext)->s.ci, n);
#line 327
  save_float2(uih___2, (uih___2->fcontext)->s.rr, n);
#line 328
  save_float2(uih___2, (uih___2->fcontext)->s.ri, n);
#line 329
  stop_save(uih___2);
#line 330
  ((uih___2->savec)->fcontext)->s = (uih___2->fcontext)->s;
  }
#line 331
  return;
}
}
#line 333 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
void uih_saveframe(struct uih_context *uih___2 ) 
{ 
  struct uih_savedcontext *s ;
  int i ;
  int resetsync ;
  int tmp ;
  int tmp___0 ;

  {
#line 335
  s = uih___2->savec;
#line 337
  resetsync = 0;
#line 338
  if (uih___2->save) {
#line 339
    changed = 0;
#line 340
    if (s->firsttime) {
      {
#line 341
      save_noparam(uih___2, "initstate");
      }
    }
#line 342
    if (s->nonfractalscreen) {
#line 342
      if (! uih___2->nonfractalscreen) {
        {
#line 343
        save_noparam(uih___2, "display");
#line 343
        s->nonfractalscreen = 0;
        }
      }
    }
#line 344
    i = (int )uih_nfilters;
    {
#line 344
    while (1) {
      while_continue: /* CIL Label */ ;
#line 344
      if (! (i >= 0)) {
#line 344
        goto while_break;
      }
#line 345
      if ((unsigned long )uih___2->filter[i] != (unsigned long )((void *)0)) {
#line 346
        if (s->filter[i] != 1) {
          {
#line 347
          start_save(uih___2, "filter");
#line 348
          save_keystring(uih___2, (char const   *)((uih___2->filter[i])->action)->shortname);
#line 349
          save_onoff(uih___2, 1);
#line 350
          s->filter[i] = 1;
#line 351
          stop_save(uih___2);
          }
        }
      } else
#line 353
      if (s->filter[i] != 0) {
        {
#line 354
        s->filter[i] = 0;
#line 355
        start_save(uih___2, "filter");
#line 356
        save_keystring(uih___2, (char const   *)(uih_filters[i])->shortname);
#line 357
        save_onoff(uih___2, 0);
#line 358
        stop_save(uih___2);
        }
      }
#line 344
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 361
    if (uih___2->palettechanged) {
      {
#line 363
      if (uih___2->palettetype == 0) {
#line 363
        goto case_0;
      }
#line 366
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 364
      save_intc(uih___2, "defaultpalette", uih___2->paletteshift);
      }
#line 365
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 367
      start_save(uih___2, "palette");
#line 368
      save_int(uih___2, uih___2->palettetype);
#line 369
      save_int(uih___2, uih___2->paletteseed);
#line 370
      save_int(uih___2, uih___2->paletteshift);
#line 371
      stop_save(uih___2);
      }
#line 372
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 374
      uih___2->palettechanged = 0;
#line 375
      s->manualpaletteshift = 0;
    }
#line 377
    if (s->manualpaletteshift != uih___2->manualpaletteshift) {
      {
#line 378
      save_intc(uih___2, "shiftpalette", uih___2->manualpaletteshift - s->manualpaletteshift);
#line 378
      s->manualpaletteshift = uih___2->manualpaletteshift;
      }
    }
#line 381
    if ((unsigned long )(s->fcontext)->currentformula != (unsigned long )(uih___2->fcontext)->currentformula) {
      {
#line 382
      save_keystringc(uih___2, "formula", (char const   *)((uih___2->fcontext)->currentformula)->shortname);
#line 382
      (s->fcontext)->currentformula = (uih___2->fcontext)->currentformula;
#line 399
      set_formula(s->fcontext, (int )((uih___2->fcontext)->currentformula - formulas));
      }
    }
#line 402
    if (s->mode >= 2) {
      {
#line 403
      save_intc(uih___2, "letterspersec", uih___2->letterspersec);
      }
    }
#line 404
    if (s->mode > 0) {
#line 405
      if (s->speedup != uih___2->speedup) {
        {
#line 406
        save_floatc(uih___2, "speedup", uih___2->speedup);
#line 406
        s->speedup = uih___2->speedup;
        }
      }
#line 408
      if (s->maxstep != uih___2->maxstep) {
        {
#line 409
        save_floatc(uih___2, "maxstep", uih___2->maxstep);
#line 409
        s->maxstep = uih___2->maxstep;
        }
      }
#line 411
      if (s->fastmode != uih___2->fastmode) {
        {
#line 412
        save_nstringc(uih___2, "fastmode", uih___2->fastmode, (char const   * const  */* const  */)(save_fastmode));
#line 412
        s->fastmode = uih___2->fastmode;
        }
      }
    }
#line 415
    if (s->juliamode != uih___2->juliamode) {
      {
#line 416
      save_onoffc(uih___2, "fastjulia", uih___2->juliamode);
#line 416
      s->juliamode = uih___2->juliamode;
      }
    }
#line 418
    if (s->cycling != uih___2->cycling) {
      {
#line 419
      save_onoffc(uih___2, "cycling", uih___2->cycling);
#line 419
      s->cycling = uih___2->cycling;
      }
    }
#line 421
    if (s->mode >= 0) {
#line 421
      if ((s->fcontext)->periodicity != (uih___2->fcontext)->periodicity) {
        {
#line 423
        save_onoffc(uih___2, "periodicity", (uih___2->fcontext)->periodicity);
#line 423
        (s->fcontext)->periodicity = (uih___2->fcontext)->periodicity;
        }
      }
    }
#line 425
    if (uih___2->cycling) {
#line 425
      goto _L;
    } else
#line 425
    if (s->mode >= 2) {
      _L: /* CIL Label */ 
#line 425
      if (s->cyclingspeed != uih___2->cyclingspeed) {
        {
#line 428
        save_intc(uih___2, "cyclingspeed", (uih___2->cyclingspeed * uih___2->direction) * uih___2->cyclingdirection);
#line 428
        s->cyclingspeed = uih___2->cyclingspeed;
#line 428
        s->direction = uih___2->direction * uih___2->cyclingdirection;
        }
      } else
#line 425
      if (s->direction != uih___2->direction * uih___2->cyclingdirection) {
        {
#line 428
        save_intc(uih___2, "cyclingspeed", (uih___2->cyclingspeed * uih___2->direction) * uih___2->cyclingdirection);
#line 428
        s->cyclingspeed = uih___2->cyclingspeed;
#line 428
        s->direction = uih___2->direction * uih___2->cyclingdirection;
        }
      }
    }
#line 433
    if (s->mode > 0) {
#line 433
      if (uih___2->step) {
#line 433
        goto _L___0;
      } else
#line 433
      if (uih___2->zoomactive) {
        _L___0: /* CIL Label */ 
#line 433
        if (s->xcenter != uih___2->xcenter) {
          {
#line 435
          save_coordc(uih___2, "zoomcenter", uih___2->xcenter, uih___2->ycenter);
#line 435
          s->xcenter = uih___2->xcenter;
#line 435
          s->ycenter = uih___2->ycenter;
          }
        } else
#line 433
        if (s->ycenter != uih___2->ycenter) {
          {
#line 435
          save_coordc(uih___2, "zoomcenter", uih___2->xcenter, uih___2->ycenter);
#line 435
          s->xcenter = uih___2->xcenter;
#line 435
          s->ycenter = uih___2->ycenter;
          }
        }
      }
    }
#line 437
    if (! (uih___2->fcontext)->mandelbrot) {
#line 437
      goto _L___2;
    } else
#line 437
    if (uih___2->juliamode) {
      _L___2: /* CIL Label */ 
#line 437
      if ((s->fcontext)->pre != (uih___2->fcontext)->pre) {
#line 437
        goto _L___1;
      } else
#line 437
      if ((s->fcontext)->pim != (uih___2->fcontext)->pim) {
        _L___1: /* CIL Label */ 
#line 440
        if (uih___2->juliamode) {
#line 440
          if (uih___2->pressed) {
            {
#line 441
            save_coordc(uih___2, "morphjulia", (uih___2->fcontext)->pre, (uih___2->fcontext)->pim);
#line 441
            (s->fcontext)->pre = (uih___2->fcontext)->pre;
#line 441
            (s->fcontext)->pim = (uih___2->fcontext)->pim;
            }
          } else {
            {
#line 446
            save_coordc(uih___2, "juliaseed", (uih___2->fcontext)->pre, (uih___2->fcontext)->pim);
#line 446
            (s->fcontext)->pre = (uih___2->fcontext)->pre;
#line 446
            (s->fcontext)->pim = (uih___2->fcontext)->pim;
            }
          }
        } else {
          {
#line 446
          save_coordc(uih___2, "juliaseed", (uih___2->fcontext)->pre, (uih___2->fcontext)->pim);
#line 446
          (s->fcontext)->pre = (uih___2->fcontext)->pre;
#line 446
          (s->fcontext)->pim = (uih___2->fcontext)->pim;
          }
        }
      }
    }
#line 451
    if ((uih___2->fcontext)->bre != (s->fcontext)->bre) {
      {
#line 453
      save_coordc(uih___2, "perturbation", (uih___2->fcontext)->bre, (uih___2->fcontext)->bim);
#line 453
      (s->fcontext)->bre = (uih___2->fcontext)->bre;
#line 453
      (s->fcontext)->bim = (uih___2->fcontext)->bim;
      }
    } else
#line 451
    if ((uih___2->fcontext)->bim != (s->fcontext)->bim) {
      {
#line 453
      save_coordc(uih___2, "perturbation", (uih___2->fcontext)->bre, (uih___2->fcontext)->bim);
#line 453
      (s->fcontext)->bre = (uih___2->fcontext)->bre;
#line 453
      (s->fcontext)->bim = (uih___2->fcontext)->bim;
      }
    }
#line 457
    if (uih___2->fastrotate != s->fastrotate) {
#line 457
      if (s->mode > 0) {
        {
#line 458
        save_onoffc(uih___2, "fastrotate", uih___2->fastrotate);
#line 459
        s->fastrotate = uih___2->fastrotate;
        }
      }
    }
#line 461
    if ((uih___2->fcontext)->angle != (s->fcontext)->angle) {
#line 461
      if (s->autorotate != 1) {
#line 463
        if (s->rotatepressed) {
#line 463
          if (s->mode == 1) {
            {
#line 464
            save_float2c(uih___2, "morphangle", (uih___2->fcontext)->angle, 5);
            }
          } else {
            {
#line 466
            save_float2c(uih___2, "angle", (uih___2->fcontext)->angle, 5);
            }
          }
        } else {
          {
#line 466
          save_float2c(uih___2, "angle", (uih___2->fcontext)->angle, 5);
          }
        }
#line 467
        s->rotatepressed = uih___2->rotatepressed;
#line 468
        (s->fcontext)->angle = (uih___2->fcontext)->angle;
      }
    }
#line 470
    if (uih___2->rotationspeed != s->rotationspeed) {
#line 470
      if (s->mode > 0) {
#line 470
        if (uih___2->rotatemode == 2) {
          {
#line 475
          save_float2c(uih___2, "rotationspeed", uih___2->rotationspeed, 6);
#line 476
          s->rotationspeed = uih___2->rotationspeed;
          }
        } else {
#line 470
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 470
      if (s->mode >= 2) {
        {
#line 475
        save_float2c(uih___2, "rotationspeed", uih___2->rotationspeed, 6);
#line 476
        s->rotationspeed = uih___2->rotationspeed;
        }
      }
    }
#line 478
    if (s->autorotate != (uih___2->rotatemode == 2)) {
      {
#line 479
      s->autorotate = uih___2->rotatemode == 2;
#line 480
      save_onoffc(uih___2, "autorotate", s->autorotate);
      }
    }
#line 482
    if ((s->fcontext)->maxiter != (uih___2->fcontext)->maxiter) {
      {
#line 483
      save_intc(uih___2, "maxiter", (int )(uih___2->fcontext)->maxiter);
#line 483
      (s->fcontext)->maxiter = (uih___2->fcontext)->maxiter;
      }
    }
#line 485
    if ((s->fcontext)->bailout != (uih___2->fcontext)->bailout) {
      {
#line 486
      save_floatc(uih___2, "bailout", (uih___2->fcontext)->bailout);
#line 486
      (s->fcontext)->bailout = (uih___2->fcontext)->bailout;
      }
    }
#line 488
    if ((s->fcontext)->coloringmode != (uih___2->fcontext)->coloringmode) {
      {
#line 489
      save_intc(uih___2, "outcoloring", (uih___2->fcontext)->coloringmode);
#line 489
      (s->fcontext)->coloringmode = (uih___2->fcontext)->coloringmode;
      }
    }
#line 491
    if ((s->fcontext)->incoloringmode != (uih___2->fcontext)->incoloringmode) {
      {
#line 492
      save_intc(uih___2, "incoloring", (uih___2->fcontext)->incoloringmode);
#line 492
      (s->fcontext)->incoloringmode = (uih___2->fcontext)->incoloringmode;
      }
    }
#line 495
    if ((s->fcontext)->incoloringmode != (uih___2->fcontext)->incoloringmode) {
      {
#line 496
      save_intc(uih___2, "incoloring", (uih___2->fcontext)->incoloringmode);
#line 496
      (s->fcontext)->incoloringmode = (uih___2->fcontext)->incoloringmode;
      }
    }
#line 499
    if ((s->fcontext)->incoloringmode == 10) {
#line 499
      goto _L___4;
    } else
#line 499
    if (s->mode >= 2) {
      _L___4: /* CIL Label */ 
#line 499
      if ((s->fcontext)->intcolor != (uih___2->fcontext)->intcolor) {
        {
#line 501
        save_intc(uih___2, "intcoloring", (uih___2->fcontext)->intcolor);
#line 501
        (s->fcontext)->intcolor = (uih___2->fcontext)->intcolor;
        }
      }
    }
#line 503
    if ((s->fcontext)->coloringmode == 10) {
#line 503
      goto _L___5;
    } else
#line 503
    if (s->mode >= 2) {
      _L___5: /* CIL Label */ 
#line 503
      if ((s->fcontext)->outtcolor != (uih___2->fcontext)->outtcolor) {
        {
#line 505
        save_intc(uih___2, "outtcoloring", (uih___2->fcontext)->outtcolor);
#line 505
        (s->fcontext)->outtcolor = (uih___2->fcontext)->outtcolor;
        }
      }
    }
#line 507
    if ((s->fcontext)->mandelbrot != (uih___2->fcontext)->mandelbrot) {
      {
#line 508
      save_onoffc(uih___2, "julia", ! (uih___2->fcontext)->mandelbrot);
#line 508
      (s->fcontext)->mandelbrot = (uih___2->fcontext)->mandelbrot;
      }
    }
#line 510
    if (s->mode > 0) {
#line 510
      if ((s->fcontext)->range != (uih___2->fcontext)->range) {
        {
#line 512
        save_intc(uih___2, "range", (uih___2->fcontext)->range);
#line 512
        (s->fcontext)->range = (uih___2->fcontext)->range;
        }
      }
    }
#line 514
    if ((s->fcontext)->plane != (uih___2->fcontext)->plane) {
      {
#line 515
      save_intc(uih___2, "plane", (uih___2->fcontext)->plane);
#line 515
      (s->fcontext)->plane = (uih___2->fcontext)->plane;
      }
    }
#line 517
    if (s->zoomactive != uih___2->zoomactive) {
#line 517
      if (s->mode > 0) {
        {
#line 519
        if (uih___2->zoomactive == -1) {
#line 519
          goto case_neg_1;
        }
#line 522
        if (uih___2->zoomactive == 1) {
#line 522
          goto case_1;
        }
#line 525
        goto switch_default___0;
        case_neg_1: /* CIL Label */ 
        {
#line 520
        save_noparam(uih___2, "unzoom");
        }
#line 521
        goto switch_break___0;
        case_1: /* CIL Label */ 
        {
#line 523
        save_noparam(uih___2, "zoom");
        }
#line 524
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
        {
#line 526
        save_noparam(uih___2, "stop");
        }
#line 527
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 529
        s->zoomactive = uih___2->zoomactive;
      }
    }
#line 531
    if (s->mode >= 0) {
#line 531
      goto _L___6;
    } else
#line 531
    if (uih___2->displaytext) {
      _L___6: /* CIL Label */ 
#line 531
      if (s->color != uih___2->color) {
        {
#line 533
        start_save(uih___2, "color");
#line 534
        save_nstring(uih___2, uih___2->color, (char const   * const  */* const  */)(uih_colornames));
#line 535
        stop_save(uih___2);
#line 536
        s->color = uih___2->color;
        }
      }
    }
#line 538
    if (s->clearscreen) {
      {
#line 539
      save_noparam(uih___2, "clearscreen");
#line 540
      s->clearscreen = 0;
#line 541
      s->nonfractalscreen = 1;
      }
    }
#line 543
    if (uih___2->displaytext) {
#line 544
      i = 0;
      {
#line 544
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 544
        if (! (i < 3)) {
#line 544
          goto while_break___0;
        }
#line 545
        if (uih___2->displaytext & (1 << i)) {
#line 546
          if (s->ytextpos != i) {
#line 546
            goto _L___7;
          } else
#line 546
          if (s->xtextpos != uih___2->textpos[i]) {
            _L___7: /* CIL Label */ 
            {
#line 547
            start_save(uih___2, "textpossition");
#line 548
            save_nstring(uih___2, uih___2->xtextpos, (char const   * const  */* const  */)(xtextposnames));
#line 549
            save_nstring(uih___2, uih___2->ytextpos, (char const   * const  */* const  */)(ytextposnames));
#line 550
            stop_save(uih___2);
#line 551
            s->xtextpos = uih___2->xtextpos;
#line 552
            s->ytextpos = uih___2->ytextpos;
            }
          }
          {
#line 554
          save_stringc(uih___2, "text", (char const   *)uih___2->text[i]);
#line 555
          s->nonfractalscreen = 1;
          }
        }
#line 544
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 558
      save_noparam(uih___2, "textsleep");
#line 559
      uih___2->displaytext = 0;
      }
    }
#line 561
    if (s->autorotate) {
#line 561
      if (changed) {
        {
#line 561
        tmp = tl_lookup_timer((uih___2->savec)->synctimer);
        }
#line 561
        if (tmp > 500000) {
          {
#line 563
          save_float2c(uih___2, "angle", (uih___2->fcontext)->angle, 5);
#line 563
          resetsync = 1;
          }
        }
      }
    }
#line 565
    if (s->mode == 0) {
      {
#line 566
      savepos(uih___2);
      }
    } else
#line 568
    if (uih___2->viewchanged) {
      {
#line 569
      savepos(uih___2);
#line 569
      uih___2->viewchanged = 0;
      }
    } else
#line 570
    if (uih___2->moved) {
      {
#line 571
      savepos3(uih___2);
#line 571
      uih___2->moved = 0;
      }
    } else
#line 572
    if (changed) {
#line 572
      if (uih___2->step) {
#line 572
        goto _L___8;
      } else {
#line 572
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 572
    if (last) {
      _L___8: /* CIL Label */ 
      {
#line 572
      tmp___0 = tl_lookup_timer((uih___2->savec)->synctimer);
      }
#line 572
      if (tmp___0 > 500000) {
        {
#line 574
        resetsync = 1;
#line 574
        savepos2(uih___2);
        }
      }
    }
#line 576
    if ((uih___2->savec)->firsttime) {
#line 577
      (uih___2->savec)->firsttime = 0;
    }
#line 578
    if (s->writefailed) {
      {
#line 579
      uih_save_disable(uih___2);
      }
    }
#line 580
    if (resetsync) {
      {
#line 581
      tl_reset_timer((uih___2->savec)->synctimer);
      }
    }
  }
#line 583
  return;
}
}
#line 585 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
int uih_save_enable(struct uih_context *uih___2 , xio_file f , int mode ) 
{ 
  struct uih_savedcontext *s ;
  int i ;
  void *tmp ;
  number_t tmp___0 ;
  number_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 589
  last = 0;
#line 590
  if (uih___2->save) {
    {
#line 591
    uih_error(uih___2, "Recording is already enabled");
    }
#line 592
    return (0);
  }
  {
#line 594
  tmp = calloc((size_t )1, sizeof(*s));
#line 594
  s = (struct uih_savedcontext *)tmp;
  }
#line 595
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 596
    uih_error(uih___2, "File could not be opended or out of memory");
    }
#line 597
    return (0);
  } else
#line 595
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 596
    uih_error(uih___2, "File could not be opended or out of memory");
    }
#line 597
    return (0);
  }
  {
#line 599
  uih___2->savec = s;
#line 600
  s->fcontext = make_fractalc((int const   )1, (uih___2->image)->pixelwidth * (float )(uih___2->image)->width,
                              (uih___2->image)->pixelheight * (float )(uih___2->image)->height);
  }
#line 603
  if ((unsigned long )s->fcontext == (unsigned long )((void *)0)) {
    {
#line 604
    uih_error(uih___2, "File could not be opended or out of memory");
    }
#line 605
    return (0);
  }
#line 607
  s->mode = mode;
#line 609
  s->speedup = (number_t )(0.0006 * (double )3);
#line 610
  s->maxstep = (number_t )(0.008 * (double )3);
#line 611
  s->xcenter = (number_t )2147483647;
#line 612
  s->fastmode = 2;
#line 613
  s->juliamode = 0;
#line 614
  s->cycling = 0;
#line 615
  i = 0;
  {
#line 615
  while (1) {
    while_continue: /* CIL Label */ ;
#line 615
    if (! (i < (int )uih_nfilters)) {
#line 615
      goto while_break;
    }
#line 616
    s->filter[i] = 0;
#line 615
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 617
  s->pressed = 0;
#line 618
  s->firsttime = 1;
#line 619
  uih___2->palettechanged = 1;
#line 620
  s->cyclingspeed = 30;
#line 621
  tmp___0 = (number_t )0;
#line 621
  (s->fcontext)->pim = tmp___0;
#line 621
  (s->fcontext)->pre = tmp___0;
#line 622
  tmp___1 = (number_t )0;
#line 622
  (s->fcontext)->bim = tmp___1;
#line 622
  (s->fcontext)->bre = tmp___1;
#line 623
  (s->fcontext)->currentformula = (struct formula  const  *)((void *)0);
#line 624
  (s->fcontext)->periodicity = 1;
#line 625
  (s->fcontext)->maxiter = 170U;
#line 626
  (s->fcontext)->bailout = (number_t )4;
#line 627
  (s->fcontext)->coloringmode = 0;
#line 628
  (s->fcontext)->incoloringmode = 0;
#line 629
  (s->fcontext)->outtcolor = 0;
#line 630
  (s->fcontext)->intcolor = 0;
#line 631
  (s->fcontext)->mandelbrot = 1;
#line 632
  (s->fcontext)->plane = 0;
#line 633
  (s->fcontext)->range = 3;
#line 634
  (s->fcontext)->angle = (number_t )0;
#line 635
  s->rotatepressed = 0;
#line 636
  s->autorotate = 0;
#line 637
  s->fastrotate = 0;
#line 638
  s->rotationspeed = (number_t )10;
#line 639
  s->clearscreen = 0;
#line 640
  s->color = 0;
#line 641
  s->xtextpos = 1;
#line 642
  s->ytextpos = 1;
#line 643
  s->file = f;
#line 644
  s->timer = tl_create_timer();
#line 645
  s->synctimer = tl_create_timer();
#line 646
  uih___2->viewchanged = 1;
#line 647
  uih___2->palettechanged = 1;
#line 648
  uih___2->save = 1;
#line 649
  uih_emulatetimers(uih___2);
#line 650
  tl_reset_timer(s->timer);
#line 651
  uih___2->moved = 0;
  }
#line 653
  if (mode == 1) {
    {
#line 654
    tmp___2 = (*(((uih___2->savec)->file)->fputs))(";Animation file automatically generated by XaoS 3.5\n;  - a realtime interactive fractal zoomer\n;Use xaos -play <filename> to replay it\n",
                                                   (uih___2->savec)->file);
    }
#line 654
    if (tmp___2 == -1) {
      {
#line 654
      outputerror(uih___2);
      }
    }
  } else
#line 658
  if (mode == 0) {
    {
#line 659
    tmp___3 = (*(((uih___2->savec)->file)->fputs))(";Position file automatically generated by XaoS 3.5\n;  - a realtime interactive fractal zoomer\n;Use xaos -load <filename> to display it\n",
                                                   (uih___2->savec)->file);
    }
#line 659
    if (tmp___3 == -1) {
      {
#line 659
      outputerror(uih___2);
      }
    }
  }
  {
#line 664
  uih_saveframe(uih___2);
  }
#line 665
  if ((unsigned long )uih___2->updatemenus != (unsigned long )((void *)0)) {
    {
#line 665
    (*(uih___2->updatemenus))(uih___2, "save");
    }
  }
  {
#line 666
  (*(f->fputc))('\n', f);
  }
#line 667
  return (1);
}
}
#line 670 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
void uih_save_disable(struct uih_context *uih___2 ) 
{ 
  int tmp ;

  {
#line 672
  if (uih___2->save) {
#line 673
    last = 1;
#line 674
    if ((uih___2->savec)->mode >= 1) {
      {
#line 675
      uih_saveframe(uih___2);
      }
    }
    {
#line 676
    tmp = (*(((uih___2->savec)->file)->fclose))((uih___2->savec)->file);
    }
#line 676
    if (tmp) {
      {
#line 677
      outputerror(uih___2);
      }
    }
    {
#line 678
    uih___2->save = 0;
#line 679
    free((void *)(uih___2->savec)->fcontext);
#line 680
    tl_free_timer((uih___2->savec)->timer);
#line 681
    tl_free_timer((uih___2->savec)->synctimer);
#line 682
    free((void *)uih___2->savec);
    }
#line 683
    if ((unsigned long )uih___2->updatemenus != (unsigned long )((void *)0)) {
      {
#line 683
      (*(uih___2->updatemenus))(uih___2, "save");
      }
    }
  }
#line 685
  return;
}
}
#line 687 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/save.c"
void uih_save_possition(struct uih_context *uih___2 , xio_file f , int mode ) 
{ 
  struct uih_savedcontext *c ;
  int save ;
  int vc ;
  int pc ;
  int mov ;
  int tmp ;

  {
  {
#line 689
  c = uih___2->savec;
#line 690
  save = uih___2->save;
#line 691
  vc = uih___2->viewchanged;
#line 692
  pc = uih___2->palettechanged;
#line 693
  tmp = 0;
#line 693
  uih___2->moved = tmp;
#line 693
  mov = tmp;
#line 694
  uih___2->moved = 0;
#line 695
  uih___2->save = 0;
#line 696
  uih___2->savec = (struct uih_savedcontext *)((void *)0);
#line 697
  uih_save_enable(uih___2, f, mode);
#line 698
  uih_save_disable(uih___2);
#line 699
  uih___2->savec = c;
#line 700
  uih___2->save = save;
#line 701
  uih___2->viewchanged = vc;
#line 702
  uih___2->palettechanged = pc;
#line 703
  mov = uih___2->moved;
  }
#line 704
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/timers.h"
extern void tl_set_interval(tl_timer *timer , int interval ) ;
#line 39
extern void tl_set_handler(tl_timer *timer , void (*handler)(void * ) , void *userdata ) ;
#line 44
extern void tl_add_timer(tl_group *group , tl_timer *timer ) ;
#line 45
extern void tl_remove_timer(tl_timer *timer ) ;
#line 50
extern void tl_slowdown_timer(tl_timer *t , int time ) ;
#line 52
extern tl_group *syncgroup ;
#line 505 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui_helper.h"
void uih_scrollup(uih_context *c ) ;
#line 506
void uih_clearmessages(uih_context *c ) ;
#line 509
void uih_rmmessage(uih_context *c , int pid___1 ) ;
#line 510
void uih_printmessages(uih_context *c ) ;
#line 536
void uih_initmessages(uih_context *c ) ;
#line 537
void uih_destroymessages(uih_context *c ) ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xerror.h"
extern void x_message(char *text  , ...) ;
#line 16 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/messg.c"
static void getpos(uih_context *c , int *x , int *y , int *w , int *h , void *data ) 
{ 
  int n ;
  int he ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 19
  n = (int )data;
#line 20
  if ((unsigned long )c->messg.message[n] != (unsigned long )((void *)0)) {
    {
#line 21
    he = (int )((c->font)->height + 1);
#line 22
    *y = c->messg.messagestart + he * n;
#line 23
    *h = he;
#line 24
    *w = xtextwidth(c->font, (char const   *)c->messg.message[n]);
#line 25
    *x = ((c->image)->width - *w) / 2;
    }
  } else {
#line 27
    tmp___1 = 0;
#line 27
    *y = tmp___1;
#line 27
    tmp___0 = tmp___1;
#line 27
    *x = tmp___0;
#line 27
    tmp = tmp___0;
#line 27
    *h = tmp;
#line 27
    *w = tmp;
  }
#line 29
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/messg.c"
static void draw(uih_context *c , void *data ) 
{ 
  int x ;
  int y ;
  int w ;
  int n ;
  int h ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 34
  n = (int )data;
#line 35
  if ((unsigned long )c->messg.message[n] != (unsigned long )((void *)0)) {
    {
#line 36
    h = (int )((c->font)->height + 1);
#line 37
    y = c->messg.messagestart + h * n;
#line 38
    w = xtextwidth(c->font, (char const   *)c->messg.message[n]);
#line 39
    x = ((c->image)->width - w) / 2;
    }
#line 40
    if (c->messg.messagetype[n]) {
#line 41
      if ((c->image)->flags & 4) {
#line 41
        tmp = *((c->palette)->index + 0);
      } else {
#line 41
        tmp = *((c->palette)->index + 2);
      }
      {
#line 41
      xprint(c->image, c->font, x, y, (char const   *)c->messg.message[n], c->encoding,
             (int )tmp, (int )*((c->palette)->index + 0), 0);
      }
    } else {
#line 46
      if ((c->image)->flags & 4) {
#line 46
        tmp___0 = *((c->palette)->index + 0);
      } else {
#line 46
        tmp___0 = *((c->palette)->index + 1);
      }
      {
#line 46
      xprint(c->image, c->font, x, y, (char const   *)c->messg.message[n], c->encoding,
             (int )tmp___0, (int )*((c->palette)->index + 0), 0);
      }
    }
  }
#line 51
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/messg.c"
void uih_rmmessage(uih_context *c , int pid___1 ) 
{ 
  int i ;

  {
#line 56
  i = 0;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (i < 5) {
#line 56
      if (! (c->messg.pid[i] != pid___1)) {
#line 56
        goto while_break;
      }
    } else {
#line 56
      goto while_break;
    }
#line 56
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  if (i == 5) {
#line 58
    return;
  }
#line 59
  if ((unsigned long )c->messg.message[i] == (unsigned long )((void *)0)) {
#line 60
    return;
  }
  {
#line 61
  free((void *)c->messg.message[i]);
#line 62
  tl_remove_timer(c->messg.messagetimer[i]);
#line 63
  tl_free_timer(c->messg.messagetimer[i]);
#line 64
  c->messg.message[i] = (char *)((void *)0);
  }
  {
#line 65
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 65
    if (! (i < 4)) {
#line 65
      goto while_break___0;
    }
#line 66
    c->messg.message[i] = c->messg.message[i + 1];
#line 67
    c->messg.messagetimer[i] = c->messg.messagetimer[i + 1];
#line 68
    c->messg.messagetype[i] = c->messg.messagetype[i + 1];
#line 69
    c->messg.pid[i] = c->messg.pid[i + 1];
#line 65
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 71
  c->messg.message[4] = (char *)((void *)0);
#line 72
  c->display = 1;
#line 73
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/messg.c"
void uih_scrollup(uih_context *c ) 
{ 


  {
  {
#line 77
  uih_rmmessage(c, c->messg.pid[0]);
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/messg.c"
void uih_clearmessages(uih_context *c ) 
{ 


  {
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! ((unsigned long )c->messg.message[0] != (unsigned long )((void *)0))) {
#line 82
      goto while_break;
    }
    {
#line 83
    uih_scrollup(c);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/messg.c"
void uih_initmessages(uih_context *c ) 
{ 
  int i ;

  {
#line 89
  i = 0;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (i < 5)) {
#line 89
      goto while_break;
    }
    {
#line 90
    c->messg.message[i] = (char *)((void *)0);
#line 91
    c->messg.w[i] = uih_registerw(c, & getpos, & draw, (void *)i, 0);
#line 89
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  c->messg.messagestart = 0;
#line 94
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/messg.c"
void uih_destroymessages(uih_context *c ) 
{ 
  int i ;

  {
  {
#line 99
  uih_clearmessages(c);
#line 100
  i = 0;
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i < 5)) {
#line 100
      goto while_break;
    }
    {
#line 101
    uih_removew(c, c->messg.w[i]);
#line 100
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/messg.c"
static int pid  ;
#line 104 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/messg.c"
static int uih_message1(uih_context *c , char const   *message , int type ) 
{ 
  int i ;

  {
#line 108
  i = 0;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (i < 5) {
#line 108
      if (! ((unsigned long )c->messg.message[i] != (unsigned long )((void *)0))) {
#line 108
        goto while_break;
      }
    } else {
#line 108
      goto while_break;
    }
#line 108
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  if (i == 5) {
    {
#line 110
    uih_scrollup(c);
#line 110
    i --;
    }
  }
  {
#line 111
  c->messg.message[i] = mystrdup(message);
#line 112
  c->messg.messagetype[i] = type;
#line 113
  c->messg.messagetimer[i] = tl_create_timer();
#line 114
  tl_reset_timer(c->messg.messagetimer[i]);
#line 115
  tl_set_interval(c->messg.messagetimer[i], 1);
#line 116
  tl_slowdown_timer(c->messg.messagetimer[i], 4000000);
#line 117
  tl_set_handler(c->messg.messagetimer[i], (void (*)(void * ))(& uih_scrollup), (void *)c);
#line 119
  tl_add_timer(syncgroup, c->messg.messagetimer[i]);
#line 121
  pid ++;
#line 121
  c->messg.pid[i] = pid;
#line 122
  c->display = 1;
  }
#line 123
  return (pid);
}
}
#line 126 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/messg.c"
int uih_message(uih_context *c , char const   *message ) 
{ 
  int tmp ;

  {
#line 128
  if (c->inhibittextoutput) {
#line 129
    return (0);
  }
  {
#line 131
  tmp = uih_message1(c, message, 0);
  }
#line 131
  return (tmp);
}
}
#line 134 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/messg.c"
int uih_error(uih_context *c , char const   *error___1 ) 
{ 
  char str___0[256] ;
  int tmp ;

  {
  {
#line 137
  sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)"Error: %s",
          error___1);
#line 138
  c->errstring = error___1;
#line 139
  tmp = uih_message1(c, (char const   *)(str___0), 1);
  }
#line 139
  return (tmp);
}
}
#line 142 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/messg.c"
void uih_printmessages(uih_context *c ) 
{ 
  int i ;

  {
#line 145
  i = 0;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (i < 5) {
#line 145
      if (! ((unsigned long )c->messg.message[i] != (unsigned long )((void *)0))) {
#line 145
        goto while_break;
      }
    } else {
#line 145
      goto while_break;
    }
    {
#line 146
    x_message(c->messg.message[i], stderr);
#line 145
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return;
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 41 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/timers.h"
extern void tl_set_multihandler(tl_timer *timer , void (*handler)(void * , int  ) ,
                                void *userdata ) ;
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 71 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uiint.h"
void ui_pipe_init(char const   *name___0 ) ;
#line 19 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/pipecmd.c"
static int pipefd  =    -1;
#line 20 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/pipecmd.c"
tl_timer *pipetimer  ;
#line 21 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/pipecmd.c"
static char pipecommand[256]  ;
#line 22 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/pipecmd.c"
static int commandpos  ;
#line 23 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/pipecmd.c"
static int textmode  =    0;
#line 24 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/pipecmd.c"
static int backslash  =    0;
#line 25 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/pipecmd.c"
static int nest  =    -1;
#line 27 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/pipecmd.c"
static void ui_pipe_handler(void *data , int q ) 
{ 
  char buf[100] ;
  int n ;
  ssize_t tmp ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 31
  tmp = read(pipefd, (void *)(buf), (size_t )100);
#line 31
  n = (int )tmp;
  }
#line 33
  if (n > 0) {
#line 34
    buf[n] = (char)0;
  }
#line 36
  i = 0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! (i < n)) {
#line 36
      goto while_break;
    }
#line 37
    if (backslash) {
#line 38
      tmp___0 = commandpos;
#line 38
      commandpos ++;
#line 38
      pipecommand[tmp___0] = buf[i];
#line 39
      goto __Cont;
    }
#line 41
    if (textmode) {
#line 42
      if ((int )buf[i] == 92) {
#line 43
        tmp___1 = commandpos;
#line 43
        commandpos ++;
#line 43
        pipecommand[tmp___1] = buf[i];
#line 44
        backslash = 1;
#line 45
        goto __Cont;
      }
#line 47
      if ((int )buf[i] == 34) {
#line 48
        tmp___2 = commandpos;
#line 48
        commandpos ++;
#line 48
        pipecommand[tmp___2] = buf[i];
#line 49
        textmode = 0;
#line 50
        goto __Cont;
      }
#line 52
      tmp___3 = commandpos;
#line 52
      commandpos ++;
#line 52
      pipecommand[tmp___3] = buf[i];
    } else {
#line 54
      tmp___4 = commandpos;
#line 54
      commandpos ++;
#line 54
      pipecommand[tmp___4] = buf[i];
#line 55
      if ((int )buf[i] == 34) {
#line 56
        textmode = 1;
      }
#line 57
      if ((int )buf[i] == 41) {
#line 58
        nest --;
      }
#line 59
      if ((int )buf[i] == 40) {
#line 60
        if (nest == -1) {
#line 61
          nest = 1;
        } else {
#line 63
          nest ++;
        }
      }
#line 65
      if (! nest) {
        {
#line 66
        tmp___5 = commandpos;
#line 66
        commandpos ++;
#line 66
        pipecommand[tmp___5] = (char)0;
#line 67
        uih_command(uih, (char const   *)(pipecommand));
#line 68
        nest = -1;
#line 69
        commandpos = 0;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 36
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/pipecmd.c"
void ui_pipe_init(char const   *name___0 ) 
{ 
  size_t tmp ;

  {
  {
#line 79
  tmp = strlen(name___0);
  }
#line 79
  if ((int )tmp == 1) {
#line 79
    if ((int const   )*(name___0 + 0) == 45) {
      {
#line 80
      pipefd = 0;
#line 81
      fcntl(pipefd, 4, 2048);
      }
    } else {
#line 79
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 83
    pipefd = open(name___0, 2048);
    }
#line 84
    if (pipefd == -1) {
      {
#line 85
      perror(name___0);
#line 86
      exit(1);
      }
    }
  }
  {
#line 89
  pipetimer = tl_create_timer();
#line 90
  tl_set_multihandler(pipetimer, & ui_pipe_handler, (void *)0);
#line 91
  tl_reset_timer(pipetimer);
#line 92
  tl_set_interval(pipetimer, 100000);
#line 93
  tl_add_timer(syncgroup, pipetimer);
  }
#line 101
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/filter.h"
extern int mkdefaultpalette(struct palette *palette ) ;
#line 35 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/timers.h"
extern void tl_update_time(void) ;
#line 48
extern void tl_stop_timer(tl_timer *t ) ;
#line 388 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui_helper.h"
void uih_setcomplettehandler(uih_context *c , void (*h)(void * ) , void *d ) ;
#line 436
void uih_load(struct uih_context *uih___2 , xio_file f , xio_constpath filename___0 ) ;
#line 439
void uih_playupdate(struct uih_context *uih___2 ) ;
#line 441
void uih_skipframe(struct uih_context *uih___2 ) ;
#line 442
int uih_replayenable(struct uih_context *uih___2 , xio_file f , xio_constpath filename___0 ,
                     int animr ) ;
#line 456
void uih_update_lines(uih_context *c ) ;
#line 460
void uih_stoptimers(uih_context *c ) ;
#line 472
int uih_fastrotateenable(uih_context *c ) ;
#line 475
void uih_rotatemode(uih_context *c , int mode ) ;
#line 480
int uih_loadcatalog(uih_context *c , char const   *name___0 ) ;
#line 481
void uih_freecatalog(uih_context *c ) ;
#line 498
extern void uih_setline(struct uih_context *uih , struct uih_window *w , int color ,
                        int x1 , int y1 , int x2 , int y2 ) ;
#line 500
extern struct uih_window *uih_registerline(struct uih_context *uih , int color , int x1 ,
                                           int y1 , int x2 , int y2 ) ;
#line 522
void uih_setfont(struct uih_context *uih___2 ) ;
#line 19 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/catalog.h"
extern char *find_text(catalog_t *catalog , char const   *name ) ;
#line 21
extern catalog_t *load_catalog(xio_file f , char const   **error ) ;
#line 23
extern void free_catalog(catalog_t * ) ;
#line 359 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xmenu.h"
extern char const   *menu_processcommand(struct uih_context *uih , char *(*f)(struct uih_context *c ) ,
                                         int scheme , int mask , char const   *root ) ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/grlib.h"
extern struct xfont  const  xsmallfont ;
#line 6
extern struct xfont  const  xbigfont ;
#line 6
extern struct xfont  const  xbigfont2 ;
#line 6
extern struct xfont  const  xaafont ;
#line 6
extern struct xfont  const  xsmallfontil1 ;
#line 6
extern struct xfont  const  xbigfontil1 ;
#line 6
extern struct xfont  const  xmedfontil1 ;
#line 6
extern struct xfont  const  xbigfont3 ;
#line 35 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.h"
void uih_playcalculate(struct uih_context *uih___2 ) ;
#line 32 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
static int nonblockmode  ;
#line 33 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
static catalog_t *catalog  ;
#line 34 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
static char const   *errstring  ;
#line 37 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
static char token[1024]  ;
#line 38 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
static int first___0  ;
#line 39 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
static int last___0  ;
#line 40 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
static int parsenext  ;
#line 42 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
static char const   * const  animroot  =    (char const   */* const  */)"animroot";
#line 44 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
__inline static struct uih_line *uih_findkey(uih_context *c , int key ) 
{ 
  struct uih_line *l ;

  {
#line 46
  l = (c->playc)->lines.first;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 47
      goto while_break;
    }
#line 48
    if (l->key == key) {
#line 49
      return (l);
    }
#line 50
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return ((struct uih_line *)((void *)0));
}
}
#line 55 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
__inline static void uih_removeline(uih_context *c , struct uih_line *l ) 
{ 


  {
#line 57
  if ((unsigned long )l == (unsigned long )((void *)0)) {
#line 58
    return;
  }
  {
#line 59
  uih_removew(c, l->w);
  }
#line 60
  if (l->prev) {
#line 61
    (l->prev)->next = l->next;
  } else {
#line 63
    (c->playc)->lines.first = l->next;
  }
#line 64
  if (l->next) {
#line 65
    (l->next)->prev = l->prev;
  }
  {
#line 66
  free((void *)l);
  }
#line 67
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_line(uih_context *c , dialogparam *d ) 
{ 
  struct uih_window *w ;
  struct uih_line *l ;
  char *tmp ;
  struct uih_line *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 73
  if ((unsigned long )c->playstring != (unsigned long )((void *)0)) {
#line 74
    if ((unsigned long )errstring == (unsigned long )((void *)0)) {
      {
#line 74
      tmp = gettext("line available only in animation replay");
#line 74
      errstring = (char const   *)tmp;
      }
    }
#line 75
    return;
  }
  {
#line 77
  w = uih_registerline(c, 0, -1, -1, -1, -1);
#line 78
  tmp___0 = uih_findkey(c, (c->playc)->lines.currkey);
#line 78
  uih_removeline(c, tmp___0);
#line 79
  tmp___1 = calloc((size_t )1, sizeof(*l));
#line 79
  l = (struct uih_line *)tmp___1;
#line 80
  l->posmode = (d + 0)->dint;
#line 81
  l->w = w;
#line 82
  l->x1 = (d + 1)->dcoord[0];
#line 83
  l->y1 = (d + 1)->dcoord[1];
#line 84
  l->x2 = (d + 2)->dcoord[0];
#line 85
  l->y2 = (d + 2)->dcoord[1];
#line 86
  l->color = c->color;
#line 87
  l->morph = 0;
#line 88
  tmp___2 = (c->playc)->lines.currkey;
#line 88
  ((c->playc)->lines.currkey) ++;
#line 88
  l->key = tmp___2;
#line 89
  l->prev = (struct uih_line *)((void *)0);
#line 90
  l->next = (c->playc)->lines.first;
#line 91
  (c->playc)->lines.first = l;
  }
#line 92
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_morphline(uih_context *c , dialogparam *d ) 
{ 
  struct uih_line *l ;
  char *tmp ;

  {
  {
#line 97
  l = uih_findkey(c, (c->playc)->lines.currkey);
  }
#line 98
  if ((unsigned long )l == (unsigned long )((void *)0)) {
#line 99
    if ((unsigned long )errstring == (unsigned long )((void *)0)) {
      {
#line 99
      tmp = gettext("Morphing non existing line!");
#line 99
      errstring = (char const   *)tmp;
      }
    }
#line 100
    return;
  }
#line 102
  ((c->playc)->lines.currkey) ++;
#line 103
  l->mposmode = (d + 0)->dint;
#line 104
  l->mx1 = (d + 1)->dcoord[0];
#line 105
  l->my1 = (d + 1)->dcoord[1];
#line 106
  l->mx2 = (d + 2)->dcoord[0];
#line 107
  l->my2 = (d + 2)->dcoord[1];
#line 108
  l->morph = 1;
#line 109
  (c->playc)->lines.morphing = 1;
#line 110
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_morphlastline(uih_context *c , dialogparam *d ) 
{ 


  {
  {
#line 114
  ((c->playc)->lines.currkey) --;
#line 115
  uih_morphline(c, d);
  }
#line 116
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_setkey(uih_context *c , int line ) 
{ 
  char *tmp ;

  {
#line 120
  if (! c->play) {
#line 121
    if ((unsigned long )errstring == (unsigned long )((void *)0)) {
      {
#line 121
      tmp = gettext("linekey not available in this context!");
#line 121
      errstring = (char const   *)tmp;
      }
    }
#line 122
    return;
  }
#line 124
  (c->playc)->lines.currkey = line;
#line 125
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
static void uih_stopmorphing(uih_context *c ) 
{ 
  struct uih_line *l ;

  {
#line 129
  l = (c->playc)->lines.first;
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! l) {
#line 130
      goto while_break;
    }
#line 131
    if (l->morph) {
#line 132
      l->x1 = l->mx1;
#line 133
      l->y1 = l->my1;
#line 134
      l->x2 = l->mx2;
#line 135
      l->y2 = l->my2;
#line 136
      l->posmode = l->mposmode;
#line 137
      l->morph = 0;
#line 138
      (c->playc)->lines.morphing = 1;
    }
#line 140
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_update_lines(uih_context *c ) 
{ 
  int m ;
  int co ;
  struct uih_line *l ;
  int x1 ;
  int y1 ;
  int x2 ;
  int y2 ;
  number_t x ;
  number_t y ;
  int timer ;
  int tmp ;
  number_t mmul ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  number_t tmp___4 ;
  number_t tmp___5 ;
  int mx1 ;
  int mx2 ;
  int my1 ;
  int my2 ;
  number_t tmp___6 ;
  number_t tmp___7 ;

  {
  {
#line 146
  m = 0;
#line 148
  l = (c->playc)->lines.first;
#line 151
  tmp = tl_lookup_timer((c->playc)->timer);
#line 151
  timer = tmp - (c->playc)->starttime;
  }
#line 152
  if (timer < 0) {
#line 152
    tmp___3 = 0.0;
  } else {
#line 152
    if (timer >= (c->playc)->frametime - (c->playc)->starttime) {
#line 152
      tmp___2 = 1.0;
    } else {
#line 152
      if (timer < (c->playc)->morphlinetimes[0]) {
#line 152
        if ((c->playc)->morphlinetimes[0]) {
#line 152
          tmp___1 = (((((double )timer / (double )(c->playc)->morphlinetimes[0]) * ((double )timer / (double )(c->playc)->morphlinetimes[0])) / (double )2) * (double )(c->playc)->morphlinetimes[0]) / (double )((((c->playc)->frametime - (c->playc)->starttime) - (c->playc)->morphlinetimes[0] / 2) - (c->playc)->morphlinetimes[1] / 2);
        } else {
#line 152
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 152
        if (((c->playc)->frametime - (c->playc)->starttime) - timer < (c->playc)->morphlinetimes[1]) {
#line 152
          if ((c->playc)->morphlinetimes[1]) {
#line 152
            tmp___0 = (double )1 - (((((double )(((c->playc)->frametime - (c->playc)->starttime) - timer) / (double )(c->playc)->morphlinetimes[1]) * ((double )(((c->playc)->frametime - (c->playc)->starttime) - timer) / (double )(c->playc)->morphlinetimes[1])) / (double )2) * (double )(c->playc)->morphlinetimes[1]) / (double )((((c->playc)->frametime - (c->playc)->starttime) - (c->playc)->morphlinetimes[0] / 2) - (c->playc)->morphlinetimes[1] / 2);
          } else {
#line 152
            tmp___0 = (double )(timer - (c->playc)->morphlinetimes[0] / 2) / (((double )((c->playc)->frametime - (c->playc)->starttime) - (double )((c->playc)->morphlinetimes[0] / 2)) - (double )((c->playc)->morphlinetimes[1] / 2));
          }
        } else {
#line 152
          tmp___0 = (double )(timer - (c->playc)->morphlinetimes[0] / 2) / (((double )((c->playc)->frametime - (c->playc)->starttime) - (double )((c->playc)->morphlinetimes[0] / 2)) - (double )((c->playc)->morphlinetimes[1] / 2));
        }
#line 152
        tmp___1 = tmp___0;
      }
#line 152
      tmp___2 = tmp___1;
    }
#line 152
    tmp___3 = tmp___2;
  }
#line 152
  mmul = (number_t )tmp___3;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! l) {
#line 158
      goto while_break;
    }
    {
#line 160
    if (l->posmode == 0) {
#line 160
      goto case_0;
    }
#line 166
    if (l->posmode == 1) {
#line 166
      goto case_1;
    }
#line 180
    if (l->posmode == 2) {
#line 180
      goto case_2;
    }
#line 159
    goto switch_break;
    case_0: /* CIL Label */ 
#line 161
    x1 = (int )((number_t )(c->image)->width * l->x1);
#line 162
    y1 = (int )((number_t )(c->image)->height * l->y1);
#line 163
    x2 = (int )((number_t )(c->image)->width * l->x2);
#line 164
    y2 = (int )((number_t )(c->image)->height * l->y2);
#line 165
    goto switch_break;
    case_1: /* CIL Label */ 
#line 167
    x = (number_t )((float )(c->image)->width * (c->image)->pixelwidth);
#line 168
    y = (number_t )((float )(c->image)->height * (c->image)->pixelheight);
#line 169
    if (x > y) {
#line 170
      x = y;
    }
#line 171
    x1 = (int )((number_t )((c->image)->width / 2) + ((l->x1 - (number_t )0.5) * x) / (number_t )(c->image)->pixelwidth);
#line 173
    y1 = (int )((number_t )((c->image)->height / 2) + ((l->y1 - (number_t )0.5) * x) / (number_t )(c->image)->pixelheight);
#line 175
    x2 = (int )((number_t )((c->image)->width / 2) + ((l->x2 - (number_t )0.5) * x) / (number_t )(c->image)->pixelwidth);
#line 177
    y2 = (int )((number_t )((c->image)->height / 2) + ((l->y2 - (number_t )0.5) * x) / (number_t )(c->image)->pixelheight);
#line 179
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 181
    x = l->x1;
#line 182
    y = l->y1;
#line 183
    tmp___4 = x * (c->fcontext)->cos - y * (c->fcontext)->sin;
#line 183
    y = x * (c->fcontext)->sin + y * (c->fcontext)->cos;
#line 183
    x = tmp___4;
#line 184
    x = ((x - (c->fcontext)->rs.nc) / ((c->fcontext)->rs.mc - (c->fcontext)->rs.nc)) * (number_t )((c->zengine)->image)->width;
#line 187
    y = ((y - (c->fcontext)->rs.ni) / ((c->fcontext)->rs.mi - (c->fcontext)->rs.ni)) * (number_t )((c->zengine)->image)->height;
#line 190
    x1 = (int )x;
#line 191
    y1 = (int )y;
#line 192
    (*(((c->zengine)->action)->convertup))(c->zengine, & x1, & y1);
#line 193
    x = l->x2;
#line 194
    y = l->y2;
#line 195
    tmp___5 = x * (c->fcontext)->cos - y * (c->fcontext)->sin;
#line 195
    y = x * (c->fcontext)->sin + y * (c->fcontext)->cos;
#line 195
    x = tmp___5;
#line 196
    x = ((x - (c->fcontext)->rs.nc) / ((c->fcontext)->rs.mc - (c->fcontext)->rs.nc)) * (number_t )((c->zengine)->image)->width;
#line 199
    y = ((y - (c->fcontext)->rs.ni) / ((c->fcontext)->rs.mi - (c->fcontext)->rs.ni)) * (number_t )((c->zengine)->image)->height;
#line 202
    x2 = (int )x;
#line 203
    y2 = (int )y;
#line 204
    (*(((c->zengine)->action)->convertup))(c->zengine, & x2, & y2);
    }
#line 205
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 207
    if (l->morph) {
#line 209
      m = 1;
      {
#line 211
      if (l->mposmode == 0) {
#line 211
        goto case_0___0;
      }
#line 217
      if (l->mposmode == 1) {
#line 217
        goto case_1___0;
      }
#line 235
      goto switch_default;
      case_0___0: /* CIL Label */ 
#line 212
      mx1 = (int )((number_t )(c->image)->width * l->mx1);
#line 213
      my1 = (int )((number_t )(c->image)->height * l->my1);
#line 214
      mx2 = (int )((number_t )(c->image)->width * l->mx2);
#line 215
      my2 = (int )((number_t )(c->image)->height * l->my2);
#line 216
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 218
      x = (number_t )((float )(c->image)->width * (c->image)->pixelwidth);
#line 219
      y = (number_t )((float )(c->image)->height * (c->image)->pixelheight);
#line 220
      if (x > y) {
#line 221
        x = y;
      }
#line 222
      mx1 = (int )((number_t )((c->image)->width / 2) + ((l->mx1 - (number_t )0.5) * x) / (number_t )(c->image)->pixelwidth);
#line 225
      my1 = (int )((number_t )((c->image)->height / 2) + ((l->my1 - (number_t )0.5) * x) / (number_t )(c->image)->pixelheight);
#line 228
      mx2 = (int )((number_t )((c->image)->width / 2) + ((l->mx2 - (number_t )0.5) * x) / (number_t )(c->image)->pixelwidth);
#line 231
      my2 = (int )((number_t )((c->image)->height / 2) + ((l->my2 - (number_t )0.5) * x) / (number_t )(c->image)->pixelheight);
#line 234
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 236
      x = l->mx1;
#line 237
      y = l->my1;
#line 238
      tmp___6 = x * (c->fcontext)->cos - y * (c->fcontext)->sin;
#line 238
      y = x * (c->fcontext)->sin + y * (c->fcontext)->cos;
#line 238
      x = tmp___6;
#line 239
      x = ((x - (c->fcontext)->rs.nc) / ((c->fcontext)->rs.mc - (c->fcontext)->rs.nc)) * (number_t )((c->zengine)->image)->width;
#line 242
      y = ((y - (c->fcontext)->rs.ni) / ((c->fcontext)->rs.mi - (c->fcontext)->rs.ni)) * (number_t )((c->zengine)->image)->height;
#line 245
      mx1 = (int )x;
#line 246
      my1 = (int )y;
#line 247
      (*(((c->zengine)->action)->convertup))(c->zengine, & mx1, & my1);
#line 248
      x = l->mx2;
#line 249
      y = l->my2;
#line 250
      tmp___7 = x * (c->fcontext)->cos - y * (c->fcontext)->sin;
#line 250
      y = x * (c->fcontext)->sin + y * (c->fcontext)->cos;
#line 250
      x = tmp___7;
#line 251
      x = ((x - (c->fcontext)->rs.nc) / ((c->fcontext)->rs.mc - (c->fcontext)->rs.nc)) * (number_t )((c->zengine)->image)->width;
#line 254
      y = ((y - (c->fcontext)->rs.ni) / ((c->fcontext)->rs.mi - (c->fcontext)->rs.ni)) * (number_t )((c->zengine)->image)->height;
#line 257
      mx2 = (int )x;
#line 258
      my2 = (int )y;
#line 259
      (*(((c->zengine)->action)->convertup))(c->zengine, & mx2, & my2);
      }
#line 260
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 262
      x1 = (int )((number_t )x1 + (number_t )(mx1 - x1) * mmul);
#line 263
      y1 = (int )((number_t )y1 + (number_t )(my1 - y1) * mmul);
#line 264
      x2 = (int )((number_t )x2 + (number_t )(mx2 - x2) * mmul);
#line 265
      y2 = (int )((number_t )y2 + (number_t )(my2 - y2) * mmul);
    }
    {
#line 268
    if (l->color == 1) {
#line 268
      goto case_1___1;
    }
#line 271
    if (l->color == 0) {
#line 271
      goto case_0___1;
    }
#line 274
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 269
    co = (int )*((c->palette)->index + 0);
#line 270
    goto switch_break___1;
    case_0___1: /* CIL Label */ 
#line 272
    co = (int )*((c->palette)->index + 1);
#line 273
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 275
    co = (int )*((c->palette)->index + 2);
#line 276
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    {
#line 278
    uih_setline(c, l->w, co, x1, y1, x2, y2);
#line 280
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  (c->playc)->lines.morphing = m;
#line 283
  if (m) {
#line 284
    c->display = 1;
  }
#line 286
  return;
}
}
#line 288 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_clear_line(uih_context *c ) 
{ 
  char *tmp ;
  int tmp___0 ;
  struct uih_line *tmp___1 ;

  {
#line 290
  if ((unsigned long )c->playstring != (unsigned long )((void *)0)) {
#line 291
    if ((unsigned long )errstring == (unsigned long )((void *)0)) {
      {
#line 291
      tmp = gettext("clear_line available only in animation replay");
#line 291
      errstring = (char const   *)tmp;
      }
    }
#line 292
    return;
  }
  {
#line 294
  tmp___0 = (c->playc)->lines.currkey;
#line 294
  ((c->playc)->lines.currkey) ++;
#line 294
  tmp___1 = uih_findkey(c, tmp___0);
#line 294
  uih_removeline(c, tmp___1);
  }
#line 295
  return;
}
}
#line 297 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_clear_lines(uih_context *c ) 
{ 
  char *tmp ;

  {
#line 299
  if ((unsigned long )c->playstring != (unsigned long )((void *)0)) {
#line 300
    if ((unsigned long )errstring == (unsigned long )((void *)0)) {
      {
#line 300
      tmp = gettext("clear_lines available only in animation replay");
#line 300
      errstring = (char const   *)tmp;
      }
    }
#line 301
    return;
  }
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! ((unsigned long )(c->playc)->lines.first != (unsigned long )((void *)0))) {
#line 303
      goto while_break;
    }
    {
#line 304
    uih_removeline(c, (c->playc)->lines.first);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  (c->playc)->lines.currkey = 0;
#line 306
  return;
}
}
#line 308 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_freecatalog(uih_context *c ) 
{ 


  {
#line 310
  if ((unsigned long )catalog != (unsigned long )((void *)0)) {
    {
#line 311
    free_catalog(catalog);
#line 311
    catalog = (catalog_t *)((void *)0);
    }
  }
#line 312
  return;
}
}
#line 314 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_setfont(struct uih_context *uih___2 ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 316
  if ((unsigned long )catalog != (unsigned long )((void *)0)) {
    {
#line 316
    tmp = find_text(catalog, "encoding");
    }
#line 316
    if (tmp) {
      {
#line 316
      tmp___0 = find_text(catalog, "encoding");
      }
#line 316
      if ((int )*(tmp___0 + 0) == 50) {
#line 318
        uih___2->encoding = 2;
      } else {
#line 320
        uih___2->encoding = 1;
      }
    } else {
#line 320
      uih___2->encoding = 1;
    }
  } else {
#line 320
    uih___2->encoding = 1;
  }
#line 321
  if ((uih___2->image)->flags & 4) {
#line 322
    uih___2->font = & xaafont;
  } else
#line 324
  if (uih___2->encoding == 2) {
#line 326
    if ((uih___2->image)->width > 1000) {
#line 326
      if ((uih___2->image)->height > 720) {
#line 327
        uih___2->font = & xbigfont3;
      } else {
#line 326
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 329
    if ((uih___2->image)->width > 800) {
#line 329
      if ((uih___2->image)->height > 600) {
#line 330
        uih___2->font = & xbigfont2;
      } else {
#line 329
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 332
    if ((double )(uih___2->image)->pixelheight < 0.07) {
#line 333
      uih___2->font = & xbigfont;
    } else {
#line 335
      uih___2->font = & xsmallfont;
    }
  } else
#line 339
  if ((double )(uih___2->image)->pixelheight < 0.04) {
#line 340
    uih___2->font = & xbigfontil1;
  } else
#line 341
  if ((double )(uih___2->image)->pixelheight < 0.07) {
#line 342
    uih___2->font = & xmedfontil1;
  } else {
#line 344
    uih___2->font = & xsmallfontil1;
  }
#line 347
  return;
}
}
#line 351 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
static int firsttime  =    1;
#line 352 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
static char const   *str  ;
#line 349 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
int uih_loadcatalog(uih_context *c , char const   *name___0 ) 
{ 
  xio_file f ;
  xio_file tmp ;
  char *tmp___0 ;

  {
  {
#line 353
  tmp = xio_getcatalog(name___0);
#line 353
  f = tmp;
  }
#line 354
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 355
    if (firsttime) {
#line 356
      firsttime = 0;
#line 357
      return (0);
    }
    {
#line 359
    tmp___0 = gettext("Catalog file not found");
#line 359
    uih_error(c, (char const   *)tmp___0);
    }
#line 360
    return (0);
  }
#line 362
  firsttime = 0;
#line 363
  if ((unsigned long )catalog != (unsigned long )((void *)0)) {
    {
#line 364
    free_catalog(catalog);
    }
  }
  {
#line 365
  catalog = load_catalog(f, & str);
  }
#line 366
  if ((unsigned long )str != (unsigned long )((void *)0)) {
    {
#line 367
    uih_error(c, str);
    }
  }
  {
#line 368
  uih_setfont(c);
  }
#line 369
  return ((unsigned long )catalog != (unsigned long )((void *)0));
}
}
#line 372 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
static void handler(void *userdata ) 
{ 
  struct uih_context *uih___2 ;

  {
#line 374
  uih___2 = (struct uih_context *)userdata;
#line 375
  ((uih___2->playc)->playframe) ++;
#line 376
  uih___2->inanimation = 2;
#line 377
  if ((uih___2->playc)->timerin) {
    {
#line 378
    tl_remove_timer((uih___2->playc)->timer);
    }
  }
#line 379
  (uih___2->playc)->timerin = 0;
#line 380
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
static void handler1(void *userdata ) 
{ 
  struct uih_context *uih___2 ;

  {
  {
#line 384
  uih___2 = (struct uih_context *)userdata;
#line 385
  ((uih___2->playc)->playframe) ++;
#line 386
  uih___2->inanimation = 2;
#line 387
  tl_update_time();
#line 388
  tl_reset_timer((uih___2->playc)->timer);
#line 389
  uih_setcomplettehandler(uih___2, (void (*)(void * ))((void *)0), (void *)0);
  }
#line 390
  return;
}
}
#line 392 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_skipframe(struct uih_context *uih___2 ) 
{ 


  {
#line 394
  if (uih___2->play) {
#line 394
    if ((uih___2->playc)->timerin) {
      {
#line 395
      handler((void *)uih___2);
#line 395
      tl_reset_timer((uih___2->playc)->timer);
      }
    }
  }
#line 396
  return;
}
}
#line 398 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
int uih_replayenable(struct uih_context *uih___2 , xio_file f , xio_constpath filename___0 ,
                     int animr ) 
{ 
  struct uih_playcontext *p ;
  char const   *s ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
#line 404
  if (uih___2->play) {
    {
#line 405
    tmp = gettext("Replay is already active");
#line 405
    uih_error(uih___2, (char const   *)tmp);
    }
#line 406
    return (0);
  }
#line 408
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 409
    tmp___0 = gettext("File open failed");
#line 409
    uih_error(uih___2, (char const   *)tmp___0);
    }
#line 410
    return (0);
  }
  {
#line 412
  tmp___1 = calloc((size_t )1, sizeof(*p));
#line 412
  p = (struct uih_playcontext *)tmp___1;
  }
#line 413
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 414
    tmp___2 = gettext("Out of memory");
#line 414
    uih_error(uih___2, (char const   *)tmp___2);
    }
#line 415
    return (0);
  }
#line 417
  if (animr) {
#line 418
    uih___2->menuroot = (char const   *)animroot;
#line 419
    if ((unsigned long )uih___2->updatemenus != (unsigned long )((void *)0)) {
      {
#line 419
      (*(uih___2->updatemenus))(uih___2, (char const   *)((void *)0));
      }
    }
  }
  {
#line 421
  p->file = f;
#line 422
  p->playframe = 1;
#line 423
  p->timer = tl_create_timer();
#line 424
  p->frametime = 0;
#line 425
  p->morph = 0;
#line 426
  p->morphjulia = 0;
#line 427
  p->lines.first = (struct uih_line *)((void *)0);
#line 428
  p->lines.morphing = 0;
#line 429
  p->lines.currkey = 0;
#line 430
  tl_update_time();
#line 431
  tl_set_handler(p->timer, & handler, (void *)uih___2);
#line 432
  uih_stoptimers(uih___2);
  }
#line 433
  if (uih___2->stoppedtimers) {
    {
#line 434
    tl_stop_timer(p->timer);
    }
  }
  {
#line 435
  uih___2->playc = p;
#line 436
  uih___2->play = 1;
#line 437
  uih_emulatetimers(uih___2);
#line 438
  tl_reset_timer(p->timer);
#line 439
  (uih___2->playc)->line = 1;
  }
#line 440
  if ((unsigned long )filename___0 != (unsigned long )((void *)0)) {
    {
#line 441
    (uih___2->playc)->directory = xio_getdirectory(filename___0);
    }
  } else {
    {
#line 443
    (uih___2->playc)->directory = xio_getdirectory("./");
    }
  }
  {
#line 445
  (uih___2->playc)->level = 0;
#line 446
  s = uih___2->playstring;
#line 447
  uih___2->playstring = (char const   *)((void *)0);
#line 448
  uih_playupdate(uih___2);
#line 449
  uih___2->playstring = s;
  }
#line 450
  return (1);
}
}
#line 453 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_replaydisable(struct uih_context *uih___2 ) 
{ 
  int i ;

  {
#line 455
  if (uih___2->play) {
    {
#line 457
    uih___2->play = 0;
#line 458
    tl_free_timer((uih___2->playc)->timer);
    }
#line 459
    if ((unsigned long )uih___2->menuroot == (unsigned long )animroot) {
#line 460
      uih___2->menuroot = "root";
#line 461
      if ((unsigned long )uih___2->updatemenus != (unsigned long )((void *)0)) {
        {
#line 461
        (*(uih___2->updatemenus))(uih___2, (char const   *)((void *)0));
        }
      }
    }
    {
#line 463
    (*(((uih___2->playc)->file)->fclose))((uih___2->playc)->file);
#line 464
    i = 0;
    }
    {
#line 464
    while (1) {
      while_continue: /* CIL Label */ ;
#line 464
      if (! (i < (uih___2->playc)->level)) {
#line 464
        goto while_break;
      }
      {
#line 465
      (*(((uih___2->playc)->prevfiles[i])->fclose))((uih___2->playc)->prevfiles[i]);
#line 464
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 466
    uih___2->display = 1;
#line 467
    uih___2->nonfractalscreen = 0;
#line 468
    uih_setcomplettehandler(uih___2, (void (*)(void * ))((void *)0), (void *)0);
#line 469
    uih_clear_lines(uih___2);
#line 470
    free((void *)(uih___2->playc)->directory);
#line 471
    free((void *)uih___2->playc);
#line 472
    uih_display(uih___2);
    }
  }
#line 474
  return;
}
}
#line 476 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
static void skipblank(struct uih_context *uih___2 ) 
{ 
  int c ;
  int tmp ;
  int tmp___0 ;

  {
#line 479
  if ((unsigned long )uih___2->playstring != (unsigned long )((void *)0)) {
    {
#line 480
    while (1) {
      while_continue: /* CIL Label */ ;
#line 480
      if (! ((int const   )*(uih___2->playstring + uih___2->playpos) == 32)) {
#line 480
        if (! ((int const   )*(uih___2->playstring + uih___2->playpos) == 9)) {
#line 480
          if (! ((int const   )*(uih___2->playstring + uih___2->playpos) == 13)) {
#line 480
            if (! ((int const   )*(uih___2->playstring + uih___2->playpos) == 10)) {
#line 480
              goto while_break;
            }
          }
        }
      }
#line 484
      (uih___2->playpos) ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 485
    return;
  }
  {
#line 487
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 488
    c = (*(((uih___2->playc)->file)->fgetc))((uih___2->playc)->file);
    }
#line 489
    if (c == 10) {
#line 490
      ((uih___2->playc)->line) ++;
    }
#line 491
    if (c == 59) {
      {
#line 492
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 492
        if (c != 10) {
          {
#line 492
          tmp = (*(((uih___2->playc)->file)->xeof))((uih___2->playc)->file);
          }
#line 492
          if (tmp) {
#line 492
            goto while_break___1;
          }
        } else {
#line 492
          goto while_break___1;
        }
        {
#line 493
        c = (*(((uih___2->playc)->file)->fgetc))((uih___2->playc)->file);
        }
#line 494
        if (c == 10) {
#line 495
          ((uih___2->playc)->line) ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 497
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 497
      tmp___0 = (*(((uih___2->playc)->file)->xeof))((uih___2->playc)->file);
      }
#line 497
      if (tmp___0) {
#line 497
        if (! (uih___2->playc)->level) {
#line 497
          goto while_break___2;
        }
      } else {
#line 497
        goto while_break___2;
      }
      {
#line 498
      c = 0;
#line 499
      (*(((uih___2->playc)->file)->fclose))((uih___2->playc)->file);
#line 500
      ((uih___2->playc)->level) --;
#line 500
      (uih___2->playc)->file = (uih___2->playc)->prevfiles[(uih___2->playc)->level];
#line 501
      (uih___2->playc)->line = 1;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 487
    if (! (c == 32)) {
#line 487
      if (! (c == 9)) {
#line 487
        if (! (c == 10)) {
#line 487
          if (! (c == 13)) {
#line 487
            if (! (c == 0)) {
#line 487
              goto while_break___0;
            }
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 506
  if (c != -1) {
    {
#line 507
    (*(((uih___2->playc)->file)->fungetc))(c, (uih___2->playc)->file);
    }
  }
#line 508
  return;
}
}
#line 510 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
static int gettoken(struct uih_context *uih___2 ) 
{ 
  int c ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;

  {
  {
#line 513
  i = 0;
#line 514
  skipblank(uih___2);
  }
#line 515
  if (first___0) {
#line 515
    if ((unsigned long )uih___2->playstring == (unsigned long )((void *)0)) {
      {
#line 515
      tmp___1 = (*(((uih___2->playc)->file)->fgetc))((uih___2->playc)->file);
#line 515
      c = tmp___1;
      }
    } else {
#line 515
      tmp___2 = uih___2->playpos;
#line 515
      (uih___2->playpos) ++;
#line 515
      c = (int )*(uih___2->playstring + tmp___2);
    }
#line 515
    if (c != 40) {
#line 516
      if (c) {
#line 516
        if ((unsigned long )uih___2->playstring == (unsigned long )((void *)0)) {
          {
#line 516
          tmp = (*(((uih___2->playc)->file)->xeof))((uih___2->playc)->file);
#line 516
          tmp___0 = tmp;
          }
        } else {
#line 516
          tmp___0 = (int const   )*(uih___2->playstring + uih___2->playpos) == 0;
        }
#line 516
        if (! tmp___0) {
#line 517
          if ((unsigned long )errstring == (unsigned long )((void *)0)) {
#line 517
            errstring = "\'(\' expected";
          }
        }
      }
#line 519
      last___0 = 1;
#line 520
      return (-1);
    }
  }
#line 522
  if (first___0) {
    {
#line 523
    skipblank(uih___2);
#line 523
    first___0 = 0;
    }
  }
#line 524
  if ((unsigned long )uih___2->playstring == (unsigned long )((void *)0)) {
    {
#line 524
    tmp___5 = (*(((uih___2->playc)->file)->xeof))((uih___2->playc)->file);
#line 524
    tmp___6 = tmp___5;
    }
  } else {
#line 524
    tmp___6 = (int const   )*(uih___2->playstring + uih___2->playpos) == 0;
  }
#line 524
  if (tmp___6) {
#line 525
    if (uih___2->playstring) {
#line 526
      if ((unsigned long )errstring == (unsigned long )((void *)0)) {
        {
#line 526
        tmp___3 = gettext("Missing parameter");
#line 526
        errstring = (char const   *)tmp___3;
        }
      }
    } else
#line 528
    if ((unsigned long )errstring == (unsigned long )((void *)0)) {
      {
#line 528
      tmp___4 = gettext("Unexpected end of file");
#line 528
      errstring = (char const   *)tmp___4;
      }
    }
#line 529
    return (0);
  }
#line 531
  if ((unsigned long )uih___2->playstring == (unsigned long )((void *)0)) {
    {
#line 531
    tmp___18 = (*(((uih___2->playc)->file)->fgetc))((uih___2->playc)->file);
#line 531
    c = tmp___18;
    }
  } else {
#line 531
    tmp___19 = uih___2->playpos;
#line 531
    (uih___2->playpos) ++;
#line 531
    c = (int )*(uih___2->playstring + tmp___19);
  }
#line 531
  if (c == 34) {
    {
#line 532
    while (1) {
      while_continue: /* CIL Label */ ;
#line 532
      if (! (c == 13)) {
#line 532
        goto while_break;
      }
#line 533
      if ((unsigned long )uih___2->playstring == (unsigned long )((void *)0)) {
        {
#line 533
        tmp___7 = (*(((uih___2->playc)->file)->fgetc))((uih___2->playc)->file);
#line 533
        c = tmp___7;
        }
      } else {
#line 533
        tmp___8 = uih___2->playpos;
#line 533
        (uih___2->playpos) ++;
#line 533
        c = (int )*(uih___2->playstring + tmp___8);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 534
    token[i] = (char )'\"';
#line 535
    i ++;
    {
#line 536
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 537
      if ((unsigned long )uih___2->playstring == (unsigned long )((void *)0)) {
        {
#line 537
        tmp___9 = (*(((uih___2->playc)->file)->fgetc))((uih___2->playc)->file);
#line 537
        c = tmp___9;
        }
      } else {
#line 537
        tmp___10 = uih___2->playpos;
#line 537
        (uih___2->playpos) ++;
#line 537
        c = (int )*(uih___2->playstring + tmp___10);
      }
      {
#line 538
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 538
        if (! (c == 13)) {
#line 538
          goto while_break___1;
        }
#line 539
        if ((unsigned long )uih___2->playstring == (unsigned long )((void *)0)) {
          {
#line 539
          tmp___11 = (*(((uih___2->playc)->file)->fgetc))((uih___2->playc)->file);
#line 539
          c = tmp___11;
          }
        } else {
#line 539
          tmp___12 = uih___2->playpos;
#line 539
          (uih___2->playpos) ++;
#line 539
          c = (int )*(uih___2->playstring + tmp___12);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 540
      if (c == -1) {
#line 540
        goto _L;
      } else
#line 540
      if (c == 0) {
        _L: /* CIL Label */ 
#line 541
        if (uih___2->playstring) {
#line 542
          if ((unsigned long )errstring == (unsigned long )((void *)0)) {
            {
#line 542
            tmp___13 = gettext("Missing parameter");
#line 542
            errstring = (char const   *)tmp___13;
            }
          }
        } else
#line 544
        if ((unsigned long )errstring == (unsigned long )((void *)0)) {
          {
#line 544
          tmp___14 = gettext("Unexpected end of file");
#line 544
          errstring = (char const   *)tmp___14;
          }
        }
#line 545
        return (0);
      }
#line 547
      if (c == 10) {
#line 547
        if ((unsigned long )uih___2->playstring == (unsigned long )((void *)0)) {
#line 548
          ((uih___2->playc)->line) ++;
        }
      }
#line 549
      if (c == 92) {
#line 550
        if ((unsigned long )uih___2->playstring == (unsigned long )((void *)0)) {
          {
#line 550
          tmp___15 = (*(((uih___2->playc)->file)->fgetc))((uih___2->playc)->file);
#line 550
          token[i] = (char )tmp___15;
          }
        } else {
#line 550
          tmp___16 = uih___2->playpos;
#line 550
          (uih___2->playpos) ++;
#line 550
          token[i] = (char )*(uih___2->playstring + tmp___16);
        }
      } else {
#line 552
        token[i] = (char )c;
      }
#line 553
      i ++;
#line 554
      if (i >= 1024) {
#line 555
        if ((unsigned long )errstring == (unsigned long )((void *)0)) {
          {
#line 555
          tmp___17 = gettext("Token is too long");
#line 555
          errstring = (char const   *)tmp___17;
          }
        }
#line 556
        i = 0;
      }
#line 536
      if (! (c != 34)) {
#line 536
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 561
  if ((unsigned long )uih___2->playstring == (unsigned long )((void *)0)) {
    {
#line 561
    (*(((uih___2->playc)->file)->fungetc))(c, (uih___2->playc)->file);
    }
  } else {
#line 561
    (uih___2->playpos) --;
  }
  {
#line 562
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 563
    if ((unsigned long )uih___2->playstring == (unsigned long )((void *)0)) {
      {
#line 563
      tmp___20 = (*(((uih___2->playc)->file)->fgetc))((uih___2->playc)->file);
#line 563
      c = tmp___20;
      }
    } else {
#line 563
      tmp___21 = uih___2->playpos;
#line 563
      (uih___2->playpos) ++;
#line 563
      c = (int )*(uih___2->playstring + tmp___21);
    }
#line 564
    if (c == -1) {
#line 564
      goto _L___0;
    } else
#line 564
    if (c == 0) {
      _L___0: /* CIL Label */ 
#line 565
      if (uih___2->playstring) {
#line 566
        if ((unsigned long )errstring == (unsigned long )((void *)0)) {
          {
#line 566
          tmp___22 = gettext("Missing parameter");
#line 566
          errstring = (char const   *)tmp___22;
          }
        }
      } else
#line 568
      if ((unsigned long )errstring == (unsigned long )((void *)0)) {
        {
#line 568
        tmp___23 = gettext("Unexpected end of file");
#line 568
        errstring = (char const   *)tmp___23;
        }
      }
#line 569
      return (0);
    }
#line 571
    token[i] = (char )c;
#line 572
    i ++;
#line 573
    if (i >= 1024) {
#line 574
      if ((unsigned long )errstring == (unsigned long )((void *)0)) {
        {
#line 574
        tmp___24 = gettext("Token is too long");
#line 574
        errstring = (char const   *)tmp___24;
        }
      }
#line 575
      i = 0;
    }
#line 562
    if (c != 32) {
#line 562
      if (c != 9) {
#line 562
        if (c != 41) {
#line 562
          if (c != 10) {
#line 562
            if (! (c != 13)) {
#line 562
              goto while_break___2;
            }
          } else {
#line 562
            goto while_break___2;
          }
        } else {
#line 562
          goto while_break___2;
        }
      } else {
#line 562
        goto while_break___2;
      }
    } else {
#line 562
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 579
  i --;
#line 580
  token[i] = (char)0;
#line 581
  skipblank(uih___2);
  }
#line 582
  if (c == 41) {
#line 583
    last___0 = 1;
#line 584
    return (i);
  }
#line 586
  if ((unsigned long )uih___2->playstring == (unsigned long )((void *)0)) {
    {
#line 586
    tmp___25 = (*(((uih___2->playc)->file)->fgetc))((uih___2->playc)->file);
#line 586
    c = tmp___25;
    }
  } else {
#line 586
    tmp___26 = uih___2->playpos;
#line 586
    (uih___2->playpos) ++;
#line 586
    c = (int )*(uih___2->playstring + tmp___26);
  }
#line 587
  if ((unsigned long )uih___2->playstring == (unsigned long )((void *)0)) {
    {
#line 588
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 588
      tmp___27 = (*(((uih___2->playc)->file)->xeof))((uih___2->playc)->file);
      }
#line 588
      if (tmp___27) {
#line 588
        if (! (uih___2->playc)->level) {
#line 588
          goto while_break___3;
        }
      } else {
#line 588
        goto while_break___3;
      }
#line 589
      ((uih___2->playc)->level) --;
#line 589
      (uih___2->playc)->file = (uih___2->playc)->prevfiles[(uih___2->playc)->level];
#line 589
      (uih___2->playc)->line = 1;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 593
  if (c == -1) {
#line 593
    goto _L___1;
  } else
#line 593
  if (c == 0) {
    _L___1: /* CIL Label */ 
#line 594
    if (uih___2->playstring) {
#line 595
      if ((unsigned long )errstring == (unsigned long )((void *)0)) {
        {
#line 595
        tmp___28 = gettext("Missing parameter");
#line 595
        errstring = (char const   *)tmp___28;
        }
      }
    } else
#line 597
    if ((unsigned long )errstring == (unsigned long )((void *)0)) {
      {
#line 597
      tmp___29 = gettext("Unexpected end of file");
#line 597
      errstring = (char const   *)tmp___29;
      }
    }
#line 598
    return (0);
  }
#line 600
  if (c == 41) {
#line 601
    last___0 = 1;
#line 602
    return (i);
  }
#line 604
  if ((unsigned long )uih___2->playstring == (unsigned long )((void *)0)) {
    {
#line 604
    (*(((uih___2->playc)->file)->fungetc))(c, (uih___2->playc)->file);
    }
  } else {
#line 604
    (uih___2->playpos) --;
  }
#line 605
  return (i);
}
}
#line 608 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
static char *gettokenwr(struct uih_context *c ) 
{ 
  int tmp ;

  {
#line 610
  if (last___0) {
#line 611
    return ((char *)((void *)0));
  }
  {
#line 612
  tmp = gettoken(c);
  }
#line 612
  if (tmp < 0) {
#line 613
    return ((char *)((void *)0));
  }
#line 614
  if (errstring) {
#line 615
    return ((char *)((void *)0));
  }
#line 616
  return (token);
}
}
#line 619 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_play_formula(struct uih_context *uih___2 , char *fname ) 
{ 
  int i ;
  int tmp ;
  char *tmp___0 ;

  {
#line 622
  i = 0;
  {
#line 622
  while (1) {
    while_continue: /* CIL Label */ ;
#line 622
    if (! (i < (int )nformulas)) {
#line 622
      goto while_break;
    }
    {
#line 623
    tmp = strcmp((char const   *)formulas[i].shortname, (char const   *)fname);
    }
#line 623
    if (! tmp) {
      {
#line 624
      set_formula(uih___2->fcontext, i);
#line 625
      uih___2->display = 1;
      }
#line 625
      if (uih___2->recalculatemode > 2) {
#line 625
        uih___2->recalculatemode = uih___2->recalculatemode;
      } else {
#line 625
        uih___2->recalculatemode = 2;
      }
#line 626
      return;
    }
#line 622
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 629
  if ((unsigned long )errstring == (unsigned long )((void *)0)) {
    {
#line 629
    tmp___0 = gettext("Unknown formula type");
#line 629
    errstring = (char const   *)tmp___0;
    }
  }
#line 630
  return;
}
}
#line 632 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_playmorph(struct uih_context *uih___2 , dialogparam *d ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 634
  if ((unsigned long )uih___2->playstring != (unsigned long )((void *)0)) {
#line 635
    if ((unsigned long )errstring == (unsigned long )((void *)0)) {
      {
#line 635
      tmp = gettext("morph available only in animation replay");
#line 635
      errstring = (char const   *)tmp;
      }
    }
#line 636
    return;
  }
#line 638
  if ((d + 2)->number <= (number_t )0) {
#line 638
    goto _L;
  } else
#line 638
  if ((d + 3)->number <= (number_t )0) {
    _L: /* CIL Label */ 
#line 639
    if ((unsigned long )errstring == (unsigned long )((void *)0)) {
      {
#line 639
      tmp___0 = gettext("morphview: Invalid viewpoint");
#line 639
      errstring = (char const   *)tmp___0;
      }
    }
#line 640
    (uih___2->playc)->destination = (vinfo )((uih___2->fcontext)->currentformula)->v;
  }
#line 642
  (uih___2->playc)->source = (uih___2->fcontext)->s;
#line 643
  (uih___2->playc)->destination.cr = (d + 0)->number;
#line 644
  (uih___2->playc)->destination.ci = (d + 1)->number;
#line 645
  (uih___2->playc)->destination.rr = (d + 2)->number;
#line 646
  (uih___2->playc)->destination.ri = (d + 3)->number;
#line 647
  (uih___2->playc)->morph = 1;
#line 648
  return;
}
}
#line 650 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_playmove(struct uih_context *uih___2 , number_t x , number_t y ) 
{ 
  char *tmp ;

  {
#line 652
  if ((unsigned long )uih___2->playstring != (unsigned long )((void *)0)) {
#line 653
    if ((unsigned long )errstring == (unsigned long )((void *)0)) {
      {
#line 653
      tmp = gettext("move available only in animation replay");
#line 653
      errstring = (char const   *)tmp;
      }
    }
#line 654
    return;
  }
#line 656
  (uih___2->playc)->source = (uih___2->fcontext)->s;
#line 657
  (uih___2->playc)->destination.cr = x;
#line 658
  (uih___2->playc)->destination.ci = y;
#line 659
  (uih___2->playc)->destination.rr = (uih___2->fcontext)->s.rr;
#line 660
  (uih___2->playc)->destination.ri = (uih___2->fcontext)->s.ri;
#line 661
  (uih___2->playc)->morph = 1;
#line 662
  return;
}
}
#line 664 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_playmorphjulia(struct uih_context *uih___2 , number_t x , number_t y ) 
{ 
  char *tmp ;

  {
#line 666
  if ((unsigned long )uih___2->playstring != (unsigned long )((void *)0)) {
#line 667
    if ((unsigned long )errstring == (unsigned long )((void *)0)) {
      {
#line 667
      tmp = gettext("morphjulia available only in animation replay");
#line 667
      errstring = (char const   *)tmp;
      }
    }
#line 668
    return;
  }
#line 670
  (uih___2->playc)->sr = (uih___2->fcontext)->pre;
#line 671
  (uih___2->playc)->si = (uih___2->fcontext)->pim;
#line 672
  (uih___2->playc)->dr = x;
#line 673
  (uih___2->playc)->di = y;
#line 674
  (uih___2->playc)->morphjulia = 1;
#line 675
  return;
}
}
#line 677 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_playmorphangle(struct uih_context *uih___2 , number_t angle ) 
{ 
  char *tmp ;

  {
#line 679
  if ((unsigned long )uih___2->playstring != (unsigned long )((void *)0)) {
#line 680
    if ((unsigned long )errstring == (unsigned long )((void *)0)) {
      {
#line 680
      tmp = gettext("morphangle available only in animation replay");
#line 680
      errstring = (char const   *)tmp;
      }
    }
#line 681
    return;
  }
#line 683
  (uih___2->playc)->morphangle = 1;
#line 684
  (uih___2->playc)->srcangle = (uih___2->fcontext)->angle;
#line 685
  (uih___2->playc)->destangle = angle;
#line 686
  return;
}
}
#line 688 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_playautorotate(struct uih_context *uih___2 , int mode ) 
{ 


  {
#line 690
  if (mode) {
    {
#line 691
    uih_fastrotateenable(uih___2);
#line 692
    uih_rotatemode(uih___2, 2);
    }
  } else {
    {
#line 694
    uih_rotatemode(uih___2, 0);
    }
  }
#line 695
  return;
}
}
#line 697 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_playfilter(struct uih_context *uih___2 , dialogparam *p ) 
{ 
  char const   *fname ;
  int mode ;
  int i ;
  int tmp ;
  char *tmp___0 ;

  {
#line 699
  fname = (char const   *)(p + 0)->dstring;
#line 702
  i = 0;
  {
#line 702
  while (1) {
    while_continue: /* CIL Label */ ;
#line 702
    if (! (i < (int )uih_nfilters)) {
#line 702
      goto while_break;
    }
    {
#line 703
    tmp = strcmp((char const   *)(uih_filters[i])->shortname, fname);
    }
#line 703
    if (! tmp) {
#line 704
      mode = (p + 1)->dint;
#line 705
      if (mode) {
        {
#line 706
        uih_enablefilter(uih___2, i);
        }
      } else {
        {
#line 708
        uih_disablefilter(uih___2, i);
        }
      }
#line 709
      return;
    }
#line 702
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 712
  if ((unsigned long )errstring == (unsigned long )((void *)0)) {
    {
#line 712
    tmp___0 = gettext("Unknown filter");
#line 712
    errstring = (char const   *)tmp___0;
    }
  }
#line 713
  return;
}
}
#line 715 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_playdefpalette(struct uih_context *uih___2 , int shift ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 717
  if ((unsigned long )((uih___2->zengine)->fractalc)->palette == (unsigned long )((void *)0)) {
#line 718
    return;
  }
  {
#line 719
  tmp = mkdefaultpalette(((uih___2->zengine)->fractalc)->palette);
  }
#line 719
  if (tmp != 0) {
#line 720
    uih___2->display = 1;
#line 720
    if (uih___2->recalculatemode > 2) {
#line 720
      uih___2->recalculatemode = uih___2->recalculatemode;
    } else {
#line 720
      uih___2->recalculatemode = 2;
    }
  }
  {
#line 722
  uih___2->palettetype = 0;
#line 723
  uih___2->palettechanged = 1;
#line 724
  tmp___0 = shiftpalette(((uih___2->zengine)->fractalc)->palette, shift);
  }
#line 724
  if (tmp___0) {
#line 725
    uih___2->display = 1;
#line 725
    if (uih___2->recalculatemode > 2) {
#line 725
      uih___2->recalculatemode = uih___2->recalculatemode;
    } else {
#line 725
      uih___2->recalculatemode = 2;
    }
  }
#line 727
  uih___2->manualpaletteshift = 0;
#line 728
  uih___2->paletteshift = shift;
#line 729
  return;
}
}
#line 731 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_zoomcenter(struct uih_context *uih___2 , number_t x , number_t y ) 
{ 


  {
#line 733
  uih___2->xcenter = x;
#line 734
  uih___2->ycenter = y;
#line 735
  uih___2->xcenterm = 2147483647;
#line 736
  uih___2->ycenterm = 2147483647;
#line 737
  return;
}
}
#line 741 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_playtextpos(struct uih_context *uih___2 , dialogparam *p ) 
{ 
  int x ;
  int y ;

  {
  {
#line 744
  x = (p + 0)->dint;
#line 745
  y = (p + 1)->dint;
#line 746
  uih_settextpos(uih___2, x, y);
  }
#line 747
  return;
}
}
#line 749 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_playusleep(struct uih_context *uih___2 , int time___0 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 751
  parsenext = 0;
#line 752
  if ((unsigned long )uih___2->playstring != (unsigned long )((void *)0)) {
#line 753
    if ((unsigned long )errstring == (unsigned long )((void *)0)) {
      {
#line 753
      tmp = gettext("sleep available only in animation replay");
#line 753
      errstring = (char const   *)tmp;
      }
    }
#line 754
    return;
  }
  {
#line 756
  (uih___2->playc)->frametime = time___0;
#line 757
  tmp___1 = tl_lookup_timer((uih___2->playc)->timer);
  }
#line 757
  if (time___0 < tmp___1) {
    {
#line 759
    tl_slowdown_timer((uih___2->playc)->timer, time___0);
#line 760
    ((uih___2->playc)->playframe) ++;
    }
  } else {
    {
#line 762
    tl_set_interval((uih___2->playc)->timer, time___0);
    }
#line 763
    if (! (uih___2->playc)->timerin) {
      {
#line 764
      (uih___2->playc)->timerin = 1;
#line 765
      tl_add_timer(syncgroup, (uih___2->playc)->timer);
      }
    } else {
      {
#line 767
      tmp___0 = gettext("Internal program error #12 %i\n");
#line 767
      printf((char const   */* __restrict  */)tmp___0, (uih___2->playc)->playframe);
      }
    }
  }
  {
#line 770
  (uih___2->playc)->starttime = tl_lookup_timer((uih___2->playc)->timer);
  }
#line 771
  return;
}
}
#line 773 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_playtextsleep(struct uih_context *uih___2 ) 
{ 


  {
  {
#line 775
  uih_playusleep(uih___2, 500000 + (1000000 * (uih___2->nletters + uih___2->todisplayletters)) / uih___2->letterspersec);
#line 779
  uih___2->nletters = 0;
#line 780
  uih___2->todisplayletters = 0;
  }
#line 781
  return;
}
}
#line 784 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_playwait(struct uih_context *uih___2 ) 
{ 
  char *tmp ;

  {
#line 786
  parsenext = 0;
#line 787
  if ((unsigned long )uih___2->playstring != (unsigned long )((void *)0)) {
#line 788
    if ((unsigned long )errstring == (unsigned long )((void *)0)) {
      {
#line 788
      tmp = gettext("wait available only in animation replay");
#line 788
      errstring = (char const   *)tmp;
      }
    }
#line 789
    return;
  }
#line 791
  if (! uih___2->uncomplette) {
#line 791
    if (! uih___2->display) {
#line 791
      if (! uih___2->recalculatemode) {
#line 791
        if (! uih___2->displaytext) {
#line 791
          if (! uih___2->clearscreen) {
#line 793
            ((uih___2->playc)->playframe) ++;
          } else {
            {
#line 795
            uih_setcomplettehandler(uih___2, & handler1, (void *)uih___2);
            }
          }
        } else {
          {
#line 795
          uih_setcomplettehandler(uih___2, & handler1, (void *)uih___2);
          }
        }
      } else {
        {
#line 795
        uih_setcomplettehandler(uih___2, & handler1, (void *)uih___2);
        }
      }
    } else {
      {
#line 795
      uih_setcomplettehandler(uih___2, & handler1, (void *)uih___2);
      }
    }
  } else {
    {
#line 795
    uih_setcomplettehandler(uih___2, & handler1, (void *)uih___2);
    }
  }
#line 797
  return;
}
}
#line 799 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_playjulia(struct uih_context *uih___2 , int julia ) 
{ 


  {
#line 801
  julia = ! julia;
#line 802
  if (julia != (uih___2->fcontext)->mandelbrot) {
#line 803
    (uih___2->fcontext)->mandelbrot = julia;
#line 804
    ((uih___2->fcontext)->version) ++;
#line 805
    if ((unsigned long )uih___2->updatemenus != (unsigned long )((void *)0)) {
      {
#line 805
      (*(uih___2->updatemenus))(uih___2, "uimandelbrot");
      }
    }
#line 806
    uih___2->display = 1;
#line 806
    if (uih___2->recalculatemode > 2) {
#line 806
      uih___2->recalculatemode = uih___2->recalculatemode;
    } else {
#line 806
      uih___2->recalculatemode = 2;
    }
  }
#line 808
  return;
}
}
#line 810 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_playcalculate(struct uih_context *uih___2 ) 
{ 


  {
#line 812
  uih___2->display = 1;
#line 812
  if (uih___2->recalculatemode > 2) {
#line 812
    uih___2->recalculatemode = uih___2->recalculatemode;
  } else {
#line 812
    uih___2->recalculatemode = 2;
  }
#line 813
  return;
}
}
#line 815 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_playzoom(struct uih_context *uih___2 ) 
{ 


  {
#line 817
  uih___2->zoomactive = 1;
#line 818
  return;
}
}
#line 820 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_playunzoom(struct uih_context *uih___2 ) 
{ 


  {
#line 822
  uih___2->zoomactive = -1;
#line 823
  return;
}
}
#line 825 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_playstop(struct uih_context *uih___2 ) 
{ 


  {
#line 827
  uih___2->zoomactive = 0;
#line 828
  return;
}
}
#line 830 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_playmessage(struct uih_context *uih___2 , char *name___0 ) 
{ 
  char *message ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 833
  if ((unsigned long )catalog == (unsigned long )((void *)0)) {
    {
#line 834
    tmp = gettext("No catalog file loaded");
#line 834
    uih_text(uih___2, (char const   *)tmp);
    }
#line 835
    return;
  }
  {
#line 837
  message = find_text(catalog, (char const   *)name___0);
  }
#line 838
  if ((unsigned long )message == (unsigned long )((void *)0)) {
    {
#line 839
    tmp___0 = gettext("Message not found in catalog file");
#line 839
    uih_text(uih___2, (char const   *)tmp___0);
    }
#line 840
    return;
  }
  {
#line 842
  uih_text(uih___2, (char const   *)message);
  }
#line 843
  return;
}
}
#line 845 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_playload(struct uih_context *uih___2 , char *file ) 
{ 
  xio_file f ;
  xio_pathdata tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
#line 849
  if ((unsigned long )uih___2->playstring != (unsigned long )((void *)0)) {
#line 850
    if ((unsigned long )errstring == (unsigned long )((void *)0)) {
      {
#line 850
      tmp___0 = gettext("load available only in animation replay");
#line 850
      errstring = (char const   *)tmp___0;
      }
    }
#line 851
    return;
  }
#line 853
  if ((uih___2->playc)->level == 10) {
#line 854
    if ((unsigned long )errstring == (unsigned long )((void *)0)) {
      {
#line 854
      tmp___1 = gettext("Include level overflow");
#line 854
      errstring = (char const   *)tmp___1;
      }
    }
#line 855
    return;
  }
  {
#line 859
  strcpy((char */* __restrict  */)(tmp), (char const   */* __restrict  */)(uih___2->playc)->directory);
#line 859
  tmp___2 = strlen((char const   *)(uih___2->playc)->directory);
  }
#line 859
  if (tmp___2) {
    {
#line 859
    tmp___3 = strlen((char const   *)(tmp));
    }
#line 859
    if ((int )tmp[tmp___3 - 1UL] != 47) {
      {
#line 859
      strcat((char */* __restrict  */)(tmp), (char const   */* __restrict  */)"/");
      }
    }
  }
  {
#line 859
  strcat((char */* __restrict  */)(tmp), (char const   */* __restrict  */)file);
#line 860
  f = xio_ropen((xio_constpath )(tmp));
  }
#line 862
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 863
    if ((unsigned long )errstring == (unsigned long )((void *)0)) {
      {
#line 863
      tmp___4 = gettext("File not found");
#line 863
      errstring = (char const   *)tmp___4;
      }
    }
#line 864
    return;
  }
#line 866
  (uih___2->playc)->prevfiles[(uih___2->playc)->level] = (uih___2->playc)->file;
#line 867
  ((uih___2->playc)->level) ++;
#line 868
  (uih___2->playc)->file = f;
#line 869
  (uih___2->playc)->line = 1;
#line 870
  return;
}
}
#line 872 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
static void uih_processcommand(struct uih_context *uih___2 , int flags ) 
{ 
  char const   *error___1 ;
  char *tmp ;

  {
  {
#line 875
  first___0 = 1;
#line 876
  last___0 = 0;
#line 877
  error___1 = menu_processcommand(uih___2, & gettokenwr, 1, flags, uih___2->menuroot);
  }
#line 878
  if ((unsigned long )error___1 != (unsigned long )((void *)0)) {
#line 879
    if ((unsigned long )errstring == (unsigned long )((void *)0)) {
#line 879
      errstring = error___1;
    }
  }
#line 880
  if (! last___0) {
#line 881
    if ((unsigned long )errstring == (unsigned long )((void *)0)) {
      {
#line 881
      tmp = gettext("Too many parameters");
#line 881
      errstring = (char const   *)tmp;
      }
    }
  }
#line 883
  return;
}
}
#line 887 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
static char errtext[1024]  ;
#line 885 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_playupdate(struct uih_context *uih___2 ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 888
  errstring = (char const   *)((void *)0);
  {
#line 889
  while (1) {
    while_continue: /* CIL Label */ ;
#line 889
    if (uih___2->play) {
#line 889
      if ((uih___2->playc)->playframe) {
#line 889
        if (! ((unsigned long )errstring == (unsigned long )((void *)0))) {
#line 889
          goto while_break;
        }
      } else {
#line 889
        goto while_break;
      }
    } else {
#line 889
      goto while_break;
    }
#line 890
    parsenext = 1;
#line 891
    ((uih___2->playc)->playframe) --;
#line 892
    if ((uih___2->playc)->lines.morphing) {
      {
#line 893
      uih_stopmorphing(uih___2);
#line 894
      uih___2->display = 1;
      }
    }
#line 896
    if ((uih___2->playc)->morph) {
#line 897
      (uih___2->fcontext)->s = (uih___2->playc)->destination;
#line 898
      uih___2->display = 1;
#line 898
      if (uih___2->recalculatemode > 1) {
#line 898
        uih___2->recalculatemode = uih___2->recalculatemode;
      } else {
#line 898
        uih___2->recalculatemode = 1;
      }
#line 899
      (uih___2->playc)->morph = 0;
    }
#line 901
    if ((uih___2->playc)->morphangle) {
      {
#line 902
      uih_angle(uih___2, (uih___2->playc)->destangle);
#line 903
      (uih___2->playc)->morphangle = 0;
      }
    }
#line 905
    if ((uih___2->playc)->morphjulia) {
      {
#line 906
      uih_setjuliaseed(uih___2, (uih___2->playc)->dr, (uih___2->playc)->di);
#line 907
      (uih___2->playc)->morphjulia = 0;
      }
    }
    {
#line 909
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 909
      tmp = (*(((uih___2->playc)->file)->xeof))((uih___2->playc)->file);
      }
#line 909
      if (tmp) {
#line 909
        goto while_break___0;
      } else
#line 909
      if (parsenext) {
#line 909
        if (! ((unsigned long )errstring == (unsigned long )((void *)0))) {
#line 909
          goto while_break___0;
        }
      } else {
#line 909
        goto while_break___0;
      }
      {
#line 910
      uih_processcommand(uih___2, 64);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 912
    uih_update_lines(uih___2);
    }
#line 913
    if ((unsigned long )errstring != (unsigned long )((void *)0)) {
      {
#line 914
      uih_error(uih___2, errstring);
      }
#line 915
      if (uih___2->play) {
        {
#line 916
        tmp___0 = gettext("Replay disabled at line %i");
#line 916
        sprintf((char */* __restrict  */)(errtext), (char const   */* __restrict  */)tmp___0,
                (uih___2->playc)->line);
#line 918
        uih_message(uih___2, (char const   *)(errtext));
        }
      }
    }
    {
#line 922
    tmp___1 = (*(((uih___2->playc)->file)->xeof))((uih___2->playc)->file);
    }
#line 922
    if (tmp___1) {
#line 922
      if (parsenext) {
        {
#line 923
        uih_replaydisable(uih___2);
        }
      } else {
#line 922
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 922
    if (errstring) {
      {
#line 923
      uih_replaydisable(uih___2);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 926
  return;
}
}
#line 928 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_load(struct uih_context *uih___2 , xio_file f , xio_constpath filename___0 ) 
{ 


  {
  {
#line 930
  nonblockmode = 1;
#line 931
  uih_replayenable(uih___2, f, filename___0, 0);
#line 932
  uih_replaydisable(uih___2);
#line 933
  nonblockmode = 0;
  }
#line 934
  return;
}
}
#line 936 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/play.c"
void uih_command(struct uih_context *uih___2 , char const   *command ) 
{ 
  int tmp ;

  {
#line 938
  errstring = (char const   *)((void *)0);
#line 939
  uih___2->playpos = 0;
#line 940
  uih___2->playstring = command;
#line 941
  if (uih___2->play) {
#line 941
    tmp = 16;
  } else {
#line 941
    tmp = 0;
  }
  {
#line 941
  uih_processcommand(uih___2, tmp);
#line 942
  uih___2->playstring = (char const   *)((void *)0);
  }
#line 943
  if ((unsigned long )errstring != (unsigned long )((void *)0)) {
    {
#line 944
    uih_error(uih___2, errstring);
    }
  }
#line 946
  return;
}
}
#line 538 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui_helper.h"
void uih_inittext(uih_context *c ) ;
#line 539
void uih_destroytext(uih_context *c ) ;
#line 14 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/playtext.c"
__inline static void prepare(struct uih_context *c , char *string , int *xmax , int *nr ) 
{ 
  int xm ;
  int n ;
  int pos ;
  int tmp ;

  {
#line 17
  xm = 0;
#line 18
  n = 1;
#line 19
  pos = 0;
  {
#line 21
  while (1) {
    while_continue: /* CIL Label */ ;
#line 22
    tmp = 0;
    {
#line 23
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 23
      if (! ((int )*string != 10)) {
#line 23
        goto while_break___0;
      }
#line 24
      if ((int )*string == 0) {
#line 25
        tmp ++;
#line 26
        if (tmp > xm) {
#line 27
          xm = tmp;
        }
#line 28
        *xmax = xm;
#line 29
        *nr = n;
#line 30
        return;
      } else {
#line 32
        tmp += (int )(c->font)->width;
      }
#line 33
      if (pos > 255) {
#line 34
        goto while_break___0;
      }
#line 35
      string ++;
#line 36
      pos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 38
    tmp ++;
#line 39
    if (tmp > xm) {
#line 40
      xm = tmp;
    }
#line 41
    n ++;
#line 42
    if (n > 30) {
#line 43
      n = 30;
#line 44
      *xmax = tmp;
#line 45
      *nr = n;
#line 46
      return;
    }
#line 48
    pos = 0;
#line 49
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 53 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/playtext.c"
static void getpos___0(uih_context *c , int *x , int *y , int *w , int *h , void *data ) 
{ 
  int num ;
  int xmax ;
  int nr ;
  int tmp ;
  int tmp___0 ;

  {
#line 56
  num = (int )data;
#line 58
  if ((unsigned long )c->text[num] == (unsigned long )((void *)0)) {
#line 59
    tmp___0 = *w;
#line 59
    *h = tmp___0;
#line 59
    tmp = tmp___0;
#line 59
    *y = tmp;
#line 59
    *x = tmp;
#line 60
    return;
  }
  {
#line 62
  prepare(c, c->text[num], & xmax, & nr);
#line 63
  nr *= (int )((c->font)->height + 1);
  }
  {
#line 65
  if (num == 0) {
#line 65
    goto case_0;
  }
#line 68
  if (num == 1) {
#line 68
    goto case_1;
  }
#line 71
  if (num == 2) {
#line 71
    goto case_2;
  }
#line 64
  goto switch_break;
  case_0: /* CIL Label */ 
#line 66
  *y = 0;
#line 67
  goto switch_break;
  case_1: /* CIL Label */ 
#line 69
  *y = ((c->image)->height - nr) / 2;
#line 70
  goto switch_break;
  case_2: /* CIL Label */ 
#line 72
  *y = (c->image)->height - nr;
#line 73
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 75
  *h = nr;
  {
#line 77
  if (c->textpos[num] == 0) {
#line 77
    goto case_0___0;
  }
#line 80
  if (c->textpos[num] == 1) {
#line 80
    goto case_1___0;
  }
#line 83
  if (c->textpos[num] == 2) {
#line 83
    goto case_2___0;
  }
#line 76
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
#line 78
  *x = 0;
#line 79
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 81
  *x = ((c->image)->width - xmax) / 2;
#line 82
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 84
  *x = (c->image)->width - xmax;
#line 85
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 87
  *w = xmax;
#line 88
  return;
}
}
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/playtext.c"
static void draw___0(uih_context *c , void *data ) 
{ 
  int num ;
  int flags ;
  int xmax ;
  int n ;
  int nr ;
  int i ;
  int x ;
  int y ;
  char *string ;
  int fgcolor ;
  int bgcolor ;
  int tmp ;

  {
#line 92
  num = (int )data;
#line 93
  flags = 0;
#line 95
  x = 0;
#line 95
  y = 0;
#line 97
  fgcolor = 0;
#line 97
  bgcolor = 0;
#line 98
  if ((unsigned long )c->text[num] == (unsigned long )((void *)0)) {
#line 99
    return;
  }
  {
#line 100
  prepare(c, c->text[num], & xmax, & n);
#line 101
  nr = n * (int )((c->font)->height + 1);
  }
  {
#line 103
  if (c->textcolor[num] == 0) {
#line 103
    goto case_0;
  }
#line 107
  if (c->textcolor[num] == 1) {
#line 107
    goto case_1;
  }
#line 112
  if (c->textcolor[num] == 2) {
#line 112
    goto case_2;
  }
#line 116
  goto switch_default;
  case_0: /* CIL Label */ 
#line 104
  fgcolor = (int )*((c->palette)->index + 1);
#line 105
  bgcolor = (int )*((c->palette)->index + 0);
#line 106
  goto switch_break;
  case_1: /* CIL Label */ 
#line 108
  fgcolor = (int )*((c->palette)->index + 0);
#line 109
  bgcolor = (int )*((c->palette)->index + 0);
#line 110
  flags = 1;
#line 111
  goto switch_break;
  case_2: /* CIL Label */ 
#line 113
  fgcolor = (int )*((c->palette)->index + 2);
#line 114
  bgcolor = (int )*((c->palette)->index + 0);
#line 115
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 117
  x_fatalerror((char *)"playtext:unknown color\n");
  }
  switch_break: /* CIL Label */ ;
  }
#line 119
  if ((c->image)->flags & 4) {
#line 120
    fgcolor = (int )*((c->palette)->index + 0);
  }
  {
#line 122
  if (num == 0) {
#line 122
    goto case_0___0;
  }
#line 125
  if (num == 1) {
#line 125
    goto case_1___0;
  }
#line 128
  if (num == 2) {
#line 128
    goto case_2___0;
  }
#line 121
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
#line 123
  y = 0;
#line 124
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 126
  y = ((c->image)->height - nr) / 2;
#line 127
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 129
  y = (c->image)->height - nr;
#line 130
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 132
  string = c->text[num];
#line 133
  i = 0;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! (i < n)) {
#line 133
      goto while_break;
    }
    {
#line 134
    xmax = xtextwidth(c->font, (char const   *)string);
    }
    {
#line 136
    if (c->textpos[num] == 0) {
#line 136
      goto case_0___1;
    }
#line 139
    if (c->textpos[num] == 1) {
#line 139
      goto case_1___1;
    }
#line 142
    if (c->textpos[num] == 2) {
#line 142
      goto case_2___1;
    }
#line 135
    goto switch_break___1;
    case_0___1: /* CIL Label */ 
#line 137
    x = 0;
#line 138
    goto switch_break___1;
    case_1___1: /* CIL Label */ 
#line 140
    x = ((c->image)->width - xmax) / 2;
#line 141
    goto switch_break___1;
    case_2___1: /* CIL Label */ 
#line 143
    x = (c->image)->width - xmax;
#line 144
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    {
#line 146
    tmp = xprint(c->image, c->font, x, y, (char const   *)string, 0, fgcolor, bgcolor,
                 flags);
#line 146
    string += tmp + 1;
#line 149
    y += (int )((c->font)->height + 1);
#line 133
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/playtext.c"
void uih_inittext(uih_context *c ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 155
  tmp___0 = (char *)((void *)0);
#line 155
  c->text[2] = tmp___0;
#line 155
  tmp = tmp___0;
#line 155
  c->text[1] = tmp;
#line 155
  c->text[0] = tmp;
#line 156
  tmp___2 = 0;
#line 156
  c->textpos[2] = tmp___2;
#line 156
  tmp___1 = tmp___2;
#line 156
  c->textpos[1] = tmp___1;
#line 156
  c->textpos[0] = tmp___1;
#line 157
  c->textwindow[0] = uih_registerw(c, & getpos___0, & draw___0, (void *)0, 0);
#line 158
  c->textwindow[1] = uih_registerw(c, & getpos___0, & draw___0, (void *)1, 0);
#line 159
  c->textwindow[2] = uih_registerw(c, & getpos___0, & draw___0, (void *)2, 0);
  }
#line 160
  return;
}
}
#line 162 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/playtext.c"
void uih_destroytext(uih_context *c ) 
{ 


  {
#line 164
  if ((unsigned long )c->text[0] != (unsigned long )((void *)0)) {
    {
#line 165
    free((void *)c->text[0]);
#line 165
    c->text[0] = (char *)((void *)0);
    }
  }
#line 166
  if ((unsigned long )c->text[1] != (unsigned long )((void *)0)) {
    {
#line 167
    free((void *)c->text[1]);
#line 167
    c->text[1] = (char *)((void *)0);
    }
  }
#line 168
  if ((unsigned long )c->text[2] != (unsigned long )((void *)0)) {
    {
#line 169
    free((void *)c->text[2]);
#line 169
    c->text[2] = (char *)((void *)0);
    }
  }
  {
#line 170
  uih_removew(c, c->textwindow[0]);
#line 171
  uih_removew(c, c->textwindow[1]);
#line 172
  uih_removew(c, c->textwindow[2]);
  }
#line 173
  return;
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 150 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 251 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
__inline extern  __attribute__((__nothrow__)) double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgamma)(double __d ) ;
#line 258
__inline extern  __attribute__((__nothrow__)) double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgamma)(double __d ) ;
#line 264
__inline extern  __attribute__((__nothrow__)) double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) gamma)(double __d ) ;
#line 271
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) lgamma_r)(double  ,
                                                                                  int *__signgamp )  __asm__("__lgamma_r_finite")  ;
#line 251
__inline extern  __attribute__((__nothrow__)) float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammaf)(float __d ) ;
#line 258
__inline extern  __attribute__((__nothrow__)) float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammaf)(float __d ) ;
#line 264
__inline extern  __attribute__((__nothrow__)) float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) gammaf)(float __d ) ;
#line 271
extern  __attribute__((__nothrow__)) float ( __attribute__((__leaf__)) lgammaf_r)(float  ,
                                                                                  int *__signgamp )  __asm__("__lgammaf_r_finite")  ;
#line 251
__inline extern  __attribute__((__nothrow__)) long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammal)(long double __d ) ;
#line 258
__inline extern  __attribute__((__nothrow__)) long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammal)(long double __d ) ;
#line 264
__inline extern  __attribute__((__nothrow__)) long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) gammal)(long double __d ) ;
#line 271
extern  __attribute__((__nothrow__)) long double ( __attribute__((__leaf__)) lgammal_r)(long double  ,
                                                                                        int *__signgamp )  __asm__("__lgammal_r_finite")  ;
#line 256 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern  __attribute__((__nothrow__)) double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgamma)(double __d ) ;
#line 256 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgamma)(double __d ) 
{ 
  int __local_signgam ;
  double tmp ;

  {
  {
#line 259
  __local_signgam = 0;
#line 260
  tmp = lgamma_r(__d, & __local_signgam);
  }
#line 260
  return ((double __attribute__((__gnu_inline__))  )tmp);
}
}
#line 265
__inline extern  __attribute__((__nothrow__)) float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammaf)(float __d ) ;
#line 265 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammaf)(float __d ) 
{ 
  int __local_signgam ;
  float tmp ;

  {
  {
#line 268
  __local_signgam = 0;
#line 269
  tmp = lgammaf_r(__d, & __local_signgam);
  }
#line 269
  return ((float __attribute__((__gnu_inline__))  )tmp);
}
}
#line 275
__inline extern  __attribute__((__nothrow__)) long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammal)(long double __d ) ;
#line 275 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) lgammal)(long double __d ) 
{ 
  int __local_signgam ;
  long double tmp ;

  {
  {
#line 278
  __local_signgam = 0;
#line 279
  tmp = lgammal_r(__d, & __local_signgam);
  }
#line 279
  return ((long double __attribute__((__gnu_inline__))  )tmp);
}
}
#line 427
extern double __gamma_r_finite(double  , int * ) ;
#line 428
__inline extern  __attribute__((__nothrow__)) double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgamma)(double __d ) ;
#line 428 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgamma)(double __d ) 
{ 
  int __local_signgam ;
  double __res ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 430
  __local_signgam = 0;
#line 431
  tmp = __gamma_r_finite(__d, & __local_signgam);
#line 431
  __res = tmp;
  }
#line 432
  if (__local_signgam < 0) {
#line 432
    tmp___0 = - __res;
  } else {
#line 432
    tmp___0 = __res;
  }
#line 432
  return ((double __attribute__((__gnu_inline__))  )tmp___0);
}
}
#line 434
extern float __gammaf_r_finite(float  , int * ) ;
#line 435
__inline extern  __attribute__((__nothrow__)) float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammaf)(float __d ) ;
#line 435 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern float __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammaf)(float __d ) 
{ 
  int __local_signgam ;
  float __res ;
  float tmp ;
  float tmp___0 ;

  {
  {
#line 437
  __local_signgam = 0;
#line 438
  tmp = __gammaf_r_finite(__d, & __local_signgam);
#line 438
  __res = tmp;
  }
#line 439
  if (__local_signgam < 0) {
#line 439
    tmp___0 = - __res;
  } else {
#line 439
    tmp___0 = __res;
  }
#line 439
  return ((float __attribute__((__gnu_inline__))  )tmp___0);
}
}
#line 442
extern long double __gammal_r_finite(long double  , int * ) ;
#line 443
__inline extern  __attribute__((__nothrow__)) long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammal)(long double __d ) ;
#line 443 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern long double __attribute__((__gnu_inline__))  ( __attribute__((__leaf__,
__always_inline__)) tgammal)(long double __d ) 
{ 
  int __local_signgam ;
  long double __res ;
  long double tmp ;
  long double tmp___0 ;

  {
  {
#line 445
  __local_signgam = 0;
#line 449
  tmp = __gammal_r_finite(__d, & __local_signgam);
#line 449
  __res = tmp;
  }
#line 451
  if (__local_signgam < 0) {
#line 451
    tmp___0 = - __res;
  } else {
#line 451
    tmp___0 = __res;
  }
#line 451
  return ((long double __attribute__((__gnu_inline__))  )tmp___0);
}
}
#line 355 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xmenu.h"
extern void menu_destroydialog(menuitem const   *item , dialogparam *d , struct uih_context *uih ) ;
#line 125 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui.h"
number_t ui_getfloat(char const   *c ) ;
#line 130
void ui_menuactivate(menuitem const   *item , dialogparam *d ) ;
#line 133
xio_path ui_getfile(char const   *basename , char const   *extension ) ;
#line 134
void ui_help(char const   *name___0 ) ;
#line 32 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/grlib.h"
extern void xdrawcursor(struct image *img , int x , int y , int color , int height ) ;
#line 25 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uiint.h"
struct ui_driver  const  *driver ;
#line 32
int helpvisible ;
#line 32 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uiint.h"
int dialogvisible  ;
#line 32 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uiint.h"
int yesnodialogvisible  ;
#line 33
int ui_nogui ;
#line 38
void ui_updatetext(struct ui_textdata *d ) ;
#line 54
void ui_builddialog(menuitem const   *item ) ;
#line 56
void ui_closedialog(int succesfull ) ;
#line 57
int ui_dialogmouse(int x , int y , int mousebuttons , int flags ) ;
#line 58
int ui_dialogkeys(int key ) ;
#line 59
void ui_buildyesno(char const   *question , void (*handler___0)(int yes ) ) ;
#line 76 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static struct opendialog dialog  ;
#line 89 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static dialogparam *qparam  ;
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static menuitem const   *qitem  ;
#line 95 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static struct yesnodialog yesnodialog  ;
#line 111 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static int okwidth  ;
#line 112 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static int cancelwidth  ;
#line 114 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void NEXT(void) 
{ 


  {
  {
#line 116
  (*(((dialog.items + dialog.current)->type)->unselect))(dialog.items + dialog.current);
#line 118
  dialog.current = (dialog.current + 1) % dialog.nitems;
#line 119
  uih->display = 1;
  }
#line 120
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void PREV(void) 
{ 


  {
  {
#line 124
  (*(((dialog.items + dialog.current)->type)->unselect))(dialog.items + dialog.current);
  }
#line 126
  if (dialog.current) {
#line 126
    (dialog.current) --;
  } else {
#line 126
    dialog.current = dialog.nitems - 1;
  }
#line 128
  uih->display = 1;
#line 129
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
char const   * const  yestext  =    (char const   */* const  */)"Yes";
#line 137 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
char const   * const  notext  =    (char const   */* const  */)"No";
#line 141 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
void ui_drawbutton(char const   *text , int pressed , int selected , int x1 , int x2 ,
                   int y ) 
{ 
  int width ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 145
  tmp = xtextwidth(uih->font, text);
#line 145
  width = tmp;
  }
#line 147
  if ((uih->palette)->type & 3840) {
#line 148
    if (pressed != 0) {
#line 148
      tmp___0 = 1;
    } else
#line 148
    if (selected != 0) {
#line 148
      tmp___0 = 1;
    } else {
#line 148
      tmp___0 = 0;
    }
    {
#line 148
    uih_drawborder(uih, x1, y, x2 - x1, (int )(((uih->font)->height + 1) + 4), tmp___0 * 4 | 16);
    }
#line 151
    if (selected) {
#line 151
      tmp___1 = *((uih->palette)->index + 0);
    } else
#line 151
    if (pressed) {
#line 151
      tmp___1 = *((uih->palette)->index + 0);
    } else {
#line 151
      tmp___1 = *((uih->palette)->index + 1);
    }
    {
#line 151
    xprint(uih->image, uih->font, ((x1 + x2) - width) / 2 + pressed, (y + 2) + pressed,
           text, uih->encoding, (int )tmp___1, (int )*((uih->palette)->index + 0),
           1);
    }
  } else {
    {
#line 156
    uih_drawborder(uih, x1, y, x2 - x1, (int )(((uih->font)->height + 1) + 4), (pressed != 0) * 4 | 16);
    }
#line 158
    if (selected) {
#line 158
      tmp___2 = *((uih->palette)->index + 2);
    } else {
#line 158
      tmp___2 = *((uih->palette)->index + 1);
    }
    {
#line 158
    xprint(uih->image, uih->font, ((x1 + x2) - width) / 2 + pressed, (y + 2) + pressed,
           text, uih->encoding, (int )tmp___2, (int )*((uih->palette)->index + 0),
           0);
    }
  }
#line 163
  return;
}
}
#line 165 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_yesnopos(struct uih_context *c , int *x , int *y , int *w , int *h ,
                        void *data ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 172
  if (filevisible) {
#line 172
    goto _L;
  } else
#line 172
  if (helpvisible) {
    _L: /* CIL Label */ 
#line 173
    tmp___1 = 0;
#line 173
    *h = tmp___1;
#line 173
    tmp___0 = tmp___1;
#line 173
    *w = tmp___0;
#line 173
    tmp = tmp___0;
#line 173
    *y = tmp;
#line 173
    *x = tmp;
#line 174
    return;
  }
#line 176
  *w = yesnodialog.width;
#line 177
  *h = 2 * (int )(((uih->font)->height + 1) + 4) + 4;
#line 178
  *x = ((uih->image)->width - yesnodialog.width) / 2;
#line 179
  *y = ((uih->image)->height - (2 * (int )(((uih->font)->height + 1) + 4) + 4)) / 2;
#line 180
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_drawyesno(struct uih_context *c , void *data ) 
{ 


  {
  {
#line 184
  xprint(uih->image, uih->font, ((uih->image)->width - yesnodialog.width) / 2 + (yesnodialog.width - yesnodialog.questionwidth) / 2,
         ((uih->image)->height - (2 * (int )(((uih->font)->height + 1) + 4) + 4)) / 2 + 2,
         (char const   *)yesnodialog.question, uih->encoding, (int )*((uih->palette)->index + 1),
         (int )*((uih->palette)->index + 0), 0);
#line 188
  ui_drawbutton((char const   *)yestext, yesnodialog.pressed == 0, yesnodialog.selected == 0,
                (((uih->image)->width - yesnodialog.width) / 2 + 2) + 1, (((uih->image)->width - yesnodialog.width) / 2 + yesnodialog.width / 2) - 1,
                (((uih->image)->height - (2 * (int )(((uih->font)->height + 1) + 4) + 4)) / 2 + (int )(((uih->font)->height + 1) + 4)) + 2);
#line 192
  ui_drawbutton((char const   *)notext, yesnodialog.pressed == 1, yesnodialog.selected == 1,
                (((uih->image)->width - yesnodialog.width) / 2 + yesnodialog.width / 2) + 1,
                ((((uih->image)->width - yesnodialog.width) / 2 + yesnodialog.width) - 2) - 1,
                (((uih->image)->height - (2 * (int )(((uih->font)->height + 1) + 4) + 4)) / 2 + (int )(((uih->font)->height + 1) + 4)) + 2);
  }
#line 197
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_closeyesno(int success ) 
{ 


  {
#line 201
  if (! yesnodialogvisible) {
#line 202
    return;
  }
  {
#line 203
  free((void *)yesnodialog.question);
#line 204
  (*(yesnodialog.handler))(success);
#line 205
  yesnodialogvisible = 0;
#line 206
  uih_removew(uih, yesnodialog.window);
#line 207
  uih->display = 1;
  }
#line 208
  return;
}
}
#line 210 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
void ui_buildyesno(char const   *question , void (*handler___0)(int yes ) ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 212
  if (yesnodialogvisible) {
    {
#line 213
    ui_closeyesno(0);
    }
  }
  {
#line 214
  yesnodialogvisible = 1;
#line 215
  yesnodialog.questionwidth = xtextwidth(uih->font, question);
#line 216
  yesnodialog.question = mystrdup(question);
#line 217
  yesnodialog.mousereleased = 0;
#line 218
  tmp = xtextwidth(uih->font, (char const   *)yestext);
#line 218
  tmp___0 = xtextwidth(uih->font, (char const   *)notext);
#line 218
  yesnodialog.width = ((tmp + tmp___0) + 16) + 2;
  }
#line 222
  if (yesnodialog.width < yesnodialog.questionwidth) {
#line 223
    yesnodialog.width = yesnodialog.questionwidth;
  }
  {
#line 224
  yesnodialog.width += 4;
#line 225
  yesnodialog.handler = handler___0;
#line 226
  yesnodialog.selected = 0;
#line 227
  yesnodialog.pressed = -1;
#line 228
  yesnodialog.window = uih_registerw(uih, & ui_yesnopos, & ui_drawyesno, (void *)0,
                                     2);
#line 230
  uih->display = 1;
  }
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static int ui_keyyesno(int key ) 
{ 


  {
#line 235
  if (! yesnodialogvisible) {
#line 236
    return (0);
  }
  {
#line 238
  if (key == 259) {
#line 238
    goto case_259;
  }
#line 242
  if (key == 257) {
#line 242
    goto case_257;
  }
#line 245
  if (key == 9) {
#line 245
    goto case_9;
  }
#line 245
  if (key == 260) {
#line 245
    goto case_9;
  }
#line 249
  if (key == 258) {
#line 249
    goto case_258;
  }
#line 252
  if (key == 10) {
#line 252
    goto case_10;
  }
#line 252
  if (key == 13) {
#line 252
    goto case_10;
  }
#line 255
  if (key == 261) {
#line 255
    goto case_261;
  }
#line 237
  goto switch_break;
  case_259: /* CIL Label */ 
#line 239
  yesnodialog.selected ^= 1;
#line 240
  uih->display = 1;
#line 241
  return (1);
  case_257: /* CIL Label */ 
#line 243
  return (1);
  case_9: /* CIL Label */ 
  case_260: /* CIL Label */ 
#line 246
  yesnodialog.selected ^= 1;
#line 247
  uih->display = 1;
#line 248
  return (1);
  case_258: /* CIL Label */ 
#line 250
  return (1);
  case_10: /* CIL Label */ 
  case_13: /* CIL Label */ 
  {
#line 253
  ui_closeyesno(! yesnodialog.selected);
  }
#line 254
  return (1);
  case_261: /* CIL Label */ 
  {
#line 256
  ui_closeyesno(0);
  }
#line 257
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 259
  return (1);
}
}
#line 262 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static int ui_mouseyesno(int x , int y , int buttons , int flags ) 
{ 
  int mouseat ;

  {
#line 264
  mouseat = 0;
#line 265
  if (! yesnodialogvisible) {
#line 266
    return (0);
  }
#line 267
  if (! yesnodialog.mousereleased) {
#line 267
    if (flags & 2) {
#line 268
      yesnodialog.mousereleased = 1;
#line 269
      return (1);
    }
  }
#line 271
  if (! yesnodialog.mousereleased) {
#line 271
    if (flags & 4) {
#line 272
      return (1);
    }
  }
#line 274
  yesnodialog.mousereleased = 1;
#line 275
  if (x < ((uih->image)->width - yesnodialog.width) / 2) {
#line 275
    goto _L;
  } else
#line 275
  if (y < ((uih->image)->height - (2 * (int )(((uih->font)->height + 1) + 4) + 4)) / 2) {
#line 275
    goto _L;
  } else
#line 275
  if (x > ((uih->image)->width - yesnodialog.width) / 2 + yesnodialog.width) {
#line 275
    goto _L;
  } else
#line 275
  if (y > ((uih->image)->height - (2 * (int )(((uih->font)->height + 1) + 4) + 4)) / 2 + (2 * (int )(((uih->font)->height + 1) + 4) + 4)) {
    _L: /* CIL Label */ 
#line 277
    if (flags & 1) {
      {
#line 278
      ui_closeyesno(0);
      }
    } else {
#line 280
      if (yesnodialog.pressed != -1) {
#line 281
        uih->display = 1;
      }
#line 282
      yesnodialog.pressed = -1;
    }
#line 284
    return (1);
  }
#line 286
  if (x > ((uih->image)->width - yesnodialog.width) / 2 + yesnodialog.width / 2) {
#line 287
    mouseat = 1;
  }
#line 288
  if (flags & 4) {
#line 289
    if (yesnodialog.pressed != mouseat) {
#line 290
      uih->display = 1;
    }
#line 291
    if (yesnodialog.selected != mouseat) {
#line 292
      uih->display = 1;
    }
#line 293
    yesnodialog.selected = mouseat;
#line 294
    yesnodialog.pressed = mouseat;
  } else {
#line 296
    if (flags & 8) {
#line 296
      if (yesnodialog.selected != mouseat) {
#line 297
        uih->display = 1;
#line 297
        yesnodialog.selected = mouseat;
      }
    }
#line 298
    if (yesnodialog.pressed != -1) {
#line 299
      uih->display = 1;
    }
#line 300
    yesnodialog.pressed = -1;
  }
#line 302
  if (flags & 2) {
    {
#line 303
    ui_closeyesno(! mouseat);
    }
  }
#line 305
  return (1);
}
}
#line 308 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_buildok(struct dialogitem *item , menudialog const   *entry ) 
{ 
  struct okdata *ok ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 311
  item->height = (int )(((uih->font)->height + 1) + 4);
#line 312
  tmp = gettext("OK");
#line 312
  okwidth = xtextwidth(uih->font, (char const   *)tmp);
#line 313
  tmp___0 = gettext("Cancel");
#line 313
  cancelwidth = xtextwidth(uih->font, (char const   *)tmp___0);
#line 314
  item->width = (okwidth + 4) + 2;
#line 315
  item->width1 = (cancelwidth + 4) + 2;
  }
#line 316
  if (item->width < item->width1) {
#line 317
    item->width = item->width1;
  }
#line 318
  if (item->width > item->width1) {
#line 319
    item->width1 = item->width;
  }
  {
#line 320
  tmp___1 = malloc(sizeof(struct okdata ));
#line 320
  ok = (struct okdata *)tmp___1;
#line 320
  item->data = (void *)ok;
#line 321
  ok->pressed = -1;
#line 322
  ok->selected = 0;
  }
#line 323
  return;
}
}
#line 325 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_destroyok(struct dialogitem *item , dialogparam *param ) 
{ 


  {
  {
#line 327
  free(item->data);
  }
#line 328
  return;
}
}
#line 330 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static int ui_keyok(struct dialogitem *item , int key ) 
{ 
  struct okdata *ok ;

  {
#line 332
  ok = (struct okdata *)item->data;
  {
#line 334
  if (key == 259) {
#line 334
    goto case_259;
  }
#line 340
  if (key == 257) {
#line 340
    goto case_257;
  }
#line 344
  if (key == 9) {
#line 344
    goto case_9;
  }
#line 344
  if (key == 260) {
#line 344
    goto case_9;
  }
#line 350
  if (key == 258) {
#line 350
    goto case_258;
  }
#line 354
  if (key == 10) {
#line 354
    goto case_10;
  }
#line 354
  if (key == 13) {
#line 354
    goto case_10;
  }
#line 333
  goto switch_break;
  case_259: /* CIL Label */ 
#line 335
  if (ok->selected >= 1) {
#line 336
    (ok->selected) --;
#line 337
    uih->display = 1;
#line 338
    return (1);
  }
  case_257: /* CIL Label */ 
  {
#line 341
  PREV();
  }
#line 342
  return (1);
  case_9: /* CIL Label */ 
  case_260: /* CIL Label */ 
#line 345
  if (ok->selected < 2) {
#line 346
    (ok->selected) ++;
#line 347
    uih->display = 1;
#line 348
    return (1);
  }
  case_258: /* CIL Label */ 
  {
#line 351
  NEXT();
  }
#line 352
  return (1);
  case_10: /* CIL Label */ 
  case_13: /* CIL Label */ 
#line 355
  if (ok->selected <= 1) {
    {
#line 356
    ui_closedialog(! ok->selected);
    }
  } else {
    {
#line 358
    ui_help((char const   *)(dialog.item)->shortname);
    }
  }
#line 359
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 361
  return (0);
}
}
#line 364 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_mouseok(struct dialogitem *item , int x , int y , int buttons , int flags ) 
{ 
  struct okdata *ok ;
  int mouseat ;

  {
#line 367
  ok = (struct okdata *)item->data;
#line 368
  mouseat = 0;
#line 369
  if (x > dialog.x + dialog.width / 3) {
#line 370
    mouseat = 1;
  }
#line 371
  if (x > dialog.x + (2 * dialog.width) / 3) {
#line 372
    mouseat = 2;
  }
#line 373
  if (flags & 4) {
#line 374
    if (ok->pressed != mouseat) {
#line 375
      uih->display = 1;
    }
#line 376
    if (ok->selected != mouseat) {
#line 377
      uih->display = 1;
    }
#line 378
    ok->selected = mouseat;
#line 379
    ok->pressed = mouseat;
  } else {
#line 381
    if (flags & 8) {
#line 381
      if (ok->selected != mouseat) {
#line 382
        uih->display = 1;
#line 382
        ok->selected = mouseat;
      }
    }
#line 383
    if (ok->pressed != -1) {
#line 384
      uih->display = 1;
    }
#line 385
    ok->pressed = -1;
  }
#line 387
  if (flags & 2) {
#line 388
    if (mouseat < 2) {
      {
#line 389
      ui_closedialog(! mouseat);
      }
    } else {
      {
#line 391
      ui_help((char const   *)(dialog.item)->shortname);
      }
    }
  }
#line 393
  return;
}
}
#line 395 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_drawok(struct dialogitem *item ) 
{ 
  struct okdata *ok ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 397
  ok = (struct okdata *)item->data;
#line 398
  if (item - dialog.items == (long )dialog.current) {
#line 398
    if (ok->selected == 0) {
#line 398
      tmp = 1;
    } else {
#line 398
      tmp = 0;
    }
  } else {
#line 398
    tmp = 0;
  }
  {
#line 398
  tmp___0 = gettext("OK");
#line 398
  ui_drawbutton((char const   *)tmp___0, ok->pressed == 0, tmp, (dialog.x + 2) + 1,
                (dialog.x + dialog.width / 3) - 1, item->y);
  }
#line 401
  if (item - dialog.items == (long )dialog.current) {
#line 401
    if (ok->selected == 1) {
#line 401
      tmp___1 = 1;
    } else {
#line 401
      tmp___1 = 0;
    }
  } else {
#line 401
    tmp___1 = 0;
  }
  {
#line 401
  tmp___2 = gettext("Cancel");
#line 401
  ui_drawbutton((char const   *)tmp___2, ok->pressed == 1, tmp___1, (dialog.x + dialog.width / 3) + 1,
                (dialog.x + (2 * dialog.width) / 3) - 2, item->y);
  }
#line 404
  if (item - dialog.items == (long )dialog.current) {
#line 404
    if (ok->selected == 2) {
#line 404
      tmp___3 = 1;
    } else {
#line 404
      tmp___3 = 0;
    }
  } else {
#line 404
    tmp___3 = 0;
  }
  {
#line 404
  tmp___4 = gettext("Help");
#line 404
  ui_drawbutton((char const   *)tmp___4, ok->pressed == 2, tmp___3, dialog.x + (2 * dialog.width) / 3,
                ((dialog.x + dialog.width) - 2) - 1, item->y);
  }
#line 407
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_unselectok(struct dialogitem *item ) 
{ 
  struct okdata *ok ;

  {
#line 411
  ok = (struct okdata *)item->data;
#line 412
  ok->pressed = -1;
#line 413
  ok->selected = 0;
#line 414
  uih->display = 1;
#line 415
  return;
}
}
#line 417 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static struct dialogtype  const  okdialog  =    {& ui_buildok, & ui_keyok, & ui_mouseok, & ui_destroyok, & ui_drawok, & ui_unselectok};
#line 426 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
void ui_updatetext(struct ui_textdata *d ) 
{ 
  int again___0 ;
  int i ;
  int wi ;
  int len ;
  size_t tmp ;

  {
  {
#line 428
  again___0 = 1;
#line 431
  tmp = strlen((char const   *)d->text);
#line 431
  len = (int )tmp;
  }
#line 432
  if (d->start >= len) {
#line 433
    d->start = 0;
  }
#line 434
  if (d->cursor > len) {
#line 435
    d->cursor = len;
  }
#line 436
  if (d->cursor < d->start) {
#line 437
    d->start = d->cursor;
  }
  {
#line 438
  while (1) {
    while_continue: /* CIL Label */ ;
#line 439
    wi = 0;
#line 440
    i = 0;
    {
#line 440
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 440
      if (! *(d->text + (d->start + i))) {
#line 440
        goto while_break___0;
      }
#line 441
      if (d->start + i == d->cursor) {
#line 442
        d->cursorpos = wi;
      }
#line 443
      wi += (int )(uih->font)->width;
#line 444
      if (wi >= d->width) {
#line 445
        goto while_break___0;
      }
#line 440
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 448
    if (d->start + i == d->cursor) {
#line 448
      if (wi < d->width) {
#line 449
        d->cursorpos = wi;
      }
    }
#line 450
    if (d->start + i < d->cursor) {
#line 451
      (d->start) ++;
    } else {
#line 453
      again___0 = 0;
    }
#line 438
    if (! again___0) {
#line 438
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  d->ndisplayed = i;
  {
#line 457
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 457
    if (! again___0) {
#line 457
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 458
  return;
}
}
#line 460 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
struct ui_textdata *ui_opentext(int x , int y , int width , char const   *def ) 
{ 
  struct ui_textdata *d ;
  void *tmp ;
  char *text ;
  int size ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 462
  tmp = malloc(sizeof(*d));
#line 462
  d = (struct ui_textdata *)tmp;
#line 464
  size = 100;
#line 465
  tmp___1 = strlen(def);
  }
#line 465
  if ((int )tmp___1 > size) {
    {
#line 466
    tmp___0 = strlen(def);
#line 466
    size = (int )tmp___0 * 2;
    }
  }
  {
#line 467
  d->x = x;
#line 468
  d->y = y;
#line 469
  d->width = width;
#line 470
  tmp___2 = malloc((size_t )size);
#line 470
  text = (char *)tmp___2;
#line 471
  strcpy((char */* __restrict  */)text, (char const   */* __restrict  */)def);
#line 472
  d->text = text;
#line 473
  d->cursor = 0;
#line 474
  d->cursorpos = 0;
#line 475
  d->start = 0;
#line 476
  d->ndisplayed = 0;
#line 477
  d->clear = 1;
#line 478
  d->size = size;
#line 479
  ui_updatetext(d);
  }
#line 480
  return (d);
}
}
#line 483 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
void ui_drawtext(struct ui_textdata *d , int active___0 ) 
{ 
  char *c ;
  void *tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;

  {
  {
#line 485
  tmp = malloc((size_t )(d->ndisplayed + 2));
#line 485
  c = (char *)tmp;
#line 486
  strncpy((char */* __restrict  */)c, (char const   */* __restrict  */)(d->text + d->start),
          (size_t )d->ndisplayed);
#line 487
  *(c + d->ndisplayed) = (char)0;
  }
#line 488
  if ((uih->palette)->type & 3840) {
#line 488
    tmp___0 = 1;
  } else {
#line 488
    tmp___0 = 0;
  }
#line 488
  if ((uih->palette)->type & 3840) {
#line 488
    tmp___2 = *((uih->palette)->index + 0);
  } else {
#line 488
    if (active___0) {
#line 488
      if (d->clear) {
#line 488
        tmp___1 = *((uih->palette)->index + 2);
      } else {
#line 488
        tmp___1 = *((uih->palette)->index + 1);
      }
    } else {
#line 488
      tmp___1 = *((uih->palette)->index + 1);
    }
#line 488
    tmp___2 = tmp___1;
  }
  {
#line 488
  xprint(uih->image, uih->font, d->x, d->y, (char const   *)c, uih->encoding, (int )tmp___2,
         (int )*((uih->palette)->index + 0), tmp___0);
  }
#line 495
  if (active___0) {
#line 496
    if ((uih->palette)->type & 3840) {
#line 496
      tmp___3 = *((uih->palette)->index + 0);
    } else {
#line 496
      tmp___3 = *((uih->palette)->index + 2);
    }
    {
#line 496
    xdrawcursor(uih->image, d->x + d->cursorpos, d->y, (int )tmp___3, (int )((uih->font)->height + 1));
    }
  }
  {
#line 501
  free((void *)c);
  }
#line 502
  return;
}
}
#line 504 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
void ui_textmouse(struct ui_textdata *d , int x , int y ) 
{ 
  int w ;
  int i ;
  int xp ;

  {
#line 506
  if (y > d->y) {
#line 506
    if (y < d->y + (int )((uih->font)->height + 1)) {
#line 506
      if (x > d->x) {
#line 507
        w = 0;
#line 509
        xp = d->x;
#line 510
        i = 0;
        {
#line 510
        while (1) {
          while_continue: /* CIL Label */ ;
#line 510
          if (i < d->ndisplayed + 1) {
#line 510
            if (! (xp - w / 2 < x)) {
#line 510
              goto while_break;
            }
          } else {
#line 510
            goto while_break;
          }
#line 511
          w = (int )(uih->font)->width;
#line 512
          xp += w;
#line 510
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 514
        d->cursor = (i + d->start) - 1;
#line 515
        if (d->cursor < 0) {
#line 516
          d->cursor = 0;
        }
        {
#line 517
        d->clear = 0;
#line 518
        ui_updatetext(d);
#line 519
        uih->display = 1;
        }
      }
    }
  }
#line 521
  return;
}
}
#line 523 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
void ui_closetext(struct ui_textdata *d ) 
{ 


  {
  {
#line 525
  free((void *)d->text);
#line 526
  free((void *)d);
  }
#line 527
  return;
}
}
#line 529 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
int ui_textkey(struct ui_textdata *d , int key ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  int len ;
  int i ;
  size_t tmp___1 ;
  int i___0 ;
  int len___0 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 532
  if (key == 259) {
#line 532
    goto case_259;
  }
#line 542
  if (key == 260) {
#line 542
    goto case_260;
  }
#line 552
  if (key == 262) {
#line 552
    goto case_262;
  }
#line 559
  if (key == 263) {
#line 559
    goto case_263;
  }
#line 566
  if (key == 8) {
#line 566
    goto case_8;
  }
#line 531
  goto switch_break;
  case_259: /* CIL Label */ 
#line 533
  if (d->clear) {
#line 534
    d->clear = 0;
  }
#line 535
  if (d->cursor) {
#line 536
    (d->cursor) --;
  } else {
#line 538
    return (0);
  }
  {
#line 539
  ui_updatetext(d);
#line 540
  uih->display = 1;
  }
#line 541
  return (1);
  case_260: /* CIL Label */ 
#line 543
  if (d->clear) {
#line 544
    d->clear = 0;
  }
  {
#line 545
  tmp = strlen((char const   *)d->text);
  }
#line 545
  if (d->cursor < (int )tmp) {
#line 546
    (d->cursor) ++;
  } else {
#line 548
    return (0);
  }
  {
#line 549
  ui_updatetext(d);
#line 550
  uih->display = 1;
  }
#line 551
  return (1);
  case_262: /* CIL Label */ 
#line 553
  if (d->clear) {
#line 554
    d->clear = 0;
  }
  {
#line 555
  d->cursor = 0;
#line 556
  ui_updatetext(d);
#line 557
  uih->display = 1;
  }
#line 558
  return (1);
  case_263: /* CIL Label */ 
#line 560
  if (d->clear) {
#line 561
    d->clear = 0;
  }
  {
#line 562
  tmp___0 = strlen((char const   *)d->text);
#line 562
  d->cursor = (int )tmp___0;
#line 563
  ui_updatetext(d);
#line 564
  uih->display = 1;
  }
#line 565
  return (1);
  case_8: /* CIL Label */ 
#line 567
  if (d->clear) {
#line 568
    *(d->text + 0) = (char)0;
#line 568
    d->clear = 0;
  } else
#line 569
  if (d->cursor) {
    {
#line 571
    tmp___1 = strlen((char const   *)d->text);
#line 571
    len = (int )tmp___1;
#line 572
    i = d->cursor;
    }
    {
#line 572
    while (1) {
      while_continue: /* CIL Label */ ;
#line 572
      if (! (i <= len)) {
#line 572
        goto while_break;
      }
#line 573
      *(d->text + (i - 1)) = *(d->text + i);
#line 572
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 575
    (d->cursor) --;
  }
  {
#line 577
  ui_updatetext(d);
#line 578
  uih->display = 1;
  }
#line 579
  return (1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 581
  tmp___4 = __ctype_b_loc();
  }
#line 581
  if ((int const   )*(*tmp___4 + key) & 16384) {
#line 584
    if (d->clear) {
#line 585
      *(d->text + 0) = (char)0;
#line 585
      d->clear = 0;
    }
    {
#line 586
    tmp___3 = strlen((char const   *)d->text);
#line 586
    len___0 = (int )tmp___3;
    }
#line 586
    if (len___0 > d->size - 2) {
      {
#line 587
      tmp___2 = realloc((void *)d->text, (size_t )(d->size * 2));
#line 587
      d->text = (char *)tmp___2;
      }
    }
#line 589
    i___0 = len___0;
    {
#line 589
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 589
      if (! (i___0 >= d->cursor)) {
#line 589
        goto while_break___0;
      }
#line 590
      *(d->text + (i___0 + 1)) = *(d->text + i___0);
#line 589
      i___0 --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 592
    *(d->text + d->cursor) = (char )key;
#line 593
    (d->cursor) ++;
#line 594
    ui_updatetext(d);
#line 595
    uih->display = 1;
    }
#line 596
    return (1);
  }
#line 598
  return (0);
}
}
#line 601 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_buildstring(struct dialogitem *item , menudialog const   *entry ) 
{ 
  struct ui_textdata *tmp ;

  {
  {
#line 604
  item->height = (int )(((uih->font)->height + 1) + 4);
#line 605
  item->width = xtextwidth(uih->font, (char const   *)(item->dialog)->question);
#line 606
  item->width1 = (int )((uih->font)->width * 20);
#line 607
  tmp = ui_opentext(0, 0, 2043, (char const   *)(item->dialog)->defstr);
#line 607
  item->data = (void *)tmp;
  }
#line 608
  return;
}
}
#line 610 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_destroystring(struct dialogitem *item , dialogparam *param ) 
{ 
  struct ui_textdata *text ;

  {
  {
#line 612
  text = (struct ui_textdata *)item->data;
#line 613
  param->dstring = mystrdup((char const   *)text->text);
#line 614
  ui_closetext(text);
  }
#line 615
  return;
}
}
#line 617 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_drawquestion(struct dialogitem *item ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 619
  if ((uih->palette)->type & 3840) {
#line 620
    if (item - dialog.items == (long )dialog.current) {
      {
#line 621
      xrectangle(uih->image, dialog.x + 2, item->y, (dialog.half - dialog.x) - 4,
                 (int )(((uih->font)->height + 1) + 4), (int )*((uih->palette)->index + 1));
      }
    }
#line 624
    if (item - dialog.items == (long )dialog.current) {
#line 624
      tmp = *((uih->palette)->index + 0);
    } else {
#line 624
      tmp = *((uih->palette)->index + 1);
    }
    {
#line 624
    xprint(uih->image, uih->font, dialog.half - item->width, item->y + 2, (char const   *)(item->dialog)->question,
           uih->encoding, (int )tmp, (int )*((uih->palette)->index + 0), 1);
    }
  } else {
#line 629
    if (item - dialog.items == (long )dialog.current) {
#line 629
      tmp___0 = *((uih->palette)->index + 2);
    } else {
#line 629
      tmp___0 = *((uih->palette)->index + 1);
    }
    {
#line 629
    xprint(uih->image, uih->font, dialog.half - item->width, item->y + 2, (char const   *)(item->dialog)->question,
           uih->encoding, (int )tmp___0, (int )*((uih->palette)->index + 0), 0);
    }
  }
#line 635
  return;
}
}
#line 637 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_drawstring(struct dialogitem *item ) 
{ 
  struct ui_textdata *text ;

  {
#line 639
  text = (struct ui_textdata *)item->data;
#line 640
  if (text->width == 2043) {
    {
#line 641
    text->x = dialog.half + 2;
#line 641
    text->width = ((dialog.width + dialog.x) - dialog.half) - 4;
#line 641
    text->y = item->y + 2;
#line 641
    ui_updatetext(text);
    }
  }
  {
#line 644
  uih_drawborder(uih, dialog.half, item->y, ((dialog.width - dialog.half) + dialog.x) - 2,
                 (int )(((uih->font)->height + 1) + 4), 20);
#line 647
  ui_drawtext(text, item - dialog.items == (long )dialog.current);
#line 648
  ui_drawquestion(item);
  }
#line 649
  return;
}
}
#line 651 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static int ui_keystring(struct dialogitem *item , int key ) 
{ 
  struct ui_textdata *text ;
  int tmp ;

  {
  {
#line 653
  text = (struct ui_textdata *)item->data;
#line 654
  tmp = ui_textkey(text, key);
  }
#line 654
  return (tmp);
}
}
#line 657 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_mousestring(struct dialogitem *item , int x , int y , int buttons ,
                           int flags ) 
{ 
  struct ui_textdata *text ;

  {
#line 661
  text = (struct ui_textdata *)item->data;
#line 662
  if (flags & 4) {
    {
#line 663
    ui_textmouse(text, x, y);
    }
  }
#line 665
  return;
}
}
#line 667 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_unselectstring(struct dialogitem *item ) 
{ 


  {
#line 669
  return;
}
}
#line 671 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static struct dialogtype  const  stringdialog  =    {& ui_buildstring, & ui_keystring, & ui_mousestring, & ui_destroystring, & ui_drawstring,
    & ui_unselectstring};
#line 680 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_buildint(struct dialogitem *item , menudialog const   *entry ) 
{ 
  char s[50] ;
  struct ui_textdata *tmp ;

  {
  {
#line 683
  item->height = (int )(((uih->font)->height + 1) + 4);
#line 684
  item->width = xtextwidth(uih->font, (char const   *)(item->dialog)->question);
#line 685
  item->width1 = (int )((uih->font)->width * 5);
#line 686
  sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%i", (item->dialog)->defint);
#line 687
  tmp = ui_opentext(0, 0, 2043, (char const   *)(s));
#line 687
  item->data = (void *)tmp;
  }
#line 688
  return;
}
}
#line 690 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_destroyint(struct dialogitem *item , dialogparam *param ) 
{ 
  struct ui_textdata *text ;
  long tmp ;

  {
  {
#line 692
  text = (struct ui_textdata *)item->data;
#line 693
  tmp = atol((char const   *)text->text);
#line 693
  param->dint = (int )tmp;
#line 694
  ui_closetext(text);
  }
#line 695
  return;
}
}
#line 697 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static struct dialogtype  const  intdialog  =    {& ui_buildint, & ui_keystring, & ui_mousestring, & ui_destroyint, & ui_drawstring,
    & ui_unselectstring};
#line 706 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static char const   *ui_getextension(char const   *ch ) 
{ 
  int i ;

  {
#line 708
  i = 0;
  {
#line 709
  while (1) {
    while_continue: /* CIL Label */ ;
#line 709
    if (! *(ch + i)) {
#line 709
      goto while_break;
    }
#line 710
    if ((int const   )*(ch + i) == 42) {
#line 711
      return ((ch + i) + 1);
    }
#line 712
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 714
  return (ch + i);
}
}
#line 717 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
number_t ui_getfloat(char const   *c ) 
{ 
  long double param ;
  int tmp ;

  {
  {
#line 730
  tmp = sscanf((char const   */* __restrict  */)c, (char const   */* __restrict  */)"%LG",
               & param);
  }
#line 730
  if (tmp == 0) {
#line 740
    return ((number_t )0);
  }
#line 742
  return (param);
}
}
#line 752 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static struct dialogitem *curritem  ;
#line 753 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void filecallback(char const   *name___0 , int succ ) 
{ 
  struct ui_filedata *text ;

  {
#line 755
  text = (struct ui_filedata *)curritem->data;
#line 756
  if (succ) {
    {
#line 757
    ui_closetext(text->text);
#line 758
    uih->display = 1;
#line 759
    text->text = ui_opentext(0, 0, 2043, name___0);
#line 760
    dialog.mousereleased = 0;
    }
  }
#line 762
  if (dialog.nitems == 2) {
    {
#line 763
    ui_closedialog(succ);
    }
  }
#line 764
  return;
}
}
#line 766 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_buildfile(struct dialogitem *item , menudialog const   *entry ) 
{ 
  char str___0[256] ;
  struct ui_filedata *data ;
  void *tmp ;
  int i ;
  char const   *tmp___0 ;
  xio_path tmp___1 ;

  {
  {
#line 769
  tmp = malloc(sizeof(*data));
#line 769
  data = (struct ui_filedata *)tmp;
#line 771
  i = 0;
#line 772
  item->height = (int )(((uih->font)->height + 1) + 4);
#line 773
  item->width = xtextwidth(uih->font, (char const   *)(item->dialog)->question);
#line 774
  item->width1 = (int )((uih->font)->width * 20);
  }
  {
#line 775
  while (1) {
    while_continue: /* CIL Label */ ;
#line 775
    if ((int const   )*((item->dialog)->defstr + i) != 42) {
#line 775
      if (! ((int const   )*((item->dialog)->defstr + i) != 0)) {
#line 775
        goto while_break;
      }
    } else {
#line 775
      goto while_break;
    }
#line 776
    str___0[i] = (char )*((item->dialog)->defstr + i);
#line 776
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 777
  str___0[i] = (char)0;
#line 778
  item->data = (void *)data;
#line 779
  if (entry->type == 6) {
    {
#line 780
    tmp___0 = ui_getextension((char const   *)(item->dialog)->defstr);
#line 780
    tmp___1 = ui_getfile((char const   *)(str___0), tmp___0);
#line 780
    data->text = ui_opentext(0, 0, 2043, (char const   *)tmp___1);
    }
  } else {
    {
#line 785
    data->text = ui_opentext(0, 0, 2043, (char const   *)(item->dialog)->defstr);
    }
  }
#line 786
  data->active = 0;
#line 787
  data->pressed = 0;
#line 789
  if (dialog.nitems == 2) {
    {
#line 790
    curritem = item;
#line 791
    ui_buildfilesel((char const   *)(data->text)->text, "", & filecallback);
    }
  }
#line 794
  return;
}
}
#line 796 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_destroyfile(struct dialogitem *item , dialogparam *param ) 
{ 
  struct ui_filedata *text ;

  {
#line 798
  text = (struct ui_filedata *)item->data;
#line 800
  if (filevisible) {
    {
#line 801
    ui_closefilesel(0);
    }
  }
  {
#line 803
  param->dpath = mystrdup((char const   *)(text->text)->text);
#line 804
  ui_closetext(text->text);
#line 805
  free((void *)text);
  }
#line 806
  return;
}
}
#line 808 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_drawfile(struct dialogitem *item ) 
{ 
  struct ui_filedata *data ;
  int wholesize ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 810
  data = (struct ui_filedata *)item->data;
#line 811
  wholesize = ((dialog.width + dialog.x) - dialog.half) - 4;
#line 813
  if ((data->text)->width == 2043) {
    {
#line 814
    (data->text)->x = dialog.half + 2;
#line 814
    (data->text)->width = (wholesize - (int )(((uih->font)->height + 1) + 4)) - 4;
#line 814
    (data->text)->y = item->y + 2;
#line 817
    ui_updatetext(data->text);
    }
  }
  {
#line 819
  uih_drawborder(uih, dialog.half, item->y, wholesize - (int )(((uih->font)->height + 1) + 4),
                 (int )(((uih->font)->height + 1) + 4), 20);
  }
#line 821
  if (item - dialog.items == (long )dialog.current) {
#line 821
    if (! data->active) {
#line 821
      tmp = 1;
    } else {
#line 821
      tmp = 0;
    }
  } else {
#line 821
    tmp = 0;
  }
  {
#line 821
  ui_drawtext(data->text, tmp);
  }
#line 822
  if (item - dialog.items == (long )dialog.current) {
#line 822
    tmp___0 = *((uih->palette)->index + 2);
  } else {
#line 822
    tmp___0 = *((uih->palette)->index + 1);
  }
  {
#line 822
  xprint(uih->image, uih->font, dialog.half - item->width, item->y + 2, (char const   *)(item->dialog)->question,
         uih->encoding, (int )tmp___0, (int )*((uih->palette)->index + 0), 0);
#line 825
  ui_drawquestion(item);
  }
#line 826
  if (item - dialog.items == (long )dialog.current) {
#line 826
    if (data->active) {
#line 826
      tmp___1 = 1;
    } else {
#line 826
      tmp___1 = 0;
    }
  } else {
#line 826
    tmp___1 = 0;
  }
#line 826
  if (data->pressed) {
#line 826
    if (item - dialog.items == (long )dialog.current) {
#line 826
      tmp___2 = 1;
    } else {
#line 826
      tmp___2 = 0;
    }
  } else {
#line 826
    tmp___2 = 0;
  }
  {
#line 826
  ui_drawbutton("B", tmp___2, tmp___1, ((dialog.x + dialog.width) - (int )(((uih->font)->height + 1) + 4)) - 2,
                (dialog.x + dialog.width) - 2, item->y);
  }
#line 830
  return;
}
}
#line 832 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static int ui_keyfile(struct dialogitem *item , int key ) 
{ 
  struct ui_filedata *text ;
  int i ;

  {
#line 834
  text = (struct ui_filedata *)item->data;
#line 835
  i = 0;
#line 836
  if (! text->active) {
    {
#line 837
    i = ui_textkey(text->text, key);
    }
  }
#line 838
  if (! i) {
#line 839
    if (key == 9) {
#line 839
      goto _L;
    } else
#line 839
    if (key == 260) {
      _L: /* CIL Label */ 
#line 840
      (text->active) ++;
#line 841
      if (text->active > 1) {
#line 842
        text->active = 0;
#line 843
        return (0);
      }
#line 845
      uih->display = 1;
#line 846
      return (1);
    }
#line 848
    if (key == 259) {
#line 849
      (text->active) --;
#line 850
      if (text->active < 0) {
#line 851
        text->active = 1;
#line 852
        return (0);
      }
#line 854
      return (1);
    }
#line 857
    if (key == 13) {
#line 857
      goto _L___0;
    } else
#line 857
    if (key == 10) {
      _L___0: /* CIL Label */ 
#line 857
      if (text->active) {
        {
#line 858
        curritem = item;
#line 859
        ui_buildfilesel((char const   *)(text->text)->text, "", & filecallback);
        }
#line 860
        return (1);
      }
    }
  }
#line 864
  return (i);
}
}
#line 867 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_mousefile(struct dialogitem *item , int x , int y , int buttons , int flags ) 
{ 
  struct ui_filedata *text ;
  int i ;

  {
#line 870
  text = (struct ui_filedata *)item->data;
#line 872
  if (flags & 8) {
#line 873
    if (x < ((dialog.x + dialog.width) - 2) - (int )(((uih->font)->height + 1) + 4)) {
#line 874
      i = 0;
    } else {
#line 876
      i = 1;
    }
#line 877
    if (text->active != i) {
#line 878
      text->active = i;
#line 878
      uih->display = 1;
    }
  }
#line 881
  if (flags & 2) {
#line 881
    if (text->pressed) {
      {
#line 882
      text->pressed = 0;
#line 883
      uih->display = 1;
#line 884
      curritem = item;
#line 885
      ui_buildfilesel((char const   *)(text->text)->text, "", & filecallback);
      }
#line 886
      return;
    }
  }
#line 889
  if (flags & 4) {
#line 890
    if (x < ((dialog.x + dialog.width) - 2) - (int )(((uih->font)->height + 1) + 4)) {
      {
#line 891
      text->active = 0;
#line 891
      ui_textmouse(text->text, x, y);
      }
#line 892
      if (text->pressed) {
#line 893
        text->pressed = 0;
#line 893
        uih->display = 1;
      }
    } else
#line 894
    if (! text->pressed) {
#line 895
      text->pressed = 1;
#line 896
      uih->display = 1;
    }
  }
#line 899
  return;
}
}
#line 901 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_unselectfile(struct dialogitem *item ) 
{ 
  struct ui_filedata *text ;

  {
#line 903
  text = (struct ui_filedata *)item->data;
#line 904
  if (text->active) {
#line 905
    text->active = 0;
#line 905
    uih->display = 1;
  }
#line 906
  if (text->pressed) {
#line 907
    text->pressed = 0;
#line 907
    uih->display = 1;
  }
#line 908
  return;
}
}
#line 910 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static struct dialogtype  const  filedialog  =    {& ui_buildfile, & ui_keyfile, & ui_mousefile, & ui_destroyfile, & ui_drawfile,
    & ui_unselectfile};
#line 919 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_buildfloat(struct dialogitem *item , menudialog const   *entry ) 
{ 
  char s[50] ;
  struct ui_textdata *tmp ;

  {
  {
#line 923
  item->height = (int )(((uih->font)->height + 1) + 4);
#line 924
  item->width = xtextwidth(uih->font, (char const   *)(item->dialog)->question);
#line 925
  item->width1 = (int )((uih->font)->width * 10);
#line 926
  sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%g", (double )(item->dialog)->deffloat);
#line 927
  tmp = ui_opentext(0, 0, 2043, (char const   *)(s));
#line 927
  item->data = (void *)tmp;
  }
#line 928
  return;
}
}
#line 930 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_destroyfloat(struct dialogitem *item , dialogparam *param ) 
{ 
  struct ui_textdata *text ;

  {
  {
#line 932
  text = (struct ui_textdata *)item->data;
#line 933
  param->number = ui_getfloat((char const   *)text->text);
#line 934
  ui_closetext(text);
  }
#line 935
  return;
}
}
#line 937 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static struct dialogtype  const  floatdialog  =    {& ui_buildfloat, & ui_keystring, & ui_mousestring, & ui_destroyfloat, & ui_drawstring,
    & ui_unselectstring};
#line 950 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_buildcoord(struct dialogitem *item , menudialog const   *entry ) 
{ 
  char s[50] ;
  struct ui_coorddata *data ;
  void *tmp ;

  {
  {
#line 954
  tmp = malloc(sizeof(*data));
#line 954
  data = (struct ui_coorddata *)tmp;
#line 956
  item->height = (int )(((uih->font)->height + 1) + 4);
#line 957
  item->width = xtextwidth(uih->font, (char const   *)(item->dialog)->question);
#line 958
  item->width1 = (int )((uih->font)->width * 20);
#line 959
  item->data = (void *)data;
#line 960
  data->active = 0;
#line 961
  sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%g", (double )(item->dialog)->deffloat);
#line 962
  data->text[0] = ui_opentext(0, 0, 2043, (char const   *)(s));
#line 963
  sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%g", (double )(item->dialog)->deffloat2);
#line 964
  data->text[1] = ui_opentext(0, 0, 2043, (char const   *)(s));
  }
#line 965
  return;
}
}
#line 967 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_destroycoord(struct dialogitem *item , dialogparam *param ) 
{ 
  struct ui_coorddata *data ;

  {
  {
#line 969
  data = (struct ui_coorddata *)item->data;
#line 970
  param->dcoord[0] = ui_getfloat((char const   *)(data->text[0])->text);
#line 971
  param->dcoord[1] = ui_getfloat((char const   *)(data->text[1])->text);
#line 972
  ui_closetext(data->text[0]);
#line 973
  ui_closetext(data->text[1]);
#line 974
  free((void *)data);
  }
#line 975
  return;
}
}
#line 979 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_drawcoord(struct dialogitem *item ) 
{ 
  struct ui_coorddata *data ;
  int wholesize ;
  int tmp ;
  int half ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 981
  data = (struct ui_coorddata *)item->data;
#line 982
  tmp = xtextwidth(uih->font, "i");
#line 982
  wholesize = (((dialog.width + dialog.x) - dialog.half) - 4) - tmp;
#line 984
  tmp___0 = xtextwidth(uih->font, "+");
#line 984
  half = (wholesize - tmp___0) / 2;
  }
#line 985
  if ((data->text[0])->width == 2043) {
    {
#line 986
    (data->text[0])->x = dialog.half + 2;
#line 986
    (data->text[0])->width = half - 2;
#line 986
    (data->text[0])->y = item->y + 2;
#line 989
    tmp___1 = xtextwidth(uih->font, "+");
#line 989
    (data->text[1])->x = ((dialog.half + half) + tmp___1) + 2;
#line 989
    (data->text[1])->width = half - 2;
#line 989
    (data->text[1])->y = item->y + 2;
#line 992
    ui_updatetext(data->text[0]);
#line 993
    ui_updatetext(data->text[1]);
    }
  }
  {
#line 995
  uih_drawborder(uih, dialog.half, item->y, half, (int )(((uih->font)->height + 1) + 4),
                 20);
#line 997
  tmp___2 = xtextwidth(uih->font, "+");
#line 997
  uih_drawborder(uih, (dialog.half + half) + tmp___2, item->y, half, (int )(((uih->font)->height + 1) + 4),
                 20);
  }
#line 999
  if (item - dialog.items == (long )dialog.current) {
#line 999
    if (! data->active) {
#line 999
      tmp___3 = 1;
    } else {
#line 999
      tmp___3 = 0;
    }
  } else {
#line 999
    tmp___3 = 0;
  }
  {
#line 999
  ui_drawtext(data->text[0], tmp___3);
  }
#line 1000
  if (item - dialog.items == (long )dialog.current) {
#line 1000
    if (data->active) {
#line 1000
      tmp___4 = 1;
    } else {
#line 1000
      tmp___4 = 0;
    }
  } else {
#line 1000
    tmp___4 = 0;
  }
  {
#line 1000
  ui_drawtext(data->text[1], tmp___4);
#line 1001
  xprint(uih->image, uih->font, dialog.half + half, item->y + 2, "+", uih->encoding,
         (int )*((uih->palette)->index + 1), (int )*((uih->palette)->index + 0), 0);
#line 1004
  tmp___5 = xtextwidth(uih->font, "i");
#line 1004
  xprint(uih->image, uih->font, ((dialog.x + dialog.width) - 2) - tmp___5, item->y + 2,
         "i", uih->encoding, (int )*((uih->palette)->index + 1), (int )*((uih->palette)->index + 0),
         0);
#line 1008
  ui_drawquestion(item);
  }
#line 1009
  return;
}
}
#line 1011 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static int ui_keycoord(struct dialogitem *item , int key ) 
{ 
  struct ui_coorddata *text ;
  int i ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 1013
  text = (struct ui_coorddata *)item->data;
#line 1014
  tmp = ui_textkey(text->text[text->active], key);
#line 1014
  i = tmp;
  }
#line 1015
  if (! i) {
#line 1016
    if (key == 9) {
#line 1016
      goto _L;
    } else
#line 1016
    if (key == 260) {
      _L: /* CIL Label */ 
#line 1017
      (text->active) ++;
#line 1018
      if (text->active > 1) {
#line 1019
        text->active = 0;
#line 1020
        return (0);
      }
#line 1022
      uih->display = 1;
#line 1023
      if (key == 260) {
        {
#line 1024
        (text->text[1])->cursor = 0;
#line 1025
        ui_updatetext(text->text[1]);
#line 1026
        uih->display = 1;
        }
      }
#line 1028
      return (1);
    }
#line 1030
    if (key == 259) {
#line 1031
      (text->active) --;
#line 1032
      if (text->active < 0) {
#line 1033
        text->active = 1;
#line 1034
        return (0);
      }
      {
#line 1036
      tmp___0 = strlen((char const   *)(text->text[0])->text);
#line 1036
      (text->text[0])->cursor = (int )tmp___0;
#line 1037
      ui_updatetext(text->text[0]);
#line 1038
      uih->display = 1;
      }
#line 1039
      return (1);
    }
  }
#line 1042
  return (i);
}
}
#line 1045 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_mousecoord(struct dialogitem *item , int x , int y , int buttons ,
                          int flags ) 
{ 
  struct ui_coorddata *text ;
  int i ;

  {
#line 1049
  text = (struct ui_coorddata *)item->data;
#line 1051
  if (flags & 8) {
#line 1052
    if (x < (text->text[1])->x) {
#line 1053
      i = 0;
    } else {
#line 1055
      i = 1;
    }
#line 1056
    if (text->active != i) {
#line 1057
      text->active = i;
#line 1057
      uih->display = 1;
    }
  }
#line 1059
  if (flags & 4) {
#line 1060
    if (x < (text->text[1])->x) {
      {
#line 1061
      text->active = 0;
#line 1061
      ui_textmouse(text->text[0], x, y);
      }
    } else {
      {
#line 1063
      text->active = 1;
#line 1063
      ui_textmouse(text->text[1], x, y);
      }
    }
  }
#line 1065
  return;
}
}
#line 1067 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_unselectcoord(struct dialogitem *item ) 
{ 
  struct ui_coorddata *text ;

  {
#line 1069
  text = (struct ui_coorddata *)item->data;
#line 1070
  text->active = 0;
#line 1071
  return;
}
}
#line 1073 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static struct dialogtype  const  coorddialog  =    {& ui_buildcoord, & ui_keycoord, & ui_mousecoord, & ui_destroycoord, & ui_drawcoord,
    & ui_unselectcoord};
#line 1091 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_choicemenupos(struct uih_context *uih___2 , int *x , int *y , int *width ,
                             int *height , void *data ) 
{ 
  struct ui_choicedata *choice ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1095
  choice = (struct ui_choicedata *)data;
#line 1096
  if (filevisible) {
#line 1096
    goto _L;
  } else
#line 1096
  if (helpvisible) {
    _L: /* CIL Label */ 
#line 1097
    tmp___1 = 0;
#line 1097
    *height = tmp___1;
#line 1097
    tmp___0 = tmp___1;
#line 1097
    *width = tmp___0;
#line 1097
    tmp = tmp___0;
#line 1097
    *y = tmp;
#line 1097
    *x = tmp;
#line 1098
    return;
  }
#line 1100
  *x = choice->x;
#line 1101
  *y = choice->y;
#line 1102
  *width = choice->width;
#line 1103
  *height = choice->height;
#line 1104
  return;
}
}
#line 1106 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_drawchoicemenu(uih_context *uih___2 , void *data ) 
{ 
  struct ui_choicedata *choice ;
  int i ;
  unsigned int tmp ;

  {
#line 1108
  choice = (struct ui_choicedata *)data;
#line 1110
  i = 0;
  {
#line 1110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1110
    if (! (i < choice->n)) {
#line 1110
      goto while_break;
    }
#line 1111
    if (i == choice->active) {
#line 1111
      tmp = *((uih___2->palette)->index + 2);
    } else {
#line 1111
      tmp = *((uih___2->palette)->index + 1);
    }
    {
#line 1111
    xprint(uih___2->image, uih___2->font, choice->x + 2, (choice->y + 2) + i * (int )((uih___2->font)->height + 1),
           *(choice->texts + i), uih___2->encoding, (int )tmp, (int )*((uih___2->palette)->index + 0),
           0);
#line 1110
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1117
  return;
}
}
#line 1119 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_buildchoicemenu(struct uih_context *uih___2 , struct ui_choicedata *choice ,
                               int x , int y , int width ) 
{ 


  {
#line 1123
  if ((unsigned long )choice->menu != (unsigned long )((void *)0)) {
#line 1124
    return;
  }
#line 1125
  choice->width = width + 4;
#line 1126
  choice->x = x;
#line 1127
  choice->height = (int )(((uih___2->font)->height + 1) * (int const   )choice->n + 4);
#line 1128
  choice->active = choice->selected;
#line 1129
  choice->y = y - choice->active * (int )((uih___2->font)->height + 1);
#line 1130
  dialog.mousegrab = 1;
#line 1131
  if (choice->x + choice->width > (uih___2->image)->width) {
#line 1132
    choice->x = (uih___2->image)->width - choice->width;
  }
#line 1133
  if (choice->y + choice->height > (uih___2->image)->height) {
#line 1134
    choice->y = (uih___2->image)->height - choice->height;
  }
#line 1135
  if (choice->x < 0) {
#line 1136
    choice->x = 0;
  }
#line 1137
  if (choice->y < 0) {
#line 1138
    choice->y = 0;
  }
  {
#line 1139
  choice->menu = uih_registerw(uih___2, & ui_choicemenupos, & ui_drawchoicemenu, (void *)choice,
                               2);
#line 1142
  uih___2->display = 1;
  }
#line 1143
  return;
}
}
#line 1145 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_closechoicemenu(struct uih_context *uih___2 , struct ui_choicedata *choice ) 
{ 


  {
#line 1148
  if ((unsigned long )choice->menu == (unsigned long )((void *)0)) {
#line 1149
    return;
  }
  {
#line 1150
  uih_removew(uih___2, choice->menu);
#line 1151
  choice->menu = (struct uih_window *)((void *)0);
#line 1152
  uih___2->display = 1;
#line 1153
  dialog.mousegrab = 0;
#line 1154
  dialog.mousereleased = 0;
  }
#line 1155
  return;
}
}
#line 1157 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_buildchoice(struct dialogitem *item , menudialog const   *entry ) 
{ 
  int i ;
  struct ui_choicedata *data ;
  void *tmp ;
  int w ;
  int tmp___0 ;

  {
  {
#line 1161
  tmp = malloc(sizeof(*data));
#line 1161
  data = (struct ui_choicedata *)tmp;
#line 1163
  item->height = (int )(((uih->font)->height + 1) + 4);
#line 1164
  item->width = xtextwidth(uih->font, (char const   *)(item->dialog)->question);
#line 1165
  item->width1 = 0;
#line 1166
  data->menu = (struct uih_window *)((void *)0);
#line 1168
  data->texts = (char const   **)entry->defstr;
#line 1169
  i = 0;
  }
  {
#line 1169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1169
    if (! ((unsigned long )*(data->texts + i) != (unsigned long )((void *)0))) {
#line 1169
      goto while_break;
    }
    {
#line 1170
    tmp___0 = xtextwidth(uih->font, *(data->texts + i));
#line 1170
    w = tmp___0;
    }
#line 1171
    if (w > item->width1) {
#line 1172
      item->width1 = w;
    }
#line 1169
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1174
  item->width1 += 4;
#line 1175
  data->n = i;
#line 1176
  data->selected = (int )entry->defint;
#line 1177
  item->data = (void *)data;
#line 1178
  return;
}
}
#line 1180 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_destroychoice(struct dialogitem *item , dialogparam *param ) 
{ 
  struct ui_choicedata *data ;

  {
  {
#line 1182
  data = (struct ui_choicedata *)item->data;
#line 1183
  param->dint = data->selected;
#line 1184
  ui_closechoicemenu(uih, data);
#line 1185
  free((void *)data);
  }
#line 1186
  return;
}
}
#line 1188 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_drawchoice(struct dialogitem *item ) 
{ 
  struct ui_choicedata *data ;
  unsigned int tmp ;

  {
  {
#line 1190
  data = (struct ui_choicedata *)item->data;
#line 1191
  uih_drawborder(uih, dialog.half, item->y, item->width1, (int )((((uih->font)->height + 1) + 4) | 16),
                 0);
  }
#line 1193
  if (item - dialog.items == (long )dialog.current) {
#line 1193
    tmp = *((uih->palette)->index + 2);
  } else {
#line 1193
    tmp = *((uih->palette)->index + 1);
  }
  {
#line 1193
  xprint(uih->image, uih->font, dialog.half + 2, item->y + 2, *(data->texts + data->selected),
         uih->encoding, (int )tmp, (int )*((uih->palette)->index + 0), 0);
#line 1197
  ui_drawquestion(item);
  }
#line 1198
  return;
}
}
#line 1200 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static int ui_keychoice(struct dialogitem *item , int key ) 
{ 
  struct ui_choicedata *data ;

  {
#line 1202
  data = (struct ui_choicedata *)item->data;
#line 1203
  if (! data->menu) {
    {
#line 1210
    if (key == 260) {
#line 1210
      goto case_260;
    }
#line 1210
    if (key == 258) {
#line 1210
      goto case_260;
    }
#line 1210
    if (key == 257) {
#line 1210
      goto case_260;
    }
#line 1210
    if (key == 13) {
#line 1210
      goto case_260;
    }
#line 1210
    if (key == 10) {
#line 1210
      goto case_260;
    }
#line 1210
    if (key == 32) {
#line 1210
      goto case_260;
    }
#line 1204
    goto switch_break;
    case_260: /* CIL Label */ 
    case_258: /* CIL Label */ 
    case_257: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_32: /* CIL Label */ 
    {
#line 1211
    ui_buildchoicemenu(uih, data, dialog.half, item->y, item->width1);
    }
#line 1213
    return (1);
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1219
    if (key == 10) {
#line 1219
      goto case_10___0;
    }
#line 1219
    if (key == 13) {
#line 1219
      goto case_10___0;
    }
#line 1219
    if (key == 32) {
#line 1219
      goto case_10___0;
    }
#line 1223
    if (key == 258) {
#line 1223
      goto case_258___0;
    }
#line 1228
    if (key == 257) {
#line 1228
      goto case_257___0;
    }
#line 1234
    if (key == 261) {
#line 1234
      goto case_261;
    }
#line 1216
    goto switch_break___0;
    case_10___0: /* CIL Label */ 
    case_13___0: /* CIL Label */ 
    case_32___0: /* CIL Label */ 
    {
#line 1220
    data->selected = data->active;
#line 1221
    ui_closechoicemenu(uih, data);
    }
#line 1222
    return (1);
    case_258___0: /* CIL Label */ 
#line 1224
    (data->active) ++;
#line 1225
    data->active %= data->n;
#line 1226
    uih->display = 1;
#line 1227
    return (1);
    case_257___0: /* CIL Label */ 
#line 1229
    (data->active) --;
#line 1230
    if (data->active < 0) {
#line 1231
      data->active = data->n - 1;
    }
#line 1232
    uih->display = 1;
#line 1233
    return (1);
    case_261: /* CIL Label */ 
    {
#line 1235
    ui_closechoicemenu(uih, data);
    }
#line 1236
    return (1);
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 1239
  return (0);
}
}
#line 1242 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_mousechoice(struct dialogitem *item , int x , int y , int buttons ,
                           int flags ) 
{ 
  struct ui_choicedata *data ;
  int in ;

  {
#line 1246
  data = (struct ui_choicedata *)item->data;
#line 1248
  if ((unsigned long )data->menu != (unsigned long )((void *)0)) {
#line 1249
    in = 0;
#line 1250
    if (x > data->x) {
#line 1250
      if (y > data->y) {
#line 1250
        if (x < data->x + data->width) {
#line 1250
          if (y < data->y + data->height) {
#line 1252
            in = 1;
          }
        }
      }
    }
#line 1253
    if (flags & 1) {
#line 1253
      if (! in) {
        {
#line 1254
        ui_closechoicemenu(uih, data);
        }
#line 1255
        return;
      }
    }
#line 1257
    if (flags & 8) {
#line 1257
      if (in) {
#line 1258
        in = (y - data->y) / (int )((uih->font)->height + 1);
#line 1259
        if (in < 0) {
#line 1260
          in = 0;
        }
#line 1261
        if (in >= data->n) {
#line 1262
          in = data->n - 1;
        }
#line 1263
        if (data->active != in) {
#line 1264
          data->active = in;
#line 1264
          uih->display = 1;
        }
      }
    }
#line 1266
    if (flags & 2) {
      {
#line 1267
      data->selected = data->active;
#line 1268
      ui_closechoicemenu(uih, data);
      }
#line 1269
      return;
    }
  } else
#line 1272
  if (flags & 1) {
#line 1272
    if (x > dialog.half) {
      {
#line 1273
      ui_buildchoicemenu(uih, data, dialog.half, item->y, item->width1);
      }
    }
  }
#line 1276
  return;
}
}
#line 1278 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_unselectchoice(struct dialogitem *item ) 
{ 
  struct ui_choicedata *data ;

  {
  {
#line 1280
  data = (struct ui_choicedata *)item->data;
#line 1281
  ui_closechoicemenu(uih, data);
  }
#line 1282
  return;
}
}
#line 1284 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static struct dialogtype  const  choicedialog  =    {& ui_buildchoice, & ui_keychoice, & ui_mousechoice, & ui_destroychoice, & ui_drawchoice,
    & ui_unselectchoice};
#line 1293 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_dialogpos(struct uih_context *c , int *x , int *y , int *width , int *height ,
                         void *data ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1297
  *x = dialog.x;
#line 1298
  *y = dialog.y;
#line 1299
  if (filevisible) {
#line 1299
    goto _L;
  } else
#line 1299
  if (helpvisible) {
    _L: /* CIL Label */ 
#line 1300
    tmp___1 = 0;
#line 1300
    *height = tmp___1;
#line 1300
    tmp___0 = tmp___1;
#line 1300
    *width = tmp___0;
#line 1300
    tmp = tmp___0;
#line 1300
    *y = tmp;
#line 1300
    *x = tmp;
#line 1301
    return;
  }
#line 1303
  *width = dialog.width;
#line 1304
  *height = dialog.height;
#line 1305
  return;
}
}
#line 1307 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_dialogdraw(struct uih_context *c , void *data ) 
{ 
  int n ;

  {
#line 1310
  n = 0;
  {
#line 1310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1310
    if (! (n < dialog.nitems)) {
#line 1310
      goto while_break;
    }
    {
#line 1311
    (*(((dialog.items + n)->type)->draw))(dialog.items + n);
#line 1310
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1312
  return;
}
}
#line 1315 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
void ui_builddialog(menuitem const   *item ) 
{ 
  int n ;
  int ypos ;
  int width1 ;
  menudialog const   *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 1317
  n = 2;
#line 1319
  width1 = 0;
#line 1320
  if (ui_nogui) {
    {
#line 1321
    printf((char const   */* __restrict  */)"dialog \"%s\"\n", item->shortname);
    }
#line 1322
    return;
  }
#line 1324
  if (driver->gui_driver) {
#line 1324
    if ((driver->gui_driver)->dialog) {
      {
#line 1325
      (*((driver->gui_driver)->dialog))(uih, (char const   *)item->shortname);
      }
#line 1326
      return;
    }
  }
#line 1328
  dialogvisible = 1;
#line 1329
  dialog.width = 0;
#line 1330
  dialog.height = 0;
#line 1331
  if (item->type == 6) {
#line 1331
    dialog.dialog = (menudialog const   *)item->pparam;
  } else {
    {
#line 1331
    tmp = (*(item->dialog))(uih);
#line 1331
    dialog.dialog = tmp;
    }
  }
#line 1332
  dialog.item = item;
#line 1333
  n = 0;
  {
#line 1333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1333
    if (! ((unsigned long )(dialog.dialog + n)->question != (unsigned long )((void *)0))) {
#line 1333
      goto while_break;
    }
#line 1333
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1334
  n ++;
#line 1335
  dialog.nitems = n;
#line 1336
  tmp___0 = malloc(sizeof(struct dialogitem ) * (unsigned long )dialog.nitems);
#line 1336
  dialog.items = (struct dialogitem *)tmp___0;
#line 1339
  dialog.mousereleased = 0;
#line 1340
  (dialog.items + (dialog.nitems - 1))->type = & okdialog;
#line 1341
  n = 0;
  }
  {
#line 1341
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1341
    if (! (n < dialog.nitems)) {
#line 1341
      goto while_break___0;
    }
#line 1342
    if (n < dialog.nitems - 1) {
      {
#line 1345
      if ((dialog.dialog + n)->type == 4) {
#line 1345
        goto case_4;
      }
#line 1345
      if ((dialog.dialog + n)->type == 3) {
#line 1345
        goto case_4;
      }
#line 1348
      if ((dialog.dialog + n)->type == 1) {
#line 1348
        goto case_1;
      }
#line 1352
      if ((dialog.dialog + n)->type == 6) {
#line 1352
        goto case_6;
      }
#line 1352
      if ((dialog.dialog + n)->type == 5) {
#line 1352
        goto case_6;
      }
#line 1355
      if ((dialog.dialog + n)->type == 2) {
#line 1355
        goto case_2;
      }
#line 1358
      if ((dialog.dialog + n)->type == 9) {
#line 1358
        goto case_9;
      }
#line 1361
      if ((dialog.dialog + n)->type == 7) {
#line 1361
        goto case_7;
      }
#line 1364
      goto switch_default;
      case_4: /* CIL Label */ 
      case_3: /* CIL Label */ 
#line 1346
      (dialog.items + n)->type = & stringdialog;
#line 1347
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1349
      (dialog.items + n)->type = & intdialog;
#line 1350
      goto switch_break;
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
#line 1353
      (dialog.items + n)->type = & filedialog;
#line 1354
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1356
      (dialog.items + n)->type = & floatdialog;
#line 1357
      goto switch_break;
      case_9: /* CIL Label */ 
#line 1359
      (dialog.items + n)->type = & coorddialog;
#line 1360
      goto switch_break;
      case_7: /* CIL Label */ 
#line 1362
      (dialog.items + n)->type = & choicedialog;
#line 1363
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1365
      printf((char const   */* __restrict  */)"uidialog:unknown type!\n");
#line 1366
      exit(1);
      }
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 1369
    (dialog.items + n)->dialog = dialog.dialog + n;
#line 1370
    (*(((dialog.items + n)->type)->build))(dialog.items + n, dialog.dialog + n);
#line 1371
    dialog.height += (dialog.items + n)->height;
    }
#line 1372
    if (width1 < (dialog.items + n)->width1) {
#line 1373
      width1 = (dialog.items + n)->width1;
    }
#line 1374
    if (dialog.width < (dialog.items + n)->width) {
#line 1375
      dialog.width = (dialog.items + n)->width;
    }
#line 1341
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1377
  dialog.height += 2 * (n - 1);
#line 1378
  tmp___1 = gettext("OK");
#line 1378
  tmp___2 = xtextwidth(uih->font, (char const   *)tmp___1);
#line 1378
  tmp___3 = gettext("Cancel");
#line 1378
  tmp___4 = xtextwidth(uih->font, (char const   *)tmp___3);
#line 1378
  tmp___5 = gettext("Help");
#line 1378
  tmp___6 = xtextwidth(uih->font, (char const   *)tmp___5);
#line 1378
  n = ((tmp___2 + tmp___4) + tmp___6) + 10;
  }
#line 1382
  if (dialog.width < n) {
#line 1383
    dialog.width = n;
  }
#line 1384
  dialog.half = dialog.width + 4;
#line 1385
  dialog.width += 4 + width1;
#line 1386
  dialog.height += 4;
#line 1387
  dialog.current = 0;
#line 1388
  dialog.x = ((uih->image)->width - dialog.width) / 2;
#line 1389
  dialog.half += dialog.x;
#line 1390
  dialog.y = ((uih->image)->height - dialog.height) / 2;
#line 1391
  ypos = dialog.y + 2;
#line 1392
  n = 0;
  {
#line 1392
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1392
    if (! (n < dialog.nitems)) {
#line 1392
      goto while_break___1;
    }
#line 1393
    (dialog.items + n)->y = ypos;
#line 1394
    ypos += (dialog.items + n)->height + 2;
#line 1392
    n ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1396
  dialog.window = uih_registerw(uih, & ui_dialogpos, & ui_dialogdraw, (void *)0, 2);
#line 1398
  uih->display = 1;
  }
#line 1399
  return;
}
}
#line 1401 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
static void ui_dialogquestion(int succesfull ) 
{ 


  {
#line 1403
  if (succesfull) {
    {
#line 1404
    ui_menuactivate(qitem, qparam);
    }
  } else {
    {
#line 1406
    menu_destroydialog(qitem, qparam, uih);
    }
  }
#line 1407
  return;
}
}
#line 1409 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
void ui_closedialog(int succesfull ) 
{ 
  int n ;
  dialogparam *param ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1411
  n = 2;
#line 1412
  if (dialogvisible) {
    {
#line 1413
    tmp = malloc(sizeof(dialogparam ) * (unsigned long )dialog.nitems);
#line 1413
    param = (dialogparam *)tmp;
#line 1415
    dialogvisible = 0;
#line 1416
    uih_removew(uih, dialog.window);
#line 1417
    uih->display = 1;
#line 1418
    n = 0;
    }
    {
#line 1418
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1418
      if (! (n < dialog.nitems)) {
#line 1418
        goto while_break;
      }
      {
#line 1419
      (*(((dialog.items + n)->type)->destroy))(dialog.items + n, param + n);
#line 1418
      n ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1421
    free((void *)dialog.items);
    }
#line 1422
    if (succesfull) {
#line 1423
      n = 0;
      {
#line 1423
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1423
        if (! (n < dialog.nitems - 1)) {
#line 1423
          goto while_break___0;
        }
#line 1424
        if ((dialog.dialog + n)->type == 6) {
          {
#line 1424
          tmp___0 = xio_exist((xio_constpath )(param + n)->dpath);
          }
#line 1424
          if (tmp___0) {
            {
#line 1426
            qparam = param;
#line 1427
            qitem = dialog.item;
#line 1428
            ui_buildyesno("File exist. Overwrite?", & ui_dialogquestion);
            }
#line 1430
            return;
          }
        }
#line 1423
        n ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1432
      ui_menuactivate(dialog.item, param);
      }
    } else {
      {
#line 1434
      menu_destroydialog(dialog.item, param, uih);
      }
    }
  }
#line 1436
  return;
}
}
#line 1438 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
int ui_dialogmouse(int x , int y , int mousebuttons , int flags ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 1441
  tmp = ui_mouseyesno(x, y, mousebuttons, flags);
  }
#line 1441
  if (tmp) {
#line 1442
    return (1);
  }
#line 1443
  if (! dialogvisible) {
#line 1444
    return (0);
  }
#line 1445
  if (! dialog.mousereleased) {
#line 1445
    if (flags & 2) {
#line 1446
      dialog.mousereleased = 1;
#line 1447
      return (1);
    }
  }
#line 1449
  if (! dialog.mousereleased) {
#line 1449
    if (flags & 4) {
#line 1450
      return (1);
    }
  }
#line 1452
  dialog.mousereleased = 1;
#line 1453
  if (dialog.mousegrab) {
    {
#line 1454
    (*(((dialog.items + dialog.current)->type)->mouse))(dialog.items + dialog.current,
                                                        x, y, mousebuttons, flags);
    }
#line 1457
    return (1);
  }
#line 1459
  if (dialog.x > x) {
#line 1459
    goto _L;
  } else
#line 1459
  if (dialog.y > y) {
#line 1459
    goto _L;
  } else
#line 1459
  if (dialog.x + dialog.width < x) {
#line 1459
    goto _L;
  } else
#line 1459
  if (dialog.y + dialog.height < y) {
    _L: /* CIL Label */ 
#line 1461
    if (flags & 1) {
      {
#line 1462
      ui_closedialog(0);
      }
#line 1463
      return (1);
    }
    {
#line 1465
    (*(((dialog.items + dialog.current)->type)->mouse))(dialog.items + dialog.current,
                                                        x, y, 0, 0);
    }
#line 1468
    return (1);
  }
#line 1470
  i = dialog.nitems - 1;
  {
#line 1470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1470
    if (! (i >= 0)) {
#line 1470
      goto while_break;
    }
#line 1471
    if ((dialog.items + i)->y < y) {
#line 1472
      goto while_break;
    }
#line 1470
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1473
  if (i == -1) {
    {
#line 1474
    (*(((dialog.items + dialog.current)->type)->mouse))(dialog.items + dialog.current,
                                                        x, y, 0, 0);
    }
#line 1477
    return (1);
  }
#line 1479
  if (flags & 1) {
#line 1479
    goto _L___0;
  } else
#line 1479
  if (flags & 8) {
    _L___0: /* CIL Label */ 
#line 1479
    if (dialog.current != i) {
      {
#line 1481
      (*(((dialog.items + dialog.current)->type)->unselect))(dialog.items + dialog.current);
#line 1483
      dialog.current = i;
#line 1484
      uih->display = 1;
      }
    }
  }
  {
#line 1486
  (*(((dialog.items + i)->type)->mouse))(dialog.items + i, x, y, mousebuttons, flags);
  }
#line 1488
  return (1);
}
}
#line 1491 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/dialog.c"
int ui_dialogkeys(int key ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1493
  tmp = ui_keyyesno(key);
  }
#line 1493
  if (tmp) {
#line 1494
    return (1);
  }
#line 1495
  if (! dialogvisible) {
#line 1496
    return (0);
  }
#line 1497
  if (key == 261) {
    {
#line 1498
    ui_closedialog(0);
    }
#line 1499
    return (1);
  }
  {
#line 1501
  tmp___0 = (*(((dialog.items + dialog.current)->type)->key))(dialog.items + dialog.current,
                                                              key);
  }
#line 1501
  if (! tmp___0) {
    {
#line 1504
    if (key == 104) {
#line 1504
      goto case_104;
    }
#line 1509
    if (key == 260) {
#line 1509
      goto case_260;
    }
#line 1509
    if (key == 258) {
#line 1509
      goto case_260;
    }
#line 1509
    if (key == 9) {
#line 1509
      goto case_260;
    }
#line 1513
    if (key == 259) {
#line 1513
      goto case_259;
    }
#line 1513
    if (key == 257) {
#line 1513
      goto case_259;
    }
#line 1517
    if (key == 10) {
#line 1517
      goto case_10;
    }
#line 1517
    if (key == 13) {
#line 1517
      goto case_10;
    }
#line 1503
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 1505
    ui_help((char const   *)(dialog.item)->shortname);
    }
#line 1506
    return (1);
    case_260: /* CIL Label */ 
    case_258: /* CIL Label */ 
    case_9: /* CIL Label */ 
    {
#line 1510
    NEXT();
    }
#line 1511
    goto switch_break;
    case_259: /* CIL Label */ 
    case_257: /* CIL Label */ 
    {
#line 1514
    PREV();
    }
#line 1515
    goto switch_break;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    {
#line 1518
    ui_closedialog(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 1521
  return (1);
}
}
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 376 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 109 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log)(double __x )  __asm__("__log_finite")  ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 232 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/filter.h"
extern void flipgeneric(struct image *img ) ;
#line 240
extern struct image *create_image_cont(int width , int height , int scanlinesize ,
                                       int nimages , pixel_t *buf1 , pixel_t *buf2 ,
                                       struct palette *palette , void (*flip)(struct image *img ) ,
                                       int flags , float pixelwidth , float pixelheight ) ;
#line 255
extern void destroy_image(struct image *img ) ;
#line 262
extern struct palette *createpalette(int start , int end , int type , int flags ,
                                     int maxentries , int (*alloccolor)(struct palette *pal ,
                                                                        int init ,
                                                                        int r , int g ,
                                                                        int b ) ,
                                     void (*setcolor)(struct palette *pal , int start ,
                                                      int end , rgb_t *rgb ) , void (*allocfinished)(struct palette *pal ) ,
                                     void (*cyclecolors)(struct palette *pal , int direction ) ,
                                     union paletteinfo *info ) ;
#line 275
extern void destroypalette(struct palette *palette ) ;
#line 157 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/fractal.h"
extern void speed_test(fractal_context * , struct image *img ) ;
#line 51 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/timers.h"
extern int tl_process_group(tl_group *group , int *activated ) ;
#line 53
extern void tl_sleep(int  ) ;
#line 350 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui_helper.h"
struct uih_context *uih_mkcontext(int flags , struct image *image___0 , int (*passfunc___0)(struct uih_context * ,
                                                                                            int  ,
                                                                                            char const   * ,
                                                                                            float  ) ,
                                  void (*longwait)(struct uih_context * ) , void (*upd)(struct uih_context *c ,
                                                                                        char const   * ) ) ;
#line 360
int uih_updateimage(uih_context *c , struct image *image___0 ) ;
#line 361
void uih_freecontext(uih_context *c ) ;
#line 368
void uih_savepalette(uih_context *c ) ;
#line 369
void uih_restorepalette(uih_context *uih___2 ) ;
#line 377
int uih_update(uih_context *c , int mousex , int mousey , int mousebuttons ) ;
#line 381
double uih_displayed(uih_context *c ) ;
#line 383
void uih_prepare_image(uih_context *c ) ;
#line 392
void uih_screentofractalcoord(uih_context *c , int mousex , int mousey , number_t *re ,
                              number_t *im ) ;
#line 398
void uih_cycling_stop(struct uih_context *c ) ;
#line 399
void uih_cycling_continue(struct uih_context *c ) ;
#line 437
void uih_loadstr(struct uih_context *c , char const   *data ) ;
#line 453
char *uih_savepostostr(struct uih_context *c ) ;
#line 494
extern void uih_clearwindows(struct uih_context *uih ) ;
#line 495
extern void uih_drawwindows(struct uih_context *uih ) ;
#line 518
void uih_saveundo(struct uih_context *c ) ;
#line 335 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xmenu.h"
extern menuitem const   *menu_findkey(char const   *key , char const   *root ) ;
#line 341
extern void menu_activate(menuitem const   *item , struct uih_context *c , dialogparam *d ) ;
#line 353
extern void menu_addqueue(menuitem const   *item , dialogparam *d ) ;
#line 354
extern menuitem const   *menu_delqueue(dialogparam **d ) ;
#line 357
extern int menu_havedialog(menuitem const   *item , struct uih_context *c ) ;
#line 126 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui.h"
void ui_resize(void) ;
#line 127
void ui_call_resize(void) ;
#line 128
 __attribute__((__noreturn__)) void ui_quit(void) ;
#line 129
void ui_menu(char const   *m ) ;
#line 131
int ui_key(int key ) ;
#line 132
void ui_loadstr(char const   *n ) ;
#line 135
char *ui_getpos(void) ;
#line 24 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uiint.h"
uih_context *uih  ;
#line 25 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uiint.h"
struct ui_driver  const  *driver  ;
#line 26
int const   ndrivers ;
#line 27
struct ui_driver  const  * const  drivers[2] ;
#line 28
int ui_nmenus ;
#line 31
struct params  const  ui_fractal_params[11] ;
#line 33 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uiint.h"
int ui_nogui  ;
#line 35
float ui_get_windowwidth(int width ) ;
#line 36
float ui_get_windowheight(int height ) ;
#line 45
int ui_menumouse(int x , int y , int mousebuttons , int flags ) ;
#line 46
int ui_menukey(int key ) ;
#line 47
int ui_menuwidth(void) ;
#line 48
void ui_closemenus(void) ;
#line 50
int ui_dorender_params(void) ;
#line 52
void ui_updatestarts(void) ;
#line 55
void ui_close_help(void) ;
#line 72
int ui_helpkeys(int key ) ;
#line 73
int ui_helpmouse(int x , int y , int buttons , int flags ) ;
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 91
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bind_textdomain_codeset)(char const   *__domainname ,
                                                                                                char const   *__codeset ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 96 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_mouse(int mousex , int mousey , int mousebuttons , int iterchange ) ;
#line 102 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
xio_pathdata configfile  ;
#line 103
static void ui_unregistermenus(void) ;
#line 104
static void ui_mkimages(int w , int h ) ;
#line 105
static  __attribute__((__noreturn__)) void main_loop(void) ;
#line 107 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
int prog_argc  ;
#line 108 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
int err  ;
#line 109 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
char **prog_argv  ;
#line 113 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
char statustext[256]  ;
#line 115 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static struct image *image  ;
#line 116 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int statusstart  ;
#line 117 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static struct uih_window *statuswindow  =    (struct uih_window *)((void *)0);
#line 118 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int ministatusstart  ;
#line 119 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static struct uih_window *ministatuswindow  =    (struct uih_window *)((void *)0);
#line 120 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int mouse  ;
#line 122 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int dirty  =    0;
#line 123 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int lastiter  ;
#line 124 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int maxiter  ;
#line 125 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int lastbuttons  ;
#line 125 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int lastx  ;
#line 125 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int lasty  ;
#line 126 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int callresize  =    0;
#line 127 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static tl_timer *maintimer  ;
#line 128 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static tl_timer *arrowtimer  ;
#line 129 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static tl_timer *loopt  ;
#line 130 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int todriver  =    0;
#line 133 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static char *defpipe  ;
#line 134 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static char *defdriver  =    (char *)((void *)0);
#line 135 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int deflist  ;
#line 136 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int printconfig  ;
#line 137 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int printspeed  ;
#line 138 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int delaytime  =    0;
#line 139 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int defthreads  =    0;
#line 140 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int maxframerate  =    80;
#line 141 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static float defscreenwidth  =    (float )0.0;
#line 141 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static float defscreenheight  =    (float )0.0;
#line 141 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static float defpixelwidth  =    (float )0.0;
#line 141 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static float defpixelheight  =    (float )0.0;
#line 149 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
struct params  const  global_params[15]  = 
#line 149
  {      {"-delay", 1, (void *)(& delaytime), "Delay screen updates (milliseconds)"}, 
        {"-driver", 2, (void *)(& defdriver), "Select driver"}, 
        {"-list", 0, (void *)(& deflist), "List available drivers. Then exit"}, 
        {"-config", 0, (void *)(& printconfig), "Print configuration. Then exit"}, 
        {"-speedtest", 0, (void *)(& printspeed), "Test speed of calculation loop. Then exit"}, 
        {"-threads",
      1, (void *)(& defthreads), "Multiple CPUs unsupported - please recompile XaoS with threads enabled"}, 
        {"-pipe",
      2, (void *)(& defpipe), "Accept commands from pipe (use \"-\" for stdin)"}, 
        {"-maxframerate", 1, (void *)(& maxframerate), "Maximal framerate (0 for unlimited - default)"}, 
        {"",
      4, (void *)0, "Screen size options: \n\n  Knowledge of exact screen size makes random dot stereogram look better. \n  Also is used for choosing correct view area"}, 
        {"-screenwidth",
      3, (void *)(& defscreenwidth), "exact size of screen in centimeters"}, 
        {"-screenheight", 3, (void *)(& defscreenheight), "exact size of screen in centimeters"}, 
        {"",
      4, (void *)0, "  Use this option in case you use some kind of virtual screen\n  or something similar that confuses previous options"}, 
        {"-pixelwidth",
      3, (void *)(& defpixelwidth), "exact size of one pixel in centimeters"}, 
        {"-pixelheight", 3, (void *)(& defpixelheight), "exact size of one pixel in centimeters"}, 
        {(char const   *)((void *)0),
      0, (void *)0, (char const   *)((void *)0)}};
#line 194 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int resizeregistered  =    0;
#line 195 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_updatemenus(uih_context *c , char const   *name___0 ) 
{ 
  struct menuitem  const  *item ;
  int tmp ;
  int tmp___0 ;

  {
#line 198
  if (ui_nogui) {
#line 199
    if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
      {
#line 200
      printf((char const   */* __restrict  */)"Root \"%s\"", uih->menuroot);
      }
    }
    {
#line 202
    item = menu_findcommand(name___0);
    }
#line 203
    if ((unsigned long )item == (unsigned long )((void *)0)) {
#line 205
      return;
    }
#line 207
    if (item->flags & 1) {
      {
#line 208
      tmp = menu_enabled(item, c);
      }
#line 208
      if (tmp) {
        {
#line 209
        printf((char const   */* __restrict  */)"checkbox \"%s\" on\n", name___0);
        }
      } else {
        {
#line 211
        printf((char const   */* __restrict  */)"checkbox \"%s\" off\n", name___0);
        }
      }
    }
#line 213
    if (item->flags & 2) {
      {
#line 214
      tmp___0 = menu_enabled(item, c);
      }
#line 214
      if (tmp___0) {
        {
#line 215
        printf((char const   */* __restrict  */)"radio \"%s\"\n", name___0);
        }
      }
    }
  }
#line 218
  if ((unsigned long )driver != (unsigned long )((void *)0)) {
#line 218
    if (driver->gui_driver) {
#line 219
      if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
#line 220
        if ((driver->gui_driver)->setrootmenu) {
          {
#line 221
          (*((driver->gui_driver)->setrootmenu))(c, uih->menuroot);
          }
        }
#line 222
        return;
      }
      {
#line 224
      item = menu_findcommand(name___0);
      }
#line 225
      if ((unsigned long )item == (unsigned long )((void *)0)) {
#line 227
        return;
      }
#line 229
      if (item->flags & 3) {
#line 230
        if ((driver->gui_driver)->enabledisable) {
          {
#line 231
          (*((driver->gui_driver)->enabledisable))(uih, name___0);
          }
        }
      }
    }
  }
#line 234
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void mousetype(int m ) 
{ 


  {
#line 241
  if (ui_nmenus) {
#line 243
    m = 0;
  } else
#line 241
  if (helpvisible) {
#line 243
    m = 0;
  } else
#line 241
  if (filevisible) {
#line 243
    m = 0;
  } else
#line 241
  if (dialogvisible) {
#line 243
    m = 0;
  } else
#line 241
  if (yesnodialogvisible) {
#line 243
    m = 0;
  }
#line 244
  if (mouse != m) {
#line 245
    mouse = m;
#line 246
    if ((unsigned long )driver->mousetype != (unsigned long )((void *)0)) {
      {
#line 247
      (*(driver->mousetype))(m);
      }
    }
  }
#line 249
  return;
}
}
#line 251 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_display(void) 
{ 


  {
  {
#line 254
  uih_drawwindows(uih);
#line 255
  (*(driver->display))();
#line 256
  uih_cycling_continue(uih);
  }
#line 257
  if (! (driver->flags & 2048)) {
#line 258
    if (driver->flush) {
      {
#line 258
      (*(driver->flush))();
      }
    }
  }
#line 259
  return;
}
}
#line 261 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
float ui_get_windowwidth(int width ) 
{ 


  {
#line 263
  if ((double )defscreenwidth > 0.0) {
#line 263
    if (driver->flags & 1024) {
#line 264
      return ((defscreenwidth * (float )width) / (float )driver->maxwidth);
    }
  }
#line 265
  if ((double )defscreenwidth > 0.0) {
#line 266
    return (defscreenwidth);
  }
#line 267
  if ((double )defpixelwidth > 0.0) {
#line 268
    return (defpixelwidth * (float )width);
  }
#line 269
  return ((float )0);
}
}
#line 272 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static float get_windowwidth(int width ) 
{ 
  float w ;
  float tmp ;

  {
  {
#line 274
  tmp = ui_get_windowwidth(width);
#line 274
  w = tmp;
  }
#line 275
  if (w) {
#line 276
    return (w);
  }
#line 277
  if (driver->flags & 512) {
#line 278
    return ((float )(driver->width * (float const   )width));
  }
#line 279
  if (driver->flags & 256) {
#line 280
    return ((float )driver->width);
  }
#line 281
  if (driver->flags & 1024) {
#line 282
    return ((float )((29.0 / (double )driver->maxwidth) * (double )width));
  }
#line 283
  return ((float )29.0);
}
}
#line 286 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
float ui_get_windowheight(int height ) 
{ 


  {
#line 288
  if ((double )defscreenheight > 0.0) {
#line 288
    if (driver->flags & 1024) {
#line 289
      return ((defscreenheight * (float )height) / (float )driver->maxheight);
    }
  }
#line 290
  if ((double )defscreenheight > 0.0) {
#line 291
    return (defscreenheight);
  }
#line 292
  if ((double )defpixelheight > 0.0) {
#line 293
    return (defpixelheight * (float )height);
  }
#line 294
  return ((float )0);
}
}
#line 297 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static float get_windowheight(int height ) 
{ 
  float h ;
  float tmp ;

  {
  {
#line 299
  tmp = ui_get_windowheight(height);
#line 299
  h = tmp;
  }
#line 300
  if (h) {
#line 301
    return (h);
  }
#line 302
  if (driver->flags & 512) {
#line 303
    return ((float )(driver->height * (float const   )height));
  }
#line 304
  if (driver->flags & 256) {
#line 305
    return ((float )driver->height);
  }
#line 306
  if (driver->flags & 1024) {
#line 307
    return ((float )((21.0 / (double )driver->maxheight) * (double )height));
  }
#line 308
  return ((float )21.5);
}
}
#line 312 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_outofmem(void) 
{ 
  char *tmp ;

  {
  {
#line 314
  tmp = gettext("XaoS is out of memory.");
#line 314
  x_error(tmp);
  }
#line 315
  return;
}
}
#line 318 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int ui_passfunc(struct uih_context *c , int display , char const   *text ,
                       float percent ) 
{ 
  char str___0[80] ;
  int x ;
  int y ;
  int b ;
  int k ;

  {
  {
#line 323
  x = 0;
#line 323
  y = 0;
#line 323
  b = 0;
#line 323
  k = 0;
#line 324
  (*(driver->processevents))(0, & x, & y, & b, & k);
#line 325
  ui_mouse(x, y, b, k);
  }
#line 327
  if (! uih->play) {
#line 328
    if (uih->display) {
      {
#line 329
      ui_display();
#line 329
      display = 1;
      }
    }
#line 330
    if (! c->interruptiblemode) {
#line 330
      if (! uih->play) {
#line 331
        if (display) {
#line 332
          if (percent) {
            {
#line 333
            sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)"%s %3.2f%%        ",
                    text, (double )percent);
            }
          } else {
            {
#line 336
            sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)"%s          ",
                    text);
            }
          }
          {
#line 337
          (*(driver->print))(0, (uih->image)->height - (int )driver->textheight, (char const   *)(str___0));
          }
#line 338
          if (driver->flush) {
            {
#line 338
            (*(driver->flush))();
            }
          }
        }
      } else {
#line 330
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 341
    if (! (driver->flags & 2048)) {
#line 342
      if (driver->flush) {
        {
#line 342
        (*(driver->flush))();
        }
      }
    }
  }
#line 345
  return (0);
}
}
#line 348 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_updatestatus(void) 
{ 
  double times ;
  double timesnop ;
  double tmp ;
  double tmp___0 ;
  double speed ;
  int tmp___1 ;
  double tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 350
  times = (double )(((uih->fcontext)->currentformula)->v.rr / (number_t const   )(uih->fcontext)->s.rr);
#line 352
  tmp = log(times);
#line 352
  tmp___0 = log(10.0);
#line 352
  timesnop = tmp / tmp___0;
#line 354
  uih_drawwindows(uih);
#line 355
  (*(driver->display))();
#line 356
  uih_cycling_continue(uih);
#line 357
  speed = uih_displayed(uih);
  }
#line 358
  if (uih->autopilot) {
#line 358
    tmp___1 = 'A';
  } else {
#line 358
    tmp___1 = ' ';
  }
#line 358
  if (times < (double )1) {
#line 358
    tmp___2 = 1.0 / times;
  } else {
#line 358
    tmp___2 = times;
  }
#line 358
  if (times < (double )1) {
    {
#line 358
    tmp___3 = gettext("unzoomed");
#line 358
    tmp___5 = tmp___3;
    }
  } else {
    {
#line 358
    tmp___4 = gettext("zoomed");
#line 358
    tmp___5 = tmp___4;
    }
  }
  {
#line 358
  tmp___6 = gettext("%s %.2f times (%.1fE) %2.2f frames/sec %c %i %i %i %i            ");
#line 358
  sprintf((char */* __restrict  */)(statustext), (char const   */* __restrict  */)tmp___6,
          tmp___5, tmp___2, timesnop, speed, tmp___1, (uih->fcontext)->coloringmode + 1,
          (uih->fcontext)->incoloringmode + 1, (uih->fcontext)->plane + 1, (uih->fcontext)->maxiter);
  }
#line 367
  if (! (driver->flags & 2048)) {
#line 368
    if (driver->flush) {
      {
#line 368
      (*(driver->flush))();
      }
    }
  }
  {
#line 370
  (*(driver->print))(0, 0, "");
  }
#line 371
  return;
}
}
#line 373 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
void ui_updatestarts(void) 
{ 
  int y ;
  int tmp ;

  {
  {
#line 375
  y = 0;
#line 376
  tmp = ui_menuwidth();
#line 376
  y += tmp;
#line 377
  ministatusstart = y;
  }
#line 378
  if ((unsigned long )ministatuswindow != (unsigned long )((void *)0)) {
#line 379
    y += (int )((uih->font)->height + 1);
  }
#line 380
  statusstart = y;
#line 381
  if ((unsigned long )statuswindow != (unsigned long )((void *)0)) {
#line 382
    y += (int )(((uih->font)->height + 1) * 11);
  }
#line 383
  uih->messg.messagestart = y;
#line 384
  return;
}
}
#line 386 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
void ui_menuactivate(menuitem const   *item , dialogparam *d ) 
{ 
  int tmp ;
  char s[256] ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 388
  if ((unsigned long )item == (unsigned long )((void *)0)) {
#line 389
    return;
  }
  {
#line 390
  ui_closemenus();
  }
#line 391
  if (item->type == 2) {
    {
#line 392
    ui_menu((char const   *)item->shortname);
    }
#line 393
    return;
  } else {
    {
#line 395
    tmp = menu_havedialog(item, uih);
    }
#line 395
    if (tmp) {
#line 395
      if ((unsigned long )d == (unsigned long )((void *)0)) {
        {
#line 396
        ui_builddialog(item);
        }
#line 397
        return;
      }
    }
#line 399
    if (uih->incalculation) {
#line 399
      if (! (item->flags & 8)) {
        {
#line 400
        menu_addqueue(item, d);
        }
#line 401
        if (item->flags & 4) {
          {
#line 402
          uih_interrupt(uih);
          }
        }
#line 403
        return;
      }
    }
#line 405
    if (item->flags & 1) {
      {
#line 407
      ui_updatestatus();
#line 408
      tmp___2 = menu_enabled(item, uih);
      }
#line 408
      if (tmp___2) {
        {
#line 411
        tmp___1 = gettext("Disabling: %s. ");
#line 411
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)tmp___1,
                item->name);
        }
      } else {
        {
#line 409
        tmp___0 = gettext("Enabling: %s. ");
#line 409
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)tmp___0,
                item->name);
        }
      }
      {
#line 412
      uih_message(uih, (char const   *)(s));
      }
#line 413
      if (driver->flush) {
        {
#line 413
        (*(driver->flush))();
        }
      }
    } else {
      {
#line 415
      uih_message(uih, (char const   *)item->name);
      }
    }
    {
#line 416
    uih_saveundo(uih);
#line 417
    menu_activate(item, uih, d);
    }
#line 418
    if ((unsigned long )d != (unsigned long )((void *)0)) {
      {
#line 419
      menu_destroydialog(item, d, uih);
      }
    }
  }
#line 421
  return;
}
}
#line 423 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
xio_path ui_getfile(char const   *basename , char const   *extension ) 
{ 
  xio_path tmp ;

  {
  {
#line 425
  tmp = xio_getfilename(basename, extension);
  }
#line 425
  return (tmp);
}
}
#line 428 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_statuspos(uih_context *uih___2 , int *x , int *y , int *w , int *h ,
                         void *data ) 
{ 


  {
#line 431
  *x = 0;
#line 432
  *y = statusstart;
#line 433
  *w = (uih___2->image)->width;
#line 434
  *h = (int )(((uih___2->font)->height + 1) * 11);
#line 435
  return;
}
}
#line 437 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_drawstatus(uih_context *uih___2 , void *data ) 
{ 
  char str___0[6000] ;
  int h ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
  {
#line 440
  h = (int )((uih___2->font)->height + 1);
#line 441
  tmp = gettext("Fractal name:%s");
#line 441
  sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)tmp,
          ((uih___2->fcontext)->currentformula)->name[! (uih___2->fcontext)->mandelbrot]);
#line 444
  xprint(uih___2->image, uih___2->font, 0, statusstart, (char const   *)(str___0),
         uih___2->encoding, (int )*((uih___2->palette)->index + 1), (int )*((uih___2->palette)->index + 0),
         0);
  }
#line 446
  if ((uih___2->fcontext)->mandelbrot) {
    {
#line 446
    tmp___0 = gettext("Mandelbrot");
#line 446
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 446
    tmp___1 = gettext("Julia");
#line 446
    tmp___2 = tmp___1;
    }
  }
  {
#line 446
  tmp___3 = gettext("Fractal type:%s");
#line 446
  sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)tmp___3,
          tmp___2);
#line 455
  xprint(uih___2->image, uih___2->font, 0, statusstart + h, (char const   *)(str___0),
         uih___2->encoding, (int )*((uih___2->palette)->index + 1), (int )*((uih___2->palette)->index + 0),
         0);
#line 457
  tmp___4 = gettext("View:[%1.12f,%1.12f]");
#line 457
  sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)tmp___4,
          (double )(uih___2->fcontext)->s.cr, (double )(uih___2->fcontext)->s.ci);
#line 459
  xprint(uih___2->image, uih___2->font, 0, statusstart + 2 * h, (char const   *)(str___0),
         uih___2->encoding, (int )*((uih___2->palette)->index + 1), (int )*((uih___2->palette)->index + 0),
         0);
#line 461
  tmp___5 = gettext("size:[%1.12f,%1.12f]");
#line 461
  sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)tmp___5,
          (double )(uih___2->fcontext)->s.rr, (double )(uih___2->fcontext)->s.ri);
#line 463
  xprint(uih___2->image, uih___2->font, 0, statusstart + 3 * h, (char const   *)(str___0),
         uih___2->encoding, (int )*((uih___2->palette)->index + 1), (int )*((uih___2->palette)->index + 0),
         0);
#line 465
  tmp___6 = gettext("Rotation:%4.2f   Screen size:%i:%i");
#line 465
  sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)tmp___6,
          (double )(uih___2->fcontext)->angle, (uih___2->image)->width, (uih___2->image)->height);
#line 468
  xprint(uih___2->image, uih___2->font, 0, statusstart + 4 * h, (char const   *)(str___0),
         uih___2->encoding, (int )*((uih___2->palette)->index + 1), (int )*((uih___2->palette)->index + 0),
         0);
#line 470
  tmp___7 = gettext("Iterations:%-4i Palette size:%i");
#line 470
  sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)tmp___7,
          (uih___2->fcontext)->maxiter, ((uih___2->image)->palette)->size);
#line 472
  xprint(uih___2->image, uih___2->font, 0, statusstart + 5 * h, (char const   *)(str___0),
         uih___2->encoding, (int )*((uih___2->palette)->index + 1), (int )*((uih___2->palette)->index + 0),
         0);
#line 474
  sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)"Bailout:%4.2f",
          (double )(uih___2->fcontext)->bailout);
#line 475
  xprint(uih___2->image, uih___2->font, 0, statusstart + 6 * h, (char const   *)(str___0),
         uih___2->encoding, (int )*((uih___2->palette)->index + 1), (int )*((uih___2->palette)->index + 0),
         0);
  }
#line 477
  if (uih___2->autopilot) {
    {
#line 477
    tmp___8 = gettext("On");
#line 477
    tmp___10 = tmp___8;
    }
  } else {
    {
#line 477
    tmp___9 = gettext("Off");
#line 477
    tmp___10 = tmp___9;
    }
  }
  {
#line 477
  tmp___11 = gettext("Autopilot:%-4s  Plane:%s");
#line 477
  sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)tmp___11,
          tmp___10, planename[(uih___2->fcontext)->plane]);
#line 480
  xprint(uih___2->image, uih___2->font, 0, statusstart + 7 * h, (char const   *)(str___0),
         uih___2->encoding, (int )*((uih___2->palette)->index + 1), (int )*((uih___2->palette)->index + 0),
         0);
#line 482
  tmp___12 = gettext("incoloring:%s    outcoloring:%s");
#line 482
  sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)tmp___12,
          incolorname[(uih___2->fcontext)->incoloringmode], outcolorname[(uih___2->fcontext)->coloringmode]);
#line 485
  xprint(uih___2->image, uih___2->font, 0, statusstart + 8 * h, (char const   *)(str___0),
         uih___2->encoding, (int )*((uih___2->palette)->index + 1), (int )*((uih___2->palette)->index + 0),
         0);
#line 487
  tmp___13 = gettext("zoomspeed:%f");
#line 487
  sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)tmp___13,
          (double )((float )uih___2->maxstep * (float )1000));
#line 488
  xprint(uih___2->image, uih___2->font, 0, statusstart + 9 * h, (char const   *)(str___0),
         uih___2->encoding, (int )*((uih___2->palette)->index + 1), (int )*((uih___2->palette)->index + 0),
         0);
  }
#line 490
  if ((uih___2->fcontext)->mandelbrot) {
    {
#line 491
    tmp___14 = gettext("Parameter:none");
#line 491
    strcpy((char */* __restrict  */)(str___0), (char const   */* __restrict  */)tmp___14);
    }
  } else {
    {
#line 493
    tmp___15 = gettext("Parameter:[%f,%f]");
#line 493
    sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)tmp___15,
            (double )((float )(uih___2->fcontext)->pre), (double )((float )(uih___2->fcontext)->pim));
    }
  }
  {
#line 495
  xprint(uih___2->image, uih___2->font, 0, statusstart + 10 * h, (char const   *)(str___0),
         uih___2->encoding, (int )*((uih___2->palette)->index + 1), (int )*((uih___2->palette)->index + 0),
         0);
  }
#line 510
  if (driver->flush) {
    {
#line 510
    (*(driver->flush))();
    }
  }
#line 511
  return;
}
}
#line 513 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_status(uih_context *uih___2 ) 
{ 


  {
#line 515
  if ((unsigned long )statuswindow == (unsigned long )((void *)0)) {
    {
#line 516
    statuswindow = uih_registerw(uih___2, & ui_statuspos, & ui_drawstatus, (void *)0,
                                 0);
    }
  } else {
    {
#line 519
    uih_removew(uih___2, statuswindow);
#line 520
    statuswindow = (struct uih_window *)((void *)0);
    }
  }
  {
#line 522
  ui_updatemenus(uih___2, "status");
#line 523
  ui_updatemenus(uih___2, "animministatus");
#line 524
  ui_updatestarts();
  }
#line 525
  return;
}
}
#line 527 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int ui_statusenabled(uih_context *uih___2 ) 
{ 


  {
#line 529
  return ((unsigned long )statuswindow != (unsigned long )((void *)0));
}
}
#line 532 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_ministatuspos(uih_context *uih___2 , int *x , int *y , int *w , int *h ,
                             void *data ) 
{ 


  {
#line 536
  *x = 0;
#line 537
  *y = ministatusstart;
#line 538
  *w = (uih___2->image)->width;
#line 539
  *h = (int )((uih___2->font)->height + 1);
#line 540
  return;
}
}
#line 542 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_drawministatus(uih_context *uih___2 , void *data ) 
{ 


  {
  {
#line 544
  xprint(uih___2->image, uih___2->font, 0, ministatusstart, (char const   *)(statustext),
         uih___2->encoding, (int )*((uih___2->palette)->index + 1), (int )*((uih___2->palette)->index + 0),
         0);
  }
#line 546
  return;
}
}
#line 548 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_noguisw(uih_context *uih___2 ) 
{ 


  {
  {
#line 550
  ui_nogui ^= 1;
#line 551
  ui_updatemenus(uih___2, "nogui");
  }
#line 552
  return;
}
}
#line 554 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int ui_noguienabled(uih_context *uih___2 ) 
{ 


  {
#line 556
  return (ui_nogui);
}
}
#line 559 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_ministatus(uih_context *uih___2 ) 
{ 


  {
#line 561
  if ((unsigned long )ministatuswindow == (unsigned long )((void *)0)) {
    {
#line 562
    ministatuswindow = uih_registerw(uih___2, & ui_ministatuspos, & ui_drawministatus,
                                     (void *)0, 0);
    }
  } else {
    {
#line 566
    uih_removew(uih___2, ministatuswindow);
#line 567
    ministatuswindow = (struct uih_window *)((void *)0);
    }
  }
  {
#line 569
  ui_updatestarts();
#line 570
  ui_updatemenus(uih___2, "ministatus");
#line 571
  ui_updatemenus(uih___2, "animministatus");
  }
#line 572
  return;
}
}
#line 574 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int ui_ministatusenabled(uih_context *uih___2 ) 
{ 


  {
#line 576
  return ((unsigned long )ministatuswindow != (unsigned long )((void *)0));
}
}
#line 579 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_message(struct uih_context *u ) 
{ 
  char s[80] ;
  char *tmp ;

  {
#line 582
  if (uih->play) {
#line 583
    return;
  }
  {
#line 584
  mousetype(1);
#line 585
  tmp = gettext("Please wait while calculating %s");
#line 585
  sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)tmp, ((uih->fcontext)->currentformula)->name[! (uih->fcontext)->mandelbrot]);
#line 588
  (*(driver->print))(0, 0, (char const   *)(s));
  }
#line 589
  return;
}
}
#line 597
static int procescounter(int *counter , char const   *text , int speed , int keys___0 ,
                         int lastkeys , int down , int up , int tenskip , int min ,
                         int max ) ;
#line 597 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int pid___0  =    -1;
#line 592 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int procescounter(int *counter , char const   *text , int speed , int keys___0 ,
                         int lastkeys , int down , int up , int tenskip , int min ,
                         int max ) 
{ 
  int changed___0 ;
  char str___0[80] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 598
  changed___0 = 0;
#line 600
  tmp = tl_lookup_timer(arrowtimer);
  }
#line 600
  if (tmp > 1000000) {
    {
#line 601
    tl_reset_timer(arrowtimer);
    }
  }
#line 602
  if (keys___0 & up) {
#line 602
    if (! (lastkeys & up)) {
      {
#line 603
      (*counter) ++;
#line 604
      tenskip = 0;
#line 605
      changed___0 = 1;
#line 606
      tl_reset_timer(arrowtimer);
      }
    }
  }
#line 608
  if (keys___0 & down) {
#line 608
    if (! (lastkeys & down)) {
      {
#line 609
      (*counter) --;
#line 610
      tenskip = 0;
#line 611
      changed___0 = 1;
#line 612
      tl_reset_timer(arrowtimer);
      }
    }
  }
  {
#line 614
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 614
    tmp___0 = tl_lookup_timer(arrowtimer);
    }
#line 614
    if (! (tmp___0 > speed * 50000)) {
#line 614
      goto while_break;
    }
    {
#line 615
    tl_slowdown_timer(arrowtimer, speed * 50000);
    }
#line 616
    if (keys___0 & up) {
#line 617
      if (tenskip) {
#line 617
        if (! (*counter % 10)) {
#line 618
          *counter += 10;
        } else {
#line 620
          (*counter) ++;
        }
      } else {
#line 620
        (*counter) ++;
      }
#line 621
      changed___0 = 1;
    }
#line 623
    if (keys___0 & down) {
#line 624
      if (tenskip) {
#line 624
        if (! (*counter % 10)) {
#line 625
          *counter -= 10;
        } else {
#line 627
          (*counter) --;
        }
      } else {
#line 627
        (*counter) --;
      }
#line 628
      changed___0 = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 631
  if (changed___0) {
#line 632
    if (*counter > max) {
#line 633
      *counter = max;
    }
#line 634
    if (*counter < min) {
#line 635
      *counter = min;
    }
    {
#line 636
    sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)text,
            *counter);
#line 637
    uih_rmmessage(uih, pid___0);
#line 638
    pid___0 = uih_message(uih, (char const   *)(str___0));
    }
#line 639
    if (driver->flush) {
      {
#line 639
      (*(driver->flush))();
      }
    }
  }
#line 641
  return (changed___0);
}
}
#line 649 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int spid  ;
#line 691 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int rpid  ;
#line 644 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_mouse(int mousex , int mousey , int mousebuttons , int iterchange ) 
{ 
  int flags ;
  char str___0[80] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  double mul1 ;
  int tmp___12 ;
  double su ;
  char *tmp___13 ;
  int tmp___14 ;
  double mul1___0 ;
  int tmp___15 ;
  double su___0 ;
  char *tmp___16 ;
  int tmp___17 ;

  {
#line 650
  flags = 0;
#line 651
  if (mousex != lastx) {
#line 652
    flags |= 8;
  } else
#line 651
  if (mousey != lasty) {
#line 652
    flags |= 8;
  }
#line 653
  if (mousebuttons & 256) {
#line 653
    if (! (lastbuttons & 256)) {
#line 654
      flags |= 1;
    }
  }
#line 655
  if (! (mousebuttons & 256)) {
#line 655
    if (lastbuttons & 256) {
#line 656
      flags |= 2;
    }
  }
#line 657
  if (mousebuttons & 256) {
#line 658
    flags |= 4;
  }
  {
#line 659
  lastx = mousex;
#line 660
  lasty = mousey;
#line 661
  lastbuttons = mousebuttons;
#line 662
  tl_update_time();
#line 664
  tmp = ui_helpmouse(mousex, mousey, mousebuttons, flags);
  }
#line 664
  if (tmp) {
    {
#line 665
    uih_update(uih, mousex, mousey, 0);
    }
#line 666
    return;
  }
  {
#line 669
  tmp___0 = ui_mousefilesel(mousex, mousey, mousebuttons, flags);
  }
#line 669
  if (tmp___0) {
    {
#line 670
    uih_update(uih, mousex, mousey, 0);
    }
#line 671
    return;
  }
  {
#line 674
  tmp___1 = ui_dialogmouse(mousex, mousey, mousebuttons, flags);
  }
#line 674
  if (tmp___1) {
    {
#line 675
    uih_update(uih, mousex, mousey, 0);
    }
#line 676
    return;
  }
  {
#line 678
  tmp___2 = ui_menumouse(mousex, mousey, mousebuttons, flags);
  }
#line 678
  if (tmp___2) {
    {
#line 679
    uih_update(uih, mousex, mousey, 0);
    }
#line 680
    return;
  }
  {
#line 682
  uih_update(uih, mousex, mousey, mousebuttons);
  }
#line 683
  if (uih->play) {
    {
#line 684
    tmp___3 = gettext("Letters per second %i  ");
#line 684
    procescounter(& uih->letterspersec, (char const   *)tmp___3, 2, iterchange, lastiter,
                  1, 2, 0, 1, 2147483647);
    }
#line 687
    return;
  }
#line 689
  if (! uih->cycling) {
#line 690
    if (uih->rotatemode == 2) {
#line 692
      if (iterchange == 2) {
        {
#line 693
        tmp___4 = tl_lookup_timer(maintimer);
#line 693
        uih->rotationspeed += (number_t )((double )(30 * tmp___4) / 1000000.0);
#line 695
        uih_rmmessage(uih, rpid);
#line 696
        tmp___5 = gettext("Rotation speed:%2.2f degrees per second ");
#line 696
        sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)tmp___5,
                (double )((float )uih->rotationspeed));
#line 700
        rpid = uih_message(uih, (char const   *)(str___0));
        }
#line 701
        if (driver->flush) {
          {
#line 701
          (*(driver->flush))();
          }
        }
      }
#line 703
      if (iterchange == 1) {
        {
#line 704
        tmp___6 = tl_lookup_timer(maintimer);
#line 704
        uih->rotationspeed -= (number_t )((double )(30 * tmp___6) / 1000000.0);
#line 706
        uih_rmmessage(uih, rpid);
#line 707
        tmp___7 = gettext("Rotation speed:%2.2f degrees per second ");
#line 707
        sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)tmp___7,
                (double )((float )uih->rotationspeed));
#line 711
        rpid = uih_message(uih, (char const   *)(str___0));
        }
#line 712
        if (driver->flush) {
          {
#line 712
          (*(driver->flush))();
          }
        }
      }
      {
#line 714
      tl_reset_timer(maintimer);
      }
    } else {
#line 716
      if (! dirty) {
#line 717
        maxiter = (int )(uih->fcontext)->maxiter;
      }
      {
#line 718
      tmp___8 = gettext("Iterations: %i   ");
#line 718
      tmp___9 = procescounter(& maxiter, (char const   *)tmp___8, 1, iterchange, lastiter,
                              1, 2, 1, 1, 2147483647);
      }
#line 718
      if (tmp___9) {
#line 721
        dirty = 1;
#line 722
        lastiter = iterchange;
#line 723
        return;
      } else
#line 718
      if (iterchange & 3) {
#line 721
        dirty = 1;
#line 722
        lastiter = iterchange;
#line 723
        return;
      }
    }
  }
#line 727
  if (dirty) {
#line 728
    if (uih->incalculation) {
      {
#line 729
      uih_interrupt(uih);
      }
    } else {
      {
#line 731
      uih_setmaxiter(uih, maxiter);
#line 731
      dirty = 0;
      }
    }
  }
#line 733
  if (uih->cycling) {
    {
#line 734
    tmp___10 = gettext("Cycling speed: %i   ");
#line 734
    tmp___11 = procescounter(& uih->cyclingspeed, (char const   *)tmp___10, 1, iterchange,
                             lastiter, 1, 2, 0, -1000000, 2147483647);
    }
#line 734
    if (tmp___11) {
      {
#line 737
      uih_setcycling(uih, uih->cyclingspeed);
      }
    }
  }
#line 740
  if (iterchange & 4) {
    {
#line 740
    tmp___14 = tl_lookup_timer(maintimer);
    }
#line 740
    if (tmp___14 > 50000) {
#line 740
      goto _L;
    } else
#line 740
    if (mousebuttons) {
      _L: /* CIL Label */ 
      {
#line 742
      tmp___12 = tl_lookup_timer(maintimer);
#line 742
      mul1 = (double )(tmp___12 / 50000);
#line 743
      su = (double )1 + (1.05 - (double )1) * mul1;
      }
#line 744
      if (su > (double )2 * 1.05) {
#line 745
        su = 1.05;
      }
      {
#line 746
      tl_reset_timer(maintimer);
#line 747
      uih->speedup *= (number_t )su;
#line 747
      uih->maxstep *= (number_t )su;
#line 748
      tmp___13 = gettext("speed:%2.2f ");
#line 748
      sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)tmp___13,
              (double )uih->speedup * (1.0 / (0.0006 * (double )3)));
#line 750
      uih_rmmessage(uih, spid);
#line 751
      spid = uih_message(uih, (char const   *)(str___0));
      }
#line 752
      if (driver->flush) {
        {
#line 752
        (*(driver->flush))();
        }
      }
    }
  }
#line 754
  if (iterchange & 8) {
    {
#line 754
    tmp___17 = tl_lookup_timer(maintimer);
    }
#line 754
    if (tmp___17 > 50000) {
#line 754
      goto _L___0;
    } else
#line 754
    if (mousebuttons) {
      _L___0: /* CIL Label */ 
      {
#line 756
      tmp___15 = tl_lookup_timer(maintimer);
#line 756
      mul1___0 = (double )(tmp___15 / 50000);
#line 757
      su___0 = (double )1 + (1.05 - (double )1) * mul1___0;
      }
#line 758
      if (su___0 > (double )2 * 1.05) {
#line 759
        su___0 = 1.05;
      }
      {
#line 760
      tl_reset_timer(maintimer);
#line 761
      uih->speedup /= (number_t )su___0;
#line 761
      uih->maxstep /= (number_t )su___0;
#line 762
      tmp___16 = gettext("speed:%2.2f ");
#line 762
      sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)tmp___16,
              (double )uih->speedup * ((double )1 / (0.0006 * (double )3)));
#line 764
      uih_rmmessage(uih, spid);
#line 765
      spid = uih_message(uih, (char const   *)(str___0));
      }
#line 766
      if (driver->flush) {
        {
#line 766
        (*(driver->flush))();
        }
      }
    }
  }
#line 768
  lastiter = iterchange;
#line 769
  return;
}
}
#line 772 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
void ui_call_resize(void) 
{ 


  {
  {
#line 774
  callresize = 1;
#line 775
  uih_interrupt(uih);
  }
#line 776
  return;
}
}
#line 778 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int ui_alloccolor(struct palette *pal , int init , int r , int g , int b ) 
{ 
  int i ;

  {
  {
#line 782
  i = (*(driver->set_color))(r, g, b, init);
  }
#line 783
  if (i == -1) {
#line 784
    return (-1);
  }
#line 785
  if (init) {
#line 786
    pal->size = 0;
  }
#line 787
  *(pal->pixels + pal->size) = (unsigned int )i;
#line 788
  (*(pal->rgb + i))[0] = (unsigned char )r;
#line 789
  (*(pal->rgb + i))[1] = (unsigned char )g;
#line 790
  (*(pal->rgb + i))[2] = (unsigned char )b;
#line 791
  (pal->size) ++;
#line 792
  if (driver->flags & 4) {
#line 793
    uih->display = 1;
  }
#line 795
  return (i);
}
}
#line 798 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_setpalette(struct palette *pal , int start , int end , rgb_t *rgb1 ) 
{ 


  {
  {
#line 801
  (*(driver->set_range))(rgb1, start, end);
  }
#line 802
  return;
}
}
#line 804 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_flip(struct image *image___0 ) 
{ 


  {
  {
#line 806
  flipgeneric(image___0);
#line 807
  (*(driver->flip_buffers))();
  }
#line 808
  return;
}
}
#line 810 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static int ui_driverselected(uih_context *c , int d ) 
{ 


  {
#line 812
  return ((unsigned long )driver == (unsigned long )drivers[d]);
}
}
#line 815 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_setdriver(uih_context *c , int d ) 
{ 


  {
#line 817
  todriver = d + 1;
#line 818
  return;
}
}
#line 820 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void processbuffer(void) 
{ 
  menuitem const   *item ;
  dialogparam *d ;

  {
#line 824
  if (uih->incalculation) {
#line 825
    return;
  }
  {
#line 826
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 826
    item = menu_delqueue(& d);
    }
#line 826
    if (! ((unsigned long )item != (unsigned long )((void *)0))) {
#line 826
      goto while_break;
    }
    {
#line 827
    ui_menuactivate(item, d);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 829
  return;
}
}
#line 831
static  __attribute__((__noreturn__)) void ui_doquit(int i ) ;
#line 832
static  __attribute__((__noreturn__)) void ui_doquit(int i ) ;
#line 832 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_doquit(int i ) 
{ 


  {
  {
#line 834
  uih_cycling_off(uih);
#line 835
  uih_freecatalog(uih);
#line 836
  uih_freecontext(uih);
#line 837
  tl_free_timer(maintimer);
#line 838
  tl_free_timer(arrowtimer);
#line 839
  tl_free_timer(loopt);
#line 840
  (*(driver->free_buffers))((char *)((void *)0), (char *)((void *)0));
#line 841
  (*(driver->uninit))();
#line 842
  destroypalette(image->palette);
#line 843
  destroy_image(image);
#line 845
  xio_uninit();
#line 846
  ui_unregistermenus();
#line 847
  uih_unregistermenus();
#line 848
  exit(i);
  }
}
}
#line 851
 __attribute__((__noreturn__)) void ui_quit(void) ;
#line 851 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
void ui_quit(void) 
{ 
  char *tmp ;

  {
  {
#line 854
  tmp = gettext("Thank you for using XaoS\n");
#line 854
  printf((char const   */* __restrict  */)tmp);
#line 856
  ui_doquit(0);
  }
}
}
#line 859 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_quitwr(uih_context *c , int quit ) 
{ 


  {
#line 861
  if ((unsigned long )c == (unsigned long )((void *)0)) {
    {
#line 862
    ui_unregistermenus();
#line 863
    uih_unregistermenus();
#line 864
    xio_uninit();
#line 865
    exit(0);
    }
  }
#line 867
  if (quit) {
    {
#line 868
    ui_quit();
    }
  }
#line 869
  return;
}
}
#line 871 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
int ui_key(int key ) 
{ 
  int sym ;
  char mkey[2] ;
  menuitem const   *item ;
  char *tmp ;
  int number ;
  dialogparam *p ;
  menudialog const   *d ;
  menudialog const   *tmp___0 ;
  menudialog const   *tmp___1 ;
  int mousex ;
  int mousey ;
  int buttons ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 879
  tmp___4 = ui_helpkeys(key);
  }
#line 879
  if (! tmp___4) {
    {
#line 879
    tmp___5 = ui_keyfilesel(key);
    }
#line 879
    if (! tmp___5) {
      {
#line 879
      tmp___6 = ui_dialogkeys(key);
      }
#line 879
      if (! tmp___6) {
        {
#line 879
        tmp___7 = ui_menukey(key);
        }
#line 879
        if (! tmp___7) {
          {
#line 881
          sym = tolower(key);
          }
          {
#line 882
          if (sym == 32) {
#line 882
            goto case_32;
          }
#line 895
          goto switch_default;
          case_32: /* CIL Label */ 
          {
#line 883
          ui_closemenus();
#line 884
          uih->display = 1;
          }
#line 885
          if (uih->play) {
#line 886
            if (uih->incalculation) {
              {
#line 887
              ui_updatestatus();
              }
            } else {
              {
#line 889
              uih_skipframe(uih);
#line 890
              tmp = gettext("Skipping, please wait...");
#line 890
              (*(driver->print))(0, 0, (char const   *)tmp);
              }
            }
          }
#line 894
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 898
          if (sym >= 48) {
#line 898
            if (sym <= 57) {
#line 899
              number = sym - 49;
#line 900
              if (number < 0) {
#line 901
                number = 9;
              }
#line 902
              if (number == -1) {
#line 903
                goto switch_break;
              }
            }
          }
          {
#line 906
          mkey[0] = (char )key;
#line 907
          mkey[1] = (char)0;
#line 908
          item = menu_findkey((char const   *)(mkey), uih->menuroot);
          }
#line 909
          if ((unsigned long )item == (unsigned long )((void *)0)) {
            {
#line 910
            mkey[0] = (char )sym;
#line 911
            item = menu_findkey((char const   *)(mkey), uih->menuroot);
            }
          }
#line 913
          if ((unsigned long )item != (unsigned long )((void *)0)) {
            {
#line 914
            p = (dialogparam *)((void *)0);
#line 915
            tmp___3 = menu_havedialog(item, uih);
            }
#line 915
            if (tmp___3) {
#line 916
              if (item->type == 6) {
#line 916
                tmp___1 = (menudialog const   *)item->pparam;
              } else {
                {
#line 916
                tmp___0 = (*(item->dialog))(uih);
#line 916
                tmp___1 = tmp___0;
                }
              }
              {
#line 916
              d = tmp___1;
#line 918
              (*(driver->getmouse))(& mousex, & mousey, & buttons);
              }
#line 919
              if ((unsigned long )(d + 0)->question != (unsigned long )((void *)0)) {
#line 919
                if ((unsigned long )(d + 1)->question == (unsigned long )((void *)0)) {
#line 919
                  if ((d + 0)->type == 9) {
                    {
#line 921
                    tmp___2 = malloc(sizeof(dialogparam ));
#line 921
                    p = (dialogparam *)tmp___2;
#line 922
                    uih_screentofractalcoord(uih, mousex, mousey, p->dcoord, p->dcoord + 1);
                    }
                  }
                }
              }
            }
            {
#line 926
            ui_menuactivate(item, p);
            }
          }
#line 928
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
  {
#line 930
  processbuffer();
  }
#line 931
  return (0);
}
}
#line 939 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_helpwr(struct uih_context *c ) 
{ 


  {
  {
#line 941
  ui_help("main");
  }
#line 942
  return;
}
}
#line 944 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
char *ui_getpos(void) 
{ 
  char *tmp ;

  {
  {
#line 946
  tmp = uih_savepostostr(uih);
  }
#line 946
  return (tmp);
}
}
#line 949 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
void ui_loadstr(char const   *n ) 
{ 


  {
  {
#line 951
  uih_loadstr(uih, n);
  }
#line 952
  return;
}
}
#line 954 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static menuitem *menuitems___0  ;
#line 974 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static menuitem menuitems_i18n___0[20]  ;
#line 975 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
int ui_no_menuitems_i18n  =    0;
#line 975 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
int ui_no_resizeitems  ;
#line 976 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static menuitem *resizeitems  ;
#line 979 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void add_resizeitems(void) 
{ 
  int no_menuitems_i18n ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 982
  no_menuitems_i18n = ui_no_menuitems_i18n;
#line 983
  menuitems_i18n___0[no_menuitems_i18n].menuname = "ui";
#line 983
  menuitems_i18n___0[no_menuitems_i18n].shortname = "resize";
#line 983
  menuitems_i18n___0[no_menuitems_i18n].key = "=";
#line 983
  menuitems_i18n___0[no_menuitems_i18n].type = 1;
#line 983
  menuitems_i18n___0[no_menuitems_i18n].flags = 100;
#line 983
  menuitems_i18n___0[no_menuitems_i18n].iparam = 0;
#line 983
  tmp = gettext("Resize");
#line 983
  menuitems_i18n___0[no_menuitems_i18n].name = (char const   *)tmp;
#line 983
  menuitems_i18n___0[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 983
  menuitems_i18n___0[no_menuitems_i18n].function = & ui_call_resize;
#line 983
  no_menuitems_i18n ++;
#line 985
  menuitems_i18n___0[no_menuitems_i18n].menuname = "uia";
#line 985
  menuitems_i18n___0[no_menuitems_i18n].shortname = "animresize";
#line 985
  menuitems_i18n___0[no_menuitems_i18n].key = "=";
#line 985
  menuitems_i18n___0[no_menuitems_i18n].type = 1;
#line 985
  menuitems_i18n___0[no_menuitems_i18n].flags = 100;
#line 985
  menuitems_i18n___0[no_menuitems_i18n].iparam = 0;
#line 985
  tmp___0 = gettext("Resize");
#line 985
  menuitems_i18n___0[no_menuitems_i18n].name = (char const   *)tmp___0;
#line 985
  menuitems_i18n___0[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 985
  menuitems_i18n___0[no_menuitems_i18n].function = & ui_call_resize;
#line 985
  no_menuitems_i18n ++;
#line 987
  no_menuitems_i18n -= ui_no_menuitems_i18n;
#line 988
  resizeitems = & menuitems_i18n___0[ui_no_menuitems_i18n];
#line 989
  menu_add((menuitem const   *)resizeitems, no_menuitems_i18n);
#line 990
  ui_no_resizeitems = no_menuitems_i18n;
#line 991
  ui_no_menuitems_i18n += no_menuitems_i18n;
  }
#line 992
  return;
}
}
#line 994 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_registermenus_i18n(void) 
{ 
  int no_menuitems_i18n ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 996
  no_menuitems_i18n = ui_no_menuitems_i18n;
#line 998
  menuitems_i18n___0[no_menuitems_i18n].menuname = "file";
#line 998
  menuitems_i18n___0[no_menuitems_i18n].shortname = "quitmenu";
#line 998
  menuitems_i18n___0[no_menuitems_i18n].key = "q";
#line 998
  menuitems_i18n___0[no_menuitems_i18n].type = 2;
#line 998
  menuitems_i18n___0[no_menuitems_i18n].flags = 0;
#line 998
  menuitems_i18n___0[no_menuitems_i18n].iparam = 0;
#line 998
  tmp = gettext("Quit");
#line 998
  menuitems_i18n___0[no_menuitems_i18n].name = (char const   *)tmp;
#line 998
  menuitems_i18n___0[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 998
  menuitems_i18n___0[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 998
  no_menuitems_i18n ++;
#line 999
  menuitems_i18n___0[no_menuitems_i18n].menuname = "quitmenu";
#line 999
  menuitems_i18n___0[no_menuitems_i18n].shortname = "quit";
#line 999
  menuitems_i18n___0[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 999
  menuitems_i18n___0[no_menuitems_i18n].type = 3;
#line 999
  menuitems_i18n___0[no_menuitems_i18n].flags = 132;
#line 999
  menuitems_i18n___0[no_menuitems_i18n].iparam = 1;
#line 999
  tmp___0 = gettext("Exit now");
#line 999
  menuitems_i18n___0[no_menuitems_i18n].name = (char const   *)tmp___0;
#line 999
  menuitems_i18n___0[no_menuitems_i18n].function = (void (*)(void))(& ui_quitwr);
#line 999
  no_menuitems_i18n ++;
#line 1001
  menuitems_i18n___0[no_menuitems_i18n].menuname = "quitmenu";
#line 1001
  menuitems_i18n___0[no_menuitems_i18n].shortname = "noquit";
#line 1001
  menuitems_i18n___0[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1001
  menuitems_i18n___0[no_menuitems_i18n].type = 3;
#line 1001
  menuitems_i18n___0[no_menuitems_i18n].flags = 96;
#line 1001
  menuitems_i18n___0[no_menuitems_i18n].iparam = 0;
#line 1001
  tmp___1 = gettext("Not yet");
#line 1001
  menuitems_i18n___0[no_menuitems_i18n].name = (char const   *)tmp___1;
#line 1001
  menuitems_i18n___0[no_menuitems_i18n].function = (void (*)(void))(& ui_quitwr);
#line 1001
  no_menuitems_i18n ++;
#line 1004
  menuitems_i18n___0[no_menuitems_i18n].menuname = "helpmenu";
#line 1004
  menuitems_i18n___0[no_menuitems_i18n].shortname = "help";
#line 1004
  menuitems_i18n___0[no_menuitems_i18n].key = "h";
#line 1004
  menuitems_i18n___0[no_menuitems_i18n].type = 1;
#line 1004
  menuitems_i18n___0[no_menuitems_i18n].flags = 8;
#line 1004
  menuitems_i18n___0[no_menuitems_i18n].iparam = 0;
#line 1004
  tmp___2 = gettext("Help");
#line 1004
  menuitems_i18n___0[no_menuitems_i18n].name = (char const   *)tmp___2;
#line 1004
  menuitems_i18n___0[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1004
  menuitems_i18n___0[no_menuitems_i18n].function = (void (*)(void))(& ui_helpwr);
#line 1004
  no_menuitems_i18n ++;
#line 1006
  menuitems_i18n___0[no_menuitems_i18n].menuname = "ui";
#line 1006
  menuitems_i18n___0[no_menuitems_i18n].shortname = "nogui";
#line 1006
  menuitems_i18n___0[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1006
  menuitems_i18n___0[no_menuitems_i18n].type = 1;
#line 1006
  menuitems_i18n___0[no_menuitems_i18n].flags = 153;
#line 1006
  menuitems_i18n___0[no_menuitems_i18n].iparam = 0;
#line 1006
  tmp___3 = gettext("Disable XaoS\'s builtin GUI");
#line 1006
  menuitems_i18n___0[no_menuitems_i18n].name = (char const   *)tmp___3;
#line 1006
  menuitems_i18n___0[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1006
  menuitems_i18n___0[no_menuitems_i18n].function = (void (*)(void))(& ui_noguisw);
#line 1006
  menuitems_i18n___0[no_menuitems_i18n].control = (int (*)(void))(& ui_noguienabled);
#line 1006
  no_menuitems_i18n ++;
#line 1009
  menuitems_i18n___0[no_menuitems_i18n].menuname = "ui";
#line 1009
  menuitems_i18n___0[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1009
  menuitems_i18n___0[no_menuitems_i18n].key = (char const   *)0;
#line 1009
  menuitems_i18n___0[no_menuitems_i18n].type = 8;
#line 1009
  menuitems_i18n___0[no_menuitems_i18n].flags = 0;
#line 1009
  menuitems_i18n___0[no_menuitems_i18n].iparam = 0;
#line 1009
  menuitems_i18n___0[no_menuitems_i18n].name = "";
#line 1009
  menuitems_i18n___0[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1009
  menuitems_i18n___0[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1009
  no_menuitems_i18n ++;
#line 1010
  menuitems_i18n___0[no_menuitems_i18n].menuname = "ui";
#line 1010
  menuitems_i18n___0[no_menuitems_i18n].shortname = "status";
#line 1010
  menuitems_i18n___0[no_menuitems_i18n].key = "/";
#line 1010
  menuitems_i18n___0[no_menuitems_i18n].type = 1;
#line 1010
  menuitems_i18n___0[no_menuitems_i18n].flags = 9;
#line 1010
  menuitems_i18n___0[no_menuitems_i18n].iparam = 0;
#line 1010
  tmp___4 = gettext("Status");
#line 1010
  menuitems_i18n___0[no_menuitems_i18n].name = (char const   *)tmp___4;
#line 1010
  menuitems_i18n___0[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1010
  menuitems_i18n___0[no_menuitems_i18n].function = (void (*)(void))(& ui_status);
#line 1010
  menuitems_i18n___0[no_menuitems_i18n].control = (int (*)(void))(& ui_statusenabled);
#line 1010
  no_menuitems_i18n ++;
#line 1012
  menuitems_i18n___0[no_menuitems_i18n].menuname = "ui";
#line 1012
  menuitems_i18n___0[no_menuitems_i18n].shortname = "ministatus";
#line 1012
  menuitems_i18n___0[no_menuitems_i18n].key = "l";
#line 1012
  menuitems_i18n___0[no_menuitems_i18n].type = 1;
#line 1012
  menuitems_i18n___0[no_menuitems_i18n].flags = 9;
#line 1012
  menuitems_i18n___0[no_menuitems_i18n].iparam = 0;
#line 1012
  tmp___5 = gettext("Ministatus");
#line 1012
  menuitems_i18n___0[no_menuitems_i18n].name = (char const   *)tmp___5;
#line 1012
  menuitems_i18n___0[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1012
  menuitems_i18n___0[no_menuitems_i18n].function = (void (*)(void))(& ui_ministatus);
#line 1012
  menuitems_i18n___0[no_menuitems_i18n].control = (int (*)(void))(& ui_ministatusenabled);
#line 1012
  no_menuitems_i18n ++;
#line 1014
  menuitems_i18n___0[no_menuitems_i18n].menuname = "ui";
#line 1014
  menuitems_i18n___0[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1014
  menuitems_i18n___0[no_menuitems_i18n].key = (char const   *)0;
#line 1014
  menuitems_i18n___0[no_menuitems_i18n].type = 8;
#line 1014
  menuitems_i18n___0[no_menuitems_i18n].flags = 0;
#line 1014
  menuitems_i18n___0[no_menuitems_i18n].iparam = 0;
#line 1014
  menuitems_i18n___0[no_menuitems_i18n].name = "";
#line 1014
  menuitems_i18n___0[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1014
  menuitems_i18n___0[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1014
  no_menuitems_i18n ++;
#line 1015
  menuitems_i18n___0[no_menuitems_i18n].menuname = "uia";
#line 1015
  menuitems_i18n___0[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1015
  menuitems_i18n___0[no_menuitems_i18n].key = (char const   *)0;
#line 1015
  menuitems_i18n___0[no_menuitems_i18n].type = 8;
#line 1015
  menuitems_i18n___0[no_menuitems_i18n].flags = 0;
#line 1015
  menuitems_i18n___0[no_menuitems_i18n].iparam = 0;
#line 1015
  menuitems_i18n___0[no_menuitems_i18n].name = "";
#line 1015
  menuitems_i18n___0[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1015
  menuitems_i18n___0[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1015
  no_menuitems_i18n ++;
#line 1016
  menuitems_i18n___0[no_menuitems_i18n].menuname = "uia";
#line 1016
  menuitems_i18n___0[no_menuitems_i18n].shortname = "animstatus";
#line 1016
  menuitems_i18n___0[no_menuitems_i18n].key = "/";
#line 1016
  menuitems_i18n___0[no_menuitems_i18n].type = 1;
#line 1016
  menuitems_i18n___0[no_menuitems_i18n].flags = 105;
#line 1016
  menuitems_i18n___0[no_menuitems_i18n].iparam = 0;
#line 1016
  tmp___6 = gettext("Status");
#line 1016
  menuitems_i18n___0[no_menuitems_i18n].name = (char const   *)tmp___6;
#line 1016
  menuitems_i18n___0[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1016
  menuitems_i18n___0[no_menuitems_i18n].function = (void (*)(void))(& ui_status);
#line 1016
  menuitems_i18n___0[no_menuitems_i18n].control = (int (*)(void))(& ui_statusenabled);
#line 1016
  no_menuitems_i18n ++;
#line 1018
  menuitems_i18n___0[no_menuitems_i18n].menuname = "uia";
#line 1018
  menuitems_i18n___0[no_menuitems_i18n].shortname = "animministatus";
#line 1018
  menuitems_i18n___0[no_menuitems_i18n].key = "l";
#line 1018
  menuitems_i18n___0[no_menuitems_i18n].type = 1;
#line 1018
  menuitems_i18n___0[no_menuitems_i18n].flags = 105;
#line 1018
  menuitems_i18n___0[no_menuitems_i18n].iparam = 0;
#line 1018
  tmp___7 = gettext("Ministatus");
#line 1018
  menuitems_i18n___0[no_menuitems_i18n].name = (char const   *)tmp___7;
#line 1018
  menuitems_i18n___0[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1018
  menuitems_i18n___0[no_menuitems_i18n].function = (void (*)(void))(& ui_ministatus);
#line 1018
  menuitems_i18n___0[no_menuitems_i18n].control = (int (*)(void))(& ui_ministatusenabled);
#line 1018
  no_menuitems_i18n ++;
#line 1020
  menuitems_i18n___0[no_menuitems_i18n].menuname = "uia";
#line 1020
  menuitems_i18n___0[no_menuitems_i18n].shortname = (char const   *)((void *)0);
#line 1020
  menuitems_i18n___0[no_menuitems_i18n].key = (char const   *)0;
#line 1020
  menuitems_i18n___0[no_menuitems_i18n].type = 8;
#line 1020
  menuitems_i18n___0[no_menuitems_i18n].flags = 0;
#line 1020
  menuitems_i18n___0[no_menuitems_i18n].iparam = 0;
#line 1020
  menuitems_i18n___0[no_menuitems_i18n].name = "";
#line 1020
  menuitems_i18n___0[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1020
  menuitems_i18n___0[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1020
  no_menuitems_i18n ++;
#line 1021
  menuitems_i18n___0[no_menuitems_i18n].menuname = "ui";
#line 1021
  menuitems_i18n___0[no_menuitems_i18n].shortname = "drivers";
#line 1021
  menuitems_i18n___0[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1021
  menuitems_i18n___0[no_menuitems_i18n].type = 2;
#line 1021
  menuitems_i18n___0[no_menuitems_i18n].flags = 0;
#line 1021
  menuitems_i18n___0[no_menuitems_i18n].iparam = 0;
#line 1021
  tmp___8 = gettext("Driver");
#line 1021
  menuitems_i18n___0[no_menuitems_i18n].name = (char const   *)tmp___8;
#line 1021
  menuitems_i18n___0[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1021
  menuitems_i18n___0[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1021
  no_menuitems_i18n ++;
#line 1022
  menuitems_i18n___0[no_menuitems_i18n].menuname = "uia";
#line 1022
  menuitems_i18n___0[no_menuitems_i18n].shortname = "drivers";
#line 1022
  menuitems_i18n___0[no_menuitems_i18n].key = (char const   *)((void *)0);
#line 1022
  menuitems_i18n___0[no_menuitems_i18n].type = 2;
#line 1022
  menuitems_i18n___0[no_menuitems_i18n].flags = 0;
#line 1022
  menuitems_i18n___0[no_menuitems_i18n].iparam = 0;
#line 1022
  tmp___9 = gettext("Driver");
#line 1022
  menuitems_i18n___0[no_menuitems_i18n].name = (char const   *)tmp___9;
#line 1022
  menuitems_i18n___0[no_menuitems_i18n].pparam = (void const   *)((void *)0);
#line 1022
  menuitems_i18n___0[no_menuitems_i18n].function = (void (*)(void))((void *)0);
#line 1022
  no_menuitems_i18n ++;
#line 1023
  no_menuitems_i18n -= ui_no_menuitems_i18n;
#line 1024
  menu_add((menuitem const   *)(& menuitems_i18n___0[ui_no_menuitems_i18n]), no_menuitems_i18n);
#line 1025
  ui_no_menuitems_i18n += no_menuitems_i18n;
  }
#line 1026
  return;
}
}
#line 1029 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static menuitem *driveritems  ;
#line 1030 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_registermenus(void) 
{ 
  int i ;
  menuitem *item ;
  void *tmp ;

  {
  {
#line 1034
  menu_add((menuitem const   *)menuitems___0, (int )(sizeof(menuitems___0) / sizeof(menuitem )));
#line 1035
  tmp = malloc(sizeof(menuitem ) * (unsigned long )ndrivers);
#line 1035
  item = (menuitem *)tmp;
#line 1035
  driveritems = item;
#line 1036
  i = 0;
  }
  {
#line 1036
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1036
    if (! (i < (int )ndrivers)) {
#line 1036
      goto while_break;
    }
#line 1037
    (item + i)->menuname = "drivers";
#line 1038
    (item + i)->shortname = (char const   *)(drivers[i])->name;
#line 1039
    (item + i)->key = (char const   *)((void *)0);
#line 1040
    (item + i)->type = 3;
#line 1041
    (item + i)->flags = 98;
#line 1042
    (item + i)->iparam = i;
#line 1043
    (item + i)->name = (char const   *)(drivers[i])->name;
#line 1044
    (item + i)->function = (void (*)(void))(& ui_setdriver);
#line 1045
    (item + i)->control = (int (*)(void))(& ui_driverselected);
#line 1036
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1047
  menu_add((menuitem const   *)item, (int )ndrivers);
  }
#line 1048
  return;
}
}
#line 1050 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_unregistermenus(void) 
{ 


  {
  {
#line 1052
  menu_delete((menuitem const   *)menuitems___0, (int )(sizeof(menuitems___0) / sizeof(menuitem )));
#line 1053
  menu_delete((menuitem const   *)driveritems, (int )ndrivers);
#line 1054
  menu_delete((menuitem const   *)(menuitems_i18n___0), ui_no_menuitems_i18n);
#line 1055
  free((void *)driveritems);
  }
#line 1056
  return;
}
}
#line 1058 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
int number_six  =    6;
#line 1074 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int width ;
  int height ;
  char welcome[50] ;
  char language[11] ;
  char *locale ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char s[256] ;
  int i___0 ;
  int tmp___10 ;
  int y ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char home[256] ;
  char *env ;
  char *tmp___15 ;
  int maxsize ;
  size_t tmp___16 ;
  int i___1 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  char *tmp___21 ;
  time_t tmp___22 ;
  xio_file f ;
  xio_file tmp___23 ;
  menuitem const   *item ;
  dialogparam *d ;
  char *tmp___24 ;
  int c ;
  int x ;
  int y___0 ;
  int b ;
  int k ;
  int linesize ;
  int size ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int x___0 ;
  int y___1 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;

  {
  {
#line 1091
  strcpy((char */* __restrict  */)(language), (char const   */* __restrict  */)"english");
#line 1094
  locale = setlocale(6, "");
  }
#line 1095
  if ((unsigned long )locale == (unsigned long )((void *)0)) {
    {
#line 1096
    printf((char const   */* __restrict  */)"An error occured in your setlocale/gettext installation.\n");
#line 1098
    printf((char const   */* __restrict  */)"I18n menus will not be available.\n");
    }
  }
#line 1122
  if ((unsigned long )locale == (unsigned long )((void *)0)) {
    {
#line 1123
    locale = getenv("LANG");
    }
  } else {
    {
#line 1122
    tmp = strcmp((char const   *)locale, "C");
    }
#line 1122
    if (tmp == 0) {
      {
#line 1123
      locale = getenv("LANG");
      }
    } else {
      {
#line 1125
      locale = setlocale(5, "");
      }
    }
  }
#line 1132
  if ((unsigned long )locale != (unsigned long )((void *)0)) {
    {
#line 1133
    tmp___0 = strlen((char const   *)locale);
    }
#line 1133
    if (tmp___0 > 2UL) {
#line 1134
      *(locale + 2) = (char )'\000';
    }
    {
#line 1135
    tmp___1 = strcmp((char const   *)locale, "hu");
    }
#line 1135
    if (tmp___1 == 0) {
      {
#line 1136
      strcpy((char */* __restrict  */)(language), (char const   */* __restrict  */)"magyar");
      }
    }
    {
#line 1137
    tmp___2 = strcmp((char const   *)locale, "cs");
    }
#line 1137
    if (tmp___2 == 0) {
      {
#line 1138
      strcpy((char */* __restrict  */)(language), (char const   */* __restrict  */)"cesky");
      }
    }
    {
#line 1139
    tmp___3 = strcmp((char const   *)locale, "de");
    }
#line 1139
    if (tmp___3 == 0) {
      {
#line 1140
      strcpy((char */* __restrict  */)(language), (char const   */* __restrict  */)"deutsch");
      }
    }
    {
#line 1141
    tmp___4 = strcmp((char const   *)locale, "es");
    }
#line 1141
    if (tmp___4 == 0) {
      {
#line 1142
      strcpy((char */* __restrict  */)(language), (char const   */* __restrict  */)"espanhol");
      }
    }
    {
#line 1143
    tmp___5 = strcmp((char const   *)locale, "fr");
    }
#line 1143
    if (tmp___5 == 0) {
      {
#line 1144
      strcpy((char */* __restrict  */)(language), (char const   */* __restrict  */)"francais");
      }
    }
    {
#line 1145
    tmp___6 = strcmp((char const   *)locale, "ro");
    }
#line 1145
    if (tmp___6 == 0) {
      {
#line 1146
      strcpy((char */* __restrict  */)(language), (char const   */* __restrict  */)"romanian");
      }
    }
    {
#line 1147
    tmp___7 = strcmp((char const   *)locale, "it");
    }
#line 1147
    if (tmp___7 == 0) {
      {
#line 1148
      strcpy((char */* __restrict  */)(language), (char const   */* __restrict  */)"italiano");
      }
    }
    {
#line 1149
    tmp___8 = strcmp((char const   *)locale, "pt");
    }
#line 1149
    if (tmp___8 == 0) {
      {
#line 1150
      strcpy((char */* __restrict  */)(language), (char const   */* __restrict  */)"portuguese");
      }
    }
  }
  {
#line 1159
  setlocale(1, "C");
#line 1163
  bindtextdomain("xaos", "/usr/share/locale");
#line 1188
  bind_textdomain_codeset("xaos", "UTF-8");
#line 1190
  textdomain("xaos");
#line 1193
  xio_init((char const   *)*(argv + 0));
#line 1194
  params_register(global_params);
#line 1195
  params_register(ui_fractal_params);
#line 1196
  uih_registermenudialogs_i18n();
#line 1199
  uih_registermenus_i18n();
#line 1200
  uih_registermenus();
#line 1201
  ui_registermenus();
#line 1202
  ui_registermenus_i18n();
#line 1203
  i = 0;
  }
  {
#line 1203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1203
    if (! (i < (int )ndrivers)) {
#line 1203
      goto while_break;
    }
    {
#line 1204
    params_register((struct params  const  *)(drivers[i])->params);
#line 1203
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1211
  prog_argc = argc;
#line 1212
  prog_argv = argv;
#line 1213
  tmp___9 = params_parser(argc, argv);
  }
#line 1213
  if (! tmp___9) {
    {
#line 1214
    ui_unregistermenus();
#line 1215
    uih_unregistermenus();
#line 1216
    xio_uninit();
#line 1217
    exit(-1);
    }
  }
  {
#line 1227
  signal(8, (void (*)(int  ))1);
  }
#line 1230
  if (printconfig) {
    {
#line 1232
    x_message((char *)"XaoS configuration\nVersion:   %s\nType size: %i\ninteger size: %i\nconfigfile: %s\nusing alloca\nusing long double\nusing gettimeofday\nusing ftime\nassertions disabled\n",
              "3.5", (int )sizeof(long double ), (int )sizeof(int ), ".XaoSrc");
    }
  }
#line 1276
  if (deflist) {
#line 1276
    goto _L;
  } else
#line 1276
  if (printconfig) {
    _L: /* CIL Label */ 
    {
#line 1278
    strcpy((char */* __restrict  */)(s), (char const   */* __restrict  */)"Available drivers: ");
#line 1279
    i = 0;
    }
    {
#line 1279
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1279
      if (! (i < (int )ndrivers)) {
#line 1279
        goto while_break___0;
      }
      {
#line 1280
      strcat((char */* __restrict  */)(s), (char const   */* __restrict  */)(drivers[i])->name);
      }
#line 1281
      if (i < (int )(ndrivers - 1)) {
        {
#line 1282
        strcat((char */* __restrict  */)(s), (char const   */* __restrict  */)", ");
        }
      }
#line 1279
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1284
    x_message(s);
#line 1285
    ui_unregistermenus();
#line 1286
    uih_unregistermenus();
#line 1287
    xio_uninit();
#line 1288
    exit(0);
    }
  }
  {
#line 1294
  tmp___10 = ui_dorender_params();
#line 1294
  i___0 = tmp___10;
  }
#line 1295
  if (i___0) {
    {
#line 1296
    ui_unregistermenus();
#line 1297
    uih_unregistermenus();
#line 1298
    xio_uninit();
#line 1299
    exit(i___0 - 1);
    }
  }
#line 1302
  if ((unsigned long )defdriver != (unsigned long )((void *)0)) {
#line 1303
    i = 0;
    {
#line 1303
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1303
      if (! (i < (int )ndrivers)) {
#line 1303
        goto while_break___1;
      }
#line 1305
      y = 0;
      {
#line 1305
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1305
        tmp___11 = tolower((int )*((drivers[i])->name + y));
#line 1305
        tmp___12 = tolower((int )*(defdriver + y));
        }
#line 1305
        if (tmp___11 == tmp___12) {
#line 1305
          if (! ((int const   )*((drivers[i])->name + y) != 0)) {
#line 1305
            goto while_break___2;
          }
        } else {
#line 1305
          goto while_break___2;
        }
#line 1305
        y ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1308
      if ((int const   )*((drivers[i])->name + y) == 0) {
        {
#line 1309
        driver = (struct ui_driver  const  *)drivers[i];
#line 1310
        tmp___13 = (*(driver->init))();
        }
#line 1310
        if (tmp___13) {
#line 1311
          goto while_break___1;
        } else {
          {
#line 1313
          x_fatalerror((char *)"Can not initialize %s driver", defdriver);
          }
        }
      }
#line 1303
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1318
    if (i == (int )ndrivers) {
      {
#line 1319
      x_fatalerror((char *)"Unknown driver %s", defdriver);
      }
    }
  } else {
#line 1322
    i = 0;
    {
#line 1322
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1322
      if (! (i < (int )ndrivers)) {
#line 1322
        goto while_break___3;
      }
      {
#line 1323
      driver = (struct ui_driver  const  *)drivers[i];
#line 1324
      tmp___14 = (*(driver->init))();
      }
#line 1324
      if (tmp___14) {
#line 1325
        goto while_break___3;
      }
#line 1322
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1327
    if (i == (int )ndrivers) {
      {
#line 1328
      x_fatalerror((char *)"Can not initialize driver");
      }
    }
  }
  {
#line 1334
  (*(driver->getsize))(& width, & height);
#line 1338
  mousetype(1);
#line 1339
  (*(driver->print))(0, 0, "Initializing. Please wait");
#line 1340
  (*(driver->print))(0, (int )driver->textheight, "Creating framebuffer");
  }
#line 1341
  if (driver->flush) {
    {
#line 1341
    (*(driver->flush))();
    }
  }
  {
#line 1342
  ui_mkimages(width, height);
#line 1344
  (*(driver->print))(0, (int )(driver->textheight * 2), "Initializing fractal engine");
  }
#line 1345
  if (driver->flush) {
    {
#line 1345
    (*(driver->flush))();
    }
  }
  {
#line 1348
  uih = uih_mkcontext((int )driver->flags, image, & ui_passfunc, & ui_message, & ui_updatemenus);
  }
#line 1352
  if (driver->gui_driver) {
#line 1352
    if ((driver->gui_driver)->setrootmenu) {
      {
#line 1353
      (*((driver->gui_driver)->setrootmenu))(uih, uih->menuroot);
      }
    }
  }
#line 1354
  if (driver->flush) {
    {
#line 1354
    (*(driver->flush))();
    }
  }
  {
#line 1356
  tmp___21 = getenv("HOME");
  }
#line 1356
  if ((unsigned long )tmp___21 != (unsigned long )((void *)0)) {
    {
#line 1357
    tmp___15 = getenv("HOME");
#line 1357
    env = tmp___15;
#line 1358
    tmp___16 = strlen(".XaoSrc");
#line 1358
    maxsize = (255 - (int )tmp___16) - 1;
#line 1360
    i___1 = 0;
    }
    {
#line 1360
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1360
      if (i___1 < maxsize) {
#line 1360
        if (! *(env + i___1)) {
#line 1360
          goto while_break___4;
        }
      } else {
#line 1360
        goto while_break___4;
      }
#line 1361
      home[i___1] = *(env + i___1);
#line 1360
      i___1 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1362
    home[i___1] = (char)0;
#line 1363
    strcpy((char */* __restrict  */)(configfile), (char const   */* __restrict  */)(home));
#line 1363
    tmp___17 = strlen((char const   *)(home));
    }
#line 1363
    if (tmp___17) {
      {
#line 1363
      tmp___18 = strlen((char const   *)(configfile));
      }
#line 1363
      if ((int )configfile[tmp___18 - 1UL] != 47) {
        {
#line 1363
        strcat((char */* __restrict  */)(configfile), (char const   */* __restrict  */)"/");
        }
      }
    }
    {
#line 1363
    strcat((char */* __restrict  */)(configfile), (char const   */* __restrict  */)".XaoSrc");
    }
  } else {
    {
#line 1366
    strcpy((char */* __restrict  */)(configfile), (char const   */* __restrict  */)"./");
#line 1366
    tmp___19 = strlen("./");
    }
#line 1366
    if (tmp___19) {
      {
#line 1366
      tmp___20 = strlen((char const   *)(configfile));
      }
#line 1366
      if ((int )configfile[tmp___20 - 1UL] != 47) {
        {
#line 1366
        strcat((char */* __restrict  */)(configfile), (char const   */* __restrict  */)"/");
        }
      }
    }
    {
#line 1366
    strcat((char */* __restrict  */)(configfile), (char const   */* __restrict  */)".XaoSrc");
    }
  }
#line 1367
  if (driver->flush) {
    {
#line 1367
    (*(driver->flush))();
    }
  }
  {
#line 1368
  tmp___22 = time((time_t *)((void *)0));
#line 1368
  srand((unsigned int )tmp___22);
#line 1369
  ((uih->fcontext)->version) ++;
#line 1370
  maintimer = tl_create_timer();
#line 1371
  arrowtimer = tl_create_timer();
#line 1372
  loopt = tl_create_timer();
#line 1373
  (*(driver->print))(0, (int )(driver->textheight * 3), "Loading message catalog");
  }
#line 1374
  if (driver->flush) {
    {
#line 1374
    (*(driver->flush))();
    }
  }
  {
#line 1375
  uih_loadcatalog(uih, (char const   *)(language));
#line 1376
  (*(driver->print))(0, (int )(driver->textheight * 4), "Initializing timming system");
  }
#line 1377
  if (driver->flush) {
    {
#line 1377
    (*(driver->flush))();
    }
  }
#line 1378
  uih->display = 1;
#line 1378
  if (uih->recalculatemode > 2) {
#line 1378
    uih->recalculatemode = uih->recalculatemode;
  } else {
#line 1378
    uih->recalculatemode = 2;
  }
  {
#line 1379
  tl_update_time();
#line 1381
  tl_reset_timer(maintimer);
#line 1382
  tl_reset_timer(arrowtimer);
  }
#line 1384
  if ((unsigned long )defpipe != (unsigned long )((void *)0)) {
    {
#line 1385
    (*(driver->print))(0, (int )(driver->textheight * 5), "Initializing pipe");
    }
#line 1386
    if (driver->flush) {
      {
#line 1386
      (*(driver->flush))();
      }
    }
    {
#line 1387
    ui_pipe_init((char const   *)defpipe);
    }
  }
  {
#line 1395
  (*(driver->print))(0, (int )(driver->textheight * 6), "Reading configuration file");
#line 1397
  tmp___23 = xio_ropen((xio_constpath )(configfile));
#line 1397
  f = tmp___23;
  }
#line 1398
  if ((unsigned long )f != (unsigned long )((void *)0)) {
    {
#line 1399
    uih_load(uih, f, (xio_constpath )(configfile));
    }
#line 1400
    if (uih->errstring) {
      {
#line 1401
      x_error((char *)"Configuration file %s load failed", configfile);
#line 1402
      uih_printmessages(uih);
#line 1403
      x_error((char *)"Hint:try to remove it :)");
#line 1404
      ui_doquit(1);
      }
    }
  }
  {
#line 1408
  (*(driver->print))(0, (int )(driver->textheight * 7), "Processing command line parameters");
  }
#line 1410
  if (driver->flush) {
    {
#line 1410
    (*(driver->flush))();
    }
  }
  {
#line 1414
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 1414
    item = menu_delqueue(& d);
    }
#line 1414
    if (! ((unsigned long )item != (unsigned long )((void *)0))) {
#line 1414
      goto while_break___5;
    }
    {
#line 1415
    uih_saveundo(uih);
#line 1416
    menu_activate(item, uih, d);
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1420
  tmp___24 = gettext("Welcome to XaoS version %s");
#line 1420
  sprintf((char */* __restrict  */)(welcome), (char const   */* __restrict  */)tmp___24,
          "3.5");
#line 1421
  uih_message(uih, (char const   *)(welcome));
  }
#line 1423
  if ((unsigned long )uih->updatemenus != (unsigned long )((void *)0)) {
    {
#line 1423
    (*(uih->updatemenus))(uih, (char const   *)driver->name);
    }
  }
#line 1424
  if (printspeed) {
    {
#line 1425
    c = 0;
#line 1427
    linesize = (uih->image)->bytesperpixel * (uih->image)->height;
#line 1428
    size = linesize * (uih->image)->height;
#line 1429
    (*(driver->print))(0, (int )(driver->textheight * 8), "Preparing for speedtest");
    }
#line 1430
    if (driver->flush) {
      {
#line 1430
      (*(driver->flush))();
      }
    }
    {
#line 1431
    uih->passfunc = (int (*)(struct uih_context * , int  , char const   * , float  ))((void *)0);
#line 1432
    tl_sleep(1000000);
#line 1433
    c = 0;
    }
    {
#line 1433
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1433
      if (! (c < 5)) {
#line 1433
        goto while_break___6;
      }
      {
#line 1434
      (*(driver->display))();
      }
#line 1434
      if (driver->flush) {
        {
#line 1434
        (*(driver->flush))();
        }
      }
#line 1433
      c ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 1435
    (*(driver->processevents))(0, & x, & y___0, & b, & k);
#line 1436
    (*(driver->print))(0, (int )(driver->textheight * 9), "Measuring dislay speed");
    }
#line 1437
    if (driver->flush) {
      {
#line 1437
      (*(driver->flush))();
      }
    }
    {
#line 1438
    tl_sleep(1000000);
#line 1439
    tl_update_time();
#line 1440
    tl_reset_timer(maintimer);
#line 1441
    c = 0;
    }
    {
#line 1442
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 1442
      tmp___25 = tl_lookup_timer(maintimer);
      }
#line 1442
      if (! (tmp___25 < 5000000)) {
#line 1442
        goto while_break___7;
      }
      {
#line 1443
      (*(driver->display))();
      }
#line 1443
      if (driver->flush) {
        {
#line 1443
        (*(driver->flush))();
        }
      }
      {
#line 1443
      (*(driver->processevents))(0, & x, & y___0, & b, & k);
#line 1443
      tl_update_time();
#line 1443
      c ++;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 1446
    x_message((char *)"Driver speed: %g FPS (%.4f MBPS)", (double )c / 5.0, ((((double )c * (double )size) / 5.0) / (double )1024) / (double )1024);
#line 1449
    (*(driver->print))(0, (int )(driver->textheight * 10), "Measuring memcpy speed");
    }
#line 1450
    if (driver->flush) {
      {
#line 1450
      (*(driver->flush))();
      }
    }
#line 1451
    c = 0;
    {
#line 1451
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1451
      if (! (c < 5)) {
#line 1451
        goto while_break___8;
      }
#line 1452
      x = 0;
      {
#line 1452
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1452
        if (! (x < (uih->image)->height)) {
#line 1452
          goto while_break___9;
        }
        {
#line 1453
        memcpy((void */* __restrict  */)*((uih->image)->currlines + y___0), (void const   */* __restrict  */)*((uih->image)->oldlines + y___0),
               (size_t )linesize);
#line 1452
        x ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 1451
      c ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 1456
    tl_update_time();
#line 1457
    tl_reset_timer(maintimer);
#line 1458
    c = 0;
    }
    {
#line 1459
    while (1) {
      while_continue___10: /* CIL Label */ ;
      {
#line 1459
      tmp___26 = tl_lookup_timer(maintimer);
      }
#line 1459
      if (! (tmp___26 < 5000000)) {
#line 1459
        goto while_break___10;
      }
#line 1460
      x = 0;
      {
#line 1460
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 1460
        if (! (x < (uih->image)->height)) {
#line 1460
          goto while_break___11;
        }
        {
#line 1461
        memcpy((void */* __restrict  */)*((uih->image)->currlines + y___0), (void const   */* __restrict  */)*((uih->image)->oldlines + y___0),
               (size_t )linesize);
#line 1460
        x ++;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 1463
      tl_update_time();
#line 1463
      c ++;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 1465
    x_message((char *)"Memcpy speed: %g FPS (%.4f MBPS)", (double )c / 5.0, ((((double )c * (double )size) / 5.0) / (double )1024) / (double )1024);
#line 1468
    (*(driver->print))(0, (int )(driver->textheight * 10), "Measuring missaligned memcpy speed");
#line 1470
    tl_update_time();
#line 1471
    tl_reset_timer(maintimer);
#line 1472
    c = 0;
    }
    {
#line 1473
    while (1) {
      while_continue___12: /* CIL Label */ ;
      {
#line 1473
      tmp___27 = tl_lookup_timer(maintimer);
      }
#line 1473
      if (! (tmp___27 < 5000000)) {
#line 1473
        goto while_break___12;
      }
#line 1474
      x = 0;
      {
#line 1474
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 1474
        if (! (x < (uih->image)->height)) {
#line 1474
          goto while_break___13;
        }
        {
#line 1475
        memcpy((void */* __restrict  */)(*((uih->image)->currlines + y___0) + 1),
               (void const   */* __restrict  */)(*((uih->image)->oldlines + y___0) + 2),
               (size_t )(linesize - 2));
#line 1474
        x ++;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
      {
#line 1477
      tl_update_time();
#line 1477
      c ++;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 1479
    x_message((char *)"Missaligned memcpy speed: %g FPS (%.4f MBPS)", (double )c / 5.0,
              ((((double )c * (double )size) / 5.0) / (double )1024) / (double )1024);
#line 1482
    (*(driver->print))(0, (int )(driver->textheight * 10), "Measuring size6 memcpy speed");
#line 1483
    tl_update_time();
#line 1484
    tl_reset_timer(maintimer);
#line 1485
    c = 0;
    }
    {
#line 1486
    while (1) {
      while_continue___14: /* CIL Label */ ;
      {
#line 1486
      tmp___28 = tl_lookup_timer(maintimer);
      }
#line 1486
      if (! (tmp___28 < 5000000)) {
#line 1486
        goto while_break___14;
      }
#line 1488
      y___1 = 0;
      {
#line 1488
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 1488
        if (! (y___1 < (uih->image)->height)) {
#line 1488
          goto while_break___15;
        }
#line 1489
        x___0 = 0;
        {
#line 1489
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 1489
          if (! (x___0 < linesize - 6)) {
#line 1489
            goto while_break___16;
          }
          {
#line 1490
          memcpy((void */* __restrict  */)(*((uih->image)->currlines + y___1) + x___0),
                 (void const   */* __restrict  */)(*((uih->image)->oldlines + y___1) + x___0),
                 (size_t )number_six);
#line 1489
          x___0 += 6;
          }
        }
        while_break___16: /* CIL Label */ ;
        }
#line 1488
        y___1 ++;
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 1493
      tl_update_time();
#line 1493
      c ++;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 1495
    x_message((char *)"Size 6 memcpy speed: %g FPS (%.4f MBPS)", (double )c / 5.0,
              ((((double )c * (double )size) / 5.0) / (double )1024) / (double )1024);
#line 1498
    (*(driver->display))();
#line 1499
    (*(driver->print))(0, (int )(driver->textheight * 11), "Measuring calculation speed");
    }
#line 1500
    if (driver->flush) {
      {
#line 1500
      (*(driver->flush))();
      }
    }
    {
#line 1501
    speed_test(uih->fcontext, image);
#line 1502
    (*(driver->print))(0, (int )(driver->textheight * 12), "Measuring new image calculation loop");
    }
#line 1504
    if (driver->flush) {
      {
#line 1504
      (*(driver->flush))();
      }
    }
    {
#line 1505
    uih_prepare_image(uih);
#line 1506
    tl_update_time();
#line 1507
    tl_reset_timer(maintimer);
#line 1508
    c = 0;
    }
    {
#line 1508
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 1508
      if (! (c < 5)) {
#line 1508
        goto while_break___17;
      }
#line 1509
      uih->display = 1;
#line 1509
      if (uih->recalculatemode > 2) {
#line 1509
        uih->recalculatemode = uih->recalculatemode;
      } else {
#line 1509
        uih->recalculatemode = 2;
      }
      {
#line 1509
      ((uih->fcontext)->version) ++;
#line 1509
      uih_prepare_image(uih);
#line 1508
      c ++;
      }
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 1511
    (*(driver->display))();
    }
#line 1512
    if (driver->flush) {
      {
#line 1512
      (*(driver->flush))();
      }
    }
    {
#line 1513
    tmp___29 = tl_lookup_timer(maintimer);
#line 1513
    tmp___30 = tl_lookup_timer(maintimer);
#line 1513
    x_message((char *)"New image caluclation took %g seconds (%.2g fps)", ((double )tmp___30 / 5.0) / 1000000.0,
              5000000.0 / (double )tmp___29);
#line 1516
    tl_update_time();
#line 1517
    c = 0;
    }
    {
#line 1517
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 1517
      if (! (c < 5)) {
#line 1517
        goto while_break___18;
      }
#line 1518
      uih->display = 1;
#line 1518
      if (uih->recalculatemode > 1) {
#line 1518
        uih->recalculatemode = uih->recalculatemode;
      } else {
#line 1518
        uih->recalculatemode = 1;
      }
      {
#line 1518
      uih_prepare_image(uih);
#line 1518
      c ++;
#line 1517
      c ++;
      }
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 1519
    c = 0;
#line 1520
    tl_update_time();
#line 1521
    tl_reset_timer(maintimer);
#line 1522
    (*(driver->print))(0, (int )(driver->textheight * 13), "Measuring zooming algorithm loop");
    }
#line 1524
    if (driver->flush) {
      {
#line 1524
      (*(driver->flush))();
      }
    }
    {
#line 1525
    while (1) {
      while_continue___19: /* CIL Label */ ;
      {
#line 1525
      tmp___31 = tl_lookup_timer(maintimer);
      }
#line 1525
      if (! (tmp___31 < 5000000)) {
#line 1525
        goto while_break___19;
      }
#line 1526
      uih->display = 1;
#line 1526
      if (uih->recalculatemode > 1) {
#line 1526
        uih->recalculatemode = uih->recalculatemode;
      } else {
#line 1526
        uih->recalculatemode = 1;
      }
      {
#line 1526
      uih_prepare_image(uih);
#line 1526
      tl_update_time();
#line 1526
      c ++;
      }
    }
    while_break___19: /* CIL Label */ ;
    }
    {
#line 1528
    x_message((char *)"Approximation loop speed: %g FPS", (double )c / 5.0);
#line 1529
    ui_doquit(0);
    }
  }
  {
#line 1551
  (*(driver->print))(0, (int )(driver->textheight * 8), "Entering main loop");
  }
#line 1552
  if (driver->flush) {
    {
#line 1552
    (*(driver->flush))();
    }
  }
  {
#line 1553
  main_loop();
#line 1554
  ui_quit();
  }
#line 1556
  return (0);
}
}
#line 1559 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_mkimages(int w , int h ) 
{ 
  struct palette *palette ;
  int scanline ;
  int width ;
  int height ;
  union paletteinfo info ;
  char *b1 ;
  char *b2 ;
  char *tmp ;
  void (*tmp___0)(struct palette *pal , int start , int end , rgb_t *rgb1 ) ;
  int (*tmp___1)(struct palette *pal , int init , int r , int g , int b ) ;
  int tmp___2 ;
  char *tmp___3 ;
  float tmp___4 ;
  float tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;

  {
#line 1566
  width = w;
#line 1567
  height = h;
#line 1568
  if (resizeregistered) {
#line 1568
    if (! (driver->flags & 16384)) {
      {
#line 1569
      menu_delete((menuitem const   *)resizeitems, ui_no_resizeitems);
#line 1570
      resizeregistered = 0;
      }
    } else {
#line 1568
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1572
  if (! resizeregistered) {
#line 1572
    if (driver->flags & 16384) {
      {
#line 1573
      add_resizeitems();
#line 1574
      resizeregistered = 1;
      }
    }
  }
  {
#line 1577
  scanline = (*(driver->alloc_buffers))(& b1, & b2);
  }
#line 1577
  if (! scanline) {
    {
#line 1578
    (*(driver->uninit))();
#line 1579
    tmp = gettext("Can not allocate buffers");
#line 1579
    x_error(tmp);
#line 1580
    ui_outofmem();
#line 1581
    exit(-1);
    }
  }
#line 1583
  info.truec.rmask = (unsigned int )driver->rmask;
#line 1584
  info.truec.gmask = (unsigned int )driver->gmask;
#line 1585
  info.truec.bmask = (unsigned int )driver->bmask;
#line 1586
  if ((unsigned long )driver->set_range != (unsigned long )((void *)0)) {
#line 1586
    tmp___0 = & ui_setpalette;
  } else {
#line 1586
    tmp___0 = (void (*)(struct palette *pal , int start , int end , rgb_t *rgb1 ))((void *)0);
  }
#line 1586
  if ((unsigned long )driver->set_color != (unsigned long )((void *)0)) {
#line 1586
    tmp___1 = & ui_alloccolor;
  } else {
#line 1586
    tmp___1 = (int (*)(struct palette *pal , int init , int r , int g , int b ))((void *)0);
  }
#line 1586
  if (driver->flags & 1) {
#line 1586
    tmp___2 = 1;
  } else {
#line 1586
    tmp___2 = 0;
  }
  {
#line 1586
  palette = createpalette((int )driver->palettestart, (int )driver->paletteend, (int )driver->imagetype,
                          tmp___2, (int )driver->maxentries, tmp___1, tmp___0, (void (*)(struct palette *pal ))((void *)0),
                          (void (*)(struct palette *pal , int direction ))((void *)0),
                          & info);
  }
#line 1595
  if (! palette) {
    {
#line 1596
    (*(driver->uninit))();
#line 1597
    tmp___3 = gettext("Can not create palette");
#line 1597
    x_error(tmp___3);
#line 1598
    ui_outofmem();
#line 1599
    exit(-1);
    }
  }
  {
#line 1601
  tmp___4 = get_windowheight(height);
#line 1601
  tmp___5 = get_windowwidth(width);
  }
#line 1601
  if (driver->flags & 8192) {
#line 1601
    tmp___6 = 4;
  } else {
#line 1601
    tmp___6 = 0;
  }
  {
#line 1601
  image = create_image_cont(width, height, scanline, 2, (unsigned char *)b1, (unsigned char *)b2,
                            palette, & ui_flip, tmp___6, tmp___5 / (float )width,
                            tmp___4 / (float )height);
  }
#line 1607
  if (! image) {
    {
#line 1608
    (*(driver->uninit))();
#line 1609
    tmp___7 = gettext("Can not create image");
#line 1609
    x_error(tmp___7);
#line 1610
    ui_outofmem();
#line 1611
    exit(-1);
    }
  }
#line 1613
  return;
}
}
#line 1615 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
void ui_resize(void) 
{ 
  int w ;
  int h ;
  char *tmp ;
  int tmp___0 ;

  {
#line 1618
  if (uih->incalculation) {
    {
#line 1619
    uih_interrupt(uih);
    }
#line 1620
    return;
  }
  {
#line 1622
  ui_closemenus();
#line 1623
  ui_closedialog(0);
#line 1624
  ui_close_help();
#line 1625
  uih_clearwindows(uih);
#line 1626
  uih_stoptimers(uih);
#line 1627
  uih_cycling_stop(uih);
#line 1628
  uih_savepalette(uih);
#line 1629
  (*(driver->getsize))(& w, & h);
  }
#line 1631
  if (w != (uih->image)->width) {
#line 1631
    goto _L;
  } else
#line 1631
  if (h != (uih->image)->height) {
#line 1631
    goto _L;
  } else
#line 1631
  if (driver->flags & 8) {
#line 1631
    goto _L;
  } else
#line 1631
  if ((uih->palette)->type != (int )driver->imagetype) {
    _L: /* CIL Label */ 
    {
#line 1634
    (*(driver->free_buffers))((char *)((void *)0), (char *)((void *)0));
#line 1635
    destroy_image(uih->image);
#line 1636
    destroypalette(uih->palette);
#line 1637
    ui_mkimages(w, h);
#line 1638
    tmp___0 = uih_updateimage(uih, image);
    }
#line 1638
    if (! tmp___0) {
      {
#line 1639
      (*(driver->uninit))();
#line 1640
      tmp = gettext("Can not allocate tables");
#line 1640
      x_error(tmp);
#line 1641
      ui_outofmem();
#line 1642
      exit(-1);
      }
    }
    {
#line 1644
    tl_process_group(syncgroup, (int *)((void *)0));
#line 1645
    tl_reset_timer(maintimer);
#line 1646
    tl_reset_timer(arrowtimer);
#line 1647
    uih->display = 1;
    }
#line 1647
    if (uih->recalculatemode > 2) {
#line 1647
      uih->recalculatemode = uih->recalculatemode;
    } else {
#line 1647
      uih->recalculatemode = 2;
    }
  }
#line 1649
  uih->display = 1;
#line 1649
  if (uih->recalculatemode > 2) {
#line 1649
    uih->recalculatemode = uih->recalculatemode;
  } else {
#line 1649
    uih->recalculatemode = 2;
  }
  {
#line 1650
  uih_restorepalette(uih);
#line 1652
  uih->display = 1;
#line 1653
  uih_cycling_continue(uih);
  }
#line 1654
  return;
}
}
#line 1656 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void ui_driver(int d ) 
{ 
  struct ui_driver  const  *driver1 ;
  int width ;
  int height ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1660
  ui_closemenus();
#line 1661
  ui_closedialog(0);
#line 1662
  ui_close_help();
  }
#line 1663
  if (d < 0) {
#line 1664
    d = 0;
  }
#line 1665
  if (d >= (int )ndrivers) {
#line 1666
    d = (int )(ndrivers - 1);
  }
  {
#line 1667
  uih_stoptimers(uih);
#line 1668
  driver1 = driver;
#line 1669
  uih_clearwindows(uih);
#line 1670
  uih_cycling_off(uih);
#line 1671
  uih_savepalette(uih);
#line 1672
  (*(driver->free_buffers))((char *)((void *)0), (char *)((void *)0));
#line 1673
  (*(driver->uninit))();
#line 1674
  driver = (struct ui_driver  const  *)drivers[d];
#line 1675
  tmp___2 = (*(driver->init))();
  }
#line 1675
  if (! tmp___2) {
    {
#line 1676
    driver = driver1;
#line 1677
    tmp = gettext("Can not initialize driver");
#line 1677
    uih_error(uih, (char const   *)tmp);
#line 1678
    tmp___1 = (*(driver1->init))();
    }
#line 1678
    if (tmp___1) {
#line 1682
      driver = driver1;
    } else {
      {
#line 1679
      tmp___0 = gettext("Can not return back to previous driver");
#line 1679
      x_fatalerror(tmp___0);
      }
    }
  }
  {
#line 1684
  (*(driver->getsize))(& width, & height);
#line 1685
  destroy_image(uih->image);
#line 1686
  destroypalette(uih->palette);
#line 1687
  uih->flags = (int )driver->flags;
#line 1688
  ui_mkimages(width, height);
#line 1689
  tmp___4 = uih_updateimage(uih, image);
  }
#line 1689
  if (! tmp___4) {
    {
#line 1690
    (*(driver->uninit))();
#line 1691
    tmp___3 = gettext("Can not allocate tables");
#line 1691
    x_error(tmp___3);
#line 1692
    ui_outofmem();
#line 1693
    exit(-1);
    }
  }
#line 1695
  if (driver->gui_driver) {
#line 1695
    if ((driver->gui_driver)->setrootmenu) {
      {
#line 1696
      (*((driver->gui_driver)->setrootmenu))(uih, uih->menuroot);
      }
    }
  }
  {
#line 1697
  tl_process_group(syncgroup, (int *)((void *)0));
#line 1698
  tl_reset_timer(maintimer);
#line 1699
  tl_reset_timer(arrowtimer);
#line 1700
  uih->display = 1;
#line 1701
  uih->display = 1;
  }
#line 1701
  if (uih->recalculatemode > 2) {
#line 1701
    uih->recalculatemode = uih->recalculatemode;
  } else {
#line 1701
    uih->recalculatemode = 2;
  }
  {
#line 1702
  uih_restorepalette(uih);
#line 1703
  ui_updatestatus();
  }
#line 1704
  if ((unsigned long )uih->updatemenus != (unsigned long )((void *)0)) {
    {
#line 1704
    (*(uih->updatemenus))(uih, (char const   *)driver->name);
    }
  }
#line 1705
  return;
}
}
#line 1707
static  __attribute__((__noreturn__)) void main_loop(void) ;
#line 1707 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/ui.c"
static void main_loop(void) 
{ 
  int inmovement ;
  int x ;
  int y ;
  int b ;
  int k ;
  int time___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1709
  inmovement = 1;
#line 1712
  if (! inmovement) {
#line 1712
    if (! uih->inanimation) {
#line 1712
      tmp = 1;
    } else {
#line 1712
      tmp = 0;
    }
  } else {
#line 1712
    tmp = 0;
  }
  {
#line 1712
  (*(driver->processevents))(tmp, & x, & y, & b, & k);
  }
  {
#line 1714
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1715
    if (uih->play) {
#line 1715
      tmp___1 = 2;
    } else {
#line 1715
      if (uih->inhibittextoutput) {
#line 1715
        tmp___0 = 3;
      } else {
#line 1715
        tmp___0 = 0;
      }
#line 1715
      tmp___1 = tmp___0;
    }
    {
#line 1715
    mousetype(tmp___1);
    }
#line 1717
    if (uih->display) {
      {
#line 1718
      uih_prepare_image(uih);
#line 1719
      ui_updatestatus();
      }
    }
    {
#line 1721
    time___0 = tl_process_group(syncgroup, (int *)((void *)0));
    }
#line 1721
    if (time___0 != -1) {
#line 1722
      if (! inmovement) {
#line 1722
        if (! uih->inanimation) {
#line 1723
          if (time___0 > 20000) {
#line 1724
            time___0 = 20000;
          }
#line 1725
          if (time___0 > delaytime) {
            {
#line 1726
            tl_sleep(time___0 - delaytime);
#line 1727
            tl_update_time();
            }
          }
        }
      }
#line 1730
      inmovement = 1;
    }
#line 1732
    if (delaytime) {
#line 1732
      goto _L;
    } else
#line 1732
    if (maxframerate) {
      _L: /* CIL Label */ 
      {
#line 1733
      tl_update_time();
#line 1734
      time___0 = tl_lookup_timer(loopt);
#line 1735
      tl_reset_timer(loopt);
#line 1736
      time___0 = 1000000 / maxframerate - time___0;
      }
#line 1737
      if (time___0 < delaytime) {
#line 1738
        time___0 = delaytime;
      }
#line 1739
      if (time___0) {
        {
#line 1740
        tl_sleep(time___0);
#line 1741
        tl_update_time();
        }
      }
    }
    {
#line 1744
    processbuffer();
    }
#line 1745
    if (! inmovement) {
#line 1745
      if (! uih->inanimation) {
#line 1745
        tmp___2 = 1;
      } else {
#line 1745
        tmp___2 = 0;
      }
    } else {
#line 1745
      tmp___2 = 0;
    }
    {
#line 1745
    (*(driver->processevents))(tmp___2, & x, & y, & b, & k);
#line 1748
    inmovement = 0;
#line 1749
    ui_mouse(x, y, b, k);
    }
#line 1750
    if (todriver) {
      {
#line 1751
      ui_driver(todriver - 1);
#line 1751
      todriver = 0;
      }
    }
#line 1752
    if (callresize) {
      {
#line 1753
      ui_resize();
#line 1753
      callresize = 0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 60 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atan2)(double __y ,
                                                                               double __x )  __asm__("__atan2_finite")  ;
#line 100
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) exp)(double __x )  __asm__("__exp_finite")  ;
#line 153
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y )  __asm__("__pow_finite")  ;
#line 212 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/filter.h"
extern struct filter *createfilter(struct filteraction  const  *fa ) ;
#line 213
extern struct queue *create_queue(struct filter *f ) ;
#line 214
extern void insertfilter(struct filter *f1 , struct filter *f2 ) ;
#line 215
extern void removefilter(struct filter *f ) ;
#line 216
extern void addfilter(struct filter *f1 , struct filter *f2 ) ;
#line 217
extern int initqueue(struct queue *q ) ;
#line 256
extern void clear_image(struct image *img ) ;
#line 284
extern void preallocpalette(struct palette *pal ) ;
#line 285
extern struct palette *clonepalette(struct palette *palette ) ;
#line 286
extern void restorepalette(struct palette *dest , struct palette *src ) ;
#line 287
extern void convertupgeneric(struct filter *f , int *x , int *y ) ;
#line 288
extern void convertdowngeneric(struct filter *f , int *x , int *y ) ;
#line 153 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/fractal.h"
extern void fractalc_resize_to(fractal_context * , float  , float  ) ;
#line 154
extern void update_view(fractal_context * ) ;
#line 155
extern void free_fractalc(fractal_context * ) ;
#line 37 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/timers.h"
extern tl_group *tl_create_group(void) ;
#line 47
extern void tl_free_group(tl_group *timer ) ;
#line 49
extern void tl_resume_timer(tl_timer *t ) ;
#line 58
extern struct timeemulator *tl_create_emulator(void) ;
#line 59
extern void tl_free_emulator(struct timeemulator *t ) ;
#line 60
extern void tl_elpased(struct timeemulator *t , int elpased ) ;
#line 61
extern void tl_emulate_timer(struct timer *t , struct timeemulator *e ) ;
#line 62
extern void tl_unemulate_timer(struct timer *t ) ;
#line 85 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xio.h"
extern xio_file xio_strropen(char const   *c ) ;
#line 86
extern xio_file xio_strwopen(void) ;
#line 87
extern char *xio_getstring(xio_file f ) ;
#line 364 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui_helper.h"
void uih_callcomplette(uih_context *c ) ;
#line 370
void uih_loadpalette(uih_context *c , struct palette *palette ) ;
#line 379
char const   *uih_save(struct uih_context *c , xio_constpath filename___0 ) ;
#line 380
void uih_tbreak(uih_context *c ) ;
#line 382
void uih_do_fractal(uih_context *c ) ;
#line 385
void uih_stopzooming(uih_context *c ) ;
#line 402
int uih_cycling(struct uih_context *uih___2 , int mode ) ;
#line 407
void uih_perbutation(uih_context *c , int mousex , int mousey ) ;
#line 415
void uih_setmandelbrot(uih_context *c , int mode , int mousex , int mousey ) ;
#line 423
int uih_setjuliamode(uih_context *c , int mode ) ;
#line 461
void uih_resumetimers(uih_context *c ) ;
#line 462
void uih_slowdowntimers(uih_context *c , int time___0 ) ;
#line 473
void uih_fastrotatedisable(uih_context *c ) ;
#line 514
void uih_constantframetime(uih_context *c , int time___0 ) ;
#line 515
void uih_noconstantframetime(uih_context *c ) ;
#line 32 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/zoom.h"
extern struct filteraction  const  zoom_filter ;
#line 34
extern struct filteraction  const  subwindow_filter ;
#line 35
extern void subwindow_setsecond(struct filter *f , struct filter *f1 ) ;
#line 46 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/plane.h"
extern void recalculate(int plane , number_t * , number_t * ) ;
#line 29 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/autopilot.h"
void do_autopilot(uih_context *context , int *x , int *y , int *controls , void (*changed___0)(void) ,
                  int times ) ;
#line 31
void clean_autopilot(uih_context *context ) ;
#line 31 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/grlib.h"
extern void xprepareimage(struct image *img ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/misc-f.h"
extern char const   *writepng(FILE *file , struct image  const  *image ) ;
#line 58 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static struct filter *uih_getinstance(struct filteraction  const  *a ) ;
#line 59
static void uih_destroyinstance(struct filter *f ) ;
#line 60
static int uih_require(struct filter *f , struct requirements *r ) ;
#line 61
static int uih_initialize(struct filter *f , struct initdata *i ) ;
#line 62 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static rgb_t const   uicolors[6]  = { {        (unsigned char)0,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)255,        (unsigned char)255,        (unsigned char)255}, 
   {        (unsigned char)255,        (unsigned char)65,        (unsigned char)0}, 
   {        (unsigned char)64,        (unsigned char)64,        (unsigned char)64}, 
   {        (unsigned char)128,        (unsigned char)128,        (unsigned char)128}, 
   {        (unsigned char)192,        (unsigned char)192,        (unsigned char)192}};
#line 71 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static rgb_t const   uibwcolors[6]  = { {        (unsigned char)0,        (unsigned char)0,        (unsigned char)0}, 
   {        (unsigned char)255,        (unsigned char)255,        (unsigned char)255}, 
   {        (unsigned char)255,        (unsigned char)255,        (unsigned char)255}, 
   {        (unsigned char)255,        (unsigned char)255,        (unsigned char)255}, 
   {        (unsigned char)255,        (unsigned char)255,        (unsigned char)255}, 
   {        (unsigned char)255,        (unsigned char)255,        (unsigned char)255}};
#line 80 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static struct filteraction  const  uih_filter  = 
#line 80
     {"XaoS\'s user interface layer", "ui", 0, & uih_getinstance, & uih_destroyinstance,
    (int (*)(struct filter *f , int flags , int time ))((void *)0), & uih_require,
    & uih_initialize, & convertupgeneric, & convertdowngeneric, (void (*)(struct filter *f ))((void *)0)};
#line 94 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static uih_context *uih___0  ;
#line 95 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static int waitcount  ;
#line 95 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static int waitcount1  ;
#line 95 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static int waitcount2  ;
#line 97
extern struct filteraction  const  interlace_filter ;
#line 97
extern struct filteraction  const  stereogram_filter ;
#line 97
extern struct filteraction  const  smalliter_filter ;
#line 97
extern struct filteraction  const  julia_filter ;
#line 97
extern struct filteraction  const  blur_filter ;
#line 97
extern struct filteraction  const  edge_filter ;
#line 97
extern struct filteraction  const  edge2_filter ;
#line 97
extern struct filteraction  const  rotate_filter ;
#line 97
extern struct filteraction  const  starfield_filter ;
#line 97
extern struct filteraction  const  truecolor_filter ;
#line 97
extern struct filteraction  const  fixedcolor_filter ;
#line 97
extern struct filteraction  const  bitmap_filter ;
#line 97
extern struct filteraction  const  emboss_filter ;
#line 97
struct filteraction  const  palette_filter ;
#line 97
extern struct filteraction antialias_filter ;
#line 97
extern struct filteraction  const  threed_filter ;
#line 103 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
struct filteraction  const  * const  uih_filters[20]  = 
#line 103
  {      (struct filteraction  const  */* const  */)(& edge_filter),      (struct filteraction  const  */* const  */)(& edge2_filter),      (struct filteraction  const  */* const  */)(& threed_filter),      (struct filteraction  const  */* const  */)(& starfield_filter), 
        (struct filteraction  const  */* const  */)(& stereogram_filter),      (struct filteraction  const  */* const  */)(& interlace_filter),      (struct filteraction  const  */* const  */)(& blur_filter),      (struct filteraction  const  */* const  */)(& emboss_filter), 
        (struct filteraction  const  */* const  */)(& palette_filter),      (struct filteraction  const  */* const  */)(& antialias_filter),      (struct filteraction  const  */* const  */)(& truecolor_filter),      (struct filteraction  const  */* const  */)((void *)0)};
#line 118 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
int const   uih_nfilters  =    (int const   )11;
#line 120 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static void uih_invalidatepos(uih_context *uih___2 ) 
{ 


  {
#line 122
  uih___2->xcenterm = 2147483647;
#line 123
  uih___2->xcenterm = 2147483647;
#line 124
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static void uih_finishpalette(struct uih_context *uih___2 ) 
{ 


  {
#line 128
  if (((uih___2->image)->palette)->flags & 8) {
#line 129
    if ((unsigned long )((uih___2->image)->palette)->allocfinished != (unsigned long )((void *)0)) {
      {
#line 130
      (*(((uih___2->image)->palette)->allocfinished))((uih___2->image)->palette);
      }
    }
#line 131
    ((uih___2->image)->palette)->flags &= -9;
  }
#line 133
  return;
}
}
#line 135 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static void uih_getcoord(uih_context *uih___2 , int x , int y , number_t *xr , number_t *yr ) 
{ 
  number_t tmp ;

  {
  {
#line 138
  (*(((uih___2->uifilter)->action)->convertdown))(uih___2->uifilter, & x, & y);
#line 139
  *xr = (uih___2->fcontext)->rs.nc + (number_t )x * (((uih___2->fcontext)->rs.mc - (uih___2->fcontext)->rs.nc) / (number_t )((uih___2->zengine)->image)->width);
#line 143
  *yr = (uih___2->fcontext)->rs.ni + (number_t )y * (((uih___2->fcontext)->rs.mi - (uih___2->fcontext)->rs.ni) / (number_t )((uih___2->zengine)->image)->height);
#line 147
  tmp = *xr * (uih___2->fcontext)->cos + *yr * (uih___2->fcontext)->sin;
#line 147
  *yr = - *xr * (uih___2->fcontext)->sin + *yr * (uih___2->fcontext)->cos;
#line 147
  *xr = tmp;
  }
#line 148
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
int uih_enablefilter(uih_context *c , int n ) 
{ 
  struct filter *f ;
  struct filter *f1 ;
  int i ;
  int wascycling___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 152
  if ((unsigned long )c->filter[n] == (unsigned long )((void *)0)) {
#line 154
    wascycling___0 = 0;
#line 155
    if (c->cycling) {
      {
#line 156
      uih_cycling_off(c);
#line 156
      wascycling___0 = 1;
      }
    }
    {
#line 157
    f = (*((uih_filters[n])->getinstance))((struct filteraction  const  *)uih_filters[n]);
#line 158
    f1 = c->uifilter;
    }
#line 159
    if ((unsigned long )c->fixedcolor != (unsigned long )((void *)0)) {
#line 160
      f1 = c->fixedcolor;
    }
#line 161
    i = 19;
    {
#line 161
    while (1) {
      while_continue: /* CIL Label */ ;
#line 161
      if (! (i > n)) {
#line 161
        goto while_break;
      }
#line 162
      if (c->filter[i]) {
#line 163
        f1 = c->filter[i];
      }
#line 161
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 165
    c->display = 1;
#line 165
    if (c->recalculatemode > 2) {
#line 165
      c->recalculatemode = c->recalculatemode;
    } else {
#line 165
      c->recalculatemode = 2;
    }
    {
#line 166
    insertfilter(f, f1);
#line 167
    tmp___1 = initqueue(c->queue);
    }
#line 167
    if (tmp___1) {
#line 184
      c->filter[n] = f;
    } else {
      {
#line 168
      c->ddatalost = 1;
#line 169
      removefilter(f);
#line 170
      (*((f->action)->destroyinstance))(f);
#line 171
      tmp = initqueue(c->queue);
      }
#line 171
      if (! tmp) {
        {
#line 172
        x_fatalerror((char *)"Fatal error. Can not continue - initialization of queue can not be performed eigher with or without filter");
        }
      }
#line 175
      if (wascycling___0) {
        {
#line 176
        uih_cycling_on(c);
        }
      }
      {
#line 177
      tmp___0 = strcmp("palette", (char const   *)(uih_filters[n])->shortname);
      }
#line 177
      if (tmp___0) {
#line 180
        if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
          {
#line 180
          (*(c->updatemenus))(c, (char const   *)(uih_filters[n])->shortname);
          }
        }
      } else
#line 178
      if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
        {
#line 178
        (*(c->updatemenus))(c, "palettef");
        }
      }
#line 182
      return (0);
    }
#line 185
    if (wascycling___0) {
      {
#line 186
      uih_cycling_on(c);
      }
    }
    {
#line 187
    tmp___2 = strcmp("palette", (char const   *)(uih_filters[n])->shortname);
    }
#line 187
    if (tmp___2) {
#line 190
      if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
        {
#line 190
        (*(c->updatemenus))(c, (char const   *)(uih_filters[n])->shortname);
        }
      }
    } else
#line 188
    if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
      {
#line 188
      (*(c->updatemenus))(c, "palettef");
      }
    }
#line 192
    return (1);
  }
#line 194
  return (0);
}
}
#line 197 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_disablefilter(uih_context *c , int n ) 
{ 
  int wascycling___0 ;
  struct filter *f ;
  struct filter *f1 ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 199
  if (n == c->aliasnum) {
#line 200
    return;
  }
#line 201
  if ((unsigned long )c->filter[n] != (unsigned long )((void *)0)) {
#line 202
    wascycling___0 = 0;
#line 203
    f = c->filter[n];
#line 204
    if (c->cycling) {
      {
#line 205
      uih_cycling_off(c);
#line 205
      wascycling___0 = 1;
      }
    }
#line 206
    c->display = 1;
#line 206
    if (c->recalculatemode > 2) {
#line 206
      c->recalculatemode = c->recalculatemode;
    } else {
#line 206
      c->recalculatemode = 2;
    }
    {
#line 207
    removefilter(f);
#line 208
    tmp___0 = initqueue(c->queue);
    }
#line 208
    if (tmp___0) {
      {
#line 224
      (*((f->action)->destroyinstance))(f);
#line 224
      c->filter[n] = (struct filter *)((void *)0);
      }
    } else {
#line 211
      c->ddatalost = 1;
#line 212
      f1 = c->uifilter;
#line 213
      if ((unsigned long )c->fixedcolor != (unsigned long )((void *)0)) {
#line 214
        f1 = c->fixedcolor;
      }
#line 215
      i = 19;
      {
#line 215
      while (1) {
        while_continue: /* CIL Label */ ;
#line 215
        if (! (i > n)) {
#line 215
          goto while_break;
        }
#line 216
        if (c->filter[i]) {
#line 217
          f1 = c->filter[i];
        }
#line 215
        i --;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 219
      insertfilter(f, f1);
#line 220
      tmp = initqueue(c->queue);
      }
#line 220
      if (! tmp) {
        {
#line 221
        x_fatalerror((char *)"Fatal error. Can not continue");
        }
      }
    }
#line 225
    if (wascycling___0) {
      {
#line 226
      uih_cycling_on(c);
      }
    }
    {
#line 227
    tmp___1 = strcmp("palette", (char const   *)(uih_filters[n])->shortname);
    }
#line 227
    if (tmp___1) {
#line 230
      if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
        {
#line 230
        (*(c->updatemenus))(c, (char const   *)(uih_filters[n])->shortname);
        }
      }
    } else
#line 228
    if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
      {
#line 228
      (*(c->updatemenus))(c, "palettef");
      }
    }
  }
#line 233
  return;
}
}
#line 235 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
int uih_fastrotateenable(uih_context *c ) 
{ 
  int wascycling___0 ;
  int tmp ;

  {
#line 237
  wascycling___0 = 0;
#line 238
  if (c->juliamode) {
    {
#line 239
    uih_disablejulia(c);
    }
  }
#line 240
  if (! c->fastrotate) {
#line 240
    if (! c->juliamode) {
#line 241
      if (c->cycling) {
        {
#line 242
        uih_cycling_off(c);
#line 242
        wascycling___0 = 1;
        }
      }
      {
#line 243
      c->rotatef = (*(rotate_filter.getinstance))(& rotate_filter);
      }
#line 244
      if ((unsigned long )c->rotatef == (unsigned long )((void *)0)) {
#line 245
        goto end;
      }
#line 246
      c->display = 1;
#line 246
      if (c->recalculatemode > 2) {
#line 246
        c->recalculatemode = c->recalculatemode;
      } else {
#line 246
        c->recalculatemode = 2;
      }
      {
#line 247
      addfilter(c->rotatef, c->zengine);
#line 248
      tmp = initqueue(c->queue);
      }
#line 248
      if (! tmp) {
#line 249
        goto end2;
      }
#line 250
      if (wascycling___0) {
        {
#line 251
        uih_cycling_on(c);
        }
      }
#line 252
      c->fastrotate = 1;
#line 253
      return (1);
    }
  }
#line 255
  return (0);
  end2: 
  {
#line 257
  removefilter(c->rotatef);
#line 258
  initqueue(c->queue);
#line 259
  (*(((c->rotatef)->action)->destroyinstance))(c->rotatef);
  }
  end: 
#line 261
  if (wascycling___0) {
    {
#line 262
    uih_cycling_on(c);
    }
  }
#line 263
  return (0);
}
}
#line 266 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_fastrotatedisable(uih_context *c ) 
{ 
  int wascycling___0 ;

  {
#line 268
  if (c->fastrotate) {
    {
#line 269
    wascycling___0 = 0;
#line 270
    uih_rotatemode(c, 0);
    }
#line 271
    if (c->cycling) {
      {
#line 272
      uih_cycling_off(c);
#line 272
      wascycling___0 = 1;
      }
    }
    {
#line 273
    c->fastrotate = 0;
#line 274
    removefilter(c->rotatef);
#line 275
    initqueue(c->queue);
#line 276
    (*(((c->rotatef)->action)->destroyinstance))(c->rotatef);
#line 277
    c->display = 1;
    }
#line 277
    if (c->recalculatemode > 2) {
#line 277
      c->recalculatemode = c->recalculatemode;
    } else {
#line 277
      c->recalculatemode = 2;
    }
#line 278
    if (wascycling___0) {
      {
#line 279
      uih_cycling_on(c);
      }
    }
  }
#line 281
  return;
}
}
#line 283 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_rotate(struct uih_context *c , int n ) 
{ 


  {
#line 285
  if (! n) {
    {
#line 286
    uih_fastrotate(c, 0);
    }
  } else {
    {
#line 288
    uih_fastrotate(c, 1);
#line 289
    uih_rotatemode(c, n);
    }
  }
#line 291
  return;
}
}
#line 293 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static void uih_fixedcolordisable(uih_context *c ) 
{ 
  int wascycling___0 ;

  {
#line 296
  if ((unsigned long )c->fixedcolor != (unsigned long )((void *)0)) {
#line 297
    wascycling___0 = 0;
#line 298
    if (c->cycling) {
      {
#line 299
      uih_cycling_off(c);
#line 299
      wascycling___0 = 1;
      }
    }
    {
#line 300
    initqueue(c->queue);
#line 301
    removefilter(c->fixedcolor);
#line 302
    initqueue(c->queue);
#line 303
    (*(((c->fixedcolor)->action)->destroyinstance))(c->fixedcolor);
#line 304
    c->fixedcolor = (struct filter *)((void *)0);
#line 305
    c->display = 1;
    }
#line 305
    if (c->recalculatemode > 2) {
#line 305
      c->recalculatemode = c->recalculatemode;
    } else {
#line 305
      c->recalculatemode = 2;
    }
#line 306
    if (wascycling___0) {
      {
#line 307
      uih_cycling_on(c);
      }
    }
  }
#line 310
  return;
}
}
#line 312 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static int uih_fixedcolorenable(uih_context *c ) 
{ 
  struct filteraction  const  *fa ;
  int wascycling___0 ;
  int tmp ;

  {
  {
#line 315
  fa = (struct filteraction  const  *)((void *)0);
#line 316
  wascycling___0 = 0;
#line 317
  preallocpalette(c->palette);
  }
  {
#line 320
  if (((c->image)->palette)->type == 4096) {
#line 320
    goto case_4096;
  }
#line 328
  if (((c->image)->palette)->type == 2048) {
#line 328
    goto case_2048;
  }
#line 328
  if (((c->image)->palette)->type == 1024) {
#line 328
    goto case_2048;
  }
#line 328
  if (((c->image)->palette)->type == 512) {
#line 328
    goto case_2048;
  }
#line 328
  if (((c->image)->palette)->type == 256) {
#line 328
    goto case_2048;
  }
#line 332
  goto switch_default;
  case_4096: /* CIL Label */ 
#line 321
  fa = & fixedcolor_filter;
#line 322
  goto switch_break;
  case_2048: /* CIL Label */ 
  case_1024: /* CIL Label */ 
  case_512: /* CIL Label */ 
  case_256: /* CIL Label */ 
#line 329
  fa = & bitmap_filter;
#line 330
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 333
  x_fatalerror((char *)"Unsupported image type. Recompile XaoS");
  }
  switch_break: /* CIL Label */ ;
  }
#line 335
  if ((unsigned long )c->fixedcolor != (unsigned long )((void *)0)) {
#line 335
    if ((unsigned long )(c->fixedcolor)->action != (unsigned long )fa) {
      {
#line 336
      uih_fixedcolordisable(c);
      }
    }
  }
#line 337
  if ((unsigned long )c->fixedcolor == (unsigned long )((void *)0)) {
#line 338
    if (c->cycling) {
      {
#line 339
      uih_cycling_off(c);
#line 339
      wascycling___0 = 1;
      }
    }
    {
#line 340
    c->fixedcolor = (*(fa->getinstance))(fa);
    }
#line 341
    if ((unsigned long )c->fixedcolor == (unsigned long )((void *)0)) {
#line 342
      goto end;
    }
#line 343
    c->display = 1;
#line 343
    if (c->recalculatemode > 2) {
#line 343
      c->recalculatemode = c->recalculatemode;
    } else {
#line 343
      c->recalculatemode = 2;
    }
    {
#line 344
    addfilter(c->fixedcolor, (c->uifilter)->previous);
#line 345
    tmp = initqueue(c->queue);
    }
#line 345
    if (! tmp) {
#line 346
      goto end2;
    }
#line 347
    if (wascycling___0) {
      {
#line 348
      uih_cycling_on(c);
      }
    }
#line 349
    return (1);
  }
#line 351
  return (0);
  end2: 
  {
#line 353
  removefilter(c->fixedcolor);
#line 354
  (*(((c->fixedcolor)->action)->destroyinstance))(c->fixedcolor);
#line 355
  c->fixedcolor = (struct filter *)((void *)0);
#line 356
  initqueue(c->queue);
  }
  end: 
#line 358
  if (wascycling___0) {
    {
#line 359
    uih_cycling_on(c);
    }
  }
#line 360
  return (0);
}
}
#line 367 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
int uih_fastrotate(uih_context *c , int mode ) 
{ 
  int tmp ;

  {
#line 369
  if (mode) {
    {
#line 370
    tmp = uih_fastrotateenable(c);
    }
#line 370
    return (tmp);
  }
  {
#line 371
  uih_fastrotatedisable(c);
  }
#line 372
  return (1);
}
}
#line 375 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_angle(uih_context *c , number_t angle ) 
{ 


  {
#line 377
  if (angle != (c->fcontext)->angle) {
#line 378
    if (! c->fastrotate) {
#line 379
      ((c->fcontext)->version) ++;
#line 380
      c->display = 1;
#line 380
      if (c->recalculatemode > 2) {
#line 380
        c->recalculatemode = c->recalculatemode;
      } else {
#line 380
        c->recalculatemode = 2;
      }
    }
#line 382
    (c->fcontext)->angle = angle;
#line 383
    c->display = 1;
#line 383
    if (c->recalculatemode > 1) {
#line 383
      c->recalculatemode = c->recalculatemode;
    } else {
#line 383
      c->recalculatemode = 1;
    }
  }
#line 385
  return;
}
}
#line 387 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_rotatemode(uih_context *c , int mode ) 
{ 
  char const   *names___1[3] ;

  {
#line 389
  names___1[0] = "norotate";
#line 389
  names___1[1] = "mouserotate";
#line 389
  names___1[2] = "controtate";
#line 394
  if (c->fastrotate) {
#line 395
    if (c->rotatemode != mode) {
#line 396
      c->rotatemode = mode;
#line 397
      if (mode == 2) {
        {
#line 398
        tl_reset_timer(c->doittimer);
        }
      }
#line 399
      if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
        {
#line 399
        (*(c->updatemenus))(c, names___1[mode]);
        }
      }
    }
  }
#line 402
  return;
}
}
#line 404 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
int uih_enablejulia(uih_context *c ) 
{ 
  int wascycling___0 ;
  struct filter *addf ;
  int tmp ;

  {
#line 406
  wascycling___0 = 0;
#line 407
  if (! c->juliamode) {
#line 407
    if ((c->fcontext)->mandelbrot) {
#line 409
      addf = c->zengine;
#line 410
      c->display = 1;
#line 410
      if (c->recalculatemode > 2) {
#line 410
        c->recalculatemode = c->recalculatemode;
      } else {
#line 410
        c->recalculatemode = 2;
      }
#line 411
      if (c->fastrotate) {
        {
#line 412
        uih_fastrotatedisable(c);
        }
      }
#line 413
      if (c->cycling) {
        {
#line 414
        uih_cycling_off(c);
#line 414
        wascycling___0 = 1;
        }
      }
#line 415
      if ((unsigned long )((c->fcontext)->currentformula)->calculate_julia == (unsigned long )((void *)0)) {
        {
#line 417
        c->julia = (*(zoom_filter.getinstance))(& zoom_filter);
        }
      } else
#line 415
      if ((c->fcontext)->slowmode) {
        {
#line 417
        c->julia = (*(zoom_filter.getinstance))(& zoom_filter);
        }
      } else {
        {
#line 419
        c->julia = (*(julia_filter.getinstance))(& julia_filter);
        }
      }
#line 420
      if ((unsigned long )c->julia == (unsigned long )((void *)0)) {
#line 421
        goto end;
      }
      {
#line 423
      c->subwindow = (*(subwindow_filter.getinstance))(& subwindow_filter);
      }
#line 424
      if ((unsigned long )c->subwindow == (unsigned long )((void *)0)) {
#line 425
        goto end2;
      }
#line 426
      if ((unsigned long )((c->fcontext)->currentformula)->calculate_julia != (unsigned long )((void *)0)) {
#line 426
        if (! (c->fcontext)->slowmode) {
          {
#line 428
          c->smalliter = (*(smalliter_filter.getinstance))(& smalliter_filter);
          }
#line 429
          if ((unsigned long )c->smalliter == (unsigned long )((void *)0)) {
#line 430
            goto end3;
          }
        } else {
#line 432
          c->smalliter = (struct filter *)((void *)0);
        }
      } else {
#line 432
        c->smalliter = (struct filter *)((void *)0);
      }
      {
#line 433
      addfilter(c->subwindow, addf);
      }
#line 434
      if ((unsigned long )((c->fcontext)->currentformula)->calculate_julia != (unsigned long )((void *)0)) {
#line 434
        if (! (c->fcontext)->slowmode) {
          {
#line 436
          addfilter(c->smalliter, addf);
          }
        }
      }
      {
#line 438
      addfilter(c->julia, addf);
#line 439
      subwindow_setsecond(c->subwindow, addf);
#line 440
      tmp = initqueue(c->queue);
      }
#line 440
      if (! tmp) {
#line 441
        goto end4;
      }
#line 442
      if ((unsigned long )((c->fcontext)->currentformula)->calculate_julia == (unsigned long )((void *)0)) {
#line 444
        c->juliamode = 2;
      } else
#line 442
      if ((c->fcontext)->slowmode) {
#line 444
        c->juliamode = 2;
      } else {
#line 446
        c->juliamode = 1;
      }
#line 447
      if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
        {
#line 447
        (*(c->updatemenus))(c, "fastjulia");
        }
      }
#line 448
      return (1);
    }
  }
#line 450
  if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
    {
#line 450
    (*(c->updatemenus))(c, "fastjulia");
    }
  }
#line 451
  return (0);
  end4: 
  {
#line 453
  removefilter(c->subwindow);
#line 454
  removefilter(c->julia);
  }
#line 455
  if ((unsigned long )c->smalliter != (unsigned long )((void *)0)) {
    {
#line 456
    removefilter(c->smalliter);
    }
  }
  {
#line 457
  initqueue(c->queue);
  }
  end3: 
  {
#line 459
  (*(((c->smalliter)->action)->destroyinstance))(c->smalliter);
  }
  end2: 
  {
#line 461
  (*(((c->subwindow)->action)->destroyinstance))(c->subwindow);
  }
  end: 
  {
#line 463
  (*(((c->julia)->action)->destroyinstance))(c->julia);
  }
#line 464
  if (wascycling___0) {
    {
#line 465
    uih_cycling_on(c);
    }
  }
#line 466
  if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
    {
#line 466
    (*(c->updatemenus))(c, "fastjulia");
    }
  }
#line 467
  return (0);
}
}
#line 470 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_disablejulia(uih_context *c ) 
{ 
  int wascycling___0 ;

  {
#line 472
  wascycling___0 = 0;
#line 473
  if (c->juliamode) {
#line 474
    c->display = 1;
#line 474
    if (c->recalculatemode > 2) {
#line 474
      c->recalculatemode = c->recalculatemode;
    } else {
#line 474
      c->recalculatemode = 2;
    }
#line 475
    ((c->fcontext)->version) ++;
#line 476
    if (c->cycling) {
      {
#line 477
      uih_cycling_off(c);
#line 477
      wascycling___0 = 1;
      }
    }
    {
#line 478
    removefilter(c->subwindow);
#line 479
    removefilter(c->julia);
    }
#line 480
    if ((unsigned long )c->smalliter != (unsigned long )((void *)0)) {
      {
#line 481
      removefilter(c->smalliter);
      }
    }
    {
#line 482
    initqueue(c->queue);
    }
#line 483
    if ((unsigned long )c->smalliter != (unsigned long )((void *)0)) {
      {
#line 484
      (*(((c->smalliter)->action)->destroyinstance))(c->smalliter);
      }
    }
    {
#line 485
    (*(((c->subwindow)->action)->destroyinstance))(c->subwindow);
#line 486
    (*(((c->julia)->action)->destroyinstance))(c->julia);
    }
#line 487
    if (wascycling___0) {
      {
#line 488
      uih_cycling_on(c);
      }
    }
#line 489
    c->juliamode = 0;
#line 490
    if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
      {
#line 490
      (*(c->updatemenus))(c, "fastjulia");
      }
    }
  }
#line 492
  return;
}
}
#line 494 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
int uih_setjuliamode(uih_context *c , int mode ) 
{ 
  int tmp ;

  {
#line 496
  if (mode) {
    {
#line 497
    tmp = uih_enablejulia(c);
    }
#line 497
    return (tmp);
  }
  {
#line 498
  uih_disablejulia(c);
  }
#line 499
  return (1);
}
}
#line 502 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_rotationspeed(uih_context *c , number_t speed ) 
{ 


  {
#line 504
  c->rotationspeed = speed;
#line 505
  return;
}
}
#line 507 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static void uih_cyclinghandler(void *userdata , int n ) 
{ 
  struct uih_context *uih___2 ;
  int direct ;

  {
#line 509
  uih___2 = (struct uih_context *)userdata;
#line 511
  if ((unsigned long )((uih___2->zengine)->fractalc)->palette != (unsigned long )((void *)0)) {
#line 511
    if ((unsigned long )(((uih___2->zengine)->fractalc)->palette)->cyclecolors == (unsigned long )((void *)0)) {
#line 513
      return;
    }
  }
#line 514
  direct = (uih___2->direction * uih___2->cyclingdirection) * n;
#line 515
  if (direct > 0) {
#line 516
    direct %= (((uih___2->zengine)->fractalc)->palette)->size - 1;
  } else {
#line 518
    direct = - (- direct % ((((uih___2->zengine)->fractalc)->palette)->size - 1));
  }
#line 520
  if (direct) {
#line 521
    uih___2->paletteshift += direct;
    {
#line 522
    while (1) {
      while_continue: /* CIL Label */ ;
#line 522
      if (! (uih___2->paletteshift < 0)) {
#line 522
        goto while_break;
      }
#line 523
      uih___2->paletteshift += (((uih___2->zengine)->fractalc)->palette)->size - 1;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 524
    uih___2->paletteshift %= (((uih___2->zengine)->fractalc)->palette)->size - 1;
#line 527
    (*((((uih___2->zengine)->fractalc)->palette)->cyclecolors))(((uih___2->zengine)->fractalc)->palette,
                                                                direct);
    }
#line 530
    if (uih___2->flags & 4) {
#line 530
      if (! uih___2->play) {
#line 532
        uih___2->display = 1;
      } else
#line 530
      if (! uih___2->nonfractalscreen) {
#line 532
        uih___2->display = 1;
      }
    }
#line 533
    if (! uih___2->recalculatemode) {
#line 533
      if ((unsigned long )(uih___2->queue)->palettechg != (unsigned long )((void *)0)) {
#line 533
        uih___2->recalculatemode = -2;
#line 533
        uih___2->display = 1;
      }
    }
  }
#line 535
  return;
}
}
#line 537 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_cycling_off(struct uih_context *c ) 
{ 


  {
#line 539
  if (c->cycling) {
    {
#line 540
    tl_free_timer(c->cyclingtimer);
#line 541
    c->cycling = 0;
    }
#line 542
    if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
      {
#line 542
      (*(c->updatemenus))(c, "cycling");
      }
    }
#line 543
    if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
      {
#line 543
      (*(c->updatemenus))(c, "rcycling");
      }
    }
  }
#line 545
  return;
}
}
#line 547 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_display(struct uih_context *c ) 
{ 


  {
#line 549
  c->display = 1;
#line 550
  c->nonfractalscreen = 0;
#line 551
  if (c->clearscreen) {
#line 552
    c->clearscreen = 0;
  }
#line 553
  c->displaytext = 0;
#line 554
  c->nletters = 0;
#line 555
  c->display = 1;
#line 556
  if ((unsigned long )c->text[0] != (unsigned long )((void *)0)) {
    {
#line 557
    free((void *)c->text[0]);
#line 557
    c->text[0] = (char *)((void *)0);
    }
  }
#line 558
  if ((unsigned long )c->text[1] != (unsigned long )((void *)0)) {
    {
#line 559
    free((void *)c->text[1]);
#line 559
    c->text[1] = (char *)((void *)0);
    }
  }
#line 560
  if ((unsigned long )c->text[2] != (unsigned long )((void *)0)) {
    {
#line 561
    free((void *)c->text[2]);
#line 561
    c->text[2] = (char *)((void *)0);
    }
  }
#line 562
  if (c->play) {
    {
#line 563
    uih_clear_lines(c);
    }
  }
#line 564
  return;
}
}
#line 566 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_cycling_stop(struct uih_context *c ) 
{ 


  {
#line 568
  if (c->cycling) {
#line 568
    if (! c->stopped) {
      {
#line 569
      tl_remove_timer(c->cyclingtimer);
#line 570
      c->stopped = 1;
      }
    }
  }
#line 572
  return;
}
}
#line 574 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_cycling_continue(struct uih_context *c ) 
{ 


  {
#line 576
  if (c->cycling) {
#line 576
    if (c->stopped) {
      {
#line 577
      c->stopped = 0;
#line 578
      tl_add_timer(syncgroup, c->cyclingtimer);
      }
    }
  }
#line 580
  return;
}
}
#line 582 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_loadfile(struct uih_context *c , xio_constpath d ) 
{ 
  xio_file f ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 585
  f = xio_ropen(d);
  }
#line 586
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 590
    tmp = __errno_location();
#line 590
    tmp___0 = strerror(*tmp);
#line 590
    uih_error(c, (char const   *)tmp___0);
    }
#line 592
    return;
  }
  {
#line 594
  uih_load(c, f, d);
  }
#line 595
  return;
}
}
#line 598 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_loadstr(struct uih_context *c , char const   *data ) 
{ 
  xio_file f ;

  {
  {
#line 601
  f = xio_strropen(data);
#line 602
  uih_load(c, f, "");
  }
#line 603
  return;
}
}
#line 606 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_playstr(struct uih_context *c , char const   *data ) 
{ 
  xio_file f ;
  char *tmp ;

  {
  {
#line 609
  tmp = mystrdup(data);
#line 609
  f = xio_strropen((char const   *)tmp);
#line 610
  uih_replayenable(c, f, "", 1);
  }
#line 611
  return;
}
}
#line 614 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_recalculate(struct uih_context *c ) 
{ 


  {
#line 616
  ((c->fcontext)->version) ++;
#line 617
  c->display = 1;
#line 617
  if (c->recalculatemode > 2) {
#line 617
    c->recalculatemode = c->recalculatemode;
  } else {
#line 617
    c->recalculatemode = 2;
  }
#line 618
  return;
}
}
#line 620 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_playfile(struct uih_context *c , xio_constpath d ) 
{ 
  xio_file f ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 623
  if (c->play) {
    {
#line 624
    uih_replaydisable(c);
    }
  }
  {
#line 625
  f = xio_ropen(d);
  }
#line 626
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 630
    tmp = __errno_location();
#line 630
    tmp___0 = strerror(*tmp);
#line 630
    uih_error(c, (char const   *)tmp___0);
    }
#line 632
    return;
  }
  {
#line 634
  uih_replayenable(c, f, d, 1);
  }
#line 635
  return;
}
}
#line 638 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_playtutorial(struct uih_context *c , char const   *name___0 ) 
{ 
  xio_pathdata tmp ;
  xio_file f ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 641
  f = (xio_file )((void *)0);
#line 643
  f = xio_gettutorial(name___0, tmp);
  }
#line 644
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 645
    tmp___0 = gettext("Tutorial files not found. Reinstall XaoS");
#line 645
    uih_error(c, (char const   *)tmp___0);
    }
#line 646
    return;
  }
  {
#line 648
  uih_replayenable(c, f, (xio_constpath )(tmp), 1);
  }
#line 649
  if ((unsigned long )c->passfunc != (unsigned long )((void *)0)) {
    {
#line 650
    tmp___1 = gettext("Preparing first image");
#line 650
    (*(c->passfunc))(c, 1, (char const   *)tmp___1, (float )0);
    }
  }
#line 652
  return;
}
}
#line 654 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_loadexample(struct uih_context *c ) 
{ 
  xio_pathdata name___0 ;
  xio_file f ;
  xio_file tmp ;
  char *tmp___0 ;
  char s[256] ;
  char *tmp___1 ;

  {
  {
#line 657
  tmp = xio_getrandomexample(name___0);
#line 657
  f = tmp;
#line 658
  c->errstring = (char const   *)((void *)0);
  }
#line 659
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 660
    tmp___0 = gettext("Could not open examples");
#line 660
    uih_error(c, (char const   *)tmp___0);
    }
#line 661
    return;
  }
  {
#line 663
  uih_load(c, f, (xio_constpath )(name___0));
  }
#line 664
  if ((unsigned long )c->errstring == (unsigned long )((void *)0)) {
    {
#line 666
    tmp___1 = gettext("File %s loaded.");
#line 666
    sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)tmp___1,
            name___0);
#line 667
    uih_message(c, (char const   *)(s));
    }
  }
#line 669
  return;
}
}
#line 671 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_savepngfile(struct uih_context *c , xio_constpath d ) 
{ 
  char const   *s ;
  char *tmp ;
  char *tmp___0 ;
  char s___0[256] ;
  char *tmp___1 ;

  {
#line 674
  if ((unsigned long )c->passfunc != (unsigned long )((void *)0)) {
    {
#line 675
    tmp = gettext("Saving image...");
#line 675
    (*(c->passfunc))(c, 1, (char const   *)tmp, (float )0);
    }
  }
#line 677
  if (c->recalculatemode) {
#line 678
    c->display = 1;
#line 678
    if (c->recalculatemode > 2) {
#line 678
      c->recalculatemode = c->recalculatemode;
    } else {
#line 678
      c->recalculatemode = 2;
    }
    {
#line 679
    uih_clearwindows(c);
#line 680
    uih_do_fractal(c);
    }
  }
#line 682
  if (c->interrupt) {
    {
#line 683
    tmp___0 = gettext("Save interrupted");
#line 683
    uih_message(c, (char const   *)tmp___0);
    }
#line 684
    return;
  }
  {
#line 686
  c->errstring = (char const   *)((void *)0);
#line 687
  s = uih_save(c, d);
  }
#line 688
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
#line 689
    uih_error(c, s);
    }
  }
#line 690
  if ((unsigned long )c->errstring == (unsigned long )((void *)0)) {
    {
#line 692
    tmp___1 = gettext("File %s saved.");
#line 692
    sprintf((char */* __restrict  */)(s___0), (char const   */* __restrict  */)tmp___1,
            d);
#line 693
    uih_message(c, (char const   *)(s___0));
    }
  }
#line 695
  return;
}
}
#line 697 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_saveposfile(struct uih_context *c , xio_constpath d ) 
{ 
  xio_file f ;
  char *tmp ;
  char s[256] ;
  char *tmp___0 ;

  {
  {
#line 700
  c->errstring = (char const   *)((void *)0);
#line 701
  f = xio_wopen(d);
  }
#line 702
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 703
    tmp = gettext("Can not open file");
#line 703
    uih_error(c, (char const   *)tmp);
    }
#line 704
    return;
  }
  {
#line 706
  uih_save_possition(c, f, 0);
  }
#line 707
  if ((unsigned long )c->errstring == (unsigned long )((void *)0)) {
    {
#line 709
    tmp___0 = gettext("File %s saved.");
#line 709
    sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)tmp___0,
            d);
#line 710
    uih_message(c, (char const   *)(s));
    }
  }
#line 712
  return;
}
}
#line 714 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
char *uih_savepostostr(struct uih_context *c ) 
{ 
  xio_file f ;
  char *tmp ;

  {
  {
#line 717
  c->errstring = (char const   *)((void *)0);
#line 718
  f = xio_strwopen();
#line 719
  uih_save_possition(c, f, 0);
#line 720
  tmp = xio_getstring(f);
  }
#line 720
  return (tmp);
}
}
#line 723 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_saveundo(struct uih_context *c ) 
{ 
  xio_file f ;

  {
#line 726
  if (c->play) {
#line 727
    return;
  }
#line 728
  c->errstring = (char const   *)((void *)0);
#line 729
  if (c->undo.undos[c->undo.last]) {
    {
#line 730
    free((void *)c->undo.undos[c->undo.last]);
    }
  }
  {
#line 731
  f = xio_strwopen();
#line 732
  uih_save_possition(c, f, 0);
#line 733
  c->undo.undos[c->undo.last] = xio_getstring(f);
#line 734
  c->undo.last = (c->undo.last + 1) % 256;
  }
#line 735
  return;
}
}
#line 737 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_undo(struct uih_context *c ) 
{ 
  xio_file f ;
  int pos ;

  {
#line 740
  pos = c->undo.last - 2;
#line 741
  if (pos < 0) {
#line 742
    pos = 256 + pos;
  }
#line 743
  if (c->undo.undos[pos]) {
    {
#line 744
    f = xio_strropen((char const   *)c->undo.undos[pos]);
#line 745
    c->undo.undos[pos] = (char *)((void *)0);
#line 746
    c->undo.last = pos;
#line 747
    uih_load(c, f, "");
    }
  }
#line 749
  return;
}
}
#line 751 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_redo(struct uih_context *c ) 
{ 
  xio_file f ;
  int pos ;

  {
#line 754
  pos = c->undo.last;
#line 755
  if (c->undo.undos[pos]) {
    {
#line 756
    f = xio_strropen((char const   *)c->undo.undos[pos]);
#line 757
    c->undo.undos[pos] = (char *)((void *)0);
#line 758
    c->undo.last = pos;
#line 759
    uih_load(c, f, "");
    }
  }
#line 761
  return;
}
}
#line 764 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_savecfg(struct uih_context *c ) 
{ 
  xio_file f ;
  int *tmp ;
  char *tmp___0 ;
  char s[256] ;
  char *tmp___1 ;

  {
  {
#line 767
  c->errstring = (char const   *)((void *)0);
#line 768
  f = xio_wopen((xio_constpath )(configfile));
  }
#line 769
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 770
    tmp = __errno_location();
#line 770
    tmp___0 = strerror(*tmp);
#line 770
    uih_message(c, (char const   *)tmp___0);
    }
#line 771
    return;
  }
  {
#line 773
  uih_save_possition(c, f, 2);
  }
#line 774
  if ((unsigned long )c->errstring == (unsigned long )((void *)0)) {
    {
#line 776
    tmp___1 = gettext("File %s saved.");
#line 776
    sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)tmp___1,
            configfile);
#line 777
    uih_message(c, (char const   *)(s));
    }
  }
#line 779
  return;
}
}
#line 781 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_saveanimfile(struct uih_context *c , xio_constpath d ) 
{ 
  xio_file f ;
  int *tmp ;
  char *tmp___0 ;
  char s[256] ;
  char *tmp___1 ;

  {
#line 784
  c->errstring = (char const   *)((void *)0);
#line 785
  if (c->save) {
    {
#line 786
    uih_save_disable(c);
    }
#line 787
    if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
      {
#line 787
      (*(c->updatemenus))(c, "record");
      }
    }
#line 788
    return;
  }
  {
#line 790
  f = xio_wopen(d);
  }
#line 791
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 792
    tmp = __errno_location();
#line 792
    tmp___0 = strerror(*tmp);
#line 792
    uih_message(c, (char const   *)tmp___0);
    }
#line 793
    return;
  }
  {
#line 795
  uih_save_enable(c, f, 1);
  }
#line 796
  if ((unsigned long )c->errstring == (unsigned long )((void *)0)) {
    {
#line 798
    tmp___1 = gettext("Recording to file %s enabled.");
#line 798
    sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)tmp___1,
            d);
#line 799
    uih_message(c, (char const   *)(s));
    }
  }
#line 801
  if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
    {
#line 801
    (*(c->updatemenus))(c, "record");
    }
  }
#line 802
  return;
}
}
#line 810 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
char const   *uih_save(struct uih_context *c , xio_constpath filename___0 ) 
{ 
  FILE *f ;
  char const   *r ;

  {
  {
#line 814
  uih_cycling_stop(c);
#line 815
  uih_stoptimers(c);
#line 816
  uih_clearwindows(c);
#line 817
  f = fopen((char const   */* __restrict  */)filename___0, (char const   */* __restrict  */)"wb");
#line 818
  r = writepng(f, (struct image  const  *)(c->queue)->saveimage);
#line 819
  uih_cycling_continue(c);
#line 820
  uih_resumetimers(c);
  }
#line 821
  return (r);
}
}
#line 824 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_setcycling(struct uih_context *c , int speed ) 
{ 


  {
#line 826
  c->cyclingspeed = speed;
#line 827
  if (c->cyclingspeed < 0) {
#line 828
    c->direction = -1;
  } else {
#line 830
    c->direction = 1;
  }
#line 831
  if (c->cycling) {
#line 832
    if (c->cyclingspeed) {
      {
#line 833
      tl_set_interval(c->cyclingtimer, (1000000 / c->cyclingspeed) * c->direction);
      }
    } else {
      {
#line 836
      tl_set_interval(c->cyclingtimer, 100000000);
      }
    }
  }
#line 838
  return;
}
}
#line 840 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
int uih_cycling_on(struct uih_context *c ) 
{ 


  {
#line 842
  if ((unsigned long )((c->zengine)->fractalc)->palette != (unsigned long )((void *)0)) {
#line 842
    if ((unsigned long )(((c->zengine)->fractalc)->palette)->cyclecolors != (unsigned long )((void *)0)) {
      {
#line 844
      c->cycling = 1;
#line 845
      tl_update_time();
#line 846
      c->cyclingtimer = tl_create_timer();
#line 847
      uih_emulatetimers(c);
#line 848
      uih_setcycling(c, c->cyclingspeed);
#line 849
      tl_set_multihandler(c->cyclingtimer, & uih_cyclinghandler, (void *)c);
#line 850
      tl_add_timer(syncgroup, c->cyclingtimer);
      }
    } else {
#line 842
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 852
    if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
      {
#line 852
      (*(c->updatemenus))(c, "cycling");
      }
    }
#line 853
    if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
      {
#line 853
      (*(c->updatemenus))(c, "rcycling");
      }
    }
#line 854
    return (0);
  }
#line 856
  if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
    {
#line 856
    (*(c->updatemenus))(c, "cycling");
    }
  }
#line 857
  if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
    {
#line 857
    (*(c->updatemenus))(c, "rcycling");
    }
  }
#line 858
  return (1);
}
}
#line 861 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
int uih_cycling(struct uih_context *uih___2 , int mode ) 
{ 
  int tmp ;

  {
#line 863
  if (mode) {
    {
#line 864
    tmp = uih_cycling_on(uih___2);
    }
#line 864
    return (tmp);
  }
  {
#line 865
  uih_cycling_off(uih___2);
  }
#line 866
  return (1);
}
}
#line 871 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static void uih_waitfunc(struct filter *f ) 
{ 
  int l ;
  int display ;
  double tmp ;
  int tmp___0 ;

  {
  {
#line 874
  tl_process_group(syncgroup, (int *)((void *)0));
#line 875
  l = tl_lookup_timer(uih___0->calculatetimer);
  }
#line 876
  if (uih___0->interrupt) {
#line 877
    f->interrupt = 1;
#line 877
    uih___0->endtime = l;
  }
#line 878
  if (uih___0->interruptiblemode) {
#line 879
    if (f->incalculation) {
#line 879
      if (! uih___0->starttime) {
#line 880
        uih___0->starttime = l;
      } else {
#line 879
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 881
    if (uih___0->starttime) {
#line 881
      if (! f->incalculation) {
#line 881
        if (! uih___0->endtime) {
#line 882
          uih___0->endtime = l;
        }
      }
    }
#line 883
    if (uih___0->maxtime) {
#line 883
      if (l > uih___0->maxtime) {
#line 883
        if (f->readyforinterrupt) {
#line 885
          f->interrupt = 1;
#line 885
          uih___0->endtime = l;
        } else {
#line 883
          goto _L___1;
        }
      } else {
#line 883
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 883
    if (uih___0->interrupt) {
#line 885
      f->interrupt = 1;
#line 885
      uih___0->endtime = l;
    }
  }
#line 887
  if (l > (waitcount + 1) * 50000) {
#line 888
    display = 0;
#line 889
    if (! uih___0->interruptiblemode) {
#line 889
      if (l > (waitcount1 + 1) * 200000) {
#line 890
        display = 1;
#line 891
        waitcount1 = l / 200000;
      }
    }
#line 893
    if ((unsigned long )f->image == (unsigned long )uih___0->image) {
#line 893
      if (! uih___0->interruptiblemode) {
#line 893
        if (l > (waitcount2 + 1) * 2000000) {
#line 895
          if (! uih___0->play) {
            {
#line 896
            uih___0->display = 1;
#line 896
            uih_finishpalette(uih___0);
#line 896
            display = 1;
            }
          }
#line 897
          waitcount2 = l / 2000000;
        }
      }
    }
#line 899
    if ((unsigned long )uih___0->passfunc != (unsigned long )((void *)0)) {
#line 900
      if (f->max) {
#line 900
        tmp = ((double )f->pos * 100.0) / (double )f->max;
      } else {
#line 900
        tmp = 100.0;
      }
      {
#line 900
      tmp___0 = (*(uih___0->passfunc))(uih___0, display, f->pass, (float )tmp);
#line 900
      f->interrupt |= tmp___0;
#line 904
      uih___0->display = 0;
      }
    }
#line 906
    waitcount = l / 50000;
  }
  {
#line 908
  uih_clearwindows(uih___0);
  }
#line 909
  return;
}
}
#line 911 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_do_fractal(uih_context *c ) 
{ 
  int flags ;
  int time___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 916
  c->interrupt = 0;
#line 917
  c->display = 0;
#line 918
  uih___0 = c;
#line 919
  if (c->juliamode) {
#line 919
    if (! (c->fcontext)->mandelbrot) {
      {
#line 920
      uih_disablejulia(c);
      }
    }
  }
#line 922
  if (c->juliamode == 1) {
#line 922
    if ((unsigned long )((c->fcontext)->currentformula)->calculate_julia == (unsigned long )((void *)0)) {
      {
#line 929
      uih_disablejulia(c);
#line 930
      uih_enablejulia(c);
#line 931
      ((c->fcontext)->version) ++;
      }
    } else
#line 922
    if ((c->fcontext)->slowmode) {
      {
#line 929
      uih_disablejulia(c);
#line 930
      uih_enablejulia(c);
#line 931
      ((c->fcontext)->version) ++;
      }
    } else {
#line 922
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 922
  if (c->juliamode == 2) {
#line 922
    if ((unsigned long )((c->fcontext)->currentformula)->calculate_julia != (unsigned long )((void *)0)) {
#line 922
      if (! (c->fcontext)->slowmode) {
        {
#line 929
        uih_disablejulia(c);
#line 930
        uih_enablejulia(c);
#line 931
        ((c->fcontext)->version) ++;
        }
      }
    }
  }
  {
#line 934
  tl_update_time();
  }
#line 935
  if (c->recalculatemode < c->fastmode) {
#line 935
    if ((unsigned long )c->emulator == (unsigned long )((void *)0)) {
#line 935
      if (! c->fixedstep) {
#line 937
        c->interruptiblemode = 1;
      } else {
#line 939
        c->interruptiblemode = 0;
      }
    } else {
#line 939
      c->interruptiblemode = 0;
    }
  } else {
#line 939
    c->interruptiblemode = 0;
  }
#line 940
  if (! c->interruptiblemode) {
#line 940
    if (c->recalculatemode > 1) {
#line 941
      if ((unsigned long )c->longwait != (unsigned long )((void *)0)) {
        {
#line 942
        (*(c->longwait))(c);
        }
      }
      {
#line 943
      uih_stoptimers(c);
      }
    }
  }
  {
#line 946
  tl_update_time();
#line 947
  tl_reset_timer(c->calculatetimer);
#line 948
  c->starttime = 0;
#line 949
  c->endtime = 0;
#line 950
  tmp = tl_lookup_timer(c->calculatetimer);
#line 950
  waitcount = tmp / 50000 + 2;
#line 951
  tmp___0 = tl_lookup_timer(c->calculatetimer);
#line 951
  waitcount1 = tmp___0 / 200000 + 1;
#line 952
  tmp___1 = tl_lookup_timer(c->calculatetimer);
#line 952
  waitcount2 = tmp___1 / 2000000 + 1;
#line 958
  c->incalculation = 1;
  }
#line 960
  if (! (c->flags & 64)) {
    {
#line 961
    uih_cycling_stop(c);
    }
  }
  {
#line 963
  time___0 = tl_lookup_timer(c->doittimer);
  }
#line 964
  if (c->rotatemode == 2) {
#line 965
    (c->fcontext)->angle += (c->rotationspeed * (number_t )time___0) / (number_t )1000000.0;
  }
  {
#line 968
  tl_reset_timer(c->doittimer);
#line 969
  c->indofractal = 1;
  }
#line 970
  if (c->recalculatemode < -2) {
#line 971
    if ((unsigned long )(c->queue)->palettechg != (unsigned long )((void *)0)) {
      {
#line 972
      flags = (*((((c->queue)->palettechg)->action)->doit))((c->queue)->palettechg,
                                                            2, 0);
      }
    } else {
#line 976
      flags = 2;
    }
  } else {
#line 978
    if (c->interruptiblemode) {
#line 978
      tmp___2 = 1;
    } else {
#line 978
      tmp___2 = 0;
    }
    {
#line 978
    flags = (*((((c->uifilter)->previous)->action)->doit))((c->uifilter)->previous,
                                                           tmp___2, time___0);
    }
  }
#line 982
  c->indofractal = 0;
#line 984
  if (! (c->flags & 64)) {
    {
#line 985
    uih_cycling_continue(c);
    }
  }
#line 987
  c->dirty = 0;
#line 988
  if (c->inanimation) {
#line 989
    (c->inanimation) --;
  }
#line 990
  c->ddatalost = 0;
#line 991
  c->recalculatemode = 0;
#line 993
  if (flags & 4) {
#line 994
    c->fastanimation = 1;
  } else {
#line 996
    c->fastanimation = 0;
  }
#line 997
  if (c->emulator) {
#line 998
    c->inanimation = 1;
  }
#line 999
  if (flags & (4 | (1 << 29))) {
#line 999
    goto _L___0;
  } else
#line 999
  if (c->rotatemode == 2) {
    _L___0: /* CIL Label */ 
    {
#line 1001
    tl_resume_timer(c->doittimer);
#line 1002
    c->uncomplette = 1;
#line 1003
    c->inanimation = 2;
    }
#line 1004
    if (flags & (1 << 29)) {
#line 1005
      c->recalculatemode = 1;
    } else {
#line 1007
      c->recalculatemode = -1;
    }
#line 1008
    c->display = 1;
  } else {
    {
#line 1010
    tl_stop_timer(c->doittimer);
#line 1011
    c->uncomplette = 0;
    }
  }
#line 1013
  if (flags & 2) {
#line 1013
    if (! c->play) {
#line 1013
      goto _L___1;
    } else
#line 1013
    if (! c->nonfractalscreen) {
      _L___1: /* CIL Label */ 
#line 1014
      c->display = 1;
#line 1015
      if (flags & 1) {
#line 1016
        c->dirty = 1;
      }
    } else {
#line 1018
      c->incalculation = 0;
    }
  } else {
#line 1018
    c->incalculation = 0;
  }
  {
#line 1019
  uih_callcomplette(c);
  }
#line 1020
  if (c->autopilot) {
#line 1021
    c->inanimation = 1;
  }
#line 1022
  return;
}
}
#line 1024 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_prepare_image(uih_context *c ) 
{ 


  {
#line 1026
  if (c->play) {
    {
#line 1027
    uih_update_lines(c);
    }
  }
#line 1028
  if (c->display) {
    {
#line 1029
    uih_clearwindows(c);
#line 1030
    xprepareimage(c->image);
    }
#line 1031
    if (c->recalculatemode) {
      {
#line 1032
      uih_do_fractal(c);
      }
    }
  }
#line 1034
  return;
}
}
#line 1036 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_callcomplette(uih_context *c ) 
{ 


  {
#line 1038
  if (! c->uncomplette) {
#line 1038
    if (! c->display) {
#line 1038
      if (! c->recalculatemode) {
#line 1038
        if (! c->inanimation) {
#line 1038
          if ((unsigned long )c->complettehandler != (unsigned long )((void *)0)) {
            {
#line 1040
            (*(c->complettehandler))(c->handlerdata);
            }
          }
        }
      }
    }
  }
#line 1042
  return;
}
}
#line 1044 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_setcomplettehandler(uih_context *c , void (*h)(void * ) , void *d ) 
{ 


  {
#line 1046
  c->complettehandler = h;
#line 1047
  c->handlerdata = d;
#line 1048
  return;
}
}
#line 1050 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_letterspersec(uih_context *c , int n ) 
{ 


  {
#line 1052
  if (n < 1) {
#line 1053
    n = 1;
  }
#line 1054
  c->letterspersec = n;
#line 1055
  return;
}
}
#line 1057 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
double uih_displayed(uih_context *c ) 
{ 
  int drawingtime ;
  int i ;
  int time1 ;
  int time___0 ;

  {
  {
#line 1060
  uih_finishpalette(c);
  }
#line 1061
  if (c->indofractal) {
#line 1062
    return ((double )0);
  }
#line 1063
  if (c->recalculatemode) {
#line 1064
    c->display = 1;
  } else {
#line 1066
    c->display = 0;
  }
  {
#line 1067
  tl_update_time();
#line 1068
  uih_resumetimers(c);
#line 1069
  c->nonfractalscreen = 0;
#line 1070
  c->nletters = 0;
  }
#line 1071
  if (c->incalculation) {
    {
#line 1072
    c->incalculation = 0;
#line 1073
    drawingtime = tl_lookup_timer(c->calculatetimer);
    }
#line 1074
    if (c->emulator) {
#line 1075
      drawingtime = 0;
    }
#line 1076
    if (c->lasttime == (double )-1) {
#line 1080
      c->lasttime = (double )drawingtime;
    } else
#line 1076
    if (drawingtime) {
#line 1076
      if (c->lasttime) {
#line 1076
        if ((double )drawingtime / c->lasttime < 0.2) {
#line 1080
          c->lasttime = (double )drawingtime;
        } else
#line 1076
        if ((double )drawingtime / c->lasttime > (double )4) {
#line 1080
          c->lasttime = (double )drawingtime;
        }
      }
    }
#line 1081
    c->lasttime = (c->lasttime * (double )30 + (double )drawingtime) / (double )31;
#line 1082
    if (c->lasttime) {
#line 1082
      c->lastspeed = 1000000.0 / c->lasttime;
    } else {
#line 1082
      c->lastspeed = 100.0;
    }
#line 1083
    if (c->interruptiblemode) {
#line 1086
      time1 = drawingtime;
#line 1087
      time1 -= c->endtime;
#line 1088
      time___0 = (drawingtime - c->endtime) + c->starttime;
#line 1089
      if (c->times[0][0] == -1) {
#line 1090
        i = 0;
        {
#line 1090
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1090
          if (! (i < 50)) {
#line 1090
            goto while_break;
          }
#line 1091
          c->times[0][i] = time___0;
#line 1091
          c->times[1][i] = time1;
#line 1090
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 1092
        c->count[0] = time___0 * 50;
#line 1092
        c->count[1] = time1 * 50;
      }
#line 1095
      c->timespos = (c->timespos + 1) % 50;
#line 1096
      c->count[0] += time___0 - c->times[0][c->timespos];
#line 1097
      c->count[1] += time1 - c->times[1][c->timespos];
#line 1098
      c->times[0][c->timespos] = time___0;
#line 1099
      c->times[1][c->timespos] = time1;
#line 1100
      c->maxtime = (c->count[0] * 5) / 50;
#line 1101
      if (c->step) {
#line 1101
        goto _L;
      } else
#line 1101
      if (c->pressed) {
#line 1101
        goto _L;
      } else
#line 1101
      if (c->play) {
#line 1101
        if ((c->playc)->morph) {
#line 1101
          goto _L;
        } else
#line 1101
        if ((c->playc)->morphangle) {
#line 1101
          goto _L;
        } else
#line 1101
        if ((c->playc)->morphjulia) {
#line 1101
          goto _L;
        } else
#line 1101
        if ((c->playc)->lines.morphing) {
#line 1101
          goto _L;
        } else {
#line 1101
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1101
      if (c->rotatemode == 2) {
#line 1101
        goto _L;
      } else
#line 1101
      if (c->fastanimation) {
        _L: /* CIL Label */ 
#line 1108
        if (c->maxtime > 40000) {
#line 1109
          c->maxtime = (c->count[0] * 3) / 50;
        }
#line 1110
        if (c->maxtime > 66666) {
#line 1111
          c->maxtime = 66666;
        }
      } else {
#line 1113
        c->maxtime = 333333;
      }
#line 1115
      if (c->maxtime < 33333) {
#line 1116
        c->maxtime = 33333;
      }
#line 1117
      c->maxtime -= c->count[1] / 50;
#line 1118
      if (c->maxtime < c->starttime + 10000) {
#line 1119
        c->maxtime = c->starttime + 10000;
      }
    }
  }
  {
#line 1122
  uih_callcomplette(c);
  }
#line 1123
  return (c->lastspeed);
}
}
#line 1126 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_text(uih_context *c , char const   *text ) 
{ 
  int i ;
  int l ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 1129
  c->display = 1;
#line 1130
  if (c->text[c->ytextpos]) {
    {
#line 1131
    free((void *)c->text[c->ytextpos]);
    }
  }
  {
#line 1132
  c->textpos[c->ytextpos] = c->xtextpos;
#line 1133
  c->textcolor[c->ytextpos] = c->color;
#line 1134
  c->displaytext |= 1 << c->ytextpos;
#line 1135
  c->text[c->ytextpos] = mystrdup(text);
#line 1136
  tmp = strlen(text);
#line 1136
  l = (int )tmp;
#line 1137
  c->todisplayletters = 0;
#line 1138
  i = 0;
  }
  {
#line 1138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1138
    if (! (i < l)) {
#line 1138
      goto while_break;
    }
    {
#line 1139
    tmp___0 = __ctype_b_loc();
    }
#line 1139
    if ((int const   )*(*tmp___0 + (int )*(text + i)) & 8) {
#line 1140
      (c->todisplayletters) ++;
    }
#line 1141
    if ((int const   )*(text + i) == 45) {
#line 1142
      c->todisplayletters += 3;
    }
#line 1143
    if ((int const   )*(text + i) == 46) {
#line 1144
      c->todisplayletters += 2;
    }
#line 1138
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1146
  c->step = (number_t )0;
#line 1147
  return;
}
}
#line 1149 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_clearscreen(uih_context *c ) 
{ 


  {
#line 1151
  c->clearscreen = 1;
#line 1152
  if (c->save) {
#line 1153
    (c->savec)->clearscreen = 1;
  }
#line 1154
  if (c->displaytext) {
#line 1155
    c->displaytext = 0;
  }
#line 1156
  if ((unsigned long )c->text[0] != (unsigned long )((void *)0)) {
    {
#line 1157
    free((void *)c->text[0]);
#line 1157
    c->text[0] = (char *)((void *)0);
    }
  }
#line 1158
  if ((unsigned long )c->text[1] != (unsigned long )((void *)0)) {
    {
#line 1159
    free((void *)c->text[1]);
#line 1159
    c->text[1] = (char *)((void *)0);
    }
  }
#line 1160
  if ((unsigned long )c->text[2] != (unsigned long )((void *)0)) {
    {
#line 1161
    free((void *)c->text[2]);
#line 1161
    c->text[2] = (char *)((void *)0);
    }
  }
#line 1162
  c->nletters = 0;
#line 1163
  c->display = 1;
#line 1164
  if (c->play) {
    {
#line 1165
    uih_clear_lines(c);
    }
  }
#line 1166
  return;
}
}
#line 1168 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_settextpos(uih_context *c , int x , int y ) 
{ 
  char const   *names1[3] ;
  char const   *names2[3] ;

  {
#line 1170
  names1[0] = "ytextposup";
#line 1170
  names1[1] = "ytextposmiddle";
#line 1170
  names1[2] = "ytextposbottom";
#line 1175
  names2[0] = "xtextposleft";
#line 1175
  names2[1] = "xtextposcenter";
#line 1175
  names2[2] = "xtextposright";
#line 1180
  c->xtextpos = x;
#line 1181
  c->ytextpos = y;
#line 1182
  if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
    {
#line 1182
    (*(c->updatemenus))(c, names1[y]);
    }
  }
#line 1183
  if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
    {
#line 1183
    (*(c->updatemenus))(c, names2[x]);
    }
  }
#line 1184
  return;
}
}
#line 1189 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_tbreak(uih_context *c ) 
{ 


  {
#line 1191
  c->tbreak = 1;
#line 1192
  return;
}
}
#line 1194 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_emulatetimers(uih_context *c ) 
{ 


  {
#line 1196
  if ((unsigned long )c->emulator == (unsigned long )((void *)0)) {
#line 1197
    return;
  }
  {
#line 1198
  tl_emulate_timer(c->maintimer, c->emulator);
#line 1199
  tl_emulate_timer(c->doittimer, c->emulator);
  }
#line 1200
  if (c->autopilot) {
    {
#line 1201
    tl_emulate_timer(c->autopilottimer, c->emulator);
    }
  }
#line 1202
  if (c->cycling) {
    {
#line 1203
    tl_emulate_timer(c->cyclingtimer, c->emulator);
    }
  }
#line 1205
  if (c->play) {
    {
#line 1206
    tl_emulate_timer((c->playc)->timer, c->emulator);
    }
  }
#line 1208
  if (c->save) {
    {
#line 1209
    tl_emulate_timer((c->savec)->timer, c->emulator);
#line 1210
    tl_emulate_timer((c->savec)->synctimer, c->emulator);
    }
  }
#line 1212
  return;
}
}
#line 1214 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static void uih_unemulatetimers(uih_context *c ) 
{ 


  {
  {
#line 1216
  tl_unemulate_timer(c->maintimer);
#line 1217
  tl_unemulate_timer(c->doittimer);
  }
#line 1218
  if (c->autopilot) {
    {
#line 1219
    tl_unemulate_timer(c->autopilottimer);
    }
  }
#line 1220
  if (c->cycling) {
    {
#line 1221
    tl_unemulate_timer(c->cyclingtimer);
    }
  }
#line 1222
  if (c->play) {
    {
#line 1223
    tl_unemulate_timer((c->playc)->timer);
    }
  }
#line 1225
  if (c->save) {
    {
#line 1226
    tl_unemulate_timer((c->savec)->timer);
#line 1227
    tl_unemulate_timer((c->savec)->synctimer);
    }
  }
#line 1229
  return;
}
}
#line 1231 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_constantframetime(uih_context *c , int time___0 ) 
{ 


  {
#line 1233
  if ((unsigned long )c->emulator == (unsigned long )((void *)0)) {
    {
#line 1234
    c->emulator = tl_create_emulator();
    }
  }
  {
#line 1235
  c->emulatedframetime = time___0;
#line 1236
  uih_emulatetimers(c);
  }
#line 1237
  return;
}
}
#line 1239 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_noconstantframetime(uih_context *c ) 
{ 


  {
#line 1241
  if ((unsigned long )c->emulator == (unsigned long )((void *)0)) {
#line 1242
    return;
  }
  {
#line 1243
  uih_unemulatetimers(c);
#line 1244
  tl_free_emulator(c->emulator);
#line 1245
  c->emulator = (struct timeemulator *)((void *)0);
  }
#line 1246
  return;
}
}
#line 1248 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_stoptimers(uih_context *c ) 
{ 


  {
#line 1250
  if (! c->stoppedtimers) {
    {
#line 1251
    c->stoppedtimers = 1;
#line 1252
    c->display = 1;
#line 1253
    tl_stop_timer(c->maintimer);
#line 1254
    tl_stop_timer(c->doittimer);
    }
#line 1255
    if (c->autopilot) {
      {
#line 1256
      tl_stop_timer(c->autopilottimer);
      }
    }
#line 1257
    if (c->play) {
      {
#line 1258
      tl_stop_timer((c->playc)->timer);
      }
#line 1259
      if (c->cycling) {
        {
#line 1260
        tl_stop_timer(c->cyclingtimer);
        }
      }
    }
#line 1262
    if (c->save) {
      {
#line 1263
      tl_stop_timer((c->savec)->timer);
#line 1264
      tl_stop_timer((c->savec)->synctimer);
      }
#line 1265
      if (c->cycling) {
        {
#line 1266
        tl_stop_timer(c->cyclingtimer);
        }
      }
    }
  }
#line 1269
  return;
}
}
#line 1271 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_slowdowntimers(uih_context *c , int time___0 ) 
{ 


  {
  {
#line 1273
  tl_slowdown_timer(c->maintimer, time___0);
  }
#line 1274
  if (c->autopilot) {
    {
#line 1275
    tl_slowdown_timer(c->autopilottimer, time___0);
    }
  }
#line 1276
  if (c->play) {
    {
#line 1277
    tl_slowdown_timer((c->playc)->timer, time___0);
    }
#line 1278
    if (c->cycling) {
      {
#line 1279
      tl_slowdown_timer(c->cyclingtimer, time___0);
      }
    }
  }
#line 1281
  if (c->save) {
    {
#line 1282
    tl_slowdown_timer((c->savec)->timer, time___0);
#line 1283
    tl_slowdown_timer((c->savec)->synctimer, time___0);
    }
#line 1284
    if (c->cycling) {
      {
#line 1285
      tl_slowdown_timer(c->cyclingtimer, time___0);
      }
    }
  }
#line 1287
  return;
}
}
#line 1289 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_resumetimers(uih_context *c ) 
{ 


  {
#line 1291
  if (c->stoppedtimers) {
    {
#line 1292
    c->stoppedtimers = 0;
#line 1293
    tl_resume_timer(c->maintimer);
    }
#line 1294
    if (c->cycling) {
      {
#line 1295
      tl_resume_timer(c->cyclingtimer);
      }
    }
#line 1296
    if (c->autopilot) {
      {
#line 1297
      tl_resume_timer(c->autopilottimer);
      }
    }
#line 1298
    if (c->play) {
      {
#line 1299
      tl_resume_timer((c->playc)->timer);
      }
    }
#line 1301
    if (c->save) {
      {
#line 1302
      tl_resume_timer((c->savec)->timer);
#line 1303
      tl_resume_timer((c->savec)->synctimer);
      }
    }
  }
#line 1306
  return;
}
}
#line 1310 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static void uih_changed(void) 
{ 


  {
#line 1312
  uih___0->display = 1;
#line 1312
  if (uih___0->recalculatemode > 2) {
#line 1312
    uih___0->recalculatemode = uih___0->recalculatemode;
  } else {
#line 1312
    uih___0->recalculatemode = 2;
  }
#line 1313
  return;
}
}
#line 1315 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static void uih_autopilothandler(void *uih1 , int n ) 
{ 


  {
  {
#line 1317
  uih___0 = (uih_context *)uih1;
#line 1318
  do_autopilot(uih___0, & uih___0->autopilotx, & uih___0->autopiloty, & uih___0->autopilotbuttons,
               & uih_changed, n);
  }
#line 1320
  return;
}
}
#line 1322 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
__inline static void uih_zoom(uih_context *uih___2 ) 
{ 


  {
#line 1324
  uih___2->step += (uih___2->speedup * (number_t )2) * (number_t )uih___2->mul;
#line 1325
  if (uih___2->step > uih___2->maxstep) {
#line 1326
    uih___2->step = uih___2->maxstep;
  } else
#line 1327
  if (uih___2->step < - uih___2->maxstep) {
#line 1328
    uih___2->step = - uih___2->maxstep;
  }
#line 1329
  return;
}
}
#line 1331 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
__inline static void uih_unzoom(uih_context *uih___2 ) 
{ 


  {
#line 1333
  uih___2->step -= (uih___2->speedup * (number_t )2) * (number_t )uih___2->mul;
#line 1334
  if (uih___2->step > uih___2->maxstep) {
#line 1335
    uih___2->step = uih___2->maxstep;
  } else
#line 1336
  if (uih___2->step < - uih___2->maxstep) {
#line 1337
    uih___2->step = - uih___2->maxstep;
  }
#line 1338
  return;
}
}
#line 1340 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
__inline static void uih_slowdown(uih_context *uih___2 ) 
{ 


  {
#line 1342
  if (uih___2->step > (number_t )0) {
#line 1343
    if (uih___2->step < uih___2->speedup * (number_t )uih___2->mul) {
#line 1344
      uih___2->step = (number_t )0;
    } else {
#line 1346
      uih___2->step -= uih___2->speedup * (number_t )uih___2->mul;
    }
  } else
#line 1347
  if (uih___2->step < (number_t )0) {
#line 1348
    if (uih___2->step > - uih___2->speedup * (number_t )uih___2->mul) {
#line 1349
      uih___2->step = (number_t )0;
    } else {
#line 1351
      uih___2->step += uih___2->speedup * (number_t )uih___2->mul;
    }
  }
#line 1353
  return;
}
}
#line 1355 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
__inline static void uih_zoomupdate(uih_context *uih___2 ) 
{ 
  number_t x ;
  number_t y ;
  number_t mmul ;
  double tmp ;
  number_t mc ;
  number_t nc ;
  number_t mi ;
  number_t ni ;

  {
  {
#line 1359
  tmp = pow((double )((number_t )1 - uih___2->step), uih___2->mul);
#line 1359
  mmul = (number_t )tmp;
#line 1360
  mc = (uih___2->fcontext)->s.cr - (uih___2->fcontext)->s.rr / (number_t )2;
#line 1361
  nc = (uih___2->fcontext)->s.cr + (uih___2->fcontext)->s.rr / (number_t )2;
#line 1362
  mi = (uih___2->fcontext)->s.ci - (uih___2->fcontext)->s.ri / (number_t )2;
#line 1363
  ni = (uih___2->fcontext)->s.ci + (uih___2->fcontext)->s.ri / (number_t )2;
#line 1364
  x = uih___2->xcenter;
#line 1364
  y = uih___2->ycenter;
#line 1365
  mc = x + (mc - x) * mmul;
#line 1366
  nc = x + (nc - x) * mmul;
#line 1367
  mi = y + (mi - y) * mmul;
#line 1368
  ni = y + (ni - y) * mmul;
#line 1369
  (uih___2->fcontext)->s.rr = nc - mc;
#line 1370
  (uih___2->fcontext)->s.ri = ni - mi;
#line 1371
  (uih___2->fcontext)->s.cr = (nc + mc) / (number_t )2;
#line 1372
  (uih___2->fcontext)->s.ci = (ni + mi) / (number_t )2;
#line 1373
  uih___2->display = 1;
  }
#line 1373
  if (uih___2->recalculatemode > 1) {
#line 1373
    uih___2->recalculatemode = uih___2->recalculatemode;
  } else {
#line 1373
    uih___2->recalculatemode = 1;
  }
#line 1374
  return;
}
}
#line 1379 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
int uih_update(uih_context *c , int mousex , int mousey , int mousebuttons ) 
{ 
  int inmovement ;
  int slowdown ;
  int time___0 ;
  int timer ;
  int tmp ;
  number_t mmul ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  number_t srr ;
  number_t drr ;
  number_t mmul1 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  int timer___0 ;
  int tmp___8 ;
  number_t mmul___0 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  number_t tmp___13 ;
  int timer___1 ;
  int tmp___14 ;
  number_t mmul___1 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;
  number_t x ;
  number_t y ;
  number_t x___0 ;
  number_t y___0 ;
  number_t x___1 ;
  number_t y___1 ;
  number_t angle ;
  double tmp___19 ;
  number_t x___2 ;
  number_t x1 ;
  number_t y___2 ;
  number_t y1___0 ;

  {
#line 1381
  inmovement = 0;
#line 1382
  slowdown = 1;
#line 1384
  uih___0 = c;
#line 1386
  if (! mousebuttons) {
#line 1386
    if (uih___0->lastbuttons) {
      {
#line 1387
      uih_saveundo(c);
      }
    }
  }
#line 1388
  uih___0->lastbuttons = mousebuttons;
#line 1389
  if (c->incalculation) {
#line 1390
    return (0);
  }
#line 1391
  if ((unsigned long )c->emulator != (unsigned long )((void *)0)) {
    {
#line 1392
    tl_elpased(c->emulator, c->emulatedframetime);
    }
  }
#line 1394
  if (mousebuttons == 1280) {
#line 1395
    mousebuttons = 512;
  }
  {
#line 1396
  tl_process_group(syncgroup, (int *)((void *)0));
#line 1397
  tl_update_time();
#line 1398
  time___0 = tl_lookup_timer(c->maintimer);
  }
#line 1399
  if (c->autopilot) {
    {
#line 1400
    tl_process_group(c->autopilotgroup, (int *)((void *)0));
    }
  }
#line 1402
  if (! c->inanimation) {
#line 1403
    time___0 = 0;
  }
#line 1404
  if (time___0 > 2000000) {
    {
#line 1405
    uih_slowdowntimers(uih___0, time___0 - 2000000);
#line 1406
    time___0 = 2000000;
    }
  }
#line 1408
  if (c->inanimation) {
#line 1409
    (c->inanimation) --;
  }
  {
#line 1410
  tl_reset_timer(c->maintimer);
#line 1411
  c->mul = (double )time___0 / (double )50000;
  }
#line 1412
  if (c->fixedstep) {
#line 1413
    c->mul = 0.3;
  }
#line 1414
  if (c->tbreak) {
#line 1415
    c->mul = (double )1;
#line 1415
    (c->tbreak) --;
  }
#line 1416
  if (c->mul == (double )0) {
#line 1417
    c->mul = 0.00000001;
  }
#line 1418
  if (c->play) {
    {
#line 1419
    uih_playupdate(c);
    }
#line 1420
    if (! c->play) {
#line 1421
      c->inanimation = 2;
#line 1422
      return (1);
    }
#line 1424
    if ((c->playc)->lines.morphing) {
      {
#line 1425
      uih_update_lines(c);
      }
    }
#line 1426
    if (c->step) {
      {
#line 1427
      uih_zoomupdate(c);
#line 1427
      inmovement = 1;
      }
    }
    {
#line 1429
    if (c->zoomactive == 1) {
#line 1429
      goto case_1;
    }
#line 1432
    if (c->zoomactive == -1) {
#line 1432
      goto case_neg_1;
    }
#line 1435
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 1430
    uih_zoom(c);
#line 1430
    inmovement = 1;
    }
#line 1431
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 1433
    uih_unzoom(c);
#line 1433
    inmovement = 1;
    }
#line 1434
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1436
    uih_slowdown(c);
    }
    switch_break: /* CIL Label */ ;
    }
#line 1438
    if ((c->playc)->morph) {
      {
#line 1439
      tmp = tl_lookup_timer((c->playc)->timer);
#line 1439
      timer = tmp - (c->playc)->starttime;
      }
#line 1441
      if (timer < 0) {
#line 1441
        tmp___3 = 0.0;
      } else {
#line 1441
        if (timer >= (c->playc)->frametime - (c->playc)->starttime) {
#line 1441
          tmp___2 = 1.0;
        } else {
#line 1441
          if (timer < (c->playc)->morphtimes[0]) {
#line 1441
            if ((c->playc)->morphtimes[0]) {
#line 1441
              tmp___1 = (((((double )timer / (double )(c->playc)->morphtimes[0]) * ((double )timer / (double )(c->playc)->morphtimes[0])) / (double )2) * (double )(c->playc)->morphtimes[0]) / (double )((((c->playc)->frametime - (c->playc)->starttime) - (c->playc)->morphtimes[0] / 2) - (c->playc)->morphtimes[1] / 2);
            } else {
#line 1441
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 1441
            if (((c->playc)->frametime - (c->playc)->starttime) - timer < (c->playc)->morphtimes[1]) {
#line 1441
              if ((c->playc)->morphtimes[1]) {
#line 1441
                tmp___0 = (double )1 - (((((double )(((c->playc)->frametime - (c->playc)->starttime) - timer) / (double )(c->playc)->morphtimes[1]) * ((double )(((c->playc)->frametime - (c->playc)->starttime) - timer) / (double )(c->playc)->morphtimes[1])) / (double )2) * (double )(c->playc)->morphtimes[1]) / (double )((((c->playc)->frametime - (c->playc)->starttime) - (c->playc)->morphtimes[0] / 2) - (c->playc)->morphtimes[1] / 2);
              } else {
#line 1441
                tmp___0 = (double )(timer - (c->playc)->morphtimes[0] / 2) / (((double )((c->playc)->frametime - (c->playc)->starttime) - (double )((c->playc)->morphtimes[0] / 2)) - (double )((c->playc)->morphtimes[1] / 2));
              }
            } else {
#line 1441
              tmp___0 = (double )(timer - (c->playc)->morphtimes[0] / 2) / (((double )((c->playc)->frametime - (c->playc)->starttime) - (double )((c->playc)->morphtimes[0] / 2)) - (double )((c->playc)->morphtimes[1] / 2));
            }
#line 1441
            tmp___1 = tmp___0;
          }
#line 1441
          tmp___2 = tmp___1;
        }
#line 1441
        tmp___3 = tmp___2;
      }
#line 1441
      mmul = (number_t )tmp___3;
#line 1448
      if ((c->playc)->source.rr * (number_t )(c->fcontext)->windowwidth > (c->playc)->source.ri * (number_t )(c->fcontext)->windowheight) {
#line 1450
        srr = (c->playc)->source.rr;
      } else {
#line 1452
        srr = (c->playc)->source.ri;
      }
#line 1453
      if ((c->playc)->destination.rr * (number_t )(c->fcontext)->windowwidth > (c->playc)->destination.ri * (number_t )(c->fcontext)->windowheight) {
#line 1455
        drr = (c->playc)->destination.rr;
      } else {
#line 1457
        drr = (c->playc)->destination.ri;
      }
#line 1458
      if (srr == drr) {
#line 1459
        mmul1 = mmul;
      } else {
        {
#line 1461
        tmp___4 = log((double )srr);
#line 1461
        tmp___5 = log((double )drr);
#line 1461
        tmp___6 = log((double )srr);
#line 1461
        tmp___7 = exp((double )((number_t )tmp___4 + (number_t )(tmp___5 - tmp___6) * mmul));
#line 1461
        mmul1 = ((number_t )tmp___7 - srr) / (drr - srr);
        }
      }
#line 1464
      if (mmul1 > (number_t )1) {
#line 1465
        mmul1 = (number_t )1;
      }
#line 1466
      if (mmul1 < (number_t )0) {
#line 1467
        mmul1 = (number_t )0;
      }
#line 1468
      inmovement = 1;
#line 1469
      (c->fcontext)->s.rr = (c->playc)->source.rr + ((c->playc)->destination.rr - (c->playc)->source.rr) * mmul1;
#line 1472
      (c->fcontext)->s.ri = (c->playc)->source.ri + ((c->playc)->destination.ri - (c->playc)->source.ri) * mmul1;
#line 1475
      (c->fcontext)->s.cr = (c->playc)->source.cr + ((c->playc)->destination.cr - (c->playc)->source.cr) * mmul1;
#line 1478
      (c->fcontext)->s.ci = (c->playc)->source.ci + ((c->playc)->destination.ci - (c->playc)->source.ci) * mmul1;
#line 1481
      c->display = 1;
#line 1481
      if (c->recalculatemode > 1) {
#line 1481
        c->recalculatemode = c->recalculatemode;
      } else {
#line 1481
        c->recalculatemode = 1;
      }
    }
#line 1483
    if ((c->playc)->morphjulia) {
      {
#line 1484
      tmp___8 = tl_lookup_timer((c->playc)->timer);
#line 1484
      timer___0 = tmp___8 - (c->playc)->starttime;
      }
#line 1486
      if (timer___0 < 0) {
#line 1486
        tmp___12 = 0.0;
      } else {
#line 1486
        if (timer___0 >= (c->playc)->frametime - (c->playc)->starttime) {
#line 1486
          tmp___11 = 1.0;
        } else {
#line 1486
          if (timer___0 < (c->playc)->morphjuliatimes[0]) {
#line 1486
            if ((c->playc)->morphjuliatimes[0]) {
#line 1486
              tmp___10 = (((((double )timer___0 / (double )(c->playc)->morphjuliatimes[0]) * ((double )timer___0 / (double )(c->playc)->morphjuliatimes[0])) / (double )2) * (double )(c->playc)->morphjuliatimes[0]) / (double )((((c->playc)->frametime - (c->playc)->starttime) - (c->playc)->morphjuliatimes[0] / 2) - (c->playc)->morphjuliatimes[1] / 2);
            } else {
#line 1486
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
#line 1486
            if (((c->playc)->frametime - (c->playc)->starttime) - timer___0 < (c->playc)->morphjuliatimes[1]) {
#line 1486
              if ((c->playc)->morphjuliatimes[1]) {
#line 1486
                tmp___9 = (double )1 - (((((double )(((c->playc)->frametime - (c->playc)->starttime) - timer___0) / (double )(c->playc)->morphjuliatimes[1]) * ((double )(((c->playc)->frametime - (c->playc)->starttime) - timer___0) / (double )(c->playc)->morphjuliatimes[1])) / (double )2) * (double )(c->playc)->morphjuliatimes[1]) / (double )((((c->playc)->frametime - (c->playc)->starttime) - (c->playc)->morphjuliatimes[0] / 2) - (c->playc)->morphjuliatimes[1] / 2);
              } else {
#line 1486
                tmp___9 = (double )(timer___0 - (c->playc)->morphjuliatimes[0] / 2) / (((double )((c->playc)->frametime - (c->playc)->starttime) - (double )((c->playc)->morphjuliatimes[0] / 2)) - (double )((c->playc)->morphjuliatimes[1] / 2));
              }
            } else {
#line 1486
              tmp___9 = (double )(timer___0 - (c->playc)->morphjuliatimes[0] / 2) / (((double )((c->playc)->frametime - (c->playc)->starttime) - (double )((c->playc)->morphjuliatimes[0] / 2)) - (double )((c->playc)->morphjuliatimes[1] / 2));
            }
#line 1486
            tmp___10 = tmp___9;
          }
#line 1486
          tmp___11 = tmp___10;
        }
#line 1486
        tmp___12 = tmp___11;
      }
      {
#line 1486
      mmul___0 = (number_t )tmp___12;
#line 1491
      tmp___13 = (c->playc)->si + ((c->playc)->di - (c->playc)->si) * mmul___0;
#line 1491
      (c->fcontext)->pim = tmp___13;
#line 1491
      uih_setjuliaseed(uih___0, (c->playc)->sr + ((c->playc)->dr - (c->playc)->sr) * mmul___0,
                       tmp___13);
#line 1497
      inmovement = 1;
      }
    }
#line 1499
    if ((c->playc)->morphangle) {
      {
#line 1500
      tmp___14 = tl_lookup_timer((c->playc)->timer);
#line 1500
      timer___1 = tmp___14 - (c->playc)->starttime;
      }
#line 1502
      if (timer___1 < 0) {
#line 1502
        tmp___18 = 0.0;
      } else {
#line 1502
        if (timer___1 >= (c->playc)->frametime - (c->playc)->starttime) {
#line 1502
          tmp___17 = 1.0;
        } else {
#line 1502
          if (timer___1 < (c->playc)->morphangletimes[0]) {
#line 1502
            if ((c->playc)->morphangletimes[0]) {
#line 1502
              tmp___16 = (((((double )timer___1 / (double )(c->playc)->morphangletimes[0]) * ((double )timer___1 / (double )(c->playc)->morphangletimes[0])) / (double )2) * (double )(c->playc)->morphangletimes[0]) / (double )((((c->playc)->frametime - (c->playc)->starttime) - (c->playc)->morphangletimes[0] / 2) - (c->playc)->morphangletimes[1] / 2);
            } else {
#line 1502
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 1502
            if (((c->playc)->frametime - (c->playc)->starttime) - timer___1 < (c->playc)->morphangletimes[1]) {
#line 1502
              if ((c->playc)->morphangletimes[1]) {
#line 1502
                tmp___15 = (double )1 - (((((double )(((c->playc)->frametime - (c->playc)->starttime) - timer___1) / (double )(c->playc)->morphangletimes[1]) * ((double )(((c->playc)->frametime - (c->playc)->starttime) - timer___1) / (double )(c->playc)->morphangletimes[1])) / (double )2) * (double )(c->playc)->morphangletimes[1]) / (double )((((c->playc)->frametime - (c->playc)->starttime) - (c->playc)->morphangletimes[0] / 2) - (c->playc)->morphangletimes[1] / 2);
              } else {
#line 1502
                tmp___15 = (double )(timer___1 - (c->playc)->morphangletimes[0] / 2) / (((double )((c->playc)->frametime - (c->playc)->starttime) - (double )((c->playc)->morphangletimes[0] / 2)) - (double )((c->playc)->morphangletimes[1] / 2));
              }
            } else {
#line 1502
              tmp___15 = (double )(timer___1 - (c->playc)->morphangletimes[0] / 2) / (((double )((c->playc)->frametime - (c->playc)->starttime) - (double )((c->playc)->morphangletimes[0] / 2)) - (double )((c->playc)->morphangletimes[1] / 2));
            }
#line 1502
            tmp___16 = tmp___15;
          }
#line 1502
          tmp___17 = tmp___16;
        }
#line 1502
        tmp___18 = tmp___17;
      }
      {
#line 1502
      mmul___1 = (number_t )tmp___18;
#line 1507
      uih_angle(uih___0, (c->playc)->srcangle + ((c->playc)->destangle - (c->playc)->srcangle) * mmul___1);
#line 1510
      inmovement = 1;
      }
    }
  } else
#line 1513
  if (! c->juliamode) {
#line 1514
    if (c->autopilot) {
#line 1515
      mousex = c->autopilotx;
#line 1516
      mousey = c->autopiloty;
#line 1517
      mousebuttons = c->autopilotbuttons;
#line 1518
      inmovement = 1;
    }
#line 1520
    if (c->step) {
#line 1523
      if (mousex != c->xcenterm) {
        {
#line 1524
        c->xcenterm = mousex;
#line 1525
        c->ycenterm = mousey;
#line 1526
        uih_getcoord(uih___0, mousex, mousey, & x, & y);
#line 1527
        c->xcenter = x;
#line 1528
        c->ycenter = y;
        }
      } else
#line 1523
      if (mousey != c->ycenterm) {
        {
#line 1524
        c->xcenterm = mousex;
#line 1525
        c->ycenterm = mousey;
#line 1526
        uih_getcoord(uih___0, mousex, mousey, & x, & y);
#line 1527
        c->xcenter = x;
#line 1528
        c->ycenter = y;
        }
      }
      {
#line 1530
      uih_zoomupdate(c);
#line 1530
      inmovement = 1;
      }
    }
#line 1532
    c->zoomactive = 0;
#line 1533
    if (c->rotatemode != 1) {
      {
#line 1535
      if (mousebuttons == 256) {
#line 1535
        goto case_256;
      }
#line 1539
      if (mousebuttons == 1024) {
#line 1539
        goto case_1024;
      }
#line 1534
      goto switch_break___0;
      case_256: /* CIL Label */ 
#line 1536
      c->zoomactive = 1;
#line 1537
      inmovement = 1;
#line 1538
      goto switch_break___0;
      case_1024: /* CIL Label */ 
#line 1540
      c->zoomactive = -1;
#line 1541
      inmovement = 1;
#line 1542
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    {
#line 1544
    uih_saveframe(c);
    }
#line 1545
    if (c->rotatemode != 1) {
#line 1546
      c->rotatepressed = 0;
      {
#line 1548
      if (mousebuttons == 256) {
#line 1548
        goto case_256___0;
      }
#line 1551
      if (mousebuttons == 1024) {
#line 1551
        goto case_1024___0;
      }
#line 1554
      if (mousebuttons == 512) {
#line 1554
        goto case_512;
      }
#line 1547
      goto switch_break___1;
      case_256___0: /* CIL Label */ 
      {
#line 1549
      uih_zoom(c);
#line 1549
      slowdown = 0;
      }
#line 1550
      goto switch_break___1;
      case_1024___0: /* CIL Label */ 
      {
#line 1552
      uih_unzoom(c);
#line 1552
      slowdown = 0;
      }
#line 1553
      goto switch_break___1;
      case_512: /* CIL Label */ 
      {
#line 1557
      uih_getcoord(uih___0, mousex, mousey, & x___0, & y___0);
      }
#line 1558
      if (c->pressed) {
#line 1558
        if (c->oldx != x___0) {
#line 1558
          goto _L___2;
        } else
#line 1558
        if (c->oldy != y___0) {
          _L___2: /* CIL Label */ 
#line 1559
          (c->fcontext)->s.cr -= x___0 - c->oldx;
#line 1560
          (c->fcontext)->s.ci -= y___0 - c->oldy;
#line 1561
          c->display = 1;
#line 1561
          if (c->recalculatemode > 1) {
#line 1561
            c->recalculatemode = c->recalculatemode;
          } else {
#line 1561
            c->recalculatemode = 1;
          }
#line 1562
          c->moved = 1;
        }
      }
      {
#line 1564
      c->pressed = 1;
#line 1565
      c->speed = (number_t )0;
#line 1566
      update_view(c->fcontext);
#line 1567
      uih_getcoord(uih___0, mousex, mousey, & c->oldx, & c->oldy);
      }
#line 1570
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    } else
#line 1573
    if (mousebuttons & 256) {
      {
#line 1577
      x___1 = (number_t )((float )(mousex - (c->image)->width / 2) * (c->image)->pixelwidth);
#line 1579
      y___1 = (number_t )((float )(mousey - (c->image)->height / 2) * (c->image)->pixelheight);
#line 1581
      tmp___19 = atan2((double )x___1, (double )y___1);
#line 1581
      angle = (number_t )((- tmp___19 * (double )180) / 3.14159265358979323846);
      }
#line 1582
      if (c->rotatepressed) {
        {
#line 1583
        uih_angle(uih___0, ((c->fcontext)->angle + angle) - c->oldangle);
        }
      }
#line 1587
      c->rotatepressed = 1;
#line 1588
      c->oldangle = angle;
    } else {
#line 1590
      c->rotatepressed = 0;
    }
#line 1592
    if (! (mousebuttons & 512)) {
#line 1593
      c->pressed = 0;
    }
#line 1594
    if (slowdown) {
      {
#line 1595
      uih_slowdown(c);
      }
    }
  } else
#line 1597
  if (mousebuttons & 256) {
    {
#line 1598
    x1 = (c->fcontext)->pre;
#line 1599
    y1___0 = (c->fcontext)->pim;
#line 1600
    c->zoomactive = 0;
#line 1601
    uih_getcoord(uih___0, mousex, mousey, & x___2, & y___2);
#line 1602
    (c->fcontext)->pre = x___2;
#line 1603
    (c->fcontext)->pim = y___2;
#line 1604
    uih_saveframe(c);
#line 1605
    c->pressed = 1;
#line 1606
    recalculate((c->fcontext)->plane, & (c->fcontext)->pre, & (c->fcontext)->pim);
    }
#line 1608
    if ((c->fcontext)->pre != x1) {
#line 1608
      goto _L___3;
    } else
#line 1608
    if ((c->fcontext)->pim != y1___0) {
      _L___3: /* CIL Label */ 
#line 1609
      c->display = 1;
#line 1609
      if (c->recalculatemode > 1) {
#line 1609
        c->recalculatemode = c->recalculatemode;
      } else {
#line 1609
        c->recalculatemode = 1;
      }
    }
  } else {
#line 1612
    c->pressed = 0;
  }
#line 1615
  if (! inmovement) {
    {
#line 1616
    uih_tbreak(c);
    }
  }
#line 1617
  if (c->uncomplette) {
#line 1618
    inmovement = 1;
  }
#line 1619
  if (! c->recalculatemode) {
#line 1619
    if (! c->display) {
      {
#line 1620
      uih_finishpalette(c);
      }
    }
  }
#line 1621
  if (! inmovement) {
    {
#line 1622
    uih_callcomplette(c);
    }
  }
#line 1623
  if (c->inanimation < inmovement * 2) {
#line 1624
    c->inanimation = inmovement * 2;
  }
#line 1625
  return (inmovement * 2);
}
}
#line 1630 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_autopilot_on(uih_context *c ) 
{ 


  {
#line 1632
  if (! c->autopilot) {
    {
#line 1633
    clean_autopilot(c);
#line 1634
    uih_autopilothandler((void *)c, 1);
#line 1635
    tl_update_time();
#line 1636
    uih_resumetimers(c);
#line 1637
    c->autopilottimer = tl_create_timer();
#line 1638
    c->autopilotgroup = tl_create_group();
#line 1639
    tl_set_multihandler(c->autopilottimer, & uih_autopilothandler, (void *)c);
#line 1640
    tl_set_interval(c->autopilottimer, 40000);
#line 1641
    tl_reset_timer(c->autopilottimer);
#line 1642
    tl_add_timer(c->autopilotgroup, c->autopilottimer);
#line 1643
    tl_update_time();
#line 1644
    c->autopilot = 1;
#line 1645
    uih_emulatetimers(c);
    }
#line 1646
    if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
      {
#line 1646
      (*(c->updatemenus))(c, "autopilot");
      }
    }
  }
#line 1648
  return;
}
}
#line 1650 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_autopilot_off(uih_context *c ) 
{ 


  {
#line 1652
  if (c->autopilot) {
    {
#line 1653
    tl_remove_timer(c->autopilottimer);
#line 1654
    tl_free_timer(c->autopilottimer);
#line 1655
    tl_free_group(c->autopilotgroup);
#line 1656
    c->autopilot = 0;
    }
#line 1657
    if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
      {
#line 1657
      (*(c->updatemenus))(c, "autopilot");
      }
    }
  }
#line 1659
  return;
}
}
#line 1661 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_mkdefaultpalette(uih_context *c ) 
{ 
  int tmp ;

  {
#line 1663
  if ((unsigned long )((c->zengine)->fractalc)->palette == (unsigned long )((void *)0)) {
#line 1664
    return;
  }
  {
#line 1665
  uih_cycling_stop(c);
#line 1666
  tmp = mkdefaultpalette(((c->zengine)->fractalc)->palette);
  }
#line 1666
  if (tmp != 0) {
#line 1667
    c->display = 1;
#line 1667
    if (c->recalculatemode > 2) {
#line 1667
      c->recalculatemode = c->recalculatemode;
    } else {
#line 1667
      c->recalculatemode = 2;
    }
  }
#line 1669
  if (! c->recalculatemode) {
#line 1669
    if ((unsigned long )(c->queue)->palettechg != (unsigned long )((void *)0)) {
#line 1669
      c->recalculatemode = -2;
#line 1669
      c->display = 1;
    }
  }
  {
#line 1670
  c->paletteshift = 0;
#line 1671
  c->manualpaletteshift = 0;
#line 1672
  c->palettechanged = 1;
#line 1673
  c->palettetype = 0;
#line 1674
  uih_finishpalette(c);
#line 1675
  uih_cycling_continue(c);
  }
#line 1676
  return;
}
}
#line 1678 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_mkpalette(uih_context *c ) 
{ 
  int seed ;
  int alg ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1681
  tmp = rand();
#line 1681
  alg = tmp % 3;
  }
#line 1682
  if ((unsigned long )((c->zengine)->fractalc)->palette == (unsigned long )((void *)0)) {
#line 1683
    return;
  }
  {
#line 1684
  uih_cycling_stop(c);
#line 1685
  seed = rand();
#line 1685
  tmp___0 = mkpalette(((c->zengine)->fractalc)->palette, seed, alg);
  }
#line 1685
  if (tmp___0 != 0) {
#line 1686
    c->display = 1;
#line 1686
    if (c->recalculatemode > 2) {
#line 1686
      c->recalculatemode = c->recalculatemode;
    } else {
#line 1686
      c->recalculatemode = 2;
    }
  }
#line 1688
  if (! c->recalculatemode) {
#line 1688
    if ((unsigned long )(c->queue)->palettechg != (unsigned long )((void *)0)) {
#line 1688
      c->recalculatemode = -2;
#line 1688
      c->display = 1;
    }
  }
  {
#line 1689
  c->paletteshift = 0;
#line 1690
  c->manualpaletteshift = 0;
#line 1691
  c->paletteseed = seed;
#line 1692
  uih_finishpalette(c);
#line 1693
  c->palettechanged = 1;
#line 1694
  c->palettetype = alg + 1;
#line 1695
  uih_cycling_continue(c);
  }
#line 1696
  return;
}
}
#line 1700 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static void uih_alloctables(uih_context *c ) 
{ 


  {
  {
#line 1702
  c->zengine = (*(zoom_filter.getinstance))(& zoom_filter);
  }
#line 1703
  if ((unsigned long )c->zengine == (unsigned long )((void *)0)) {
#line 1704
    return;
  }
  {
#line 1705
  c->fcontext = make_fractalc((int const   )0, (c->image)->pixelwidth * (float )(c->image)->width,
                              (c->image)->pixelheight * (float )(c->image)->height);
  }
#line 1708
  if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
    {
#line 1708
    (*(c->updatemenus))(c, "periodicity");
    }
  }
#line 1708
  if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
    {
#line 1708
    (*(c->updatemenus))(c, "in0");
    }
  }
#line 1709
  if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
    {
#line 1709
    (*(c->updatemenus))(c, "int0");
    }
  }
#line 1709
  if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
    {
#line 1709
    (*(c->updatemenus))(c, "out0");
    }
  }
#line 1711
  if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
    {
#line 1711
    (*(c->updatemenus))(c, "outt0");
    }
  }
#line 1712
  if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
    {
#line 1712
    (*(c->updatemenus))(c, "plane0");
    }
  }
#line 1712
  if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
    {
#line 1712
    (*(c->updatemenus))(c, "guess3");
    }
  }
  {
#line 1712
  uih___0 = c;
#line 1713
  c->uifilter = (*(uih_filter.getinstance))(& uih_filter);
#line 1714
  c->queue = create_queue(c->uifilter);
#line 1715
  insertfilter(c->zengine, c->uifilter);
  }
#line 1716
  return;
}
}
#line 1718 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static int uih_initqueue(uih_context *c ) 
{ 
  int tmp ;

  {
  {
#line 1720
  tmp = initqueue(c->queue);
  }
#line 1720
  return (tmp);
}
}
#line 1723 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_setmaxstep(uih_context *c , number_t p ) 
{ 


  {
#line 1725
  c->maxstep = p;
#line 1726
  return;
}
}
#line 1728 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_setspeedup(uih_context *c , number_t p ) 
{ 


  {
#line 1730
  c->speedup = p;
#line 1731
  return;
}
}
#line 1733 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_setmaxiter(uih_context *c , int maxiter___0 ) 
{ 


  {
#line 1735
  if (maxiter___0 < 1) {
#line 1736
    maxiter___0 = 1;
  }
#line 1737
  if (maxiter___0 > 2000000) {
#line 1738
    maxiter___0 = 2000000;
  }
#line 1739
  if ((c->fcontext)->maxiter != (unsigned int )maxiter___0) {
#line 1740
    (c->fcontext)->maxiter = (unsigned int )maxiter___0;
#line 1741
    ((c->fcontext)->version) ++;
#line 1742
    c->display = 1;
#line 1742
    if (c->recalculatemode > 2) {
#line 1742
      c->recalculatemode = c->recalculatemode;
    } else {
#line 1742
      c->recalculatemode = 2;
    }
  }
#line 1744
  return;
}
}
#line 1746 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_setbailout(uih_context *c , number_t bailout ) 
{ 


  {
#line 1748
  if (bailout < (number_t )0) {
#line 1749
    bailout = (number_t )0;
  }
#line 1750
  if ((c->fcontext)->bailout != bailout) {
#line 1751
    (c->fcontext)->bailout = bailout;
#line 1752
    ((c->fcontext)->version) ++;
#line 1753
    c->display = 1;
#line 1753
    if (c->recalculatemode > 2) {
#line 1753
      c->recalculatemode = c->recalculatemode;
    } else {
#line 1753
      c->recalculatemode = 2;
    }
  }
#line 1755
  return;
}
}
#line 1757 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_setincoloringmode(uih_context *c , int mode ) 
{ 
  int tmp ;
  char str___0[10] ;

  {
#line 1759
  if (mode < 0) {
    {
#line 1760
    tmp = rand();
#line 1760
    mode = tmp % 11;
    }
  }
#line 1761
  if (mode > 11) {
#line 1762
    mode = 11;
  }
#line 1763
  if ((c->fcontext)->incoloringmode != mode) {
#line 1765
    (c->fcontext)->incoloringmode = mode;
#line 1766
    ((c->fcontext)->version) ++;
#line 1767
    c->display = 1;
#line 1767
    if (c->recalculatemode > 2) {
#line 1767
      c->recalculatemode = c->recalculatemode;
    } else {
#line 1767
      c->recalculatemode = 2;
    }
    {
#line 1768
    sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)"in%i",
            mode);
    }
#line 1769
    if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
      {
#line 1769
      (*(c->updatemenus))(c, (char const   *)(str___0));
      }
    }
  }
#line 1771
  return;
}
}
#line 1773 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_setintcolor(uih_context *c , int mode ) 
{ 
  int tmp ;
  char str___0[10] ;

  {
#line 1775
  if (mode < 0) {
    {
#line 1776
    tmp = rand();
#line 1776
    mode = tmp % 15;
    }
  }
#line 1777
  if (mode > 15) {
#line 1778
    mode = 15;
  }
#line 1779
  if ((c->fcontext)->intcolor != mode) {
#line 1781
    (c->fcontext)->intcolor = mode;
#line 1782
    if ((c->fcontext)->incoloringmode == 10) {
#line 1783
      ((c->fcontext)->version) ++;
#line 1784
      c->display = 1;
#line 1784
      if (c->recalculatemode > 2) {
#line 1784
        c->recalculatemode = c->recalculatemode;
      } else {
#line 1784
        c->recalculatemode = 2;
      }
    }
    {
#line 1786
    sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)"int%i",
            mode);
    }
#line 1787
    if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
      {
#line 1787
      (*(c->updatemenus))(c, (char const   *)(str___0));
      }
    }
  }
#line 1789
  return;
}
}
#line 1791 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_setouttcolor(uih_context *c , int mode ) 
{ 
  int tmp ;
  char str___0[10] ;

  {
#line 1793
  if (mode < 0) {
    {
#line 1794
    tmp = rand();
#line 1794
    mode = tmp % 15;
    }
  }
#line 1795
  if (mode > 15) {
#line 1796
    mode = 15;
  }
#line 1797
  if ((c->fcontext)->outtcolor != mode) {
#line 1799
    (c->fcontext)->outtcolor = mode;
#line 1800
    if ((c->fcontext)->coloringmode == 10) {
#line 1801
      ((c->fcontext)->version) ++;
#line 1802
      c->display = 1;
#line 1802
      if (c->recalculatemode > 2) {
#line 1802
        c->recalculatemode = c->recalculatemode;
      } else {
#line 1802
        c->recalculatemode = 2;
      }
    }
    {
#line 1804
    sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)"outt%i",
            mode);
    }
#line 1805
    if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
      {
#line 1805
      (*(c->updatemenus))(c, (char const   *)(str___0));
      }
    }
  }
#line 1807
  return;
}
}
#line 1809 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_setperbutation(uih_context *c , number_t zre , number_t zim ) 
{ 


  {
#line 1811
  if ((c->fcontext)->bre != zre) {
#line 1811
    goto _L;
  } else
#line 1811
  if ((c->fcontext)->bim != zim) {
    _L: /* CIL Label */ 
#line 1812
    (c->fcontext)->bre = zre;
#line 1813
    (c->fcontext)->bim = zim;
#line 1814
    if ((c->fcontext)->mandelbrot) {
#line 1815
      ((c->fcontext)->version) ++;
#line 1816
      c->display = 1;
#line 1816
      if (c->recalculatemode > 2) {
#line 1816
        c->recalculatemode = c->recalculatemode;
      } else {
#line 1816
        c->recalculatemode = 2;
      }
    }
#line 1818
    if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
      {
#line 1818
      (*(c->updatemenus))(c, "uiperturbation");
      }
    }
  }
#line 1820
  return;
}
}
#line 1822 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_perbutation(uih_context *c , int mousex , int mousey ) 
{ 
  number_t r ;
  number_t i ;

  {
  {
#line 1825
  uih_getcoord(c, mousex, mousey, & r, & i);
#line 1826
  uih_setperbutation(c, r, i);
  }
#line 1827
  return;
}
}
#line 1829 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_setjuliaseed(uih_context *c , number_t zre , number_t zim ) 
{ 


  {
#line 1831
  if ((c->fcontext)->pre != zre) {
#line 1831
    goto _L___0;
  } else
#line 1831
  if ((c->fcontext)->pim != zim) {
    _L___0: /* CIL Label */ 
#line 1832
    (c->fcontext)->pre = zre;
#line 1833
    (c->fcontext)->pim = zim;
#line 1834
    if (c->juliamode) {
#line 1835
      c->display = 1;
#line 1835
      if (c->recalculatemode > 1) {
#line 1835
        c->recalculatemode = c->recalculatemode;
      } else {
#line 1835
        c->recalculatemode = 1;
      }
    } else
#line 1837
    if (! (c->fcontext)->mandelbrot) {
#line 1838
      ((c->fcontext)->version) ++;
#line 1839
      if (c->playc) {
#line 1839
        if ((c->playc)->morphjulia) {
#line 1840
          c->display = 1;
#line 1840
          if (c->recalculatemode > 1) {
#line 1840
            c->recalculatemode = c->recalculatemode;
          } else {
#line 1840
            c->recalculatemode = 1;
          }
        } else {
#line 1839
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1842
        c->display = 1;
#line 1842
        if (c->recalculatemode > 2) {
#line 1842
          c->recalculatemode = c->recalculatemode;
        } else {
#line 1842
          c->recalculatemode = 2;
        }
      }
    }
  }
#line 1846
  return;
}
}
#line 1848 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_setfastmode(uih_context *c , int mode ) 
{ 
  char const   *names___1[5] ;

  {
#line 1850
  names___1[0] = "nodynamic";
#line 1850
  names___1[1] = "nodynamic";
#line 1850
  names___1[2] = "dynamicanimation";
#line 1850
  names___1[3] = "dynamicnew";
#line 1850
  names___1[4] = "dynamicnew";
#line 1857
  if (mode < 0) {
#line 1858
    mode = 0;
  }
#line 1859
  c->fastmode = mode;
#line 1860
  if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
    {
#line 1860
    (*(c->updatemenus))(c, names___1[mode]);
    }
  }
#line 1861
  return;
}
}
#line 1863 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_setoutcoloringmode(uih_context *c , int mode ) 
{ 
  int tmp ;
  char str___0[10] ;

  {
#line 1865
  if (mode < 0) {
    {
#line 1866
    tmp = rand();
#line 1866
    mode = tmp % 11;
    }
  }
#line 1867
  if (mode > 11) {
#line 1868
    mode = 10;
  }
#line 1869
  if ((c->fcontext)->coloringmode != mode) {
#line 1871
    (c->fcontext)->coloringmode = mode;
#line 1872
    ((c->fcontext)->version) ++;
#line 1873
    c->display = 1;
#line 1873
    if (c->recalculatemode > 2) {
#line 1873
      c->recalculatemode = c->recalculatemode;
    } else {
#line 1873
      c->recalculatemode = 2;
    }
    {
#line 1874
    sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)"out%i",
            mode);
    }
#line 1875
    if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
      {
#line 1875
      (*(c->updatemenus))(c, (char const   *)(str___0));
      }
    }
  }
#line 1877
  return;
}
}
#line 1879 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_setplane(uih_context *c , int mode ) 
{ 
  int i ;
  int tmp ;
  char str___0[10] ;

  {
#line 1883
  if (mode < 0) {
#line 1884
    mode = 0;
  }
#line 1885
  i = 0;
  {
#line 1885
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1885
    if (! ((unsigned long )planename[i] != (unsigned long )((void *)0))) {
#line 1885
      goto while_break;
    }
#line 1885
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1886
  if (mode >= i) {
#line 1887
    mode = i - 1;
  }
#line 1888
  if (mode < 0) {
    {
#line 1889
    tmp = rand();
#line 1889
    mode = tmp % i;
    }
  }
  {
#line 1890
  uih_invalidatepos(c);
  }
#line 1891
  if ((c->fcontext)->plane != mode) {
#line 1893
    (c->fcontext)->plane = mode;
#line 1897
    ((c->fcontext)->version) ++;
#line 1898
    c->display = 1;
#line 1898
    if (c->recalculatemode > 2) {
#line 1898
      c->recalculatemode = c->recalculatemode;
    } else {
#line 1898
      c->recalculatemode = 2;
    }
    {
#line 1899
    sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)"plane%i",
            mode);
    }
#line 1900
    if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
      {
#line 1900
      (*(c->updatemenus))(c, (char const   *)(str___0));
      }
    }
  }
#line 1902
  return;
}
}
#line 1904 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_screentofractalcoord(uih_context *c , int mousex , int mousey , number_t *re ,
                              number_t *im ) 
{ 


  {
  {
#line 1908
  uih_getcoord(c, mousex, mousey, re, im);
#line 1909
  recalculate((c->fcontext)->plane, re, im);
  }
#line 1910
  return;
}
}
#line 1912 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_setmandelbrot(uih_context *c , int mode , int mousex , int mousey ) 
{ 


  {
#line 1914
  if (mode < 0) {
#line 1915
    mode = 0;
  }
#line 1916
  if (mode > 1) {
#line 1917
    mode = 1;
  }
#line 1918
  if ((c->fcontext)->mandelbrot != mode) {
#line 1919
    (c->fcontext)->mandelbrot = mode;
#line 1920
    if ((c->fcontext)->mandelbrot == 0) {
#line 1920
      if (! c->juliamode) {
        {
#line 1921
        uih_getcoord(c, mousex, mousey, & (c->fcontext)->pre, & (c->fcontext)->pim);
#line 1923
        recalculate((c->fcontext)->plane, & (c->fcontext)->pre, & (c->fcontext)->pim);
        }
      } else {
        {
#line 1926
        uih_disablejulia(c);
        }
      }
    } else {
      {
#line 1926
      uih_disablejulia(c);
      }
    }
#line 1927
    ((c->fcontext)->version) ++;
#line 1928
    c->display = 1;
#line 1928
    if (c->recalculatemode > 2) {
#line 1928
      c->recalculatemode = c->recalculatemode;
    } else {
#line 1928
      c->recalculatemode = 2;
    }
#line 1929
    if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
      {
#line 1929
      (*(c->updatemenus))(c, "uimandelbrot");
      }
    }
  }
#line 1931
  return;
}
}
#line 1933 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_setguessing(uih_context *c , int range ) 
{ 
  char str___0[10] ;

  {
#line 1936
  (c->fcontext)->range = range;
#line 1937
  if (range <= 1) {
#line 1938
    if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
      {
#line 1938
      (*(c->updatemenus))(c, "noguess");
      }
    }
  } else
#line 1939
  if (range > 8) {
#line 1940
    if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
      {
#line 1940
      (*(c->updatemenus))(c, "guessall");
      }
    }
  } else {
    {
#line 1942
    sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)"guess%i",
            range);
    }
#line 1943
    if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
      {
#line 1943
      (*(c->updatemenus))(c, (char const   *)(str___0));
      }
    }
  }
#line 1945
  return;
}
}
#line 1947 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_setperiodicity(uih_context *c , int periodicity ) 
{ 


  {
#line 1949
  (c->fcontext)->periodicity = periodicity;
#line 1950
  if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
    {
#line 1950
    (*(c->updatemenus))(c, "periodicity");
    }
  }
#line 1951
  return;
}
}
#line 1953 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_interrupt(uih_context *c ) 
{ 


  {
#line 1955
  if (c->incalculation) {
#line 1956
    c->interrupt = 1;
  }
#line 1957
  return;
}
}
#line 1959 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_stopzooming(uih_context *c ) 
{ 


  {
#line 1961
  c->speed = (number_t )0;
#line 1962
  return;
}
}
#line 1964 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
int uih_updateimage(uih_context *c , struct image *image___0 ) 
{ 
  int tmp ;

  {
  {
#line 1967
  c->image = image___0;
#line 1968
  c->palette = image___0->palette;
#line 1969
  (c->queue)->isinitialized = 0;
#line 1970
  c->ddatalost = 1;
#line 1971
  fractalc_resize_to(c->fcontext, (c->image)->pixelwidth * (float )(c->image)->width,
                     (c->image)->pixelheight * (float )(c->image)->height);
#line 1973
  c->display = 1;
#line 1974
  (c->palette)->ncells = (int )(sizeof(uicolors) / sizeof(rgb_t ));
#line 1975
  (c->palette)->prergb = uicolors;
  }
#line 1976
  if ((c->palette)->type & 3840) {
#line 1977
    (c->palette)->prergb = uibwcolors;
  }
#line 1978
  c->inanimation = 2;
#line 1979
  c->display = 1;
#line 1979
  if (c->recalculatemode > 2) {
#line 1979
    c->recalculatemode = c->recalculatemode;
  } else {
#line 1979
    c->recalculatemode = 2;
  }
#line 1980
  if ((image___0->palette)->type & 7936) {
    {
#line 1981
    uih_fixedcolorenable(c);
    }
  } else {
    {
#line 1983
    uih_fixedcolordisable(c);
    }
  }
  {
#line 1984
  tmp = uih_initqueue(c);
  }
#line 1984
  return (tmp);
}
}
#line 1987 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static void uih_getcscreensizes(struct uih_context *uih___2 , int *x , int *y , int *w ,
                                int *h , void *data ) 
{ 
  int tmp ;

  {
#line 1991
  *x = 0;
#line 1992
  *y = 0;
#line 1993
  if (uih___2->clearscreen) {
#line 1994
    *w = (uih___2->image)->width;
#line 1994
    *h = (uih___2->image)->height;
  } else {
#line 1996
    tmp = 0;
#line 1996
    *h = tmp;
#line 1996
    *w = tmp;
  }
#line 1997
  return;
}
}
#line 1999 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static void uih_drawcscreen(struct uih_context *uih___2 , void *data ) 
{ 


  {
#line 2001
  if (uih___2->clearscreen) {
    {
#line 2002
    clear_image(uih___2->image);
    }
  }
#line 2003
  return;
}
}
#line 2010 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
struct uih_context *uih_mkcontext(int flags , struct image *image___0 , int (*passfunc___0)(struct uih_context * ,
                                                                                            int  ,
                                                                                            char const   * ,
                                                                                            float  ) ,
                                  void (*longwait)(struct uih_context * ) , void (*upd)(struct uih_context *c ,
                                                                                        char const   * ) ) 
{ 
  uih_context *uih___2 ;
  void *tmp ;

  {
  {
#line 2019
  tmp = calloc(sizeof(*uih___2), (size_t )1);
#line 2019
  uih___2 = (uih_context *)tmp;
#line 2020
  uih___2->updatemenus = upd;
#line 2021
  uih___2->autopilot = 0;
#line 2022
  uih___2->flags = flags;
#line 2023
  uih___2->image = image___0;
#line 2024
  uih___2->playstring = (char const   *)((void *)0);
#line 2025
  uih___2->palette = image___0->palette;
#line 2026
  uih___2->menuroot = "root";
#line 2027
  (uih___2->palette)->ncells = (int )(sizeof(uicolors) / sizeof(rgb_t ));
#line 2028
  (uih___2->palette)->prergb = uicolors;
  }
#line 2029
  if ((uih___2->palette)->type & 3840) {
#line 2030
    (uih___2->palette)->prergb = uibwcolors;
  }
#line 2032
  uih___2->speed = (number_t )0;
#line 2033
  uih___2->step = (number_t )0;
#line 2034
  uih___2->color = 0;
#line 2035
  uih___2->speedup = (number_t )(0.0006 * (double )3);
#line 2036
  uih___2->maxstep = (number_t )(0.008 * (double )3);
#line 2037
  uih___2->lasttime = (double )-1;
#line 2038
  uih___2->recalculatemode = 2;
#line 2039
  uih___2->display = 1;
#line 2040
  uih___2->fastmode = 2;
#line 2041
  if ((unsigned long )uih___2->updatemenus != (unsigned long )((void *)0)) {
    {
#line 2041
    (*(uih___2->updatemenus))(uih___2, "dynamicanimation");
    }
  }
#line 2042
  uih___2->aliasnum = -1;
#line 2043
  uih___2->direction = 1;
#line 2044
  uih___2->cyclingdirection = 1;
#line 2045
  uih___2->cyclingspeed = 30;
#line 2046
  uih___2->ddatalost = 1;
#line 2047
  uih___2->xtextpos = 1;
#line 2048
  if ((unsigned long )uih___2->updatemenus != (unsigned long )((void *)0)) {
    {
#line 2048
    (*(uih___2->updatemenus))(uih___2, "xtextleft");
    }
  }
#line 2049
  uih___2->complettehandler = (void (*)(void * ))0;
#line 2050
  uih___2->ytextpos = 1;
#line 2051
  if ((unsigned long )uih___2->updatemenus != (unsigned long )((void *)0)) {
    {
#line 2051
    (*(uih___2->updatemenus))(uih___2, "ytextup");
    }
  }
#line 2052
  uih___2->display = 0;
#line 2053
  uih___2->errstring = (char const   *)((void *)0);
#line 2054
  uih___2->rotatemode = 0;
#line 2055
  if ((unsigned long )uih___2->updatemenus != (unsigned long )((void *)0)) {
    {
#line 2055
    (*(uih___2->updatemenus))(uih___2, "norotate");
    }
  }
  {
#line 2056
  uih___2->rotationspeed = (number_t )10;
#line 2057
  uih___2->longwait = longwait;
#line 2058
  uih___2->passfunc = passfunc___0;
#line 2059
  uih___2->nletters = 0;
#line 2060
  uih___2->letterspersec = 15;
#line 2061
  uih___2->maintimer = tl_create_timer();
#line 2062
  uih___2->calculatetimer = tl_create_timer();
#line 2063
  uih___2->doittimer = tl_create_timer();
#line 2076
  globaluih = uih___2;
#line 2078
  tl_update_time();
#line 2079
  tl_reset_timer(uih___2->maintimer);
#line 2080
  tl_reset_timer(uih___2->calculatetimer);
#line 2081
  tl_stop_timer(uih___2->doittimer);
#line 2082
  tl_reset_timer(uih___2->doittimer);
#line 2083
  uih_alloctables(uih___2);
#line 2084
  uih_initqueue(uih___2);
  }
#line 2085
  if ((image___0->palette)->type & 7936) {
    {
#line 2086
    uih_fixedcolorenable(uih___2);
    }
  }
  {
#line 2087
  uih_mkdefaultpalette(uih___2);
#line 2088
  uih_stoptimers(uih___2);
#line 2089
  clean_autopilot(uih___2);
#line 2090
  uih___2->display = 1;
  }
#line 2090
  if (uih___2->recalculatemode > 2) {
#line 2090
    uih___2->recalculatemode = uih___2->recalculatemode;
  } else {
#line 2090
    uih___2->recalculatemode = 2;
  }
  {
#line 2091
  uih___2->cscreenwindow = uih_registerw(uih___2, & uih_getcscreensizes, & uih_drawcscreen,
                                         (void *)0, 1);
#line 2094
  uih_initmessages(uih___2);
#line 2095
  uih_inittext(uih___2);
#line 2096
  uih_emulatetimers(uih___2);
#line 2097
  uih_setformula(uih___2, 0);
#line 2098
  uih_saveundo(uih___2);
  }
#line 2099
  return (uih___2);
}
}
#line 2102 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_savepalette(uih_context *c ) 
{ 


  {
#line 2104
  if ((unsigned long )c->palette2 != (unsigned long )((void *)0)) {
    {
#line 2105
    destroypalette(c->palette2);
    }
  }
#line 2106
  if ((unsigned long )((c->zengine)->fractalc)->palette != (unsigned long )((void *)0)) {
    {
#line 2107
    c->palette2 = clonepalette(((c->zengine)->fractalc)->palette);
    }
  }
#line 2108
  return;
}
}
#line 2110 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_restorepalette(uih_context *uih___2 ) 
{ 


  {
#line 2112
  if ((unsigned long )uih___2->palette2 != (unsigned long )((void *)0)) {
#line 2113
    if ((unsigned long )((uih___2->zengine)->fractalc)->palette != (unsigned long )((void *)0)) {
      {
#line 2114
      restorepalette(((uih___2->zengine)->fractalc)->palette, uih___2->palette2);
      }
    }
    {
#line 2115
    destroypalette(uih___2->palette2);
    }
  }
  {
#line 2117
  uih___2->palette2 = (struct palette *)((void *)0);
#line 2118
  uih_finishpalette(uih___2);
  }
#line 2119
  return;
}
}
#line 2121 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_loadpalette(uih_context *c , struct palette *palette ) 
{ 


  {
#line 2123
  if (c->palette2) {
    {
#line 2124
    destroypalette(c->palette2);
    }
  }
  {
#line 2125
  c->palette2 = clonepalette(palette);
#line 2126
  uih_restorepalette(c);
  }
#line 2127
  if (! c->recalculatemode) {
#line 2127
    if ((unsigned long )(c->queue)->palettechg != (unsigned long )((void *)0)) {
#line 2127
      c->recalculatemode = -2;
#line 2127
      c->display = 1;
    }
  }
#line 2128
  return;
}
}
#line 2130 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
struct palette *uih_clonepalette(uih_context *c ) 
{ 
  struct palette *tmp ;

  {
#line 2132
  if ((unsigned long )((c->zengine)->fractalc)->palette != (unsigned long )((void *)0)) {
    {
#line 2133
    tmp = clonepalette(((c->zengine)->fractalc)->palette);
    }
#line 2133
    return (tmp);
  }
#line 2135
  return ((struct palette *)((void *)0));
}
}
#line 2138 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_setformula(uih_context *c , int num ) 
{ 


  {
  {
#line 2140
  set_formula(c->fcontext, num);
#line 2141
  c->display = 1;
  }
#line 2141
  if (c->recalculatemode > 2) {
#line 2141
    c->recalculatemode = c->recalculatemode;
  } else {
#line 2141
    c->recalculatemode = 2;
  }
#line 2142
  if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
    {
#line 2142
    (*(c->updatemenus))(c, "uimandelbrot");
    }
  }
#line 2143
  if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
    {
#line 2143
    (*(c->updatemenus))(c, "uiperturbation");
    }
  }
#line 2144
  if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
    {
#line 2144
    (*(c->updatemenus))(c, (char const   *)((c->fcontext)->currentformula)->shortname);
    }
  }
#line 2145
  return;
}
}
#line 2147 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_initstate(struct uih_context *uih___2 ) 
{ 
  int i ;
  int ver ;
  int tmp ;

  {
  {
#line 2150
  ver = (uih___2->fcontext)->version;
#line 2151
  uih___2->step = (number_t )0;
#line 2152
  uih___2->speedup = (number_t )(0.0006 * (double )3);
#line 2153
  uih___2->maxstep = (number_t )(0.008 * (double )3);
#line 2154
  uih_fastrotatedisable(uih___2);
#line 2155
  uih_disablejulia(uih___2);
#line 2156
  uih___2->color = 0;
#line 2157
  uih_cycling_off(uih___2);
#line 2158
  i = 0;
  }
  {
#line 2158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2158
    if (! (i < (int )uih_nfilters)) {
#line 2158
      goto while_break;
    }
    {
#line 2159
    uih_disablefilter(uih___2, i);
#line 2158
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2160
  uih_setperbutation(uih___2, (number_t )0, (number_t )0);
#line 2161
  set_formula(uih___2->fcontext, 0);
#line 2162
  uih_setperiodicity(uih___2, 1);
#line 2163
  uih_setmaxiter(uih___2, 170);
#line 2164
  uih_setbailout(uih___2, (number_t )4);
#line 2165
  uih_setincoloringmode(uih___2, 0);
#line 2166
  uih_setoutcoloringmode(uih___2, 0);
#line 2167
  uih_setcycling(uih___2, 30);
#line 2168
  uih_display(uih___2);
#line 2169
  uih_setfastmode(uih___2, 2);
#line 2170
  uih_setintcolor(uih___2, 0);
#line 2171
  uih_setouttcolor(uih___2, 0);
#line 2172
  uih_setplane(uih___2, 0);
#line 2173
  uih_setguessing(uih___2, 3);
#line 2174
  uih_angle(uih___2, (number_t )0);
#line 2175
  uih_rotatemode(uih___2, 0);
#line 2176
  uih_rotationspeed(uih___2, (number_t )10);
#line 2177
  uih___2->xtextpos = 1;
#line 2178
  uih___2->ytextpos = 1;
  }
#line 2179
  if (uih___2->playc) {
#line 2180
    (uih___2->playc)->morphtimes[0] = 0;
#line 2181
    (uih___2->playc)->morphtimes[1] = 0;
#line 2182
    (uih___2->playc)->morphjuliatimes[0] = 0;
#line 2183
    (uih___2->playc)->morphjuliatimes[1] = 0;
#line 2184
    (uih___2->playc)->morphangletimes[0] = 0;
#line 2185
    (uih___2->playc)->morphangletimes[1] = 0;
#line 2186
    (uih___2->playc)->morphlinetimes[0] = 0;
#line 2187
    (uih___2->playc)->morphlinetimes[1] = 0;
  }
  {
#line 2189
  tmp = mkdefaultpalette(((uih___2->zengine)->fractalc)->palette);
  }
#line 2189
  if (tmp != 0) {
#line 2189
    goto _L;
  } else
#line 2189
  if (uih___2->recalculatemode) {
#line 2189
    goto _L;
  } else
#line 2189
  if ((uih___2->fcontext)->version != ver) {
    _L: /* CIL Label */ 
#line 2191
    uih___2->display = 1;
#line 2191
    if (uih___2->recalculatemode > 2) {
#line 2191
      uih___2->recalculatemode = uih___2->recalculatemode;
    } else {
#line 2191
      uih___2->recalculatemode = 2;
    }
  }
#line 2193
  return;
}
}
#line 2196 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_freecontext(uih_context *c ) 
{ 
  struct filter *f ;
  int i ;

  {
#line 2206
  if ((unsigned long )c->emulator != (unsigned long )((void *)0)) {
    {
#line 2207
    uih_noconstantframetime(c);
    }
  }
#line 2208
  i = 0;
  {
#line 2208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2208
    if (! (i < 256)) {
#line 2208
      goto while_break;
    }
#line 2209
    if (c->undo.undos[i]) {
      {
#line 2210
      free((void *)c->undo.undos[i]);
#line 2210
      c->undo.undos[i] = (char *)0;
      }
    }
#line 2208
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2211
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2211
    if (! (c->queue)->first) {
#line 2211
      goto while_break___0;
    }
    {
#line 2212
    f = (c->queue)->first;
#line 2213
    removefilter((c->queue)->first);
#line 2214
    (*((f->action)->destroyinstance))(f);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2216
  uih_destroymessages(c);
#line 2217
  uih_destroytext(c);
#line 2218
  uih_removew(c, c->cscreenwindow);
#line 2219
  free((void *)c->queue);
#line 2220
  free_fractalc(c->fcontext);
#line 2221
  free((void *)c);
  }
#line 2222
  return;
}
}
#line 2224 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static struct filter *uih_getinstance(struct filteraction  const  *a ) 
{ 
  struct filter *f ;
  struct filter *tmp ;

  {
  {
#line 2226
  tmp = createfilter(a);
#line 2226
  f = tmp;
#line 2227
  f->data = (void *)uih___0;
#line 2228
  f->name = "XaoS\'s user interface layer";
  }
#line 2229
  return (f);
}
}
#line 2232 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static void uih_destroyinstance(struct filter *f ) 
{ 
  struct uih_context *c ;

  {
#line 2234
  c = (struct uih_context *)f->data;
#line 2235
  if (c->autopilot) {
    {
#line 2236
    uih_autopilot_off(c);
    }
  }
#line 2237
  if (c->cycling) {
    {
#line 2238
    uih_cycling_off(c);
    }
  }
  {
#line 2239
  tl_free_timer(c->maintimer);
#line 2240
  tl_free_timer(c->calculatetimer);
#line 2241
  tl_free_timer(c->doittimer);
  }
#line 2242
  if (c->save) {
    {
#line 2243
    uih_save_disable(c);
    }
  }
#line 2244
  if (c->play) {
    {
#line 2245
    uih_replaydisable(c);
    }
  }
  {
#line 2246
  free((void *)f);
  }
#line 2247
  return;
}
}
#line 2249 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static int wascycling  ;
#line 2250 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static int uih_require(struct filter *f , struct requirements *r ) 
{ 
  struct uih_context *uih___2 ;

  {
  {
#line 2253
  uih___2 = (struct uih_context *)f->data;
#line 2254
  f->req = *r;
#line 2255
  uih_clearwindows(uih___2);
  }
#line 2256
  if (uih___2->cycling) {
    {
#line 2257
    uih_cycling_off(uih___2);
#line 2257
    wascycling = 1;
    }
  }
#line 2258
  if (! (r->supportedmask & ((uih___2->image)->palette)->type)) {
#line 2259
    return (0);
  }
#line 2261
  return (1);
}
}
#line 2264 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
static int uih_initialize(struct filter *f , struct initdata *i ) 
{ 
  struct uih_context *uih___2 ;
  int returnval ;

  {
  {
#line 2268
  uih___2 = (struct uih_context *)f->data;
#line 2269
  (f->queue)->saveimage = uih___2->image;
#line 2270
  i->fractalc = uih___2->fcontext;
#line 2271
  uih_setfont(uih___2);
#line 2272
  tl_update_time();
#line 2273
  f->image = uih___2->image;
#line 2274
  f->wait_function = & uih_waitfunc;
#line 2275
  uih___2->times[0][0] = -1;
#line 2276
  i->image = uih___2->image;
#line 2277
  f->fractalc = i->fractalc;
#line 2278
  ((f->image)->palette)->flags |= 4;
#line 2279
  (i->fractalc)->palette = (uih___2->image)->palette;
#line 2280
  i->wait_function = & uih_waitfunc;
  }
#line 2282
  if (uih___2->ddatalost) {
#line 2283
    i->flags |= 1;
  }
  {
#line 2284
  uih___2->tbreak = 2;
#line 2285
  uih_invalidatepos(uih___2);
#line 2286
  clean_autopilot(uih___2);
#line 2287
  returnval = (*(((f->previous)->action)->initialize))(f->previous, i);
  }
#line 2288
  if (wascycling) {
    {
#line 2289
    uih_cycling_on(uih___2);
#line 2289
    wascycling = 0;
    }
  }
#line 2290
  return (returnval);
}
}
#line 2293 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
void uih_inhibittextsw(uih_context *c ) 
{ 


  {
#line 2295
  c->inhibittextoutput ^= 1;
#line 2296
  if ((unsigned long )c->updatemenus != (unsigned long )((void *)0)) {
    {
#line 2296
    (*(c->updatemenus))(c, "inhibittextoutput");
    }
  }
#line 2297
  return;
}
}
#line 2299 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/ui_helper.c"
int uih_inhibittextselected(uih_context *c ) 
{ 


  {
#line 2301
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 2302
    return (0);
  }
#line 2303
  return (c->inhibittextoutput);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 63 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 65
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 377
extern int vprintf(char const   * __restrict  __format , __gnuc_va_list __arg ) ;
#line 379
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 247 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/filter.h"
extern struct image *create_image_mem(int width , int height , int nimages , struct palette *palette ,
                                      float pixelwidth , float pixelheight ) ;
#line 532 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/ui_helper.h"
int uih_renderimage(struct uih_context *gc1 , xio_file af , xio_constpath const   path ,
                    struct image *img , int antialias , char const   *catalog___0 ,
                    int noise ) ;
#line 35 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/render.c"
static int noiselevel  ;
#line 37 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/render.c"
static struct uih_context *gc  ;
#line 38 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/render.c"
static struct uih_context *uih___1  ;
#line 39 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/render.c"
static int newline  =    1;
#line 40 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/render.c"
static int interrupt  =    0;
#line 41 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/render.c"
static void error___0(char const   *str___0 ) 
{ 
  char *tmp ;

  {
#line 43
  if (noiselevel < 1) {
#line 44
    return;
  }
#line 45
  if (! gc) {
    {
#line 46
    tmp = gettext("Error: %s");
#line 46
    x_error(tmp, str___0);
    }
  }
  {
#line 47
  uih_error(gc, str___0);
  }
#line 48
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/render.c"
static void uiherror(struct uih_context *c ) 
{ 


  {
#line 52
  if (noiselevel < 1) {
#line 53
    return;
  }
#line 54
  if (! gc) {
    {
#line 55
    uih_printmessages(c);
    }
  } else {
    {
#line 57
    uih_error(gc, uih___1->errstring);
    }
  }
#line 58
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/render.c"
static void printmsg(char const   *text  , ...) 
{ 
  va_list ap ;
  char s[256] ;
  int tmp ;
  int tmp___0 ;

  {
#line 63
  if (noiselevel < 2) {
#line 64
    return;
  }
  {
#line 65
  __builtin_va_start(ap, text);
  }
#line 66
  if (! gc) {
    {
#line 67
    vprintf((char const   */* __restrict  */)text, ap);
#line 68
    printf((char const   */* __restrict  */)"\n");
    }
  } else {
    {
#line 71
    vsprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)text,
             ap);
#line 72
    uih_message(gc, (char const   *)(s));
#line 73
    tmp = (*(gc->passfunc))(gc, 1, (char const   *)(s), (float )100);
#line 73
    tmp___0 = gc->interrupt | tmp;
#line 73
    gc->interrupt = tmp___0;
#line 73
    interrupt |= tmp___0;
#line 74
    uih_clearwindows(gc);
    }
  }
#line 76
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/render.c"
static int passfunc(struct uih_context *c , int display , char const   *text , float percent ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 82
  if (noiselevel < 3) {
#line 83
    return (0);
  }
#line 84
  if (gc) {
#line 85
    if ((unsigned long )gc->passfunc != (unsigned long )((void *)0)) {
      {
#line 86
      tmp = (*(gc->passfunc))(gc, display, text, percent);
#line 86
      tmp___0 = gc->interrupt | tmp;
#line 86
      gc->interrupt = tmp___0;
#line 86
      interrupt |= tmp___0;
      }
    }
    {
#line 88
    uih_clearwindows(gc);
    }
#line 89
    return (interrupt);
  } else
#line 90
  if (display) {
#line 92
    if (newline) {
      {
#line 93
      printf((char const   */* __restrict  */)"\n");
#line 93
      newline = 0;
      }
    }
    {
#line 94
    printf((char const   */* __restrict  */)"\r %s %3.2f%% ", text, (double )percent);
#line 95
    fflush(stdout);
    }
  }
#line 98
  return (0);
}
}
#line 108 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/render.c"
static void save_frame_dist(uih_context *c , int backward , struct frame_info *f1 ,
                            struct frame_info *f2 ) 
{ 
  xio_file f ;
  int x1 ;
  int y1___0 ;
  char str___0[256] ;
  int tmp ;
  char *tmp___0 ;
  number_t x ;
  number_t y ;
  number_t x2 ;
  number_t y2 ;
  number_t tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;

  {
#line 115
  if (! (f2->rect.mc - f2->rect.nc)) {
#line 116
    return;
  } else
#line 115
  if (! (f2->rect.mi - f2->rect.ni)) {
#line 116
    return;
  }
#line 118
  if (backward) {
#line 118
    tmp = 'b';
  } else {
#line 118
    tmp = 'p';
  }
  {
#line 118
  sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)"%s.%c",
          f1->name, tmp);
#line 119
  f = xio_wopen((xio_constpath )(str___0));
  }
#line 120
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 121
    tmp___0 = gettext("Cannot open motion vector file!");
#line 121
    x_error(tmp___0);
    }
#line 122
    return;
  }
#line 124
  y1___0 = 0;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (y1___0 < ((c->image)->height + 7) / 8)) {
#line 124
      goto while_break;
    }
#line 125
    x1 = 0;
    {
#line 125
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 125
      if (! (x1 < ((c->image)->width + 7) / 8)) {
#line 125
        goto while_break___0;
      }
#line 129
      x = f1->rect.nc + ((number_t )(x1 * 8 + 4) * (f1->rect.mc - f1->rect.nc)) / (number_t )(c->image)->width;
#line 132
      y = f1->rect.ni + ((number_t )(y1___0 * 8 + 4) * (f1->rect.mi - f1->rect.ni)) / (number_t )(c->image)->height;
#line 136
      if (f2->angle != f1->angle) {
        {
#line 137
        tmp___2 = cos((double )(f2->angle - f1->angle));
#line 137
        tmp___3 = sin((double )(f2->angle - f1->angle));
#line 137
        tmp___1 = x * (number_t )tmp___2 - y * (number_t )tmp___3;
#line 140
        tmp___4 = sin((double )(f2->angle - f1->angle));
#line 140
        tmp___5 = cos((double )(f2->angle - f1->angle));
#line 140
        y = x * (number_t )tmp___4 + y * (number_t )tmp___5;
#line 142
        x = tmp___1;
        }
      }
      {
#line 144
      x2 = ((x - f2->rect.nc) * (number_t )(c->image)->width) / (f2->rect.mc - f2->rect.nc);
#line 146
      y2 = ((y - f2->rect.ni) * (number_t )(c->image)->height) / (f2->rect.mi - f2->rect.ni);
#line 148
      sprintf((char */* __restrict  */)(str___0), (char const   */* __restrict  */)"%3.2g %3.2g  ",
              (double )((int )((x2 - (number_t )(x1 * 8 + 4)) * (number_t )10)) / 10.0,
              (double )((int )((y2 - (number_t )(y1___0 * 8 + 4)) * (number_t )10)) / 10.0);
#line 151
      (*(f->fputs))((char const   *)(str___0), f);
#line 125
      x1 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 153
    (*(f->fputc))('\n', f);
#line 124
    y1___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 155
  (*(f->fclose))(f);
  }
#line 157
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/render.c"
static int iframedist  ;
#line 162 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/render.c"
static int mvectors  ;
#line 163 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/render.c"
static xio_file patf  ;
#line 167
static void uih_encodeframe(int startpos , int endpos , struct frame_info *curframe ) ;
#line 167 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/render.c"
static int lastiframe  =    -200;
#line 168 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/render.c"
static struct frame_info lastp  ;
#line 169 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/render.c"
static struct frame_info bframes[5]  ;
#line 170 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/render.c"
static int nbframes  =    0;
#line 164 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/render.c"
static void uih_encodeframe(int startpos , int endpos , struct frame_info *curframe ) 
{ 
  int i ;
  char type ;

  {
#line 173
  if (! gc) {
    {
#line 174
    printf((char const   */* __restrict  */)" motion");
    }
  }
  {
#line 175
  fflush(stdout);
  }
#line 176
  if (endpos > startpos + 4) {
#line 177
    if (endpos - lastiframe > iframedist) {
#line 178
      type = (char )'I';
    } else {
#line 180
      type = (char )'P';
    }
  } else {
#line 182
    if (endpos - lastiframe > iframedist) {
#line 183
      type = (char )'I';
    } else
#line 185
    if ((startpos - lastiframe) % 3) {
#line 185
      type = (char )'B';
    } else {
#line 185
      type = (char )'P';
    }
#line 186
    if (startpos != endpos) {
#line 187
      type = (char )'P';
    }
  }
#line 189
  if (curframe->newimage) {
#line 190
    type = (char )'I';
  }
#line 191
  if (mvectors) {
    {
#line 193
    if ((int )type == 73) {
#line 193
      goto case_73;
    }
#line 198
    if ((int )type == 80) {
#line 198
      goto case_80;
    }
#line 202
    if ((int )type == 66) {
#line 202
      goto case_66;
    }
#line 192
    goto switch_break;
    case_73: /* CIL Label */ 
#line 194
    if (startpos) {
      {
#line 195
      save_frame_dist(uih___1, 0, curframe, & lastp);
      }
    }
#line 196
    lastp = *curframe;
#line 197
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 199
    save_frame_dist(uih___1, 0, curframe, & lastp);
#line 200
    lastp = *curframe;
    }
#line 201
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 203
    save_frame_dist(uih___1, 0, curframe, & lastp);
    }
#line 204
    if (nbframes < 5) {
      {
#line 205
      bframes[nbframes] = *curframe;
#line 206
      bframes[nbframes].name = mystrdup((char const   *)curframe->name);
#line 207
      nbframes ++;
      }
    }
#line 209
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 212
  (*(patf->fputc))((int )type, patf);
  }
#line 213
  if ((int )type == 73) {
#line 214
    lastiframe = startpos;
  }
#line 215
  if (startpos != endpos) {
    {
#line 216
    while (1) {
      while_continue: /* CIL Label */ ;
#line 216
      if (! (startpos != endpos)) {
#line 216
        goto while_break;
      }
      {
#line 217
      (*(patf->fputc))('p', patf);
#line 217
      startpos ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 219
  if (! gc) {
    {
#line 220
    printf((char const   */* __restrict  */)" %c", (int )type);
    }
  }
  {
#line 221
  fflush(stdout);
  }
#line 222
  if (mvectors) {
#line 223
    if ((int )type != 66) {
#line 223
      if (nbframes) {
#line 224
        if (! gc) {
          {
#line 225
          printf((char const   */* __restrict  */)" backframes");
          }
        }
        {
#line 226
        fflush(stdout);
#line 227
        i = 0;
        }
        {
#line 227
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 227
          if (! (i < nbframes)) {
#line 227
            goto while_break___0;
          }
          {
#line 228
          save_frame_dist(uih___1, 1, bframes + i, curframe);
#line 229
          fflush(stdout);
#line 230
          free((void *)bframes[i].name);
#line 227
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 232
        nbframes = 0;
      }
    }
  }
#line 235
  if ((unsigned long )patf->flush != (unsigned long )((void *)0)) {
    {
#line 235
    (*(patf->flush))(patf);
    }
  }
#line 236
  return;
}
}
#line 256 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/render.c"
static char *saveddata  ;
#line 239 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/render.c"
int uih_renderanimation(struct uih_context *gc1 , char const   *basename , xio_constpath const   animation ,
                        int width , int height , float pixelwidth , float pixelheight ,
                        int frametime , int type , int antialias , int slowmode___0 ,
                        int letterspersec___0 , char const   *catalog___0 , int motionvectors ,
                        int iframedist2 ) 
{ 
  struct palette *pal ;
  struct palette *tmp ;
  struct image *img ;
  xio_file of ;
  FILE *f ;
  xio_file af ;
  char s[200] ;
  int lastframenum ;
  int aliasnum ;
  int newimage ;
  int y ;
  struct frame_info curframe ;
  int framenum ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  menuitem const   *item ;
  dialogparam *d ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;

  {
  {
#line 247
  tmp = createpalette(0, 0, type, 0, 0, (int (*)(struct palette *pal , int init ,
                                                 int r , int g , int b ))((void *)0),
                      (void (*)(struct palette *pal , int start , int end , rgb_t *rgb ))((void *)0),
                      (void (*)(struct palette *pal ))((void *)0), (void (*)(struct palette *pal ,
                                                                             int direction ))((void *)0),
                      (union paletteinfo *)((void *)0));
#line 247
  pal = tmp;
#line 254
  lastframenum = -1;
#line 255
  aliasnum = 0;
#line 261
  framenum = 0;
#line 264
  noiselevel = 3;
#line 265
  gc = gc1;
  }
#line 266
  if (gc) {
#line 267
    gc->incalculation = 1;
  }
  {
#line 269
  mvectors = motionvectors;
#line 270
  tmp___0 = gettext("Vectors: %i");
#line 270
  printmsg((char const   *)tmp___0, motionvectors);
  }
#line 271
  if (iframedist2) {
#line 272
    iframedist = iframedist2;
  } else {
#line 274
    iframedist = 27;
  }
  {
#line 276
  tmp___1 = gettext("Initializing");
#line 276
  printmsg((char const   *)tmp___1);
  }
#line 277
  if (! (type & 30)) {
#line 278
    antialias = 0;
  }
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! ((unsigned long )uih_filters[aliasnum] != (unsigned long )(& antialias_filter))) {
#line 280
      goto while_break;
    }
#line 281
    aliasnum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 283
  if (! pal) {
    {
#line 284
    tmp___2 = gettext("Cannot create palette");
#line 284
    error___0((char const   *)tmp___2);
    }
#line 285
    if (gc) {
#line 286
      gc->incalculation = 0;
    }
#line 287
    return (0);
  }
#line 289
  if (! pixelwidth) {
#line 290
    pixelwidth = (float )(29.0 / (double )width);
  }
#line 291
  if (! pixelheight) {
#line 292
    pixelheight = (float )(21.5 / (double )height);
  }
  {
#line 293
  img = create_image_mem(width, height, 2, pal, pixelwidth, pixelheight);
  }
#line 294
  if (! img) {
    {
#line 295
    tmp___3 = gettext("Cannot create image\n");
#line 295
    error___0((char const   *)tmp___3);
    }
#line 296
    if (gc) {
#line 297
      gc->incalculation = 0;
    }
    {
#line 298
    destroypalette(pal);
    }
#line 299
    return (0);
  }
  {
#line 301
  tmp___4 = malloc((size_t )((img->width * img->height) * img->bytesperpixel));
#line 301
  saveddata = (char *)tmp___4;
  }
#line 303
  if ((unsigned long )saveddata == (unsigned long )((void *)0)) {
    {
#line 304
    tmp___5 = gettext("Cannot create checking buffer!");
#line 304
    error___0((char const   *)tmp___5);
    }
#line 305
    if (gc) {
#line 306
      gc->incalculation = 0;
    }
    {
#line 307
    destroy_image(img);
#line 308
    destroypalette(pal);
    }
#line 309
    return (0);
  }
  {
#line 311
  uih___1 = uih_mkcontext(0, img, & passfunc, (void (*)(struct uih_context * ))((void *)0),
                          (void (*)(struct uih_context *c , char const   * ))((void *)0));
  }
#line 312
  if (! uih___1) {
    {
#line 313
    tmp___6 = gettext("Cannot create context\n");
#line 313
    error___0((char const   *)tmp___6);
    }
#line 314
    if (gc) {
#line 315
      gc->incalculation = 0;
    }
    {
#line 316
    destroy_image(img);
#line 317
    destroypalette(pal);
#line 318
    free((void *)saveddata);
    }
#line 319
    return (0);
  }
  {
#line 321
  (uih___1->fcontext)->slowmode = 1;
#line 322
  uih_constantframetime(uih___1, frametime);
#line 323
  af = xio_ropen((xio_constpath )animation);
  }
#line 324
  if ((unsigned long )af == (unsigned long )((void *)0)) {
    {
#line 325
    tmp___7 = gettext("Cannot open animation file\n");
#line 325
    error___0((char const   *)tmp___7);
    }
#line 326
    if (gc) {
#line 327
      gc->incalculation = 0;
    }
    {
#line 328
    uih_freecontext(uih___1);
#line 329
    destroy_image(img);
#line 330
    destroypalette(pal);
#line 331
    free((void *)saveddata);
    }
#line 332
    return (0);
  }
#line 335
  if (! gc) {
    {
#line 336
    tmp___8 = gettext("Loading catalogs");
#line 336
    printmsg((char const   *)tmp___8);
    }
#line 337
    if (! gc) {
      {
#line 338
      uih_loadcatalog(uih___1, "english");
      }
#line 339
      if (uih___1->errstring) {
        {
#line 340
        uiherror(uih___1);
        }
#line 341
        if (gc) {
#line 342
          gc->incalculation = 0;
        }
        {
#line 343
        uih_freecontext(uih___1);
#line 344
        destroy_image(img);
#line 345
        destroypalette(pal);
#line 346
        free((void *)saveddata);
#line 347
        (*(af->fclose))(af);
        }
#line 348
        return (0);
      }
    }
#line 351
    if ((unsigned long )catalog___0 != (unsigned long )((void *)0)) {
      {
#line 352
      uih_loadcatalog(uih___1, catalog___0);
      }
    }
#line 353
    if (uih___1->errstring) {
      {
#line 354
      uiherror(uih___1);
      }
#line 355
      if (gc) {
#line 356
        gc->incalculation = 0;
      }
      {
#line 357
      uih_freecontext(uih___1);
#line 358
      destroy_image(img);
#line 359
      destroypalette(pal);
#line 360
      free((void *)saveddata);
      }
#line 361
      if (! gc) {
        {
#line 362
        uih_freecatalog(uih___1);
        }
      }
      {
#line 363
      (*(af->fclose))(af);
      }
#line 364
      return (0);
    }
    {
#line 366
    tmp___9 = gettext("Processing command line options");
#line 366
    printmsg((char const   *)tmp___9);
    }
    {
#line 370
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 370
      item = menu_delqueue(& d);
      }
#line 370
      if (! ((unsigned long )item != (unsigned long )((void *)0))) {
#line 370
        goto while_break___0;
      }
      {
#line 371
      menu_activate(item, uih___1, d);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 374
    if (uih___1->errstring) {
      {
#line 375
      uiherror(uih___1);
      }
#line 376
      if (gc) {
#line 377
        gc->incalculation = 0;
      }
      {
#line 378
      uih_freecontext(uih___1);
#line 379
      destroy_image(img);
#line 380
      destroypalette(pal);
#line 381
      free((void *)saveddata);
      }
#line 382
      if (! gc) {
        {
#line 383
        uih_freecatalog(uih___1);
        }
      }
      {
#line 384
      (*(af->fclose))(af);
      }
#line 385
      return (0);
    }
  }
  {
#line 389
  tmp___10 = gettext("Enabling animation replay\n");
#line 389
  printmsg((char const   *)tmp___10);
#line 391
  uih_replayenable(uih___1, af, (xio_constpath )animation, 1);
#line 393
  sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s.par",
          basename);
#line 394
  of = xio_wopen((xio_constpath )(s));
  }
#line 395
  if ((unsigned long )of == (unsigned long )((void *)0)) {
    {
#line 396
    tmp___11 = gettext("Cannot open image file");
#line 396
    error___0((char const   *)tmp___11);
    }
#line 397
    if (gc) {
#line 398
      gc->incalculation = 0;
    }
    {
#line 399
    uih_freecontext(uih___1);
#line 400
    destroy_image(img);
#line 401
    destroypalette(pal);
#line 402
    free((void *)saveddata);
    }
#line 403
    if (! gc) {
      {
#line 404
      uih_freecatalog(uih___1);
      }
    }
#line 405
    return (0);
  }
  {
#line 407
  sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s.pat",
          basename);
#line 408
  patf = xio_wopen((xio_constpath )(s));
  }
#line 409
  if ((unsigned long )patf == (unsigned long )((void *)0)) {
    {
#line 410
    tmp___12 = gettext("Cannot open pattern file");
#line 410
    error___0((char const   *)tmp___12);
    }
#line 411
    if (gc) {
#line 412
      gc->incalculation = 0;
    }
    {
#line 413
    uih_freecontext(uih___1);
#line 414
    destroy_image(img);
#line 415
    destroypalette(pal);
#line 416
    free((void *)saveddata);
    }
#line 417
    if (! gc) {
      {
#line 418
      uih_freecatalog(uih___1);
      }
    }
    {
#line 419
    (*(of->fclose))(of);
    }
#line 420
    return (0);
  }
  {
#line 422
  uih_letterspersec(uih___1, letterspersec___0);
  }
#line 426
  if (! gc) {
    {
#line 427
    tmp___13 = gettext("Entering calculation loop!");
#line 427
    x_message(tmp___13);
    }
  } else {
    {
#line 429
    tmp___14 = gettext("Entering calculation loop!");
#line 429
    printmsg((char const   *)tmp___14);
    }
  }
  {
#line 431
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 431
    if (uih___1->play) {
#line 431
      goto _L;
    } else
#line 431
    if (uih___1->display) {
      _L: /* CIL Label */ 
#line 431
      if (! (! interrupt)) {
#line 431
        goto while_break___1;
      }
    } else {
#line 431
      goto while_break___1;
    }
#line 432
    if (uih___1->errstring) {
      {
#line 433
      uiherror(uih___1);
      }
#line 434
      if (gc) {
#line 435
        gc->incalculation = 0;
      }
      {
#line 436
      uih_freecontext(uih___1);
#line 437
      destroy_image(img);
#line 438
      destroypalette(pal);
#line 439
      free((void *)saveddata);
      }
#line 440
      if (! gc) {
        {
#line 441
        uih_freecatalog(uih___1);
        }
      }
      {
#line 442
      (*(of->fclose))(of);
#line 443
      (*(patf->fclose))(patf);
      }
#line 444
      return (0);
    }
    {
#line 446
    fflush(stdout);
#line 447
    tl_process_group(syncgroup, (int *)((void *)0));
#line 448
    uih_update(uih___1, 0, 0, 0);
    }
#line 451
    if (uih___1->display) {
#line 453
      if (lastframenum < framenum - 1) {
#line 454
        if (lastframenum == framenum - 1) {
          {
#line 455
          tmp___15 = gettext("Frame %i skipped.");
#line 455
          printmsg((char const   *)tmp___15, framenum - 1);
          }
        } else {
          {
#line 457
          tmp___16 = gettext("Frames %i - %i skipped.");
#line 457
          printmsg((char const   *)tmp___16, lastframenum, framenum - 1);
          }
        }
      }
      {
#line 461
      tmp___17 = gettext("Frame %4i: ");
#line 461
      printmsg((char const   *)tmp___17, framenum);
#line 463
      newline = 1;
#line 464
      newimage = 0;
      }
#line 465
      if (uih___1->recalculatemode > 0) {
#line 466
        if (! gc) {
          {
#line 467
          printf((char const   */* __restrict  */)"calculating");
#line 467
          fflush(stdout);
          }
        }
#line 468
        if (slowmode___0) {
#line 469
          uih___1->display = 1;
#line 469
          if (uih___1->recalculatemode > 2) {
#line 469
            uih___1->recalculatemode = uih___1->recalculatemode;
          } else {
#line 469
            uih___1->recalculatemode = 2;
          }
#line 469
          ((uih___1->fcontext)->version) ++;
        }
      }
#line 471
      if (antialias) {
#line 471
        if (! uih___1->filter[aliasnum]) {
#line 472
          if (! gc) {
            {
#line 473
            printf((char const   */* __restrict  */)"antialias ");
            }
          }
          {
#line 474
          uih___1->aliasnum = aliasnum;
#line 475
          uih_enablefilter(uih___1, aliasnum);
          }
        }
      }
      {
#line 477
      uih_prepare_image(uih___1);
      }
#line 479
      if (! gc) {
        {
#line 480
        printf((char const   */* __restrict  */)" rendering");
        }
      }
      {
#line 481
      fflush(stdout);
#line 482
      uih_drawwindows(uih___1);
#line 484
      y = 0;
      }
#line 485
      if (lastframenum >= 0) {
        {
#line 486
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 486
          if (! (y < img->height)) {
#line 486
            goto while_break___2;
          }
          {
#line 487
          tmp___18 = memcmp((void const   *)(saveddata + (img->width * img->bytesperpixel) * y),
                            (void const   *)*((uih___1->image)->currlines + y), (size_t )(img->width * img->bytesperpixel));
          }
#line 487
          if (tmp___18) {
#line 491
            goto while_break___2;
          }
#line 486
          y ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 495
      if (y != img->height) {
        {
#line 496
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 496
          if (! (y < img->height)) {
#line 496
            goto while_break___3;
          }
          {
#line 497
          memcpy((void */* __restrict  */)(saveddata + (img->width * img->bytesperpixel) * y),
                 (void const   */* __restrict  */)*((uih___1->image)->currlines + y),
                 (size_t )(img->width * img->bytesperpixel));
#line 496
          y ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 500
        if (framenum) {
          {
#line 501
          uih_encodeframe(lastframenum, framenum - 1, & curframe);
          }
        }
#line 502
        if (! gc) {
          {
#line 503
          printf((char const   */* __restrict  */)" saving");
          }
        }
        {
#line 504
        fflush(stdout);
#line 505
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s%04i.png",
                basename, framenum);
#line 506
        curframe.rect = (uih___1->fcontext)->rs;
#line 507
        curframe.angle = (uih___1->fcontext)->angle;
#line 508
        curframe.name = s;
#line 509
        curframe.newimage = newimage;
#line 512
        f = fopen((char const   */* __restrict  */)(s), (char const   */* __restrict  */)"wb");
        }
#line 513
        if ((unsigned long )f == (unsigned long )((void *)0)) {
          {
#line 514
          tmp___19 = gettext("Cannot open image file");
#line 514
          error___0((char const   *)tmp___19);
          }
#line 515
          if (gc) {
#line 516
            gc->incalculation = 0;
          }
          {
#line 517
          uih_freecontext(uih___1);
#line 518
          destroy_image(img);
#line 519
          destroypalette(pal);
#line 520
          free((void *)saveddata);
          }
#line 521
          if (! gc) {
            {
#line 522
            uih_freecatalog(uih___1);
            }
          }
          {
#line 523
          (*(of->fclose))(of);
#line 524
          (*(patf->fclose))(patf);
          }
#line 525
          return (0);
        }
        {
#line 527
        writepng(f, (struct image  const  *)uih___1->image);
#line 528
        tmp___20 = gettext(" done.");
#line 528
        printmsg((char const   *)tmp___20);
#line 529
        uih_displayed(uih___1);
#line 530
        lastframenum = framenum;
        }
      } else {
        {
#line 532
        tmp___21 = gettext(" skipping...");
#line 532
        printmsg((char const   *)tmp___21);
#line 533
        uih_displayed(uih___1);
        }
      }
    }
    {
#line 536
    (*(of->fputs))((char const   *)(s), of);
#line 537
    (*(of->fputs))("\n", of);
    }
#line 538
    if ((unsigned long )of->flush != (unsigned long )((void *)0)) {
      {
#line 538
      (*(of->flush))(of);
      }
    }
#line 539
    framenum ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 541
  curframe.newimage = 1;
#line 542
  if (framenum) {
    {
#line 543
    uih_encodeframe(lastframenum, framenum - 1, & curframe);
    }
  }
#line 544
  if (uih___1->errstring) {
    {
#line 545
    uiherror(uih___1);
    }
#line 546
    if (gc) {
#line 547
      gc->incalculation = 0;
    }
    {
#line 548
    uih_freecontext(uih___1);
#line 549
    destroy_image(img);
#line 550
    destroypalette(pal);
#line 551
    free((void *)saveddata);
    }
#line 552
    if (! gc) {
      {
#line 553
      uih_freecatalog(uih___1);
      }
    }
    {
#line 554
    (*(of->fclose))(of);
#line 555
    (*(patf->fclose))(patf);
    }
#line 556
    return (0);
  }
  {
#line 558
  (*(of->fclose))(of);
#line 559
  free((void *)saveddata);
#line 560
  (*(patf->fclose))(patf);
#line 561
  uih_freecontext(uih___1);
#line 562
  destroy_image(img);
#line 563
  destroypalette(pal);
  }
#line 564
  if (interrupt) {
    {
#line 565
    tmp___22 = gettext("Calculation interrupted");
#line 565
    error___0((char const   *)tmp___22);
    }
  } else
#line 567
  if (! gc) {
    {
#line 568
    tmp___23 = gettext("Calculation finished");
#line 568
    x_message(tmp___23);
    }
  } else {
    {
#line 570
    tmp___24 = gettext("Calculation finished");
#line 570
    printmsg((char const   *)tmp___24);
    }
  }
#line 572
  if (gc) {
#line 573
    gc->incalculation = 0;
  }
#line 574
  if (! gc) {
    {
#line 575
    uih_freecatalog(uih___1);
    }
  }
#line 576
  return (1);
}
}
#line 579 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/render.c"
int uih_renderimage(struct uih_context *gc1 , xio_file af , xio_constpath const   path ,
                    struct image *img , int antialias , char const   *catalog___0 ,
                    int noise ) 
{ 
  int aliasnum ;
  int ok ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 584
  aliasnum = 0;
#line 585
  ok = 1;
#line 586
  noiselevel = noise;
#line 587
  gc = gc1;
#line 588
  if (gc) {
#line 589
    gc->incalculation = 1;
  }
  {
#line 591
  while (1) {
    while_continue: /* CIL Label */ ;
#line 591
    if (! ((unsigned long )uih_filters[aliasnum] != (unsigned long )(& antialias_filter))) {
#line 591
      goto while_break;
    }
#line 592
    aliasnum ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 594
  uih___1 = uih_mkcontext(0, img, & passfunc, (void (*)(struct uih_context * ))((void *)0),
                          (void (*)(struct uih_context *c , char const   * ))((void *)0));
  }
#line 595
  if (! uih___1) {
    {
#line 596
    tmp = gettext("Cannot create context\n");
#line 596
    error___0((char const   *)tmp);
    }
#line 597
    if (gc) {
#line 598
      gc->incalculation = 0;
    }
#line 599
    return (0);
  }
  {
#line 601
  (uih___1->fcontext)->slowmode = 1;
#line 602
  uih_constantframetime(uih___1, 100000);
  }
#line 604
  if (! gc) {
    {
#line 605
    tmp___0 = gettext("Loading catalogs");
#line 605
    printmsg((char const   *)tmp___0);
#line 606
    uih_loadcatalog(uih___1, "english");
    }
#line 607
    if (uih___1->errstring) {
      {
#line 608
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)uih___1->errstring);
#line 609
      uih_clearmessages(uih___1);
#line 610
      uih___1->errstring = (char const   *)((void *)0);
      }
    }
#line 612
    if ((unsigned long )catalog___0 != (unsigned long )((void *)0)) {
      {
#line 613
      uih_loadcatalog(uih___1, catalog___0);
      }
    }
#line 614
    if (uih___1->errstring) {
      {
#line 615
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)uih___1->errstring);
#line 616
      uih_clearmessages(uih___1);
#line 617
      uih___1->errstring = (char const   *)((void *)0);
      }
    }
#line 619
    if (uih___1->errstring) {
      {
#line 620
      uih_freecatalog(uih___1);
#line 621
      uih_freecontext(uih___1);
#line 622
      uiherror(uih___1);
      }
#line 623
      if (gc) {
#line 624
        gc->incalculation = 0;
      }
#line 625
      return (0);
    }
  }
  {
#line 629
  uih_load(uih___1, af, (xio_constpath )path);
  }
#line 630
  if (uih___1->errstring) {
    {
#line 631
    uiherror(uih___1);
#line 632
    uih_freecatalog(uih___1);
#line 633
    uih_freecontext(uih___1);
    }
#line 634
    if (gc) {
#line 635
      gc->incalculation = 0;
    }
#line 636
    return (0);
  }
  {
#line 638
  tmp___1 = gettext("Entering calculation loop!");
#line 638
  printmsg((char const   *)tmp___1);
#line 640
  tl_process_group(syncgroup, (int *)((void *)0));
#line 641
  uih_update(uih___1, 0, 0, 0);
#line 643
  uih___1->display = 1;
  }
#line 643
  if (uih___1->recalculatemode > 2) {
#line 643
    uih___1->recalculatemode = uih___1->recalculatemode;
  } else {
#line 643
    uih___1->recalculatemode = 2;
  }
#line 643
  ((uih___1->fcontext)->version) ++;
#line 644
  if (antialias) {
#line 644
    if (! uih___1->filter[aliasnum]) {
      {
#line 645
      uih___1->aliasnum = aliasnum;
#line 646
      uih_enablefilter(uih___1, aliasnum);
      }
    }
  }
  {
#line 648
  uih_prepare_image(uih___1);
  }
#line 649
  if (uih___1->errstring) {
#line 650
    ok = 0;
  }
  {
#line 651
  uih_drawwindows(uih___1);
  }
#line 652
  if (uih___1->errstring) {
#line 653
    ok = 0;
  }
  {
#line 654
  uih_freecontext(uih___1);
#line 655
  uih_freecatalog(uih___1);
  }
#line 656
  if (interrupt) {
    {
#line 657
    tmp___2 = gettext("Calculation interrupted");
#line 657
    error___0((char const   *)tmp___2);
    }
  } else {
    {
#line 659
    tmp___3 = gettext("Calculation finished");
#line 659
    printmsg((char const   *)tmp___3);
    }
  }
#line 661
  if (gc) {
#line 662
    gc->incalculation = 0;
  }
#line 663
  return (1);
}
}
#line 230 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __isnan)(double __value )  __attribute__((__const__)) ;
#line 230
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __isnanf)(float __value )  __attribute__((__const__)) ;
#line 230
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __isnanl)(long double __value )  __attribute__((__const__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 2 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/autod.c"
__inline static int look18(uih_context *context , int x , int y , int range , int max ) 
{ 
  register pixel8_t *vbuff ;
  register int i ;
  register int j ;
  register int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 6
  c = 0;
#line 7
  if (range < ((context->zengine)->image)->width / 2) {
#line 8
    if (x < 0) {
#line 10
      return (0);
    } else
#line 8
    if (x > ((context->zengine)->image)->width) {
#line 10
      return (0);
    } else
#line 8
    if (y < 0) {
#line 10
      return (0);
    } else
#line 8
    if (y > ((context->zengine)->image)->height) {
#line 10
      return (0);
    }
  }
  {
#line 11
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12
    max --;
#line 13
    c = 0;
#line 14
    if (range > ((context->zengine)->image)->width / 2) {
      {
#line 15
      tmp = rand();
#line 15
      context->x1 = tmp % ((((context->zengine)->image)->width - 4) - 1) + 2;
#line 15
      tmp___0 = rand();
#line 15
      context->y1 = tmp___0 % ((((context->zengine)->image)->height - 4) - 1) + 2;
      }
    } else {
      {
#line 21
      tmp___1 = rand();
#line 21
      context->x1 = (tmp___1 % range - (range >> 1)) + x;
#line 22
      tmp___2 = rand();
#line 22
      context->y1 = (tmp___2 % range - (range >> 1)) + y;
      }
#line 23
      if (context->x1 < 2) {
#line 24
        context->x1 = 2;
      }
#line 25
      if (context->y1 < 2) {
#line 26
        context->y1 = 2;
      }
#line 27
      if (context->x1 > (((context->zengine)->image)->width - 2) - 2) {
#line 29
        context->x1 = (((context->zengine)->image)->width - 2) - 2;
      }
#line 31
      if (context->y1 > (((context->zengine)->image)->height - 2) - 2) {
#line 33
        context->y1 = (((context->zengine)->image)->height - 2) - 2;
      }
    }
#line 36
    j = context->y1 - 2;
    {
#line 36
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 36
      if (! (j <= context->y1 + 2)) {
#line 36
        goto while_break___0;
      }
#line 37
      vbuff = *(((context->zengine)->image)->currlines + j);
#line 38
      i = context->x1 - 2;
      {
#line 38
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 38
        if (! (i <= context->x1 + 2)) {
#line 38
          goto while_break___1;
        }
#line 40
        if ((unsigned int )*(vbuff + i) == *(((context->image)->palette)->pixels + 0)) {
#line 41
          c ++;
        }
#line 38
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 36
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 11
    if (c == 0) {
#line 11
      goto _L;
    } else
#line 11
    if (c > 4) {
      _L: /* CIL Label */ 
#line 11
      if (! (max > 0)) {
#line 11
        goto while_break;
      }
    } else {
#line 11
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  if (max > 0) {
#line 46
    context->c1 = 256;
#line 46
    context->interlevel = 1;
#line 47
    return (1);
  }
#line 49
  return (0);
}
}
#line 52 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/autod.c"
__inline static int look28(uih_context *context , int x , int y , int range , int max ) 
{ 
  register pixel8_t *vbuff ;
  register pixel8_t *vbuff2 ;
  register int i ;
  register int j ;
  register int i1 ;
  register int j1___0 ;
  register int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 56
  c = 0;
#line 57
  if (range < ((context->zengine)->image)->width / 2) {
#line 58
    if (x < 0) {
#line 60
      return (0);
    } else
#line 58
    if (x > ((context->zengine)->image)->width) {
#line 60
      return (0);
    } else
#line 58
    if (y < 0) {
#line 60
      return (0);
    } else
#line 58
    if (y > ((context->zengine)->image)->height) {
#line 60
      return (0);
    }
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    max --;
#line 63
    c = 0;
#line 65
    if (range > ((context->zengine)->image)->width / 2) {
      {
#line 66
      tmp = rand();
#line 66
      context->x1 = tmp % ((((context->zengine)->image)->width - 4) - 1) + 2;
#line 66
      tmp___0 = rand();
#line 66
      context->y1 = tmp___0 % ((((context->zengine)->image)->height - 4) - 1) + 2;
      }
    } else {
      {
#line 72
      tmp___1 = rand();
#line 72
      context->x1 = (tmp___1 % range - (range >> 1)) + x;
#line 73
      tmp___2 = rand();
#line 73
      context->y1 = (tmp___2 % range - (range >> 1)) + y;
      }
#line 74
      if (context->x1 < 2) {
#line 75
        context->x1 = 2;
      }
#line 76
      if (context->y1 < 2) {
#line 77
        context->y1 = 2;
      }
#line 78
      if (context->x1 > (((context->zengine)->image)->width - 2) - 2) {
#line 80
        context->x1 = (((context->zengine)->image)->width - 2) - 2;
      }
#line 82
      if (context->y1 > (((context->zengine)->image)->height - 2) - 2) {
#line 84
        context->y1 = (((context->zengine)->image)->height - 2) - 2;
      }
    }
#line 88
    j = context->y1 - 2;
    {
#line 88
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 88
      if (! (j < context->y1 + 2)) {
#line 88
        goto while_break___0;
      }
#line 89
      vbuff = *(((context->zengine)->image)->currlines + j);
#line 90
      i = context->x1 - 2;
      {
#line 90
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 90
        if (! (i <= context->x1 + 2)) {
#line 90
          goto while_break___1;
        }
#line 92
        j1___0 = j + 1;
        {
#line 92
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 92
          if (! (j1___0 < context->y1 + 2)) {
#line 92
            goto while_break___2;
          }
#line 93
          vbuff2 = *(((context->zengine)->image)->currlines + j1___0);
#line 96
          i1 = i + 1;
          {
#line 96
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 96
            if (! (i1 < context->x1 + 2)) {
#line 96
              goto while_break___3;
            }
#line 97
            if ((int )*(vbuff + i) == (int )*(vbuff2 + i1)) {
#line 98
              c ++;
            }
#line 96
            i1 ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 92
          j1___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 90
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 88
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 61
    if (c > 2) {
#line 61
      if (! (max > 0)) {
#line 61
        goto while_break;
      }
    } else {
#line 61
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if (max > 0) {
#line 105
    context->c1 = 256;
#line 105
    context->interlevel = 2;
#line 106
    return (1);
  }
#line 108
  return (0);
}
}
#line 2 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/autod.c"
__inline static int look116(uih_context *context , int x , int y , int range , int max ) 
{ 
  register pixel16_t *vbuff ;
  register int i ;
  register int j ;
  register int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 6
  c = 0;
#line 7
  if (range < ((context->zengine)->image)->width / 2) {
#line 8
    if (x < 0) {
#line 10
      return (0);
    } else
#line 8
    if (x > ((context->zengine)->image)->width) {
#line 10
      return (0);
    } else
#line 8
    if (y < 0) {
#line 10
      return (0);
    } else
#line 8
    if (y > ((context->zengine)->image)->height) {
#line 10
      return (0);
    }
  }
  {
#line 11
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12
    max --;
#line 13
    c = 0;
#line 14
    if (range > ((context->zengine)->image)->width / 2) {
      {
#line 15
      tmp = rand();
#line 15
      context->x1 = tmp % ((((context->zengine)->image)->width - 4) - 1) + 2;
#line 15
      tmp___0 = rand();
#line 15
      context->y1 = tmp___0 % ((((context->zengine)->image)->height - 4) - 1) + 2;
      }
    } else {
      {
#line 21
      tmp___1 = rand();
#line 21
      context->x1 = (tmp___1 % range - (range >> 1)) + x;
#line 22
      tmp___2 = rand();
#line 22
      context->y1 = (tmp___2 % range - (range >> 1)) + y;
      }
#line 23
      if (context->x1 < 2) {
#line 24
        context->x1 = 2;
      }
#line 25
      if (context->y1 < 2) {
#line 26
        context->y1 = 2;
      }
#line 27
      if (context->x1 > (((context->zengine)->image)->width - 2) - 2) {
#line 29
        context->x1 = (((context->zengine)->image)->width - 2) - 2;
      }
#line 31
      if (context->y1 > (((context->zengine)->image)->height - 2) - 2) {
#line 33
        context->y1 = (((context->zengine)->image)->height - 2) - 2;
      }
    }
#line 36
    j = context->y1 - 2;
    {
#line 36
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 36
      if (! (j <= context->y1 + 2)) {
#line 36
        goto while_break___0;
      }
#line 37
      vbuff = (pixel16_t *)*(((context->zengine)->image)->currlines + j);
#line 38
      i = context->x1 - 2;
      {
#line 38
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 38
        if (! (i <= context->x1 + 2)) {
#line 38
          goto while_break___1;
        }
#line 40
        if ((unsigned int )*(vbuff + i) == *(((context->image)->palette)->pixels + 0)) {
#line 41
          c ++;
        }
#line 38
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 36
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 11
    if (c == 0) {
#line 11
      goto _L;
    } else
#line 11
    if (c > 4) {
      _L: /* CIL Label */ 
#line 11
      if (! (max > 0)) {
#line 11
        goto while_break;
      }
    } else {
#line 11
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  if (max > 0) {
#line 46
    context->c1 = 256;
#line 46
    context->interlevel = 1;
#line 47
    return (1);
  }
#line 49
  return (0);
}
}
#line 52 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/autod.c"
__inline static int look216(uih_context *context , int x , int y , int range , int max ) 
{ 
  register pixel16_t *vbuff ;
  register pixel16_t *vbuff2 ;
  register int i ;
  register int j ;
  register int i1 ;
  register int j1___0 ;
  register int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 56
  c = 0;
#line 57
  if (range < ((context->zengine)->image)->width / 2) {
#line 58
    if (x < 0) {
#line 60
      return (0);
    } else
#line 58
    if (x > ((context->zengine)->image)->width) {
#line 60
      return (0);
    } else
#line 58
    if (y < 0) {
#line 60
      return (0);
    } else
#line 58
    if (y > ((context->zengine)->image)->height) {
#line 60
      return (0);
    }
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    max --;
#line 63
    c = 0;
#line 65
    if (range > ((context->zengine)->image)->width / 2) {
      {
#line 66
      tmp = rand();
#line 66
      context->x1 = tmp % ((((context->zengine)->image)->width - 4) - 1) + 2;
#line 66
      tmp___0 = rand();
#line 66
      context->y1 = tmp___0 % ((((context->zengine)->image)->height - 4) - 1) + 2;
      }
    } else {
      {
#line 72
      tmp___1 = rand();
#line 72
      context->x1 = (tmp___1 % range - (range >> 1)) + x;
#line 73
      tmp___2 = rand();
#line 73
      context->y1 = (tmp___2 % range - (range >> 1)) + y;
      }
#line 74
      if (context->x1 < 2) {
#line 75
        context->x1 = 2;
      }
#line 76
      if (context->y1 < 2) {
#line 77
        context->y1 = 2;
      }
#line 78
      if (context->x1 > (((context->zengine)->image)->width - 2) - 2) {
#line 80
        context->x1 = (((context->zengine)->image)->width - 2) - 2;
      }
#line 82
      if (context->y1 > (((context->zengine)->image)->height - 2) - 2) {
#line 84
        context->y1 = (((context->zengine)->image)->height - 2) - 2;
      }
    }
#line 88
    j = context->y1 - 2;
    {
#line 88
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 88
      if (! (j < context->y1 + 2)) {
#line 88
        goto while_break___0;
      }
#line 89
      vbuff = (pixel16_t *)*(((context->zengine)->image)->currlines + j);
#line 90
      i = context->x1 - 2;
      {
#line 90
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 90
        if (! (i <= context->x1 + 2)) {
#line 90
          goto while_break___1;
        }
#line 92
        j1___0 = j + 1;
        {
#line 92
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 92
          if (! (j1___0 < context->y1 + 2)) {
#line 92
            goto while_break___2;
          }
#line 93
          vbuff2 = (pixel16_t *)*(((context->zengine)->image)->currlines + j1___0);
#line 96
          i1 = i + 1;
          {
#line 96
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 96
            if (! (i1 < context->x1 + 2)) {
#line 96
              goto while_break___3;
            }
#line 97
            if ((int )*(vbuff + i) == (int )*(vbuff2 + i1)) {
#line 98
              c ++;
            }
#line 96
            i1 ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 92
          j1___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 90
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 88
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 61
    if (c > 2) {
#line 61
      if (! (max > 0)) {
#line 61
        goto while_break;
      }
    } else {
#line 61
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if (max > 0) {
#line 105
    context->c1 = 256;
#line 105
    context->interlevel = 2;
#line 106
    return (1);
  }
#line 108
  return (0);
}
}
#line 2 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/autod.c"
__inline static int look124(uih_context *context , int x , int y , int range , int max ) 
{ 
  register pixel8_t *vbuff ;
  register int i ;
  register int j ;
  register int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 6
  c = 0;
#line 7
  if (range < ((context->zengine)->image)->width / 2) {
#line 8
    if (x < 0) {
#line 10
      return (0);
    } else
#line 8
    if (x > ((context->zengine)->image)->width) {
#line 10
      return (0);
    } else
#line 8
    if (y < 0) {
#line 10
      return (0);
    } else
#line 8
    if (y > ((context->zengine)->image)->height) {
#line 10
      return (0);
    }
  }
  {
#line 11
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12
    max --;
#line 13
    c = 0;
#line 14
    if (range > ((context->zengine)->image)->width / 2) {
      {
#line 15
      tmp = rand();
#line 15
      context->x1 = tmp % ((((context->zengine)->image)->width - 4) - 1) + 2;
#line 15
      tmp___0 = rand();
#line 15
      context->y1 = tmp___0 % ((((context->zengine)->image)->height - 4) - 1) + 2;
      }
    } else {
      {
#line 21
      tmp___1 = rand();
#line 21
      context->x1 = (tmp___1 % range - (range >> 1)) + x;
#line 22
      tmp___2 = rand();
#line 22
      context->y1 = (tmp___2 % range - (range >> 1)) + y;
      }
#line 23
      if (context->x1 < 2) {
#line 24
        context->x1 = 2;
      }
#line 25
      if (context->y1 < 2) {
#line 26
        context->y1 = 2;
      }
#line 27
      if (context->x1 > (((context->zengine)->image)->width - 2) - 2) {
#line 29
        context->x1 = (((context->zengine)->image)->width - 2) - 2;
      }
#line 31
      if (context->y1 > (((context->zengine)->image)->height - 2) - 2) {
#line 33
        context->y1 = (((context->zengine)->image)->height - 2) - 2;
      }
    }
#line 36
    j = context->y1 - 2;
    {
#line 36
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 36
      if (! (j <= context->y1 + 2)) {
#line 36
        goto while_break___0;
      }
#line 37
      vbuff = *(((context->zengine)->image)->currlines + j);
#line 38
      i = context->x1 - 2;
      {
#line 38
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 38
        if (! (i <= context->x1 + 2)) {
#line 38
          goto while_break___1;
        }
#line 40
        if ((pixel32_t )*((pixel16_t *)(vbuff + i * 3)) + (pixel32_t )((int )*((vbuff + i * 3) + 2) << 16) == *(((context->image)->palette)->pixels + 0)) {
#line 41
          c ++;
        }
#line 38
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 36
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 11
    if (c == 0) {
#line 11
      goto _L;
    } else
#line 11
    if (c > 4) {
      _L: /* CIL Label */ 
#line 11
      if (! (max > 0)) {
#line 11
        goto while_break;
      }
    } else {
#line 11
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  if (max > 0) {
#line 46
    context->c1 = 256;
#line 46
    context->interlevel = 1;
#line 47
    return (1);
  }
#line 49
  return (0);
}
}
#line 52 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/autod.c"
__inline static int look224(uih_context *context , int x , int y , int range , int max ) 
{ 
  register pixel8_t *vbuff ;
  register pixel8_t *vbuff2 ;
  register int i ;
  register int j ;
  register int i1 ;
  register int j1___0 ;
  register int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 56
  c = 0;
#line 57
  if (range < ((context->zengine)->image)->width / 2) {
#line 58
    if (x < 0) {
#line 60
      return (0);
    } else
#line 58
    if (x > ((context->zengine)->image)->width) {
#line 60
      return (0);
    } else
#line 58
    if (y < 0) {
#line 60
      return (0);
    } else
#line 58
    if (y > ((context->zengine)->image)->height) {
#line 60
      return (0);
    }
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    max --;
#line 63
    c = 0;
#line 65
    if (range > ((context->zengine)->image)->width / 2) {
      {
#line 66
      tmp = rand();
#line 66
      context->x1 = tmp % ((((context->zengine)->image)->width - 4) - 1) + 2;
#line 66
      tmp___0 = rand();
#line 66
      context->y1 = tmp___0 % ((((context->zengine)->image)->height - 4) - 1) + 2;
      }
    } else {
      {
#line 72
      tmp___1 = rand();
#line 72
      context->x1 = (tmp___1 % range - (range >> 1)) + x;
#line 73
      tmp___2 = rand();
#line 73
      context->y1 = (tmp___2 % range - (range >> 1)) + y;
      }
#line 74
      if (context->x1 < 2) {
#line 75
        context->x1 = 2;
      }
#line 76
      if (context->y1 < 2) {
#line 77
        context->y1 = 2;
      }
#line 78
      if (context->x1 > (((context->zengine)->image)->width - 2) - 2) {
#line 80
        context->x1 = (((context->zengine)->image)->width - 2) - 2;
      }
#line 82
      if (context->y1 > (((context->zengine)->image)->height - 2) - 2) {
#line 84
        context->y1 = (((context->zengine)->image)->height - 2) - 2;
      }
    }
#line 88
    j = context->y1 - 2;
    {
#line 88
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 88
      if (! (j < context->y1 + 2)) {
#line 88
        goto while_break___0;
      }
#line 89
      vbuff = *(((context->zengine)->image)->currlines + j);
#line 90
      i = context->x1 - 2;
      {
#line 90
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 90
        if (! (i <= context->x1 + 2)) {
#line 90
          goto while_break___1;
        }
#line 92
        j1___0 = j + 1;
        {
#line 92
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 92
          if (! (j1___0 < context->y1 + 2)) {
#line 92
            goto while_break___2;
          }
#line 93
          vbuff2 = *(((context->zengine)->image)->currlines + j1___0);
#line 96
          i1 = i + 1;
          {
#line 96
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 96
            if (! (i1 < context->x1 + 2)) {
#line 96
              goto while_break___3;
            }
#line 97
            if ((pixel32_t )*((pixel16_t *)(vbuff + i * 3)) + (pixel32_t )((int )*((vbuff + i * 3) + 2) << 16) == (pixel32_t )*((pixel16_t *)(vbuff2 + i1 * 3)) + (pixel32_t )((int )*((vbuff2 + i1 * 3) + 2) << 16)) {
#line 98
              c ++;
            }
#line 96
            i1 ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 92
          j1___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 90
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 88
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 61
    if (c > 2) {
#line 61
      if (! (max > 0)) {
#line 61
        goto while_break;
      }
    } else {
#line 61
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if (max > 0) {
#line 105
    context->c1 = 256;
#line 105
    context->interlevel = 2;
#line 106
    return (1);
  }
#line 108
  return (0);
}
}
#line 2 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/autod.c"
__inline static int look132(uih_context *context , int x , int y , int range , int max ) 
{ 
  register pixel32_t *vbuff ;
  register int i ;
  register int j ;
  register int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 6
  c = 0;
#line 7
  if (range < ((context->zengine)->image)->width / 2) {
#line 8
    if (x < 0) {
#line 10
      return (0);
    } else
#line 8
    if (x > ((context->zengine)->image)->width) {
#line 10
      return (0);
    } else
#line 8
    if (y < 0) {
#line 10
      return (0);
    } else
#line 8
    if (y > ((context->zengine)->image)->height) {
#line 10
      return (0);
    }
  }
  {
#line 11
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12
    max --;
#line 13
    c = 0;
#line 14
    if (range > ((context->zengine)->image)->width / 2) {
      {
#line 15
      tmp = rand();
#line 15
      context->x1 = tmp % ((((context->zengine)->image)->width - 4) - 1) + 2;
#line 15
      tmp___0 = rand();
#line 15
      context->y1 = tmp___0 % ((((context->zengine)->image)->height - 4) - 1) + 2;
      }
    } else {
      {
#line 21
      tmp___1 = rand();
#line 21
      context->x1 = (tmp___1 % range - (range >> 1)) + x;
#line 22
      tmp___2 = rand();
#line 22
      context->y1 = (tmp___2 % range - (range >> 1)) + y;
      }
#line 23
      if (context->x1 < 2) {
#line 24
        context->x1 = 2;
      }
#line 25
      if (context->y1 < 2) {
#line 26
        context->y1 = 2;
      }
#line 27
      if (context->x1 > (((context->zengine)->image)->width - 2) - 2) {
#line 29
        context->x1 = (((context->zengine)->image)->width - 2) - 2;
      }
#line 31
      if (context->y1 > (((context->zengine)->image)->height - 2) - 2) {
#line 33
        context->y1 = (((context->zengine)->image)->height - 2) - 2;
      }
    }
#line 36
    j = context->y1 - 2;
    {
#line 36
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 36
      if (! (j <= context->y1 + 2)) {
#line 36
        goto while_break___0;
      }
#line 37
      vbuff = (pixel32_t *)*(((context->zengine)->image)->currlines + j);
#line 38
      i = context->x1 - 2;
      {
#line 38
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 38
        if (! (i <= context->x1 + 2)) {
#line 38
          goto while_break___1;
        }
#line 40
        if (*(vbuff + i) == *(((context->image)->palette)->pixels + 0)) {
#line 41
          c ++;
        }
#line 38
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 36
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 11
    if (c == 0) {
#line 11
      goto _L;
    } else
#line 11
    if (c > 4) {
      _L: /* CIL Label */ 
#line 11
      if (! (max > 0)) {
#line 11
        goto while_break;
      }
    } else {
#line 11
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  if (max > 0) {
#line 46
    context->c1 = 256;
#line 46
    context->interlevel = 1;
#line 47
    return (1);
  }
#line 49
  return (0);
}
}
#line 52 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/autod.c"
__inline static int look232(uih_context *context , int x , int y , int range , int max ) 
{ 
  register pixel32_t *vbuff ;
  register pixel32_t *vbuff2 ;
  register int i ;
  register int j ;
  register int i1 ;
  register int j1___0 ;
  register int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 56
  c = 0;
#line 57
  if (range < ((context->zengine)->image)->width / 2) {
#line 58
    if (x < 0) {
#line 60
      return (0);
    } else
#line 58
    if (x > ((context->zengine)->image)->width) {
#line 60
      return (0);
    } else
#line 58
    if (y < 0) {
#line 60
      return (0);
    } else
#line 58
    if (y > ((context->zengine)->image)->height) {
#line 60
      return (0);
    }
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    max --;
#line 63
    c = 0;
#line 65
    if (range > ((context->zengine)->image)->width / 2) {
      {
#line 66
      tmp = rand();
#line 66
      context->x1 = tmp % ((((context->zengine)->image)->width - 4) - 1) + 2;
#line 66
      tmp___0 = rand();
#line 66
      context->y1 = tmp___0 % ((((context->zengine)->image)->height - 4) - 1) + 2;
      }
    } else {
      {
#line 72
      tmp___1 = rand();
#line 72
      context->x1 = (tmp___1 % range - (range >> 1)) + x;
#line 73
      tmp___2 = rand();
#line 73
      context->y1 = (tmp___2 % range - (range >> 1)) + y;
      }
#line 74
      if (context->x1 < 2) {
#line 75
        context->x1 = 2;
      }
#line 76
      if (context->y1 < 2) {
#line 77
        context->y1 = 2;
      }
#line 78
      if (context->x1 > (((context->zengine)->image)->width - 2) - 2) {
#line 80
        context->x1 = (((context->zengine)->image)->width - 2) - 2;
      }
#line 82
      if (context->y1 > (((context->zengine)->image)->height - 2) - 2) {
#line 84
        context->y1 = (((context->zengine)->image)->height - 2) - 2;
      }
    }
#line 88
    j = context->y1 - 2;
    {
#line 88
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 88
      if (! (j < context->y1 + 2)) {
#line 88
        goto while_break___0;
      }
#line 89
      vbuff = (pixel32_t *)*(((context->zengine)->image)->currlines + j);
#line 90
      i = context->x1 - 2;
      {
#line 90
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 90
        if (! (i <= context->x1 + 2)) {
#line 90
          goto while_break___1;
        }
#line 92
        j1___0 = j + 1;
        {
#line 92
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 92
          if (! (j1___0 < context->y1 + 2)) {
#line 92
            goto while_break___2;
          }
#line 93
          vbuff2 = (pixel32_t *)*(((context->zengine)->image)->currlines + j1___0);
#line 96
          i1 = i + 1;
          {
#line 96
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 96
            if (! (i1 < context->x1 + 2)) {
#line 96
              goto while_break___3;
            }
#line 97
            if (*(vbuff + i) == *(vbuff2 + i1)) {
#line 98
              c ++;
            }
#line 96
            i1 ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 92
          j1___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 90
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 88
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 61
    if (c > 2) {
#line 61
      if (! (max > 0)) {
#line 61
        goto while_break;
      }
    } else {
#line 61
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if (max > 0) {
#line 105
    context->c1 = 256;
#line 105
    context->interlevel = 2;
#line 106
    return (1);
  }
#line 108
  return (0);
}
}
#line 67 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/autopilot.c"
void clean_autopilot(uih_context *context ) 
{ 


  {
#line 69
  context->minsize = (number_t )1000;
#line 70
  context->maxsize = (number_t )0;
#line 71
  context->autime = 0;
#line 72
  context->minlong = 0;
#line 73
  context->x1 = 2147483647;
#line 74
  context->y1 = 2147483647;
#line 75
  context->autopilotversion = (context->fcontext)->version;
#line 76
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/autopilot.c"
static void again(uih_context *context ) 
{ 


  {
  {
#line 80
  (context->fcontext)->s = (vinfo )((context->fcontext)->currentformula)->v;
#line 81
  ((context->fcontext)->version) ++;
#line 82
  clean_autopilot(context);
  }
#line 83
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/autopilot.c"
void do_autopilot(uih_context *context , int *x , int *y , int *controls , void (*changed___0)(void) ,
                  int times ) 
{ 
  int c ;
  number_t volatile   step ;
  number_t volatile   pos ;
  number_t volatile   pos1 ;
  number_t volatile   ystep ;
  number_t volatile   ypos ;
  number_t volatile   ypos1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;

  {
  {
#line 89
  c = 0;
#line 90
  step = (number_t volatile   )((((context->fcontext)->rs.mc - (context->fcontext)->rs.nc) / (number_t )((context->zengine)->image)->width) / (number_t )10);
#line 93
  pos = (number_t volatile   )(context->fcontext)->rs.mc;
#line 94
  pos1 = (number_t volatile   )(context->fcontext)->rs.mc;
#line 95
  ystep = (number_t volatile   )((((context->fcontext)->rs.mi - (context->fcontext)->rs.ni) / (number_t )((context->zengine)->image)->height) / (number_t )10);
#line 98
  ypos = (number_t volatile   )(context->fcontext)->rs.mi;
#line 99
  ypos1 = (number_t volatile   )(context->fcontext)->rs.mi;
#line 100
  pos += step;
#line 101
  ypos += ystep;
#line 102
  pos1 -= step;
#line 103
  ypos1 -= ystep;
#line 104
  *x = context->x1;
#line 105
  *y = context->y1;
#line 106
  uih_clearwindows(context);
#line 107
  (*(((context->zengine)->action)->convertup))(context->zengine, x, y);
  }
#line 108
  if (context->minlong > 5) {
#line 108
    if (context->c1 == 1024) {
      {
#line 121
      again(context);
#line 122
      (*changed___0)();
      }
    } else {
#line 108
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 108
  if (! (pos > (number_t volatile   )(context->fcontext)->rs.mc)) {
    {
#line 121
    again(context);
#line 122
    (*changed___0)();
    }
  } else
#line 108
  if (! (ypos > (number_t volatile   )(context->fcontext)->rs.mi)) {
    {
#line 121
    again(context);
#line 122
    (*changed___0)();
    }
  } else
#line 108
  if (pos1 >= (number_t volatile   )(context->fcontext)->rs.mc) {
    {
#line 121
    again(context);
#line 122
    (*changed___0)();
    }
  } else
#line 108
  if (ypos1 >= (number_t volatile   )(context->fcontext)->rs.mi) {
    {
#line 121
    again(context);
#line 122
    (*changed___0)();
    }
  } else
#line 108
  if ((context->fcontext)->rs.mc - (context->fcontext)->rs.nc > (number_t )100.0) {
    {
#line 121
    again(context);
#line 122
    (*changed___0)();
    }
  } else {
#line 108
    if (sizeof(pos) == sizeof(float )) {
      {
#line 108
      tmp = __isnanf((float )pos);
#line 108
      tmp___3 = tmp;
      }
    } else {
#line 108
      if (sizeof(pos) == sizeof(double )) {
        {
#line 108
        tmp___0 = __isnan((double )pos);
#line 108
        tmp___2 = tmp___0;
        }
      } else {
        {
#line 108
        tmp___1 = __isnanl((long double )pos);
#line 108
        tmp___2 = tmp___1;
        }
      }
#line 108
      tmp___3 = tmp___2;
    }
#line 108
    if (tmp___3) {
      {
#line 121
      again(context);
#line 122
      (*changed___0)();
      }
    } else {
#line 108
      if (sizeof(ypos) == sizeof(float )) {
        {
#line 108
        tmp___4 = __isnanf((float )ypos);
#line 108
        tmp___8 = tmp___4;
        }
      } else {
#line 108
        if (sizeof(ypos) == sizeof(double )) {
          {
#line 108
          tmp___5 = __isnan((double )ypos);
#line 108
          tmp___7 = tmp___5;
          }
        } else {
          {
#line 108
          tmp___6 = __isnanl((long double )ypos);
#line 108
          tmp___7 = tmp___6;
          }
        }
#line 108
        tmp___8 = tmp___7;
      }
#line 108
      if (tmp___8) {
        {
#line 121
        again(context);
#line 122
        (*changed___0)();
        }
      } else {
#line 108
        if (sizeof((context->fcontext)->s.cr) == sizeof(float )) {
          {
#line 108
          tmp___9 = __isnanf((float )(context->fcontext)->s.cr);
#line 108
          tmp___13 = tmp___9;
          }
        } else {
#line 108
          if (sizeof((context->fcontext)->s.cr) == sizeof(double )) {
            {
#line 108
            tmp___10 = __isnan((double )(context->fcontext)->s.cr);
#line 108
            tmp___12 = tmp___10;
            }
          } else {
            {
#line 108
            tmp___11 = __isnanl((context->fcontext)->s.cr);
#line 108
            tmp___12 = tmp___11;
            }
          }
#line 108
          tmp___13 = tmp___12;
        }
#line 108
        if (tmp___13) {
          {
#line 121
          again(context);
#line 122
          (*changed___0)();
          }
        } else {
#line 108
          if (sizeof((context->fcontext)->s.ci) == sizeof(float )) {
            {
#line 108
            tmp___14 = __isnanf((float )(context->fcontext)->s.ci);
#line 108
            tmp___18 = tmp___14;
            }
          } else {
#line 108
            if (sizeof((context->fcontext)->s.ci) == sizeof(double )) {
              {
#line 108
              tmp___15 = __isnan((double )(context->fcontext)->s.ci);
#line 108
              tmp___17 = tmp___15;
              }
            } else {
              {
#line 108
              tmp___16 = __isnanl((context->fcontext)->s.ci);
#line 108
              tmp___17 = tmp___16;
              }
            }
#line 108
            tmp___18 = tmp___17;
          }
#line 108
          if (tmp___18) {
            {
#line 121
            again(context);
#line 122
            (*changed___0)();
            }
          } else {
#line 108
            if (sizeof((context->fcontext)->s.rr - (context->fcontext)->s.ri) == sizeof(float )) {
              {
#line 108
              tmp___19 = __isnanf((float )((context->fcontext)->s.rr - (context->fcontext)->s.ri));
#line 108
              tmp___23 = tmp___19;
              }
            } else {
#line 108
              if (sizeof((context->fcontext)->s.rr - (context->fcontext)->s.ri) == sizeof(double )) {
                {
#line 108
                tmp___20 = __isnan((double )((context->fcontext)->s.rr - (context->fcontext)->s.ri));
#line 108
                tmp___22 = tmp___20;
                }
              } else {
                {
#line 108
                tmp___21 = __isnanl((context->fcontext)->s.rr - (context->fcontext)->s.ri);
#line 108
                tmp___22 = tmp___21;
                }
              }
#line 108
              tmp___23 = tmp___22;
            }
#line 108
            if (tmp___23) {
              {
#line 121
              again(context);
#line 122
              (*changed___0)();
              }
            } else
#line 108
            if ((context->fcontext)->s.rr == (number_t )0) {
              {
#line 121
              again(context);
#line 122
              (*changed___0)();
              }
            } else
#line 108
            if ((context->fcontext)->s.ri == (number_t )0) {
              {
#line 121
              again(context);
#line 122
              (*changed___0)();
              }
            } else {
#line 108
              if (sizeof((context->fcontext)->rs.mc - (context->fcontext)->rs.mi) == sizeof(float )) {
                {
#line 108
                tmp___24 = __isnanf((float )((context->fcontext)->rs.mc - (context->fcontext)->rs.mi));
#line 108
                tmp___28 = tmp___24;
                }
              } else {
#line 108
                if (sizeof((context->fcontext)->rs.mc - (context->fcontext)->rs.mi) == sizeof(double )) {
                  {
#line 108
                  tmp___25 = __isnan((double )((context->fcontext)->rs.mc - (context->fcontext)->rs.mi));
#line 108
                  tmp___27 = tmp___25;
                  }
                } else {
                  {
#line 108
                  tmp___26 = __isnanl((context->fcontext)->rs.mc - (context->fcontext)->rs.mi);
#line 108
                  tmp___27 = tmp___26;
                  }
                }
#line 108
                tmp___28 = tmp___27;
              }
#line 108
              if (tmp___28) {
                {
#line 121
                again(context);
#line 122
                (*changed___0)();
                }
              } else {
#line 108
                if (sizeof((context->fcontext)->rs.nc - (context->fcontext)->rs.ni) == sizeof(float )) {
                  {
#line 108
                  tmp___29 = __isnanf((float )((context->fcontext)->rs.nc - (context->fcontext)->rs.ni));
#line 108
                  tmp___33 = tmp___29;
                  }
                } else {
#line 108
                  if (sizeof((context->fcontext)->rs.nc - (context->fcontext)->rs.ni) == sizeof(double )) {
                    {
#line 108
                    tmp___30 = __isnan((double )((context->fcontext)->rs.nc - (context->fcontext)->rs.ni));
#line 108
                    tmp___32 = tmp___30;
                    }
                  } else {
                    {
#line 108
                    tmp___31 = __isnanl((context->fcontext)->rs.nc - (context->fcontext)->rs.ni);
#line 108
                    tmp___32 = tmp___31;
                    }
                  }
#line 108
                  tmp___33 = tmp___32;
                }
#line 108
                if (tmp___33) {
                  {
#line 121
                  again(context);
#line 122
                  (*changed___0)();
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 125
  if (! context->c1) {
#line 125
    if ((context->zengine)->flags & (1 << 29)) {
#line 126
      return;
    }
  }
#line 128
  if (! ((unsigned long )changed___0 != (unsigned long )((void *)0))) {
    {
#line 128
    __assert_fail("changed != ((void *)0)", "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui-hlp/autopilot.c",
                  128U, "do_autopilot");
    }
  }
#line 129
  if ((context->fcontext)->version != context->autopilotversion) {
    {
#line 130
    clean_autopilot(context);
    }
  }
#line 131
  if ((context->fcontext)->rs.mc - (context->fcontext)->rs.nc < context->minsize) {
#line 133
    context->minsize = (context->fcontext)->rs.mc - (context->fcontext)->rs.nc;
#line 135
    context->minlong = 0;
  }
#line 137
  if ((context->fcontext)->rs.mc - (context->fcontext)->rs.nc > context->maxsize) {
#line 139
    context->minsize = (context->fcontext)->rs.mc - (context->fcontext)->rs.nc;
#line 141
    context->maxsize = (context->fcontext)->rs.mc - (context->fcontext)->rs.nc;
#line 143
    context->minlong = 0;
  }
#line 145
  if (context->autime <= 0) {
    {
#line 146
    (context->minlong) ++;
#line 147
    tmp___34 = rand();
#line 147
    context->autime = tmp___34 % 10;
    }
#line 148
    if ((context->zengine)->flags & (1 << 30)) {
#line 149
      context->c1 = 0;
    } else {
      {
#line 152
      if (((context->zengine)->image)->bytesperpixel == 1) {
#line 152
        goto case_1;
      }
#line 164
      if (((context->zengine)->image)->bytesperpixel == 2) {
#line 164
        goto case_2;
      }
#line 177
      if (((context->zengine)->image)->bytesperpixel == 3) {
#line 177
        goto case_3;
      }
#line 189
      if (((context->zengine)->image)->bytesperpixel == 4) {
#line 189
        goto case_4;
      }
#line 151
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 153
      c = look18(context, *x, *y, 30, 450);
      }
#line 154
      if (! c) {
        {
#line 155
        c = look28(context, *x, *y, 30, 450);
        }
      }
      {
#line 156
      tmp___35 = rand();
      }
#line 156
      if (! (tmp___35 % 30)) {
#line 157
        c = 0;
      }
#line 158
      if (! c) {
        {
#line 159
        c = look18(context, *x, *y, 10000, 10);
        }
      }
#line 160
      if (! c) {
        {
#line 161
        c = look18(context, *x, *y, 10000, 1000);
        }
      }
#line 162
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 165
      c = look116(context, *x, *y, 30, 450);
      }
#line 166
      if (! c) {
        {
#line 167
        c = look216(context, *x, *y, 30, 450);
        }
      }
      {
#line 168
      tmp___36 = rand();
      }
#line 168
      if (! (tmp___36 % 30)) {
#line 169
        c = 0;
      }
#line 170
      if (! c) {
        {
#line 171
        c = look116(context, *x, *y, 10000, 10);
        }
      }
#line 172
      if (! c) {
        {
#line 173
        c = look216(context, *x, *y, 10000, 10);
        }
      }
#line 174
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 178
      c = look124(context, *x, *y, 30, 450);
      }
#line 179
      if (! c) {
        {
#line 180
        c = look224(context, *x, *y, 30, 450);
        }
      }
      {
#line 181
      tmp___37 = rand();
      }
#line 181
      if (! (tmp___37 % 30)) {
#line 182
        c = 0;
      }
#line 183
      if (! c) {
        {
#line 184
        c = look124(context, *x, *y, 10000, 10);
        }
      }
#line 185
      if (! c) {
        {
#line 186
        c = look224(context, *x, *y, 10000, 10);
        }
      }
#line 187
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 190
      c = look132(context, *x, *y, 30, 450);
      }
#line 191
      if (! c) {
        {
#line 192
        c = look232(context, *x, *y, 30, 450);
        }
      }
      {
#line 193
      tmp___38 = rand();
      }
#line 193
      if (! (tmp___38 % 30)) {
#line 194
        c = 0;
      }
#line 195
      if (! c) {
        {
#line 196
        c = look132(context, *x, *y, 10000, 10);
        }
      }
#line 197
      if (! c) {
        {
#line 198
        c = look232(context, *x, *y, 10000, 10);
        }
      }
      switch_break: /* CIL Label */ ;
      }
#line 200
      if (! c) {
#line 201
        if ((context->zengine)->flags & (1 << 29)) {
#line 202
          context->c1 = 0;
        } else {
#line 204
          context->c1 = 1024;
#line 204
          context->autime >>= 1;
        }
      }
    }
  }
  {
#line 208
  context->autime -= times;
#line 209
  *x = context->x1;
#line 210
  *y = context->y1;
#line 211
  (*(((context->zengine)->action)->convertup))(context->zengine, x, y);
#line 213
  *controls = context->c1;
  }
#line 214
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/grlib.h"
extern void xhline(struct image *image , int x , int y , int width , int fgcolor ) ;
#line 28 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uiint.h"
int ui_nmenus  ;
#line 52 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uimenu.c"
static struct ui_menu *ui_menus[20]  ;
#line 76 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uimenu.c"
static struct ui_menuitems *ui_getmenuitems(char const   *name___0 , int *width1 ,
                                            int *height1 , int *n1 , int horizontal ) 
{ 
  menuitem const   *item ;
  int nseparators ;
  int i ;
  int width ;
  int n ;
  struct ui_menuitems *items ;
  void *tmp ;
  int w ;
  int sbehind ;
  int tmp___0 ;
  int tmp___1 ;
  char c[10] ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char c___0[10] ;
  int tmp___7 ;

  {
#line 81
  nseparators = 0;
#line 83
  width = 0;
#line 86
  n = 0;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 86
    item = menu_item(name___0, n);
    }
#line 86
    if (! ((unsigned long )item != (unsigned long )((void *)0))) {
#line 86
      goto while_break;
    }
#line 87
    if (item->type == 8) {
#line 88
      nseparators ++;
    }
#line 86
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  n -= nseparators;
#line 90
  *n1 = n;
#line 91
  *height1 = n * (int )((uih->font)->height + 1) + nseparators * 6;
#line 92
  tmp = malloc((unsigned long )n * sizeof(struct ui_menuitems ));
#line 92
  items = (struct ui_menuitems *)tmp;
#line 94
  nseparators = 0;
#line 95
  i = 0;
  }
  {
#line 95
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 95
    if (! (i < n)) {
#line 95
      goto while_break___0;
    }
#line 97
    sbehind = -1;
#line 98
    nseparators --;
    {
#line 99
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 100
      nseparators ++;
#line 101
      sbehind ++;
#line 102
      item = menu_item(name___0, i + nseparators);
      }
#line 99
      if (! (item->type == 8)) {
#line 99
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 105
    (items + i)->item = item;
#line 106
    (items + i)->separator = sbehind;
#line 107
    if (horizontal) {
      {
#line 108
      tmp___0 = xtextwidth(uih->font, (char const   *)((items + i)->item)->name);
#line 108
      tmp___1 = xtextwidth(uih->font, "  ");
#line 108
      w = tmp___0 + tmp___1;
      }
#line 109
      if (((items + i)->item)->key) {
        {
#line 111
        sprintf((char */* __restrict  */)(c), (char const   */* __restrict  */)"(%s)",
                ((items + i)->item)->key);
#line 112
        tmp___2 = xtextwidth(uih->font, (char const   *)(c));
#line 112
        w += tmp___2;
        }
      }
    } else {
      {
#line 115
      tmp___3 = xtextwidth(uih->font, "w");
#line 115
      tmp___4 = xtextwidth(uih->font, "X");
#line 115
      tmp___5 = xtextwidth(uih->font, (char const   *)((items + i)->item)->name);
#line 115
      tmp___6 = xtextwidth(uih->font, ">");
#line 115
      w = ((tmp___3 + tmp___4) + tmp___5) + tmp___6;
      }
#line 116
      if (((items + i)->item)->key) {
        {
#line 118
        sprintf((char */* __restrict  */)(c___0), (char const   */* __restrict  */)" %s ",
                ((items + i)->item)->key);
#line 119
        tmp___7 = xtextwidth(uih->font, (char const   *)(c___0));
#line 119
        w += tmp___7;
        }
      }
    }
#line 122
    (items + i)->width = w;
#line 123
    (items + i)->height = (int )(((uih->font)->height + 1) + 1);
#line 124
    if (w > width) {
#line 125
      width = w;
    }
#line 95
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 127
  *width1 = width;
#line 128
  return (items);
}
}
#line 131 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uimenu.c"
static void ui_menusize(uih_context *c , int *x , int *y , int *w , int *h , void *data ) 
{ 
  struct ui_menu *m ;

  {
#line 134
  m = (struct ui_menu *)data;
#line 135
  *x = m->x;
#line 136
  *y = m->y;
#line 137
  *w = m->width;
#line 138
  *h = m->height;
#line 139
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uimenu.c"
static void ui_drawmenu(uih_context *c , void *data ) 
{ 
  struct ui_menu *m ;
  int i ;
  int width1 ;
  int tmp ;
  char s[2] ;
  int color ;
  unsigned int tmp___0 ;
  int pressed ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char ch[20] ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char ch___0[20] ;
  int tmp___7 ;

  {
  {
#line 143
  m = (struct ui_menu *)data;
#line 145
  tmp = xtextwidth(c->font, "w");
#line 145
  width1 = tmp;
#line 147
  s[1] = (char)0;
  }
#line 148
  if (! (m->flags & 1)) {
    {
#line 149
    xprint(c->image, c->font, m->x + (m->width - m->namewidth) / 2, m->y + 2, m->fullname,
           c->encoding, (int )*((c->palette)->index + 2), (int )*((c->palette)->index + 0),
           0);
    }
  }
#line 152
  i = 0;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! (i < m->n)) {
#line 152
      goto while_break;
    }
#line 153
    if (i == m->selected) {
#line 153
      tmp___0 = *((c->palette)->index + 2);
    } else {
#line 153
      tmp___0 = *((c->palette)->index + 1);
    }
#line 153
    color = (int )tmp___0;
#line 154
    pressed = 0;
#line 155
    if ((uih->palette)->type & 3840) {
#line 155
      if (i == m->selected) {
        {
#line 156
        pressed = 1;
#line 157
        color = (int )*((c->palette)->index + 0);
#line 158
        xrectangle(uih->image, (m->items + i)->x, (m->items + i)->y, (m->items + i)->width,
                   (m->items + i)->height, (int )*((c->palette)->index + 1));
        }
      }
    }
#line 161
    if (! (m->flags & 1)) {
#line 162
      if ((m->items + i)->separator) {
        {
#line 163
        xhline(c->image, m->x + 5, ((m->items + i)->y - 2) - 3, m->width - 10, (int )*((c->palette)->index + 0));
#line 166
        xhline(c->image, m->x + 5, ((m->items + i)->y - 1) - 3, m->width - 10, (int )*((c->palette)->index + 4));
        }
      }
#line 170
      if (i < 10) {
#line 171
        if (i == 9) {
#line 171
          tmp___1 = 0;
        } else {
#line 171
          tmp___1 = i + 1;
        }
#line 171
        s[0] = (char )(48 + tmp___1);
      } else {
#line 173
        s[0] = (char )(65 + (i - 10));
      }
      {
#line 174
      xprint(c->image, c->font, (m->items + i)->x, (m->items + i)->y, (char const   *)(s),
             c->encoding, color, (int )*((c->palette)->index + 0), pressed);
#line 176
      tmp___2 = menu_enabled((m->items + i)->item, uih);
      }
#line 176
      if (tmp___2) {
        {
#line 177
        xprint(c->image, c->font, (m->items + i)->x + width1, (m->items + i)->y, "X",
               c->encoding, color, (int )*((c->palette)->index + 0), pressed);
        }
      }
      {
#line 181
      tmp___3 = xtextwidth(uih->font, "X");
#line 181
      xprint(c->image, c->font, ((m->items + i)->x + width1) + tmp___3, (m->items + i)->y,
             (char const   *)((m->items + i)->item)->name, c->encoding, color, (int )*((c->palette)->index + 0),
             pressed);
      }
#line 184
      if (((m->items + i)->item)->key) {
        {
#line 186
        sprintf((char */* __restrict  */)(ch), (char const   */* __restrict  */)" %s ",
                ((m->items + i)->item)->key);
#line 187
        tmp___4 = xtextwidth(uih->font, ">");
#line 187
        tmp___5 = xtextwidth(uih->font, (char const   *)(ch));
#line 187
        xprint(c->image, c->font, (((m->items + i)->x + (m->items + i)->width) - tmp___4) - tmp___5,
               (m->items + i)->y, (char const   *)(ch), c->encoding, (int )*((c->palette)->index + 4),
               (int )*((c->palette)->index + 0), pressed);
        }
      }
#line 193
      if (((m->items + i)->item)->type == 2) {
        {
#line 194
        tmp___6 = xtextwidth(uih->font, ">");
#line 194
        xprint(c->image, c->font, ((m->items + i)->x + (m->items + i)->width) - tmp___6,
               (m->items + i)->y, ">", c->encoding, color, (int )*((c->palette)->index + 0),
               pressed);
        }
      }
    } else {
      {
#line 199
      xprint(c->image, c->font, (m->items + i)->x, (m->items + i)->y, (char const   *)((m->items + i)->item)->name,
             c->encoding, color, (int )*((c->palette)->index + 0), pressed);
      }
#line 202
      if (((m->items + i)->item)->key) {
        {
#line 204
        sprintf((char */* __restrict  */)(ch___0), (char const   */* __restrict  */)"%s",
                ((m->items + i)->item)->key);
#line 205
        tmp___7 = xtextwidth(uih->font, (char const   *)((m->items + i)->item)->name);
#line 205
        xprint(c->image, c->font, ((m->items + i)->x + tmp___7) + 2, (m->items + i)->y,
               (char const   *)(ch___0), c->encoding, (int )*((c->palette)->index + 4),
               (int )*((c->palette)->index + 0), pressed);
        }
      }
    }
#line 152
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return;
}
}
#line 215 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uimenu.c"
static struct ui_menu *ui_buildmenu(char const   *name___0 , int x , int y , int flags ) 
{ 
  int shift ;
  int width ;
  int height ;
  int textheight___0 ;
  struct ui_menu *menu ;
  int i ;
  void *tmp ;
  int line ;
  int xpos ;

  {
  {
#line 218
  shift = 0;
#line 220
  textheight___0 = (int )((uih->font)->height + 1);
#line 223
  tmp = malloc(sizeof(*menu));
#line 223
  menu = (struct ui_menu *)tmp;
#line 224
  menu->timer = tl_create_timer();
#line 225
  tl_reset_timer(menu->timer);
#line 226
  menu->flags = flags;
#line 227
  menu->items = ui_getmenuitems(name___0, & width, & height, & menu->n, flags & 1);
#line 230
  menu->selected = -1;
#line 231
  menu->fullname = menu_fullname(name___0);
#line 232
  menu->name = name___0;
#line 233
  menu->namewidth = xtextwidth(uih->font, menu->fullname);
  }
#line 234
  if (! (menu->flags & 1)) {
#line 235
    if (menu->namewidth > width) {
#line 236
      width = menu->namewidth;
    }
#line 237
    width += 4;
#line 238
    height += 4 + (int )((uih->font)->height + 1);
#line 239
    if (x + width > (uih->image)->width) {
#line 240
      x = (uih->image)->width - width;
    }
#line 241
    if (y + height > (uih->image)->height) {
#line 242
      y = (uih->image)->height - height;
    }
#line 243
    if (x < 0) {
#line 244
      x = 0;
    }
#line 245
    if (y < 0) {
#line 246
      y = 0;
    }
#line 247
    shift = 0;
#line 248
    i = 0;
    {
#line 248
    while (1) {
      while_continue: /* CIL Label */ ;
#line 248
      if (! (i < menu->n)) {
#line 248
        goto while_break;
      }
#line 249
      shift += (menu->items + i)->separator * 6;
#line 250
      (menu->items + i)->x = x + 2;
#line 251
      (menu->items + i)->y = ((y + 2) + textheight___0 * (i + 1)) + shift;
#line 253
      (menu->items + i)->width = width - 4;
#line 254
      (menu->items + i)->height = textheight___0;
#line 248
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 257
    line = 0;
#line 258
    xpos = 2;
#line 259
    x = 0;
#line 259
    width = (uih->image)->width;
#line 260
    i = 0;
    {
#line 260
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 260
      if (! (i < menu->n)) {
#line 260
        goto while_break___0;
      }
#line 261
      if ((xpos + 4) + (menu->items + i)->width > (uih->image)->width) {
#line 263
        xpos = 2;
#line 263
        line ++;
      }
#line 264
      (menu->items + i)->x = xpos;
#line 265
      (menu->items + i)->y = (y + 2) + line * textheight___0;
#line 266
      xpos += (menu->items + i)->width;
#line 267
      (menu->items + i)->height = textheight___0;
#line 260
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 269
    height = (line + 1) * textheight___0 + 4;
  }
  {
#line 271
  menu->selected = -1;
#line 272
  menu->window = uih_registerw(uih, & ui_menusize, & ui_drawmenu, (void *)menu, 2);
#line 274
  uih->display = 1;
#line 275
  menu->x = x;
#line 276
  menu->y = y;
#line 277
  menu->width = width;
#line 278
  menu->height = height;
  }
#line 279
  return (menu);
}
}
#line 282 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uimenu.c"
static void ui_closemenu(struct ui_menu *menu ) 
{ 


  {
  {
#line 284
  free((void *)menu->items);
#line 285
  tl_free_timer(menu->timer);
#line 286
  uih_removew(uih, menu->window);
#line 287
  uih->display = 1;
#line 288
  free((void *)menu);
  }
#line 289
  return;
}
}
#line 291 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uimenu.c"
static void ui_openmenu(char const   *name___0 , int x , int y , int flags ) 
{ 


  {
#line 293
  if (ui_nogui) {
    {
#line 294
    printf((char const   */* __restrict  */)"menu \"%s\"\n", name___0);
    }
#line 295
    return;
  }
#line 297
  if (driver->gui_driver) {
#line 297
    if ((driver->gui_driver)->menu) {
      {
#line 298
      (*((driver->gui_driver)->menu))(uih, name___0);
      }
#line 299
      return;
    }
  }
#line 301
  if (ui_nmenus > 20) {
#line 302
    return;
  }
  {
#line 303
  ui_menus[ui_nmenus] = ui_buildmenu(name___0, x, y, flags);
#line 304
  ui_nmenus ++;
#line 305
  ui_updatestarts();
  }
#line 306
  return;
}
}
#line 308 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uimenu.c"
static void ui_closetopmenu(void) 
{ 


  {
#line 310
  if (! ui_nmenus) {
#line 311
    return;
  }
  {
#line 312
  ui_nmenus --;
#line 313
  ui_closemenu(ui_menus[ui_nmenus]);
#line 314
  ui_updatestarts();
  }
#line 315
  return;
}
}
#line 317 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uimenu.c"
void ui_closemenus(void) 
{ 


  {
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (! ui_nmenus) {
#line 319
      goto while_break;
    }
    {
#line 320
    ui_closetopmenu();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  return;
}
}
#line 323 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uimenu.c"
void ui_menu(char const   *m ) 
{ 
  int mousex ;
  int mousey ;
  int buttons ;

  {
  {
#line 326
  (*(driver->getmouse))(& mousex, & mousey, & buttons);
#line 327
  ui_openmenu(m, mousex, mousey, 0);
  }
#line 328
  return;
}
}
#line 330 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uimenu.c"
static void ui_menupress(int number ) 
{ 
  menuitem const   *item ;
  int flags ;
  int mousex ;
  int mousey ;
  int buttons ;

  {
#line 333
  if (number >= (ui_menus[ui_nmenus - 1])->n) {
#line 334
    return;
  }
#line 335
  (ui_menus[ui_nmenus - 1])->selected = number;
#line 336
  item = ((ui_menus[ui_nmenus - 1])->items + number)->item;
#line 337
  if ((unsigned long )item != (unsigned long )((void *)0)) {
#line 338
    uih->display = 1;
#line 339
    if (item->type == 2) {
      {
#line 340
      flags = 0;
#line 342
      (*(driver->getmouse))(& mousex, & mousey, & buttons);
      }
#line 343
      if (buttons & 256) {
#line 344
        flags |= 2;
      }
#line 345
      if ((ui_menus[ui_nmenus - 1])->flags & 1) {
        {
#line 346
        ui_openmenu((char const   *)item->shortname, ((ui_menus[ui_nmenus - 1])->items + number)->x,
                    ((ui_menus[ui_nmenus - 1])->items + number)->y + ((ui_menus[ui_nmenus - 1])->items + number)->height,
                    flags);
        }
      } else {
        {
#line 352
        ui_openmenu((char const   *)item->shortname, ((ui_menus[ui_nmenus - 1])->items + number)->x + ((ui_menus[ui_nmenus - 1])->items + number)->width,
                    ((ui_menus[ui_nmenus - 1])->items + number)->y, flags);
        }
      }
    } else {
      {
#line 358
      ui_menuactivate(item, (dialogparam *)((void *)0));
      }
    }
  }
#line 360
  return;
}
}
#line 362 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uimenu.c"
int ui_menumouse(int x , int y , int mousebuttons , int flags ) 
{ 
  struct ui_menu *m ;
  int place ;
  int inmenu ;
  int i ;
  struct ui_menu *m2 ;
  int i___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int nmenu ;
  struct ui_menu *m2___0 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 364
  if (ui_nmenus) {
#line 365
    m = ui_menus[ui_nmenus - 1];
#line 366
    place = -1;
#line 367
    inmenu = 0;
#line 368
    if (x >= m->x) {
#line 368
      if (y >= m->y) {
#line 368
        if (x <= m->x + m->width) {
#line 368
          if (y <= m->y + m->height) {
#line 371
            i = 0;
            {
#line 371
            while (1) {
              while_continue: /* CIL Label */ ;
#line 371
              if (! (i < m->n)) {
#line 371
                goto while_break;
              }
#line 372
              if (x >= (m->items + i)->x) {
#line 372
                if (y >= (m->items + i)->y) {
#line 372
                  if (x <= (m->items + i)->x + (m->items + i)->width) {
#line 372
                    if (y <= (m->items + i)->y + (m->items + i)->height) {
#line 375
                      place = i;
#line 376
                      goto while_break;
                    }
                  }
                }
              }
#line 371
              i ++;
            }
            while_break: /* CIL Label */ ;
            }
#line 379
            inmenu = 1;
          } else {
#line 368
            goto _L___1;
          }
        } else {
#line 368
          goto _L___1;
        }
      } else {
#line 368
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 381
    if (ui_nmenus > 1) {
#line 382
      m2 = ui_menus[ui_nmenus - 2];
#line 384
      i___0 = m2->selected;
#line 385
      if (x >= (m2->items + i___0)->x) {
#line 385
        if (y >= (m2->items + i___0)->y) {
#line 385
          if (x <= (m2->items + i___0)->x + (m2->items + i___0)->width) {
#line 385
            if (y <= (m2->items + i___0)->y + (m2->items + i___0)->height) {
#line 388
              inmenu = 1;
            }
          }
        }
      }
    }
#line 391
    if (m->flags & 4) {
#line 391
      if (! inmenu) {
        {
#line 392
        ui_closetopmenu();
#line 393
        tmp = ui_menumouse(x, y, mousebuttons, flags);
        }
#line 393
        return (tmp);
      }
    }
#line 395
    if (flags & 8) {
#line 395
      if (m->selected != place) {
#line 396
        m->selected = place;
#line 396
        uih->display = 1;
      }
    }
#line 397
    if (m->flags & 2) {
#line 398
      if (inmenu) {
#line 398
        if (place >= 0) {
#line 398
          if (m->flags & 1) {
#line 398
            if (flags & 4) {
#line 398
              if (((m->items + place)->item)->type == 2) {
                {
#line 401
                ui_menupress(place);
                }
#line 402
                return (1);
              } else {
#line 398
                goto _L___5;
              }
            } else {
#line 398
              goto _L___5;
            }
          } else {
#line 398
            goto _L___5;
          }
        } else {
#line 398
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 403
      if (inmenu) {
#line 403
        if (place >= 0) {
#line 403
          if (flags & 4) {
#line 403
            if (((m->items + place)->item)->type == 2) {
              {
#line 403
              tmp___0 = xtextwidth(uih->font, ">");
              }
#line 403
              if (x > ((m->items + place)->x + (m->items + place)->width) - 2 * tmp___0) {
                {
#line 408
                ui_menupress(place);
                }
#line 409
                return (1);
              }
            }
          }
        }
      }
#line 411
      if (flags & 2) {
#line 411
        goto _L___6;
      } else
#line 411
      if (! (flags & 4)) {
        _L___6: /* CIL Label */ 
        {
#line 412
        tmp___1 = tl_lookup_timer(m->timer);
        }
#line 412
        if (tmp___1 < 300000) {
#line 413
          m->flags &= -3;
#line 414
          return (1);
        }
#line 416
        if (! inmenu) {
          {
#line 417
          ui_closetopmenu();
#line 418
          tmp___2 = ui_menumouse(x, y, mousebuttons, flags);
          }
#line 418
          return (tmp___2);
        } else
#line 416
        if (place < 0) {
          {
#line 417
          ui_closetopmenu();
#line 418
          tmp___2 = ui_menumouse(x, y, mousebuttons, flags);
          }
#line 418
          return (tmp___2);
        }
        {
#line 420
        ui_menupress(place);
        }
#line 421
        return (1);
      }
#line 423
      if (! inmenu) {
#line 425
        nmenu = ui_nmenus - 2;
        {
#line 425
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 425
          if (! (nmenu > -1)) {
#line 425
            goto while_break___0;
          }
#line 426
          m2___0 = ui_menus[nmenu];
#line 427
          if (x > m2___0->x) {
#line 427
            if (y > m2___0->y) {
#line 427
              if (x < m2___0->x + m2___0->width) {
#line 427
                if (y < m2___0->y + m2___0->height) {
                  {
#line 429
                  ui_closetopmenu();
#line 430
                  m2___0->flags |= 2;
#line 431
                  tmp___3 = ui_menumouse(x, y, mousebuttons, flags);
                  }
#line 431
                  return (tmp___3);
                }
              }
            }
          }
#line 425
          nmenu --;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else
#line 435
    if (flags & 1) {
#line 436
      if (! inmenu) {
        {
#line 437
        ui_closetopmenu();
#line 438
        tmp___4 = ui_menumouse(x, y, mousebuttons, flags);
        }
#line 438
        return (tmp___4);
      } else
#line 436
      if (place < 0) {
        {
#line 437
        ui_closetopmenu();
#line 438
        tmp___4 = ui_menumouse(x, y, mousebuttons, flags);
        }
#line 438
        return (tmp___4);
      }
      {
#line 440
      ui_menupress(place);
      }
    }
#line 442
    return (1);
  } else
#line 444
  if (! ui_nogui) {
#line 444
    if (! driver->gui_driver) {
#line 444
      goto _L___7;
    } else
#line 444
    if (! (driver->gui_driver)->setrootmenu) {
      _L___7: /* CIL Label */ 
#line 444
      if (flags & 8) {
#line 444
        if (y < (int )(((uih->font)->height + 1) + 1)) {
#line 444
          if (! mousebuttons) {
            {
#line 448
            ui_openmenu(uih->menuroot, 0, 0, 5);
            }
          }
        }
      }
    }
  }
#line 451
  return (0);
}
}
#line 454 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uimenu.c"
int ui_menukey(int key ) 
{ 
  int k ;
  struct ui_menu *menu ;
  menuitem const   *item ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 457
  if (! ui_nmenus) {
#line 458
    if (key == 10) {
      {
#line 459
      ui_closemenus();
#line 460
      ui_openmenu(uih->menuroot, 0, 0, 1);
      }
#line 461
      return (1);
    } else
#line 458
    if (key == 13) {
      {
#line 459
      ui_closemenus();
#line 460
      ui_openmenu(uih->menuroot, 0, 0, 1);
      }
#line 461
      return (1);
    }
#line 463
    return (0);
  } else {
#line 465
    menu = ui_menus[ui_nmenus - 1];
    {
#line 468
    if (key == 13) {
#line 468
      goto case_13;
    }
#line 468
    if (key == 10) {
#line 468
      goto case_13;
    }
#line 472
    if (key == 104) {
#line 472
      goto case_104;
    }
#line 482
    if (key == 259) {
#line 482
      goto case_259;
    }
#line 501
    if (key == 260) {
#line 501
      goto case_260;
    }
#line 521
    if (key == 258) {
#line 521
      goto case_258;
    }
#line 534
    if (key == 261) {
#line 534
      goto case_261;
    }
#line 537
    if (key == 257) {
#line 537
      goto case_257;
    }
#line 466
    goto switch_break;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 469
    if (menu->selected >= 0) {
      {
#line 470
      ui_menupress(menu->selected);
      }
    }
#line 471
    return (1);
    case_104: /* CIL Label */ 
    {
#line 474
    item = (menu->items + menu->selected)->item;
#line 475
    ui_closemenus();
    }
#line 476
    if (menu->selected >= 0) {
      {
#line 477
      ui_help((char const   *)item->shortname);
      }
    } else {
      {
#line 479
      ui_help(menu->name);
      }
    }
#line 480
    return (1);
    case_259: /* CIL Label */ 
#line 483
    if (menu->flags & 1) {
#line 484
      if (menu->selected == -1) {
#line 485
        menu->selected = 0;
      } else {
#line 487
        (menu->selected) --;
      }
#line 488
      if (menu->selected < 0) {
#line 489
        menu->selected = menu->n - 1;
      }
#line 490
      uih->display = 1;
    } else
#line 491
    if (ui_nmenus == 2) {
#line 491
      if ((ui_menus[0])->flags & 1) {
        {
#line 493
        ui_closetopmenu();
#line 494
        ((ui_menus[0])->selected) --;
        }
#line 495
        if ((ui_menus[0])->selected < 0) {
#line 496
          (ui_menus[0])->selected = (ui_menus[0])->n - 1;
        }
        {
#line 497
        ui_menupress((ui_menus[0])->selected);
        }
      } else {
        {
#line 499
        ui_closetopmenu();
        }
      }
    } else {
      {
#line 499
      ui_closetopmenu();
      }
    }
#line 500
    return (1);
    case_260: /* CIL Label */ 
#line 502
    if (menu->flags & 1) {
#line 503
      if (menu->selected == -1) {
#line 504
        menu->selected = 0;
      } else {
#line 506
        (menu->selected) ++;
      }
#line 507
      menu->selected %= menu->n;
#line 508
      uih->display = 1;
    } else
#line 509
    if (menu->selected >= 0) {
#line 509
      if (((menu->items + menu->selected)->item)->type == 2) {
        {
#line 512
        ui_menupress(menu->selected);
        }
      } else {
#line 509
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 513
    if (ui_nmenus == 2) {
#line 513
      if ((ui_menus[0])->flags & 1) {
        {
#line 515
        ui_closetopmenu();
#line 516
        ((ui_menus[0])->selected) ++;
#line 517
        (ui_menus[0])->selected %= (ui_menus[0])->n;
#line 518
        ui_menupress((ui_menus[0])->selected);
        }
      }
    }
#line 520
    return (1);
    case_258: /* CIL Label */ 
#line 522
    if (menu->flags & 1) {
#line 523
      if (menu->selected >= 0) {
        {
#line 524
        ui_menupress((ui_menus[0])->selected);
        }
      }
    } else {
#line 526
      if (menu->selected == -1) {
#line 527
        menu->selected = 0;
      } else {
#line 529
        (menu->selected) ++;
      }
#line 530
      menu->selected %= menu->n;
#line 531
      uih->display = 1;
    }
#line 533
    return (1);
    case_261: /* CIL Label */ 
    {
#line 535
    ui_closetopmenu();
    }
#line 536
    return (1);
    case_257: /* CIL Label */ 
#line 538
    if (menu->flags & 1) {
      {
#line 539
      ui_closetopmenu();
      }
    } else {
#line 541
      if (menu->selected == -1) {
#line 542
        menu->selected = 0;
      } else {
#line 544
        (menu->selected) --;
      }
#line 545
      if (menu->selected < 0) {
#line 546
        menu->selected = menu->n - 1;
      }
#line 547
      uih->display = 1;
    }
#line 549
    return (1);
    switch_break: /* CIL Label */ ;
    }
    {
#line 551
    tmp___0 = tolower(key);
    }
#line 551
    if (tmp___0 >= 97) {
      {
#line 551
      tmp___1 = tolower(key);
      }
#line 551
      if (tmp___1 - 97 < (ui_menus[ui_nmenus - 1])->n - 10) {
        {
#line 553
        tmp = tolower(key);
#line 553
        ui_menupress((tmp - 97) + 10);
        }
#line 554
        return (1);
      }
    }
#line 556
    if (key >= 48) {
#line 556
      if (key <= 57) {
#line 557
        k = key - 49;
#line 558
        if (k == -1) {
#line 559
          k = 9;
        }
        {
#line 560
        ui_menupress(k);
        }
#line 561
        return (1);
      }
    }
#line 563
    return (0);
  }
}
}
#line 567 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uimenu.c"
int ui_menuwidth(void) 
{ 


  {
#line 569
  if (ui_nmenus) {
#line 569
    if ((ui_menus[0])->flags & 1) {
#line 570
      return ((ui_menus[0])->height);
    }
  }
#line 571
  return (0);
}
}
#line 222 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/filter.h"
extern int inherimage(struct filter *f , struct initdata *data , int flags , int width ,
                      int height , struct palette *palette , float pixelwidth , float pixelheight ) ;
#line 225
extern void destroyinheredimage(struct filter *f ) ;
#line 226
extern void updateinheredimage(struct filter *f ) ;
#line 228
extern void inhermisc(struct filter *f , struct initdata  const  *i ) ;
#line 47 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xthread.h"
extern struct taskinfo definfo ;
#line 2 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/engine/paletted.c"
static void palette8(void *data , struct taskinfo *task , int r1 , int r2 ) 
{ 
  pixel8_t *src ;
  pixel8_t *srcend ;
  ppixel8_t dest ;
  struct filter *f ;
  struct palettedata *s ;
  int i ;
  unsigned int *table ;

  {
#line 6
  f = (struct filter *)data;
#line 7
  s = (struct palettedata *)f->data;
#line 9
  table = s->table;
#line 10
  i = r1;
  {
#line 10
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10
    if (! (i < r2)) {
#line 10
      goto while_break;
    }
#line 11
    src = *((f->childimage)->currlines + i);
#line 12
    srcend = src + (f->image)->width;
#line 13
    dest = *((f->image)->currlines + i);
    {
#line 14
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 14
      if (! ((unsigned long )src < (unsigned long )srcend)) {
#line 14
        goto while_break___0;
      }
#line 15
      *dest = (pixel8_t )*(table + *src);
#line 16
      src ++;
#line 17
      dest ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 10
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 20
  return;
}
}
#line 2 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/engine/paletted.c"
static void palette32(void *data , struct taskinfo *task , int r1 , int r2 ) 
{ 
  pixel8_t *src ;
  pixel8_t *srcend ;
  ppixel32_t dest ;
  struct filter *f ;
  struct palettedata *s ;
  int i ;
  unsigned int *table ;

  {
#line 6
  f = (struct filter *)data;
#line 7
  s = (struct palettedata *)f->data;
#line 9
  table = s->table;
#line 10
  i = r1;
  {
#line 10
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10
    if (! (i < r2)) {
#line 10
      goto while_break;
    }
#line 11
    src = *((f->childimage)->currlines + i);
#line 12
    srcend = src + (f->image)->width;
#line 13
    dest = (ppixel32_t )*((f->image)->currlines + i);
    {
#line 14
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 14
      if (! ((unsigned long )src < (unsigned long )srcend)) {
#line 14
        goto while_break___0;
      }
#line 15
      *dest = *(table + *src);
#line 16
      src ++;
#line 17
      dest ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 10
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 20
  return;
}
}
#line 2 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/engine/paletted.c"
static void palette24(void *data , struct taskinfo *task , int r1 , int r2 ) 
{ 
  pixel8_t *src ;
  pixel8_t *srcend ;
  ppixel8_t dest ;
  struct filter *f ;
  struct palettedata *s ;
  int i ;
  unsigned int *table ;

  {
#line 6
  f = (struct filter *)data;
#line 7
  s = (struct palettedata *)f->data;
#line 9
  table = s->table;
#line 10
  i = r1;
  {
#line 10
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10
    if (! (i < r2)) {
#line 10
      goto while_break;
    }
#line 11
    src = *((f->childimage)->currlines + i);
#line 12
    srcend = src + (f->image)->width;
#line 13
    dest = *((f->image)->currlines + i);
    {
#line 14
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 14
      if (! ((unsigned long )src < (unsigned long )srcend)) {
#line 14
        goto while_break___0;
      }
#line 15
      *((pixel16_t *)dest) = (pixel16_t )*(table + *src);
#line 15
      *(dest + 2) = (pixel8_t )(*(table + *src) >> 16);
#line 16
      src ++;
#line 17
      dest += 3;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 10
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 20
  return;
}
}
#line 2 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/engine/paletted.c"
static void palette16(void *data , struct taskinfo *task , int r1 , int r2 ) 
{ 
  pixel8_t *src ;
  pixel8_t *srcend ;
  ppixel16_t dest ;
  struct filter *f ;
  struct palettedata *s ;
  int i ;
  unsigned int *table ;

  {
#line 6
  f = (struct filter *)data;
#line 7
  s = (struct palettedata *)f->data;
#line 9
  table = s->table;
#line 10
  i = r1;
  {
#line 10
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10
    if (! (i < r2)) {
#line 10
      goto while_break;
    }
#line 11
    src = *((f->childimage)->currlines + i);
#line 12
    srcend = src + (f->image)->width;
#line 13
    dest = (ppixel16_t )*((f->image)->currlines + i);
    {
#line 14
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 14
      if (! ((unsigned long )src < (unsigned long )srcend)) {
#line 14
        goto while_break___0;
      }
#line 15
      *dest = (pixel16_t )*(table + *src);
#line 16
      src ++;
#line 17
      dest ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 10
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 20
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/engine/palettef.c"
static void mysetcolor(struct palette *p , int start , int end , rgb_t *rgb ) 
{ 


  {
#line 40
  p->data = (void *)(& p);
#line 41
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/engine/palettef.c"
static int requirement(struct filter *f , struct requirements *r ) 
{ 
  int tmp ;

  {
  {
#line 45
  f->req = *r;
#line 46
  r->nimages = 1;
#line 47
  r->flags &= -2;
#line 48
  r->supportedmask = 127;
#line 50
  tmp = (*(((f->next)->action)->requirement))(f->next, r);
  }
#line 50
  return (tmp);
}
}
#line 53 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/engine/palettef.c"
static int initialize(struct filter *f , struct initdata *i ) 
{ 
  struct palettedata *s ;
  struct palette *palette ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 55
  s = (struct palettedata *)f->data;
#line 56
  inhermisc(f, (struct initdata  const  *)i);
  }
#line 57
  if (((i->image)->palette)->type != 1) {
#line 57
    goto _L___1;
  } else
#line 57
  if ((unsigned long )((i->image)->palette)->setpalette == (unsigned long )((void *)0)) {
    _L___1: /* CIL Label */ 
#line 59
    if (i->flags & 1) {
#line 59
      goto _L;
    } else
#line 59
    if (f->imageversion) {
#line 59
      if (f->imageversion != (i->image)->version) {
#line 59
        goto _L;
      } else {
#line 59
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 59
    if ((i->image)->version != f->imageversion) {
#line 59
      goto _L;
    } else
#line 59
    if (! s->active) {
      _L: /* CIL Label */ 
#line 61
      if (! s->active) {
        {
#line 63
        palette = clonepalette((i->image)->palette);
#line 64
        restorepalette(s->palette, palette);
#line 65
        destroypalette(palette);
        }
      }
#line 67
      (s->palette)->data = (void *)s;
#line 68
      if (((i->image)->palette)->maxentries < 256) {
#line 69
        (s->palette)->maxentries = ((i->image)->palette)->maxentries;
      } else {
#line 71
        (s->palette)->maxentries = 256;
      }
#line 72
      s->active = 1;
    }
    {
#line 74
    tmp = inherimage(f, i, 3, 0, 0, s->palette, (float )0, (float )0);
    }
#line 74
    if (! tmp) {
#line 76
      return (0);
    }
#line 77
    if ((unsigned long )(f->fractalc)->palette == (unsigned long )(f->image)->palette) {
#line 77
      (f->fractalc)->palette = s->palette;
    }
#line 78
    (f->queue)->saveimage = f->childimage;
#line 79
    (f->queue)->palettechg = f;
  } else {
#line 81
    if (s->active) {
      {
#line 82
      f->image = i->image;
#line 83
      restorepalette((f->image)->palette, s->palette);
      }
    }
#line 85
    s->active = 0;
  }
  {
#line 87
  tmp___0 = (*(((f->previous)->action)->initialize))(f->previous, i);
  }
#line 87
  return (tmp___0);
}
}
#line 90 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/engine/palettef.c"
static struct filter *getinstance(struct filteraction  const  *a ) 
{ 
  struct filter *f ;
  struct filter *tmp ;
  struct palettedata *i ;
  void *tmp___0 ;

  {
  {
#line 92
  tmp = createfilter(a);
#line 92
  f = tmp;
#line 93
  tmp___0 = calloc((size_t )1, sizeof(*i));
#line 93
  i = (struct palettedata *)tmp___0;
#line 94
  i->active = 0;
#line 95
  i->palette = createpalette(0, 256, 1, 0, 256, (int (*)(struct palette *pal , int init ,
                                                         int r , int g , int b ))((void *)0),
                             & mysetcolor, (void (*)(struct palette *pal ))((void *)0),
                             (void (*)(struct palette *pal , int direction ))((void *)0),
                             (union paletteinfo *)((void *)0));
#line 98
  f->childimage = (struct image *)((void *)0);
#line 99
  f->data = (void *)i;
#line 100
  f->name = "Palette emulator";
  }
#line 101
  return (f);
}
}
#line 104 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/engine/palettef.c"
static void destroyinstance(struct filter *f ) 
{ 
  struct palettedata *i ;

  {
  {
#line 106
  i = (struct palettedata *)f->data;
#line 107
  destroypalette(i->palette);
#line 108
  destroyinheredimage(f);
#line 109
  free(f->data);
#line 110
  free((void *)f);
  }
#line 111
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/engine/palettef.c"
static int doit(struct filter *f , int flags , int time1 ) 
{ 
  int val ;
  int time___0 ;
  struct palettedata *s ;
  int i ;

  {
#line 116
  time___0 = time1;
#line 117
  s = (struct palettedata *)f->data;
#line 118
  if (s->active) {
    {
#line 119
    updateinheredimage(f);
    }
  }
#line 120
  if (flags & 2) {
#line 121
    val = 0;
  } else {
    {
#line 123
    val = (*(((f->previous)->action)->doit))(f->previous, flags, time___0);
    }
  }
#line 124
  if (s->active) {
#line 126
    if ((unsigned long )(s->palette)->data != (unsigned long )((void *)0)) {
      {
#line 127
      val |= 2;
#line 128
      restorepalette((f->image)->palette, (f->childimage)->palette);
#line 129
      i = 0;
      }
      {
#line 129
      while (1) {
        while_continue: /* CIL Label */ ;
#line 129
        if (! (i < 256)) {
#line 129
          goto while_break;
        }
#line 130
        s->table[i] = *(((f->image)->palette)->pixels + i % ((f->image)->palette)->size);
#line 129
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 133
      (s->palette)->data = (void *)0;
    }
    {
#line 135
    if ((f->image)->bytesperpixel == 3) {
#line 135
      goto case_3;
    }
#line 135
    if ((f->image)->bytesperpixel == 2) {
#line 135
      goto case_2;
    }
#line 135
    if ((f->image)->bytesperpixel == 1) {
#line 135
      goto case_1;
    }
#line 135
    if ((f->image)->bytesperpixel == 4) {
#line 135
      goto case_4;
    }
#line 135
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 135
    palette24((void *)f, & definfo, 0, (f->image)->height);
    }
#line 135
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 135
    palette16((void *)f, & definfo, 0, (f->image)->height);
    }
#line 135
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 135
    palette8((void *)f, & definfo, 0, (f->image)->height);
    }
#line 135
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 135
    palette32((void *)f, & definfo, 0, (f->image)->height);
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 142
  return (val);
}
}
#line 145 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/engine/palettef.c"
static void myremovefilter(struct filter *f ) 
{ 
  struct palettedata *s ;

  {
#line 147
  s = (struct palettedata *)f->data;
#line 148
  if (s->active) {
    {
#line 149
    restorepalette((f->image)->palette, s->palette);
    }
  }
#line 151
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/engine/palettef.c"
struct filteraction  const  palette_filter  = 
#line 153
     {"Palette emulator", "palette", 0, & getinstance, & destroyinstance, & doit, & requirement,
    & initialize, & convertupgeneric, & convertdowngeneric, & myremovefilter};
#line 40 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/include/xshl.h"
extern void xshl_free(struct xshl_line * ) ;
#line 43
extern struct xshl_line *help_make(char const   *command , int (*getwidth)(void * ,
                                                                           int flags ,
                                                                           char const   *text ) ,
                                   int width , int smallheight , int bigheight ) ;
#line 32 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uiint.h"
int helpvisible  ;
#line 23 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
static int historypos  ;
#line 24 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
static struct xshl_line *lines  ;
#line 25 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
static int helpwidth  ;
#line 25 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
static int helpheight  ;
#line 25 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
static int helpx  ;
#line 25 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
static int helpy  ;
#line 26 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
static struct uih_window *helpw  ;
#line 27 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
static int textheight  ;
#line 28 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
static char *ui_helppage[10]  ;
#line 29 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
static int ui_helppos[10]  ;
#line 32 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
static struct xshl_item *presseditem  ;
#line 33 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
static struct xshl_item *selecteditem  ;
#line 34 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
static int pressedline  ;
#line 35 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
static int selectedline  ;
#line 45 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
static int pressedbutton___0  =    -1;
#line 46 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
static int selectedbutton  =    -1;
#line 49 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
char const   * const  names[3]  = {      (char const   */* const  */)"OK",      (char const   */* const  */)"Back",      (char const   */* const  */)"Main"};
#line 52
static void ui_build_help(char *name___0 ) ;
#line 53 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
static void ui_backhelp(void) 
{ 


  {
#line 55
  historypos --;
#line 56
  if (historypos < 0) {
#line 57
    historypos = 9;
  }
  {
#line 58
  ui_build_help(ui_helppage[historypos]);
  }
#line 59
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
static void do_button(int i ) 
{ 


  {
  {
#line 64
  if (i == 0) {
#line 64
    goto case_0;
  }
#line 67
  if (i == 1) {
#line 67
    goto case_1;
  }
#line 70
  if (i == 2) {
#line 70
    goto case_2;
  }
#line 63
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 65
  ui_close_help();
  }
#line 66
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 68
  ui_backhelp();
  }
#line 69
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 71
  ui_help("main");
  }
#line 72
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
void ui_close_help(void) 
{ 


  {
#line 78
  if ((unsigned long )helpw != (unsigned long )((void *)0)) {
    {
#line 79
    xshl_free(lines);
#line 80
    helpvisible = 0;
#line 81
    uih_removew(uih, helpw);
#line 82
    uih->display = 1;
#line 83
    helpw = (struct uih_window *)((void *)0);
    }
  }
#line 85
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
static int getwidth(void *data , int flags , char const   *text ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 89
  if ((uih->image)->flags & 4) {
    {
#line 90
    tmp = xtextwidth(uih->font, text);
    }
#line 90
    return (tmp);
  }
  {
#line 91
  tmp___0 = xtextwidth(uih->font, text);
  }
#line 91
  return (tmp___0 - 1);
}
}
#line 94 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
static void helpsize(struct uih_context *c , int *x , int *y , int *width , int *height ,
                     void *data ) 
{ 


  {
#line 99
  *x = helpx;
#line 100
  *y = helpy;
#line 101
  *width = helpwidth;
#line 102
  *height = helpheight;
#line 103
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
static void drawhelp(struct uih_context *c , void *data ) 
{ 
  int i ;
  int y ;
  int percentx ;
  int percenty ;
  struct xshl_item *curritem___0 ;
  unsigned int bgcolor ;
  unsigned int fgcolor ;
  int flags ;
  int x ;
  int i___0 ;
  size_t tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 107
  i = 0;
#line 111
  uih_drawborder(uih, helpx + 2, helpy + 2, (helpwidth - 18) + 10, helpheight - (int )(((uih->font)->height + 1) + 16),
                 4);
  }
#line 115
  if (ui_helppos[historypos] > (textheight - helpheight / 2) + (int )(((uih->font)->height + 1) + 16)) {
#line 116
    ui_helppos[historypos] = (textheight - helpheight / 2) + (int )(((uih->font)->height + 1) + 16);
  }
#line 117
  if (ui_helppos[historypos] < 0) {
#line 118
    ui_helppos[historypos] = 0;
  }
#line 121
  percentx = ((helpheight - (int )(((uih->font)->height + 1) + 16)) * ui_helppos[historypos]) / textheight;
#line 123
  percenty = ((helpheight - (int )(((uih->font)->height + 1) + 16)) * ((ui_helppos[historypos] + helpheight) - (int )(((uih->font)->height + 1) + 16))) / textheight;
#line 126
  if (percentx < 2) {
#line 127
    percentx = 2;
  }
#line 128
  if (percenty < 2) {
#line 129
    percenty = 2;
  }
#line 130
  if (percentx > (helpheight - (int )(((uih->font)->height + 1) + 16)) - 2) {
#line 131
    percentx = (helpheight - (int )(((uih->font)->height + 1) + 16)) - 2;
  }
#line 132
  if (percenty > (helpheight - (int )(((uih->font)->height + 1) + 16)) - 2) {
#line 133
    percenty = (helpheight - (int )(((uih->font)->height + 1) + 16)) - 2;
  }
  {
#line 134
  uih_drawborder(uih, (helpx + helpwidth) - 18, (helpy + 2) + percentx, 9, percenty - percentx,
                 0);
#line 136
  i = 0;
  }
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! (i < 3)) {
#line 136
      goto while_break;
    }
    {
#line 137
    ui_drawbutton((char const   *)names[i], pressedbutton___0 == i, selectedbutton == i,
                  ((helpx + 2) + ((helpwidth - 4) / 3) * i) + 2, ((helpx + 2) + ((helpwidth - 4) / 3) * (i + 1)) - 2,
                  ((helpy + helpheight) - (int )(((uih->font)->height + 1) + 4)) - 2);
#line 136
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  i = 0;
  {
#line 145
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 145
    if (! (((4 + (lines + i)->y) - ui_helppos[historypos]) + 10 < 4)) {
#line 145
      goto while_break___0;
    }
#line 146
    i ++;
#line 147
    if ((lines + i)->y < 0) {
#line 148
      return;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 150
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 150
    y = ((4 + (lines + i)->y) - ui_helppos[historypos]) + 10;
#line 150
    if (y < (helpheight - (int )(((uih->font)->height + 1) + 16)) - (int )((uih->font)->height + 1)) {
#line 150
      if (! ((lines + i)->y >= 0)) {
#line 150
        goto while_break___1;
      }
    } else {
#line 150
      goto while_break___1;
    }
#line 154
    curritem___0 = (lines + i)->first;
    {
#line 155
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 155
      if (! ((unsigned long )curritem___0 != (unsigned long )((void *)0))) {
#line 155
        goto while_break___2;
      }
#line 156
      bgcolor = *((uih->palette)->index + 0);
#line 157
      fgcolor = *((uih->palette)->index + 5);
#line 158
      flags = 0;
#line 159
      x = 4 + curritem___0->x;
#line 161
      if (curritem___0->c.flags & 9) {
#line 162
        fgcolor = *((uih->palette)->index + 2);
      } else
#line 163
      if (curritem___0->c.flags & 130) {
#line 164
        if ((uih->image)->flags & 4) {
#line 164
          fgcolor = *((uih->palette)->index + 2);
        } else {
#line 164
          fgcolor = *((uih->palette)->index + 1);
        }
      } else
#line 167
      if (curritem___0->c.flags & 16) {
#line 168
        fgcolor = *((uih->palette)->index + 0);
#line 168
        bgcolor = fgcolor;
#line 168
        flags = 1;
      } else {
#line 170
        bgcolor = fgcolor;
#line 170
        flags |= 1;
      }
#line 171
      if ((uih->palette)->type & 3840) {
#line 172
        flags = 1;
#line 173
        fgcolor = *((uih->palette)->index + 0);
      }
#line 175
      if ((unsigned long )curritem___0->c.linktext != (unsigned long )((void *)0)) {
#line 176
        if ((uih->palette)->type & 3840) {
#line 177
          if ((unsigned long )curritem___0 == (unsigned long )presseditem) {
            {
#line 179
            fgcolor = *((uih->palette)->index + 1);
#line 179
            xrectangle(uih->image, x + helpx, y + helpy, curritem___0->width, (int )((uih->font)->height + 1),
                       (int )*((uih->palette)->index + 0));
            }
          } else
#line 177
          if ((unsigned long )curritem___0 == (unsigned long )selecteditem) {
            {
#line 179
            fgcolor = *((uih->palette)->index + 1);
#line 179
            xrectangle(uih->image, x + helpx, y + helpy, curritem___0->width, (int )((uih->font)->height + 1),
                       (int )*((uih->palette)->index + 0));
            }
          } else {
            {
#line 187
            xhline(uih->image, x + helpx, ((y + helpy) + (int )((uih->font)->height + 1)) - 1,
                   curritem___0->width, (int )*((uih->palette)->index + 0));
            }
          }
        } else {
#line 191
          if ((uih->image)->flags & 4) {
#line 192
            if ((unsigned long )curritem___0 == (unsigned long )presseditem) {
#line 192
              fgcolor = *((uih->palette)->index + 2);
            } else
#line 192
            if ((unsigned long )curritem___0 == (unsigned long )selecteditem) {
#line 192
              fgcolor = *((uih->palette)->index + 2);
            } else {
#line 192
              fgcolor = *((uih->palette)->index + 0);
            }
          } else {
            {
#line 197
            tmp = strlen((char const   *)curritem___0->c.linktext);
#line 197
            i___0 = (int )tmp;
            }
#line 198
            if (i___0 > 3) {
              {
#line 198
              tmp___2 = strcmp(".xaf", (char const   *)((curritem___0->c.linktext + i___0) - 4));
              }
#line 198
              if (tmp___2) {
#line 198
                goto _L;
              } else {
#line 201
                if ((unsigned long )curritem___0 == (unsigned long )presseditem) {
#line 201
                  tmp___0 = *((uih->palette)->index + 2);
                } else
#line 201
                if ((unsigned long )curritem___0 == (unsigned long )selecteditem) {
#line 201
                  tmp___0 = *((uih->palette)->index + 2);
                } else {
#line 201
                  tmp___0 = *((uih->palette)->index + 2);
                }
                {
#line 201
                xhline(uih->image, x + helpx, ((y + helpy) + (int )((uih->font)->height + 1)) - 1,
                       curritem___0->width, (int )tmp___0);
                }
              }
            } else {
              _L: /* CIL Label */ 
#line 208
              if ((unsigned long )curritem___0 == (unsigned long )presseditem) {
#line 208
                tmp___1 = *((uih->palette)->index + 2);
              } else
#line 208
              if ((unsigned long )curritem___0 == (unsigned long )selecteditem) {
#line 208
                tmp___1 = *((uih->palette)->index + 2);
              } else {
#line 208
                tmp___1 = *((uih->palette)->index + 5);
              }
              {
#line 208
              xhline(uih->image, x + helpx, ((y + helpy) + (int )((uih->font)->height + 1)) - 1,
                     curritem___0->width, (int )tmp___1);
              }
            }
            {
#line 214
            xhline(uih->image, (x + helpx) + 1, (y + helpy) + (int )((uih->font)->height + 1),
                   curritem___0->width, (int )*((uih->palette)->index + 0));
            }
          }
#line 218
          flags = 0;
#line 219
          bgcolor = *((uih->palette)->index + 0);
#line 220
          if (fgcolor == *((uih->palette)->index + 5)) {
#line 221
            fgcolor = *((uih->palette)->index + 1);
          }
#line 222
          if ((unsigned long )curritem___0 == (unsigned long )presseditem) {
#line 224
            fgcolor = *((uih->palette)->index + 2);
          } else
#line 222
          if ((unsigned long )curritem___0 == (unsigned long )selecteditem) {
#line 224
            fgcolor = *((uih->palette)->index + 2);
          }
        }
      }
      {
#line 227
      xprint(uih->image, uih->font, x + helpx, y + helpy, (char const   *)curritem___0->text,
             0, (int )fgcolor, (int )bgcolor, flags);
#line 229
      curritem___0 = curritem___0->next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 231
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 233
  return;
}
}
#line 235 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
int ui_helpkeys(int key ) 
{ 
  int i ;

  {
#line 238
  if ((unsigned long )helpw == (unsigned long )((void *)0)) {
#line 239
    return (0);
  }
  {
#line 241
  if (key == 104) {
#line 241
    goto case_104;
  }
#line 245
  if (key == 109) {
#line 245
    goto case_109;
  }
#line 249
  if (key == 106) {
#line 249
    goto case_106;
  }
#line 249
  if (key == 258) {
#line 249
    goto case_106;
  }
#line 255
  if (key == 107) {
#line 255
    goto case_107;
  }
#line 255
  if (key == 257) {
#line 255
    goto case_107;
  }
#line 263
  if (key == 32) {
#line 263
    goto case_32;
  }
#line 263
  if (key == 102) {
#line 263
    goto case_32;
  }
#line 263
  if (key == 43) {
#line 263
    goto case_32;
  }
#line 263
  if (key == 265) {
#line 263
    goto case_32;
  }
#line 270
  if (key == 45) {
#line 270
    goto case_45;
  }
#line 270
  if (key == 264) {
#line 270
    goto case_45;
  }
#line 277
  if (key == 1) {
#line 277
    goto case_1;
  }
#line 277
  if (key == 98) {
#line 277
    goto case_1;
  }
#line 283
  if (key == 111) {
#line 283
    goto case_111;
  }
#line 283
  if (key == 99) {
#line 283
    goto case_111;
  }
#line 283
  if (key == 113) {
#line 283
    goto case_111;
  }
#line 283
  if (key == 261) {
#line 283
    goto case_111;
  }
#line 287
  if (key == 260) {
#line 287
    goto case_260;
  }
#line 287
  if (key == 9) {
#line 287
    goto case_260;
  }
#line 319
  if (key == 10) {
#line 319
    goto case_10;
  }
#line 319
  if (key == 13) {
#line 319
    goto case_10;
  }
#line 240
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 242
  ui_close_help();
#line 243
  ui_menu("tutor");
  }
#line 244
  return (1);
  case_109: /* CIL Label */ 
  {
#line 246
  ui_help("main");
  }
#line 247
  return (1);
  case_106: /* CIL Label */ 
  case_258: /* CIL Label */ 
#line 250
  ui_helppos[historypos] += 8;
#line 250
  uih->display = 1;
#line 251
  presseditem = (struct xshl_item *)((void *)0);
#line 252
  selecteditem = (struct xshl_item *)((void *)0);
#line 253
  goto switch_break;
  case_107: /* CIL Label */ 
  case_257: /* CIL Label */ 
#line 256
  ui_helppos[historypos] -= 8;
#line 256
  uih->display = 1;
#line 257
  presseditem = (struct xshl_item *)((void *)0);
#line 258
  selecteditem = (struct xshl_item *)((void *)0);
#line 259
  goto switch_break;
  case_32: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_265: /* CIL Label */ 
#line 264
  ui_helppos[historypos] += (helpheight - (int )(((uih->font)->height + 1) + 16)) - 32;
#line 264
  uih->display = 1;
#line 266
  presseditem = (struct xshl_item *)((void *)0);
#line 267
  selecteditem = (struct xshl_item *)((void *)0);
#line 268
  goto switch_break;
  case_45: /* CIL Label */ 
  case_264: /* CIL Label */ 
#line 271
  ui_helppos[historypos] -= (helpheight - (int )(((uih->font)->height + 1) + 16)) - 32;
#line 271
  uih->display = 1;
#line 273
  presseditem = (struct xshl_item *)((void *)0);
#line 274
  selecteditem = (struct xshl_item *)((void *)0);
#line 275
  goto switch_break;
  case_1: /* CIL Label */ 
  case_98: /* CIL Label */ 
  {
#line 278
  ui_backhelp();
  }
#line 279
  goto switch_break;
  case_111: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_261: /* CIL Label */ 
  {
#line 284
  ui_close_help();
  }
#line 285
  goto switch_break;
  case_260: /* CIL Label */ 
  case_9: /* CIL Label */ 
#line 288
  uih->display = 1;
#line 289
  if (selectedbutton < 0) {
#line 289
    goto _L;
  } else
#line 289
  if (selectedbutton == 2) {
    _L: /* CIL Label */ 
#line 290
    if ((unsigned long )selecteditem == (unsigned long )((void *)0)) {
#line 291
      i = 0;
      {
#line 292
      while (1) {
        while_continue: /* CIL Label */ ;
#line 292
        if (! (((4 + (lines + i)->y) - ui_helppos[historypos]) + 10 < 4)) {
#line 292
          goto while_break;
        }
#line 293
        i ++;
#line 294
        if ((lines + i)->y < 0) {
#line 295
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 297
      selecteditem = (lines + i)->first;
    } else {
#line 299
      i = selectedline;
#line 299
      selecteditem = selecteditem->next;
    }
    {
#line 300
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 300
      if ((lines + i)->y >= 0) {
#line 300
        if (! (((4 + (lines + i)->y) - ui_helppos[historypos]) + 10 < helpheight - (int )(((uih->font)->height + 1) + 16))) {
#line 300
          goto while_break___0;
        }
      } else {
#line 300
        goto while_break___0;
      }
#line 303
      selectedline = i;
      {
#line 304
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 304
        if (! ((unsigned long )selecteditem != (unsigned long )((void *)0))) {
#line 304
          goto while_break___1;
        }
#line 305
        if ((unsigned long )selecteditem->c.linktext != (unsigned long )((void *)0)) {
#line 306
          selectedbutton = -1;
#line 307
          return (0);
        }
#line 309
        selecteditem = selecteditem->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 311
      selecteditem = (lines + (i + 1))->first;
#line 300
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 313
    selecteditem = (struct xshl_item *)((void *)0);
#line 314
    selectedbutton = 0;
  } else {
#line 316
    selectedbutton ++;
  }
#line 317
  goto switch_break;
  case_10: /* CIL Label */ 
  case_13: /* CIL Label */ 
#line 320
  if ((unsigned long )selecteditem != (unsigned long )((void *)0)) {
    {
#line 321
    ui_help((char const   *)selecteditem->c.linktext);
    }
#line 322
    return (1);
  }
#line 324
  if (selectedbutton >= 0) {
    {
#line 325
    do_button(selectedbutton);
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 327
  return (1);
}
}
#line 332 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
static int grabbed___0  =    0;
#line 330 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
int ui_helpmouse(int x , int y , int buttons , int flags ) 
{ 
  int atpressed ;
  int button ;
  int i ;
  int pos ;
  int i___0 ;
  struct xshl_item *item ;

  {
#line 333
  atpressed = 0;
#line 334
  if ((unsigned long )helpw == (unsigned long )((void *)0)) {
#line 335
    return (0);
  }
#line 336
  if (x < helpx) {
#line 336
    goto _L___3;
  } else
#line 336
  if (y < helpy) {
#line 336
    goto _L___3;
  } else
#line 336
  if (x > helpx + helpwidth) {
#line 336
    goto _L___3;
  } else
#line 336
  if (y > helpy + helpheight) {
    _L___3: /* CIL Label */ 
#line 338
    if (flags & 1) {
      {
#line 339
      ui_close_help();
      }
    }
#line 340
    pressedbutton___0 = -1;
#line 341
    if (pressedbutton___0 != -1) {
#line 342
      pressedbutton___0 = -1;
#line 342
      uih->display = 1;
    }
#line 343
    return (1);
  } else {
#line 345
    if (y > ((helpy + helpheight) - (int )(((uih->font)->height + 1) + 4)) - 4) {
#line 348
      i = 0;
      {
#line 348
      while (1) {
        while_continue: /* CIL Label */ ;
#line 348
        if (! (i <= 3)) {
#line 348
          goto while_break;
        }
#line 349
        if (x < (helpx + 2) + ((helpwidth - 4) / 3) * i) {
#line 350
          goto while_break;
        }
#line 348
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 351
      button = i - 1;
#line 352
      if (flags & 4) {
#line 353
        if (pressedbutton___0 != selectedbutton) {
#line 355
          selectedbutton = button;
#line 355
          pressedbutton___0 = selectedbutton;
#line 355
          uih->display = 1;
        } else
#line 353
        if (pressedbutton___0 != button) {
#line 355
          selectedbutton = button;
#line 355
          pressedbutton___0 = selectedbutton;
#line 355
          uih->display = 1;
        }
      } else {
#line 358
        if (pressedbutton___0 != -1) {
#line 359
          pressedbutton___0 = -1;
#line 359
          uih->display = 1;
        }
#line 360
        if (flags & 2) {
          {
#line 361
          do_button(button);
          }
        }
      }
#line 363
      return (1);
    }
#line 365
    if (pressedbutton___0 != -1) {
#line 366
      pressedbutton___0 = -1;
#line 366
      uih->display = 1;
    }
#line 367
    if (buttons) {
#line 367
      if (x > (helpx + helpwidth) - 18) {
#line 367
        if (y < (helpy + helpheight) - (int )(((uih->font)->height + 1) + 16)) {
#line 367
          goto _L;
        } else {
#line 367
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 367
      if (grabbed___0) {
        _L: /* CIL Label */ 
#line 371
        pos = ((y - helpy) * textheight) / (helpheight - (int )(((uih->font)->height + 1) + 16));
#line 372
        if (pos != ui_helppos[historypos]) {
#line 373
          ui_helppos[historypos] = pos;
#line 373
          uih->display = 1;
        }
#line 374
        grabbed___0 = 1;
#line 375
        return (1);
      } else {
#line 377
        grabbed___0 = 0;
      }
    } else {
#line 377
      grabbed___0 = 0;
    }
#line 378
    y -= helpy + (int )((uih->font)->height + 1);
#line 379
    x -= 4 + helpx;
#line 380
    pressedbutton___0 = -1;
#line 381
    if ((unsigned long )presseditem != (unsigned long )((void *)0)) {
#line 382
      if ((((4 + (lines + pressedline)->y) - ui_helppos[historypos]) + 10) + 1 >= y) {
#line 382
        if (((4 + (lines + pressedline)->y) - ui_helppos[historypos]) + 10 <= y + (int )((uih->font)->height + 1)) {
#line 382
          if (presseditem->x <= x) {
#line 382
            if (presseditem->x + presseditem->width >= x) {
#line 386
              atpressed = 1;
            }
          }
        }
      }
    }
#line 388
    if (flags & 1) {
#line 388
      goto _L___1;
    } else
#line 388
    if (flags & 4) {
#line 388
      if (! atpressed) {
        _L___1: /* CIL Label */ 
#line 389
        i___0 = 0;
#line 390
        i___0 = 0;
        {
#line 390
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 390
          if ((lines + i___0)->y >= 0) {
#line 390
            if (! ((((4 + (lines + i___0)->y) - ui_helppos[historypos]) + 10) + 1 <= y)) {
#line 390
              if (! (((4 + (lines + i___0)->y) - ui_helppos[historypos]) + 10 >= y + (int )((uih->font)->height + 1))) {
#line 390
                goto while_break___0;
              }
            }
          } else {
#line 390
            goto while_break___0;
          }
#line 390
          i___0 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 394
        if ((lines + i___0)->y >= 0) {
#line 395
          item = (lines + i___0)->first;
          {
#line 396
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 396
            if (! ((unsigned long )item != (unsigned long )((void *)0))) {
#line 396
              goto while_break___1;
            }
#line 397
            if ((unsigned long )item->c.linktext != (unsigned long )((void *)0)) {
#line 397
              if (item->x <= x) {
#line 397
                if (item->x + item->width >= x) {
#line 399
                  goto while_break___1;
                }
              }
            }
#line 400
            item = item->next;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 402
          if ((unsigned long )item != (unsigned long )((void *)0)) {
#line 403
            uih->display = 1;
#line 404
            presseditem = item;
#line 405
            pressedline = i___0;
          }
        }
      } else {
#line 388
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 408
    if (flags & 8) {
#line 409
      if (! atpressed) {
#line 409
        if ((unsigned long )presseditem != (unsigned long )((void *)0)) {
#line 410
          uih->display = 1;
#line 410
          presseditem = (struct xshl_item *)0;
        }
      }
    } else
#line 411
    if (flags & 2) {
#line 412
      if (atpressed) {
        {
#line 413
        ui_help((char const   *)presseditem->c.linktext);
        }
#line 414
        return (1);
      }
#line 416
      if ((unsigned long )presseditem != (unsigned long )((void *)0)) {
#line 417
        presseditem = (struct xshl_item *)((void *)0);
#line 417
        uih->display = 1;
      }
    }
  }
#line 421
  return (1);
}
}
#line 424 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
static void ui_build_help(char *name___0 ) 
{ 
  int i ;
  int width ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 428
  if (ui_nogui) {
    {
#line 429
    printf((char const   */* __restrict  */)"help \"%s\"\n", name___0);
    }
#line 430
    return;
  }
#line 432
  if (driver->gui_driver) {
#line 432
    if ((driver->gui_driver)->help) {
      {
#line 433
      (*((driver->gui_driver)->help))(uih, (char const   *)name___0);
      }
#line 434
      return;
    }
  }
#line 436
  if ((unsigned long )helpw != (unsigned long )((void *)0)) {
    {
#line 437
    ui_close_help();
    }
  }
  {
#line 438
  pressedbutton___0 = -1;
#line 439
  helpvisible = 1;
#line 440
  tmp = xtextwidth(uih->font, "w");
#line 440
  width = 80 * tmp;
  }
#line 441
  if (width > (uih->image)->width - 18) {
#line 442
    width = (uih->image)->width - 18;
  }
#line 443
  if (name___0) {
#line 443
    tmp___0 = (char const   *)name___0;
  } else {
#line 443
    tmp___0 = "main";
  }
  {
#line 443
  lines = help_make(tmp___0, & getwidth, width - 2, (int )((uih->font)->height + 1),
                    (int )((uih->font)->height + 1));
  }
#line 446
  if ((unsigned long )lines == (unsigned long )((void *)0)) {
    {
#line 447
    lines = help_make("main", & getwidth, width - 2, (int )((uih->font)->height + 1),
                      (int )((uih->font)->height + 1));
    }
#line 450
    if ((unsigned long )lines == (unsigned long )((void *)0)) {
      {
#line 451
      helpvisible = 0;
#line 452
      uih_message(uih, "Help file not found");
      }
#line 453
      return;
    }
  }
#line 456
  width += 18;
#line 457
  uih->display = 1;
#line 458
  selecteditem = (struct xshl_item *)((void *)0);
#line 458
  presseditem = selecteditem;
#line 459
  helpwidth = width;
#line 460
  helpx = ((uih->image)->width - width) / 2;
#line 461
  i = 0;
  {
#line 461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 461
    if (! ((lines + i)->y >= 0)) {
#line 461
      goto while_break;
    }
#line 461
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 462
  textheight = (lines + (i - 1))->y + 4 * (int )((uih->font)->height + 1);
#line 463
  if (textheight < (uih->image)->height - (int )(((uih->font)->height + 1) + 16)) {
#line 464
    helpheight = textheight;
  } else {
#line 466
    helpheight = (uih->image)->height - (int )(((uih->font)->height + 1) + 16);
  }
  {
#line 467
  helpheight += (int )(((uih->font)->height + 1) + 16);
#line 468
  helpy = ((uih->image)->height - helpheight) / 2;
#line 469
  helpw = uih_registerw(uih, & helpsize, & drawhelp, (void *)0, 2);
  }
#line 470
  return;
}
}
#line 472 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/uihelp.c"
void ui_help(char const   *name___0 ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 474
  tmp = strlen(name___0);
  }
#line 474
  if (tmp > 4UL) {
    {
#line 474
    tmp___0 = strlen(name___0);
#line 474
    tmp___1 = strcmp((name___0 + tmp___0) - 4, ".xaf");
    }
#line 474
    if (! tmp___1) {
      {
#line 475
      uih_playtutorial(uih, name___0);
      }
#line 476
      if ((unsigned long )helpw != (unsigned long )((void *)0)) {
        {
#line 477
        ui_close_help();
        }
      }
#line 479
      return;
    }
  }
  {
#line 481
  historypos ++;
#line 482
  historypos %= 10;
#line 483
  ui_helppage[historypos] = mystrdup(name___0);
#line 484
  ui_helppos[historypos] = 0;
#line 485
  ui_build_help(ui_helppage[historypos]);
  }
#line 486
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/fparams.c"
static char *defrender  =    (char *)((void *)0);
#line 46 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/fparams.c"
static char const   *rbasename  =    "anim";
#line 47 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/fparams.c"
static int alias  =    0;
#line 48 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/fparams.c"
static int slowmode  =    0;
#line 49 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/fparams.c"
static char *imgtype  ;
#line 50 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/fparams.c"
static char *defsize  ;
#line 51 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/fparams.c"
static float framerate  ;
#line 52 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/fparams.c"
static int letterspersec  =    20;
#line 53 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/fparams.c"
static int defvectors  ;
#line 54 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/fparams.c"
static int iframedist___0  ;
#line 55 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/fparams.c"
struct params  const  ui_fractal_params[11]  = 
#line 55
  {      {"", 4, (void *)0, "Animation rendering:"}, 
        {"-render", 2, (void *)(& defrender), "Render animation into seqence of .png files"}, 
        {"-basename",
      2, (void *)(& rbasename), "Name for .png files (XaoS will add 4 digit number and extension"}, 
        {"-size",
      2, (void *)(& defsize), "widthxheight"}, 
        {"-renderimage", 2, (void *)(& imgtype), "256 or truecolor"}, 
        {"-renderframerate", 3, (void *)(& framerate), "framerate"}, 
        {"-antialiasing", 0, (void *)(& alias), "Perform antialiasing (slow, requires quite lot of memory)"}, 
        {"-alwaysrecalc",
      0, (void *)(& slowmode), "Always recalculate whole image (slowes down rendering, increases quality)"}, 
        {"-rendervectors",
      0, (void *)(& defvectors), "Render motion vectors (should be used for MPEG encoding)"}, 
        {"-iframedist",
      1, (void *)(& iframedist___0), "Recommended distance between I frames in pat file (should be used for MPEG encoding)"}, 
        {(char const   *)((void *)0),
      0, (void *)0, (char const   *)((void *)0)}};
#line 76 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/fparams.c"
int ui_dorender_params(void) 
{ 
  int imagetype ;
  int width ;
  int height ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;

  {
#line 78
  if ((unsigned long )defrender != (unsigned long )((void *)0)) {
#line 79
    imagetype = 8;
#line 80
    width = 640;
#line 80
    height = 480;
#line 89
    if ((unsigned long )imgtype != (unsigned long )((void *)0)) {
      {
#line 90
      tmp___0 = strcmp("256", (char const   *)imgtype);
      }
#line 90
      if (tmp___0) {
        {
#line 92
        tmp = strcmp("truecolor", (char const   *)imgtype);
        }
#line 92
        if (! tmp) {
          {
#line 93
          x_fatalerror((char *)"Unknown image type:%s", imgtype);
          }
        }
      } else {
#line 91
        imagetype = 1;
      }
    }
#line 96
    if ((unsigned long )defsize != (unsigned long )((void *)0)) {
      {
#line 96
      tmp___1 = sscanf((char const   */* __restrict  */)defsize, (char const   */* __restrict  */)"%ix%i",
                       & width, & height);
      }
#line 96
      if (! tmp___1) {
#line 96
        if (width <= 0) {
          {
#line 99
          x_fatalerror((char *)"Invalid size (use for example 320x200");
          }
        } else
#line 96
        if (height <= 0) {
          {
#line 99
          x_fatalerror((char *)"Invalid size (use for example 320x200");
          }
        }
      }
    }
#line 101
    if (framerate <= (float )0) {
#line 102
      framerate = (float )30;
    }
    {
#line 103
    tmp___2 = ui_get_windowheight(height);
#line 103
    tmp___3 = ui_get_windowwidth(width);
#line 103
    uih_renderanimation((struct uih_context *)((void *)0), rbasename, (xio_constpath const   )defrender,
                        width, height, tmp___3 / (float )width, tmp___2 / (float )height,
                        (int )((float )1000000 / framerate), imagetype, alias, slowmode,
                        letterspersec, (char const   *)((void *)0), defvectors, iframedist___0);
    }
#line 109
    return (1);
  }
#line 111
  return (0);
}
}
#line 25 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/drivers.c"
extern struct ui_driver  const  x11_driver ;
#line 31 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/drivers.c"
struct ui_driver  const  * const  drivers[2]  = {      (struct ui_driver  const  */* const  */)(& x11_driver),      (struct ui_driver  const  */* const  */)((void *)0)};
#line 86 "/home/june/repo/benchmarks/collector2/temp/xaos-3.5+ds1/src/ui/drivers.c"
int const   ndrivers  =    (int const   )(sizeof(drivers) / sizeof(drivers[0]) - 1UL);
