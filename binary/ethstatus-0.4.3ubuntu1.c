/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 358
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 39 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_63 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 39 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_63 sync_serial_settings;
#line 45 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_64 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 45 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_64 te1_settings;
#line 52 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_65 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 52 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_65 raw_hdlc_proto;
#line 57 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_66 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 57 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_66 fr_proto;
#line 67 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_67 {
   unsigned int dlci ;
};
#line 67 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_67 fr_proto_pvc;
#line 71 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_68 {
   unsigned int dlci ;
   char master[16] ;
};
#line 71 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_68 fr_proto_pvc_info;
#line 76 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_69 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 76 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_69 cisco_proto;
#line 143 "/usr/include/linux/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 153 "/usr/include/linux/if.h"
union __anonunion_ifs_ifsu_72 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 153 "/usr/include/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_72 ifs_ifsu ;
};
#line 177 "/usr/include/linux/if.h"
union __anonunion_ifr_ifrn_73 {
   char ifrn_name[16] ;
};
#line 177 "/usr/include/linux/if.h"
union __anonunion_ifr_ifru_74 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 177 "/usr/include/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_73 ifr_ifrn ;
   union __anonunion_ifr_ifru_74 ifr_ifru ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
struct statvline {
   int hline[76] ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
typedef struct statvline statvline[10];
#line 40 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
struct theme {
   int background ;
   int border[2] ;
   int labels[2] ;
   int data[2] ;
   int version[2] ;
   int outgoing[2] ;
   int ingoing[2] ;
   int intersection[2] ;
   int power_led[4] ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
typedef struct theme theme;
#line 54 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
struct DataStats {
   double rx_packets[2] ;
   unsigned long rx_errors[2] ;
   double rx_bytes[2] ;
   double tx_packets[2] ;
   unsigned long tx_errors[2] ;
   double tx_bytes[2] ;
   double rx_packets_comp[2] ;
   double tx_packets_comp[2] ;
   double rx_bytes_comp ;
   double tx_bytes_comp ;
   unsigned long connect_time ;
   unsigned long current_time ;
   float top_speed ;
   int top_packet ;
   unsigned long log_time ;
   unsigned long log_value ;
   char *ip_addr_rtrn ;
   char user_box[32] ;
   int email ;
   char *start_time ;
};
#line 54 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
typedef struct DataStats DataStats;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 717
extern int system(char const   *__command ) ;
#line 460 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 459
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 587 "/usr/include/curses.h"
extern int cbreak(void) ;
#line 597
extern int curs_set(int  ) ;
#line 611
extern int endwin(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 633
extern int init_color(short  , short  , short  , short  ) ;
#line 634
extern int init_pair(short  , short  , short  ) ;
#line 642
extern int intrflush(WINDOW * , _Bool  ) ;
#line 674
extern int mvprintw(int  , int  , char const   *  , ...) ;
#line 710
extern int nodelay(WINDOW * , _Bool  ) ;
#line 711
extern int noecho(void) ;
#line 712
extern int nonl(void) ;
#line 764
extern int start_color(void) ;
#line 788
extern int waddnstr(WINDOW * , char const   * , int  ) ;
#line 799
extern int wborder(WINDOW * , chtype  , chtype  , chtype  , chtype  , chtype  , chtype  ,
                   chtype  , chtype  ) ;
#line 810
extern int wgetch(WINDOW * ) ;
#line 813
extern int whline(WINDOW * , chtype  , int  ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 1386
extern WINDOW *stdscr ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
statvline graph  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
struct tm localt  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
theme colors  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
DataStats stats  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
struct stat st  ;
#line 83
void close_eths(char *errmsg  , ...) ;
#line 84
void chcolor(int x , int y ) ;
#line 86
void update_stat(int reload ) ;
#line 87
void update_info(void) ;
#line 88
void led_on(unsigned int who ) ;
#line 89
void led_off(unsigned int who ) ;
#line 90
int is_online(short force , short only_check ) ;
#line 91
void clear_info(void) ;
#line 92
void show_usage(char *name ) ;
#line 94
void ip_address(int display ) ;
#line 96
void check_email(void) ;
#line 97
void autoscale(char *str , double bytes ) ;
#line 101 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
char home[128]  ;
#line 102 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
char *interface  =    (char *)"eth0";
#line 103 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
char data_type[6]  = {      (char )'b',      (char )'y',      (char )'t',      (char )'e', 
        (char )'s',      (char )'\000'};
#line 104 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
char mth[12][4]  = 
#line 104
  { {        (char )'J',        (char )'a',        (char )'n',        (char )'\000'}, 
   {        (char )'F',        (char )'e',        (char )'b',        (char )'\000'}, 
   {        (char )'M',        (char )'a',        (char )'r',        (char )'\000'}, 
   {        (char )'A',        (char )'p',        (char )'r',        (char )'\000'}, 
   {        (char )'M',        (char )'a',        (char )'y',        (char )'\000'}, 
   {        (char )'J',        (char )'u',        (char )'n',        (char )'\000'}, 
   {        (char )'J',        (char )'u',        (char )'l',        (char )'\000'}, 
   {        (char )'A',        (char )'u',        (char )'g',        (char )'\000'}, 
   {        (char )'S',        (char )'e',        (char )'p',        (char )'\000'}, 
   {        (char )'O',        (char )'c',        (char )'t',        (char )'\000'}, 
   {        (char )'N',        (char )'o',        (char )'v',        (char )'\000'}, 
   {        (char )'D',        (char )'e',        (char )'c',        (char )'\000'}};
#line 107 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
int eth_s  =    -1;
#line 108 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
int CHAR  =    '#';
#line 109 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
int sec_value  =    0;
#line 112 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
char autoscalebytes[15]  ;
#line 114 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
float SPEED[2]  = {      (float )10240,      (float )10240};
#line 116 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
unsigned short VGA  =    (unsigned short)1;
#line 117 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
unsigned short con  =    (unsigned short)0;
#line 118 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
unsigned short discon  =    (unsigned short)0;
#line 119 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
unsigned short disconnected  =    (unsigned short)0;
#line 120 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
unsigned short check  =    (unsigned short)0;
#line 121 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
unsigned short online  =    (unsigned short)0;
#line 122 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
unsigned short first_log  =    (unsigned short)1;
#line 122 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.h"
unsigned short lsnumber  =    (unsigned short)1;
#line 54 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.c"
void ip_address(int display ) 
{ 
  struct ifreq ifr ;
  struct sockaddr_in *skt ;
  int tmp ;

  {
  {
#line 59
  eth_s = socket(2, 2, 0);
  }
#line 59
  if (eth_s < 0) {
    {
#line 61
    perror("socket");
#line 62
    exit(0);
    }
  }
  {
#line 65
  strcpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)interface);
#line 67
  tmp = ioctl(eth_s, 35093UL, & ifr);
#line 69
  skt = (struct sockaddr_in *)(& ifr.ifr_ifru.ifru_addr);
  }
#line 71
  if (skt->sin_addr.s_addr) {
    {
#line 72
    stats.ip_addr_rtrn = inet_ntoa(skt->sin_addr);
    }
  } else {
#line 74
    stats.ip_addr_rtrn = (char *)"Unknown";
  }
#line 76
  if (display) {
    {
#line 78
    chcolor(colors.data[0], colors.data[1]);
#line 79
    mvprintw(17, 27, "%s", stats.ip_addr_rtrn);
#line 80
    wrefresh(stdscr);
    }
  }
#line 82
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.c"
void check_email(void) 
{ 
  FILE *email_box ;
  int rtrn ;
  char location[128] ;
  char buf[128] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 91
  rtrn = 0;
#line 94
  sprintf((char */* __restrict  */)(location), (char const   */* __restrict  */)"/var/mail/%s",
          stats.user_box);
#line 96
  tmp = stat((char const   */* __restrict  */)(location), (struct stat */* __restrict  */)(& st));
  }
#line 96
  if (! tmp) {
#line 97
    rtrn = (int )st.st_size;
  }
  {
#line 98
  stats.email = 0;
#line 99
  chcolor(colors.data[0], colors.data[1]);
  }
#line 100
  if (rtrn) {
    {
#line 101
    email_box = fopen((char const   */* __restrict  */)(location), (char const   */* __restrict  */)"r");
    }
#line 101
    if (email_box) {
      {
#line 103
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 103
        tmp___1 = feof(email_box);
        }
#line 103
        if (tmp___1) {
#line 103
          goto while_break;
        }
        {
#line 105
        fgets((char */* __restrict  */)(buf), 128, (FILE */* __restrict  */)email_box);
#line 106
        tmp___0 = strncmp((char const   *)(buf), "From ", (size_t )5);
        }
#line 106
        if (! tmp___0) {
#line 107
          (stats.email) ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 109
      if (stats.email < 10) {
        {
#line 110
        mvprintw(17, 65, "0%d         ", stats.email);
        }
      } else {
        {
#line 112
        mvprintw(17, 65, "%d           ", stats.email);
        }
      }
      {
#line 113
      fclose(email_box);
      }
    } else {
      {
#line 116
      mvprintw(17, 65, "Can\'t check");
      }
    }
  } else {
    {
#line 119
    mvprintw(17, 65, "00         ");
    }
  }
  {
#line 120
  wrefresh(stdscr);
  }
#line 121
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.c"
void center(short line , char *strg  , ...) 
{ 
  short where ;
  char *final ;
  va_list trans ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 133
  tmp = malloc((size_t )80);
#line 133
  final = (char *)tmp;
#line 134
  __builtin_va_start(trans, strg);
#line 135
  vsnprintf((char */* __restrict  */)final, (size_t )80, (char const   */* __restrict  */)strg,
            trans);
#line 136
  __builtin_va_end(trans);
#line 137
  tmp___0 = strlen((char const   *)final);
#line 137
  where = (short )((int )(40UL - tmp___0 / 2UL));
  }
#line 138
  if ((int )line != 0) {
#line 138
    if ((int )line != 24) {
      {
#line 139
      wmove(stdscr, (int )line, 20);
#line 140
      whline(stdscr, (chtype )32, 50);
      }
    }
  }
  {
#line 142
  mvprintw((int )line, (int )where, "%s", final);
#line 143
  free((void *)final);
  }
#line 144
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.c"
int is_online(short force , short only_check ) 
{ 
  int rtrn ;
  char check___0[256] ;
  char red_tmp[256] ;
  char *tmp ;
  FILE *routefile ;
  char b_rx[32] ;
  char b_tx[32] ;
  char e_rx[32] ;
  char e_tx[32] ;
  char p_rx[32] ;
  char p_tx[32] ;
  double tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 152
  rtrn = 0;
#line 157
  routefile = fopen((char const   */* __restrict  */)"/proc/net/dev", (char const   */* __restrict  */)"r");
  }
#line 157
  if ((unsigned long )routefile == (unsigned long )((void *)0)) {
    {
#line 159
    sprintf((char */* __restrict  */)(red_tmp), (char const   */* __restrict  */)"Error! Unable to open %s\nCheck in your Kernel Configuration if /proc filesystem is supported\n\n",
            "/proc/net/dev");
#line 162
    close_eths(red_tmp);
    }
  }
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 164
    tmp___7 = feof(routefile);
    }
#line 164
    if (tmp___7) {
#line 164
      goto while_break;
    }
    {
#line 166
    fgets((char */* __restrict  */)(check___0), 256, (FILE */* __restrict  */)routefile);
#line 167
    tmp___6 = strstr((char const   *)(check___0), (char const   *)interface);
    }
#line 167
    if (tmp___6) {
#line 168
      tmp = check___0;
      {
#line 169
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 169
        if (! ((int )*tmp != 58)) {
#line 169
          goto while_break___0;
        }
#line 170
        tmp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 171
      tmp ++;
#line 172
      sscanf((char const   */* __restrict  */)tmp, (char const   */* __restrict  */)"%s %s %s %s %s %s %s %s %s %s %s",
             b_rx, p_rx, e_rx, red_tmp, red_tmp, red_tmp, red_tmp, red_tmp, b_tx,
             p_tx, e_tx);
#line 177
      tmp___0 = atof((char const   *)(p_tx));
#line 177
      stats.tx_packets[0] = tmp___0;
#line 178
      tmp___1 = atof((char const   *)(b_tx));
#line 178
      stats.tx_bytes[0] = tmp___1;
#line 179
      tmp___2 = atoi((char const   *)(e_tx));
#line 179
      stats.tx_errors[0] = (unsigned long )((double )tmp___2);
#line 180
      tmp___3 = atof((char const   *)(p_rx));
#line 180
      stats.rx_packets[0] = tmp___3;
#line 181
      tmp___4 = atof((char const   *)(b_rx));
#line 181
      stats.rx_bytes[0] = tmp___4;
#line 182
      tmp___5 = atoi((char const   *)(e_rx));
#line 182
      stats.rx_errors[0] = (unsigned long )((double )tmp___5);
#line 184
      rtrn = 1;
#line 184
      online = (unsigned short )rtrn;
      }
#line 185
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  fclose(routefile);
  }
#line 191
  if (! only_check) {
#line 192
    if (rtrn) {
#line 193
      if (! con) {
#line 193
        goto _L;
      } else
#line 193
      if (force) {
#line 193
        if (con) {
          _L: /* CIL Label */ 
          {
#line 194
          chcolor(colors.power_led[0], colors.power_led[1]);
#line 194
          wmove(stdscr, 12, 10);
#line 195
          whline(stdscr, (chtype )CHAR, 3);
#line 196
          con = (unsigned short)1;
#line 196
          discon = (unsigned short)0;
#line 197
          wrefresh(stdscr);
          }
        }
      }
    } else
#line 201
    if (! discon) {
#line 201
      goto _L___0;
    } else
#line 201
    if (force) {
#line 201
      if (discon) {
        _L___0: /* CIL Label */ 
        {
#line 202
        chcolor(colors.power_led[2], colors.power_led[3]);
#line 202
        wmove(stdscr, 12, 10);
#line 203
        whline(stdscr, (chtype )CHAR, 3);
#line 204
        online = (unsigned short)0;
#line 204
        con = online;
#line 204
        discon = (unsigned short)1;
#line 205
        wrefresh(stdscr);
        }
      }
    }
  }
#line 209
  return (rtrn);
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.c"
void update_info(void) 
{ 


  {
  {
#line 218
  chcolor(colors.data[0], colors.data[1]);
#line 219
  mvprintw(20, 27, "%.0f", stats.rx_packets[0]);
#line 220
  mvprintw(20, 65, "%.0f", stats.tx_packets[0]);
#line 221
  mvprintw(22, 27, "%ld", stats.rx_errors[0]);
#line 222
  mvprintw(22, 65, "%ld", stats.tx_errors[0]);
#line 225
  chcolor(colors.labels[0], colors.labels[1]);
#line 226
  autoscale(autoscalebytes, stats.rx_bytes[0]);
#line 227
  mvprintw(21, 6, "Received:                        ");
#line 228
  chcolor(colors.data[0], colors.data[1]);
#line 229
  mvprintw(21, 27, "%sB", autoscalebytes);
#line 231
  chcolor(colors.labels[0], colors.labels[1]);
#line 232
  autoscale(autoscalebytes, stats.tx_bytes[0]);
#line 233
  mvprintw(21, 41, "Transmitted:                        ");
#line 234
  chcolor(colors.data[0], colors.data[1]);
#line 235
  mvprintw(21, 65, "%sB", autoscalebytes);
  }
#line 236
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.c"
void clear_info(void) 
{ 


  {
  {
#line 243
  chcolor(colors.background, 0);
#line 244
  mvprintw(19, 65, "   ");
#line 245
  mvprintw(19, 27, "            ");
#line 246
  mvprintw(20, 27, "            ");
#line 247
  mvprintw(20, 65, "              ");
#line 248
  mvprintw(22, 27, "            ");
#line 249
  mvprintw(22, 65, "              ");
#line 250
  mvprintw(21, 27, "            ");
#line 251
  mvprintw(21, 65, "              ");
#line 252
  mvprintw(16, 22, "               ");
#line 253
  mvprintw(17, 27, "            ");
  }
#line 254
  return;
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.c"
void do_exit(int x , short line ) 
{ 


  {
  {
#line 263
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\nEthStatus-v%s - %s",
          "0.4a", "Gabriel Montenegro / Christoph Haas");
#line 270
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Exiting...\n\n");
#line 271
  exit(0);
  }
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.c"
char *opt_analiser(char *in ) 
{ 
  char real[256] ;
  char temp[256] ;
  char *rt ;
  short a ;
  short value ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 280
  value = (short)0;
#line 281
  tmp = strlen((char const   *)in);
#line 281
  bzero((void *)(temp), tmp);
#line 282
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%s",
          in);
#line 284
  tmp___0 = strlen((char const   *)(real));
#line 284
  bzero((void *)(real), tmp___0);
#line 285
  a = (short)0;
  }
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 285
    tmp___1 = strlen((char const   *)(temp));
    }
#line 285
    if (! ((size_t )a < tmp___1 - 1UL)) {
#line 285
      goto while_break;
    }
    {
#line 288
    if ((int )temp[a] == 9) {
#line 288
      goto case_9;
    }
#line 291
    if ((int )temp[a] == 35) {
#line 291
      goto case_35;
    }
#line 295
    goto switch_default;
    case_9: /* CIL Label */ 
#line 289
    real[a] = (char )'\000';
#line 290
    goto switch_break;
    case_35: /* CIL Label */ 
#line 292
    value = (short )((int )value + 1);
#line 293
    real[a] = (char )'\000';
#line 294
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 296
    if (! value) {
#line 297
      real[a] = temp[a];
    }
    switch_break: /* CIL Label */ ;
    }
#line 285
    a = (short )((int )a + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 300
  real[a] = (char )'\000';
#line 301
  tmp___2 = strlen((char const   *)(real));
#line 301
  tmp___3 = malloc(tmp___2);
#line 301
  rt = (char *)tmp___3;
#line 302
  rt = real;
  }
#line 303
  return (rt);
  {
#line 304
  free((void *)rt);
  }
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.c"
char *get_option(char *in ) 
{ 
  short b ;
  short a ;
  char real[256] ;
  char get[256] ;
  char *rt ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 312
  b = (short)0;
#line 315
  sprintf((char */* __restrict  */)(real), (char const   */* __restrict  */)"%s",
          in);
#line 316
  a = (short)0;
  }
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 316
    tmp = strlen((char const   *)(real));
    }
#line 316
    if (! ((size_t )a <= tmp - 1UL)) {
#line 316
      goto while_break;
    }
#line 317
    if ((int )real[a] == 61) {
      {
#line 318
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 318
        if (! ((int )real[(int )a + 1] != 0)) {
#line 318
          goto while_break___0;
        }
#line 320
        if ((int )real[(int )a + 1] != 32) {
#line 321
          get[b] = real[(int )a + 1];
        } else {
#line 323
          b = (short )((int )b - 1);
        }
#line 324
        b = (short )((int )b + 1);
#line 324
        a = (short )((int )a + 1);
      }
      while_break___0: /* CIL Label */ ;
      }
#line 326
      get[b] = (char )'\000';
#line 327
      goto while_break;
    }
#line 316
    a = (short )((int )a + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 330
  tmp___0 = strlen((char const   *)(get));
#line 330
  tmp___1 = malloc(tmp___0);
#line 330
  rt = (char *)tmp___1;
#line 331
  rt = get;
  }
#line 332
  return (rt);
  {
#line 333
  free((void *)rt);
  }
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.c"
void led_on(unsigned int who ) 
{ 


  {
#line 342
  if (who == 1U) {
    {
#line 343
    chcolor(colors.ingoing[0], colors.ingoing[1]);
#line 344
    wmove(stdscr, 12, 37);
#line 344
    whline(stdscr, (chtype )CHAR, 2);
    }
  } else
#line 346
  if (who == 2U) {
    {
#line 347
    chcolor(colors.outgoing[0], colors.outgoing[1]);
#line 348
    wmove(stdscr, 12, 41);
#line 348
    whline(stdscr, (chtype )CHAR, 2);
    }
  }
#line 350
  return;
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.c"
void led_off(unsigned int who ) 
{ 


  {
#line 355
  if (who == 1U) {
    {
#line 356
    chcolor(colors.labels[0], colors.labels[1]);
#line 357
    mvprintw(12, 37, "  ");
    }
  } else
#line 359
  if (who == 2U) {
    {
#line 360
    chcolor(colors.labels[0], colors.labels[1]);
#line 361
    mvprintw(12, 41, "  ");
    }
  }
#line 363
  return;
}
}
#line 369 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.c"
void update_stat(int reload ) 
{ 
  int x ;
  int y ;
  int bps[2] ;
  int pps[2] ;
  int ps ;
  float makegraph_in ;
  float makegraph_out ;
  float ks ;
  int tmp ;

  {
#line 374
  makegraph_in = (float )0;
#line 374
  makegraph_out = (float )0;
#line 379
  if (! stats.rx_bytes_comp) {
#line 380
    stats.rx_bytes_comp = stats.rx_bytes[0];
  }
#line 381
  if (! stats.tx_bytes_comp) {
#line 382
    stats.tx_bytes_comp = stats.tx_bytes[0];
  }
#line 383
  if (! stats.tx_packets_comp[1]) {
#line 384
    stats.tx_packets_comp[1] = stats.tx_packets[0];
  }
#line 385
  if (! stats.rx_packets_comp[1]) {
#line 386
    stats.rx_packets_comp[1] = stats.rx_packets[0];
  }
  {
#line 388
  bps[0] = (int )(stats.rx_bytes[0] - stats.rx_bytes_comp);
#line 389
  bps[1] = (int )(stats.tx_bytes[0] - stats.tx_bytes_comp);
#line 390
  pps[0] = (int )(stats.rx_packets[0] - stats.rx_packets_comp[1]);
#line 391
  pps[1] = (int )(stats.tx_packets[0] - stats.tx_packets_comp[1]);
#line 394
  ks = (float )(bps[0] + bps[1]);
#line 395
  ks /= (float )1024;
#line 396
  ps = pps[0] + pps[1];
#line 398
  autoscale(autoscalebytes, (double )(ks * (float )1024));
#line 399
  center((short)14, (char *)"%sB/s   %d Packets/s", autoscalebytes, ps);
  }
#line 404
  if (ks > stats.top_speed) {
    {
#line 406
    mvprintw(19, 27, "             ");
#line 407
    mvprintw(19, 27, "%sB/s", autoscalebytes);
#line 409
    stats.top_speed = ks;
    }
  }
#line 411
  if (ps > stats.top_packet) {
    {
#line 413
    mvprintw(19, 65, "             ");
#line 414
    mvprintw(19, 65, "%d", ps);
#line 415
    stats.top_packet = ps;
    }
  }
#line 417
  stats.rx_bytes_comp = stats.rx_bytes[0];
#line 418
  stats.tx_bytes_comp = stats.tx_bytes[0];
#line 419
  stats.rx_packets_comp[1] = stats.rx_packets[0];
#line 420
  stats.tx_packets_comp[1] = stats.tx_packets[0];
#line 428
  y = 0;
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if (! (y < 10)) {
#line 428
      goto while_break;
    }
#line 430
    if ((float )bps[0] > (float )((double )SPEED[0] * 102.4) * (float )y) {
#line 430
      if ((float )bps[0] <= (float )((double )SPEED[0] * 102.4) * (float )(y + 1)) {
#line 432
        makegraph_in = (float )(y + 1);
      } else {
#line 430
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 433
    if ((float )bps[0] > SPEED[0] * (float )1024) {
#line 434
      makegraph_in = (float )10;
    }
#line 436
    if ((float )bps[1] > (float )((double )SPEED[1] * 102.4) * (float )y) {
#line 436
      if ((float )bps[1] <= (float )((double )SPEED[1] * 102.4) * (float )(y + 1)) {
#line 438
        makegraph_out = (float )(y + 1);
      } else {
#line 436
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 439
    if ((float )bps[1] > SPEED[1] * (float )1024) {
#line 440
      makegraph_out = (float )10;
    }
#line 428
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  x = 0;
  {
#line 443
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 443
    if (! (x != 10)) {
#line 443
      goto while_break___0;
    }
#line 444
    graph[x].hline[75] = 0;
#line 443
    x ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 447
  if (makegraph_in > (float )10) {
#line 448
    makegraph_in = (float )10;
  }
#line 449
  if (makegraph_out > (float )10) {
#line 450
    makegraph_out = (float )10;
  }
#line 452
  x = 0;
  {
#line 452
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 452
    if (! ((float )x < makegraph_in)) {
#line 452
      goto while_break___1;
    }
#line 453
    graph[x].hline[75] = 1;
#line 452
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 455
  x = 0;
  {
#line 455
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 455
    if (! ((float )x < makegraph_out)) {
#line 455
      goto while_break___2;
    }
#line 457
    if (graph[x].hline[75] == 1) {
#line 458
      graph[x].hline[75] = 3;
    } else {
#line 460
      graph[x].hline[75] = 2;
    }
#line 455
    x ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 463
  y = 0;
  {
#line 463
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 463
    if (! (y != 10)) {
#line 463
      goto while_break___3;
    }
#line 464
    x = 0;
    {
#line 464
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 464
      if (! (x != 76)) {
#line 464
        goto while_break___4;
      }
#line 466
      if (! reload) {
#line 467
        if (x) {
#line 468
          graph[y].hline[x - 1] = graph[y].hline[x];
        }
      }
#line 471
      if (graph[y].hline[x] == 3) {
        {
#line 473
        chcolor(colors.intersection[0], colors.intersection[1]);
#line 474
        wmove(stdscr, (y + 10) - 2 * y, x + 2);
#line 475
        whline(stdscr, (chtype )CHAR, 1);
        }
      } else
#line 477
      if (graph[y].hline[x] == 1) {
        {
#line 479
        chcolor(colors.ingoing[0], colors.ingoing[1]);
#line 480
        wmove(stdscr, (y + 10) - 2 * y, x + 2);
#line 481
        whline(stdscr, (chtype )CHAR, 1);
        }
      } else
#line 483
      if (graph[y].hline[x] == 2) {
        {
#line 485
        chcolor(colors.outgoing[0], colors.outgoing[1]);
#line 486
        wmove(stdscr, (y + 10) - 2 * y, x + 2);
#line 487
        whline(stdscr, (chtype )CHAR, 1);
        }
      } else {
        {
#line 491
        chcolor(colors.background, 0);
#line 492
        tmp = wmove(stdscr, (y + 10) - 2 * y, x + 2);
        }
#line 492
        if (! (tmp == -1)) {
          {
#line 492
          waddnstr(stdscr, " ", -1);
          }
        }
      }
#line 464
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 463
    y ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 496
  return;
}
}
#line 502 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.c"
void show_usage(char *name ) 
{ 


  {
  {
#line 504
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nEthStatus v0.4a - Gabriel Montenegro / Christoph Haas\nUsage: %s\n  [-i interface]                      interface name\n  [-v [vga|mono]]                     video display mode\n  [-S speed[k|m|g]]                   line speed in [K|M|G]bps\n  [-s [10|100|64|128|256|768|1540]]   line speed (backward compatibility)\n\n",
          name);
  }
#line 511
  return;
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.c"
void chcolor(int x , int y ) 
{ 


  {
  {
#line 518
  init_pair((short)1, (short)0, (short )colors.background);
#line 519
  init_pair((short)2, (short)1, (short )colors.background);
#line 520
  init_pair((short)3, (short)2, (short )colors.background);
#line 521
  init_pair((short)4, (short)3, (short )colors.background);
#line 522
  init_pair((short)5, (short)4, (short )colors.background);
#line 523
  init_pair((short)6, (short)5, (short )colors.background);
#line 524
  init_pair((short)7, (short)6, (short )colors.background);
#line 525
  init_pair((short)8, (short)7, (short )colors.background);
  }
#line 527
  if (! y) {
#line 528
    if (stdscr) {
#line 528
      stdscr->_attrs = (chtype )(x + 1) << 8;
    }
  }
#line 529
  if (y) {
#line 530
    if (stdscr) {
#line 530
      stdscr->_attrs = ((chtype )(x + 1) << 8) | (1UL << 21);
    }
  }
#line 531
  return;
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.c"
void close_eths(char *errmsg  , ...) 
{ 
  va_list trans ;
  char *final ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 541
  tmp = strlen((char const   *)errmsg);
#line 541
  tmp___0 = malloc(tmp);
#line 541
  final = (char *)tmp___0;
#line 542
  __builtin_va_start(trans, errmsg);
#line 543
  tmp___1 = strlen((char const   *)errmsg);
#line 543
  vsnprintf((char */* __restrict  */)final, tmp___1, (char const   */* __restrict  */)errmsg,
            trans);
#line 544
  __builtin_va_end(trans);
#line 545
  endwin();
#line 546
  curs_set(1);
#line 547
  system("clear");
#line 548
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          final);
#line 549
  free((void *)final);
#line 550
  exit(0);
  }
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.c"
void face(void) 
{ 
  short x ;
  short y ;

  {
  {
#line 559
  chcolor(colors.background, 0);
#line 560
  x = (short)0;
  }
  {
#line 560
  while (1) {
    while_continue: /* CIL Label */ ;
#line 560
    if (! ((int )x <= 24)) {
#line 560
      goto while_break;
    }
#line 561
    y = (short)0;
    {
#line 561
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 561
      if (! ((int )y <= 80)) {
#line 561
        goto while_break___0;
      }
      {
#line 562
      mvprintw((int )x, (int )y, " ");
#line 561
      y = (short )((int )y + 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 560
    x = (short )((int )x + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 563
  wrefresh(stdscr);
#line 564
  chcolor(colors.border[0], colors.border[1]);
#line 565
  wborder(stdscr, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0,
          (chtype )0, (chtype )0);
#line 567
  wrefresh(stdscr);
#line 568
  chcolor(colors.labels[0], colors.labels[1]);
#line 569
  mvprintw(17, 6, "IP Address:");
#line 574
  mvprintw(20, 6, "Received Packets:");
#line 575
  mvprintw(22, 6, "Errors on Receiving:");
#line 576
  mvprintw(20, 41, "Transmited Packets:");
#line 577
  mvprintw(22, 41, "Errors on Transmission:");
#line 578
  mvprintw(13, 37, "RX");
#line 579
  mvprintw(13, 41, "TX");
#line 580
  mvprintw(18, 6, "Interface name:");
#line 581
  mvprintw(18, 41, "Graphic Using Speed:");
#line 582
  mvprintw(13, 9, "ON/OFF");
#line 583
  mvprintw(19, 6, "Top Speed:");
#line 584
  mvprintw(19, 41, "Top Packets/s:");
#line 585
  wrefresh(stdscr);
#line 586
  chcolor(colors.version[0], colors.version[1]);
#line 587
  mvprintw(0, 31, ".EthStatus v0.4a.");
#line 588
  wrefresh(stdscr);
#line 589
  chcolor(colors.data[0], colors.data[1]);
#line 590
  mvprintw(18, 27, "%s", interface);
#line 592
  autoscale(autoscalebytes, (double )SPEED[0] * (double )1000);
#line 593
  mvprintw(18, 65, "%sB/s", autoscalebytes);
#line 594
  mvprintw(19, 27, "0.00 KB/s");
#line 595
  mvprintw(19, 65, "0");
#line 596
  wrefresh(stdscr);
  }
#line 597
  return;
}
}
#line 603 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.c"
int main(int argc , char **argv ) 
{ 
  short x ;
  short y ;
  short key_pressed ;
  short first ;
  short reload ;
  time_t cron ;
  int bps ;
  char modifier ;
  long KBps ;
  int option ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  struct tm *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
  {
#line 605
  first = (short)1;
#line 605
  reload = (short)0;
#line 607
  cron = time((time_t *)((void *)0));
#line 608
  stats.start_time = ctime((time_t const   *)(& cron));
#line 616
  colors.ingoing[0] = 2;
#line 616
  colors.ingoing[1] = 1;
#line 617
  colors.outgoing[0] = 3;
#line 617
  colors.outgoing[1] = 1;
#line 618
  colors.intersection[0] = 2;
#line 618
  colors.intersection[1] = 0;
#line 619
  colors.background = 0;
#line 620
  colors.data[0] = 6;
#line 620
  colors.data[1] = 0;
#line 621
  colors.border[0] = 7;
#line 621
  colors.data[1] = 0;
#line 622
  colors.labels[0] = 7;
#line 622
  colors.labels[1] = 0;
#line 623
  colors.version[0] = 7;
#line 623
  colors.labels[1] = 1;
#line 624
  colors.power_led[0] = 2;
#line 624
  colors.power_led[1] = 1;
#line 625
  colors.power_led[2] = 1;
#line 625
  colors.power_led[3] = 0;
  }
  {
#line 629
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 629
    option = getopt(argc, (char * const  *)argv, "hi:s:S:v:");
    }
#line 629
    if (! (option != -1)) {
#line 629
      goto while_break;
    }
    {
#line 633
    if (option == 104) {
#line 633
      goto case_104;
    }
#line 638
    if (option == 105) {
#line 638
      goto case_105;
    }
#line 647
    if (option == 118) {
#line 647
      goto case_118;
    }
#line 665
    if (option == 83) {
#line 665
      goto case_83;
    }
#line 711
    if (option == 115) {
#line 711
      goto case_115;
    }
#line 738
    if (option == 63) {
#line 738
      goto case_63;
    }
#line 631
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 634
    show_usage(*(argv + 0));
#line 635
    exit(0);
    }
#line 636
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 639
    tmp = strlen((char const   *)optarg);
    }
#line 639
    if (tmp > 5UL) {
      {
#line 641
      show_usage(*(argv + 0));
#line 642
      exit(10);
      }
    }
#line 644
    interface = optarg;
#line 645
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 648
    tmp___0 = strcmp((char const   *)optarg, "mono");
    }
#line 648
    if (! tmp___0) {
#line 650
      VGA = (unsigned short)0;
#line 651
      goto switch_break;
    }
    {
#line 653
    tmp___1 = strcmp((char const   *)optarg, "vga");
    }
#line 653
    if (tmp___1) {
      {
#line 660
      show_usage(*(argv + 0));
#line 661
      exit(10);
      }
    } else {
#line 655
      VGA = (unsigned short)1;
#line 656
      goto switch_break;
    }
#line 663
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 667
    tmp___2 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%i%c",
                     & bps, & modifier);
    }
#line 667
    if (! tmp___2) {
      {
#line 669
      show_usage(*(argv + 0));
#line 670
      exit(10);
      }
    }
#line 673
    if (bps > 1024) {
      {
#line 675
      show_usage(*(argv + 0));
#line 676
      exit(10);
      }
    }
#line 680
    KBps = (long )bps;
#line 683
    if ((int )modifier == 107) {
#line 684
      KBps = KBps;
    } else
#line 683
    if ((int )modifier == 75) {
#line 684
      KBps = KBps;
    } else
#line 685
    if ((int )modifier == 109) {
#line 686
      KBps *= 1024L;
    } else
#line 685
    if ((int )modifier == 109) {
#line 686
      KBps *= 1024L;
    } else
#line 687
    if ((int )modifier == 103) {
#line 688
      KBps *= 1048576L;
    } else
#line 687
    if ((int )modifier == 103) {
#line 688
      KBps *= 1048576L;
    } else {
      {
#line 691
      show_usage(*(argv + 0));
#line 692
      exit(10);
      }
    }
#line 696
    KBps /= 8L;
#line 698
    if (KBps == 0L) {
      {
#line 700
      show_usage(*(argv + 0));
#line 701
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"ERROR: bandwidth set too low\n");
#line 702
      exit(10);
      }
    }
#line 707
    SPEED[0] = (float )KBps;
#line 708
    SPEED[1] = (float )KBps;
#line 709
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 712
    tmp___13 = strcmp((char const   *)optarg, "100");
    }
#line 712
    if (tmp___13) {
      {
#line 712
      tmp___14 = strcmp((char const   *)optarg, "10");
      }
#line 712
      if (tmp___14) {
        {
#line 714
        tmp___11 = strcmp((char const   *)optarg, "64");
        }
#line 714
        if (tmp___11) {
          {
#line 714
          tmp___12 = strcmp((char const   *)optarg, "128");
          }
#line 714
          if (tmp___12) {
            {
#line 716
            tmp___10 = strcmp((char const   *)optarg, "256");
            }
#line 716
            if (tmp___10) {
              {
#line 721
              tmp___9 = strcmp((char const   *)optarg, "768");
              }
#line 721
              if (tmp___9) {
                {
#line 726
                tmp___8 = strcmp((char const   *)optarg, "1540");
                }
#line 726
                if (tmp___8) {
                  {
#line 733
                  show_usage(*(argv + 0));
#line 734
                  exit(10);
                  }
                } else {
                  {
#line 728
                  tmp___7 = atof((char const   *)optarg);
#line 728
                  SPEED[0] = (float )tmp___7;
#line 729
                  SPEED[1] = (float )256;
                  }
                }
              } else {
                {
#line 723
                tmp___6 = atof((char const   *)optarg);
#line 723
                SPEED[0] = (float )tmp___6;
#line 724
                SPEED[1] = (float )128;
                }
              }
            } else {
              {
#line 718
              tmp___5 = atof((char const   *)optarg);
#line 718
              SPEED[0] = (float )tmp___5;
#line 719
              SPEED[1] = (float )64;
              }
            }
          } else {
            {
#line 715
            tmp___4 = atof((char const   *)optarg);
#line 715
            SPEED[1] = (float )tmp___4;
#line 715
            SPEED[0] = SPEED[1];
            }
          }
        } else {
          {
#line 715
          tmp___4 = atof((char const   *)optarg);
#line 715
          SPEED[1] = (float )tmp___4;
#line 715
          SPEED[0] = SPEED[1];
          }
        }
      } else {
        {
#line 713
        tmp___3 = atof((char const   *)optarg);
#line 713
        SPEED[1] = (float )((tmp___3 / (double )8) * (double )1024);
#line 713
        SPEED[0] = SPEED[1];
        }
      }
    } else {
      {
#line 713
      tmp___3 = atof((char const   *)optarg);
#line 713
      SPEED[1] = (float )((tmp___3 / (double )8) * (double )1024);
#line 713
      SPEED[0] = SPEED[1];
      }
    }
#line 736
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 739
    show_usage(*(argv + 0));
#line 740
    exit(10);
    }
#line 741
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 746
  stats.tx_packets[0] = (double )0;
#line 746
  stats.tx_bytes[0] = (double )0;
#line 746
  stats.tx_errors[0] = 0UL;
#line 747
  stats.rx_packets[0] = (double )0;
#line 747
  stats.rx_bytes[0] = (double )0;
#line 747
  stats.rx_errors[0] = 0UL;
#line 748
  stats.tx_bytes_comp = (double )0;
#line 748
  stats.tx_bytes_comp = (double )0;
#line 749
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Running EthStatus v%s...",
          "0.4a");
#line 750
  printf((char const   */* __restrict  */)"\033(U");
#line 751
  initscr();
#line 752
  intrflush(stdscr, (_Bool)0);
  }
#line 753
  if (VGA) {
    {
#line 754
    start_color();
    }
  }
  {
#line 755
  init_color((short)1, (short)1, (short)2, (short)4);
#line 756
  curs_set(0);
#line 757
  nonl();
#line 758
  noecho();
#line 759
  cbreak();
#line 760
  nodelay(stdscr, (_Bool)1);
#line 761
  face();
#line 762
  update_info();
  }
  {
#line 767
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 768
    tmp___16 = is_online((short)0, (short)0);
    }
#line 768
    if (tmp___16) {
#line 769
      if (disconnected) {
        {
#line 770
        clear_info();
#line 771
        y = (short)0;
        }
        {
#line 771
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 771
          if (! ((int )y != 10)) {
#line 771
            goto while_break___1;
          }
#line 772
          x = (short)0;
          {
#line 772
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 772
            if (! ((int )x != 75)) {
#line 772
              goto while_break___2;
            }
#line 773
            graph[y].hline[x] = 0;
#line 772
            x = (short )((int )x + 1);
          }
          while_break___2: /* CIL Label */ ;
          }
#line 771
          y = (short )((int )y + 1);
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 775
        stats.rx_packets_comp[1] = (double )0;
#line 775
        stats.tx_packets_comp[1] = stats.rx_packets_comp[1];
#line 775
        stats.tx_packets_comp[0] = stats.tx_packets_comp[1];
#line 775
        stats.rx_packets_comp[0] = stats.tx_packets_comp[0];
#line 775
        stats.tx_bytes_comp = stats.rx_packets_comp[0];
#line 775
        stats.rx_bytes_comp = stats.tx_bytes_comp;
#line 775
        stats.top_packet = (int )stats.rx_bytes_comp;
#line 775
        stats.top_speed = (float )stats.top_packet;
#line 776
        update_stat(0);
        }
      }
      {
#line 778
      cron = time((time_t *)((void *)0));
#line 779
      tmp___15 = localtime((time_t const   *)(& cron));
#line 779
      localt = *tmp___15;
      }
#line 782
      if (stats.rx_packets[0] != stats.rx_packets_comp[0]) {
        {
#line 783
        led_on(1U);
        }
      } else {
        {
#line 785
        led_off(1U);
        }
      }
#line 788
      if (stats.tx_packets[0] != stats.tx_packets_comp[0]) {
        {
#line 789
        led_on(2U);
        }
      } else {
        {
#line 791
        led_off(2U);
        }
      }
      {
#line 793
      stats.rx_packets_comp[0] = stats.rx_packets[0];
#line 794
      stats.tx_packets_comp[0] = stats.tx_packets[0];
#line 796
      update_info();
      }
#line 798
      if (sec_value == 0) {
#line 798
        if (first) {
#line 798
          goto _L;
        } else {
#line 798
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 798
      if (disconnected) {
        _L: /* CIL Label */ 
        {
#line 800
        sec_value = localt.tm_sec;
#line 801
        stats.log_value = (unsigned long )((localt.tm_sec + localt.tm_min * 60) + localt.tm_hour * 3600);
#line 802
        ip_address(1);
#line 802
        update_stat(0);
#line 803
        first = (short)0;
#line 803
        disconnected = (unsigned short)0;
        }
      }
#line 805
      if (stats.log_value + stats.log_time == (unsigned long )((localt.tm_sec + localt.tm_min * 60) + localt.tm_hour * 3600)) {
#line 807
        stats.log_value = (unsigned long )((localt.tm_sec + localt.tm_min * 60) + localt.tm_hour * 3600);
      }
#line 809
      if (localt.tm_sec != sec_value) {
#line 811
        if (check) {
          {
#line 812
          check_email();
          }
        }
        {
#line 813
        update_stat(0);
#line 814
        sec_value = localt.tm_sec;
        }
      }
      {
#line 816
      usleep((__useconds_t )10L);
      }
    } else {
      {
#line 819
      usleep((__useconds_t )100000L);
      }
    }
    {
#line 821
    tmp___17 = wgetch(stdscr);
#line 821
    key_pressed = (short )tmp___17;
    }
#line 822
    if ((int )key_pressed != -1) {
      {
#line 822
      tmp___19 = tolower((int )key_pressed);
      }
#line 822
      if (tmp___19 == 113) {
#line 823
        goto while_break___0;
      } else {
#line 822
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 824
    if ((int )key_pressed != -1) {
      {
#line 824
      tmp___18 = tolower((int )key_pressed);
      }
#line 824
      if (tmp___18 == 114) {
        {
#line 826
        face();
#line 827
        is_online((short)1, (short)0);
#line 828
        ip_address(1);
        }
#line 829
        if (check) {
          {
#line 830
          check_email();
          }
        }
        {
#line 831
        update_stat(1);
#line 832
        reload = (short)1;
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 835
  endwin();
#line 836
  system("clear");
#line 837
  curs_set(1);
#line 838
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"EthStatus v0.4a - Gabriel Montenegro / Christoph Haas\n\n");
  }
#line 839
  return (0);
}
}
#line 847 "/home/june/repo/benchmarks/collector/temp/ethstatus-0.4.3ubuntu1/ethstatus.c"
void autoscale(char *str , double bytes ) 
{ 


  {
#line 849
  if (bytes > ((double )1024 * (double )1024) * (double )1024) {
    {
#line 850
    sprintf((char */* __restrict  */)str, (char const   */* __restrict  */)"%.2f G",
            bytes / (double )1073741824);
    }
  } else
#line 851
  if (bytes > (double )1024 * (double )1024) {
    {
#line 852
    sprintf((char */* __restrict  */)str, (char const   */* __restrict  */)"%.2f M",
            bytes / (double )1048576);
    }
  } else
#line 853
  if (bytes > (double )1024) {
    {
#line 854
    sprintf((char */* __restrict  */)str, (char const   */* __restrict  */)"%.2f K",
            bytes / (double )1024);
    }
  } else {
    {
#line 855
    sprintf((char */* __restrict  */)str, (char const   */* __restrict  */)"%.2f ",
            bytes);
    }
  }
#line 856
  return;
}
}
