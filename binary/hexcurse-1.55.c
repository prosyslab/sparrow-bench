/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 55 "../include/hex.h"
struct LinkedList {
   long loc ;
   int val ;
   struct LinkedList *next ;
};
#line 61 "../include/hex.h"
struct Stack {
   int savedVal ;
   long currentLoc ;
   struct Stack *prev ;
   struct LinkedList *llist ;
};
#line 70 "../include/hex.h"
typedef struct Stack hexStack;
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 358
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 45 "../include/hex.h"
struct __anonstruct_WINS_54 {
   WINDOW *hex ;
   WINDOW *ascii ;
   WINDOW *address ;
   WINDOW *scrollbar ;
   WINDOW *hex_outline ;
   WINDOW *ascii_outline ;
   WINDOW *cur_address ;
};
#line 45 "../include/hex.h"
typedef struct __anonstruct_WINS_54 WINS;
#line 69 "../include/hex.h"
typedef struct LinkedList hexList;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 87 "../include/hgetopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 69 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/getopt.c"
enum __anonenum_ordering_25 {
    REQUIRE_ORDER = 0,
    PERMUTE = 1,
    RETURN_IN_ORDER = 2
} ;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 114 "../include/hex.h"
FILE *fpIN  ;
#line 114 "../include/hex.h"
FILE *fpOUT  ;
#line 168
void createStack(hexStack *stack ) ;
#line 169
void pushStack(hexStack **stack , hexStack *tmpStack ) ;
#line 170
void popStack(hexStack **stack ) ;
#line 171
void smashDaStack(hexStack **stack ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/stack.c"
void createStack(hexStack *stack ) 
{ 


  {
#line 33
  stack = (hexStack *)((void *)0);
#line 34
  stack->llist = (struct LinkedList *)((void *)0);
#line 35
  stack->prev = (struct Stack *)((void *)0);
#line 36
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/stack.c"
void pushStack(hexStack **stack , hexStack *tmpStack ) 
{ 
  hexStack *oldStack ;

  {
#line 46
  oldStack = *stack;
#line 48
  if ((unsigned long )oldStack == (unsigned long )((void *)0)) {
#line 49
    *stack = tmpStack;
  } else {
#line 52
    tmpStack->prev = oldStack;
#line 53
    *stack = tmpStack;
  }
#line 56
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/stack.c"
void popStack(hexStack **stack ) 
{ 
  hexStack *tmpStack ;

  {
#line 68
  tmpStack = *stack;
#line 70
  if ((unsigned long )tmpStack != (unsigned long )((void *)0)) {
    {
#line 72
    *stack = tmpStack->prev;
#line 73
    free((void *)tmpStack);
    }
  }
#line 76
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/stack.c"
void smashDaStack(hexStack **stack ) 
{ 
  hexStack *tmpStack ;

  {
#line 85
  tmpStack = *stack;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! ((unsigned long )tmpStack != (unsigned long )((void *)0))) {
#line 87
      goto while_break;
    }
    {
#line 89
    *stack = tmpStack->prev;
#line 90
    free((void *)tmpStack);
#line 91
    tmpStack = *stack;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  return;
}
}
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 278
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 75 "../include/hex.h"
hexList *head ;
#line 144
hexList *deleteNode(hexList *head___0 , int loc ) ;
#line 145
hexList *insertItem(hexList *head___0 , int loc , int val ) ;
#line 146
int searchList(hexList *head___0 , int loc ) ;
#line 147
int writeChanges(WINS *win , FILE *fpIN___0 , FILE *fpOUT___0 , char *fpINfilename___0 ,
                 char *fpOUTfilename___0 ) ;
#line 148
hexList *freeList(hexList *head___0 ) ;
#line 164
void popupWin(char *msg , int time ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/llist.c"
hexList *deleteNode(hexList *head___0 , int loc ) 
{ 
  hexList *tmpHead ;

  {
#line 27
  if ((unsigned long )head___0 == (unsigned long )((void *)0)) {
#line 28
    return (head___0);
  } else
#line 29
  if (head___0->loc > (long )loc) {
#line 30
    return (head___0);
  } else
#line 31
  if (head___0->loc < (long )loc) {
    {
#line 32
    head___0->next = deleteNode(head___0->next, loc);
    }
  } else
#line 33
  if (head___0->loc == (long )loc) {
    {
#line 35
    tmpHead = head___0;
#line 36
    head___0 = head___0->next;
#line 37
    free((void *)tmpHead);
    }
  }
#line 42
  return (head___0);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/llist.c"
hexList *insertItem(hexList *head___0 , int loc , int val ) 
{ 
  void *tmp ;
  hexList *tmpHead ;
  void *tmp___0 ;
  hexList *tmpHead___0 ;
  void *tmp___1 ;

  {
#line 51
  if ((unsigned long )head___0 == (unsigned long )((void *)0)) {
    {
#line 53
    tmp = calloc((size_t )1, sizeof(struct LinkedList ));
#line 53
    head___0 = (struct LinkedList *)tmp;
#line 54
    head___0->loc = (long )loc;
#line 55
    head___0->val = val;
#line 56
    head___0->next = (struct LinkedList *)((void *)0);
    }
  } else
#line 58
  if (head___0->loc == (long )loc) {
    {
#line 61
    tmp___0 = calloc((size_t )1, sizeof(struct LinkedList ));
#line 61
    tmpHead = (struct LinkedList *)tmp___0;
#line 62
    tmpHead->loc = (long )loc;
#line 63
    tmpHead->val = val;
#line 64
    tmpHead->next = head___0;
#line 65
    head___0 = tmpHead;
    }
  } else
#line 67
  if (head___0->loc < (long )loc) {
    {
#line 68
    head___0->next = insertItem(head___0->next, loc, val);
    }
  } else
#line 67
  if ((unsigned long )head___0->next == (unsigned long )((void *)0)) {
    {
#line 68
    head___0->next = insertItem(head___0->next, loc, val);
    }
  } else
#line 70
  if ((unsigned long )head___0->next != (unsigned long )((void *)0)) {
#line 70
    if ((head___0->next)->loc >= (long )loc) {
      {
#line 73
      tmp___1 = calloc((size_t )1, sizeof(struct LinkedList ));
#line 73
      tmpHead___0 = (struct LinkedList *)tmp___1;
#line 74
      tmpHead___0->loc = (long )loc;
#line 75
      tmpHead___0->val = val;
#line 76
      tmpHead___0->next = head___0;
#line 77
      head___0 = tmpHead___0;
      }
    }
  }
#line 80
  return (head___0);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/llist.c"
int searchList(hexList *head___0 , int loc ) 
{ 
  hexList *tmpHead ;

  {
#line 92
  tmpHead = head___0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! ((unsigned long )tmpHead != (unsigned long )((void *)0))) {
#line 93
      goto while_break;
    }
#line 95
    if (tmpHead->loc == (long )loc) {
#line 96
      return (tmpHead->val);
    } else {
#line 98
      tmpHead = tmpHead->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  return (-1);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/llist.c"
int writeChanges(WINS *win , FILE *fpIN___0 , FILE *fpOUT___0 , char *fpINfilename___0 ,
                 char *fpOUTfilename___0 ) 
{ 
  unsigned int buff ;
  unsigned int prev_loc ;
  hexList *tmpHead ;
  int tmp ;

  {
  {
#line 111
  tmpHead = head;
#line 113
  fpOUT___0 = fopen((char const   */* __restrict  */)fpOUTfilename___0, (char const   */* __restrict  */)"w+");
  }
#line 113
  if (fpOUT___0) {
#line 113
    if (fpIN___0) {
      {
#line 115
      rewind(fpIN___0);
#line 116
      rewind(fpOUT___0);
      }
      {
#line 117
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 117
        tmp = fgetc(fpIN___0);
#line 117
        buff = (unsigned int )tmp;
        }
#line 117
        if (! (buff != 4294967295U)) {
#line 117
          goto while_break;
        }
        {
#line 118
        fputc((int )buff, fpOUT___0);
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 113
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 120
  if (! fpOUT___0) {
#line 120
    if (fpIN___0) {
      {
#line 122
      fpOUT___0 = freopen((char const   */* __restrict  */)fpINfilename___0, (char const   */* __restrict  */)"r+",
                          (FILE */* __restrict  */)fpIN___0);
      }
#line 122
      if (fpOUT___0) {
#line 122
        if (*fpOUTfilename___0) {
          {
#line 124
          popupWin((char *)"Cannot write to file: bad permissions", -1);
          }
#line 126
          return (1);
        }
      } else {
        {
#line 124
        popupWin((char *)"Cannot write to file: bad permissions", -1);
        }
#line 126
        return (1);
      }
    } else {
      {
#line 131
      popupWin((char *)"No data written.", -1);
      }
#line 133
      return (1);
    }
  } else {
    {
#line 131
    popupWin((char *)"No data written.", -1);
    }
#line 133
    return (1);
  }
  {
#line 136
  rewind(fpIN___0);
#line 137
  rewind(fpOUT___0);
#line 138
  prev_loc = 4294967295U;
  }
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 139
    if (! ((unsigned long )tmpHead != (unsigned long )((void *)0))) {
#line 139
      goto while_break___0;
    }
#line 142
    if ((long )prev_loc != tmpHead->loc) {
      {
#line 143
      fseek(fpOUT___0, tmpHead->loc, 0);
#line 144
      fputc(tmpHead->val, fpOUT___0);
      }
    }
#line 146
    prev_loc = (unsigned int )tmpHead->loc;
#line 147
    tmpHead = tmpHead->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 151
  fflush(fpOUT___0);
#line 152
  fpIN___0 = fpOUT___0;
#line 153
  rewind(fpIN___0);
#line 154
  rewind(fpOUT___0);
  }
#line 156
  return (0);
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/llist.c"
hexList *freeList(hexList *head___0 ) 
{ 


  {
#line 168
  if ((unsigned long )head___0 != (unsigned long )((void *)0)) {
    {
#line 170
    freeList(head___0->next);
#line 171
    free((void *)head___0);
    }
  }
#line 173
  return ((hexList *)((void *)0));
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 267 "/usr/include/curses.h"
extern chtype acs_map[] ;
#line 587
extern int cbreak(void) ;
#line 603
extern int delwin(WINDOW * ) ;
#line 606
extern int doupdate(void) ;
#line 611
extern int endwin(void) ;
#line 627
extern int idlok(WINDOW * , _Bool  ) ;
#line 632
extern WINDOW *initscr(void) ;
#line 647
extern int keypad(WINDOW * , _Bool  ) ;
#line 699
extern int mvwprintw(WINDOW * , int  , int  , char const   *  , ...) ;
#line 707
extern WINDOW *newwin(int  , int  , int  , int  ) ;
#line 711
extern int noecho(void) ;
#line 727
extern int raw(void) ;
#line 741
extern int scrollok(WINDOW * , _Bool  ) ;
#line 753
extern int slk_clear(void) ;
#line 757
extern int slk_noutrefresh(void) ;
#line 759
extern int slk_restore(void) ;
#line 760
extern int slk_set(int  , char const   * , int  ) ;
#line 785
extern int waddch(WINDOW * , chtype const    ) ;
#line 794
extern int wattr_on(WINDOW * , attr_t  , void * ) ;
#line 795
extern int wattr_off(WINDOW * , attr_t  , void * ) ;
#line 799
extern int wborder(WINDOW * , chtype  , chtype  , chtype  , chtype  , chtype  , chtype  ,
                   chtype  , chtype  ) ;
#line 801
extern int wclear(WINDOW * ) ;
#line 810
extern int wgetch(WINDOW * ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 825
extern int wnoutrefresh(WINDOW * ) ;
#line 828
extern int wredrawln(WINDOW * , int  , int  ) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 832
extern int wscrl(WINDOW * , int  ) ;
#line 839
extern int wtouchln(WINDOW * , int  , int  , int  ) ;
#line 1390
extern int COLS ;
#line 1392
extern int LINES ;
#line 73 "../include/hex.h"
int MAXY ;
#line 74
WINS *windows ;
#line 76
int BASE ;
#line 77
int hex_outline_width ;
#line 78
int hex_win_width ;
#line 79
int ascii_outline_width ;
#line 80
int ascii_win_width ;
#line 81
long maxlines ;
#line 82
long currentLine ;
#line 86
int SIZE_CH ;
#line 124
void outline(FILE *fp , int linenum ) ;
#line 125
int maxLoc(FILE *fp ) ;
#line 127
int maxLines(int len ) ;
#line 141
void catchSegfault(int sig ) ;
#line 151
void init_menu(WINS *windows___0 ) ;
#line 152
void exit_err(char *err_str ) ;
#line 153
void init_screen(void) ;
#line 154
void screen_exit(int exit_val ) ;
#line 155
void init_fkeys(void) ;
#line 156
void checkScreenSize(int sig ) ;
#line 157
void refreshall(WINS *win ) ;
#line 158
WINDOW *drawbox(int y , int x , int height , int width ) ;
#line 159
void scrollbar(WINS *windows___0 , int cl , long maxLines___0 ) ;
#line 160
void printHelp(WINS *win ) ;
#line 161
void winscroll(WINS *windows___0 , WINDOW *win , int n , int currentLine___0 ) ;
#line 162
void clearScreen(WINS *win ) ;
#line 163
int quitProgram(int notChanged , short ch ) ;
#line 165
short questionWin(char *msg ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/screen.c"
void init_menu(WINS *windows___0 ) 
{ 
  int x ;
  WINDOW *win ;

  {
#line 30
  x = 1;
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! (x < 24)) {
#line 30
      goto while_break;
    }
    {
#line 31
    signal(x, (void (*)(int  ))1);
#line 30
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 34
  signal(11, & catchSegfault);
#line 36
  signal(28, & checkScreenSize);
#line 39
  windows___0->hex_outline = drawbox(0, 0, LINES, hex_outline_width);
#line 40
  windows___0->ascii_outline = drawbox(0, hex_outline_width + 1, LINES, ascii_outline_width);
#line 42
  windows___0->scrollbar = newwin(LINES, 1, 0, hex_outline_width);
#line 44
  windows___0->hex = newwin(LINES - 2, hex_win_width, 1, 10);
#line 45
  windows___0->ascii = newwin(LINES - 2, ascii_win_width, 1, hex_outline_width + 2);
#line 47
  windows___0->address = newwin(LINES - 2, 9, 1, 1);
#line 49
  windows___0->cur_address = newwin(1, 8, 0, 1);
#line 51
  waddch(windows___0->scrollbar, (chtype const   )acs_map[(unsigned char )'-']);
#line 52
  wattr_on(windows___0->scrollbar, 1UL << 18, (void *)0);
#line 53
  waddch(windows___0->scrollbar, (chtype const   )acs_map[(unsigned char )'`']);
#line 54
  wattr_off(windows___0->scrollbar, 1UL << 18, (void *)0);
#line 55
  x = 0;
  }
  {
#line 55
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 55
    if (! (x < LINES - 2)) {
#line 55
      goto while_break___0;
    }
    {
#line 56
    waddch(windows___0->scrollbar, (chtype const   )acs_map[(unsigned char )'a']);
#line 55
    x ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 57
  waddch(windows___0->scrollbar, (chtype const   )acs_map[(unsigned char )'.']);
#line 58
  wrefresh(windows___0->scrollbar);
#line 60
  cbreak();
#line 61
  noecho();
#line 62
  raw();
#line 64
  win = windows___0->hex;
#line 65
  x = 0;
  }
  {
#line 65
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 65
    if (! (x <= 2)) {
#line 65
      goto while_break___1;
    }
    {
#line 67
    idlok(win, (_Bool)1);
#line 69
    keypad(win, (_Bool)1);
    }
#line 71
    if (x == 0) {
#line 71
      win = windows___0->ascii;
    } else {
#line 71
      win = windows___0->address;
    }
#line 65
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/screen.c"
void exit_err(char *err_str ) 
{ 


  {
  {
#line 82
  endwin();
#line 83
  perror((char const   *)err_str);
#line 84
  printf((char const   */* __restrict  */)"\n\n");
#line 85
  exit(1);
  }
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/screen.c"
void init_screen(void) 
{ 
  WINDOW *tmp ;

  {
  {
#line 95
  tmp = initscr();
  }
#line 95
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 97
    perror("initscr");
#line 98
    printf((char const   */* __restrict  */)"exiting\n");
#line 99
    exit(1);
    }
  }
#line 102
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/screen.c"
void screen_exit(int exit_val ) 
{ 


  {
  {
#line 110
  endwin();
#line 111
  printf((char const   */* __restrict  */)"\n");
#line 112
  exit(exit_val);
  }
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/screen.c"
void init_fkeys(void) 
{ 


  {
  {
#line 120
  slk_set(1, "Help", 1);
#line 121
  slk_set(2, "Save", 1);
#line 122
  slk_set(3, "Open", 1);
#line 123
  slk_set(4, "Goto", 1);
#line 124
  slk_set(5, "Find", 1);
#line 126
  slk_set(7, "Hex Edit", 1);
#line 127
  slk_set(8, "Quit", 1);
#line 128
  slk_set(9, "Quit", 1);
#line 129
  slk_noutrefresh();
  }
#line 130
  return;
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/screen.c"
void checkScreenSize(int sig ) 
{ 
  int count ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 141
  clearScreen(windows);
#line 142
  endwin();
#line 143
  init_screen();
#line 145
  slk_clear();
#line 146
  slk_restore();
#line 147
  slk_noutrefresh();
#line 148
  doupdate();
#line 150
  BASE = (COLS - 14) / 4;
#line 151
  hex_outline_width = BASE * 3 + 11;
#line 152
  MAXY = LINES - 3;
#line 153
  hex_win_width = BASE * 3;
#line 154
  ascii_outline_width = BASE + 2;
#line 155
  ascii_win_width = BASE;
  }
#line 156
  if ((unsigned long )fpIN != (unsigned long )((void *)0)) {
    {
#line 156
    tmp = maxLoc(fpIN);
#line 156
    tmp___0 = tmp;
    }
  } else {
#line 156
    tmp___0 = 0;
  }
  {
#line 156
  tmp___1 = maxLines(tmp___0);
#line 156
  maxlines = (long )tmp___1;
#line 157
  currentLine = 0L;
#line 158
  SIZE_CH = 1;
  }
#line 160
  if (COLS < 70) {
#line 160
    goto _L;
  } else
#line 160
  if (LINES < 7) {
    _L: /* CIL Label */ 
    {
#line 168
    init_fkeys();
#line 169
    init_menu(windows);
#line 170
    clearScreen(windows);
#line 171
    slk_clear();
#line 172
    mvwprintw(windows->hex, 0, 0, "Your screen is too small");
#line 174
    refreshall(windows);
#line 175
    doupdate();
    }
  } else {
    {
#line 179
    init_fkeys();
#line 180
    init_menu(windows);
#line 181
    wmove(windows->hex, 0, 0);
    }
#line 182
    if (fpIN) {
#line 184
      count = 0;
      {
#line 184
      while (1) {
        while_continue: /* CIL Label */ ;
#line 184
        if (count <= MAXY) {
          {
#line 184
          tmp___2 = maxLoc(fpIN);
#line 184
          tmp___3 = maxLines(tmp___2);
          }
#line 184
          if (! (count <= tmp___3)) {
#line 184
            goto while_break;
          }
        } else {
#line 184
          goto while_break;
        }
        {
#line 186
        outline(fpIN, count);
#line 184
        count ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 191
      mvwprintw(windows->cur_address, 0, 0, "%s", "00000000");
#line 192
      wmove(windows->hex, 0, 0);
      }
    }
    {
#line 198
    refreshall(windows);
#line 199
    wnoutrefresh(windows->cur_address);
#line 201
    wnoutrefresh(windows->hex);
#line 202
    doupdate();
    }
  }
#line 204
  return;
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/screen.c"
void refreshall(WINS *win ) 
{ 


  {
  {
#line 211
  slk_noutrefresh();
#line 212
  wnoutrefresh(win->hex_outline);
#line 213
  wnoutrefresh(win->ascii_outline);
#line 214
  wnoutrefresh(win->scrollbar);
#line 215
  wnoutrefresh(win->ascii);
#line 216
  wnoutrefresh(win->address);
#line 217
  wnoutrefresh(win->hex);
  }
#line 218
  return;
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/screen.c"
WINDOW *drawbox(int y , int x , int height , int width ) 
{ 
  WINDOW *win ;

  {
  {
#line 229
  win = newwin(height, width, y, x);
#line 231
  wborder(win, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0, (chtype )0,
          (chtype )0, (chtype )0);
  }
#line 233
  return (win);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/screen.c"
void scrollbar(WINS *windows___0 , int cl , long maxLines___0 ) 
{ 
  float x ;
  float percent ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 248
  if ((unsigned long )fpIN != (unsigned long )((void *)0)) {
    {
#line 249
    tmp = maxLoc(fpIN);
#line 249
    percent = (float )cl / (float )tmp;
    }
  } else {
#line 251
    percent = (float )0.0;
  }
#line 253
  x = (float )((int )(percent * (float )LINES));
#line 254
  if (x < (float )1) {
#line 254
    x = (float )1;
  } else {
#line 254
    x = x;
  }
#line 255
  if (x >= (float )(LINES - 1)) {
#line 255
    x = (float )(LINES - 2);
#line 255
    x = x;
  } else {
#line 255
    x = x;
  }
  {
#line 257
  wattr_on(windows___0->scrollbar, 1UL << 18, (void *)0);
#line 258
  wattr_on(windows___0->scrollbar, 1UL << 18, (void *)0);
#line 259
  tmp___0 = wmove(windows___0->scrollbar, (int )x, 0);
  }
#line 259
  if (! (tmp___0 == -1)) {
    {
#line 259
    waddch(windows___0->scrollbar, (chtype const   )acs_map[(unsigned char )'`']);
    }
  }
  {
#line 260
  wattr_off(windows___0->scrollbar, 1UL << 18, (void *)0);
#line 261
  wnoutrefresh(windows___0->scrollbar);
#line 262
  tmp___1 = wmove(windows___0->scrollbar, (int )x, 0);
  }
#line 262
  if (! (tmp___1 == -1)) {
    {
#line 262
    waddch(windows___0->scrollbar, (chtype const   )acs_map[(unsigned char )'a']);
    }
  }
#line 263
  return;
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/screen.c"
void printHelp(WINS *win ) 
{ 
  WINDOW *ctrl ;
  WINDOW *help ;
  WINDOW *small ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 273
  ctrl = newwin(LINES - 2, 9, 1, 1);
#line 273
  help = newwin(LINES - 2, hex_win_width, 1, 10);
#line 273
  small = newwin(LINES - 2, ascii_win_width, 1, hex_outline_width + 2);
  }
#line 277
  if (LINES < 18) {
    {
#line 279
    mvwprintw(help, 0, 0, "Screen too small to display help");
#line 280
    wmove(help, 0, 0);
    }
  } else
#line 277
  if (COLS < 78) {
    {
#line 279
    mvwprintw(help, 0, 0, "Screen too small to display help");
#line 280
    wmove(help, 0, 0);
    }
  } else {
    {
#line 284
    wmove(ctrl, 0, 0);
#line 285
    mvwprintw(ctrl, 0, 1, "Ctrl Key");
#line 286
    mvwprintw(ctrl, 2, 1, "CTRL+?");
#line 287
    mvwprintw(ctrl, 3, 1, "CTRL+S");
#line 288
    mvwprintw(ctrl, 4, 1, "CTRL+O");
#line 289
    mvwprintw(ctrl, 5, 1, "CTRL+G");
#line 290
    mvwprintw(ctrl, 6, 1, "CTRL+F");
#line 291
    mvwprintw(ctrl, 7, 1, "CTRL+A");
#line 292
    mvwprintw(ctrl, 8, 1, "TAB");
#line 293
    mvwprintw(ctrl, 9, 1, "CTRL+Q");
#line 294
    mvwprintw(ctrl, 11, 1, "CTRL+U");
#line 295
    mvwprintw(ctrl, 12, 1, "CTRL+D");
#line 296
    mvwprintw(ctrl, 13, 1, "CTRL+Z");
#line 297
    mvwprintw(ctrl, 14, 1, "CTRL+T");
#line 298
    mvwprintw(ctrl, 15, 1, "CTRL+B");
#line 300
    mvwprintw(small, 0, 1, "Function Keys");
#line 301
    mvwprintw(small, 2, 1, "Help     = F1");
#line 302
    mvwprintw(small, 3, 1, "Save     = F2");
#line 303
    mvwprintw(small, 4, 1, "Open     = F3");
#line 304
    mvwprintw(small, 5, 1, "Goto     = F4");
#line 305
    mvwprintw(small, 6, 1, "Find     = F5");
#line 306
    mvwprintw(small, 7, 1, "HexAdres = F6");
#line 307
    mvwprintw(small, 8, 1, "Hex Edit = F7");
#line 308
    mvwprintw(small, 9, 1, "Quit     = F8");
#line 309
    mvwprintw(small, 11, 1, "Page up  = PGUP");
#line 310
    mvwprintw(small, 12, 1, "Page down= PGDN");
#line 312
    mvwprintw(help, 0, 10, "HexCurse Keyboard Commands");
#line 313
    mvwprintw(help, 2, 2, "Help     - you are reading it now");
#line 314
    mvwprintw(help, 3, 2, "Save     - saves the current file open");
#line 315
    mvwprintw(help, 4, 2, "Open     - opens a new file");
#line 316
    mvwprintw(help, 5, 2, "Goto     - goto a specified address");
#line 317
    mvwprintw(help, 6, 2, "Find     - search for a hex/ascii value");
#line 318
    mvwprintw(help, 7, 2, "HexAdres - toggle between hex/decimal address");
#line 319
    mvwprintw(help, 8, 2, "Hex Edit - toggle between hex/ASCII windows");
#line 320
    mvwprintw(help, 9, 2, "Quit     - exit out of the program");
#line 321
    mvwprintw(help, 11, 2, "Page up  - scrolls one screen up");
#line 322
    mvwprintw(help, 12, 2, "Page down- scrolls one screen down");
#line 323
    mvwprintw(help, 13, 2, "Undo     - reverts last modification");
#line 324
    mvwprintw(help, 14, 2, "Home     - returns to the top of the file");
#line 325
    mvwprintw(help, 15, 2, "End      - jumps to the bottom of the file");
#line 326
    mvwprintw(help, 17, 12, "Press enter to continue");
    }
  }
  {
#line 329
  wnoutrefresh(ctrl);
#line 330
  wnoutrefresh(help);
#line 331
  wnoutrefresh(small);
#line 332
  doupdate();
#line 334
  wgetch(ctrl);
#line 336
  delwin(ctrl);
#line 337
  delwin(help);
#line 338
  delwin(small);
  }
#line 340
  if (win->hex) {
#line 340
    tmp = (int )(win->hex)->_maxy + 1;
  } else {
#line 340
    tmp = -1;
  }
  {
#line 340
  wredrawln(win->hex, 0, tmp);
  }
#line 341
  if (win->ascii) {
#line 341
    tmp___0 = (int )(win->ascii)->_maxy + 1;
  } else {
#line 341
    tmp___0 = -1;
  }
  {
#line 341
  wredrawln(win->ascii, 0, tmp___0);
  }
#line 342
  if (win->address) {
#line 342
    tmp___1 = (int )(win->address)->_maxy + 1;
  } else {
#line 342
    tmp___1 = -1;
  }
  {
#line 342
  wredrawln(win->address, 0, tmp___1);
#line 344
  wnoutrefresh(win->hex);
#line 345
  wnoutrefresh(win->ascii);
#line 346
  wnoutrefresh(win->address);
#line 347
  doupdate();
  }
#line 349
  return;
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/screen.c"
void winscroll(WINS *windows___0 , WINDOW *win , int n , int currentLine___0 ) 
{ 
  int row ;
  int col ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 359
  if (win) {
#line 359
    row = (int )win->_cury;
  } else {
#line 359
    row = -1;
  }
#line 359
  if (win) {
#line 359
    col = (int )win->_curx;
  } else {
#line 359
    col = -1;
  }
  {
#line 361
  scrollok(windows___0->hex, (_Bool)1);
#line 362
  scrollok(windows___0->ascii, (_Bool)1);
#line 363
  scrollok(windows___0->address, (_Bool)1);
#line 365
  wscrl(windows___0->hex, n);
#line 366
  wscrl(windows___0->ascii, n);
#line 367
  wscrl(windows___0->address, n);
#line 369
  scrollok(windows___0->hex, (_Bool)0);
#line 370
  scrollok(windows___0->ascii, (_Bool)0);
#line 371
  scrollok(windows___0->address, (_Bool)0);
  }
#line 373
  if (n == 1) {
#line 373
    tmp = MAXY;
  } else {
#line 373
    tmp = 0;
  }
  {
#line 373
  wmove(windows___0->hex, tmp, 0);
  }
#line 374
  if (n == 1) {
#line 374
    tmp___0 = MAXY;
  } else {
#line 374
    tmp___0 = 0;
  }
  {
#line 374
  wmove(windows___0->ascii, tmp___0, 0);
  }
#line 375
  if (n == 1) {
#line 375
    tmp___1 = MAXY;
  } else {
#line 375
    tmp___1 = 0;
  }
  {
#line 375
  wmove(windows___0->address, tmp___1, 0);
#line 377
  outline(fpIN, currentLine___0);
#line 379
  wnoutrefresh(windows___0->hex);
#line 380
  wnoutrefresh(windows___0->ascii);
#line 381
  wnoutrefresh(windows___0->address);
#line 383
  wmove(win, row, col);
  }
#line 384
  return;
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/screen.c"
void clearScreen(WINS *win ) 
{ 


  {
  {
#line 391
  wclear(win->hex);
#line 392
  wclear(win->ascii);
#line 393
  wclear(win->address);
#line 394
  wclear(win->scrollbar);
#line 395
  wclear(win->hex_outline);
#line 396
  wclear(win->ascii_outline);
#line 397
  wclear(win->cur_address);
#line 398
  refreshall(win);
#line 399
  doupdate();
  }
#line 400
  return;
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/screen.c"
int quitProgram(int notChanged , short ch ) 
{ 
  short str ;

  {
#line 415
  if ((int )ch == 272) {
#line 415
    goto _L;
  } else
#line 415
  if ((int )ch == 17) {
#line 415
    goto _L;
  } else
#line 415
  if ((int )ch == 24) {
    _L: /* CIL Label */ 
#line 417
    if (! notChanged) {
      {
#line 420
      str = questionWin((char *)"Do you want to save changes? (y/n)");
      }
#line 422
      if ((int )str == 89) {
#line 423
        return (2);
      } else
#line 422
      if ((int )str == 121) {
#line 423
        return (2);
      } else
#line 424
      if ((int )str != 78) {
#line 424
        if ((int )str != 110) {
#line 425
          return (0);
        }
      }
    }
#line 428
    return (1);
  } else {
#line 431
    return (0);
  }
}
}
#line 444 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/screen.c"
void popupWin(char *msg , int time ) 
{ 
  WINDOW *tmpwin ;
  int y ;
  int len ;
  size_t tmp ;
  int x ;

  {
  {
#line 448
  y = LINES / 2 - 3;
#line 448
  tmp = strlen((char const   *)msg);
#line 448
  len = (int )tmp;
#line 448
  x = (COLS - len) / 2;
  }
#line 452
  if (y < 2) {
#line 452
    y = 2;
  } else {
#line 452
    y = y;
  }
#line 453
  if (! time) {
#line 453
    time = 2;
  } else {
#line 453
    time = time;
  }
  {
#line 455
  tmpwin = drawbox(y, x, 5, len + 6);
#line 457
  keypad(tmpwin, (_Bool)1);
#line 459
  mvwprintw(tmpwin, 2, 3, (char const   *)msg);
#line 460
  wmove(tmpwin, 2, len + 4);
#line 461
  wrefresh(tmpwin);
  }
#line 463
  if (time == -1) {
    {
#line 464
    wgetch(tmpwin);
    }
  } else {
    {
#line 466
    sleep((unsigned int )time);
    }
  }
  {
#line 468
  delwin(tmpwin);
#line 470
  wtouchln(windows->hex, y - 1, 5, 1);
#line 471
  wtouchln(windows->ascii, y - 1, 5, 1);
#line 472
  wtouchln(windows->address, y - 1, 5, 1);
#line 473
  wtouchln(windows->hex_outline, y, 5, 1);
#line 474
  wtouchln(windows->ascii_outline, y, 5, 1);
#line 475
  wtouchln(windows->scrollbar, y, 5, 1);
#line 477
  refreshall(windows);
#line 479
  doupdate();
  }
#line 480
  return;
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/screen.c"
short questionWin(char *msg ) 
{ 
  WINDOW *tmpwin ;
  short ch ;
  int y ;
  int len ;
  size_t tmp ;
  int x ;
  int tmp___0 ;

  {
  {
#line 492
  y = LINES / 2 - 3;
#line 492
  tmp = strlen((char const   *)msg);
#line 492
  len = (int )tmp;
#line 492
  x = (COLS - len) / 2;
  }
#line 496
  if (y < 2) {
#line 496
    y = 2;
  } else {
#line 496
    y = y;
  }
  {
#line 498
  tmpwin = drawbox(y, x, 5, len + 6);
#line 500
  mvwprintw(tmpwin, 2, 3, (char const   *)msg);
#line 501
  wmove(tmpwin, 2, len + 4);
#line 502
  wrefresh(tmpwin);
#line 504
  tmp___0 = wgetch(tmpwin);
#line 504
  ch = (short )tmp___0;
#line 506
  delwin(tmpwin);
#line 508
  wtouchln(windows->hex, y - 1, 5, 1);
#line 509
  wtouchln(windows->ascii, y - 1, 5, 1);
#line 510
  wtouchln(windows->address, y - 1, 5, 1);
#line 511
  wtouchln(windows->hex_outline, y, 5, 1);
#line 512
  wtouchln(windows->ascii_outline, y, 5, 1);
#line 513
  wtouchln(windows->scrollbar, y, 5, 1);
#line 515
  refreshall(windows);
#line 517
  doupdate();
  }
#line 519
  return (ch);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 459
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 608 "/usr/include/curses.h"
extern int echo(void) ;
#line 803
extern int wclrtoeol(WINDOW * ) ;
#line 826
extern int wprintw(WINDOW * , char const   *  , ...) ;
#line 81 "../include/hex.h"
long maxlines  ;
#line 82 "../include/hex.h"
long currentLine  ;
#line 83 "../include/hex.h"
_Bool editHex  ;
#line 84
_Bool printHex ;
#line 85 "../include/hex.h"
long LastLoc  ;
#line 86 "../include/hex.h"
int SIZE_CH  ;
#line 87
_Bool USE_EBCDIC ;
#line 88
char EBCDIC[256] ;
#line 119
int wacceptch(WINS *win , long len , char *fpINfilename___0 , char *fpOUTfilename___0 ) ;
#line 120
void restoreBorder(WINS *win ) ;
#line 121
char *inputLine(WINDOW *win , int line , int col ) ;
#line 128
int openfile(WINS *win , char *fpINfilename___0 ) ;
#line 129
void savefile(WINS *win , char *fpINfilename___0 , char *fpOUTfilename___0 ) ;
#line 130
int hexSearch(FILE *fp , int *ch , int startfp , int length ) ;
#line 131
int gotoLine(FILE *fp , int currLoc , int gotoLoc , int maxlines___0 , WINDOW *win ) ;
#line 132
int getLocVal(long loc ) ;
#line 133
_Bool inHexList(long loc ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/acceptch.c"
int wacceptch(WINS *win , long len , char *fpINfilename___0 , char *fpOUTfilename___0 ) 
{ 
  int row ;
  int col ;
  int count ;
  int val ;
  int tmpval ;
  int ch[17] ;
  int eol ;
  int save ;
  int lastRow ;
  int lastCol ;
  int prevVal ;
  int curVal ;
  int tmp ;
  long cl ;
  long gotoLoc ;
  long lastLine ;
  long currentLine___0 ;
  char *gotoLocStr ;
  char *temp ;
  char *tmpstr ;
  char SearchStr[13] ;
  short key ;
  WINDOW *Winds ;
  hexStack *stack ;
  hexStack *tmpStack ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  unsigned short const   **tmp___14 ;
  unsigned short const   **tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  WINDOW *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  size_t tmp___34 ;
  size_t tmp___35 ;
  char const   *tmp___36 ;
  int tmp___37 ;
  size_t tmp___39 ;
  size_t tmp___40 ;
  size_t tmp___41 ;
  size_t tmp___43 ;
  size_t tmp___44 ;
  size_t tmp___45 ;
  unsigned short const   **tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  char const   *tmp___51 ;
  char const   *tmp___52 ;
  char const   *tmp___53 ;
  char const   *tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  WINDOW *tmp___58 ;
  WINDOW *tmp___59 ;
  int tmp___61 ;
  unsigned short const   **tmp___62 ;
  int tmp___63 ;
  char const   *tmp___64 ;
  int tmp___65 ;
  WINDOW *tmp___66 ;
  WINDOW *tmp___67 ;
  WINDOW *tmp___68 ;
  int tmp___70 ;
  unsigned short const   **tmp___71 ;
  int tmp___72 ;
  char const   *tmp___73 ;
  WINDOW *tmp___74 ;
  WINDOW *tmp___75 ;
  WINDOW *tmp___76 ;
  WINDOW *tmp___77 ;
  int tmp___78 ;
  _Bool tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___84 ;
  unsigned short const   **tmp___85 ;
  int tmp___86 ;
  int tmp___88 ;
  unsigned short const   **tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  WINDOW *tmp___92 ;
  WINDOW *tmp___93 ;
  chtype tmp___96 ;
  int tmp___97 ;
  _Bool tmp___98 ;
  WINDOW *tmp___99 ;
  int tmp___101 ;
  unsigned short const   **tmp___102 ;
  int tmp___103 ;
  char const   *tmp___104 ;
  int tmp___105 ;
  WINDOW *tmp___106 ;
  WINDOW *tmp___107 ;
  WINDOW *tmp___108 ;
  WINDOW *tmp___109 ;
  WINDOW *tmp___110 ;
  WINDOW *tmp___111 ;
  int tmp___112 ;
  _Bool tmp___113 ;
  int tmp___114 ;
  int tmp___116 ;
  unsigned short const   **tmp___117 ;
  int tmp___118 ;
  char const   *tmp___119 ;
  int tmp___120 ;
  WINDOW *tmp___121 ;
  WINDOW *tmp___122 ;
  WINDOW *tmp___123 ;
  WINDOW *tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  char const   *tmp___127 ;
  int tmp___128 ;
  int tmp___129 ;
  int tmp___130 ;

  {
  {
#line 34
  row = 0;
#line 34
  col = 0;
#line 34
  eol = BASE * 3 - 1;
#line 34
  save = 0;
#line 34
  lastRow = 0;
#line 34
  lastCol = 0;
#line 42
  gotoLoc = 0L;
#line 42
  lastLine = 0L;
#line 42
  currentLine___0 = 0L;
#line 56
  editHex = (_Bool)1;
#line 58
  SIZE_CH = 0;
#line 59
  Winds = win->hex;
#line 60
  tmp___0 = maxLines((int )len);
#line 60
  maxlines = (long )tmp___0;
#line 63
  stack = (hexStack *)((void *)0);
#line 64
  tmp___1 = calloc((size_t )81, sizeof(char ));
#line 64
  temp = (char *)tmp___1;
  }
#line 66
  if (fpIN) {
    {
#line 68
    curVal = getLocVal(0L);
#line 68
    prevVal = curVal;
#line 69
    wattr_on(win->ascii, 1UL << 17, (void *)0);
#line 70
    mvwprintw(win->ascii, 0, 0, "%c", curVal);
#line 71
    wmove(win->hex, 0, 0);
    }
#line 72
    if (win->ascii) {
#line 72
      (win->ascii)->_attrs = 0UL;
    }
    {
#line 73
    wnoutrefresh(win->ascii);
#line 74
    doupdate();
    }
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 78
    tmp___129 = wgetch(Winds);
#line 78
    key = (short )tmp___129;
    }
#line 78
    if ((unsigned long )stack == (unsigned long )((void *)0)) {
#line 78
      tmp___130 = 1;
    } else {
#line 78
      tmp___130 = 0;
    }
    {
#line 78
    save = quitProgram(tmp___130, key);
    }
#line 78
    if (save) {
#line 78
      goto while_break;
    }
#line 80
    lastRow = row;
#line 81
    lastCol = col;
#line 82
    if (Winds) {
#line 82
      row = (int )Winds->_cury;
    } else {
#line 82
      row = -1;
    }
#line 82
    if (Winds) {
#line 82
      col = (int )Winds->_curx;
    } else {
#line 82
      col = -1;
    }
#line 84
    if (SIZE_CH) {
#line 86
      col = 0;
#line 86
      row = col;
#line 86
      cl = (long )row;
#line 87
      eol = BASE * 3 - 1;
#line 88
      editHex = (_Bool)1;
#line 89
      Winds = win->hex;
#line 91
      currentLine___0 = 0L;
#line 93
      SIZE_CH = 0;
    }
#line 96
    if (COLS < 70) {
#line 97
      goto while_continue;
    } else
#line 96
    if (LINES < 7) {
#line 97
      goto while_continue;
    }
#line 100
    if (! fpIN) {
#line 100
      if ((int )key != 15) {
#line 100
        if ((int )key != 267) {
#line 100
          if ((int )key != 8) {
#line 100
            if ((int )key != 265) {
#line 102
              goto while_continue;
            }
          }
        }
      }
    }
    {
#line 107
    if ((int )key == 259) {
#line 107
      goto case_259;
    }
#line 118
    if ((int )key == 258) {
#line 118
      goto case_258;
    }
#line 133
    if ((int )key == 260) {
#line 133
      goto case_260;
    }
#line 133
    if ((int )key == 263) {
#line 133
      goto case_260;
    }
#line 221
    if ((int )key == 261) {
#line 221
      goto case_261;
    }
#line 254
    if ((int )key == 339) {
#line 254
      goto case_339;
    }
#line 254
    if ((int )key == 21) {
#line 254
      goto case_339;
    }
#line 264
    if ((int )key == 338) {
#line 264
      goto case_338;
    }
#line 264
    if ((int )key == 4) {
#line 264
      goto case_338;
    }
#line 344
    if ((int )key == 262) {
#line 344
      goto case_262;
    }
#line 344
    if ((int )key == 20) {
#line 344
      goto case_262;
    }
#line 362
    if ((int )key == 360) {
#line 362
      goto case_360;
    }
#line 362
    if ((int )key == 2) {
#line 362
      goto case_360;
    }
#line 384
    if ((int )key == 267) {
#line 384
      goto case_267;
    }
#line 384
    if ((int )key == 15) {
#line 384
      goto case_267;
    }
#line 397
    if ((int )key == 266) {
#line 397
      goto case_266;
    }
#line 397
    if ((int )key == 19) {
#line 397
      goto case_266;
    }
#line 402
    if ((int )key == 269) {
#line 402
      goto case_269;
    }
#line 402
    if ((int )key == 6) {
#line 402
      goto case_269;
    }
#line 514
    if ((int )key == 270) {
#line 514
      goto case_270;
    }
#line 514
    if ((int )key == 1) {
#line 514
      goto case_270;
    }
#line 539
    if ((int )key == 268) {
#line 539
      goto case_268;
    }
#line 539
    if ((int )key == 7) {
#line 539
      goto case_268;
    }
#line 576
    if ((int )key == 271) {
#line 576
      goto case_271;
    }
#line 576
    if ((int )key == 9) {
#line 576
      goto case_271;
    }
#line 619
    if ((int )key == 265) {
#line 619
      goto case_265;
    }
#line 619
    if ((int )key == 8) {
#line 619
      goto case_265;
    }
#line 619
    if ((int )key == 31) {
#line 619
      goto case_265;
    }
#line 627
    if ((int )key == 26) {
#line 627
      goto case_26;
    }
#line 153
    goto switch_default;
    case_259: /* CIL Label */ 
#line 108
    if (currentLine___0 > 0L) {
      {
#line 110
      currentLine___0 --;
#line 111
      row --;
#line 111
      wmove(Winds, row, col);
      }
    }
#line 114
    if (currentLine___0 >= 0L) {
#line 114
      if (row < 0) {
        {
#line 115
        winscroll(win, Winds, -1, (int )currentLine___0);
        }
      }
    }
#line 116
    goto switch_break;
    case_258: /* CIL Label */ 
#line 119
    if (editHex) {
#line 119
      tmp___2 = 3;
    } else {
#line 119
      tmp___2 = 1;
    }
#line 119
    if ((currentLine___0 + 1L) * (long )BASE + (long )(col / tmp___2) < len) {
#line 121
      if (currentLine___0 < maxlines) {
        {
#line 123
        row ++;
#line 123
        wmove(Winds, row, col);
#line 124
        currentLine___0 ++;
        }
      }
#line 127
      if (row > MAXY) {
#line 127
        if (currentLine___0 <= maxlines) {
          {
#line 128
          winscroll(win, Winds, 1, (int )currentLine___0);
          }
        }
      }
    }
#line 130
    goto switch_break;
    case_260: /* CIL Label */ 
    case_263: /* CIL Label */ 
#line 134
    if (col == 0) {
#line 134
      if (currentLine___0 != 0L) {
#line 136
        currentLine___0 --;
#line 137
        if (row == 0) {
          {
#line 139
          winscroll(win, Winds, -1, (int )currentLine___0);
#line 140
          row ++;
          }
        }
        {
#line 142
        row --;
#line 142
        wmove(Winds, row, eol - 1);
        }
      }
    }
    {
#line 145
    col --;
#line 145
    wmove(Winds, row, col);
    }
#line 146
    if (editHex) {
#line 148
      if ((col + 1) % 3 == 0) {
        {
#line 149
        col --;
#line 149
        wmove(Winds, row, col);
        }
      }
    }
#line 151
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 155
    tmp___14 = __ctype_b_loc();
    }
#line 155
    if ((int const   )*(*tmp___14 + (int )key) & 16384) {
#line 155
      if (editHex) {
        {
#line 155
        tmp___15 = __ctype_b_loc();
        }
#line 155
        if ((int const   )*(*tmp___15 + (int )key) & 4096) {
#line 155
          goto _L___0;
        } else {
#line 155
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 155
      if (! editHex) {
        _L___0: /* CIL Label */ 
#line 157
        if (editHex) {
#line 157
          tmp___10 = 3;
        } else {
#line 157
          tmp___10 = 1;
        }
#line 157
        cl = currentLine___0 * (long )BASE + (long )(col / tmp___10);
#line 157
        if (cl < len) {
          {
#line 161
          val = searchList(head, (int )cl);
          }
#line 161
          if (val == -1) {
            {
#line 163
            fseek(fpIN, cl, 0);
#line 164
            val = fgetc(fpIN);
            }
          }
          {
#line 167
          wattr_on(win->hex, 1UL << 21, (void *)0);
#line 168
          wattr_on(win->ascii, 1UL << 21, (void *)0);
          }
#line 170
          if (editHex) {
            {
#line 170
            tmp___3 = toupper((int )key);
#line 170
            tmp___4 = tmp___3;
            }
          } else {
#line 170
            tmp___4 = (int )key;
          }
          {
#line 170
          wprintw(Winds, "%c", tmp___4);
#line 172
          tmpval = val;
          }
#line 174
          if (editHex) {
#line 176
            if ((int )key >= 65) {
#line 176
              if ((int )key <= 70) {
#line 177
                key = (short )((int )key - 7);
              } else {
#line 176
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
#line 178
            if ((int )key >= 97) {
#line 178
              if ((int )key <= 102) {
#line 179
                key = (short )((int )key - 39);
              }
            }
#line 180
            key = (short )((int )key - 48);
#line 182
            if (col % 3 == 0) {
#line 183
              val = (int )key * 16 + val % 16;
            } else
#line 184
            if (col % 3 == 1) {
#line 185
              val = (val - (val + 16) % 16) + (int )key;
            }
          } else {
#line 188
            val = (int )key;
          }
#line 190
          if (editHex) {
            {
#line 192
            wmove(win->ascii, row, col / 3);
            }
#line 193
            if (USE_EBCDIC) {
#line 193
              tmp___8 = (int )EBCDIC[val];
            } else {
              {
#line 193
              tmp___7 = __ctype_b_loc();
              }
#line 193
              if ((int const   )*(*tmp___7 + val) & 16384) {
#line 193
                tmp___6 = val;
              } else {
#line 193
                tmp___6 = 46;
              }
#line 193
              tmp___8 = tmp___6;
            }
            {
#line 193
            wprintw(win->ascii, "%c", tmp___8);
#line 195
            wmove(win->hex, row, col);
#line 196
            wrefresh(win->ascii);
            }
          } else {
            {
#line 200
            wmove(win->hex, row, col * 3);
#line 201
            wprintw(win->hex, "%02X", val);
#line 202
            wmove(win->ascii, row, col);
#line 203
            wrefresh(win->hex);
            }
          }
#line 206
          if (win->hex) {
#line 206
            (win->hex)->_attrs = 0UL;
          }
#line 207
          if (win->ascii) {
#line 207
            (win->ascii)->_attrs = 0UL;
          }
          {
#line 210
          head = insertItem(head, (int )cl, val);
#line 212
          tmp___9 = calloc((size_t )1, sizeof(hexStack ));
#line 212
          tmpStack = (hexStack *)tmp___9;
#line 213
          tmpStack->currentLoc = cl;
#line 214
          tmpStack->llist = head;
#line 215
          tmpStack->savedVal = tmpval;
#line 216
          tmpStack->prev = (struct Stack *)((void *)0);
#line 217
          pushStack(& stack, tmpStack);
          }
        }
        case_261: /* CIL Label */ 
#line 222
        if (editHex) {
#line 222
          tmp___12 = 3;
        } else {
#line 222
          tmp___12 = 1;
        }
#line 222
        if (currentLine___0 * (long )BASE + (long )(col / tmp___12) < len) {
          {
#line 224
          col ++;
#line 224
          wmove(Winds, row, col);
          }
#line 225
          if (editHex) {
#line 225
            tmp___11 = 3;
          } else {
#line 225
            tmp___11 = 1;
          }
#line 225
          if (currentLine___0 * (long )BASE + (long )(col / tmp___11) == len) {
            {
#line 226
            col --;
#line 226
            wmove(Winds, row, col);
            }
          }
#line 228
          if (col == eol) {
#line 228
            if (currentLine___0 < maxlines) {
#line 230
              currentLine___0 ++;
#line 231
              if (row < MAXY) {
                {
#line 232
                col = 0;
#line 233
                row ++;
#line 233
                wmove(Winds, row, col);
                }
              } else {
                {
#line 237
                winscroll(win, Winds, 1, (int )currentLine___0);
#line 238
                wmove(Winds, row, 0);
                }
              }
            }
          }
#line 241
          if (editHex) {
#line 242
            if ((col + 1) % 3 == 0) {
              {
#line 243
              col ++;
#line 243
              wmove(Winds, row, col);
              }
            }
          }
        }
#line 248
        if (editHex) {
#line 248
          tmp___13 = 3;
        } else {
#line 248
          tmp___13 = 1;
        }
#line 248
        if (currentLine___0 * (long )BASE + (long )(col / tmp___13) == len) {
          {
#line 249
          col -= 2;
#line 249
          wmove(Winds, row, col);
          }
        }
      }
    }
#line 251
    goto switch_break;
    case_339: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 255
    if (currentLine___0 == (long )row) {
      {
#line 256
      currentLine___0 = 0L;
#line 257
      wmove(Winds, 0, 0);
      }
#line 258
      goto switch_break;
    } else {
#line 261
      currentLine___0 -= (long )(2 * MAXY);
    }
    case_338: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 265
    if (Winds) {
#line 265
      row = (int )Winds->_cury;
    } else {
#line 265
      row = -1;
    }
#line 265
    if (Winds) {
#line 265
      col = (int )Winds->_curx;
    } else {
#line 265
      col = -1;
    }
#line 267
    if (maxlines - currentLine___0 <= (long )MAXY) {
      {
#line 269
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 269
        if (editHex) {
#line 269
          tmp___16 = 3;
        } else {
#line 269
          tmp___16 = 1;
        }
#line 269
        if (! ((currentLine___0 + 1L) * (long )BASE + (long )(col / tmp___16) < len)) {
#line 269
          goto while_break___0;
        }
#line 271
        if (currentLine___0 < maxlines) {
#line 273
          row ++;
#line 274
          currentLine___0 ++;
        }
#line 277
        if (row > MAXY) {
#line 277
          if (currentLine___0 <= maxlines) {
            {
#line 279
            winscroll(win, Winds, 1, (int )currentLine___0);
#line 280
            row = MAXY;
            }
#line 281
            if (editHex) {
#line 281
              col = (int )(3L * (len % (long )BASE - 1L));
            } else {
#line 281
              col = (int )(len % (long )BASE - 1L);
            }
#line 282
            if (col < 0) {
#line 283
              if (editHex) {
#line 283
                col = 3 * (BASE - 1);
              } else {
#line 283
                col = BASE - 1;
              }
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 287
      if (editHex) {
#line 287
        tmp___17 = 3;
      } else {
#line 287
        tmp___17 = 1;
      }
#line 287
      if (len - (currentLine___0 * (long )BASE + (long )(col / tmp___17)) <= (long )BASE) {
#line 287
        if (currentLine___0 < maxlines) {
#line 287
          if (row >= MAXY) {
            {
#line 289
            currentLine___0 ++;
#line 289
            winscroll(win, Winds, 1, (int )currentLine___0);
            }
          }
        }
      }
#line 291
      row = (int )((long )row + (maxlines - currentLine___0));
#line 292
      currentLine___0 = maxlines;
#line 294
      if (editHex) {
#line 294
        col = (int )(3L * (len % (long )BASE - 1L));
      } else {
#line 294
        col = (int )(len % (long )BASE - 1L);
      }
#line 295
      if (col < 0) {
#line 296
        if (editHex) {
#line 296
          col = 3 * (BASE - 1);
        } else {
#line 296
          col = BASE - 1;
        }
      }
      {
#line 298
      wmove(Winds, row, col);
      }
#line 300
      goto switch_break;
    }
#line 303
    currentLine___0 += (long )MAXY;
#line 305
    if (currentLine___0 > maxlines) {
#line 306
      currentLine___0 = maxlines;
    } else
#line 307
    if (currentLine___0 < 0L) {
#line 308
      currentLine___0 = 0L;
    }
#line 310
    val = (int )(currentLine___0 - (long )row);
#line 311
    if (val < 0) {
#line 313
      val = 0;
#line 313
      row = val;
#line 314
      if (editHex) {
#line 314
        tmp___18 = 3;
      } else {
#line 314
        tmp___18 = 1;
      }
#line 314
      if (editHex) {
#line 314
        tmp___19 = 3;
      } else {
#line 314
        tmp___19 = 1;
      }
#line 314
      if (currentLine___0 * (long )BASE + (long )(col / tmp___18) != (long )(row * BASE + col / tmp___19)) {
#line 316
        row = (int )currentLine___0;
      }
    }
    {
#line 319
    wmove(win->hex, 0, 0);
#line 320
    wmove(win->ascii, 0, 0);
#line 321
    wmove(win->address, 0, 0);
#line 323
    count = 0;
    }
    {
#line 323
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 323
      if (count <= MAXY) {
#line 323
        if (! ((long )(count + val) <= maxlines)) {
#line 323
          goto while_break___1;
        }
      } else {
#line 323
        goto while_break___1;
      }
      {
#line 325
      outline(fpIN, count + val);
#line 323
      count ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 327
    if (count < MAXY) {
      {
#line 328
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 328
        if (! (count <= MAXY)) {
#line 328
          goto while_break___2;
        }
        {
#line 329
        wmove(win->address, count, 0);
#line 330
        wclrtoeol(win->address);
#line 331
        wmove(win->hex, count, 0);
#line 332
        wclrtoeol(win->hex);
#line 333
        wmove(win->ascii, count, 0);
#line 334
        wclrtoeol(win->ascii);
#line 328
        count ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 337
    wmove(Winds, row, col);
#line 338
    wnoutrefresh(win->ascii);
#line 339
    wnoutrefresh(win->address);
#line 340
    wnoutrefresh(win->hex);
    }
#line 341
    goto switch_break;
    case_262: /* CIL Label */ 
    case_20: /* CIL Label */ 
    {
#line 345
    col = 0;
#line 345
    row = col;
#line 345
    cl = (long )row;
#line 345
    currentLine___0 = cl;
#line 346
    wmove(win->hex, 0, 0);
#line 347
    wmove(win->ascii, 0, 0);
#line 348
    wmove(win->address, 0, 0);
#line 350
    count = 0;
    }
    {
#line 350
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 350
      if (count <= MAXY) {
        {
#line 350
        tmp___20 = maxLoc(fpIN);
#line 350
        tmp___21 = maxLines(tmp___20);
        }
#line 350
        if (! (count <= tmp___21)) {
#line 350
          goto while_break___3;
        }
      } else {
#line 350
        goto while_break___3;
      }
      {
#line 352
      outline(fpIN, count);
#line 350
      count ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 354
    mvwprintw(windows->cur_address, 0, 0, "00000000");
    }
#line 355
    if (editHex) {
#line 355
      tmp___22 = win->hex;
    } else {
#line 355
      tmp___22 = win->ascii;
    }
    {
#line 355
    wmove(tmp___22, 0, 0);
#line 356
    wnoutrefresh(win->ascii);
#line 357
    wnoutrefresh(win->address);
#line 358
    wnoutrefresh(win->hex);
    }
#line 359
    goto switch_break;
    case_360: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 363
    if (editHex) {
#line 363
      tmp___23 = 3;
    } else {
#line 363
      tmp___23 = 1;
    }
    {
#line 363
    tmp___24 = maxLoc(fpIN);
    }
#line 363
    if (currentLine___0 * (long )BASE + (long )(col / tmp___23) == (long )(tmp___24 - 1)) {
#line 364
      goto switch_break;
    }
#line 367
    if (maxlines - currentLine___0 >= (long )MAXY) {
      {
#line 368
      tmp___25 = maxLoc(fpIN);
      }
#line 368
      if (len % (long )BASE) {
#line 368
        tmp___26 = MAXY;
      } else {
#line 368
        tmp___26 = MAXY + 1;
      }
#line 368
      if (editHex) {
#line 368
        tmp___27 = 3;
      } else {
#line 368
        tmp___27 = 1;
      }
      {
#line 368
      tmp___28 = gotoLine(fpIN, (int )(currentLine___0 * (long )BASE + (long )(col / tmp___27)),
                          tmp___25 - BASE * tmp___26, (int )maxlines, Winds);
#line 368
      currentLine___0 = (long )tmp___28;
      }
    }
#line 373
    if (Winds) {
#line 373
      row = (int )Winds->_cury;
    } else {
#line 373
      row = -1;
    }
#line 373
    if (Winds) {
#line 373
      col = (int )Winds->_curx;
    } else {
#line 373
      col = -1;
    }
    {
#line 374
    tmp___29 = maxLoc(fpIN);
    }
#line 374
    if (editHex) {
#line 374
      tmp___30 = 3;
    } else {
#line 374
      tmp___30 = 1;
    }
    {
#line 374
    tmp___31 = gotoLine(fpIN, (int )(currentLine___0 * (long )BASE + (long )(col / tmp___30)),
                        tmp___29 - 1, (int )maxlines, Winds);
#line 374
    currentLine___0 = (long )tmp___31;
#line 378
    wnoutrefresh(win->ascii);
#line 379
    wnoutrefresh(win->address);
#line 380
    wnoutrefresh(win->hex);
    }
#line 381
    goto switch_break;
    case_267: /* CIL Label */ 
    case_15: /* CIL Label */ 
    {
#line 387
    tmp___32 = openfile(win, fpINfilename___0);
    }
#line 387
    if (tmp___32) {
#line 389
      if (fpIN) {
        {
#line 390
        curVal = getLocVal(0L);
#line 390
        prevVal = curVal;
        }
      }
#line 392
      return (1);
    }
#line 394
    goto switch_break;
    case_266: /* CIL Label */ 
    case_19: /* CIL Label */ 
    {
#line 398
    savefile(win, fpINfilename___0, fpOUTfilename___0);
    }
#line 399
    goto switch_break;
    case_269: /* CIL Label */ 
    case_6: /* CIL Label */ 
    {
#line 405
    tmp___33 = strcmp((char const   *)fpINfilename___0, "");
    }
#line 405
    if (! tmp___33) {
      {
#line 407
      wmove(win->hex_outline, LINES - 1, 1);
#line 408
      wclrtoeol(win->hex_outline);
#line 409
      popupWin((char *)"No file loaded!", -1);
#line 410
      restoreBorder(win);
#line 411
      wrefresh(win->hex_outline);
      }
#line 412
      goto switch_break;
    }
#line 416
    if ((unsigned long )temp != (unsigned long )((void *)0)) {
      {
#line 418
      bzero((void *)(SearchStr), (size_t )13);
#line 419
      strcat((char */* __restrict  */)(SearchStr), (char const   */* __restrict  */)"(");
#line 420
      tmp___35 = strlen((char const   *)temp);
      }
#line 420
      if (tmp___35 <= 10UL) {
        {
#line 421
        tmp___34 = strlen((char const   *)temp);
#line 421
        strncat((char */* __restrict  */)(SearchStr), (char const   */* __restrict  */)temp,
                tmp___34);
        }
      } else {
        {
#line 424
        strncat((char */* __restrict  */)(SearchStr), (char const   */* __restrict  */)temp,
                (size_t )7);
#line 425
        strcat((char */* __restrict  */)(SearchStr), (char const   */* __restrict  */)"...");
        }
      }
      {
#line 427
      strcat((char */* __restrict  */)(SearchStr), (char const   */* __restrict  */)")");
      }
    }
    {
#line 430
    wmove(win->hex_outline, LINES - 1, 19);
#line 431
    wclrtoeol(win->hex_outline);
    }
#line 432
    if (editHex) {
#line 432
      tmp___36 = "hex";
    } else {
#line 432
      tmp___36 = "ascii";
    }
    {
#line 432
    mvwprintw(win->hex_outline, LINES - 1, 1, "Enter %s value %s: ", tmp___36, SearchStr);
#line 436
    echo();
    }
#line 439
    if (editHex) {
#line 439
      tmp___37 = 21;
    } else {
#line 439
      tmp___37 = 23;
    }
    {
#line 439
    tmp___41 = strlen((char const   *)temp);
    }
#line 439
    if (tmp___41 > 10UL) {
#line 439
      tmp___40 = (size_t )10;
    } else {
      {
#line 439
      tmp___39 = strlen((char const   *)temp);
#line 439
      tmp___40 = tmp___39;
      }
    }
    {
#line 439
    tmpstr = inputLine(win->hex_outline, LINES - 1, (int )((size_t )tmp___37 + tmp___40));
#line 442
    noecho();
#line 444
    wmove(win->hex_outline, LINES - 1, 1);
#line 445
    wclrtoeol(win->hex_outline);
#line 446
    mvwprintw(win->hex_outline, LINES - 1, 1, "Searching ...");
#line 447
    wrefresh(win->hex_outline);
#line 448
    doupdate();
    }
#line 450
    if ((int )*(tmpstr + 0) == 27) {
      {
#line 452
      restoreBorder(win);
#line 453
      wrefresh(win->hex_outline);
      }
#line 454
      goto switch_break;
    }
#line 457
    if ((int )*(tmpstr + 0) != 0) {
      {
#line 459
      bzero((void *)temp, (size_t )81);
#line 460
      tmp___45 = strlen((char const   *)tmpstr);
      }
#line 460
      if (tmp___45 > 80UL) {
#line 460
        tmp___44 = (size_t )80;
      } else {
        {
#line 460
        tmp___43 = strlen((char const   *)tmpstr);
#line 460
        tmp___44 = tmp___43;
        }
      }
      {
#line 460
      strncpy((char */* __restrict  */)temp, (char const   */* __restrict  */)tmpstr,
              tmp___44);
      }
    }
#line 464
    val = 0;
#line 466
    count = 0;
    {
#line 466
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 466
      if ((int )*(temp + count) != 0) {
#line 466
        if (! (count < 80)) {
#line 466
          goto while_break___4;
        }
      } else {
#line 466
        goto while_break___4;
      }
#line 467
      if (! editHex) {
#line 468
        ch[count] = (int )*(temp + count);
      } else {
        {
#line 471
        tmp___46 = __ctype_b_loc();
#line 471
        key = (short )*(temp + count);
        }
#line 471
        if ((int const   )*(*tmp___46 + (int )key) & 4096) {
#line 473
          if ((int )key >= 65) {
#line 473
            if ((int )key <= 70) {
#line 474
              key = (short )((int )key - 7);
            } else {
#line 473
              goto _L___2;
            }
          } else
          _L___2: /* CIL Label */ 
#line 475
          if ((int )key >= 97) {
#line 475
            if ((int )key <= 102) {
#line 476
              key = (short )((int )key - 39);
            }
          }
#line 477
          key = (short )((int )key - 48);
#line 479
          if (count % 2 == 0) {
#line 480
            tmp = (int )key * 16;
          } else {
#line 482
            ch[(count - 1) / 2] = tmp + (int )key;
          }
        } else {
#line 485
          val = -1;
        }
      }
#line 466
      count ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 487
    if (count % 2 > 0) {
#line 487
      if (editHex) {
#line 488
        ch[(count + 1) / 2] = tmp;
      }
    }
#line 490
    if (val != -1) {
#line 492
      if (editHex) {
#line 492
        tmp___47 = (count + 1) / 2;
      } else {
#line 492
        tmp___47 = count;
      }
#line 492
      if (editHex) {
#line 492
        tmp___48 = 3;
      } else {
#line 492
        tmp___48 = 1;
      }
      {
#line 492
      val = hexSearch(fpIN, ch, (int )(currentLine___0 * (long )BASE + (long )(col / tmp___48)),
                      tmp___47);
      }
    }
#line 495
    if (val == -1) {
      {
#line 497
      popupWin((char *)"Value not found!", -1);
#line 498
      restoreBorder(win);
#line 499
      wrefresh(win->hex_outline);
      }
    } else {
#line 503
      if (Winds) {
#line 503
        row = (int )Winds->_cury;
      } else {
#line 503
        row = -1;
      }
#line 503
      if (Winds) {
#line 503
        col = (int )Winds->_curx;
      } else {
#line 503
        col = -1;
      }
#line 505
      if (editHex) {
#line 505
        tmp___49 = 3;
      } else {
#line 505
        tmp___49 = 1;
      }
      {
#line 505
      tmp___50 = gotoLine(fpIN, (int )(currentLine___0 * (long )BASE + (long )(col / tmp___49)),
                          val, (int )maxlines, Winds);
#line 505
      currentLine___0 = (long )tmp___50;
      }
    }
#line 510
    goto switch_break;
    case_270: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 515
    printHex = (_Bool )(! printHex);
#line 517
    if (Winds) {
#line 517
      row = (int )Winds->_cury;
    } else {
#line 517
      row = -1;
    }
#line 517
    if (Winds) {
#line 517
      col = (int )Winds->_curx;
    } else {
#line 517
      col = -1;
    }
    {
#line 518
    row = (int )(currentLine___0 - (long )row);
#line 520
    wmove(win->address, 0, 0);
    }
#line 523
    if (maxlines - (long )row < (long )MAXY) {
#line 524
      count = 0;
      {
#line 524
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 524
        if (! ((long )count <= maxlines - (long )row)) {
#line 524
          goto while_break___5;
        }
#line 525
        if (printHex) {
#line 525
          tmp___51 = "%08X ";
        } else {
#line 525
          tmp___51 = "%08d ";
        }
        {
#line 525
        wprintw(win->address, tmp___51, (count + row) * BASE);
#line 524
        count ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
    } else {
#line 528
      count = 0;
      {
#line 528
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 528
        if (count <= MAXY) {
#line 528
          if (! ((long )count <= maxlines)) {
#line 528
            goto while_break___6;
          }
        } else {
#line 528
          goto while_break___6;
        }
#line 529
        if (printHex) {
#line 529
          tmp___52 = "%08X ";
        } else {
#line 529
          tmp___52 = "%08d ";
        }
        {
#line 529
        wprintw(win->address, tmp___52, (count + row) * BASE);
#line 528
        count ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 533
    if (printHex) {
#line 533
      tmp___53 = "Hex Addr";
    } else {
#line 533
      tmp___53 = "Dec Addr";
    }
    {
#line 533
    slk_set(6, tmp___53, 1);
#line 534
    slk_noutrefresh();
#line 535
    wnoutrefresh(win->address);
    }
#line 536
    goto switch_break;
    case_268: /* CIL Label */ 
    case_7: /* CIL Label */ 
    {
#line 540
    wmove(win->hex_outline, LINES - 1, 21);
#line 541
    wclrtoeol(win->hex_outline);
    }
#line 542
    if (printHex) {
#line 542
      tmp___54 = "HEX";
    } else {
#line 542
      tmp___54 = "decimal";
    }
    {
#line 542
    mvwprintw(win->hex_outline, LINES - 1, 1, "Enter %s location: ", tmp___54);
#line 545
    echo();
    }
#line 546
    if (printHex) {
#line 546
      tmp___55 = 21;
    } else {
#line 546
      tmp___55 = 25;
    }
    {
#line 546
    gotoLocStr = inputLine(win->hex_outline, LINES - 1, tmp___55);
    }
#line 548
    if ((int )*(gotoLocStr + 0) == 27) {
      {
#line 550
      restoreBorder(win);
#line 551
      wrefresh(win->hex_outline);
      }
#line 552
      goto switch_break;
    }
    {
#line 555
    gotoLoc = strtol((char const   */* __restrict  */)gotoLocStr, (char **/* __restrict  */)((void *)0),
                     16);
#line 557
    noecho();
    }
#line 559
    if (gotoLoc < 0L) {
      {
#line 561
      popupWin((char *)"Invalid location!", -1);
#line 562
      restoreBorder(win);
#line 563
      wrefresh(win->hex_outline);
      }
    } else
#line 559
    if (gotoLoc > len - 1L) {
      {
#line 561
      popupWin((char *)"Invalid location!", -1);
#line 562
      restoreBorder(win);
#line 563
      wrefresh(win->hex_outline);
      }
    } else {
#line 567
      if (Winds) {
#line 567
        row = (int )Winds->_cury;
      } else {
#line 567
        row = -1;
      }
#line 567
      if (Winds) {
#line 567
        col = (int )Winds->_curx;
      } else {
#line 567
        col = -1;
      }
#line 569
      if (editHex) {
#line 569
        tmp___56 = 3;
      } else {
#line 569
        tmp___56 = 1;
      }
      {
#line 569
      tmp___57 = gotoLine(fpIN, (int )(currentLine___0 * (long )BASE + (long )(col / tmp___56)),
                          (int )gotoLoc, (int )maxlines, Winds);
#line 569
      currentLine___0 = (long )tmp___57;
      }
    }
#line 573
    goto switch_break;
    case_271: /* CIL Label */ 
    case_9: /* CIL Label */ 
#line 578
    if (Winds) {
#line 578
      row = (int )Winds->_cury;
    } else {
#line 578
      row = -1;
    }
#line 578
    if (Winds) {
#line 578
      col = (int )Winds->_curx;
    } else {
#line 578
      col = -1;
    }
#line 579
    if (editHex) {
#line 579
      tmp___59 = win->ascii;
    } else {
#line 579
      tmp___59 = win->hex;
    }
#line 579
    if (tmp___59) {
#line 579
      if (editHex) {
#line 579
        tmp___58 = win->ascii;
      } else {
#line 579
        tmp___58 = win->hex;
      }
#line 579
      tmp___58->_attrs = 0UL;
    }
#line 580
    if (editHex) {
      {
#line 580
      tmp___62 = __ctype_b_loc();
      }
#line 580
      if ((int const   )*(*tmp___62 + curVal) & 16384) {
#line 580
        tmp___61 = curVal;
      } else {
#line 580
        tmp___61 = '.';
      }
#line 580
      tmp___63 = tmp___61;
    } else {
#line 580
      tmp___63 = curVal;
    }
#line 580
    if (editHex) {
#line 580
      tmp___64 = "%c";
    } else {
#line 580
      tmp___64 = "%02X";
    }
#line 580
    if (editHex) {
#line 580
      tmp___65 = col / 3;
    } else {
#line 580
      tmp___65 = col * 3;
    }
#line 580
    if (editHex) {
#line 580
      tmp___66 = win->ascii;
    } else {
#line 580
      tmp___66 = win->hex;
    }
    {
#line 580
    mvwprintw(tmp___66, row, tmp___65, tmp___64, tmp___63);
    }
#line 584
    if (editHex) {
#line 584
      tmp___67 = win->ascii;
    } else {
#line 584
      tmp___67 = win->hex;
    }
    {
#line 584
    wnoutrefresh(tmp___67);
    }
#line 585
    if (editHex) {
      {
#line 587
      Winds = win->ascii;
#line 588
      eol = BASE;
#line 589
      wmove(Winds, row, col / 3);
#line 590
      slk_set(7, "Asc Edit", 1);
      }
    } else {
      {
#line 594
      Winds = win->hex;
#line 595
      eol = BASE * 3 - 1;
#line 596
      wmove(Winds, row, col * 3);
#line 597
      slk_set(7, "Hex Edit", 1);
      }
    }
    {
#line 600
    editHex = (_Bool )(! editHex);
#line 601
    slk_noutrefresh();
    }
#line 603
    if (Winds) {
#line 603
      row = (int )Winds->_cury;
    } else {
#line 603
      row = -1;
    }
#line 603
    if (Winds) {
#line 603
      col = (int )Winds->_curx;
    } else {
#line 603
      col = -1;
    }
#line 605
    if (editHex) {
#line 605
      tmp___78 = 3;
    } else {
#line 605
      tmp___78 = 1;
    }
    {
#line 605
    tmp___79 = inHexList(currentLine___0 * (long )BASE + (long )(col / tmp___78));
    }
#line 605
    if (tmp___79) {
#line 607
      if (editHex) {
#line 607
        tmp___68 = win->hex;
      } else {
#line 607
        tmp___68 = win->ascii;
      }
      {
#line 607
      wattr_on(tmp___68, 1UL << 21, (void *)0);
      }
#line 608
      if (editHex) {
#line 608
        tmp___72 = curVal;
      } else {
        {
#line 608
        tmp___71 = __ctype_b_loc();
        }
#line 608
        if ((int const   )*(*tmp___71 + curVal) & 16384) {
#line 608
          tmp___70 = curVal;
        } else {
#line 608
          tmp___70 = '.';
        }
#line 608
        tmp___72 = tmp___70;
      }
#line 608
      if (editHex) {
#line 608
        tmp___73 = "%02X";
      } else {
#line 608
        tmp___73 = "%c";
      }
#line 608
      if (editHex) {
#line 608
        tmp___74 = win->hex;
      } else {
#line 608
        tmp___74 = win->ascii;
      }
      {
#line 608
      mvwprintw(tmp___74, row, col, tmp___73, tmp___72);
      }
#line 611
      if (editHex) {
#line 611
        tmp___76 = win->hex;
      } else {
#line 611
        tmp___76 = win->ascii;
      }
#line 611
      if (tmp___76) {
#line 611
        if (editHex) {
#line 611
          tmp___75 = win->hex;
        } else {
#line 611
          tmp___75 = win->ascii;
        }
#line 611
        tmp___75->_attrs = 0UL;
      }
      {
#line 612
      wmove(Winds, row, col);
      }
#line 613
      if (editHex) {
#line 613
        tmp___77 = win->ascii;
      } else {
#line 613
        tmp___77 = win->hex;
      }
      {
#line 613
      wnoutrefresh(tmp___77);
      }
    }
#line 615
    goto switch_break;
    case_265: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_31: /* CIL Label */ 
#line 620
    if (Winds) {
#line 620
      row = (int )Winds->_cury;
    } else {
#line 620
      row = -1;
    }
#line 620
    if (Winds) {
#line 620
      col = (int )Winds->_curx;
    } else {
#line 620
      col = -1;
    }
    {
#line 622
    printHelp(win);
#line 624
    wmove(Winds, row, col);
    }
#line 625
    goto switch_break;
    case_26: /* CIL Label */ 
#line 628
    if (Winds) {
#line 628
      row = (int )Winds->_cury;
    } else {
#line 628
      row = -1;
    }
#line 628
    if (Winds) {
#line 628
      col = (int )Winds->_curx;
    } else {
#line 628
      col = -1;
    }
#line 631
    if ((unsigned long )stack == (unsigned long )((void *)0)) {
#line 631
      cl = cl;
    } else {
#line 631
      cl = stack->currentLoc;
    }
#line 632
    if ((unsigned long )stack != (unsigned long )((void *)0)) {
      {
#line 636
      val = stack->savedVal;
#line 637
      popStack(& stack);
#line 638
      head = deleteNode(head, (int )cl);
      }
#line 641
      if (editHex) {
#line 641
        tmp___80 = 3;
      } else {
#line 641
        tmp___80 = 1;
      }
      {
#line 641
      tmp___81 = gotoLine(fpIN, (int )(currentLine___0 * (long )BASE + (long )(col / tmp___80)),
                          (int )cl, (int )maxlines, Winds);
#line 641
      currentLine___0 = (long )tmp___81;
      }
#line 655
      if (Winds) {
#line 655
        row = (int )Winds->_cury;
      } else {
#line 655
        row = -1;
      }
#line 655
      if (Winds) {
#line 655
        col = (int )Winds->_curx;
      } else {
#line 655
        col = -1;
      }
      {
#line 657
      tmp___82 = searchList(head, (int )cl);
      }
#line 657
      if (tmp___82 != -1) {
        {
#line 659
        wattr_on(win->hex, 1UL << 21, (void *)0);
#line 660
        wattr_on(win->ascii, 1UL << 21, (void *)0);
        }
      }
#line 662
      if (editHex) {
        {
#line 664
        wmove(win->ascii, row, col / 3);
        }
#line 665
        if (USE_EBCDIC) {
#line 665
          tmp___86 = (int )EBCDIC[val];
        } else {
          {
#line 665
          tmp___85 = __ctype_b_loc();
          }
#line 665
          if ((int const   )*(*tmp___85 + val) & 16384) {
#line 665
            tmp___84 = val;
          } else {
#line 665
            tmp___84 = 46;
          }
#line 665
          tmp___86 = tmp___84;
        }
        {
#line 665
        wprintw(win->ascii, "%c", tmp___86);
#line 667
        wmove(win->hex, row, col);
#line 668
        wrefresh(win->ascii);
#line 670
        wprintw(win->hex, "%02X", val);
#line 671
        wmove(win->hex, row, col);
#line 672
        wrefresh(win->hex);
        }
      } else {
        {
#line 676
        wmove(win->hex, row, col * 3);
#line 677
        wprintw(win->hex, "%02X", val);
#line 678
        wmove(win->ascii, row, col);
#line 679
        wrefresh(win->hex);
        }
#line 681
        if (USE_EBCDIC) {
#line 681
          tmp___90 = (int )EBCDIC[val];
        } else {
          {
#line 681
          tmp___89 = __ctype_b_loc();
          }
#line 681
          if ((int const   )*(*tmp___89 + val) & 16384) {
#line 681
            tmp___88 = val;
          } else {
#line 681
            tmp___88 = 46;
          }
#line 681
          tmp___90 = tmp___88;
        }
        {
#line 681
        wprintw(win->ascii, "%c", tmp___90);
#line 683
        wmove(win->ascii, row, col);
#line 684
        wrefresh(win->ascii);
        }
      }
#line 686
      if (win->hex) {
#line 686
        (win->hex)->_attrs = 0UL;
      }
#line 687
      if (win->ascii) {
#line 687
        (win->ascii)->_attrs = 0UL;
      }
    }
#line 691
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 700
    if (Winds) {
#line 700
      row = (int )Winds->_cury;
    } else {
#line 700
      row = -1;
    }
#line 700
    if (Winds) {
#line 700
      col = (int )Winds->_curx;
    } else {
#line 700
      col = -1;
    }
#line 701
    if (fpIN) {
#line 705
      if (lastRow == MAXY) {
#line 705
        if ((int )key == 258) {
#line 705
          if (maxlines != currentLine___0) {
#line 706
            lastRow --;
          } else {
#line 705
            goto _L___4;
          }
        } else {
#line 705
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 707
      if (lastRow == 0) {
#line 707
        if ((int )key == 259) {
#line 707
          if (currentLine___0 != 0L) {
#line 708
            lastRow ++;
          }
        }
      }
#line 709
      if (lastRow == MAXY) {
#line 709
        if (lastCol == eol - 1) {
#line 709
          if ((int )key == 261) {
#line 709
            if (maxlines != currentLine___0) {
#line 711
              lastRow --;
            } else {
#line 709
              goto _L___7;
            }
          } else {
#line 709
            goto _L___7;
          }
        } else {
#line 709
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
#line 712
      if (lastRow == 0) {
#line 712
        if (lastCol == 0) {
#line 712
          if ((int )key == 260) {
#line 712
            if (currentLine___0 != 0L) {
#line 714
              lastRow ++;
            }
          }
        }
      }
#line 717
      if ((int )key != 9) {
#line 719
        if (editHex) {
#line 719
          tmp___91 = 3;
        } else {
#line 719
          tmp___91 = 1;
        }
        {
#line 719
        curVal = getLocVal(lastLine * (long )BASE + (long )(lastCol / tmp___91));
        }
#line 720
        if (editHex) {
#line 720
          tmp___93 = win->ascii;
        } else {
#line 720
          tmp___93 = win->hex;
        }
#line 720
        if (tmp___93) {
#line 720
          if (editHex) {
#line 720
            tmp___92 = win->ascii;
          } else {
#line 720
            tmp___92 = win->hex;
          }
#line 720
          tmp___92->_attrs = 0UL;
        }
#line 721
        if (editHex) {
#line 721
          tmp___97 = 3;
        } else {
#line 721
          tmp___97 = 1;
        }
        {
#line 721
        tmp___98 = inHexList(lastLine * (long )BASE + (long )(lastCol / tmp___97));
        }
#line 721
        if (tmp___98) {
#line 721
          tmp___96 = 1UL << 21;
        } else {
#line 721
          tmp___96 = 0UL;
        }
#line 721
        if (editHex) {
#line 721
          tmp___99 = win->ascii;
        } else {
#line 721
          tmp___99 = win->hex;
        }
        {
#line 721
        wattr_on(tmp___99, tmp___96, (void *)0);
        }
#line 724
        if (editHex) {
          {
#line 724
          tmp___102 = __ctype_b_loc();
          }
#line 724
          if ((int const   )*(*tmp___102 + curVal) & 16384) {
#line 724
            tmp___101 = curVal;
          } else {
#line 724
            tmp___101 = '.';
          }
#line 724
          tmp___103 = tmp___101;
        } else {
#line 724
          tmp___103 = curVal;
        }
#line 724
        if (editHex) {
#line 724
          tmp___104 = "%c";
        } else {
#line 724
          tmp___104 = "%02X";
        }
#line 724
        if (editHex) {
#line 724
          tmp___105 = lastCol / 3;
        } else {
#line 724
          tmp___105 = lastCol * 3;
        }
#line 724
        if (editHex) {
#line 724
          tmp___106 = win->ascii;
        } else {
#line 724
          tmp___106 = win->hex;
        }
        {
#line 724
        mvwprintw(tmp___106, lastRow, tmp___105, tmp___104, tmp___103);
#line 728
        wmove(Winds, row, col);
        }
#line 729
        if (editHex) {
#line 729
          tmp___108 = win->ascii;
        } else {
#line 729
          tmp___108 = win->hex;
        }
#line 729
        if (tmp___108) {
#line 729
          if (editHex) {
#line 729
            tmp___107 = win->ascii;
          } else {
#line 729
            tmp___107 = win->hex;
          }
#line 729
          tmp___107->_attrs = 0UL;
        }
#line 730
        if (editHex) {
#line 730
          tmp___109 = win->ascii;
        } else {
#line 730
          tmp___109 = win->hex;
        }
        {
#line 730
        wnoutrefresh(tmp___109);
        }
      }
#line 733
      if (editHex) {
#line 733
        tmp___110 = win->ascii;
      } else {
#line 733
        tmp___110 = win->hex;
      }
      {
#line 733
      wattr_on(tmp___110, 1UL << 17, (void *)0);
      }
#line 734
      if (editHex) {
#line 734
        tmp___112 = 3;
      } else {
#line 734
        tmp___112 = 1;
      }
      {
#line 734
      tmp___113 = inHexList(currentLine___0 * (long )BASE + (long )(col / tmp___112));
      }
#line 734
      if (tmp___113) {
#line 735
        if (editHex) {
#line 735
          tmp___111 = win->ascii;
        } else {
#line 735
          tmp___111 = win->hex;
        }
        {
#line 735
        wattr_on(tmp___111, 1UL << 21, (void *)0);
        }
      }
#line 737
      if (editHex) {
#line 737
        tmp___114 = 3;
      } else {
#line 737
        tmp___114 = 1;
      }
      {
#line 737
      curVal = getLocVal(currentLine___0 * (long )BASE + (long )(col / tmp___114));
      }
#line 739
      if (editHex) {
        {
#line 739
        tmp___117 = __ctype_b_loc();
        }
#line 739
        if ((int const   )*(*tmp___117 + curVal) & 16384) {
#line 739
          tmp___116 = curVal;
        } else {
#line 739
          tmp___116 = '.';
        }
#line 739
        tmp___118 = tmp___116;
      } else {
#line 739
        tmp___118 = curVal;
      }
#line 739
      if (editHex) {
#line 739
        tmp___119 = "%c";
      } else {
#line 739
        tmp___119 = "%02X";
      }
#line 739
      if (editHex) {
#line 739
        tmp___120 = col / 3;
      } else {
#line 739
        tmp___120 = col * 3;
      }
#line 739
      if (editHex) {
#line 739
        tmp___121 = win->ascii;
      } else {
#line 739
        tmp___121 = win->hex;
      }
      {
#line 739
      mvwprintw(tmp___121, row, tmp___120, tmp___119, tmp___118);
      }
#line 743
      if (editHex) {
#line 743
        tmp___123 = win->ascii;
      } else {
#line 743
        tmp___123 = win->hex;
      }
#line 743
      if (tmp___123) {
#line 743
        if (editHex) {
#line 743
          tmp___122 = win->ascii;
        } else {
#line 743
          tmp___122 = win->hex;
        }
#line 743
        tmp___122->_attrs = 0UL;
      }
#line 744
      if (editHex) {
#line 744
        tmp___124 = win->ascii;
      } else {
#line 744
        tmp___124 = win->hex;
      }
      {
#line 744
      wnoutrefresh(tmp___124);
      }
    }
#line 747
    if (editHex) {
#line 747
      tmp___125 = 3;
    } else {
#line 747
      tmp___125 = 1;
    }
#line 747
    LastLoc = currentLine___0 * (long )BASE + (long )(col / tmp___125);
#line 748
    lastLine = currentLine___0;
#line 750
    if (editHex) {
#line 750
      tmp___126 = 3;
    } else {
#line 750
      tmp___126 = 1;
    }
#line 750
    if (printHex) {
#line 750
      tmp___127 = "%08X";
    } else {
#line 750
      tmp___127 = "%08d";
    }
    {
#line 750
    mvwprintw(win->cur_address, 0, 0, tmp___127, currentLine___0 * (long )BASE + (long )(col / tmp___126));
#line 753
    wnoutrefresh(win->cur_address);
    }
#line 755
    if (editHex) {
#line 755
      tmp___128 = 3;
    } else {
#line 755
      tmp___128 = 1;
    }
    {
#line 755
    scrollbar(win, (int )(currentLine___0 * (long )BASE + (long )(col / tmp___128)),
              maxlines);
#line 757
    wmove(Winds, row, col);
#line 758
    doupdate();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 762
  if (save == 2) {
    {
#line 762
    savefile(win, fpINfilename___0, fpOUTfilename___0);
    }
  }
#line 764
  return (0);
}
}
#line 771 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/acceptch.c"
void restoreBorder(WINS *win ) 
{ 
  int count ;
  int tmp ;
  int tmp___0 ;

  {
#line 775
  count = 1;
  {
#line 775
  while (1) {
    while_continue: /* CIL Label */ ;
#line 775
    if (! (count < hex_outline_width - 1)) {
#line 775
      goto while_break;
    }
    {
#line 776
    tmp = wmove(win->hex_outline, LINES - 1, count);
    }
#line 776
    if (! (tmp == -1)) {
      {
#line 776
      waddch(win->hex_outline, (chtype const   )acs_map[(unsigned char )'q']);
      }
    }
#line 775
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 777
  tmp___0 = wmove(win->hex_outline, LINES - 1, hex_outline_width - 1);
  }
#line 777
  if (! (tmp___0 == -1)) {
    {
#line 777
    waddch(win->hex_outline, (chtype const   )acs_map[(unsigned char )'j']);
    }
  }
#line 779
  return;
}
}
#line 785 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/acceptch.c"
char *inputLine(WINDOW *win , int line , int col ) 
{ 
  int x ;
  unsigned long c ;
  char *ch ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 791
  noecho();
#line 793
  tmp = malloc((size_t )81);
#line 793
  ch = (char *)tmp;
#line 795
  wmove(win, line, col);
#line 797
  x = 0;
  }
  {
#line 797
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 797
    tmp___1 = wgetch(win);
#line 797
    c = (unsigned long )tmp___1;
    }
#line 797
    if (! (c != 10UL)) {
#line 797
      goto while_break;
    }
    {
#line 799
    wclrtoeol(win);
    }
#line 800
    if (c == 8UL) {
#line 800
      goto _L___0;
    } else
#line 800
    if (c == 127UL) {
      _L___0: /* CIL Label */ 
      {
#line 802
      tmp___0 = wmove(win, line, col + (x - 1));
      }
#line 802
      if (! (tmp___0 == -1)) {
        {
#line 802
        waddch(win, (chtype const   )32);
        }
      }
      {
#line 803
      wmove(win, line, col + (x - 1));
#line 804
      *(ch + x) = (char )'\000';
#line 805
      x -= 2;
      }
    } else
#line 807
    if (c > 32UL) {
#line 807
      if (c < 127UL) {
        {
#line 809
        *(ch + x) = (char )c;
#line 810
        waddch(win, (chtype const   )*(ch + x));
        }
      } else {
#line 807
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 812
    if (c == 27UL) {
#line 814
      *(ch + 0) = (char)27;
#line 815
      return (ch);
    } else {
#line 819
      *(ch + x) = (char )'\000';
#line 820
      x --;
    }
#line 823
    if (x < 0) {
      {
#line 825
      wmove(win, line, col);
#line 826
      x = -1;
      }
    }
#line 797
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 830
  *(ch + x) = (char )'\000';
#line 832
  return (ch);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 32 "/usr/include/alloca.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) alloca)(size_t __size ) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 41 "../include/hgetopt.h"
char *optarg ;
#line 55
int optind ;
#line 60
int opterr ;
#line 64
int optopt ;
#line 132
int _getopt_internal(int argc , char * const  *argv , char const   *optstring , struct option  const  *longopts ,
                     int *longind , int long_only ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/getopt.c"
char *optarg  =    (char *)0;
#line 52 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/getopt.c"
int optind  =    0;
#line 55 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/getopt.c"
static char *nextchar  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/getopt.c"
int opterr  =    1;
#line 66 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/getopt.c"
int optopt  =    '?';
#line 69 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/getopt.c"
static enum __anonenum_ordering_25 ordering  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/getopt.c"
static enum __anonenum_ordering_25 default_ordering  =    (enum __anonenum_ordering_25 )1;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/getopt.c"
static int first_nonopt  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/getopt.c"
static int last_nonopt  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/getopt.c"
static void exchange(char **argv ) 
{ 
  int nonopts_size ;
  char **temp ;
  void *tmp ;

  {
  {
#line 85
  nonopts_size = (int )((unsigned long )(last_nonopt - first_nonopt) * sizeof(char *));
#line 86
  tmp = alloca((size_t )nonopts_size);
#line 86
  temp = (char **)tmp;
#line 90
  memcpy((void */* __restrict  */)((char *)temp), (void const   */* __restrict  */)((char *)(argv + first_nonopt)),
         (size_t )nonopts_size);
#line 91
  memcpy((void */* __restrict  */)((char *)(argv + first_nonopt)), (void const   */* __restrict  */)((char *)(argv + last_nonopt)),
         (unsigned long )(optind - last_nonopt) * sizeof(char *));
#line 93
  memcpy((void */* __restrict  */)((char *)(argv + ((first_nonopt + optind) - last_nonopt))),
         (void const   */* __restrict  */)((char *)temp), (size_t )nonopts_size);
#line 99
  first_nonopt += optind - last_nonopt;
#line 100
  last_nonopt = optind;
  }
#line 101
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/getopt.c"
void getopt_set_posix_option_order(int on_or_off ) 
{ 


  {
#line 109
  if (on_or_off == 1) {
#line 110
    default_ordering = (enum __anonenum_ordering_25 )0;
  } else {
#line 112
    default_ordering = (enum __anonenum_ordering_25 )1;
  }
#line 113
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/getopt.c"
int _getopt_internal(int argc , char * const  *argv , char const   *optstring , struct option  const  *longopts ,
                     int *longind , int long_only ) 
{ 
  int option_index ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct option  const  *p ;
  char *s ;
  int exact ;
  int ambig ;
  struct option  const  *pfound ;
  int indfound ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  char c ;
  char *tmp___12 ;
  char *temp ;
  char *tmp___13 ;
  int tmp___14 ;

  {
#line 126
  optarg = (char *)0;
#line 128
  if (optind > argc) {
#line 130
    optind = argc;
#line 131
    return (-1);
  } else
#line 128
  if (optind < 0) {
#line 130
    optind = argc;
#line 131
    return (-1);
  }
#line 139
  if (optind == 0) {
#line 141
    optind = 1;
#line 141
    last_nonopt = optind;
#line 141
    first_nonopt = last_nonopt;
#line 143
    nextchar = (char *)((void *)0);
#line 147
    if ((int const   )*(optstring + 0) == 45) {
#line 149
      ordering = (enum __anonenum_ordering_25 )2;
#line 150
      optstring ++;
    } else
#line 152
    if ((int const   )*(optstring + 0) == 43) {
#line 154
      ordering = (enum __anonenum_ordering_25 )0;
#line 155
      optstring ++;
    } else {
      {
#line 157
      tmp = getenv("POSIXLY_CORRECT");
      }
#line 157
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 158
        ordering = (enum __anonenum_ordering_25 )0;
      } else {
#line 160
        ordering = default_ordering;
      }
    }
  }
#line 163
  if ((unsigned long )nextchar == (unsigned long )((void *)0)) {
#line 163
    goto _L___2;
  } else
#line 163
  if ((int )*nextchar == 0) {
    _L___2: /* CIL Label */ 
#line 165
    if ((unsigned int )ordering == 1U) {
#line 170
      if (first_nonopt != last_nonopt) {
#line 170
        if (last_nonopt != optind) {
          {
#line 171
          exchange((char **)argv);
          }
        } else {
#line 170
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 172
      if (last_nonopt != optind) {
#line 173
        first_nonopt = optind;
      }
      {
#line 178
      while (1) {
        while_continue: /* CIL Label */ ;
#line 178
        if (optind < argc) {
#line 178
          if (! ((int )*(*(argv + optind) + 0) != 45)) {
#line 178
            if (! ((int )*(*(argv + optind) + 1) == 0)) {
#line 178
              goto while_break;
            }
          }
        } else {
#line 178
          goto while_break;
        }
#line 185
        optind ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 186
      last_nonopt = optind;
    }
#line 194
    if (optind != argc) {
      {
#line 194
      tmp___0 = strcmp((char const   *)*(argv + optind), "--");
      }
#line 194
      if (! tmp___0) {
#line 196
        optind ++;
#line 198
        if (first_nonopt != last_nonopt) {
#line 198
          if (last_nonopt != optind) {
            {
#line 199
            exchange((char **)argv);
            }
          } else {
#line 198
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 200
        if (first_nonopt == last_nonopt) {
#line 201
          first_nonopt = optind;
        }
#line 202
        last_nonopt = argc;
#line 204
        optind = argc;
      }
    }
#line 210
    if (optind == argc) {
#line 214
      if (first_nonopt != last_nonopt) {
#line 215
        optind = first_nonopt;
      }
#line 216
      return (-1);
    }
#line 222
    if ((int )*(*(argv + optind) + 0) != 45) {
#line 222
      goto _L___1;
    } else
#line 222
    if ((int )*(*(argv + optind) + 1) == 0) {
      _L___1: /* CIL Label */ 
#line 229
      if ((unsigned int )ordering == 0U) {
#line 230
        return (-1);
      }
#line 231
      tmp___1 = optind;
#line 231
      optind ++;
#line 231
      optarg = (char *)*(argv + tmp___1);
#line 232
      return (1);
    }
#line 238
    if ((unsigned long )longopts != (unsigned long )((void *)0)) {
#line 238
      if ((int )*(*(argv + optind) + 1) == 45) {
#line 238
        tmp___2 = 1;
      } else {
#line 238
        tmp___2 = 0;
      }
    } else {
#line 238
      tmp___2 = 0;
    }
#line 238
    nextchar = (char *)((*(argv + optind) + 1) + tmp___2);
  }
#line 242
  if ((unsigned long )longopts != (unsigned long )((void *)0)) {
#line 242
    if ((int )*(*(argv + optind) + 0) == 45) {
#line 242
      if ((int )*(*(argv + optind) + 1) == 45) {
#line 242
        goto _L___4;
      } else
#line 242
      if (long_only) {
        _L___4: /* CIL Label */ 
#line 251
        s = nextchar;
#line 252
        exact = 0;
#line 253
        ambig = 0;
#line 254
        pfound = (struct option  const  *)((void *)0);
#line 255
        indfound = 0;
        {
#line 257
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 257
          if (*s) {
#line 257
            if (! ((int )*s != 61)) {
#line 257
              goto while_break___0;
            }
          } else {
#line 257
            goto while_break___0;
          }
#line 258
          s ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 261
        p = longopts;
#line 261
        option_index = 0;
        {
#line 261
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 261
          if (! p->name) {
#line 261
            goto while_break___1;
          }
          {
#line 263
          tmp___4 = strncmp((char const   *)p->name, (char const   *)nextchar, (size_t )(s - nextchar));
          }
#line 263
          if (! tmp___4) {
            {
#line 265
            tmp___3 = strlen((char const   *)p->name);
            }
#line 265
            if ((size_t )(s - nextchar) == tmp___3) {
#line 268
              pfound = p;
#line 269
              indfound = option_index;
#line 270
              exact = 1;
#line 271
              goto while_break___1;
            } else
#line 273
            if ((unsigned long )pfound == (unsigned long )((void *)0)) {
#line 276
              pfound = p;
#line 277
              indfound = option_index;
            } else {
#line 281
              ambig = 1;
            }
          }
#line 261
          p ++;
#line 261
          option_index ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 284
        if (ambig) {
#line 284
          if (! exact) {
#line 286
            if (opterr) {
              {
#line 287
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option `%s\' is ambiguous\n",
                      *(argv + 0), *(argv + optind));
              }
            }
            {
#line 289
            tmp___5 = strlen((char const   *)nextchar);
#line 289
            nextchar += tmp___5;
#line 290
            optind ++;
            }
#line 291
            return ('?');
          }
        }
#line 294
        if ((unsigned long )pfound != (unsigned long )((void *)0)) {
#line 296
          option_index = indfound;
#line 297
          optind ++;
#line 298
          if (*s) {
#line 302
            if (pfound->has_arg) {
#line 303
              optarg = s + 1;
            } else {
#line 306
              if (opterr) {
#line 308
                if ((int )*(*(argv + (optind - 1)) + 1) == 45) {
                  {
#line 310
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option `--%s\' doesn\'t allow an argument\n",
                          *(argv + 0), pfound->name);
                  }
                } else {
                  {
#line 315
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option `%c%s\' doesn\'t allow an argument\n",
                          *(argv + 0), (int )*(*(argv + (optind - 1)) + 0), pfound->name);
                  }
                }
              }
              {
#line 319
              tmp___6 = strlen((char const   *)nextchar);
#line 319
              nextchar += tmp___6;
              }
#line 320
              return ('?');
            }
          } else
#line 323
          if (pfound->has_arg == 1) {
#line 325
            if (optind < argc) {
#line 326
              tmp___7 = optind;
#line 326
              optind ++;
#line 326
              optarg = (char *)*(argv + tmp___7);
            } else {
#line 329
              if (opterr) {
                {
#line 330
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option `%s\' requires an argument\n",
                        *(argv + 0), *(argv + (optind - 1)));
                }
              }
              {
#line 332
              tmp___8 = strlen((char const   *)nextchar);
#line 332
              nextchar += tmp___8;
              }
#line 333
              if ((int const   )*(optstring + 0) == 58) {
#line 333
                tmp___9 = ':';
              } else {
#line 333
                tmp___9 = '?';
              }
#line 333
              return (tmp___9);
            }
          }
          {
#line 336
          tmp___10 = strlen((char const   *)nextchar);
#line 336
          nextchar += tmp___10;
          }
#line 337
          if ((unsigned long )longind != (unsigned long )((void *)0)) {
#line 338
            *longind = option_index;
          }
#line 339
          if (pfound->flag) {
#line 341
            *(pfound->flag) = (int )pfound->val;
#line 342
            return (0);
          }
#line 344
          return ((int )pfound->val);
        }
#line 350
        if (! long_only) {
#line 350
          goto _L___3;
        } else
#line 350
        if ((int )*(*(argv + optind) + 1) == 45) {
#line 350
          goto _L___3;
        } else {
          {
#line 350
          tmp___11 = strchr(optstring, (int )*nextchar);
          }
#line 350
          if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
            _L___3: /* CIL Label */ 
#line 356
            if (opterr) {
#line 358
              if ((int )*(*(argv + optind) + 1) == 45) {
                {
#line 360
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unrecognized option `--%s\'\n",
                        *(argv + 0), nextchar);
                }
              } else {
                {
#line 364
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unrecognized option `%c%s\'\n",
                        *(argv + 0), (int )*(*(argv + optind) + 0), nextchar);
                }
              }
            }
#line 367
            nextchar = (char *)"";
#line 368
            optind ++;
#line 369
            return ('?');
          }
        }
      }
    }
  }
  {
#line 376
  tmp___12 = nextchar;
#line 376
  nextchar ++;
#line 376
  c = *tmp___12;
#line 377
  tmp___13 = strchr(optstring, (int )c);
#line 377
  temp = tmp___13;
  }
#line 380
  if ((int )*nextchar == 0) {
#line 381
    optind ++;
  }
#line 383
  optopt = (int )c;
#line 385
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 385
    goto _L___5;
  } else
#line 385
  if ((int )c == 58) {
    _L___5: /* CIL Label */ 
#line 387
    if (opterr) {
      {
#line 397
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: illegal option -- %c\n",
              *(argv + 0), (int )c);
      }
    }
#line 400
    optopt = (int )c;
#line 401
    return ('?');
  }
#line 403
  if ((int )*(temp + 1) == 58) {
#line 405
    if ((int )*(temp + 2) == 58) {
#line 408
      if ((int )*nextchar != 0) {
#line 410
        optarg = nextchar;
#line 411
        optind ++;
      } else {
#line 414
        optarg = (char *)0;
      }
#line 415
      nextchar = (char *)((void *)0);
    } else {
#line 420
      if ((int )*nextchar != 0) {
#line 422
        optarg = nextchar;
#line 425
        optind ++;
      } else
#line 427
      if (optind == argc) {
#line 429
        if (opterr) {
          {
#line 436
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option requires an argument -- %c\n",
                  *(argv + 0), (int )c);
          }
        }
#line 440
        optopt = (int )c;
#line 441
        if ((int const   )*(optstring + 0) == 58) {
#line 442
          c = (char )':';
        } else {
#line 444
          c = (char )'?';
        }
      } else {
#line 449
        tmp___14 = optind;
#line 449
        optind ++;
#line 449
        optarg = (char *)*(argv + tmp___14);
      }
#line 450
      nextchar = (char *)((void *)0);
    }
  }
#line 453
  return ((int )c);
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/getopt.c"
int hgetopt(int argc , char * const  *argv , char const   *optstring ) 
{ 
  int tmp ;

  {
  {
#line 463
  tmp = _getopt_internal(argc, argv, optstring, (struct option  const  *)0, (int *)0,
                         0);
  }
#line 463
  return (tmp);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 788 "/usr/include/curses.h"
extern int waddnstr(WINDOW * , char const   * , int  ) ;
#line 126 "../include/hex.h"
void print_usage(void) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/file.c"
void outline(FILE *fp , int linenum ) 
{ 
  unsigned int i ;
  unsigned int c ;
  unsigned int *tmp ;
  unsigned long __lengthoftmp ;
  void *tmp___0 ;
  hexList *tmpHead ;
  char const   *tmp___1 ;
  char const   *tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;

  {
  {
#line 29
  __lengthoftmp = (unsigned long )BASE;
#line 29
  tmp___0 = __builtin_alloca(sizeof(*tmp) * __lengthoftmp);
#line 29
  tmp = (unsigned int *)tmp___0;
#line 30
  tmpHead = head;
#line 32
  i = 0U;
  }
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (! (i < (unsigned int )BASE)) {
#line 32
      goto while_break;
    }
#line 33
    *(tmp + i) = 4294967295U;
#line 32
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 35
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 35
    if ((unsigned long )tmpHead != (unsigned long )((void *)0)) {
#line 35
      if (! (tmpHead->loc < (long )(linenum * BASE))) {
#line 35
        goto while_break___0;
      }
    } else {
#line 35
      goto while_break___0;
    }
#line 36
    tmpHead = tmpHead->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 38
  i = 0U;
  {
#line 38
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 38
    if (! (i < (unsigned int )BASE)) {
#line 38
      goto while_break___1;
    }
    {
#line 40
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 40
      if ((unsigned long )tmpHead != (unsigned long )((void *)0)) {
#line 40
        if (! (tmpHead->loc < (long )((unsigned int )(linenum * BASE) + i))) {
#line 40
          goto while_break___2;
        }
      } else {
#line 40
        goto while_break___2;
      }
#line 41
      tmpHead = tmpHead->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 43
    if ((unsigned long )tmpHead != (unsigned long )((void *)0)) {
#line 43
      if (tmpHead->loc == (long )((unsigned int )(linenum * BASE) + i)) {
#line 45
        *(tmp + i) = (unsigned int )tmpHead->val;
#line 46
        tmpHead = tmpHead->next;
      }
    }
#line 38
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 50
  wclrtoeol(windows->hex);
#line 51
  wclrtoeol(windows->ascii);
  }
#line 54
  if (printHex) {
#line 54
    tmp___1 = "%08X ";
  } else {
#line 54
    tmp___1 = "%08d ";
  }
  {
#line 54
  wprintw(windows->address, tmp___1, linenum * BASE);
#line 56
  rewind(fp);
#line 57
  fseek(fp, (long )(linenum * BASE), 0);
#line 59
  i = 0U;
  }
  {
#line 59
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 59
    if (i < (unsigned int )BASE) {
      {
#line 59
      tmp___5 = _IO_getc(fp);
#line 59
      c = (unsigned int )tmp___5;
      }
#line 59
      if (! (c != 4294967295U)) {
#line 59
        goto while_break___3;
      }
    } else {
#line 59
      goto while_break___3;
    }
#line 61
    if (*(tmp + i) != 4294967295U) {
      {
#line 62
      c = *(tmp + i);
#line 63
      wattr_on(windows->ascii, 1UL << 21, (void *)0);
#line 64
      wattr_on(windows->hex, 1UL << 21, (void *)0);
      }
    }
    {
#line 66
    wprintw(windows->hex, "%02X ", c);
    }
#line 67
    if (USE_EBCDIC) {
      {
#line 68
      wprintw(windows->ascii, "%c", (int )EBCDIC[c]);
      }
    } else {
      {
#line 70
      tmp___4 = __ctype_b_loc();
      }
#line 70
      if ((int const   )*(*tmp___4 + (int )c) & 16384) {
#line 70
        tmp___3 = "%c";
      } else {
#line 70
        tmp___3 = ".";
      }
      {
#line 70
      wprintw(windows->ascii, tmp___3, c);
      }
    }
    {
#line 71
    wattr_off(windows->ascii, 1UL << 21, (void *)0);
#line 72
    wattr_off(windows->hex, 1UL << 21, (void *)0);
#line 59
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/file.c"
int maxLoc(FILE *fp ) 
{ 
  long tmp ;

  {
  {
#line 83
  fseek(fp, 0L, 2);
#line 84
  tmp = ftell(fp);
  }
#line 84
  return ((int )tmp);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/file.c"
void print_usage(void) 
{ 
  char *ver ;

  {
  {
#line 93
  ver = (char *)"1.55";
#line 95
  printf((char const   */* __restrict  */)"hexcurse, version %s by FishMoth (jewfish and armoth)\n",
         ver);
#line 96
  printf((char const   */* __restrict  */)"\nusage: hexcurse [-?|help] [-a] [-r rnum] [-o outputfile] ");
#line 97
  printf((char const   */* __restrict  */)"[[-i] infile]\n\n");
#line 98
  printf((char const   */* __restrict  */)"    -a\t\tOutput addresses in decimal format initially\n");
#line 99
  printf((char const   */* __restrict  */)"    -e\t\tOutput characters in EBCDIC format rather than ASCII\n");
#line 100
  printf((char const   */* __restrict  */)"    -r rnum\tResize the display to \"rnum\" bytes wide\n");
#line 101
  printf((char const   */* __restrict  */)"    -o outfile\tWrite output to outfile by default\n");
#line 102
  printf((char const   */* __restrict  */)"    -? | -help\tDisplay usage and version of hexcurse program\n");
#line 103
  printf((char const   */* __restrict  */)"    [-i] infile\tRead from data from infile (-i required if not last argument)\n\n");
  }
#line 104
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/file.c"
int maxLines(int len ) 
{ 
  int tmp ;

  {
#line 113
  if (BASE == 0) {
#line 113
    return (0);
  }
#line 115
  if (len % BASE != 0) {
#line 116
    return (len / BASE);
  } else {
#line 118
    if (BASE == 1) {
#line 118
      tmp = 0;
    } else {
#line 118
      tmp = len / BASE - 1;
    }
#line 118
    return (tmp);
  }
#line 119
  return (len / BASE);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/file.c"
int openfile(WINS *win , char *fpINfilename___0 ) 
{ 
  char *ch ;
  FILE *tmpfp ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 131
  tmp = malloc((size_t )81);
#line 131
  ch = (char *)tmp;
#line 133
  wmove(win->hex_outline, LINES - 1, 21);
#line 134
  wclrtoeol(win->hex_outline);
#line 135
  tmp___0 = wmove(win->hex_outline, LINES - 1, 1);
  }
#line 135
  if (! (tmp___0 == -1)) {
    {
#line 135
    waddnstr(win->hex_outline, "Enter file to open: ", -1);
    }
  }
  {
#line 137
  freeList(head);
#line 138
  head = (hexList *)((void *)0);
  }
#line 139
  if (! fpINfilename___0) {
    {
#line 140
    tmp___1 = malloc((size_t )81);
#line 140
    fpINfilename___0 = (char *)tmp___1;
    }
  }
  {
#line 142
  ch = inputLine(win->hex_outline, LINES - 1, 21);
  }
#line 144
  if ((int )*(ch + 0) == 27) {
    {
#line 146
    restoreBorder(win);
#line 147
    wrefresh(win->hex_outline);
    }
#line 148
    return (0);
  }
#line 151
  if ((int )*(ch + 0) != 0) {
    {
#line 152
    strncpy((char */* __restrict  */)fpINfilename___0, (char const   */* __restrict  */)ch,
            (size_t )80);
    }
  }
  {
#line 154
  tmpfp = fopen((char const   */* __restrict  */)fpINfilename___0, (char const   */* __restrict  */)"r");
  }
#line 154
  if (! tmpfp) {
    {
#line 156
    wmove(win->hex_outline, LINES - 1, 1);
#line 157
    wclrtoeol(win->hex_outline);
#line 160
    popupWin((char *)"Could not open file!", -1);
#line 161
    restoreBorder(win);
#line 162
    wnoutrefresh(win->hex_outline);
    }
#line 164
    return (0);
  }
  {
#line 167
  restoreBorder(win);
#line 169
  wrefresh(win->hex_outline);
#line 170
  fclose(tmpfp);
#line 172
  fpIN = fopen((char const   */* __restrict  */)fpINfilename___0, (char const   */* __restrict  */)"r");
#line 174
  wclear(win->hex);
#line 175
  wclear(win->ascii);
#line 176
  wclear(win->address);
#line 178
  refreshall(win);
#line 179
  doupdate();
  }
#line 180
  return (1);
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/file.c"
void savefile(WINS *win , char *fpINfilename___0 , char *fpOUTfilename___0 ) 
{ 
  char *ch ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 190
  tmp = malloc((size_t )81);
#line 190
  ch = (char *)tmp;
  }
#line 192
  if (! fpINfilename___0) {
    {
#line 193
    tmp___0 = malloc((size_t )81);
#line 193
    fpINfilename___0 = (char *)tmp___0;
    }
  }
  {
#line 195
  wmove(win->hex_outline, LINES - 1, 20);
#line 196
  wclrtoeol(win->hex_outline);
#line 197
  tmp___3 = strcmp((char const   *)fpOUTfilename___0, "");
  }
#line 197
  if (tmp___3) {
#line 197
    tmp___2 = fpOUTfilename___0;
  } else {
#line 197
    tmp___2 = fpINfilename___0;
  }
  {
#line 197
  mvwprintw(win->hex_outline, LINES - 1, 1, "Enter file to save: %s", tmp___2);
#line 200
  wrefresh(win->hex_outline);
#line 202
  ch = inputLine(win->hex_outline, LINES - 1, 21);
  }
#line 204
  if ((int )*(ch + 0) != 27) {
#line 206
    if ((int )*(ch + 0) != 0) {
      {
#line 207
      strncpy((char */* __restrict  */)fpOUTfilename___0, (char const   */* __restrict  */)ch,
              (size_t )80);
      }
    }
    {
#line 209
    tmp___5 = strlen((char const   *)fpINfilename___0);
#line 209
    tmp___6 = strncmp((char const   *)fpOUTfilename___0, (char const   *)fpINfilename___0,
                      tmp___5);
    }
#line 209
    if (! tmp___6) {
      {
#line 210
      tmp___4 = strlen((char const   *)fpOUTfilename___0);
#line 210
      bzero((void *)fpOUTfilename___0, tmp___4);
      }
    }
    {
#line 213
    tmp___7 = writeChanges(win, fpIN, fpOUT, fpINfilename___0, fpOUTfilename___0);
    }
#line 213
    if (! tmp___7) {
      {
#line 214
      popupWin((char *)"The file has been saved.", -1);
      }
    }
  }
  {
#line 217
  free((void *)ch);
#line 218
  restoreBorder(win);
#line 219
  wnoutrefresh(win->hex_outline);
  }
#line 220
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/file.c"
int hexSearch(FILE *fp , int *ch , int startfp , int length ) 
{ 
  int loop ;
  int tmp ;
  int c ;
  int flag ;
  long currLoc ;
  long startLoc ;
  long foundLoc ;

  {
  {
#line 230
  flag = 0;
#line 231
  foundLoc = -1L;
#line 233
  fseek(fp, (long )startfp, 0);
#line 235
  c = _IO_getc(fp);
#line 236
  currLoc = ftell(fp);
#line 237
  tmp = searchList(head, (int )(currLoc - 1L));
  }
#line 237
  if (tmp != -1) {
#line 238
    c = tmp;
  }
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! (currLoc != (long )startfp)) {
#line 240
      goto while_break;
    }
#line 242
    if (c == *(ch + 0)) {
      {
#line 244
      startLoc = ftell(fp);
#line 246
      loop = 1;
      }
      {
#line 246
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 246
        if (loop < length) {
#line 246
          if (! (c != -1)) {
#line 246
            goto while_break___0;
          }
        } else {
#line 246
          goto while_break___0;
        }
        {
#line 248
        c = fgetc(fp);
#line 249
        currLoc = ftell(fp);
#line 250
        tmp = searchList(head, (int )(currLoc - 1L));
        }
#line 250
        if (tmp != -1) {
#line 251
          c = tmp;
        }
#line 252
        if (c != *(ch + loop)) {
#line 253
          goto while_break___0;
        }
#line 246
        loop ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 257
      if (loop == length) {
#line 257
        if (flag) {
#line 258
          return ((int )(startLoc - 1L));
        } else {
#line 257
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 259
      if (loop == length) {
#line 260
        foundLoc = startLoc - 1L;
      }
    }
#line 263
    flag = 1;
#line 266
    if (c == -1) {
      {
#line 267
      rewind(fp);
      }
    }
    {
#line 269
    currLoc = ftell(fp);
    }
#line 271
    if (currLoc != (long )startfp) {
      {
#line 273
      c = fgetc(fp);
#line 274
      currLoc = ftell(fp);
#line 275
      tmp = searchList(head, (int )(currLoc - 1L));
      }
#line 275
      if (tmp != -1) {
#line 276
        c = tmp;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  return ((int )foundLoc);
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/file.c"
char *boyerMooreSearch(FILE *fp , char const   *str , int startfp , size_t textLen ) 
{ 
  unsigned int charJump[256] ;
  unsigned int *matchJump ;
  unsigned int *backUp ;
  size_t patLen ;
  unsigned int u ;
  unsigned int uText ;
  unsigned int uPat ;
  unsigned int uA ;
  unsigned int uB ;
  char text[97] ;
  void *tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 293
  patLen = strlen(str);
#line 295
  tmp = malloc((2UL * sizeof(unsigned int )) * (patLen + 1UL));
#line 295
  matchJump = (unsigned int *)tmp;
#line 297
  backUp = (matchJump + patLen) + 1;
#line 299
  memset((void *)(charJump), 0, 256UL * sizeof(unsigned int ));
#line 300
  u = 0U;
  }
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! ((size_t )u < patLen)) {
#line 300
      goto while_break;
    }
#line 301
    charJump[(unsigned char )*(str + u)] = (unsigned int )((patLen - (size_t )u) - 1UL);
#line 300
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 303
  u = 1U;
  {
#line 303
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 303
    if (! ((size_t )u <= patLen)) {
#line 303
      goto while_break___0;
    }
#line 304
    *(matchJump + u) = (unsigned int )(2UL * patLen - (size_t )u);
#line 303
    u ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 306
  u = (unsigned int )patLen;
#line 307
  uA = (unsigned int )(patLen + 1UL);
  {
#line 309
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 309
    if (! (u > 0U)) {
#line 309
      goto while_break___1;
    }
#line 311
    *(backUp + u) = uA;
    {
#line 312
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 312
      if ((size_t )uA <= patLen) {
#line 312
        if (! ((int const   )*(str + (u - 1U)) != (int const   )*(str + (uA - 1U)))) {
#line 312
          goto while_break___2;
        }
      } else {
#line 312
        goto while_break___2;
      }
#line 314
      if ((size_t )*(matchJump + uA) > patLen - (size_t )u) {
#line 315
        *(matchJump + uA) = (unsigned int )(patLen - (size_t )u);
      }
#line 317
      uA = *(backUp + uA);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 320
    u --;
#line 321
    uA --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 324
  u = 1U;
  {
#line 324
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 324
    if (! (u <= uA)) {
#line 324
      goto while_break___3;
    }
#line 325
    if ((size_t )*(matchJump + u) > (patLen + (size_t )uA) - (size_t )u) {
#line 326
      *(matchJump + u) = (unsigned int )((patLen + (size_t )uA) - (size_t )u);
    }
#line 324
    u ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 328
  uB = *(backUp + uA);
  {
#line 330
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 330
    if (! ((size_t )uA <= patLen)) {
#line 330
      goto while_break___4;
    }
    {
#line 332
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 332
      if (! (uA <= uB)) {
#line 332
        goto while_break___5;
      }
#line 334
      if ((size_t )*(matchJump + uA) > (size_t )(uB - uA) + patLen) {
#line 335
        *(matchJump + uA) = (unsigned int )((size_t )(uB - uA) + patLen);
      }
#line 337
      uA ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 339
    uB = *(backUp + uB);
  }
  while_break___4: /* CIL Label */ ;
  }
#line 342
  uPat = (unsigned int )patLen;
#line 343
  uText = (unsigned int )(patLen - 1UL);
  {
#line 344
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 344
    if ((size_t )uText < textLen) {
#line 344
      if (! (uPat != 0U)) {
#line 344
        goto while_break___6;
      }
    } else {
#line 344
      goto while_break___6;
    }
#line 346
    if ((int )text[uText] == (int )*(str + (uPat - 1U))) {
#line 348
      uText --;
#line 349
      uPat --;
    } else {
#line 353
      uA = charJump[(unsigned char )text[uText]];
#line 354
      uB = *(matchJump + uPat);
#line 355
      if (uA > uB) {
#line 355
        tmp___0 = uA;
      } else {
#line 355
        tmp___0 = uB;
      }
#line 355
      uText += tmp___0;
#line 356
      uPat = (unsigned int )patLen;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 360
  if (uPat == 0U) {
#line 361
    return (text + (uText + 1U));
  } else {
#line 363
    return ((char *)((void *)0));
  }
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/file.c"
int gotoLine(FILE *fp , int currLoc , int gotoLoc , int maxlines___0 , WINDOW *win ) 
{ 
  int count ;
  int currentLine___0 ;
  int row ;
  int col ;
  int tmp ;
  int linediff ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  WINDOW *tmp___7 ;
  int tmp___8 ;
  WINDOW *tmp___9 ;

  {
#line 374
  if (win) {
#line 374
    row = (int )win->_cury;
  } else {
#line 374
    row = -1;
  }
#line 374
  if (win) {
#line 374
    col = (int )win->_curx;
  } else {
#line 374
    col = -1;
  }
  {
#line 376
  restoreBorder(windows);
#line 378
  wrefresh(windows->hex_outline);
#line 379
  currentLine___0 = maxLines(gotoLoc);
  }
#line 381
  if (gotoLoc % BASE == 0) {
#line 382
    currentLine___0 ++;
  }
#line 391
  if (gotoLoc >= currLoc) {
#line 393
    tmp = currLoc - row * BASE;
#line 394
    if (tmp % BASE) {
      {
#line 394
      tmp___0 = maxLines(tmp);
#line 394
      tmp___2 = tmp___0;
      }
    } else {
      {
#line 394
      tmp ++;
#line 394
      tmp___1 = maxLines(tmp);
#line 394
      tmp___2 = tmp___1;
      }
    }
#line 394
    linediff = currentLine___0 - tmp___2;
  } else {
#line 398
    tmp = currLoc + (MAXY - row) * BASE;
#line 399
    if (tmp % BASE) {
      {
#line 399
      tmp___3 = maxLines(tmp);
#line 399
      tmp___5 = tmp___3;
      }
    } else {
      {
#line 399
      tmp ++;
#line 399
      tmp___4 = maxLines(tmp);
#line 399
      tmp___5 = tmp___4;
      }
    }
#line 399
    linediff = currentLine___0 - tmp___5;
#line 401
    if (linediff >= MAXY * -1) {
#line 401
      if (linediff < 1) {
#line 401
        linediff += MAXY;
      }
    }
  }
#line 404
  if (linediff < 1) {
#line 404
    linediff *= -1;
  }
#line 406
  if (linediff <= MAXY) {
#line 409
    if (editHex) {
#line 409
      tmp___6 = (gotoLoc % BASE) * 3;
    } else {
#line 409
      tmp___6 = gotoLoc % BASE;
    }
#line 409
    if (editHex) {
#line 409
      tmp___7 = windows->hex;
    } else {
#line 409
      tmp___7 = windows->ascii;
    }
    {
#line 409
    wmove(tmp___7, linediff, tmp___6);
    }
  } else {
    {
#line 415
    wclear(windows->hex);
#line 416
    wclear(windows->ascii);
#line 417
    wclear(windows->address);
#line 419
    wmove(windows->hex, 0, 0);
#line 420
    wmove(windows->ascii, 0, 0);
#line 421
    wmove(windows->address, 0, 0);
#line 423
    count = 0;
    }
    {
#line 423
    while (1) {
      while_continue: /* CIL Label */ ;
#line 423
      if (count <= MAXY) {
#line 423
        if (! (count + currentLine___0 <= maxlines___0)) {
#line 423
          goto while_break;
        }
      } else {
#line 423
        goto while_break;
      }
      {
#line 425
      outline(fp, count + currentLine___0);
#line 423
      count ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 427
    if (editHex) {
#line 427
      tmp___8 = (gotoLoc % BASE) * 3;
    } else {
#line 427
      tmp___8 = gotoLoc % BASE;
    }
#line 427
    if (editHex) {
#line 427
      tmp___9 = windows->hex;
    } else {
#line 427
      tmp___9 = windows->ascii;
    }
    {
#line 427
    wmove(tmp___9, 0, tmp___8);
    }
  }
  {
#line 437
  wnoutrefresh(windows->scrollbar);
#line 438
  wnoutrefresh(windows->ascii);
#line 439
  wnoutrefresh(windows->address);
#line 440
  wnoutrefresh(windows->hex);
#line 441
  doupdate();
  }
#line 443
  return (currentLine___0);
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/file.c"
int getLocVal(long loc ) 
{ 
  hexList *tmpHead ;
  int tmp ;

  {
#line 452
  tmpHead = head;
  {
#line 454
  while (1) {
    while_continue: /* CIL Label */ ;
#line 454
    if ((unsigned long )tmpHead != (unsigned long )((void *)0)) {
#line 454
      if (! (tmpHead->loc < loc)) {
#line 454
        goto while_break;
      }
    } else {
#line 454
      goto while_break;
    }
#line 455
    tmpHead = tmpHead->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  if ((unsigned long )tmpHead != (unsigned long )((void *)0)) {
#line 456
    if (tmpHead->loc == loc) {
#line 457
      return (tmpHead->val);
    }
  }
  {
#line 459
  fseek(fpIN, loc, 0);
#line 460
  tmp = fgetc(fpIN);
  }
#line 460
  return (tmp);
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/file.c"
_Bool inHexList(long loc ) 
{ 
  hexList *tmpHead ;

  {
#line 469
  tmpHead = head;
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if ((unsigned long )tmpHead != (unsigned long )((void *)0)) {
#line 471
      if (! (tmpHead->loc < loc)) {
#line 471
        goto while_break;
      }
    } else {
#line 471
      goto while_break;
    }
#line 472
    tmpHead = tmpHead->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 473
  if ((unsigned long )tmpHead != (unsigned long )((void *)0)) {
#line 473
    if (tmpHead->loc == loc) {
#line 474
      return ((_Bool)1);
    } else {
#line 476
      return ((_Bool)0);
    }
  } else {
#line 476
    return ((_Bool)0);
  }
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 755 "/usr/include/curses.h"
extern int slk_init(int  ) ;
#line 776
extern void use_env(_Bool  ) ;
#line 72 "../include/hex.h"
char *fpINfilename ;
#line 72
char *fpOUTfilename ;
#line 73 "../include/hex.h"
int MAXY  ;
#line 74 "../include/hex.h"
WINS *windows  ;
#line 75 "../include/hex.h"
hexList *head  ;
#line 76 "../include/hex.h"
int BASE  ;
#line 77 "../include/hex.h"
int hex_outline_width  ;
#line 78 "../include/hex.h"
int hex_win_width  ;
#line 79 "../include/hex.h"
int ascii_outline_width  ;
#line 80 "../include/hex.h"
int ascii_win_width  ;
#line 84 "../include/hex.h"
_Bool printHex  ;
#line 87 "../include/hex.h"
_Bool USE_EBCDIC  ;
#line 139
long parseArgs(int argc , char **argv , char *fpINfilename___0 , char *fpOUTfilename___0 ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/hexcurse.c"
int resize  =    0;
#line 33 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/hexcurse.c"
char *fpINfilename  =    (char *)((void *)0);
#line 33 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/hexcurse.c"
char *fpOUTfilename  =    (char *)((void *)0);
#line 38 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/hexcurse.c"
_Bool IN_HELP  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/hexcurse.c"
char EBCDIC[256]  = 
#line 46
  {      (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )' ',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'<',      (char )'(',      (char )'+',      (char )'|', 
        (char )'&',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'!',      (char )'$', 
        (char )'*',      (char )')',      (char )';',      (char )'.', 
        (char )'-',      (char )'/',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )',', 
        (char )'%',      (char )'_',      (char )'>',      (char )'?', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )':',      (char )'#', 
        (char )'@',      (char )'\'',      (char )'=',      (char )'\"', 
        (char )'.',      (char )'a',      (char )'b',      (char )'c', 
        (char )'d',      (char )'e',      (char )'f',      (char )'g', 
        (char )'h',      (char )'i',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'j',      (char )'k', 
        (char )'l',      (char )'m',      (char )'n',      (char )'o', 
        (char )'p',      (char )'q',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'r',      (char )'s',      (char )'t', 
        (char )'u',      (char )'v',      (char )'w',      (char )'x', 
        (char )'y',      (char )'z',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'`',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'A',      (char )'B',      (char )'C', 
        (char )'D',      (char )'E',      (char )'F',      (char )'G', 
        (char )'H',      (char )'I',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'J',      (char )'K', 
        (char )'L',      (char )'M',      (char )'N',      (char )'O', 
        (char )'P',      (char )'Q',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'.',      (char )'R',      (char )'S',      (char )'T', 
        (char )'U',      (char )'V',      (char )'W',      (char )'X', 
        (char )'Y',      (char )'Z',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'.',      (char )'.', 
        (char )'.',      (char )'.',      (char )'.',      (char )'.'};
#line 65 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/hexcurse.c"
int main(int argc , char **argv ) 
{ 
  int row ;
  int col ;
  int x ;
  int retval ;
  int val ;
  long len ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 68
  retval = 1;
#line 71
  tmp = malloc(sizeof(WINS ));
#line 71
  windows = (WINS *)tmp;
#line 72
  tmp___0 = calloc((size_t )1, sizeof(struct LinkedList ));
#line 72
  head = (struct LinkedList *)tmp___0;
#line 73
  tmp___1 = malloc((size_t )81);
#line 73
  fpINfilename = (char *)tmp___1;
#line 74
  tmp___2 = malloc((size_t )81);
#line 74
  fpOUTfilename = (char *)tmp___2;
#line 75
  printHex = (_Bool)1;
#line 76
  USE_EBCDIC = (_Bool)0;
#line 79
  len = parseArgs(argc, argv, fpINfilename, fpOUTfilename);
#line 81
  use_env((_Bool)1);
#line 82
  slk_init(0);
#line 83
  init_screen();
  }
#line 85
  if (COLS < 70) {
    {
#line 87
    endwin();
#line 88
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\nThe screen size too small.\nThe minimum allowable");
#line 89
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" screen size is %dx%d\n\n",
            70, 8);
#line 90
    exit(-1);
    }
  } else
#line 85
  if (LINES < 7) {
    {
#line 87
    endwin();
#line 88
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n\nThe screen size too small.\nThe minimum allowable");
#line 89
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" screen size is %dx%d\n\n",
            70, 8);
#line 90
    exit(-1);
    }
  }
#line 93
  if (resize > 0) {
#line 93
    if (resize < COLS) {
#line 93
      BASE = resize;
    } else {
#line 93
      BASE = (COLS - 14) / 4;
    }
  } else {
#line 93
    BASE = (COLS - 14) / 4;
  }
#line 94
  MAXY = LINES - 3;
#line 95
  hex_win_width = BASE * 3;
#line 96
  ascii_win_width = BASE;
#line 97
  hex_outline_width = BASE * 3 + 11;
#line 98
  ascii_outline_width = BASE + 2;
#line 100
  if (printHex) {
#line 100
    tmp___3 = "Hex Addr";
  } else {
#line 100
    tmp___3 = "Dec Addr";
  }
  {
#line 100
  slk_set(6, tmp___3, 1);
#line 101
  init_fkeys();
#line 102
  init_menu(windows);
  }
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! retval) {
#line 105
      goto while_break;
    }
    {
#line 107
    head = freeList(head);
#line 109
    mvwprintw(windows->hex_outline, 0, 1, "00000000");
    }
#line 111
    if ((unsigned long )fpIN != (unsigned long )((void *)0)) {
      {
#line 113
      tmp___4 = maxLoc(fpIN);
#line 113
      len = (long )tmp___4;
#line 114
      val = maxLines((int )len);
#line 115
      x = 0;
      }
      {
#line 115
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 115
        if (x <= MAXY) {
#line 115
          if (! (x <= val)) {
#line 115
            goto while_break___0;
          }
        } else {
#line 115
          goto while_break___0;
        }
        {
#line 116
        outline(fpIN, x);
#line 115
        x ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 119
    wmove(windows->hex, 0, 0);
#line 120
    col = 0;
#line 120
    row = col;
#line 122
    refreshall(windows);
#line 123
    doupdate();
#line 125
    tmp___5 = wmove(windows->scrollbar, 1, 0);
    }
#line 125
    if (! (tmp___5 == -1)) {
      {
#line 125
      waddch(windows->scrollbar, (chtype const   )acs_map[(unsigned char )'a']);
      }
    }
    {
#line 127
    retval = wacceptch(windows, len, fpINfilename, fpOUTfilename);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 130
  screen_exit(0);
  }
#line 131
  return (retval);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/hexcurse.c"
long parseArgs(int argc , char **argv , char *fpINfilename___0 , char *fpOUTfilename___0 ) 
{ 
  int val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 173
    val = hgetopt(argc, (char * const  *)argv, "a:i:o:r:e");
    }
#line 173
    if (! (val != -1)) {
#line 173
      goto while_break;
    }
    {
#line 177
    if (val == 97) {
#line 177
      goto case_97;
    }
#line 180
    if (val == 105) {
#line 180
      goto case_105;
    }
#line 183
    if (val == 111) {
#line 183
      goto case_111;
    }
#line 186
    if (val == 114) {
#line 186
      goto case_114;
    }
#line 189
    if (val == 101) {
#line 189
      goto case_101;
    }
#line 193
    if (val == 63) {
#line 193
      goto case_63;
    }
#line 175
    goto switch_break;
    case_97: /* CIL Label */ 
#line 177
    printHex = (_Bool)0;
#line 178
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 180
    strncpy((char */* __restrict  */)fpINfilename___0, (char const   */* __restrict  */)optarg,
            (size_t )80);
    }
#line 181
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 183
    strncpy((char */* __restrict  */)fpOUTfilename___0, (char const   */* __restrict  */)optarg,
            (size_t )80);
    }
#line 184
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 186
    resize = atoi((char const   *)optarg);
    }
#line 187
    goto switch_break;
    case_101: /* CIL Label */ 
#line 189
    USE_EBCDIC = (_Bool)1;
#line 190
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 193
    print_usage();
    }
#line 194
    if (optopt == 104) {
      {
#line 195
      exit(0);
      }
    } else
#line 194
    if (optopt == 63) {
      {
#line 195
      exit(0);
      }
    } else {
      {
#line 197
      exit(-1);
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  argc -= optind;
#line 201
  argv += optind;
#line 203
  if (*(argv + 0)) {
    {
#line 204
    strncpy((char */* __restrict  */)fpINfilename___0, (char const   */* __restrict  */)*(argv + 0),
            (size_t )80);
    }
  }
  {
#line 206
  tmp = strcmp((char const   *)fpINfilename___0, "");
  }
#line 206
  if (tmp) {
    {
#line 207
    fpIN = fopen((char const   */* __restrict  */)fpINfilename___0, (char const   */* __restrict  */)"r");
    }
#line 207
    if ((unsigned long )fpIN == (unsigned long )((void *)0)) {
      {
#line 208
      exit_err((char *)"Could not open file");
      }
    }
  }
#line 210
  if ((unsigned long )fpIN != (unsigned long )((void *)0)) {
    {
#line 210
    tmp___0 = maxLoc(fpIN);
#line 210
    tmp___1 = tmp___0;
    }
  } else {
#line 210
    tmp___1 = 0;
  }
#line 210
  return ((long )tmp___1);
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/hexcurse-1.55/src/hexcurse.c"
void catchSegfault(int sig ) 
{ 


  {
  {
#line 222
  endwin();
#line 223
  printf((char const   */* __restrict  */)"\n\nHexcurse has encountered a segmentation fault!\n");
#line 224
  printf((char const   */* __restrict  */)"\tPlease submit a full bug report to devel@jewfish.net.\n");
#line 225
  printf((char const   */* __restrict  */)"\tInclude what you did to cause the segfault, and if possible\n");
#line 226
  printf((char const   */* __restrict  */)"\tinclude the core dump.  And for your troubles, we\'ll add you \n");
#line 227
  printf((char const   */* __restrict  */)"\tto the Changelog. Then you can brag to your friends about it!\n");
#line 229
  exit(-1);
  }
}
}
