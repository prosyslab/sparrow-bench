/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 368 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned char Byte;
#line 370 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned int uInt;
#line 371 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned long uLong;
#line 377 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef Byte Bytef;
#line 386 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef void *voidpf;
#line 83 "/usr/include/zlib.h"
struct internal_state;
#line 83
struct internal_state;
#line 85 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 85 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 106 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1742 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/ciso-1.0.0/ciso.h"
struct ciso_header {
   unsigned char magic[4] ;
   unsigned long header_size ;
   unsigned long long total_bytes ;
   unsigned long block_size ;
   unsigned char ver ;
   unsigned char align ;
   unsigned char rsv_06[2] ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/ciso-1.0.0/ciso.h"
typedef struct ciso_header CISO_H;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 246 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 353
extern int deflateEnd(z_streamp strm ) ;
#line 392
extern int inflate(z_streamp strm , int flush ) ;
#line 508
extern int inflateEnd(z_streamp strm ) ;
#line 1637
extern int deflateInit2_(z_streamp strm , int level , int method , int windowBits ,
                         int memLevel , int strategy , char const   *version , int stream_size ) ;
#line 1641
extern int inflateInit2_(z_streamp strm , int windowBits , char const   *version ,
                         int stream_size ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/ciso-1.0.0/ciso.c"
char const   *fname_in  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/ciso-1.0.0/ciso.c"
char const   *fname_out  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/ciso-1.0.0/ciso.c"
FILE *fin  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/ciso-1.0.0/ciso.c"
FILE *fout  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/ciso-1.0.0/ciso.c"
z_stream z  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/ciso-1.0.0/ciso.c"
unsigned int *index_buf  =    (unsigned int *)((void *)0);
#line 35 "/home/june/repo/benchmarks/collector/temp/ciso-1.0.0/ciso.c"
unsigned int *crc_buf  =    (unsigned int *)((void *)0);
#line 36 "/home/june/repo/benchmarks/collector/temp/ciso-1.0.0/ciso.c"
unsigned char *block_buf1  =    (unsigned char *)((void *)0);
#line 37 "/home/june/repo/benchmarks/collector/temp/ciso-1.0.0/ciso.c"
unsigned char *block_buf2  =    (unsigned char *)((void *)0);
#line 43 "/home/june/repo/benchmarks/collector/temp/ciso-1.0.0/ciso.c"
CISO_H ciso  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/ciso-1.0.0/ciso.c"
int ciso_total_block  ;
#line 56
extern int ( /* missing proto */  memset)() ;
#line 46 "/home/june/repo/benchmarks/collector/temp/ciso-1.0.0/ciso.c"
unsigned long long check_file_size(FILE *fp ) 
{ 
  unsigned long long pos ;
  int tmp ;
  long tmp___0 ;

  {
  {
#line 50
  tmp = fseek(fp, 0L, 2);
  }
#line 50
  if (tmp < 0) {
#line 51
    return (0xffffffffffffffffULL);
  }
  {
#line 52
  tmp___0 = ftell(fp);
#line 52
  pos = (unsigned long long )tmp___0;
  }
#line 53
  if (pos == 0xffffffffffffffffULL) {
#line 53
    return (pos);
  }
  {
#line 56
  memset(& ciso, 0, sizeof(ciso));
#line 58
  ciso.magic[0] = (unsigned char )'C';
#line 59
  ciso.magic[1] = (unsigned char )'I';
#line 60
  ciso.magic[2] = (unsigned char )'S';
#line 61
  ciso.magic[3] = (unsigned char )'O';
#line 62
  ciso.ver = (unsigned char)1;
#line 64
  ciso.block_size = 2048UL;
#line 65
  ciso.total_bytes = pos;
#line 71
  ciso_total_block = (int )(pos / (unsigned long long )ciso.block_size);
#line 73
  fseek(fp, 0L, 0);
  }
#line 75
  return (pos);
}
}
#line 194
extern int ( /* missing proto */  memcpy)() ;
#line 81 "/home/june/repo/benchmarks/collector/temp/ciso-1.0.0/ciso.c"
int decomp_ciso(void) 
{ 
  unsigned int index ;
  unsigned int index2 ;
  unsigned long long read_pos ;
  unsigned long long read_size ;
  int index_size ;
  int block ;
  int cmp_size ;
  int status ;
  int percent_period ;
  int percent_cnt ;
  int plain ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  char const   *tmp___7 ;
  size_t tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 97
  tmp = fread((void */* __restrict  */)(& ciso), (size_t )1, sizeof(ciso), (FILE */* __restrict  */)fin);
  }
#line 97
  if (tmp != sizeof(ciso)) {
    {
#line 99
    printf((char const   */* __restrict  */)"file read error\n");
    }
#line 100
    return (1);
  }
#line 104
  if ((int )ciso.magic[0] != 67) {
    {
#line 113
    printf((char const   */* __restrict  */)"ciso file format error\n");
    }
#line 114
    return (1);
  } else
#line 104
  if ((int )ciso.magic[1] != 73) {
    {
#line 113
    printf((char const   */* __restrict  */)"ciso file format error\n");
    }
#line 114
    return (1);
  } else
#line 104
  if ((int )ciso.magic[2] != 83) {
    {
#line 113
    printf((char const   */* __restrict  */)"ciso file format error\n");
    }
#line 114
    return (1);
  } else
#line 104
  if ((int )ciso.magic[3] != 79) {
    {
#line 113
    printf((char const   */* __restrict  */)"ciso file format error\n");
    }
#line 114
    return (1);
  } else
#line 104
  if (ciso.block_size == 0UL) {
    {
#line 113
    printf((char const   */* __restrict  */)"ciso file format error\n");
    }
#line 114
    return (1);
  } else
#line 104
  if (ciso.total_bytes == 0ULL) {
    {
#line 113
    printf((char const   */* __restrict  */)"ciso file format error\n");
    }
#line 114
    return (1);
  }
  {
#line 117
  ciso_total_block = (int )(ciso.total_bytes / (unsigned long long )ciso.block_size);
#line 120
  index_size = (int )((unsigned long )(ciso_total_block + 1) * sizeof(unsigned long ));
#line 121
  tmp___0 = malloc((size_t )index_size);
#line 121
  index_buf = (unsigned int *)tmp___0;
#line 122
  tmp___1 = malloc(ciso.block_size);
#line 122
  block_buf1 = (unsigned char *)tmp___1;
#line 123
  tmp___2 = malloc(ciso.block_size * 2UL);
#line 123
  block_buf2 = (unsigned char *)tmp___2;
  }
#line 125
  if (! index_buf) {
    {
#line 127
    printf((char const   */* __restrict  */)"Can\'t allocate memory\n");
    }
#line 128
    return (1);
  } else
#line 125
  if (! block_buf1) {
    {
#line 127
    printf((char const   */* __restrict  */)"Can\'t allocate memory\n");
    }
#line 128
    return (1);
  } else
#line 125
  if (! block_buf2) {
    {
#line 127
    printf((char const   */* __restrict  */)"Can\'t allocate memory\n");
    }
#line 128
    return (1);
  }
  {
#line 130
  memset(index_buf, 0, index_size);
#line 133
  tmp___3 = fread((void */* __restrict  */)index_buf, (size_t )1, (size_t )index_size,
                  (FILE */* __restrict  */)fin);
  }
#line 133
  if (tmp___3 != (size_t )index_size) {
    {
#line 135
    printf((char const   */* __restrict  */)"file read error\n");
    }
#line 136
    return (1);
  }
  {
#line 140
  printf((char const   */* __restrict  */)"Decompress \'%s\' to \'%s\'\n", fname_in,
         fname_out);
#line 141
  printf((char const   */* __restrict  */)"Total File Size %ld bytes\n", ciso.total_bytes);
#line 142
  printf((char const   */* __restrict  */)"block size      %d  bytes\n", ciso.block_size);
#line 143
  printf((char const   */* __restrict  */)"total blocks    %d  blocks\n", ciso_total_block);
#line 144
  printf((char const   */* __restrict  */)"index align     %d\n", 1 << (int )ciso.align);
#line 147
  z.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
#line 148
  z.zfree = (void (*)(voidpf opaque , voidpf address ))0;
#line 149
  z.opaque = (voidpf )0;
#line 152
  percent_period = ciso_total_block / 100;
#line 153
  percent_cnt = 0;
#line 155
  block = 0;
  }
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! (block < ciso_total_block)) {
#line 155
      goto while_break;
    }
#line 157
    percent_cnt --;
#line 157
    if (percent_cnt <= 0) {
      {
#line 159
      percent_cnt = percent_period;
#line 160
      printf((char const   */* __restrict  */)"decompress %d%%\r", block / percent_period);
      }
    }
    {
#line 163
    tmp___5 = inflateInit2_(& z, -15, "1.2.8", (int )sizeof(z_stream ));
    }
#line 163
    if (tmp___5 != 0) {
#line 165
      if (z.msg) {
#line 165
        tmp___4 = (char const   *)z.msg;
      } else {
#line 165
        tmp___4 = "???";
      }
      {
#line 165
      printf((char const   */* __restrict  */)"deflateInit : %s\n", tmp___4);
      }
#line 166
      return (1);
    }
#line 170
    index = *(index_buf + block);
#line 171
    plain = (int )(index & 2147483648U);
#line 172
    index &= 2147483647U;
#line 173
    read_pos = (unsigned long long )(index << (int )ciso.align);
#line 174
    if (plain) {
#line 176
      read_size = (unsigned long long )ciso.block_size;
    } else {
#line 180
      index2 = *(index_buf + (block + 1)) & 2147483647U;
#line 181
      read_size = (unsigned long long )((index2 - index) << (int )ciso.align);
    }
    {
#line 183
    fseek(fin, (long )read_pos, 0);
#line 185
    tmp___6 = fread((void */* __restrict  */)block_buf2, (size_t )1, (size_t )read_size,
                    (FILE */* __restrict  */)fin);
#line 185
    z.avail_in = (uInt )tmp___6;
    }
#line 186
    if ((unsigned long long )z.avail_in != read_size) {
      {
#line 188
      printf((char const   */* __restrict  */)"block=%d : read error\n", block);
      }
#line 189
      return (1);
    }
#line 192
    if (plain) {
      {
#line 194
      memcpy(block_buf1, block_buf2, read_size);
#line 195
      cmp_size = (int )read_size;
      }
    } else {
      {
#line 199
      z.next_out = block_buf1;
#line 200
      z.avail_out = (uInt )ciso.block_size;
#line 201
      z.next_in = block_buf2;
#line 202
      status = inflate(& z, 3);
      }
#line 203
      if (status != 1) {
#line 206
        if (z.msg) {
#line 206
          tmp___7 = (char const   *)z.msg;
        } else {
#line 206
          tmp___7 = "error";
        }
        {
#line 206
        printf((char const   */* __restrict  */)"block %d:inflate : %s[%d]\n", block,
               tmp___7, status);
        }
#line 207
        return (1);
      }
#line 209
      cmp_size = (int )(ciso.block_size - (unsigned long )z.avail_out);
#line 210
      if ((unsigned long )cmp_size != ciso.block_size) {
        {
#line 212
        printf((char const   */* __restrict  */)"block %d : block size error %d != %d\n",
               block, cmp_size, ciso.block_size);
        }
#line 213
        return (1);
      }
    }
    {
#line 217
    tmp___8 = fwrite((void const   */* __restrict  */)block_buf1, (size_t )1, (size_t )cmp_size,
                     (FILE */* __restrict  */)fout);
    }
#line 217
    if (tmp___8 != (size_t )cmp_size) {
      {
#line 219
      printf((char const   */* __restrict  */)"block %d : Write error\n", block);
      }
#line 220
      return (1);
    }
    {
#line 224
    tmp___10 = inflateEnd(& z);
    }
#line 224
    if (tmp___10 != 0) {
#line 226
      if (z.msg) {
#line 226
        tmp___9 = (char const   *)z.msg;
      } else {
#line 226
        tmp___9 = "error";
      }
      {
#line 226
      printf((char const   */* __restrict  */)"inflateEnd : %s\n", tmp___9);
      }
#line 227
      return (1);
    }
#line 155
    block ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 231
  printf((char const   */* __restrict  */)"ciso decompress completed\n");
  }
#line 232
  return (0);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/ciso-1.0.0/ciso.c"
int comp_ciso(int level ) 
{ 
  unsigned long long file_size ;
  unsigned long long write_pos ;
  int index_size ;
  int block ;
  unsigned char buf4[64] ;
  int cmp_size ;
  int status ;
  int percent_period ;
  int percent_cnt ;
  int align ;
  int align_b ;
  int align_m ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  unsigned long long tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char const   *tmp___8 ;
  size_t tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 252
  file_size = check_file_size(fin);
  }
#line 253
  if (file_size < 0ULL) {
    {
#line 255
    printf((char const   */* __restrict  */)"Can\'t get file size\n");
    }
#line 256
    return (1);
  }
  {
#line 260
  index_size = (int )((unsigned long )(ciso_total_block + 1) * sizeof(unsigned long ));
#line 261
  tmp = malloc((size_t )index_size);
#line 261
  index_buf = (unsigned int *)tmp;
#line 262
  tmp___0 = malloc((size_t )index_size);
#line 262
  crc_buf = (unsigned int *)tmp___0;
#line 263
  tmp___1 = malloc(ciso.block_size);
#line 263
  block_buf1 = (unsigned char *)tmp___1;
#line 264
  tmp___2 = malloc(ciso.block_size * 2UL);
#line 264
  block_buf2 = (unsigned char *)tmp___2;
  }
#line 266
  if (! index_buf) {
    {
#line 268
    printf((char const   */* __restrict  */)"Can\'t allocate memory\n");
    }
#line 269
    return (1);
  } else
#line 266
  if (! crc_buf) {
    {
#line 268
    printf((char const   */* __restrict  */)"Can\'t allocate memory\n");
    }
#line 269
    return (1);
  } else
#line 266
  if (! block_buf1) {
    {
#line 268
    printf((char const   */* __restrict  */)"Can\'t allocate memory\n");
    }
#line 269
    return (1);
  } else
#line 266
  if (! block_buf2) {
    {
#line 268
    printf((char const   */* __restrict  */)"Can\'t allocate memory\n");
    }
#line 269
    return (1);
  }
  {
#line 271
  memset(index_buf, 0, index_size);
#line 272
  memset(crc_buf, 0, index_size);
#line 273
  memset(buf4, 0, sizeof(buf4));
#line 276
  z.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
#line 277
  z.zfree = (void (*)(voidpf opaque , voidpf address ))0;
#line 278
  z.opaque = (voidpf )0;
#line 281
  printf((char const   */* __restrict  */)"Compress \'%s\' to \'%s\'\n", fname_in,
         fname_out);
#line 282
  printf((char const   */* __restrict  */)"Total File Size %ld bytes\n", ciso.total_bytes);
#line 283
  printf((char const   */* __restrict  */)"block size      %d  bytes\n", ciso.block_size);
#line 284
  printf((char const   */* __restrict  */)"index align     %d\n", 1 << (int )ciso.align);
#line 285
  printf((char const   */* __restrict  */)"compress level  %d\n", level);
#line 288
  fwrite((void const   */* __restrict  */)(& ciso), (size_t )1, sizeof(ciso), (FILE */* __restrict  */)fout);
#line 291
  fwrite((void const   */* __restrict  */)index_buf, (size_t )1, (size_t )index_size,
         (FILE */* __restrict  */)fout);
#line 293
  write_pos = (unsigned long long )(sizeof(ciso) + (unsigned long )index_size);
#line 296
  percent_period = ciso_total_block / 100;
#line 297
  percent_cnt = ciso_total_block / 100;
#line 299
  align_b = 1 << (int )ciso.align;
#line 300
  align_m = align_b - 1;
#line 302
  block = 0;
  }
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    if (! (block < ciso_total_block)) {
#line 302
      goto while_break;
    }
#line 304
    percent_cnt --;
#line 304
    if (percent_cnt <= 0) {
#line 306
      percent_cnt = percent_period;
#line 307
      if (block == 0) {
#line 307
        tmp___3 = 0ULL;
      } else {
#line 307
        tmp___3 = (100ULL * write_pos) / (unsigned long long )(block * 2048);
      }
      {
#line 307
      printf((char const   */* __restrict  */)"compress %3d%% avarage rate %3d%%\r",
             block / percent_period, tmp___3);
      }
    }
    {
#line 312
    tmp___5 = deflateInit2_(& z, level, 8, -15, 8, 0, "1.2.8", (int )sizeof(z_stream ));
    }
#line 312
    if (tmp___5 != 0) {
#line 314
      if (z.msg) {
#line 314
        tmp___4 = (char const   *)z.msg;
      } else {
#line 314
        tmp___4 = "???";
      }
      {
#line 314
      printf((char const   */* __restrict  */)"deflateInit : %s\n", tmp___4);
      }
#line 315
      return (1);
    }
#line 319
    align = (int )write_pos & align_m;
#line 320
    if (align) {
      {
#line 322
      align = align_b - align;
#line 323
      tmp___6 = fwrite((void const   */* __restrict  */)(buf4), (size_t )1, (size_t )align,
                       (FILE */* __restrict  */)fout);
      }
#line 323
      if (tmp___6 != (size_t )align) {
        {
#line 325
        printf((char const   */* __restrict  */)"block %d : Write error\n", block);
        }
#line 326
        return (1);
      }
#line 328
      write_pos += (unsigned long long )align;
    }
    {
#line 332
    *(index_buf + block) = (unsigned int )(write_pos >> (int )ciso.align);
#line 335
    z.next_out = block_buf2;
#line 336
    z.avail_out = (uInt )(ciso.block_size * 2UL);
#line 337
    z.next_in = block_buf1;
#line 338
    tmp___7 = fread((void */* __restrict  */)block_buf1, (size_t )1, ciso.block_size,
                    (FILE */* __restrict  */)fin);
#line 338
    z.avail_in = (uInt )tmp___7;
    }
#line 339
    if ((unsigned long )z.avail_in != ciso.block_size) {
      {
#line 341
      printf((char const   */* __restrict  */)"block=%d : read error\n", block);
      }
#line 342
      return (1);
    }
    {
#line 347
    status = deflate(& z, 4);
    }
#line 348
    if (status != 1) {
#line 351
      if (z.msg) {
#line 351
        tmp___8 = (char const   *)z.msg;
      } else {
#line 351
        tmp___8 = "error";
      }
      {
#line 351
      printf((char const   */* __restrict  */)"block %d:deflate : %s[%d]\n", block,
             tmp___8, status);
      }
#line 352
      return (1);
    }
#line 355
    cmp_size = (int )(ciso.block_size * 2UL - (unsigned long )z.avail_out);
#line 358
    if ((unsigned long )cmp_size >= ciso.block_size) {
      {
#line 360
      cmp_size = (int )ciso.block_size;
#line 361
      memcpy(block_buf2, block_buf1, cmp_size);
#line 363
      *(index_buf + block) |= 2147483648U;
      }
    }
    {
#line 367
    tmp___9 = fwrite((void const   */* __restrict  */)block_buf2, (size_t )1, (size_t )cmp_size,
                     (FILE */* __restrict  */)fout);
    }
#line 367
    if (tmp___9 != (size_t )cmp_size) {
      {
#line 369
      printf((char const   */* __restrict  */)"block %d : Write error\n", block);
      }
#line 370
      return (1);
    }
    {
#line 374
    write_pos += (unsigned long long )cmp_size;
#line 377
    tmp___11 = deflateEnd(& z);
    }
#line 377
    if (tmp___11 != 0) {
#line 379
      if (z.msg) {
#line 379
        tmp___10 = (char const   *)z.msg;
      } else {
#line 379
        tmp___10 = "error";
      }
      {
#line 379
      printf((char const   */* __restrict  */)"deflateEnd : %s\n", tmp___10);
      }
#line 380
      return (1);
    }
#line 302
    block ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 385
  *(index_buf + block) = (unsigned int )(write_pos >> (int )ciso.align);
#line 388
  fseek(fout, (long )sizeof(ciso), 0);
#line 389
  fwrite((void const   */* __restrict  */)index_buf, (size_t )1, (size_t )index_size,
         (FILE */* __restrict  */)fout);
#line 391
  printf((char const   */* __restrict  */)"ciso compress completed , total size = %8d bytes , rate %d%%\n",
         (int )write_pos, (int )((write_pos * 100ULL) / ciso.total_bytes));
  }
#line 393
  return (0);
}
}
#line 399 "/home/june/repo/benchmarks/collector/temp/ciso-1.0.0/ciso.c"
int main(int argc , char **argv ) 
{ 
  int level ;
  int result ;

  {
  {
#line 404
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Compressed ISO9660 converter Ver.1.01 by BOOSTER\n");
  }
#line 406
  if (argc != 4) {
    {
#line 408
    printf((char const   */* __restrict  */)"Usage: ciso level infile outfile\n");
#line 409
    printf((char const   */* __restrict  */)"  level: 1-9 compress ISO to CSO (1=fast/large - 9=small/slow\n");
#line 410
    printf((char const   */* __restrict  */)"         0   decompress CSO to ISO\n");
    }
#line 411
    return (0);
  }
#line 413
  level = (int )*(*(argv + 1) + 0) - 48;
#line 414
  if (level < 0) {
    {
#line 416
    printf((char const   */* __restrict  */)"Unknown mode: %c\n", (int )*(*(argv + 1) + 0));
    }
#line 417
    return (1);
  } else
#line 414
  if (level > 9) {
    {
#line 416
    printf((char const   */* __restrict  */)"Unknown mode: %c\n", (int )*(*(argv + 1) + 0));
    }
#line 417
    return (1);
  }
  {
#line 420
  fname_in = (char const   *)*(argv + 2);
#line 421
  fname_out = (char const   *)*(argv + 3);
#line 423
  fin = fopen((char const   */* __restrict  */)fname_in, (char const   */* __restrict  */)"rb");
  }
#line 423
  if ((unsigned long )fin == (unsigned long )((void *)0)) {
    {
#line 425
    printf((char const   */* __restrict  */)"Can\'t open %s\n", fname_in);
    }
#line 426
    return (1);
  }
  {
#line 428
  fout = fopen((char const   */* __restrict  */)fname_out, (char const   */* __restrict  */)"wb");
  }
#line 428
  if ((unsigned long )fout == (unsigned long )((void *)0)) {
    {
#line 430
    printf((char const   */* __restrict  */)"Can\'t create %s\n", fname_out);
    }
#line 431
    return (1);
  }
#line 434
  if (level == 0) {
    {
#line 435
    result = decomp_ciso();
    }
  } else {
    {
#line 437
    result = comp_ciso(level);
    }
  }
#line 440
  if (index_buf) {
    {
#line 440
    free((void *)index_buf);
    }
  }
#line 441
  if (crc_buf) {
    {
#line 441
    free((void *)crc_buf);
    }
  }
#line 442
  if (block_buf1) {
    {
#line 442
    free((void *)block_buf1);
    }
  }
#line 443
  if (block_buf2) {
    {
#line 443
    free((void *)block_buf2);
    }
  }
  {
#line 446
  fclose(fin);
#line 447
  fclose(fout);
  }
#line 448
  return (result);
}
}
