/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/wait.h"
union wait;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_44 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_45 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_44 __wait_terminated ;
   struct __anonstruct___wait_stopped_45 __wait_stopped ;
};
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 4 "/home/wheatley/newnew/temp/ninja-0.1.3/src/proc.h"
struct proc_info {
   pid_t pid ;
   pid_t ppid ;
   uid_t uid ;
   gid_t gid ;
   char name[128] ;
};
#line 10 "/home/wheatley/newnew/temp/ninja-0.1.3/src/common.h"
struct options {
   int daemon ;
   int interval ;
   int quiet ;
   int nokill ;
   int nokillppid ;
   int noroot ;
   int logwlist ;
   int rinitw ;
   gid_t group ;
   char logfile[128] ;
   char command[128] ;
   char wlist[128] ;
   int soffset ;
};
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 20 "/home/wheatley/newnew/temp/ninja-0.1.3/src/proto.h"
void LOG(char *fmt  , ...) ;
#line 21
void die(char *fmt  , ...) ;
#line 36
void sighandler(int s ) ;
#line 8 "/home/wheatley/newnew/temp/ninja-0.1.3/src/signal.c"
void sighandler(int s ) 
{ 


  {
  {
#line 12
  if (s == 17) {
#line 12
    goto case_17;
  }
#line 16
  if (s == 11) {
#line 16
    goto case_11;
  }
#line 20
  if (s == 2) {
#line 20
    goto case_2;
  }
#line 24
  if (s == 3) {
#line 24
    goto case_3;
  }
#line 28
  goto switch_default;
  case_17: /* CIL Label */ 
  {
#line 13
  wait((union wait *)((void *)0));
  }
#line 14
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 17
  die((char *)"got signal SIGSEGV -- segmentation fault");
  }
#line 18
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 21
  die((char *)"got signal SIGINT -- terminating");
  }
#line 22
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 25
  die((char *)"got signal SIGQUIT -- terminating");
  }
#line 26
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 29
  LOG((char *)"ignored signal: %d", s);
  }
  switch_break: /* CIL Label */ ;
  }
#line 32
  return;
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 717
extern int system(char const   *__command ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 8 "/home/wheatley/newnew/temp/ninja-0.1.3/src/proto.h"
void main_loop(int mgroup , int cycledelay , char *wlist ) ;
#line 9
int *get_active_pids(void) ;
#line 12
int check_group(char const   *user , gid_t const   gid ) ;
#line 13
char *get_user(uid_t uid ) ;
#line 17
int get_proc_info(pid_t const   pid , struct proc_info *pi ) ;
#line 28
int wlist_match(char *wlist , pid_t pid , uid_t uid , gid_t gid ) ;
#line 43
int file_isregular(char *fpath ) ;
#line 44
long file_size(char *fpath ) ;
#line 14 "/home/wheatley/newnew/temp/ninja-0.1.3/src/mloop.c"
struct options global_opts ;
#line 16 "/home/wheatley/newnew/temp/ninja-0.1.3/src/mloop.c"
void main_loop(int mgroup , int cycledelay , char *wlist ) 
{ 
  int root_pids[32768] ;
  int *active_pids___0 ;
  int i ;
  int j ;
  int rinitw_trap ;
  int file_mess ;
  struct proc_info pi ;
  struct proc_info ppi ;
  pid_t evil_pid ;
  pid_t evil_ppid ;
  char evil_pid_name[4097] ;
  char evil_ppid_name[4097] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  char *tmp___8 ;
  char extcmd[256] ;
  char *tmp___9 ;
  __pid_t tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 30
  LOG((char *)"generating initial pid array..");
#line 34
  i = 0;
  }
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (! (i < 32768)) {
#line 34
      goto while_break;
    }
    {
#line 35
    root_pids[i] = 0;
#line 36
    tmp = get_proc_info((pid_t const   )i, & pi);
    }
#line 36
    if (tmp != -1) {
#line 36
      if (pi.uid == 0U) {
#line 37
        root_pids[i] = 1;
      } else
#line 36
      if (pi.gid == 0U) {
#line 37
        root_pids[i] = 1;
      }
    }
#line 34
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 40
  LOG((char *)"now monitoring process activity");
  }
  {
#line 43
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 45
    active_pids___0 = get_active_pids();
#line 49
    i = global_opts.soffset;
    }
    {
#line 49
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 49
      if (! (i < 32768)) {
#line 49
        goto while_break___1;
      }
#line 51
      if (*(active_pids___0 + i) == 0) {
#line 52
        goto __Cont;
      }
      {
#line 57
      tmp___14 = get_proc_info((pid_t const   )i, & pi);
      }
#line 57
      if (tmp___14 != -1) {
#line 57
        if (pi.uid == 0U) {
#line 57
          goto _L___2;
        } else
#line 57
        if (pi.gid == 0U) {
          _L___2: /* CIL Label */ 
#line 59
          if (root_pids[i] != 1) {
            {
#line 64
            root_pids[i] = 1;
#line 67
            tmp___0 = get_proc_info((pid_t const   )pi.ppid, & ppi);
            }
#line 67
            if (tmp___0 == -1) {
#line 68
              root_pids[i] = 0;
#line 69
              goto __Cont;
            }
#line 73
            rinitw_trap = 0;
#line 74
            if (global_opts.rinitw == 1) {
#line 74
              if (pi.ppid == 1) {
                {
#line 74
                tmp___2 = wlist_match(wlist, pi.pid, ppi.uid, ppi.gid);
                }
#line 74
                if (tmp___2) {
#line 74
                  goto _L___0;
                } else {
                  {
#line 76
                  LOG((char *)"INIT CONTROLLED PROCESS NOT WHITELISTED -- JUMPING TO KILL");
#line 77
                  rinitw_trap = 1;
                  }
                }
              } else {
#line 74
                goto _L___0;
              }
            } else {
              _L___0: /* CIL Label */ 
#line 82
              if (ppi.uid == 0U) {
#line 82
                if (global_opts.noroot == 1) {
#line 83
                  goto loop_end;
                }
              }
#line 86
              if ((int )global_opts.wlist[0] != 0) {
                {
#line 86
                tmp___1 = wlist_match(wlist, pi.pid, ppi.uid, ppi.gid);
                }
#line 86
                if (tmp___1) {
#line 88
                  if (global_opts.logwlist == 1) {
                    {
#line 89
                    LOG((char *)"WHITELIST: %s[%d] ppid_uid=%d", pi.name, pi.pid,
                        ppi.uid);
                    }
                  }
#line 91
                  goto loop_end;
                }
              }
            }
            {
#line 96
            LOG((char *)"NEW ROOT PROCESS: %s[%d] ppid=%d uid=%d gid=%d", pi.name,
                pi.pid, pi.ppid, pi.uid, pi.gid);
#line 99
            evil_pid = pi.pid;
#line 100
            evil_ppid = pi.ppid;
#line 102
            snprintf((char */* __restrict  */)(evil_pid_name), (size_t )4096, (char const   */* __restrict  */)"%s",
                     pi.name);
#line 104
            tmp___13 = get_proc_info((pid_t const   )pi.ppid, & pi);
            }
#line 104
            if (tmp___13 != -1) {
              {
#line 106
              tmp___3 = get_user(pi.uid);
#line 106
              LOG((char *)"  - ppid uid=%d(%s) gid=%d ppid=%d", pi.uid, tmp___3, pi.gid,
                  pi.ppid);
#line 109
              snprintf((char */* __restrict  */)(evil_ppid_name), (size_t )4096, (char const   */* __restrict  */)"%s",
                       pi.name);
#line 111
              tmp___4 = get_user(pi.uid);
              }
#line 111
              if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
                {
#line 112
                LOG((char *)"  ! WARNING: unable to get username for uid %d", pi.uid);
                }
              }
              {
#line 115
              file_mess = 0;
#line 116
              tmp___5 = file_isregular((char *)"/etc/passwd");
              }
#line 116
              if (tmp___5 != 1) {
                {
#line 117
                LOG((char *)"  ! WARNING: /etc/passwd has been modified: no longer a regular file");
#line 118
                file_mess ++;
                }
              }
              {
#line 120
              tmp___6 = file_isregular((char *)"/etc/group");
              }
#line 120
              if (tmp___6 != 1) {
                {
#line 121
                LOG((char *)"  ! WARNING: /etc/group has been modified: no longer a regular file");
#line 122
                file_mess ++;
                }
              }
              {
#line 124
              tmp___7 = file_size((char *)"/etc/passwd");
              }
#line 124
              if (tmp___7 < 1L) {
                {
#line 125
                LOG((char *)"  ! WARNING: /etc/passwd has a size of 0 bytes");
#line 126
                file_mess ++;
                }
              }
#line 129
              if (file_mess != 0) {
                {
#line 130
                LOG((char *)"  + Detected problems with passwd and/or group file, jumping to kill");
                }
#line 131
                goto kill;
              }
              {
#line 137
              tmp___11 = get_user(pi.uid);
#line 137
              tmp___12 = check_group((char const   *)tmp___11, (gid_t const   )mgroup);
              }
#line 137
              if (tmp___12) {
                kill: 
                {
#line 145
                LOG((char *)"  + UNAUTHORIZED PROCESS DETECTED: %s[%d] (parent: %s[%d])",
                    evil_pid_name, evil_pid, evil_ppid_name, evil_ppid);
                }
#line 148
                if (global_opts.nokill == 0) {
                  {
#line 150
                  LOG((char *)"  - sending signal SIGKILL to pid %d", evil_pid);
#line 151
                  kill(evil_pid, 9);
                  }
#line 153
                  if (global_opts.nokillppid == 0) {
#line 153
                    if (rinitw_trap == 0) {
                      {
#line 155
                      LOG((char *)"  - sending signal SIGKILL to ppid %d", evil_ppid);
#line 156
                      kill(evil_ppid, 9);
                      }
                    }
                  }
                  {
#line 160
                  LOG((char *)"  * offending process(es) terminated");
                  }
                } else {
                  {
#line 164
                  LOG((char *)"  - nokill option set, no signals sent");
                  }
                }
#line 168
                if ((int )global_opts.command[0] != 0) {
                  {
#line 172
                  tmp___9 = get_user(pi.uid);
#line 172
                  snprintf((char */* __restrict  */)(extcmd), sizeof(extcmd), (char const   */* __restrict  */)"%s %s",
                           global_opts.command, tmp___9);
#line 175
                  LOG((char *)"  - executing \'%s\'", extcmd);
#line 177
                  tmp___10 = fork();
                  }
                  {
#line 179
                  if (tmp___10 == 0) {
#line 179
                    goto case_0;
                  }
#line 184
                  if (tmp___10 == -1) {
#line 184
                    goto case_neg_1;
                  }
#line 177
                  goto switch_break;
                  case_0: /* CIL Label */ 
                  {
#line 180
                  system((char const   *)(extcmd));
#line 181
                  _exit(0);
                  }
#line 182
                  goto switch_break;
                  case_neg_1: /* CIL Label */ 
                  {
#line 185
                  LOG((char *)"  - ERROR: fork() failed when trying to execute command");
                  }
#line 186
                  goto switch_break;
                  switch_break: /* CIL Label */ ;
                  }
                }
              } else
#line 137
              if (rinitw_trap == 0) {
                {
#line 138
                tmp___8 = get_user(pi.uid);
#line 138
                LOG((char *)"  + %s is in magic group, all OK!", tmp___8);
                }
              } else {
#line 137
                goto kill;
              }
            }
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 49
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    loop_end: 
#line 208
    j = 0;
    {
#line 208
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 208
      if (! (j < 32768)) {
#line 208
        goto while_break___2;
      }
#line 209
      if (root_pids[j] == 1) {
#line 210
        if (*(active_pids___0 + j) != 1) {
#line 211
          root_pids[j] = 0;
        }
      }
#line 208
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 217
    if (cycledelay <= 0) {
      {
#line 218
      usleep((__useconds_t )50000);
      }
    } else {
      {
#line 220
      sleep((unsigned int )cycledelay);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 231 "/home/wheatley/newnew/temp/ninja-0.1.3/src/mloop.c"
static int active_pids[32768]  ;
#line 227 "/home/wheatley/newnew/temp/ninja-0.1.3/src/mloop.c"
int *get_active_pids(void) 
{ 
  DIR *dp ;
  struct dirent *d ;
  int pidnr ;
  int i ;
  long tmp ;

  {
  {
#line 235
  dp = opendir("/proc");
  }
#line 235
  if ((unsigned long )dp == (unsigned long )((void *)0)) {
#line 236
    return ((int *)((void *)0));
  }
#line 238
  i = 0;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! (i < 32768)) {
#line 238
      goto while_break;
    }
#line 239
    active_pids[i] = 0;
#line 238
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 241
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 241
    d = readdir(dp);
    }
#line 241
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 241
      goto while_break___0;
    }
    {
#line 243
    tmp = strtol((char const   */* __restrict  */)(d->d_name), (char **/* __restrict  */)((void *)0),
                 0);
#line 243
    pidnr = (int )tmp;
    }
#line 245
    if (pidnr > 0) {
#line 246
      active_pids[pidnr] = 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 250
  closedir(dp);
  }
#line 252
  return (active_pids);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 809
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 14 "/home/wheatley/newnew/temp/ninja-0.1.3/src/proto.h"
gid_t get_gid(char *name ) ;
#line 26
off_t fd_len(int fd ) ;
#line 27
char *wlist_read(char *path ) ;
#line 29
char *get_map_name(pid_t pid ) ;
#line 30
void chreplace(char *s , char c1 , char c2 ) ;
#line 31
int user_match(char *item , char *users ) ;
#line 32
int group_match(uid_t uid , char *groups , gid_t pwent_gid ) ;
#line 33
char *get_map_exec_offset(void) ;
#line 14 "/home/wheatley/newnew/temp/ninja-0.1.3/src/wlist.c"
off_t fd_len(int fd ) 
{ 
  off_t len ;

  {
  {
#line 18
  len = lseek(fd, (__off_t )0, 2);
#line 19
  lseek(fd, (__off_t )0, 0);
  }
#line 21
  return (len);
}
}
#line 25 "/home/wheatley/newnew/temp/ninja-0.1.3/src/wlist.c"
char *wlist_read(char *path ) 
{ 
  int wlist_fd ;
  char *wlist ;
  off_t tmp ;
  void *tmp___0 ;

  {
  {
#line 30
  wlist_fd = open((char const   *)path, 0);
  }
#line 30
  if (wlist_fd == -1) {
#line 31
    return ((char *)((void *)0));
  }
  {
#line 33
  tmp = fd_len(wlist_fd);
#line 33
  tmp___0 = mmap((void *)0, (size_t )tmp, 1, 2, wlist_fd, (__off_t )0);
#line 33
  wlist = (char *)tmp___0;
  }
#line 33
  if ((unsigned long )wlist == (unsigned long )((void *)-1)) {
#line 34
    return ((char *)((void *)0));
  }
#line 36
  return (wlist);
}
}
#line 43 "/home/wheatley/newnew/temp/ninja-0.1.3/src/wlist.c"
static char buf[16]  = {      (char )'\000',      (char )'\000'};
#line 40 "/home/wheatley/newnew/temp/ninja-0.1.3/src/wlist.c"
char *get_map_exec_offset(void) 
{ 
  FILE *fp ;

  {
#line 45
  if (! buf[0] == 0) {
#line 46
    return (buf);
  }
  {
#line 48
  fp = fopen((char const   */* __restrict  */)"/proc/1/maps", (char const   */* __restrict  */)"r");
  }
#line 48
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 49
    LOG((char *)"warning: unable to get map_exec_offset from /proc/1/maps: whitelisting will not work");
    }
#line 50
    return ((char *)((void *)0));
  }
  {
#line 53
  fgets((char */* __restrict  */)(buf), 9, (FILE */* __restrict  */)fp);
#line 55
  fclose(fp);
  }
#line 57
  return (buf);
}
}
#line 67 "/home/wheatley/newnew/temp/ninja-0.1.3/src/wlist.c"
static char map_name[4104]  ;
#line 61 "/home/wheatley/newnew/temp/ninja-0.1.3/src/wlist.c"
char *get_map_name(pid_t pid ) 
{ 
  FILE *fd ;
  char mfile[64] ;
  char mfield[5][25] ;
  char mbuf[4230] ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 69
  snprintf((char */* __restrict  */)(mfile), sizeof(mfile), (char const   */* __restrict  */)"/proc/%d/maps",
           pid);
#line 71
  fd = fopen((char const   */* __restrict  */)(mfile), (char const   */* __restrict  */)"r");
  }
#line 71
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
#line 72
    return ((char *)((void *)0));
  }
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 76
    memset((void *)(map_name), '\000', sizeof(map_name));
#line 77
    memset((void *)(mbuf), '\000', sizeof(mbuf));
#line 79
    tmp = fgets((char */* __restrict  */)(mbuf), (int )sizeof(mbuf), (FILE */* __restrict  */)fd);
    }
#line 79
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 80
      return ((char *)((void *)0));
    }
    {
#line 82
    sscanf((char const   */* __restrict  */)(mbuf), (char const   */* __restrict  */)"%24s %24s %24s %24s %24s %s",
           mfield[0], mfield[1], mfield[2], mfield[3], mfield[4], map_name);
    }
#line 85
    if (! (map_name)) {
#line 87
      goto __Cont;
    }
    {
#line 90
    tmp___0 = get_map_exec_offset();
#line 90
    tmp___1 = strncmp((char const   *)(mfield[0]), (char const   *)tmp___0, (size_t )8);
    }
#line 90
    if (! tmp___1) {
#line 91
      return (map_name);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return ((char *)((void *)0));
}
}
#line 99 "/home/wheatley/newnew/temp/ninja-0.1.3/src/wlist.c"
int wlist_match(char *wlist , pid_t pid , uid_t uid , gid_t gid ) 
{ 
  unsigned long wlist_pos ;
  int i ;
  char map_name___0[4104] ;
  char link_path[64] ;
  char wlist_entry[512] ;
  char wlist_exec[512] ;
  char wlist_groups[512] ;
  char wlist_users[512] ;
  ssize_t tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 101
  wlist_pos = 0UL;
#line 102
  i = 0;
#line 117
  memset((void *)(map_name___0), '\000', sizeof(map_name___0));
#line 118
  snprintf((char */* __restrict  */)(link_path), sizeof(link_path), (char const   */* __restrict  */)"/proc/%d/exe",
           pid);
#line 119
  tmp = readlink((char const   */* __restrict  */)(link_path), (char */* __restrict  */)(map_name___0),
                 sizeof(map_name___0) - 1UL);
  }
#line 119
  if (tmp == -1L) {
#line 120
    return (0);
  }
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    tmp___0 = i;
#line 128
    i ++;
#line 128
    tmp___1 = wlist_pos;
#line 128
    wlist_pos ++;
#line 128
    wlist_entry[tmp___0] = *(wlist + tmp___1);
#line 130
    if ((int )*(wlist + wlist_pos) == 0) {
#line 131
      return (0);
    }
#line 133
    if ((int )*(wlist + wlist_pos) == 10) {
      {
#line 134
      wlist_entry[i] = (char )'\000';
#line 136
      memset((void *)(wlist_exec), '\000', sizeof(wlist_exec));
#line 137
      memset((void *)(wlist_groups), '\000', sizeof(wlist_groups));
#line 138
      memset((void *)(wlist_users), '\000', sizeof(wlist_users));
#line 140
      chreplace(wlist_entry, (char )':', (char )' ');
#line 141
      sscanf((char const   */* __restrict  */)(wlist_entry), (char const   */* __restrict  */)"%511s %511s %511s",
             wlist_exec, wlist_groups, wlist_users);
#line 144
      tmp___5 = strcmp((char const   *)(map_name___0), (char const   *)(wlist_exec));
      }
#line 144
      if (! tmp___5) {
        {
#line 148
        tmp___2 = get_user(uid);
#line 148
        tmp___3 = user_match(tmp___2, wlist_users);
        }
#line 148
        if (tmp___3 > 0) {
#line 149
          return (1);
        }
        {
#line 153
        tmp___4 = group_match(uid, wlist_groups, gid);
        }
#line 153
        if (tmp___4 > 0) {
#line 154
          return (1);
        }
      }
      {
#line 158
      i = 0;
#line 159
      wlist_pos ++;
#line 161
      tmp___6 = strlen((char const   *)wlist);
      }
#line 161
      if (wlist_pos >= tmp___6) {
#line 162
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  return (0);
}
}
#line 172 "/home/wheatley/newnew/temp/ninja-0.1.3/src/wlist.c"
void chreplace(char *s , char c1 , char c2 ) 
{ 
  int i ;
  int slen ;
  size_t tmp ;

  {
  {
#line 177
  tmp = strlen((char const   *)s);
#line 177
  slen = (int )tmp;
#line 179
  i = 0;
  }
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (i < slen)) {
#line 179
      goto while_break;
    }
#line 180
    if ((int )*(s + i) == (int )c1) {
#line 181
      *(s + i) = c2;
    }
#line 179
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  return;
}
}
#line 187 "/home/wheatley/newnew/temp/ninja-0.1.3/src/wlist.c"
int user_match(char *item , char *users ) 
{ 
  int i ;
  int j ;
  int match ;
  char mtr[32] ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 190
  match = 0;
#line 193
  memset((void *)(mtr), '\000', sizeof(mtr));
#line 195
  i = 0;
#line 195
  j = 0;
  }
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 195
    tmp___2 = strlen((char const   *)users);
    }
#line 195
    if (! ((size_t )i < tmp___2 + 1UL)) {
#line 195
      goto while_break;
    }
#line 197
    if ((int )*(users + i) == 44) {
#line 197
      goto _L;
    } else {
      {
#line 197
      tmp___1 = strlen((char const   *)users);
      }
#line 197
      if ((size_t )i >= tmp___1) {
        _L: /* CIL Label */ 
        {
#line 199
        tmp = strcmp((char const   *)(mtr), (char const   *)item);
        }
#line 199
        if (! tmp) {
#line 200
          match ++;
        }
        {
#line 202
        memset((void *)(mtr), '\000', sizeof(mtr));
#line 203
        j = 0;
        }
      } else {
#line 207
        tmp___0 = j;
#line 207
        j ++;
#line 207
        mtr[tmp___0] = *(users + i);
      }
    }
#line 195
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return (match);
}
}
#line 217 "/home/wheatley/newnew/temp/ninja-0.1.3/src/wlist.c"
int group_match(uid_t uid , char *groups , gid_t pwent_gid ) 
{ 
  int i ;
  int j ;
  char mtr[32] ;
  gid_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  gid_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 222
  memset((void *)(mtr), '\000', sizeof(mtr));
#line 224
  i = 0;
#line 224
  j = 0;
  }
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 224
    tmp___5 = strlen((char const   *)groups);
    }
#line 224
    if (! ((size_t )i < tmp___5 + 1UL)) {
#line 224
      goto while_break;
    }
#line 226
    if ((int )*(groups + i) == 44) {
#line 226
      goto _L;
    } else {
      {
#line 226
      tmp___4 = strlen((char const   *)groups);
      }
#line 226
      if ((size_t )i >= tmp___4) {
        _L: /* CIL Label */ 
        {
#line 228
        tmp = get_gid(mtr);
#line 228
        tmp___0 = get_user(uid);
#line 228
        tmp___1 = check_group((char const   *)tmp___0, (gid_t const   )tmp);
        }
#line 228
        if (tmp___1) {
          {
#line 228
          tmp___2 = get_gid(mtr);
          }
#line 228
          if (tmp___2 == pwent_gid) {
#line 229
            return (1);
          }
        } else {
#line 229
          return (1);
        }
        {
#line 231
        memset((void *)(mtr), '\000', sizeof(mtr));
#line 232
        j = 0;
        }
      } else {
#line 236
        tmp___3 = j;
#line 236
        j ++;
#line 236
        mtr[tmp___3] = *(groups + i);
      }
    }
#line 224
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  return (0);
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 13 "/home/wheatley/newnew/temp/ninja-0.1.3/src/proc.c"
int get_proc_info(pid_t const   pid , struct proc_info *pi ) 
{ 
  FILE *fp ;
  char filename[32] ;
  char rbuf[128] ;
  char pbuf[5][33] ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 21
  snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"/proc/%d/status",
           pid);
#line 23
  fp = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"r");
  }
#line 23
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 24
    return (-1);
  }
  {
#line 26
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 26
    tmp___8 = fgets((char */* __restrict  */)(rbuf), (int )sizeof(rbuf), (FILE */* __restrict  */)fp);
    }
#line 26
    if (! ((unsigned long )tmp___8 != (unsigned long )((void *)0))) {
#line 26
      goto while_break;
    }
#line 28
    i = 0;
    {
#line 28
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 28
      if (! (i < 5)) {
#line 28
        goto while_break___0;
      }
      {
#line 29
      memset((void *)(pbuf[i]), 0, sizeof(pbuf[i]));
#line 28
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 31
    sscanf((char const   */* __restrict  */)(rbuf), (char const   */* __restrict  */)"%32s %32s %32s %32s %32s",
           pbuf[0], pbuf[1], pbuf[2], pbuf[3], pbuf[4]);
#line 33
    tmp = strcmp((char const   *)(pbuf[0]), "Name:");
    }
#line 33
    if (! tmp) {
      {
#line 34
      snprintf((char */* __restrict  */)(pi->name), (size_t )127, (char const   */* __restrict  */)"%s",
               pbuf[1]);
      }
    }
    {
#line 36
    tmp___0 = strcmp((char const   *)(pbuf[0]), "Pid:");
    }
#line 36
    if (! tmp___0) {
      {
#line 37
      pi->pid = atoi((char const   *)(pbuf[1]));
      }
    }
    {
#line 39
    tmp___1 = strcmp((char const   *)(pbuf[0]), "PPid:");
    }
#line 39
    if (! tmp___1) {
      {
#line 40
      pi->ppid = atoi((char const   *)(pbuf[1]));
      }
    }
    {
#line 42
    tmp___4 = strcmp((char const   *)(pbuf[0]), "Uid:");
    }
#line 42
    if (! tmp___4) {
      {
#line 44
      tmp___2 = atoi((char const   *)(pbuf[1]));
#line 44
      pi->uid = (uid_t )tmp___2;
#line 46
      i = 1;
      }
      {
#line 46
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 46
        if (! (i < 4)) {
#line 46
          goto while_break___1;
        }
        {
#line 47
        tmp___3 = atoi((char const   *)(pbuf[i]));
        }
#line 47
        if (tmp___3 == 0) {
#line 48
          pi->uid = (uid_t )0;
        }
#line 46
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 53
    tmp___7 = strcmp((char const   *)(pbuf[0]), "Gid:");
    }
#line 53
    if (! tmp___7) {
      {
#line 55
      tmp___5 = atoi((char const   *)(pbuf[1]));
#line 55
      pi->gid = (gid_t )tmp___5;
#line 57
      i = 1;
      }
      {
#line 57
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 57
        if (! (i < 4)) {
#line 57
          goto while_break___2;
        }
        {
#line 58
        tmp___6 = atoi((char const   *)(pbuf[i]));
        }
#line 58
        if (tmp___6 == 0) {
#line 59
          pi->gid = (gid_t )0;
        }
#line 57
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 66
  fclose(fp);
  }
#line 68
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 22 "/home/wheatley/newnew/temp/ninja-0.1.3/src/proto.h"
char *timestamp(void) ;
#line 23
char *replace(char *string , char c1 , char c2 ) ;
#line 15 "/home/wheatley/newnew/temp/ninja-0.1.3/src/log.c"
void LOG(char *fmt  , ...) 
{ 
  va_list args ;
  FILE *fd ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 20
  if (global_opts.quiet == 0) {
    {
#line 21
    __builtin_va_start(args, fmt);
#line 23
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s",
            "log: ");
#line 25
    vfprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)fmt,
             args);
#line 26
    puts("");
#line 27
    __builtin_va_end(args);
    }
  }
#line 30
  if ((int )global_opts.logfile[0] != 0) {
    {
#line 30
    tmp___1 = file_isregular(global_opts.logfile);
    }
#line 30
    if (tmp___1 == 1) {
      {
#line 31
      __builtin_va_start(args, fmt);
#line 32
      fd = fopen((char const   */* __restrict  */)(global_opts.logfile), (char const   */* __restrict  */)"a");
      }
#line 33
      if ((unsigned long )fd != (unsigned long )((void *)0)) {
        {
#line 34
        tmp = timestamp();
#line 34
        tmp___0 = replace(tmp, (char )'\n', (char )']');
#line 34
        fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"[%s ",
                tmp___0);
#line 35
        vfprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)fmt,
                 args);
#line 36
        fprintf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"\n");
#line 37
        fclose(fd);
        }
      }
      {
#line 39
      __builtin_va_end(args);
      }
    }
  }
#line 41
  return;
}
}
#line 45 "/home/wheatley/newnew/temp/ninja-0.1.3/src/log.c"
void die(char *fmt  , ...) 
{ 
  va_list args ;

  {
  {
#line 50
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          "die: ");
#line 53
  __builtin_va_start(args, fmt);
#line 54
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           args);
#line 56
  __builtin_va_end(args);
#line 58
  puts("");
#line 60
  exit(1);
  }
}
}
#line 64 "/home/wheatley/newnew/temp/ninja-0.1.3/src/log.c"
char *timestamp(void) 
{ 
  time_t t ;
  time_t tmp ;
  char *tmp___0 ;

  {
  {
#line 66
  tmp = time((time_t *)0);
#line 66
  t = tmp;
#line 68
  tmp___0 = ctime((time_t const   *)(& t));
  }
#line 68
  return (tmp___0);
}
}
#line 72 "/home/wheatley/newnew/temp/ninja-0.1.3/src/log.c"
char *replace(char *string , char c1 , char c2 ) 
{ 
  int i ;
  size_t tmp ;

  {
#line 76
  i = 0;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 76
    tmp = strlen((char const   *)string);
    }
#line 76
    if (! ((size_t )i < tmp)) {
#line 76
      goto while_break;
    }
#line 77
    if ((int )*(string + i) == (int )c1) {
#line 78
      *(string + i) = c2;
    }
#line 76
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return (string);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 937
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) daemon)(int __nochdir ,
                                                                             int __noclose ) ;
#line 105 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 4 "/home/wheatley/newnew/temp/ninja-0.1.3/src/proto.h"
int main(int argc , char **argv ) ;
#line 5
void help(void) ;
#line 39
int conf_read(char const   *path ) ;
#line 18 "/home/wheatley/newnew/temp/ninja-0.1.3/src/main.c"
struct options global_opts  ;
#line 21 "/home/wheatley/newnew/temp/ninja-0.1.3/src/main.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  struct group *gr ;
  FILE *fd ;
  char *wlist ;
  int tmp ;
  int tmp___0 ;
  __uid_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 26
  wlist = (char *)((void *)0);
#line 28
  global_opts.daemon = 0;
#line 29
  global_opts.interval = 1;
#line 30
  global_opts.quiet = 0;
#line 31
  global_opts.group = (gid_t )0;
#line 32
  global_opts.nokill = 0;
#line 33
  global_opts.nokillppid = 0;
#line 34
  global_opts.noroot = 1;
#line 35
  global_opts.logwlist = 0;
#line 36
  global_opts.rinitw = 0;
#line 37
  global_opts.soffset = 0;
#line 38
  memset((void *)(global_opts.logfile), 0, sizeof(global_opts.logfile));
#line 39
  memset((void *)(global_opts.command), 0, sizeof(global_opts.command));
#line 40
  memset((void *)(global_opts.wlist), 0, sizeof(global_opts.wlist));
  }
#line 43
  if (argc <= 1) {
    {
#line 44
    LOG((char *)"warning: no configuration file specified, using default values");
    }
  }
#line 46
  if (argc > 1) {
#line 46
    if ((int )*(*(argv + 1) + 0) != 45) {
      {
#line 47
      LOG((char *)"reading configuration file: %s", *(argv + 1));
#line 49
      tmp = conf_read((char const   *)*(argv + 1));
      }
#line 49
      if (tmp != 0) {
        {
#line 50
        die((char *)"error: unable to read configuration file");
        }
      }
    } else {
#line 46
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 54
  if (argc > 1) {
    {
#line 54
    tmp___0 = strcmp((char const   *)*(argv + 1), "-h");
    }
#line 54
    if (! tmp___0) {
      {
#line 55
      help();
#line 56
      exit(1);
      }
    }
  }
  {
#line 61
  LOG((char *)"ninja version %s initializing", "0.1.3");
#line 63
  tmp___1 = getuid();
  }
#line 63
  if (tmp___1 != 0U) {
    {
#line 64
    die((char *)"error: must run as root");
    }
  }
  {
#line 67
  tmp___2 = file_isregular((char *)"/etc/passwd");
  }
#line 67
  if (tmp___2 != 1) {
    {
#line 68
    LOG((char *)"warning: /etc/passwd is not a regular file -- this will cause problems");
    }
  }
  {
#line 69
  tmp___3 = file_isregular((char *)"/etc/group");
  }
#line 69
  if (tmp___3 != 1) {
    {
#line 70
    LOG((char *)"warning: /etc/group is not a regular file -- this will cause problems");
    }
  }
  {
#line 71
  tmp___4 = file_size((char *)"/etc/passwd");
  }
#line 71
  if (tmp___4 < 1L) {
    {
#line 72
    LOG((char *)"warning: /etc/passwd has a size of 0 bytes -- this will cause problems");
    }
  }
#line 74
  if (global_opts.group == 4294967295U) {
    {
#line 75
    die((char *)"error: no magic group specified");
    }
  }
#line 77
  if (global_opts.rinitw == 1) {
#line 77
    if ((int )global_opts.wlist[0] == 0) {
      {
#line 78
      die((char *)"error: require_init_wlist option set, but no whitelist is specified");
      }
    }
  }
#line 80
  i = 0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! (i < 100)) {
#line 80
      goto while_break;
    }
    {
#line 81
    signal(i, & sighandler);
#line 80
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 83
  gr = getgrgid(global_opts.group);
  }
#line 83
  if ((unsigned long )gr == (unsigned long )((void *)0)) {
    {
#line 84
    die((char *)"error: magic group not found by getgrgid()");
    }
  }
  {
#line 86
  LOG((char *)"magic group: gid=%d (%s)", gr->gr_gid, gr->gr_name);
  }
#line 88
  if ((int )global_opts.logfile[0] != 0) {
    {
#line 90
    LOG((char *)"logfile: %s", global_opts.logfile);
#line 92
    tmp___5 = file_isregular(global_opts.logfile);
    }
#line 92
    if (tmp___5 != 1) {
      {
#line 93
      die((char *)"error: `%s\' is not a regular file", global_opts.logfile);
      }
    }
    {
#line 95
    fd = fopen((char const   */* __restrict  */)(global_opts.logfile), (char const   */* __restrict  */)"a");
    }
#line 95
    if ((unsigned long )fd == (unsigned long )((void *)0)) {
      {
#line 96
      die((char *)"error: unable to open log file");
      }
    } else {
      {
#line 98
      fclose(fd);
      }
    }
  }
#line 101
  if ((int )global_opts.command[0] != 0) {
    {
#line 102
    LOG((char *)"external command: %s <user>", global_opts.command);
    }
  }
#line 105
  if ((int )global_opts.wlist[0] != 0) {
    {
#line 106
    wlist = wlist_read(global_opts.wlist);
    }
#line 106
    if ((unsigned long )wlist == (unsigned long )((void *)0)) {
      {
#line 107
      die((char *)"failed to read whitelist");
      }
    }
    {
#line 108
    LOG((char *)"whitelist mapped in memory at %p", (void *)wlist);
    }
  }
#line 111
  if (global_opts.soffset != 0) {
    {
#line 112
    LOG((char *)"proc scanning offset: %d", global_opts.soffset);
    }
  }
#line 115
  if (global_opts.daemon == 1) {
    {
#line 116
    LOG((char *)"entering daemon mode");
#line 117
    tmp___6 = daemon(0, 0);
    }
#line 117
    if (tmp___6 == -1) {
      {
#line 118
      die((char *)"error: daemon() failed");
      }
    }
#line 119
    global_opts.quiet = 1;
  }
  {
#line 122
  LOG((char *)"entering main loop");
#line 124
  main_loop((int )global_opts.group, global_opts.interval, wlist);
  }
#line 126
  return (0);
}
}
#line 130 "/home/wheatley/newnew/temp/ninja-0.1.3/src/main.c"
void help(void) 
{ 


  {
  {
#line 132
  printf((char const   */* __restrict  */)"usage: %s <config_file>\n", "ninja");
  }
#line 133
  return;
}
}
#line 689 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getgroups)(int __size ,
                                                                                __gid_t *__list ) ;
#line 72 "/usr/include/pwd.h"
extern void setpwent(void) ;
#line 78
extern void endpwent(void) ;
#line 84
extern struct passwd *getpwent(void) ;
#line 62 "/usr/include/grp.h"
extern void setgrent(void) ;
#line 71
extern void endgrent(void) ;
#line 77
extern struct group *getgrent(void) ;
#line 201
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 11 "/home/wheatley/newnew/temp/ninja-0.1.3/src/user.c"
int check_group(char const   *user , gid_t const   gid ) 
{ 
  size_t group_count ;
  gid_t gid_list[65537] ;
  int i ;
  int tmp ;

  {
#line 17
  if ((unsigned long )user == (unsigned long )((void *)0)) {
#line 18
    return (1);
  }
  {
#line 20
  initgroups(user, (__gid_t )-1);
#line 22
  tmp = getgroups(0, gid_list);
#line 22
  group_count = (size_t )tmp;
#line 23
  getgroups((int )group_count, gid_list);
#line 25
  i = 0;
  }
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
#line 25
    if (! ((size_t )i < group_count)) {
#line 25
      goto while_break;
    }
#line 26
    if (gid_list[i] == (gid_t )gid) {
#line 27
      return (0);
    }
#line 25
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 30
  return (1);
}
}
#line 34 "/home/wheatley/newnew/temp/ninja-0.1.3/src/user.c"
char *get_user(uid_t uid ) 
{ 
  struct passwd *pwent ;

  {
  {
#line 38
  setpwent();
  }
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 40
    pwent = getpwent();
    }
#line 40
    if (! ((unsigned long )pwent != (unsigned long )((void *)0))) {
#line 40
      goto while_break;
    }
#line 41
    if (pwent->pw_uid == uid) {
      {
#line 42
      endpwent();
      }
#line 43
      return (pwent->pw_name);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 47
  endpwent();
  }
#line 49
  return ((char *)((void *)0));
}
}
#line 53 "/home/wheatley/newnew/temp/ninja-0.1.3/src/user.c"
gid_t get_gid(char *name ) 
{ 
  struct group *grent ;
  int tmp ;

  {
  {
#line 57
  setgrent();
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 59
    grent = getgrent();
    }
#line 59
    if (! ((unsigned long )grent != (unsigned long )((void *)0))) {
#line 59
      goto while_break;
    }
    {
#line 60
    tmp = strcmp((char const   *)grent->gr_name, (char const   *)name);
    }
#line 60
    if (! tmp) {
      {
#line 61
      endgrent();
      }
#line 62
      return (grent->gr_gid);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 66
  endgrent();
  }
#line 68
  return ((gid_t )-1);
}
}
#line 749 "/usr/include/stdio.h"
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 263 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 9 "/home/wheatley/newnew/temp/ninja-0.1.3/src/file.c"
int file_isregular(char *fpath ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
#line 13
  tmp = lstat((char const   */* __restrict  */)fpath, (struct stat */* __restrict  */)(& st));
  }
#line 13
  if (tmp == 0) {
#line 15
    if (! ((st.st_mode & 61440U) == 32768U)) {
#line 16
      return (0);
    }
  } else {
#line 20
    return (-1);
  }
#line 24
  return (1);
}
}
#line 28 "/home/wheatley/newnew/temp/ninja-0.1.3/src/file.c"
long file_size(char *fpath ) 
{ 
  FILE *fp ;
  long fsize ;
  int tmp ;

  {
  {
#line 33
  fp = fopen((char const   */* __restrict  */)fpath, (char const   */* __restrict  */)"r");
  }
#line 33
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 34
    return (-1L);
  }
  {
#line 36
  tmp = fseek(fp, 0L, 2);
  }
#line 36
  if (tmp != 0) {
#line 37
    return (-2L);
  }
  {
#line 39
  fsize = ftell(fp);
#line 40
  fclose(fp);
  }
#line 42
  return (fsize);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 40 "/home/wheatley/newnew/temp/ninja-0.1.3/src/proto.h"
void stolower(char *s ) ;
#line 9 "/home/wheatley/newnew/temp/ninja-0.1.3/src/config.c"
int conf_read(char const   *path ) 
{ 
  FILE *fp ;
  char cf_option[65] ;
  char cf_eq ;
  char cf_value[161] ;
  char buf___0[256] ;
  unsigned long line_num ;
  int i ;
  int ignore_line ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;

  {
  {
#line 16
  line_num = 0UL;
#line 20
  fp = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r");
  }
#line 20
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 21
    return (-1);
  }
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 25
    memset((void *)(buf___0), 0, sizeof(buf___0));
#line 26
    tmp = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)fp);
    }
#line 26
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 27
      goto while_break;
    }
#line 29
    line_num ++;
#line 31
    ignore_line = 0;
#line 32
    i = 0;
    {
#line 32
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 32
      tmp___0 = strlen((char const   *)(buf___0));
      }
#line 32
      if (! ((size_t )i < tmp___0)) {
#line 32
        goto while_break___0;
      }
#line 34
      if ((int )buf___0[i] == 32) {
#line 35
        goto __Cont;
      } else
#line 34
      if ((int )buf___0[i] == 9) {
#line 35
        goto __Cont;
      }
#line 37
      if ((int )buf___0[i] == 35) {
#line 38
        ignore_line = 1;
      } else
#line 37
      if ((int )buf___0[i] == 10) {
#line 38
        ignore_line = 1;
      }
#line 40
      goto while_break___0;
      __Cont: /* CIL Label */ 
#line 32
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 43
    if (ignore_line == 1) {
#line 44
      goto __Cont___0;
    }
    {
#line 46
    cf_option[0] = (char)0;
#line 47
    cf_eq = (char)0;
#line 48
    cf_value[0] = (char)0;
#line 50
    sscanf((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%64s %c %160s\n",
           cf_option, & cf_eq, cf_value);
#line 52
    stolower(cf_option);
#line 53
    stolower(cf_value);
#line 55
    tmp___1 = strcmp((char const   *)(cf_value), "true");
    }
#line 55
    if (! tmp___1) {
      {
#line 56
      sprintf((char */* __restrict  */)(cf_value), (char const   */* __restrict  */)"yes");
      }
    }
    {
#line 57
    tmp___2 = strcmp((char const   *)(cf_value), "false");
    }
#line 57
    if (! tmp___2) {
      {
#line 58
      sprintf((char */* __restrict  */)(cf_value), (char const   */* __restrict  */)"no");
      }
    }
    {
#line 60
    tmp___32 = strcmp((char const   *)(cf_option), "daemon");
    }
#line 60
    if (tmp___32) {
      _L___9: /* CIL Label */ 
      {
#line 62
      tmp___30 = strcmp((char const   *)(cf_option), "daemon");
      }
#line 62
      if (tmp___30) {
        _L___8: /* CIL Label */ 
        {
#line 65
        tmp___29 = strcmp((char const   *)(cf_option), "interval");
        }
#line 65
        if (tmp___29) {
          {
#line 68
          tmp___28 = strcmp((char const   *)(cf_option), "group");
          }
#line 68
          if (tmp___28) {
            {
#line 71
            tmp___27 = strcmp((char const   *)(cf_option), "logfile");
            }
#line 71
            if (tmp___27) {
              {
#line 74
              tmp___26 = strcmp((char const   *)(cf_option), "whitelist");
              }
#line 74
              if (tmp___26) {
                {
#line 77
                tmp___25 = strcmp((char const   *)(cf_option), "external_command");
                }
#line 77
                if (tmp___25) {
                  {
#line 80
                  tmp___24 = strcmp((char const   *)(cf_option), "proc_scan_offset");
                  }
#line 80
                  if (tmp___24) {
                    {
#line 83
                    tmp___22 = strcmp((char const   *)(cf_option), "no_kill");
                    }
#line 83
                    if (tmp___22) {
                      _L___7: /* CIL Label */ 
                      {
#line 85
                      tmp___20 = strcmp((char const   *)(cf_option), "no_kill");
                      }
#line 85
                      if (tmp___20) {
                        _L___6: /* CIL Label */ 
                        {
#line 88
                        tmp___18 = strcmp((char const   *)(cf_option), "no_kill_ppid");
                        }
#line 88
                        if (tmp___18) {
                          _L___5: /* CIL Label */ 
                          {
#line 90
                          tmp___16 = strcmp((char const   *)(cf_option), "no_kill_ppid");
                          }
#line 90
                          if (tmp___16) {
                            _L___4: /* CIL Label */ 
                            {
#line 93
                            tmp___14 = strcmp((char const   *)(cf_option), "ignore_root_procs");
                            }
#line 93
                            if (tmp___14) {
                              _L___3: /* CIL Label */ 
                              {
#line 95
                              tmp___12 = strcmp((char const   *)(cf_option), "ignore_root_procs");
                              }
#line 95
                              if (tmp___12) {
                                _L___2: /* CIL Label */ 
                                {
#line 98
                                tmp___10 = strcmp((char const   *)(cf_option), "log_whitelist");
                                }
#line 98
                                if (tmp___10) {
                                  _L___1: /* CIL Label */ 
                                  {
#line 100
                                  tmp___8 = strcmp((char const   *)(cf_option), "log_whitelist");
                                  }
#line 100
                                  if (tmp___8) {
                                    _L___0: /* CIL Label */ 
                                    {
#line 103
                                    tmp___6 = strcmp((char const   *)(cf_option),
                                                     "require_init_wlist");
                                    }
#line 103
                                    if (tmp___6) {
                                      _L: /* CIL Label */ 
                                      {
#line 105
                                      tmp___4 = strcmp((char const   *)(cf_option),
                                                       "require_init_wlist");
                                      }
#line 105
                                      if (tmp___4) {
                                        {
#line 109
                                        LOG((char *)"warning: %s:%d: unknown option and/or value",
                                            path, line_num);
                                        }
                                      } else {
                                        {
#line 105
                                        tmp___5 = strcmp((char const   *)(cf_value),
                                                         "no");
                                        }
#line 105
                                        if (tmp___5) {
                                          {
#line 109
                                          LOG((char *)"warning: %s:%d: unknown option and/or value",
                                              path, line_num);
                                          }
                                        } else {
#line 106
                                          global_opts.rinitw = 0;
                                        }
                                      }
                                    } else {
                                      {
#line 103
                                      tmp___7 = strcmp((char const   *)(cf_value),
                                                       "yes");
                                      }
#line 103
                                      if (tmp___7) {
#line 103
                                        goto _L;
                                      } else {
#line 104
                                        global_opts.rinitw = 1;
                                      }
                                    }
                                  } else {
                                    {
#line 100
                                    tmp___9 = strcmp((char const   *)(cf_value), "no");
                                    }
#line 100
                                    if (tmp___9) {
#line 100
                                      goto _L___0;
                                    } else {
#line 101
                                      global_opts.logwlist = 0;
                                    }
                                  }
                                } else {
                                  {
#line 98
                                  tmp___11 = strcmp((char const   *)(cf_value), "yes");
                                  }
#line 98
                                  if (tmp___11) {
#line 98
                                    goto _L___1;
                                  } else {
#line 99
                                    global_opts.logwlist = 1;
                                  }
                                }
                              } else {
                                {
#line 95
                                tmp___13 = strcmp((char const   *)(cf_value), "no");
                                }
#line 95
                                if (tmp___13) {
#line 95
                                  goto _L___2;
                                } else {
#line 96
                                  global_opts.noroot = 0;
                                }
                              }
                            } else {
                              {
#line 93
                              tmp___15 = strcmp((char const   *)(cf_value), "yes");
                              }
#line 93
                              if (tmp___15) {
#line 93
                                goto _L___3;
                              } else {
#line 94
                                global_opts.noroot = 1;
                              }
                            }
                          } else {
                            {
#line 90
                            tmp___17 = strcmp((char const   *)(cf_value), "no");
                            }
#line 90
                            if (tmp___17) {
#line 90
                              goto _L___4;
                            } else {
#line 91
                              global_opts.nokillppid = 0;
                            }
                          }
                        } else {
                          {
#line 88
                          tmp___19 = strcmp((char const   *)(cf_value), "yes");
                          }
#line 88
                          if (tmp___19) {
#line 88
                            goto _L___5;
                          } else {
#line 89
                            global_opts.nokillppid = 1;
                          }
                        }
                      } else {
                        {
#line 85
                        tmp___21 = strcmp((char const   *)(cf_value), "no");
                        }
#line 85
                        if (tmp___21) {
#line 85
                          goto _L___6;
                        } else {
#line 86
                          global_opts.nokill = 0;
                        }
                      }
                    } else {
                      {
#line 83
                      tmp___23 = strcmp((char const   *)(cf_value), "yes");
                      }
#line 83
                      if (tmp___23) {
#line 83
                        goto _L___7;
                      } else {
#line 84
                        global_opts.nokill = 1;
                      }
                    }
                  } else {
                    {
#line 81
                    global_opts.soffset = atoi((char const   *)(cf_value));
                    }
                  }
                } else {
                  {
#line 78
                  snprintf((char */* __restrict  */)(global_opts.command), sizeof(global_opts.command),
                           (char const   */* __restrict  */)"%s", cf_value);
                  }
                }
              } else {
                {
#line 75
                snprintf((char */* __restrict  */)(global_opts.wlist), sizeof(global_opts.wlist),
                         (char const   */* __restrict  */)"%s", cf_value);
                }
              }
            } else {
              {
#line 72
              snprintf((char */* __restrict  */)(global_opts.logfile), sizeof(global_opts.logfile),
                       (char const   */* __restrict  */)"%s", cf_value);
              }
            }
          } else {
            {
#line 69
            tmp___3 = atoi((char const   *)(cf_value));
#line 69
            global_opts.group = (gid_t )tmp___3;
            }
          }
        } else {
          {
#line 66
          global_opts.interval = atoi((char const   *)(cf_value));
          }
        }
      } else {
        {
#line 62
        tmp___31 = strcmp((char const   *)(cf_value), "no");
        }
#line 62
        if (tmp___31) {
#line 62
          goto _L___8;
        } else {
#line 63
          global_opts.daemon = 0;
        }
      }
    } else {
      {
#line 60
      tmp___33 = strcmp((char const   *)(cf_value), "yes");
      }
#line 60
      if (tmp___33) {
#line 60
        goto _L___9;
      } else {
#line 61
        global_opts.daemon = 1;
      }
    }
    __Cont___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  return (0);
}
}
#line 117 "/home/wheatley/newnew/temp/ninja-0.1.3/src/config.c"
void stolower(char *s ) 
{ 
  int i ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 121
  i = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 121
    tmp___0 = strlen((char const   *)s);
    }
#line 121
    if (! ((size_t )i < tmp___0)) {
#line 121
      goto while_break;
    }
    {
#line 122
    tmp = tolower((int )*(s + i));
#line 122
    *(s + i) = (char )tmp;
#line 121
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  return;
}
}
