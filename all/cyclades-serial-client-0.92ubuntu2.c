/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_9 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_9 __sigset_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_10 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_10 fd_set;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 2 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/libcsc/../inc/control.h"
enum __anonenum_e_operation_31 {
    eSET_SPEED = 0,
    eSEND_BREAK = 1,
    eSET_CSIZE = 2,
    eSET_PARITY = 3,
    eSET_STOPSIZE = 4,
    eSET_CONTROL = 5
} ;
#line 2 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/libcsc/../inc/control.h"
typedef enum __anonenum_e_operation_31 e_operation;
#line 12 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/libcsc/../inc/control.h"
struct __anonstruct_s_control_32 {
   int size ;
   e_operation oper ;
   int val ;
};
#line 12 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/libcsc/../inc/control.h"
typedef struct __anonstruct_s_control_32 s_control;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_35 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_36 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_37 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_38 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_39 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_40 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_41 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_34 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_35 _kill ;
   struct __anonstruct__timer_36 _timer ;
   struct __anonstruct__rt_37 _rt ;
   struct __anonstruct__sigchld_38 _sigchld ;
   struct __anonstruct__sigfault_39 _sigfault ;
   struct __anonstruct__sigpoll_40 _sigpoll ;
   struct __anonstruct__sigsys_41 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_33 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_34 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_33 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_53 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_53 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 19 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrio.h"
struct buffer {
   unsigned char *b_base ;
   unsigned char *b_ins ;
   unsigned char *b_rem ;
   int b_hold ;
   int b_size ;
};
#line 75 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrio.h"
struct portconfig {
   int speed ;
   int datasize ;
   int stopsize ;
   int parity ;
   int flowc ;
};
#line 83 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrio.h"
struct portstate {
   int modemstate ;
   int linestate ;
};
#line 88 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrio.h"
struct comport {
   int support ;
   struct portconfig portconfig ;
   struct portstate portstate ;
};
#line 95 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrio.h"
struct nvt {
   int state ;
   int substate ;
   int servertype ;
   int iosize ;
   struct comport *comport ;
   struct buffer *inbuff ;
   struct buffer *outbuff ;
};
#line 194 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrio.h"
struct event {
   int ev_type ;
   int ev_code ;
   void *ev_param ;
   int ev_size ;
   struct event *ev_next ;
   struct event *ev_last ;
};
#line 59 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 34 "/usr/include/x86_64-linux-gnu/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 105 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrio.h"
union __anonunion_io_param_53 {
   struct portconfig portconfig ;
   int arg ;
};
#line 105 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrio.h"
struct iocontrol {
   int io_oper ;
   union __anonunion_io_param_53 io_param ;
};
#line 116 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrio.h"
struct pty {
   int state ;
   int substate ;
   int iosize ;
   int portmodes ;
   struct iocontrol iocontrol ;
   struct comport *comport ;
   struct buffer *inbuff ;
   struct buffer *outbuff ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
struct statenames {
   char const   * const  stname ;
   char **subnames ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 56 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *dlopen(char const   *__file , int __mode ) ;
#line 60
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) dlclose)(void *__handle ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2), __leaf__)) dlsym)(void * __restrict  __handle ,
                                                                                              char const   * __restrict  __name ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 214
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 48 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) speed_t ( __attribute__((__leaf__)) cfgetospeed)(struct termios  const  *__termios_p ) ;
#line 51
extern  __attribute__((__nothrow__)) speed_t ( __attribute__((__leaf__)) cfgetispeed)(struct termios  const  *__termios_p ) ;
#line 54
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) cfsetospeed)(struct termios *__termios_p ,
                                                                                  speed_t __speed ) ;
#line 57
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) cfsetispeed)(struct termios *__termios_p ,
                                                                                  speed_t __speed ) ;
#line 66
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int fd ,
                                                                         int optional_actions ,
                                                                         struct termios  const  *termios_p ) ;
#line 80
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsendbreak)(int fd ,
                                                                           int duration ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 149
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/libcsc/../inc/telnet.h"
int NvtOptions[256]  ;
#line 126 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/libcsc/../inc/telnet.h"
int CmdState[13]  ;
#line 7 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/libcsc/../inc/port_speed.h"
static int baud_index_to_int___0(speed_t baud_index ) 
{ 


  {
  {
#line 11
  if (baud_index == 0U) {
#line 11
    goto case_0;
  }
#line 13
  if (baud_index == 1U) {
#line 13
    goto case_1;
  }
#line 15
  if (baud_index == 2U) {
#line 15
    goto case_2;
  }
#line 17
  if (baud_index == 3U) {
#line 17
    goto case_3;
  }
#line 19
  if (baud_index == 4U) {
#line 19
    goto case_4;
  }
#line 21
  if (baud_index == 5U) {
#line 21
    goto case_5;
  }
#line 23
  if (baud_index == 6U) {
#line 23
    goto case_6;
  }
#line 25
  if (baud_index == 7U) {
#line 25
    goto case_7;
  }
#line 27
  if (baud_index == 8U) {
#line 27
    goto case_8;
  }
#line 29
  if (baud_index == 9U) {
#line 29
    goto case_9;
  }
#line 31
  if (baud_index == 10U) {
#line 31
    goto case_10;
  }
#line 33
  if (baud_index == 11U) {
#line 33
    goto case_11;
  }
#line 35
  if (baud_index == 12U) {
#line 35
    goto case_12;
  }
#line 37
  if (baud_index == 13U) {
#line 37
    goto case_13;
  }
#line 39
  if (baud_index == 14U) {
#line 39
    goto case_14;
  }
#line 41
  if (baud_index == 15U) {
#line 41
    goto case_15;
  }
#line 44
  if (baud_index == 4097U) {
#line 44
    goto case_4097;
  }
#line 48
  if (baud_index == 4098U) {
#line 48
    goto case_4098;
  }
#line 52
  if (baud_index == 4099U) {
#line 52
    goto case_4099;
  }
#line 56
  if (baud_index == 4100U) {
#line 56
    goto case_4100;
  }
#line 9
  goto switch_break;
  case_0: /* CIL Label */ 
#line 12
  return (0);
  case_1: /* CIL Label */ 
#line 14
  return (50);
  case_2: /* CIL Label */ 
#line 16
  return (75);
  case_3: /* CIL Label */ 
#line 18
  return (110);
  case_4: /* CIL Label */ 
#line 20
  return (134);
  case_5: /* CIL Label */ 
#line 22
  return (150);
  case_6: /* CIL Label */ 
#line 24
  return (200);
  case_7: /* CIL Label */ 
#line 26
  return (300);
  case_8: /* CIL Label */ 
#line 28
  return (600);
  case_9: /* CIL Label */ 
#line 30
  return (1200);
  case_10: /* CIL Label */ 
#line 32
  return (1800);
  case_11: /* CIL Label */ 
#line 34
  return (2400);
  case_12: /* CIL Label */ 
#line 36
  return (4800);
  case_13: /* CIL Label */ 
#line 38
  return (9600);
  case_14: /* CIL Label */ 
#line 40
  return (19200);
  case_15: /* CIL Label */ 
#line 42
  return (38400);
  case_4097: /* CIL Label */ 
#line 45
  return (57600);
  case_4098: /* CIL Label */ 
#line 49
  return (115200);
  case_4099: /* CIL Label */ 
#line 53
  return (230400);
  case_4100: /* CIL Label */ 
#line 57
  return (460800);
  switch_break: /* CIL Label */ ;
  }
#line 60
  return (-1);
}
}
#line 259 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 190 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/libcsc/libcyclades-ser-cli.c"
static void *libc  =    (void *)0;
#line 27 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/libcsc/libcyclades-ser-cli.c"
static int (*real_tcsetattr)(int fd , int optional_actions , struct termios  const  *termios_p )  =    (int (*)(int fd ,
            int optional_actions , struct termios  const  *termios_p ))((void *)0);
#line 28 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/libcsc/libcyclades-ser-cli.c"
static int (*real_tcsendbreak)(int fd , int duration )  ;
#line 29 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/libcsc/libcyclades-ser-cli.c"
static char *cyclades_devices[32]  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/libcsc/libcyclades-ser-cli.c"
static int num_devices  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/libcsc/libcyclades-ser-cli.c"
static int socket_fd  =    -1;
#line 32 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/libcsc/libcyclades-ser-cli.c"
static int socket_ind  =    -1;
#line 34 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/libcsc/libcyclades-ser-cli.c"
void libcsc_init(void) 
{ 
  FILE *fp ;
  void *tmp ;
  void *tmp___0 ;
  char str[1024] ;
  char *tmp___1 ;

  {
  {
#line 38
  libc = dlopen("libc.so.6", 257);
  }
#line 39
  if (! libc) {
    {
#line 41
    printf((char const   */* __restrict  */)"Can\'t map libc.so.6\n");
#line 42
    exit(1);
    }
  }
  {
#line 44
  tmp = dlsym((void */* __restrict  */)libc, (char const   */* __restrict  */)"tcsetattr");
#line 44
  real_tcsetattr = (int (*)(int  , int  , struct termios  const  * ))tmp;
#line 45
  tmp___0 = dlsym((void */* __restrict  */)libc, (char const   */* __restrict  */)"tcsendbreak");
#line 45
  real_tcsendbreak = (int (*)(int  , int  ))tmp___0;
#line 47
  num_devices = 0;
#line 48
  fp = fopen((char const   */* __restrict  */)"/etc/cyclades-devices", (char const   */* __restrict  */)"r");
  }
#line 49
  if (fp) {
    {
#line 52
    while (1) {
      while_continue: /* CIL Label */ ;
#line 52
      if (num_devices < 32) {
        {
#line 52
        tmp___1 = fgets((char */* __restrict  */)(str), (int )sizeof(str), (FILE */* __restrict  */)fp);
        }
#line 52
        if (! tmp___1) {
#line 52
          goto while_break;
        }
      } else {
#line 52
        goto while_break;
      }
#line 54
      if ((int )str[0] == 47) {
        {
#line 56
        strtok((char */* __restrict  */)(str), (char const   */* __restrict  */)":\r\n");
#line 57
        cyclades_devices[num_devices] = strdup((char const   *)(str));
#line 58
        num_devices ++;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 61
    fclose(fp);
    }
  }
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/libcsc/libcyclades-ser-cli.c"
void libcsc_fini(void) 
{ 


  {
  {
#line 67
  dlclose(libc);
#line 68
  libc = (void *)0;
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/libcsc/libcyclades-ser-cli.c"
static void close_socket(void) 
{ 


  {
  {
#line 73
  close(socket_fd);
#line 74
  socket_fd = -1;
#line 75
  socket_ind = -1;
  }
#line 76
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/libcsc/libcyclades-ser-cli.c"
static int open_socket(int ind ) 
{ 
  struct sockaddr_un addr ;
  int tmp ;

  {
#line 82
  if (socket_ind == ind) {
#line 83
    return (0);
  }
#line 84
  if (socket_fd >= 0) {
    {
#line 85
    close(socket_fd);
    }
  }
  {
#line 86
  socket_fd = socket(1, 1, 0);
  }
#line 87
  if (socket_fd == -1) {
#line 88
    return (-1);
  }
  {
#line 89
  addr.sun_family = (sa_family_t )1;
#line 90
  snprintf((char */* __restrict  */)(addr.sun_path), sizeof(addr.sun_path), (char const   */* __restrict  */)"%s.control",
           cyclades_devices[ind]);
#line 91
  addr.sun_path[sizeof(addr.sun_path) - 1UL] = (char )'\000';
#line 92
  socket_ind = ind;
#line 93
  tmp = connect(socket_fd, (struct sockaddr  const  *)(& addr), (socklen_t )sizeof(addr));
  }
#line 93
  if (tmp) {
    {
#line 95
    close(socket_fd);
#line 96
    socket_fd = -1;
#line 97
    socket_ind = -1;
    }
#line 98
    return (-1);
  }
#line 100
  return (0);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/libcsc/libcyclades-ser-cli.c"
static int get_device_ind(int fd ) 
{ 
  struct stat device_stat ;
  struct stat fd_stat ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 108
  tmp = fstat(fd, & fd_stat);
  }
#line 108
  if (tmp) {
#line 109
    return (-1);
  }
#line 110
  i = 0;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! (i < num_devices)) {
#line 110
      goto while_break;
    }
    {
#line 112
    tmp___0 = stat((char const   */* __restrict  */)cyclades_devices[i], (struct stat */* __restrict  */)(& device_stat));
    }
#line 112
    if (! tmp___0) {
#line 114
      if (device_stat.st_dev == fd_stat.st_dev) {
#line 114
        if (device_stat.st_ino == fd_stat.st_ino) {
#line 116
          return (i);
        }
      }
    }
#line 110
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return (-1);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/libcsc/libcyclades-ser-cli.c"
static int send_data(int port_ind , e_operation oper , int val , int extra_timeout ) 
{ 
  fd_set readfds ;
  fd_set exceptfds ;
  struct timeval timeout ;
  s_control s ;
  struct sigaction act ;
  struct sigaction oldact ;
  int rc ;
  int no_ign_pipe ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;

  {
  {
#line 129
  no_ign_pipe = 0;
#line 131
  tmp = open_socket(port_ind);
  }
#line 131
  if (tmp == -1) {
#line 132
    return (-1);
  }
  {
#line 133
  act.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 134
  tmp___0 = sigaction(13, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)(& oldact));
  }
#line 134
  if (tmp___0) {
    {
#line 136
    syslog(4, "libcyclades-ser-cli: Can\'t ignore SIGPIPE.");
#line 137
    no_ign_pipe = 1;
    }
  }
  {
#line 140
  s.oper = oper;
#line 141
  s.val = val;
#line 142
  s.size = (int )sizeof(s_control );
#line 143
  tmp___2 = send(socket_fd, (void const   *)(& s), sizeof(s_control ), 0);
  }
#line 143
  if ((unsigned long )tmp___2 != sizeof(s_control )) {
#line 145
    if (! no_ign_pipe) {
      {
#line 147
      tmp___1 = sigaction(13, (struct sigaction  const  */* __restrict  */)(& oldact),
                          (struct sigaction */* __restrict  */)((void *)0));
      }
#line 147
      if (tmp___1) {
        {
#line 148
        syslog(3, "libcyclades-ser-cli: Can\'t reset SIGPIPE handler.");
        }
      }
    }
    {
#line 150
    close_socket();
    }
#line 151
    return (-1);
  }
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readfds.__fds_bits[0]): "memory");
#line 153
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  readfds.__fds_bits[socket_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << socket_fd % (8 * (int )sizeof(__fd_mask ));
  {
#line 155
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 155
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& exceptfds.__fds_bits[0]): "memory");
#line 155
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 156
  exceptfds.__fds_bits[socket_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << socket_fd % (8 * (int )sizeof(__fd_mask ));
#line 157
  timeout.tv_sec = (__time_t )(extra_timeout + 2);
#line 158
  timeout.tv_usec = (__suseconds_t )0;
#line 159
  tmp___4 = select(socket_fd + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)(& exceptfds), (struct timeval */* __restrict  */)(& timeout));
  }
#line 159
  if (tmp___4 != 1) {
#line 159
    goto _L;
  } else
#line 159
  if ((exceptfds.__fds_bits[socket_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << socket_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
    _L: /* CIL Label */ 
#line 162
    if (! no_ign_pipe) {
      {
#line 164
      tmp___3 = sigaction(13, (struct sigaction  const  */* __restrict  */)(& oldact),
                          (struct sigaction */* __restrict  */)((void *)0));
      }
#line 164
      if (tmp___3) {
        {
#line 165
        syslog(3, "libcyclades-ser-cli: Can\'t reset SIGPIPE handler.");
        }
      }
    }
    {
#line 167
    close_socket();
    }
#line 168
    return (-1);
  }
  {
#line 170
  tmp___5 = recv(socket_fd, (void *)(& s), sizeof(s), 256);
#line 170
  rc = (int )tmp___5;
  }
#line 171
  if (! no_ign_pipe) {
    {
#line 173
    tmp___6 = sigaction(13, (struct sigaction  const  */* __restrict  */)(& oldact),
                        (struct sigaction */* __restrict  */)((void *)0));
    }
#line 173
    if (tmp___6) {
      {
#line 174
      syslog(3, "libcyclades-ser-cli: Can\'t reset SIGPIPE handler.");
      }
    }
  }
#line 176
  if ((unsigned long )rc != sizeof(s)) {
    {
#line 178
    close_socket();
    }
#line 179
    return (-1);
  } else
#line 176
  if (s.val != val) {
    {
#line 178
    close_socket();
    }
#line 179
    return (-1);
  } else
#line 176
  if ((unsigned int )s.oper != (unsigned int )oper) {
    {
#line 178
    close_socket();
    }
#line 179
    return (-1);
  } else
#line 176
  if ((unsigned long )s.size != sizeof(s)) {
    {
#line 178
    close_socket();
    }
#line 179
    return (-1);
  }
#line 181
  return (0);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/libcsc/libcyclades-ser-cli.c"
static void do_xon_xoff(int ind , int *a_success , int *a_fail , struct termios *term ,
                        struct termios  const  *termios_p ) 
{ 
  int xon ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int xon___0 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 188
  if ((term->c_iflag & 1024U) != (unsigned int )(termios_p->c_iflag & 1024U)) {
#line 190
    xon = 1;
#line 191
    if (termios_p->c_iflag & 1024U) {
#line 192
      xon = 2;
    }
    {
#line 193
    tmp___1 = send_data(ind, (e_operation )5, xon, 0);
    }
#line 193
    if (tmp___1) {
#line 206
      tmp___0 = a_fail;
#line 206
      a_fail ++;
    } else {
#line 197
      term->c_iflag = 0U;
#line 199
      term->c_cflag = 0U;
#line 201
      if (termios_p->c_iflag & 1024U) {
#line 202
        term->c_iflag |= 5120U;
      }
#line 203
      tmp = a_success;
#line 203
      a_success ++;
    }
  }
#line 208
  if ((term->c_iflag & 4096U) != (unsigned int )(termios_p->c_iflag & 4096U)) {
#line 210
    xon___0 = 14;
#line 211
    if (termios_p->c_iflag & 4096U) {
#line 212
      xon___0 = 15;
    }
    {
#line 213
    tmp___4 = send_data(ind, (e_operation )5, xon___0, 0);
    }
#line 213
    if (tmp___4) {
#line 223
      tmp___3 = a_fail;
#line 223
      a_fail ++;
    } else {
#line 215
      term->c_iflag = 0U;
#line 217
      term->c_cflag = 0U;
#line 219
      term->c_iflag |= (unsigned int )(termios_p->c_iflag & 1024U);
#line 220
      tmp___2 = a_success;
#line 220
      a_success ++;
    }
  }
#line 225
  return;
}
}
#line 227
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int fd ,
                                                                         int optional_actions ,
                                                                         struct termios  const  *termios_p ) ;
#line 227 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/libcsc/libcyclades-ser-cli.c"
int ( __attribute__((__leaf__)) tcsetattr)(int fd , int optional_actions , struct termios  const  *termios_p ) 
{ 
  int ind ;
  int tmp ;
  struct termios term ;
  int a_fail ;
  int a_success ;
  speed_t i_sp ;
  speed_t o_sp ;
  speed_t term_sp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int csize ;
  int tmp___5 ;
  int parity ;
  int tmp___6 ;
  int stop ;
  int tmp___7 ;
  int rtscts ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 229
  tmp = get_device_ind(fd);
#line 229
  ind = tmp;
#line 231
  a_fail = 0;
#line 231
  a_success = 0;
  }
#line 234
  if (ind == -1) {
    {
#line 235
    tmp___0 = (*real_tcsetattr)(fd, optional_actions, termios_p);
    }
#line 235
    return (tmp___0);
  }
  {
#line 236
  tmp___1 = tcgetattr(fd, & term);
  }
#line 236
  if (tmp___1) {
#line 237
    return (-1);
  }
  {
#line 238
  tmp___2 = memcmp((void const   *)(& term), (void const   *)termios_p, sizeof(struct termios ));
  }
#line 238
  if (! tmp___2) {
#line 239
    return (0);
  }
#line 241
  if ((term.c_cflag & 1024U) != (unsigned int )(termios_p->c_cflag & 1024U)) {
#line 243
    term.c_cflag = 0U;
#line 244
    term.c_cflag |= (unsigned int )(termios_p->c_cflag & 1024U);
#line 245
    a_success ++;
  }
  {
#line 249
  i_sp = cfgetispeed(termios_p);
#line 250
  o_sp = cfgetospeed(termios_p);
#line 251
  term_sp = cfgetispeed((struct termios  const  *)(& term));
  }
#line 252
  if (i_sp != term_sp) {
#line 252
    goto _L;
  } else
#line 252
  if (o_sp != term_sp) {
    _L: /* CIL Label */ 
#line 254
    if (i_sp != o_sp) {
#line 256
      if (i_sp != term_sp) {
#line 257
        term_sp = i_sp;
      } else {
#line 259
        term_sp = o_sp;
      }
    } else {
#line 263
      term_sp = i_sp;
    }
    {
#line 265
    tmp___3 = baud_index_to_int___0(term_sp);
#line 265
    tmp___4 = send_data(ind, (e_operation )0, tmp___3, 0);
    }
#line 265
    if (tmp___4) {
#line 272
      a_fail ++;
    } else {
      {
#line 267
      cfsetispeed(& term, term_sp);
#line 268
      cfsetospeed(& term, term_sp);
#line 269
      a_success ++;
      }
    }
  }
#line 274
  if ((term.c_cflag & 48U) != (unsigned int )(termios_p->c_cflag & 48U)) {
    {
#line 280
    if ((termios_p->c_cflag & 48U) == 0U) {
#line 280
      goto case_0;
    }
#line 283
    if ((termios_p->c_cflag & 48U) == 16U) {
#line 283
      goto case_16;
    }
#line 286
    if ((termios_p->c_cflag & 48U) == 32U) {
#line 286
      goto case_32;
    }
#line 289
    if ((termios_p->c_cflag & 48U) == 48U) {
#line 289
      goto case_48;
    }
#line 292
    goto switch_default;
    case_0: /* CIL Label */ 
#line 281
    csize = 5;
#line 282
    goto switch_break;
    case_16: /* CIL Label */ 
#line 284
    csize = 6;
#line 285
    goto switch_break;
    case_32: /* CIL Label */ 
#line 287
    csize = 7;
#line 288
    goto switch_break;
    case_48: /* CIL Label */ 
#line 290
    csize = 8;
#line 291
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 293
    csize = 0;
    switch_break: /* CIL Label */ ;
    }
#line 295
    if (csize == 0) {
#line 297
      a_fail ++;
    } else {
      {
#line 301
      tmp___5 = send_data(ind, (e_operation )2, csize, 0);
      }
#line 301
      if (tmp___5) {
#line 307
        a_fail ++;
      } else {
#line 303
        a_success ++;
#line 304
        term.c_cflag = (unsigned int )csize;
      }
    }
  }
#line 310
  if ((term.c_iflag & 16U) != (unsigned int )(termios_p->c_iflag & 16U)) {
#line 310
    goto _L___0;
  } else
#line 310
  if ((term.c_cflag & 768U) != (unsigned int )(termios_p->c_cflag & 768U)) {
    _L___0: /* CIL Label */ 
#line 314
    if (termios_p->c_cflag & 256U) {
#line 316
      if (termios_p->c_cflag & 512U) {
#line 317
        parity = 2;
      } else {
#line 319
        parity = 3;
      }
    } else {
#line 322
      parity = 1;
    }
    {
#line 324
    tmp___6 = send_data(ind, (e_operation )3, parity, 0);
    }
#line 324
    if (tmp___6) {
#line 331
      a_fail ++;
    } else {
#line 326
      term.c_cflag = 0U;
#line 327
      term.c_cflag |= (unsigned int )(termios_p->c_cflag & 768U);
#line 328
      a_success ++;
    }
  }
#line 333
  if ((term.c_cflag & 64U) != (unsigned int )(termios_p->c_cflag & 64U)) {
#line 335
    stop = 1;
#line 336
    if (termios_p->c_cflag & 64U) {
#line 337
      stop = 2;
    }
    {
#line 338
    tmp___7 = send_data(ind, (e_operation )4, stop, 0);
    }
#line 338
    if (tmp___7) {
#line 345
      a_fail ++;
    } else {
#line 340
      term.c_cflag = 0U;
#line 341
      term.c_cflag |= (unsigned int )(termios_p->c_cflag & 64U);
#line 342
      a_success ++;
    }
  }
  {
#line 347
  do_xon_xoff(ind, & a_success, & a_fail, & term, termios_p);
  }
#line 350
  if ((term.c_cflag & 2147483648U) != (unsigned int )(termios_p->c_cflag & 2147483648U)) {
#line 352
    rtscts = 1;
#line 353
    if (termios_p->c_cflag & 2147483648U) {
#line 354
      rtscts = 3;
    }
    {
#line 355
    tmp___8 = send_data(ind, (e_operation )5, rtscts, 0);
    }
#line 355
    if (tmp___8) {
#line 369
      a_fail ++;
    } else {
#line 357
      term.c_cflag = 0U;
#line 358
      term.c_cflag |= (unsigned int )(termios_p->c_cflag & 2147483648U);
#line 359
      a_success ++;
#line 360
      if (rtscts == 1) {
        {
#line 364
        term.c_iflag = 0U;
#line 365
        do_xon_xoff(ind, & a_success, & a_fail, & term, termios_p);
        }
      }
    }
  }
  {
#line 372
  tmp___9 = memcmp((void const   *)(& term.c_cc), (void const   *)(& termios_p->c_cc),
                   sizeof(term.c_cc));
  }
#line 372
  if (tmp___9) {
    {
#line 374
    memcpy((void */* __restrict  */)(& term.c_cc), (void const   */* __restrict  */)(& termios_p->c_cc),
           sizeof(term.c_cc));
#line 375
    a_success ++;
    }
  }
#line 377
  if (a_success) {
    {
#line 378
    (*real_tcsetattr)(fd, optional_actions, (struct termios  const  *)(& term));
    }
  }
#line 379
  if (a_success) {
#line 380
    return (0);
  } else
#line 379
  if (! a_fail) {
#line 380
    return (0);
  }
#line 381
  return (-1);
}
}
#line 384
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsendbreak)(int fd ,
                                                                           int duration ) ;
#line 384 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/libcsc/libcyclades-ser-cli.c"
int ( __attribute__((__leaf__)) tcsendbreak)(int fd , int duration ) 
{ 
  int ind ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 386
  tmp = get_device_ind(fd);
#line 386
  ind = tmp;
  }
#line 387
  if (ind == -1) {
    {
#line 388
    tmp___0 = (*real_tcsendbreak)(fd, duration);
    }
#line 388
    return (tmp___0);
  }
  {
#line 389
  tmp___1 = send_data(ind, (e_operation )1, duration, duration % 4 + 1);
  }
#line 389
  return (tmp___1);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 111 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/cyclades-ser-cli.h"
int Debug ;
#line 22 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/system.h"
void sysdelay(int msecs ) ;
#line 23
void sysmessage(int type , char const   * const  format  , ...) ;
#line 26
unsigned char *mem_get(int size ) ;
#line 29
char Idmsg[128] ;
#line 276 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrio.h"
struct event Eventpoll[20]  ;
#line 278 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrio.h"
struct event Evhead  ;
#line 246 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/telnet.h"
int tel_init(int netsize , struct buffer *ibp , struct buffer *obp ) ;
#line 247
int tel_putdata(struct buffer *bp ) ;
#line 249
int tel_getdata(void) ;
#line 250
int tel_putcmd(int command , int arg ) ;
#line 251
void tel_free(void) ;
#line 252
int sync_comport_command(int command , int arg ) ;
#line 255 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/telnet.h"
struct nvt Nvt  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/sock.h"
int sock_unlink(void) ;
#line 24
int sock_write(unsigned char *buf , int n ) ;
#line 25
int sock_read(unsigned char *buf , int n ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
void do_option(int opt ) ;
#line 34
void dont_option(int opt ) ;
#line 35
void will_option(int opt ) ;
#line 36
void wont_option(int opt ) ;
#line 37
void send_option(int type , int opt ) ;
#line 38
void handle_suboption(unsigned char *suboptp , int subsize ) ;
#line 44
void comport_config(void) ;
#line 45
void comport_default(void) ;
#line 47
int comport_command(int command , int arg ) ;
#line 48
void handle_com_port_command(unsigned char *buf ) ;
#line 54
void print_all(void) ;
#line 55
void print_option(unsigned char c ) ;
#line 56
void print_control(unsigned char c ) ;
#line 58
void print_linestate(int state ) ;
#line 59
void print_modemstate(int state ) ;
#line 60
void print_speed(int speed ) ;
#line 61
void print_datasize(int datasize ) ;
#line 62
void print_stopsize(int stopsize ) ;
#line 63
void print_parity(int parity ) ;
#line 64
void print_setcontrol(int control ) ;
#line 65
void print_purge(int purge ) ;
#line 66
void print_command(int cmdidx ) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
struct comport Comport  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
unsigned char Suboptbuf[64]  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
int Suboptsize  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
unsigned char Comibuf[16384]  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
unsigned char Comobuf[16384]  ;
#line 86 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
int tel_init(int netsize , struct buffer *ibp , struct buffer *obp ) 
{ 
  int retries ;
  int tmp ;

  {
  {
#line 89
  retries = 0;
#line 91
  Nvt.iosize = netsize;
#line 92
  Nvt.inbuff = ibp;
#line 93
  Nvt.outbuff = obp;
#line 94
  Nvt.comport = & Comport;
#line 96
  comport_default();
  }
#line 98
  if (Nvt.servertype == 1) {
#line 99
    return (0);
  }
  {
#line 101
  sysdelay(1000);
#line 103
  NvtOptions[44] |= 1;
#line 104
  send_option(251, 44);
#line 105
  NvtOptions[44] |= 4;
#line 107
  NvtOptions[3] |= 16;
#line 108
  send_option(253, 3);
#line 109
  NvtOptions[3] |= 64;
#line 111
  tel_getdata();
  }
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 114
    sysdelay(200);
#line 115
    tel_getdata();
    }
#line 113
    if (! (NvtOptions[44] & 2)) {
#line 113
      tmp = retries;
#line 113
      retries ++;
#line 113
      if (! (tmp < 2)) {
#line 113
        goto while_break;
      }
    } else {
#line 113
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  if (NvtOptions[44] & 2) {
    {
#line 119
    comport_config();
    }
  }
#line 122
  return (0);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
int S_state  =    0;
#line 132 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
int tel_getdata(void) 
{ 
  int i ;
  int ret ;
  struct buffer *bp ;
  unsigned char c ;
  int XXi ;
  struct event *evp ;
  int XXi___0 ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;
  struct event *evp___0 ;
  int XXi___1 ;

  {
  {
#line 138
  bp = Nvt.inbuff;
#line 142
  ret = sock_read(Comibuf, Nvt.iosize);
  }
#line 142
  if (ret <= 0) {
#line 143
    return (-1);
  }
#line 144
  if (Debug > 2) {
    {
#line 145
    sysmessage(0, (char const   */* const  */)"Sock_read, %d bytes: %02X %02X %02X %02X %02X %02X %02X %02X\n",
               ret, (int )Comibuf[0], (int )Comibuf[1], (int )Comibuf[2], (int )Comibuf[3],
               (int )Comibuf[4], (int )Comibuf[5], (int )Comibuf[6], (int )Comibuf[7]);
    }
  }
#line 151
  if (Nvt.servertype == 1) {
#line 152
    XXi = bp->b_size - bp->b_hold;
#line 152
    if (ret > XXi) {
      {
#line 152
      sysmessage(4, (char const   */* const  */)"%s: Buffer overflow\n", Idmsg);
#line 152
      ret = XXi;
      }
    }
    {
#line 152
    memcpy((void */* __restrict  */)bp->b_ins, (void const   */* __restrict  */)(Comibuf),
           (size_t )ret);
#line 152
    bp->b_ins += ret;
#line 152
    bp->b_hold += ret;
#line 153
    XXi___0 = 0;
#line 153
    evp = & Eventpoll[0];
    }
    {
#line 153
    while (1) {
      while_continue: /* CIL Label */ ;
#line 153
      if (! (XXi___0 < 20)) {
#line 153
        goto while_break;
      }
#line 153
      if (evp->ev_type == 0) {
#line 153
        goto while_break;
      }
#line 153
      XXi___0 ++;
#line 153
      evp ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 153
    if (XXi___0 == 20) {
      {
#line 153
      sysmessage(4, (char const   */* const  */)"%s: Too many events", Idmsg);
      }
    } else {
#line 153
      evp->ev_type = 2;
#line 153
      evp->ev_code = 1;
#line 153
      evp->ev_param = (void *)0;
#line 153
      evp->ev_size = 0;
#line 153
      evp->ev_next = & Evhead;
#line 153
      evp->ev_last = Evhead.ev_last;
#line 153
      (Evhead.ev_last)->ev_next = evp;
#line 153
      Evhead.ev_last = evp;
    }
#line 154
    return (0);
  }
#line 157
  i = 0;
  {
#line 157
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 157
    if (! (i < ret)) {
#line 157
      goto while_break___0;
    }
#line 158
    c = Comibuf[i];
    {
#line 160
    if (S_state == 0) {
#line 160
      goto case_0;
    }
#line 169
    if (S_state == 1) {
#line 169
      goto case_1;
    }
#line 199
    if (S_state == 4) {
#line 199
      goto case_4;
    }
#line 204
    if (S_state == 5) {
#line 204
      goto case_5;
    }
#line 209
    if (S_state == 2) {
#line 209
      goto case_2;
    }
#line 214
    if (S_state == 3) {
#line 214
      goto case_3;
    }
#line 219
    if (S_state == 6) {
#line 219
      goto case_6;
    }
#line 232
    if (S_state == 7) {
#line 232
      goto case_7;
    }
#line 159
    goto switch_break;
    case_0: /* CIL Label */ 
#line 161
    if ((int )c == 255) {
      {
#line 162
      S_state = 1;
#line 163
      print_control(c);
      }
    } else
#line 165
    if (bp->b_hold < bp->b_size) {
#line 165
      tmp___0 = bp->b_ins;
#line 165
      (bp->b_ins) ++;
#line 165
      *tmp___0 = c;
#line 165
      (bp->b_hold) ++;
    } else {
      {
#line 165
      sysmessage(4, (char const   */* const  */)"%s: Buffer overflow\n", Idmsg);
      }
    }
#line 168
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 171
    if ((int )c == 253) {
#line 171
      goto case_253;
    }
#line 175
    if ((int )c == 254) {
#line 175
      goto case_254;
    }
#line 179
    if ((int )c == 251) {
#line 179
      goto case_251;
    }
#line 183
    if ((int )c == 252) {
#line 183
      goto case_252;
    }
#line 187
    if ((int )c == 250) {
#line 187
      goto case_250;
    }
#line 193
    goto switch_default;
    case_253: /* CIL Label */ 
    {
#line 172
    S_state = 4;
#line 173
    print_control(c);
    }
#line 174
    goto switch_break___0;
    case_254: /* CIL Label */ 
    {
#line 176
    S_state = 5;
#line 177
    print_control(c);
    }
#line 178
    goto switch_break___0;
    case_251: /* CIL Label */ 
    {
#line 180
    S_state = 2;
#line 181
    print_control(c);
    }
#line 182
    goto switch_break___0;
    case_252: /* CIL Label */ 
    {
#line 184
    S_state = 3;
#line 185
    print_control(c);
    }
#line 186
    goto switch_break___0;
    case_250: /* CIL Label */ 
    {
#line 188
    S_state = 6;
#line 189
    print_control(c);
#line 190
    Suboptsize = 0;
    }
#line 191
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 194
    S_state = 0;
#line 195
    if (bp->b_hold < bp->b_size) {
#line 195
      tmp___1 = bp->b_ins;
#line 195
      (bp->b_ins) ++;
#line 195
      *tmp___1 = c;
#line 195
      (bp->b_hold) ++;
    } else {
      {
#line 195
      sysmessage(4, (char const   */* const  */)"%s: Buffer overflow\n", Idmsg);
      }
    }
#line 196
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 198
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 200
    print_option(c);
#line 201
    S_state = 0;
#line 202
    do_option((int )c);
    }
#line 203
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 205
    print_option(c);
#line 206
    S_state = 0;
#line 207
    dont_option((int )c);
    }
#line 208
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 210
    print_option(c);
#line 211
    S_state = 0;
#line 212
    will_option((int )c);
    }
#line 213
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 215
    print_option(c);
#line 216
    S_state = 0;
#line 217
    wont_option((int )c);
    }
#line 218
    goto switch_break;
    case_6: /* CIL Label */ 
#line 220
    if ((int )c == 255) {
      {
#line 221
      S_state = 7;
#line 222
      print_control(c);
      }
    } else
#line 224
    if (Suboptsize > 64) {
      {
#line 225
      sysmessage(3, (char const   */* const  */)"Suboption too large\n");
      }
    } else {
#line 228
      tmp___2 = Suboptsize;
#line 228
      Suboptsize ++;
#line 228
      Suboptbuf[tmp___2] = c;
    }
#line 231
    goto switch_break;
    case_7: /* CIL Label */ 
#line 233
    if ((int )c == 240) {
      {
#line 234
      S_state = 0;
#line 235
      print_control(c);
#line 236
      handle_suboption(Suboptbuf, Suboptsize);
#line 237
      Suboptsize = 0;
      }
    } else {
      {
#line 239
      S_state = 0;
#line 240
      sysmessage(3, (char const   */* const  */)"Suboption not terminated: %d", (int )c);
      }
    }
#line 243
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 157
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 246
  if (bp->b_hold) {
#line 247
    XXi___1 = 0;
#line 247
    evp___0 = & Eventpoll[0];
    {
#line 247
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 247
      if (! (XXi___1 < 20)) {
#line 247
        goto while_break___1;
      }
#line 247
      if (evp___0->ev_type == 0) {
#line 247
        goto while_break___1;
      }
#line 247
      XXi___1 ++;
#line 247
      evp___0 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 247
    if (XXi___1 == 20) {
      {
#line 247
      sysmessage(4, (char const   */* const  */)"%s: Too many events", Idmsg);
      }
    } else {
#line 247
      evp___0->ev_type = 2;
#line 247
      evp___0->ev_code = 1;
#line 247
      evp___0->ev_param = (void *)0;
#line 247
      evp___0->ev_size = 0;
#line 247
      evp___0->ev_next = & Evhead;
#line 247
      evp___0->ev_last = Evhead.ev_last;
#line 247
      (Evhead.ev_last)->ev_next = evp___0;
#line 247
      Evhead.ev_last = evp___0;
    }
  }
  {
#line 250
  print_all();
  }
#line 251
  return (0);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
int tel_putdata(struct buffer *bp ) 
{ 
  unsigned char c ;
  int ret ;
  int size ;
  int frombuf ;
  unsigned char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned char *tmp___3 ;

  {
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if (! bp->b_hold) {
#line 262
      goto while_break;
    }
#line 264
    if (Nvt.servertype == 1) {
#line 266
      if (bp->b_hold < Nvt.iosize) {
#line 266
        size = bp->b_hold;
      } else {
#line 266
        size = Nvt.iosize;
      }
      {
#line 267
      memcpy((void */* __restrict  */)(Comobuf), (void const   */* __restrict  */)bp->b_rem,
             (size_t )size);
#line 267
      bp->b_rem += size;
#line 267
      bp->b_hold -= size;
#line 268
      ret = sock_write(Comobuf, size);
      }
#line 268
      if (ret != size) {
#line 269
        if (ret < 0) {
#line 270
          return (ret);
        } else {
#line 272
          frombuf = size - ret;
#line 273
          bp->b_rem -= frombuf;
#line 273
          bp->b_hold += frombuf;
        }
#line 275
        goto while_break;
      }
    } else {
#line 278
      if (bp->b_hold < Nvt.iosize) {
#line 278
        frombuf = bp->b_hold;
      } else {
#line 278
        frombuf = Nvt.iosize;
      }
#line 279
      size = 0;
      {
#line 280
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 280
        tmp___2 = frombuf;
#line 280
        frombuf --;
#line 280
        if (! tmp___2) {
#line 280
          goto while_break___0;
        }
#line 281
        if (bp->b_hold) {
#line 281
          tmp = bp->b_rem;
#line 281
          (bp->b_rem) ++;
#line 281
          c = *tmp;
        } else {
#line 281
          c = (unsigned char)0;
        }
#line 281
        if (bp->b_hold) {
#line 281
          (bp->b_hold) --;
        }
#line 282
        if ((int )c == 255) {
#line 283
          if (size == Nvt.iosize - 1) {
#line 285
            (bp->b_rem) --;
#line 285
            (bp->b_hold) ++;
#line 286
            frombuf ++;
#line 287
            goto while_break___0;
          }
#line 289
          tmp___0 = size;
#line 289
          size ++;
#line 289
          Comobuf[tmp___0] = (unsigned char)255;
        }
#line 291
        tmp___1 = size;
#line 291
        size ++;
#line 291
        Comobuf[tmp___1] = c;
#line 292
        if (size == Nvt.iosize) {
#line 293
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 298
      frombuf = 0;
      {
#line 299
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 299
        if (! (size > 0)) {
#line 299
          goto while_break___1;
        }
        {
#line 300
        ret = sock_write(& Comobuf[frombuf], size);
        }
#line 300
        if (ret == size) {
#line 301
          goto while_break___1;
        }
#line 303
        if (Debug > 2) {
          {
#line 304
          sysmessage(0, (char const   */* const  */)"Sock write: %d of %d\n", ret,
                     size);
          }
        }
#line 306
        if (ret < 0) {
#line 307
          return (ret);
        }
#line 309
        frombuf += ret;
#line 310
        size -= ret;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  if (bp->b_hold == 0) {
#line 341
    tmp___3 = bp->b_base;
#line 341
    bp->b_ins = tmp___3;
#line 341
    bp->b_rem = tmp___3;
#line 341
    bp->b_hold = 0;
  }
#line 343
  return (0);
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
int tel_putcmd(int command , int arg ) 
{ 
  int tmp ;

  {
  {
#line 349
  tmp = comport_command(command, arg);
  }
#line 349
  return (tmp);
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
void tel_free(void) 
{ 
  int opt ;

  {
#line 358
  S_state = 0;
#line 359
  Suboptsize = 0;
#line 361
  opt = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if (! (opt < 256)) {
#line 361
      goto while_break;
    }
#line 362
    NvtOptions[opt] &= -2;
#line 361
    opt ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 365
  sock_unlink();
  }
#line 366
  return;
}
}
#line 372 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
void do_option(int opt ) 
{ 


  {
#line 375
  if (NvtOptions[opt] & 1) {
#line 376
    NvtOptions[opt] |= 2;
#line 377
    if (! (NvtOptions[opt] & 4)) {
      {
#line 378
      send_option(251, opt);
#line 379
      NvtOptions[opt] |= 4;
      }
    }
  } else {
    {
#line 382
    send_option(252, opt);
    }
  }
#line 384
  return;
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
void dont_option(int opt ) 
{ 


  {
#line 389
  NvtOptions[opt] &= -3;
#line 390
  return;
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
void will_option(int opt ) 
{ 


  {
#line 395
  if (NvtOptions[opt] & 16) {
#line 396
    NvtOptions[opt] |= 32;
#line 397
    if (! (NvtOptions[opt] & 64)) {
      {
#line 398
      send_option(253, opt);
#line 399
      NvtOptions[opt] |= 64;
      }
    }
  } else {
    {
#line 402
    send_option(254, opt);
    }
  }
#line 404
  return;
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
void wont_option(int opt ) 
{ 


  {
#line 409
  NvtOptions[opt] &= -33;
#line 410
  return;
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
void send_option(int type , int opt ) 
{ 
  int ret ;
  int size ;
  unsigned char *obp ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  struct event *evp ;
  int XXi ;

  {
#line 420
  obp = & Comobuf[0];
#line 422
  tmp = obp;
#line 422
  obp ++;
#line 422
  *tmp = (unsigned char)255;
#line 423
  tmp___0 = obp;
#line 423
  obp ++;
#line 423
  *tmp___0 = (unsigned char )type;
#line 424
  tmp___1 = obp;
#line 424
  obp ++;
#line 424
  *tmp___1 = (unsigned char )opt;
#line 426
  size = 3;
#line 427
  obp = & Comobuf[0];
#line 429
  if (Debug > 2) {
    {
#line 430
    sysmessage(0, (char const   */* const  */)"Sock_write, 3 bytes: %02X %02X %02X\n",
               (int )Comobuf[0], (int )Comobuf[1], (int )Comobuf[2]);
    }
  }
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! size) {
#line 434
      goto while_break;
    }
    {
#line 435
    ret = sock_write(obp, size);
    }
#line 435
    if (ret == -1) {
#line 436
      XXi = 0;
#line 436
      evp = & Eventpoll[0];
      {
#line 436
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 436
        if (! (XXi < 20)) {
#line 436
          goto while_break___0;
        }
#line 436
        if (evp->ev_type == 0) {
#line 436
          goto while_break___0;
        }
#line 436
        XXi ++;
#line 436
        evp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 436
      if (XXi == 20) {
        {
#line 436
        sysmessage(4, (char const   */* const  */)"%s: Too many events", Idmsg);
        }
      } else {
#line 436
        evp->ev_type = 2;
#line 436
        evp->ev_code = 2;
#line 436
        evp->ev_param = (void *)0;
#line 436
        evp->ev_size = 0;
#line 436
        evp->ev_next = & Evhead;
#line 436
        evp->ev_last = Evhead.ev_last;
#line 436
        (Evhead.ev_last)->ev_next = evp;
#line 436
        Evhead.ev_last = evp;
      }
#line 437
      goto while_break;
    } else
#line 438
    if (ret != size) {
      {
#line 439
      sysmessage(2, (char const   */* const  */)"Partial write in send_option: %d/%d\n",
                 ret, size);
#line 442
      sysdelay(200);
      }
    }
#line 444
    size -= ret;
#line 445
    obp += ret;
  }
  while_break: /* CIL Label */ ;
  }
#line 447
  return;
}
}
#line 449 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
void handle_suboption(unsigned char *suboptp , int subsize ) 
{ 
  unsigned char subopt ;

  {
  {
#line 452
  subopt = *suboptp;
#line 454
  print_option(subopt);
  }
  {
#line 457
  if ((int )subopt == 44) {
#line 457
    goto case_44;
  }
#line 461
  goto switch_default;
  case_44: /* CIL Label */ 
  {
#line 458
  suboptp ++;
#line 458
  handle_com_port_command(suboptp);
#line 459
  subsize --;
  }
#line 460
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 462
  sysmessage(3, (char const   */* const  */)"suboption not supported: %d\n", (int )subopt);
  }
#line 464
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 466
  return;
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
void comport_config(void) 
{ 
  int mask ;

  {
  {
#line 478
  Comport.support = 1;
#line 481
  sync_comport_command(1, 0);
#line 482
  sync_comport_command(2, 0);
#line 483
  sync_comport_command(3, 0);
#line 484
  sync_comport_command(4, 0);
#line 485
  sync_comport_command(5, 0);
#line 488
  mask = 128;
#line 489
  sync_comport_command(11, mask);
#line 490
  mask = 20;
#line 491
  sync_comport_command(10, mask);
#line 493
  sysdelay(1000);
#line 495
  tel_getdata();
  }
#line 497
  return;
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
void comport_default(void) 
{ 


  {
#line 503
  Comport.support = 0;
#line 507
  Comport.portconfig.speed = 9600;
#line 508
  Comport.portconfig.datasize = 8;
#line 509
  Comport.portconfig.stopsize = 1;
#line 510
  Comport.portconfig.parity = 1;
#line 511
  Comport.portconfig.flowc = 1;
#line 513
  Comport.portstate.modemstate = 176;
#line 514
  Comport.portstate.linestate = 0;
#line 515
  return;
}
}
#line 517 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
int sync_comport_command(int command , int arg ) 
{ 
  int tmp ;

  {
  {
#line 521
  tmp = comport_command(command, arg);
  }
#line 521
  if (tmp == -1) {
#line 522
    return (-1);
  }
#line 524
  CmdState[command] = 1;
  {
#line 526
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 527
    sysdelay(200);
#line 528
    tel_getdata();
    }
#line 526
    if (! (CmdState[command] == 1)) {
#line 526
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 530
  return (0);
}
}
#line 533 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
int comport_command(int command , int arg ) 
{ 
  int size ;
  int ret ;
  unsigned char *obp ;
  struct event *evp ;
  int XXi ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  struct event *evp___0 ;
  int XXi___0 ;

  {
#line 540
  if ((Nvt.comport)->support == 0) {
#line 541
    CmdState[command] = 0;
#line 542
    XXi = 0;
#line 542
    evp = & Eventpoll[0];
    {
#line 542
    while (1) {
      while_continue: /* CIL Label */ ;
#line 542
      if (! (XXi < 20)) {
#line 542
        goto while_break;
      }
#line 542
      if (evp->ev_type == 0) {
#line 542
        goto while_break;
      }
#line 542
      XXi ++;
#line 542
      evp ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 542
    if (XXi == 20) {
      {
#line 542
      sysmessage(4, (char const   */* const  */)"%s: Too many events", Idmsg);
      }
    } else {
#line 542
      evp->ev_type = 2;
#line 542
      evp->ev_code = 3;
#line 542
      evp->ev_param = (void *)0;
#line 542
      evp->ev_size = 0;
#line 542
      evp->ev_next = & Evhead;
#line 542
      evp->ev_last = Evhead.ev_last;
#line 542
      (Evhead.ev_last)->ev_next = evp;
#line 542
      Evhead.ev_last = evp;
    }
#line 543
    return (0);
  }
#line 546
  obp = & Comobuf[0];
#line 548
  tmp___0 = obp;
#line 548
  obp ++;
#line 548
  *tmp___0 = (unsigned char)255;
#line 549
  tmp___1 = obp;
#line 549
  obp ++;
#line 549
  *tmp___1 = (unsigned char)250;
#line 550
  tmp___2 = obp;
#line 550
  obp ++;
#line 550
  *tmp___2 = (unsigned char)44;
#line 551
  tmp___3 = obp;
#line 551
  obp ++;
#line 551
  *tmp___3 = (unsigned char )command;
  {
#line 553
  if (command == 1) {
#line 553
    goto case_1;
  }
#line 557
  goto switch_default;
  case_1: /* CIL Label */ 
#line 554
  *obp = (unsigned char )((arg >> 24) & 255);
#line 554
  *(obp + 1) = (unsigned char )((arg >> 16) & 255);
#line 554
  *(obp + 2) = (unsigned char )((arg >> 8) & 255);
#line 554
  *(obp + 3) = (unsigned char )(arg & 255);
#line 555
  obp += 4;
#line 556
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 558
  *obp = (unsigned char )(arg & 255);
#line 559
  obp ++;
#line 560
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 562
  tmp___4 = obp;
#line 562
  obp ++;
#line 562
  *tmp___4 = (unsigned char)255;
#line 563
  tmp___5 = obp;
#line 563
  obp ++;
#line 563
  *tmp___5 = (unsigned char)240;
#line 565
  size = (int )(obp - & Comobuf[0]);
#line 566
  obp = & Comobuf[0];
#line 568
  if (Debug > 2) {
    {
#line 569
    sysmessage(0, (char const   */* const  */)"Sock_write, %d bytes: %02X %02X %02X %02X %02X %02X %02X %02X\n",
               size, (int )Comobuf[0], (int )Comobuf[1], (int )Comobuf[2], (int )Comobuf[3],
               (int )Comobuf[4], (int )Comobuf[5], (int )Comobuf[6], (int )Comobuf[7]);
    }
  }
  {
#line 574
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 574
    if (! size) {
#line 574
      goto while_break___0;
    }
    {
#line 575
    ret = sock_write(obp, size);
    }
#line 575
    if (ret == -1) {
#line 576
      XXi___0 = 0;
#line 576
      evp___0 = & Eventpoll[0];
      {
#line 576
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 576
        if (! (XXi___0 < 20)) {
#line 576
          goto while_break___1;
        }
#line 576
        if (evp___0->ev_type == 0) {
#line 576
          goto while_break___1;
        }
#line 576
        XXi___0 ++;
#line 576
        evp___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 576
      if (XXi___0 == 20) {
        {
#line 576
        sysmessage(4, (char const   */* const  */)"%s: Too many events", Idmsg);
        }
      } else {
#line 576
        evp___0->ev_type = 2;
#line 576
        evp___0->ev_code = 2;
#line 576
        evp___0->ev_param = (void *)0;
#line 576
        evp___0->ev_size = 0;
#line 576
        evp___0->ev_next = & Evhead;
#line 576
        evp___0->ev_last = Evhead.ev_last;
#line 576
        (Evhead.ev_last)->ev_next = evp___0;
#line 576
        Evhead.ev_last = evp___0;
      }
#line 577
      return (-1);
    } else
#line 578
    if (ret != size) {
      {
#line 579
      sysmessage(2, (char const   */* const  */)"Partial write in send_comport: %d/%d\n",
                 ret, size);
#line 582
      sysdelay(200);
      }
    }
#line 584
    size -= ret;
#line 585
    obp += ret;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 587
  return (0);
}
}
#line 590 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
void handle_com_port_command(unsigned char *buf ) 
{ 
  unsigned char cmd ;
  unsigned char *tmp ;
  int cmdarg ;
  int cmdidx ;
  int is_notify ;
  int notify ;
  struct event *evp ;
  void *memptr ;
  int XXi ;
  unsigned char *tmp___0 ;
  struct event *evp___0 ;
  void *memptr___0 ;
  int XXi___0 ;
  unsigned char *tmp___1 ;
  struct event *evp___1 ;
  void *memptr___1 ;
  int XXi___1 ;
  unsigned char *tmp___2 ;
  struct event *evp___2 ;
  void *memptr___2 ;
  int XXi___2 ;
  unsigned char *tmp___3 ;
  struct event *evp___3 ;
  int XXi___3 ;

  {
#line 593
  tmp = buf;
#line 593
  buf ++;
#line 593
  cmd = *tmp;
#line 596
  is_notify = 0;
#line 599
  cmdidx = (int )cmd;
#line 601
  if ((int )cmd >= 100) {
#line 601
    if ((int )cmd <= 112) {
#line 602
      cmdidx -= 100;
    }
  }
  {
#line 605
  print_command(cmdidx);
  }
  {
#line 610
  if ((int )cmd == 109) {
#line 610
    goto case_109;
  }
#line 610
  if ((int )cmd == 108) {
#line 610
    goto case_109;
  }
#line 610
  if ((int )cmd == 100) {
#line 610
    goto case_109;
  }
#line 612
  if ((int )cmd == 101) {
#line 612
    goto case_101;
  }
#line 616
  if ((int )cmd == 102) {
#line 616
    goto case_102;
  }
#line 620
  if ((int )cmd == 103) {
#line 620
    goto case_103;
  }
#line 625
  if ((int )cmd == 104) {
#line 625
    goto case_104;
  }
#line 630
  if ((int )cmd == 105) {
#line 630
    goto case_105;
  }
#line 645
  if ((int )cmd == 106) {
#line 645
    goto case_106;
  }
#line 660
  if ((int )cmd == 110) {
#line 660
    goto case_110;
  }
#line 665
  if ((int )cmd == 107) {
#line 665
    goto case_107;
  }
#line 683
  if ((int )cmd == 111) {
#line 683
    goto case_111;
  }
#line 687
  if ((int )cmd == 112) {
#line 687
    goto case_112;
  }
#line 691
  goto switch_default___0;
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_100: /* CIL Label */ 
#line 611
  goto switch_break;
  case_101: /* CIL Label */ 
  {
#line 613
  Comport.portconfig.speed = ((((int )*buf << 24) + ((int )*(buf + 1) << 16)) + ((int )*(buf + 2) << 8)) + (int )*(buf + 3);
#line 614
  print_speed(Comport.portconfig.speed);
  }
#line 615
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 617
  Comport.portconfig.datasize = (int )*buf;
#line 618
  print_datasize(Comport.portconfig.datasize);
  }
#line 619
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 621
  Comport.portconfig.parity = (int )*buf;
#line 622
  print_parity(Comport.portconfig.parity);
  }
#line 623
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 626
  Comport.portconfig.stopsize = (int )*buf;
#line 627
  print_stopsize(Comport.portconfig.stopsize);
  }
#line 628
  goto switch_break;
  case_105: /* CIL Label */ 
  {
#line 631
  cmdarg = (int )*buf;
#line 632
  print_setcontrol(cmdarg);
  }
  {
#line 636
  if (cmdarg == 3) {
#line 636
    goto case_3;
  }
#line 636
  if (cmdarg == 2) {
#line 636
    goto case_3;
  }
#line 636
  if (cmdarg == 1) {
#line 636
    goto case_3;
  }
#line 639
  goto switch_default;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 637
  Comport.portconfig.flowc = cmdarg;
#line 638
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 640
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 643
  goto switch_break;
  case_106: /* CIL Label */ 
  {
#line 646
  is_notify = 1;
#line 647
  cmdarg = (int )*buf;
#line 648
  print_linestate(cmdarg);
#line 649
  Comport.portstate.linestate = cmdarg;
  }
#line 650
  if (cmdarg & 16) {
#line 651
    notify = 2;
#line 652
    XXi = 0;
#line 652
    evp = & Eventpoll[0];
    {
#line 652
    while (1) {
      while_continue: /* CIL Label */ ;
#line 652
      if (! (XXi < 20)) {
#line 652
        goto while_break;
      }
#line 652
      if (evp->ev_type == 0) {
#line 652
        goto while_break;
      }
#line 652
      XXi ++;
#line 652
      evp ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 652
    if (XXi == 20) {
      {
#line 652
      sysmessage(4, (char const   */* const  */)"%s: Too many events", Idmsg);
      }
    } else {
#line 652
      evp->ev_type = 2;
#line 652
      evp->ev_code = 0;
#line 652
      if (& notify) {
        {
#line 652
        tmp___0 = mem_get(128);
#line 652
        memptr = (void *)tmp___0;
        }
#line 652
        if ((unsigned long )memptr == (unsigned long )((void *)0)) {
          {
#line 652
          sysmessage(4, (char const   */* const  */)"%s: No memory", Idmsg);
          }
        }
        {
#line 652
        memcpy((void */* __restrict  */)memptr, (void const   */* __restrict  */)(& notify),
               sizeof(int ));
#line 652
        evp->ev_param = memptr;
#line 652
        evp->ev_size = (int )sizeof(int );
        }
      } else {
#line 652
        evp->ev_param = (void *)(& notify);
#line 652
        evp->ev_size = 0;
      }
#line 652
      evp->ev_next = & Evhead;
#line 652
      evp->ev_last = Evhead.ev_last;
#line 652
      (Evhead.ev_last)->ev_next = evp;
#line 652
      Evhead.ev_last = evp;
    }
  }
#line 654
  if (cmdarg & 4) {
#line 655
    notify = 3;
#line 656
    XXi___0 = 0;
#line 656
    evp___0 = & Eventpoll[0];
    {
#line 656
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 656
      if (! (XXi___0 < 20)) {
#line 656
        goto while_break___0;
      }
#line 656
      if (evp___0->ev_type == 0) {
#line 656
        goto while_break___0;
      }
#line 656
      XXi___0 ++;
#line 656
      evp___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 656
    if (XXi___0 == 20) {
      {
#line 656
      sysmessage(4, (char const   */* const  */)"%s: Too many events", Idmsg);
      }
    } else {
#line 656
      evp___0->ev_type = 2;
#line 656
      evp___0->ev_code = 0;
#line 656
      if (& notify) {
        {
#line 656
        tmp___1 = mem_get(128);
#line 656
        memptr___0 = (void *)tmp___1;
        }
#line 656
        if ((unsigned long )memptr___0 == (unsigned long )((void *)0)) {
          {
#line 656
          sysmessage(4, (char const   */* const  */)"%s: No memory", Idmsg);
          }
        }
        {
#line 656
        memcpy((void */* __restrict  */)memptr___0, (void const   */* __restrict  */)(& notify),
               sizeof(int ));
#line 656
        evp___0->ev_param = memptr___0;
#line 656
        evp___0->ev_size = (int )sizeof(int );
        }
      } else {
#line 656
        evp___0->ev_param = (void *)(& notify);
#line 656
        evp___0->ev_size = 0;
      }
#line 656
      evp___0->ev_next = & Evhead;
#line 656
      evp___0->ev_last = Evhead.ev_last;
#line 656
      (Evhead.ev_last)->ev_next = evp___0;
#line 656
      Evhead.ev_last = evp___0;
    }
  }
#line 658
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 661
  cmdarg = (int )*buf;
#line 662
  print_linestate(cmdarg);
  }
#line 663
  goto switch_break;
  case_107: /* CIL Label */ 
#line 666
  is_notify = 1;
#line 667
  cmdarg = (int )*buf;
#line 668
  if ((cmdarg ^ Comport.portstate.modemstate) & 128) {
#line 669
    if (Comport.portstate.modemstate & 128) {
#line 670
      notify = 1;
#line 671
      XXi___1 = 0;
#line 671
      evp___1 = & Eventpoll[0];
      {
#line 671
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 671
        if (! (XXi___1 < 20)) {
#line 671
          goto while_break___1;
        }
#line 671
        if (evp___1->ev_type == 0) {
#line 671
          goto while_break___1;
        }
#line 671
        XXi___1 ++;
#line 671
        evp___1 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 671
      if (XXi___1 == 20) {
        {
#line 671
        sysmessage(4, (char const   */* const  */)"%s: Too many events", Idmsg);
        }
      } else {
#line 671
        evp___1->ev_type = 2;
#line 671
        evp___1->ev_code = 0;
#line 671
        if (& notify) {
          {
#line 671
          tmp___2 = mem_get(128);
#line 671
          memptr___1 = (void *)tmp___2;
          }
#line 671
          if ((unsigned long )memptr___1 == (unsigned long )((void *)0)) {
            {
#line 671
            sysmessage(4, (char const   */* const  */)"%s: No memory", Idmsg);
            }
          }
          {
#line 671
          memcpy((void */* __restrict  */)memptr___1, (void const   */* __restrict  */)(& notify),
                 sizeof(int ));
#line 671
          evp___1->ev_param = memptr___1;
#line 671
          evp___1->ev_size = (int )sizeof(int );
          }
        } else {
#line 671
          evp___1->ev_param = (void *)(& notify);
#line 671
          evp___1->ev_size = 0;
        }
#line 671
        evp___1->ev_next = & Evhead;
#line 671
        evp___1->ev_last = Evhead.ev_last;
#line 671
        (Evhead.ev_last)->ev_next = evp___1;
#line 671
        Evhead.ev_last = evp___1;
      }
    } else {
#line 674
      notify = 0;
#line 675
      XXi___2 = 0;
#line 675
      evp___2 = & Eventpoll[0];
      {
#line 675
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 675
        if (! (XXi___2 < 20)) {
#line 675
          goto while_break___2;
        }
#line 675
        if (evp___2->ev_type == 0) {
#line 675
          goto while_break___2;
        }
#line 675
        XXi___2 ++;
#line 675
        evp___2 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 675
      if (XXi___2 == 20) {
        {
#line 675
        sysmessage(4, (char const   */* const  */)"%s: Too many events", Idmsg);
        }
      } else {
#line 675
        evp___2->ev_type = 2;
#line 675
        evp___2->ev_code = 0;
#line 675
        if (& notify) {
          {
#line 675
          tmp___3 = mem_get(128);
#line 675
          memptr___2 = (void *)tmp___3;
          }
#line 675
          if ((unsigned long )memptr___2 == (unsigned long )((void *)0)) {
            {
#line 675
            sysmessage(4, (char const   */* const  */)"%s: No memory", Idmsg);
            }
          }
          {
#line 675
          memcpy((void */* __restrict  */)memptr___2, (void const   */* __restrict  */)(& notify),
                 sizeof(int ));
#line 675
          evp___2->ev_param = memptr___2;
#line 675
          evp___2->ev_size = (int )sizeof(int );
          }
        } else {
#line 675
          evp___2->ev_param = (void *)(& notify);
#line 675
          evp___2->ev_size = 0;
        }
#line 675
        evp___2->ev_next = & Evhead;
#line 675
        evp___2->ev_last = Evhead.ev_last;
#line 675
        (Evhead.ev_last)->ev_next = evp___2;
#line 675
        Evhead.ev_last = evp___2;
      }
    }
  }
  {
#line 679
  Comport.portstate.modemstate = cmdarg;
#line 680
  print_modemstate(cmdarg);
  }
#line 681
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 684
  cmdarg = (int )*buf;
#line 685
  print_modemstate(cmdarg);
  }
#line 686
  goto switch_break;
  case_112: /* CIL Label */ 
  {
#line 688
  cmdarg = (int )*buf;
#line 689
  print_purge(cmdarg);
  }
#line 690
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 692
  sysmessage(2, (char const   */* const  */)"Unnimplemented command: %d\n", (int )cmd);
  }
#line 693
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 696
  if (! is_notify) {
#line 697
    if (CmdState[cmdidx] == 1) {
#line 698
      CmdState[cmdidx] = 0;
    } else {
#line 700
      XXi___3 = 0;
#line 700
      evp___3 = & Eventpoll[0];
      {
#line 700
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 700
        if (! (XXi___3 < 20)) {
#line 700
          goto while_break___3;
        }
#line 700
        if (evp___3->ev_type == 0) {
#line 700
          goto while_break___3;
        }
#line 700
        XXi___3 ++;
#line 700
        evp___3 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 700
      if (XXi___3 == 20) {
        {
#line 700
        sysmessage(4, (char const   */* const  */)"%s: Too many events", Idmsg);
        }
      } else {
#line 700
        evp___3->ev_type = 2;
#line 700
        evp___3->ev_code = 3;
#line 700
        evp___3->ev_param = (void *)0;
#line 700
        evp___3->ev_size = 0;
#line 700
        evp___3->ev_next = & Evhead;
#line 700
        evp___3->ev_last = Evhead.ev_last;
#line 700
        (Evhead.ev_last)->ev_next = evp___3;
#line 700
        Evhead.ev_last = evp___3;
      }
    }
  }
  {
#line 703
  print_all();
  }
#line 704
  return;
}
}
#line 710 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
char Debugbuf[512]  ;
#line 712 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
void print_all(void) 
{ 


  {
#line 715
  if ((int )Debugbuf[0] != 0) {
    {
#line 716
    sysmessage(0, (char const   */* const  */)"%s\n", Debugbuf);
    }
  }
#line 718
  Debugbuf[0] = (char)0;
#line 719
  return;
}
}
#line 725 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
void print_control(unsigned char c ) 
{ 
  char msgbuf[32] ;

  {
#line 728
  if (Debug > 2) {
    {
#line 732
    if ((int )c == 253) {
#line 732
      goto case_253;
    }
#line 735
    if ((int )c == 254) {
#line 735
      goto case_254;
    }
#line 738
    if ((int )c == 251) {
#line 738
      goto case_251;
    }
#line 741
    if ((int )c == 252) {
#line 741
      goto case_252;
    }
#line 744
    if ((int )c == 255) {
#line 744
      goto case_255;
    }
#line 747
    if ((int )c == 240) {
#line 747
      goto case_240;
    }
#line 750
    if ((int )c == 250) {
#line 750
      goto case_250;
    }
#line 753
    goto switch_default;
    case_253: /* CIL Label */ 
    {
#line 733
    sprintf((char */* __restrict  */)(msgbuf), (char const   */* __restrict  */)"DO ");
    }
#line 734
    goto switch_break;
    case_254: /* CIL Label */ 
    {
#line 736
    sprintf((char */* __restrict  */)(msgbuf), (char const   */* __restrict  */)"DONT ");
    }
#line 737
    goto switch_break;
    case_251: /* CIL Label */ 
    {
#line 739
    sprintf((char */* __restrict  */)(msgbuf), (char const   */* __restrict  */)"WILL ");
    }
#line 740
    goto switch_break;
    case_252: /* CIL Label */ 
    {
#line 742
    sprintf((char */* __restrict  */)(msgbuf), (char const   */* __restrict  */)"WONT ");
    }
#line 743
    goto switch_break;
    case_255: /* CIL Label */ 
    {
#line 745
    sprintf((char */* __restrict  */)(msgbuf), (char const   */* __restrict  */)"IAC ");
    }
#line 746
    goto switch_break;
    case_240: /* CIL Label */ 
    {
#line 748
    sprintf((char */* __restrict  */)(msgbuf), (char const   */* __restrict  */)"SE ");
    }
#line 749
    goto switch_break;
    case_250: /* CIL Label */ 
    {
#line 751
    sprintf((char */* __restrict  */)(msgbuf), (char const   */* __restrict  */)"SB ");
    }
#line 752
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 754
    sprintf((char */* __restrict  */)(msgbuf), (char const   */* __restrict  */)"Ctl %02X ",
            (int )c);
    }
#line 755
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 757
    strcat((char */* __restrict  */)(Debugbuf), (char const   */* __restrict  */)(msgbuf));
    }
  }
#line 759
  return;
}
}
#line 762 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
void print_option(unsigned char c ) 
{ 
  char msgbuf[32] ;

  {
#line 765
  if (Debug > 2) {
    {
#line 768
    if ((int )c == 0) {
#line 768
      goto case_0;
    }
#line 771
    if ((int )c == 1) {
#line 771
      goto case_1;
    }
#line 774
    if ((int )c == 3) {
#line 774
      goto case_3;
    }
#line 777
    if ((int )c == 44) {
#line 777
      goto case_44;
    }
#line 780
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 769
    sprintf((char */* __restrict  */)(msgbuf), (char const   */* __restrict  */)"BINARY ");
    }
#line 770
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 772
    sprintf((char */* __restrict  */)(msgbuf), (char const   */* __restrict  */)"ECHO ");
    }
#line 773
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 775
    sprintf((char */* __restrict  */)(msgbuf), (char const   */* __restrict  */)"SUPPRESS GO AHEAD ");
    }
#line 776
    goto switch_break;
    case_44: /* CIL Label */ 
    {
#line 778
    sprintf((char */* __restrict  */)(msgbuf), (char const   */* __restrict  */)"COMM PORT OPTION ");
    }
#line 779
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 781
    sprintf((char */* __restrict  */)(msgbuf), (char const   */* __restrict  */)"Cmd %3d ",
            (int )c);
    }
#line 782
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 784
    strcat((char */* __restrict  */)(Debugbuf), (char const   */* __restrict  */)(msgbuf));
    }
  }
#line 786
  return;
}
}
#line 792 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
char const   * const  Command_names[13]  = 
#line 792
  {      (char const   */* const  */)"COM_SIGNATURE",      (char const   */* const  */)"COM_SET_BAUDRATE",      (char const   */* const  */)"COM_SET_DATASIZE",      (char const   */* const  */)"COM_SET_PARITY", 
        (char const   */* const  */)"COM_SET_STOPSIZE",      (char const   */* const  */)"COM_SET_CONTROL",      (char const   */* const  */)"COM_NOTIFY_LINESTATE",      (char const   */* const  */)"COM_NOTIFY_MODEMSTATE", 
        (char const   */* const  */)"COM_FLOWCONTROL_SUSPEND",      (char const   */* const  */)"COM_FLOWCONTROL_RESUME",      (char const   */* const  */)"COM_SET_LINESTATE_MASK",      (char const   */* const  */)"COM_SET_MODEMSTATE_MASK", 
        (char const   */* const  */)"COM_PURGE_DATA"};
#line 808 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
char const   * const  Parity_names[6]  = {      (char const   */* const  */)"PARITY_REQ",      (char const   */* const  */)"PARITY_NONE",      (char const   */* const  */)"PARITY_ODD",      (char const   */* const  */)"PARITY_EVEN", 
        (char const   */* const  */)"PARITY_MARK",      (char const   */* const  */)"PARITY_SPACE"};
#line 817 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
char const   * const  Stop_names[4]  = {      (char const   */* const  */)"SSIZE_REQ",      (char const   */* const  */)"SSIZE_ONE",      (char const   */* const  */)"SSIZE_TWO",      (char const   */* const  */)"SSIZE_1DOT5"};
#line 824 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
char const   * const  Control_names[20]  = 
#line 824
  {      (char const   */* const  */)"OFLOW_REQ",      (char const   */* const  */)"OFLOW_NONE",      (char const   */* const  */)"OFLOW_SOFT",      (char const   */* const  */)"OFLOW_HARD", 
        (char const   */* const  */)"BREAK_REQ",      (char const   */* const  */)"BREAK_ON",      (char const   */* const  */)"BREAK_OFF",      (char const   */* const  */)"DTR_REQ", 
        (char const   */* const  */)"DTR_ON",      (char const   */* const  */)"DTR_OFF",      (char const   */* const  */)"RTS_REQ",      (char const   */* const  */)"RTS_ON", 
        (char const   */* const  */)"RTS_OFF",      (char const   */* const  */)"IFLOW_REQ",      (char const   */* const  */)"IFLOW_NONE",      (char const   */* const  */)"IFLOW_SOFT", 
        (char const   */* const  */)"IFLOW_HARD",      (char const   */* const  */)"DCD_FLOW",      (char const   */* const  */)"DTR_FLOW",      (char const   */* const  */)"DSR_FLOW"};
#line 847 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
char const   * const  Purge_names[4]  = {      (char const   */* const  */)"What??",      (char const   */* const  */)"COM_PURGE_RECV",      (char const   */* const  */)"COM_PURGE_XMIT",      (char const   */* const  */)"COM_PURGE_BOTH"};
#line 855 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
void print_linestate(int state ) 
{ 
  char linestates[256] ;

  {
#line 858
  if (Debug > 2) {
#line 860
    linestates[0] = (char)0;
#line 862
    if (state & 128) {
      {
#line 863
      strcat((char */* __restrict  */)(linestates), (char const   */* __restrict  */)"LINE_TIMEOUT_ERROR ");
      }
    }
#line 865
    if (state & 64) {
      {
#line 866
      strcat((char */* __restrict  */)(linestates), (char const   */* __restrict  */)"LINE_SHIFTREG_EMPTY ");
      }
    }
#line 868
    if (state & 32) {
      {
#line 869
      strcat((char */* __restrict  */)(linestates), (char const   */* __restrict  */)"LINE_HOLDREG_EMPTY ");
      }
    }
#line 871
    if (state & 16) {
      {
#line 872
      strcat((char */* __restrict  */)(linestates), (char const   */* __restrict  */)"LINE_BREAK_ERROR ");
      }
    }
#line 874
    if (state & 8) {
      {
#line 875
      strcat((char */* __restrict  */)(linestates), (char const   */* __restrict  */)"LINE_FRAME_ERROR ");
      }
    }
#line 877
    if (state & 4) {
      {
#line 878
      strcat((char */* __restrict  */)(linestates), (char const   */* __restrict  */)"LINE_PARITY_ERROR ");
      }
    }
#line 880
    if (state & 2) {
      {
#line 881
      strcat((char */* __restrict  */)(linestates), (char const   */* __restrict  */)"LINE_OVERRUN_ERROR ");
      }
    }
#line 883
    if (state & 1) {
      {
#line 884
      strcat((char */* __restrict  */)(linestates), (char const   */* __restrict  */)"LINE_DATA_READY ");
      }
    }
    {
#line 886
    strcat((char */* __restrict  */)(Debugbuf), (char const   */* __restrict  */)(linestates));
    }
  }
#line 888
  return;
}
}
#line 890 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
void print_modemstate(int state ) 
{ 
  char modemstates[256] ;

  {
#line 893
  if (Debug > 2) {
#line 896
    modemstates[0] = (char)0;
#line 898
    if (state & 128) {
      {
#line 899
      strcat((char */* __restrict  */)(modemstates), (char const   */* __restrict  */)"MODEM_DCD ");
      }
    }
#line 901
    if (state & 64) {
      {
#line 902
      strcat((char */* __restrict  */)(modemstates), (char const   */* __restrict  */)"MODEM_RI ");
      }
    }
#line 904
    if (state & 32) {
      {
#line 905
      strcat((char */* __restrict  */)(modemstates), (char const   */* __restrict  */)"MODEM_DSR ");
      }
    }
#line 907
    if (state & 16) {
      {
#line 908
      strcat((char */* __restrict  */)(modemstates), (char const   */* __restrict  */)"MODEM_CTS ");
      }
    }
#line 910
    if (state & 8) {
      {
#line 911
      strcat((char */* __restrict  */)(modemstates), (char const   */* __restrict  */)"MODEM_DELTA_DCD ");
      }
    }
#line 913
    if (state & 4) {
      {
#line 914
      strcat((char */* __restrict  */)(modemstates), (char const   */* __restrict  */)"MODEM_TRAIL_RI ");
      }
    }
#line 916
    if (state & 2) {
      {
#line 917
      strcat((char */* __restrict  */)(modemstates), (char const   */* __restrict  */)"MODEM_DELTA_DSR ");
      }
    }
#line 919
    if (state & 1) {
      {
#line 920
      strcat((char */* __restrict  */)(modemstates), (char const   */* __restrict  */)"MODEM_DELTA_CTS ");
      }
    }
    {
#line 923
    strcat((char */* __restrict  */)(Debugbuf), (char const   */* __restrict  */)(modemstates));
    }
  }
#line 925
  return;
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
void print_speed(int speed ) 
{ 
  char buf[32] ;

  {
#line 930
  if (Debug > 2) {
    {
#line 932
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"Speed: %d bps ",
            speed);
#line 933
    strcat((char */* __restrict  */)(Debugbuf), (char const   */* __restrict  */)(buf));
    }
  }
#line 935
  return;
}
}
#line 937 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
void print_datasize(int datasize ) 
{ 
  char buf[32] ;

  {
#line 940
  if (Debug > 2) {
    {
#line 942
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"Datasize: %d bits ",
            datasize);
#line 943
    strcat((char */* __restrict  */)(Debugbuf), (char const   */* __restrict  */)(buf));
    }
  }
#line 945
  return;
}
}
#line 947 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
void print_stopsize(int stopsize ) 
{ 
  char buf[32] ;

  {
#line 950
  if (Debug > 2) {
    {
#line 952
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s ",
            Stop_names[stopsize]);
#line 953
    strcat((char */* __restrict  */)(Debugbuf), (char const   */* __restrict  */)(buf));
    }
  }
#line 955
  return;
}
}
#line 957 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
void print_parity(int parity ) 
{ 
  char buf[32] ;

  {
#line 960
  if (Debug > 2) {
    {
#line 962
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s ",
            Parity_names[parity]);
#line 963
    strcat((char */* __restrict  */)(Debugbuf), (char const   */* __restrict  */)(buf));
    }
  }
#line 965
  return;
}
}
#line 967 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
void print_setcontrol(int control ) 
{ 
  char buf[32] ;

  {
#line 970
  if (Debug > 2) {
    {
#line 972
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s ",
            Control_names[control]);
#line 973
    strcat((char */* __restrict  */)(Debugbuf), (char const   */* __restrict  */)(buf));
    }
  }
#line 975
  return;
}
}
#line 977 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
void print_purge(int purge ) 
{ 
  char buf[32] ;

  {
#line 980
  if (Debug > 2) {
    {
#line 982
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s ",
            Purge_names[purge]);
#line 983
    strcat((char */* __restrict  */)(Debugbuf), (char const   */* __restrict  */)(buf));
    }
  }
#line 985
  return;
}
}
#line 987 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/telnet.c"
void print_command(int cmdidx ) 
{ 
  char buf[32] ;

  {
#line 990
  if (Debug > 2) {
    {
#line 992
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s: ",
            Command_names[cmdidx]);
#line 993
    strcat((char */* __restrict  */)(Debugbuf), (char const   */* __restrict  */)(buf));
    }
  }
#line 995
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 48 "/usr/include/x86_64-linux-gnu/sys/times.h"
extern  __attribute__((__nothrow__)) clock_t ( __attribute__((__leaf__)) times)(struct tms *__buffer ) ;
#line 432 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 660
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpgrp)(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 332
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 379
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 110 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/cyclades-ser-cli.h"
char *Pgname ;
#line 112
int Console ;
#line 21 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/system.h"
void mindelay(void) ;
#line 24
void doexit(int val ) ;
#line 25
void init_system(void) ;
#line 27
void mem_free(void *ptr ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/system.h"
char Idmsg[128]  ;
#line 390 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrio.h"
int Hang_up ;
#line 33 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/dev.h"
void dev_unlink(void) ;
#line 46
int P_mfd ;
#line 48
int P_sfd ;
#line 57
char P_devname[64] ;
#line 59
char P_contrname[108] ;
#line 43 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/system.c"
static int Start_time  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/system.c"
static int End_time  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/system.c"
static struct tms Timest  ;
#line 51
static void sysc_tout(int sig ) ;
#line 52
static void rot(int sig ) ;
#line 53
static void user_hangup(int sig ) ;
#line 54
static void sys_times(char *buf ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/system.c"
void init_system(void) 
{ 
  int sig ;
  clock_t tmp ;

  {
  {
#line 61
  setpgrp();
#line 62
  umask((__mode_t )0);
#line 64
  tmp = times(& Timest);
#line 64
  Start_time = (int )tmp;
#line 66
  openlog((char const   *)Pgname, 3, 18 << 3);
#line 71
  setbuf((FILE */* __restrict  */)stdout, (char */* __restrict  */)((void *)0));
#line 72
  setbuf((FILE */* __restrict  */)stderr, (char */* __restrict  */)((void *)0));
#line 74
  sig = 1;
  }
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! (sig < 65)) {
#line 74
      goto while_break;
    }
    {
#line 78
    if (sig == 1) {
#line 78
      goto case_1;
    }
#line 78
    if (sig == 18) {
#line 78
      goto case_1;
    }
#line 78
    if (sig == 13) {
#line 78
      goto case_1;
    }
#line 82
    if (sig == 11) {
#line 82
      goto case_11;
    }
#line 82
    if (sig == 7) {
#line 82
      goto case_11;
    }
#line 84
    if (sig == 14) {
#line 84
      goto case_14;
    }
#line 87
    if (sig == 10) {
#line 87
      goto case_10;
    }
#line 90
    goto switch_default;
    case_1: /* CIL Label */ 
    case_18: /* CIL Label */ 
    case_13: /* CIL Label */ 
    {
#line 79
    signal(sig, (void (*)(int  ))1);
    }
#line 80
    goto switch_break;
    case_11: /* CIL Label */ 
    case_7: /* CIL Label */ 
#line 83
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 85
    signal(sig, & sysc_tout);
    }
#line 86
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 88
    signal(sig, & user_hangup);
    }
#line 89
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 91
    signal(sig, & rot);
    }
#line 92
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 74
    sig ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/system.c"
void sysdelay(int msecs ) 
{ 
  struct timeval tv ;

  {
  {
#line 103
  tv.tv_sec = (__time_t )(msecs / 1000);
#line 104
  tv.tv_usec = (__suseconds_t )((msecs % 1000) * 1000);
#line 105
  select(0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0,
         (struct timeval */* __restrict  */)(& tv));
  }
#line 106
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/system.c"
void sysmessage(int type , char const   * const  format  , ...) 
{ 
  char buf[512] ;
  va_list args ;
  char const   *pritext ;
  int priority ;

  {
  {
#line 116
  __builtin_va_start(args, format);
#line 118
  vsprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)format,
           args);
  }
#line 120
  if (Console) {
    {
#line 122
    if (type == 0) {
#line 122
      goto case_0;
    }
#line 125
    if (type == 1) {
#line 125
      goto case_1;
    }
#line 128
    if (type == 2) {
#line 128
      goto case_2;
    }
#line 131
    if (type == 3) {
#line 131
      goto case_3;
    }
#line 135
    goto switch_default;
    case_0: /* CIL Label */ 
#line 123
    pritext = "DEBUG";
#line 124
    goto switch_break;
    case_1: /* CIL Label */ 
#line 126
    pritext = "INFO";
#line 127
    goto switch_break;
    case_2: /* CIL Label */ 
#line 129
    pritext = "NOTICE";
#line 130
    goto switch_break;
    case_3: /* CIL Label */ 
#line 132
    pritext = "WARNING";
#line 133
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 136
    pritext = "ERR";
#line 137
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 139
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s",
            Idmsg, pritext, buf);
    }
  } else {
    {
#line 142
    if (type == 0) {
#line 142
      goto case_0___0;
    }
#line 145
    if (type == 1) {
#line 145
      goto case_1___0;
    }
#line 148
    if (type == 2) {
#line 148
      goto case_2___0;
    }
#line 151
    if (type == 3) {
#line 151
      goto case_3___0;
    }
#line 155
    goto switch_default___0;
    case_0___0: /* CIL Label */ 
#line 143
    priority = 7;
#line 144
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 146
    priority = 6;
#line 147
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 149
    priority = 5;
#line 150
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
#line 152
    priority = 4;
#line 153
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 156
    priority = 3;
#line 157
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 159
    if (priority != 7) {
      {
#line 160
      syslog(priority, "%s: %s", Idmsg, buf);
      }
    } else
#line 159
    if (Debug > 0) {
      {
#line 160
      syslog(priority, "%s: %s", Idmsg, buf);
      }
    }
  }
  {
#line 162
  __builtin_va_end(args);
  }
#line 163
  return;
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/system.c"
void mindelay(void) 
{ 
  struct timeval tv ;
  int usecs ;

  {
  {
#line 173
  usecs = 10000;
#line 175
  tv.tv_sec = (__time_t )0;
#line 176
  tv.tv_usec = (__suseconds_t )usecs;
#line 177
  select(0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0,
         (struct timeval */* __restrict  */)(& tv));
  }
#line 178
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/system.c"
void doexit(int val ) 
{ 
  char timbuf[64] ;
  clock_t tmp ;

  {
  {
#line 189
  dev_unlink();
#line 190
  sock_unlink();
#line 192
  tmp = times(& Timest);
#line 192
  End_time = (int )tmp;
#line 194
  sys_times(timbuf);
  }
#line 196
  if (val) {
    {
#line 197
    sysmessage(4, (char const   */* const  */)"Exiting with %d code (%s)\n", val,
               timbuf);
    }
  } else {
    {
#line 200
    sysmessage(2, (char const   */* const  */)"Exiting with %d code (%s)\n", val,
               timbuf);
    }
  }
  {
#line 203
  exit(val);
  }
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/system.c"
void dev_unlink(void) 
{ 


  {
  {
#line 209
  close(P_sfd);
#line 210
  P_sfd = -1;
#line 211
  close(P_mfd);
#line 212
  P_mfd = -1;
#line 213
  unlink((char const   *)(P_devname));
  }
#line 214
  if (P_contrname[0]) {
    {
#line 215
    unlink((char const   *)(P_contrname));
    }
  }
#line 216
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/system.c"
static void rot(int sig ) 
{ 
  char timbuf[64] ;
  clock_t tmp ;

  {
  {
#line 228
  dev_unlink();
#line 229
  sock_unlink();
#line 231
  tmp = times(& Timest);
#line 231
  End_time = (int )tmp;
#line 233
  sys_times(timbuf);
  }
#line 235
  if (sig == 15) {
    {
#line 236
    sysmessage(1, (char const   */* const  */)"Normal shutdown (SIGTERM) (%s)\n",
               timbuf);
#line 238
    exit(0);
    }
  } else {
    {
#line 240
    sysmessage(4, (char const   */* const  */)"signal %d received (%s)\n\n", sig,
               timbuf);
#line 242
    exit(3);
    }
  }
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/system.c"
unsigned char *mem_get(int size ) 
{ 
  void *tmp ;

  {
  {
#line 249
  tmp = malloc((size_t )size);
  }
#line 249
  return ((unsigned char *)tmp);
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/system.c"
void mem_free(void *ptr ) 
{ 


  {
  {
#line 255
  free(ptr);
  }
#line 256
  return;
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/system.c"
static void sysc_tout(int sig ) 
{ 


  {
  {
#line 261
  alarm(0U);
#line 262
  signal(sig, & sysc_tout);
  }
#line 263
  return;
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/system.c"
static void user_hangup(int sig ) 
{ 


  {
  {
#line 268
  Hang_up = 1;
#line 269
  signal(sig, & user_hangup);
  }
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/system.c"
static void sys_times(char *buf ) 
{ 
  int usr ;
  int sys ;
  int tot ;
  int pru ;
  int prs ;
  int prt ;
  int secs ;

  {
#line 278
  tot = End_time - Start_time;
#line 279
  usr = (int )Timest.tms_utime;
#line 280
  sys = (int )Timest.tms_stime;
#line 282
  if (tot == 0) {
#line 282
    tot = 1;
  }
  {
#line 283
  pru = (usr * 100) / tot;
#line 284
  prs = (sys * 100) / tot;
#line 285
  prt = pru + prs;
#line 287
  secs = tot / 100;
#line 289
  sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%6d, %3d%%, %3d%%, %3d%%",
          secs, pru, prs, prt);
  }
#line 290
  return;
}
}
#line 263 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 803
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) symlink)(char const   *__from ,
                                                                                                char const   *__to ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/dev.h"
int dev_getaddr(char *dname ) ;
#line 32
void dev_free(void) ;
#line 34
int dev_init(int iosize , int devmodem , int closemode , struct buffer *ibp , struct buffer *obp ,
             struct comport *cp ) ;
#line 36
int dev_config(void) ;
#line 37
int dev_closeslave(void) ;
#line 38
int dev_probe(void) ;
#line 39
int dev_getdata(void) ;
#line 40
int dev_putdata(struct buffer *bp ) ;
#line 41
void dev_interrupt(void) ;
#line 42
void dev_hangup(void) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/dev.h"
struct pty Pty  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/dev.h"
int P_mfd  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/dev.h"
int P_sfd  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/dev.h"
int P_contr_listen  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/dev.h"
int P_contr[32]  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/dev.h"
char P_devname[64]  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/dev.h"
char P_contrname[108]  ;
#line 7 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/port_speed.h"
int baud_index_to_int(speed_t baud_index ) 
{ 


  {
  {
#line 11
  if (baud_index == 0U) {
#line 11
    goto case_0;
  }
#line 13
  if (baud_index == 1U) {
#line 13
    goto case_1;
  }
#line 15
  if (baud_index == 2U) {
#line 15
    goto case_2;
  }
#line 17
  if (baud_index == 3U) {
#line 17
    goto case_3;
  }
#line 19
  if (baud_index == 4U) {
#line 19
    goto case_4;
  }
#line 21
  if (baud_index == 5U) {
#line 21
    goto case_5;
  }
#line 23
  if (baud_index == 6U) {
#line 23
    goto case_6;
  }
#line 25
  if (baud_index == 7U) {
#line 25
    goto case_7;
  }
#line 27
  if (baud_index == 8U) {
#line 27
    goto case_8;
  }
#line 29
  if (baud_index == 9U) {
#line 29
    goto case_9;
  }
#line 31
  if (baud_index == 10U) {
#line 31
    goto case_10;
  }
#line 33
  if (baud_index == 11U) {
#line 33
    goto case_11;
  }
#line 35
  if (baud_index == 12U) {
#line 35
    goto case_12;
  }
#line 37
  if (baud_index == 13U) {
#line 37
    goto case_13;
  }
#line 39
  if (baud_index == 14U) {
#line 39
    goto case_14;
  }
#line 41
  if (baud_index == 15U) {
#line 41
    goto case_15;
  }
#line 44
  if (baud_index == 4097U) {
#line 44
    goto case_4097;
  }
#line 48
  if (baud_index == 4098U) {
#line 48
    goto case_4098;
  }
#line 52
  if (baud_index == 4099U) {
#line 52
    goto case_4099;
  }
#line 56
  if (baud_index == 4100U) {
#line 56
    goto case_4100;
  }
#line 9
  goto switch_break;
  case_0: /* CIL Label */ 
#line 12
  return (0);
  case_1: /* CIL Label */ 
#line 14
  return (50);
  case_2: /* CIL Label */ 
#line 16
  return (75);
  case_3: /* CIL Label */ 
#line 18
  return (110);
  case_4: /* CIL Label */ 
#line 20
  return (134);
  case_5: /* CIL Label */ 
#line 22
  return (150);
  case_6: /* CIL Label */ 
#line 24
  return (200);
  case_7: /* CIL Label */ 
#line 26
  return (300);
  case_8: /* CIL Label */ 
#line 28
  return (600);
  case_9: /* CIL Label */ 
#line 30
  return (1200);
  case_10: /* CIL Label */ 
#line 32
  return (1800);
  case_11: /* CIL Label */ 
#line 34
  return (2400);
  case_12: /* CIL Label */ 
#line 36
  return (4800);
  case_13: /* CIL Label */ 
#line 38
  return (9600);
  case_14: /* CIL Label */ 
#line 40
  return (19200);
  case_15: /* CIL Label */ 
#line 42
  return (38400);
  case_4097: /* CIL Label */ 
#line 45
  return (57600);
  case_4098: /* CIL Label */ 
#line 49
  return (115200);
  case_4099: /* CIL Label */ 
#line 53
  return (230400);
  case_4100: /* CIL Label */ 
#line 57
  return (460800);
  switch_break: /* CIL Label */ ;
  }
#line 60
  return (-1);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/port_speed.h"
speed_t int_to_baud_index(int speed ) 
{ 


  {
  {
#line 67
  if (speed == 0) {
#line 67
    goto case_0;
  }
#line 69
  if (speed == 50) {
#line 69
    goto case_50;
  }
#line 71
  if (speed == 75) {
#line 71
    goto case_75;
  }
#line 73
  if (speed == 110) {
#line 73
    goto case_110;
  }
#line 75
  if (speed == 134) {
#line 75
    goto case_134;
  }
#line 77
  if (speed == 150) {
#line 77
    goto case_150;
  }
#line 79
  if (speed == 200) {
#line 79
    goto case_200;
  }
#line 81
  if (speed == 300) {
#line 81
    goto case_300;
  }
#line 83
  if (speed == 600) {
#line 83
    goto case_600;
  }
#line 85
  if (speed == 1200) {
#line 85
    goto case_1200;
  }
#line 87
  if (speed == 1800) {
#line 87
    goto case_1800;
  }
#line 89
  if (speed == 2400) {
#line 89
    goto case_2400;
  }
#line 91
  if (speed == 4800) {
#line 91
    goto case_4800;
  }
#line 93
  if (speed == 9600) {
#line 93
    goto case_9600;
  }
#line 95
  if (speed == 19200) {
#line 95
    goto case_19200;
  }
#line 97
  if (speed == 38400) {
#line 97
    goto case_38400;
  }
#line 100
  if (speed == 57600) {
#line 100
    goto case_57600;
  }
#line 104
  if (speed == 115200) {
#line 104
    goto case_115200;
  }
#line 108
  if (speed == 230400) {
#line 108
    goto case_230400;
  }
#line 112
  if (speed == 460800) {
#line 112
    goto case_460800;
  }
#line 65
  goto switch_break;
  case_0: /* CIL Label */ 
#line 68
  return ((speed_t )0);
  case_50: /* CIL Label */ 
#line 70
  return ((speed_t )1);
  case_75: /* CIL Label */ 
#line 72
  return ((speed_t )2);
  case_110: /* CIL Label */ 
#line 74
  return ((speed_t )3);
  case_134: /* CIL Label */ 
#line 76
  return ((speed_t )4);
  case_150: /* CIL Label */ 
#line 78
  return ((speed_t )5);
  case_200: /* CIL Label */ 
#line 80
  return ((speed_t )6);
  case_300: /* CIL Label */ 
#line 82
  return ((speed_t )7);
  case_600: /* CIL Label */ 
#line 84
  return ((speed_t )8);
  case_1200: /* CIL Label */ 
#line 86
  return ((speed_t )9);
  case_1800: /* CIL Label */ 
#line 88
  return ((speed_t )10);
  case_2400: /* CIL Label */ 
#line 90
  return ((speed_t )11);
  case_4800: /* CIL Label */ 
#line 92
  return ((speed_t )12);
  case_9600: /* CIL Label */ 
#line 94
  return ((speed_t )13);
  case_19200: /* CIL Label */ 
#line 96
  return ((speed_t )14);
  case_38400: /* CIL Label */ 
#line 98
  return ((speed_t )15);
  case_57600: /* CIL Label */ 
#line 101
  return ((speed_t )4097);
  case_115200: /* CIL Label */ 
#line 105
  return ((speed_t )4098);
  case_230400: /* CIL Label */ 
#line 109
  return ((speed_t )4099);
  case_460800: /* CIL Label */ 
#line 113
  return ((speed_t )4100);
  switch_break: /* CIL Label */ ;
  }
#line 116
  return ((speed_t )0);
}
}
#line 33 "/usr/include/pty.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) openpty)(int *__amaster ,
                                                                              int *__aslave ,
                                                                              char *__name ,
                                                                              struct termios  const  *__termp ,
                                                                              struct winsize  const  *__winp ) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/linux-dev.c"
void parse_message(unsigned char type , char *buf , int size ) ;
#line 69
void parse_packet(int type ) ;
#line 75
void portconfig_to_termios(struct portconfig *pcp , struct termios *tp ) ;
#line 81
int get_slave_controlling(dev_t device ) ;
#line 96 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/linux-dev.c"
char P_sname[64]  ;
#line 97 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/linux-dev.c"
dev_t P_devnumber  ;
#line 99 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/linux-dev.c"
char Databuf[32768]  ;
#line 113 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/linux-dev.c"
int dev_getaddr(char *dname ) 
{ 
  int fd ;
  int slave_fd ;
  int mode ;
  char stty[16] ;
  struct stat statb ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
  {
#line 117
  fd = -1;
#line 131
  tmp___2 = lstat((char const   */* __restrict  */)dname, (struct stat */* __restrict  */)(& statb));
  }
#line 131
  if (tmp___2 >= 0) {
#line 133
    if ((statb.st_mode & 61440U) == 40960U) {
      {
#line 135
      sysmessage(3, (char const   */* const  */)"Removing old sym-link \"%s\".\n",
                 dname);
#line 136
      unlink((char const   *)dname);
      }
    } else
#line 139
    if (! ((statb.st_mode & 61440U) == 8192U)) {
      {
#line 141
      sysmessage(4, (char const   */* const  */)"%s already exists\n", dname);
      }
#line 143
      return (2);
    }
  } else {
    {
#line 146
    tmp___1 = __errno_location();
    }
#line 146
    if (*tmp___1 != 2) {
      {
#line 148
      tmp = __errno_location();
#line 148
      tmp___0 = strerror(*tmp);
#line 148
      sysmessage(4, (char const   */* const  */)"Can\'t lstat %s : %s\n", dname, tmp___0);
      }
#line 150
      return (1);
    }
  }
  {
#line 192
  tmp___3 = openpty(& fd, & slave_fd, stty, (struct termios  const  *)((void *)0),
                    (struct winsize  const  *)((void *)0));
  }
#line 192
  if (tmp___3) {
    {
#line 194
    sysmessage(4, (char const   */* const  */)"Can\'t get a free pseudo-tty :\n");
    }
#line 196
    return (1);
  }
  {
#line 210
  mode = 1;
#line 211
  tmp___6 = ioctl(fd, 21536UL, & mode);
  }
#line 211
  if (tmp___6 == -1) {
    {
#line 212
    tmp___4 = __errno_location();
#line 212
    tmp___5 = strerror(*tmp___4);
#line 212
    sysmessage(4, (char const   */* const  */)"Can\'t put master pty in packet mode: %s\n",
               tmp___5);
#line 215
    close(fd);
    }
#line 216
    return (1);
  }
  {
#line 222
  tmp___9 = lstat((char const   */* __restrict  */)(stty), (struct stat */* __restrict  */)(& statb));
  }
#line 222
  if (tmp___9 == -1) {
    {
#line 223
    tmp___7 = __errno_location();
#line 223
    tmp___8 = strerror(*tmp___7);
#line 223
    sysmessage(4, (char const   */* const  */)"Can\'t stat slave pty: %s\n", tmp___8);
#line 226
    close(fd);
    }
#line 227
    return (1);
  }
  {
#line 230
  P_devnumber = statb.st_rdev;
#line 232
  tmp___12 = symlink((char const   *)(stty), (char const   *)dname);
  }
#line 232
  if (tmp___12 == -1) {
    {
#line 233
    tmp___10 = __errno_location();
#line 233
    tmp___11 = strerror(*tmp___10);
#line 233
    sysmessage(4, (char const   */* const  */)"Can\'t link dev : %s\n", tmp___11);
    }
#line 235
    return (1);
  } else {
    {
#line 237
    sysmessage(2, (char const   */* const  */)"Using %s pseudo-tty\n", stty);
    }
  }
  {
#line 242
  P_mfd = fd;
#line 243
  strcpy((char */* __restrict  */)(P_sname), (char const   */* __restrict  */)(stty));
#line 244
  strcpy((char */* __restrict  */)(P_devname), (char const   */* __restrict  */)dname);
  }
#line 246
  return (0);
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/linux-dev.c"
void dev_free(void) 
{ 


  {
  {
#line 253
  close(P_sfd);
#line 254
  P_sfd = -1;
  }
#line 255
  return;
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/linux-dev.c"
int dev_init(int iosize , int devmodem , int closemode , struct buffer *ibp , struct buffer *obp ,
             struct comport *cp ) 
{ 


  {
#line 263
  Pty.portmodes = 0;
#line 264
  if (devmodem == 1) {
#line 265
    Pty.portmodes = 2;
  }
#line 268
  if (closemode == 0) {
#line 269
    Pty.portmodes |= 1;
  }
#line 272
  Pty.portmodes |= 20;
#line 274
  Pty.iosize = iosize;
#line 275
  Pty.inbuff = ibp;
#line 276
  Pty.outbuff = obp;
#line 277
  Pty.comport = cp;
#line 279
  return (0);
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/linux-dev.c"
int dev_config(void) 
{ 
  int sfd ;
  struct termios tios ;
  struct portconfig *pcp ;
  int modes ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 288
  pcp = & (Pty.comport)->portconfig;
#line 289
  modes = Pty.portmodes;
#line 291
  sysmessage(2, (char const   */* const  */)"Opening %s pseudo-tty\n", P_sname);
#line 292
  sfd = open((char const   *)(P_sname), 258);
  }
#line 292
  if (sfd == -1) {
    {
#line 293
    tmp = __errno_location();
#line 293
    tmp___0 = strerror(*tmp);
#line 293
    sysmessage(4, (char const   */* const  */)"Can\'t open slave device : %s\n", tmp___0);
    }
#line 295
    return (1);
  }
  {
#line 298
  memset((void *)(& tios), 0, sizeof(struct termios ));
#line 300
  portconfig_to_termios(pcp, & tios);
#line 302
  tios.c_cflag |= 128U;
#line 303
  tios.c_lflag |= 128U;
  }
#line 306
  if (modes & 1) {
#line 307
    tios.c_cflag |= 1024U;
  }
#line 309
  if (modes & 2) {
#line 310
    tios.c_cflag |= 2048U;
  }
#line 312
  if (modes & 4) {
#line 313
    tios.c_iflag |= 1U;
  }
#line 315
  if (modes & 16) {
#line 316
    tios.c_iflag |= 4U;
  }
  {
#line 318
  tios.c_iflag = 0U;
#line 320
  tios.c_cc[6] = (cc_t )1;
#line 322
  tmp___3 = tcsetattr(sfd, 0, (struct termios  const  *)(& tios));
  }
#line 322
  if (tmp___3 == -1) {
    {
#line 323
    tmp___1 = __errno_location();
#line 323
    tmp___2 = strerror(*tmp___1);
#line 323
    sysmessage(4, (char const   */* const  */)"Can\'t set termios : %s\n", tmp___2);
#line 325
    close(sfd);
    }
#line 326
    return (1);
  }
#line 329
  P_sfd = sfd;
#line 331
  return (0);
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/linux-dev.c"
int dev_closeslave(void) 
{ 
  int mode ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 339
  if (Pty.state == 5) {
#line 339
    if (P_sfd != -1) {
#line 340
      if (Debug > 1) {
        {
#line 341
        sysmessage(0, (char const   */* const  */)"Closing %s pseudo-tty \n", P_sname);
        }
      }
      {
#line 344
      sysmessage(2, (char const   */* const  */)"Closing %s pseudo-tty \n", P_sname);
#line 346
      close(P_sfd);
#line 347
      P_sfd = -1;
#line 348
      mode = 1;
#line 349
      tmp___1 = ioctl(P_mfd, 21536UL, & mode);
      }
#line 349
      if (tmp___1 == -1) {
        {
#line 350
        tmp = __errno_location();
#line 350
        tmp___0 = strerror(*tmp);
#line 350
        sysmessage(4, (char const   */* const  */)"Can\'t put master pty in packet mode: %s\n",
                   tmp___0);
        }
#line 353
        return (1);
      }
    }
  }
#line 357
  return (0);
}
}
#line 361 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/linux-dev.c"
unsigned char Holdbuf[4]  ;
#line 362 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/linux-dev.c"
int Hold  =    0;
#line 364 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/linux-dev.c"
int dev_probe(void) 
{ 
  int retc ;
  int retmsg ;
  unsigned char type ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 371
  tmp___2 = read(P_mfd, (void *)(Holdbuf), (size_t )1);
#line 371
  retc = (int )tmp___2;
  }
#line 371
  if (retc == -1) {
    {
#line 372
    tmp___1 = __errno_location();
    }
#line 372
    if (*tmp___1 == 5) {
#line 373
      retc = 0;
    } else {
      {
#line 375
      tmp = __errno_location();
#line 375
      tmp___0 = strerror(*tmp);
#line 375
      sysmessage(4, (char const   */* const  */)"Can\'t read from master pty: %s\n",
                 tmp___0);
      }
#line 378
      return (retc);
    }
  }
#line 382
  if (Debug > 2) {
    {
#line 383
    sysmessage(0, (char const   */* const  */)"PROBE: %d bytes: %d", retc, (int )Holdbuf[0]);
    }
  }
#line 385
  if (retc != 0) {
#line 386
    type = Holdbuf[0];
#line 387
    if ((int )type == 0) {
#line 388
      retmsg = 1;
    } else
#line 389
    if ((int )type & 3) {
#line 390
      retmsg = 3;
    } else {
#line 392
      retmsg = 5;
    }
#line 394
    Hold = 1;
  } else {
#line 396
    retmsg = 2;
  }
#line 398
  if (Debug > 1) {
    {
#line 399
    sysmessage(0, (char const   */* const  */)"PROBE: msg %d\n", retmsg);
    }
  }
#line 401
  return (retmsg);
}
}
#line 404 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/linux-dev.c"
int dev_getdata(void) 
{ 
  int retc ;
  int size ;
  int mode ;
  unsigned char type ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;
  int i ;
  char debbuf[128] ;
  char oct[8] ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 412
  size = Pty.iosize;
#line 414
  if (Hold == 1) {
#line 415
    Hold = 0;
#line 416
    retc = 1;
#line 417
    Databuf[0] = (char )Holdbuf[0];
  } else {
    {
#line 419
    tmp___2 = read(P_mfd, (void *)(Databuf), (size_t )size);
#line 419
    retc = (int )tmp___2;
    }
#line 419
    if (retc == -1) {
      {
#line 420
      tmp___1 = __errno_location();
      }
#line 420
      if (*tmp___1 == 5) {
#line 421
        retc = 0;
      } else {
        {
#line 423
        tmp = __errno_location();
#line 423
        tmp___0 = strerror(*tmp);
#line 423
        sysmessage(4, (char const   */* const  */)"Can\'t read from master pty: %s\n",
                   tmp___0);
        }
#line 429
        return (retc);
      }
    }
  }
#line 434
  if (Debug > 2) {
    {
#line 435
    sysmessage(0, (char const   */* const  */)" DATA: %d bytes: ", retc);
    }
  }
#line 437
  if (Debug > 2) {
    {
#line 442
    sprintf((char */* __restrict  */)(debbuf), (char const   */* __restrict  */)"DAT: ");
#line 443
    i = 0;
    }
    {
#line 443
    while (1) {
      while_continue: /* CIL Label */ ;
#line 443
      if (i < retc) {
#line 443
        if (! (i < 8)) {
#line 443
          goto while_break;
        }
      } else {
#line 443
        goto while_break;
      }
      {
#line 444
      sprintf((char */* __restrict  */)(oct), (char const   */* __restrict  */)"%02X ",
              (int )((unsigned char )Databuf[i]));
#line 445
      strcat((char */* __restrict  */)(debbuf), (char const   */* __restrict  */)(oct));
#line 443
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 447
    sysmessage(0, (char const   */* const  */)"%s\n", debbuf);
    }
  }
  {
#line 454
  mode = 1;
#line 455
  tmp___5 = ioctl(P_mfd, 21536UL, & mode);
  }
#line 455
  if (tmp___5 == -1) {
    {
#line 456
    tmp___3 = __errno_location();
#line 456
    tmp___4 = strerror(*tmp___3);
#line 456
    sysmessage(4, (char const   */* const  */)"Can\'t put master pty in packet mode: %s\n",
               tmp___4);
    }
#line 459
    return (-1);
  }
  {
#line 462
  type = (unsigned char )Databuf[0];
#line 464
  parse_message(type, Databuf, retc);
  }
#line 466
  return (0);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/linux-dev.c"
void parse_message(unsigned char type , char *buf , int size ) 
{ 
  struct buffer *bp ;
  struct event *evp ;
  int XXi ;
  struct event *evp___0 ;
  int XXi___0 ;
  struct event *evp___1 ;
  int XXi___1 ;
  int XXi___2 ;
  struct event *evp___2 ;
  int XXi___3 ;

  {
#line 477
  bp = Pty.inbuff;
#line 479
  if (size != 0) {
    {
#line 482
    if (Pty.state == 13) {
#line 482
      goto case_13;
    }
#line 482
    if (Pty.state == 2) {
#line 482
      goto case_13;
    }
#line 480
    goto switch_break;
    case_13: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 483
    XXi = 0;
#line 483
    evp = & Eventpoll[0];
    {
#line 483
    while (1) {
      while_continue: /* CIL Label */ ;
#line 483
      if (! (XXi < 20)) {
#line 483
        goto while_break;
      }
#line 483
      if (evp->ev_type == 0) {
#line 483
        goto while_break;
      }
#line 483
      XXi ++;
#line 483
      evp ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 483
    if (XXi == 20) {
      {
#line 483
      sysmessage(4, (char const   */* const  */)"%s: Too many events", Idmsg);
      }
    } else {
#line 483
      evp->ev_type = 1;
#line 483
      evp->ev_code = 0;
#line 483
      evp->ev_param = (void *)0;
#line 483
      evp->ev_size = 0;
#line 483
      evp->ev_next = & Evhead;
#line 483
      evp->ev_last = Evhead.ev_last;
#line 483
      (Evhead.ev_last)->ev_next = evp;
#line 483
      Evhead.ev_last = evp;
    }
#line 484
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 487
    XXi___0 = 0;
#line 487
    evp___0 = & Eventpoll[0];
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (! (XXi___0 < 20)) {
#line 487
        goto while_break___0;
      }
#line 487
      if (evp___0->ev_type == 0) {
#line 487
        goto while_break___0;
      }
#line 487
      XXi___0 ++;
#line 487
      evp___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 487
    if (XXi___0 == 20) {
      {
#line 487
      sysmessage(4, (char const   */* const  */)"%s: Too many events", Idmsg);
      }
    } else {
#line 487
      evp___0->ev_type = 1;
#line 487
      evp___0->ev_code = 1;
#line 487
      evp___0->ev_param = (void *)0;
#line 487
      evp___0->ev_size = 0;
#line 487
      evp___0->ev_next = & Evhead;
#line 487
      evp___0->ev_last = Evhead.ev_last;
#line 487
      (Evhead.ev_last)->ev_next = evp___0;
#line 487
      Evhead.ev_last = evp___0;
    }
#line 488
    return;
  }
#line 495
  if ((int )type == 0) {
#line 496
    if (size == 0) {
#line 497
      XXi___1 = 0;
#line 497
      evp___1 = & Eventpoll[0];
      {
#line 497
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 497
        if (! (XXi___1 < 20)) {
#line 497
          goto while_break___1;
        }
#line 497
        if (evp___1->ev_type == 0) {
#line 497
          goto while_break___1;
        }
#line 497
        XXi___1 ++;
#line 497
        evp___1 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 497
      if (XXi___1 == 20) {
        {
#line 497
        sysmessage(4, (char const   */* const  */)"%s: Too many events", Idmsg);
        }
      } else {
#line 497
        evp___1->ev_type = 1;
#line 497
        evp___1->ev_code = 1;
#line 497
        evp___1->ev_param = (void *)0;
#line 497
        evp___1->ev_size = 0;
#line 497
        evp___1->ev_next = & Evhead;
#line 497
        evp___1->ev_last = Evhead.ev_last;
#line 497
        (Evhead.ev_last)->ev_next = evp___1;
#line 497
        Evhead.ev_last = evp___1;
      }
    } else {
#line 499
      buf ++;
#line 500
      size --;
#line 502
      XXi___2 = bp->b_size - bp->b_hold;
#line 502
      if (size > XXi___2) {
        {
#line 502
        sysmessage(4, (char const   */* const  */)"%s: Buffer overflow\n", Idmsg);
#line 502
        size = XXi___2;
        }
      }
      {
#line 502
      memcpy((void */* __restrict  */)bp->b_ins, (void const   */* __restrict  */)buf,
             (size_t )size);
#line 502
      bp->b_ins += size;
#line 502
      bp->b_hold += size;
#line 503
      XXi___3 = 0;
#line 503
      evp___2 = & Eventpoll[0];
      }
      {
#line 503
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 503
        if (! (XXi___3 < 20)) {
#line 503
          goto while_break___2;
        }
#line 503
        if (evp___2->ev_type == 0) {
#line 503
          goto while_break___2;
        }
#line 503
        XXi___3 ++;
#line 503
        evp___2 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 503
      if (XXi___3 == 20) {
        {
#line 503
        sysmessage(4, (char const   */* const  */)"%s: Too many events", Idmsg);
        }
      } else {
#line 503
        evp___2->ev_type = 1;
#line 503
        evp___2->ev_code = 2;
#line 503
        evp___2->ev_param = (void *)0;
#line 503
        evp___2->ev_size = 0;
#line 503
        evp___2->ev_next = & Evhead;
#line 503
        evp___2->ev_last = Evhead.ev_last;
#line 503
        (Evhead.ev_last)->ev_next = evp___2;
#line 503
        Evhead.ev_last = evp___2;
      }
    }
  } else {
    {
#line 506
    parse_packet((int )type);
    }
  }
#line 508
  return;
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/linux-dev.c"
int dev_putdata(struct buffer *bp ) 
{ 
  struct pty *pty ;
  int ret ;
  int size ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  ssize_t tmp___2 ;
  unsigned char *tmp___3 ;

  {
#line 514
  pty = & Pty;
  {
#line 519
  while (1) {
    while_continue: /* CIL Label */ ;
#line 519
    if (! bp->b_hold) {
#line 519
      goto while_break;
    }
#line 520
    if (bp->b_hold < pty->iosize) {
#line 520
      size = bp->b_hold;
    } else {
#line 520
      size = pty->iosize;
    }
    {
#line 521
    tmp___2 = write(P_mfd, (void const   *)bp->b_rem, (size_t )size);
#line 521
    ret = (int )tmp___2;
    }
#line 521
    if (ret == -1) {
      {
#line 522
      tmp___1 = __errno_location();
      }
#line 522
      if (*tmp___1 == 11) {
#line 523
        ret = 0;
      } else {
        {
#line 525
        tmp = __errno_location();
#line 525
        tmp___0 = strerror(*tmp);
#line 525
        sysmessage(4, (char const   */* const  */)"Can\'t write on master pty: %s\n",
                   tmp___0);
        }
      }
#line 532
      return (ret);
    }
#line 538
    bp->b_rem += ret;
#line 538
    bp->b_hold -= ret;
  }
  while_break: /* CIL Label */ ;
  }
#line 540
  if (bp->b_hold == 0) {
#line 541
    tmp___3 = bp->b_base;
#line 541
    bp->b_ins = tmp___3;
#line 541
    bp->b_rem = tmp___3;
#line 541
    bp->b_hold = 0;
  }
#line 543
  return (0);
}
}
#line 546 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/linux-dev.c"
void dev_interrupt(void) 
{ 
  int procid ;

  {
  {
#line 550
  procid = get_slave_controlling(P_devnumber);
  }
#line 550
  if (procid > 0) {
    {
#line 551
    kill(- procid, 2);
    }
  }
#line 553
  return;
}
}
#line 555 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/linux-dev.c"
void dev_hangup(void) 
{ 
  int procid ;

  {
  {
#line 559
  procid = get_slave_controlling(P_devnumber);
  }
#line 559
  if (procid > 0) {
    {
#line 560
    kill(- procid, 1);
    }
  }
#line 562
  return;
}
}
#line 564 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/linux-dev.c"
void parse_packet(int type ) 
{ 
  int flushbits ;
  int flushmode ;
  struct event *evp ;
  void *memptr ;
  int XXi ;
  unsigned char *tmp ;

  {
#line 569
  flushbits = type & 3;
#line 570
  if (flushbits) {
    {
#line 572
    if (flushbits == 1) {
#line 572
      goto case_1;
    }
#line 575
    if (flushbits == 2) {
#line 575
      goto case_2;
    }
#line 578
    goto switch_default;
    case_1: /* CIL Label */ 
#line 573
    flushmode = 0;
#line 574
    goto switch_break;
    case_2: /* CIL Label */ 
#line 576
    flushmode = 1;
#line 577
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 579
    flushmode = 2;
#line 580
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 582
    XXi = 0;
#line 582
    evp = & Eventpoll[0];
    {
#line 582
    while (1) {
      while_continue: /* CIL Label */ ;
#line 582
      if (! (XXi < 20)) {
#line 582
        goto while_break;
      }
#line 582
      if (evp->ev_type == 0) {
#line 582
        goto while_break;
      }
#line 582
      XXi ++;
#line 582
      evp ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 582
    if (XXi == 20) {
      {
#line 582
      sysmessage(4, (char const   */* const  */)"%s: Too many events", Idmsg);
      }
    } else {
#line 582
      evp->ev_type = 1;
#line 582
      evp->ev_code = 4;
#line 582
      if ((void *)(& flushmode)) {
        {
#line 582
        tmp = mem_get(128);
#line 582
        memptr = (void *)tmp;
        }
#line 582
        if ((unsigned long )memptr == (unsigned long )((void *)0)) {
          {
#line 582
          sysmessage(4, (char const   */* const  */)"%s: No memory", Idmsg);
          }
        }
        {
#line 582
        memcpy((void */* __restrict  */)memptr, (void const   */* __restrict  */)((void *)(& flushmode)),
               sizeof(int ));
#line 582
        evp->ev_param = memptr;
#line 582
        evp->ev_size = (int )sizeof(int );
        }
      } else {
#line 582
        evp->ev_param = (void *)(& flushmode);
#line 582
        evp->ev_size = 0;
      }
#line 582
      evp->ev_next = & Evhead;
#line 582
      evp->ev_last = Evhead.ev_last;
#line 582
      (Evhead.ev_last)->ev_next = evp;
#line 582
      Evhead.ev_last = evp;
    }
  }
#line 584
  return;
}
}
#line 592 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/linux-dev.c"
void portconfig_to_termios(struct portconfig *pcp , struct termios *tp ) 
{ 
  speed_t speed ;

  {
  {
#line 598
  speed = int_to_baud_index(pcp->speed);
  }
#line 599
  if (speed == 0U) {
#line 600
    speed = (speed_t )4098;
  }
  {
#line 601
  cfsetospeed(tp, speed);
#line 602
  cfsetispeed(tp, (speed_t )0);
  }
  {
#line 606
  if (pcp->datasize == 5) {
#line 606
    goto case_5;
  }
#line 609
  if (pcp->datasize == 6) {
#line 609
    goto case_6;
  }
#line 612
  if (pcp->datasize == 7) {
#line 612
    goto case_7;
  }
#line 615
  if (pcp->datasize == 8) {
#line 615
    goto case_8;
  }
#line 605
  goto switch_break;
  case_5: /* CIL Label */ 
#line 607
  tp->c_cflag = tp->c_cflag;
#line 608
  goto switch_break;
  case_6: /* CIL Label */ 
#line 610
  tp->c_cflag |= 16U;
#line 611
  goto switch_break;
  case_7: /* CIL Label */ 
#line 613
  tp->c_cflag |= 32U;
#line 614
  goto switch_break;
  case_8: /* CIL Label */ 
#line 616
  tp->c_cflag |= 48U;
#line 617
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 621
  if (pcp->stopsize == 2) {
#line 622
    tp->c_cflag |= 64U;
  }
  {
#line 627
  if (pcp->parity == 3) {
#line 627
    goto case_3;
  }
#line 630
  if (pcp->parity == 2) {
#line 630
    goto case_2;
  }
#line 634
  goto switch_default;
  case_3: /* CIL Label */ 
#line 628
  tp->c_cflag |= 256U;
#line 629
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 631
  tp->c_cflag |= 768U;
#line 632
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 635
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 640
  if (pcp->flowc == 2) {
#line 640
    goto case_2___0;
  }
#line 643
  goto switch_default___0;
  case_2___0: /* CIL Label */ 
#line 641
  tp->c_iflag |= 1024U;
#line 642
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
#line 644
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 647
  return;
}
}
#line 653 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/linux-dev.c"
int get_slave_controlling(dev_t device ) 
{ 
  DIR *dip ;
  struct dirent *dep ;
  int process ;
  char procfile[128] ;
  char procbuf[512] ;
  int procfd ;
  char dummybuf[512] ;
  int dummyint ;
  int tty ;
  gid_t tpgid ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;

  {
  {
#line 667
  dip = opendir("/proc");
  }
#line 667
  if ((unsigned long )dip == (unsigned long )((DIR *)0)) {
    {
#line 668
    tmp = __errno_location();
#line 668
    tmp___0 = strerror(*tmp);
#line 668
    sysmessage(4, (char const   */* const  */)"Can\'t open /proc: %s", tmp___0);
#line 670
    exit(1);
    }
  }
  {
#line 673
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 673
    dep = readdir(dip);
    }
#line 673
    if (! ((unsigned long )dep != (unsigned long )((struct dirent *)0))) {
#line 673
      goto while_break;
    }
    {
#line 674
    process = atoi((char const   *)(dep->d_name));
    }
#line 675
    if (process > 0) {
      {
#line 676
      sprintf((char */* __restrict  */)(procfile), (char const   */* __restrict  */)"/proc/%d/stat",
              process);
#line 677
      procfd = open((char const   *)(procfile), 0);
      }
#line 677
      if (procfd == -1) {
        {
#line 678
        tmp___1 = __errno_location();
#line 678
        tmp___2 = strerror(*tmp___1);
#line 678
        sysmessage(4, (char const   */* const  */)"Can\'t open %s:%s\n", procfile,
                   tmp___2);
        }
#line 681
        goto while_break;
      }
      {
#line 683
      tmp___5 = read(procfd, (void *)(procbuf), (size_t )512);
      }
#line 683
      if (tmp___5 <= 0L) {
        {
#line 684
        tmp___3 = __errno_location();
#line 684
        tmp___4 = strerror(*tmp___3);
#line 684
        sysmessage(4, (char const   */* const  */)"Can\'t read %s:%s", procfile, tmp___4);
        }
#line 687
        goto while_break;
      }
      {
#line 689
      close(procfd);
#line 690
      tmp___6 = sscanf((char const   */* __restrict  */)(procbuf), (char const   */* __restrict  */)"%d %s %c %d %d %d %d %u %s",
                       & dummyint, & dummybuf[0], (char *)(& dummyint), & dummyint,
                       & dummyint, & dummyint, & tty, & tpgid, & dummybuf[0]);
      }
#line 690
      if (tmp___6 != 0) {
#line 694
        if ((dev_t )tty == device) {
#line 695
          goto while_break;
        }
      }
#line 698
      tpgid = (gid_t )0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 702
  closedir(dip);
  }
#line 703
  return ((int )tpgid);
}
}
#line 710 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/linux-dev.c"
char ioctlbuf[32]  ;
#line 243 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 388 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrio.h"
void imminent_event(int msgtype ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/sock.h"
int S_fd ;
#line 603 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/misc.c"
int external_poll(int eventmask , int timeout ) 
{ 
  fd_set readmask ;
  fd_set writemask ;
  fd_set exceptmask ;
  struct timeval tv ;
  int ret ;
  int maxfd ;
  int msgtype ;
  int i ;
  int j ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int __d0___1 ;
  int __d1___1 ;
  int flags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct event *evp ;
  int XXi ;
  int tmp___3 ;
  struct event *evp___0 ;
  int XXi___0 ;
  s_control s ;
  ssize_t tmp___5 ;
  ssize_t tmp___6 ;

  {
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readmask.__fds_bits[0]): "memory");
#line 55
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 56
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 56
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& writemask.__fds_bits[0]): "memory");
#line 56
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 57
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 57
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___1), "=D" (__d1___1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& exceptmask.__fds_bits[0]): "memory");
#line 57
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 59
  if (S_fd > P_mfd) {
#line 59
    maxfd = S_fd;
  } else {
#line 59
    maxfd = P_mfd;
  }
#line 60
  if (Nvt.servertype == 0) {
#line 62
    i = 0;
    {
#line 62
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 62
      if (i < 32) {
#line 62
        if (! (P_contr[i] != -1)) {
#line 62
          goto while_break___2;
        }
      } else {
#line 62
        goto while_break___2;
      }
#line 64
      if (maxfd > P_contr[i]) {
#line 64
        maxfd = maxfd;
      } else {
#line 64
        maxfd = P_contr[i];
      }
#line 65
      readmask.__fds_bits[P_contr[i] / (8 * (int )sizeof(__fd_mask ))] |= 1L << P_contr[i] % (8 * (int )sizeof(__fd_mask ));
#line 62
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 67
    if (maxfd > P_contr_listen) {
#line 67
      maxfd = maxfd;
    } else {
#line 67
      maxfd = P_contr_listen;
    }
#line 68
    readmask.__fds_bits[P_contr_listen / (8 * (int )sizeof(__fd_mask ))] |= 1L << P_contr_listen % (8 * (int )sizeof(__fd_mask ));
  }
#line 70
  maxfd ++;
#line 72
  if (eventmask & 9) {
#line 73
    readmask.__fds_bits[P_mfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << P_mfd % (8 * (int )sizeof(__fd_mask ));
  }
#line 74
  if (eventmask & 4) {
#line 75
    exceptmask.__fds_bits[P_mfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << P_mfd % (8 * (int )sizeof(__fd_mask ));
  }
#line 76
  if (eventmask & 2) {
#line 77
    writemask.__fds_bits[P_mfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << P_mfd % (8 * (int )sizeof(__fd_mask ));
  }
#line 78
  if (eventmask & 80) {
#line 79
    readmask.__fds_bits[S_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << S_fd % (8 * (int )sizeof(__fd_mask ));
  }
#line 80
  if (eventmask & 32) {
#line 81
    writemask.__fds_bits[S_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << S_fd % (8 * (int )sizeof(__fd_mask ));
  }
  {
#line 83
  tv.tv_sec = (__time_t )(timeout / 1000);
#line 84
  tv.tv_usec = (__suseconds_t )((timeout % 1000) * 1000);
#line 86
  ret = select(maxfd, (fd_set */* __restrict  */)(& readmask), (fd_set */* __restrict  */)(& writemask),
               (fd_set */* __restrict  */)(& exceptmask), (struct timeval */* __restrict  */)(& tv));
  }
#line 88
  if (Nvt.servertype == 0) {
#line 88
    if ((readmask.__fds_bits[P_contr_listen / (8 * (int )sizeof(__fd_mask ))] & (1L << P_contr_listen % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 92
      sysmessage(3, (char const   */* const  */)"Receiving control connection from FD %d\n",
                 P_contr_listen);
      }
#line 93
      if (P_contr[31] != -1) {
        {
#line 95
        close(P_contr[0]);
#line 96
        readmask.__fds_bits[P_contr[0] / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << P_contr[0] % (8 * (int )sizeof(__fd_mask )));
#line 97
        i = 0;
        }
        {
#line 97
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 97
          if (! (i < 31)) {
#line 97
            goto while_break___3;
          }
#line 98
          P_contr[i] = P_contr[i + 1];
#line 97
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 99
        P_contr[31] = -1;
      }
#line 101
      i = 0;
      {
#line 101
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 101
        if (! (P_contr[i] != -1)) {
#line 101
          goto while_break___4;
        }
#line 101
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 104
      tmp = fcntl(P_contr_listen, 4, 2048);
      }
#line 104
      if (tmp == -1) {
        {
#line 106
        sysmessage(4, (char const   */* const  */)"Can\'t set non-blocking IO.\n");
#line 107
        _exit(1);
        }
      }
      {
#line 110
      P_contr[i] = accept(P_contr_listen, (struct sockaddr */* __restrict  */)((void *)0),
                          (socklen_t */* __restrict  */)((void *)0));
      }
#line 111
      if (P_contr[i] == -1) {
        {
#line 113
        sysmessage(4, (char const   */* const  */)"Error in accept on control socket.\n");
        }
      } else {
        {
#line 117
        flags = fcntl(P_contr[i], 3);
        }
#line 117
        if (flags == -1) {
          {
#line 119
          sysmessage(4, (char const   */* const  */)"Can\'t set non-blocking IO on control socket!\n");
          }
        } else {
          {
#line 117
          tmp___0 = fcntl(P_contr[i], 4, flags & 2048);
          }
#line 117
          if (tmp___0) {
            {
#line 119
            sysmessage(4, (char const   */* const  */)"Can\'t set non-blocking IO on control socket!\n");
            }
          } else {
            {
#line 121
            sysmessage(3, (char const   */* const  */)"New control socket FD=%d\n",
                       P_contr[i]);
            }
          }
        }
      }
    }
  }
#line 124
  if ((readmask.__fds_bits[P_mfd / (8 * (int )sizeof(__fd_mask ))] & (1L << P_mfd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 124
    goto _L;
  } else
#line 124
  if ((exceptmask.__fds_bits[P_mfd / (8 * (int )sizeof(__fd_mask ))] & (1L << P_mfd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
    _L: /* CIL Label */ 
#line 126
    if (Debug > 2) {
#line 128
      if ((exceptmask.__fds_bits[P_mfd / (8 * (int )sizeof(__fd_mask ))] & (1L << P_mfd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 129
        sysmessage(3, (char const   */* const  */)"Pty exception\n");
        }
      }
    }
#line 131
    if (eventmask & 8) {
      {
#line 133
      msgtype = dev_probe();
      }
#line 133
      if (msgtype == -1) {
        {
#line 135
        sysmessage(3, (char const   */* const  */)"Hang up PTY PROBE\n");
#line 136
        Hang_up = 1;
        }
#line 137
        return (-1);
      }
      {
#line 139
      imminent_event(msgtype);
      }
    } else {
      {
#line 143
      tmp___1 = dev_getdata();
      }
#line 143
      if (tmp___1 == -1) {
        {
#line 145
        sysmessage(3, (char const   */* const  */)"Hang up PTY GETDATA\n");
#line 146
        Hang_up = 1;
        }
#line 147
        return (-1);
      }
    }
  } else
#line 153
  if (eventmask & 1) {
    {
#line 155
    dev_closeslave();
    }
  }
#line 158
  if ((writemask.__fds_bits[P_mfd / (8 * (int )sizeof(__fd_mask ))] & (1L << P_mfd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 160
    XXi = 0;
#line 160
    evp = & Eventpoll[0];
    {
#line 160
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 160
      if (! (XXi < 20)) {
#line 160
        goto while_break___5;
      }
#line 160
      if (evp->ev_type == 0) {
#line 160
        goto while_break___5;
      }
#line 160
      XXi ++;
#line 160
      evp ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 160
    if (XXi == 20) {
      {
#line 160
      sysmessage(4, (char const   */* const  */)"%s: Too many events", Idmsg);
      }
    } else {
#line 160
      evp->ev_type = 1;
#line 160
      evp->ev_code = 5;
#line 160
      evp->ev_param = (void *)0;
#line 160
      evp->ev_size = 0;
#line 160
      evp->ev_next = & Evhead;
#line 160
      evp->ev_last = Evhead.ev_last;
#line 160
      (Evhead.ev_last)->ev_next = evp;
#line 160
      Evhead.ev_last = evp;
    }
  }
#line 162
  if ((readmask.__fds_bits[S_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << S_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
    {
#line 164
    tmp___3 = tel_getdata();
    }
#line 164
    if (tmp___3 == -1) {
      {
#line 166
      sysmessage(3, (char const   */* const  */)"Hang up NVT GETDATA\n");
#line 167
      Hang_up = 1;
      }
#line 168
      return (-1);
    }
  }
#line 171
  if ((writemask.__fds_bits[S_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << S_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 173
    XXi___0 = 0;
#line 173
    evp___0 = & Eventpoll[0];
    {
#line 173
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 173
      if (! (XXi___0 < 20)) {
#line 173
        goto while_break___6;
      }
#line 173
      if (evp___0->ev_type == 0) {
#line 173
        goto while_break___6;
      }
#line 173
      XXi___0 ++;
#line 173
      evp___0 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 173
    if (XXi___0 == 20) {
      {
#line 173
      sysmessage(4, (char const   */* const  */)"%s: Too many events", Idmsg);
      }
    } else {
#line 173
      evp___0->ev_type = 2;
#line 173
      evp___0->ev_code = 4;
#line 173
      evp___0->ev_param = (void *)0;
#line 173
      evp___0->ev_size = 0;
#line 173
      evp___0->ev_next = & Evhead;
#line 173
      evp___0->ev_last = Evhead.ev_last;
#line 173
      (Evhead.ev_last)->ev_next = evp___0;
#line 173
      Evhead.ev_last = evp___0;
    }
  }
#line 175
  if (Nvt.servertype == 0) {
#line 177
    i = 0;
    {
#line 177
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 177
      if (i < 32) {
#line 177
        if (! (P_contr[i] != -1)) {
#line 177
          goto while_break___7;
        }
      } else {
#line 177
        goto while_break___7;
      }
#line 179
      if ((readmask.__fds_bits[P_contr[i] / (8 * (int )sizeof(__fd_mask ))] & (1L << P_contr[i] % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 182
        tmp___6 = recv(P_contr[i], (void *)(& s), sizeof(s), 256);
        }
#line 182
        if ((unsigned long )tmp___6 != sizeof(s)) {
#line 182
          goto _L___0;
        } else
#line 182
        if ((unsigned long )s.size != sizeof(s)) {
          _L___0: /* CIL Label */ 
          {
#line 185
          sysmessage(3, (char const   */* const  */)"Closing control connection.\n");
#line 186
          close(P_contr[i]);
#line 187
          j = i;
          }
          {
#line 187
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 187
            if (! (j < 31)) {
#line 187
              goto while_break___8;
            }
#line 188
            P_contr[j] = P_contr[j + 1];
#line 187
            j ++;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 189
          P_contr[31] = -1;
        } else {
          {
#line 195
          if ((unsigned int )s.oper == 0U) {
#line 195
            goto case_0;
          }
#line 199
          if ((unsigned int )s.oper == 1U) {
#line 199
            goto case_1;
          }
#line 214
          if ((unsigned int )s.oper == 2U) {
#line 214
            goto case_2;
          }
#line 218
          if ((unsigned int )s.oper == 3U) {
#line 218
            goto case_3;
          }
#line 222
          if ((unsigned int )s.oper == 4U) {
#line 222
            goto case_4;
          }
#line 226
          if ((unsigned int )s.oper == 5U) {
#line 226
            goto case_5;
          }
#line 193
          goto switch_break;
          case_0: /* CIL Label */ 
          {
#line 196
          sync_comport_command(1, s.val);
#line 197
          s.val = Comport.portconfig.speed;
          }
#line 198
          goto switch_break;
          case_1: /* CIL Label */ 
#line 200
          if (s.val == 0) {
#line 202
            tv.tv_sec = (__time_t )0;
#line 203
            tv.tv_usec = (__suseconds_t )250000;
          } else {
#line 207
            tv.tv_sec = (__time_t )(s.val / 4);
#line 208
            tv.tv_usec = (__suseconds_t )((s.val % 4) * 250000);
          }
          {
#line 210
          sync_comport_command(5, 5);
#line 211
          select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
#line 212
          sync_comport_command(5, 6);
          }
#line 213
          goto switch_break;
          case_2: /* CIL Label */ 
          {
#line 215
          sync_comport_command(2, s.val);
#line 216
          s.val = Comport.portconfig.datasize;
          }
#line 217
          goto switch_break;
          case_3: /* CIL Label */ 
          {
#line 219
          sync_comport_command(3, s.val);
#line 220
          s.val = Comport.portconfig.parity;
          }
#line 221
          goto switch_break;
          case_4: /* CIL Label */ 
          {
#line 223
          sync_comport_command(4, s.val);
#line 224
          s.val = Comport.portconfig.stopsize;
          }
#line 225
          goto switch_break;
          case_5: /* CIL Label */ 
          {
#line 227
          sync_comport_command(5, s.val);
          }
#line 231
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
          {
#line 233
          tmp___5 = send(P_contr[i], (void const   *)(& s), sizeof(s), 0);
          }
#line 233
          if ((unsigned long )tmp___5 != sizeof(s)) {
            {
#line 235
            sysmessage(3, (char const   */* const  */)"Lost control connection to client.\n");
#line 236
            close(P_contr[i]);
#line 237
            j = i;
            }
            {
#line 237
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 237
              if (! (j < 31)) {
#line 237
                goto while_break___9;
              }
#line 238
              P_contr[j] = P_contr[j + 1];
#line 237
              j ++;
            }
            while_break___9: /* CIL Label */ ;
            }
#line 239
            P_contr[31] = -1;
#line 240
            i --;
          }
        }
      }
#line 177
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 250
  return (ret);
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrio.h"
int tsr_init(int netsize , int devsize , int devmodem , int closemode ) ;
#line 387
void tsr_io(void) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
struct buffer Inbuf  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
struct buffer Outbuf  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
int Hang_up  =    0;
#line 47 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
struct statenames Pty_states[16]  = 
#line 47
  {      {(char const   */* const  */)"PTY_INITIAL", (char **)0}, 
        {(char const   */* const  */)"PTY_CLOSING", (char **)0}, 
        {(char const   */* const  */)"PTY_CLOSED", (char **)0}, 
        {(char const   */* const  */)"PTY_OPENING", (char **)0}, 
        {(char const   */* const  */)"PTY_WAITDCD", (char **)0}, 
        {(char const   */* const  */)"PTY_OPER", (char **)0}, 
        {(char const   */* const  */)"PTY_CONFIG", (char **)0}, 
        {(char const   */* const  */)"PTY_WAITNVTWR", (char **)0}, 
        {(char const   */* const  */)"PTY_WAITUSRWR", (char **)0}, 
        {(char const   */* const  */)"PTY_WAITNRUW", (char **)0}, 
        {(char const   */* const  */)"PTY_WAITNVTCM", (char **)0}, 
        {(char const   */* const  */)"PTY_WAITCLOCAL", (char **)0}, 
        {(char const   */* const  */)"PTY_WAITCLOSE", (char **)0}, 
        {(char const   */* const  */)"PTY_OPERRONLY", (char **)0}, 
        {(char const   */* const  */)"PTY_WAITUSRWR0", (char **)0}, 
        {(char const   */* const  */)"PTY_WAITUSRWR2", (char **)0}};
#line 66 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
struct statenames Nvt_states[7]  = {      {(char const   */* const  */)"NVT_INITIAL", (char **)0}, 
        {(char const   */* const  */)"NVT_OPER", (char **)0}, 
        {(char const   */* const  */)"NVT_WAITPTYWR", (char **)0}, 
        {(char const   */* const  */)"NVT_WAITRASWR", (char **)0}, 
        {(char const   */* const  */)"NVT_WAITRWPW", (char **)0}, 
        {(char const   */* const  */)"NVT_WAITRASCM", (char **)0}, 
        {(char const   */* const  */)"NVT_WAITRCPW", (char **)0}};
#line 76 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
char const   * const  Pty_events[6]  = {      (char const   */* const  */)"EV_UPOPEN",      (char const   */* const  */)"EV_UPCLOSE",      (char const   */* const  */)"EV_UPDATA",      (char const   */* const  */)"EV_UPCONTROL", 
        (char const   */* const  */)"EV_UPFLUSH",      (char const   */* const  */)"EV_UPWROK"};
#line 85 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
char const   * const  Nvt_events[5]  = {      (char const   */* const  */)"EV_RNDNTFY",      (char const   */* const  */)"EV_RNDATA",      (char const   */* const  */)"EV_RNHANG",      (char const   */* const  */)"EV_RNCMOK", 
        (char const   */* const  */)"EV_RNWROK"};
#line 97
void all_hangup(void) ;
#line 98
int check_states(void) ;
#line 99
void all_wakeup(void) ;
#line 100
void all_readonly(void) ;
#line 106
void up_nop(struct event *evp ) ;
#line 108
void up_open(struct event *unused ) ;
#line 109
void up_op01(struct event *unused ) ;
#line 110
void up_close(struct event *unused ) ;
#line 111
void up_data(struct event *unused ) ;
#line 112
void up_ioctl(struct event *unused ) ;
#line 113
void up_flush(struct event *evp ) ;
#line 114
void up_wrok(struct event *unused ) ;
#line 120
void np_nop(char const   * const  evhand ) ;
#line 122
void np_wrok(void) ;
#line 123
void np_wok01(void) ;
#line 124
void np_wok02(void) ;
#line 125
void np_woker(void) ;
#line 127
void np_cmdok(void) ;
#line 128
void np_cok01(void) ;
#line 129
void np_cok02(void) ;
#line 130
void np_cok03(void) ;
#line 131
void np_cok04(void) ;
#line 132
void np_coker(void) ;
#line 134
void np_dcdon(void) ;
#line 135
void np_don01(void) ;
#line 136
void np_don02(void) ;
#line 137
void np_doner(void) ;
#line 139
void np_dcdoff(void) ;
#line 140
void np_dof01(void) ;
#line 141
void np_dof02(void) ;
#line 142
void np_dofer(void) ;
#line 144
void np_parity(void) ;
#line 145
void np_par01(void) ;
#line 146
void np_parer(void) ;
#line 148
void np_break(void) ;
#line 149
void np_brk01(void) ;
#line 150
void np_brker(void) ;
#line 157
int do_ptydata(void) ;
#line 158
void do_ptyopen(void) ;
#line 159
void do_ptyopen1(void) ;
#line 160
void do_ptyclose(void) ;
#line 161
void do_ptyclose1(void) ;
#line 162
void do_ptywrite(void) ;
#line 163
void do_ptyioctl(void) ;
#line 164
void do_ptyconfig(int mode , struct portconfig *pcp ) ;
#line 165
void do_ptyconfig1(void) ;
#line 166
void do_ptysendbreak(int interval ) ;
#line 167
void do_ptyflush(int mode ) ;
#line 168
void do_ptyhangup(void) ;
#line 169
void do_ptyinterrupt(void) ;
#line 175
void rn_nop(struct event *evp ) ;
#line 177
void rn_ntfy(struct event *evp ) ;
#line 178
void rn_data(struct event *unused ) ;
#line 179
void rn_cmdok(struct event *unused ) ;
#line 180
void rn_wrok(struct event *unused ) ;
#line 186
void pn_nop(char const   * const  evhand ) ;
#line 188
void pn_wrok(void) ;
#line 189
void pn_wok01(void) ;
#line 190
void pn_wok02(void) ;
#line 191
void pn_woker(void) ;
#line 197
void do_nvterror(char const   * const  action ) ;
#line 198
int do_nvtdata(void) ;
#line 199
void do_nvtdtron(void) ;
#line 200
void do_nvtdtroff(void) ;
#line 201
void do_nvtconfig(struct portconfig *pcp ) ;
#line 202
void do_nvtsendbreak(int interval ) ;
#line 203
void do_nvtflush(int mode ) ;
#line 209
char *tsr_states(char const   * const  unused ) ;
#line 210
void print_ptystate(char const   * const  hand ) ;
#line 211
void print_nvtstate(char const   * const  hand ) ;
#line 212
void print_action(char const   * const  hand ) ;
#line 213
void print_event(struct event *evp ) ;
#line 220 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void (*Pty_upevents[16][6])(struct event *evp )  = 
#line 220
  { {        & up_nop,        & up_nop,        & up_nop,        & up_nop, 
            & up_nop,        & up_nop}, 
   {        & up_nop,        & up_nop,        & up_nop,        & up_nop, 
            & up_nop,        & up_nop}, 
   {        & up_open,        & up_nop,        & up_nop,        & up_nop, 
            & up_nop,        & up_nop}, 
   {        & up_nop,        & up_nop,        & up_nop,        & up_nop, 
            & up_nop,        & up_nop}, 
   {        & up_nop,        & up_nop,        & up_nop,        & up_nop, 
            & up_nop,        & up_nop}, 
   {        & up_nop,        & up_close,        & up_data,        & up_ioctl, 
            & up_flush,        & up_nop}, 
   {        & up_nop,        & up_nop,        & up_nop,        & up_nop, 
            & up_nop,        & up_nop}, 
   {        & up_nop,        & up_nop,        & up_nop,        & up_nop, 
            & up_nop,        & up_nop}, 
   {        & up_nop,        & up_close,        & up_data,        & up_nop, 
            & up_nop,        & up_wrok}, 
   {        & up_nop,        & up_nop,        & up_nop,        & up_nop, 
            & up_nop,        & up_wrok}, 
   {        & up_nop,        & up_nop,        & up_nop,        & up_nop, 
            & up_nop,        & up_nop}, 
   {        & up_nop,        & up_close,        & up_nop,        & up_nop, 
            & up_nop,        & up_nop}, 
   {        & up_nop,        & up_close,        & up_nop,        & up_nop, 
            & up_nop,        & up_nop}, 
   {        & up_op01,        & up_nop,        & up_nop,        & up_nop, 
            & up_nop,        & up_nop}, 
   {        & up_nop,        & up_close,        & up_nop,        & up_nop, 
            & up_nop,        & up_wrok}, 
   {        & up_nop,        & up_close,        & up_nop,        & up_nop, 
            & up_nop,        & up_wrok}};
#line 246 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void (*Pty_npevents[16][6])(void)  = 
#line 246
  { {        & np_woker,        & np_coker,        & np_doner,        & np_dofer, 
            & np_parer,        & np_brker}, 
   {        & np_woker,        & np_cok01,        & np_doner,        & np_dofer, 
            & np_parer,        & np_brker}, 
   {        & np_woker,        & np_coker,        & np_doner,        & np_dofer, 
            & np_parer,        & np_brker}, 
   {        & np_woker,        & np_cok02,        & np_doner,        & np_dofer, 
            & np_parer,        & np_brker}, 
   {        & np_woker,        & np_coker,        & np_don01,        & np_dofer, 
            & np_parer,        & np_brker}, 
   {        & np_woker,        & np_coker,        & np_doner,        & np_dof01, 
            & np_par01,        & np_brk01}, 
   {        & np_woker,        & np_cok03,        & np_doner,        & np_dofer, 
            & np_parer,        & np_brker}, 
   {        & np_wok01,        & np_coker,        & np_doner,        & np_dofer, 
            & np_par01,        & np_brk01}, 
   {        & np_woker,        & np_coker,        & np_doner,        & np_dofer, 
            & np_parer,        & np_brker}, 
   {        & np_wok02,        & np_coker,        & np_doner,        & np_dofer, 
            & np_parer,        & np_brker}, 
   {        & np_woker,        & np_cok04,        & np_doner,        & np_dofer, 
            & np_parer,        & np_brker}, 
   {        & np_woker,        & np_coker,        & np_don02,        & np_dofer, 
            & np_parer,        & np_brker}, 
   {        & np_woker,        & np_coker,        & np_don01,        & np_dofer, 
            & np_parer,        & np_brker}, 
   {        & np_woker,        & np_coker,        & np_doner,        & np_dof02, 
            & np_parer,        & np_brk01}, 
   {        & np_woker,        & np_coker,        & np_doner,        & np_dofer, 
            & np_parer,        & np_brker}, 
   {        & np_woker,        & np_coker,        & np_doner,        & np_dofer, 
            & np_parer,        & np_brker}};
#line 270 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void (*Nvt_rnevents[7][5])(struct event *evp )  = { {        & rn_ntfy,        & rn_nop,        & rn_nop,        & rn_nop, 
            & rn_nop}, 
   {        & rn_ntfy,        & rn_data,        & rn_nop,        & rn_nop, 
            & rn_nop}, 
   {        & rn_nop,        & rn_nop,        & rn_nop,        & rn_nop, 
            & rn_nop}, 
   {        & rn_ntfy,        & rn_data,        & rn_nop,        & rn_nop, 
            & rn_wrok}, 
   {        & rn_nop,        & rn_nop,        & rn_nop,        & rn_nop, 
            & rn_wrok}, 
   {        & rn_ntfy,        & rn_nop,        & rn_nop,        & rn_cmdok, 
            & rn_nop}, 
   {        & rn_nop,        & rn_nop,        & rn_nop,        & rn_cmdok, 
            & rn_nop}};
#line 286 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void (*Nvt_pnevents[7][1])(void)  = { {        & pn_woker}, 
   {        & pn_woker}, 
   {        & pn_wok01}, 
   {        & pn_woker}, 
   {        & pn_wok02}, 
   {        & pn_woker}, 
   {        & pn_woker}};
#line 302 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
int tsr_init(int netsize , int devsize , int devmodem , int closemode ) 
{ 
  int ret ;

  {
  {
#line 309
  Inbuf.b_base = mem_get(2 * netsize);
  }
#line 309
  if ((unsigned long )Inbuf.b_base == (unsigned long )((void *)0)) {
    {
#line 309
    sysmessage(4, (char const   */* const  */)"%s: out of memory\n", Idmsg);
    }
#line 309
    return (7);
  }
  {
#line 309
  Inbuf.b_rem = Inbuf.b_base;
#line 309
  Inbuf.b_ins = Inbuf.b_rem;
#line 309
  Inbuf.b_size = 2 * netsize;
#line 309
  Inbuf.b_hold = 0;
#line 311
  Outbuf.b_base = mem_get(2 * devsize);
  }
#line 311
  if ((unsigned long )Outbuf.b_base == (unsigned long )((void *)0)) {
    {
#line 311
    sysmessage(4, (char const   */* const  */)"%s: out of memory\n", Idmsg);
    }
#line 311
    return (7);
  }
  {
#line 311
  Outbuf.b_rem = Outbuf.b_base;
#line 311
  Outbuf.b_ins = Outbuf.b_rem;
#line 311
  Outbuf.b_size = 2 * devsize;
#line 311
  Outbuf.b_hold = 0;
#line 315
  Evhead.ev_next = & Evhead;
#line 315
  Evhead.ev_last = Evhead.ev_next;
#line 319
  Hang_up = 0;
#line 323
  ret = tel_init(netsize, & Inbuf, & Outbuf);
  }
#line 323
  if (ret != 0) {
#line 324
    return (ret);
  }
  {
#line 326
  Nvt.state = 1;
#line 326
  print_nvtstate((char const   */* const  */)"tsr_init");
#line 330
  ret = dev_init(devsize, devmodem, closemode, & Outbuf, & Inbuf, Nvt.comport);
  }
#line 330
  if (ret == 0) {
    {
#line 333
    Pty.state = 0;
#line 333
    print_ptystate((char const   */* const  */)"tsr_init");
#line 334
    do_ptyclose();
    }
  }
#line 337
  return (ret);
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void tsr_io(void) 
{ 
  struct event *ev ;
  int mask ;

  {
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 353
    if (! (Hang_up == 0)) {
#line 353
      goto while_break;
    }
    {
#line 354
    mask = check_states();
#line 355
    external_poll(mask, 1000);
    }
    {
#line 356
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 356
      if (! (Hang_up == 0)) {
#line 356
        goto while_break___0;
      }
#line 357
      if ((unsigned long )Evhead.ev_next == (unsigned long )(& Evhead)) {
#line 357
        ev = (struct event *)0;
      } else {
#line 357
        ev = Evhead.ev_next;
      }
#line 358
      if (! ev) {
#line 358
        goto while_break___0;
      }
      {
#line 360
      print_event(ev);
      }
      {
#line 363
      if (ev->ev_type == 1) {
#line 363
        goto case_1;
      }
#line 367
      if (ev->ev_type == 2) {
#line 367
        goto case_2;
      }
#line 362
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 364
      (*(Pty_upevents[Pty.state][ev->ev_code]))(ev);
      }
#line 365
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 368
      (*(Nvt_rnevents[Nvt.state][ev->ev_code]))(ev);
      }
#line 369
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 371
      (ev->ev_last)->ev_next = ev->ev_next;
#line 371
      (ev->ev_next)->ev_last = ev->ev_last;
#line 371
      ev->ev_type = 0;
#line 371
      if (ev->ev_param) {
        {
#line 371
        mem_free(ev->ev_param);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  all_hangup();
  }
#line 375
  return;
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void all_hangup(void) 
{ 
  struct event *evp ;
  int i ;

  {
  {
#line 381
  dev_hangup();
#line 383
  tel_free();
#line 385
  dev_free();
#line 387
  mem_free((void *)Inbuf.b_base);
#line 389
  mem_free((void *)Outbuf.b_base);
#line 391
  i = 0;
#line 391
  evp = & Eventpoll[0];
  }
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    if (! (i < 20)) {
#line 391
      goto while_break;
    }
#line 391
    evp->ev_type = 0;
#line 391
    i ++;
#line 391
    evp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 391
  Evhead.ev_next = & Evhead;
#line 391
  Evhead.ev_last = Evhead.ev_next;
#line 393
  Hang_up = 0;
#line 395
  return;
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
int check_states(void) 
{ 
  int mask ;

  {
#line 400
  mask = 0;
  {
#line 404
  if (Pty.state == 13) {
#line 404
    goto case_13;
  }
#line 404
  if (Pty.state == 5) {
#line 404
    goto case_13;
  }
#line 408
  if (Pty.state == 12) {
#line 408
    goto case_12;
  }
#line 408
  if (Pty.state == 11) {
#line 408
    goto case_12;
  }
#line 411
  if (Pty.state == 14) {
#line 411
    goto case_14;
  }
#line 414
  if (Pty.state == 8) {
#line 414
    goto case_8;
  }
#line 418
  if (Pty.state == 15) {
#line 418
    goto case_15;
  }
#line 418
  if (Pty.state == 9) {
#line 418
    goto case_15;
  }
#line 402
  goto switch_break;
  case_13: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 405
  mask = 5;
#line 406
  goto switch_break;
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
#line 409
  mask = 12;
#line 410
  goto switch_break;
  case_14: /* CIL Label */ 
#line 412
  mask = 7;
#line 413
  goto switch_break;
  case_8: /* CIL Label */ 
#line 415
  mask = 7;
#line 416
  goto switch_break;
  case_15: /* CIL Label */ 
  case_9: /* CIL Label */ 
#line 419
  mask = 2;
#line 420
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 426
  if (Nvt.state == 6) {
#line 426
    goto case_6;
  }
#line 426
  if (Nvt.state == 5) {
#line 426
    goto case_6;
  }
#line 426
  if (Nvt.state == 1) {
#line 426
    goto case_6;
  }
#line 429
  if (Nvt.state == 3) {
#line 429
    goto case_3;
  }
#line 432
  if (Nvt.state == 4) {
#line 432
    goto case_4;
  }
#line 423
  goto switch_break___0;
  case_6: /* CIL Label */ 
  case_5___0: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 427
  mask |= 16;
#line 428
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 430
  mask |= 48;
#line 431
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 433
  mask |= 32;
#line 434
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 437
  return (mask);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void imminent_event(int msgtype ) 
{ 


  {
  {
#line 444
  if (Pty.state == 12) {
#line 444
    goto case_12;
  }
#line 451
  if (Pty.state == 14) {
#line 451
    goto case_14;
  }
#line 459
  if (Pty.state == 8) {
#line 459
    goto case_8;
  }
#line 466
  if (Pty.state == 11) {
#line 466
    goto case_11;
  }
#line 443
  goto switch_break;
  case_12: /* CIL Label */ 
#line 445
  if (msgtype != 2) {
    {
#line 446
    Pty.state = 4;
#line 446
    print_ptystate((char const   */* const  */)"probe");
    }
  } else {
    {
#line 448
    dev_getdata();
    }
  }
#line 450
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 452
  Pty.state = 8;
#line 452
  print_ptystate((char const   */* const  */)"probe");
  }
#line 453
  if (msgtype != 2) {
#line 453
    if (msgtype != 1) {
      {
#line 454
      Pty.state = 15;
#line 454
      print_ptystate((char const   */* const  */)"probe");
      }
    } else {
      {
#line 456
      dev_getdata();
      }
    }
  } else {
    {
#line 456
    dev_getdata();
    }
  }
#line 458
  goto switch_break;
  case_8: /* CIL Label */ 
#line 460
  if (msgtype != 2) {
#line 460
    if (msgtype != 1) {
      {
#line 461
      Pty.state = 15;
#line 461
      print_ptystate((char const   */* const  */)"probe");
      }
    } else {
      {
#line 463
      dev_getdata();
      }
    }
  } else {
    {
#line 463
    dev_getdata();
    }
  }
#line 465
  goto switch_break;
  case_11: /* CIL Label */ 
#line 467
  if (msgtype == 4) {
    {
#line 468
    Pty.state = 5;
#line 468
    print_ptystate((char const   */* const  */)"probe");
#line 469
    Pty.portmodes |= 2;
#line 470
    dev_getdata();
    }
  } else
#line 471
  if (msgtype == 2) {
    {
#line 472
    Pty.state = 5;
#line 472
    print_ptystate((char const   */* const  */)"probe");
#line 473
    dev_getdata();
    }
  } else {
    {
#line 475
    Pty.state = 4;
#line 475
    print_ptystate((char const   */* const  */)"probe");
    }
  }
#line 477
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 479
  return;
}
}
#line 483 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void all_wakeup(void) 
{ 
  int tmp ;

  {
#line 489
  if (! (Pty.portmodes & 2)) {
#line 489
    if (! ((Pty.comport)->portstate.modemstate & 128)) {
      {
#line 491
      Pty.state = 12;
#line 491
      print_ptystate((char const   */* const  */)"all_wakeup");
#line 492
      do_ptyhangup();
      }
#line 493
      return;
    }
  }
#line 497
  if ((Pty.outbuff)->b_hold) {
    {
#line 498
    tmp = do_ptydata();
    }
#line 498
    if (tmp != 0) {
#line 499
      return;
    }
    {
#line 501
    pn_wrok();
    }
  }
#line 505
  if ((Pty.inbuff)->b_hold) {
    {
#line 506
    do_ptywrite();
    }
  }
#line 508
  return;
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void all_readonly(void) 
{ 
  int tmp ;

  {
#line 515
  if (! (Pty.portmodes & 2)) {
#line 515
    if (! ((Pty.comport)->portstate.modemstate & 128)) {
      {
#line 517
      Pty.state = 11;
#line 517
      print_ptystate((char const   */* const  */)"all_readonly");
#line 518
      do_ptyhangup();
      }
#line 519
      return;
    }
  }
#line 523
  if ((Pty.outbuff)->b_hold) {
    {
#line 524
    tmp = do_ptydata();
    }
#line 524
    if (tmp != 0) {
#line 525
      return;
    }
    {
#line 527
    pn_wrok();
    }
  }
#line 529
  return;
}
}
#line 535 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void up_nop(struct event *evp ) 
{ 
  char const   *event ;
  char *tmp ;

  {
  {
#line 538
  event = (char const   *)Pty_events[evp->ev_code];
#line 539
  tmp = tsr_states((char const   */* const  */)event);
#line 539
  sysmessage(0, (char const   */* const  */)"PTY state (EVENT %s): %s\n", event, tmp);
  }
#line 541
  return;
}
}
#line 543 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void up_open(struct event *unused ) 
{ 


  {
  {
#line 546
  unused = unused;
#line 547
  do_ptyopen();
  }
#line 548
  return;
}
}
#line 551 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void up_op01(struct event *unused ) 
{ 


  {
#line 554
  unused = unused;
  {
#line 557
  if (Pty.state == 13) {
#line 557
    goto case_13;
  }
#line 561
  if (Pty.state == 14) {
#line 561
    goto case_14;
  }
#line 556
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 558
  Pty.state = 5;
#line 558
  print_ptystate((char const   */* const  */)"up_op01");
#line 559
  all_wakeup();
  }
#line 560
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 562
  Pty.state = 8;
#line 562
  print_ptystate((char const   */* const  */)"up_op01");
  }
#line 563
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 565
  return;
}
}
#line 567 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void up_close(struct event *unused ) 
{ 


  {
  {
#line 570
  unused = unused;
#line 571
  do_ptyclose();
  }
#line 572
  return;
}
}
#line 574 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void up_ioctl(struct event *unused ) 
{ 


  {
  {
#line 577
  unused = unused;
#line 578
  do_ptyioctl();
  }
#line 579
  return;
}
}
#line 581 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void up_flush(struct event *evp ) 
{ 
  int mode ;

  {
  {
#line 585
  mode = *((int *)evp->ev_param);
#line 587
  do_ptyflush(mode);
  }
#line 588
  return;
}
}
#line 590 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void up_data(struct event *unused ) 
{ 


  {
  {
#line 593
  unused = unused;
#line 594
  do_ptywrite();
  }
#line 595
  return;
}
}
#line 597 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void up_wrok(struct event *unused ) 
{ 
  int tmp ;

  {
#line 600
  unused = unused;
  {
#line 602
  if (Pty.state == 14) {
#line 602
    goto case_14;
  }
#line 606
  if (Pty.state == 15) {
#line 606
    goto case_15;
  }
#line 606
  if (Pty.state == 8) {
#line 606
    goto case_15;
  }
#line 609
  if (Pty.state == 9) {
#line 609
    goto case_9;
  }
#line 601
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 603
  Pty.state = 13;
#line 603
  print_ptystate((char const   */* const  */)"up_wrok");
  }
#line 604
  goto switch_break;
  case_15: /* CIL Label */ 
  case_8: /* CIL Label */ 
  {
#line 607
  Pty.state = 5;
#line 607
  print_ptystate((char const   */* const  */)"up_wrok");
  }
#line 608
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 610
  Pty.state = 7;
#line 610
  print_ptystate((char const   */* const  */)"up_wrok");
  }
#line 611
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 614
  tmp = do_ptydata();
  }
#line 614
  if (tmp == 0) {
    {
#line 615
    pn_wrok();
    }
  }
#line 617
  return;
}
}
#line 623 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_nop(char const   * const  evhand ) 
{ 
  char *tmp ;

  {
  {
#line 626
  tmp = tsr_states(evhand);
#line 626
  sysmessage(0, (char const   */* const  */)"PTY state (INT EVENT %s): %s\n", evhand,
             tmp);
  }
#line 628
  return;
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_wrok(void) 
{ 


  {
  {
#line 634
  (*(Pty_npevents[Pty.state][0]))();
  }
#line 635
  return;
}
}
#line 637 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_wok01(void) 
{ 


  {
  {
#line 640
  Pty.state = 5;
#line 640
  print_ptystate((char const   */* const  */)"np_wrok");
#line 641
  all_wakeup();
  }
#line 642
  return;
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_wok02(void) 
{ 


  {
  {
#line 647
  Pty.state = 8;
#line 647
  print_ptystate((char const   */* const  */)"np_wrok");
  }
#line 648
  return;
}
}
#line 650 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_woker(void) 
{ 


  {
  {
#line 653
  np_nop((char const   */* const  */)"np_wrok");
  }
#line 654
  return;
}
}
#line 659 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_cmdok(void) 
{ 


  {
  {
#line 662
  (*(Pty_npevents[Pty.state][1]))();
  }
#line 663
  return;
}
}
#line 665 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_cok01(void) 
{ 


  {
  {
#line 668
  do_ptyclose1();
  }
#line 669
  return;
}
}
#line 671 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_cok02(void) 
{ 


  {
  {
#line 674
  do_ptyopen1();
  }
#line 675
  return;
}
}
#line 677 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_cok03(void) 
{ 


  {
  {
#line 680
  do_ptyconfig1();
  }
#line 681
  return;
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_cok04(void) 
{ 


  {
  {
#line 686
  Pty.state = 5;
#line 686
  print_ptystate((char const   */* const  */)"np_cmdok");
#line 687
  all_wakeup();
  }
#line 688
  return;
}
}
#line 690 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_coker(void) 
{ 


  {
  {
#line 693
  np_nop((char const   */* const  */)"np_cmdok");
  }
#line 694
  return;
}
}
#line 699 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_dcdon(void) 
{ 


  {
  {
#line 702
  (*(Pty_npevents[Pty.state][2]))();
  }
#line 703
  return;
}
}
#line 705 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_don01(void) 
{ 


  {
  {
#line 708
  Pty.state = 5;
#line 708
  print_ptystate((char const   */* const  */)"np_dcdon");
#line 709
  all_wakeup();
  }
#line 710
  return;
}
}
#line 711 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_don02(void) 
{ 


  {
  {
#line 714
  Pty.state = 13;
#line 714
  print_ptystate((char const   */* const  */)"np_dcdon");
#line 715
  all_readonly();
  }
#line 716
  return;
}
}
#line 717 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_doner(void) 
{ 


  {
  {
#line 720
  np_nop((char const   */* const  */)"ev_npdcdon");
  }
#line 721
  return;
}
}
#line 725 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_dcdoff(void) 
{ 


  {
  {
#line 728
  (*(Pty_npevents[Pty.state][3]))();
  }
#line 729
  return;
}
}
#line 731 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_dof01(void) 
{ 


  {
#line 734
  if (! (Pty.portmodes & 2)) {
    {
#line 735
    Pty.state = 12;
#line 735
    print_ptystate((char const   */* const  */)"np_dcdoff");
#line 736
    do_ptyhangup();
    }
  }
#line 738
  return;
}
}
#line 740 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_dof02(void) 
{ 


  {
#line 743
  if (! (Pty.portmodes & 2)) {
    {
#line 744
    Pty.state = 11;
#line 744
    print_ptystate((char const   */* const  */)"np_dcdoff");
#line 745
    do_ptyhangup();
    }
  }
#line 747
  return;
}
}
#line 749 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_dofer(void) 
{ 


  {
  {
#line 752
  np_nop((char const   */* const  */)"np_dcdoff");
  }
#line 753
  return;
}
}
#line 757 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_parity(void) 
{ 


  {
  {
#line 760
  (*(Pty_npevents[Pty.state][4]))();
  }
#line 761
  return;
}
}
#line 763 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_par01(void) 
{ 
  int portmodes ;
  struct buffer *bp ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 769
  portmodes = Pty.portmodes;
#line 770
  bp = Pty.outbuff;
#line 771
  if (! (portmodes & 16)) {
#line 772
    if (portmodes & 32) {
#line 773
      if (bp->b_hold < bp->b_size) {
#line 773
        tmp = bp->b_ins;
#line 773
        (bp->b_ins) ++;
#line 773
        *tmp = (unsigned char)255;
#line 773
        (bp->b_hold) ++;
      } else {
        {
#line 773
        sysmessage(4, (char const   */* const  */)"%s: Buffer overflow\n", Idmsg);
        }
      }
#line 774
      if (bp->b_hold < bp->b_size) {
#line 774
        tmp___0 = bp->b_ins;
#line 774
        (bp->b_ins) ++;
#line 774
        *tmp___0 = (unsigned char)0;
#line 774
        (bp->b_hold) ++;
      } else {
        {
#line 774
        sysmessage(4, (char const   */* const  */)"%s: Buffer overflow\n", Idmsg);
        }
      }
    } else
#line 776
    if (bp->b_hold < bp->b_size) {
#line 776
      tmp___1 = bp->b_ins;
#line 776
      (bp->b_ins) ++;
#line 776
      *tmp___1 = (unsigned char)0;
#line 776
      (bp->b_hold) ++;
    } else {
      {
#line 776
      sysmessage(4, (char const   */* const  */)"%s: Buffer overflow\n", Idmsg);
      }
    }
  }
#line 779
  return;
}
}
#line 781 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_parer(void) 
{ 


  {
  {
#line 784
  np_nop((char const   */* const  */)"np_parity");
  }
#line 785
  return;
}
}
#line 789 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_break(void) 
{ 


  {
  {
#line 792
  (*(Pty_npevents[Pty.state][5]))();
  }
#line 793
  return;
}
}
#line 795 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_brk01(void) 
{ 
  int portmodes ;
  struct buffer *bp1 ;
  struct buffer *bp2 ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;

  {
#line 801
  portmodes = Pty.portmodes;
#line 802
  bp1 = Pty.outbuff;
#line 803
  bp2 = Pty.inbuff;
#line 804
  if (! (portmodes & 4)) {
#line 805
    if (portmodes & 8) {
      {
#line 806
      tmp = bp1->b_base;
#line 806
      bp1->b_ins = tmp;
#line 806
      bp1->b_rem = tmp;
#line 806
      bp1->b_hold = 0;
#line 807
      tmp___0 = bp2->b_base;
#line 807
      bp2->b_ins = tmp___0;
#line 807
      bp2->b_rem = tmp___0;
#line 807
      bp2->b_hold = 0;
#line 808
      do_ptyinterrupt();
      }
    } else
#line 809
    if (portmodes & 32) {
#line 810
      if (bp1->b_hold < bp1->b_size) {
#line 810
        tmp___1 = bp1->b_ins;
#line 810
        (bp1->b_ins) ++;
#line 810
        *tmp___1 = (unsigned char)255;
#line 810
        (bp1->b_hold) ++;
      } else {
        {
#line 810
        sysmessage(4, (char const   */* const  */)"%s: Buffer overflow\n", Idmsg);
        }
      }
#line 811
      if (bp1->b_hold < bp1->b_size) {
#line 811
        tmp___2 = bp1->b_ins;
#line 811
        (bp1->b_ins) ++;
#line 811
        *tmp___2 = (unsigned char)0;
#line 811
        (bp1->b_hold) ++;
      } else {
        {
#line 811
        sysmessage(4, (char const   */* const  */)"%s: Buffer overflow\n", Idmsg);
        }
      }
    } else
#line 813
    if (bp1->b_hold < bp1->b_size) {
#line 813
      tmp___3 = bp1->b_ins;
#line 813
      (bp1->b_ins) ++;
#line 813
      *tmp___3 = (unsigned char)0;
#line 813
      (bp1->b_hold) ++;
    } else {
      {
#line 813
      sysmessage(4, (char const   */* const  */)"%s: Buffer overflow\n", Idmsg);
      }
    }
  }
#line 816
  return;
}
}
#line 818 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void np_brker(void) 
{ 


  {
  {
#line 821
  np_nop((char const   */* const  */)"np_break");
  }
#line 822
  return;
}
}
#line 828 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void do_ptyerror(char const   * const  action ) 
{ 
  char *tmp ;

  {
  {
#line 831
  tmp = tsr_states(action);
#line 831
  sysmessage(4, (char const   */* const  */)"Undesirable PTY state for ACTION %s: %s\n",
             action, tmp);
  }
#line 833
  return;
}
}
#line 835 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
int do_ptydata(void) 
{ 
  int ret ;
  struct buffer *bp ;
  unsigned char *tmp ;

  {
  {
#line 839
  bp = Pty.outbuff;
#line 841
  print_action((char const   */* const  */)"do_ptydata");
  }
  {
#line 845
  if (Pty.state == 7) {
#line 845
    goto case_7;
  }
#line 845
  if (Pty.state == 13) {
#line 845
    goto case_7;
  }
#line 845
  if (Pty.state == 5) {
#line 845
    goto case_7;
  }
#line 876
  if (Pty.state == 4) {
#line 876
    goto case_4;
  }
#line 876
  if (Pty.state == 11) {
#line 876
    goto case_4;
  }
#line 876
  if (Pty.state == 3) {
#line 876
    goto case_4;
  }
#line 876
  if (Pty.state == 2) {
#line 876
    goto case_4;
  }
#line 876
  if (Pty.state == 1) {
#line 876
    goto case_4;
  }
#line 876
  if (Pty.state == 12) {
#line 876
    goto case_4;
  }
#line 882
  goto switch_default;
  case_7: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 846
  ret = dev_putdata(bp);
  }
#line 846
  if (ret == 0) {
#line 847
    if (bp->b_hold != 0) {
      {
#line 849
      if (Pty.state == 5) {
#line 849
        goto case_5___0;
      }
#line 852
      if (Pty.state == 7) {
#line 852
        goto case_7___0;
      }
#line 855
      if (Pty.state == 13) {
#line 855
        goto case_13___0;
      }
#line 848
      goto switch_break___0;
      case_5___0: /* CIL Label */ 
      {
#line 850
      Pty.state = 8;
#line 850
      print_ptystate((char const   */* const  */)"do_ptydata");
      }
#line 851
      goto switch_break___0;
      case_7___0: /* CIL Label */ 
      {
#line 853
      Pty.state = 9;
#line 853
      print_ptystate((char const   */* const  */)"do_ptydata");
      }
#line 854
      goto switch_break___0;
      case_13___0: /* CIL Label */ 
      {
#line 856
      Pty.state = 14;
#line 856
      print_ptystate((char const   */* const  */)"do_ptydata");
      }
#line 857
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 859
      ret = 6;
    } else {
#line 861
      ret = 0;
    }
  } else {
#line 864
    Hang_up = 1;
#line 865
    if (Debug > 0) {
      {
#line 866
      sysmessage(0, (char const   */* const  */)"HANGUP DO_PTYDATA\n");
      }
    }
#line 868
    ret = 1;
  }
#line 870
  goto switch_break;
  case_4: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_12: /* CIL Label */ 
  {
#line 877
  tmp = (Pty.outbuff)->b_base;
#line 877
  (Pty.outbuff)->b_ins = tmp;
#line 877
  (Pty.outbuff)->b_rem = tmp;
#line 877
  (Pty.outbuff)->b_hold = 0;
#line 878
  pn_wrok();
#line 879
  ret = 0;
  }
#line 880
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 883
  do_ptyerror((char const   */* const  */)"do_ptydata");
#line 884
  ret = 6;
  }
#line 885
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 888
  return (ret);
}
}
#line 891 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void do_ptyclose(void) 
{ 
  int tmp ;
  unsigned char *tmp___0 ;

  {
  {
#line 895
  print_action((char const   */* const  */)"do_ptyclose");
  }
#line 898
  if ((Pty.inbuff)->b_hold) {
    {
#line 899
    tmp = do_nvtdata();
    }
#line 899
    if (tmp != 0) {
      {
#line 900
      sysmessage(3, (char const   */* const  */)"Can\'t flush output buffer before close\n");
      }
    }
  }
#line 906
  if ((Pty.outbuff)->b_hold) {
    {
#line 907
    tmp___0 = (Pty.outbuff)->b_base;
#line 907
    (Pty.outbuff)->b_ins = tmp___0;
#line 907
    (Pty.outbuff)->b_rem = tmp___0;
#line 907
    (Pty.outbuff)->b_hold = 0;
#line 908
    pn_wrok();
    }
  }
#line 913
  if (Pty.portmodes & 1) {
    {
#line 914
    Pty.state = 1;
#line 914
    print_ptystate((char const   */* const  */)"do_ptyclose");
#line 915
    do_nvtdtroff();
    }
  } else {
    {
#line 917
    do_ptyclose1();
    }
  }
#line 919
  return;
}
}
#line 921 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void do_ptyclose1(void) 
{ 


  {
  {
#line 924
  print_action((char const   */* const  */)"do_ptyclose1");
#line 925
  dev_config();
#line 926
  Pty.state = 2;
#line 926
  print_ptystate((char const   */* const  */)"do_ptyclose1");
#line 931
  sysdelay(1000);
#line 932
  do_ptyopen();
  }
#line 933
  return;
}
}
#line 935 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void do_ptyopen(void) 
{ 


  {
  {
#line 938
  print_action((char const   */* const  */)"do_ptyopen");
#line 939
  Pty.state = 3;
#line 939
  print_ptystate((char const   */* const  */)"do_ptyopen");
#line 940
  do_nvtdtron();
  }
#line 941
  return;
}
}
#line 943 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void do_ptyopen1(void) 
{ 
  unsigned char *tmp ;

  {
  {
#line 946
  print_action((char const   */* const  */)"do_ptyopen1");
  }
#line 947
  if (! (Pty.portmodes & 2)) {
#line 947
    if (! ((Pty.comport)->portstate.modemstate & 128)) {
#line 950
      if ((Pty.outbuff)->b_hold) {
        {
#line 951
        tmp = (Pty.outbuff)->b_base;
#line 951
        (Pty.outbuff)->b_ins = tmp;
#line 951
        (Pty.outbuff)->b_rem = tmp;
#line 951
        (Pty.outbuff)->b_hold = 0;
#line 952
        pn_wrok();
        }
      }
      {
#line 954
      Pty.state = 11;
#line 954
      print_ptystate((char const   */* const  */)"do_ptyopen1");
      }
    } else {
      {
#line 956
      Pty.state = 13;
#line 956
      print_ptystate((char const   */* const  */)"do_ptyopen1");
#line 957
      all_readonly();
      }
    }
  } else {
    {
#line 956
    Pty.state = 13;
#line 956
    print_ptystate((char const   */* const  */)"do_ptyopen1");
#line 957
    all_readonly();
    }
  }
#line 959
  return;
}
}
#line 961 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void do_ptywrite(void) 
{ 
  int ret ;

  {
  {
#line 965
  print_action((char const   */* const  */)"do_ptywrite");
#line 966
  ret = do_nvtdata();
  }
#line 966
  if (ret != 0) {
#line 967
    if (ret == 6) {
      {
#line 969
      if (Pty.state == 5) {
#line 969
        goto case_5;
      }
#line 972
      if (Pty.state == 8) {
#line 972
        goto case_8;
      }
#line 968
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 970
      Pty.state = 7;
#line 970
      print_ptystate((char const   */* const  */)"do_ptywrite");
      }
#line 971
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 973
      Pty.state = 9;
#line 973
      print_ptystate((char const   */* const  */)"do_ptywrite");
      }
#line 974
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 979
  return;
}
}
#line 981 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void do_ptyioctl(void) 
{ 
  struct iocontrol *iocp ;
  int oper ;
  struct portconfig *pconfig ;
  int param ;

  {
  {
#line 984
  iocp = & Pty.iocontrol;
#line 985
  oper = iocp->io_oper;
#line 989
  print_action((char const   */* const  */)"do_ptyioctl");
  }
  {
#line 993
  if (oper == 3) {
#line 993
    goto case_3;
  }
#line 993
  if (oper == 2) {
#line 993
    goto case_3;
  }
#line 993
  if (oper == 1) {
#line 993
    goto case_3;
  }
#line 997
  if (oper == 4) {
#line 997
    goto case_4;
  }
#line 1001
  if (oper == 6) {
#line 1001
    goto case_6;
  }
#line 990
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 994
  pconfig = & iocp->io_param.portconfig;
#line 995
  do_ptyconfig(oper, pconfig);
  }
#line 996
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 998
  param = iocp->io_param.arg;
#line 999
  do_ptysendbreak(param);
  }
#line 1000
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1002
  param = iocp->io_param.arg;
#line 1003
  do_ptyflush(param);
  }
#line 1004
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1007
  iocp->io_oper = 0;
#line 1008
  return;
}
}
#line 1010 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void do_ptyconfig(int mode , struct portconfig *pcp ) 
{ 
  struct portconfig *cur ;
  int tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1015
  print_action((char const   */* const  */)"do_ptyconfig");
  }
#line 1016
  if (mode != 1) {
    {
#line 1017
    tmp = do_nvtdata();
    }
#line 1017
    if (tmp != 0) {
      {
#line 1018
      sysmessage(3, (char const   */* const  */)"Can\'t flush output buffer before configure\n");
      }
    }
  }
#line 1023
  if (mode == 3) {
#line 1025
    if ((Pty.outbuff)->b_hold) {
      {
#line 1026
      tmp___0 = (Pty.outbuff)->b_base;
#line 1026
      (Pty.outbuff)->b_ins = tmp___0;
#line 1026
      (Pty.outbuff)->b_rem = tmp___0;
#line 1026
      (Pty.outbuff)->b_hold = 0;
#line 1027
      pn_wrok();
      }
    }
  }
  {
#line 1033
  cur = & (Pty.comport)->portconfig;
#line 1035
  tmp___1 = memcmp((void const   *)((void *)cur), (void const   *)((void *)pcp), sizeof(struct portconfig ));
  }
#line 1035
  if (tmp___1 != 0) {
#line 1037
    if (! pcp->speed) {
      {
#line 1038
      Pty.state = 10;
#line 1038
      print_ptystate((char const   */* const  */)"do_ptyconfig");
#line 1039
      do_nvtdtroff();
      }
    } else {
      {
#line 1041
      Pty.state = 6;
#line 1041
      print_ptystate((char const   */* const  */)"do_ptyconfig");
#line 1042
      do_nvtconfig(pcp);
      }
    }
  } else {
    {
#line 1045
    do_ptyconfig1();
    }
  }
#line 1048
  return;
}
}
#line 1050 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void do_ptyconfig1(void) 
{ 


  {
  {
#line 1054
  print_action((char const   */* const  */)"do_ptyconfig1");
  }
#line 1055
  if (! (Pty.portmodes & 2)) {
#line 1055
    if (! ((Pty.comport)->portstate.modemstate & 128)) {
      {
#line 1057
      Pty.state = 4;
#line 1057
      print_ptystate((char const   */* const  */)"do_ptyconfig1");
      }
    } else {
      {
#line 1059
      Pty.state = 5;
#line 1059
      print_ptystate((char const   */* const  */)"do_ptyconfig1");
#line 1060
      all_wakeup();
      }
    }
  } else {
    {
#line 1059
    Pty.state = 5;
#line 1059
    print_ptystate((char const   */* const  */)"do_ptyconfig1");
#line 1060
    all_wakeup();
    }
  }
#line 1063
  return;
}
}
#line 1065 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void do_ptysendbreak(int interval ) 
{ 
  int tmp ;

  {
  {
#line 1069
  print_action((char const   */* const  */)"do_ptysendbreak");
#line 1070
  tmp = do_nvtdata();
  }
#line 1070
  if (tmp != 0) {
    {
#line 1071
    sysmessage(3, (char const   */* const  */)"Can\'t flush output buffer before send break\n");
    }
  }
  {
#line 1074
  Pty.state = 10;
#line 1074
  print_ptystate((char const   */* const  */)"do_ptysendbreak");
#line 1075
  do_nvtsendbreak(interval);
  }
#line 1076
  return;
}
}
#line 1078 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void do_ptyflush(int mode ) 
{ 
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;

  {
  {
#line 1081
  print_action((char const   */* const  */)"do_ptyflush");
  }
  {
#line 1083
  if (mode == 0) {
#line 1083
    goto case_0;
  }
#line 1089
  if (mode == 1) {
#line 1089
    goto case_1;
  }
#line 1092
  if (mode == 2) {
#line 1092
    goto case_2;
  }
#line 1082
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1084
  if ((Pty.outbuff)->b_hold) {
    {
#line 1085
    tmp = (Pty.outbuff)->b_base;
#line 1085
    (Pty.outbuff)->b_ins = tmp;
#line 1085
    (Pty.outbuff)->b_rem = tmp;
#line 1085
    (Pty.outbuff)->b_hold = 0;
#line 1086
    pn_wrok();
    }
  }
#line 1088
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1090
  tmp___0 = (Pty.inbuff)->b_base;
#line 1090
  (Pty.inbuff)->b_ins = tmp___0;
#line 1090
  (Pty.inbuff)->b_rem = tmp___0;
#line 1090
  (Pty.inbuff)->b_hold = 0;
#line 1091
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1093
  tmp___1 = (Pty.inbuff)->b_base;
#line 1093
  (Pty.inbuff)->b_ins = tmp___1;
#line 1093
  (Pty.inbuff)->b_rem = tmp___1;
#line 1093
  (Pty.inbuff)->b_hold = 0;
#line 1094
  if ((Pty.outbuff)->b_hold) {
    {
#line 1095
    tmp___2 = (Pty.outbuff)->b_base;
#line 1095
    (Pty.outbuff)->b_ins = tmp___2;
#line 1095
    (Pty.outbuff)->b_rem = tmp___2;
#line 1095
    (Pty.outbuff)->b_hold = 0;
#line 1096
    pn_wrok();
    }
  }
#line 1098
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1100
  Pty.state = 10;
#line 1100
  print_ptystate((char const   */* const  */)"do_ptyflush");
#line 1101
  do_nvtflush(mode);
  }
#line 1102
  return;
}
}
#line 1104 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void do_ptyhangup(void) 
{ 
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
  {
#line 1107
  print_action((char const   */* const  */)"do_ptyhangup");
#line 1108
  tmp = (Pty.inbuff)->b_base;
#line 1108
  (Pty.inbuff)->b_ins = tmp;
#line 1108
  (Pty.inbuff)->b_rem = tmp;
#line 1108
  (Pty.inbuff)->b_hold = 0;
  }
#line 1109
  if ((Pty.outbuff)->b_hold) {
    {
#line 1110
    tmp___0 = (Pty.outbuff)->b_base;
#line 1110
    (Pty.outbuff)->b_ins = tmp___0;
#line 1110
    (Pty.outbuff)->b_rem = tmp___0;
#line 1110
    (Pty.outbuff)->b_hold = 0;
#line 1111
    pn_wrok();
    }
  }
  {
#line 1113
  dev_hangup();
  }
#line 1114
  return;
}
}
#line 1116 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void do_ptyinterrupt(void) 
{ 


  {
  {
#line 1119
  print_action((char const   */* const  */)"do_ptyinterrupt");
#line 1120
  dev_interrupt();
  }
#line 1121
  return;
}
}
#line 1128 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void rn_nop(struct event *evp ) 
{ 
  char const   *event ;
  char *tmp ;

  {
  {
#line 1131
  event = (char const   *)Nvt_events[evp->ev_code];
#line 1132
  tmp = tsr_states((char const   */* const  */)event);
#line 1132
  sysmessage(0, (char const   */* const  */)"NVT state (EVENT %s): %s\n", event, tmp);
  }
#line 1134
  return;
}
}
#line 1136 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void rn_cmdok(struct event *unused ) 
{ 
  int state ;

  {
#line 1140
  state = Nvt.state;
#line 1141
  unused = unused;
  {
#line 1143
  if (state == 5) {
#line 1143
    goto case_5;
  }
#line 1146
  if (state == 6) {
#line 1146
    goto case_6;
  }
#line 1142
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1144
  Nvt.state = 1;
#line 1144
  print_nvtstate((char const   */* const  */)"rn_cmdok");
  }
#line 1145
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1147
  Nvt.state = 2;
#line 1147
  print_nvtstate((char const   */* const  */)"rn_cmdok");
  }
#line 1148
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1151
  np_cmdok();
  }
#line 1152
  return;
}
}
#line 1154 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void rn_wrok(struct event *unused ) 
{ 
  int state ;
  int tmp ;

  {
#line 1158
  state = Nvt.state;
#line 1159
  unused = unused;
  {
#line 1161
  if (state == 3) {
#line 1161
    goto case_3;
  }
#line 1164
  if (state == 4) {
#line 1164
    goto case_4;
  }
#line 1160
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1162
  Nvt.state = 1;
#line 1162
  print_nvtstate((char const   */* const  */)"rn_wrok");
  }
#line 1163
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1165
  Nvt.state = 2;
#line 1165
  print_nvtstate((char const   */* const  */)"rn_wrok");
  }
#line 1166
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1169
  tmp = do_nvtdata();
  }
#line 1169
  if (tmp == 0) {
    {
#line 1170
    np_wrok();
    }
  }
#line 1172
  return;
}
}
#line 1174 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void rn_ntfy(struct event *evp ) 
{ 
  int notify ;

  {
#line 1179
  notify = *((int *)evp->ev_param);
  {
#line 1182
  if (notify == 0) {
#line 1182
    goto case_0;
  }
#line 1185
  if (notify == 1) {
#line 1185
    goto case_1;
  }
#line 1188
  if (notify == 2) {
#line 1188
    goto case_2;
  }
#line 1191
  if (notify == 3) {
#line 1191
    goto case_3;
  }
#line 1181
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1183
  np_dcdon();
  }
#line 1184
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1186
  np_dcdoff();
  }
#line 1187
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1189
  np_break();
  }
#line 1190
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1192
  np_parity();
  }
#line 1193
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1195
  return;
}
}
#line 1197 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void rn_data(struct event *unused ) 
{ 
  int ret ;

  {
  {
#line 1202
  unused = unused;
#line 1203
  ret = do_ptydata();
  }
#line 1203
  if (ret != 0) {
#line 1204
    if (ret == 6) {
      {
#line 1206
      if (Nvt.state == 1) {
#line 1206
        goto case_1;
      }
#line 1209
      if (Nvt.state == 3) {
#line 1209
        goto case_3;
      }
#line 1212
      if (Nvt.state == 5) {
#line 1212
        goto case_5;
      }
#line 1205
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 1207
      Nvt.state = 2;
#line 1207
      print_nvtstate((char const   */* const  */)"rn_data");
      }
#line 1208
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 1210
      Nvt.state = 4;
#line 1210
      print_nvtstate((char const   */* const  */)"rn_data");
      }
#line 1211
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 1213
      Nvt.state = 6;
#line 1213
      print_nvtstate((char const   */* const  */)"rn_data");
      }
#line 1214
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1218
  return;
}
}
#line 1224 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void pn_nop(char const   * const  evhand ) 
{ 
  char *tmp ;

  {
  {
#line 1227
  tmp = tsr_states(evhand);
#line 1227
  sysmessage(0, (char const   */* const  */)"NVT state (INT EVENT %s): %s\n", evhand,
             tmp);
  }
#line 1229
  return;
}
}
#line 1231 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void pn_wrok(void) 
{ 


  {
  {
#line 1234
  (*(Nvt_pnevents[Nvt.state][0]))();
  }
#line 1235
  return;
}
}
#line 1236 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void pn_wok01(void) 
{ 


  {
  {
#line 1239
  Nvt.state = 1;
#line 1239
  print_nvtstate((char const   */* const  */)"pn_wrok");
  }
#line 1240
  return;
}
}
#line 1242 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void pn_wok02(void) 
{ 


  {
  {
#line 1245
  Nvt.state = 3;
#line 1245
  print_nvtstate((char const   */* const  */)"pn_wrok");
  }
#line 1246
  return;
}
}
#line 1248 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void pn_woker(void) 
{ 


  {
  {
#line 1251
  pn_nop((char const   */* const  */)"ev_pnwrok");
  }
#line 1252
  return;
}
}
#line 1258 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void do_nvterror(char const   * const  action ) 
{ 
  char *tmp ;

  {
  {
#line 1261
  tmp = tsr_states(action);
#line 1261
  sysmessage(4, (char const   */* const  */)"Undesirable NVT state for ACTION %s: %s\n",
             action, tmp);
  }
#line 1263
  return;
}
}
#line 1265 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
int do_nvtdata(void) 
{ 
  int ret ;
  struct buffer *bp ;

  {
  {
#line 1269
  bp = Nvt.outbuff;
#line 1271
  print_action((char const   */* const  */)"do_nvtdata");
  }
#line 1272
  if (! bp->b_hold) {
#line 1273
    return (0);
  }
  {
#line 1277
  if (Nvt.state == 2) {
#line 1277
    goto case_2;
  }
#line 1277
  if (Nvt.state == 1) {
#line 1277
    goto case_2;
  }
#line 1297
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 1278
  ret = tel_putdata(bp);
  }
#line 1278
  if (ret == 0) {
#line 1279
    if (bp->b_hold != 0) {
#line 1280
      if (Nvt.state == 1) {
        {
#line 1281
        Nvt.state = 3;
#line 1281
        print_nvtstate((char const   */* const  */)"do_nvtdata");
        }
      } else {
        {
#line 1283
        Nvt.state = 4;
#line 1283
        print_nvtstate((char const   */* const  */)"do_nvtdata");
        }
      }
#line 1285
      ret = 6;
    } else {
#line 1287
      ret = 0;
    }
  } else {
#line 1290
    Hang_up = 1;
#line 1291
    if (Debug > 0) {
      {
#line 1292
      sysmessage(0, (char const   */* const  */)"HANGUP DO_NVTDATA\n");
      }
    }
#line 1294
    ret = 1;
  }
#line 1296
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1298
  do_nvterror((char const   */* const  */)"do_nvtdata");
#line 1299
  ret = 6;
  }
#line 1300
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1302
  return (ret);
}
}
#line 1306 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void do_nvtdtron(void) 
{ 


  {
  {
#line 1310
  print_action((char const   */* const  */)"do_nvtdtron");
  }
  {
#line 1313
  if (Nvt.state == 2) {
#line 1313
    goto case_2;
  }
#line 1313
  if (Nvt.state == 1) {
#line 1313
    goto case_2;
  }
#line 1322
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 1314
  tel_putcmd(5, 8);
  }
#line 1315
  if (Nvt.state == 1) {
    {
#line 1316
    Nvt.state = 5;
#line 1316
    print_nvtstate((char const   */* const  */)"do_nvtdtron");
    }
  } else {
    {
#line 1318
    Nvt.state = 6;
#line 1318
    print_nvtstate((char const   */* const  */)"do_nvtdtron");
    }
  }
#line 1320
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1323
  do_nvterror((char const   */* const  */)"do_nvtdtron");
  }
#line 1324
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1326
  return;
}
}
#line 1328 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void do_nvtdtroff(void) 
{ 


  {
  {
#line 1331
  print_action((char const   */* const  */)"do_nvtdtroff");
  }
  {
#line 1334
  if (Nvt.state == 2) {
#line 1334
    goto case_2;
  }
#line 1334
  if (Nvt.state == 1) {
#line 1334
    goto case_2;
  }
#line 1343
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 1335
  tel_putcmd(5, 9);
  }
#line 1336
  if (Nvt.state == 1) {
    {
#line 1337
    Nvt.state = 5;
#line 1337
    print_nvtstate((char const   */* const  */)"do_nvtdtroff");
    }
  } else {
    {
#line 1339
    Nvt.state = 6;
#line 1339
    print_nvtstate((char const   */* const  */)"do_nvtdtroff");
    }
  }
#line 1341
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1344
  do_nvterror((char const   */* const  */)"do_nvtdtroff");
  }
#line 1345
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1347
  return;
}
}
#line 1349 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void do_nvtconfig(struct portconfig *pcp ) 
{ 
  struct portconfig *cur ;
  int cmds ;

  {
  {
#line 1352
  cur = & (Nvt.comport)->portconfig;
#line 1353
  cmds = 0;
#line 1355
  print_action((char const   */* const  */)"do_nvtconfig");
  }
  {
#line 1358
  if (Nvt.state == 2) {
#line 1358
    goto case_2;
  }
#line 1358
  if (Nvt.state == 1) {
#line 1358
    goto case_2;
  }
#line 1389
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 1359
  if (pcp->speed != cur->speed) {
    {
#line 1360
    tel_putcmd(1, pcp->speed);
#line 1361
    cmds ++;
    }
  }
#line 1363
  if (pcp->datasize != cur->datasize) {
    {
#line 1364
    tel_putcmd(2, pcp->datasize);
#line 1365
    cmds ++;
    }
  }
#line 1367
  if (pcp->stopsize != cur->stopsize) {
    {
#line 1368
    tel_putcmd(4, pcp->stopsize);
#line 1369
    cmds ++;
    }
  }
#line 1371
  if (pcp->parity != cur->parity) {
    {
#line 1372
    tel_putcmd(3, pcp->stopsize);
#line 1373
    cmds ++;
    }
  }
#line 1375
  if (pcp->flowc != cur->flowc) {
    {
#line 1376
    tel_putcmd(5, pcp->flowc);
#line 1377
    cmds ++;
    }
  }
#line 1379
  if (cmds) {
#line 1380
    if (Nvt.state == 1) {
      {
#line 1381
      Nvt.state = 5;
#line 1381
      print_nvtstate((char const   */* const  */)"do_nvtconfig");
      }
    } else {
      {
#line 1383
      Nvt.state = 6;
#line 1383
      print_nvtstate((char const   */* const  */)"do_nvtconfig");
      }
    }
  } else {
    {
#line 1386
    np_cmdok();
    }
  }
#line 1388
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1390
  do_nvterror((char const   */* const  */)"do_nvtconfig");
  }
#line 1391
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1393
  return;
}
}
#line 1395 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void do_nvtsendbreak(int interval ) 
{ 


  {
  {
#line 1398
  print_action((char const   */* const  */)"do_nvtsendbreak");
  }
  {
#line 1401
  if (Nvt.state == 2) {
#line 1401
    goto case_2;
  }
#line 1401
  if (Nvt.state == 1) {
#line 1401
    goto case_2;
  }
#line 1420
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 1402
  tel_putcmd(5, 5);
#line 1410
  interval = 250;
#line 1412
  sysdelay(interval);
#line 1413
  tel_putcmd(5, 6);
  }
#line 1414
  if (Nvt.state == 1) {
    {
#line 1415
    Nvt.state = 5;
#line 1415
    print_nvtstate((char const   */* const  */)"do_nvtsendbreak");
    }
  } else {
    {
#line 1417
    Nvt.state = 6;
#line 1417
    print_nvtstate((char const   */* const  */)"do_nvtsendbreak");
    }
  }
#line 1419
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1421
  do_nvterror((char const   */* const  */)"do_nvtsendbreak");
  }
#line 1422
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1424
  return;
}
}
#line 1426 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void do_nvtflush(int mode ) 
{ 
  int purgemode ;

  {
  {
#line 1431
  print_action((char const   */* const  */)"do_nvtflush");
  }
  {
#line 1434
  if (Nvt.state == 2) {
#line 1434
    goto case_2;
  }
#line 1434
  if (Nvt.state == 1) {
#line 1434
    goto case_2;
  }
#line 1455
  goto switch_default___0;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 1436
  if (mode == 0) {
#line 1436
    goto case_0;
  }
#line 1439
  if (mode == 1) {
#line 1439
    goto case_1___0;
  }
#line 1443
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1437
  purgemode = 1;
#line 1438
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 1440
  purgemode = 2;
#line 1441
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 1444
  purgemode = 3;
#line 1445
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1448
  tel_putcmd(12, purgemode);
  }
#line 1449
  if (Nvt.state == 1) {
    {
#line 1450
    Nvt.state = 5;
#line 1450
    print_nvtstate((char const   */* const  */)"do_nvtflush");
    }
  } else {
    {
#line 1452
    Nvt.state = 6;
#line 1452
    print_nvtstate((char const   */* const  */)"do_nvtflush");
    }
  }
#line 1454
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 1456
  do_nvterror((char const   */* const  */)"do_nvtflush");
  }
#line 1457
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1459
  return;
}
}
#line 1466 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
char debugbuf[128]  ;
#line 1468 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
char *tsr_states(char const   * const  unused ) 
{ 
  char const   *pstate ;
  char const   *psubstate ;
  char const   *nstate ;
  char const   *nsubstate ;

  {
#line 1474
  pstate = (char const   *)Pty_states[Pty.state].stname;
#line 1476
  if (Pty_states[Pty.state].subnames) {
#line 1477
    psubstate = (char const   *)*(Pty_states[Pty.state].subnames + Pty.substate);
  } else {
#line 1479
    psubstate = "NONE";
  }
#line 1483
  nstate = (char const   *)Nvt_states[Nvt.state].stname;
#line 1485
  if (Nvt_states[Nvt.state].subnames) {
#line 1486
    nsubstate = (char const   *)*(Nvt_states[Nvt.state].subnames + Nvt.substate);
  } else {
#line 1488
    nsubstate = "NONE";
  }
  {
#line 1491
  sprintf((char */* __restrict  */)(debugbuf), (char const   */* __restrict  */)"%s %s -- %s %s\n",
          pstate, psubstate, nstate, nsubstate);
  }
#line 1493
  return (debugbuf);
}
}
#line 1497 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void print_ptystate(char const   * const  hand ) 
{ 
  char const   *state ;
  char const   *substate ;

  {
#line 1502
  if (Debug > 0) {
#line 1503
    state = (char const   *)Pty_states[Pty.state].stname;
#line 1505
    if (Pty_states[Pty.state].subnames) {
#line 1506
      substate = (char const   *)*(Pty_states[Pty.state].subnames + Pty.substate);
    } else {
#line 1508
      substate = "NONE";
    }
    {
#line 1511
    sysmessage(0, (char const   */* const  */)"PTYSTATE (%s): %s %s\n", hand, state,
               substate);
    }
  }
#line 1513
  return;
}
}
#line 1515 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void print_nvtstate(char const   * const  hand ) 
{ 
  char const   *state ;
  char const   *substate ;

  {
#line 1520
  if (Debug > 0) {
#line 1521
    state = (char const   *)Nvt_states[Nvt.state].stname;
#line 1523
    if (Nvt_states[Nvt.state].subnames) {
#line 1524
      substate = (char const   *)*(Nvt_states[Nvt.state].subnames + Nvt.substate);
    } else {
#line 1526
      substate = "NONE";
    }
    {
#line 1529
    sysmessage(0, (char const   */* const  */)"NVTSTATE (%s): %s %s\n", hand, state,
               substate);
    }
  }
#line 1531
  return;
}
}
#line 1533 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void print_action(char const   * const  hand ) 
{ 


  {
#line 1536
  if (Debug > 1) {
    {
#line 1537
    sysmessage(0, (char const   */* const  */)"ACTION %s\n", hand);
    }
  }
#line 1538
  return;
}
}
#line 1541 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/tsrio.c"
void print_event(struct event *evp ) 
{ 
  unsigned char *cp ;
  char const   *type ;
  char const   *name ;

  {
#line 1548
  if (Debug > 1) {
    {
#line 1552
    if (evp->ev_type == 1) {
#line 1552
      goto case_1;
    }
#line 1556
    if (evp->ev_type == 2) {
#line 1556
      goto case_2;
    }
#line 1560
    goto switch_default;
    case_1: /* CIL Label */ 
#line 1553
    type = "EV_UP";
#line 1554
    name = (char const   *)Pty_events[evp->ev_code];
#line 1555
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1557
    type = "EV_RN";
#line 1558
    name = (char const   *)Nvt_events[evp->ev_code];
#line 1559
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1561
    type = "EV_UNK";
#line 1562
    name = "UNKNOWN";
#line 1563
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1565
    if (evp->ev_param) {
      {
#line 1567
      cp = (unsigned char *)evp->ev_param;
#line 1568
      sprintf((char */* __restrict  */)(debugbuf), (char const   */* __restrict  */)"%02X %02X %02X %02X",
              (int )*cp, (int )*(cp + 1), (int )*(cp + 2), (int )*(cp + 3));
#line 1570
      sysmessage(0, (char const   */* const  */)"EVENT %s %s, size %d: %s\n", type,
                 name, evp->ev_size, debugbuf);
      }
    } else {
      {
#line 1575
      sysmessage(0, (char const   */* const  */)"EVENT %s %s\n", type, name);
      }
    }
  }
#line 1579
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrmeasure.h"
int devreads  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrmeasure.h"
int devnreads  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrmeasure.h"
int devwrites  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrmeasure.h"
int devnwrites  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrmeasure.h"
int netreads  ;
#line 29 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrmeasure.h"
int netnreads  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrmeasure.h"
int netwrites  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrmeasure.h"
int netnwrites  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrmeasure.h"
int devrbytes  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrmeasure.h"
int devwbytes  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrmeasure.h"
int netrbytes  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrmeasure.h"
int netwbytes  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/tsrmeasure.h"
int ioscheds  ;
#line 226 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 53
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/sock.h"
int sock_getaddr(char *host , int base , int physport ) ;
#line 22
int sock_link(int iosize ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/sock.h"
int S_fd  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/sock.c"
struct sockaddr_in S_inaddr  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/sock.c"
int sock_getaddr(char *host , int base , int physport ) 
{ 
  struct sockaddr_in *sp ;
  struct hostent *hp ;
  int tcpport ;
  in_addr_t tmp ;
  char *tmp___0 ;

  {
  {
#line 51
  sp = & S_inaddr;
#line 55
  hp = gethostbyname((char const   *)host);
  }
#line 55
  if ((unsigned long )hp != (unsigned long )((struct hostent *)((void *)0))) {
    {
#line 56
    memcpy((void */* __restrict  */)((char *)(& sp->sin_addr)), (void const   */* __restrict  */)*(hp->h_addr_list + 0),
           (size_t )hp->h_length);
#line 57
    sp->sin_family = (sa_family_t )hp->h_addrtype;
    }
  } else {
    {
#line 58
    tmp = inet_addr((char const   *)host);
#line 58
    sp->sin_addr.s_addr = tmp;
    }
#line 58
    if (tmp != 4294967295U) {
#line 59
      sp->sin_family = (sa_family_t )2;
    } else {
      {
#line 61
      sysmessage(4, (char const   */* const  */)"%s: No such host\n", host);
      }
#line 63
      return (2);
    }
  }
  {
#line 66
  tcpport = base + physport;
#line 68
  sp->sin_port = htons((uint16_t )tcpport);
#line 70
  tmp___0 = inet_ntoa(sp->sin_addr);
#line 70
  sysmessage(2, (char const   */* const  */)"Using %s:%d socket\n", tmp___0, tcpport);
  }
#line 73
  return (0);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/sock.c"
int sock_link(int iosize ) 
{ 
  int fd ;
  struct sockaddr_in *sp ;
  int flag ;
  char dummy[4] ;
  int bufsize ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  ssize_t tmp___16 ;

  {
  {
#line 82
  sp = & S_inaddr;
#line 87
  fd = socket(2, 1, 6);
  }
#line 87
  if (fd == -1) {
    {
#line 88
    tmp = __errno_location();
#line 88
    tmp___0 = strerror(*tmp);
#line 88
    sysmessage(4, (char const   */* const  */)"Can\'t create a socket for communication : %s\n",
               tmp___0);
    }
#line 91
    return (1);
  }
  {
#line 94
  bufsize = 2 * iosize;
#line 96
  tmp___3 = setsockopt(fd, 1, 7, (void const   *)(& bufsize), (socklen_t )sizeof(int ));
  }
#line 96
  if (tmp___3 == -1) {
    {
#line 98
    tmp___1 = __errno_location();
#line 98
    tmp___2 = strerror(*tmp___1);
#line 98
    sysmessage(4, (char const   */* const  */)"Can\'t set socket buffer size : %s\n",
               tmp___2);
    }
#line 100
    return (1);
  }
  {
#line 102
  tmp___6 = connect(fd, (struct sockaddr  const  *)((struct sockaddr *)sp), (socklen_t )sizeof(struct sockaddr_in ));
  }
#line 102
  if (tmp___6 == -1) {
    {
#line 104
    tmp___4 = __errno_location();
#line 104
    tmp___5 = strerror(*tmp___4);
#line 104
    sysmessage(3, (char const   */* const  */)"Can\'t initiate connection on a socket : %s\n",
               tmp___5);
#line 107
    close(fd);
    }
#line 108
    return (4);
  }
  {
#line 121
  flag = fcntl(fd, 3, 0);
  }
#line 121
  if (flag == -1) {
    {
#line 122
    tmp___7 = __errno_location();
#line 122
    tmp___8 = strerror(*tmp___7);
#line 122
    sysmessage(4, (char const   */* const  */)"Can\'t get file flags of a socket : %s\n",
               tmp___8);
#line 125
    close(fd);
    }
#line 126
    return (1);
  }
  {
#line 131
  flag |= 2048;
#line 136
  tmp___11 = fcntl(fd, 4, flag);
  }
#line 136
  if (tmp___11 == -1) {
    {
#line 137
    tmp___9 = __errno_location();
#line 137
    tmp___10 = strerror(*tmp___9);
#line 137
    sysmessage(4, (char const   */* const  */)"Can\'t set file flags of a socket : %s\n",
               tmp___10);
#line 140
    close(fd);
    }
#line 141
    return (1);
  }
  {
#line 144
  sysdelay(1000);
#line 146
  tmp___16 = recv(fd, (void *)(dummy), (size_t )0, 0);
  }
#line 146
  if (tmp___16 == -1L) {
    {
#line 147
    tmp___14 = __errno_location();
    }
#line 147
    if (*tmp___14 != 11) {
      {
#line 147
      tmp___15 = __errno_location();
      }
#line 147
      if (*tmp___15 != 11) {
        {
#line 148
        tmp___12 = __errno_location();
#line 148
        tmp___13 = strerror(*tmp___12);
#line 148
        sysmessage(3, (char const   */* const  */)"Can\'t initiate connection on a socket : (recv) %s\n",
                   tmp___13);
#line 151
        close(fd);
        }
#line 152
        return (4);
      }
    }
  }
#line 155
  S_fd = fd;
#line 156
  return (0);
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/sock.c"
int sock_unlink(void) 
{ 


  {
  {
#line 162
  close(S_fd);
  }
#line 164
  return (0);
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/sock.c"
int sock_write(unsigned char *buf , int n ) 
{ 
  int ret ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  ssize_t tmp___3 ;

  {
  {
#line 177
  tmp___3 = send(S_fd, (void const   *)buf, (size_t )n, 0);
#line 177
  ret = (int )tmp___3;
  }
#line 177
  if (ret < 0) {
    {
#line 178
    tmp___1 = __errno_location();
    }
#line 178
    if (*tmp___1 == 11) {
#line 179
      ret = 0;
    } else {
      {
#line 178
      tmp___2 = __errno_location();
      }
#line 178
      if (*tmp___2 == 11) {
#line 179
        ret = 0;
      } else {
        {
#line 181
        tmp = __errno_location();
#line 181
        tmp___0 = strerror(*tmp);
#line 181
        sysmessage(4, (char const   */* const  */)"send : %s\n", tmp___0);
        }
      }
    }
  }
#line 194
  return (ret);
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/sock.c"
int sock_read(unsigned char *buf , int n ) 
{ 
  register int ret ;
  int tot ;
  int rcnt ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 204
  rcnt = 0;
#line 204
  tot = rcnt;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 207
    tmp___3 = recv(S_fd, (void *)buf, (size_t )n, 0);
#line 207
    ret = (int )tmp___3;
    }
#line 207
    if (ret > 0) {
#line 208
      tot += ret;
#line 209
      buf += ret;
#line 210
      n -= ret;
    } else
#line 226
    if (ret < 0) {
      {
#line 227
      tmp___1 = __errno_location();
      }
#line 227
      if (*tmp___1 == 11) {
#line 228
        ret = 0;
      } else {
        {
#line 227
        tmp___2 = __errno_location();
        }
#line 227
        if (*tmp___2 == 11) {
#line 228
          ret = 0;
        } else {
          {
#line 230
          tmp = __errno_location();
#line 230
          tmp___0 = strerror(*tmp);
#line 230
          sysmessage(4, (char const   */* const  */)"recv : %s\n", tmp___0);
          }
        }
      }
    }
#line 206
    if (n > 0) {
#line 206
      if (! (ret > 0)) {
#line 206
        goto while_break;
      }
    } else {
#line 206
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  if (ret >= 0) {
#line 241
    ret = tot;
  }
#line 244
  return (ret);
}
}
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 937 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) daemon)(int __nochdir ,
                                                                             int __noclose ) ;
#line 110 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/cyclades-ser-cli.h"
char *Pgname  ;
#line 111 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/cyclades-ser-cli.h"
int Debug  ;
#line 112 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/cyclades-ser-cli.h"
int Console  ;
#line 113 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/inc/cyclades-ser-cli.h"
int Foreground  ;
#line 123 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/cyclades-ser-cli.c"
static char const   * const  Version  =    (char const   */* const  */)"cyclades-ser-cli 0.92 Wed Mar  2 23:58:14 KST 2016";
#line 56
static void helpmsg(void) ;
#line 57
static void mkidmsg(char *pgname , char *device ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/cyclades-ser-cli.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  char *device ;
  char *rasname ;
  int physport ;
  int ptyiosize ;
  int netiosize ;
  int retrydelay ;
  int retry ;
  int nretries ;
  int opt ;
  int retst ;
  int devmodem ;
  int closemode ;
  int baseport ;
  struct sockaddr_un control_addr ;
  struct sigaction act ;
  struct stat stat_buf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 78
  act.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 79
  tmp = sigaction(13, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 79
  if (tmp) {
    {
#line 80
    sysmessage(4, (char const   */* const  */)"Can\'t block SIGPIPE.\n");
    }
  }
#line 82
  ptyiosize = 1024;
#line 83
  netiosize = 128;
#line 84
  retrydelay = 15000;
#line 85
  nretries = 2147483647;
#line 86
  Nvt.servertype = 0;
#line 87
  devmodem = 0;
#line 88
  closemode = 0;
#line 89
  baseport = 0;
#line 91
  Console = 0;
#line 92
  Foreground = 0;
#line 94
  Pgname = *(argv + 0);
#line 95
  Debug = 0;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    opt = getopt(argc, (char * const  *)argv, "u:n:r:fi:st:m:c:p:d:xvhH");
    }
#line 97
    if (! (opt != -1)) {
#line 97
      goto while_break;
    }
    {
#line 99
    if (opt == 117) {
#line 99
      goto case_117;
    }
#line 105
    if (opt == 110) {
#line 105
      goto case_110;
    }
#line 111
    if (opt == 114) {
#line 111
      goto case_114;
    }
#line 114
    if (opt == 102) {
#line 114
      goto case_102;
    }
#line 117
    if (opt == 105) {
#line 117
      goto case_105;
    }
#line 120
    if (opt == 115) {
#line 120
      goto case_115;
    }
#line 125
    if (opt == 109) {
#line 125
      goto case_109;
    }
#line 128
    if (opt == 99) {
#line 128
      goto case_99;
    }
#line 131
    if (opt == 112) {
#line 131
      goto case_112;
    }
#line 134
    if (opt == 100) {
#line 134
      goto case_100;
    }
#line 137
    if (opt == 120) {
#line 137
      goto case_120;
    }
#line 141
    if (opt == 118) {
#line 141
      goto case_118;
    }
#line 146
    goto switch_default;
    case_117: /* CIL Label */ 
    {
#line 100
    ptyiosize = atoi((char const   *)optarg);
    }
#line 101
    if (ptyiosize > 32768) {
#line 102
      ptyiosize = 32768;
    }
#line 104
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 106
    netiosize = atoi((char const   *)optarg);
    }
#line 107
    if (netiosize > 16384) {
#line 108
      netiosize = 16384;
    }
#line 110
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 112
    nretries = atoi((char const   *)optarg);
    }
#line 113
    goto switch_break;
    case_102: /* CIL Label */ 
#line 115
    Foreground = 1;
#line 116
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 118
    tmp___0 = atoi((char const   *)optarg);
#line 118
    retrydelay = tmp___0 * 1000;
    }
#line 119
    goto switch_break;
    case_115: /* CIL Label */ 
#line 121
    Nvt.servertype = 1;
#line 122
    if (! baseport) {
#line 123
      baseport = 31000;
    }
#line 124
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 126
    devmodem = atoi((char const   *)optarg);
    }
#line 127
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 129
    closemode = atoi((char const   *)optarg);
    }
#line 130
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 132
    baseport = atoi((char const   *)optarg);
    }
#line 133
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 135
    Debug = atoi((char const   *)optarg);
    }
#line 136
    goto switch_break;
    case_120: /* CIL Label */ 
#line 138
    Console = 1;
#line 139
    Foreground = 1;
#line 140
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 142
    printf((char const   */* __restrict  */)"%s\n", Version);
#line 143
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 147
    helpmsg();
#line 148
    exit(2);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  if (! baseport) {
#line 152
    baseport = 30000;
  }
#line 154
  argc -= optind;
#line 155
  argv += optind;
#line 157
  if (argc != 3) {
    {
#line 158
    helpmsg();
#line 159
    exit(2);
    }
  }
  {
#line 162
  device = *(argv + 0);
#line 164
  mkidmsg(Pgname, device);
#line 166
  tmp___1 = strncmp((char const   *)device, "/dev/", (size_t )5);
  }
#line 166
  if (tmp___1 != 0) {
    {
#line 167
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Warning, device does not have a \"/dev\" prefix\n",
            Idmsg);
    }
  }
  {
#line 169
  rasname = *(argv + 1);
#line 171
  physport = atoi((char const   *)*(argv + 2));
  }
#line 173
  if (physport == 0) {
#line 174
    if (Nvt.servertype == 0) {
#line 175
      baseport = 23;
    } else {
      {
#line 177
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Physical port must be > 0 for socket service\n",
              Idmsg);
#line 179
      exit(2);
      }
    }
  }
  {
#line 183
  init_system();
#line 187
  retst = dev_getaddr(device);
  }
#line 187
  if (retst != 0) {
    {
#line 188
    exit(retst);
    }
  }
#line 191
  if (Nvt.servertype == 0) {
    {
#line 193
    P_contr_listen = socket(1, 1, 0);
    }
#line 194
    if (P_contr_listen == -1) {
      {
#line 196
      sysmessage(4, (char const   */* const  */)"Can\'t create Unix socket.\n");
#line 197
      exit(1);
      }
    }
    {
#line 199
    control_addr.sun_family = (sa_family_t )1;
#line 200
    snprintf((char */* __restrict  */)(P_contrname), sizeof(P_contrname), (char const   */* __restrict  */)"%s.control",
             device);
#line 201
    P_contrname[sizeof(P_contrname) - 1UL] = (char )'\000';
#line 202
    tmp___2 = stat((char const   */* __restrict  */)(P_contrname), (struct stat */* __restrict  */)(& stat_buf));
    }
#line 202
    if (! tmp___2) {
      {
#line 204
      sysmessage(3, (char const   */* const  */)"Removing old control socket \"%s\".\n",
                 P_contrname);
#line 205
      unlink((char const   *)(P_contrname));
      }
    }
    {
#line 207
    strcpy((char */* __restrict  */)(control_addr.sun_path), (char const   */* __restrict  */)(P_contrname));
#line 208
    tmp___3 = bind(P_contr_listen, (struct sockaddr  const  *)((struct sockaddr *)(& control_addr)),
                   (socklen_t )sizeof(control_addr));
    }
#line 208
    if (tmp___3) {
      {
#line 211
      sysmessage(4, (char const   */* const  */)"Can\'t bind Unix socket.\n");
#line 212
      exit(1);
      }
    } else {
      {
#line 208
      tmp___4 = listen(P_contr_listen, 8);
      }
#line 208
      if (tmp___4) {
        {
#line 211
        sysmessage(4, (char const   */* const  */)"Can\'t bind Unix socket.\n");
#line 212
        exit(1);
        }
      }
    }
#line 214
    i = 0;
    {
#line 214
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 214
      if (! (i < 32)) {
#line 214
        goto while_break___0;
      }
#line 215
      P_contr[i] = -1;
#line 214
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 218
  retst = sock_getaddr(rasname, baseport, physport);
  }
#line 218
  if (retst != 0) {
    {
#line 219
    exit(retst);
    }
  }
#line 222
  retry = 0;
#line 224
  if (! Foreground) {
    {
#line 225
    daemon(0, 0);
    }
  }
  {
#line 227
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 227
    if (! (retry < nretries)) {
#line 227
      goto while_break___1;
    }
#line 229
    if (retry) {
#line 230
      if (retrydelay) {
        {
#line 231
        sysdelay(retrydelay);
        }
      }
      {
#line 233
      sysmessage(3, (char const   */* const  */)"Trying again ... \n");
      }
    }
    {
#line 237
    retst = sock_link(netiosize);
    }
#line 237
    if (retst != 0) {
#line 238
      if (retst != 4) {
        {
#line 239
        doexit(retst);
        }
      }
#line 241
      retry ++;
#line 242
      goto while_continue___1;
    }
    {
#line 245
    retry = 0;
#line 247
    tsr_init(netiosize, ptyiosize, devmodem, closemode);
#line 251
    tsr_io();
#line 253
    retry ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 256
  sysmessage(4, (char const   */* const  */)"Exiting ...\n");
#line 258
  doexit(5);
  }
#line 261
  return (0);
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/cyclades-ser-cli.c"
static void helpmsg(void) 
{ 


  {
  {
#line 267
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: cyclades-ser-cli [options] devname rasname physport\n");
#line 268
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\toptions:\n");
#line 269
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t[-h] [-v] [-x]\n");
#line 270
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t[-u ptyiosize]  [-n netiosize] [-i retrydelay]\n");
#line 271
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t[-r numretries] [-t devtype]   [-s servertype]\n");
#line 272
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t[-m devmodem]   [-c closemode] [-p startport]\n");
#line 273
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t[-d deblevel]\n");
  }
#line 274
  return;
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/cyclades-serial-client-0.92ubuntu2/cyclades-ser-cli.c"
static void mkidmsg(char *pgname , char *device ) 
{ 
  char *cp ;

  {
  {
#line 281
  cp = strrchr((char const   *)pgname, '/');
  }
#line 281
  if ((unsigned long )cp != (unsigned long )((char *)((void *)0))) {
#line 282
    cp ++;
  } else {
#line 284
    cp = pgname;
  }
  {
#line 286
  Pgname = cp;
#line 287
  sprintf((char */* __restrict  */)(Idmsg), (char const   */* __restrict  */)"%7s %s",
          cp, device);
  }
#line 288
  return;
}
}
