/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 128 "/usr/lib/ocaml/caml/config.h"
typedef long intnat;
#line 58 "/usr/lib/ocaml/caml/mlvalues.h"
typedef intnat value;
#line 49 "/usr/lib/ocaml/caml/memory.h"
struct caml__roots_block {
   struct caml__roots_block *next ;
   intnat ntables ;
   intnat nitems ;
   value *tables[5] ;
};
#line 94 "/usr/lib/ocaml/caml/config.h"
typedef int int32;
#line 123 "/usr/lib/ocaml/caml/config.h"
typedef long long int64;
#line 129 "/usr/lib/ocaml/caml/config.h"
typedef unsigned long uintnat;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_9 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_9 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 60 "/usr/lib/ocaml/caml/mlvalues.h"
typedef uintnat mlsize_t;
#line 261
struct custom_operations;
#line 23 "/usr/lib/ocaml/caml/custom.h"
struct custom_operations {
   char *identifier ;
   void (*finalize)(value v ) ;
   int (*compare)(value v1 , value v2 ) ;
   intnat (*hash)(value v ) ;
   void (*serialize)(value v , uintnat *wsize_32 , uintnat *wsize_64 ) ;
   uintnat (*deserialize)(void *dst ) ;
   int (*compare_ext)(value v1 , value v2 ) ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 28 "/usr/include/x86_64-linux-gnu/sys/signalfd.h"
struct signalfd_siginfo {
   uint32_t ssi_signo ;
   int32_t ssi_errno ;
   int32_t ssi_code ;
   uint32_t ssi_pid ;
   uint32_t ssi_uid ;
   int32_t ssi_fd ;
   uint32_t ssi_tid ;
   uint32_t ssi_band ;
   uint32_t ssi_overrun ;
   uint32_t ssi_trapno ;
   int32_t ssi_status ;
   int32_t ssi_int ;
   uint64_t ssi_ptr ;
   uint64_t ssi_utime ;
   uint64_t ssi_stime ;
   uint64_t ssi_addr ;
   uint8_t __pad[48] ;
};
#line 137 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 104 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 59 "/usr/lib/ocaml/caml/mlvalues.h"
typedef uintnat header_t;
#line 61 "/usr/lib/ocaml/caml/mlvalues.h"
typedef unsigned int tag_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim64_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 292
enum __priority_which {
    PRIO_PROCESS = 0,
    PRIO_PGRP = 1,
    PRIO_USER = 2
} ;
#line 38 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef enum __rlimit_resource __rlimit_resource_t;
#line 40 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef enum __priority_which __priority_which_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 194 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef signed char int8_t;
#line 195 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef short int16_t;
#line 197 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long int64_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 31 "/usr/lib/ocaml/caml/misc.h"
typedef size_t asize_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/sys/eventfd.h"
typedef uint64_t eventfd_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char domainname[65] ;
};
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 88 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off64_t off_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 73 "/usr/lib/ocaml/caml/bigarray.h"
struct caml_ba_proxy {
   intnat refcount ;
   void *data ;
   uintnat size ;
};
#line 79 "/usr/lib/ocaml/caml/bigarray.h"
struct caml_ba_array {
   void *data ;
   intnat num_dims ;
   intnat flags ;
   struct caml_ba_proxy *proxy ;
   intnat dim[1] ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 311 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct ucred {
   pid_t pid ;
   uid_t uid ;
   gid_t gid ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 163 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 29 "/usr/include/x86_64-linux-gnu/bits/statvfs.h"
struct statvfs {
   unsigned long f_bsize ;
   unsigned long f_frsize ;
   __fsblkcnt64_t f_blocks ;
   __fsblkcnt64_t f_bfree ;
   __fsblkcnt64_t f_bavail ;
   __fsfilcnt64_t f_files ;
   __fsfilcnt64_t f_ffree ;
   __fsfilcnt64_t f_favail ;
   unsigned long f_fsid ;
   unsigned long f_flag ;
   unsigned long f_namemax ;
   int __f_spare[6] ;
};
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 224 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 242 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
};
#line 35 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/sendmsg.c"
int sendfd___0 ;
#line 35 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/sendmsg.c"
union __anonunion_control_un_29 {
   struct cmsghdr cmsg ;
   char control[(((sizeof(sendfd___0) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))] ;
};
#line 88
int recvfd___0 ;
#line 88 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/sendmsg.c"
union __anonunion_control_un_30 {
   struct cmsghdr cmsg ;
   char control[(((sizeof(recvfd___0) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))] ;
};
#line 93 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off64_t off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 28 "/usr/include/x86_64-linux-gnu/sys/ptrace.h"
enum __ptrace_request {
    PTRACE_TRACEME = 0,
    PTRACE_PEEKTEXT = 1,
    PTRACE_PEEKDATA = 2,
    PTRACE_PEEKUSER = 3,
    PTRACE_POKETEXT = 4,
    PTRACE_POKEDATA = 5,
    PTRACE_POKEUSER = 6,
    PTRACE_CONT = 7,
    PTRACE_KILL = 8,
    PTRACE_SINGLESTEP = 9,
    PTRACE_GETREGS = 12,
    PTRACE_SETREGS = 13,
    PTRACE_GETFPREGS = 14,
    PTRACE_SETFPREGS = 15,
    PTRACE_ATTACH = 16,
    PTRACE_DETACH = 17,
    PTRACE_GETFPXREGS = 18,
    PTRACE_SETFPXREGS = 19,
    PTRACE_SYSCALL = 24,
    PTRACE_SETOPTIONS = 16896,
    PTRACE_GETEVENTMSG = 16897,
    PTRACE_GETSIGINFO = 16898,
    PTRACE_SETSIGINFO = 16899,
    PTRACE_GETREGSET = 16900,
    PTRACE_SETREGSET = 16901,
    PTRACE_SEIZE = 16902,
    PTRACE_INTERRUPT = 16903,
    PTRACE_LISTEN = 16904,
    PTRACE_PEEKSIGINFO = 16905
} ;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_31 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_32 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_31 ifr_ifrn ;
   union __anonunion_ifr_ifru_32 ifr_ifru ;
};
#line 176 "/usr/include/net/if.h"
union __anonunion_ifc_ifcu_33 {
   __caddr_t ifcu_buf ;
   struct ifreq *ifcu_req ;
};
#line 176 "/usr/include/net/if.h"
struct ifconf {
   int ifc_len ;
   union __anonunion_ifc_ifcu_33 ifc_ifcu ;
};
#line 29 "/usr/include/ifaddrs.h"
union __anonunion_ifa_ifu_34 {
   struct sockaddr *ifu_broadaddr ;
   struct sockaddr *ifu_dstaddr ;
};
#line 29 "/usr/include/ifaddrs.h"
struct ifaddrs {
   struct ifaddrs *ifa_next ;
   char *ifa_name ;
   unsigned int ifa_flags ;
   struct sockaddr *ifa_addr ;
   struct sockaddr *ifa_netmask ;
   union __anonunion_ifa_ifu_34 ifa_ifu ;
   void *ifa_data ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
#line 588
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unsetenv)(char const   *__name ) ;
#line 595
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clearenv)(void) ;
#line 645
extern int ( __attribute__((__nonnull__(1))) mkstemps)(char *__template , int __suffixlen )  __asm__("mkstemps64")  ;
#line 663
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) mkdtemp)(char *__template ) ;
#line 698
extern int ( __attribute__((__nonnull__(1))) mkostemps)(char *__template , int __suffixlen ,
                                                        int __flags )  __asm__("mkostemps64")  ;
#line 734
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) realpath)(char const   * __restrict  __name ,
                                                                                 char * __restrict  __resolved ) ;
#line 56 "/usr/lib/ocaml/caml/memory.h"
extern struct caml__roots_block *caml_local_roots ;
#line 30 "/usr/lib/ocaml/caml/unixsupport.h"
extern  __attribute__((__noreturn__)) void uerror(char *cmdname , value arg ) ;
#line 28 "/usr/lib/ocaml/caml/signals.h"
extern void caml_enter_blocking_section(void) ;
#line 29
extern void caml_leave_blocking_section(void) ;
#line 32 "/usr/lib/ocaml/caml/alloc.h"
extern value caml_copy_string(char const   * ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/stdlib.c"
value caml_extunix_realpath(value v_path ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_path ;
  int caml__dummy_v_path  __attribute__((__unused__)) ;
  value v_s ;
  struct caml__roots_block caml__roots_v_s ;
  int caml__dummy_v_s  __attribute__((__unused__)) ;
  char *path ;
  char *tmp ;
  value caml__temp_result ;

  {
  {
#line 14
  caml__frame = caml_local_roots;
#line 14
  caml__roots_v_path.next = caml_local_roots;
#line 14
  caml_local_roots = & caml__roots_v_path;
#line 14
  caml__roots_v_path.nitems = (intnat )1;
#line 14
  caml__roots_v_path.ntables = (intnat )1;
#line 14
  caml__roots_v_path.tables[0] = & v_path;
#line 14
  caml__dummy_v_path = 0;
#line 15
  v_s = 1L;
#line 15
  caml__roots_v_s.next = caml_local_roots;
#line 15
  caml_local_roots = & caml__roots_v_s;
#line 15
  caml__roots_v_s.nitems = (intnat )1;
#line 15
  caml__roots_v_s.ntables = (intnat )1;
#line 15
  caml__roots_v_s.tables[0] = & v_s;
#line 15
  caml__dummy_v_s = 0;
#line 17
  tmp = realpath((char const   */* __restrict  */)((char *)v_path), (char */* __restrict  */)((void *)0));
#line 17
  path = tmp;
  }
#line 18
  if ((unsigned long )((void *)0) == (unsigned long )path) {
    {
#line 20
    uerror((char *)"realpath", v_path);
    }
  }
  {
#line 23
  v_s = caml_copy_string((char const   *)path);
#line 24
  free((void *)path);
  }
  {
#line 26
  while (1) {
    while_continue: /* CIL Label */ ;
#line 26
    caml__temp_result = v_s;
#line 26
    caml_local_roots = caml__frame;
#line 26
    return (caml__temp_result);
#line 26
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 27
  return (0L);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/stdlib.c"
value caml_extunix_setenv(value v_name , value v_val , value v_overwrite ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_name ;
  int caml__dummy_v_name  __attribute__((__unused__)) ;
  int tmp ;
  value caml__temp_result ;

  {
  {
#line 60
  caml__frame = caml_local_roots;
#line 60
  caml__roots_v_name.next = caml_local_roots;
#line 60
  caml_local_roots = & caml__roots_v_name;
#line 60
  caml__roots_v_name.nitems = (intnat )1;
#line 60
  caml__roots_v_name.ntables = (intnat )3;
#line 60
  caml__roots_v_name.tables[0] = & v_name;
#line 60
  caml__roots_v_name.tables[1] = & v_val;
#line 60
  caml__roots_v_name.tables[2] = & v_overwrite;
#line 60
  caml__dummy_v_name = 0;
#line 62
  tmp = setenv((char const   *)((char *)v_name), (char const   *)((char *)v_val),
               (int )(v_overwrite >> 1));
  }
#line 62
  if (0 != tmp) {
    {
#line 64
    uerror((char *)"setenv", v_name);
    }
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    caml__temp_result = 1L;
#line 67
    caml_local_roots = caml__frame;
#line 67
    return (caml__temp_result);
#line 67
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  return (0L);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/stdlib.c"
value caml_extunix_unsetenv(value v_name ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_name ;
  int caml__dummy_v_name  __attribute__((__unused__)) ;
  int tmp ;
  value caml__temp_result ;

  {
  {
#line 72
  caml__frame = caml_local_roots;
#line 72
  caml__roots_v_name.next = caml_local_roots;
#line 72
  caml_local_roots = & caml__roots_v_name;
#line 72
  caml__roots_v_name.nitems = (intnat )1;
#line 72
  caml__roots_v_name.ntables = (intnat )1;
#line 72
  caml__roots_v_name.tables[0] = & v_name;
#line 72
  caml__dummy_v_name = 0;
#line 74
  tmp = unsetenv((char const   *)((char *)v_name));
  }
#line 74
  if (0 != tmp) {
    {
#line 76
    uerror((char *)"unsetenv", v_name);
    }
  }
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    caml__temp_result = 1L;
#line 79
    caml_local_roots = caml__frame;
#line 79
    return (caml__temp_result);
#line 79
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return (0L);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/stdlib.c"
value caml_extunix_clearenv(value v_unit ) 
{ 
  int tmp ;

  {
  {
#line 89
  tmp = clearenv();
  }
#line 89
  if (0 != tmp) {
    {
#line 91
    uerror((char *)"clearenv", (value )0);
    }
  }
#line 94
  return (1L);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/stdlib.c"
value caml_extunix_mkdtemp(value v_path ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_path ;
  int caml__dummy_v_path  __attribute__((__unused__)) ;
  char *path ;
  char *tmp ;
  char *ret ;
  value caml__temp_result ;

  {
  {
#line 103
  caml__frame = caml_local_roots;
#line 103
  caml__roots_v_path.next = caml_local_roots;
#line 103
  caml_local_roots = & caml__roots_v_path;
#line 103
  caml__roots_v_path.nitems = (intnat )1;
#line 103
  caml__roots_v_path.ntables = (intnat )1;
#line 103
  caml__roots_v_path.tables[0] = & v_path;
#line 103
  caml__dummy_v_path = 0;
#line 104
  tmp = strdup((char const   *)((char *)v_path));
#line 104
  path = tmp;
#line 106
  caml_enter_blocking_section();
#line 107
  ret = mkdtemp(path);
#line 108
  caml_leave_blocking_section();
  }
#line 109
  if ((unsigned long )((void *)0) == (unsigned long )ret) {
    {
#line 111
    free((void *)path);
#line 112
    uerror((char *)"mkdtemp", v_path);
    }
  }
  {
#line 114
  v_path = caml_copy_string((char const   *)ret);
#line 115
  free((void *)path);
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    caml__temp_result = v_path;
#line 116
    caml_local_roots = caml__frame;
#line 116
    return (caml__temp_result);
#line 116
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  return (0L);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/stdlib.c"
value caml_extunix_internal_mkstemps(value v_template , value v_suffixlen ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_template ;
  int caml__dummy_v_template  __attribute__((__unused__)) ;
  char *template ;
  int suffixlen ;
  int ret ;
  value caml__temp_result ;

  {
  {
#line 125
  caml__frame = caml_local_roots;
#line 125
  caml__roots_v_template.next = caml_local_roots;
#line 125
  caml_local_roots = & caml__roots_v_template;
#line 125
  caml__roots_v_template.nitems = (intnat )1;
#line 125
  caml__roots_v_template.ntables = (intnat )2;
#line 125
  caml__roots_v_template.tables[0] = & v_template;
#line 125
  caml__roots_v_template.tables[1] = & v_suffixlen;
#line 125
  caml__dummy_v_template = 0;
#line 126
  template = (char *)v_template;
#line 127
  suffixlen = (int )(v_suffixlen >> 1);
#line 130
  ret = mkstemps(template, suffixlen);
  }
#line 131
  if (ret == -1) {
    {
#line 133
    uerror((char *)"mkstemps", v_template);
    }
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    caml__temp_result = ((intnat )ret << 1) + 1L;
#line 135
    caml_local_roots = caml__frame;
#line 135
    return (caml__temp_result);
#line 135
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  return (0L);
}
}
#line 2 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/common.h"
int extunix_open_flags(value v_flags ) ;
#line 151 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/stdlib.c"
value caml_extunix_internal_mkostemps(value v_template , value v_suffixlen , value v_flags ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_template ;
  int caml__dummy_v_template  __attribute__((__unused__)) ;
  char *template ;
  int flags ;
  int tmp ;
  int suffixlen ;
  int ret ;
  value caml__temp_result ;

  {
  {
#line 153
  caml__frame = caml_local_roots;
#line 153
  caml__roots_v_template.next = caml_local_roots;
#line 153
  caml_local_roots = & caml__roots_v_template;
#line 153
  caml__roots_v_template.nitems = (intnat )1;
#line 153
  caml__roots_v_template.ntables = (intnat )3;
#line 153
  caml__roots_v_template.tables[0] = & v_template;
#line 153
  caml__roots_v_template.tables[1] = & v_suffixlen;
#line 153
  caml__roots_v_template.tables[2] = & v_flags;
#line 153
  caml__dummy_v_template = 0;
#line 154
  template = (char *)v_template;
#line 155
  tmp = extunix_open_flags(v_flags);
#line 155
  flags = tmp | 524288;
#line 156
  suffixlen = (int )(v_suffixlen >> 1);
#line 159
  ret = mkostemps(template, suffixlen, flags);
  }
#line 160
  if (ret == -1) {
    {
#line 162
    uerror((char *)"mkostemps", v_template);
    }
  }
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    caml__temp_result = ((intnat )ret << 1) + 1L;
#line 164
    caml_local_roots = caml__frame;
#line 164
    return (caml__temp_result);
#line 164
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return (0L);
}
}
#line 956 "/usr/include/unistd.h"
extern int fsync(int __fd ) ;
#line 1112
extern int fdatasync(int __fildes ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/fsync.c"
value caml_extunix_fsync(value v_fd ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_fd ;
  int caml__dummy_v_fd  __attribute__((__unused__)) ;
  int r ;
  value caml__temp_result ;

  {
  {
#line 39
  caml__frame = caml_local_roots;
#line 39
  caml__roots_v_fd.next = caml_local_roots;
#line 39
  caml_local_roots = & caml__roots_v_fd;
#line 39
  caml__roots_v_fd.nitems = (intnat )1;
#line 39
  caml__roots_v_fd.ntables = (intnat )1;
#line 39
  caml__roots_v_fd.tables[0] = & v_fd;
#line 39
  caml__dummy_v_fd = 0;
#line 40
  r = 0;
#line 41
  caml_enter_blocking_section();
#line 42
  r = fsync((int )(v_fd >> 1));
#line 43
  caml_leave_blocking_section();
  }
#line 44
  if (0 != r) {
    {
#line 45
    uerror((char *)"fsync", (value )0);
    }
  }
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    caml__temp_result = 1L;
#line 46
    caml_local_roots = caml__frame;
#line 46
    return (caml__temp_result);
#line 46
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return (0L);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/fsync.c"
value caml_extunix_fdatasync(value v_fd ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_fd ;
  int caml__dummy_v_fd  __attribute__((__unused__)) ;
  int r ;
  value caml__temp_result ;

  {
  {
#line 53
  caml__frame = caml_local_roots;
#line 53
  caml__roots_v_fd.next = caml_local_roots;
#line 53
  caml_local_roots = & caml__roots_v_fd;
#line 53
  caml__roots_v_fd.nitems = (intnat )1;
#line 53
  caml__roots_v_fd.ntables = (intnat )1;
#line 53
  caml__roots_v_fd.tables[0] = & v_fd;
#line 53
  caml__dummy_v_fd = 0;
#line 54
  r = 0;
#line 55
  caml_enter_blocking_section();
#line 56
  r = fdatasync((int )(v_fd >> 1));
#line 57
  caml_leave_blocking_section();
  }
#line 58
  if (0 != r) {
    {
#line 59
    uerror((char *)"fdatasync", (value )0);
    }
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    caml__temp_result = 1L;
#line 60
    caml_local_roots = caml__frame;
#line 60
    return (caml__temp_result);
#line 60
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  return (0L);
}
}
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 29 "/usr/lib/ocaml/caml/unixsupport.h"
extern  __attribute__((__noreturn__)) void unix_error(int errcode , char *cmdname ,
                                                      value arg ) ;
#line 35 "/usr/lib/ocaml/caml/alloc.h"
extern value caml_copy_int32(int32  ) ;
#line 36
extern value caml_copy_int64(int64  ) ;
#line 49 "/usr/lib/ocaml/caml/custom.h"
extern value caml_alloc_custom(struct custom_operations *ops , uintnat size , mlsize_t mem ,
                               mlsize_t max ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 53 "/usr/include/x86_64-linux-gnu/sys/signalfd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) signalfd)(int __fd ,
                                                                                               sigset_t const   *__mask ,
                                                                                               int __flags ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/signalfd.c"
extern int caml_convert_signal_number(int signo ) ;
#line 18
extern int caml_rev_convert_signal_number(int signo ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/signalfd.c"
value caml_extunix_signalfd(value vfd , value vsigs , value vflags , value v_unit ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vfd ;
  int caml__dummy_vfd  __attribute__((__unused__)) ;
  int fd ;
  int tmp ;
  int flags ;
  int ret ;
  sigset_t ss ;
  int sig ;
  int tmp___0 ;
  int tmp___1 ;
  int f ;
  value caml__temp_result ;

  {
#line 23
  caml__frame = caml_local_roots;
#line 23
  caml__roots_vfd.next = caml_local_roots;
#line 23
  caml_local_roots = & caml__roots_vfd;
#line 23
  caml__roots_vfd.nitems = (intnat )1;
#line 23
  caml__roots_vfd.ntables = (intnat )4;
#line 23
  caml__roots_vfd.tables[0] = & vfd;
#line 23
  caml__roots_vfd.tables[1] = & vsigs;
#line 23
  caml__roots_vfd.tables[2] = & vflags;
#line 23
  caml__roots_vfd.tables[3] = & v_unit;
#line 23
  caml__dummy_vfd = 0;
#line 24
  if (1L == vfd) {
#line 24
    tmp = -1;
  } else {
#line 24
    tmp = (int )(*((value *)vfd + 0) >> 1);
  }
  {
#line 24
  fd = tmp;
#line 25
  flags = 0;
#line 26
  ret = 0;
#line 28
  sigemptyset(& ss);
  }
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (! ((vsigs & 1L) != 0L))) {
#line 29
      goto while_break;
    }
    {
#line 30
    tmp___0 = caml_convert_signal_number((int )(*((value *)vsigs + 0) >> 1));
#line 30
    sig = tmp___0;
#line 31
    tmp___1 = sigaddset(& ss, sig);
    }
#line 31
    if (tmp___1 < 0) {
      {
#line 31
      uerror((char *)"sigaddset", (value )0);
      }
    }
#line 32
    vsigs = *((value *)vsigs + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 34
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 34
    if (! (! ((vflags & 1L) != 0L))) {
#line 34
      goto while_break___0;
    }
#line 35
    f = (int )(*((value *)vflags + 0) >> 1);
#line 36
    if (2048 == f) {
#line 36
      flags |= 2048;
    }
#line 37
    if (524288 == f) {
#line 37
      flags |= 524288;
    }
#line 38
    vflags = *((value *)vflags + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 40
  ret = signalfd(fd, (sigset_t const   *)(& ss), flags);
  }
#line 41
  if (ret < 0) {
    {
#line 41
    uerror((char *)"signalfd", (value )0);
    }
  }
  {
#line 42
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 42
    caml__temp_result = ((intnat )ret << 1) + 1L;
#line 42
    caml_local_roots = caml__frame;
#line 42
    return (caml__temp_result);
#line 42
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 43
  return (0L);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/signalfd.c"
static struct custom_operations ssi_ops  =    {(char *)"signalfd.signalfd_siginfo", (void (*)(value v ))((void *)0), (int (*)(value v1 ,
                                                                                   value v2 ))((void *)0),
    (intnat (*)(value v ))((void *)0), (void (*)(value v , uintnat *wsize_32 , uintnat *wsize_64 ))((void *)0),
    (uintnat (*)(void *dst ))((void *)0), (int (*)(value v1 , value v2 ))((void *)0)};
#line 59 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/signalfd.c"
value caml_extunix_signalfd_read(value vfd ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vfd ;
  int caml__dummy_vfd  __attribute__((__unused__)) ;
  value vret ;
  struct caml__roots_block caml__roots_vret ;
  int caml__dummy_vret  __attribute__((__unused__)) ;
  struct signalfd_siginfo ssi ;
  ssize_t nread ;
  value caml__temp_result ;

  {
  {
#line 61
  caml__frame = caml_local_roots;
#line 61
  caml__roots_vfd.next = caml_local_roots;
#line 61
  caml_local_roots = & caml__roots_vfd;
#line 61
  caml__roots_vfd.nitems = (intnat )1;
#line 61
  caml__roots_vfd.ntables = (intnat )1;
#line 61
  caml__roots_vfd.tables[0] = & vfd;
#line 61
  caml__dummy_vfd = 0;
#line 62
  vret = 1L;
#line 62
  caml__roots_vret.next = caml_local_roots;
#line 62
  caml_local_roots = & caml__roots_vret;
#line 62
  caml__roots_vret.nitems = (intnat )1;
#line 62
  caml__roots_vret.ntables = (intnat )1;
#line 62
  caml__roots_vret.tables[0] = & vret;
#line 62
  caml__dummy_vret = 0;
#line 64
  nread = (ssize_t )0;
#line 65
  caml_enter_blocking_section();
#line 66
  nread = read((int )(vfd >> 1), (void *)(& ssi), sizeof(struct signalfd_siginfo ));
#line 67
  caml_leave_blocking_section();
  }
#line 68
  if ((unsigned long )nread != sizeof(struct signalfd_siginfo )) {
    {
#line 69
    unix_error(22, (char *)"signalfd_read", (value )0);
    }
  }
  {
#line 70
  vret = caml_alloc_custom(& ssi_ops, sizeof(struct signalfd_siginfo ), (mlsize_t )0,
                           (mlsize_t )1);
#line 71
  memcpy((void */* __restrict  */)((void *)((value *)vret + 1)), (void const   */* __restrict  */)(& ssi),
         sizeof(struct signalfd_siginfo ));
  }
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    caml__temp_result = vret;
#line 72
    caml_local_roots = caml__frame;
#line 72
    return (caml__temp_result);
#line 72
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return (0L);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/signalfd.c"
value caml_extunix_ssi_signo_sys(value vssi ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vssi ;
  int caml__dummy_vssi  __attribute__((__unused__)) ;
  struct signalfd_siginfo *ssi ;
  value caml__temp_result ;
  int tmp ;

  {
#line 78
  caml__frame = caml_local_roots;
#line 78
  caml__roots_vssi.next = caml_local_roots;
#line 78
  caml_local_roots = & caml__roots_vssi;
#line 78
  caml__roots_vssi.nitems = (intnat )1;
#line 78
  caml__roots_vssi.ntables = (intnat )1;
#line 78
  caml__roots_vssi.tables[0] = & vssi;
#line 78
  caml__dummy_vssi = 0;
#line 79
  ssi = (struct signalfd_siginfo *)((void *)((value *)vssi + 1));
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 80
    tmp = caml_rev_convert_signal_number((int )ssi->ssi_signo);
#line 80
    caml__temp_result = ((intnat )tmp << 1) + 1L;
#line 80
    caml_local_roots = caml__frame;
    }
#line 80
    return (caml__temp_result);
#line 80
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return (0L);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/signalfd.c"
value caml_extunix_ssi_signo(value vssi ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vssi ;
  int caml__dummy_vssi  __attribute__((__unused__)) ;
  struct signalfd_siginfo *ssi ;
  value caml__temp_result ;
  value tmp ;

  {
#line 92
  caml__frame = caml_local_roots;
#line 92
  caml__roots_vssi.next = caml_local_roots;
#line 92
  caml_local_roots = & caml__roots_vssi;
#line 92
  caml__roots_vssi.nitems = (intnat )1;
#line 92
  caml__roots_vssi.ntables = (intnat )1;
#line 92
  caml__roots_vssi.tables[0] = & vssi;
#line 92
  caml__dummy_vssi = 0;
#line 92
  ssi = (struct signalfd_siginfo *)((void *)((value *)vssi + 1));
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 92
    tmp = caml_copy_int32((int32 )ssi->ssi_signo);
#line 92
    caml__temp_result = tmp;
#line 92
    caml_local_roots = caml__frame;
    }
#line 92
    return (caml__temp_result);
#line 92
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return (0L);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/signalfd.c"
value caml_extunix_ssi_errno(value vssi ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vssi ;
  int caml__dummy_vssi  __attribute__((__unused__)) ;
  struct signalfd_siginfo *ssi ;
  value caml__temp_result ;
  value tmp ;

  {
#line 93
  caml__frame = caml_local_roots;
#line 93
  caml__roots_vssi.next = caml_local_roots;
#line 93
  caml_local_roots = & caml__roots_vssi;
#line 93
  caml__roots_vssi.nitems = (intnat )1;
#line 93
  caml__roots_vssi.ntables = (intnat )1;
#line 93
  caml__roots_vssi.tables[0] = & vssi;
#line 93
  caml__dummy_vssi = 0;
#line 93
  ssi = (struct signalfd_siginfo *)((void *)((value *)vssi + 1));
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 93
    tmp = caml_copy_int32(ssi->ssi_errno);
#line 93
    caml__temp_result = tmp;
#line 93
    caml_local_roots = caml__frame;
    }
#line 93
    return (caml__temp_result);
#line 93
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  return (0L);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/signalfd.c"
value caml_extunix_ssi_code(value vssi ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vssi ;
  int caml__dummy_vssi  __attribute__((__unused__)) ;
  struct signalfd_siginfo *ssi ;
  value caml__temp_result ;
  value tmp ;

  {
#line 94
  caml__frame = caml_local_roots;
#line 94
  caml__roots_vssi.next = caml_local_roots;
#line 94
  caml_local_roots = & caml__roots_vssi;
#line 94
  caml__roots_vssi.nitems = (intnat )1;
#line 94
  caml__roots_vssi.ntables = (intnat )1;
#line 94
  caml__roots_vssi.tables[0] = & vssi;
#line 94
  caml__dummy_vssi = 0;
#line 94
  ssi = (struct signalfd_siginfo *)((void *)((value *)vssi + 1));
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 94
    tmp = caml_copy_int32(ssi->ssi_code);
#line 94
    caml__temp_result = tmp;
#line 94
    caml_local_roots = caml__frame;
    }
#line 94
    return (caml__temp_result);
#line 94
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  return (0L);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/signalfd.c"
value caml_extunix_ssi_pid(value vssi ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vssi ;
  int caml__dummy_vssi  __attribute__((__unused__)) ;
  struct signalfd_siginfo *ssi ;
  value caml__temp_result ;
  value tmp ;

  {
#line 95
  caml__frame = caml_local_roots;
#line 95
  caml__roots_vssi.next = caml_local_roots;
#line 95
  caml_local_roots = & caml__roots_vssi;
#line 95
  caml__roots_vssi.nitems = (intnat )1;
#line 95
  caml__roots_vssi.ntables = (intnat )1;
#line 95
  caml__roots_vssi.tables[0] = & vssi;
#line 95
  caml__dummy_vssi = 0;
#line 95
  ssi = (struct signalfd_siginfo *)((void *)((value *)vssi + 1));
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 95
    tmp = caml_copy_int32((int32 )ssi->ssi_pid);
#line 95
    caml__temp_result = tmp;
#line 95
    caml_local_roots = caml__frame;
    }
#line 95
    return (caml__temp_result);
#line 95
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return (0L);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/signalfd.c"
value caml_extunix_ssi_uid(value vssi ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vssi ;
  int caml__dummy_vssi  __attribute__((__unused__)) ;
  struct signalfd_siginfo *ssi ;
  value caml__temp_result ;
  value tmp ;

  {
#line 96
  caml__frame = caml_local_roots;
#line 96
  caml__roots_vssi.next = caml_local_roots;
#line 96
  caml_local_roots = & caml__roots_vssi;
#line 96
  caml__roots_vssi.nitems = (intnat )1;
#line 96
  caml__roots_vssi.ntables = (intnat )1;
#line 96
  caml__roots_vssi.tables[0] = & vssi;
#line 96
  caml__dummy_vssi = 0;
#line 96
  ssi = (struct signalfd_siginfo *)((void *)((value *)vssi + 1));
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 96
    tmp = caml_copy_int32((int32 )ssi->ssi_uid);
#line 96
    caml__temp_result = tmp;
#line 96
    caml_local_roots = caml__frame;
    }
#line 96
    return (caml__temp_result);
#line 96
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  return (0L);
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/signalfd.c"
value caml_extunix_ssi_fd(value vssi ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vssi ;
  int caml__dummy_vssi  __attribute__((__unused__)) ;
  struct signalfd_siginfo *ssi ;
  value caml__temp_result ;

  {
#line 97
  caml__frame = caml_local_roots;
#line 97
  caml__roots_vssi.next = caml_local_roots;
#line 97
  caml_local_roots = & caml__roots_vssi;
#line 97
  caml__roots_vssi.nitems = (intnat )1;
#line 97
  caml__roots_vssi.ntables = (intnat )1;
#line 97
  caml__roots_vssi.tables[0] = & vssi;
#line 97
  caml__dummy_vssi = 0;
#line 97
  ssi = (struct signalfd_siginfo *)((void *)((value *)vssi + 1));
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    caml__temp_result = ((intnat )ssi->ssi_fd << 1) + 1L;
#line 97
    caml_local_roots = caml__frame;
#line 97
    return (caml__temp_result);
#line 97
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  return (0L);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/signalfd.c"
value caml_extunix_ssi_tid(value vssi ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vssi ;
  int caml__dummy_vssi  __attribute__((__unused__)) ;
  struct signalfd_siginfo *ssi ;
  value caml__temp_result ;
  value tmp ;

  {
#line 98
  caml__frame = caml_local_roots;
#line 98
  caml__roots_vssi.next = caml_local_roots;
#line 98
  caml_local_roots = & caml__roots_vssi;
#line 98
  caml__roots_vssi.nitems = (intnat )1;
#line 98
  caml__roots_vssi.ntables = (intnat )1;
#line 98
  caml__roots_vssi.tables[0] = & vssi;
#line 98
  caml__dummy_vssi = 0;
#line 98
  ssi = (struct signalfd_siginfo *)((void *)((value *)vssi + 1));
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 98
    tmp = caml_copy_int32((int32 )ssi->ssi_tid);
#line 98
    caml__temp_result = tmp;
#line 98
    caml_local_roots = caml__frame;
    }
#line 98
    return (caml__temp_result);
#line 98
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  return (0L);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/signalfd.c"
value caml_extunix_ssi_band(value vssi ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vssi ;
  int caml__dummy_vssi  __attribute__((__unused__)) ;
  struct signalfd_siginfo *ssi ;
  value caml__temp_result ;
  value tmp ;

  {
#line 99
  caml__frame = caml_local_roots;
#line 99
  caml__roots_vssi.next = caml_local_roots;
#line 99
  caml_local_roots = & caml__roots_vssi;
#line 99
  caml__roots_vssi.nitems = (intnat )1;
#line 99
  caml__roots_vssi.ntables = (intnat )1;
#line 99
  caml__roots_vssi.tables[0] = & vssi;
#line 99
  caml__dummy_vssi = 0;
#line 99
  ssi = (struct signalfd_siginfo *)((void *)((value *)vssi + 1));
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 99
    tmp = caml_copy_int32((int32 )ssi->ssi_band);
#line 99
    caml__temp_result = tmp;
#line 99
    caml_local_roots = caml__frame;
    }
#line 99
    return (caml__temp_result);
#line 99
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return (0L);
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/signalfd.c"
value caml_extunix_ssi_overrun(value vssi ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vssi ;
  int caml__dummy_vssi  __attribute__((__unused__)) ;
  struct signalfd_siginfo *ssi ;
  value caml__temp_result ;
  value tmp ;

  {
#line 100
  caml__frame = caml_local_roots;
#line 100
  caml__roots_vssi.next = caml_local_roots;
#line 100
  caml_local_roots = & caml__roots_vssi;
#line 100
  caml__roots_vssi.nitems = (intnat )1;
#line 100
  caml__roots_vssi.ntables = (intnat )1;
#line 100
  caml__roots_vssi.tables[0] = & vssi;
#line 100
  caml__dummy_vssi = 0;
#line 100
  ssi = (struct signalfd_siginfo *)((void *)((value *)vssi + 1));
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 100
    tmp = caml_copy_int32((int32 )ssi->ssi_overrun);
#line 100
    caml__temp_result = tmp;
#line 100
    caml_local_roots = caml__frame;
    }
#line 100
    return (caml__temp_result);
#line 100
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  return (0L);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/signalfd.c"
value caml_extunix_ssi_trapno(value vssi ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vssi ;
  int caml__dummy_vssi  __attribute__((__unused__)) ;
  struct signalfd_siginfo *ssi ;
  value caml__temp_result ;
  value tmp ;

  {
#line 101
  caml__frame = caml_local_roots;
#line 101
  caml__roots_vssi.next = caml_local_roots;
#line 101
  caml_local_roots = & caml__roots_vssi;
#line 101
  caml__roots_vssi.nitems = (intnat )1;
#line 101
  caml__roots_vssi.ntables = (intnat )1;
#line 101
  caml__roots_vssi.tables[0] = & vssi;
#line 101
  caml__dummy_vssi = 0;
#line 101
  ssi = (struct signalfd_siginfo *)((void *)((value *)vssi + 1));
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 101
    tmp = caml_copy_int32((int32 )ssi->ssi_trapno);
#line 101
    caml__temp_result = tmp;
#line 101
    caml_local_roots = caml__frame;
    }
#line 101
    return (caml__temp_result);
#line 101
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  return (0L);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/signalfd.c"
value caml_extunix_ssi_status(value vssi ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vssi ;
  int caml__dummy_vssi  __attribute__((__unused__)) ;
  struct signalfd_siginfo *ssi ;
  value caml__temp_result ;
  value tmp ;

  {
#line 102
  caml__frame = caml_local_roots;
#line 102
  caml__roots_vssi.next = caml_local_roots;
#line 102
  caml_local_roots = & caml__roots_vssi;
#line 102
  caml__roots_vssi.nitems = (intnat )1;
#line 102
  caml__roots_vssi.ntables = (intnat )1;
#line 102
  caml__roots_vssi.tables[0] = & vssi;
#line 102
  caml__dummy_vssi = 0;
#line 102
  ssi = (struct signalfd_siginfo *)((void *)((value *)vssi + 1));
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 102
    tmp = caml_copy_int32(ssi->ssi_status);
#line 102
    caml__temp_result = tmp;
#line 102
    caml_local_roots = caml__frame;
    }
#line 102
    return (caml__temp_result);
#line 102
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return (0L);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/signalfd.c"
value caml_extunix_ssi_int(value vssi ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vssi ;
  int caml__dummy_vssi  __attribute__((__unused__)) ;
  struct signalfd_siginfo *ssi ;
  value caml__temp_result ;
  value tmp ;

  {
#line 103
  caml__frame = caml_local_roots;
#line 103
  caml__roots_vssi.next = caml_local_roots;
#line 103
  caml_local_roots = & caml__roots_vssi;
#line 103
  caml__roots_vssi.nitems = (intnat )1;
#line 103
  caml__roots_vssi.ntables = (intnat )1;
#line 103
  caml__roots_vssi.tables[0] = & vssi;
#line 103
  caml__dummy_vssi = 0;
#line 103
  ssi = (struct signalfd_siginfo *)((void *)((value *)vssi + 1));
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 103
    tmp = caml_copy_int32(ssi->ssi_int);
#line 103
    caml__temp_result = tmp;
#line 103
    caml_local_roots = caml__frame;
    }
#line 103
    return (caml__temp_result);
#line 103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return (0L);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/signalfd.c"
value caml_extunix_ssi_ptr(value vssi ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vssi ;
  int caml__dummy_vssi  __attribute__((__unused__)) ;
  struct signalfd_siginfo *ssi ;
  value caml__temp_result ;
  value tmp ;

  {
#line 104
  caml__frame = caml_local_roots;
#line 104
  caml__roots_vssi.next = caml_local_roots;
#line 104
  caml_local_roots = & caml__roots_vssi;
#line 104
  caml__roots_vssi.nitems = (intnat )1;
#line 104
  caml__roots_vssi.ntables = (intnat )1;
#line 104
  caml__roots_vssi.tables[0] = & vssi;
#line 104
  caml__dummy_vssi = 0;
#line 104
  ssi = (struct signalfd_siginfo *)((void *)((value *)vssi + 1));
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 104
    tmp = caml_copy_int64((int64 )ssi->ssi_ptr);
#line 104
    caml__temp_result = tmp;
#line 104
    caml_local_roots = caml__frame;
    }
#line 104
    return (caml__temp_result);
#line 104
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return (0L);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/signalfd.c"
value caml_extunix_ssi_utime(value vssi ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vssi ;
  int caml__dummy_vssi  __attribute__((__unused__)) ;
  struct signalfd_siginfo *ssi ;
  value caml__temp_result ;
  value tmp ;

  {
#line 105
  caml__frame = caml_local_roots;
#line 105
  caml__roots_vssi.next = caml_local_roots;
#line 105
  caml_local_roots = & caml__roots_vssi;
#line 105
  caml__roots_vssi.nitems = (intnat )1;
#line 105
  caml__roots_vssi.ntables = (intnat )1;
#line 105
  caml__roots_vssi.tables[0] = & vssi;
#line 105
  caml__dummy_vssi = 0;
#line 105
  ssi = (struct signalfd_siginfo *)((void *)((value *)vssi + 1));
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 105
    tmp = caml_copy_int64((int64 )ssi->ssi_utime);
#line 105
    caml__temp_result = tmp;
#line 105
    caml_local_roots = caml__frame;
    }
#line 105
    return (caml__temp_result);
#line 105
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return (0L);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/signalfd.c"
value caml_extunix_ssi_stime(value vssi ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vssi ;
  int caml__dummy_vssi  __attribute__((__unused__)) ;
  struct signalfd_siginfo *ssi ;
  value caml__temp_result ;
  value tmp ;

  {
#line 106
  caml__frame = caml_local_roots;
#line 106
  caml__roots_vssi.next = caml_local_roots;
#line 106
  caml_local_roots = & caml__roots_vssi;
#line 106
  caml__roots_vssi.nitems = (intnat )1;
#line 106
  caml__roots_vssi.ntables = (intnat )1;
#line 106
  caml__roots_vssi.tables[0] = & vssi;
#line 106
  caml__dummy_vssi = 0;
#line 106
  ssi = (struct signalfd_siginfo *)((void *)((value *)vssi + 1));
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 106
    tmp = caml_copy_int64((int64 )ssi->ssi_stime);
#line 106
    caml__temp_result = tmp;
#line 106
    caml_local_roots = caml__frame;
    }
#line 106
    return (caml__temp_result);
#line 106
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return (0L);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/signalfd.c"
value caml_extunix_ssi_addr(value vssi ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vssi ;
  int caml__dummy_vssi  __attribute__((__unused__)) ;
  struct signalfd_siginfo *ssi ;
  value caml__temp_result ;
  value tmp ;

  {
#line 107
  caml__frame = caml_local_roots;
#line 107
  caml__roots_vssi.next = caml_local_roots;
#line 107
  caml_local_roots = & caml__roots_vssi;
#line 107
  caml__roots_vssi.nitems = (intnat )1;
#line 107
  caml__roots_vssi.ntables = (intnat )1;
#line 107
  caml__roots_vssi.tables[0] = & vssi;
#line 107
  caml__dummy_vssi = 0;
#line 107
  ssi = (struct signalfd_siginfo *)((void *)((value *)vssi + 1));
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 107
    tmp = caml_copy_int64((int64 )ssi->ssi_addr);
#line 107
    caml__temp_result = tmp;
#line 107
    caml_local_roots = caml__frame;
    }
#line 107
    return (caml__temp_result);
#line 107
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  return (0L);
}
}
#line 35 "/usr/lib/ocaml/caml/memory.h"
extern void caml_modify(value * , value  ) ;
#line 36 "/usr/lib/ocaml/caml/fail.h"
extern  __attribute__((__noreturn__)) void caml_invalid_argument(char const   * ) ;
#line 28 "/usr/lib/ocaml/caml/alloc.h"
extern value caml_alloc(mlsize_t  , tag_t  ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 54 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit *__rlimits )  __asm__("getrlimit64")  ;
#line 73
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit  const  *__rlimits )  __asm__("setrlimit64")  ;
#line 93
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpriority)(__priority_which_t __which ,
                                                                                  id_t __who ) ;
#line 97
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpriority)(__priority_which_t __which ,
                                                                                  id_t __who ,
                                                                                  int __prio ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/resource.c"
static void decode_which_prio(value vwprio , int *pwhich , id_t *pwho ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vwprio ;
  int caml__dummy_vwprio  __attribute__((__unused__)) ;

  {
#line 38
  caml__frame = caml_local_roots;
#line 38
  caml__roots_vwprio.next = caml_local_roots;
#line 38
  caml_local_roots = & caml__roots_vwprio;
#line 38
  caml__roots_vwprio.nitems = (intnat )1;
#line 38
  caml__roots_vwprio.ntables = (intnat )1;
#line 38
  caml__roots_vwprio.tables[0] = & vwprio;
#line 38
  caml__dummy_vwprio = 0;
#line 40
  if ((vwprio & 1L) == 0L) {
#line 40
    if (! (*((header_t *)vwprio + -1) >> 10 == 1UL)) {
      {
#line 40
      __assert_fail("(((vwprio) & 1) == 0) && (((mlsize_t) (((((header_t *) (vwprio)) [-1])) >> 10))) == 1",
                    "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/resource.c",
                    40U, "decode_which_prio");
      }
    }
  } else {
    {
#line 40
    __assert_fail("(((vwprio) & 1) == 0) && (((mlsize_t) (((((header_t *) (vwprio)) [-1])) >> 10))) == 1",
                  "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/resource.c",
                  40U, "decode_which_prio");
    }
  }
#line 42
  *pwho = (id_t )(*((value *)vwprio + 0) >> 1);
  {
#line 46
  if ((int )*((unsigned char *)vwprio + - sizeof(value )) == 0) {
#line 46
    goto case_0;
  }
#line 49
  if ((int )*((unsigned char *)vwprio + - sizeof(value )) == 1) {
#line 49
    goto case_1;
  }
#line 52
  if ((int )*((unsigned char *)vwprio + - sizeof(value )) == 2) {
#line 52
    goto case_2;
  }
#line 55
  goto switch_default;
  case_0: /* CIL Label */ 
#line 47
  *pwhich = 0;
#line 48
  goto switch_break;
  case_1: /* CIL Label */ 
#line 50
  *pwhich = 1;
#line 51
  goto switch_break;
  case_2: /* CIL Label */ 
#line 53
  *pwhich = 2;
#line 54
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 56
  caml_invalid_argument("decode_which_prio");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    caml_local_roots = caml__frame;
#line 59
    return;
#line 59
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/resource.c"
value caml_extunix_getpriority(value vwprio ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vwprio ;
  int caml__dummy_vwprio  __attribute__((__unused__)) ;
  int which ;
  id_t who ;
  int res ;
  int *tmp ;
  int *tmp___0 ;
  value caml__temp_result ;

  {
  {
#line 64
  caml__frame = caml_local_roots;
#line 64
  caml__roots_vwprio.next = caml_local_roots;
#line 64
  caml_local_roots = & caml__roots_vwprio;
#line 64
  caml__roots_vwprio.nitems = (intnat )1;
#line 64
  caml__roots_vwprio.ntables = (intnat )1;
#line 64
  caml__roots_vwprio.tables[0] = & vwprio;
#line 64
  caml__dummy_vwprio = 0;
#line 67
  res = -1;
#line 69
  decode_which_prio(vwprio, & which, & who);
#line 71
  tmp = __errno_location();
#line 71
  *tmp = 0;
#line 72
  res = getpriority((__priority_which_t )which, who);
  }
#line 73
  if (res == -1) {
    {
#line 73
    tmp___0 = __errno_location();
    }
#line 73
    if (*tmp___0 != 0) {
      {
#line 75
      uerror((char *)"getpriority", (value )0);
      }
    }
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    caml__temp_result = ((intnat )res << 1) + 1L;
#line 78
    caml_local_roots = caml__frame;
#line 78
    return (caml__temp_result);
#line 78
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return (0L);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/resource.c"
value caml_extunix_setpriority(value vwprio , value vprio ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vwprio ;
  int caml__dummy_vwprio  __attribute__((__unused__)) ;
  int which ;
  id_t who ;
  int tmp ;
  value caml__temp_result ;

  {
  {
#line 83
  caml__frame = caml_local_roots;
#line 83
  caml__roots_vwprio.next = caml_local_roots;
#line 83
  caml_local_roots = & caml__roots_vwprio;
#line 83
  caml__roots_vwprio.nitems = (intnat )1;
#line 83
  caml__roots_vwprio.ntables = (intnat )2;
#line 83
  caml__roots_vwprio.tables[0] = & vwprio;
#line 83
  caml__roots_vwprio.tables[1] = & vprio;
#line 83
  caml__dummy_vwprio = 0;
#line 87
  decode_which_prio(vwprio, & which, & who);
#line 89
  tmp = setpriority((__priority_which_t )which, who, (int )(vprio >> 1));
  }
#line 89
  if (tmp != 0) {
    {
#line 91
    uerror((char *)"setpriority", (value )0);
    }
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    caml__temp_result = 1L;
#line 94
    caml_local_roots = caml__frame;
#line 94
    return (caml__temp_result);
#line 94
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return (0L);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/resource.c"
static int resource_map[7]  = {      4,      0,      2,      1, 
        7,      3,      9};
#line 110 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/resource.c"
static int decode_resource(value vrsrc ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vrsrc ;
  int caml__dummy_vrsrc  __attribute__((__unused__)) ;
  int caml__temp_result ;

  {
#line 112
  caml__frame = caml_local_roots;
#line 112
  caml__roots_vrsrc.next = caml_local_roots;
#line 112
  caml_local_roots = & caml__roots_vrsrc;
#line 112
  caml__roots_vrsrc.nitems = (intnat )1;
#line 112
  caml__roots_vrsrc.ntables = (intnat )1;
#line 112
  caml__roots_vrsrc.tables[0] = & vrsrc;
#line 112
  caml__dummy_vrsrc = 0;
#line 113
  if ((int )(vrsrc >> 1) < 7) {
#line 113
    if (! ((int )(vrsrc >> 1) >= 0)) {
      {
#line 113
      __assert_fail("((int) ((vrsrc) >> 1)) < 7 && ((int) ((vrsrc) >> 1)) >= 0", "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/resource.c",
                    113U, "decode_resource");
      }
    }
  } else {
    {
#line 113
    __assert_fail("((int) ((vrsrc) >> 1)) < 7 && ((int) ((vrsrc) >> 1)) >= 0", "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/resource.c",
                  113U, "decode_resource");
    }
  }
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    caml__temp_result = resource_map[(int )(vrsrc >> 1)];
#line 114
    caml_local_roots = caml__frame;
#line 114
    return (caml__temp_result);
#line 114
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return (0);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/resource.c"
static value encode_limit(rlim_t v ) 
{ 
  struct caml__roots_block *caml__frame ;
  value vres ;
  struct caml__roots_block caml__roots_vres ;
  int caml__dummy_vres  __attribute__((__unused__)) ;
  mlsize_t caml__temp_offset ;
  value caml__temp_val ;
  value tmp ;
  value caml__temp_result ;

  {
#line 119
  caml__frame = caml_local_roots;
#line 120
  vres = 1L;
#line 120
  caml__roots_vres.next = caml_local_roots;
#line 120
  caml_local_roots = & caml__roots_vres;
#line 120
  caml__roots_vres.nitems = (intnat )1;
#line 120
  caml__roots_vres.ntables = (intnat )1;
#line 120
  caml__roots_vres.tables[0] = & vres;
#line 120
  caml__dummy_vres = 0;
#line 122
  if ((unsigned long long )v == 0xffffffffffffffffULL) {
#line 124
    vres = 1L;
  } else {
    {
#line 128
    vres = caml_alloc((mlsize_t )1, (tag_t )0);
    }
    {
#line 129
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 129
      caml__temp_offset = (mlsize_t )0;
#line 129
      tmp = caml_copy_int64((int64 )v);
#line 129
      caml__temp_val = tmp;
#line 129
      caml_modify((value *)vres + caml__temp_offset, caml__temp_val);
      }
#line 129
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 132
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 132
    caml__temp_result = vres;
#line 132
    caml_local_roots = caml__frame;
#line 132
    return (caml__temp_result);
#line 132
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 133
  return (0L);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/resource.c"
static rlim_t decode_limit(value vchglimit ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vchglimit ;
  int caml__dummy_vchglimit  __attribute__((__unused__)) ;
  rlim_t res ;
  rlim_t caml__temp_result ;

  {
#line 137
  caml__frame = caml_local_roots;
#line 137
  caml__roots_vchglimit.next = caml_local_roots;
#line 137
  caml_local_roots = & caml__roots_vchglimit;
#line 137
  caml__roots_vchglimit.nitems = (intnat )1;
#line 137
  caml__roots_vchglimit.ntables = (intnat )1;
#line 137
  caml__roots_vchglimit.tables[0] = & vchglimit;
#line 137
  caml__dummy_vchglimit = 0;
#line 138
  res = (rlim_t )0xffffffffffffffffULL;
#line 140
  if ((vchglimit & 1L) == 0L) {
#line 142
    if (! ((int )*((unsigned char *)vchglimit + - sizeof(value )) == 0)) {
      {
#line 142
      __assert_fail("(((unsigned char *) (vchglimit)) [-sizeof(value)]) == 0", "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/resource.c",
                    142U, "decode_limit");
      }
    }
#line 143
    res = (rlim_t )*((int64 *)((void *)((value *)*((value *)vchglimit + 0) + 1)));
  }
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    caml__temp_result = res;
#line 146
    caml_local_roots = caml__frame;
#line 146
    return (caml__temp_result);
#line 146
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return (0UL);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/resource.c"
value caml_extunix_getrlimit(value vrsrc ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vrsrc ;
  int caml__dummy_vrsrc  __attribute__((__unused__)) ;
  value vres ;
  struct caml__roots_block caml__roots_vres ;
  int caml__dummy_vres  __attribute__((__unused__)) ;
  struct rlimit rlmt ;
  int tmp ;
  int tmp___0 ;
  mlsize_t caml__temp_offset ;
  value caml__temp_val ;
  value tmp___1 ;
  mlsize_t caml__temp_offset___0 ;
  value caml__temp_val___0 ;
  value tmp___2 ;
  value caml__temp_result ;

  {
  {
#line 151
  caml__frame = caml_local_roots;
#line 151
  caml__roots_vrsrc.next = caml_local_roots;
#line 151
  caml_local_roots = & caml__roots_vrsrc;
#line 151
  caml__roots_vrsrc.nitems = (intnat )1;
#line 151
  caml__roots_vrsrc.ntables = (intnat )1;
#line 151
  caml__roots_vrsrc.tables[0] = & vrsrc;
#line 151
  caml__dummy_vrsrc = 0;
#line 152
  vres = 1L;
#line 152
  caml__roots_vres.next = caml_local_roots;
#line 152
  caml_local_roots = & caml__roots_vres;
#line 152
  caml__roots_vres.nitems = (intnat )1;
#line 152
  caml__roots_vres.ntables = (intnat )1;
#line 152
  caml__roots_vres.tables[0] = & vres;
#line 152
  caml__dummy_vres = 0;
#line 155
  tmp = decode_resource(vrsrc);
#line 155
  tmp___0 = getrlimit((__rlimit_resource_t )tmp, & rlmt);
  }
#line 155
  if (tmp___0 != 0) {
    {
#line 157
    uerror((char *)"getrlimit", (value )0);
    }
  }
  {
#line 160
  vres = caml_alloc((mlsize_t )2, (tag_t )0);
  }
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 161
    caml__temp_offset = (mlsize_t )0;
#line 161
    tmp___1 = encode_limit(rlmt.rlim_cur);
#line 161
    caml__temp_val = tmp___1;
#line 161
    caml_modify((value *)vres + caml__temp_offset, caml__temp_val);
    }
#line 161
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 162
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 162
    caml__temp_offset___0 = (mlsize_t )1;
#line 162
    tmp___2 = encode_limit(rlmt.rlim_max);
#line 162
    caml__temp_val___0 = tmp___2;
#line 162
    caml_modify((value *)vres + caml__temp_offset___0, caml__temp_val___0);
    }
#line 162
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 164
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 164
    caml__temp_result = vres;
#line 164
    caml_local_roots = caml__frame;
#line 164
    return (caml__temp_result);
#line 164
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 165
  return (0L);
}
}
#line 167
#pragma GCC diagnostic push
#line 168
#pragma GCC diagnostic ignored "-Wmissing-field-initializers"
#line 170 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/resource.c"
value caml_extunix_setrlimit(value vrsrc , value vslimit , value vhlimit ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vrsrc ;
  int caml__dummy_vrsrc  __attribute__((__unused__)) ;
  struct rlimit rlmt ;
  int tmp ;
  int tmp___0 ;
  value caml__temp_result ;

  {
  {
#line 172
  caml__frame = caml_local_roots;
#line 172
  caml__roots_vrsrc.next = caml_local_roots;
#line 172
  caml_local_roots = & caml__roots_vrsrc;
#line 172
  caml__roots_vrsrc.nitems = (intnat )1;
#line 172
  caml__roots_vrsrc.ntables = (intnat )3;
#line 172
  caml__roots_vrsrc.tables[0] = & vrsrc;
#line 172
  caml__roots_vrsrc.tables[1] = & vslimit;
#line 172
  caml__roots_vrsrc.tables[2] = & vhlimit;
#line 172
  caml__dummy_vrsrc = 0;
#line 173
  rlmt.rlim_cur = (rlim_t )0;
#line 173
  rlmt.rlim_max = 0UL;
#line 175
  rlmt.rlim_cur = decode_limit(vslimit);
#line 176
  rlmt.rlim_max = decode_limit(vhlimit);
#line 178
  tmp = decode_resource(vrsrc);
#line 178
  tmp___0 = setrlimit((__rlimit_resource_t )tmp, (struct rlimit  const  *)(& rlmt));
  }
#line 178
  if (tmp___0 != 0) {
    {
#line 180
    uerror((char *)"setrlimit", (value )0);
    }
  }
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    caml__temp_result = 1L;
#line 183
    caml_local_roots = caml__frame;
#line 183
    return (caml__temp_result);
#line 183
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  return (0L);
}
}
#line 186
#pragma GCC diagnostic pop
/* compiler builtin: 
   int __builtin_bswap32(int  ) ;  */
/* compiler builtin: 
   long __builtin_bswap64(long  ) ;  */
#line 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static unsigned int __bswap_32(unsigned int __bsx ) 
{ 
  int tmp ;

  {
  {
#line 47
  tmp = __builtin_bswap32((int )__bsx);
  }
#line 47
  return ((unsigned int )tmp);
}
}
#line 108 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static __uint64_t __bswap_64(__uint64_t __bsx ) 
{ 
  long tmp ;

  {
  {
#line 111
  tmp = __builtin_bswap64((long )__bsx);
  }
#line 111
  return ((__uint64_t )tmp);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_htobe16(value v_x ) 
{ 
  uint16_t x ;
  unsigned short __v ;
  unsigned short __x ;

  {
#line 45
  x = (uint16_t )(v_x >> 1);
#line 45
  __x = x;
#line 45
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 45
  x = __v;
#line 45
  return (((intnat )x << 1) + 1L);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_htobe16_signed(value v_x ) 
{ 
  int16_t x ;
  unsigned short __v ;
  unsigned short __x ;

  {
#line 46
  x = (int16_t )(v_x >> 1);
#line 46
  __x = (unsigned short )x;
#line 46
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 46
  x = (int16_t )__v;
#line 46
  return (((intnat )x << 1) + 1L);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_be16toh(value v_x ) 
{ 
  uint16_t x ;
  unsigned short __v ;
  unsigned short __x ;

  {
#line 47
  x = (uint16_t )(v_x >> 1);
#line 47
  __x = x;
#line 47
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 47
  x = __v;
#line 47
  return (((intnat )x << 1) + 1L);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_be16toh_signed(value v_x ) 
{ 
  int16_t x ;
  unsigned short __v ;
  unsigned short __x ;

  {
#line 48
  x = (int16_t )(v_x >> 1);
#line 48
  __x = (unsigned short )x;
#line 48
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 48
  x = (int16_t )__v;
#line 48
  return (((intnat )x << 1) + 1L);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_htobe31(value v_x ) 
{ 
  uint32_t x ;

  {
  {
#line 49
  x = (uint32_t )(v_x >> 1);
#line 49
  x = __bswap_32(x);
  }
#line 49
  return (((intnat )x << 1) + 1L);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_htobe31_signed(value v_x ) 
{ 
  int32_t x ;
  unsigned int tmp ;

  {
  {
#line 50
  x = (int32_t )(v_x >> 1);
#line 50
  tmp = __bswap_32((unsigned int )x);
#line 50
  x = (int32_t )tmp;
  }
#line 50
  return (((intnat )x << 1) + 1L);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_be31toh(value v_x ) 
{ 
  uint32_t x ;

  {
  {
#line 51
  x = (uint32_t )(v_x >> 1);
#line 51
  x = __bswap_32(x);
  }
#line 51
  return (((intnat )x << 1) + 1L);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_be31toh_signed(value v_x ) 
{ 
  int32_t x ;
  unsigned int tmp ;

  {
  {
#line 52
  x = (int32_t )(v_x >> 1);
#line 52
  tmp = __bswap_32((unsigned int )x);
#line 52
  x = (int32_t )tmp;
  }
#line 52
  return (((intnat )x << 1) + 1L);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_htobe32(value v_x ) 
{ 
  int32_t x ;
  unsigned int tmp ;
  value tmp___0 ;

  {
  {
#line 53
  x = *((int32 *)((void *)((value *)v_x + 1)));
#line 53
  tmp = __bswap_32((unsigned int )x);
#line 53
  x = (int32_t )tmp;
#line 53
  tmp___0 = caml_copy_int32(x);
  }
#line 53
  return (tmp___0);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_be32toh(value v_x ) 
{ 
  int32_t x ;
  unsigned int tmp ;
  value tmp___0 ;

  {
  {
#line 54
  x = *((int32 *)((void *)((value *)v_x + 1)));
#line 54
  tmp = __bswap_32((unsigned int )x);
#line 54
  x = (int32_t )tmp;
#line 54
  tmp___0 = caml_copy_int32(x);
  }
#line 54
  return (tmp___0);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_htobe64(value v_x ) 
{ 
  int64_t x ;
  __uint64_t tmp ;
  value tmp___0 ;

  {
  {
#line 55
  x = (int64_t )*((int64 *)((void *)((value *)v_x + 1)));
#line 55
  tmp = __bswap_64((__uint64_t )x);
#line 55
  x = (int64_t )tmp;
#line 55
  tmp___0 = caml_copy_int64((int64 )x);
  }
#line 55
  return (tmp___0);
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_be64toh(value v_x ) 
{ 
  int64_t x ;
  __uint64_t tmp ;
  value tmp___0 ;

  {
  {
#line 56
  x = (int64_t )*((int64 *)((void *)((value *)v_x + 1)));
#line 56
  tmp = __bswap_64((__uint64_t )x);
#line 56
  x = (int64_t )tmp;
#line 56
  tmp___0 = caml_copy_int64((int64 )x);
  }
#line 56
  return (tmp___0);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_bu16(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  uint16_t x ;
  unsigned short __v ;
  unsigned short __x ;

  {
  {
#line 58
  str = (char *)v_str;
#line 58
  off = (size_t )(v_off >> 1);
#line 58
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 58
  __x = x;
#line 58
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 58
  x = __v;
  }
#line 58
  return (((intnat )x << 1) + 1L);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_bs16(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  int16_t x ;
  unsigned short __v ;
  unsigned short __x ;

  {
  {
#line 59
  str = (char *)v_str;
#line 59
  off = (size_t )(v_off >> 1);
#line 59
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 59
  __x = (unsigned short )x;
#line 59
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 59
  x = (int16_t )__v;
  }
#line 59
  return (((intnat )x << 1) + 1L);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_bu31(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  uint32_t x ;

  {
  {
#line 60
  str = (char *)v_str;
#line 60
  off = (size_t )(v_off >> 1);
#line 60
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 60
  x = __bswap_32(x);
  }
#line 60
  return (((intnat )x << 1) + 1L);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_bs31(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  int32_t x ;
  unsigned int tmp ;

  {
  {
#line 61
  str = (char *)v_str;
#line 61
  off = (size_t )(v_off >> 1);
#line 61
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 61
  tmp = __bswap_32((unsigned int )x);
#line 61
  x = (int32_t )tmp;
  }
#line 61
  return (((intnat )x << 1) + 1L);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_bs32(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  int32_t x ;
  unsigned int tmp ;
  value tmp___0 ;

  {
  {
#line 62
  str = (char *)v_str;
#line 62
  off = (size_t )(v_off >> 1);
#line 62
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 62
  tmp = __bswap_32((unsigned int )x);
#line 62
  x = (int32_t )tmp;
#line 62
  tmp___0 = caml_copy_int32(x);
  }
#line 62
  return (tmp___0);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_bu63(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  uint64_t x ;

  {
  {
#line 63
  str = (char *)v_str;
#line 63
  off = (size_t )(v_off >> 1);
#line 63
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 63
  x = __bswap_64(x);
  }
#line 63
  return (((intnat )x << 1) + 1L);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_bs63(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  int64_t x ;
  __uint64_t tmp ;

  {
  {
#line 64
  str = (char *)v_str;
#line 64
  off = (size_t )(v_off >> 1);
#line 64
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 64
  tmp = __bswap_64((__uint64_t )x);
#line 64
  x = (int64_t )tmp;
  }
#line 64
  return ((x << 1) + 1L);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_bs64(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  int64_t x ;
  __uint64_t tmp ;
  value tmp___0 ;

  {
  {
#line 65
  str = (char *)v_str;
#line 65
  off = (size_t )(v_off >> 1);
#line 65
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 65
  tmp = __bswap_64((__uint64_t )x);
#line 65
  x = (int64_t )tmp;
#line 65
  tmp___0 = caml_copy_int64((int64 )x);
  }
#line 65
  return (tmp___0);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_set_b16(value v_str , value v_off , value v_x ) 
{ 
  char *str ;
  size_t off ;
  uint16_t x ;
  unsigned short __v ;
  unsigned short __x ;

  {
  {
#line 67
  str = (char *)v_str;
#line 67
  off = (size_t )(v_off >> 1);
#line 67
  x = (uint16_t )(v_x >> 1);
#line 67
  __x = x;
#line 67
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 67
  x = __v;
#line 67
  memcpy((void */* __restrict  */)(str + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 67
  return (1L);
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_set_b31(value v_str , value v_off , value v_x ) 
{ 
  char *str ;
  size_t off ;
  uint32_t x ;

  {
  {
#line 68
  str = (char *)v_str;
#line 68
  off = (size_t )(v_off >> 1);
#line 68
  x = (uint32_t )(v_x >> 1);
#line 68
  x = __bswap_32(x);
#line 68
  memcpy((void */* __restrict  */)(str + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 68
  return (1L);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_set_b32(value v_str , value v_off , value v_x ) 
{ 
  char *str ;
  size_t off ;
  uint32_t x ;

  {
  {
#line 69
  str = (char *)v_str;
#line 69
  off = (size_t )(v_off >> 1);
#line 69
  x = (uint32_t )*((int32 *)((void *)((value *)v_x + 1)));
#line 69
  x = __bswap_32(x);
#line 69
  memcpy((void */* __restrict  */)(str + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 69
  return (1L);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_set_b63(value v_str , value v_off , value v_x ) 
{ 
  char *str ;
  size_t off ;
  uint64_t x ;

  {
  {
#line 70
  str = (char *)v_str;
#line 70
  off = (size_t )(v_off >> 1);
#line 70
  x = (uint64_t )(v_x >> 1);
#line 70
  x = __bswap_64(x);
#line 70
  memcpy((void */* __restrict  */)(str + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 70
  return (1L);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_set_b64(value v_str , value v_off , value v_x ) 
{ 
  char *str ;
  size_t off ;
  uint64_t x ;

  {
  {
#line 71
  str = (char *)v_str;
#line 71
  off = (size_t )(v_off >> 1);
#line 71
  x = (uint64_t )*((int64 *)((void *)((value *)v_x + 1)));
#line 71
  x = __bswap_64(x);
#line 71
  memcpy((void */* __restrict  */)(str + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 71
  return (1L);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_htole16(value v_x ) 
{ 
  uint16_t x ;

  {
#line 74
  x = (uint16_t )(v_x >> 1);
#line 74
  x = x;
#line 74
  return (((intnat )x << 1) + 1L);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_htole16_signed(value v_x ) 
{ 
  int16_t x ;

  {
#line 75
  x = (int16_t )(v_x >> 1);
#line 75
  x = x;
#line 75
  return (((intnat )x << 1) + 1L);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_le16toh(value v_x ) 
{ 
  uint16_t x ;

  {
#line 76
  x = (uint16_t )(v_x >> 1);
#line 76
  x = x;
#line 76
  return (((intnat )x << 1) + 1L);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_le16toh_signed(value v_x ) 
{ 
  int16_t x ;

  {
#line 77
  x = (int16_t )(v_x >> 1);
#line 77
  x = x;
#line 77
  return (((intnat )x << 1) + 1L);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_htole31(value v_x ) 
{ 
  uint32_t x ;

  {
#line 78
  x = (uint32_t )(v_x >> 1);
#line 78
  x = x;
#line 78
  return (((intnat )x << 1) + 1L);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_htole31_signed(value v_x ) 
{ 
  int32_t x ;

  {
#line 79
  x = (int32_t )(v_x >> 1);
#line 79
  x = x;
#line 79
  return (((intnat )x << 1) + 1L);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_le31toh(value v_x ) 
{ 
  uint32_t x ;

  {
#line 80
  x = (uint32_t )(v_x >> 1);
#line 80
  x = x;
#line 80
  return (((intnat )x << 1) + 1L);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_le31toh_signed(value v_x ) 
{ 
  int32_t x ;

  {
#line 81
  x = (int32_t )(v_x >> 1);
#line 81
  x = x;
#line 81
  return (((intnat )x << 1) + 1L);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_htole32(value v_x ) 
{ 
  int32_t x ;
  value tmp ;

  {
  {
#line 82
  x = *((int32 *)((void *)((value *)v_x + 1)));
#line 82
  x = x;
#line 82
  tmp = caml_copy_int32(x);
  }
#line 82
  return (tmp);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_le32toh(value v_x ) 
{ 
  int32_t x ;
  value tmp ;

  {
  {
#line 83
  x = *((int32 *)((void *)((value *)v_x + 1)));
#line 83
  x = x;
#line 83
  tmp = caml_copy_int32(x);
  }
#line 83
  return (tmp);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_htole64(value v_x ) 
{ 
  int64_t x ;
  value tmp ;

  {
  {
#line 84
  x = (int64_t )*((int64 *)((void *)((value *)v_x + 1)));
#line 84
  x = x;
#line 84
  tmp = caml_copy_int64((int64 )x);
  }
#line 84
  return (tmp);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_le64toh(value v_x ) 
{ 
  int64_t x ;
  value tmp ;

  {
  {
#line 85
  x = (int64_t )*((int64 *)((void *)((value *)v_x + 1)));
#line 85
  x = x;
#line 85
  tmp = caml_copy_int64((int64 )x);
  }
#line 85
  return (tmp);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_lu16(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  uint16_t x ;

  {
  {
#line 87
  str = (char *)v_str;
#line 87
  off = (size_t )(v_off >> 1);
#line 87
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 87
  x = x;
  }
#line 87
  return (((intnat )x << 1) + 1L);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_ls16(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  int16_t x ;

  {
  {
#line 88
  str = (char *)v_str;
#line 88
  off = (size_t )(v_off >> 1);
#line 88
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 88
  x = x;
  }
#line 88
  return (((intnat )x << 1) + 1L);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_lu31(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  uint32_t x ;

  {
  {
#line 89
  str = (char *)v_str;
#line 89
  off = (size_t )(v_off >> 1);
#line 89
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 89
  x = x;
  }
#line 89
  return (((intnat )x << 1) + 1L);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_ls31(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  int32_t x ;

  {
  {
#line 90
  str = (char *)v_str;
#line 90
  off = (size_t )(v_off >> 1);
#line 90
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 90
  x = x;
  }
#line 90
  return (((intnat )x << 1) + 1L);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_ls32(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  int32_t x ;
  value tmp ;

  {
  {
#line 91
  str = (char *)v_str;
#line 91
  off = (size_t )(v_off >> 1);
#line 91
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 91
  x = x;
#line 91
  tmp = caml_copy_int32(x);
  }
#line 91
  return (tmp);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_lu63(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  uint64_t x ;

  {
  {
#line 92
  str = (char *)v_str;
#line 92
  off = (size_t )(v_off >> 1);
#line 92
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 92
  x = x;
  }
#line 92
  return (((intnat )x << 1) + 1L);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_ls63(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  int64_t x ;

  {
  {
#line 93
  str = (char *)v_str;
#line 93
  off = (size_t )(v_off >> 1);
#line 93
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 93
  x = x;
  }
#line 93
  return ((x << 1) + 1L);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_ls64(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  int64_t x ;
  value tmp ;

  {
  {
#line 94
  str = (char *)v_str;
#line 94
  off = (size_t )(v_off >> 1);
#line 94
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 94
  x = x;
#line 94
  tmp = caml_copy_int64((int64 )x);
  }
#line 94
  return (tmp);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_set_l16(value v_str , value v_off , value v_x ) 
{ 
  char *str ;
  size_t off ;
  uint16_t x ;

  {
  {
#line 96
  str = (char *)v_str;
#line 96
  off = (size_t )(v_off >> 1);
#line 96
  x = (uint16_t )(v_x >> 1);
#line 96
  x = x;
#line 96
  memcpy((void */* __restrict  */)(str + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 96
  return (1L);
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_set_l31(value v_str , value v_off , value v_x ) 
{ 
  char *str ;
  size_t off ;
  uint32_t x ;

  {
  {
#line 97
  str = (char *)v_str;
#line 97
  off = (size_t )(v_off >> 1);
#line 97
  x = (uint32_t )(v_x >> 1);
#line 97
  x = x;
#line 97
  memcpy((void */* __restrict  */)(str + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 97
  return (1L);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_set_l32(value v_str , value v_off , value v_x ) 
{ 
  char *str ;
  size_t off ;
  uint32_t x ;

  {
  {
#line 98
  str = (char *)v_str;
#line 98
  off = (size_t )(v_off >> 1);
#line 98
  x = (uint32_t )*((int32 *)((void *)((value *)v_x + 1)));
#line 98
  x = x;
#line 98
  memcpy((void */* __restrict  */)(str + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 98
  return (1L);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_set_l63(value v_str , value v_off , value v_x ) 
{ 
  char *str ;
  size_t off ;
  uint64_t x ;

  {
  {
#line 99
  str = (char *)v_str;
#line 99
  off = (size_t )(v_off >> 1);
#line 99
  x = (uint64_t )(v_x >> 1);
#line 99
  x = x;
#line 99
  memcpy((void */* __restrict  */)(str + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 99
  return (1L);
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_set_l64(value v_str , value v_off , value v_x ) 
{ 
  char *str ;
  size_t off ;
  uint64_t x ;

  {
  {
#line 100
  str = (char *)v_str;
#line 100
  off = (size_t )(v_off >> 1);
#line 100
  x = (uint64_t )*((int64 *)((void *)((value *)v_x + 1)));
#line 100
  x = x;
#line 100
  memcpy((void */* __restrict  */)(str + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 100
  return (1L);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_u8(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  uint8_t x ;

  {
  {
#line 106
  str = (char *)v_str;
#line 106
  off = (size_t )(v_off >> 1);
#line 106
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 106
  x = x;
  }
#line 106
  return (((intnat )x << 1) + 1L);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_s8(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  int8_t x ;

  {
  {
#line 107
  str = (char *)v_str;
#line 107
  off = (size_t )(v_off >> 1);
#line 107
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 107
  x = x;
  }
#line 107
  return (((intnat )x << 1) + 1L);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_hu16(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  uint16_t x ;

  {
  {
#line 108
  str = (char *)v_str;
#line 108
  off = (size_t )(v_off >> 1);
#line 108
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 108
  x = x;
  }
#line 108
  return (((intnat )x << 1) + 1L);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_hs16(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  int16_t x ;

  {
  {
#line 109
  str = (char *)v_str;
#line 109
  off = (size_t )(v_off >> 1);
#line 109
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 109
  x = x;
  }
#line 109
  return (((intnat )x << 1) + 1L);
}
}
#line 110 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_hu31(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  uint32_t x ;

  {
  {
#line 110
  str = (char *)v_str;
#line 110
  off = (size_t )(v_off >> 1);
#line 110
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 110
  x = x;
  }
#line 110
  return (((intnat )x << 1) + 1L);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_hs31(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  int32_t x ;

  {
  {
#line 111
  str = (char *)v_str;
#line 111
  off = (size_t )(v_off >> 1);
#line 111
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 111
  x = x;
  }
#line 111
  return (((intnat )x << 1) + 1L);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_hs32(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  int32_t x ;
  value tmp ;

  {
  {
#line 112
  str = (char *)v_str;
#line 112
  off = (size_t )(v_off >> 1);
#line 112
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 112
  x = x;
#line 112
  tmp = caml_copy_int32(x);
  }
#line 112
  return (tmp);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_hu63(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  uint64_t x ;

  {
  {
#line 113
  str = (char *)v_str;
#line 113
  off = (size_t )(v_off >> 1);
#line 113
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 113
  x = x;
  }
#line 113
  return (((intnat )x << 1) + 1L);
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_hs63(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  int64_t x ;

  {
  {
#line 114
  str = (char *)v_str;
#line 114
  off = (size_t )(v_off >> 1);
#line 114
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 114
  x = x;
  }
#line 114
  return ((x << 1) + 1L);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_get_hs64(value v_str , value v_off ) 
{ 
  char *str ;
  size_t off ;
  int64_t x ;
  value tmp ;

  {
  {
#line 115
  str = (char *)v_str;
#line 115
  off = (size_t )(v_off >> 1);
#line 115
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(str + off),
         sizeof(x));
#line 115
  x = x;
#line 115
  tmp = caml_copy_int64((int64 )x);
  }
#line 115
  return (tmp);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_set_8(value v_str , value v_off , value v_x ) 
{ 
  char *str ;
  size_t off ;
  uint8_t x ;

  {
  {
#line 117
  str = (char *)v_str;
#line 117
  off = (size_t )(v_off >> 1);
#line 117
  x = (uint8_t )(v_x >> 1);
#line 117
  x = x;
#line 117
  memcpy((void */* __restrict  */)(str + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 117
  return (1L);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_set_h16(value v_str , value v_off , value v_x ) 
{ 
  char *str ;
  size_t off ;
  uint16_t x ;

  {
  {
#line 118
  str = (char *)v_str;
#line 118
  off = (size_t )(v_off >> 1);
#line 118
  x = (uint16_t )(v_x >> 1);
#line 118
  x = x;
#line 118
  memcpy((void */* __restrict  */)(str + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 118
  return (1L);
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_set_h31(value v_str , value v_off , value v_x ) 
{ 
  char *str ;
  size_t off ;
  uint32_t x ;

  {
  {
#line 119
  str = (char *)v_str;
#line 119
  off = (size_t )(v_off >> 1);
#line 119
  x = (uint32_t )(v_x >> 1);
#line 119
  x = x;
#line 119
  memcpy((void */* __restrict  */)(str + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 119
  return (1L);
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_set_h32(value v_str , value v_off , value v_x ) 
{ 
  char *str ;
  size_t off ;
  uint32_t x ;

  {
  {
#line 120
  str = (char *)v_str;
#line 120
  off = (size_t )(v_off >> 1);
#line 120
  x = (uint32_t )*((int32 *)((void *)((value *)v_x + 1)));
#line 120
  x = x;
#line 120
  memcpy((void */* __restrict  */)(str + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 120
  return (1L);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_set_h63(value v_str , value v_off , value v_x ) 
{ 
  char *str ;
  size_t off ;
  uint64_t x ;

  {
  {
#line 121
  str = (char *)v_str;
#line 121
  off = (size_t )(v_off >> 1);
#line 121
  x = (uint64_t )(v_x >> 1);
#line 121
  x = x;
#line 121
  memcpy((void */* __restrict  */)(str + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 121
  return (1L);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endian.c"
value caml_extunix_set_h64(value v_str , value v_off , value v_x ) 
{ 
  char *str ;
  size_t off ;
  uint64_t x ;

  {
  {
#line 122
  str = (char *)v_str;
#line 122
  off = (size_t )(v_off >> 1);
#line 122
  x = (uint64_t )*((int64 *)((void *)((value *)v_x + 1)));
#line 122
  x = x;
#line 122
  memcpy((void */* __restrict  */)(str + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 122
  return (1L);
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 227 "/usr/lib/ocaml/caml/mlvalues.h"
extern mlsize_t caml_string_length(value  ) ;
#line 38 "/usr/lib/ocaml/caml/memory.h"
extern void *caml_stat_alloc(asize_t  ) ;
#line 39
extern void caml_stat_free(void * ) ;
#line 796 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4), __leaf__)) linkat)(int __fromfd ,
                                                                                               char const   *__from ,
                                                                                               int __tofd ,
                                                                                               char const   *__to ,
                                                                                               int __flags ) ;
#line 816
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3), __leaf__)) symlinkat)(char const   *__from ,
                                                                                                  int __tofd ,
                                                                                                  char const   *__to ) ;
#line 820
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(2,3), __leaf__)) readlinkat)(int __fd ,
                                                                                                       char const   * __restrict  __path ,
                                                                                                       char * __restrict  __buf ,
                                                                                                       size_t __len ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) unlinkat)(int __fd ,
                                                                                               char const   *__name ,
                                                                                               int __flag ) ;
#line 29 "/usr/lib/ocaml/caml/alloc.h"
extern value caml_alloc_small(mlsize_t  , tag_t  ) ;
#line 34
extern value caml_copy_double(double  ) ;
#line 48
extern int caml_convert_flag_list(value  , int * ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 185 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) renameat)(int __oldfd ,
                                                                               char const   *__old ,
                                                                               int __newfd ,
                                                                               char const   *__new ) ;
#line 243 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) fstatat)(int __fd ,
                                                                                                char const   * __restrict  __file ,
                                                                                                struct stat * __restrict  __buf ,
                                                                                                int __flag )  __asm__("fstatat64")  ;
#line 328
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) mkdirat)(int __fd ,
                                                                                              char const   *__path ,
                                                                                              __mode_t __mode ) ;
#line 174 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(2))) openat)(int __fd , char const   *__file ,
                                                     int __oflag  , ...)  __asm__("openat64")  ;
#line 10 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/atfile.c"
extern value cst_to_constr(int n , int *tbl , int size , int deflt ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/atfile.c"
static int file_kind_table[7]  = {      32768,      16384,      8192,      24576, 
        40960,      4096,      49152};
#line 32 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/atfile.c"
static int at_flags_table[5]  = {      512,      256,      512,      1024, 
        2048};
#line 36 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/atfile.c"
static value stat_aux(struct stat *buf ) 
{ 
  struct caml__roots_block *caml__frame ;
  value atime ;
  value mtime ;
  value ctime ;
  value offset ;
  value v ;
  struct caml__roots_block caml__roots_atime ;
  int caml__dummy_atime  __attribute__((__unused__)) ;
  value caml__temp_result ;

  {
  {
#line 38
  caml__frame = caml_local_roots;
#line 39
  atime = 1L;
#line 39
  mtime = 1L;
#line 39
  ctime = 1L;
#line 39
  offset = 1L;
#line 39
  v = 1L;
#line 39
  caml__roots_atime.next = caml_local_roots;
#line 39
  caml_local_roots = & caml__roots_atime;
#line 39
  caml__roots_atime.nitems = (intnat )1;
#line 39
  caml__roots_atime.ntables = (intnat )5;
#line 39
  caml__roots_atime.tables[0] = & atime;
#line 39
  caml__roots_atime.tables[1] = & mtime;
#line 39
  caml__roots_atime.tables[2] = & ctime;
#line 39
  caml__roots_atime.tables[3] = & offset;
#line 39
  caml__roots_atime.tables[4] = & v;
#line 39
  caml__dummy_atime = 0;
#line 41
  atime = caml_copy_double((double )buf->st_atim.tv_sec);
#line 42
  mtime = caml_copy_double((double )buf->st_mtim.tv_sec);
#line 43
  ctime = caml_copy_double((double )buf->st_ctim.tv_sec);
#line 44
  offset = (buf->st_size << 1) + 1L;
#line 45
  v = caml_alloc_small((mlsize_t )12, (tag_t )0);
#line 46
  *((value *)v + 0) = ((intnat )buf->st_dev << 1) + 1L;
#line 47
  *((value *)v + 1) = ((intnat )buf->st_ino << 1) + 1L;
#line 48
  *((value *)v + 2) = cst_to_constr((int )(buf->st_mode & 61440U), file_kind_table,
                                    (int )(sizeof(file_kind_table) / sizeof(int )),
                                    0);
#line 50
  *((value *)v + 3) = ((intnat )(buf->st_mode & 4095U) << 1) + 1L;
#line 51
  *((value *)v + 4) = ((intnat )buf->st_nlink << 1) + 1L;
#line 52
  *((value *)v + 5) = ((intnat )buf->st_uid << 1) + 1L;
#line 53
  *((value *)v + 6) = ((intnat )buf->st_gid << 1) + 1L;
#line 54
  *((value *)v + 7) = ((intnat )buf->st_rdev << 1) + 1L;
#line 55
  *((value *)v + 8) = offset;
#line 56
  *((value *)v + 9) = atime;
#line 57
  *((value *)v + 10) = mtime;
#line 58
  *((value *)v + 11) = ctime;
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    caml__temp_result = v;
#line 59
    caml_local_roots = caml__frame;
#line 59
    return (caml__temp_result);
#line 59
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  return (0L);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/atfile.c"
value caml_extunix_fstatat(value v_dirfd , value v_name , value v_flags ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_dirfd ;
  int caml__dummy_v_dirfd  __attribute__((__unused__)) ;
  int ret ;
  struct stat buf ;
  char *p ;
  mlsize_t tmp ;
  void *tmp___0 ;
  int flags ;
  int tmp___1 ;
  value caml__temp_result ;
  value tmp___2 ;

  {
  {
#line 64
  caml__frame = caml_local_roots;
#line 64
  caml__roots_v_dirfd.next = caml_local_roots;
#line 64
  caml_local_roots = & caml__roots_v_dirfd;
#line 64
  caml__roots_v_dirfd.nitems = (intnat )1;
#line 64
  caml__roots_v_dirfd.ntables = (intnat )3;
#line 64
  caml__roots_v_dirfd.tables[0] = & v_dirfd;
#line 64
  caml__roots_v_dirfd.tables[1] = & v_name;
#line 64
  caml__roots_v_dirfd.tables[2] = & v_flags;
#line 64
  caml__dummy_v_dirfd = 0;
#line 67
  tmp = caml_string_length(v_name);
#line 67
  tmp___0 = caml_stat_alloc(tmp + 1UL);
#line 67
  p = (char *)tmp___0;
#line 68
  tmp___1 = caml_convert_flag_list(v_flags, at_flags_table);
#line 68
  flags = tmp___1;
#line 69
  flags &= 2304;
#line 71
  strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)((char *)v_name));
#line 72
  caml_enter_blocking_section();
#line 73
  ret = fstatat((int )(v_dirfd >> 1), (char const   */* __restrict  */)p, (struct stat */* __restrict  */)(& buf),
                flags);
#line 74
  caml_leave_blocking_section();
#line 75
  caml_stat_free((void *)p);
  }
#line 76
  if (ret != 0) {
    {
#line 76
    uerror((char *)"fstatat", v_name);
    }
  }
#line 77
  if (buf.st_size > (1L << (8UL * sizeof(value ) - 2UL)) - 1L) {
#line 77
    if ((buf.st_mode & 61440U) == 32768U) {
      {
#line 78
      unix_error(75, (char *)"fstatat", v_name);
      }
    }
  }
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    tmp___2 = stat_aux(& buf);
#line 79
    caml__temp_result = tmp___2;
#line 79
    caml_local_roots = caml__frame;
    }
#line 79
    return (caml__temp_result);
#line 79
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return (0L);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/atfile.c"
value caml_extunix_unlinkat(value v_dirfd , value v_name , value v_flags ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_dirfd ;
  int caml__dummy_v_dirfd  __attribute__((__unused__)) ;
  char *p ;
  mlsize_t tmp ;
  void *tmp___0 ;
  int ret ;
  int flags ;
  int tmp___1 ;
  value caml__temp_result ;

  {
  {
#line 84
  caml__frame = caml_local_roots;
#line 84
  caml__roots_v_dirfd.next = caml_local_roots;
#line 84
  caml_local_roots = & caml__roots_v_dirfd;
#line 84
  caml__roots_v_dirfd.nitems = (intnat )1;
#line 84
  caml__roots_v_dirfd.ntables = (intnat )3;
#line 84
  caml__roots_v_dirfd.tables[0] = & v_dirfd;
#line 84
  caml__roots_v_dirfd.tables[1] = & v_name;
#line 84
  caml__roots_v_dirfd.tables[2] = & v_flags;
#line 84
  caml__dummy_v_dirfd = 0;
#line 85
  tmp = caml_string_length(v_name);
#line 85
  tmp___0 = caml_stat_alloc(tmp + 1UL);
#line 85
  p = (char *)tmp___0;
#line 86
  ret = 0;
#line 87
  tmp___1 = caml_convert_flag_list(v_flags, at_flags_table);
#line 87
  flags = tmp___1;
#line 88
  flags &= 512;
#line 90
  strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)((char *)v_name));
#line 91
  caml_enter_blocking_section();
#line 92
  ret = unlinkat((int )(v_dirfd >> 1), (char const   *)p, flags);
#line 93
  caml_leave_blocking_section();
#line 94
  caml_stat_free((void *)p);
  }
#line 95
  if (ret != 0) {
    {
#line 95
    uerror((char *)"unlinkat", v_name);
    }
  }
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    caml__temp_result = 1L;
#line 96
    caml_local_roots = caml__frame;
#line 96
    return (caml__temp_result);
#line 96
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  return (0L);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/atfile.c"
value caml_extunix_renameat(value v_oldfd , value v_oldname , value v_newfd , value v_newname ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_oldfd ;
  int caml__dummy_v_oldfd  __attribute__((__unused__)) ;
  int ret ;
  int tmp ;
  value caml__temp_result ;

  {
  {
#line 101
  caml__frame = caml_local_roots;
#line 101
  caml__roots_v_oldfd.next = caml_local_roots;
#line 101
  caml_local_roots = & caml__roots_v_oldfd;
#line 101
  caml__roots_v_oldfd.nitems = (intnat )1;
#line 101
  caml__roots_v_oldfd.ntables = (intnat )4;
#line 101
  caml__roots_v_oldfd.tables[0] = & v_oldfd;
#line 101
  caml__roots_v_oldfd.tables[1] = & v_oldname;
#line 101
  caml__roots_v_oldfd.tables[2] = & v_newfd;
#line 101
  caml__roots_v_oldfd.tables[3] = & v_newname;
#line 101
  caml__dummy_v_oldfd = 0;
#line 102
  tmp = renameat((int )(v_oldfd >> 1), (char const   *)((char *)v_oldname), (int )(v_newfd >> 1),
                 (char const   *)((char *)v_newname));
#line 102
  ret = tmp;
  }
#line 103
  if (ret != 0) {
    {
#line 103
    uerror((char *)"renameat", v_oldname);
    }
  }
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    caml__temp_result = 1L;
#line 104
    caml_local_roots = caml__frame;
#line 104
    return (caml__temp_result);
#line 104
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return (0L);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/atfile.c"
value caml_extunix_mkdirat(value v_dirfd , value v_name , value v_mode ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_dirfd ;
  int caml__dummy_v_dirfd  __attribute__((__unused__)) ;
  int ret ;
  int tmp ;
  value caml__temp_result ;

  {
  {
#line 109
  caml__frame = caml_local_roots;
#line 109
  caml__roots_v_dirfd.next = caml_local_roots;
#line 109
  caml_local_roots = & caml__roots_v_dirfd;
#line 109
  caml__roots_v_dirfd.nitems = (intnat )1;
#line 109
  caml__roots_v_dirfd.ntables = (intnat )3;
#line 109
  caml__roots_v_dirfd.tables[0] = & v_dirfd;
#line 109
  caml__roots_v_dirfd.tables[1] = & v_name;
#line 109
  caml__roots_v_dirfd.tables[2] = & v_mode;
#line 109
  caml__dummy_v_dirfd = 0;
#line 110
  tmp = mkdirat((int )(v_dirfd >> 1), (char const   *)((char *)v_name), (__mode_t )((int )(v_mode >> 1)));
#line 110
  ret = tmp;
  }
#line 111
  if (ret != 0) {
    {
#line 111
    uerror((char *)"mkdirat", v_name);
    }
  }
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    caml__temp_result = 1L;
#line 112
    caml_local_roots = caml__frame;
#line 112
    return (caml__temp_result);
#line 112
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  return (0L);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/atfile.c"
value caml_extunix_linkat(value v_olddirfd , value v_oldname , value v_newdirfd ,
                          value v_newname , value v_flags ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_olddirfd ;
  int caml__dummy_v_olddirfd  __attribute__((__unused__)) ;
  int ret ;
  int flags ;
  int tmp ;
  value caml__temp_result ;

  {
  {
#line 117
  caml__frame = caml_local_roots;
#line 117
  caml__roots_v_olddirfd.next = caml_local_roots;
#line 117
  caml_local_roots = & caml__roots_v_olddirfd;
#line 117
  caml__roots_v_olddirfd.nitems = (intnat )1;
#line 117
  caml__roots_v_olddirfd.ntables = (intnat )5;
#line 117
  caml__roots_v_olddirfd.tables[0] = & v_olddirfd;
#line 117
  caml__roots_v_olddirfd.tables[1] = & v_oldname;
#line 117
  caml__roots_v_olddirfd.tables[2] = & v_newdirfd;
#line 117
  caml__roots_v_olddirfd.tables[3] = & v_newname;
#line 117
  caml__roots_v_olddirfd.tables[4] = & v_flags;
#line 117
  caml__dummy_v_olddirfd = 0;
#line 118
  ret = 0;
#line 119
  tmp = caml_convert_flag_list(v_flags, at_flags_table);
#line 119
  flags = tmp;
#line 120
  flags &= 1024;
#line 121
  ret = linkat((int )(v_olddirfd >> 1), (char const   *)((char *)v_oldname), (int )(v_newdirfd >> 1),
               (char const   *)((char *)v_newname), flags);
  }
#line 122
  if (ret != 0) {
    {
#line 122
    uerror((char *)"linkat", v_oldname);
    }
  }
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    caml__temp_result = 1L;
#line 123
    caml_local_roots = caml__frame;
#line 123
    return (caml__temp_result);
#line 123
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  return (0L);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/atfile.c"
value caml_extunix_symlinkat(value v_path , value v_newdirfd , value v_newname ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_path ;
  int caml__dummy_v_path  __attribute__((__unused__)) ;
  int ret ;
  int tmp ;
  value caml__temp_result ;

  {
  {
#line 128
  caml__frame = caml_local_roots;
#line 128
  caml__roots_v_path.next = caml_local_roots;
#line 128
  caml_local_roots = & caml__roots_v_path;
#line 128
  caml__roots_v_path.nitems = (intnat )1;
#line 128
  caml__roots_v_path.ntables = (intnat )3;
#line 128
  caml__roots_v_path.tables[0] = & v_path;
#line 128
  caml__roots_v_path.tables[1] = & v_newdirfd;
#line 128
  caml__roots_v_path.tables[2] = & v_newname;
#line 128
  caml__dummy_v_path = 0;
#line 129
  tmp = symlinkat((char const   *)((char *)v_path), (int )(v_newdirfd >> 1), (char const   *)((char *)v_newname));
#line 129
  ret = tmp;
  }
#line 130
  if (ret != 0) {
    {
#line 130
    uerror((char *)"symlinkat", v_path);
    }
  }
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    caml__temp_result = 1L;
#line 131
    caml_local_roots = caml__frame;
#line 131
    return (caml__temp_result);
#line 131
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  return (0L);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/atfile.c"
value caml_extunix_openat(value v_dirfd , value path , value flags , value perm ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_dirfd ;
  int caml__dummy_v_dirfd  __attribute__((__unused__)) ;
  int ret ;
  int cv_flags ;
  char *p ;
  mlsize_t tmp ;
  void *tmp___0 ;
  value caml__temp_result ;

  {
  {
#line 136
  caml__frame = caml_local_roots;
#line 136
  caml__roots_v_dirfd.next = caml_local_roots;
#line 136
  caml_local_roots = & caml__roots_v_dirfd;
#line 136
  caml__roots_v_dirfd.nitems = (intnat )1;
#line 136
  caml__roots_v_dirfd.ntables = (intnat )4;
#line 136
  caml__roots_v_dirfd.tables[0] = & v_dirfd;
#line 136
  caml__roots_v_dirfd.tables[1] = & path;
#line 136
  caml__roots_v_dirfd.tables[2] = & flags;
#line 136
  caml__roots_v_dirfd.tables[3] = & perm;
#line 136
  caml__dummy_v_dirfd = 0;
#line 140
  cv_flags = extunix_open_flags(flags);
#line 141
  tmp = caml_string_length(path);
#line 141
  tmp___0 = caml_stat_alloc(tmp + 1UL);
#line 141
  p = (char *)tmp___0;
#line 142
  strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)((char *)path));
#line 144
  caml_enter_blocking_section();
#line 145
  ret = openat((int )(v_dirfd >> 1), (char const   *)p, cv_flags, (int )(perm >> 1));
#line 146
  caml_leave_blocking_section();
#line 147
  caml_stat_free((void *)p);
  }
#line 148
  if (ret == -1) {
    {
#line 148
    uerror((char *)"openat", path);
    }
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    caml__temp_result = ((intnat )ret << 1) + 1L;
#line 149
    caml_local_roots = caml__frame;
#line 149
    return (caml__temp_result);
#line 149
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  return (0L);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/atfile.c"
char *readlinkat_malloc(int dirfd___0 , char const   *filename ) 
{ 
  int size ;
  int nchars ;
  char *buffer ;
  char *tmp ;
  void *tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 154
  size = 100;
#line 156
  buffer = (char *)((void *)0);
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 161
    tmp___0 = realloc((void *)buffer, (size_t )size);
#line 161
    tmp = (char *)tmp___0;
    }
#line 162
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 164
      free((void *)buffer);
      }
#line 165
      return ((char *)((void *)0));
    }
    {
#line 167
    buffer = tmp;
#line 168
    tmp___1 = readlinkat(dirfd___0, (char const   */* __restrict  */)filename, (char */* __restrict  */)buffer,
                         (size_t )size);
#line 168
    nchars = (int )tmp___1;
    }
#line 169
    if (nchars < 0) {
      {
#line 171
      free((void *)buffer);
      }
#line 172
      return ((char *)((void *)0));
    }
#line 174
    if (nchars < size) {
#line 176
      *(buffer + nchars) = (char )'\000';
#line 177
      return (buffer);
    }
#line 179
    size *= 2;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/atfile.c"
value caml_extunix_readlinkat(value v_dirfd , value v_name ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_dirfd ;
  int caml__dummy_v_dirfd  __attribute__((__unused__)) ;
  value v_link ;
  struct caml__roots_block caml__roots_v_link ;
  int caml__dummy_v_link  __attribute__((__unused__)) ;
  char *res ;
  char *p ;
  mlsize_t tmp ;
  void *tmp___0 ;
  value caml__temp_result ;

  {
  {
#line 185
  caml__frame = caml_local_roots;
#line 185
  caml__roots_v_dirfd.next = caml_local_roots;
#line 185
  caml_local_roots = & caml__roots_v_dirfd;
#line 185
  caml__roots_v_dirfd.nitems = (intnat )1;
#line 185
  caml__roots_v_dirfd.ntables = (intnat )2;
#line 185
  caml__roots_v_dirfd.tables[0] = & v_dirfd;
#line 185
  caml__roots_v_dirfd.tables[1] = & v_name;
#line 185
  caml__dummy_v_dirfd = 0;
#line 186
  v_link = 1L;
#line 186
  caml__roots_v_link.next = caml_local_roots;
#line 186
  caml_local_roots = & caml__roots_v_link;
#line 186
  caml__roots_v_link.nitems = (intnat )1;
#line 186
  caml__roots_v_link.ntables = (intnat )1;
#line 186
  caml__roots_v_link.tables[0] = & v_link;
#line 186
  caml__dummy_v_link = 0;
#line 188
  tmp = caml_string_length(v_name);
#line 188
  tmp___0 = caml_stat_alloc(tmp + 1UL);
#line 188
  p = (char *)tmp___0;
#line 189
  strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)((char *)v_name));
#line 191
  caml_enter_blocking_section();
#line 192
  res = readlinkat_malloc((int )(v_dirfd >> 1), (char const   *)p);
#line 193
  caml_leave_blocking_section();
#line 194
  caml_stat_free((void *)p);
  }
#line 195
  if ((unsigned long )res == (unsigned long )((void *)0)) {
    {
#line 195
    uerror((char *)"readlinkat", v_name);
    }
  }
  {
#line 196
  v_link = caml_copy_string((char const   *)res);
#line 197
  free((void *)res);
  }
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    caml__temp_result = v_link;
#line 198
    caml_local_roots = caml__frame;
#line 198
    return (caml__temp_result);
#line 198
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  return (0L);
}
}
#line 34 "/usr/include/x86_64-linux-gnu/sys/eventfd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) eventfd)(int __count ,
                                                                              int __flags ) ;
#line 37
extern int eventfd_read(int __fd , eventfd_t *__value ) ;
#line 40
extern int eventfd_write(int __fd , eventfd_t __value ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/eventfd.c"
value caml_extunix_eventfd(value v_init ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_init ;
  int caml__dummy_v_init  __attribute__((__unused__)) ;
  int fd ;
  int tmp ;
  value caml__temp_result ;

  {
  {
#line 9
  caml__frame = caml_local_roots;
#line 9
  caml__roots_v_init.next = caml_local_roots;
#line 9
  caml_local_roots = & caml__roots_v_init;
#line 9
  caml__roots_v_init.nitems = (intnat )1;
#line 9
  caml__roots_v_init.ntables = (intnat )1;
#line 9
  caml__roots_v_init.tables[0] = & v_init;
#line 9
  caml__dummy_v_init = 0;
#line 10
  tmp = eventfd((int )(v_init >> 1), 0);
#line 10
  fd = tmp;
  }
#line 11
  if (-1 == fd) {
    {
#line 11
    uerror((char *)"eventfd", (value )0);
    }
  }
  {
#line 12
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12
    caml__temp_result = ((intnat )fd << 1) + 1L;
#line 12
    caml_local_roots = caml__frame;
#line 12
    return (caml__temp_result);
#line 12
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 13
  return (0L);
}
}
#line 15 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/eventfd.c"
value caml_extunix_eventfd_read(value v_fd ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_fd ;
  int caml__dummy_v_fd  __attribute__((__unused__)) ;
  eventfd_t v ;
  int tmp ;
  value caml__temp_result ;
  value tmp___0 ;

  {
  {
#line 17
  caml__frame = caml_local_roots;
#line 17
  caml__roots_v_fd.next = caml_local_roots;
#line 17
  caml_local_roots = & caml__roots_v_fd;
#line 17
  caml__roots_v_fd.nitems = (intnat )1;
#line 17
  caml__roots_v_fd.ntables = (intnat )1;
#line 17
  caml__roots_v_fd.tables[0] = & v_fd;
#line 17
  caml__dummy_v_fd = 0;
#line 19
  tmp = eventfd_read((int )(v_fd >> 1), & v);
  }
#line 19
  if (-1 == tmp) {
    {
#line 20
    uerror((char *)"eventfd_read", (value )0);
    }
  }
  {
#line 21
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 21
    tmp___0 = caml_copy_int64((int64 )v);
#line 21
    caml__temp_result = tmp___0;
#line 21
    caml_local_roots = caml__frame;
    }
#line 21
    return (caml__temp_result);
#line 21
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 22
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/eventfd.c"
value caml_extunix_eventfd_write(value v_fd , value v_val ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_fd ;
  int caml__dummy_v_fd  __attribute__((__unused__)) ;
  int tmp ;
  value caml__temp_result ;

  {
  {
#line 26
  caml__frame = caml_local_roots;
#line 26
  caml__roots_v_fd.next = caml_local_roots;
#line 26
  caml_local_roots = & caml__roots_v_fd;
#line 26
  caml__roots_v_fd.nitems = (intnat )1;
#line 26
  caml__roots_v_fd.ntables = (intnat )2;
#line 26
  caml__roots_v_fd.tables[0] = & v_fd;
#line 26
  caml__roots_v_fd.tables[1] = & v_val;
#line 26
  caml__dummy_v_fd = 0;
#line 27
  tmp = eventfd_write((int )(v_fd >> 1), (eventfd_t )*((int64 *)((void *)((value *)v_val + 1))));
  }
#line 27
  if (-1 == tmp) {
    {
#line 28
    uerror((char *)"eventfd_write", (value )0);
    }
  }
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    caml__temp_result = 1L;
#line 29
    caml_local_roots = caml__frame;
#line 29
    return (caml__temp_result);
#line 29
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 30
  return (0L);
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/uname.c"
value caml_extunix_uname(value u ) 
{ 
  struct utsname uname_data ;
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_u ;
  int caml__dummy_u  __attribute__((__unused__)) ;
  value result ;
  value domainname ;
  struct caml__roots_block caml__roots_result ;
  int caml__dummy_result  __attribute__((__unused__)) ;
  mlsize_t caml__temp_offset ;
  value caml__temp_val ;
  value tmp ;
  mlsize_t caml__temp_offset___0 ;
  value caml__temp_val___0 ;
  value tmp___0 ;
  mlsize_t caml__temp_offset___1 ;
  value caml__temp_val___1 ;
  value tmp___1 ;
  mlsize_t caml__temp_offset___2 ;
  value caml__temp_val___2 ;
  value tmp___2 ;
  mlsize_t caml__temp_offset___3 ;
  value caml__temp_val___3 ;
  value tmp___3 ;
  int tmp___4 ;
  value caml__temp_result ;

  {
  {
#line 11
  caml__frame = caml_local_roots;
#line 11
  caml__roots_u.next = caml_local_roots;
#line 11
  caml_local_roots = & caml__roots_u;
#line 11
  caml__roots_u.nitems = (intnat )1;
#line 11
  caml__roots_u.ntables = (intnat )1;
#line 11
  caml__roots_u.tables[0] = & u;
#line 11
  caml__dummy_u = 0;
#line 12
  result = 1L;
#line 12
  domainname = 1L;
#line 12
  caml__roots_result.next = caml_local_roots;
#line 12
  caml_local_roots = & caml__roots_result;
#line 12
  caml__roots_result.nitems = (intnat )1;
#line 12
  caml__roots_result.ntables = (intnat )2;
#line 12
  caml__roots_result.tables[0] = & result;
#line 12
  caml__roots_result.tables[1] = & domainname;
#line 12
  caml__dummy_result = 0;
#line 14
  memset((void *)(& uname_data), 0, sizeof(uname_data));
#line 16
  tmp___4 = uname(& uname_data);
  }
#line 16
  if (tmp___4 == 0) {
    {
#line 18
    result = caml_alloc((mlsize_t )5, (tag_t )0);
    }
    {
#line 19
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 19
      caml__temp_offset = (mlsize_t )0;
#line 19
      tmp = caml_copy_string((char const   *)(& uname_data.sysname[0]));
#line 19
      caml__temp_val = tmp;
#line 19
      caml_modify((value *)result + caml__temp_offset, caml__temp_val);
      }
#line 19
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 20
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 20
      caml__temp_offset___0 = (mlsize_t )1;
#line 20
      tmp___0 = caml_copy_string((char const   *)(& uname_data.nodename[0]));
#line 20
      caml__temp_val___0 = tmp___0;
#line 20
      caml_modify((value *)result + caml__temp_offset___0, caml__temp_val___0);
      }
#line 20
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 21
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 21
      caml__temp_offset___1 = (mlsize_t )2;
#line 21
      tmp___1 = caml_copy_string((char const   *)(& uname_data.release[0]));
#line 21
      caml__temp_val___1 = tmp___1;
#line 21
      caml_modify((value *)result + caml__temp_offset___1, caml__temp_val___1);
      }
#line 21
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 22
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 22
      caml__temp_offset___2 = (mlsize_t )3;
#line 22
      tmp___2 = caml_copy_string((char const   *)(& uname_data.version[0]));
#line 22
      caml__temp_val___2 = tmp___2;
#line 22
      caml_modify((value *)result + caml__temp_offset___2, caml__temp_val___2);
      }
#line 22
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 23
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 23
      caml__temp_offset___3 = (mlsize_t )4;
#line 23
      tmp___3 = caml_copy_string((char const   *)(& uname_data.machine[0]));
#line 23
      caml__temp_val___3 = tmp___3;
#line 23
      caml_modify((value *)result + caml__temp_offset___3, caml__temp_val___3);
      }
#line 23
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else {
    {
#line 27
    uerror((char *)"uname", (value )0);
    }
  }
  {
#line 30
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 30
    caml__temp_result = result;
#line 30
    caml_local_roots = caml__frame;
#line 30
    return (caml__temp_result);
#line 30
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 31
  return (0L);
}
}
#line 916 "/usr/include/stdlib.h"
extern int posix_openpt(int __oflag ) ;
#line 924
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) grantpt)(int __fd ) ;
#line 928
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) unlockpt)(int __fd ) ;
#line 933
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ptsname)(int __fd ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pts.c"
value caml_extunix_posix_openpt(value flags ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_flags ;
  int caml__dummy_flags  __attribute__((__unused__)) ;
  int ret ;
  int cv_flags ;
  value caml__temp_result ;

  {
  {
#line 11
  caml__frame = caml_local_roots;
#line 11
  caml__roots_flags.next = caml_local_roots;
#line 11
  caml_local_roots = & caml__roots_flags;
#line 11
  caml__roots_flags.nitems = (intnat )1;
#line 11
  caml__roots_flags.ntables = (intnat )1;
#line 11
  caml__roots_flags.tables[0] = & flags;
#line 11
  caml__dummy_flags = 0;
#line 13
  cv_flags = extunix_open_flags(flags);
#line 14
  ret = posix_openpt(cv_flags);
  }
#line 15
  if (ret == -1) {
    {
#line 16
    uerror((char *)"posix_openpt", (value )0);
    }
  }
  {
#line 17
  while (1) {
    while_continue: /* CIL Label */ ;
#line 17
    caml__temp_result = ((intnat )ret << 1) + 1L;
#line 17
    caml_local_roots = caml__frame;
#line 17
    return (caml__temp_result);
#line 17
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 18
  return (0L);
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pts.c"
value caml_extunix_grantpt(value fd ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_fd ;
  int caml__dummy_fd  __attribute__((__unused__)) ;
  int tmp ;
  value caml__temp_result ;

  {
  {
#line 22
  caml__frame = caml_local_roots;
#line 22
  caml__roots_fd.next = caml_local_roots;
#line 22
  caml_local_roots = & caml__roots_fd;
#line 22
  caml__roots_fd.nitems = (intnat )1;
#line 22
  caml__roots_fd.ntables = (intnat )1;
#line 22
  caml__roots_fd.tables[0] = & fd;
#line 22
  caml__dummy_fd = 0;
#line 23
  tmp = grantpt((int )(fd >> 1));
  }
#line 23
  if (tmp == -1) {
    {
#line 24
    uerror((char *)"grantpt", (value )0);
    }
  }
  {
#line 25
  while (1) {
    while_continue: /* CIL Label */ ;
#line 25
    caml__temp_result = 1L;
#line 25
    caml_local_roots = caml__frame;
#line 25
    return (caml__temp_result);
#line 25
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 26
  return (0L);
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pts.c"
value caml_extunix_unlockpt(value fd ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_fd ;
  int caml__dummy_fd  __attribute__((__unused__)) ;
  int tmp ;
  value caml__temp_result ;

  {
  {
#line 30
  caml__frame = caml_local_roots;
#line 30
  caml__roots_fd.next = caml_local_roots;
#line 30
  caml_local_roots = & caml__roots_fd;
#line 30
  caml__roots_fd.nitems = (intnat )1;
#line 30
  caml__roots_fd.ntables = (intnat )1;
#line 30
  caml__roots_fd.tables[0] = & fd;
#line 30
  caml__dummy_fd = 0;
#line 31
  tmp = unlockpt((int )(fd >> 1));
  }
#line 31
  if (tmp == -1) {
    {
#line 32
    uerror((char *)"unlockpt", (value )0);
    }
  }
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    caml__temp_result = 1L;
#line 33
    caml_local_roots = caml__frame;
#line 33
    return (caml__temp_result);
#line 33
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 34
  return (0L);
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pts.c"
value caml_extunix_ptsname(value fd ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_fd ;
  int caml__dummy_fd  __attribute__((__unused__)) ;
  value ret ;
  struct caml__roots_block caml__roots_ret ;
  int caml__dummy_ret  __attribute__((__unused__)) ;
  char *name ;
  char *tmp ;
  value caml__temp_result ;

  {
  {
#line 38
  caml__frame = caml_local_roots;
#line 38
  caml__roots_fd.next = caml_local_roots;
#line 38
  caml_local_roots = & caml__roots_fd;
#line 38
  caml__roots_fd.nitems = (intnat )1;
#line 38
  caml__roots_fd.ntables = (intnat )1;
#line 38
  caml__roots_fd.tables[0] = & fd;
#line 38
  caml__dummy_fd = 0;
#line 39
  ret = 1L;
#line 39
  caml__roots_ret.next = caml_local_roots;
#line 39
  caml_local_roots = & caml__roots_ret;
#line 39
  caml__roots_ret.nitems = (intnat )1;
#line 39
  caml__roots_ret.ntables = (intnat )1;
#line 39
  caml__roots_ret.tables[0] = & ret;
#line 39
  caml__dummy_ret = 0;
#line 40
  tmp = ptsname((int )(fd >> 1));
#line 40
  name = tmp;
  }
#line 41
  if ((unsigned long )name == (unsigned long )((char *)0)) {
    {
#line 42
    uerror((char *)"ptsname", (value )0);
    }
  }
  {
#line 43
  ret = caml_copy_string((char const   *)name);
  }
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    caml__temp_result = ret;
#line 44
    caml_local_roots = caml__frame;
#line 44
    return (caml__temp_result);
#line 44
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return (0L);
}
}
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 388
extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off64_t __offset )  __asm__("pread64")  ;
#line 391
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __nbytes , __off64_t __offset )  __asm__("pwrite64")  ;
#line 639
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpgid)(__pid_t __pid ) ;
#line 646
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpgid)(__pid_t __pid ,
                                                                              __pid_t __pgid ) ;
#line 671
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getsid)(__pid_t __pid ) ;
#line 705
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setreuid)(__uid_t __ruid ,
                                                                               __uid_t __euid ) ;
#line 722
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setregid)(__gid_t __rgid ,
                                                                               __gid_t __egid ) ;
#line 743
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setresuid)(__uid_t __ruid ,
                                                                                __uid_t __euid ,
                                                                                __uid_t __suid ) ;
#line 748
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setresgid)(__gid_t __rgid ,
                                                                                __gid_t __egid ,
                                                                                __gid_t __sgid ) ;
#line 770
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ttyname)(int __fd ) ;
#line 839
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) tcgetpgrp)(int __fd ) ;
#line 842
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetpgrp)(int __fd ,
                                                                                __pid_t __pgrp_id ) ;
#line 885 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctermid)(char *__s ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_ttyname(value v_fd ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_fd ;
  int caml__dummy_v_fd  __attribute__((__unused__)) ;
  char *r ;
  char *tmp ;
  value caml__temp_result ;
  value tmp___0 ;

  {
  {
#line 21
  caml__frame = caml_local_roots;
#line 21
  caml__roots_v_fd.next = caml_local_roots;
#line 21
  caml_local_roots = & caml__roots_v_fd;
#line 21
  caml__roots_v_fd.nitems = (intnat )1;
#line 21
  caml__roots_v_fd.ntables = (intnat )1;
#line 21
  caml__roots_v_fd.tables[0] = & v_fd;
#line 21
  caml__dummy_v_fd = 0;
#line 22
  tmp = ttyname((int )(v_fd >> 1));
#line 22
  r = tmp;
  }
#line 23
  if (r) {
    {
#line 24
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 24
      tmp___0 = caml_copy_string((char const   *)r);
#line 24
      caml__temp_result = tmp___0;
#line 24
      caml_local_roots = caml__frame;
      }
#line 24
      return (caml__temp_result);
#line 24
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 26
    uerror((char *)"ttyname", (value )0);
    }
  }
#line 28
  return (0L);
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_ctermid(value v_unit ) 
{ 
  char buf[10] ;
  char *tmp ;
  value tmp___0 ;

  {
  {
#line 38
  tmp = ctermid(buf);
#line 38
  tmp___0 = caml_copy_string((char const   *)tmp);
  }
#line 38
  return (tmp___0);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_setpgid(value v_pid , value v_pgid ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_pid ;
  int caml__dummy_v_pid  __attribute__((__unused__)) ;
  int tmp ;
  value caml__temp_result ;

  {
  {
#line 47
  caml__frame = caml_local_roots;
#line 47
  caml__roots_v_pid.next = caml_local_roots;
#line 47
  caml_local_roots = & caml__roots_v_pid;
#line 47
  caml__roots_v_pid.nitems = (intnat )1;
#line 47
  caml__roots_v_pid.ntables = (intnat )2;
#line 47
  caml__roots_v_pid.tables[0] = & v_pid;
#line 47
  caml__roots_v_pid.tables[1] = & v_pgid;
#line 47
  caml__dummy_v_pid = 0;
#line 48
  tmp = setpgid((int )(v_pid >> 1), (int )(v_pgid >> 1));
  }
#line 48
  if (0 != tmp) {
    {
#line 49
    uerror((char *)"setpgid", (value )0);
    }
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    caml__temp_result = 1L;
#line 50
    caml_local_roots = caml__frame;
#line 50
    return (caml__temp_result);
#line 50
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  return (0L);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_getpgid(value v_pid ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_pid ;
  int caml__dummy_v_pid  __attribute__((__unused__)) ;
  int pgid ;
  __pid_t tmp ;
  value caml__temp_result ;

  {
  {
#line 55
  caml__frame = caml_local_roots;
#line 55
  caml__roots_v_pid.next = caml_local_roots;
#line 55
  caml_local_roots = & caml__roots_v_pid;
#line 55
  caml__roots_v_pid.nitems = (intnat )1;
#line 55
  caml__roots_v_pid.ntables = (intnat )1;
#line 55
  caml__roots_v_pid.tables[0] = & v_pid;
#line 55
  caml__dummy_v_pid = 0;
#line 56
  tmp = getpgid((int )(v_pid >> 1));
#line 56
  pgid = tmp;
  }
#line 57
  if (pgid < 0) {
    {
#line 58
    uerror((char *)"getpgid", (value )0);
    }
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    caml__temp_result = ((intnat )pgid << 1) + 1L;
#line 59
    caml_local_roots = caml__frame;
#line 59
    return (caml__temp_result);
#line 59
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  return (0L);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_getsid(value v_pid ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_pid ;
  int caml__dummy_v_pid  __attribute__((__unused__)) ;
  int sid ;
  __pid_t tmp ;
  value caml__temp_result ;

  {
  {
#line 64
  caml__frame = caml_local_roots;
#line 64
  caml__roots_v_pid.next = caml_local_roots;
#line 64
  caml_local_roots = & caml__roots_v_pid;
#line 64
  caml__roots_v_pid.nitems = (intnat )1;
#line 64
  caml__roots_v_pid.ntables = (intnat )1;
#line 64
  caml__roots_v_pid.tables[0] = & v_pid;
#line 64
  caml__dummy_v_pid = 0;
#line 65
  tmp = getsid((int )(v_pid >> 1));
#line 65
  sid = tmp;
  }
#line 66
  if (sid < 0) {
    {
#line 67
    uerror((char *)"getsid", (value )0);
    }
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    caml__temp_result = ((intnat )sid << 1) + 1L;
#line 68
    caml_local_roots = caml__frame;
#line 68
    return (caml__temp_result);
#line 68
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return (0L);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_setreuid(value v_ruid , value v_euid ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_ruid ;
  int caml__dummy_v_ruid  __attribute__((__unused__)) ;
  int r ;
  int tmp ;
  value caml__temp_result ;

  {
  {
#line 77
  caml__frame = caml_local_roots;
#line 77
  caml__roots_v_ruid.next = caml_local_roots;
#line 77
  caml_local_roots = & caml__roots_v_ruid;
#line 77
  caml__roots_v_ruid.nitems = (intnat )1;
#line 77
  caml__roots_v_ruid.ntables = (intnat )2;
#line 77
  caml__roots_v_ruid.tables[0] = & v_ruid;
#line 77
  caml__roots_v_ruid.tables[1] = & v_euid;
#line 77
  caml__dummy_v_ruid = 0;
#line 78
  tmp = setreuid((__uid_t )((int )(v_ruid >> 1)), (__uid_t )((int )(v_euid >> 1)));
#line 78
  r = tmp;
  }
#line 79
  if (r < 0) {
    {
#line 80
    uerror((char *)"setreuid", (value )0);
    }
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    caml__temp_result = 1L;
#line 81
    caml_local_roots = caml__frame;
#line 81
    return (caml__temp_result);
#line 81
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (0L);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_setregid(value v_rgid , value v_egid ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_rgid ;
  int caml__dummy_v_rgid  __attribute__((__unused__)) ;
  int r ;
  int tmp ;
  value caml__temp_result ;

  {
  {
#line 86
  caml__frame = caml_local_roots;
#line 86
  caml__roots_v_rgid.next = caml_local_roots;
#line 86
  caml_local_roots = & caml__roots_v_rgid;
#line 86
  caml__roots_v_rgid.nitems = (intnat )1;
#line 86
  caml__roots_v_rgid.ntables = (intnat )2;
#line 86
  caml__roots_v_rgid.tables[0] = & v_rgid;
#line 86
  caml__roots_v_rgid.tables[1] = & v_egid;
#line 86
  caml__dummy_v_rgid = 0;
#line 87
  tmp = setregid((__gid_t )((int )(v_rgid >> 1)), (__gid_t )((int )(v_egid >> 1)));
#line 87
  r = tmp;
  }
#line 88
  if (r < 0) {
    {
#line 89
    uerror((char *)"setregid", (value )0);
    }
  }
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    caml__temp_result = 1L;
#line 90
    caml_local_roots = caml__frame;
#line 90
    return (caml__temp_result);
#line 90
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return (0L);
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_setresuid(value r , value e , value s ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_r ;
  int caml__dummy_r  __attribute__((__unused__)) ;
  uid_t ruid ;
  uid_t euid ;
  uid_t suid ;
  int tmp ;
  value caml__temp_result ;

  {
  {
#line 99
  caml__frame = caml_local_roots;
#line 99
  caml__roots_r.next = caml_local_roots;
#line 99
  caml_local_roots = & caml__roots_r;
#line 99
  caml__roots_r.nitems = (intnat )1;
#line 99
  caml__roots_r.ntables = (intnat )3;
#line 99
  caml__roots_r.tables[0] = & r;
#line 99
  caml__roots_r.tables[1] = & e;
#line 99
  caml__roots_r.tables[2] = & s;
#line 99
  caml__dummy_r = 0;
#line 100
  ruid = (uid_t )((int )(r >> 1));
#line 101
  euid = (uid_t )((int )(e >> 1));
#line 102
  suid = (uid_t )((int )(s >> 1));
#line 104
  tmp = setresuid(ruid, euid, suid);
  }
#line 104
  if (tmp != 0) {
    {
#line 105
    uerror((char *)"setresuid", (value )0);
    }
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    caml__temp_result = 1L;
#line 106
    caml_local_roots = caml__frame;
#line 106
    return (caml__temp_result);
#line 106
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  return (0L);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_setresgid(value r , value e , value s ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_r ;
  int caml__dummy_r  __attribute__((__unused__)) ;
  gid_t rgid ;
  gid_t egid ;
  gid_t sgid ;
  int tmp ;
  value caml__temp_result ;

  {
  {
#line 111
  caml__frame = caml_local_roots;
#line 111
  caml__roots_r.next = caml_local_roots;
#line 111
  caml_local_roots = & caml__roots_r;
#line 111
  caml__roots_r.nitems = (intnat )1;
#line 111
  caml__roots_r.ntables = (intnat )3;
#line 111
  caml__roots_r.tables[0] = & r;
#line 111
  caml__roots_r.tables[1] = & e;
#line 111
  caml__roots_r.tables[2] = & s;
#line 111
  caml__dummy_r = 0;
#line 112
  rgid = (gid_t )((int )(r >> 1));
#line 113
  egid = (gid_t )((int )(e >> 1));
#line 114
  sgid = (gid_t )((int )(s >> 1));
#line 116
  tmp = setresgid(rgid, egid, sgid);
  }
#line 116
  if (tmp == -1) {
    {
#line 117
    uerror((char *)"setresgid", (value )0);
    }
  }
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    caml__temp_result = 1L;
#line 118
    caml_local_roots = caml__frame;
#line 118
    return (caml__temp_result);
#line 118
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return (0L);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_is_open_descr(value v_fd ) 
{ 
  int r ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 127
  tmp = fcntl((int )(v_fd >> 1), 3);
#line 127
  r = tmp;
  }
#line 128
  if (-1 == r) {
    {
#line 130
    tmp___0 = __errno_location();
    }
#line 130
    if (9 == *tmp___0) {
#line 130
      return (1L);
    }
    {
#line 131
    uerror((char *)"fcntl", (value )0);
    }
  }
#line 133
  return ((1L << 1) + 1L);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_tcgetpgrp(value v_fd ) 
{ 
  int pgid ;
  __pid_t tmp ;

  {
  {
#line 142
  tmp = tcgetpgrp((int )(v_fd >> 1));
#line 142
  pgid = tmp;
  }
#line 143
  if (-1 == pgid) {
    {
#line 144
    uerror((char *)"tcgetpgrp", (value )0);
    }
  }
#line 145
  return (((intnat )pgid << 1) + 1L);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_tcsetpgrp(value v_fd , value v_pgid ) 
{ 
  int r ;
  int tmp ;

  {
  {
#line 150
  tmp = tcsetpgrp((int )(v_fd >> 1), (int )(v_pgid >> 1));
#line 150
  r = tmp;
  }
#line 151
  if (-1 == r) {
    {
#line 152
    uerror((char *)"tcsetpgrp", (value )0);
    }
  }
#line 153
  return (((intnat )r << 1) + 1L);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_pread_common(value v_fd , off_t off , value v_buf , value v_ofs ,
                                value v_len , int mode ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_fd ;
  int caml__dummy_v_fd  __attribute__((__unused__)) ;
  ssize_t ret ;
  size_t fd ;
  size_t ofs ;
  size_t len ;
  size_t processed ;
  char iobuf[65536] ;
  size_t numbytes ;
  size_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  value caml__temp_result ;

  {
#line 168
  caml__frame = caml_local_roots;
#line 168
  caml__roots_v_fd.next = caml_local_roots;
#line 168
  caml_local_roots = & caml__roots_v_fd;
#line 168
  caml__roots_v_fd.nitems = (intnat )1;
#line 168
  caml__roots_v_fd.ntables = (intnat )4;
#line 168
  caml__roots_v_fd.tables[0] = & v_fd;
#line 168
  caml__roots_v_fd.tables[1] = & v_buf;
#line 168
  caml__roots_v_fd.tables[2] = & v_ofs;
#line 168
  caml__roots_v_fd.tables[3] = & v_len;
#line 168
  caml__dummy_v_fd = 0;
#line 170
  fd = (size_t )((int )(v_fd >> 1));
#line 171
  ofs = (size_t )(v_ofs >> 1);
#line 172
  len = (size_t )(v_len >> 1);
#line 173
  processed = (size_t )0;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (len > 0UL)) {
#line 176
      goto while_break;
    }
#line 177
    if (len > 65536UL) {
#line 177
      tmp = (size_t )65536;
    } else {
#line 177
      tmp = len;
    }
    {
#line 177
    numbytes = tmp;
#line 178
    caml_enter_blocking_section();
#line 179
    ret = pread((int )fd, (void *)(iobuf), numbytes, off);
#line 180
    caml_leave_blocking_section();
    }
#line 181
    if (ret == 0L) {
#line 181
      goto while_break;
    }
#line 182
    if (ret == -1L) {
      {
#line 183
      tmp___0 = __errno_location();
      }
#line 183
      if (*tmp___0 == 4) {
#line 183
        if (mode & (1 << 2)) {
#line 183
          goto while_continue;
        }
      }
#line 184
      if (processed > 0UL) {
        {
#line 185
        tmp___1 = __errno_location();
        }
#line 185
        if (*tmp___1 == 11) {
#line 185
          goto while_break;
        } else {
          {
#line 185
          tmp___2 = __errno_location();
          }
#line 185
          if (*tmp___2 == 11) {
#line 185
            goto while_break;
          }
        }
#line 186
        if (mode & (1 << 1)) {
#line 186
          goto while_break;
        }
      }
      {
#line 188
      uerror((char *)"pread", (value )0);
      }
    }
    {
#line 190
    memcpy((void */* __restrict  */)((char *)v_buf + ofs), (void const   */* __restrict  */)(iobuf),
           (size_t )ret);
#line 191
    processed += (size_t )ret;
#line 192
    off += ret;
#line 193
    ofs += (size_t )ret;
#line 194
    len -= (size_t )ret;
    }
#line 195
    if (mode & 1) {
#line 195
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 198
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 198
    caml__temp_result = ((intnat )processed << 1) + 1L;
#line 198
    caml_local_roots = caml__frame;
#line 198
    return (caml__temp_result);
#line 198
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 199
  return (0L);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_all_pread(value v_fd , value v_off , value v_buf , value v_ofs ,
                             value v_len ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 203
  off = v_off >> 1;
#line 204
  tmp = caml_extunix_pread_common(v_fd, off, v_buf, v_ofs, v_len, 1 << 2);
  }
#line 204
  return (tmp);
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_single_pread(value v_fd , value v_off , value v_buf , value v_ofs ,
                                value v_len ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 209
  off = v_off >> 1;
#line 210
  tmp = caml_extunix_pread_common(v_fd, off, v_buf, v_ofs, v_len, 1);
  }
#line 210
  return (tmp);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_pread(value v_fd , value v_off , value v_buf , value v_ofs , value v_len ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 215
  off = v_off >> 1;
#line 216
  tmp = caml_extunix_pread_common(v_fd, off, v_buf, v_ofs, v_len, (1 << 2) | (1 << 1));
  }
#line 216
  return (tmp);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_intr_pread(value v_fd , value v_off , value v_buf , value v_ofs ,
                              value v_len ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 221
  off = v_off >> 1;
#line 222
  tmp = caml_extunix_pread_common(v_fd, off, v_buf, v_ofs, v_len, 1 << 1);
  }
#line 222
  return (tmp);
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_all_pread64(value v_fd , value v_off , value v_buf , value v_ofs ,
                               value v_len ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 227
  off = (off_t )*((int64 *)((void *)((value *)v_off + 1)));
#line 228
  tmp = caml_extunix_pread_common(v_fd, off, v_buf, v_ofs, v_len, 1 << 2);
  }
#line 228
  return (tmp);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_single_pread64(value v_fd , value v_off , value v_buf , value v_ofs ,
                                  value v_len ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 233
  off = (off_t )*((int64 *)((void *)((value *)v_off + 1)));
#line 234
  tmp = caml_extunix_pread_common(v_fd, off, v_buf, v_ofs, v_len, 1);
  }
#line 234
  return (tmp);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_pread64(value v_fd , value v_off , value v_buf , value v_ofs ,
                           value v_len ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 239
  off = (off_t )*((int64 *)((void *)((value *)v_off + 1)));
#line 240
  tmp = caml_extunix_pread_common(v_fd, off, v_buf, v_ofs, v_len, (1 << 2) | (1 << 1));
  }
#line 240
  return (tmp);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_intr_pread64(value v_fd , value v_off , value v_buf , value v_ofs ,
                                value v_len ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 245
  off = (off_t )*((int64 *)((void *)((value *)v_off + 1)));
#line 246
  tmp = caml_extunix_pread_common(v_fd, off, v_buf, v_ofs, v_len, 1 << 1);
  }
#line 246
  return (tmp);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_pwrite_common(value v_fd , off_t off , value v_buf , value v_ofs ,
                                 value v_len , int mode ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_fd ;
  int caml__dummy_v_fd  __attribute__((__unused__)) ;
  ssize_t ret ;
  size_t fd ;
  size_t ofs ;
  size_t len ;
  size_t processed ;
  char iobuf[65536] ;
  size_t numbytes ;
  size_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  value caml__temp_result ;

  {
#line 255
  caml__frame = caml_local_roots;
#line 255
  caml__roots_v_fd.next = caml_local_roots;
#line 255
  caml_local_roots = & caml__roots_v_fd;
#line 255
  caml__roots_v_fd.nitems = (intnat )1;
#line 255
  caml__roots_v_fd.ntables = (intnat )4;
#line 255
  caml__roots_v_fd.tables[0] = & v_fd;
#line 255
  caml__roots_v_fd.tables[1] = & v_buf;
#line 255
  caml__roots_v_fd.tables[2] = & v_ofs;
#line 255
  caml__roots_v_fd.tables[3] = & v_len;
#line 255
  caml__dummy_v_fd = 0;
#line 257
  fd = (size_t )((int )(v_fd >> 1));
#line 258
  ofs = (size_t )(v_ofs >> 1);
#line 259
  len = (size_t )(v_len >> 1);
#line 260
  processed = (size_t )0;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! (len > 0UL)) {
#line 263
      goto while_break;
    }
#line 264
    if (len > 65536UL) {
#line 264
      tmp = (size_t )65536;
    } else {
#line 264
      tmp = len;
    }
    {
#line 264
    numbytes = tmp;
#line 265
    memcpy((void */* __restrict  */)(iobuf), (void const   */* __restrict  */)((char *)v_buf + ofs),
           numbytes);
#line 266
    caml_enter_blocking_section();
#line 267
    ret = pwrite((int )fd, (void const   *)(iobuf), numbytes, off);
#line 268
    caml_leave_blocking_section();
    }
#line 269
    if (ret == 0L) {
#line 269
      goto while_break;
    }
#line 270
    if (ret == -1L) {
      {
#line 271
      tmp___0 = __errno_location();
      }
#line 271
      if (*tmp___0 == 4) {
#line 271
        if (mode & (1 << 2)) {
#line 271
          goto while_continue;
        }
      }
#line 272
      if (processed > 0UL) {
        {
#line 273
        tmp___1 = __errno_location();
        }
#line 273
        if (*tmp___1 == 11) {
#line 273
          goto while_break;
        } else {
          {
#line 273
          tmp___2 = __errno_location();
          }
#line 273
          if (*tmp___2 == 11) {
#line 273
            goto while_break;
          }
        }
#line 274
        if (mode & (1 << 1)) {
#line 274
          goto while_break;
        }
      }
      {
#line 276
      uerror((char *)"pwrite", (value )0);
      }
    }
#line 278
    processed += (size_t )ret;
#line 279
    off += ret;
#line 280
    ofs += (size_t )ret;
#line 281
    len -= (size_t )ret;
#line 282
    if (mode & 1) {
#line 282
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 285
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 285
    caml__temp_result = ((intnat )processed << 1) + 1L;
#line 285
    caml_local_roots = caml__frame;
#line 285
    return (caml__temp_result);
#line 285
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 286
  return (0L);
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_all_pwrite(value v_fd , value v_off , value v_buf , value v_ofs ,
                              value v_len ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 290
  off = v_off >> 1;
#line 291
  tmp = caml_extunix_pwrite_common(v_fd, off, v_buf, v_ofs, v_len, 1 << 2);
  }
#line 291
  return (tmp);
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_single_pwrite(value v_fd , value v_off , value v_buf , value v_ofs ,
                                 value v_len ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 296
  off = v_off >> 1;
#line 297
  tmp = caml_extunix_pwrite_common(v_fd, off, v_buf, v_ofs, v_len, 1);
  }
#line 297
  return (tmp);
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_pwrite(value v_fd , value v_off , value v_buf , value v_ofs , value v_len ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 302
  off = v_off >> 1;
#line 303
  tmp = caml_extunix_pwrite_common(v_fd, off, v_buf, v_ofs, v_len, (1 << 2) | (1 << 1));
  }
#line 303
  return (tmp);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_intr_pwrite(value v_fd , value v_off , value v_buf , value v_ofs ,
                               value v_len ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 308
  off = v_off >> 1;
#line 309
  tmp = caml_extunix_pwrite_common(v_fd, off, v_buf, v_ofs, v_len, 1 << 1);
  }
#line 309
  return (tmp);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_all_pwrite64(value v_fd , value v_off , value v_buf , value v_ofs ,
                                value v_len ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 314
  off = (off_t )*((int64 *)((void *)((value *)v_off + 1)));
#line 315
  tmp = caml_extunix_pwrite_common(v_fd, off, v_buf, v_ofs, v_len, 1 << 2);
  }
#line 315
  return (tmp);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_single_pwrite64(value v_fd , value v_off , value v_buf , value v_ofs ,
                                   value v_len ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 320
  off = (off_t )*((int64 *)((void *)((value *)v_off + 1)));
#line 321
  tmp = caml_extunix_pwrite_common(v_fd, off, v_buf, v_ofs, v_len, 1);
  }
#line 321
  return (tmp);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_pwrite64(value v_fd , value v_off , value v_buf , value v_ofs ,
                            value v_len ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 326
  off = (off_t )*((int64 *)((void *)((value *)v_off + 1)));
#line 327
  tmp = caml_extunix_pwrite_common(v_fd, off, v_buf, v_ofs, v_len, (1 << 2) | (1 << 1));
  }
#line 327
  return (tmp);
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_intr_pwrite64(value v_fd , value v_off , value v_buf , value v_ofs ,
                                 value v_len ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 332
  off = (off_t )*((int64 *)((void *)((value *)v_off + 1)));
#line 333
  tmp = caml_extunix_pwrite_common(v_fd, off, v_buf, v_ofs, v_len, 1 << 1);
  }
#line 333
  return (tmp);
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_read_common(value v_fd , value v_buf , value v_ofs , value v_len ,
                               int mode ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_fd ;
  int caml__dummy_v_fd  __attribute__((__unused__)) ;
  ssize_t ret ;
  size_t fd ;
  size_t ofs ;
  size_t len ;
  size_t processed ;
  char iobuf[65536] ;
  size_t numbytes ;
  size_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  value caml__temp_result ;

  {
#line 342
  caml__frame = caml_local_roots;
#line 342
  caml__roots_v_fd.next = caml_local_roots;
#line 342
  caml_local_roots = & caml__roots_v_fd;
#line 342
  caml__roots_v_fd.nitems = (intnat )1;
#line 342
  caml__roots_v_fd.ntables = (intnat )4;
#line 342
  caml__roots_v_fd.tables[0] = & v_fd;
#line 342
  caml__roots_v_fd.tables[1] = & v_buf;
#line 342
  caml__roots_v_fd.tables[2] = & v_ofs;
#line 342
  caml__roots_v_fd.tables[3] = & v_len;
#line 342
  caml__dummy_v_fd = 0;
#line 344
  fd = (size_t )((int )(v_fd >> 1));
#line 345
  ofs = (size_t )(v_ofs >> 1);
#line 346
  len = (size_t )(v_len >> 1);
#line 347
  processed = (size_t )0;
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    if (! (len > 0UL)) {
#line 350
      goto while_break;
    }
#line 351
    if (len > 65536UL) {
#line 351
      tmp = (size_t )65536;
    } else {
#line 351
      tmp = len;
    }
    {
#line 351
    numbytes = tmp;
#line 352
    caml_enter_blocking_section();
#line 353
    ret = read((int )fd, (void *)(iobuf), numbytes);
#line 354
    caml_leave_blocking_section();
    }
#line 355
    if (ret == 0L) {
#line 355
      goto while_break;
    }
#line 356
    if (ret == -1L) {
      {
#line 357
      tmp___0 = __errno_location();
      }
#line 357
      if (*tmp___0 == 4) {
#line 357
        if (mode & (1 << 2)) {
#line 357
          goto while_continue;
        }
      }
#line 358
      if (processed > 0UL) {
        {
#line 359
        tmp___1 = __errno_location();
        }
#line 359
        if (*tmp___1 == 11) {
#line 359
          goto while_break;
        } else {
          {
#line 359
          tmp___2 = __errno_location();
          }
#line 359
          if (*tmp___2 == 11) {
#line 359
            goto while_break;
          }
        }
#line 360
        if (mode & (1 << 1)) {
#line 360
          goto while_break;
        }
      }
      {
#line 362
      uerror((char *)"read", (value )0);
      }
    }
    {
#line 364
    memcpy((void */* __restrict  */)((char *)v_buf + ofs), (void const   */* __restrict  */)(iobuf),
           (size_t )ret);
#line 365
    processed += (size_t )ret;
#line 366
    ofs += (size_t )ret;
#line 367
    len -= (size_t )ret;
    }
#line 368
    if (mode & 1) {
#line 368
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 371
    caml__temp_result = ((intnat )processed << 1) + 1L;
#line 371
    caml_local_roots = caml__frame;
#line 371
    return (caml__temp_result);
#line 371
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 372
  return (0L);
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_all_read(value v_fd , value v_buf , value v_ofs , value v_len ) 
{ 
  value tmp ;

  {
  {
#line 376
  tmp = caml_extunix_read_common(v_fd, v_buf, v_ofs, v_len, 1 << 2);
  }
#line 376
  return (tmp);
}
}
#line 379 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_single_read(value v_fd , value v_buf , value v_ofs , value v_len ) 
{ 
  value tmp ;

  {
  {
#line 381
  tmp = caml_extunix_read_common(v_fd, v_buf, v_ofs, v_len, 1);
  }
#line 381
  return (tmp);
}
}
#line 384 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_read(value v_fd , value v_buf , value v_ofs , value v_len ) 
{ 
  value tmp ;

  {
  {
#line 386
  tmp = caml_extunix_read_common(v_fd, v_buf, v_ofs, v_len, (1 << 2) | (1 << 1));
  }
#line 386
  return (tmp);
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_intr_read(value v_fd , value v_buf , value v_ofs , value v_len ) 
{ 
  value tmp ;

  {
  {
#line 391
  tmp = caml_extunix_read_common(v_fd, v_buf, v_ofs, v_len, 1 << 1);
  }
#line 391
  return (tmp);
}
}
#line 399 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_write_common(value v_fd , value v_buf , value v_ofs , value v_len ,
                                int mode ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_fd ;
  int caml__dummy_v_fd  __attribute__((__unused__)) ;
  ssize_t ret ;
  size_t fd ;
  size_t ofs ;
  size_t len ;
  size_t processed ;
  char iobuf[65536] ;
  size_t numbytes ;
  size_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  value caml__temp_result ;

  {
#line 400
  caml__frame = caml_local_roots;
#line 400
  caml__roots_v_fd.next = caml_local_roots;
#line 400
  caml_local_roots = & caml__roots_v_fd;
#line 400
  caml__roots_v_fd.nitems = (intnat )1;
#line 400
  caml__roots_v_fd.ntables = (intnat )4;
#line 400
  caml__roots_v_fd.tables[0] = & v_fd;
#line 400
  caml__roots_v_fd.tables[1] = & v_buf;
#line 400
  caml__roots_v_fd.tables[2] = & v_ofs;
#line 400
  caml__roots_v_fd.tables[3] = & v_len;
#line 400
  caml__dummy_v_fd = 0;
#line 402
  fd = (size_t )((int )(v_fd >> 1));
#line 403
  ofs = (size_t )(v_ofs >> 1);
#line 404
  len = (size_t )(v_len >> 1);
#line 405
  processed = (size_t )0;
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 408
    if (! (len > 0UL)) {
#line 408
      goto while_break;
    }
#line 409
    if (len > 65536UL) {
#line 409
      tmp = (size_t )65536;
    } else {
#line 409
      tmp = len;
    }
    {
#line 409
    numbytes = tmp;
#line 410
    memcpy((void */* __restrict  */)(iobuf), (void const   */* __restrict  */)((char *)v_buf + ofs),
           numbytes);
#line 411
    caml_enter_blocking_section();
#line 412
    ret = write((int )fd, (void const   *)(iobuf), numbytes);
#line 413
    caml_leave_blocking_section();
    }
#line 414
    if (ret == 0L) {
#line 414
      goto while_break;
    }
#line 415
    if (ret == -1L) {
      {
#line 416
      tmp___0 = __errno_location();
      }
#line 416
      if (*tmp___0 == 4) {
#line 416
        if (mode & (1 << 2)) {
#line 416
          goto while_continue;
        }
      }
#line 417
      if (processed > 0UL) {
        {
#line 418
        tmp___1 = __errno_location();
        }
#line 418
        if (*tmp___1 == 11) {
#line 418
          goto while_break;
        } else {
          {
#line 418
          tmp___2 = __errno_location();
          }
#line 418
          if (*tmp___2 == 11) {
#line 418
            goto while_break;
          }
        }
#line 419
        if (mode & (1 << 1)) {
#line 419
          goto while_break;
        }
      }
      {
#line 421
      uerror((char *)"write", (value )0);
      }
    }
#line 423
    processed += (size_t )ret;
#line 424
    ofs += (size_t )ret;
#line 425
    len -= (size_t )ret;
#line 426
    if (mode & 1) {
#line 426
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 429
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 429
    caml__temp_result = ((intnat )processed << 1) + 1L;
#line 429
    caml_local_roots = caml__frame;
#line 429
    return (caml__temp_result);
#line 429
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 430
  return (0L);
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_all_write(value v_fd , value v_buf , value v_ofs , value v_len ) 
{ 
  value tmp ;

  {
  {
#line 434
  tmp = caml_extunix_write_common(v_fd, v_buf, v_ofs, v_len, 1 << 2);
  }
#line 434
  return (tmp);
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_single_write(value v_fd , value v_buf , value v_ofs , value v_len ) 
{ 
  value tmp ;

  {
  {
#line 439
  tmp = caml_extunix_write_common(v_fd, v_buf, v_ofs, v_len, 1);
  }
#line 439
  return (tmp);
}
}
#line 442 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_write(value v_fd , value v_buf , value v_ofs , value v_len ) 
{ 
  value tmp ;

  {
  {
#line 444
  tmp = caml_extunix_write_common(v_fd, v_buf, v_ofs, v_len, (1 << 2) | (1 << 1));
  }
#line 444
  return (tmp);
}
}
#line 447 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/unistd.c"
value caml_extunix_intr_write(value v_fd , value v_buf , value v_ofs , value v_len ) 
{ 
  value tmp ;

  {
  {
#line 449
  tmp = caml_extunix_write_common(v_fd, v_buf, v_ofs, v_len, 1 << 1);
  }
#line 449
  return (tmp);
}
}
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 213
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strptime)(char const   * __restrict  __s ,
                                                                                 char const   * __restrict  __fmt ,
                                                                                 struct tm *__tp ) ;
#line 272
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) asctime_r)(struct tm  const  * __restrict  __tp ,
                                                                                  char * __restrict  __buf ) ;
#line 289
extern char *tzname[2] ;
#line 319
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) timegm)(struct tm *__tp ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/time.c"
static value alloc_tm(struct tm *tm ) 
{ 
  value res ;

  {
  {
#line 17
  res = caml_alloc_small((mlsize_t )9, (tag_t )0);
#line 18
  *((value *)res + 0) = ((intnat )tm->tm_sec << 1) + 1L;
#line 19
  *((value *)res + 1) = ((intnat )tm->tm_min << 1) + 1L;
#line 20
  *((value *)res + 2) = ((intnat )tm->tm_hour << 1) + 1L;
#line 21
  *((value *)res + 3) = ((intnat )tm->tm_mday << 1) + 1L;
#line 22
  *((value *)res + 4) = ((intnat )tm->tm_mon << 1) + 1L;
#line 23
  *((value *)res + 5) = ((intnat )tm->tm_year << 1) + 1L;
#line 24
  *((value *)res + 6) = ((intnat )tm->tm_wday << 1) + 1L;
#line 25
  *((value *)res + 7) = ((intnat )tm->tm_yday << 1) + 1L;
  }
#line 26
  if (tm->tm_isdst) {
#line 26
    *((value *)res + 8) = (1L << 1) + 1L;
  } else {
#line 26
    *((value *)res + 8) = 1L;
  }
#line 27
  return (res);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/time.c"
static void fill_tm(struct tm *tm , value t ) 
{ 


  {
#line 32
  tm->tm_sec = (int )(*((value *)t + 0) >> 1);
#line 33
  tm->tm_min = (int )(*((value *)t + 1) >> 1);
#line 34
  tm->tm_hour = (int )(*((value *)t + 2) >> 1);
#line 35
  tm->tm_mday = (int )(*((value *)t + 3) >> 1);
#line 36
  tm->tm_mon = (int )(*((value *)t + 4) >> 1);
#line 37
  tm->tm_year = (int )(*((value *)t + 5) >> 1);
#line 38
  tm->tm_wday = (int )(*((value *)t + 6) >> 1);
#line 39
  tm->tm_yday = (int )(*((value *)t + 7) >> 1);
#line 40
  tm->tm_isdst = (int )(*((value *)t + 8) >> 1);
#line 41
  return;
}
}
#line 43
#pragma GCC diagnostic push
#line 44
#pragma GCC diagnostic ignored "-Wmissing-field-initializers"
#line 46 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/time.c"
value caml_extunix_strptime(value v_fmt , value v_s ) 
{ 
  struct tm tm ;
  char *tmp ;
  value tmp___0 ;

  {
  {
#line 48
  tm.tm_sec = 0;
#line 48
  tm.tm_min = 0;
#line 48
  tm.tm_hour = 0;
#line 48
  tm.tm_mday = 0;
#line 48
  tm.tm_mon = 0;
#line 48
  tm.tm_year = 0;
#line 48
  tm.tm_wday = 0;
#line 48
  tm.tm_yday = 0;
#line 48
  tm.tm_isdst = 0;
#line 48
  tm.tm_gmtoff = 0L;
#line 48
  tm.tm_zone = (char const   *)0;
#line 49
  tmp = strptime((char const   */* __restrict  */)((char *)v_s), (char const   */* __restrict  */)((char *)v_fmt),
                 & tm);
  }
#line 49
  if ((unsigned long )((void *)0) == (unsigned long )tmp) {
    {
#line 50
    unix_error(22, (char *)"strptime", v_s);
    }
  }
  {
#line 51
  tmp___0 = alloc_tm(& tm);
  }
#line 51
  return (tmp___0);
}
}
#line 54
#pragma GCC diagnostic pop
#line 56 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/time.c"
value caml_extunix_asctime(value v_t ) 
{ 
  struct tm tm ;
  char buf[32] ;
  char *tmp ;
  value tmp___0 ;

  {
  {
#line 61
  fill_tm(& tm, v_t);
#line 62
  tmp = asctime_r((struct tm  const  */* __restrict  */)(& tm), (char */* __restrict  */)(buf));
  }
#line 62
  if ((unsigned long )((void *)0) == (unsigned long )tmp) {
    {
#line 63
    unix_error(22, (char *)"asctime", (value )0);
    }
  }
  {
#line 64
  tmp___0 = caml_copy_string((char const   *)(buf));
  }
#line 64
  return (tmp___0);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/time.c"
value caml_extunix_strftime(value v_fmt , value v_t ) 
{ 
  struct tm tm ;
  char buf[256] ;
  size_t tmp ;
  value tmp___0 ;

  {
  {
#line 72
  fill_tm(& tm, v_t);
#line 73
  tmp = strftime((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)((char *)v_fmt),
                 (struct tm  const  */* __restrict  */)(& tm));
  }
#line 73
  if (0UL == tmp) {
    {
#line 74
    unix_error(22, (char *)"strftime", v_fmt);
    }
  }
  {
#line 76
  tmp___0 = caml_copy_string((char const   *)(buf));
  }
#line 76
  return (tmp___0);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/time.c"
value caml_extunix_tzname(value v_isdst ) 
{ 
  int i ;
  int tmp ;
  value tmp___0 ;

  {
#line 81
  if ((int )(v_isdst >> 1)) {
#line 81
    tmp = 1;
  } else {
#line 81
    tmp = 0;
  }
  {
#line 81
  i = tmp;
#line 82
  tmp___0 = caml_copy_string((char const   *)tzname[i]);
  }
#line 82
  return (tmp___0);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/time.c"
value caml_extunix_timegm(value v_t ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_t ;
  int caml__dummy_v_t  __attribute__((__unused__)) ;
  struct tm tm ;
  time_t t ;
  value caml__temp_result ;
  value tmp ;

  {
  {
#line 91
  caml__frame = caml_local_roots;
#line 91
  caml__roots_v_t.next = caml_local_roots;
#line 91
  caml_local_roots = & caml__roots_v_t;
#line 91
  caml__roots_v_t.nitems = (intnat )1;
#line 91
  caml__roots_v_t.ntables = (intnat )1;
#line 91
  caml__roots_v_t.tables[0] = & v_t;
#line 91
  caml__dummy_v_t = 0;
#line 95
  fill_tm(& tm, v_t);
#line 96
  t = timegm(& tm);
  }
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 98
    tmp = caml_copy_double((double )t);
#line 98
    caml__temp_result = tmp;
#line 98
    caml_local_roots = caml__frame;
    }
#line 98
    return (caml__temp_result);
#line 98
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return (0L);
}
}
#line 31 "/usr/lib/ocaml/caml/alloc.h"
extern value caml_alloc_string(mlsize_t  ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/bigarray.c"
value caml_extunixba_get_substr(value v_buf , value v_off , value v_len ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_buf ;
  int caml__dummy_v_buf  __attribute__((__unused__)) ;
  value v_str ;
  struct caml__roots_block caml__roots_v_str ;
  int caml__dummy_v_str  __attribute__((__unused__)) ;
  char *buf ;
  size_t off ;
  size_t len ;
  char *str ;
  value caml__temp_result ;

  {
  {
#line 7
  caml__frame = caml_local_roots;
#line 7
  caml__roots_v_buf.next = caml_local_roots;
#line 7
  caml_local_roots = & caml__roots_v_buf;
#line 7
  caml__roots_v_buf.nitems = (intnat )1;
#line 7
  caml__roots_v_buf.ntables = (intnat )3;
#line 7
  caml__roots_v_buf.tables[0] = & v_buf;
#line 7
  caml__roots_v_buf.tables[1] = & v_off;
#line 7
  caml__roots_v_buf.tables[2] = & v_len;
#line 7
  caml__dummy_v_buf = 0;
#line 8
  v_str = 1L;
#line 8
  caml__roots_v_str.next = caml_local_roots;
#line 8
  caml_local_roots = & caml__roots_v_str;
#line 8
  caml__roots_v_str.nitems = (intnat )1;
#line 8
  caml__roots_v_str.ntables = (intnat )1;
#line 8
  caml__roots_v_str.tables[0] = & v_str;
#line 8
  caml__dummy_v_str = 0;
#line 9
  buf = (char *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 10
  off = (size_t )(v_off >> 1);
#line 11
  len = (size_t )(v_len >> 1);
#line 13
  v_str = caml_alloc_string(len);
#line 14
  str = (char *)v_str;
#line 15
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)(buf + off),
         len);
  }
  {
#line 16
  while (1) {
    while_continue: /* CIL Label */ ;
#line 16
    caml__temp_result = v_str;
#line 16
    caml_local_roots = caml__frame;
#line 16
    return (caml__temp_result);
#line 16
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 17
  return (0L);
}
}
#line 19 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/bigarray.c"
value caml_extunixba_set_substr(value v_buf , value v_off , value v_str ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_buf ;
  int caml__dummy_v_buf  __attribute__((__unused__)) ;
  char *buf ;
  size_t off ;
  size_t len ;
  mlsize_t tmp ;
  char *str ;
  value caml__temp_result ;

  {
  {
#line 21
  caml__frame = caml_local_roots;
#line 21
  caml__roots_v_buf.next = caml_local_roots;
#line 21
  caml_local_roots = & caml__roots_v_buf;
#line 21
  caml__roots_v_buf.nitems = (intnat )1;
#line 21
  caml__roots_v_buf.ntables = (intnat )3;
#line 21
  caml__roots_v_buf.tables[0] = & v_buf;
#line 21
  caml__roots_v_buf.tables[1] = & v_off;
#line 21
  caml__roots_v_buf.tables[2] = & v_str;
#line 21
  caml__dummy_v_buf = 0;
#line 22
  buf = (char *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 23
  off = (size_t )(v_off >> 1);
#line 24
  tmp = caml_string_length(v_str);
#line 24
  len = tmp;
#line 25
  str = (char *)v_str;
#line 26
  memcpy((void */* __restrict  */)(buf + off), (void const   */* __restrict  */)str,
         len);
  }
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
#line 27
    caml__temp_result = 1L;
#line 27
    caml_local_roots = caml__frame;
#line 27
    return (caml__temp_result);
#line 27
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 28
  return (0L);
}
}
#line 111 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) mlockall)(int __flags ) ;
#line 115
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munlockall)(void) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/mman.c"
static int mlockall_flags[2]  = {      1,      2};
#line 9 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/mman.c"
value caml_extunix_mlockall(value v_flags ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_flags ;
  int caml__dummy_v_flags  __attribute__((__unused__)) ;
  int flags ;
  int tmp ;
  int ret ;
  value caml__temp_result ;

  {
  {
#line 11
  caml__frame = caml_local_roots;
#line 11
  caml__roots_v_flags.next = caml_local_roots;
#line 11
  caml_local_roots = & caml__roots_v_flags;
#line 11
  caml__roots_v_flags.nitems = (intnat )1;
#line 11
  caml__roots_v_flags.ntables = (intnat )1;
#line 11
  caml__roots_v_flags.tables[0] = & v_flags;
#line 11
  caml__dummy_v_flags = 0;
#line 12
  tmp = caml_convert_flag_list(v_flags, mlockall_flags);
#line 12
  flags = tmp;
#line 13
  ret = 0;
#line 15
  caml_enter_blocking_section();
#line 16
  ret = mlockall(flags);
#line 17
  caml_leave_blocking_section();
  }
#line 19
  if (ret != 0) {
    {
#line 19
    uerror((char *)"mlockall", (value )0);
    }
  }
  {
#line 21
  while (1) {
    while_continue: /* CIL Label */ ;
#line 21
    caml__temp_result = 1L;
#line 21
    caml_local_roots = caml__frame;
#line 21
    return (caml__temp_result);
#line 21
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 22
  return (0L);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/mman.c"
value caml_extunix_munlockall(value v_unit ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_unit ;
  int caml__dummy_v_unit  __attribute__((__unused__)) ;
  int ret ;
  value caml__temp_result ;

  {
  {
#line 26
  caml__frame = caml_local_roots;
#line 26
  caml__roots_v_unit.next = caml_local_roots;
#line 26
  caml_local_roots = & caml__roots_v_unit;
#line 26
  caml__roots_v_unit.nitems = (intnat )1;
#line 26
  caml__roots_v_unit.ntables = (intnat )1;
#line 26
  caml__roots_v_unit.tables[0] = & v_unit;
#line 26
  caml__dummy_v_unit = 0;
#line 27
  ret = 0;
#line 29
  caml_enter_blocking_section();
#line 30
  ret = munlockall();
#line 31
  caml_leave_blocking_section();
  }
#line 33
  if (ret != 0) {
    {
#line 33
    uerror((char *)"munlockall", (value )0);
    }
  }
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    caml__temp_result = 1L;
#line 35
    caml_local_roots = caml__frame;
#line 35
    return (caml__temp_result);
#line 35
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 36
  return (0L);
}
}
#line 30 "/usr/lib/ocaml/caml/alloc.h"
extern value caml_alloc_tuple(mlsize_t  ) ;
#line 219 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void * __restrict  __optval ,
                                                                                 socklen_t * __restrict  __optlen ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/read_cred.c"
value caml_extunix_read_credentials(value fd_val ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_fd_val ;
  int caml__dummy_fd_val  __attribute__((__unused__)) ;
  value res ;
  struct caml__roots_block caml__roots_res ;
  int caml__dummy_res  __attribute__((__unused__)) ;
  struct ucred crd ;
  socklen_t crdlen ;
  int fd ;
  int tmp ;
  mlsize_t caml__temp_offset ;
  value caml__temp_val ;
  mlsize_t caml__temp_offset___0 ;
  value caml__temp_val___0 ;
  mlsize_t caml__temp_offset___1 ;
  value caml__temp_val___1 ;
  value caml__temp_result ;

  {
  {
#line 11
  caml__frame = caml_local_roots;
#line 11
  caml__roots_fd_val.next = caml_local_roots;
#line 11
  caml_local_roots = & caml__roots_fd_val;
#line 11
  caml__roots_fd_val.nitems = (intnat )1;
#line 11
  caml__roots_fd_val.ntables = (intnat )1;
#line 11
  caml__roots_fd_val.tables[0] = & fd_val;
#line 11
  caml__dummy_fd_val = 0;
#line 12
  res = 1L;
#line 12
  caml__roots_res.next = caml_local_roots;
#line 12
  caml_local_roots = & caml__roots_res;
#line 12
  caml__roots_res.nitems = (intnat )1;
#line 12
  caml__roots_res.ntables = (intnat )1;
#line 12
  caml__roots_res.tables[0] = & res;
#line 12
  caml__dummy_res = 0;
#line 14
  crdlen = (socklen_t )sizeof(crd);
#line 15
  fd = (int )(fd_val >> 1);
#line 17
  tmp = getsockopt(fd, 1, 17, (void */* __restrict  */)(& crd), (socklen_t */* __restrict  */)(& crdlen));
  }
#line 17
  if (tmp == -1) {
    {
#line 18
    uerror((char *)"read_credentials", (value )0);
    }
  }
  {
#line 20
  res = caml_alloc_tuple((mlsize_t )3);
  }
  {
#line 21
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 21
    caml__temp_offset = (mlsize_t )0;
#line 21
    caml__temp_val = ((intnat )crd.pid << 1) + 1L;
#line 21
    caml_modify((value *)res + caml__temp_offset, caml__temp_val);
    }
#line 21
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 22
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 22
    caml__temp_offset___0 = (mlsize_t )1;
#line 22
    caml__temp_val___0 = ((intnat )crd.uid << 1) + 1L;
#line 22
    caml_modify((value *)res + caml__temp_offset___0, caml__temp_val___0);
    }
#line 22
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 23
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 23
    caml__temp_offset___1 = (mlsize_t )2;
#line 23
    caml__temp_val___1 = ((intnat )crd.gid << 1) + 1L;
#line 23
    caml_modify((value *)res + caml__temp_offset___1, caml__temp_val___1);
    }
#line 23
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 24
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 24
    caml__temp_result = res;
#line 24
    caml_local_roots = caml__frame;
#line 24
    return (caml__temp_result);
#line 24
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 25
  return (0L);
}
}
#line 223 "/usr/include/dirent.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) dirfd)(DIR *__dirp ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/dirfd.c"
value caml_extunix_dirfd(value v_dir ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_dir ;
  int caml__dummy_v_dir  __attribute__((__unused__)) ;
  int fd ;
  DIR *dir ;
  value caml__temp_result ;

  {
#line 9
  caml__frame = caml_local_roots;
#line 9
  caml__roots_v_dir.next = caml_local_roots;
#line 9
  caml_local_roots = & caml__roots_v_dir;
#line 9
  caml__roots_v_dir.nitems = (intnat )1;
#line 9
  caml__roots_v_dir.ntables = (intnat )1;
#line 9
  caml__roots_v_dir.tables[0] = & v_dir;
#line 9
  caml__dummy_v_dir = 0;
#line 10
  fd = -1;
#line 11
  dir = *((DIR **)((value *)v_dir + 0));
#line 12
  if ((unsigned long )dir == (unsigned long )((DIR *)((void *)0))) {
    {
#line 12
    unix_error(9, (char *)"dirfd", (value )0);
    }
  }
  {
#line 13
  fd = dirfd(dir);
  }
#line 14
  if (fd < 0) {
    {
#line 14
    uerror((char *)"dirfd", (value )0);
    }
  }
  {
#line 15
  while (1) {
    while_continue: /* CIL Label */ ;
#line 15
    caml__temp_result = ((intnat )fd << 1) + 1L;
#line 15
    caml_local_roots = caml__frame;
#line 15
    return (caml__temp_result);
#line 15
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 16
  return (0L);
}
}
#line 15 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_pread_common(value v_fd , off_t off , value v_buf , int mode ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_fd ;
  int caml__dummy_v_fd  __attribute__((__unused__)) ;
  ssize_t ret ;
  size_t fd ;
  size_t len ;
  size_t processed ;
  char *buf ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  value caml__temp_result ;

  {
#line 16
  caml__frame = caml_local_roots;
#line 16
  caml__roots_v_fd.next = caml_local_roots;
#line 16
  caml_local_roots = & caml__roots_v_fd;
#line 16
  caml__roots_v_fd.nitems = (intnat )1;
#line 16
  caml__roots_v_fd.ntables = (intnat )2;
#line 16
  caml__roots_v_fd.tables[0] = & v_fd;
#line 16
  caml__roots_v_fd.tables[1] = & v_buf;
#line 16
  caml__dummy_v_fd = 0;
#line 18
  fd = (size_t )((int )(v_fd >> 1));
#line 19
  len = (size_t )((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->dim[0];
#line 20
  processed = (size_t )0;
#line 21
  buf = (char *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23
    if (! (len > 0UL)) {
#line 23
      goto while_break;
    }
    {
#line 24
    caml_enter_blocking_section();
#line 25
    ret = pread((int )fd, (void *)buf, len, off);
#line 26
    caml_leave_blocking_section();
    }
#line 27
    if (ret == 0L) {
#line 27
      goto while_break;
    }
#line 28
    if (ret == -1L) {
      {
#line 29
      tmp = __errno_location();
      }
#line 29
      if (*tmp == 4) {
#line 29
        if (mode & (1 << 2)) {
#line 29
          goto while_continue;
        }
      }
#line 30
      if (processed > 0UL) {
        {
#line 31
        tmp___0 = __errno_location();
        }
#line 31
        if (*tmp___0 == 11) {
#line 31
          goto while_break;
        } else {
          {
#line 31
          tmp___1 = __errno_location();
          }
#line 31
          if (*tmp___1 == 11) {
#line 31
            goto while_break;
          }
        }
#line 32
        if (mode & (1 << 1)) {
#line 32
          goto while_break;
        }
      }
      {
#line 34
      uerror((char *)"pread", (value )0);
      }
    }
#line 36
    processed += (size_t )ret;
#line 37
    buf += ret;
#line 38
    off += ret;
#line 39
    len -= (size_t )ret;
#line 40
    if (mode & 1) {
#line 40
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 43
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 43
    caml__temp_result = ((intnat )processed << 1) + 1L;
#line 43
    caml_local_roots = caml__frame;
#line 43
    return (caml__temp_result);
#line 43
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 44
  return (0L);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_all_pread(value v_fd , value v_off , value v_buf ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 48
  off = v_off >> 1;
#line 49
  tmp = caml_extunixba_pread_common(v_fd, off, v_buf, 1 << 2);
  }
#line 49
  return (tmp);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_single_pread(value v_fd , value v_off , value v_buf ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 54
  off = v_off >> 1;
#line 55
  tmp = caml_extunixba_pread_common(v_fd, off, v_buf, 1);
  }
#line 55
  return (tmp);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_pread(value v_fd , value v_off , value v_buf ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 60
  off = v_off >> 1;
#line 61
  tmp = caml_extunixba_pread_common(v_fd, off, v_buf, (1 << 2) | (1 << 1));
  }
#line 61
  return (tmp);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_intr_pread(value v_fd , value v_off , value v_buf ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 66
  off = v_off >> 1;
#line 67
  tmp = caml_extunixba_pread_common(v_fd, off, v_buf, 1 << 1);
  }
#line 67
  return (tmp);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_all_pread64(value v_fd , value v_off , value v_buf ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 72
  off = (off_t )*((int64 *)((void *)((value *)v_off + 1)));
#line 73
  tmp = caml_extunixba_pread_common(v_fd, off, v_buf, 1 << 2);
  }
#line 73
  return (tmp);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_single_pread64(value v_fd , value v_off , value v_buf ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 78
  off = (off_t )*((int64 *)((void *)((value *)v_off + 1)));
#line 79
  tmp = caml_extunixba_pread_common(v_fd, off, v_buf, 1);
  }
#line 79
  return (tmp);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_pread64(value v_fd , value v_off , value v_buf ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 84
  off = (off_t )*((int64 *)((void *)((value *)v_off + 1)));
#line 85
  tmp = caml_extunixba_pread_common(v_fd, off, v_buf, (1 << 2) | (1 << 1));
  }
#line 85
  return (tmp);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_intr_pread64(value v_fd , value v_off , value v_buf ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 90
  off = (off_t )*((int64 *)((void *)((value *)v_off + 1)));
#line 91
  tmp = caml_extunixba_pread_common(v_fd, off, v_buf, 1 << 1);
  }
#line 91
  return (tmp);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_pwrite_common(value v_fd , off_t off , value v_buf , int mode ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_fd ;
  int caml__dummy_v_fd  __attribute__((__unused__)) ;
  ssize_t ret ;
  size_t fd ;
  size_t len ;
  size_t processed ;
  char *buf ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  value caml__temp_result ;

  {
#line 100
  caml__frame = caml_local_roots;
#line 100
  caml__roots_v_fd.next = caml_local_roots;
#line 100
  caml_local_roots = & caml__roots_v_fd;
#line 100
  caml__roots_v_fd.nitems = (intnat )1;
#line 100
  caml__roots_v_fd.ntables = (intnat )2;
#line 100
  caml__roots_v_fd.tables[0] = & v_fd;
#line 100
  caml__roots_v_fd.tables[1] = & v_buf;
#line 100
  caml__dummy_v_fd = 0;
#line 102
  fd = (size_t )((int )(v_fd >> 1));
#line 103
  len = (size_t )((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->dim[0];
#line 104
  processed = (size_t )0;
#line 105
  buf = (char *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (len > 0UL)) {
#line 107
      goto while_break;
    }
    {
#line 108
    caml_enter_blocking_section();
#line 109
    ret = pwrite((int )fd, (void const   *)buf, len, off);
#line 110
    caml_leave_blocking_section();
    }
#line 111
    if (ret == 0L) {
#line 111
      goto while_break;
    }
#line 112
    if (ret == -1L) {
      {
#line 113
      tmp = __errno_location();
      }
#line 113
      if (*tmp == 4) {
#line 113
        if (mode & (1 << 2)) {
#line 113
          goto while_continue;
        }
      }
#line 114
      if (processed > 0UL) {
        {
#line 115
        tmp___0 = __errno_location();
        }
#line 115
        if (*tmp___0 == 11) {
#line 115
          goto while_break;
        } else {
          {
#line 115
          tmp___1 = __errno_location();
          }
#line 115
          if (*tmp___1 == 11) {
#line 115
            goto while_break;
          }
        }
#line 116
        if (mode & (1 << 1)) {
#line 116
          goto while_break;
        }
      }
      {
#line 118
      uerror((char *)"pwrite", (value )0);
      }
    }
#line 120
    processed += (size_t )ret;
#line 121
    buf += ret;
#line 122
    off += ret;
#line 123
    len -= (size_t )ret;
#line 124
    if (mode & 1) {
#line 124
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 127
    caml__temp_result = ((intnat )processed << 1) + 1L;
#line 127
    caml_local_roots = caml__frame;
#line 127
    return (caml__temp_result);
#line 127
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 128
  return (0L);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_all_pwrite(value v_fd , value v_off , value v_buf ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 132
  off = v_off >> 1;
#line 133
  tmp = caml_extunixba_pwrite_common(v_fd, off, v_buf, 1 << 2);
  }
#line 133
  return (tmp);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_single_pwrite(value v_fd , value v_off , value v_buf ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 138
  off = v_off >> 1;
#line 139
  tmp = caml_extunixba_pwrite_common(v_fd, off, v_buf, 1);
  }
#line 139
  return (tmp);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_pwrite(value v_fd , value v_off , value v_buf ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 144
  off = v_off >> 1;
#line 145
  tmp = caml_extunixba_pwrite_common(v_fd, off, v_buf, (1 << 2) | (1 << 1));
  }
#line 145
  return (tmp);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_intr_pwrite(value v_fd , value v_off , value v_buf ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 150
  off = v_off >> 1;
#line 151
  tmp = caml_extunixba_pwrite_common(v_fd, off, v_buf, 1 << 1);
  }
#line 151
  return (tmp);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_all_pwrite64(value v_fd , value v_off , value v_buf ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 156
  off = (off_t )*((int64 *)((void *)((value *)v_off + 1)));
#line 157
  tmp = caml_extunixba_pwrite_common(v_fd, off, v_buf, 1 << 2);
  }
#line 157
  return (tmp);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_single_pwrite64(value v_fd , value v_off , value v_buf ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 162
  off = (off_t )*((int64 *)((void *)((value *)v_off + 1)));
#line 163
  tmp = caml_extunixba_pwrite_common(v_fd, off, v_buf, 1);
  }
#line 163
  return (tmp);
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_pwrite64(value v_fd , value v_off , value v_buf ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 168
  off = (off_t )*((int64 *)((void *)((value *)v_off + 1)));
#line 169
  tmp = caml_extunixba_pwrite_common(v_fd, off, v_buf, (1 << 2) | (1 << 1));
  }
#line 169
  return (tmp);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_intr_pwrite64(value v_fd , value v_off , value v_buf ) 
{ 
  off_t off ;
  value tmp ;

  {
  {
#line 174
  off = (off_t )*((int64 *)((void *)((value *)v_off + 1)));
#line 175
  tmp = caml_extunixba_pwrite_common(v_fd, off, v_buf, 1 << 1);
  }
#line 175
  return (tmp);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_read_common(value v_fd , value v_buf , int mode ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_fd ;
  int caml__dummy_v_fd  __attribute__((__unused__)) ;
  ssize_t ret ;
  size_t fd ;
  size_t len ;
  size_t processed ;
  char *buf ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  value caml__temp_result ;

  {
#line 184
  caml__frame = caml_local_roots;
#line 184
  caml__roots_v_fd.next = caml_local_roots;
#line 184
  caml_local_roots = & caml__roots_v_fd;
#line 184
  caml__roots_v_fd.nitems = (intnat )1;
#line 184
  caml__roots_v_fd.ntables = (intnat )2;
#line 184
  caml__roots_v_fd.tables[0] = & v_fd;
#line 184
  caml__roots_v_fd.tables[1] = & v_buf;
#line 184
  caml__dummy_v_fd = 0;
#line 186
  fd = (size_t )((int )(v_fd >> 1));
#line 187
  len = (size_t )((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->dim[0];
#line 188
  processed = (size_t )0;
#line 189
  buf = (char *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (len > 0UL)) {
#line 191
      goto while_break;
    }
    {
#line 192
    caml_enter_blocking_section();
#line 193
    ret = read((int )fd, (void *)buf, len);
#line 194
    caml_leave_blocking_section();
    }
#line 195
    if (ret == 0L) {
#line 195
      goto while_break;
    }
#line 196
    if (ret == -1L) {
      {
#line 197
      tmp = __errno_location();
      }
#line 197
      if (*tmp == 4) {
#line 197
        if (mode & (1 << 2)) {
#line 197
          goto while_continue;
        }
      }
#line 198
      if (processed > 0UL) {
        {
#line 199
        tmp___0 = __errno_location();
        }
#line 199
        if (*tmp___0 == 11) {
#line 199
          goto while_break;
        } else {
          {
#line 199
          tmp___1 = __errno_location();
          }
#line 199
          if (*tmp___1 == 11) {
#line 199
            goto while_break;
          }
        }
#line 200
        if (mode & (1 << 1)) {
#line 200
          goto while_break;
        }
      }
      {
#line 202
      uerror((char *)"read", (value )0);
      }
    }
#line 204
    processed += (size_t )ret;
#line 205
    buf += ret;
#line 206
    len -= (size_t )ret;
#line 207
    if (mode & 1) {
#line 207
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 210
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 210
    caml__temp_result = ((intnat )processed << 1) + 1L;
#line 210
    caml_local_roots = caml__frame;
#line 210
    return (caml__temp_result);
#line 210
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 211
  return (0L);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_all_read(value v_fd , value v_buf ) 
{ 
  value tmp ;

  {
  {
#line 215
  tmp = caml_extunixba_read_common(v_fd, v_buf, 1 << 2);
  }
#line 215
  return (tmp);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_single_read(value v_fd , value v_buf ) 
{ 
  value tmp ;

  {
  {
#line 220
  tmp = caml_extunixba_read_common(v_fd, v_buf, 1);
  }
#line 220
  return (tmp);
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_read(value v_fd , value v_buf ) 
{ 
  value tmp ;

  {
  {
#line 225
  tmp = caml_extunixba_read_common(v_fd, v_buf, (1 << 2) | (1 << 1));
  }
#line 225
  return (tmp);
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_intr_read(value v_fd , value v_buf ) 
{ 
  value tmp ;

  {
  {
#line 230
  tmp = caml_extunixba_read_common(v_fd, v_buf, 1 << 1);
  }
#line 230
  return (tmp);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_write_common(value v_fd , value v_buf , int mode ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_fd ;
  int caml__dummy_v_fd  __attribute__((__unused__)) ;
  ssize_t ret ;
  size_t fd ;
  size_t len ;
  size_t processed ;
  char *buf ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  value caml__temp_result ;

  {
#line 239
  caml__frame = caml_local_roots;
#line 239
  caml__roots_v_fd.next = caml_local_roots;
#line 239
  caml_local_roots = & caml__roots_v_fd;
#line 239
  caml__roots_v_fd.nitems = (intnat )1;
#line 239
  caml__roots_v_fd.ntables = (intnat )2;
#line 239
  caml__roots_v_fd.tables[0] = & v_fd;
#line 239
  caml__roots_v_fd.tables[1] = & v_buf;
#line 239
  caml__dummy_v_fd = 0;
#line 241
  fd = (size_t )((int )(v_fd >> 1));
#line 242
  len = (size_t )((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->dim[0];
#line 243
  processed = (size_t )0;
#line 244
  buf = (char *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (! (len > 0UL)) {
#line 246
      goto while_break;
    }
    {
#line 247
    caml_enter_blocking_section();
#line 248
    ret = write((int )fd, (void const   *)buf, len);
#line 249
    caml_leave_blocking_section();
    }
#line 250
    if (ret == 0L) {
#line 250
      goto while_break;
    }
#line 251
    if (ret == -1L) {
      {
#line 252
      tmp = __errno_location();
      }
#line 252
      if (*tmp == 4) {
#line 252
        if (mode & (1 << 2)) {
#line 252
          goto while_continue;
        }
      }
#line 253
      if (processed > 0UL) {
        {
#line 254
        tmp___0 = __errno_location();
        }
#line 254
        if (*tmp___0 == 11) {
#line 254
          goto while_break;
        } else {
          {
#line 254
          tmp___1 = __errno_location();
          }
#line 254
          if (*tmp___1 == 11) {
#line 254
            goto while_break;
          }
        }
#line 255
        if (mode & (1 << 1)) {
#line 255
          goto while_break;
        }
      }
      {
#line 257
      uerror((char *)"write", (value )0);
      }
    }
#line 259
    processed += (size_t )ret;
#line 260
    buf += ret;
#line 261
    len -= (size_t )ret;
#line 262
    if (mode & 1) {
#line 262
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 265
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 265
    caml__temp_result = ((intnat )processed << 1) + 1L;
#line 265
    caml_local_roots = caml__frame;
#line 265
    return (caml__temp_result);
#line 265
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 266
  return (0L);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_all_write(value v_fd , value v_buf ) 
{ 
  value tmp ;

  {
  {
#line 270
  tmp = caml_extunixba_write_common(v_fd, v_buf, 1 << 2);
  }
#line 270
  return (tmp);
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_single_write(value v_fd , value v_buf ) 
{ 
  value tmp ;

  {
  {
#line 275
  tmp = caml_extunixba_write_common(v_fd, v_buf, 1);
  }
#line 275
  return (tmp);
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_write(value v_fd , value v_buf ) 
{ 
  value tmp ;

  {
  {
#line 280
  tmp = caml_extunixba_write_common(v_fd, v_buf, (1 << 2) | (1 << 1));
  }
#line 280
  return (tmp);
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/pread_pwrite_ba.c"
value caml_extunixba_intr_write(value v_fd , value v_buf ) 
{ 
  value tmp ;

  {
  {
#line 285
  tmp = caml_extunixba_write_common(v_fd, v_buf, 1 << 1);
  }
#line 285
  return (tmp);
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_bu16(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint16_t x ;
  unsigned short __v ;
  unsigned short __x ;

  {
  {
#line 36
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 36
  off = (size_t )(v_off >> 1);
#line 36
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 36
  __x = x;
#line 36
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 36
  x = __v;
  }
#line 36
  return (((intnat )x << 1) + 1L);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_bs16(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  int16_t x ;
  unsigned short __v ;
  unsigned short __x ;

  {
  {
#line 37
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 37
  off = (size_t )(v_off >> 1);
#line 37
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 37
  __x = (unsigned short )x;
#line 37
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 37
  x = (int16_t )__v;
  }
#line 37
  return (((intnat )x << 1) + 1L);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_bu31(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint32_t x ;

  {
  {
#line 38
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 38
  off = (size_t )(v_off >> 1);
#line 38
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 38
  x = __bswap_32(x);
  }
#line 38
  return (((intnat )x << 1) + 1L);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_bs31(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  int32_t x ;
  unsigned int tmp ;

  {
  {
#line 39
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 39
  off = (size_t )(v_off >> 1);
#line 39
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 39
  tmp = __bswap_32((unsigned int )x);
#line 39
  x = (int32_t )tmp;
  }
#line 39
  return (((intnat )x << 1) + 1L);
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_bs32(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  int32_t x ;
  unsigned int tmp ;
  value tmp___0 ;

  {
  {
#line 40
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 40
  off = (size_t )(v_off >> 1);
#line 40
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 40
  tmp = __bswap_32((unsigned int )x);
#line 40
  x = (int32_t )tmp;
#line 40
  tmp___0 = caml_copy_int32(x);
  }
#line 40
  return (tmp___0);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_bu63(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint64_t x ;

  {
  {
#line 41
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 41
  off = (size_t )(v_off >> 1);
#line 41
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 41
  x = __bswap_64(x);
  }
#line 41
  return (((intnat )x << 1) + 1L);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_bs63(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  int64_t x ;
  __uint64_t tmp ;

  {
  {
#line 42
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 42
  off = (size_t )(v_off >> 1);
#line 42
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 42
  tmp = __bswap_64((__uint64_t )x);
#line 42
  x = (int64_t )tmp;
  }
#line 42
  return ((x << 1) + 1L);
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_bs64(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  int64_t x ;
  __uint64_t tmp ;
  value tmp___0 ;

  {
  {
#line 43
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 43
  off = (size_t )(v_off >> 1);
#line 43
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 43
  tmp = __bswap_64((__uint64_t )x);
#line 43
  x = (int64_t )tmp;
#line 43
  tmp___0 = caml_copy_int64((int64 )x);
  }
#line 43
  return (tmp___0);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_set_b16(value v_buf , value v_off , value v_x ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint16_t x ;
  unsigned short __v ;
  unsigned short __x ;

  {
  {
#line 45
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 45
  off = (size_t )(v_off >> 1);
#line 45
  x = (uint16_t )(v_x >> 1);
#line 45
  __x = x;
#line 45
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 45
  x = __v;
#line 45
  memcpy((void */* __restrict  */)(buf + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 45
  return (1L);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_set_b31(value v_buf , value v_off , value v_x ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint32_t x ;

  {
  {
#line 46
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 46
  off = (size_t )(v_off >> 1);
#line 46
  x = (uint32_t )(v_x >> 1);
#line 46
  x = __bswap_32(x);
#line 46
  memcpy((void */* __restrict  */)(buf + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 46
  return (1L);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_set_b32(value v_buf , value v_off , value v_x ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint32_t x ;

  {
  {
#line 47
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 47
  off = (size_t )(v_off >> 1);
#line 47
  x = (uint32_t )*((int32 *)((void *)((value *)v_x + 1)));
#line 47
  x = __bswap_32(x);
#line 47
  memcpy((void */* __restrict  */)(buf + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 47
  return (1L);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_set_b63(value v_buf , value v_off , value v_x ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint64_t x ;

  {
  {
#line 48
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 48
  off = (size_t )(v_off >> 1);
#line 48
  x = (uint64_t )(v_x >> 1);
#line 48
  x = __bswap_64(x);
#line 48
  memcpy((void */* __restrict  */)(buf + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 48
  return (1L);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_set_b64(value v_buf , value v_off , value v_x ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint64_t x ;

  {
  {
#line 49
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 49
  off = (size_t )(v_off >> 1);
#line 49
  x = (uint64_t )*((int64 *)((void *)((value *)v_x + 1)));
#line 49
  x = __bswap_64(x);
#line 49
  memcpy((void */* __restrict  */)(buf + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 49
  return (1L);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_lu16(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint16_t x ;

  {
  {
#line 52
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 52
  off = (size_t )(v_off >> 1);
#line 52
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 52
  x = x;
  }
#line 52
  return (((intnat )x << 1) + 1L);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_ls16(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  int16_t x ;

  {
  {
#line 53
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 53
  off = (size_t )(v_off >> 1);
#line 53
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 53
  x = x;
  }
#line 53
  return (((intnat )x << 1) + 1L);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_lu31(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint32_t x ;

  {
  {
#line 54
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 54
  off = (size_t )(v_off >> 1);
#line 54
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 54
  x = x;
  }
#line 54
  return (((intnat )x << 1) + 1L);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_ls31(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  int32_t x ;

  {
  {
#line 55
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 55
  off = (size_t )(v_off >> 1);
#line 55
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 55
  x = x;
  }
#line 55
  return (((intnat )x << 1) + 1L);
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_ls32(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  int32_t x ;
  value tmp ;

  {
  {
#line 56
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 56
  off = (size_t )(v_off >> 1);
#line 56
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 56
  x = x;
#line 56
  tmp = caml_copy_int32(x);
  }
#line 56
  return (tmp);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_lu63(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint64_t x ;

  {
  {
#line 57
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 57
  off = (size_t )(v_off >> 1);
#line 57
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 57
  x = x;
  }
#line 57
  return (((intnat )x << 1) + 1L);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_ls63(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  int64_t x ;

  {
  {
#line 58
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 58
  off = (size_t )(v_off >> 1);
#line 58
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 58
  x = x;
  }
#line 58
  return ((x << 1) + 1L);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_ls64(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  int64_t x ;
  value tmp ;

  {
  {
#line 59
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 59
  off = (size_t )(v_off >> 1);
#line 59
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 59
  x = x;
#line 59
  tmp = caml_copy_int64((int64 )x);
  }
#line 59
  return (tmp);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_set_l16(value v_buf , value v_off , value v_x ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint16_t x ;

  {
  {
#line 61
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 61
  off = (size_t )(v_off >> 1);
#line 61
  x = (uint16_t )(v_x >> 1);
#line 61
  x = x;
#line 61
  memcpy((void */* __restrict  */)(buf + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 61
  return (1L);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_set_l31(value v_buf , value v_off , value v_x ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint32_t x ;

  {
  {
#line 62
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 62
  off = (size_t )(v_off >> 1);
#line 62
  x = (uint32_t )(v_x >> 1);
#line 62
  x = x;
#line 62
  memcpy((void */* __restrict  */)(buf + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 62
  return (1L);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_set_l32(value v_buf , value v_off , value v_x ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint32_t x ;

  {
  {
#line 63
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 63
  off = (size_t )(v_off >> 1);
#line 63
  x = (uint32_t )*((int32 *)((void *)((value *)v_x + 1)));
#line 63
  x = x;
#line 63
  memcpy((void */* __restrict  */)(buf + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 63
  return (1L);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_set_l63(value v_buf , value v_off , value v_x ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint64_t x ;

  {
  {
#line 64
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 64
  off = (size_t )(v_off >> 1);
#line 64
  x = (uint64_t )(v_x >> 1);
#line 64
  x = x;
#line 64
  memcpy((void */* __restrict  */)(buf + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 64
  return (1L);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_set_l64(value v_buf , value v_off , value v_x ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint64_t x ;

  {
  {
#line 65
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 65
  off = (size_t )(v_off >> 1);
#line 65
  x = (uint64_t )*((int64 *)((void *)((value *)v_x + 1)));
#line 65
  x = x;
#line 65
  memcpy((void */* __restrict  */)(buf + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 65
  return (1L);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_u8(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint8_t x ;

  {
  {
#line 71
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 71
  off = (size_t )(v_off >> 1);
#line 71
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 71
  x = x;
  }
#line 71
  return (((intnat )x << 1) + 1L);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_s8(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  int8_t x ;

  {
  {
#line 72
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 72
  off = (size_t )(v_off >> 1);
#line 72
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 72
  x = x;
  }
#line 72
  return (((intnat )x << 1) + 1L);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_hu16(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint16_t x ;

  {
  {
#line 73
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 73
  off = (size_t )(v_off >> 1);
#line 73
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 73
  x = x;
  }
#line 73
  return (((intnat )x << 1) + 1L);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_hs16(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  int16_t x ;

  {
  {
#line 74
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 74
  off = (size_t )(v_off >> 1);
#line 74
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 74
  x = x;
  }
#line 74
  return (((intnat )x << 1) + 1L);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_hu31(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint32_t x ;

  {
  {
#line 75
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 75
  off = (size_t )(v_off >> 1);
#line 75
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 75
  x = x;
  }
#line 75
  return (((intnat )x << 1) + 1L);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_hs31(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  int32_t x ;

  {
  {
#line 76
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 76
  off = (size_t )(v_off >> 1);
#line 76
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 76
  x = x;
  }
#line 76
  return (((intnat )x << 1) + 1L);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_hs32(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  int32_t x ;
  value tmp ;

  {
  {
#line 77
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 77
  off = (size_t )(v_off >> 1);
#line 77
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 77
  x = x;
#line 77
  tmp = caml_copy_int32(x);
  }
#line 77
  return (tmp);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_hu63(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint64_t x ;

  {
  {
#line 78
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 78
  off = (size_t )(v_off >> 1);
#line 78
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 78
  x = x;
  }
#line 78
  return (((intnat )x << 1) + 1L);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_hs63(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  int64_t x ;

  {
  {
#line 79
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 79
  off = (size_t )(v_off >> 1);
#line 79
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 79
  x = x;
  }
#line 79
  return ((x << 1) + 1L);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_get_hs64(value v_buf , value v_off ) 
{ 
  int8_t *buf ;
  size_t off ;
  int64_t x ;
  value tmp ;

  {
  {
#line 80
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 80
  off = (size_t )(v_off >> 1);
#line 80
  memcpy((void */* __restrict  */)(& x), (void const   */* __restrict  */)(buf + off),
         sizeof(x));
#line 80
  x = x;
#line 80
  tmp = caml_copy_int64((int64 )x);
  }
#line 80
  return (tmp);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_set_8(value v_buf , value v_off , value v_x ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint8_t x ;

  {
  {
#line 82
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 82
  off = (size_t )(v_off >> 1);
#line 82
  x = (uint8_t )(v_x >> 1);
#line 82
  x = x;
#line 82
  memcpy((void */* __restrict  */)(buf + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 82
  return (1L);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_set_h16(value v_buf , value v_off , value v_x ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint16_t x ;

  {
  {
#line 83
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 83
  off = (size_t )(v_off >> 1);
#line 83
  x = (uint16_t )(v_x >> 1);
#line 83
  x = x;
#line 83
  memcpy((void */* __restrict  */)(buf + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 83
  return (1L);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_set_h31(value v_buf , value v_off , value v_x ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint32_t x ;

  {
  {
#line 84
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 84
  off = (size_t )(v_off >> 1);
#line 84
  x = (uint32_t )(v_x >> 1);
#line 84
  x = x;
#line 84
  memcpy((void */* __restrict  */)(buf + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 84
  return (1L);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_set_h32(value v_buf , value v_off , value v_x ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint32_t x ;

  {
  {
#line 85
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 85
  off = (size_t )(v_off >> 1);
#line 85
  x = (uint32_t )*((int32 *)((void *)((value *)v_x + 1)));
#line 85
  x = x;
#line 85
  memcpy((void */* __restrict  */)(buf + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 85
  return (1L);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_set_h63(value v_buf , value v_off , value v_x ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint64_t x ;

  {
  {
#line 86
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 86
  off = (size_t )(v_off >> 1);
#line 86
  x = (uint64_t )(v_x >> 1);
#line 86
  x = x;
#line 86
  memcpy((void */* __restrict  */)(buf + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 86
  return (1L);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/endianba.c"
value caml_extunixba_set_h64(value v_buf , value v_off , value v_x ) 
{ 
  int8_t *buf ;
  size_t off ;
  uint64_t x ;

  {
  {
#line 87
  buf = (int8_t *)((struct caml_ba_array *)((void *)((value *)v_buf + 1)))->data;
#line 87
  off = (size_t )(v_off >> 1);
#line 87
  x = (uint64_t )*((int64 *)((void *)((value *)v_x + 1)));
#line 87
  x = x;
#line 87
  memcpy((void */* __restrict  */)(buf + off), (void const   */* __restrict  */)(& x),
         sizeof(x));
  }
#line 87
  return (1L);
}
}
#line 56 "/usr/include/x86_64-linux-gnu/sys/statvfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) statvfs)(char const   * __restrict  __file ,
                                                                                                struct statvfs * __restrict  __buf )  __asm__("statvfs64")  ;
#line 77
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstatvfs)(int __fildes ,
                                                                                               struct statvfs *__buf )  __asm__("fstatvfs64")  ;
#line 7 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/statvfs.c"
static value convert(struct statvfs *s ) 
{ 
  struct caml__roots_block *caml__frame ;
  value v_s ;
  struct caml__roots_block caml__roots_v_s ;
  int caml__dummy_v_s  __attribute__((__unused__)) ;
  mlsize_t caml__temp_offset ;
  value caml__temp_val ;
  mlsize_t caml__temp_offset___0 ;
  value caml__temp_val___0 ;
  value tmp ;
  mlsize_t caml__temp_offset___1 ;
  value caml__temp_val___1 ;
  value tmp___0 ;
  mlsize_t caml__temp_offset___2 ;
  value caml__temp_val___2 ;
  value tmp___1 ;
  mlsize_t caml__temp_offset___3 ;
  value caml__temp_val___3 ;
  value tmp___2 ;
  mlsize_t caml__temp_offset___4 ;
  value caml__temp_val___4 ;
  value tmp___3 ;
  mlsize_t caml__temp_offset___5 ;
  value caml__temp_val___5 ;
  value tmp___4 ;
  mlsize_t caml__temp_offset___6 ;
  value caml__temp_val___6 ;
  value tmp___5 ;
  mlsize_t caml__temp_offset___7 ;
  value caml__temp_val___7 ;
  mlsize_t caml__temp_offset___8 ;
  value caml__temp_val___8 ;
  value caml__temp_result ;

  {
  {
#line 9
  caml__frame = caml_local_roots;
#line 10
  v_s = 1L;
#line 10
  caml__roots_v_s.next = caml_local_roots;
#line 10
  caml_local_roots = & caml__roots_v_s;
#line 10
  caml__roots_v_s.nitems = (intnat )1;
#line 10
  caml__roots_v_s.ntables = (intnat )1;
#line 10
  caml__roots_v_s.tables[0] = & v_s;
#line 10
  caml__dummy_v_s = 0;
#line 12
  v_s = caml_alloc((mlsize_t )10, (tag_t )0);
  }
  {
#line 14
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 14
    caml__temp_offset = (mlsize_t )0;
#line 14
    caml__temp_val = ((intnat )s->f_bsize << 1) + 1L;
#line 14
    caml_modify((value *)v_s + caml__temp_offset, caml__temp_val);
    }
#line 14
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 15
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 15
    caml__temp_offset___0 = (mlsize_t )1;
#line 15
    tmp = caml_copy_int64((int64 )s->f_blocks);
#line 15
    caml__temp_val___0 = tmp;
#line 15
    caml_modify((value *)v_s + caml__temp_offset___0, caml__temp_val___0);
    }
#line 15
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 16
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 16
    caml__temp_offset___1 = (mlsize_t )2;
#line 16
    tmp___0 = caml_copy_int64((int64 )s->f_bfree);
#line 16
    caml__temp_val___1 = tmp___0;
#line 16
    caml_modify((value *)v_s + caml__temp_offset___1, caml__temp_val___1);
    }
#line 16
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 17
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 17
    caml__temp_offset___2 = (mlsize_t )3;
#line 17
    tmp___1 = caml_copy_int64((int64 )s->f_bavail);
#line 17
    caml__temp_val___2 = tmp___1;
#line 17
    caml_modify((value *)v_s + caml__temp_offset___2, caml__temp_val___2);
    }
#line 17
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 18
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 18
    caml__temp_offset___3 = (mlsize_t )4;
#line 18
    tmp___2 = caml_copy_int64((int64 )s->f_files);
#line 18
    caml__temp_val___3 = tmp___2;
#line 18
    caml_modify((value *)v_s + caml__temp_offset___3, caml__temp_val___3);
    }
#line 18
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 19
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 19
    caml__temp_offset___4 = (mlsize_t )5;
#line 19
    tmp___3 = caml_copy_int64((int64 )s->f_ffree);
#line 19
    caml__temp_val___4 = tmp___3;
#line 19
    caml_modify((value *)v_s + caml__temp_offset___4, caml__temp_val___4);
    }
#line 19
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 20
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 20
    caml__temp_offset___5 = (mlsize_t )6;
#line 20
    tmp___4 = caml_copy_int64((int64 )s->f_favail);
#line 20
    caml__temp_val___5 = tmp___4;
#line 20
    caml_modify((value *)v_s + caml__temp_offset___5, caml__temp_val___5);
    }
#line 20
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 21
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 21
    caml__temp_offset___6 = (mlsize_t )7;
#line 21
    tmp___5 = caml_copy_int64((int64 )s->f_fsid);
#line 21
    caml__temp_val___6 = tmp___5;
#line 21
    caml_modify((value *)v_s + caml__temp_offset___6, caml__temp_val___6);
    }
#line 21
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 22
  while (1) {
    while_continue___7: /* CIL Label */ ;
    {
#line 22
    caml__temp_offset___7 = (mlsize_t )8;
#line 22
    caml__temp_val___7 = ((intnat )s->f_flag << 1) + 1L;
#line 22
    caml_modify((value *)v_s + caml__temp_offset___7, caml__temp_val___7);
    }
#line 22
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 23
  while (1) {
    while_continue___8: /* CIL Label */ ;
    {
#line 23
    caml__temp_offset___8 = (mlsize_t )9;
#line 23
    caml__temp_val___8 = ((intnat )s->f_namemax << 1) + 1L;
#line 23
    caml_modify((value *)v_s + caml__temp_offset___8, caml__temp_val___8);
    }
#line 23
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 25
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 25
    caml__temp_result = v_s;
#line 25
    caml_local_roots = caml__frame;
#line 25
    return (caml__temp_result);
#line 25
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 26
  return (0L);
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/statvfs.c"
value caml_extunix_statvfs(value v_path ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_path ;
  int caml__dummy_v_path  __attribute__((__unused__)) ;
  struct statvfs s ;
  int tmp ;
  value caml__temp_result ;
  value tmp___0 ;

  {
  {
#line 30
  caml__frame = caml_local_roots;
#line 30
  caml__roots_v_path.next = caml_local_roots;
#line 30
  caml_local_roots = & caml__roots_v_path;
#line 30
  caml__roots_v_path.nitems = (intnat )1;
#line 30
  caml__roots_v_path.ntables = (intnat )1;
#line 30
  caml__roots_v_path.tables[0] = & v_path;
#line 30
  caml__dummy_v_path = 0;
#line 33
  tmp = statvfs((char const   */* __restrict  */)((char *)v_path), (struct statvfs */* __restrict  */)(& s));
  }
#line 33
  if (0 != tmp) {
    {
#line 35
    uerror((char *)"statvfs", v_path);
    }
  }
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    tmp___0 = convert(& s);
#line 38
    caml__temp_result = tmp___0;
#line 38
    caml_local_roots = caml__frame;
    }
#line 38
    return (caml__temp_result);
#line 38
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  return (0L);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/statvfs.c"
value caml_extunix_fstatvfs(value v_fd ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_fd ;
  int caml__dummy_v_fd  __attribute__((__unused__)) ;
  struct statvfs s ;
  int tmp ;
  value caml__temp_result ;
  value tmp___0 ;

  {
  {
#line 43
  caml__frame = caml_local_roots;
#line 43
  caml__roots_v_fd.next = caml_local_roots;
#line 43
  caml_local_roots = & caml__roots_v_fd;
#line 43
  caml__roots_v_fd.nitems = (intnat )1;
#line 43
  caml__roots_v_fd.ntables = (intnat )1;
#line 43
  caml__roots_v_fd.tables[0] = & v_fd;
#line 43
  caml__dummy_v_fd = 0;
#line 46
  tmp = fstatvfs((int )(v_fd >> 1), & s);
  }
#line 46
  if (0 != tmp) {
    {
#line 48
    uerror((char *)"fstatvfs", (value )0);
    }
  }
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 51
    tmp___0 = convert(& s);
#line 51
    caml__temp_result = tmp___0;
#line 51
    caml_local_roots = caml__frame;
    }
#line 51
    return (caml__temp_result);
#line 51
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (0L);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/sendmsg.c"
int sendfd___0 ;
#line 88
int recvfd___0 ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 184 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 202
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/sendmsg.c"
value caml_extunix_sendmsg(value fd_val , value sendfd_val , value data_val ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_fd_val ;
  int caml__dummy_fd_val  __attribute__((__unused__)) ;
  value data ;
  struct caml__roots_block caml__roots_data ;
  int caml__dummy_data  __attribute__((__unused__)) ;
  size_t datalen ;
  struct msghdr msg ;
  struct iovec iov[1] ;
  int fd ;
  ssize_t ret ;
  char *buf ;
  int sendfd___0 ;
  union __anonunion_control_un_29 control_un ;
  struct cmsghdr *cmsgp ;
  void *tmp ;
  value caml__temp_result ;

  {
  {
#line 21
  caml__frame = caml_local_roots;
#line 21
  caml__roots_fd_val.next = caml_local_roots;
#line 21
  caml_local_roots = & caml__roots_fd_val;
#line 21
  caml__roots_fd_val.nitems = (intnat )1;
#line 21
  caml__roots_fd_val.ntables = (intnat )3;
#line 21
  caml__roots_fd_val.tables[0] = & fd_val;
#line 21
  caml__roots_fd_val.tables[1] = & sendfd_val;
#line 21
  caml__roots_fd_val.tables[2] = & data_val;
#line 21
  caml__dummy_fd_val = 0;
#line 22
  data = 1L;
#line 22
  caml__roots_data.next = caml_local_roots;
#line 22
  caml_local_roots = & caml__roots_data;
#line 22
  caml__roots_data.nitems = (intnat )1;
#line 22
  caml__roots_data.ntables = (intnat )1;
#line 22
  caml__roots_data.tables[0] = & data;
#line 22
  caml__dummy_data = 0;
#line 26
  fd = (int )(fd_val >> 1);
#line 30
  memset((void *)(& msg), 0, sizeof(msg));
  }
#line 32
  if (sendfd_val != 1L) {
#line 33
    sendfd___0 = (int )(*((value *)sendfd_val + 0) >> 1);
#line 41
    msg.msg_control = (void *)(control_un.control);
#line 42
    msg.msg_controllen = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + sizeof(sendfd___0);
#line 44
    if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 44
      cmsgp = (struct cmsghdr *)msg.msg_control;
    } else {
#line 44
      cmsgp = (struct cmsghdr *)0;
    }
#line 45
    cmsgp->cmsg_len = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + sizeof(sendfd___0);
#line 46
    cmsgp->cmsg_level = 1;
#line 47
    cmsgp->cmsg_type = 1;
#line 48
    *((int *)((unsigned char *)(cmsgp + 1))) = sendfd___0;
  }
  {
#line 55
  datalen = caml_string_length(data_val);
#line 56
  tmp = malloc(datalen + 1UL);
#line 56
  buf = (char *)tmp;
#line 57
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)((char *)data_val),
         datalen);
#line 58
  *(buf + datalen) = (char )'\000';
#line 60
  iov[0].iov_base = (void *)buf;
#line 61
  iov[0].iov_len = strlen((char const   *)buf);
#line 62
  msg.msg_iov = iov;
#line 63
  msg.msg_iovlen = (size_t )1;
#line 65
  caml_enter_blocking_section();
#line 66
  ret = sendmsg(fd, (struct msghdr  const  *)(& msg), 0);
#line 67
  caml_leave_blocking_section();
#line 69
  free((void *)buf);
  }
#line 71
  if (ret == -1L) {
    {
#line 72
    uerror((char *)"sendmsg", (value )0);
    }
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    caml__temp_result = 1L;
#line 73
    caml_local_roots = caml__frame;
#line 73
    return (caml__temp_result);
#line 73
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return (0L);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/sendmsg.c"
value caml_extunix_recvmsg(value fd_val ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_fd_val ;
  int caml__dummy_fd_val  __attribute__((__unused__)) ;
  value data ;
  value res ;
  struct caml__roots_block caml__roots_data ;
  int caml__dummy_data  __attribute__((__unused__)) ;
  struct msghdr msg ;
  int fd ;
  int recvfd___0 ;
  ssize_t len ;
  struct iovec iov[1] ;
  char buf[4096] ;
  union __anonunion_control_un_30 control_un ;
  struct cmsghdr *cmsgp ;
  mlsize_t caml__temp_offset ;
  value caml__temp_val ;
  value some_fd ;
  struct caml__roots_block caml__roots_some_fd ;
  int caml__dummy_some_fd  __attribute__((__unused__)) ;
  value tmp ;
  value tmp___0 ;
  mlsize_t caml__temp_offset___0 ;
  value caml__temp_val___0 ;
  mlsize_t caml__temp_offset___1 ;
  value caml__temp_val___1 ;
  mlsize_t caml__temp_offset___2 ;
  value caml__temp_val___2 ;
  value tmp___1 ;
  value caml__temp_result ;

  {
  {
#line 78
  caml__frame = caml_local_roots;
#line 78
  caml__roots_fd_val.next = caml_local_roots;
#line 78
  caml_local_roots = & caml__roots_fd_val;
#line 78
  caml__roots_fd_val.nitems = (intnat )1;
#line 78
  caml__roots_fd_val.ntables = (intnat )1;
#line 78
  caml__roots_fd_val.tables[0] = & fd_val;
#line 78
  caml__dummy_fd_val = 0;
#line 79
  data = 1L;
#line 79
  res = 1L;
#line 79
  caml__roots_data.next = caml_local_roots;
#line 79
  caml_local_roots = & caml__roots_data;
#line 79
  caml__roots_data.nitems = (intnat )1;
#line 79
  caml__roots_data.ntables = (intnat )2;
#line 79
  caml__roots_data.tables[0] = & data;
#line 79
  caml__roots_data.tables[1] = & res;
#line 79
  caml__dummy_data = 0;
#line 81
  fd = (int )(fd_val >> 1);
#line 94
  memset((void *)(& msg), 0, sizeof(msg));
#line 95
  msg.msg_control = (void *)(control_un.control);
#line 96
  msg.msg_controllen = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + sizeof(recvfd___0);
#line 102
  iov[0].iov_base = (void *)(buf);
#line 103
  iov[0].iov_len = sizeof(buf);
#line 104
  msg.msg_iov = iov;
#line 105
  msg.msg_iovlen = (size_t )1;
#line 107
  caml_enter_blocking_section();
#line 108
  len = recvmsg(fd, & msg, 0);
#line 109
  caml_leave_blocking_section();
  }
#line 111
  if (len == -1L) {
    {
#line 112
    uerror((char *)"recvmsg", (value )0);
    }
  }
  {
#line 114
  res = caml_alloc((mlsize_t )2, (tag_t )0);
  }
#line 117
  if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 117
    cmsgp = (struct cmsghdr *)msg.msg_control;
  } else {
#line 117
    cmsgp = (struct cmsghdr *)0;
  }
#line 118
  if ((unsigned long )cmsgp == (unsigned long )((void *)0)) {
    {
#line 119
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 119
      caml__temp_offset = (mlsize_t )0;
#line 119
      caml__temp_val = 1L;
#line 119
      caml_modify((value *)res + caml__temp_offset, caml__temp_val);
      }
#line 119
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 121
    some_fd = 1L;
#line 121
    caml__roots_some_fd.next = caml_local_roots;
#line 121
    caml_local_roots = & caml__roots_some_fd;
#line 121
    caml__roots_some_fd.nitems = (intnat )1;
#line 121
    caml__roots_some_fd.ntables = (intnat )1;
#line 121
    caml__roots_some_fd.tables[0] = & some_fd;
#line 121
    caml__dummy_some_fd = 0;
#line 122
    if (cmsgp->cmsg_len != (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + sizeof(recvfd___0)) {
      {
#line 123
      tmp = caml_copy_string("wrong descriptor size");
#line 123
      unix_error(22, (char *)"recvmsg", tmp);
      }
    }
#line 124
    if (cmsgp->cmsg_level != 1) {
      {
#line 125
      tmp___0 = caml_copy_string("invalid protocol");
#line 125
      unix_error(22, (char *)"recvmsg", tmp___0);
      }
    } else
#line 124
    if (cmsgp->cmsg_type != 1) {
      {
#line 125
      tmp___0 = caml_copy_string("invalid protocol");
#line 125
      unix_error(22, (char *)"recvmsg", tmp___0);
      }
    }
    {
#line 126
    some_fd = caml_alloc((mlsize_t )1, (tag_t )0);
    }
    {
#line 127
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 127
      caml__temp_offset___0 = (mlsize_t )0;
#line 127
      caml__temp_val___0 = ((intnat )*((int *)((unsigned char *)(cmsgp + 1))) << 1) + 1L;
#line 127
      caml_modify((value *)some_fd + caml__temp_offset___0, caml__temp_val___0);
      }
#line 127
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 128
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 128
      caml__temp_offset___1 = (mlsize_t )0;
#line 128
      caml__temp_val___1 = some_fd;
#line 128
      caml_modify((value *)res + caml__temp_offset___1, caml__temp_val___1);
      }
#line 128
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 141
  buf[len] = (char )'\000';
  {
#line 142
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 142
    caml__temp_offset___2 = (mlsize_t )1;
#line 142
    tmp___1 = caml_copy_string((char const   *)(buf));
#line 142
    caml__temp_val___2 = tmp___1;
#line 142
    caml_modify((value *)res + caml__temp_offset___2, caml__temp_val___2);
    }
#line 142
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 144
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 144
    caml__temp_result = res;
#line 144
    caml_local_roots = caml__frame;
#line 144
    return (caml__temp_result);
#line 144
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 145
  return (0L);
}
}
#line 263 "/usr/include/fcntl.h"
extern int posix_fallocate(int __fd , __off64_t __offset , __off64_t __len )  __asm__("posix_fallocate64")  ;
#line 271
extern int posix_fallocate64(int __fd , off64_t __offset , off64_t __len ) ;
#line 95 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/fallocate.c"
static void caml_fallocate_error(int errcode ) 
{ 


  {
#line 97
  if (errcode != 0) {
    {
#line 99
    unix_error(errcode, (char *)"fallocate", (value )0);
    }
  }
#line 101
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/fallocate.c"
value caml_extunix_fallocate64(value vfd , value voff , value vlen ) 
{ 
  int errcode ;
  int fd ;
  off64_t off ;
  off64_t len ;
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vfd ;
  int caml__dummy_vfd  __attribute__((__unused__)) ;
  value caml__temp_result ;

  {
  {
#line 105
  errcode = 0;
#line 106
  fd = -1;
#line 107
  off = (off64_t )0;
#line 108
  len = (off64_t )0;
#line 110
  caml__frame = caml_local_roots;
#line 110
  caml__roots_vfd.next = caml_local_roots;
#line 110
  caml_local_roots = & caml__roots_vfd;
#line 110
  caml__roots_vfd.nitems = (intnat )1;
#line 110
  caml__roots_vfd.ntables = (intnat )3;
#line 110
  caml__roots_vfd.tables[0] = & vfd;
#line 110
  caml__roots_vfd.tables[1] = & voff;
#line 110
  caml__roots_vfd.tables[2] = & vlen;
#line 110
  caml__dummy_vfd = 0;
#line 112
  fd = (int )(vfd >> 1);
#line 113
  off = (off64_t )*((int64 *)((void *)((value *)voff + 1)));
#line 114
  len = (off64_t )*((int64 *)((void *)((value *)vlen + 1)));
#line 116
  errcode = posix_fallocate64(fd, off, len);
#line 118
  caml_fallocate_error(errcode);
  }
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    caml__temp_result = 1L;
#line 120
    caml_local_roots = caml__frame;
#line 120
    return (caml__temp_result);
#line 120
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  return (0L);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/fallocate.c"
value caml_extunix_fallocate(value vfd , value voff , value vlen ) 
{ 
  int errcode ;
  int fd ;
  off_t off ;
  off_t len ;
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vfd ;
  int caml__dummy_vfd  __attribute__((__unused__)) ;
  value caml__temp_result ;

  {
  {
#line 125
  errcode = 0;
#line 126
  fd = -1;
#line 127
  off = (off_t )0;
#line 128
  len = (off_t )0;
#line 130
  caml__frame = caml_local_roots;
#line 130
  caml__roots_vfd.next = caml_local_roots;
#line 130
  caml_local_roots = & caml__roots_vfd;
#line 130
  caml__roots_vfd.nitems = (intnat )1;
#line 130
  caml__roots_vfd.ntables = (intnat )3;
#line 130
  caml__roots_vfd.tables[0] = & vfd;
#line 130
  caml__roots_vfd.tables[1] = & voff;
#line 130
  caml__roots_vfd.tables[2] = & vlen;
#line 130
  caml__dummy_vfd = 0;
#line 132
  fd = (int )(vfd >> 1);
#line 133
  off = voff >> 1;
#line 134
  len = vlen >> 1;
#line 136
  errcode = posix_fallocate(fd, off, len);
#line 138
  caml_fallocate_error(errcode);
  }
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    caml__temp_result = 1L;
#line 140
    caml_local_roots = caml__frame;
#line 140
    return (caml__temp_result);
#line 140
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  return (0L);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 325
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) open_memstream)(char **__bufloc ,
                                                                                       size_t *__sizeloc ) ;
#line 132 "/usr/include/malloc.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) malloc_stats)(void) ;
#line 135
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) malloc_info)(int __options ,
                                                                                  FILE *__fp ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/malloc.c"
value caml_extunix_malloc_stats(value v_unit ) 
{ 


  {
  {
#line 11
  malloc_stats();
  }
#line 12
  return (1L);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/malloc.c"
value caml_extunix_malloc_info(value v_unit ) 
{ 
  struct caml__roots_block *caml__frame ;
  value v_s ;
  struct caml__roots_block caml__roots_v_s ;
  int caml__dummy_v_s  __attribute__((__unused__)) ;
  char *buf ;
  size_t size ;
  int r ;
  FILE *f ;
  FILE *tmp ;
  value caml__temp_result ;

  {
  {
#line 24
  caml__frame = caml_local_roots;
#line 25
  v_s = 1L;
#line 25
  caml__roots_v_s.next = caml_local_roots;
#line 25
  caml_local_roots = & caml__roots_v_s;
#line 25
  caml__roots_v_s.nitems = (intnat )1;
#line 25
  caml__roots_v_s.ntables = (intnat )1;
#line 25
  caml__roots_v_s.tables[0] = & v_s;
#line 25
  caml__dummy_v_s = 0;
#line 26
  buf = (char *)((void *)0);
#line 29
  tmp = open_memstream(& buf, & size);
#line 29
  f = tmp;
  }
#line 31
  if ((unsigned long )((void *)0) == (unsigned long )f) {
    {
#line 32
    uerror((char *)"malloc_info", (value )0);
    }
  }
  {
#line 33
  r = malloc_info(0, f);
#line 34
  fclose(f);
  }
#line 35
  if (0 != r) {
    {
#line 37
    free((void *)buf);
#line 38
    uerror((char *)"malloc_info", (value )0);
    }
  }
  {
#line 40
  v_s = caml_alloc_string(size);
#line 41
  memcpy((void */* __restrict  */)((char *)v_s), (void const   */* __restrict  */)buf,
         size);
#line 42
  free((void *)buf);
  }
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    caml__temp_result = v_s;
#line 43
    caml_local_roots = caml__frame;
#line 43
    return (caml__temp_result);
#line 43
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  return (0L);
}
}
#line 242 "/usr/include/fcntl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) posix_fadvise)(int __fd ,
                                                                                    __off64_t __offset ,
                                                                                    __off64_t __len ,
                                                                                    int __advise )  __asm__("posix_fadvise64")  ;
#line 250
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) posix_fadvise64)(int __fd ,
                                                                                      off64_t __offset ,
                                                                                      off64_t __len ,
                                                                                      int __advise ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/fadvise.c"
static int caml_advises[6]  = {      0,      2,      1,      5, 
        3,      4};
#line 29 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/fadvise.c"
value caml_extunix_fadvise64(value vfd , value voff , value vlen , value vadvise ) 
{ 
  int errcode ;
  int fd ;
  off64_t off ;
  off64_t len ;
  int advise ;
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vfd ;
  int caml__dummy_vfd  __attribute__((__unused__)) ;
  value caml__temp_result ;

  {
  {
#line 31
  errcode = 0;
#line 32
  fd = -1;
#line 33
  off = (off64_t )0;
#line 34
  len = (off64_t )0;
#line 35
  advise = 0;
#line 37
  caml__frame = caml_local_roots;
#line 37
  caml__roots_vfd.next = caml_local_roots;
#line 37
  caml_local_roots = & caml__roots_vfd;
#line 37
  caml__roots_vfd.nitems = (intnat )1;
#line 37
  caml__roots_vfd.ntables = (intnat )4;
#line 37
  caml__roots_vfd.tables[0] = & vfd;
#line 37
  caml__roots_vfd.tables[1] = & voff;
#line 37
  caml__roots_vfd.tables[2] = & vlen;
#line 37
  caml__roots_vfd.tables[3] = & vadvise;
#line 37
  caml__dummy_vfd = 0;
#line 39
  fd = (int )(vfd >> 1);
#line 40
  off = (off64_t )*((int64 *)((void *)((value *)voff + 1)));
#line 41
  len = (off64_t )*((int64 *)((void *)((value *)vlen + 1)));
#line 42
  advise = caml_advises[(int )(vadvise >> 1)];
#line 44
  errcode = posix_fadvise64(fd, off, len, advise);
  }
#line 46
  if (errcode != 0) {
    {
#line 48
    unix_error(errcode, (char *)"fadvise64", (value )0);
    }
  }
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    caml__temp_result = 1L;
#line 51
    caml_local_roots = caml__frame;
#line 51
    return (caml__temp_result);
#line 51
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (0L);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/fadvise.c"
value caml_extunix_fadvise(value vfd , value voff , value vlen , value vadvise ) 
{ 
  int errcode ;
  int fd ;
  off_t off ;
  off_t len ;
  int advise ;
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_vfd ;
  int caml__dummy_vfd  __attribute__((__unused__)) ;
  value caml__temp_result ;

  {
  {
#line 56
  errcode = 0;
#line 57
  fd = -1;
#line 58
  off = (off_t )0;
#line 59
  len = (off_t )0;
#line 60
  advise = 0;
#line 62
  caml__frame = caml_local_roots;
#line 62
  caml__roots_vfd.next = caml_local_roots;
#line 62
  caml_local_roots = & caml__roots_vfd;
#line 62
  caml__roots_vfd.nitems = (intnat )1;
#line 62
  caml__roots_vfd.ntables = (intnat )4;
#line 62
  caml__roots_vfd.tables[0] = & vfd;
#line 62
  caml__roots_vfd.tables[1] = & voff;
#line 62
  caml__roots_vfd.tables[2] = & vlen;
#line 62
  caml__roots_vfd.tables[3] = & vadvise;
#line 62
  caml__dummy_vfd = 0;
#line 64
  fd = (int )(vfd >> 1);
#line 65
  off = voff >> 1;
#line 66
  len = vlen >> 1;
#line 67
  advise = caml_advises[(int )(vadvise >> 1)];
#line 69
  errcode = posix_fadvise(fd, off, len, advise);
  }
#line 71
  if (errcode != 0) {
    {
#line 73
    unix_error(errcode, (char *)"fadvise", (value )0);
    }
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    caml__temp_result = 1L;
#line 76
    caml_local_roots = caml__frame;
#line 76
    return (caml__temp_result);
#line 76
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  return (0L);
}
}
#line 503 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) posix_memalign)(void **__memptr ,
                                                                                                     size_t __alignment ,
                                                                                                     size_t __size ) ;
#line 115 "/usr/lib/ocaml/caml/bigarray.h"
extern value caml_ba_alloc_dims(int flags , int num_dims , void *data  , ...) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/memalign.c"
value caml_extunix_memalign(value valignment , value vsize ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_valignment ;
  int caml__dummy_valignment  __attribute__((__unused__)) ;
  size_t alignment ;
  size_t size ;
  int errcode ;
  void *memptr ;
  value caml__temp_result ;
  value tmp ;

  {
  {
#line 22
  caml__frame = caml_local_roots;
#line 22
  caml__roots_valignment.next = caml_local_roots;
#line 22
  caml_local_roots = & caml__roots_valignment;
#line 22
  caml__roots_valignment.nitems = (intnat )1;
#line 22
  caml__roots_valignment.ntables = (intnat )2;
#line 22
  caml__roots_valignment.tables[0] = & valignment;
#line 22
  caml__roots_valignment.tables[1] = & vsize;
#line 22
  caml__dummy_valignment = 0;
#line 29
  alignment = (size_t )((int )(valignment >> 1));
#line 30
  size = (size_t )((int )(vsize >> 1));
#line 32
  errcode = posix_memalign(& memptr, alignment, size);
  }
#line 34
  if (errcode != 0) {
    {
#line 36
    unix_error(errcode, (char *)"memalign", (value )0);
    }
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 39
    tmp = caml_ba_alloc_dims(515, 1, memptr, size);
#line 39
    caml__temp_result = tmp;
#line 39
    caml_local_roots = caml__frame;
    }
#line 39
    return (caml__temp_result);
#line 39
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  return (0L);
}
}
#line 37 "/usr/lib/ocaml/caml/alloc.h"
extern value caml_copy_nativeint(intnat  ) ;
#line 213 "/usr/include/x86_64-linux-gnu/sys/ptrace.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) ptrace)(enum __ptrace_request __request 
                                                                              , ...) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/ptrace.c"
value caml_extunix_ptrace_traceme(value v_unit ) 
{ 
  long r ;
  long tmp ;

  {
  {
#line 9
  tmp = ptrace((enum __ptrace_request )0, 0, 0, 0);
#line 9
  r = tmp;
  }
#line 11
  if (r != 0L) {
    {
#line 12
    uerror((char *)"ptrace_traceme", (value )0);
    }
  }
#line 13
  return (1L);
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/ptrace.c"
value caml_extunix_ptrace(value v_pid , value v_req ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_pid ;
  int caml__dummy_v_pid  __attribute__((__unused__)) ;
  long r ;
  value caml__temp_result ;

  {
#line 18
  caml__frame = caml_local_roots;
#line 18
  caml__roots_v_pid.next = caml_local_roots;
#line 18
  caml_local_roots = & caml__roots_v_pid;
#line 18
  caml__roots_v_pid.nitems = (intnat )1;
#line 18
  caml__roots_v_pid.ntables = (intnat )2;
#line 18
  caml__roots_v_pid.tables[0] = & v_pid;
#line 18
  caml__roots_v_pid.tables[1] = & v_req;
#line 18
  caml__dummy_v_pid = 0;
#line 19
  r = 0L;
  {
#line 22
  if ((int )(v_req >> 1) == 0) {
#line 22
    goto case_0;
  }
#line 23
  if ((int )(v_req >> 1) == 1) {
#line 23
    goto case_1;
  }
#line 24
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 22
  r = ptrace((enum __ptrace_request )16, (int )(v_pid >> 1), 0, 0);
  }
#line 22
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 23
  r = ptrace((enum __ptrace_request )17, (int )(v_pid >> 1), 0, 0);
  }
#line 23
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 24
  caml_invalid_argument("ptrace");
  }
  switch_break: /* CIL Label */ ;
  }
#line 26
  if (r != 0L) {
    {
#line 27
    uerror((char *)"ptrace", (value )0);
    }
  }
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    caml__temp_result = 1L;
#line 28
    caml_local_roots = caml__frame;
#line 28
    return (caml__temp_result);
#line 28
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 29
  return (0L);
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/ptrace.c"
value caml_extunix_ptrace_peekdata(value v_pid , value v_addr ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_pid ;
  int caml__dummy_v_pid  __attribute__((__unused__)) ;
  long r ;
  long tmp ;
  int *tmp___0 ;
  value caml__temp_result ;
  value tmp___1 ;

  {
  {
#line 33
  caml__frame = caml_local_roots;
#line 33
  caml__roots_v_pid.next = caml_local_roots;
#line 33
  caml_local_roots = & caml__roots_v_pid;
#line 33
  caml__roots_v_pid.nitems = (intnat )1;
#line 33
  caml__roots_v_pid.ntables = (intnat )2;
#line 33
  caml__roots_v_pid.tables[0] = & v_pid;
#line 33
  caml__roots_v_pid.tables[1] = & v_addr;
#line 33
  caml__dummy_v_pid = 0;
#line 34
  tmp = ptrace((enum __ptrace_request )2, (int )(v_pid >> 1), *((intnat *)((void *)((value *)v_addr + 1))),
               0);
#line 34
  r = tmp;
  }
#line 35
  if (-1L == r) {
    {
#line 35
    tmp___0 = __errno_location();
    }
#line 35
    if (0 != *tmp___0) {
      {
#line 36
      uerror((char *)"ptrace_peekdata", (value )0);
      }
    }
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 37
    tmp___1 = caml_copy_nativeint(r);
#line 37
    caml__temp_result = tmp___1;
#line 37
    caml_local_roots = caml__frame;
    }
#line 37
    return (caml__temp_result);
#line 37
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  return (0L);
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/ptrace.c"
value caml_extunix_ptrace_peektext(value v_pid , value v_addr ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_pid ;
  int caml__dummy_v_pid  __attribute__((__unused__)) ;
  long r ;
  long tmp ;
  int *tmp___0 ;
  value caml__temp_result ;
  value tmp___1 ;

  {
  {
#line 42
  caml__frame = caml_local_roots;
#line 42
  caml__roots_v_pid.next = caml_local_roots;
#line 42
  caml_local_roots = & caml__roots_v_pid;
#line 42
  caml__roots_v_pid.nitems = (intnat )1;
#line 42
  caml__roots_v_pid.ntables = (intnat )2;
#line 42
  caml__roots_v_pid.tables[0] = & v_pid;
#line 42
  caml__roots_v_pid.tables[1] = & v_addr;
#line 42
  caml__dummy_v_pid = 0;
#line 43
  tmp = ptrace((enum __ptrace_request )1, (int )(v_pid >> 1), *((intnat *)((void *)((value *)v_addr + 1))),
               0);
#line 43
  r = tmp;
  }
#line 44
  if (-1L == r) {
    {
#line 44
    tmp___0 = __errno_location();
    }
#line 44
    if (0 != *tmp___0) {
      {
#line 45
      uerror((char *)"ptrace_peektext", (value )0);
      }
    }
  }
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 46
    tmp___1 = caml_copy_nativeint(r);
#line 46
    caml__temp_result = tmp___1;
#line 46
    caml_local_roots = caml__frame;
    }
#line 46
    return (caml__temp_result);
#line 46
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return (0L);
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/common.c"
static int open_flag_table[13]  = 
#line 20 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/common.c"
  {      0,      1,      2,      2048, 
        1024,      64,      512,      128, 
        256,      4096,      1052672,      1052672, 
        0};
#line 25 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/common.c"
int extunix_open_flags(value v_flags ) 
{ 
  int tmp ;

  {
  {
#line 27
  tmp = caml_convert_flag_list(v_flags, open_flag_table);
  }
#line 27
  return (tmp);
}
}
#line 27 "/usr/include/execinfo.h"
extern int ( __attribute__((__nonnull__(1))) backtrace)(void **__array , int __size ) ;
#line 32
extern  __attribute__((__nothrow__)) char **( __attribute__((__nonnull__(1), __leaf__)) backtrace_symbols)(void * const  *__array ,
                                                                                                           int __size ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/execinfo.c"
value caml_extunix_backtrace(value unit ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_unit ;
  int caml__dummy_unit  __attribute__((__unused__)) ;
  value v_ret ;
  struct caml__roots_block caml__roots_v_ret ;
  int caml__dummy_v_ret  __attribute__((__unused__)) ;
  void *buffer[100] ;
  int nptrs ;
  int tmp ;
  int j ;
  char **strings ;
  char **tmp___0 ;
  mlsize_t caml__temp_offset ;
  value caml__temp_val ;
  value tmp___1 ;
  value caml__temp_result ;

  {
  {
#line 9
  caml__frame = caml_local_roots;
#line 9
  caml__roots_unit.next = caml_local_roots;
#line 9
  caml_local_roots = & caml__roots_unit;
#line 9
  caml__roots_unit.nitems = (intnat )1;
#line 9
  caml__roots_unit.ntables = (intnat )1;
#line 9
  caml__roots_unit.tables[0] = & unit;
#line 9
  caml__dummy_unit = 0;
#line 10
  v_ret = 1L;
#line 10
  caml__roots_v_ret.next = caml_local_roots;
#line 10
  caml_local_roots = & caml__roots_v_ret;
#line 10
  caml__roots_v_ret.nitems = (intnat )1;
#line 10
  caml__roots_v_ret.ntables = (intnat )1;
#line 10
  caml__roots_v_ret.tables[0] = & v_ret;
#line 10
  caml__dummy_v_ret = 0;
#line 13
  tmp = backtrace(buffer, 100);
#line 13
  nptrs = tmp;
#line 15
  tmp___0 = backtrace_symbols((void * const  *)(buffer), nptrs);
#line 15
  strings = tmp___0;
  }
#line 16
  if ((unsigned long )((void *)0) == (unsigned long )strings) {
    {
#line 17
    uerror((char *)"backtrace", (value )0);
    }
  }
  {
#line 19
  v_ret = caml_alloc_tuple((mlsize_t )nptrs);
#line 20
  j = 0;
  }
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
#line 20
    if (! (j < nptrs)) {
#line 20
      goto while_break;
    }
    {
#line 21
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 21
      caml__temp_offset = (mlsize_t )j;
#line 21
      tmp___1 = caml_copy_string((char const   *)*(strings + j));
#line 21
      caml__temp_val = tmp___1;
#line 21
      caml_modify((value *)v_ret + caml__temp_offset, caml__temp_val);
      }
#line 21
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 20
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 23
  free((void *)strings);
  }
  {
#line 24
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 24
    caml__temp_result = v_ret;
#line 24
    caml_local_roots = caml__frame;
#line 24
    return (caml__temp_result);
#line 24
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 25
  return (0L);
}
}
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 66 "/usr/include/ifaddrs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getifaddrs)(struct ifaddrs **__ifap ) ;
#line 69
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeifaddrs)(struct ifaddrs *__ifa ) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/ioctl_siocgifconf.c"
value caml_extunix_ioctl_siocgifconf(value v_sock ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_sock ;
  int caml__dummy_v_sock  __attribute__((__unused__)) ;
  value lst ;
  value item ;
  value cons ;
  struct caml__roots_block caml__roots_lst ;
  int caml__dummy_lst  __attribute__((__unused__)) ;
  struct ifreq ifreqs[32] ;
  struct ifconf ifconf ;
  unsigned int i ;
  int tmp ;
  mlsize_t caml__temp_offset ;
  value caml__temp_val ;
  value tmp___0 ;
  mlsize_t caml__temp_offset___0 ;
  value caml__temp_val___0 ;
  char *tmp___1 ;
  value tmp___2 ;
  mlsize_t caml__temp_offset___1 ;
  value caml__temp_val___1 ;
  mlsize_t caml__temp_offset___2 ;
  value caml__temp_val___2 ;
  value caml__temp_result ;

  {
  {
#line 12
  caml__frame = caml_local_roots;
#line 12
  caml__roots_v_sock.next = caml_local_roots;
#line 12
  caml_local_roots = & caml__roots_v_sock;
#line 12
  caml__roots_v_sock.nitems = (intnat )1;
#line 12
  caml__roots_v_sock.ntables = (intnat )1;
#line 12
  caml__roots_v_sock.tables[0] = & v_sock;
#line 12
  caml__dummy_v_sock = 0;
#line 13
  lst = 1L;
#line 13
  item = 1L;
#line 13
  cons = 1L;
#line 13
  caml__roots_lst.next = caml_local_roots;
#line 13
  caml_local_roots = & caml__roots_lst;
#line 13
  caml__roots_lst.nitems = (intnat )1;
#line 13
  caml__roots_lst.ntables = (intnat )3;
#line 13
  caml__roots_lst.tables[0] = & lst;
#line 13
  caml__roots_lst.tables[1] = & item;
#line 13
  caml__roots_lst.tables[2] = & cons;
#line 13
  caml__dummy_lst = 0;
#line 19
  lst = 1L;
#line 21
  memset((void *)(& ifconf), 0, sizeof(ifconf));
#line 22
  ifconf.ifc_ifcu.ifcu_req = ifreqs;
#line 23
  ifconf.ifc_len = (int )sizeof(ifreqs);
#line 25
  tmp = ioctl((int )(v_sock >> 1), 35090UL, (char *)(& ifconf));
  }
#line 25
  if (0 != tmp) {
    {
#line 26
    uerror((char *)"ioctl(SIOCGIFCONF)", (value )0);
    }
  }
#line 28
  i = 0U;
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    if (! ((unsigned long )i < (unsigned long )ifconf.ifc_len / sizeof(struct ifreq ))) {
#line 28
      goto while_break;
    }
    {
#line 30
    cons = caml_alloc((mlsize_t )2, (tag_t )0);
#line 31
    item = caml_alloc((mlsize_t )2, (tag_t )0);
    }
    {
#line 32
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 32
      caml__temp_offset = (mlsize_t )0;
#line 32
      tmp___0 = caml_copy_string((char const   *)(ifreqs[i].ifr_ifrn.ifrn_name));
#line 32
      caml__temp_val = tmp___0;
#line 32
      caml_modify((value *)item + caml__temp_offset, caml__temp_val);
      }
#line 32
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 33
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 33
      caml__temp_offset___0 = (mlsize_t )1;
#line 33
      tmp___1 = inet_ntoa(((struct sockaddr_in *)(& ifreqs[i].ifr_ifru.ifru_addr))->sin_addr);
#line 33
      tmp___2 = caml_copy_string((char const   *)tmp___1);
#line 33
      caml__temp_val___0 = tmp___2;
#line 33
      caml_modify((value *)item + caml__temp_offset___0, caml__temp_val___0);
      }
#line 33
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 34
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 34
      caml__temp_offset___1 = (mlsize_t )0;
#line 34
      caml__temp_val___1 = item;
#line 34
      caml_modify((value *)cons + caml__temp_offset___1, caml__temp_val___1);
      }
#line 34
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 35
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 35
      caml__temp_offset___2 = (mlsize_t )1;
#line 35
      caml__temp_val___2 = lst;
#line 35
      caml_modify((value *)cons + caml__temp_offset___2, caml__temp_val___2);
      }
#line 35
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 36
    lst = cons;
#line 28
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 39
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 39
    caml__temp_result = lst;
#line 39
    caml_local_roots = caml__frame;
#line 39
    return (caml__temp_result);
#line 39
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 40
  return (0L);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/ioctl_siocgifconf.c"
value caml_extunix_getifaddrs(value v ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v ;
  int caml__dummy_v  __attribute__((__unused__)) ;
  value lst ;
  value item ;
  value cons ;
  struct caml__roots_block caml__roots_lst ;
  int caml__dummy_lst  __attribute__((__unused__)) ;
  struct ifaddrs *ifaddrs ;
  struct ifaddrs *iter ;
  int tmp ;
  mlsize_t caml__temp_offset ;
  value caml__temp_val ;
  value tmp___0 ;
  mlsize_t caml__temp_offset___0 ;
  value caml__temp_val___0 ;
  char *tmp___1 ;
  value tmp___2 ;
  mlsize_t caml__temp_offset___1 ;
  value caml__temp_val___1 ;
  mlsize_t caml__temp_offset___2 ;
  value caml__temp_val___2 ;
  value caml__temp_result ;

  {
  {
#line 48
  caml__frame = caml_local_roots;
#line 48
  caml__roots_v.next = caml_local_roots;
#line 48
  caml_local_roots = & caml__roots_v;
#line 48
  caml__roots_v.nitems = (intnat )1;
#line 48
  caml__roots_v.ntables = (intnat )1;
#line 48
  caml__roots_v.tables[0] = & v;
#line 48
  caml__dummy_v = 0;
#line 49
  lst = 1L;
#line 49
  item = 1L;
#line 49
  cons = 1L;
#line 49
  caml__roots_lst.next = caml_local_roots;
#line 49
  caml_local_roots = & caml__roots_lst;
#line 49
  caml__roots_lst.nitems = (intnat )1;
#line 49
  caml__roots_lst.ntables = (intnat )3;
#line 49
  caml__roots_lst.tables[0] = & lst;
#line 49
  caml__roots_lst.tables[1] = & item;
#line 49
  caml__roots_lst.tables[2] = & cons;
#line 49
  caml__dummy_lst = 0;
#line 51
  ifaddrs = (struct ifaddrs *)((void *)0);
#line 52
  iter = (struct ifaddrs *)((void *)0);
#line 54
  lst = 1L;
#line 56
  tmp = getifaddrs(& ifaddrs);
  }
#line 56
  if (0 != tmp) {
#line 58
    if (ifaddrs) {
      {
#line 58
      freeifaddrs(ifaddrs);
      }
    }
    {
#line 59
    uerror((char *)"getifaddrs", (value )0);
    }
  }
#line 62
  iter = ifaddrs;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! ((unsigned long )iter != (unsigned long )((void *)0))) {
#line 64
      goto while_break;
    }
#line 66
    if ((unsigned long )iter->ifa_addr != (unsigned long )((void *)0)) {
#line 66
      if ((int )(iter->ifa_addr)->sa_family == 2) {
        {
#line 68
        cons = caml_alloc((mlsize_t )2, (tag_t )0);
#line 69
        item = caml_alloc((mlsize_t )2, (tag_t )0);
        }
        {
#line 70
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 70
          caml__temp_offset = (mlsize_t )0;
#line 70
          tmp___0 = caml_copy_string((char const   *)iter->ifa_name);
#line 70
          caml__temp_val = tmp___0;
#line 70
          caml_modify((value *)item + caml__temp_offset, caml__temp_val);
          }
#line 70
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 71
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 71
          caml__temp_offset___0 = (mlsize_t )1;
#line 71
          tmp___1 = inet_ntoa(((struct sockaddr_in *)iter->ifa_addr)->sin_addr);
#line 71
          tmp___2 = caml_copy_string((char const   *)tmp___1);
#line 71
          caml__temp_val___0 = tmp___2;
#line 71
          caml_modify((value *)item + caml__temp_offset___0, caml__temp_val___0);
          }
#line 71
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 72
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 72
          caml__temp_offset___1 = (mlsize_t )0;
#line 72
          caml__temp_val___1 = item;
#line 72
          caml_modify((value *)cons + caml__temp_offset___1, caml__temp_val___1);
          }
#line 72
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 73
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 73
          caml__temp_offset___2 = (mlsize_t )1;
#line 73
          caml__temp_val___2 = lst;
#line 73
          caml_modify((value *)cons + caml__temp_offset___2, caml__temp_val___2);
          }
#line 73
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 74
        lst = cons;
      }
    }
#line 76
    iter = iter->ifa_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 79
  freeifaddrs(ifaddrs);
  }
  {
#line 80
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 80
    caml__temp_result = lst;
#line 80
    caml_local_roots = caml__frame;
#line 80
    return (caml__temp_result);
#line 80
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 81
  return (0L);
}
}
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/tty_ioctl.c"
value caml_extunix_crtscts(value mlfd ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_mlfd ;
  int caml__dummy_mlfd  __attribute__((__unused__)) ;
  struct termios t ;
  int r ;
  int fd ;
  value caml__temp_result ;

  {
  {
#line 13
  caml__frame = caml_local_roots;
#line 13
  caml__roots_mlfd.next = caml_local_roots;
#line 13
  caml_local_roots = & caml__roots_mlfd;
#line 13
  caml__roots_mlfd.nitems = (intnat )1;
#line 13
  caml__roots_mlfd.ntables = (intnat )1;
#line 13
  caml__roots_mlfd.tables[0] = & mlfd;
#line 13
  caml__dummy_mlfd = 0;
#line 15
  fd = (int )(mlfd >> 1);
#line 17
  r = tcgetattr(fd, & t);
  }
#line 18
  if (0 == r) {
    {
#line 19
    t.c_cflag |= 2147483648U;
#line 20
    r = tcsetattr(fd, 0, (struct termios  const  *)(& t));
    }
  }
#line 22
  if (0 != r) {
    {
#line 22
    uerror((char *)"crtscts", (value )0);
    }
  }
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23
    caml__temp_result = 1L;
#line 23
    caml_local_roots = caml__frame;
#line 23
    return (caml__temp_result);
#line 23
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 24
  return (0L);
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/tty_ioctl.c"
value caml_extunix_ioctl_TIOCMGET(value v_fd ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_fd ;
  int caml__dummy_v_fd  __attribute__((__unused__)) ;
  int arg ;
  int r ;
  int tmp ;
  value tmp___0 ;
  value caml__temp_result ;

  {
  {
#line 38
  caml__frame = caml_local_roots;
#line 38
  caml__roots_v_fd.next = caml_local_roots;
#line 38
  caml_local_roots = & caml__roots_v_fd;
#line 38
  caml__roots_v_fd.nitems = (intnat )1;
#line 38
  caml__roots_v_fd.ntables = (intnat )1;
#line 38
  caml__roots_v_fd.tables[0] = & v_fd;
#line 38
  caml__dummy_v_fd = 0;
#line 39
  arg = 0;
#line 40
  tmp = ioctl((int )(v_fd >> 1), 21525UL, & arg);
#line 40
  r = tmp;
  }
#line 41
  if (r < 0) {
    {
#line 41
    tmp___0 = caml_copy_string("TIOCMGET");
#line 41
    uerror((char *)"ioctl", tmp___0);
    }
  }
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    caml__temp_result = ((intnat )arg << 1) + 1L;
#line 42
    caml_local_roots = caml__frame;
#line 42
    return (caml__temp_result);
#line 42
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  return (0L);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/tty_ioctl.c"
value caml_extunix_ioctl_TIOCMSET(value v_fd , value v_arg ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_fd ;
  int caml__dummy_v_fd  __attribute__((__unused__)) ;
  int arg ;
  int r ;
  int tmp ;
  value tmp___0 ;
  value caml__temp_result ;

  {
  {
#line 45
  caml__frame = caml_local_roots;
#line 45
  caml__roots_v_fd.next = caml_local_roots;
#line 45
  caml_local_roots = & caml__roots_v_fd;
#line 45
  caml__roots_v_fd.nitems = (intnat )1;
#line 45
  caml__roots_v_fd.ntables = (intnat )2;
#line 45
  caml__roots_v_fd.tables[0] = & v_fd;
#line 45
  caml__roots_v_fd.tables[1] = & v_arg;
#line 45
  caml__dummy_v_fd = 0;
#line 45
  arg = (int )(v_arg >> 1);
#line 45
  tmp = ioctl((int )(v_fd >> 1), 21528UL, & arg);
#line 45
  r = tmp;
  }
#line 45
  if (r < 0) {
    {
#line 45
    tmp___0 = caml_copy_string("TIOCMSET");
#line 45
    uerror((char *)"ioctl", tmp___0);
    }
  }
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    caml__temp_result = 1L;
#line 45
    caml_local_roots = caml__frame;
#line 45
    return (caml__temp_result);
#line 45
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  return (0L);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/tty_ioctl.c"
value caml_extunix_ioctl_TIOCMBIC(value v_fd , value v_arg ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_fd ;
  int caml__dummy_v_fd  __attribute__((__unused__)) ;
  int arg ;
  int r ;
  int tmp ;
  value tmp___0 ;
  value caml__temp_result ;

  {
  {
#line 46
  caml__frame = caml_local_roots;
#line 46
  caml__roots_v_fd.next = caml_local_roots;
#line 46
  caml_local_roots = & caml__roots_v_fd;
#line 46
  caml__roots_v_fd.nitems = (intnat )1;
#line 46
  caml__roots_v_fd.ntables = (intnat )2;
#line 46
  caml__roots_v_fd.tables[0] = & v_fd;
#line 46
  caml__roots_v_fd.tables[1] = & v_arg;
#line 46
  caml__dummy_v_fd = 0;
#line 46
  arg = (int )(v_arg >> 1);
#line 46
  tmp = ioctl((int )(v_fd >> 1), 21527UL, & arg);
#line 46
  r = tmp;
  }
#line 46
  if (r < 0) {
    {
#line 46
    tmp___0 = caml_copy_string("TIOCMBIC");
#line 46
    uerror((char *)"ioctl", tmp___0);
    }
  }
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    caml__temp_result = 1L;
#line 46
    caml_local_roots = caml__frame;
#line 46
    return (caml__temp_result);
#line 46
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 46
  return (0L);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/tty_ioctl.c"
value caml_extunix_ioctl_TIOCMBIS(value v_fd , value v_arg ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v_fd ;
  int caml__dummy_v_fd  __attribute__((__unused__)) ;
  int arg ;
  int r ;
  int tmp ;
  value tmp___0 ;
  value caml__temp_result ;

  {
  {
#line 47
  caml__frame = caml_local_roots;
#line 47
  caml__roots_v_fd.next = caml_local_roots;
#line 47
  caml_local_roots = & caml__roots_v_fd;
#line 47
  caml__roots_v_fd.nitems = (intnat )1;
#line 47
  caml__roots_v_fd.ntables = (intnat )2;
#line 47
  caml__roots_v_fd.tables[0] = & v_fd;
#line 47
  caml__roots_v_fd.tables[1] = & v_arg;
#line 47
  caml__dummy_v_fd = 0;
#line 47
  arg = (int )(v_arg >> 1);
#line 47
  tmp = ioctl((int )(v_fd >> 1), 21526UL, & arg);
#line 47
  r = tmp;
  }
#line 47
  if (r < 0) {
    {
#line 47
    tmp___0 = caml_copy_string("TIOCMBIS");
#line 47
    uerror((char *)"ioctl", tmp___0);
    }
  }
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    caml__temp_result = 1L;
#line 47
    caml_local_roots = caml__frame;
#line 47
    return (caml__temp_result);
#line 47
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return (0L);
}
}
#line 557 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fexecve)(int __fd ,
                                                                                              char * const  *__argv ,
                                                                                              char * const  *__envp ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/fexecve.c"
static char **array_of_value(value v ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v ;
  int caml__dummy_v  __attribute__((__unused__)) ;
  char **arr ;
  mlsize_t size ;
  mlsize_t i ;
  void *tmp ;
  char **caml__temp_result ;

  {
  {
#line 12
  caml__frame = caml_local_roots;
#line 12
  caml__roots_v.next = caml_local_roots;
#line 12
  caml_local_roots = & caml__roots_v;
#line 12
  caml__roots_v.nitems = (intnat )1;
#line 12
  caml__roots_v.ntables = (intnat )1;
#line 12
  caml__roots_v.tables[0] = & v;
#line 12
  caml__dummy_v = 0;
#line 16
  size = *((header_t *)v + -1) >> 10;
#line 17
  tmp = caml_stat_alloc((size + 1UL) * sizeof(char *));
#line 17
  arr = (char **)tmp;
#line 18
  i = (mlsize_t )0;
  }
  {
#line 18
  while (1) {
    while_continue: /* CIL Label */ ;
#line 18
    if (! (i < size)) {
#line 18
      goto while_break;
    }
#line 19
    *(arr + i) = (char *)*((value *)v + i);
#line 18
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 20
  *(arr + size) = (char *)((void *)0);
  {
#line 22
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 22
    caml__temp_result = arr;
#line 22
    caml_local_roots = caml__frame;
#line 22
    return (caml__temp_result);
#line 22
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 23
  return ((char **)0);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/fexecve.c"
value caml_extunix_fexecve(value fd_val , value argv_val , value envp_val ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_fd_val ;
  int caml__dummy_fd_val  __attribute__((__unused__)) ;
  char **argv ;
  char **envp ;
  value caml__temp_result ;

  {
  {
#line 27
  caml__frame = caml_local_roots;
#line 27
  caml__roots_fd_val.next = caml_local_roots;
#line 27
  caml_local_roots = & caml__roots_fd_val;
#line 27
  caml__roots_fd_val.nitems = (intnat )1;
#line 27
  caml__roots_fd_val.ntables = (intnat )3;
#line 27
  caml__roots_fd_val.tables[0] = & fd_val;
#line 27
  caml__roots_fd_val.tables[1] = & argv_val;
#line 27
  caml__roots_fd_val.tables[2] = & envp_val;
#line 27
  caml__dummy_fd_val = 0;
#line 31
  argv = array_of_value(argv_val);
#line 32
  envp = array_of_value(envp_val);
#line 34
  fexecve((int )(fd_val >> 1), (char * const  *)argv, (char * const  *)envp);
#line 36
  caml_stat_free((void *)argv);
#line 37
  caml_stat_free((void *)envp);
#line 38
  uerror((char *)"fexecve", (value )0);
  }
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    caml__temp_result = 1L;
#line 40
    caml_local_roots = caml__frame;
#line 40
    return (caml__temp_result);
#line 40
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/fallocate.c"
static void caml_fallocate_error___0(int errcode ) 
{ 


  {
#line 97
  if (errcode != 0) {
    {
#line 99
    unix_error(errcode, (char *)"fallocate", (value )0);
    }
  }
#line 101
  return;
}
}
#line 20 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/common.c"
static int open_flag_table___0[13]  = 
#line 20 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/common.c"
  {      0,      1,      2,      2048, 
        1024,      64,      512,      128, 
        256,      4096,      1052672,      1052672, 
        0};
#line 7 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/mman.c"
static int mlockall_flags___0[2]  = {      1,      2};
#line 12 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/atfile.c"
static int file_kind_table___0[7]  = {      32768,      16384,      8192,      24576, 
        40960,      4096,      49152};
#line 32 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/atfile.c"
static int at_flags_table___0[5]  = {      512,      256,      512,      1024, 
        2048};
#line 36 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/atfile.c"
static value stat_aux___0(struct stat *buf ) 
{ 
  struct caml__roots_block *caml__frame ;
  value atime ;
  value mtime ;
  value ctime ;
  value offset ;
  value v ;
  struct caml__roots_block caml__roots_atime ;
  int caml__dummy_atime  __attribute__((__unused__)) ;
  value caml__temp_result ;

  {
  {
#line 38
  caml__frame = caml_local_roots;
#line 39
  atime = 1L;
#line 39
  mtime = 1L;
#line 39
  ctime = 1L;
#line 39
  offset = 1L;
#line 39
  v = 1L;
#line 39
  caml__roots_atime.next = caml_local_roots;
#line 39
  caml_local_roots = & caml__roots_atime;
#line 39
  caml__roots_atime.nitems = (intnat )1;
#line 39
  caml__roots_atime.ntables = (intnat )5;
#line 39
  caml__roots_atime.tables[0] = & atime;
#line 39
  caml__roots_atime.tables[1] = & mtime;
#line 39
  caml__roots_atime.tables[2] = & ctime;
#line 39
  caml__roots_atime.tables[3] = & offset;
#line 39
  caml__roots_atime.tables[4] = & v;
#line 39
  caml__dummy_atime = 0;
#line 41
  atime = caml_copy_double((double )buf->st_atim.tv_sec);
#line 42
  mtime = caml_copy_double((double )buf->st_mtim.tv_sec);
#line 43
  ctime = caml_copy_double((double )buf->st_ctim.tv_sec);
#line 44
  offset = (buf->st_size << 1) + 1L;
#line 45
  v = caml_alloc_small((mlsize_t )12, (tag_t )0);
#line 46
  *((value *)v + 0) = ((intnat )buf->st_dev << 1) + 1L;
#line 47
  *((value *)v + 1) = ((intnat )buf->st_ino << 1) + 1L;
#line 48
  *((value *)v + 2) = cst_to_constr((int )(buf->st_mode & 61440U), file_kind_table___0,
                                    (int )(sizeof(file_kind_table___0) / sizeof(int )),
                                    0);
#line 50
  *((value *)v + 3) = ((intnat )(buf->st_mode & 4095U) << 1) + 1L;
#line 51
  *((value *)v + 4) = ((intnat )buf->st_nlink << 1) + 1L;
#line 52
  *((value *)v + 5) = ((intnat )buf->st_uid << 1) + 1L;
#line 53
  *((value *)v + 6) = ((intnat )buf->st_gid << 1) + 1L;
#line 54
  *((value *)v + 7) = ((intnat )buf->st_rdev << 1) + 1L;
#line 55
  *((value *)v + 8) = offset;
#line 56
  *((value *)v + 9) = atime;
#line 57
  *((value *)v + 10) = mtime;
#line 58
  *((value *)v + 11) = ctime;
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    caml__temp_result = v;
#line 59
    caml_local_roots = caml__frame;
#line 59
    return (caml__temp_result);
#line 59
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  return (0L);
}
}
#line 19 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/fadvise.c"
static int caml_advises___0[6]  = {      0,      2,      1,      5, 
        3,      4};
#line 9 "/home/june/repo/benchmarks/collector/temp/ocaml-extunix-0.0.6/_build/src/fexecve.c"
static char **array_of_value___0(value v ) 
{ 
  struct caml__roots_block *caml__frame ;
  struct caml__roots_block caml__roots_v ;
  int caml__dummy_v  __attribute__((__unused__)) ;
  char **arr ;
  mlsize_t size ;
  mlsize_t i ;
  void *tmp ;
  char **caml__temp_result ;

  {
  {
#line 12
  caml__frame = caml_local_roots;
#line 12
  caml__roots_v.next = caml_local_roots;
#line 12
  caml_local_roots = & caml__roots_v;
#line 12
  caml__roots_v.nitems = (intnat )1;
#line 12
  caml__roots_v.ntables = (intnat )1;
#line 12
  caml__roots_v.tables[0] = & v;
#line 12
  caml__dummy_v = 0;
#line 16
  size = *((header_t *)v + -1) >> 10;
#line 17
  tmp = caml_stat_alloc((size + 1UL) * sizeof(char *));
#line 17
  arr = (char **)tmp;
#line 18
  i = (mlsize_t )0;
  }
  {
#line 18
  while (1) {
    while_continue: /* CIL Label */ ;
#line 18
    if (! (i < size)) {
#line 18
      goto while_break;
    }
#line 19
    *(arr + i) = (char *)*((value *)v + i);
#line 18
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 20
  *(arr + size) = (char *)((void *)0);
  {
#line 22
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 22
    caml__temp_result = arr;
#line 22
    caml_local_roots = caml__frame;
#line 22
    return (caml__temp_result);
#line 22
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 23
  return ((char **)0);
}
}
